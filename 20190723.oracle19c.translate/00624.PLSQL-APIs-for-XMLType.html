<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <meta name="abstract" content="There are several PL/SQL packages that provide APIs for XMLType."></meta>
      <meta name="description" content="There are several PL/SQL packages that provide APIs for XMLType."></meta>
      <title>XMLType的PL / SQL API</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Developer&#39;s Guide "></meta>
      <meta property="og:description" content="There are several PL/SQL packages that provide APIs for XMLType."></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Developer&#39;s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="xml-db-developers-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-03-30T12:32:42-07:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="2002, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96222-03"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="XMLType-APIs.html" title="Previous" type="text/html"></link>
      <link rel="next" href="PLSQL-package-DBMS_XMLSTORE.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="XML DB Developer&#39;s Guide"></meta>
    <meta name="dcterms.isVersionOf" content="ADXDB"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="XMLType-APIs.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="PLSQL-package-DBMS_XMLSTORE.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">开发人员指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="XMLType-APIs.html" property="item" typeof="WebPage"><span property="name">XMLType API</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">XMLType的PL / SQL API</li>
            </ol>
            <a id="GUID-2D5B2D47-9CFF-49D0-9BD8-114BBE48A289" name="GUID-2D5B2D47-9CFF-49D0-9BD8-114BBE48A289"></a><a id="ADXDB1100"></a>
            
            <h2 id="ADXDB-GUID-2D5B2D47-9CFF-49D0-9BD8-114BBE48A289" class="sect2"><span class="enumeration_chapter">11个</span>用于XMLType的PL / SQL API</h2>
         </header>
         <div class="ind">
            <div>
               <p>有几个PL / SQL包为<code class="codeph">XMLType</code>提供API。
               </p>
            </div>
            <div>
               <ul class="ullinks">
                  <li class="ulchildlink"><a href="PLSQL-APIs-for-XMLType.html#GUID-F0B8E95C-E73D-475E-B4E3-DB9D753DA274">XMLType的PL / SQL API概述</a><br><code class="codeph">XMLType</code>的PL / SQL应用程序接口（API）包括DOM API，解析器API和处理器API。</li>
                  <li class="ulchildlink"><a href="PLSQL-APIs-for-XMLType.html#GUID-C8B6BD89-F267-46C3-8656-99CFA052A198">用于XMLType的PL / SQL DOM API（DBMS_XMLDOM）</a><br><code class="codeph">XMLType</code>的PL / SQL DOM API， <code class="codeph">DBMS_XMLDOM</code>允许您使用DOM操作<code class="codeph">XMLType</code>实例。</li>
                  <li class="ulchildlink"><a href="PLSQL-APIs-for-XMLType.html#GUID-3EA684A3-2149-4550-924A-35CD5246ED90">XMLType的PL / SQL Parser API（DBMS_XMLPARSER）</a><br>用于<code class="codeph">XMLType</code>的PL / SQL Parser API（ <code class="codeph">DBMS_XMLPARSER</code> ）构建可由PL / SQL API访问的解析结果树。如果解析失败，则会引发错误。
                  </li>
                  <li class="ulchildlink"><a href="PLSQL-APIs-for-XMLType.html#GUID-0E3358AF-0819-4B17-AF0B-793E96DA5EB9">用于XMLType的PL / SQL XSLT处理器（DBMS_XSLPROCESSOR）</a><br>您可以使用PL / SQL包<code class="codeph">DBMS_XSLPROCESSOR</code>将一个XML文档转换为另一个XML文档，或将XML数据转换为HTML，PDF或其他格式。该包遍历文档的DOM树，并对其应用可扩展样式表语言转换（XSLT）语句以生成转换后的文档。
                  </li>
               </ul>
               <div class="familylinks">
                  <div class="parentlink">
                     <p><strong>父主题：</strong> <a href="XMLType-APIs.html#GUID-6209297F-DBE4-4F31-85F1-4083BF5BDE01" title="您可以使用Oracle XML DB XMLType PL / SQL，Java，C API和Oracle Data Provider for .NET（ODP.NET）来访问和操作XML数据。">XMLType API</a></p>
                  </div>
               </div>
            </div>
            <a id="ADXDB4870"></a><div class="props_rev_3"><a id="GUID-F0B8E95C-E73D-475E-B4E3-DB9D753DA274" name="GUID-F0B8E95C-E73D-475E-B4E3-DB9D753DA274"></a><h3 id="ADXDB-GUID-F0B8E95C-E73D-475E-B4E3-DB9D753DA274" class="sect3"><span class="enumeration_section">11.1</span> XMLType的PL / SQL API概述</h3>
               <div>
                  <p><code class="codeph">XMLType</code>的PL / SQL应用程序接口（API）包括DOM API，解析器API和处理器API。</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><code class="codeph">XMLType</code> PL / SQL文档对象模型（DOM）API（包<code class="codeph">DBMS_XMLDOM</code> ）：用于访问<code class="codeph">XMLType</code>对象。您可以访问基于XML架构的文档和基于非架构的文档。
                        </p>
                        <p><strong class="term">DOM</strong>是动态内存中XML文档的基于树的对象表示。它支持以编程方式访问其元素和属性。DOM对象及其接口是W3C推荐。它指定XML文档的文档对象模型，包括用于编程访问的API。DOM将解析的文档视为对象树。
                        </p>
                     </li>
                     <li>
                        <p>用于<code class="codeph">XMLType</code> PL / SQL XML Parser API（包<code class="codeph">DBMS_XMLPARSER</code> ）：用于创建DOM并访问XML文档的内容和结构。
                        </p>
                     </li>
                     <li>
                        <p>用于<code class="codeph">XMLType</code> PL / SQL XSLT处理器（包<code class="codeph">DBMS_XSLPROCESSOR</code> ）：用于使用XSLT将XML文档转换为其他格式。</p>
                     </li>
                  </ul>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="PLSQL-APIs-for-XMLType.html#GUID-CF14A19A-A284-4CA3-8103-8D7713CE8BDC">XMLType的PL / SQL API：功能</a><br>您可以使用PLType for <code class="codeph">XMLType</code>来创建<code class="codeph">XMLType</code>表，列和视图;从以不同字符集编码的数据构造<code class="codeph">XMLType</code>实例;并以各种方式访问和操作<code class="codeph">XMLType</code> 。
                     </li>
                     <li class="ulchildlink"><a href="PLSQL-APIs-for-XMLType.html#GUID-63032A9C-B4E2-4BB9-89E5-EBEEEF282C39">XMLType的PL / SQL API：参考</a><br>描述了<code class="codeph">XMLType</code>的PL / SQL应用程序编程接口（API）。
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="PLSQL-APIs-for-XMLType.html#GUID-2D5B2D47-9CFF-49D0-9BD8-114BBE48A289" title="有几个PL / SQL包为XMLType提供API。">XMLType的PL / SQL API</a></p>
                     </div>
                  </div>
               </div>
               <a id="ADXDB4871"></a><div class="props_rev_3"><a id="GUID-CF14A19A-A284-4CA3-8103-8D7713CE8BDC" name="GUID-CF14A19A-A284-4CA3-8103-8D7713CE8BDC"></a><h4 id="ADXDB-GUID-CF14A19A-A284-4CA3-8103-8D7713CE8BDC" class="sect4"><span class="enumeration_section">11.1.1</span> XMLType的PL / SQL API：功能</h4>
                  <div>
                     <p>您可以使用PLType for <code class="codeph">XMLType</code>来创建<code class="codeph">XMLType</code>表，列和视图;从以不同字符集编码的数据构造<code class="codeph">XMLType</code>实例;并以各种方式访问和操作<code class="codeph">XMLType</code> 。
                     </p>
                     <div class="section"></div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="PLSQL-APIs-for-XMLType.html#GUID-CC88AF77-83DA-4AA5-B7B9-AC7C67DAFA74">XML数据的延迟加载（惰性表现）</a><br>延迟XML加载仅在请求时加载数据行，从而增强涉及大型XML文档和许多并发用户的应用程序的可伸缩性。
                        </li>
                        <li class="ulchildlink"><a href="PLSQL-APIs-for-XMLType.html#GUID-57B7D074-7870-4CE3-8EDA-515485742595">XMLType数据类型支持XML模式</a><br>SQL数据类型<code class="codeph">XMLType</code>支持XML Schema。
                        </li>
                        <li class="ulchildlink"><a href="PLSQL-APIs-for-XMLType.html#GUID-01ACFBC7-9C51-4D27-8CC9-5377C8426AD2">XMLType支持不同字符集中的数据</a><br>您可以使用PL / SQL从任何Oracle支持的字符集中编码的数据创建<code class="codeph">XMLType</code>实例。为此，您使用PL / SQL <code class="codeph">XMLType</code>构造函数或<code class="codeph">XMLType</code>方法<code class="codeph">createXML()</code> 。
                        </li>
                     </ul>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="intro-to-XML-DB.html#GUID-E5AC647D-E48C-4D2F-A528-D03CD911ED3A" title="Oracle XML DB提供标准数据库功能，如事务控制，数据完整性，复制，可靠性，可用性，安全性和可伸缩性，同时还允许以XML为中心的方式对XML文档进行有效的索引，查询，更新和搜索。">Oracle XML DB功能</a></li>
                           <li><a href="query-and-update-XML.html#GUID-01C75289-804F-4BAA-AE7C-DFA73198581E" title="应用程序有许多方法可以查询和更新Oracle数据库中的XML数据，包括基于XML模式和非基于模式的数据。">查询和更新XML数据</a></li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="PLSQL-APIs-for-XMLType.html#GUID-F0B8E95C-E73D-475E-B4E3-DB9D753DA274" title="XMLType的PL / SQL应用程序接口（API）包括DOM API，解析器API和处理器API。">XMLType的PL / SQL API概述</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="ADXDB4872"></a><div class="props_rev_3"><a id="GUID-CC88AF77-83DA-4AA5-B7B9-AC7C67DAFA74" name="GUID-CC88AF77-83DA-4AA5-B7B9-AC7C67DAFA74"></a><h5 id="ADXDB-GUID-CC88AF77-83DA-4AA5-B7B9-AC7C67DAFA74" class="sect5"><span class="enumeration_section">11.1.1.1</span> XML数据的延迟加载（惰性表现）</h5>
                     <div>
                        <p>延迟XML加载仅在请求时加载数据行，从而增强涉及大型XML文档和许多并发用户的应用程序的可伸缩性。</p>
                        <p>因为<code class="codeph">XMLType</code>提供动态内存或虚拟文档对象模型（DOM），所以它可以使用称为<span class="bold">延迟XML加载</span>的内存保存过程，有时也称为<span class="bold">惰性表现形式</span> 。此过程通过仅在请求时加载数据行来优化内存使用。如果内存使用量过大，它会丢弃文档中先前引用的部分。延迟XML加载支持高度可伸缩的应用程序，其中有许多并发用户需要访问大型XML文档。
                        </p>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="PLSQL-APIs-for-XMLType.html#GUID-CF14A19A-A284-4CA3-8103-8D7713CE8BDC" title="您可以使用PLType for XMLType来创建XMLType表，列和视图;从以不同字符集编码的数据构造XMLType实例;并以各种方式访问和操作XMLType。">XMLType的PL / SQL API：功能</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="ADXDB4873"></a><div class="props_rev_3"><a id="GUID-57B7D074-7870-4CE3-8EDA-515485742595" name="GUID-57B7D074-7870-4CE3-8EDA-515485742595"></a><h5 id="ADXDB-GUID-57B7D074-7870-4CE3-8EDA-515485742595" class="sect5"><span class="enumeration_section">11.1.1.2</span> XMLType数据类型支持XML模式</h5>
                     <div>
                        <p>SQL数据类型<code class="codeph">XMLType</code>支持XML Schema。
                        </p>
                        <p>您可以创建XML模式，并使用从XML到对象关系存储的映射来注释它。要利用PL / SQL DOM API，首先要创建一个XML模式并进行注册。然后，在创建<code class="codeph">XMLType</code>表和列时，可以指定这些表符合已注册的XML模式。
                        </p>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="PLSQL-APIs-for-XMLType.html#GUID-CF14A19A-A284-4CA3-8103-8D7713CE8BDC" title="您可以使用PLType for XMLType来创建XMLType表，列和视图;从以不同字符集编码的数据构造XMLType实例;并以各种方式访问和操作XMLType。">XMLType的PL / SQL API：功能</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="ADXDB4874"></a><div class="props_rev_3"><a id="GUID-01ACFBC7-9C51-4D27-8CC9-5377C8426AD2" name="GUID-01ACFBC7-9C51-4D27-8CC9-5377C8426AD2"></a><h5 id="ADXDB-GUID-01ACFBC7-9C51-4D27-8CC9-5377C8426AD2" class="sect5"><span class="enumeration_section">11.1.1.3</span> XMLType支持不同字符集中的数据</h5>
                     <div>
                        <p>您可以使用PL / SQL从任何Oracle支持的字符集中编码的数据创建<code class="codeph">XMLType</code>实例。为此，您使用PL / SQL <code class="codeph">XMLType</code>构造函数或<code class="codeph">XMLType</code>方法<code class="codeph">createXML()</code> 。
                        </p>
                        <p>必须使用数据类型<code class="codeph">BFILE</code>或<code class="codeph">BLOB</code>提供源XML数据。数据的编码通过参数<code class="codeph">csid</code>指定。当此参数为零（ <code class="codeph">0</code> ）时，源数据的编码由XML prolog确定，如XML 1.0 Reference的附录F中所指定。
                        </p>
                        <div class="infoboxnote" id="GUID-01ACFBC7-9C51-4D27-8CC9-5377C8426AD2__GUID-18C5E9C4-EF02-43D3-8D53-7907613E821F">
                           <p class="notep1">警告：</p>
                           <p> <span class="italic">AL32UTF8</span>是适用于<code class="codeph">XMLType</code>数据的Oracle数据库字符集。它等同于IANA注册的标准UTF-8编码，该编码支持所有有效的XML字符。
                           </p>
                           <p>不要将Oracle数据库数据库字符集UTF8（无连字符）与数据库字符集AL32UTF8或字符<span class="italic">编码</span> UTF-8混淆。数据库字符集UTF8已被AL32UTF8 <span class="italic">取代</span> 。<span class="italic">不要</span>使用UTF8 XML数据。字符集UTF8仅支持Unicode 3.1及更早版本。它不支持所有有效的XML字符。AL32UTF8没有这样的限制。
                           </p>
                           <p>对XML数据使用数据库字符集UTF8可能会<span class="italic">阻止系统或对安全性产生负面影响</span> 。如果数据库字符集不支持的字符出现在输入文档元素名称中，则替换字符（通常为“ <code class="codeph">?</code>“）代替它。这会终止解析并引发异常。它可能导致无法恢复的错误。
                           </p>
                        </div>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="PLSQL-APIs-for-XMLType.html#GUID-CF14A19A-A284-4CA3-8103-8D7713CE8BDC" title="您可以使用PLType for XMLType来创建XMLType表，列和视图;从以不同字符集编码的数据构造XMLType实例;并以各种方式访问和操作XMLType。">XMLType的PL / SQL API：功能</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="ADXDB3955"></a><a id="ADXDB0110"></a><div class="props_rev_3"><a id="GUID-63032A9C-B4E2-4BB9-89E5-EBEEEF282C39" name="GUID-63032A9C-B4E2-4BB9-89E5-EBEEEF282C39"></a><h4 id="ADXDB-GUID-63032A9C-B4E2-4BB9-89E5-EBEEEF282C39" class="sect4"><span class="enumeration_section">11.1.2</span> XMLType的PL / SQL API：参考</h4>
                  <div>
                     <p>描述了<code class="codeph">XMLType</code>的PL / SQL应用程序编程接口（API）。
                     </p>
                     <div class="section">
                        <p><a href="PLSQL-APIs-for-XMLType.html#GUID-63032A9C-B4E2-4BB9-89E5-EBEEEF282C39__CHDFJDFJ" title="此表列出了可用于操作XML数据的PL / SQL API的参考文档。">表11-1</a>列出了可用于操作XML数据的PL / SQL API的参考文档。PL / SQL API的主要参考是<a href="../arpls/index.html" target="_blank"><span><cite>Oracle Database PL / SQL包和类型参考</cite></span></a> 。
                        </p>
                        <div class="infoboxnotealso" id="GUID-63032A9C-B4E2-4BB9-89E5-EBEEEF282C39__GUID-E55DD7EB-69C5-45AA-80D1-A5CB97191BF4">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>有关适用于<a href="../jaxml/index.html" target="_blank"><span><cite>XML的Java API</cite></span></a>的信息，请参阅<a href="../jaxml/index.html" target="_blank"><span><cite>Oracle数据库XML Java API参考</cite></span></a></p>
                              </li>
                              <li>
                                 <p>有关适用于<a href="../caxml/index.html" target="_blank"><span><cite>XML的C API</cite></span></a>的信息，请参阅<a href="../caxml/index.html" target="_blank"><span><cite>Oracle数据库XML C API参考</cite></span></a></p>
                              </li>
                              <li>
                                 <p><a href="../cpxml/index.html" target="_blank"><span><cite>有关XML的C ++ API</cite></span></a>的信息，请参阅<a href="../cpxml/index.html" target="_blank"><span><cite>Oracle Database XML C ++ API参考</cite></span></a></p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="tblformalwide" id="GUID-63032A9C-B4E2-4BB9-89E5-EBEEEF282C39__CHDFJDFJ">
                        <p class="titleintable">表11-1与XML相关的PL / SQL API</p>
                        <table cellpadding="4" cellspacing="0" class="FormalWide" title="与XML相关的PL / SQL API" width="100%" border="1" summary="This table lists the reference documentation for the PL/SQL APIs that you can use to manipulate XML data. " frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="31%" id="d66991e616">API</th>
                                 <th align="left" valign="bottom" width="33%" id="d66991e619">文档</th>
                                 <th align="left" valign="bottom" width="37%" id="d66991e622">描述</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d66991e627" headers="d66991e616 ">
                                    <p><code class="codeph">的XMLType</code></p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d66991e627 d66991e619 ">
                                    <p><a href="../arpls/XMLTYPE.html#ARPLS369" target="_blank"><span><cite>Oracle Database PL / SQL包和类型参考</cite></span> ，“XMLType”一章</a></p>
                                 </td>
                                 <td align="left" valign="top" width="37%" headers="d66991e627 d66991e622 ">
                                    <p>对<code class="codeph">XMLType</code>数据执行XML操作的PL / SQL API  - 验证，转换。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d66991e646" headers="d66991e616 ">
                                    <p>数据库URI类型</p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d66991e646 d66991e619 ">
                                    <p><a href="../arpls/Database-URI-TYPEs.html#ARPLS800" target="_blank"><span><cite>Oracle Database PL / SQL包和类型参考</cite></span> ，“数据库URI类型”一章</a></p>
                                 </td>
                                 <td align="left" valign="top" width="37%" headers="d66991e646 d66991e622 ">
                                    <p>用于各种URI类型的函数。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d66991e661" headers="d66991e616 ">
                                    <p><code class="codeph">DBMS_METADATA</code></p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d66991e661 d66991e619 ">
                                    <p><a href="../arpls/DBMS_METADATA.html#ARPLS026" target="_blank"><span><cite>Oracle Database PL / SQL包和类型参考</cite></span> ，“DBMS_METADATA”一章</a></p>
                                 </td>
                                 <td align="left" valign="top" width="37%" headers="d66991e661 d66991e622 ">
                                    <p>PL / SQL API，用于从XML数据库字典中检索元数据，或检索创建DDL并提交XML以重新创建关联对象。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d66991e677" headers="d66991e616 ">
                                    <p><code class="codeph">DBMS_RESCONFIG</code></p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d66991e677 d66991e619 ">
                                    <p><a href="../arpls/DBMS_RESCONFIG.html#ARPLS199" target="_blank"><span><cite>Oracle Database PL / SQL包和类型参考</cite></span> ，“DBMS_RESCONFIG”一章</a></p>
                                 </td>
                                 <td align="left" valign="top" width="37%" headers="d66991e677 d66991e622 ">
                                    <p>PL / SQL API，用于在资源配置列表上运行，以及检索资源的侦听器信息。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d66991e693" headers="d66991e616 ">
                                    <p><code class="codeph">DBMS_XDB_ADMIN</code></p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d66991e693 d66991e619 ">
                                    <p><a href="../arpls/DBMS_XDB_ADMIN.html#ARPLS214" target="_blank"><span><cite>Oracle Database PL / SQL包和类型参考</cite></span> ，“DBMS_XDB_ADMIN”一章</a></p>
                                 </td>
                                 <td align="left" valign="top" width="37%" headers="d66991e693 d66991e622 ">
                                    <p>PL / SQL API，用于由数据库管理员管理Oracle XML DB存储库。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d66991e709" headers="d66991e616 ">
                                    <p><code class="codeph">DBMS_XDB_CONFIG</code></p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d66991e709 d66991e619 ">
                                    <p><a href="../arpls/DBMS_XDB_CONFIG.html#ARPLS73564" target="_blank"><span><cite>Oracle Database PL / SQL包和类型参考</cite></span> ，“DBMS_XDB_CONFIG”一章</a></p>
                                 </td>
                                 <td align="left" valign="top" width="37%" headers="d66991e709 d66991e622 ">
                                    <p>用于管理Oracle XML DB配置会话的PL / SQL API。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d66991e725" headers="d66991e616 ">
                                    <p><code class="codeph">DBMS_XDB_CONSTANTS</code></p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d66991e725 d66991e619 ">
                                    <p><a href="../arpls/DBMS_XDB_CONSTANTS.html#ARPLS73572" target="_blank"><span><cite>Oracle Database PL / SQL包和类型参考</cite></span> ，“DBMS_XDB_CONSTANTS”一章</a></p>
                                 </td>
                                 <td align="left" valign="top" width="37%" headers="d66991e725 d66991e622 ">
                                    <p>用于Oracle XML DB的PL / SQL常量</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d66991e741" headers="d66991e616 ">
                                    <p><code class="codeph">DBMS_XDB_REPOS</code></p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d66991e741 d66991e619 ">
                                    <p><a href="../arpls/DBMS_XDB_REPOS.html#ARPLS74188" target="_blank"><span><cite>Oracle Database PL / SQL包和类型参考</cite></span> ，“DBMS_XDB_REPOS”一章</a></p>
                                 </td>
                                 <td align="left" valign="top" width="37%" headers="d66991e741 d66991e622 ">
                                    <p>PL / SQL API，供应用程序开发人员使用Oracle XML DB Repository。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d66991e757" headers="d66991e616 ">
                                    <p><code class="codeph">DBMS_XDBRESOURCE</code></p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d66991e757 d66991e619 ">
                                    <p><a href="../arpls/DBMS_XDBRESOURCE.html#ARPLS230" target="_blank"><span><cite>Oracle Database PL / SQL包和类型参考</cite></span> ，“DBMS_XDBRESOURCE”一章</a></p>
                                 </td>
                                 <td align="left" valign="top" width="37%" headers="d66991e757 d66991e622 ">
                                    <p>用于操作存储库资源元数据和内容的PL / SQL API。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d66991e773" headers="d66991e616 ">
                                    <p><code class="codeph">DBMS_XDBT</code></p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d66991e773 d66991e619 ">
                                    <p><a href="../arpls/DBMS_XDBT.html#ARPLS372" target="_blank"><span><cite>Oracle Database PL / SQL包和类型参考</cite></span> ，“DBMS_XDBT”一章</a></p>
                                 </td>
                                 <td align="left" valign="top" width="37%" headers="d66991e773 d66991e622 ">
                                    <p>PL / SQL API，用于在存储库资源上创建文本索引。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d66991e789" headers="d66991e616 ">
                                    <p><code class="codeph">DBMS_XDB_VERSION</code></p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d66991e789 d66991e619 ">
                                    <p><a href="../arpls/DBMS_XDB_VERSION.html#ARPLS373" target="_blank"><span><cite>Oracle Database PL / SQL包和类型参考</cite></span> ，“DBMS_XDB_VERSION”一章</a></p>
                                 </td>
                                 <td align="left" valign="top" width="37%" headers="d66991e789 d66991e622 ">
                                    <p>用于存储库资源的版本管理的PL / SQL API。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d66991e806" headers="d66991e616 ">
                                    <p><code class="codeph">DBMS_XDBZ</code></p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d66991e806 d66991e619 ">
                                    <p><a href="../arpls/DBMS_XDBZ.html#ARPLS805" target="_blank"><span><cite>Oracle Database PL / SQL包和类型参考</cite></span> ，“DBMS_XDBZ”一章</a></p>
                                 </td>
                                 <td align="left" valign="top" width="37%" headers="d66991e806 d66991e622 ">
                                    <p>Oracle XML DB Repository基于ACL的安全性。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d66991e822" headers="d66991e616 ">
                                    <p><code class="codeph">DBMS_XEVENT</code></p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d66991e822 d66991e619 ">
                                    <p><a href="../arpls/DBMS_XEVENT.html#ARPLS210" target="_blank"><span><cite>Oracle Database PL / SQL包和类型参考</cite></span> ，“DBMS_XEVENT”一章</a></p>
                                 </td>
                                 <td align="left" valign="top" width="37%" headers="d66991e822 d66991e622 ">
                                    <p>PL / SQL API提供与事件相关的类型和支持接口..</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d66991e838" headers="d66991e616 ">
                                    <p><code class="codeph">DBMS_XMLDOM</code></p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d66991e838 d66991e619 ">
                                    <p><a href="../arpls/DBMS_XMLDOM.html#ARPLS399" target="_blank"><span><cite>Oracle Database PL / SQL包和类型参考</cite></span> ，“DBMS_XMLDOM”一章</a></p>
                                 </td>
                                 <td align="left" valign="top" width="37%" headers="d66991e838 d66991e622 ">
                                    <p>用于<code class="codeph">XMLType</code>的DOM API的PL / SQL实现。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d66991e857" headers="d66991e616 ">
                                    <p><code class="codeph">DBMS_XMLGEN</code></p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d66991e857 d66991e619 ">
                                    <p><a href="../arpls/DBMS_XMLGEN.html#ARPLS374" target="_blank"><span><cite>Oracle Database PL / SQL包和类型参考</cite></span> ，“DBMS_XMLGEN”一章</a></p>
                                 </td>
                                 <td align="left" valign="top" width="37%" headers="d66991e857 d66991e622 ">
                                    <p>用于将SQL查询结果转换为规范XML格式的PL / SQL API。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d66991e873" headers="d66991e616 ">
                                    <p><code class="codeph">DBMS_XMLINDEX</code></p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d66991e873 d66991e619 ">
                                    <p><a href="../arpls/DBMS_XMLINDEX.html#ARPLS212" target="_blank"><span><cite>Oracle Database PL / SQL包和类型参考</cite></span> ，“DBMS_XMLINDEX”一章</a></p>
                                 </td>
                                 <td align="left" valign="top" width="37%" headers="d66991e873 d66991e622 ">
                                    <p>用于<code class="codeph">XMLIndex</code> PL / SQL API。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d66991e892" headers="d66991e616 ">
                                    <p><code class="codeph">DBMS_XMLPARSER</code></p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d66991e892 d66991e619 ">
                                    <p><a href="../arpls/DBMS_XMLPARSER.html#ARPLS375" target="_blank"><span><cite>Oracle Database PL / SQL包和类型参考</cite></span> ，“DBMS_XMLPARSER”一章</a></p>
                                 </td>
                                 <td align="left" valign="top" width="37%" headers="d66991e892 d66991e622 ">
                                    <p>用于<code class="codeph">XMLType</code>的DOM Parser API的PL / SQL实现。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d66991e911" headers="d66991e616 ">
                                    <p><code class="codeph">DBMS_XMLSCHEMA</code></p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d66991e911 d66991e619 ">
                                    <p><a href="../arpls/DBMS_XMLSCHEMA.html#ARPLS377" target="_blank"><span><cite>Oracle Database PL / SQL包和类型参考</cite></span> ，“DBMS_XMLSCHEMA”一章</a></p>
                                 </td>
                                 <td align="left" valign="top" width="37%" headers="d66991e911 d66991e622 ">
                                    <p>用于管理Oracle数据库中的XML模式的PL / SQL API  - 模式注册，删除。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d66991e927" headers="d66991e616 ">
                                    <p><code class="codeph">DBMS_XMLSCHEMA_ANNOTATE</code></p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d66991e927 d66991e619 ">
                                    <p><a href="../arpls/DBMS_XMLSCHEMA_ANNOTATE.html#ARPLS73580" target="_blank"><span><cite>Oracle Database PL / SQL包和类型参考</cite></span></a> ，“DBMS_XMLSCHEMA_ANNOTATE”一章</p>
                                 </td>
                                 <td align="left" valign="top" width="37%" headers="d66991e927 d66991e622 ">
                                    <p>PL / SQL API，用于添加和管理特定于Oracle的XML Schema注释。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d66991e943" headers="d66991e616 ">
                                    <p><code class="codeph">DBMS_XMLSTORAGE_MANAGE</code></p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d66991e943 d66991e619 ">
                                    <p><a href="../arpls/DBMS_XMLSTORAGE_MANAGE.html#ARPLS73588" target="_blank"><span><cite>Oracle Database PL / SQL包和类型参考</cite></span></a> ，“DBMS_XMLSTORAGE_MANAGE”一章</p>
                                 </td>
                                 <td align="left" valign="top" width="37%" headers="d66991e943 d66991e622 ">
                                    <p>PL /。SQL API在XML模式注册后管理和修改XML数据的存储。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d66991e959" headers="d66991e616 ">
                                    <p><code class="codeph">DBMS_XMLSTORE</code></p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d66991e959 d66991e619 ">
                                    <p><a href="../arpls/DBMS_XMLSTORE.html#ARPLS801" target="_blank"><span><cite>Oracle Database PL / SQL包和类型参考</cite></span> ，“DBMS_XMLSTORE”一章</a></p>
                                 </td>
                                 <td align="left" valign="top" width="37%" headers="d66991e959 d66991e622 ">
                                    <p>PL / SQL API，用于在关系表中存储XML数据。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d66991e975" headers="d66991e616 ">
                                    <p><code class="codeph">DBMS_XSLPROCESSOR</code></p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d66991e975 d66991e619 ">
                                    <p><a href="../arpls/DBMS_XSLPROCESSOR.html#ARPLS379" target="_blank"><span><cite>Oracle Database PL / SQL包和类型参考</cite></span> ，“DBMS_XSLPROCESSOR”一章</a></p>
                                 </td>
                                 <td align="left" valign="top" width="37%" headers="d66991e975 d66991e622 ">
                                    <p>XSLT处理器的PL / SQL实现。</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="PLSQL-APIs-for-XMLType.html#GUID-F0B8E95C-E73D-475E-B4E3-DB9D753DA274" title="XMLType的PL / SQL应用程序接口（API）包括DOM API，解析器API和处理器API。">XMLType的PL / SQL API概述</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div><a id="ADXDB4875"></a><div class="props_rev_3"><a id="GUID-C8B6BD89-F267-46C3-8656-99CFA052A198" name="GUID-C8B6BD89-F267-46C3-8656-99CFA052A198"></a><h3 id="ADXDB-GUID-C8B6BD89-F267-46C3-8656-99CFA052A198" class="sect3"><span class="enumeration_section">11.2</span> XMLType的PL / SQL DOM API（DBMS_XMLDOM）</h3>
               <div>
                  <p><code class="codeph">XMLType</code>的PL / SQL DOM API， <code class="codeph">DBMS_XMLDOM</code>允许您使用DOM操作<code class="codeph">XMLType</code>实例。</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="PLSQL-APIs-for-XMLType.html#GUID-F1FAD45D-0C4D-4037-9676-F126EAAB2F87">W3C文档对象模型（DOM）建议概述</a><br>万维网联盟（W3C）推荐的文档对象模型（DOM）是用于访问XML文档结构的通用API。
                     </li>
                     <li class="ulchildlink"><a href="PLSQL-APIs-for-XMLType.html#GUID-629DC11A-283C-4A89-AB96-DE142E5FF34B">用于XMLType的PL / SQL DOM API（DBMS_XMLDOM）：功能</a><br>Oracle XML DB扩展了Oracle数据库XML开发平台，超越了SQL支持，用于存储和检索XML数据。它允许您使用PL / SQL，Java和C中的DOM操作<code class="codeph">XMLType</code>实例。</li>
                     <li class="ulchildlink"><a href="PLSQL-APIs-for-XMLType.html#GUID-1395CFCB-6CDC-4FC6-9AA3-81443805E0C4">使用Oracle XML Developer Kit和Oracle XML DB进行应用程序设计</a><br>在基于Oracle XML DB构建应用程序时，您不需要Oracle XML Developer's Kit（XDK）提供的其他组件。但是，您可以将XDK组件与Oracle XML DB一起使用，以部署端到端运行的一整套支持XML的应用程序。
                     </li>
                     <li class="ulchildlink"><a href="PLSQL-APIs-for-XMLType.html#GUID-0DAAFA6D-6EDD-465B-999A-D9011FA46230">准备XML数据以将PL / SQL DOM API用于XMLType</a><br>创建XML模式，对其进行注释以将XML映射到SQL对象，并注册XML模式。
                     </li>
                     <li class="ulchildlink"><a href="PLSQL-APIs-for-XMLType.html#GUID-92017A80-EA34-4ED4-8B8A-EB222D404867">XML模式类型映射到SQL对象类型</a><br>必须先向Oracle XML DB注册XML模式，然后才能由XML文档引用它。注册XML模式时，它声明的元素和属性将映射到数据库中相应SQL对象类型的属性。
                     </li>
                     <li class="ulchildlink"><a href="PLSQL-APIs-for-XMLType.html#GUID-10C47D9D-A6CD-4E37-B9D8-9E0B75ACADB2">使用XMLType视图将现有数据包装为XML</a><br>要使现有的关系数据和对象关系数据可用于XML应用程序，可以基于它创建<code class="codeph">XMLType</code>视图。然后，您可以使用PL / SQL DOM API访问生成的XML数据。</li>
                     <li class="ulchildlink"><a href="PLSQL-APIs-for-XMLType.html#GUID-7E32FE20-2471-4FA2-BF90-3036E4A73991">Oracle XML DB支持的DBMS_XMLDOM方法</a><br>Oracle XML DB支持所有<code class="codeph">DBMS_XMLDOM</code>方法，但有一些例外。
                     </li>
                     <li class="ulchildlink"><a href="PLSQL-APIs-for-XMLType.html#GUID-33EBF3B7-B804-4A2B-A4EF-0F40FFC742F6">用于XMLType的PL / SQL DOM API：节点类型</a><br>DOM指定XML文档中的元素用于创建基于对象的树结构的方式。它定义和公开接口以管理和使用存储在XML文档中的对象。DOM支持在不同系统中存储文档。
                     </li>
                     <li class="ulchildlink"><a href="PLSQL-APIs-for-XMLType.html#GUID-DD35C504-C429-49AC-A6A7-3001BA96C1F5">PL / SQL函数NEWDOMDOCUMENT和DOMDOCUMENT节点</a><br>PL / SQL函数<code class="codeph">newDOMDocument</code>在给定<code class="codeph">XMLType</code>值的<code class="codeph">newDOMDocument</code>构造DOM文档句柄。生成的句柄是<code class="codeph">DOMDocument</code>类型。
                     </li>
                     <li class="ulchildlink"><a href="PLSQL-APIs-for-XMLType.html#GUID-11900518-CC1D-4344-9ABE-CE3F67D8C71F">DOM NodeList和NamedNodeMap对象</a><br>当您更改<code class="codeph">DOMDocument</code>实例下的文档结构时，更改将反映在所有相关的<code class="codeph">NodeList</code>和<code class="codeph">NamedNodeMap</code>对象中。
                     </li>
                     <li class="ulchildlink"><a href="PLSQL-APIs-for-XMLType.html#GUID-378E17DE-EE95-4D4B-96B3-8F181B235CFD">使用PL / SQL DOM API for XMLType（DBMS_XMLDOM）概述</a><br>使用PL / SQL包<code class="codeph">DBMS_XMLDOM</code>通常涉及创建DOM文档，遍历或扩展DOM树，以及创建和操作节点。
                     </li>
                     <li class="ulchildlink"><a href="PLSQL-APIs-for-XMLType.html#GUID-4B7856FD-9104-497C-81F1-0B3C3F7DE81F">用于XMLType的PL / SQL DOM API  - 示例</a><br>提供了使用PL / SQL DOM API for <code class="codeph">XMLType</code>示例。
                     </li>
                     <li class="ulchildlink"><a href="PLSQL-APIs-for-XMLType.html#GUID-27F60B86-33DC-4E4B-B870-DDCBCF7819F6">使用DBMS_XMLDOM进行大型节点处理</a><br>Oracle XML DB提供了抽象流和流操作方法，可用于处理大于64 K字节的XML节点。
                     </li>
                     <li class="ulchildlink"><a href="PLSQL-APIs-for-XMLType.html#GUID-F9CC00ED-132E-451F-94D4-953161F87482">用于大型节点处理的Get-Push模型</a><br>在此模型中，使用处于推送模式的解析器检索DOM节点的值。Oracle XML DB将节点数据写入解析器读取的输出流。
                     </li>
                     <li class="ulchildlink"><a href="PLSQL-APIs-for-XMLType.html#GUID-44A8FF6E-4CE5-4FEA-AC55-AAEACE8CCC57">用于大型节点处理的Get-Pull模型</a><br>在此模型中，使用处于拉模式的解析器检索DOM节点的值。Oracle XML DB从解析器编写的输入流中读取事件数据。
                     </li>
                     <li class="ulchildlink"><a href="PLSQL-APIs-for-XMLType.html#GUID-43443083-4ED7-4E62-A450-E60CE2524AD7">用于大型节点处理的Set-Pull模型</a><br>在此模型中，使用处于拉模式的解析器设置DOM节点的值。Oracle XML DB从解析器编写的输入流中读取事件数据。
                     </li>
                     <li class="ulchildlink"><a href="PLSQL-APIs-for-XMLType.html#GUID-DCBCC32B-3529-49A0-BF23-1BFF9062367D">用于大型节点处理的Set-Push模型</a><br>在此模型中，使用处于推送模式的解析器设置DOM节点的值。Oracle XML DB将节点数据写入解析器读取的输出流。
                     </li>
                     <li class="ulchildlink"><a href="PLSQL-APIs-for-XMLType.html#GUID-A0C33052-CAEA-4678-B3AA-C0D2EA7A56F7">确定大型节点处理的二进制流或字符流</a><br>您可以使用子程序<code class="codeph">DBMS_XMLDOM.useBinaryStream</code>来确定是使用字符流还是二进制流来访问大型节点的内容。
                     </li>
                  </ul>
                  <div class="infoboxnotealso" id="GUID-C8B6BD89-F267-46C3-8656-99CFA052A198__GUID-4B885720-FBB0-4890-8FA5-1CEA3DEFF892">
                     <p class="notep1">也可以看看：</p>
                     <p> <a href="../arpls/DBMS_XMLDOM.html#ARPLS399" target="_blank"><span><cite>Oracle Database PL / SQL包和类型参考，</cite></span></a>用于描述各个<code class="codeph">DBMS_XMLDOM</code>方法</p>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="PLSQL-APIs-for-XMLType.html#GUID-2D5B2D47-9CFF-49D0-9BD8-114BBE48A289" title="有几个PL / SQL包为XMLType提供API。">XMLType的PL / SQL API</a></p>
                     </div>
                  </div>
               </div>
               <a id="ADXDB4876"></a><div class="props_rev_3"><a id="GUID-F1FAD45D-0C4D-4037-9676-F126EAAB2F87" name="GUID-F1FAD45D-0C4D-4037-9676-F126EAAB2F87"></a><h4 id="ADXDB-GUID-F1FAD45D-0C4D-4037-9676-F126EAAB2F87" class="sect4"><span class="enumeration_section">11.2.1</span> W3C文档对象模型（DOM）建议概述</h4>
                  <div>
                     <p>万维网联盟（W3C）推荐的文档对象模型（DOM）是用于访问XML文档结构的通用API。</p>
                     <p>DOM是用于访问XML文档结构的通用API。它最初开发用于形式化动态HTML，用于动画，交互和动态更新网页。DOM为Web页面和XML文档提供了与语言无关且与平台无关的对象模型。DOM描述了与语言无关且与平台无关的接口，用于访问和操作XML组件和元素。它以通用，内容中立的方式表达XML文档的结构。可以编写应用程序来动态删除，添加和编辑XML文档的内容，属性和样式。DOM可以创建在所有浏览器，服务器和平台上正常运行的应用程序。</p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="PLSQL-APIs-for-XMLType.html#GUID-27EFF9BC-8944-45D2-AAA0-B4B398E28318">Oracle XML Developer的W3C DOM标准套件扩展</a><br>Oracle XML Developer's Kit（XDK）扩展了W3C DOM API。 Oracle XML DB支持这些扩展，但与数据库中不适用的客户端操作相关的扩展除外。请参阅Oracle XML Developer的Kit Java和C组件中的Simple API for XML（SAX）接口。
                        </li>
                        <li class="ulchildlink"><a href="PLSQL-APIs-for-XMLType.html#GUID-70263FE1-8B79-4A10-A7DC-83CC2E4194DE">支持的W3C DOM建议</a><br>用于访问和操作XML数据的所有Oracle XML DB API均符合W3C批准的标准XML处理要求。 PL / SQL DOM支持W3C DOM规范的第1级和第2级。
                        </li>
                        <li class="ulchildlink"><a href="PLSQL-APIs-for-XMLType.html#GUID-47252A61-464B-418C-83AA-5CE2AD5A3310">DOM和SAX之间的区别</a><br>DOM是XML的主要通用基于树的API。 SAX（XML的简单API）是XML解析器和XML应用程序之间的主要基于事件的通用编程接口。
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="PLSQL-APIs-for-XMLType.html#GUID-C8B6BD89-F267-46C3-8656-99CFA052A198" title="XMLType的PL / SQL DOM API，DBMS_XMLDOM允许您使用DOM操作XMLType实例。">XMLType的PL / SQL DOM API（DBMS_XMLDOM）</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="ADXDB4877"></a><div class="props_rev_3"><a id="GUID-27EFF9BC-8944-45D2-AAA0-B4B398E28318" name="GUID-27EFF9BC-8944-45D2-AAA0-B4B398E28318"></a><h5 id="ADXDB-GUID-27EFF9BC-8944-45D2-AAA0-B4B398E28318" class="sect5"><span class="enumeration_section">11.2.1.1</span> Oracle XML Developer的W3C DOM标准套件扩展</h5>
                     <div>
                        <p>Oracle XML Developer's Kit（XDK）扩展了W3C DOM API。 Oracle XML DB支持这些扩展，但与数据库中不适用的客户端操作相关的扩展除外。请参阅Oracle XML Developer的Kit Java和C组件中的Simple API for XML（SAX）接口。</p>
                     </div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-27EFF9BC-8944-45D2-AAA0-B4B398E28318__GUID-1D59D2DA-F49D-4A53-A3A6-F82C8BE6B3F9">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/adxdb&amp;id=ADXDK" target="_blank"><span><cite>Oracle XML Developer's Kit程序员指南</cite></span></a></p>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="PLSQL-APIs-for-XMLType.html#GUID-F1FAD45D-0C4D-4037-9676-F126EAAB2F87" title="万维网联盟（W3C）推荐的文档对象模型（DOM）是用于访问XML文档结构的通用API。">W3C文档对象模型（DOM）建议概述</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="ADXDB4878"></a><div class="props_rev_3"><a id="GUID-70263FE1-8B79-4A10-A7DC-83CC2E4194DE" name="GUID-70263FE1-8B79-4A10-A7DC-83CC2E4194DE"></a><h5 id="ADXDB-GUID-70263FE1-8B79-4A10-A7DC-83CC2E4194DE" class="sect5"><span class="enumeration_section">11.2.1.2</span>支持的W3C DOM建议</h5>
                     <div>
                        <p>用于访问和操作XML数据的所有Oracle XML DB API均符合W3C批准的标准XML处理要求。 PL / SQL DOM支持W3C DOM规范的第1级和第2级。</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><span class="bold">DOM Level 1.0  -</span> DOM规范的第一个正式级别，于1998年10月完成。Level 1.0定义了对XML 1.0和HTML的支持。</p>
                           </li>
                           <li>
                              <p><span class="bold">DOM Level 2.0  -</span> 2000年11月完成，Level 2.0扩展了1.0级，支持带有命名空间的XML 1.0，并增加了对层叠样式表（CSS）和事件（用户界面事件和树操作事件）的支持，并增强了树操作（树范围和遍历机制）。CSS是一种向Web文档添加样式（字体，颜色，间距等）的简单机制。
                              </p>
                           </li>
                        </ul>
                        <p>Oracle对DOM的支持如下：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>在Oracle9i第1版（9.0.1）中，Oracle XML Developer的PL / SQL工具包实现了DOM Level 1.0和部分DOM Level 2.0。</p>
                           </li>
                           <li>
                              <p>在Oracle9i第2版（9.2）和Oracle数据库10g第1版（10.1）中， <code class="codeph">XMLType</code>的PL / SQL API实现了DOM Levels 1.0和Level 2.0 Core，并通过<code class="codeph">XMLType</code> API的扩展完全集成在数据库中。</p>
                           </li>
                        </ul>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="PLSQL-APIs-for-XMLType.html#GUID-F1FAD45D-0C4D-4037-9676-F126EAAB2F87" title="万维网联盟（W3C）推荐的文档对象模型（DOM）是用于访问XML文档结构的通用API。">W3C文档对象模型（DOM）建议概述</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="ADXDB4879"></a><div class="props_rev_3"><a id="GUID-47252A61-464B-418C-83AA-5CE2AD5A3310" name="GUID-47252A61-464B-418C-83AA-5CE2AD5A3310"></a><h5 id="ADXDB-GUID-47252A61-464B-418C-83AA-5CE2AD5A3310" class="sect5"><span class="enumeration_section">11.2.1.3</span> DOM和SAX之间的区别</h5>
                     <div>
                        <p>DOM是XML的主要通用基于树的API。 SAX（XML的简单API）是XML解析器和XML应用程序之间的主要基于事件的通用编程接口。</p>
                        <p>DOM通过创建对象来工作。这些对象具有子对象和属性。子对象具有自己的子对象和属性，依此类推。通过向下移动对象层次结构或通过显式为HTML元素提供ID属性来引用对象。例如：</p><pre class="pre codeblock"><code>&lt;img src =“employee_jdoe.gif”ID =“0123jdoe”&gt;</code></pre><p>结构操作的例子是：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>重新排序元素</p>
                           </li>
                           <li>
                              <p>添加或删除元素</p>
                           </li>
                           <li>
                              <p>添加或删除属性</p>
                           </li>
                           <li>
                              <p>重命名元素</p>
                           </li>
                        </ul>
                     </div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-47252A61-464B-418C-83AA-5CE2AD5A3310__GUID-5E8B118C-2782-4AE4-87D2-45B8AEA9C0FF">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/adxdb&amp;id=w3_org_dom" target="_blank">文档对象模型（ <span class="bold">DOM</span> <span class="bold">）</span></a></p>
                              </li>
                              <li>
                                 <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/adxdb&amp;id=sax_project_org" target="_blank">SAX项目</a></p>
                              </li>
                           </ul>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="PLSQL-APIs-for-XMLType.html#GUID-F1FAD45D-0C4D-4037-9676-F126EAAB2F87" title="万维网联盟（W3C）推荐的文档对象模型（DOM）是用于访问XML文档结构的通用API。">W3C文档对象模型（DOM）建议概述</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="ADXDB4880"></a><div class="props_rev_3"><a id="GUID-629DC11A-283C-4A89-AB96-DE142E5FF34B" name="GUID-629DC11A-283C-4A89-AB96-DE142E5FF34B"></a><h4 id="ADXDB-GUID-629DC11A-283C-4A89-AB96-DE142E5FF34B" class="sect4"><span class="enumeration_section">11.2.2</span> XMLType的PL / SQL DOM API（DBMS_XMLDOM）：功能</h4>
                  <div>
                     <p>Oracle XML DB扩展了Oracle数据库XML开发平台，超越了SQL支持，用于存储和检索XML数据。它允许您使用PL / SQL，Java和C中的DOM操作<code class="codeph">XMLType</code>实例。</p>
                     <p><code class="codeph">XMLType</code> （ <code class="codeph">DBMS_XMLDOM</code> ）的PL / SQL DOM API的<span class="italic">默认</span>操作执行以下操作：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>生成可由DOM API访问的解析树。</p>
                        </li>
                        <li>
                           <p>如果找到DTD，则验证。否则，请勿验证。</p>
                        </li>
                        <li>
                           <p>如果解析失败，则引发应用程序错误。</p>
                        </li>
                     </ul>
                     <p>在显示对象文档时发生DTD验证。如果使用惰性表现形式，则在使用文档时验证该文档。</p>
                     <p>PL / SQL DOM API利用服务器中基于C的XML表示，并在基于XML模式的XML实例上运行。<code class="codeph">XMLType</code>的PL / SQL，Java和C DOM API符合W3C DOM建议，用于在关系列或对象关系列中定义和实现XML数据的对象关系存储，以及<code class="codeph">XMLType</code>动态内存实例。有关W3C DOM建议的说明，请参阅<a href="PLSQL-APIs-for-XMLType.html#GUID-0DAAFA6D-6EDD-465B-999A-D9011FA46230" title="创建XML模式，对其进行注释以将XML映射到SQL对象，并注册XML模式。">准备XML数据以将PL / SQL DOM API用于XMLType</a> 。
                     </p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="PLSQL-APIs-for-XMLType.html#GUID-46089A58-2DAA-4D13-8989-F59B1CE68406">PL / SQL DOM API支持XML模式</a><br><code class="codeph">XMLType</code>的PL / SQL DOM API支持XML Schema。Oracle XML DB使用XML模式中的注释作为元数据来确定XML文档的结构以及文档到数据库模式的映射。
                        </li>
                        <li class="ulchildlink"><a href="PLSQL-APIs-for-XMLType.html#GUID-2EF9BD1C-1EBF-43D5-838E-73261791081A">增强的DOM性能</a><br>Oracle XML DB使用DOM提供在XML和多个后端数据源之间转换数据的标准方法。这样就无需为环境中的不同数据源使用单独的XML转换技术。
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="PLSQL-APIs-for-XMLType.html#GUID-C8B6BD89-F267-46C3-8656-99CFA052A198" title="XMLType的PL / SQL DOM API，DBMS_XMLDOM允许您使用DOM操作XMLType实例。">XMLType的PL / SQL DOM API（DBMS_XMLDOM）</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="ADXDB6003"></a><div class="props_rev_3"><a id="GUID-46089A58-2DAA-4D13-8989-F59B1CE68406" name="GUID-46089A58-2DAA-4D13-8989-F59B1CE68406"></a><h5 id="ADXDB-GUID-46089A58-2DAA-4D13-8989-F59B1CE68406" class="sect5"><span class="enumeration_section">11.2.2.1</span> PL / SQL DOM API对XML模式的支持</h5>
                     <div>
                        <p><code class="codeph">XMLType</code>的PL / SQL DOM API支持XML Schema。Oracle XML DB使用XML模式中的注释作为元数据来确定XML文档的结构以及文档到数据库模式的映射。
                        </p>
                        <div class="infoboxnote" id="GUID-46089A58-2DAA-4D13-8989-F59B1CE68406__GUID-509DFEAE-DC3D-4B83-BEF4-9AAD1386551F">
                           <p class="notep1">注意：</p>
                           <p>为了向后兼容性和灵活性，PL / SQL DOM支持基于XML模式的文档和基于非模式的文档。</p>
                        </div>
                        <p>在向XML XML DB注册XML模式后， <code class="codeph">XMLType</code>的PL / SQL DOM API在动态内存中构建关联XML文档的树表示，作为节点对象的层次结构，每个节点对象都有自己的专用接口。大多数节点对象类型可以具有子节点类型，这些子节点类型又实现了更多，更专用的接口。某些节点类型的节点可以具有各种类型的子节点，而其他节点类型的节点必须是叶节点，它们没有子节点。
                        </p>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="PLSQL-APIs-for-XMLType.html#GUID-629DC11A-283C-4A89-AB96-DE142E5FF34B" title="Oracle XML DB扩展了Oracle数据库XML开发平台，超越了SQL支持，用于存储和检索XML数据。它允许您使用PL / SQL，Java和C中的DOM操作XMLType实例。">XMLType的PL / SQL DOM API（DBMS_XMLDOM）：功能</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="ADXDB4882"></a><div class="props_rev_3"><a id="GUID-2EF9BD1C-1EBF-43D5-838E-73261791081A" name="GUID-2EF9BD1C-1EBF-43D5-838E-73261791081A"></a><h5 id="ADXDB-GUID-2EF9BD1C-1EBF-43D5-838E-73261791081A" class="sect5"><span class="enumeration_section">11.2.2.2</span>增强的DOM性能</h5>
                     <div>
                        <p>Oracle XML DB使用DOM提供在XML和多个后端数据源之间转换数据的标准方法。这样就无需为环境中的不同数据源使用单独的XML转换技术。</p>
                        <p>需要交换XML数据的应用程序可以使用单个本机XML数据库来缓存XML文档。因此，Oracle XML DB可以充当Web应用程序和后端数据源之间的中间缓存，无论它们位于关系数据库还是文件系统中，都可以提高应用程序性能。</p>
                        <div class="section"></div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="relinfo">
                           <p><strong>相关话题</strong></p>
                           <ul>
                              <li><a href="Java-DOM-API-for-XMLType.html#GUID-4C510052-8A31-4917-8567-0E2825927C54" title="XMLType的Java DOM API允许您使用DOM操作XMLType实例。您可以使用它来操作Java中的XML数据，包括通过Java数据库连接（JDBC）获取它。">用于XMLType的Java DOM API</a></li>
                           </ul>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="PLSQL-APIs-for-XMLType.html#GUID-629DC11A-283C-4A89-AB96-DE142E5FF34B" title="Oracle XML DB扩展了Oracle数据库XML开发平台，超越了SQL支持，用于存储和检索XML数据。它允许您使用PL / SQL，Java和C中的DOM操作XMLType实例。">XMLType的PL / SQL DOM API（DBMS_XMLDOM）：功能</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="ADXDB4883"></a><div class="props_rev_3"><a id="GUID-1395CFCB-6CDC-4FC6-9AA3-81443805E0C4" name="GUID-1395CFCB-6CDC-4FC6-9AA3-81443805E0C4"></a><h4 id="ADXDB-GUID-1395CFCB-6CDC-4FC6-9AA3-81443805E0C4" class="sect4"><span class="enumeration_section">11.2.3</span>使用Oracle XML Developer Kit和Oracle XML DB进行应用程序设计</h4>
                  <div>
                     <p>在基于Oracle XML DB构建应用程序时，您不需要Oracle XML Developer's Kit（XDK）提供的其他组件。但是，您可以将XDK组件与Oracle XML DB一起使用，以部署端到端运行的一整套支持XML的应用程序。</p>
                     <p>这些XDK功能对于开发基于Oracle XML DB的XML应用程序特别有用。</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>用于XML（SAX）接口处理的简单API。SAX是XML解析器提供的XML标准接口，由程序和基于事件的应用程序使用。</p>
                        </li>
                        <li>
                           <p>DOM接口处理，用于结构和递归的基于对象的处理。</p>
                        </li>
                     </ul>
                     <p>Oracle XML Developer's Kit包含用于创建在客户端，浏览器或插件中运行的应用程序的基本构建块。此类应用程序通常读取，操作，转换和查看XML文档。为了提供各种各样的部署选项，Oracle XML Developer's Kit可用于Java，C和C ++。Oracle XML Developer's Kit完全受支持，并附带商业再发行许可证。</p>
                     <p>Oracle XML Developer's Kit for Java包含以下组件：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><span class="bold">XML Parsers  -</span>使用行业标准DOM和SAX接口创建和解析XML。支持Java，C，C ++和用于XML处理的Java API（JAXP）。
                           </p>
                        </li>
                        <li>
                           <p><span class="bold">XSL处理器 -</span>将XML转换或呈现为其他基于文本的格式，如HTML。支持Java，C和C ++。
                           </p>
                        </li>
                        <li>
                           <p><span class="bold">XML Schema Processor  -</span>使用XML简单和复杂的数据类型。支持Java，C和C ++。
                           </p>
                        </li>
                        <li>
                           <p><span class="bold">XML类生成器，Oracle JAXB类生成器 -</span>分别从DTD和XML模式自动生成C ++和Java类，以从Web表单或应用程序发送XML数据。类生成器接受输入文件并创建一组具有相应功能的输出类。对于XML类生成器，输入文件是DTD，输出是一系列类，可用于创建符合DTD的XML文档。</p>
                        </li>
                        <li>
                           <p><span class="bold">XML SQL实用程序 -</span>从SQL查询生成XML文档，DTD和XML模式。支持Java。
                           </p>
                        </li>
                        <li>
                           <p><span class="bold">TransX Utility  -</span>将封装在XML中的数据加载到数据库中。具有对安装有用的附加功能。
                           </p>
                        </li>
                        <li>
                           <p><span class="bold">XML Pipeline Processor  -</span>通过XML控制文件调用Java进程。
                           </p>
                        </li>
                        <li>
                           <p><span class="bold">XSLT VM和编译器 -</span>提供使用已编译的XSL样式表的高性能基于C的XSLT转换引擎。
                           </p>
                        </li>
                        <li>
                           <p><span class="bold">XML Java Bean  -</span>使用Java组件解析，转换，比较，检索和压缩XML文档。
                           </p>
                        </li>
                     </ul>
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-1395CFCB-6CDC-4FC6-9AA3-81443805E0C4__GUID-8167ACA7-0E49-40F4-A796-C78FEBEAF452">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="../adxdk/index.html" target="_blank"><span><cite>Oracle XML Developer's Kit程序员指南</cite></span></a></p>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="PLSQL-APIs-for-XMLType.html#GUID-C8B6BD89-F267-46C3-8656-99CFA052A198" title="XMLType的PL / SQL DOM API，DBMS_XMLDOM允许您使用DOM操作XMLType实例。">XMLType的PL / SQL DOM API（DBMS_XMLDOM）</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB4884"></a><div class="props_rev_3"><a id="GUID-0DAAFA6D-6EDD-465B-999A-D9011FA46230" name="GUID-0DAAFA6D-6EDD-465B-999A-D9011FA46230"></a><h4 id="ADXDB-GUID-0DAAFA6D-6EDD-465B-999A-D9011FA46230" class="sect4"><span class="enumeration_section">11.2.4</span>准备XML数据以将PL / SQL DOM API用于XMLType</h4>
                  <div>
                     <p>创建XML模式，对其进行注释以将XML映射到SQL对象，并注册XML模式。</p>
                     <div class="section">
                        <p>准备在Oracle XML DB中使用PL / SQL DOM API的数据：</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li><span>创建标准XML架构。</span></li>
                        <li><span>使用您使用的SQL对象的定义来注释XML模式。</span></li>
                        <li><span>注册XML模式，以生成必要的数据库映射。</span></li>
                     </ol>
                     <div class="section">
                        <p>然后，您可以执行以下任何操作：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>使用<code class="codeph">XMLType</code>视图以XML格式包装现有的关系数据或对象关系数据，使其以XML格式提供给您的应用程序。请参阅<a href="PLSQL-APIs-for-XMLType.html#GUID-10C47D9D-A6CD-4E37-B9D8-9E0B75ACADB2" title="要使现有的关系数据和对象关系数据可用于XML应用程序，可以基于它创建XMLType视图。然后，您可以使用PL / SQL DOM API访问生成的XML数据。">使用XMLType视图将现有数据包装为XML</a> 。
                              </p>
                           </li>
                           <li>
                              <p>将XML数据插入<code class="codeph">XMLType</code>列。
                              </p>
                           </li>
                           <li>
                              <p>使用Oracle XML DB PL / SQL和Java DOM API来处理存储在<code class="codeph">XMLType</code>列和表中的XML数据。
                              </p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="PLSQL-APIs-for-XMLType.html#GUID-C8B6BD89-F267-46C3-8656-99CFA052A198" title="XMLType的PL / SQL DOM API，DBMS_XMLDOM允许您使用DOM操作XMLType实例。">XMLType的PL / SQL DOM API（DBMS_XMLDOM）</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB4885"></a><div class="props_rev_3"><a id="GUID-92017A80-EA34-4ED4-8B8A-EB222D404867" name="GUID-92017A80-EA34-4ED4-8B8A-EB222D404867"></a><h4 id="ADXDB-GUID-92017A80-EA34-4ED4-8B8A-EB222D404867" class="sect4"><span class="enumeration_section">11.2.5</span> XML模式类型映射到SQL对象类型</h4>
                  <div>
                     <p>必须先向Oracle XML DB注册XML模式，然后才能由XML文档引用它。注册XML模式时，它声明的元素和属性将映射到数据库中相应SQL对象类型的属性。</p>
                     <p>在XML模式注册之后，符合XML模式并引用它的XML文档可以由Oracle XML DB管理。可以为XML模式定义的根元素创建用于存储符合文档的表和列。</p>
                     <p>通过使用PL / SQL包<code class="codeph">DBMS_XMLSCHEMA</code>并指定模式文档及其<span class="italic">模式位置URL</span>来注册XML模式。此URL是唯一标识数据库中已注册模式的名称。它不需要对应任何实际位置 - 特别是，它不需要指示架构文档的位置。
                     </p>
                     <p>架构的<span class="italic">目标命名空间</span>是XML架构中使用的另一个URL。它为XML模式元素和类型指定名称空间。XML文档应指定根元素的名称空间和标识定义此元素的模式的模式位置URL。
                     </p>
                     <p>使用基于路径的协议（如HTTP（S）和FTP）将文档插入Oracle XML DB时，如果指定了其名称和位置且尚未注册，则会<span class="italic">隐式注册</span>文档符合的XML模式。
                     </p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="PLSQL-APIs-for-XMLType.html#GUID-21ABBFB2-3961-4706-BD1A-0F71FA5CB09A">XML模式映射的DOM保真度</a><br>在XML模式中声明的元素和属性将映射到相应SQL对象类型的单独属性。XML文档中编码的其他信息（例如注释，处理指令，命名空间声明和前缀定义以及空格）不直接表示。
                        </li>
                     </ul>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="XML-Schema-and-query-basic.html#GUID-C09824C1-6B02-4556-A265-B1749DEE8DE1" title="XML Schema是用于描述XML文档的内容和结构的标准。您可以注册，更新和删除与Oracle XML DB一起使用的XML架构。您可以定义用于基于XML模式的数据的存储结构，并将XML模式数据类型映射到SQL数据类型。">XML模式存储和查询：基本</a></li>
                        </ul>
                     </div>
                     <div class="infoboxnotealso" id="GUID-92017A80-EA34-4ED4-8B8A-EB222D404867__GUID-1BDA6F6B-EB95-44BE-B06C-46F4DC3C9F9B">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/adxdb&amp;id=ARPLS377" target="_blank"><span><cite>Oracle Database PL / SQL包和类型</cite></span></a>各个<code class="codeph">DBMS_XMLSCHEMA</code>方法的<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/adxdb&amp;id=ARPLS377" target="_blank"><span><cite>参考</cite></span></a>描述</p>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="PLSQL-APIs-for-XMLType.html#GUID-C8B6BD89-F267-46C3-8656-99CFA052A198" title="XMLType的PL / SQL DOM API，DBMS_XMLDOM允许您使用DOM操作XMLType实例。">XMLType的PL / SQL DOM API（DBMS_XMLDOM）</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="ADXDB4886"></a><div class="props_rev_3"><a id="GUID-21ABBFB2-3961-4706-BD1A-0F71FA5CB09A" name="GUID-21ABBFB2-3961-4706-BD1A-0F71FA5CB09A"></a><h5 id="ADXDB-GUID-21ABBFB2-3961-4706-BD1A-0F71FA5CB09A" class="sect5"><span class="enumeration_section">11.2.5.1</span> XML模式映射的DOM保真度</h5>
                     <div>
                        <p>在XML模式中声明的元素和属性将映射到相应SQL对象类型的单独属性。XML文档中编码的其他信息（例如注释，处理指令，命名空间声明和前缀定义以及空格）不直接表示。</p>
                        <p>要存储此附加信息，二进制属性<code class="codeph">SYS_XDBPD$</code>将出现在所有生成的SQL对象类型中。此数据库属性存储原始XML文档中未使用其他数据库属性存储的所有信息。保留此附件信息可确保存储在Oracle XML DB中的XML文档的<span class="italic">DOM保真度</span> ：从数据库检索的XML文档与存储的原始文档相同。
                        </p>
                        <div class="infoboxnote" id="GUID-21ABBFB2-3961-4706-BD1A-0F71FA5CB09A__GUID-08227380-74C9-436C-AE44-6215756510D6">
                           <p class="notep1">注意：</p>
                           <p>在本书中，为简单起见，大多数示例中省略了属性<code class="codeph">SYS_XDBPD$</code> 。但是，该属性始终存在于由模式注册生成的SQL对象类型中。
                           </p>
                        </div>
                        <div class="section"></div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="relinfo">
                           <p><strong>相关话题</strong></p>
                           <ul>
                              <li><a href="XML-Schema-and-query-object-relational-storage.html#GUID-AF8651CF-49C5-4B13-A198-0AE1F0770439" title="为了提供以对象关系存储的XML数据的DOM保真度，Oracle XML DB使用系统定义的二进制对象属性SYS_XDBPD $将所有无法存储在任何其他对象属性中的信息记录为实例级元数据（位置描述符或PD）。">对象关系存储的SYS_XDBPD $和DOM保真度</a></li>
                           </ul>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="PLSQL-APIs-for-XMLType.html#GUID-92017A80-EA34-4ED4-8B8A-EB222D404867" title="必须先向Oracle XML DB注册XML模式，然后才能由XML文档引用它。注册XML模式时，它声明的元素和属性将映射到数据库中相应SQL对象类型的属性。">XML模式类型映射到SQL对象类型</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="ADXDB4887"></a><div class="props_rev_3"><a id="GUID-10C47D9D-A6CD-4E37-B9D8-9E0B75ACADB2" name="GUID-10C47D9D-A6CD-4E37-B9D8-9E0B75ACADB2"></a><h4 id="ADXDB-GUID-10C47D9D-A6CD-4E37-B9D8-9E0B75ACADB2" class="sect4"><span class="enumeration_section">11.2.6</span>使用XMLType视图将现有数据包装为XML</h4>
                  <div>
                     <p>要使现有的关系数据和对象关系数据可用于XML应用程序，可以基于它创建<code class="codeph">XMLType</code>视图。然后，您可以使用PL / SQL DOM API访问生成的XML数据。</p>
                     <p>注册包含表示XML类型和SQL对象类型之间映射的注释的XML模式后，可以创建符合XML模式的<code class="codeph">XMLType</code>视图。
                     </p>
                     <div class="section"></div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="XMLType-views.html#GUID-9F0A7B1F-269B-411F-AD8B-8F1CB2E2A671" title="您可以在关系数据和对象关系数据上创建XMLType视图。">XMLType视图</a></li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="PLSQL-APIs-for-XMLType.html#GUID-C8B6BD89-F267-46C3-8656-99CFA052A198" title="XMLType的PL / SQL DOM API，DBMS_XMLDOM允许您使用DOM操作XMLType实例。">XMLType的PL / SQL DOM API（DBMS_XMLDOM）</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB4888"></a><div class="props_rev_3"><a id="GUID-7E32FE20-2471-4FA2-BF90-3036E4A73991" name="GUID-7E32FE20-2471-4FA2-BF90-3036E4A73991"></a><h4 id="ADXDB-GUID-7E32FE20-2471-4FA2-BF90-3036E4A73991" class="sect4"><span class="enumeration_section">11.2.7</span> Oracle XML DB支持的DBMS_XMLDOM方法</h4>
                  <div>
                     <p>Oracle XML DB支持所有<code class="codeph">DBMS_XMLDOM</code>方法，但有一些例外。
                     </p>
                     <div class="section">
                        <p>Oracle XML DB <span class="italic">不</span>支持这些方法：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">writeExternalDTDToFile（）</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">writeExternalDTDToBuffer（）</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">writeExternalDTDToClob（）</code></p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-7E32FE20-2471-4FA2-BF90-3036E4A73991__GUID-918F3952-EE17-4B6B-B72A-4D19C4F30CC6">
                        <p class="notep1">也可以看看：</p>
                        <p> <a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/adxdb&amp;id=ARPLS399" target="_blank"><span><cite>Oracle Database PL / SQL包和类型参考，</cite></span></a>用于描述各个<code class="codeph">DBMS_XMLDOM</code>方法</p>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="PLSQL-APIs-for-XMLType.html#GUID-C8B6BD89-F267-46C3-8656-99CFA052A198" title="XMLType的PL / SQL DOM API，DBMS_XMLDOM允许您使用DOM操作XMLType实例。">XMLType的PL / SQL DOM API（DBMS_XMLDOM）</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB4890"></a><a id="ADXDB4889"></a><div class="props_rev_3"><a id="GUID-33EBF3B7-B804-4A2B-A4EF-0F40FFC742F6" name="GUID-33EBF3B7-B804-4A2B-A4EF-0F40FFC742F6"></a><h4 id="ADXDB-GUID-33EBF3B7-B804-4A2B-A4EF-0F40FFC742F6" class="sect4"><span class="enumeration_section">11.2.8</span> XMLType的PL / SQL DOM API：节点类型</h4>
                  <div>
                     <p>DOM指定XML文档中的元素用于创建基于对象的树结构的方式。它定义和公开接口以管理和使用存储在XML文档中的对象。DOM支持在不同系统中存储文档。</p>
                     <p>在DOM规范中，术语“ <span class="bold">文档</span> ”描述了用于许多不同类型的信息或数据的容器，DOM实现了这些容器。
                     </p>
                     <p>当调用诸如<code class="codeph">getNodeType(myNode)</code>类的请求时，它返回<code class="codeph">myNodeType</code> ，这是父节点支持的节点类型。以下常量表示节点可以采用的不同类型：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">ELEMENT_NODE</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">ATTRIBUTE_NODE</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">TEXT_NODE</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">CDATA_SECTION_NODE</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">ENTITY_REFERENCE_NODE</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">ENTITY_NODE</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">PROCESSING_INSTRUCTION_NODE</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">COMMENT_NODE</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">DOCUMENT_NODE</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">DOCUMENT_TYPE_NODE</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">DOCUMENT_FRAGMENT_NODE</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">NOTATION_NODE</code></p>
                        </li>
                     </ul>
                     <p><a href="PLSQL-APIs-for-XMLType.html#GUID-33EBF3B7-B804-4A2B-A4EF-0F40FFC742F6__G1047756" title="此表描述了DBMS_XMLDOM中支持的XML和HTML DOM节点类型以及子节点类型。">表11-2</a>显示了XML和HTML的节点类型，以及允许的相应子节点类型。
                     </p>
                     <div class="tblformalwide" id="GUID-33EBF3B7-B804-4A2B-A4EF-0F40FFC742F6__G1047756">
                        <p class="titleintable">表11-2 XML和HTML DOM节点类型及其子节点类型</p>
                        <table cellpadding="4" cellspacing="0" class="FormalWide" title="XML和HTML DOM节点类型及其子节点类型" width="100%" border="1" summary="This table describes the XML and HTML DOM node types and child node types supported in DBMS_XMLDOM." frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="25%" id="d66991e2350">节点类型</th>
                                 <th align="left" valign="bottom" width="75%" id="d66991e2353">儿童节点类型</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="25%" id="d66991e2358" headers="d66991e2350 "><pre class="oac_no_warn" dir="ltr">文献</pre></td>
                                 <td align="left" valign="top" width="75%" headers="d66991e2358 d66991e2353 ">
                                    <p><code class="codeph">Element</code> （最多一个）， <code class="codeph">ProcessingInstruction</code> ， <code class="codeph">Comment</code> ， <code class="codeph">DocumentType</code> （最多一个）</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="25%" id="d66991e2376" headers="d66991e2350 "><pre class="oac_no_warn" dir="ltr">的DocumentFragment</pre></td>
                                 <td align="left" valign="top" width="75%" headers="d66991e2376 d66991e2353 ">
                                    <p><code class="codeph">Element</code> ， <code class="codeph">ProcessingInstruction</code> ， <code class="codeph">Comment</code> ， <code class="codeph">Text</code> ， <code class="codeph">CDATASection</code> ， <code class="codeph">EntityReference</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="25%" id="d66991e2399" headers="d66991e2350 "><pre class="oac_no_warn" dir="ltr">DocumentType</pre></td>
                                 <td align="left" valign="top" width="75%" headers="d66991e2399 d66991e2353 ">
                                    <p>没有小孩</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="25%" id="d66991e2406" headers="d66991e2350 "><pre class="oac_no_warn" dir="ltr">的EntityReference</pre></td>
                                 <td align="left" valign="top" width="75%" headers="d66991e2406 d66991e2353 ">
                                    <p><code class="codeph">Element</code> ， <code class="codeph">ProcessingInstruction</code> ， <code class="codeph">Comment</code> ， <code class="codeph">Text</code> ， <code class="codeph">CDATASection</code> ， <code class="codeph">EntityReference</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="25%" id="d66991e2429" headers="d66991e2350 "><pre class="oac_no_warn" dir="ltr">元件</pre></td>
                                 <td align="left" valign="top" width="75%" headers="d66991e2429 d66991e2353 ">
                                    <p><code class="codeph">Element</code> ， <code class="codeph">Text</code> ， <code class="codeph">Comment</code> ， <code class="codeph">ProcessingInstruction</code> ， <code class="codeph">CDATASection</code> ， <code class="codeph">EntityReference</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="25%" id="d66991e2452" headers="d66991e2350 "><pre class="oac_no_warn" dir="ltr">ATTR</pre></td>
                                 <td align="left" valign="top" width="75%" headers="d66991e2452 d66991e2353 ">
                                    <p><code class="codeph">Text</code> ， <code class="codeph">EntityReference</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="25%" id="d66991e2463" headers="d66991e2350 "><pre class="oac_no_warn" dir="ltr">的ProcessingInstruction</pre></td>
                                 <td align="left" valign="top" width="75%" headers="d66991e2463 d66991e2353 ">
                                    <p>没有小孩</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="25%" id="d66991e2470" headers="d66991e2350 "><pre class="oac_no_warn" dir="ltr">评论</pre></td>
                                 <td align="left" valign="top" width="75%" headers="d66991e2470 d66991e2353 ">
                                    <p>没有小孩</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="25%" id="d66991e2477" headers="d66991e2350 "><pre class="oac_no_warn" dir="ltr">文本</pre></td>
                                 <td align="left" valign="top" width="75%" headers="d66991e2477 d66991e2353 ">
                                    <p>没有小孩</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="25%" id="d66991e2484" headers="d66991e2350 "><pre class="oac_no_warn" dir="ltr">的CDATASection</pre></td>
                                 <td align="left" valign="top" width="75%" headers="d66991e2484 d66991e2353 ">
                                    <p>没有小孩</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="25%" id="d66991e2491" headers="d66991e2350 "><pre class="oac_no_warn" dir="ltr">实体</pre></td>
                                 <td align="left" valign="top" width="75%" headers="d66991e2491 d66991e2353 ">
                                    <p><code class="codeph">Element</code> ， <code class="codeph">ProcessingInstruction</code> ， <code class="codeph">Comment</code> ， <code class="codeph">Text</code> ， <code class="codeph">CDATASection</code> ， <code class="codeph">EntityReference</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="25%" id="d66991e2515" headers="d66991e2350 "><pre class="oac_no_warn" dir="ltr">符号</pre></td>
                                 <td align="left" valign="top" width="75%" headers="d66991e2515 d66991e2353 ">
                                    <p>没有小孩</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <p>用于<code class="codeph">XMLType</code> Oracle XML DB DOM API还指定了以下接口：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><span class="bold">的</span> <span class="bold">NodeList</span> <span class="bold">接口</span>来处理节点的有序列表，例如：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>Node的子节点</p>
                              </li>
                              <li>
                                 <p>元素接口的方法<code class="codeph">getElementsByTagName()</code>返回的元素</p>
                              </li>
                           </ul>
                        </li>
                        <li>
                           <p><span class="bold">甲</span> <span class="bold">的NamedNodeMap</span> <span class="bold">接口</span>来处理无序节点集，可以通过名称属性引用，例如元素的属性。
                           </p>
                        </li>
                     </ul>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="PLSQL-APIs-for-XMLType.html#GUID-C8B6BD89-F267-46C3-8656-99CFA052A198" title="XMLType的PL / SQL DOM API，DBMS_XMLDOM允许您使用DOM操作XMLType实例。">XMLType的PL / SQL DOM API（DBMS_XMLDOM）</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB4891"></a><div class="props_rev_3"><a id="GUID-DD35C504-C429-49AC-A6A7-3001BA96C1F5" name="GUID-DD35C504-C429-49AC-A6A7-3001BA96C1F5"></a><h4 id="ADXDB-GUID-DD35C504-C429-49AC-A6A7-3001BA96C1F5" class="sect4"><span class="enumeration_section">11.2.9</span> PL / SQL函数NEWDOMDOCUMENT和DOMDOCUMENT节点</h4>
                  <div>
                     <p>PL / SQL函数<code class="codeph">newDOMDocument</code>在给定<code class="codeph">XMLType</code>值的<code class="codeph">newDOMDocument</code>构造DOM文档句柄。生成的句柄是<code class="codeph">DOMDocument</code>类型。
                     </p>
                     <p>PL / SQL应用程序的典型使用场景是：</p>
                     <ol>
                        <li>
                           <p>获取或构造<code class="codeph">XMLType</code>实例</p>
                        </li>
                        <li>
                           <p>在<code class="codeph">XMLType</code>实例上构造<code class="codeph">DOMDocument</code>节点</p>
                        </li>
                        <li>
                           <p>使用DOM API访问和操作XML数据</p>
                           <div class="infoboxnote" id="GUID-DD35C504-C429-49AC-A6A7-3001BA96C1F5__GUID-CD1A0F5D-8284-4511-A7D0-6A0F9192490E">
                              <p class="notep1">注意：</p>
                              <p>对于<code class="codeph">DOMDocument</code> ，节点类型表示XML片段的句柄，但不表示数据本身。
                              </p>
                              <p>例如，如果复制节点值， <code class="codeph">DOMDocument</code>句柄克隆到相同的基础数据。当其他句柄访问时，由其中一个句柄修改的任何数据都是可见的。构造<code class="codeph">DOMDocument</code>句柄的<code class="codeph">XMLType</code>值是数据，并反映其上所有DOM操作的结果。
                              </p>
                           </div>
                        </li>
                     </ol>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="PLSQL-APIs-for-XMLType.html#GUID-C8B6BD89-F267-46C3-8656-99CFA052A198" title="XMLType的PL / SQL DOM API，DBMS_XMLDOM允许您使用DOM操作XMLType实例。">XMLType的PL / SQL DOM API（DBMS_XMLDOM）</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB4892"></a><div class="props_rev_3"><a id="GUID-11900518-CC1D-4344-9ABE-CE3F67D8C71F" name="GUID-11900518-CC1D-4344-9ABE-CE3F67D8C71F"></a><h4 id="ADXDB-GUID-11900518-CC1D-4344-9ABE-CE3F67D8C71F" class="sect4"><span class="enumeration_section">11.2.10</span> DOM NodeList和NamedNodeMap对象</h4>
                  <div>
                     <p>当您更改<code class="codeph">DOMDocument</code>实例下的文档结构时，更改将反映在所有相关的<code class="codeph">NodeList</code>和<code class="codeph">NamedNodeMap</code>对象中。
                     </p>
                     <p>例如，如果DOM用户获取包含元素子元素的<code class="codeph">NodeList</code>对象，然后随后向该元素添加更多子元素（或删除子元素或修改现有子元素），则这些更改会自动传播到<code class="codeph">NodeList</code>而无需执行其他操作。用户。同样，对树中节点的更改将在<code class="codeph">NodeList</code>和<code class="codeph">NamedNodeMap</code>对象中对该节点的所有引用中传播。
                     </p>
                     <p>接口： <code class="codeph">Text</code> ， <code class="codeph">Comment</code>和<code class="codeph">CDATASection,</code>都继承自<code class="codeph">CharacterData</code>接口。
                     </p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="PLSQL-APIs-for-XMLType.html#GUID-C8B6BD89-F267-46C3-8656-99CFA052A198" title="XMLType的PL / SQL DOM API，DBMS_XMLDOM允许您使用DOM操作XMLType实例。">XMLType的PL / SQL DOM API（DBMS_XMLDOM）</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB4894"></a><a id="ADXDB4893"></a><div class="props_rev_3"><a id="GUID-378E17DE-EE95-4D4B-96B3-8F181B235CFD" name="GUID-378E17DE-EE95-4D4B-96B3-8F181B235CFD"></a><h4 id="ADXDB-GUID-378E17DE-EE95-4D4B-96B3-8F181B235CFD" class="sect4"><span class="enumeration_section">11.2.11</span>为XMLType使用PL / SQL DOM API概述（DBMS_XMLDOM）</h4>
                  <div>
                     <p>使用PL / SQL包<code class="codeph">DBMS_XMLDOM</code>通常涉及创建DOM文档，遍历或扩展DOM树，以及创建和操作节点。
                     </p>
                     <div class="section">
                        <p><a href="PLSQL-APIs-for-XMLType.html#GUID-378E17DE-EE95-4D4B-96B3-8F181B235CFD__I1043435">图11-1</a>说明了PL / SQL DOM API for <code class="codeph">XMLType</code> （ <code class="codeph">DBMS_XMLDOM</code> ）的使用。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p>您可以从现有<code class="codeph">XMLType</code>或作为空文档创建DOM文档（ <code class="codeph">DOMDocument</code> ）。过程<code class="codeph">newDOMDocument</code>处理<code class="codeph">XMLType</code>实例或空文档。
                              </p>
                              <p>这将创建一个<code class="codeph">DOMDocument</code>实例。
                              </p>
                           </li>
                           <li>
                              <p>您可以使用DOM API PL / SQL方法（如<code class="codeph">createElement()</code> ， <code class="codeph">createText()</code> ， <code class="codeph">createAttribute()</code>和<code class="codeph">createComment()</code>来遍历和扩展DOM树。
                              </p>
                           </li>
                           <li>
                              <p>PL / SQL方法（如<code class="codeph">DOMElement()</code>和<code class="codeph">DOMText()</code>也可以传递给PL / SQL函数<code class="codeph">makeNode</code>以获取<code class="codeph">DOMNode</code>接口。
                              </p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <div class="figure" id="GUID-378E17DE-EE95-4D4B-96B3-8F181B235CFD__I1043435">
                           <p class="titleinfigure">图11-1为XMLType使用PL / SQL DOM API</p><img src="img/adxdb014.gif" width="457" alt="下面是图11-1的描述" title="下面是图11-1的描述" longdesc="img_text/adxdb014.html"><br><a href="img_text/adxdb014.html">“图11-1为XMLType使用PL / SQL DOM API”的描述</a></div>
                        <!-- class="figure" -->
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="PLSQL-APIs-for-XMLType.html#GUID-C8B6BD89-F267-46C3-8656-99CFA052A198" title="XMLType的PL / SQL DOM API，DBMS_XMLDOM允许您使用DOM操作XMLType实例。">XMLType的PL / SQL DOM API（DBMS_XMLDOM）</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB4896"></a><a id="ADXDB4897"></a><a id="ADXDB4895"></a><div class="props_rev_3"><a id="GUID-4B7856FD-9104-497C-81F1-0B3C3F7DE81F" name="GUID-4B7856FD-9104-497C-81F1-0B3C3F7DE81F"></a><h4 id="ADXDB-GUID-4B7856FD-9104-497C-81F1-0B3C3F7DE81F" class="sect4"><span class="enumeration_section">11.2.12</span> XMLType的PL / SQL DOM API  - 示例</h4>
                  <div>
                     <p>提供了使用PL / SQL DOM API for <code class="codeph">XMLType</code>示例。
                     </p>
                     <div class="section">
                        <p>在完成实例时，请记住为<span class="italic">每个</span> <code class="codeph">DOMDocument</code>实例调用过程<code class="codeph">freeDocument</code> 。此过程释放文档及其所有节点。即使在释放<code class="codeph">DOMDocument</code>实例之后，您仍然可以访问构建<code class="codeph">DOMDocument</code>实例的<code class="codeph">XMLType</code>实例。
                        </p>
                        <p><a href="PLSQL-APIs-for-XMLType.html#GUID-4B7856FD-9104-497C-81F1-0B3C3F7DE81F__CHDHAJEC">例11-1</a>在动态存储器中创建XML文档的分层表示：DOM文档。
                        </p>
                        <p><a href="PLSQL-APIs-for-XMLType.html#GUID-4B7856FD-9104-497C-81F1-0B3C3F7DE81F__CHDHAJEC">例11-1</a>使用DOM文档的<span class="italic">句柄</span>来操作它：打印它，更改它的一部分，并在更改后再次打印它。通过其句柄操作DOM文档也间接影响文档表示的XML数据，因此在更改后查询该数据会显示更改的结果。
                        </p>
                        <p>DOM文档是使用PL / SQL函数<code class="codeph">newDOMDocument</code>从<code class="codeph">XMLType</code>变量创建的。使用函数<code class="codeph">makeNode</code>创建此文档的句柄。使用函数<code class="codeph">writeToBuffer</code>将文档写入<code class="codeph">VARCHAR2</code>缓冲区，并使用<code class="codeph">DBMS_OUTPUT.put_line</code>打印缓冲区。
                        </p>
                        <p>在使用各种<code class="codeph">DBMS_XMLDOM</code>过程操作文档之后，将<code class="codeph">XMLType</code>变量中的（已更改的）数据插入到表中并进行查询，以显示更改。只有当数据插入到数据库表中时才会变为持久性。在那之前，它只存在于内存中。数据库查询是在文档（ <code class="codeph">DOMDocument</code>实例）从动态内存中释放之后进行的，这一事实表明了这种持久性。
                        </p>
                        <p><a href="PLSQL-APIs-for-XMLType.html#GUID-4B7856FD-9104-497C-81F1-0B3C3F7DE81F__BEIDGEJC">示例11-2</a>创建一个空DOM文档，然后将一个元素节点（ <code class="codeph">&lt;ELEM&gt;</code> ）添加到文档中。<code class="codeph">DBMS_XMLDOM</code> API节点过程用于获取元素节点的名称（ <code class="codeph">&lt;ELEM&gt;</code> ），值（ <code class="codeph">NULL</code> ）和类型（ <code class="codeph">1</code> =元素节点）。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-4B7856FD-9104-497C-81F1-0B3C3F7DE81F__CHDHAJEC">
                        <p class="titleinexample">示例11-1创建和操作DOM文档</p><pre class="pre codeblock"><code>CREATE TABLE person OF XMLType; DECLARE var XMLType; doc DBMS_XMLDOM.DOMDocument; ndoc DBMS_XMLDOM.DOMNode; docelem DBMS_XMLDOM.DOMElement; node DBMS_XMLDOM.DOMNode; childnode DBMS_XMLDOM.DOMNode; nodelist DBMS_XMLDOM.DOMNodelist; buf VARCHAR2（2000）; BEGIN var：= XMLType（'&lt;PERSON&gt; &lt;NAME&gt; <span class="bold">ramesh</span> &lt;/ NAME&gt; &lt;/ PERSON&gt;'）; - 创建DOMDocument句柄doc：= DBMS_XMLDOM.newDOMDocument（var）; ndoc：= DBMS_XMLDOM.makeNode（doc）; DBMS_XMLDOM.writeToBuffer（ndoc，buf）; DBMS_OUTPUT.put_line（' <span class="bold">Before：</span> '|| buf）; docelem：= DBMS_XMLDOM.getDocumentElement（doc）; - 访问元素nodelist：= DBMS_XMLDOM.getElementsByTagName（docelem，' <span class="bold">NAME</span> '）; node：= DBMS_XMLDOM.item（nodelist，0）; childnode：= DBMS_XMLDOM.getFirstChild（node）; - 操作元素DBMS_XMLDOM.setNodeValue（childnode，' <span class="bold">raj</span> '）; DBMS_XMLDOM.writeToBuffer（ndoc，buf）; DBMS_OUTPUT.put_line（' <span class="bold">After：</span> '|| buf）; DBMS_XMLDOM.freeDocument（DOC）; INSERT INTO VALUES（var）;结束; /</code></pre><p>这会产生以下输出：</p><pre class="oac_no_warn" dir="ltr">之前：&lt;PERSON&gt; &lt;NAME&gt; <span class="bold">ramesh</span> &lt;/ NAME&gt; &lt;/ PERSON&gt;之后：&lt;PERSON&gt; &lt;NAME&gt; <span class="bold">raj</span> &lt;/ NAME&gt; &lt;/ PERSON&gt;</pre><p>此查询确认数据已更改：</p><pre class="pre codeblock"><code>SELECT * FROM person; SYS_NC_ROWINFO $ --------------- &lt;PERSON&gt; &lt;NAME&gt; <span class="bold">raj</span> &lt;/ NAME&gt; &lt;/ PERSON&gt;选择了1行。
</code></pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-4B7856FD-9104-497C-81F1-0B3C3F7DE81F__BEIDGEJC">
                        <p class="titleinexample">示例11-2创建元素节点并获取相关信息</p><pre class="pre codeblock"><code>DECLARE doc DBMS_XMLDOM.DOMDocument; elem DBMS_XMLDOM.DOMElement; nelem DBMS_XMLDOM.DOMNode; BEGIN doc：= DBMS_XMLDOM.newDOMDocument; elem：= DBMS_XMLDOM.createElement（doc，'ELEM'）; nelem：= DBMS_XMLDOM.makeNode（elem）; DBMS_OUTPUT.put_line（'Node name ='|| DBMS_XMLDOM.getNodeName（nelem））; DBMS_OUTPUT.put_line（'Node value ='|| DBMS_XMLDOM.getNodeValue（nelem））; DBMS_OUTPUT.put_line（'Node type ='|| DBMS_XMLDOM.getNodeType（nelem））; DBMS_XMLDOM.freeDocument（DOC）;结束; /</code></pre><p>这会产生以下输出：</p><pre class="pre codeblock"><code>节点名称= ELEM节点值=节点类型= 1</code></pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="PLSQL-APIs-for-XMLType.html#GUID-C8B6BD89-F267-46C3-8656-99CFA052A198" title="XMLType的PL / SQL DOM API，DBMS_XMLDOM允许您使用DOM操作XMLType实例。">XMLType的PL / SQL DOM API（DBMS_XMLDOM）</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB4898"></a><div class="props_rev_3"><a id="GUID-27F60B86-33DC-4E4B-B870-DDCBCF7819F6" name="GUID-27F60B86-33DC-4E4B-B870-DDCBCF7819F6"></a><h4 id="ADXDB-GUID-27F60B86-33DC-4E4B-B870-DDCBCF7819F6" class="sect4"><span class="enumeration_section">11.2.13</span>使用DBMS_XMLDOM进行大型节点处理</h4>
                  <div>
                     <p>Oracle XML DB提供了抽象流和流操作方法，可用于处理大于64 K字节的XML节点。</p>
                     <p>在Oracle Database 11g第1版（11.1）之前，Oracle XML DB处理的每个文本节点或属性值的大小限制为64 K字节。从版本11.1开始，此限制不再适用。</p>
                     <p>要克服此大小限制并允许节点包含图形文件，PDF文件和多字节字符编码，可以使用以下抽象流。这些抽象的PL / SQL流类似于相应的Java流。每个输入流都有一个关联的编写器或数据生成器，每个输出流都有一个关联的读取器或数据使用者。</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><span class="bold">二进制输入流：</span>这为数据使用者提供对源数据的只读访问，作为顺序（非数组）线性字节空间。消费者以二进制格式对底层源数据（无论什么表示）进行迭代读访问，即以未转换的“原始”格式对源数据进行读访问。消费者看到节点中存在的字节序列。没有规定源数据的格式或表示。特别是，没有相关的字符集。
                           </p>
                        </li>
                        <li>
                           <p><span class="bold">二进制输出流：</span>这为数据生成者提供了对目标数据的只写访问，作为顺序（非数组）线性字节空间。生产者对二进制格式的目标数据进行迭代写访问，即以纯二进制格式对目标数据进行写访问，完全没有数据语义。生产者传递一系列字节，目标数据被这些字节替换。不会发生数据转换。
                           </p>
                        </li>
                        <li>
                           <p><span class="bold">字符输入流：</span>这提供了对源数据的数据消费者迭代只读访问，作为字符的顺序（非数组）线性空间，与源数据的表示和格式无关。源数据的转换可能会也可能不会发生。
                           </p>
                        </li>
                        <li>
                           <p><span class="bold">字符输出流：</span>这为数据生成者提供了对目标数据的迭代只写访问，作为字符的顺序（非数组）线性空间。生产者传递一系列字符，目标数据被这个字符序列替换。传递的数据的转换可能会也可能不会发生。
                           </p>
                        </li>
                     </ul>
                     <p>每个输入流都有以下抽象方法：打开，读取和关闭。每个输出流都有以下抽象方法：open，write，flush和close。对于输出流，必须在物理写入任何节点之前关闭流。</p>
                     <p>有四种通用节点访问模型，用于读写。每种访问模型都有二进制和字符版本。在数据类型<code class="codeph">DOMNode</code>上定义的二进制和字符流方法实现了这些访问模型。
                     </p>
                     <p>您的应用程序充当客户端，解析器作为其服务提供者。解析器模式确定解析器或应用程序是否驱动流数据流。</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>对于处于推送模式的解析器，您的应用程序将数据推送到输出流中的解析器，解析器返回所请求操作的结果。</p>
                        </li>
                        <li>
                           <p>对于处于拉模式的解析器，您的应用程序会从输入流中的解析器中提取数据。流中的每个数据项都是解析事件的结果。</p>
                        </li>
                     </ul>
                     <p>每个访问模型都在一个单独的部分中描述，并解释了在大型节点上运行的<code class="codeph">DBMS_XMLDOM</code>包中的PL / SQL函数和过程。每个子程序的名称反映它是读取（“获取”）还是写入（“设置”）数据，以及解析器是用于推（“推”）还是拉（拉）模式。
                     </p>
                     <p>除了get-push和set-pull访问模型（无论是二进制还是字符）之外，Oracle提供了一个可以使用的具体流（隐式）。对于get-push和set-pull，您必须定义Oracle提供的抽象流类型的子类型，并且必须实现其访问方法（打开，关闭等）。对于get-push和set-pull，然后实例化您的流类型并将您的流作为访问方法的参数提供。因此，例如，您可以使用<code class="codeph">my_node.getNodeValueAsCharacterStream(my-stream)</code>进行get-push，但只使用<code class="codeph">my_node.getNodeValueAsCharacterStream()</code>进行get-pull。后者不需要显式的流参数，因为使用了Oracle提供的具体流。
                     </p>
                     <div class="infoboxnote" id="GUID-27F60B86-33DC-4E4B-B870-DDCBCF7819F6__GUID-B6406E01-9925-490E-B062-02B9C26E18E6">
                        <p class="notep1">注意：</p>
                        <p>访问字符数据流时，您使用的访问方法确定所访问节点的明显字符集。如果使用Java访问流，则Java程序看到的字符集是UCS2（或应用程序指定的字符集）。如果使用PL / SQL访问流，则PL / SQL程序看到的字符集是数据库会话字符集（或应用程序指定的字符集）。但是，在所有情况下，XML数据都存储在数据库字符集的数据库中。</p>
                        <p>在以下描述中，C1是存储在数据库中的节点的字符集，C2是程序看到的节点的字符集。</p>
                     </div>
                     <div class="section"></div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="PLSQL-APIs-for-XMLType.html#GUID-F9CC00ED-132E-451F-94D4-953161F87482" title="在此模型中，使用处于推送模式的解析器检索DOM节点的值。Oracle XML DB将节点数据写入解析器读取的输出流。">用于大型节点处理的Get-Push模型</a></li>
                           <li><a href="PLSQL-APIs-for-XMLType.html#GUID-44A8FF6E-4CE5-4FEA-AC55-AAEACE8CCC57" title="在此模型中，使用处于拉模式的解析器检索DOM节点的值。Oracle XML DB从解析器编写的输入流中读取事件数据。">用于大型节点处理的Get-Pull模型</a></li>
                           <li><a href="PLSQL-APIs-for-XMLType.html#GUID-43443083-4ED7-4E62-A450-E60CE2524AD7" title="在此模型中，使用处于拉模式的解析器设置DOM节点的值。Oracle XML DB从解析器编写的输入流中读取事件数据。">用于大型节点处理的Set-Pull模型</a></li>
                           <li><a href="PLSQL-APIs-for-XMLType.html#GUID-DCBCC32B-3529-49A0-BF23-1BFF9062367D" title="在此模型中，使用处于推送模式的解析器设置DOM节点的值。Oracle XML DB将节点数据写入解析器读取的输出流。">用于大型节点处理的Set-Push模型</a></li>
                           <li><a href="Java-DOM-API-for-XMLType.html#GUID-292AD380-743C-4E36-BDD1-039A279006C0" title="Oracle XML DB提供了抽象流和流操作方法，可用于处理大于64 K字节的XML节点。使用Java类XMLNode和XMLAttr以及thick或kprb连接来操作大型节点。">使用Java进行大型XML节点处理</a></li>
                        </ul>
                     </div>
                     <div class="infoboxnotealso" id="GUID-27F60B86-33DC-4E4B-B870-DDCBCF7819F6__GUID-561B5F2B-5CE8-42C6-AD4A-5C48A675ACC8">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/adxdb&amp;id=ARPLS399" target="_blank"><span><cite>Oracle数据库PL / SQL包和类型参考</cite></span></a></p>
                           </li>
                           <li>
                              <p>有关用于处理大型节点的Java函数的信息，请参阅<a href="../jaxml/index.html" target="_blank"><span><cite>Oracle数据库XML Java API参考</cite></span></a></p>
                           </li>
                           <li>
                              <p>有关用于处理大型节点的C函数的信息，请参阅<a href="../caxml/package-DOM-API.html#CAXML-GUID-1A4B5DBB-1B8C-4963-AEC4-C5DC0709C325" target="_blank"><span><cite>Oracle Database XML C API参考</cite></span></a></p>
                           </li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="PLSQL-APIs-for-XMLType.html#GUID-C8B6BD89-F267-46C3-8656-99CFA052A198" title="XMLType的PL / SQL DOM API，DBMS_XMLDOM允许您使用DOM操作XMLType实例。">XMLType的PL / SQL DOM API（DBMS_XMLDOM）</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB4900"></a><a id="ADXDB4901"></a><a id="ADXDB4899"></a><div class="props_rev_3"><a id="GUID-F9CC00ED-132E-451F-94D4-953161F87482" name="GUID-F9CC00ED-132E-451F-94D4-953161F87482"></a><h4 id="ADXDB-GUID-F9CC00ED-132E-451F-94D4-953161F87482" class="sect4"><span class="enumeration_section">11.2.14</span>用于大型节点处理的Get-Push模型</h4>
                  <div>
                     <p>在此模型中，使用处于推送模式的解析器检索DOM节点的值。Oracle XML DB将节点数据写入解析器读取的输出流。</p>
                     <p>要读取此模型中的节点值，应用程序将创建二进制输出流或<span>字符输出流</span> ，并将其传递给Oracle XML DB。在这种情况下，源数据是节点值。Oracle XML DB通过将节点数据添加到流来填充输出流。如果流是<span>字符输出流</span> ，则字符集C2是会话字符集，并且如果需要，节点数据从C1转换为C2。此外，节点的数据类型可以是Oracle XML DB支持的任何数据类型。如果节点数据类型不是字符数据，则首先将节点数据转换为C2中的字符数据。如果是<span>二进制输出流</span> ，则节点的数据类型必须是<code class="codeph">RAW</code>或<code class="codeph">BLOB</code> 。</p>
                     <p>在这种情况下使用的<code class="codeph">DBMS_XMLDOM</code>包的过程是：</p><pre class="pre codeblock"><code>PROCEDURE getNodeValueAsBinaryStream（n IN DBMS_XMLDOM.domnode，value IN SYS.utl_BinaryOutputStream）;</code></pre><p>应用程序传递<code class="codeph">SYS.utl_BinaryOutputStream</code>的实现，Oracle XML DB将该节点的内容写入其中。节点的数据类型必须是<code class="codeph">RAW</code>或<code class="codeph">CLOB</code> ，否则引发异常。
                     </p><pre class="pre codeblock"><code>PROCEDURE getNodeValueAsCharacterStream（n IN DBMS_XMLDOM.domnode，value IN SYS.utl_CharacterOutputStream）;</code></pre><p>必要时，节点数据将转换为会话字符集，然后“推送”到<code class="codeph">SYS.utl_CharacterOutputStream</code> 。
                     </p>
                     <p>以下示例片段说明了将节点值读取为二进制数据并在用户定义的<code class="codeph">SYS.utl_BinaryOutPutStream</code>子类型中驱动write方法，该子类型称为<code class="codeph">MyBinaryOutputStream</code> ：</p>
                     <div class="example" id="GUID-F9CC00ED-132E-451F-94D4-953161F87482__GUID-B18213EB-09FC-4CEE-B98F-61F3C7B32D06">
                        <p class="titleinexample">示例11-3创建SYS.util_BinaryOutputStream（）的用户定义子类型</p><pre class="pre codeblock"><code>在SYS.utl_BinaryOutputStream下创建类型MyBinaryOutputStream（构造函数MyBinaryOutputStream（）返回自身结果，成员函数写入（字节IN RAW）返回INTEGER，成员程序写入（字节IN RAW，偏移IN INTEGER，长度IN OUT INTEGER），成员函数冲洗（）RETURN BOOLEAN，会员功能close（）RETURN BOOLEAN）; ）; - 在这里放置实现这些方法的代码......</code></pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-F9CC00ED-132E-451F-94D4-953161F87482__GUID-11572A36-0C31-41B8-A3A6-691A218EC1F5">
                        <p class="titleinexample">示例11-4使用用户定义的流检索节点值</p><pre class="pre codeblock"><code>DECLARE ostream MyBinaryOutputStream = MyBinaryOutputStream（）; node DBMS_XMLDOM.domnode; ...开始 ...- 这将驱动MyBinaryOutputStream中的写入方法， - 刷新数据，并在完全写入值后关闭流。DBMS_XMLDOM.getNodeValueAsBinaryStream（node，ostream）; ...结束;</code></pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="PLSQL-APIs-for-XMLType.html#GUID-C8B6BD89-F267-46C3-8656-99CFA052A198" title="XMLType的PL / SQL DOM API，DBMS_XMLDOM允许您使用DOM操作XMLType实例。">XMLType的PL / SQL DOM API（DBMS_XMLDOM）</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB4903"></a><a id="ADXDB4904"></a><a id="ADXDB4902"></a><div class="props_rev_3"><a id="GUID-44A8FF6E-4CE5-4FEA-AC55-AAEACE8CCC57" name="GUID-44A8FF6E-4CE5-4FEA-AC55-AAEACE8CCC57"></a><h4 id="ADXDB-GUID-44A8FF6E-4CE5-4FEA-AC55-AAEACE8CCC57" class="sect4"><span class="enumeration_section">11.2.15</span>大节点处理的Get-Pull模型</h4>
                  <div>
                     <p>在此模型中，使用处于拉模式的解析器检索DOM节点的值。Oracle XML DB从解析器编写的输入流中读取事件数据。</p>
                     <p>要读取此模型中节点的值，Oracle XML DB会创建<span>二进制输入流</span>或字符输入流，并将其返回给调用者。<span>字符输入流</span>的字符集C2是当前会话字符集。当调用者从流中提取节点数据时，Oracle XML DB会填充输入流，因此Oracle XML DB再次成为数据的生产者。如果流是<span>字符输入流</span> ，则节点数据类型可以是Oracle XML DB支持的任何节点数据类型，并且如果必要，则将节点数据从C1转换为C2。如果节点数据是非字符的，则将其转换为C2中的字符。如果是<span>二进制输入流</span> ，则节点的数据类型必须是<code class="codeph">RAW</code>或<code class="codeph">BLOB</code> 。</p>
                     <p>在这种情况下使用的<code class="codeph">DBMS_XMLDOM</code>包的功能是<code class="codeph">getNodeValueAsBinaryStream</code>和<code class="codeph">getNodeValueAsCharacterStream</code> 。
                     </p><pre class="oac_no_warn" dir="ltr">FUNCTION getNodeValueAsBinaryStream（n IN DBMS_XMLDOM.domnode）RETURN SYS.utl_BinaryInputStream;</pre><p>此函数返回新PL / SQL <code class="codeph">SYS.utl_BinaryInputStream</code>的实例，该实例可使用定义的方法读取，如<a href="PLSQL-APIs-for-XMLType.html#GUID-43443083-4ED7-4E62-A450-E60CE2524AD7" title="在此模型中，使用处于拉模式的解析器设置DOM节点的值。Oracle XML DB从解析器编写的输入流中读取事件数据。">“大型节点处理的Set-Pull模型</a> ”一节中所述。节点数据类型必须是<code class="codeph">RAW</code>或<code class="codeph">BLOB</code> ，否则引发异常。
                     </p><pre class="oac_no_warn" dir="ltr">FUNCTION getNodeValueAsCharacterStream（n IN DBMS_XMLDOM.domnode）RETURN SYS.utl_CharacterInputStream;</pre><p>此函数返回可使用已定义方法读取的新PL / SQL <code class="codeph">SYS.utl_CharacterInputStream</code>的实例。如果节点数据是字符，则将其转换为当前会话字符集。如果节点数据不是字符数据，则首先将其转换为字符数据。
                     </p>
                     <p><a href="PLSQL-APIs-for-XMLType.html#GUID-44A8FF6E-4CE5-4FEA-AC55-AAEACE8CCC57__CHDBFEGJ">例11-5</a>说明了以50字节为增量读取节点值作为二进制数据：</p>
                     <p><a href="PLSQL-APIs-for-XMLType.html#GUID-44A8FF6E-4CE5-4FEA-AC55-AAEACE8CCC57__CHDBIJAC">例11-6</a>说明了以50个字符为增量读取节点值作为字符数据：</p>
                     <div class="example" id="GUID-44A8FF6E-4CE5-4FEA-AC55-AAEACE8CCC57__CHDBFEGJ">
                        <p class="titleinexample">例11-5二进制数据的获取</p><pre class="oac_no_warn" dir="ltr">DECLARE istream SYS.utl_BinaryInputStream; node DBMS_XMLDOM.domnode;缓冲原料（50）; numBytes pls_integer; ...开始 ...istream：= DBMS_XMLDOM.getNodeValueAsBinaryStream（node）; - 以50字节块的形式读取流LOOP numBytes：= 50; istream.read（buffer，numBytes）;如果numBytes &lt;= 0则退出;万一; - 在缓冲区END LOOP中处理下一个50字节的节点值...结束;</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-44A8FF6E-4CE5-4FEA-AC55-AAEACE8CCC57__CHDBIJAC">
                        <p class="titleinexample">例11-6字符数据的获取</p><pre class="oac_no_warn" dir="ltr">DECLARE istream SYS.utl_CharacterInputStream; node DBMS_XMLDOM.domnode; buffer varchar2（50）; numChars pls_integer; ...开始 ...istream：= DBMS_XMLDOM.getNodeValueAsCharacterStream（node）; - 以50个字符的块读取流LOOP numChars：= 50; istream.read（buffer，numChars）;如果numChars &lt;= 0则退出;万一; - 在缓冲区END LOOP中处理接下来的50个字符的节点值...结束;</pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="PLSQL-APIs-for-XMLType.html#GUID-C8B6BD89-F267-46C3-8656-99CFA052A198" title="XMLType的PL / SQL DOM API，DBMS_XMLDOM允许您使用DOM操作XMLType实例。">XMLType的PL / SQL DOM API（DBMS_XMLDOM）</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB4906"></a><a id="ADXDB4905"></a><div class="props_rev_3"><a id="GUID-43443083-4ED7-4E62-A450-E60CE2524AD7" name="GUID-43443083-4ED7-4E62-A450-E60CE2524AD7"></a><h4 id="ADXDB-GUID-43443083-4ED7-4E62-A450-E60CE2524AD7" class="sect4"><span class="enumeration_section">11.2.16</span>大型节点处理的集拉模型</h4>
                  <div>
                     <p>在此模型中，使用处于拉模式的解析器设置DOM节点的值。Oracle XML DB从解析器编写的输入流中读取事件数据。</p>
                     <p>要在此模式下编写节点值，应用程序将创建<span>二进制输入流</span>或<span>字符输入流</span> ，并将其传递给Oracle XML DB。</p>
                     <p><span>字符输入流</span> C2的字符集是会话字符集。Oracle XML DB从输入流中提取数据并填充节点。如果流是<span>字符输入流</span> ，则该节点的数据类型可以是Oracle XML DB支持的任何数据类型。如果节点的数据类型不是字符，则首先将流数据转换为节点数据类型。如果节点数据类型是字符，则不进行转换，因此节点数据保留在字符集C2中。如果流是<code class="codeph">binary input stream</code> ，则节点的数据类型必须是<code class="codeph">RAW</code>或<code class="codeph">BLOB</code>并且不进行转换。
                     </p>
                     <p>在这种情况下使用的<code class="codeph">DBMS_XMLDOM</code>包的过程是<code class="codeph">setNodeValueAsBinaryStream</code>和<code class="codeph">setNodeValueAsCharacterStream</code> 。
                     </p><pre class="pre codeblock"><code>PROCEDURE setNodeValueAsBinaryStream（ <span class="italic">n</span> IN DBMS_XMLDOM.domnode， <span class="italic">value</span> IN SYS.utl_BinaryInputStream）;</code></pre><p>应用程序传递<code class="codeph">SYS.utl_BinaryInputStream</code>的实现，Oracle XML DB从该实现中读取数据以填充节点。节点的数据类型必须是<code class="codeph">RAW</code>或<code class="codeph">BLOB</code> ，否则引发异常。
                     </p><pre class="pre codeblock"><code>PROCEDURE setNodeValueAsCharacterStream（ <span class="italic">n</span> IN DBMS_XMLDOM.domnode， <span class="italic">value</span> IN SYS.utl_CharacterInputStream）;</code></pre><p>应用程序传递<code class="codeph">SYS.utl_CharacterInputStream</code>的实现，Oracle XML DB从该实现中读取以填充节点。节点的数据类型可以是Oracle XML DB支持的任何有效类型。如果它是非字符数据类型，则从流中读取的字符数据将转换为节点的数据类型。如果节点的数据类型是字符或<code class="codeph">CLOB</code> ，则不会发生转换，并且节点的字符集将成为PL / SQL会话的字符集。
                     </p>
                     <p><a href="PLSQL-APIs-for-XMLType.html#GUID-43443083-4ED7-4E62-A450-E60CE2524AD7__CHDFDBIG">例11-7</a>说明了将节点值设置为由用户定义的<code class="codeph">SYS.utl_BinaryInputStream</code>子类型中定义的读取方法生成的二进制数据，该子类型称为<code class="codeph">MyBinaryInputStream</code> ：</p>
                     <p>您可以使用<code class="codeph">MyBinaryInputStream</code>类型的对象来设置节点的值，如下所示：</p><pre class="pre codeblock"><code>DECLARE istream MyBinaryInputStream = MyBinaryInputStream（）; node DBMS_XMLDOM.domnode; ...开始 ...- 这将驱动MyBinaryInputStream中的读取方法DBMS_XMLDOM.setNodeValueAsBinaryStream（node，istream）; ...结束;</code></pre><div class="example" id="GUID-43443083-4ED7-4E62-A450-E60CE2524AD7__CHDFDBIG">
                        <p class="titleinexample">例11-7二进制数据的设置 - 拉取</p><pre class="pre codeblock"><code>在SYS.utl_BinaryInputStream下创建类型MyBinaryInputStream（构造函数MyBinaryInputStream（）返回自身结果，成员函数read（）RETURN RAW，成员程序读取（字节IN OUT RAW，numbytes IN OUT INTEGER），成员程序读取（字节IN OUT RAW， offset IN INTEGER，length IN OUT INTEGER），MEMBER FUNCTION close（）RETURN BOOLEAN）;</code></pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="PLSQL-APIs-for-XMLType.html#GUID-C8B6BD89-F267-46C3-8656-99CFA052A198" title="XMLType的PL / SQL DOM API，DBMS_XMLDOM允许您使用DOM操作XMLType实例。">XMLType的PL / SQL DOM API（DBMS_XMLDOM）</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB4908"></a><a id="ADXDB4907"></a><div class="props_rev_3"><a id="GUID-DCBCC32B-3529-49A0-BF23-1BFF9062367D" name="GUID-DCBCC32B-3529-49A0-BF23-1BFF9062367D"></a><h4 id="ADXDB-GUID-DCBCC32B-3529-49A0-BF23-1BFF9062367D" class="sect4"><span class="enumeration_section">11.2.17</span>用于大型节点处理的Set-Push模型</h4>
                  <div>
                     <p>在此模型中，使用处于推送模式的解析器设置DOM节点的值。Oracle XML DB将节点数据写入解析器读取的输出流。</p>
                     <p>要在此模式下写入新节点值，Oracle XML DB会创建<span>二进制输出流</span>或<span>字符输出流</span> ，并将其返回给调用者。<span>字符输出流</span> C2的字符集是当前会话字符集。调用者将数据推送到输出流，然后Oracle XML DB将其写入Oracle XML DB节点。如果流是<span>字符输出流</span> ，则节点的数据类型可以是Oracle XML DB支持的任何类型。在这种情况下，字符数据被转换为节点数据类型。如果节点数据类型是字符，则字符集C1变为C2。不会发生数据转换。如果流是<span>二进制输入流</span> ，则节点的数据类型必须是<code class="codeph">RAW</code>或<code class="codeph">BLOB</code> 。在这种情况下，在没有数据转换的情况下读取流。
                     </p>
                     <p>在这种情况下使用的<code class="codeph">DBMS_XMLDOM</code>包的过程是<code class="codeph">setNodeValueAsBinaryStream</code>和<code class="codeph">setNodeValueAsCharacterStream</code> 。
                     </p><pre class="pre codeblock"><code>FUNCTION setNodeValueAsBinaryStream（n IN DBMS_XMLDOM.domnode）RETURN SYS.utl_BinaryOutputStream;</code></pre><p>此函数返回<code class="codeph">SYS.utl_BinaryOutputStream</code>的实例，调用者可以将该节点值写入其中。节点的数据类型必须是<code class="codeph">RAW</code>或<code class="codeph">BLOB</code> ，否则引发异常。
                     </p><pre class="pre codeblock"><code>FUNCTION setNodeValueAsCharacterStream（n IN DBMS_XMLDOM.domnode）RETURN SYS.utl_CharacterOutputStream;</code></pre><p>此函数返回PL / SQL <code class="codeph">SYS.utl_CharacterOutputStream</code>类型的实例，调用者可以将该节点值写入该实例。节点的数据类型可以是任何有效的Oracle XML DB数据类型。如果类型不是字符或<code class="codeph">CLOB</code> ，则写入流的字符数据将转换为节点数据类型。如果节点的数据类型是字符或<code class="codeph">CLOB</code> ，则写入流的字符数据将从PL / SQL会话字符集转换为节点的字符集</p>
                     <p><a href="PLSQL-APIs-for-XMLType.html#GUID-DCBCC32B-3529-49A0-BF23-1BFF9062367D__CHDCEHBB">例11-8</a>说明了通过将50个字节的段写入<code class="codeph">SYS.utl_BinaryOutputStream</code> ，将节点的值设置为二进制数据：</p>
                     <div class="example" id="GUID-DCBCC32B-3529-49A0-BF23-1BFF9062367D__CHDCEHBB">
                        <p class="titleinexample">例11-8二进制数据的Set-Push</p><pre class="pre codeblock"><code>DECLARE ostream SYS.utl_BinaryOutputStream; node DBMS_XMLDOM.domnode;缓冲原料（500）;段生（50）; numBytes pls_integer; offset pls_integer; ...开始 ...ostream：= DBMS_XMLDOM.setNodeValueAsBinaryStream（node）; offset：= 0;长度：= 500; - 以50字节块的形式写入流LOOP numBytes：= 50; - 获取下一个50字节的缓冲区ostream.write（segment，offset，numBytes）; length：= length  -  numBytes; IF长度&lt;= 0然后退出;万一; END LOOP ostream.close（）; ...结束;</code></pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="PLSQL-APIs-for-XMLType.html#GUID-C8B6BD89-F267-46C3-8656-99CFA052A198" title="XMLType的PL / SQL DOM API，DBMS_XMLDOM允许您使用DOM操作XMLType实例。">XMLType的PL / SQL DOM API（DBMS_XMLDOM）</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB4909"></a><div class="props_rev_3"><a id="GUID-A0C33052-CAEA-4678-B3AA-C0D2EA7A56F7" name="GUID-A0C33052-CAEA-4678-B3AA-C0D2EA7A56F7"></a><h4 id="ADXDB-GUID-A0C33052-CAEA-4678-B3AA-C0D2EA7A56F7" class="sect4"><span class="enumeration_section">11.2.18</span>确定大型节点处理的二进制流或字符流</h4>
                  <div>
                     <p>您可以使用子程序<code class="codeph">DBMS_XMLDOM.useBinaryStream</code>来确定是使用字符流还是二进制流来访问大型节点的内容。
                     </p>
                     <div class="section"><pre class="pre codeblock"><code>功能useBinaryStream（n IN DBMS_XMLDOM.domnode）RETURN BOOLEAN;</code></pre><p>如果节点的数据类型是<code class="codeph">RAW</code>或<code class="codeph">BLOB</code> ，则此函数返回<code class="codeph">TRUE</code> ，以便可以使用<code class="codeph">SYS.utl_BinaryInputStream</code>或<code class="codeph">SYS.utl_BinaryOutputStream</code>读取或写入节点值。如果返回值<code class="codeph">FALSE</code> ，则只能使用<code class="codeph">SYS.utl_CharacterInputStream</code>或<code class="codeph">SYS.utl_CharacterOutputStream</code>访问节点值。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="PLSQL-APIs-for-XMLType.html#GUID-C8B6BD89-F267-46C3-8656-99CFA052A198" title="XMLType的PL / SQL DOM API，DBMS_XMLDOM允许您使用DOM操作XMLType实例。">XMLType的PL / SQL DOM API（DBMS_XMLDOM）</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div><a id="ADXDB4913"></a><a id="ADXDB4914"></a><a id="ADXDB4910"></a><div class="props_rev_3"><a id="GUID-3EA684A3-2149-4550-924A-35CD5246ED90" name="GUID-3EA684A3-2149-4550-924A-35CD5246ED90"></a><h3 id="ADXDB-GUID-3EA684A3-2149-4550-924A-35CD5246ED90" class="sect3"><span class="enumeration_section">11.3</span>用于XMLType的PL / SQL分析器API（DBMS_XMLPARSER）</h3>
               <div>
                  <p>用于<code class="codeph">XMLType</code>的PL / SQL Parser API（ <code class="codeph">DBMS_XMLPARSER</code> ）构建可由PL / SQL API访问的解析结果树。如果解析失败，则会引发错误。
                  </p>
                  <p>称为XML解析器或处理器的软件模块读取XML文档并提供对其内容和结构的访问。XML解析器通常代表另一个模块（通常是应用程序）执行其工作。</p>
                  <p>XML文档由称为<span class="italic">实体</span>的存储单元<span class="italic">组成</span> ，包含已解析或未解析的数据。解析数据由字符组成，其中一些字符构成字符数据，其中一些字符作为标记。标记编码文档存储布局和逻辑结构的描述。XML提供了一种对存储布局和逻辑结构施加约束的机制。
                  </p>
                  <p><a href="PLSQL-APIs-for-XMLType.html#GUID-3EA684A3-2149-4550-924A-35CD5246ED90__I1043623">图11-2</a>说明了如何使用PL / SQL Parser for <code class="codeph">XMLType</code> （ <code class="codeph">DBMS_XMLPARSER</code> ）。这些是步骤：</p>
                  <ol>
                     <li>
                        <p>使用PL / SQL方法<code class="codeph">newParser()</code>构造解析器实例。
                        </p>
                     </li>
                     <li>
                        <p>使用PL / SQL方法解析XML文档，例如<code class="codeph">parseBuffer()</code> ， <code class="codeph">parseClob()</code>和<code class="codeph">parse(URI)</code> 。如果输入不是有效的XML文档，则会引发错误。
                        </p>
                     </li>
                     <li>
                        <p>在解析器上调用PL / SQL函数<code class="codeph">getDocument</code>以获取<code class="codeph">DOMDocument</code>接口。
                        </p>
                     </li>
                  </ol>
                  <div class="figure" id="GUID-3EA684A3-2149-4550-924A-35CD5246ED90__I1043623">
                     <p class="titleinfigure">图11-2为XMLType使用PL / SQL Parser API</p><img src="img/adxdb015.gif" width="188" alt="下面是图11-2的描述" title="下面是图11-2的描述" longdesc="img_text/adxdb015.html"><br><a href="img_text/adxdb015.html">“图11-2为XMLType使用PL / SQL Parser API”的说明</a></div>
                  <!-- class="figure" -->
                  <p><a href="PLSQL-APIs-for-XMLType.html#GUID-3EA684A3-2149-4550-924A-35CD5246ED90__BEIGFDHI">例11-9</a>解析一个简单的XML文档。它创建了一个XML解析器（ <code class="codeph">DBMS_XMLPARSER.parser</code>实例），并使用它来解析变量<code class="codeph">indoc</code>的XML文档（文本）。解析创建一个DOM文档，使用<code class="codeph">DBMS_XMLPARSER.getDocument</code>从解析器中检索该文档。创建包含整个文档的DOM节点，并打印节点。在释放（销毁）DOM文档之后，使用<code class="codeph">DBMS_XMLPARSER.freeParser</code>释放解析器实例。
                  </p>
                  <div class="infoboxnote" id="GUID-3EA684A3-2149-4550-924A-35CD5246ED90__GUID-DEB9E8FE-378C-483A-8490-B3573CC7FCB5">
                     <p class="notep1">注意：</p>
                     <p>方法不支持<code class="codeph">DBMS_XMLPARSER.setErrorLog()</code> 。
                     </p>
                  </div>
                  <div class="infoboxnotealso" id="GUID-3EA684A3-2149-4550-924A-35CD5246ED90__GUID-CAB21705-BD3A-438B-A983-82FD20A2FED4">
                     <p class="notep1">也可以看看：</p>
                     <p><a href="../arpls/DBMS_XMLPARSER.html#ARPLS375" target="_blank"><span><cite>Oracle Database PL / SQL包和类型参考，</cite></span></a>用于描述各个<code class="codeph">DBMS_XMLPARSER</code>方法</p>
                  </div>
                  <div class="example" id="GUID-3EA684A3-2149-4550-924A-35CD5246ED90__BEIGFDHI">
                     <p class="titleinexample">示例11-9解析XML文档</p><pre class="oac_no_warn" dir="ltr">DECLARE indoc VARCHAR2（2000）; indomdoc DBMS_XMLDOM.DOMDocument; innode DBMS_XMLDOM.DOMNode; myparser DBMS_XMLPARSER.parser; buf VARCHAR2（2000）; BEGIN indoc：='&lt;emp&gt; &lt;name&gt; De Selby &lt;/ name&gt; &lt;/ emp&gt;'; myParser：= DBMS_XMLPARSER.newParser; DBMS_XMLPARSER.parseBuffer（myParser，indoc）; indomdoc：= DBMS_XMLPARSER.getDocument（myParser）; innode：= DBMS_XMLDOM.makeNode（indomdoc）; DBMS_XMLDOM.writeToBuffer（innode，buf）; DBMS_OUTPUT.PUT_LINE（BUF）; DBMS_XMLDOM.freeDocument（indomdoc）; DBMS_XMLPARSER.freeParser（myParser）;结束; /</pre><p>这会产生以下输出：</p><pre class="oac_no_warn" dir="ltr">&lt;emp&gt; &lt;name&gt; De Selby &lt;/ name&gt; &lt;/ emp&gt;</pre></div>
                  <!-- class="example" -->
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="PLSQL-APIs-for-XMLType.html#GUID-2D5B2D47-9CFF-49D0-9BD8-114BBE48A289" title="有几个PL / SQL包为XMLType提供API。">XMLType的PL / SQL API</a></p>
                     </div>
                  </div>
               </div>
               
            </div><a id="ADXDB4915"></a><div class="props_rev_3"><a id="GUID-0E3358AF-0819-4B17-AF0B-793E96DA5EB9" name="GUID-0E3358AF-0819-4B17-AF0B-793E96DA5EB9"></a><h3 id="ADXDB-GUID-0E3358AF-0819-4B17-AF0B-793E96DA5EB9" class="sect3"><span class="enumeration_section">11.4</span>用于XMLType的PL / SQL XSLT处理器（DBMS_XSLPROCESSOR）</h3>
               <div>
                  <p>您可以使用PL / SQL包<code class="codeph">DBMS_XSLPROCESSOR</code>将一个XML文档转换为另一个XML文档，或将XML数据转换为HTML，PDF或其他格式。该包遍历文档的DOM树，并对其应用可扩展样式表语言转换（XSLT）语句以生成转换后的文档。
                  </p>
                  <p>W3C XSL建议书描述了将源树转换为结果树的规则。在XSL中表示的转换称为<strong class="term">XSLT样式表</strong> 。指定的转换是通过将模式与XSLT样式表中定义的模板相关联来实现的。实例化模板以创建结果树的一部分。XSLT广泛用于将XML数据转换为HTML以进行Web浏览器显示。
                  </p>
                  <div class="infoboxnote" id="GUID-0E3358AF-0819-4B17-AF0B-793E96DA5EB9__GUID-FB8722D7-BA31-4BF7-AF82-334277CA24FF">
                     <p class="notep1">注意：</p>
                     <p>Oracle XML DB应用程序不需要单独的XML解析器。但是，需要外部处理的应用程序仍然可以首先使用XML Parser for PL / SQL来公开文档结构。Oracle XML Developer's Kit中的PL / SQL XML解析器解析XML文档（或独立的DTD），以便XML文档可以由应用程序处理，通常在客户端上运行。<code class="codeph">XMLType</code> PL / SQL API用于在服务器上运行并本机集成在数据库中的应用程序。在服务器上运行应用程序的好处包括性能改进和增强的访问和操作选项。
                     </p>
                  </div>
                  <div class="section"></div>
                  <!-- class="section" -->
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="PLSQL-APIs-for-XMLType.html#GUID-A12D2387-0268-4766-80B2-1BBDDDC77C8D">用于XMLType的PL / SQL XSLT处理器：功能</a><br>用于<code class="codeph">XMLType</code> PL / SQL XSLT处理器（ <code class="codeph">DBMS_XSLPROCESSOR</code> ）遵循W3C XSLT最终建议（REC-xslt-19991116）。它提供了一种方便有效的方法，可以将单个XSL样式表应用于多个文档。
                     </li>
                     <li class="ulchildlink"><a href="PLSQL-APIs-for-XMLType.html#GUID-0C886A80-A2C1-4E02-8E80-B13D577F4AC3">为XMLType使用PL / SQL XSLT处理器API（DBMS_XSLPROCESSOR）</a><br>您可以创建一个XSLT处理器，从DOM文档构建<code class="codeph">STYLESHEET</code>对象，使用处理器和样式表转换文档，并使用<code class="codeph">STYLESHEET</code> API for <code class="codeph">XMLType</code>来操作XSLT处理的结果。
                     </li>
                  </ul>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="transformation-and-validation-of-XMLType-data.html#GUID-EC4E2212-67EF-425C-AB5E-D48E62EAB9A7" title="有几个Oracle SQL函数和XMLType API，用于使用XSLT样式表转换XMLType数据，以及根据XML模式验证XMLType实例。">XMLType数据的转换和验证</a></li>
                     </ul>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="PLSQL-APIs-for-XMLType.html#GUID-2D5B2D47-9CFF-49D0-9BD8-114BBE48A289" title="有几个PL / SQL包为XMLType提供API。">XMLType的PL / SQL API</a></p>
                     </div>
                  </div>
               </div>
               <a id="ADXDB4917"></a><div class="props_rev_3"><a id="GUID-A12D2387-0268-4766-80B2-1BBDDDC77C8D" name="GUID-A12D2387-0268-4766-80B2-1BBDDDC77C8D"></a><h4 id="ADXDB-GUID-A12D2387-0268-4766-80B2-1BBDDDC77C8D" class="sect4"><span class="enumeration_section">11.4.1</span>用于XMLType的PL / SQL XSLT处理器：功能</h4>
                  <div>
                     <p>用于<code class="codeph">XMLType</code> PL / SQL XSLT处理器（ <code class="codeph">DBMS_XSLPROCESSOR</code> ）遵循W3C XSLT最终建议（REC-xslt-19991116）。它提供了一种方便有效的方法，可以将单个XSL样式表应用于多个文档。
                     </p>
                     <p>PL / SQL包<code class="codeph">DBMS_XSLPROCESSOR</code>使用PL / SQL数据类型<code class="codeph">PROCESSOR</code>和<code class="codeph">STYLESHEET</code> ，它们特定于XSL处理器实现。Oracle XML DB支持所有<code class="codeph">DBMS_XSLPROCESSOR</code>方法， <span class="italic">但</span>方法<code class="codeph">setErrorLog()</code> 。
                     </p>
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-A12D2387-0268-4766-80B2-1BBDDDC77C8D__GUID-8D89DEF2-2483-46D6-8CC6-D2C19BE12EB0">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="../arpls/DBMS_XSLPROCESSOR.html#ARPLS379" target="_blank"><span><cite>Oracle Database PL / SQL包和类型参考，</cite></span></a>用于描述各个<code class="codeph">DBMS_XSLPROCESSOR</code>方法</p>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="PLSQL-APIs-for-XMLType.html#GUID-0E3358AF-0819-4B17-AF0B-793E96DA5EB9" title="您可以使用PL / SQL包DBMS_XSLPROCESSOR将一个XML文档转换为另一个XML文档，或将XML数据转换为HTML，PDF或其他格式。该包遍历文档的DOM树，并对其应用可扩展样式表语言转换（XSLT）语句以生成转换后的文档。">用于XMLType的PL / SQL XSLT处理器（DBMS_XSLPROCESSOR）</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB4919"></a><a id="ADXDB4920"></a><a id="ADXDB4918"></a><div class="props_rev_3"><a id="GUID-0C886A80-A2C1-4E02-8E80-B13D577F4AC3" name="GUID-0C886A80-A2C1-4E02-8E80-B13D577F4AC3"></a><h4 id="ADXDB-GUID-0C886A80-A2C1-4E02-8E80-B13D577F4AC3" class="sect4"><span class="enumeration_section">11.4.2</span>对XMLType使用PL / SQL XSLT处理器API（DBMS_XSLPROCESSOR）</h4>
                  <div>
                     <p>您可以创建一个XSLT处理器，从DOM文档构建<code class="codeph">STYLESHEET</code>对象，使用处理器和样式表转换文档，并使用<code class="codeph">STYLESHEET</code> API for <code class="codeph">XMLType</code>来操作XSLT处理的结果。
                     </p>
                     <div class="section">
                        <p><a href="PLSQL-APIs-for-XMLType.html#GUID-0C886A80-A2C1-4E02-8E80-B13D577F4AC3__BEIJAGBB">图11-3</a>说明了如何使用XSLT Processor for <code class="codeph">XMLType</code> （ <code class="codeph">DBMS_XSLPROCESSOR</code> ）。
                        </p>
                        <div class="figure" id="GUID-0C886A80-A2C1-4E02-8E80-B13D577F4AC3__BEIJAGBB">
                           <p class="titleinfigure">图11-3为XMLType使用PL / SQL XSLT处理器</p><img src="img/adxdb016.gif" width="323" alt="下面是图11-3的描述" title="下面是图11-3的描述" longdesc="img_text/adxdb016.html"><br><a href="img_text/adxdb016.html">“图11-3为XMLType使用PL / SQL XSLT处理器”的描述</a></div>
                        <!-- class="figure" -->
                        <p>这些是步骤：</p>
                        <ol>
                           <li>
                              <p>使用<code class="codeph">newProcessor</code>构造XSLT处理器。
                              </p>
                           </li>
                           <li>
                              <p>使用<code class="codeph">newStylesheet</code>从DOM文档构建<code class="codeph">STYLESHEET</code>对象。
                              </p>
                           </li>
                           <li>
                              <p>（可选）您可以使用<code class="codeph">setParams</code>为<code class="codeph">STYLESHEET</code>对象设置参数。
                              </p>
                           </li>
                           <li>
                              <p>使用<code class="codeph">processXSL</code>使用处理器和<code class="codeph">STYLESHEET</code>对象转换DOM文档。
                              </p>
                           </li>
                           <li>
                              <p>使用PL / SQL DOM API for <code class="codeph">XMLType</code>来操作XSLT处理的结果。
                              </p>
                           </li>
                        </ol>
                        <p><a href="PLSQL-APIs-for-XMLType.html#GUID-0C886A80-A2C1-4E02-8E80-B13D577F4AC3__BEIFDEJB">例11-10</a>使用过程<code class="codeph">processXSL</code>转换XML文档。它使用相同的解析器实例来创建两个不同的DOM文档：要转换的XML文本和XSLT样式表。创建一个XSL处理器实例，它将样式表应用于源XML以生成新的DOM片段。从该片段创建DOM节点（ <code class="codeph">outnode</code> ），并打印节点内容。使用<code class="codeph">freeDocFrag</code> ， <code class="codeph">freeParser</code>和<code class="codeph">freeProcessor</code>程序分别释放输出DOM片段，解析器和XSLT处理器实例。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-0C886A80-A2C1-4E02-8E80-B13D577F4AC3__BEIFDEJB">
                        <p class="titleinexample">示例11-10使用XSL样式表转换XML文档</p><pre class="pre codeblock"><code>DECLARE indoc VARCHAR2（2000）; xsldoc VARCHAR2（2000）; myParser DBMS_XMLPARSER.parser; indomdoc DBMS_XMLDOM.DOMDocument; xsltdomdoc DBMS_XMLDOM.DOMDocument; xsl DBMS_XSLPROCESSOR.stylesheet; outdomdocf DBMS_XMLDOM.DOMDocumentFragment; outnode DBMS_XMLDOM.DOMNode; proc DBMS_XSLPROCESSOR.processor; buf VARCHAR2（2000）; BEGIN indoc：='&lt;emp&gt; &lt;empno&gt; 1 &lt;/ empno&gt; &lt;fname&gt; robert &lt;/ fname&gt; &lt;lname&gt; smith &lt;/ lname&gt; &lt;sal&gt; 1000 &lt;/ sal&gt; &lt;job&gt; engineer &lt;/ job&gt; &lt;/ EMP&gt;'; xsldoc：='&lt;？xml版本=“1.0”？&gt; &lt;xsl：stylesheet version =“1.0”xmlns：xsl =“http://www.w3.org/1999/XSL/Transform”&gt; &lt;xsl：output encoding =“utf-8”/&gt; &lt;！ -  alphabetizes xml树 - &gt; &lt;xsl：template match =“*”&gt; &lt;xsl：copy&gt; &lt;xsl：apply-templates select =“* | text（）”&gt; &lt;xsl：sort select =“name（。）”data -type =“text”order =“ascending”/&gt; &lt;/ xsl：apply-templates&gt; &lt;/ xsl：copy&gt; &lt;/ xsl：template&gt; &lt;xsl：template match =“text（）”&gt; &lt;xsl：value- of select =“normalize-space（。）”/&gt; &lt;/ xsl：template&gt; &lt;/ xsl：stylesheet&gt;'; myParser：= DBMS_XMLPARSER.newParser; DBMS_XMLPARSER.parseBuffer（myParser，indoc）; indomdoc：= DBMS_XMLPARSER.getDocument（myParser）; DBMS_XMLPARSER.parseBuffer（myParser，xsldoc）; xsltdomdoc：= DBMS_XMLPARSER.getDocument（myParser）; xsl：= DBMS_XSLPROCESSOR.newStyleSheet（xsltdomdoc，''）; proc：= DBMS_XSLPROCESSOR.newProcessor; - 将样式表应用于DOM文档outdomdocf：= DBMS_XSLPROCESSOR.processXSL（proc，xsl，indomdoc）; outnode：= DBMS_XMLDOM.makeNode（outdomdocf）; - 这里可以使用XMLType的PL / SQL DOM API DBMS_XMLDOM.writeToBuffer（outnode，buf）; DBMS_OUTPUT.PUT_LINE（BUF）; DBMS_XMLDOM.freeDocument（indomdoc）; DBMS_XMLDOM.freeDocument（xsltdomdoc）; DBMS_XMLDOM.freeDocFrag（outdomdocf）; DBMS_XMLPARSER.freeParser（myParser）; DBMS_XSLPROCESSOR.freeProcessor（PROC）;结束; /</code></pre><p>这会产生以下输出：</p><pre class="pre codeblock"><code>&lt;emp&gt; &lt;empno&gt; 1 &lt;/ empno&gt; &lt;fname&gt; robert &lt;/ fname&gt; &lt;job&gt; engineer &lt;/ job&gt; &lt;lname&gt; smith &lt;/ lname&gt; &lt;sal&gt; 1000 &lt;/ sal&gt; &lt;/ emp&gt;</code></pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="PLSQL-APIs-for-XMLType.html#GUID-0E3358AF-0819-4B17-AF0B-793E96DA5EB9" title="您可以使用PL / SQL包DBMS_XSLPROCESSOR将一个XML文档转换为另一个XML文档，或将XML数据转换为HTML，PDF或其他格式。该包遍历文档的DOM树，并对其应用可扩展样式表语言转换（XSLT）语句以生成转换后的文档。">用于XMLType的PL / SQL XSLT处理器（DBMS_XSLPROCESSOR）</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div>
         </div>
      </article>
   </body>
</html>