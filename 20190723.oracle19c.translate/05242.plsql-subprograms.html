<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <title>PL / SQL子程序</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Database PL/SQL Language Reference "></meta>
      <meta property="og:description" content=""></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Database PL/SQL Language Reference"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="database-pl-sql-language-reference.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-13T20:26:20-08:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="1996, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96448-02"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="dynamic-sql.html" title="Previous" type="text/html"></link>
      <link rel="next" href="plsql-triggers.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Database PL/SQL Language Reference"></meta>
    <meta name="dcterms.isVersionOf" content="LNPLS"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="dynamic-sql.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="plsql-triggers.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">数据库PL / SQL语言参考</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">PL / SQL子程序</li>
            </ol>
            <a id="GUID-13BEBBEC-02D4-48E8-A059-DFEAC4751A3B" name="GUID-13BEBBEC-02D4-48E8-A059-DFEAC4751A3B"></a><a id="LNPLS523"></a><a id="LNPLS008"></a>
            
            <h2 id="LNPLS-GUID-13BEBBEC-02D4-48E8-A059-DFEAC4751A3B" class="sect2"><span class="enumeration_chapter">8个</span> PL / SQL子程序</h2>
         </header>
         <div class="ind">
            <div>
               <p>PL / SQL <span class="bold">子程序</span>是可以重复调用的命名PL / SQL块。如果子程序具有参数，则每个调用的值可能不同。
               </p>
               <p>子程序是程序或功能。通常，您使用过程执行操作，并使用函数来计算和返回值。</p>
               <div class="section">
                  <p class="subhead1" id="GUID-13BEBBEC-02D4-48E8-A059-DFEAC4751A3B__GUID-8809110C-556D-4AFE-A5C7-B76D1062528D">话题</p>
               </div>
               <!-- class="section" -->
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="plsql-subprograms.html#GUID-56B4253C-6113-4C97-A0D2-1488B6526076">使用子程序的原因</a></p>
                  </li>
                  <li>
                     <p><a href="plsql-subprograms.html#GUID-E03F512B-1A30-43B4-8DCA-64DA68AE7CE4">嵌套，包和独立子程序</a></p>
                  </li>
                  <li>
                     <p><a href="plsql-subprograms.html#GUID-C04B6BF9-1B19-42F9-82D8-CA137E97A024">子程序调用</a></p>
                  </li>
                  <li>
                     <p><a href="plsql-subprograms.html#GUID-F4B0F4E1-90F4-4432-8DCF-3C93D0376E88">子程序属性</a></p>
                  </li>
                  <li>
                     <p><a href="plsql-subprograms.html#GUID-855AA11F-32CB-4CAD-9255-BE92A6821487">子程序部件</a></p>
                  </li>
                  <li>
                     <p><a href="plsql-subprograms.html#GUID-117C2D94-EB7C-4A9E-A080-99F4829D69B0">前瞻宣言</a></p>
                  </li>
                  <li>
                     <p><a href="plsql-subprograms.html#GUID-C0397690-70F4-480D-ADC9-02D277DAA1BB">子程序参数</a></p>
                  </li>
                  <li>
                     <p><a href="plsql-subprograms.html#GUID-A7D51201-1711-4F33-827F-70042700801F">子程序调用解析</a></p>
                  </li>
                  <li>
                     <p><a href="plsql-subprograms.html#GUID-47D5A50E-7AAF-4C80-A06A-37593EA2526A">重载的子程序</a></p>
                  </li>
                  <li>
                     <p><a href="plsql-subprograms.html#GUID-E093EF16-0477-44B4-B3E2-37D7CEF4F25C">递归子程序</a></p>
                  </li>
                  <li>
                     <p><a href="plsql-subprograms.html#GUID-6C6A828F-8FA0-4278-97D2-6D5649A66A9A">子程序副作用</a></p>
                  </li>
                  <li>
                     <p><a href="plsql-subprograms.html#GUID-250BDBBB-0CD6-4D56-9DDF-6FCEDC110D00" title="当PL / SQL函数具有RESULT_CACHE选项时，其结果将缓存在共享全局区域（SGA）中，因此连接到同一实例的会话可以在可用时重用这些结果。">PL / SQL函数结果缓存</a></p>
                  </li>
                  <li>
                     <p><a href="plsql-subprograms.html#GUID-4FC97312-AC30-4A6E-8337-996198191E29">SQL语句可以调用的PL / SQL函数</a></p>
                  </li>
                  <li>
                     <p><a href="plsql-subprograms.html#GUID-41D23DE7-3C07-41CF-962B-F92B696594B5" title="如果在DR单元（定义者权限单元）中包含已连接的用户数据库链接，则必须向将运行DR单元的用户授予INHERIT REMOTE PRIVILEGES权限。">祈求者的权利和定义者权利（AUTHID财产）</a></p>
                  </li>
                  <li>
                     <p><a href="plsql-subprograms.html#GUID-96B5DE2B-D809-4296-9CDE-B317B81895F8">外部子程序</a></p>
                  </li>
               </ul>
            </div><a id="LNPLS99900"></a><div class="props_rev_3"><a id="GUID-56B4253C-6113-4C97-A0D2-1488B6526076" name="GUID-56B4253C-6113-4C97-A0D2-1488B6526076"></a><h3 id="LNPLS-GUID-56B4253C-6113-4C97-A0D2-1488B6526076" class="sect3"><span class="enumeration_section">8.1</span>使用子程序的原因</h3>
               <div>
                  <p>子程序支持开发和维护可靠，可重用的代码，具有以下功能：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><span class="bold">模块化</span></p>
                        <p>子程序允许您将程序分解为可管理，定义明确的模块。</p>
                     </li>
                     <li>
                        <p><span class="bold">更轻松的应用设计</span></p>
                        <p>在设计应用程序时，您可以推迟子程序的实现细节，直到您测试了主程序，然后一步一步地完善它们。（要定义没有实现细节的子程序，请使用<code class="codeph">NULL</code>语句，如<a href="plsql-control-statements.html#GUID-FB72FFC2-4B55-45C9-BA38-57511913242F__BABDHJDA">例4-35所示</a> 。）
                        </p>
                     </li>
                     <li>
                        <p><span class="bold">可维护性</span></p>
                        <p>您可以在不更改其调用者的情况下更改子程序的实现细节。</p>
                     </li>
                     <li>
                        <p><span class="bold">包装性</span></p>
                        <p>子程序可以分组到包中，其优点在<span class="q">“ <a href="plsql-packages.html#GUID-F2763E50-C2C6-4A4B-AEFA-103EB8529FD5">使用包的原因</a> ”中</span>进行了解释。
                        </p>
                     </li>
                     <li>
                        <p><span class="bold">可重用性</span></p>
                        <p>在许多不同环境中，任何数量的应用程序都可以使用相同的包子程序或独立子程序。</p>
                     </li>
                     <li>
                        <p><span class="bold">更好的性能</span></p>
                        <p>每个子程序都以可执行的形式编译和存储，可以重复调用。由于存储的子程序在数据库服务器中运行，因此通过网络进行的单个调用可以启动大型作业。这种分工可以减少网络流量并缩短响应时间。存储的子程序在用户之间进行缓存和共享，从而降低了内存需求和调用开销。</p>
                     </li>
                  </ul>
                  <p>子程序是其他可维护性功能的重要组成部分，例如包（在<a href="plsql-packages.html#GUID-C285EC5A-BE50-4192-A88E-48C0778B34E0" title="本章介绍如何将相关的PL / SQL代码和数据捆绑到一个包中，其内容可供许多应用程序使用。">PL / SQL包中</a>解释）和抽象数据类型（在<span class="q">“ <a href="overview.html#GUID-4E7295F2-854D-454F-9001-CA950FCAAC55" title="抽象数据类型（ADT）由数据结构和操纵数据的子程序组成。">抽象数据类型</a> ”中</span>解释）。
                  </p>
               </div>
            </div><a id="LNPLS99899"></a><div class="props_rev_3"><a id="GUID-E03F512B-1A30-43B4-8DCA-64DA68AE7CE4" name="GUID-E03F512B-1A30-43B4-8DCA-64DA68AE7CE4"></a><h3 id="LNPLS-GUID-E03F512B-1A30-43B4-8DCA-64DA68AE7CE4" class="sect3"><span class="enumeration_section">8.2</span>嵌套，包和独立子程序</h3>
               <div>
                  <p>您可以在PL / SQL块（可以是另一个子程序）内部，包内或模式级别创建子程序。</p>
                  <p>在PL / SQL块内创建的子程序是<span class="bold">嵌套的子程序</span> 。您可以同时声明和定义它，也可以先声明它，然后在同一个块中定义它（参见<span class="q">“ <a href="plsql-subprograms.html#GUID-117C2D94-EB7C-4A9E-A080-99F4829D69B0">转发声明</a> ”</span> ）。嵌套子程序仅在嵌套在独立子程序包或程序包子程序中时才存储在数据库中。
                  </p>
                  <p>在包内创建的子程序是<span class="bold">包子程序</span> 。您在包规范中声明它并在包体中定义它。它将存储在数据库中，直到您删除包。（包在<a href="plsql-packages.html#GUID-C285EC5A-BE50-4192-A88E-48C0778B34E0" title="本章介绍如何将相关的PL / SQL代码和数据捆绑到一个包中，其内容可供许多应用程序使用。">PL / SQL包</a>中描述。）
                  </p>
                  <p>在模式级别创建的子程序是一个<span class="bold">独立的子程序</span> 。您可以使用<code class="codeph">CREATE</code> <code class="codeph">FUNCTION</code>或<code class="codeph">CREATE</code> <code class="codeph">PROCEDURE</code>语句创建它。它将存储在数据库中，直到您使用<code class="codeph">DROP</code> <code class="codeph">FUNCTION</code>或<code class="codeph">DROP</code> <code class="codeph">PROCEDURE</code>语句删除它。（这些语句在<a href="sql-statements-for-stored-plsql-units.html#GUID-C918310F-F1BB-41D7-9466-B558B70DDFFE" title="本章介绍如何使用创建，更改和删除存储的PL / SQL单元的SQL语句。">存储的PL / SQL单元的SQL</a>语句中描述。）
                  </p>
                  <p><span class="bold">存储的子程序</span>是包子程序或独立子程序。存储的子程序受<code class="codeph">AUTHID</code>和<code class="codeph">ACCESSIBLE</code> <code class="codeph">BY</code>子句的影响，这些子句可以出现在<code class="codeph">CREATE</code> <code class="codeph">FUNCTION</code> ， <code class="codeph">CREATE</code> <code class="codeph">PROCEDURE</code>和<code class="codeph">CREATE</code> <code class="codeph">PACKAGE</code>语句中。<code class="codeph">AUTHID</code>子句影响子程序在运行时发出的SQL语句的名称解析和权限检查（有关更多信息，请参阅<span class="q">“ <a href="plsql-subprograms.html#GUID-41D23DE7-3C07-41CF-962B-F92B696594B5" title="如果在DR单元（定义者权限单元）中包含已连接的用户数据库链接，则必须向将运行DR单元的用户授予INHERIT REMOTE PRIVILEGES权限。">Invoker的权利和定义者权利（AUTHID属性）</a> ”</span> ）。<code class="codeph">ACCESSIBLE</code> <code class="codeph">BY</code>子句指定可以访问子程序的PL / SQL单元的白名单。
                  </p>
               </div>
            </div><a id="LNPLS99901"></a><div class="props_rev_3"><a id="GUID-C04B6BF9-1B19-42F9-82D8-CA137E97A024" name="GUID-C04B6BF9-1B19-42F9-82D8-CA137E97A024"></a><h3 id="LNPLS-GUID-C04B6BF9-1B19-42F9-82D8-CA137E97A024" class="sect3"><span class="enumeration_section">8.3</span>子程序调用</h3>
               <div>
                  <p>子程序调用具有以下形式：</p><pre class="oac_no_warn" dir="ltr"><span class="italic">subprogram_name</span> [（[ <span class="italic">parameter</span> [， <span class="italic">parameter</span> ] ...]）]</pre><p>如果子程序没有参数，或者为每个参数指定默认值，则可以省略参数列表或指定空参数列表。</p>
                  <p>过程调用是PL / SQL语句。例如：</p><pre class="oac_no_warn" dir="ltr">raise_salary（employee_id，amount）;</pre><p>函数调用是一个表达式。例如：</p><pre class="oac_no_warn" dir="ltr">new_salary：= get_salary（employee_id）; IF salary_ok（new_salary，new_title）然后......</pre><div class="infoboxnotealso" id="GUID-C04B6BF9-1B19-42F9-82D8-CA137E97A024__GUID-CEE1BE27-78FE-4739-A497-3FC4A7DB3F55">
                     <p class="notep1">也可以看看：</p>
                     <p><span class="q">“ <a href="plsql-subprograms.html#GUID-C0397690-70F4-480D-ADC9-02D277DAA1BB">子程序参数</a> ”</span> ，以获取有关在子程序调用中指定参数的更多信息</p>
                  </div>
               </div>
            </div>
            <div class="sect2"><a id="GUID-F4B0F4E1-90F4-4432-8DCF-3C93D0376E88" name="GUID-F4B0F4E1-90F4-4432-8DCF-3C93D0376E88"></a><h3 id="LNPLS-GUID-F4B0F4E1-90F4-4432-8DCF-3C93D0376E88" class="sect3"><span class="enumeration_section">8.4</span>子程序属性</h3>
               <div>
                  <p></p>
                  <p>每个子程序属性只能在子程序声明中出现一次。属性可以按任何顺序出现。属性出现在子程序标题中的<code class="codeph">IS</code>或<code class="codeph">AS</code>关键字之前。属性不能出现在嵌套的子程序中。
                  </p>
                  <div class="section">
                     <p>只有<code class="codeph">ACCESSIBLE BY</code>属性才能出现在包子程序中。独立子程序在其声明中可能具有以下属性。
                     </p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="ACCESSIBLE-BY-clause.html#GUID-9720619C-9862-4123-96E7-3E85F240FF36" title="ACCESSIBLE BY子句限制对单元和子程序的访问。">可以通过条款访问</a></p>
                        </li>
                        <li>
                           <p><a href="DEFAULT-COLLATION-clause.html#GUID-453FC0EA-7B83-407B-A991-87A48017B358" title="排序（也称为排序排序）确定当比较和排序两个字符串时，字符串是否等于，先于或跟随另一个字符串。Oracle数据库归类按照不同语言中使用的排序文本规则排序字符串。">默认收集条款</a></p>
                        </li>
                        <li>
                           <p><a href="plsql-subprograms.html#GUID-41D23DE7-3C07-41CF-962B-F92B696594B5" title="如果在DR单元（定义者权限单元）中包含已连接的用户数据库链接，则必须向将运行DR单元的用户授予INHERIT REMOTE PRIVILEGES权限。">祈求者的权利和定义者权利（AUTHID财产）</a></p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
               </div>
            </div><a id="LNPLS530"></a><a id="LNPLS654"></a><a id="LNPLS653"></a><div class="props_rev_3"><a id="GUID-855AA11F-32CB-4CAD-9255-BE92A6821487" name="GUID-855AA11F-32CB-4CAD-9255-BE92A6821487"></a><h3 id="LNPLS-GUID-855AA11F-32CB-4CAD-9255-BE92A6821487" class="sect3"><span class="enumeration_section">8.5</span>子程序部件</h3>
               <div>
                  <p>子程序以<span class="bold">子程序标题</span>开头，该<span class="bold">标题</span>指定其名称和（可选）其参数列表。
                  </p>
                  <p>像匿名块一样，子程序包含以下部分：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><span class="bold">声明部分（可选）</span></p>
                        <p>此部分声明并定义本地类型，游标，常量，变量，异常和嵌套子程序。当子程序完成执行时，这些项目不再存在。</p>
                        <p>这部分也可以指定编译指示。</p>
                        <div class="infoboxnote" id="GUID-855AA11F-32CB-4CAD-9255-BE92A6821487__GUID-42259B7D-DD24-4B59-BB78-752DB3C1A774">
                           <p class="notep1">注意：</p>
                           <p>子程序的声明部分不以关键字<code class="codeph">DECLARE</code>开头，因为匿名块的声明部分。
                           </p>
                        </div>
                     </li>
                     <li>
                        <p><span class="bold">可执行部分（必填）</span></p>
                        <p>此部分包含一个或多个分配值，控制执行和操作数据的语句。（在应用程序设计过程的早期，此部分可能只包含<code class="codeph">NULL</code>语句，如<a href="plsql-control-statements.html#GUID-FB72FFC2-4B55-45C9-BA38-57511913242F__BABDHJDA">例4-35所示</a> 。）
                        </p>
                     </li>
                     <li>
                        <p><span class="bold">异常处理部分（可选）</span></p>
                        <p>此部分包含处理运行时错误的代码。</p>
                     </li>
                  </ul>
                  <div class="section">
                     <p class="subhead2" id="GUID-855AA11F-32CB-4CAD-9255-BE92A6821487__GUID-9A9E48C9-0A9F-405D-8D35-5658CF8E0CAA">话题</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="plsql-subprograms.html#GUID-5E23F601-5194-4F40-823B-C1BD12B9248C">功能的附加部件</a></p>
                        </li>
                        <li>
                           <p><a href="plsql-subprograms.html#GUID-96E5D372-E653-4C0F-858F-8309A91CE1FF">返回声明</a></p>
                        </li>
                     </ul>
                     <div class="infoboxnotealso" id="GUID-855AA11F-32CB-4CAD-9255-BE92A6821487__GUID-C7788C2E-CA9D-4659-90DD-7347DBCFB760">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><span class="q">“ <a href="plsql-language-fundamentals.html#GUID-D6EFD7E8-39DF-4430-B625-B6D37E49F6F4" title="编译指示是编译器在编译时处理的指令。">编译指示</a> ”</span></p>
                           </li>
                           <li>
                              <p><span class="q">“ <a href="procedure-declaration-and-definition.html#GUID-9A48D7CE-3720-46A4-B5CA-C2250CA86AF2" title="在调用过程之前，必须声明并定义它。您可以先声明它（使用procedure_declaration），然后在同一个块，子程序或包中使用procedure_definition定义它，或者同时声明和定义它（使用procedure_definition）。">程序声明和定义</a> ”，</span>用于过程声明和定义的语法</p>
                           </li>
                           <li>
                              <p><span class="q">“ <a href="plsql-subprograms.html#GUID-C0397690-70F4-480D-ADC9-02D277DAA1BB">子程序参数</a> ”</span>有关子程序参数的更多信息</p>
                           </li>
                        </ul>
                     </div>
                  </div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-855AA11F-32CB-4CAD-9255-BE92A6821487__CHDBIEEE">
                     <p class="titleinexample">示例8-1声明，定义和调用简单的PL / SQL过程</p>
                     <p>在此示例中，匿名块同时声明并定义过程并调用它三次。第三次调用引发了过程的异常处理部分处理的异常。</p><pre class="oac_no_warn" dir="ltr">DECLARE first_name employees.first_name％TYPE; last_name employees.last_name％TYPE;电子邮件employees.email％TYPE;雇主VARCHAR2（8）：='AcmeCorp'; <span class="bold">- 声明和定义过程</span> PROCEDURE create_email（ <span class="bold">- 子程序标题开头</span> name1 VARCHAR2，name2 VARCHAR2，公司VARCHAR2） <span class="bold">- 子程序标题结束</span> IS <span class="bold">- 声明部分开始</span> error_message VARCHAR2（30）：='电子邮件地址太长。“; BEGIN <span class="bold">- 可执行部分开始</span>发送电子邮件：= name1 || '' || name2 || '@'||公司; EXCEPTION <span class="bold">- 异常处理部分在</span> VALUE_ERROR那么DBMS_OUTPUT.PUT_LINE（error_message）时开始; END create_email; BEGIN first_name：='John'; last_name：='Doe'; create_email（first_name，last_name，employer）; <span class="bold">- 调用</span> DBMS_OUTPUT.PUT_LINE（'首先是名字，电子邮件是：'|| email）; create_email（last_name，first_name，employer）; <span class="bold">- 调用</span> DBMS_OUTPUT.PUT_LINE（'姓氏优先，电子邮件是：'|| email）; first_name：='伊丽莎白'; last_name：='麦当劳'; create_email（first_name，last_name，employer）; <span class="bold">- 调用</span> END; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">首先是名字，电子邮件是：John。Doe @ AcmeCorp首先使用姓氏，电子邮件是：Doe。John @ AcmeCorp电子邮件地址太长。</pre></div>
                  <!-- class="example" -->
               </div><a id="LNPLS538"></a><a id="LNPLS99898"></a><div class="props_rev_3"><a id="GUID-5E23F601-5194-4F40-823B-C1BD12B9248C" name="GUID-5E23F601-5194-4F40-823B-C1BD12B9248C"></a><h4 id="LNPLS-GUID-5E23F601-5194-4F40-823B-C1BD12B9248C" class="sect4"><span class="enumeration_section">8.5.1</span>功能的附加部件</h4>
                  <div>
                     <p>函数具有与过程相同的结构，除了：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>函数标题必须包含<span class="bold"><code class="codeph">RETURN</code></span> <span class="bold">子句</span> ，该<span class="bold">子句</span>指定函数返回的值的数据类型。（过程标题不能有<code class="codeph">RETURN</code>子句。）
                           </p>
                        </li>
                        <li>
                           <p>在函数的可执行部分中，每个执行路径必须导致<span class="bold"><code class="codeph">RETURN</code></span> <span class="bold">语句</span> 。否则，PL / SQL编译器会发出编译时警告。（在过程中， <code class="codeph">RETURN</code>语句是可选的，不建议使用。有关详细信息，请参阅<span class="q">“ <a href="plsql-subprograms.html#GUID-96E5D372-E653-4C0F-858F-8309A91CE1FF">RETURN语句</a> ”</span> 。）
                           </p>
                        </li>
                        <li>
                           <p>函数声明可以包含以下选项：</p>
                        </li>
                     </ul>
                     <div class="tblformal" id="GUID-5E23F601-5194-4F40-823B-C1BD12B9248C__GUID-A1101A2D-DD12-4E54-B5F5-72F65F1AAA7A">
                        <table cellpadding="4" cellspacing="0" class="Formal" title="" width="100%" border="1" summary="This table lists the additional options that are only available in functions." frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="33%" id="d58247e1113">选项</th>
                                 <th align="left" valign="bottom" width="67%" id="d58247e1116">描述</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="33%" id="d58247e1121" headers="d58247e1113 ">
                                    <p><code class="codeph">DETERMINISTIC</code>选项</p>
                                 </td>
                                 <td align="left" valign="top" width="67%" headers="d58247e1121 d58247e1116 ">
                                    <p>帮助优化器避免冗余函数调用。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="33%" id="d58247e1130" headers="d58247e1113 ">
                                    <p><code class="codeph">PARALLEL_ENABLE</code>选项</p>
                                 </td>
                                 <td align="left" valign="top" width="67%" headers="d58247e1130 d58247e1116 ">
                                    <p>启用并行执行功能，使其可以安全地用于并行DML评估的从属会话。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="33%" id="d58247e1139" headers="d58247e1113 ">
                                    <p><code class="codeph">PIPELINED</code>选项</p>
                                 </td>
                                 <td align="left" valign="top" width="67%" headers="d58247e1139 d58247e1116 ">
                                    <p>使表函数流水线化，用作行源。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="33%" id="d58247e1148" headers="d58247e1113 ">
                                    <p><code class="codeph">RESULT_CACHE</code>选项</p>
                                 </td>
                                 <td align="left" valign="top" width="67%" headers="d58247e1148 d58247e1116 ">
                                    <p>将函数结果存储在PL / SQL函数结果缓存中。</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <div class="infoboxnotealso" id="GUID-5E23F601-5194-4F40-823B-C1BD12B9248C__GUID-1C232AE8-9229-44AE-BFE4-F2E9DAA4B46D">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><span class="q">“ <a href="function-declaration-and-definition.html#GUID-4E19FB09-46B5-4CE5-8A5B-CD815C29DA1C" title="在调用函数之前，必须声明并定义它。您可以先声明它（使用function_declaration），然后在同一个块，子程序或包中（使用function_definition）定义它，或者同时声明和定义它（使用function_definition）。">函数声明和定义</a> ”，</span>用于函数声明和定义的语法，包括上表中各项的描述</p>
                           </li>
                           <li>
                              <p><span class="q">“ <a href="plsql-subprograms.html#GUID-250BDBBB-0CD6-4D56-9DDF-6FCEDC110D00" title="当PL / SQL函数具有RESULT_CACHE选项时，其结果将缓存在共享全局区域（SGA）中，因此连接到同一实例的会话可以在可用时重用这些结果。">PL / SQL函数结果缓存</a> ”</span>有关<code class="codeph">RESULT_CACHE</code>选项的更多信息</p>
                           </li>
                        </ul>
                     </div>
                     <div class="example" id="GUID-5E23F601-5194-4F40-823B-C1BD12B9248C__CIHBEGEG">
                        <p class="titleinexample">示例8-2声明，定义和调用简单的PL / SQL函数</p>
                        <p>在此示例中，匿名块同时声明并定义一个函数并调用它。</p><pre class="oac_no_warn" dir="ltr">DECLARE <span class="bold">- 声明和定义函数</span> FUNCTION square（原始NUMBER） <span class="bold">- 参数列表</span> RETURN NUMBER <span class="bold">-  RETURN子句</span> AS <span class="bold">- 声明部分开始</span> original_squared NUMBER; BEGIN <span class="bold">- 可执行部分开始</span> original_squared：= original * original;返回original_squared; <span class="bold">-  RETURN语句</span>结束; BEGIN DBMS_OUTPUT.PUT_LINE（square（100））; <span class="bold">- 调用</span> END; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">10000</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="LNPLS539"></a><a id="LNPLS99897"></a><div class="props_rev_3"><a id="GUID-96E5D372-E653-4C0F-858F-8309A91CE1FF" name="GUID-96E5D372-E653-4C0F-858F-8309A91CE1FF"></a><h4 id="LNPLS-GUID-96E5D372-E653-4C0F-858F-8309A91CE1FF" class="sect4"><span class="enumeration_section">8.5.2</span>返回声明</h4>
                  <div>
                     <p><code class="codeph">RETURN</code>语句立即结束子程序或包含它的匿名块的执行。子程序或匿名块可以包含多个<code class="codeph">RETURN</code>语句。
                     </p>
                     <div class="section">
                        <p class="subhead3" id="GUID-96E5D372-E653-4C0F-858F-8309A91CE1FF__GUID-B2C21EEF-DA9F-4812-BFEF-ED015DEA33AB">话题</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="plsql-subprograms.html#GUID-919FB82F-4D11-4941-96F1-85A5354072E7">函数中的RETURN语句</a></p>
                           </li>
                           <li>
                              <p><a href="plsql-subprograms.html#GUID-B25162E7-4E32-4E4C-A15C-890E03A3A71E">程序中的RETURN语句</a></p>
                           </li>
                           <li>
                              <p><a href="plsql-subprograms.html#GUID-4102EAC5-1B56-4DAB-9EDA-84398FD1F5E6">匿名阻止中的RETURN语句</a></p>
                           </li>
                        </ul>
                        <div class="infoboxnotealso" id="GUID-96E5D372-E653-4C0F-858F-8309A91CE1FF__GUID-2A2805E2-ED28-44B1-BB3B-94B4AB0943BE">
                           <p class="notep1">也可以看看：</p>
                           <p><span class="q">“ <a href="RETURN-statement.html#GUID-2DCDD1F2-041A-479C-A2F8-B3B68F50FE5D" title="RETURN语句立即结束子程序或包含它的匿名块的执行。">RETURN声明</a> ”，</span>为的语法<code class="codeph">RETURN</code>声明</p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div><a id="LNPLS540"></a><a id="LNPLS550"></a><a id="LNPLS552"></a><a id="LNPLS99895"></a><div class="props_rev_3"><a id="GUID-919FB82F-4D11-4941-96F1-85A5354072E7" name="GUID-919FB82F-4D11-4941-96F1-85A5354072E7"></a><h5 id="LNPLS-GUID-919FB82F-4D11-4941-96F1-85A5354072E7" class="sect5"><span class="enumeration_section">8.5.2.1</span>函数中的RETURN语句</h5>
                     <div>
                        <p>在函数中，每个执行路径必须指向<code class="codeph">RETURN</code>语句，并且每个<code class="codeph">RETURN</code>语句都必须指定一个表达式。<code class="codeph">RETURN</code>语句将表达式的值分配给函数标识符，并将控制权返回给调用者，其中执行在调用之后立即恢复。
                        </p>
                        <div class="infoboxnote" id="GUID-919FB82F-4D11-4941-96F1-85A5354072E7__GUID-D56F4FC7-513C-4FB0-A10E-7D2C59135BDA">
                           <p class="notep1">注意：</p>
                           <p>在流水线表函数中， <code class="codeph">RETURN</code>语句不需要指定表达式。有关管道表函数部分的信息，请参阅<span class="q">“ <a href="plsql-optimization-and-tuning.html#GUID-58D850B2-A416-47EA-8803-8936E2D6748A">创建管道表函数</a> ”</span> 。
                           </p>
                        </div>
                        <p>在<a href="plsql-subprograms.html#GUID-919FB82F-4D11-4941-96F1-85A5354072E7__CIHEHEHB">例8-3中</a> ，匿名块两次调用相同的函数。第一次， <code class="codeph">RETURN</code>语句将控制权返回给调用语句的内部。第二次， <code class="codeph">RETURN</code>语句将控制权返回到调用语句之后的语句。
                        </p>
                        <p>在<a href="plsql-subprograms.html#GUID-919FB82F-4D11-4941-96F1-85A5354072E7__CIHFDEBC">例8-4中</a> ，函数有多个<code class="codeph">RETURN</code>语句，但如果参数不是0或1，则没有执行路径导致<code class="codeph">RETURN</code>语句。该函数编译警告PLW-05005：子程序F在第11行返回无值。
                        </p>
                        <p>除了添加<code class="codeph">ELSE</code>子句之外， <a href="plsql-subprograms.html#GUID-919FB82F-4D11-4941-96F1-85A5354072E7__CIHDHIDD">例8-5</a>与<a href="plsql-subprograms.html#GUID-919FB82F-4D11-4941-96F1-85A5354072E7__CIHFDEBC">例8-4</a>类似。每个执行路径都会导致<code class="codeph">RETURN</code>语句，并且该函数在没有警告的情况下编译PLW-05005。
                        </p>
                        <div class="example" id="GUID-919FB82F-4D11-4941-96F1-85A5354072E7__CIHEHEHB">
                           <p class="titleinexample">例8-3在函数中的RETURN语句后继续执行</p><pre class="oac_no_warn" dir="ltr">DECLARE x INTEGER;功能f（n INTEGER）返回INTEGER是BEGIN <span class="bold">RETURN（n * n）;</span>结束; BEGIN DBMS_OUTPUT.PUT_LINE（'f返回'|| <span class="bold">f（2）</span> <span class="bold">||'。执行返回此处（1）。'</span> ）; x：= <span class="bold">f（2）</span> ; <span class="bold">DBMS_OUTPUT.PUT_LINE（'执行返回此处（2）。“）;</span>结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">f返回4。执行返回此处（1）。执行返回此处（2）。
</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-919FB82F-4D11-4941-96F1-85A5354072E7__CIHFDEBC">
                           <p class="titleinexample">例8-4不是每个执行路径导致RETURN语句的功能</p><pre class="oac_no_warn" dir="ltr">创建或替换功能f（n INTEGER）返回INTEGER AUTHID DEFINER， <span class="bold">如果n = 0，则</span>返回1; <span class="bold">ELSIF n = 1</span>然后返回n;万一;结束; /</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-919FB82F-4D11-4941-96F1-85A5354072E7__CIHDHIDD">
                           <p class="titleinexample">例8-5每个执行路径导致RETURN语句的功能</p><pre class="oac_no_warn" dir="ltr">创建或替换功能f（n INTEGER）返回INTEGER AUTHID DEFINER，如果n = 0，则返回1; ELSIF n = 1然后返回n; <span class="bold">ELSE</span> RETURN n * n;万一;结束; /开始为我在0 ..3 LOOP DBMS_OUTPUT.PUT_LINE（'f（'|| i ||'）='|| f（i））;结束循环;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">f（0）= 1 f（1）= 1 f（2）= 4 f（3）= 9</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="LNPLS555"></a><a id="LNPLS99894"></a><div class="props_rev_3"><a id="GUID-B25162E7-4E32-4E4C-A15C-890E03A3A71E" name="GUID-B25162E7-4E32-4E4C-A15C-890E03A3A71E"></a><h5 id="LNPLS-GUID-B25162E7-4E32-4E4C-A15C-890E03A3A71E" class="sect5"><span class="enumeration_section">8.5.2.2</span>程序中的RETURN语句</h5>
                     <div>
                        <p>在一个过程中， <code class="codeph">RETURN</code>语句将控制返回给调用者，其中执行在调用之后立即恢复。<code class="codeph">RETURN</code>语句不能指定表达式。
                        </p>
                        <p>在<a href="plsql-subprograms.html#GUID-B25162E7-4E32-4E4C-A15C-890E03A3A71E__CIHHFGDG">例8-6中</a> ， <code class="codeph">RETURN</code>语句将控制权返回到调用语句之后的语句。
                        </p>
                        <div class="example" id="GUID-B25162E7-4E32-4E4C-A15C-890E03A3A71E__CIHHFGDG">
                           <p class="titleinexample">例8-6在程序中的RETURN语句后继续执行</p><pre class="oac_no_warn" dir="ltr">DECLARE程序p BEGIN DBMS_OUTPUT.PUT_LINE（'Inside p'）; <span class="bold">返回;</span> DBMS_OUTPUT.PUT_LINE（ <span class="bold">'无法访问的语句。'</span> ）;结束;开始<span class="bold">p;</span> <span class="bold">DBMS_OUTPUT.PUT_LINE（'Control返回此处。“）;</span>结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">内部p Control返回此处。</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="LNPLS556"></a><a id="LNPLS99893"></a><div class="props_rev_3"><a id="GUID-4102EAC5-1B56-4DAB-9EDA-84398FD1F5E6" name="GUID-4102EAC5-1B56-4DAB-9EDA-84398FD1F5E6"></a><h5 id="LNPLS-GUID-4102EAC5-1B56-4DAB-9EDA-84398FD1F5E6" class="sect5"><span class="enumeration_section">8.5.2.3</span>匿名块中的RETURN语句</h5>
                     <div>
                        <p>在匿名块中， <code class="codeph">RETURN</code>语句退出其自己的块和所有封闭块。<code class="codeph">RETURN</code>语句不能指定表达式。
                        </p>
                        <p>在<a href="plsql-subprograms.html#GUID-4102EAC5-1B56-4DAB-9EDA-84398FD1F5E6__CIHGCFCC">例8-7中</a> ， <code class="codeph">RETURN</code>语句退出内部和外部块。
                        </p>
                        <div class="example" id="GUID-4102EAC5-1B56-4DAB-9EDA-84398FD1F5E6__CIHGCFCC">
                           <p class="titleinexample">例8-7执行在匿名块中的RETURN语句后恢复</p><pre class="oac_no_warn" dir="ltr">BEGIN BEGIN DBMS_OUTPUT.PUT_LINE（'内部块。“）; <span class="bold">返回;</span> DBMS_OUTPUT.PUT_LINE（ <span class="bold">'无法访问的语句。'</span> ）;结束; DBMS_OUTPUT.PUT_LINE（ <span class="bold">'在外部块内部。无法访问的声明。'</span> ）;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">内部内部。</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div>
               </div>
            </div><a id="LNPLS656"></a><a id="LNPLS99896"></a><div class="props_rev_3"><a id="GUID-117C2D94-EB7C-4A9E-A080-99F4829D69B0" name="GUID-117C2D94-EB7C-4A9E-A080-99F4829D69B0"></a><h3 id="LNPLS-GUID-117C2D94-EB7C-4A9E-A080-99F4829D69B0" class="sect3"><span class="enumeration_section">8.6</span>前瞻性声明</h3>
               <div>
                  <p>如果同一PL / SQL块中的嵌套子程序相互调用，则需要前向声明，因为必须先声明子程序才能调用它。</p>
                  <p><span class="bold">前向声明</span>声明了嵌套的子程序，但没有定义它。您必须稍后在同一个块中定义它。前向声明和定义必须具有相同的子程序标题。
                  </p>
                  <p>在<a href="plsql-subprograms.html#GUID-117C2D94-EB7C-4A9E-A080-99F4829D69B0__CHDGICCH">例8-8中</a> ，匿名块创建了两个相互调用的过程。
                  </p>
                  <div class="example" id="GUID-117C2D94-EB7C-4A9E-A080-99F4829D69B0__CHDGICCH">
                     <p class="titleinexample">示例8-8嵌套子程序互相调用</p><pre class="oac_no_warn" dir="ltr">DECLARE <span class="bold">- 声明proc1（前向声明）：</span> PROCEDURE proc1（number1 NUMBER）; <span class="bold">- 声明并定义proc2：</span> PROCEDURE proc2（number2 NUMBER）是BEGIN proc1（number2）;结束; <span class="bold">- 定义proc 1：</span> PROCEDURE proc1（number1 NUMBER）是BEGIN proc2（number1）;结束; BEGIN NULL;结束; /</pre></div>
                  <!-- class="example" -->
               </div>
            </div><a id="LNPLS557"></a><a id="LNPLS00806"></a><div class="props_rev_3"><a id="GUID-C0397690-70F4-480D-ADC9-02D277DAA1BB" name="GUID-C0397690-70F4-480D-ADC9-02D277DAA1BB"></a><h3 id="LNPLS-GUID-C0397690-70F4-480D-ADC9-02D277DAA1BB" class="sect3"><span class="enumeration_section">8.7</span>子程序参数</h3>
               <div>
                  <p>如果子程序具有参数，则每个调用的值可能不同。</p>
                  <div class="section">
                     <p class="subhead2" id="GUID-C0397690-70F4-480D-ADC9-02D277DAA1BB__GUID-ECD9D10F-727D-433A-B584-92EE202AF581">话题</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="plsql-subprograms.html#GUID-9ACD7C7D-861B-4410-AC6F-8536C191E2EF">正式和实际子程序参数</a></p>
                        </li>
                        <li>
                           <p><a href="plsql-subprograms.html#GUID-18E72176-145F-4E12-95F1-03F84B3D5DC6">子程序参数传递方法</a></p>
                        </li>
                        <li>
                           <p><a href="plsql-subprograms.html#GUID-518B8827-26CC-4734-B799-ACB038185638">子程序参数模式</a></p>
                        </li>
                        <li>
                           <p><a href="plsql-subprograms.html#GUID-CB95955E-8843-4481-BB07-A52CA2FF4A8B">子程序参数别名</a></p>
                        </li>
                        <li>
                           <p><a href="plsql-subprograms.html#GUID-C1079955-95B2-4D0F-8928-649EDA355461">IN子程序参数的默认值</a></p>
                        </li>
                        <li>
                           <p><a href="plsql-subprograms.html#GUID-A5DA8CF5-1BCC-4ABE-9B68-DB593FF1D2CC">实际参数的位置，命名和混合表示法</a></p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
               </div><a id="LNPLS1962"></a><a id="LNPLS658"></a><a id="LNPLS657"></a><div class="props_rev_3"><a id="GUID-9ACD7C7D-861B-4410-AC6F-8536C191E2EF" name="GUID-9ACD7C7D-861B-4410-AC6F-8536C191E2EF"></a><h4 id="LNPLS-GUID-9ACD7C7D-861B-4410-AC6F-8536C191E2EF" class="sect4"><span class="enumeration_section">8.7.1</span>正式和实际子程序参数</h4>
                  <div>
                     <p>如果希望子程序具有参数，请在子程序标题中声明<span class="bold">形式参数</span> 。在每个形式参数声明中，指定参数的名称和数据类型，以及（可选）其模式和默认值。在子程序的执行部分中，按名称引用形式参数。
                     </p>
                     <p>调用子程序时，请指定其值将分配给形式参数的<span class="bold">实际</span>参数。相应的实际和形式参数必须具有兼容的数据类型。
                     </p>
                     <div class="infoboxnote" id="GUID-9ACD7C7D-861B-4410-AC6F-8536C191E2EF__GUID-7BC3F85D-6CE5-45D0-846E-AE1842A4A464">
                        <p class="notep1">注意：</p>
                        <p>您可以声明受约束子类型的形式参数，如下所示：</p><pre class="oac_no_warn" dir="ltr">DECLARE <span class="bold">SUBTYPE n1是NUMBER（1）;</span> <span class="bold">SUBTYPE v1 IS VARCHAR2（1）;</span>程序p（n <span class="bold">n1</span> ，v <span class="bold">v1</span> ）是......
</pre><p>但是你不能在形式参数声明中包含约束，如下所示：</p><pre class="oac_no_warn" dir="ltr">DECLARE PROCEDURE p（n <span class="bold">NUMBER（1）</span> ，v <span class="bold">VARCHAR2（1）</span> ）IS ......</pre></div>
                     <div class="infobox-tip" id="GUID-9ACD7C7D-861B-4410-AC6F-8536C191E2EF__GUID-CD4885C2-1B2D-4CE5-A8C1-0BAAB791E67F">
                        <p class="notep1">小费：</p>
                        <p>为避免混淆，请为正式和实际参数使用不同的名称。</p>
                     </div>
                     <div class="infoboxnote" id="GUID-9ACD7C7D-861B-4410-AC6F-8536C191E2EF__GUID-2E052916-E408-4FF9-B2EC-C02E026B7F67">
                        <p class="notep1">注意：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>可以按任何顺序评估实际参数（包括形式参数的默认值）。如果程序确定评估顺序，那么在程序执行此操作时，其行为是不确定的。</p>
                           </li>
                           <li>
                              <p>您不能在服务器到服务器远程过程调用（RPC）中使用LOB参数。</p>
                           </li>
                        </ul>
                     </div>
                     <p>在<a href="plsql-subprograms.html#GUID-9ACD7C7D-861B-4410-AC6F-8536C191E2EF__CIHJHJDE">例8-9中</a> ，该过程具有形式参数<code class="codeph">emp_id</code>和<code class="codeph">amount</code> 。在第一个过程调用中，相应的实际参数是<code class="codeph">emp_num</code>和<code class="codeph">bonus</code> ，其值分别为120和100。在第二个过程调用中，实际参数是<code class="codeph">emp_num</code>和<code class="codeph">merit</code> + <code class="codeph">bonus</code> ，其值分别为120和150。
                     </p>
                     <div class="section">
                        <p class="subhead3" id="GUID-9ACD7C7D-861B-4410-AC6F-8536C191E2EF__GUID-79645156-36D7-4FE1-8354-DE70FBD80551">话题：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="plsql-subprograms.html#GUID-BA13F32D-4E04-4004-8CE5-5B628678A253">约束子类的形式参数</a></p>
                           </li>
                        </ul>
                        <div class="infoboxnotealso" id="GUID-9ACD7C7D-861B-4410-AC6F-8536C191E2EF__GUID-EF8FF330-B07C-4BB3-B91A-38064020FBC4">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><span class="q">“ <a href="formal-parameter-declaration.html#GUID-5BA8E033-96B9-439A-A4FC-4844FEC14AD8" title="A formal parameter declaration specifies the name and data type of the parameter, and (optionally) its mode and default value.">形式参数声明</a> ”</span>用于<span class="q"><a href="formal-parameter-declaration.html#GUID-5BA8E033-96B9-439A-A4FC-4844FEC14AD8" title="形式参数声明指定参数的名称和数据类型，以及（可选）其模式和默认值。">形式参数声明</a></span>的语法和语义</p>
                              </li>
                              <li>
                                 <p><span class="q">“ <a href="expression.html#GUID-D4700B45-F2C8-443E-AEE7-2BD20FFD45B8__CHDBCJGE">function_call :: =</a> ”</span>和<span class="q">“ <a href="expression.html#GUID-D4700B45-F2C8-443E-AEE7-2BD20FFD45B8__CHDEBDGB">function_call</a> ”</span>用于函数调用的语法和语义</p>
                              </li>
                              <li>
                                 <p><span class="q">“ <a href="block.html#GUID-9ACEB9ED-567E-4E1A-A16A-B8B35214FC9D__CJAEJGEA">procedure_call :: =</a> ”</span>和<span class="q">“ <a href="block.html#GUID-9ACEB9ED-567E-4E1A-A16A-B8B35214FC9D__CHDIICHC">procedure</a> ”，</span>用于过程调用的语法和语义</p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-9ACD7C7D-861B-4410-AC6F-8536C191E2EF__CIHJHJDE">
                        <p class="titleinexample">例8-9形式参数和实际参数</p><pre class="oac_no_warn" dir="ltr">DECLARE emp_num NUMBER（6）：= 120;奖金数量（6）：= 100;功绩NUMBER（4）：= 50; PROCEDURE raise_salary（ <span class="bold">emp_id NUMBER， - 形式参数</span> <span class="bold">金额NUMBER  - 形式参数</span> ）IS BEGIN UPDATE employees SET salary = salary + <span class="bold">amount</span> <span class="bold">- 对形式参数</span> WHERE employee_id = <span class="bold">emp_id的</span> <span class="bold">引用</span> ; <span class="bold">- 引用形式参数</span> END raise_salary; BEGIN raise_salary（ <span class="bold">emp_num，bonus</span> ）; <span class="bold">- 实际参数</span> / * raise_salary运行此语句：UPDATE employees SET salary = salary + <span class="bold">100</span> WHERE employee_id = <span class="bold">120</span> ; * / raise_salary（ <span class="bold">emp_num，merit + bonus</span> ）; <span class="bold">- 实际参数</span> / * raise_salary运行此语句：UPDATE employees SET salary = salary + <span class="bold">150</span> WHERE employee_id = <span class="bold">120</span> ; */ 结束; /</pre></div>
                     <!-- class="example" -->
                  </div><a id="LNPLS379"></a><a id="LNPLS560"></a><a id="LNPLS562"></a><a id="LNPLS558"></a><div class="props_rev_3"><a id="GUID-BA13F32D-4E04-4004-8CE5-5B628678A253" name="GUID-BA13F32D-4E04-4004-8CE5-5B628678A253"></a><h5 id="LNPLS-GUID-BA13F32D-4E04-4004-8CE5-5B628678A253" class="sect5"><span class="enumeration_section">8.7.1.1</span>约束子类型的形式参数</h5>
                     <div>
                        <p>如果形式参数的数据类型是受约束的子类型，则：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>如果子类型具有<code class="codeph">NOT</code> <code class="codeph">NULL</code>约束，则实际参数继承它。
                              </p>
                           </li>
                           <li>
                              <p>如果子类型具有基本类型<code class="codeph">VARCHAR2</code> ，则实际参数不会继承子类型的大小。
                              </p>
                           </li>
                           <li>
                              <p>如果子类型具有数字基类型，则实际参数将继承子类型的范围，但不会继承精度或比例。</p>
                           </li>
                        </ul>
                        <div class="infoboxnote" id="GUID-BA13F32D-4E04-4004-8CE5-5B628678A253__GUID-931C1F4D-9EB8-4434-AC1E-E892922129AA">
                           <p class="notep1">注意：</p>
                           <p>在函数中，子句<code class="codeph">RETURN</code> <span class="italic"><code class="codeph">datatype</code></span>声明了一个隐藏的形式参数，语句<code class="codeph">RETURN</code> <span class="italic"><code class="codeph">value</code></span>指定了相应的实际参数。因此，如果<span class="italic"><code class="codeph">datatype</code></span>是受约束的数据类型，则前面的规则适用于<span class="italic"><code class="codeph">value</code></span> （请参见<a href="plsql-subprograms.html#GUID-BA13F32D-4E04-4004-8CE5-5B628678A253__CHDEJAEB">示例8-11</a> ）。
                           </p>
                        </div>
                        <p><a href="plsql-subprograms.html#GUID-BA13F32D-4E04-4004-8CE5-5B628678A253__CJAJAHJD">例8-10</a>显示实际的子程序参数继承<code class="codeph">NOT</code> <code class="codeph">NULL</code>约束但不继承<code class="codeph">VARCHAR2</code>子类型的大小。
                        </p>
                        <p>正如<a href="plsql-predefined-data-types.html#GUID-1D28B7B6-15AE-454A-8134-F8724551AE8B">PL / SQL预定义数据类型</a>所示，PL / SQL具有许多预定义数据类型，这些数据类型是其他数据类型的约束子类型。例如， <code class="codeph">INTEGER</code>是<code class="codeph">NUMBER</code>的约束子类型：</p><pre class="oac_no_warn" dir="ltr">SUBTYPE INTEGER是数字（38,0）;</pre><p>在<a href="plsql-subprograms.html#GUID-BA13F32D-4E04-4004-8CE5-5B628678A253__CHDEJAEB">例8-11中</a> ，该函数同时具有<code class="codeph">INTEGER</code>形式参数和<code class="codeph">INTEGER</code>返回类型。匿名块使用不是整数的实际参数调用该函数。由于实际参数继承了<code class="codeph">INTEGER</code>的范围而不是精度和比例，并且实际参数在<code class="codeph">INTEGER</code>范围内，因此调用成功。出于同样的原因， <code class="codeph">RETURN</code>语句成功返回非整数值。
                        </p>
                        <p>在<a href="plsql-subprograms.html#GUID-BA13F32D-4E04-4004-8CE5-5B628678A253__CHDBFCDI">例8-12中</a> ，函数在返回之前隐式地将其形式参数转换为约束子类型<code class="codeph">INTEGER</code> 。
                        </p>
                        <div class="infoboxnotealso" id="GUID-BA13F32D-4E04-4004-8CE5-5B628678A253__GUID-DF5F953A-6CD6-41D1-9FF8-1E9BF2D8D08E">
                           <p class="notep1">也可以看看：</p>
                           <p><span class="q">“ <a href="plsql-data-types.html#GUID-FDC366F3-66AA-4F6A-A59B-5A08DCBD4F9F" title="A constrained subtype has only a subset of the values of its base type.">约束子类型</a> ”</span>用于<span class="q"><a href="plsql-data-types.html#GUID-FDC366F3-66AA-4F6A-A59B-5A08DCBD4F9F" title="受约束的子类型仅具有其基本类型的值的子集。">约束子类型</a></span>的一般信息</p>
                        </div>
                        <div class="example" id="GUID-BA13F32D-4E04-4004-8CE5-5B628678A253__CJAJAHJD">
                           <p class="titleinexample">示例8-10实际参数仅从子类型继承NOT NULL</p><pre class="oac_no_warn" dir="ltr">DECLARE <span class="bold">SUBTYPE许可证IS VARCHAR2（7）NOT NULL</span> ; n许可证：='DLLLDDD';程序p（ <span class="bold">x许可证</span> ）是BEGIN DBMS_OUTPUT.PUT_LINE（x）;结束; BEGIN p（'1ABC123456789'）; <span class="bold"> - 成功; size不是继承</span> p（NULL）; <span class="bold"> - 引发错误; NOT NULL是继承</span> END; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">P（NULL）; - 引发错误;继承NOT NULL *第12行的ERROR：ORA-06550：第12行，第5列：PLS-00567：无法将NULL传递给NOT NULL约束形式参数ORA-06550：第12行，第3列：PL / SQL：语句被忽略</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-BA13F32D-4E04-4004-8CE5-5B628678A253__CHDEJAEB">
                           <p class="titleinexample">示例8-11实际参数和返回值仅从子类型继承范围</p><pre class="oac_no_warn" dir="ltr">DECLARE FUNCTION测试<span class="bold">（p INTEGER）RETURN INTEGER</span>是BEGIN DBMS_OUTPUT.PUT_LINE（'p ='|| p）;返回p;结束测试; BEGIN DBMS_OUTPUT.PUT_LINE（'test（p）='|| test（0.66））;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr"><span class="bold">p = .66</span> <span class="bold">test（p）= .66</span> PL / SQL过程成功完成。
</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-BA13F32D-4E04-4004-8CE5-5B628678A253__CHDBFCDI">
                           <p class="titleinexample">例8-12函数隐式转换形式参数为约束子类型</p><pre class="oac_no_warn" dir="ltr">DECLARE FUNCTION测试<span class="bold">（p NUMBER）返回编号</span>是<span class="bold">q INTEGER：= p; - 隐式将p转换为INTEGER</span> BEGIN DBMS_OUTPUT.PUT_LINE（'p ='|| <span class="bold">q</span> ）; - 显示q，而不是p RETURN <span class="bold">q</span> ; - 返回q，而不是p END测试; BEGIN DBMS_OUTPUT.PUT_LINE（'test（p）='|| test（0.66））;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr"><span class="bold">p = 1</span> <span class="bold">test（p）= 1</span> PL / SQL过程成功完成。</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div>
               </div><a id="LNPLS566"></a><a id="LNPLS99952"></a><div class="props_rev_3"><a id="GUID-18E72176-145F-4E12-95F1-03F84B3D5DC6" name="GUID-18E72176-145F-4E12-95F1-03F84B3D5DC6"></a><h4 id="LNPLS-GUID-18E72176-145F-4E12-95F1-03F84B3D5DC6" class="sect4"><span class="enumeration_section">8.7.2</span>子程序参数传递方法</h4>
                  <div>
                     <p>PL / SQL编译器有两种方法将实际参数传递给子程序：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><span class="bold">引用</span></p>
                           <p>编译器将子程序传递给实际参数。实际和形式参数指的是相同的内存位置。</p>
                        </li>
                        <li>
                           <p><span class="bold">按价值</span></p>
                           <p>编译器将实际参数的值分配给相应的形式参数。实际和形式参数指的是不同的存储位置。</p>
                           <p>如有必要，编译器会隐式地将实际参数的数据类型转换为形式参数的数据类型。有关隐式数据转换的信息，请参阅<a href="../sqlrf/Data-Type-Comparison-Rules.html#SQLRF51047" target="_blank"><span class="italic">Oracle数据库SQL语言参考</span></a> 。
                           </p>
                           <div class="infobox-tip" id="GUID-18E72176-145F-4E12-95F1-03F84B3D5DC6__GUID-71EA1EF8-9A14-476F-A10E-1729D86E6B6C">
                              <p class="notep1">小费：</p>
                              <p>通过以下任一方式避免隐式数据转换（出于<a href="../sqlrf/Data-Type-Comparison-Rules.html#SQLRF51046" target="_blank"><span class="italic">Oracle数据库SQL语言参考中</span></a>的原因）：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>声明要用作实际参数的变量，使用与其相应形式参数相同的数据类型（如<a href="plsql-subprograms.html#GUID-18E72176-145F-4E12-95F1-03F84B3D5DC6__CIHFEEIJ">例8-13</a>中变量<code class="codeph">x</code>的声明）。
                                    </p>
                                 </li>
                                 <li>
                                    <p>使用<a href="../sqlrf/Data-Type-Comparison-Rules.html#SQLRF51054" target="_blank"><span class="italic">Oracle数据库SQL语言参考中</span></a>描述的SQL转换函数将实际参数显式转换为其相应形式参数的数据类型（如<a href="plsql-subprograms.html#GUID-18E72176-145F-4E12-95F1-03F84B3D5DC6__CIHFEEIJ">示例8-13</a>中的过程的第三次调用）。
                                    </p>
                                 </li>
                              </ul>
                           </div>
                        </li>
                     </ul>
                     <p>在<a href="plsql-subprograms.html#GUID-18E72176-145F-4E12-95F1-03F84B3D5DC6__CIHFEEIJ">例8-13中</a> ，过程<code class="codeph">p</code>有一个参数<code class="codeph">n</code> ，它通过值传递。匿名块调用<code class="codeph">p</code>三次，避免两次隐式转换。
                     </p>
                     <p>编译器传递特定实际参数的方法取决于其模式，如<span class="q">“ <a href="plsql-subprograms.html#GUID-518B8827-26CC-4734-B799-ACB038185638">子程序参数模式</a> ”中所述</span> 。
                     </p>
                     <div class="example" id="GUID-18E72176-145F-4E12-95F1-03F84B3D5DC6__CIHFEEIJ">
                        <p class="titleinexample">例8-13避免实际参数的隐式转换</p><pre class="oac_no_warn" dir="ltr">创建或替换过程p（ <span class="bold">n NUMBER</span> ）AUTHID DEFINER开始为空;结束; / DECLARE <span class="bold">x NUMBER</span> ：= 1; y VARCHAR2（1）：='1';开始p（ <span class="bold">x</span> ）; <span class="bold">- 不需要转换</span> p（y）; -  z从VARCHAR2隐式转换为NUMBER p（ <span class="bold">TO_NUMBER（y）</span> ）; <span class="bold">-  z显式从VARCHAR2转换为NUMBER</span> END; /</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="LNPLS665"></a><a id="LNPLS662"></a><a id="LNPLS567"></a><a id="LNPLS2171"></a><a id="LNPLS659"></a><div class="props_rev_3"><a id="GUID-518B8827-26CC-4734-B799-ACB038185638" name="GUID-518B8827-26CC-4734-B799-ACB038185638"></a><h4 id="LNPLS-GUID-518B8827-26CC-4734-B799-ACB038185638" class="sect4"><span class="enumeration_section">8.7.3</span>子程序参数模式</h4>
                  <div>
                     <p>形式参数的<span class="bold">模式</span>决定了它的行为。
                     </p>
                     <p><a href="plsql-subprograms.html#GUID-518B8827-26CC-4734-B799-ACB038185638__BCFHBGBI" title="该表总结并比较了子程序参数的参数模式。">表8-1</a>总结并比较了子程序参数模式的特性。
                     </p>
                     <div class="tblformal" id="GUID-518B8827-26CC-4734-B799-ACB038185638__BCFHBGBI">
                        <p class="titleintable">表8-1 PL / SQL子程序参数模式</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="PL / SQL子程序参数模式" width="100%" border="1" summary="This table summarizes and compares the parameter modes of subprogram parameters." frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="19%" id="d58247e2778">参数模式</th>
                                 <th align="left" valign="bottom" width="19%" id="d58247e2781">是默认的吗？</th>
                                 <th align="left" valign="bottom" width="63%" id="d58247e2784">角色</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="19%" id="d58247e2789" headers="d58247e2778 ">
                                    <p>在</p>
                                 </td>
                                 <td align="left" valign="top" width="19%" headers="d58247e2789 d58247e2781 ">
                                    <p>默认模式</p>
                                 </td>
                                 <td align="left" valign="top" width="63%" headers="d58247e2789 d58247e2784 ">
                                    <p>将值传递给子程序。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="19%" id="d58247e2799" headers="d58247e2778 ">
                                    <p>OUT</p>
                                 </td>
                                 <td align="left" valign="top" width="19%" headers="d58247e2799 d58247e2781 ">
                                    <p>必须指定。</p>
                                 </td>
                                 <td align="left" valign="top" width="63%" headers="d58247e2799 d58247e2784 ">
                                    <p>返回调用者的值。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="19%" id="d58247e2809" headers="d58247e2778 ">
                                    <p>进出</p>
                                 </td>
                                 <td align="left" valign="top" width="19%" headers="d58247e2809 d58247e2781 ">
                                    <p>必须指定。</p>
                                 </td>
                                 <td align="left" valign="top" width="63%" headers="d58247e2809 d58247e2784 ">
                                    <p>将初始值传递给子程序并将更新的值返回给调用者。</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <div class="tblformalwide" id="GUID-518B8827-26CC-4734-B799-ACB038185638__PLSQLSUBPROGRAMPARAMETERMODES-521E28A5">
                        <p class="titleintable">表8-2 PL / SQL子程序参数模式特性</p>
                        <table cellpadding="4" cellspacing="0" class="FormalWide" title="PL / SQL子程序参数模式特性" width="100%" border="1" summary="This table summarizes and compares the parameter modes of subprogram parameters and their characteristics." frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="15%" id="d58247e2830">参数模式</th>
                                 <th align="left" valign="bottom" width="30%" id="d58247e2833">形式参数</th>
                                 <th align="left" valign="bottom" width="32%" id="d58247e2836">实际参数</th>
                                 <th align="left" valign="bottom" width="24%" id="d58247e2839">通过参考？</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="15%" id="d58247e2844" headers="d58247e2830 ">
                                    <p>在</p>
                                 </td>
                                 <td align="left" valign="top" width="30%" headers="d58247e2844 d58247e2833 ">
                                    <p>形式参数的作用类似于常量：当子程序开始时，其值是其实际参数或默认值的值，子程序不能更改此值。</p>
                                 </td>
                                 <td align="left" valign="top" width="32%" headers="d58247e2844 d58247e2836 ">
                                    <p>实际参数可以是常量，初始化变量，文字或表达式。</p>
                                 </td>
                                 <td align="left" valign="top" width="24%" headers="d58247e2844 d58247e2839 ">
                                    <p>实际参数通过引用传递。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="15%" id="d58247e2857" headers="d58247e2830 ">
                                    <p>OUT</p>
                                 </td>
                                 <td align="left" valign="top" width="30%" headers="d58247e2857 d58247e2833 ">
                                    <p>正式参数初始化为其类型的默认值。该类型的默认值是<code class="codeph">NULL</code> ，除了用非记录类型<code class="codeph">NULL</code>缺省值（参见<a href="plsql-subprograms.html#GUID-518B8827-26CC-4734-B799-ACB038185638__CHDJEJHG">实施例8-16</a> ）。
                                    </p>
                                    <p>当子程序开始时，无论其实际参数的值如何，形式参数都具有其初始值。Oracle建议子程序为formal参数赋值。</p>
                                 </td>
                                 <td align="left" valign="top" width="32%" headers="d58247e2857 d58247e2836 ">
                                    <p>如果形式参数类型的默认值为<code class="codeph">NULL</code> ，则实际参数必须是其数据类型未定义为<code class="codeph">NOT</code> <code class="codeph">NULL</code>的变量。</p>
                                 </td>
                                 <td align="left" valign="top" width="24%" headers="d58247e2857 d58247e2839 ">
                                    <p>默认情况下，实际参数按值传递;如果指定<code class="codeph">NOCOPY</code> ，则可以通过引用传递。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="15%" id="d58247e2892" headers="d58247e2830 ">
                                    <p>进出</p>
                                 </td>
                                 <td align="left" valign="top" width="30%" headers="d58247e2892 d58247e2833 ">
                                    <p>形式参数的作用类似于初始化变量：当子程序开始时，其值是其实际参数的值。Oracle建议子程序更新其值。</p>
                                 </td>
                                 <td align="left" valign="top" width="32%" headers="d58247e2892 d58247e2836 ">
                                    <p>实际参数必须是变量（通常，它是字符串缓冲区或数字累加器）。</p>
                                 </td>
                                 <td align="left" valign="top" width="24%" headers="d58247e2892 d58247e2839 ">
                                    <p>默认情况下，实际参数按值传递（在两个方向上）;如果指定<code class="codeph">NOCOPY</code> ，则可以通过引用传递。
                                    </p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <div class="infobox-tip" id="GUID-518B8827-26CC-4734-B799-ACB038185638__GUID-0242530B-3A27-46E1-B799-1A785BC91ADA">
                        <p class="notep1">小费：</p>
                        <p>不要使用<code class="codeph">OUT</code>和<code class="codeph">IN</code> <code class="codeph">OUT</code>作为功能参数。理想情况下，函数接受零个或多个参数并返回单个值。具有<code class="codeph">IN</code> <code class="codeph">OUT</code>参数的函数返回多个值并具有副作用。
                        </p>
                     </div>
                     <div class="infoboxnote" id="GUID-518B8827-26CC-4734-B799-ACB038185638__GUID-5EE12830-268B-4A71-9AEC-FE77FCF093DA">
                        <p class="notep1">注意：</p>
                        <p>Oracle数据库提供的许多软件包和类型的规范使用以下表示法声明形式参数：</p><pre class="oac_no_warn" dir="ltr">i1 IN VARCHAR2 CHARACTER SET ANY_CS i2 IN VARCHAR2 CHARACTER SET i1％CHARSET</pre><p>在声明自己的正式或实际参数时，请勿使用此表示法。它保留用于Oracle实现提供的包类型。</p>
                     </div>
                     <p>无论<code class="codeph">OUT</code>或<code class="codeph">IN</code> <code class="codeph">OUT</code>参数如何传递：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>如果子程序成功退出，则实际参数的值是分配给形式参数的最终值。（形式参数至少分配了一个值 - 初始值。）</p>
                        </li>
                        <li>
                           <p>如果子程序以异常结束，则实际参数的值未定义。</p>
                        </li>
                        <li>
                           <p>可以按任何顺序返回正式的<code class="codeph">OUT</code>和<code class="codeph">IN</code> <code class="codeph">OUT</code>参数。在此示例中， <code class="codeph">x</code>和<code class="codeph">y</code>的最终值未定义：</p><pre class="oac_no_warn" dir="ltr">创建或替换过程p（x OUT INTEGER，y OUT INTEGER）as BEGIN x：= 17; y：= 93;结束; /</pre></li>
                     </ul>
                     <p>当通过引用传递<code class="codeph">OUT</code>或<code class="codeph">IN</code> <code class="codeph">OUT</code>参数时，实际和形式参数引用相同的存储器位置。因此，如果子程序更改形式参数的值，则更改会立即显示在实际参数中（请参阅<span class="q">“ <a href="plsql-subprograms.html#GUID-1D93EBAE-406B-45CE-B89F-A456E37415CB">参数传递参数的子程序参数别名</a> ”</span> ）。
                     </p>
                     <p>在<a href="plsql-subprograms.html#GUID-518B8827-26CC-4734-B799-ACB038185638__G1170259">例8-14中</a> ，过程<code class="codeph">p</code>有两个<code class="codeph">IN</code>参数，一个<code class="codeph">OUT</code>参数和一个<code class="codeph">IN</code> <code class="codeph">OUT</code>参数。<code class="codeph">OUT</code>和<code class="codeph">IN</code> <code class="codeph">OUT</code>参数按值传递（默认值）。匿名块使用不同的实际参数调用<code class="codeph">p</code>两次。在每次调用之前，匿名块将打印实际参数的值。过程<code class="codeph">p</code>打印其形式参数的初始值。每次调用后，匿名块将再次打印实际参数的值。
                     </p>
                     <p>在<a href="plsql-subprograms.html#GUID-518B8827-26CC-4734-B799-ACB038185638__CHDBGIHE">例8-15中</a> ，匿名块使用实际参数调用过程<code class="codeph">p</code> （来自<a href="plsql-subprograms.html#GUID-518B8827-26CC-4734-B799-ACB038185638__G1170259">例8-14</a> ），该参数使<code class="codeph">p</code>引发预定义的异常<code class="codeph">ZERO_DIVIDE</code> ，而<code class="codeph">p</code>不处理。异常传播到匿名块，该块处理<code class="codeph">ZERO_DIVIDE</code>并显示<code class="codeph">p</code>的<code class="codeph">IN</code>和<code class="codeph">IN</code> <code class="codeph">OUT</code>参数的实际参数保留了它们在调用之前具有的值。（异常传播在<span class="q">“ <a href="plsql-error-handling.html#GUID-A99B76C3-44DF-40E1-AB7A-454C6805B9BB">异常传播</a> ”中进行了</span>解释。）
                     </p>
                     <p>在<a href="plsql-subprograms.html#GUID-518B8827-26CC-4734-B799-ACB038185638__CHDJEJHG">例8-16中</a> ，过程<code class="codeph">p</code>有三个<code class="codeph">OUT</code>形式参数： <code class="codeph">x</code> ，具有非<code class="codeph">NULL</code>默认值的记录类型; <code class="codeph">y</code> ，没有非<code class="codeph">NULL</code>默认值的记录类型;和<code class="codeph">z</code> ，这不是记录。
                     </p>
                     <p><code class="codeph">x</code> ， <code class="codeph">y</code>和<code class="codeph">z</code>的相应实际参数分别为<code class="codeph">r1</code> ， <code class="codeph">r2</code>和<code class="codeph">s</code> 。 <code class="codeph">s</code>以初始值声明。但是，当调用<code class="codeph">p</code>时， <code class="codeph">s</code>的值初始化为<code class="codeph">NULL</code> 。 <code class="codeph">r1</code>和<code class="codeph">r2</code>的值分别初始化为其记录类型的默认值<code class="codeph">'abcde'</code>和<code class="codeph">NULL</code> 。
                     </p>
                     <div class="example" id="GUID-518B8827-26CC-4734-B799-ACB038185638__G1170259">
                        <p class="titleinexample">示例8-14过程调用之前，期间和之后的参数值</p><pre class="oac_no_warn" dir="ltr">创建或替换过程p（PLS_INTEGER， <span class="bold">-  IN默认为</span> b <span class="bold">IN</span> PLS_INTEGER，c <span class="bold">OUT</span> PLS_INTEGER，d <span class="bold">IN OUT</span> BINARY_FLOAT）AUTHID DEFINER BEGIN  - 打印参数值：DBMS_OUTPUT.PUT_LINE（'内部过程p：'）; DBMS_OUTPUT.PUT（'IN a ='）; DBMS_OUTPUT.PUT_LINE（NVL（TO_CHAR（a），'NULL'））; DBMS_OUTPUT.PUT（'IN b ='）; DBMS_OUTPUT.PUT_LINE（NVL（TO_CHAR（b），'NULL'））; DBMS_OUTPUT.PUT（'OUT c ='）; DBMS_OUTPUT.PUT_LINE（NVL（TO_CHAR（c），'NULL'））; DBMS_OUTPUT.PUT_LINE（'IN OUT d ='|| TO_CHAR（d））; <span class="bold">- 可以引用IN参数a和b，</span> <span class="bold">- 但不能为它们赋值。</span>c：= a + 10; <span class="bold">- 为OUT参数</span> d：= 10 / b <span class="bold">分配值</span> ; <span class="bold">- 为IN OUT参数</span> END <span class="bold">赋值</span> ; / DECLARE aa CONSTANT PLS_INTEGER：= 1; bb PLS_INTEGER：= 2; cc PLS_INTEGER：= 3; dd BINARY_FLOAT：= 4; ee PLS_INTEGER; ff BINARY_FLOAT：= 5; BEGIN DBMS_OUTPUT.PUT_LINE（'在调用过程p：'之前）; DBMS_OUTPUT.PUT（'aa ='）; DBMS_OUTPUT.PUT_LINE（NVL（TO_CHAR（aa），'NULL'））; DBMS_OUTPUT.PUT（'bb ='）; DBMS_OUTPUT.PUT_LINE（NVL（TO_CHAR（bb），'NULL'））; DBMS_OUTPUT.PUT（'cc ='）; DBMS_OUTPUT.PUT_LINE（NVL（TO_CHAR（cc），'NULL'））; DBMS_OUTPUT.PUT_LINE（'dd ='|| TO_CHAR（dd））; p（aa， - 常数bb， - 初始化变量cc， - 初始化变量dd  - 初始化变量）; DBMS_OUTPUT.PUT_LINE（'调用过程p：'后）; DBMS_OUTPUT.PUT（'aa ='）; DBMS_OUTPUT.PUT_LINE（NVL（TO_CHAR（aa），'NULL'））; DBMS_OUTPUT.PUT（'bb ='）; DBMS_OUTPUT.PUT_LINE（NVL（TO_CHAR（bb），'NULL'））; DBMS_OUTPUT.PUT（'cc ='）; DBMS_OUTPUT.PUT_LINE（NVL（TO_CHAR（cc），'NULL'））; DBMS_OUTPUT.PUT_LINE（'dd ='|| TO_CHAR（dd））; DBMS_OUTPUT.PUT_LINE（'在调用过程p：'之前）; DBMS_OUTPUT.PUT（'ee ='）; DBMS_OUTPUT.PUT_LINE（NVL（TO_CHAR（ee），'NULL'））; DBMS_OUTPUT.PUT_LINE（'ff ='|| TO_CHAR（ff））; p（1， -  literal（bb + 3）* 4， -  expression ee， -  uninitialized variable ff  -  initialized variable）; DBMS_OUTPUT.PUT_LINE（'调用过程p：'后）; DBMS_OUTPUT.PUT（'ee ='）; DBMS_OUTPUT.PUT_LINE（NVL（TO_CHAR（ee），'NULL'））; DBMS_OUTPUT.PUT_LINE（'ff ='|| TO_CHAR（ff））;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">在调用程序之前p：aa = 1 bb = 2 cc = 3 dd = 4.0E + 000内部程序p：IN a = 1 IN b = 2 OUT c = NULL IN OUT d = 4.0E + 000调用程序后p：aa = 1 bb = 2 cc = 11 dd = 5.0E + 000在调用程序之前p：ee = NULL ff = 5.0E + 000内部程序p：IN a = 1 IN b = 20 OUT c = NULL IN OUT d = 5.0E +000调用过程后p：ee = 11 ff = 5.0E-001 PL / SQL过程成功完成。
</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-518B8827-26CC-4734-B799-ACB038185638__CHDBGIHE">
                        <p class="titleinexample">例8-15异常处理后的OUT和IN OUT参数值</p><pre class="oac_no_warn" dir="ltr">DECLARE j PLS_INTEGER：= 10; k BINARY_FLOAT：= 15; BEGIN DBMS_OUTPUT.PUT_LINE（'在调用过程p：'之前）; DBMS_OUTPUT.PUT（'j ='）; DBMS_OUTPUT.PUT_LINE（NVL（TO_CHAR（j），'NULL'））; DBMS_OUTPUT.PUT_LINE（'k ='|| TO_CHAR（k））; p（4,0，j，k）; - 导致p退出时出现异常ZERO_DIVIDE EXCEPTION ZERO_DIVIDE，然后DBMS_OUTPUT.PUT_LINE（'调用过程p：'后）; DBMS_OUTPUT.PUT（'j ='）; DBMS_OUTPUT.PUT_LINE（NVL（TO_CHAR（j），'NULL'））; DBMS_OUTPUT.PUT_LINE（'k ='|| TO_CHAR（k））;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">在调用过程之前p：j = 10 k = 1.5E + 001内部过程p：IN a = 4 IN b = 0 OUT c = NULL IN OUT d = 1.5E + 001调用过程后p：j = 10 k = 1.5E +001 PL / SQL程序成功完成。
</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-518B8827-26CC-4734-B799-ACB038185638__CHDJEJHG">
                        <p class="titleinexample">例8-16具有非NULL默认值的记录类型的OUT形式参数</p><pre class="oac_no_warn" dir="ltr">创建或替换包装r_types AUTHID DEFINER是类型r_type_1是记录（f VARCHAR2（5）：='abcde'）; TYPE r_type_2是RECORD（f VARCHAR2（5））;结束; /创建或替换过程p（x OUT r_types.r_type_1，y OUT r_types.r_type_2，z OUT VARCHAR2）AUTHID CURRENT_USER是BEGIN DBMS_OUTPUT.PUT_LINE（'xf是'|| NVL（xf，'NULL'））; DBMS_OUTPUT.PUT_LINE（'yf is'|| NVL（yf，'NULL'））; DBMS_OUTPUT.PUT_LINE（'z是'|| NVL（z，'NULL'））;结束; / DECLARE r1 r_types.r_type_1; r2 r_types.r_type_2; s VARCHAR2（5）：='fghij'; BEGIN p（r1，r2，s）;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">xf是abcde yf是NULL z是NULL PL / SQL过程成功完成。</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="LNPLS569"></a><a id="LNPLS00815"></a><div class="props_rev_3"><a id="GUID-CB95955E-8843-4481-BB07-A52CA2FF4A8B" name="GUID-CB95955E-8843-4481-BB07-A52CA2FF4A8B"></a><h4 id="LNPLS-GUID-CB95955E-8843-4481-BB07-A52CA2FF4A8B" class="sect4"><span class="enumeration_section">8.7.4</span>子程序参数混叠</h4>
                  <div>
                     <p><span class="bold">别名</span>对于相同的内存位置有两个不同的名称。如果存储的项目可以通过多个路径显示，并且您可以按一个路径更改项目，则可以按所有路径查看更改。
                     </p>
                     <p>子程序参数别名总是在编译器通过引用传递实际参数时发生，并且当子程序具有游标变量参数时也会发生。</p>
                     <div class="section">
                        <p class="subhead3" id="GUID-CB95955E-8843-4481-BB07-A52CA2FF4A8B__GUID-F671B5D3-239C-4CFA-ADB8-D017621ECEFC">话题</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="plsql-subprograms.html#GUID-1D93EBAE-406B-45CE-B89F-A456E37415CB">参数传递的子程序参数混叠</a></p>
                           </li>
                           <li>
                              <p><a href="plsql-subprograms.html#GUID-2CCDEA03-F0ED-463A-BEC1-3F9430047692">带有光标变量参数的子程序参数混叠</a></p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div><a id="LNPLS695"></a><a id="LNPLS696"></a><a id="LNPLS99892"></a><div class="props_rev_3"><a id="GUID-1D93EBAE-406B-45CE-B89F-A456E37415CB" name="GUID-1D93EBAE-406B-45CE-B89F-A456E37415CB"></a><h5 id="LNPLS-GUID-1D93EBAE-406B-45CE-B89F-A456E37415CB" class="sect5"><span class="enumeration_section">8.7.4.1</span>参数传递参数的子程序参数混叠</h5>
                     <div>
                        <p>当编译器通过引用传递实际参数时，实际和形式参数引用相同的存储器位置。因此，如果子程序更改形式参数的值，则更改会立即显示在实际参数中。</p>
                        <p>编译器始终通过引用传递<code class="codeph">IN</code>参数，但结果别名不会导致问题，因为子程序无法为<code class="codeph">IN</code>参数赋值。
                        </p>
                        <p>如果为该参数指定<code class="codeph">NOCOPY</code> ，则编译器<span class="italic">可以</span>通过引用传递<code class="codeph">OUT</code>或<code class="codeph">IN</code> <code class="codeph">OUT</code>参数。<code class="codeph">NOCOPY</code>只是一个提示 - 每次调用子程序时，编译器都会默默地决定是服从还是忽略<code class="codeph">NOCOPY</code> 。因此，对于一次调用而不是另一次调用可能会出现别名，从而使子程序结果不确定。例如：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>如果实际参数是全局变量，那么对参数的赋值<span class="italic">可能会</span>显示在global参数中（参见<a href="plsql-subprograms.html#GUID-1D93EBAE-406B-45CE-B89F-A456E37415CB__CIHBCCHI">例8-17</a> ）。
                              </p>
                           </li>
                           <li>
                              <p>如果相同的变量是两个形式参数的实际参数，然后分配给任何正式的参数<span class="italic">可能</span>在正式参数立即显示（见<a href="plsql-subprograms.html#GUID-1D93EBAE-406B-45CE-B89F-A456E37415CB__CIHJIDAB">例8-18</a> ）。
                              </p>
                           </li>
                           <li>
                              <p>如果实际参数是包变量，那么对形式参数或包变量的赋值<span class="italic">可能会</span>立即显示在形式参数和包变量中。
                              </p>
                           </li>
                           <li>
                              <p>如果子程序退出时出现未处理的异常，则<span class="italic">可能会</span>在实际参数中显示形式参数的赋值。
                              </p>
                           </li>
                        </ul>
                        <div class="infoboxnotealso" id="GUID-1D93EBAE-406B-45CE-B89F-A456E37415CB__GUID-3B9C9E03-5FF6-4CFE-84FF-D557A5B54EC5">
                           <p class="notep1">也可以看看：</p>
                           <p><span class="q">“ <a href="formal-parameter-declaration.html#GUID-5BA8E033-96B9-439A-A4FC-4844FEC14AD8__CJACJCGJ">NOCOPY</a> ”</span>表示编译器始终忽略<code class="codeph">NOCOPY</code></p>
                        </div>
                        <p>在<a href="plsql-subprograms.html#GUID-1D93EBAE-406B-45CE-B89F-A456E37415CB__CIHBCCHI">例8-17中</a> ，该过程有一个<code class="codeph">IN</code> <code class="codeph">OUT</code> <code class="codeph">NOCOPY</code>形式参数，它为其赋值<code class="codeph">'aardvark'</code> 。匿名块将值<code class="codeph">'aardwolf'</code>分配给全局变量，然后将全局变量传递给过程。如果编译器服从<code class="codeph">NOCOPY</code>提示，那么全局变量的最终值是<code class="codeph">'aardvark'</code> 。如果编译器忽略<code class="codeph">NOCOPY</code>提示，那么全局变量的最终值是<code class="codeph">'aardwolf'</code> 。
                        </p>
                        <p>在<a href="plsql-subprograms.html#GUID-1D93EBAE-406B-45CE-B89F-A456E37415CB__CIHJIDAB">例8-18中</a> ，该过程具有<code class="codeph">IN</code>参数， <code class="codeph">IN</code> <code class="codeph">OUT</code>参数和<code class="codeph">IN</code> <code class="codeph">OUT</code> <code class="codeph">NOCOPY</code>参数。对于所有三个形式参数，匿名块使用相同的实际参数（全局变量）调用该过程。该过程在更改<code class="codeph">IN</code> <code class="codeph">OUT</code> <code class="codeph">NOCOPY</code>参数的值之前更改<code class="codeph">IN</code> <code class="codeph">OUT</code>参数的值。但是，如果编译器遵循<code class="codeph">NOCOPY</code>提示，则后一个更改会立即显示在实际参数中。在程序成功退出并且控制返回到匿名块之后，前一个更改显示在实际参数中。
                        </p>
                        <div class="example" id="GUID-1D93EBAE-406B-45CE-B89F-A456E37415CB__CIHBCCHI">
                           <p class="titleinexample">例8-17全局变量的别名为实际参数</p><pre class="oac_no_warn" dir="ltr">DECLARE TYPE定义IS RECORD（单词VARCHAR2（20），表示VARCHAR2（200））; TYPE Dictionary IS VARRAY（2000）OF Definition;词典：= Dictionary（）; - 全局变量PROCEDURE add_entry（word_list IN OUT NOCOPY Dictionary  - 形式NOCOPY参数）IS BEGIN word_list（1）.word：='aardvark';结束; BEGIN词典。延伸; lexicon（1）.word：='aardwolf'; <span class="bold">add_entry（词汇）; - 全局变量是实际参数</span> DBMS_OUTPUT.PUT_LINE（lexicon（1）.word）;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">土豚</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-1D93EBAE-406B-45CE-B89F-A456E37415CB__CIHJIDAB">
                           <p class="titleinexample">例8-18多个形式参数的相同实际参数的别名</p><pre class="oac_no_warn" dir="ltr">DECLARE n NUMBER：= 10;程序p（数字中的n1，输出数字中的n2，输出的数量为n3）是否为n2：= 20; <span class="bold">- 只有在程序成功</span> DBMS_OUTPUT.put_line（n1） <span class="bold">后，实际参数才为20</span> ; <span class="bold">- 实际参数值仍为10</span> n3：= 30; <span class="bold">- 可能会立即更改实际参数</span> DBMS_OUTPUT.put_line（n1）; <span class="bold">- 实际参数值为10或30</span> END; BEGIN p（n，n，n）; DBMS_OUTPUT.PUT_LINE（N）;结束; /</pre><p>如果编译器遵循<code class="codeph">NOCOPY</code>提示，则结果如下：</p><pre class="oac_no_warn" dir="ltr">10 30 20</pre><p>如果编译器忽略<code class="codeph">NOCOPY</code>提示，则结果：</p><pre class="oac_no_warn" dir="ltr">10 10 30</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="LNPLS697"></a><a id="LNPLS99891"></a><div class="props_rev_3"><a id="GUID-2CCDEA03-F0ED-463A-BEC1-3F9430047692" name="GUID-2CCDEA03-F0ED-463A-BEC1-3F9430047692"></a><h5 id="LNPLS-GUID-2CCDEA03-F0ED-463A-BEC1-3F9430047692" class="sect5"><span class="enumeration_section">8.7.4.2</span>带有游标变量参数的子程序参数混叠</h5>
                     <div>
                        <p>游标变量参数是指针。因此，如果子程序将一个游标变量参数分配给另一个，则它们引用相同的内存位置。此别名可能会产生意想不到的结果。</p>
                        <p>在<a href="plsql-subprograms.html#GUID-2CCDEA03-F0ED-463A-BEC1-3F9430047692__CIHBIFGC">例8-19中</a> ，该过程有两个游标变量参数<code class="codeph">emp_cv1</code>和<code class="codeph">emp_cv2</code> 。该过程打开<code class="codeph">emp_cv1</code>并将其值（指针）分配给<code class="codeph">emp_cv2</code> 。现在<code class="codeph">emp_cv1</code>和<code class="codeph">emp_cv2</code>指的是相同的内存位置。当该过程关闭<code class="codeph">emp_cv1</code> ，它也会关闭<code class="codeph">emp_cv2</code> 。因此，当过程尝试从<code class="codeph">emp_cv2</code>获取时，PL / SQL会引发异常。
                        </p>
                        <div class="example" id="GUID-2CCDEA03-F0ED-463A-BEC1-3F9430047692__CIHBIFGC">
                           <p class="titleinexample">例8-19游标变量子程序参数的别名</p><pre class="oac_no_warn" dir="ltr">DECLARE TYPE EmpCurTyp是REF CURSOR; c1 EmpCurTyp; c2 EmpCurTyp;程序get_emp_data（emp_cv1 IN OUT EmpCurTyp，emp_cv2 IN OUT EmpCurTyp）IS emp_rec employees％ROWTYPE; BEGIN OPEN emp_cv1 FOR SELECT * FROM employees; <span class="bold">emp_cv2：= emp_cv1; - 现在两个变量都引用相同的位置</span> FETCH emp_cv1 INTO emp_rec; - 获取第一排员工FETCH emp_cv1 INTO emp_rec; - 获取第二排员工FETCH emp_cv2 INTO emp_rec; - 取得第三排员工<span class="bold">CLOSE emp_cv1; - 关闭两个变量</span> <span class="bold">FETCH emp_cv2 INTO emp_rec; - 调用get_emp_data时导致错误</span> END; BEGIN get_emp_data（c1，c2）;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">第1行的DECLARE * ERROR：ORA-01001：光标无效ORA-06512：第19行ORA-06512：第22行</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div>
               </div><a id="LNPLS667"></a><a id="LNPLS668"></a><a id="LNPLS570"></a><a id="LNPLS666"></a><div class="props_rev_3"><a id="GUID-C1079955-95B2-4D0F-8928-649EDA355461" name="GUID-C1079955-95B2-4D0F-8928-649EDA355461"></a><h4 id="LNPLS-GUID-C1079955-95B2-4D0F-8928-649EDA355461" class="sect4"><span class="enumeration_section">8.7.5</span> IN子程序参数的默认值</h4>
                  <div>
                     <p>声明正式的<code class="codeph">IN</code>参数时，可以为其指定默认值。具有默认值的形式参数称为<span class="bold">可选参数</span> ，因为其对应的实际参数在子程序调用中是可选的。如果省略实际参数，则调用将默认值分配给formal参数。没有默认值的形式参数称为<span class="bold">必需参数</span> ，因为子程序调用中需要相应的实际参数。
                     </p>
                     <p>省略实际参数不会使相应形式参数的值为<code class="codeph">NULL</code> 。要使形式参数的值为<code class="codeph">NULL</code> ，请将<code class="codeph">NULL</code>指定为默认值或实际参数。
                     </p>
                     <p>在<a href="plsql-subprograms.html#GUID-C1079955-95B2-4D0F-8928-649EDA355461__CIHICIAH">例8-20中</a> ，该过程具有一个必需参数和两个可选参数。
                     </p>
                     <p>在<a href="plsql-subprograms.html#GUID-C1079955-95B2-4D0F-8928-649EDA355461__CIHICIAH">例8-20中</a> ，过程调用以与声明其对应的形式参数相同的顺序指定实际参数 - 即，调用使用位置表示法。位置表示法不允许您省略<code class="codeph">raise_salary</code>的第二个参数，但指定第三个参数;要做到这一点，您必须使用命名或混合表示法。有关详细信息，请参阅<span class="q">“ <a href="plsql-subprograms.html#GUID-A5DA8CF5-1BCC-4ABE-9B68-DB593FF1D2CC">实际参数的位置，命名和混合表示法</a> ”</span> 。
                     </p>
                     <p>形式参数的默认值可以是可以将值赋给参数的任何表达式;也就是说，值和参数必须具有兼容的数据类型。如果子程序调用指定形式参数的实际参数，则该调用不会评估默认值。</p>
                     <p>在<a href="plsql-subprograms.html#GUID-C1079955-95B2-4D0F-8928-649EDA355461__G1782475">例8-21中</a> ，过程<code class="codeph">p</code>有一个参数，其默认值是函数<code class="codeph">f</code>的调用。函数<code class="codeph">f</code>递增全局变量的值。当在没有实际参数的情况下调用<code class="codeph">p</code> ， <code class="codeph">p</code>调用<code class="codeph">f</code> ，并且<code class="codeph">f</code>递增全局变量。当<code class="codeph">p</code>与实际参数调用， <code class="codeph">p</code>不会调用<code class="codeph">f</code>和全局变量的值不会改变。
                     </p>
                     <p><a href="plsql-subprograms.html#GUID-C1079955-95B2-4D0F-8928-649EDA355461__CHDHECGF">例8-22</a>创建一个带有两个必需参数的过程，调用它，然后添加第三个可选参数。因为第三个参数是可选的，所以原始调用仍然有效。
                     </p>
                     <div class="example" id="GUID-C1079955-95B2-4D0F-8928-649EDA355461__CIHICIAH">
                        <p class="titleinexample">示例8-20具有默认参数值的过程</p><pre class="oac_no_warn" dir="ltr">DECLARE PROCEDURE raise_salary（emp_id IN employees.employee_id％TYPE，IN IN employees.salary％TYPE <span class="bold">：= 100</span> ，额外IN employeess.salary％TYPE <span class="bold">：= 50</span> ）IS BEGIN UPDATE员工SET薪水=工资+金额+额外WHERE employee_id = emp_id ; END raise_salary; BEGIN raise_salary（120）; -同<span class="bold"><span class="bold">RAISE_SALARY（120，100，50）RAISE_SALARY（121，200）;</span></span> -同<span class="bold">RAISE_SALARY（121，200，50）END;</span> /</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-C1079955-95B2-4D0F-8928-649EDA355461__G1782475">
                        <p class="titleinexample">例8-21功能提供默认参数值</p><pre class="oac_no_warn" dir="ltr">DECLARE global PLS_INTEGER：= 0;功能f RETURN PLS_INTEGER是BEGIN DBMS_OUTPUT.PUT_LINE（'内部f。“）; global：= global + 1; RETURN global * 2;结束f;程序p（ <span class="bold">x IN PLS_INTEGER：= f（）</span> ）是BEGIN DBMS_OUTPUT.PUT_LINE（'内部p。'|| 'global ='||全球|| '，x ='|| x || ”。'）; DBMS_OUTPUT.PUT_LINE（ '--------------------------------'）;结束p;程序pre_p IS BEGIN DBMS_OUTPUT.PUT_LINE（'在调用p之前，global ='|| global ||'。'）; DBMS_OUTPUT.PUT_LINE（'调用p。“）; END pre_p; BEGIN pre_p; <span class="bold">P（）; - 评估默认表达式</span> pre_p; <span class="bold">P（100）; - 未评估默认表达式</span> pre_p; <span class="bold">P（）; - 评估默认表达式</span> END; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">在调用p之前，global = 0。调用p。
<span class="bold">里面f。</span>里面的p。 global = 1，x = 2。--------------------------------在调用p之前，global = 1。调用p。里面的p。 global = 1，x = 100。--------------------------------在调用p之前，global = 1。调用p。
<span class="bold">里面f。</span>里面的p。 global = 2，x = 4。--------------------------------</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-C1079955-95B2-4D0F-8928-649EDA355461__CHDHECGF">
                        <p class="titleinexample">示例8-22在不更改现有调用的情况下添加子程序参数</p>
                        <p>创建程序：</p><pre class="oac_no_warn" dir="ltr">创建或替换过程print_name（第一个VARCHAR2，最后一个VARCHAR2）AUTHID DEFINER是BEGIN DBMS_OUTPUT.PUT_LINE（第一个||''|| last）; END print_name; /</pre><p>调用程序：</p><pre class="oac_no_warn" dir="ltr">BEGIN print_name（'John'，'Doe'）;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">约翰·多伊</pre><p>使用默认值添加第三个参数：</p><pre class="oac_no_warn" dir="ltr">创建或替换过程print_name（第一个VARCHAR2，最后一个VARCHAR2， <span class="bold">mi VARCHAR2：= NULL</span> ）如果mi为空，那么AUTHID DEFINER就开始了DBMS_OUTPUT.PUT_LINE（首先||''|| last）; ELSE DBMS_OUTPUT.PUT_LINE（首先||''|| mi ||'。'|| last）;万一; END print_name; /</pre><p>调用程序：</p><pre class="oac_no_warn" dir="ltr">BEGIN print_name（'John'，'Doe'）; <span class="bold">- 原始调用</span> print_name（'John'，'Public'，'Q'）; <span class="bold">- 新调用</span> END; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">John Doe John Q. Public</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="LNPLS573"></a><a id="LNPLS670"></a><a id="LNPLS574"></a><a id="LNPLS00825"></a><div class="props_rev_3"><a id="GUID-A5DA8CF5-1BCC-4ABE-9B68-DB593FF1D2CC" name="GUID-A5DA8CF5-1BCC-4ABE-9B68-DB593FF1D2CC"></a><h4 id="LNPLS-GUID-A5DA8CF5-1BCC-4ABE-9B68-DB593FF1D2CC" class="sect4"><span class="enumeration_section">8.7.6</span>实际参数的位置，命名和混合表示法</h4>
                  <div>
                     <p>调用子程序时，可以使用位置，命名或混合符号指定实际参数。<a href="plsql-subprograms.html#GUID-A5DA8CF5-1BCC-4ABE-9B68-DB593FF1D2CC__CHDBDFEH" title="该表总结并比较了PL / SQL子程序参数表示法。">表8-3</a>总结并比较了这些表示法。
                     </p>
                     <div class="tblformalwide" id="GUID-A5DA8CF5-1BCC-4ABE-9B68-DB593FF1D2CC__CHDBDFEH">
                        <p class="titleintable">表8-3 PL / SQL实际参数表示法</p>
                        <table cellpadding="4" cellspacing="0" class="FormalWide" title="PL / SQL实际参数表示法" width="100%" border="1" summary="This table summarizes and compares the PL/SQL subprogram parameter notations." frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="16%" id="d58247e4057">符号</th>
                                 <th align="left" valign="bottom" width="19%" id="d58247e4059">句法</th>
                                 <th align="left" valign="bottom" width="19%" id="d58247e4062">可选参数</th>
                                 <th align="left" valign="bottom" width="25%" id="d58247e4065">好处</th>
                                 <th align="left" valign="bottom" width="21%" id="d58247e4068">缺点</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="16%" id="d58247e4073" headers="d58247e4057 ">
                                    <p>位置</p>
                                 </td>
                                 <td align="left" valign="top" width="19%" headers="d58247e4073 d58247e4059 ">
                                    <p>按照声明形式参数的顺序指定实际参数。</p>
                                 </td>
                                 <td align="left" valign="top" width="19%" headers="d58247e4073 d58247e4062 ">
                                    <p>您可以省略尾随可选参数。</p>
                                 </td>
                                 <td align="left" valign="top" width="25%" headers="d58247e4073 d58247e4065 "> </td>
                                 <td align="left" valign="top" width="21%" headers="d58247e4073 d58247e4068 ">
                                    <p>以错误的顺序指定实际参数可能会导致难以检测的问题，尤其是在实际参数是文字的情况下。</p>
                                    <p>如果形式参数列表发生更改，子程序调用必须更改，除非列表仅获取新的尾随可选参数（如<a href="plsql-subprograms.html#GUID-C1079955-95B2-4D0F-8928-649EDA355461__CHDHECGF">例8-22所示</a> ）。
                                    </p>
                                    <p>降低了代码清晰度和可维护性。如果子程序具有大量参数，则不推荐使用。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="16%" id="d58247e4093" headers="d58247e4057 ">
                                    <p>命名</p>
                                 </td>
                                 <td align="left" valign="top" width="19%" headers="d58247e4093 d58247e4059 ">
                                    <p>使用以下语法以任何顺序指定实际参数：</p><pre class="oac_no_warn" dir="ltr"><span class="italic">formal</span> =&gt; <span class="italic">actual</span></pre><p><span class="italic"><code class="codeph">formal</code></span>是形参的名称， <span class="italic"><code class="codeph">actual</code></span>是实际参数。
                                    </p>
                                 </td>
                                 <td align="left" valign="top" width="19%" headers="d58247e4093 d58247e4062 ">
                                    <p>您可以省略任何可选参数。</p>
                                 </td>
                                 <td align="left" valign="top" width="25%" headers="d58247e4093 d58247e4065 ">
                                    <p>指定实际参数没有错误的顺序。</p>
                                    <p>仅当形式参数列表获取新的必需参数时，子程序调用才必须更改。</p>
                                    <p>调用由其他人定义或维护的子程序时建议使用。</p>
                                 </td>
                                 <td align="left" valign="top" width="21%" headers="d58247e4093 d58247e4068 "> </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="16%" id="d58247e4126" headers="d58247e4057 ">
                                    <p>杂</p>
                                 </td>
                                 <td align="left" valign="top" width="19%" headers="d58247e4126 d58247e4059 ">
                                    <p>从位置表示法开始，然后对其余参数使用命名表示法。</p>
                                 </td>
                                 <td align="left" valign="top" width="19%" headers="d58247e4126 d58247e4062 ">
                                    <p>在位置表示法中，您可以省略尾随可选参数;在命名表示法中，您可以省略任何可选参数。</p>
                                 </td>
                                 <td align="left" valign="top" width="25%" headers="d58247e4126 d58247e4065 ">
                                    <p>调用具有必需参数后跟可选参数的子程序时非常方便，并且必须仅指定一些可选参数。</p>
                                 </td>
                                 <td align="left" valign="top" width="21%" headers="d58247e4126 d58247e4068 ">
                                    <p>在位置表示法中，错误的顺序可能导致难以检测的问题，尤其是在实际参数是文字的情况下。</p>
                                    <p>对形式参数列表的更改可能需要更改位置表示法。</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <p>在<a href="plsql-subprograms.html#GUID-A5DA8CF5-1BCC-4ABE-9B68-DB593FF1D2CC__CIHHBJDE">例8-23中</a> ，过程调用使用不同的符号，但是是等效的。
                     </p>
                     <p>在<a href="plsql-subprograms.html#GUID-A5DA8CF5-1BCC-4ABE-9B68-DB593FF1D2CC__CHDDBJGC">例8-24中</a> ，SQL <code class="codeph">SELECT</code>语句使用具有不同表示法的等效调用来调用PL / SQL函数<code class="codeph">compute_bonus</code> 。
                     </p>
                     <div class="example" id="GUID-A5DA8CF5-1BCC-4ABE-9B68-DB593FF1D2CC__CIHHBJDE">
                        <p class="titleinexample">示例8-23匿名块中具有不同表示法的等效调用</p><pre class="oac_no_warn" dir="ltr">DECLARE emp_num NUMBER（6）：= 120;奖金数量（6）：= 50; PROCEDURE raise_salary（emp_id NUMBER，NUMBER）IS BEGIN UPDATE employees SET salary = salary + amount WHERE employee_id = emp_id; END raise_salary; BEGIN <span class="bold">- 等效调用：</span> raise_salary（emp_num，bonus）; <span class="bold">- 位置表示法</span> raise_salary（amount =&gt; bonus，emp_id =&gt; emp_num）; <span class="bold">- 命名表示法</span> raise_salary（emp_id =&gt; emp_num，amount =&gt; bonus）; <span class="bold">- 命名表示法</span> raise_salary（emp_num，amount =&gt; bonus）; <span class="bold">- 混合符号</span> END; /</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-A5DA8CF5-1BCC-4ABE-9B68-DB593FF1D2CC__CHDDBJGC">
                        <p class="titleinexample">示例8-24 SELECT语句中具有不同符号的等效调用</p><pre class="oac_no_warn" dir="ltr">创建或替换功能compute_bonus（emp_id NUMBER，奖金编号）返回编号AUTHID DEFINER是emp_sal NUMBER; BEGIN SELECT salary INTO emp_sal FROM employees WHERE employee_id = emp_id;返回emp_sal +奖金; END compute_bonus; / SELECT compute_bonus（120,50）FROM DUAL; <span class="bold">- 位置</span> SELECT compute_bonus（bonus =&gt; 50，emp_id =&gt; 120）FROM DUAL; <span class="bold">- 命名</span> SELECT compute_bonus（120，bonus =&gt; 50）FROM DUAL; <span class="bold"> - 混合</span></pre></div>
                     <!-- class="example" -->
                  </div>
               </div>
            </div><a id="LNPLS680"></a><a id="LNPLS681"></a><a id="LNPLS00808"></a><div class="props_rev_3"><a id="GUID-A7D51201-1711-4F33-827F-70042700801F" name="GUID-A7D51201-1711-4F33-827F-70042700801F"></a><h3 id="LNPLS-GUID-A7D51201-1711-4F33-827F-70042700801F" class="sect3"><span class="enumeration_section">8.8</span>子程序调用解决方案</h3>
               <div>
                  <p>当PL / SQL编译器遇到子程序调用时，它会在当前作用域中首先搜索匹配的子程序声明，然后在必要时在连续的封闭作用域中搜索。</p>
                  <p>如果子程序名称和参数列表匹配，则声明和调用匹配。如果声明中的每个必需形式参数在调用中具有相应的实际参数，则参数列表匹配。</p>
                  <p>如果编译器没有找到调用的匹配声明，则会生成语义错误。</p>
                  <p><a href="plsql-subprograms.html#GUID-A7D51201-1711-4F33-827F-70042700801F__i19285">图8-1</a>显示了PL / SQL编译器如何解析子程序调用。
                  </p>
                  <div class="figure" id="GUID-A7D51201-1711-4F33-827F-70042700801F__i19285">
                     <p class="titleinfigure">图8-1 PL / SQL编译器如何解析调用</p><img src="img/lnpls012.gif" width="285" alt="下面是图8-1的描述" title="下面是图8-1的描述" longdesc="img_text/lnpls012.html"><br><a href="img_text/lnpls012.html">“图8-1 PL / SQL编译器如何解析调用”的说明</a></div>
                  <!-- class="figure" -->
                  <p>在<a href="plsql-subprograms.html#GUID-A7D51201-1711-4F33-827F-70042700801F__CHDECFCH">例8-25中</a> ，函数<code class="codeph">balance</code>尝试使用适当的实际参数调用封闭过程<code class="codeph">swap</code> 。但是， <code class="codeph">balance</code>包含两个名为<code class="codeph">swap</code>嵌套过程，并且两者都没有与封闭过程<code class="codeph">swap</code>相同类型的参数。因此，调用导致编译错误PLS-00306。
                  </p>
                  <div class="example" id="GUID-A7D51201-1711-4F33-827F-70042700801F__CHDECFCH">
                     <p class="titleinexample">示例8-25解析PL / SQL过程名称</p><pre class="oac_no_warn" dir="ltr">DECLARE PROCEDURE swap（n1 NUMBER，n2 NUMBER）是<span class="bold">num1 NUMBER;</span> <span class="bold">num2 NUMBER;</span>功能余额（bal NUMBER）返回号码是x号码：= 10;程序交换（d1 DATE，d2 DATE）是BEGIN NULL;结束;程序交换（b1 BOOLEAN，b2 BOOLEAN）是BEGIN NULL;结束; BEGIN  - 余额<span class="bold">掉期（num1，num2）;</span>返回x;结束余额; BEGIN  - 封闭程序交换NULL;结束交换; BEGIN  - 匿名块NULL;结束; - 匿名阻止/</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">swap（num1，num2）; *第33行的错误：ORA-06550：第33行，第7列：PLS-00306：调用'SWAP'ORA-06550时参数的数量或类型错误：第33行，第7行：PL / SQL：语句被忽略</pre></div>
                  <!-- class="example" -->
               </div>
            </div><a id="LNPLS576"></a><a id="LNPLS671"></a><a id="LNPLS00807"></a><div class="props_rev_3"><a id="GUID-47D5A50E-7AAF-4C80-A06A-37593EA2526A" name="GUID-47D5A50E-7AAF-4C80-A06A-37593EA2526A"></a><h3 id="LNPLS-GUID-47D5A50E-7AAF-4C80-A06A-37593EA2526A" class="sect3"><span class="enumeration_section">8.9</span>重载的子程序</h3>
               <div>
                  <p>PL / SQL允许您重载嵌套的子程序，包子程序和类型方法。如果它们的形式参数在名称，编号，顺序或数据类型族上不同，则可以对几个不同的子程序使用相同的名称。（ <span class="bold">数据类型族</span>是数据类型及其子类型。有关预定义PL / SQL数据类型的数据类型系列，请参阅<a href="plsql-predefined-data-types.html#GUID-1D28B7B6-15AE-454A-8134-F8724551AE8B">PL / SQL预定义数据类型</a> 。有关用户定义的PL / SQL子类型的信息，请参阅<span class="q">“ <a href="plsql-data-types.html#GUID-0E03C20F-2960-4ED9-8692-D4DCBF1F9670" title="PL / SQL允许您定义自己的子类型。">用户定义的PL / SQL子类型</a> ”</span> 。）如果形式参数仅在名称上有所不同，则必须使用命名表示法来指定相应的实际参数。（有关命名表示法的信息，请参阅<span class="q">“ <a href="plsql-subprograms.html#GUID-A5DA8CF5-1BCC-4ABE-9B68-DB593FF1D2CC">实际参数的位置，命名和混合表示法</a> ”</span> 。）
                  </p>
                  <p><a href="plsql-subprograms.html#GUID-47D5A50E-7AAF-4C80-A06A-37593EA2526A__CIHFCEBD">例8-26</a>定义了两个具有相同名称的子程序<code class="codeph">initialize</code> 。这些过程初始化了不同类型的集合。因为过程中的处理是相同的，所以给它们相同的名称是合乎逻辑的。
                  </p>
                  <p>您可以将两个<code class="codeph">initialize</code>过程放在同一个块，子程序，包或类型主体中。PL / SQL通过检查其形式参数来确定要调用的过程。PL / SQL使用的<code class="codeph">initialize</code>版本取决于您是使用<code class="codeph">date_tab_typ</code>还是<code class="codeph">num_tab_typ</code>参数调用过程。
                  </p>
                  <p>有关包中重载过程的示例，请参见<a href="plsql-packages.html#GUID-3A313D35-26B6-4A0D-A128-231692BCBC97__CJAIICFE">示例10-9</a> 。
                  </p>
                  <div class="section">
                     <p class="subhead2" id="GUID-47D5A50E-7AAF-4C80-A06A-37593EA2526A__GUID-76B44466-5C9D-4E46-B012-3EF14B38A9BD">话题</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="plsql-subprograms.html#GUID-A12B503E-9F79-4C44-B221-83B475DE6D50">仅在数值数据类型中不同的形式参数</a></p>
                        </li>
                        <li>
                           <p><a href="plsql-subprograms.html#GUID-BE995DE8-6E36-4728-A2D3-2F8B8438D305">您无法超载的子程序</a></p>
                        </li>
                        <li>
                           <p><a href="plsql-subprograms.html#GUID-ACE7A3B5-CF77-47C7-ACAD-B2D7BC729D45">子程序过载错误</a></p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-47D5A50E-7AAF-4C80-A06A-37593EA2526A__CIHFCEBD">
                     <p class="titleinexample">例8-26重载的子程序</p><pre class="oac_no_warn" dir="ltr">DECLARE TYPE date_tab_typ是由PLS_INTEGER提供的日期索引表; TYPE num_tab_typ是PLS_INTEGER的数字索引表; hiredate_tab date_tab_typ; sal_tab num_tab_typ; PROCEDURE初始化（tab OUT <span class="bold">date_tab_typ</span> ，n INTEGER）IS BEGIN DBMS_OUTPUT.PUT_LINE（'Invoked first version'）; FOR i IN 1..n LOOP标签（i）：= SYSDATE;结束循环; END初始化; PROCEDURE初始化（tab OUT <span class="bold">num_tab_typ</span> ，n INTEGER）IS BEGIN DBMS_OUTPUT.PUT_LINE（'Invoked second version'）; FOR i IN 1..n LOOP标签（i）：= 0.0;结束循环; END初始化; BEGIN <span class="bold">初始化（hiredate_tab，50）;</span> <span class="bold">initialize（sal_tab，100）;</span>结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr"><span class="bold">调用第一个版本</span> <span class="bold">调用第二个版本</span>
</pre></div>
                  <!-- class="example" -->
               </div><a id="LNPLS672"></a><div class="props_rev_3"><a id="GUID-A12B503E-9F79-4C44-B221-83B475DE6D50" name="GUID-A12B503E-9F79-4C44-B221-83B475DE6D50"></a><h4 id="LNPLS-GUID-A12B503E-9F79-4C44-B221-83B475DE6D50" class="sect4"><span class="enumeration_section">8.9.1</span>仅在数值数据类型中不同的形式参数</h4>
                  <div>
                     <p>如果子程序的形式参数仅在数值数据类型上有所不同，则可以重载子程序。此技术在编写数学应用程序编程接口（API）时很有用，因为函数的多个版本可以使用相同的名称，并且每个版本都可以接受不同的数字类型。例如，接受<code class="codeph">BINARY_FLOAT</code>的函数可能更快，而接受<code class="codeph">BINARY_DOUBLE</code>的函数可能更精确。
                     </p>
                     <p>将参数传递给此类重载子程序时，为避免出现问题或意外结果：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>确保为每组预期参数调用子程序的预期版本。</p>
                           <p>例如，如果你有重载函数接受<code class="codeph">BINARY_FLOAT</code>和<code class="codeph">BINARY_DOUBLE</code> ，如果你传递像<code class="codeph">'5.0'</code>这样的<code class="codeph">VARCHAR2</code>文字，会调用它？
                           </p>
                        </li>
                        <li>
                           <p>限定数字文字并使用转换函数来明确预期的参数类型。</p>
                           <p>例如，使用<code class="codeph">5.0f</code> （对于<code class="codeph">BINARY_FLOAT</code> ）， <code class="codeph">5.0d</code> （对于<code class="codeph">BINARY_DOUBLE</code> ）或转换函数（如<code class="codeph">TO_BINARY_FLOAT</code> ， <code class="codeph">TO_BINARY_DOUBLE</code>和<code class="codeph">TO_NUMBER</code> ）等<code class="codeph">TO_BINARY_FLOAT</code> 。</p>
                        </li>
                     </ul>
                     <p>PL / SQL按以下顺序查找匹配的数字参数：</p>
                     <ol>
                        <li>
                           <p><code class="codeph">PLS_INTEGER</code> （或<code class="codeph">BINARY_INTEGER</code> ，相同的数据类型）</p>
                        </li>
                        <li>
                           <p><code class="codeph">数</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">BINARY_FLOAT</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">BINARY_DOUBLE</code></p>
                        </li>
                     </ol>
                     <p><code class="codeph">VARCHAR2</code>值可以与<code class="codeph">NUMBER</code> ， <code class="codeph">BINARY_FLOAT</code>或<code class="codeph">BINARY_DOUBLE</code>参数匹配。
                     </p>
                     <p>PL / SQL使用与提供的参数匹配的第一个重载子程序。例如， <code class="codeph">SQRT</code>函数采用单个参数。有重载版本接受<code class="codeph">NUMBER</code> ， <code class="codeph">BINARY_FLOAT</code>或<code class="codeph">BINARY_DOUBLE</code>参数。如果传递<code class="codeph">PLS_INTEGER</code>参数，则第一个匹配的重载是具有<code class="codeph">NUMBER</code>参数的重载。
                     </p>
                     <p>采用<code class="codeph">NUMBER</code>参数的<code class="codeph">SQRT</code>函数可能是最慢的。要使用更快的版本，请使用<code class="codeph">TO_BINARY_FLOAT</code>或<code class="codeph">TO_BINARY_DOUBLE</code>函数将参数转换为另一种数据类型，然后再将其传递给<code class="codeph">SQRT</code>函数。
                     </p>
                     <p>如果PL / SQL必须将参数转换为另一种数据类型，它首先会尝试将其转换为更高的数据类型。例如：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">ATAN2</code>函数采用两个相同类型的参数。如果传递不同类型的参数 - 例如，一个<code class="codeph">PLS_INTEGER</code>和一个<code class="codeph">BINARY_FLOAT</code> -PL / SQL尝试查找匹配，其中两个参数都使用较高类型。在这种情况下，这是<code class="codeph">ATAN2</code>的版本，它<code class="codeph">ATAN2</code>两个<code class="codeph">BINARY_FLOAT</code>参数; <code class="codeph">PLS_INTEGER</code>参数向上转换。
                           </p>
                        </li>
                        <li>
                           <p>函数采用不同类型的两个参数。一个重载版本采用<code class="codeph">PLS_INTEGER</code>和<code class="codeph">BINARY_FLOAT</code>参数。另一个重载版本需要<code class="codeph">NUMBER</code>和<code class="codeph">BINARY_DOUBLE</code>参数。如果调用此函数并传递两个<code class="codeph">NUMBER</code>参数，PL / SQL首先会找到第二个参数为<code class="codeph">BINARY_FLOAT</code>的重载版本。因为此参数比另一个重载中的<code class="codeph">BINARY_DOUBLE</code>参数更接近匹配，所以PL / SQL向下看并将第一个<code class="codeph">NUMBER</code>参数转换为<code class="codeph">PLS_INTEGER</code> 。</p>
                        </li>
                     </ul>
                  </div>
               </div><a id="LNPLS673"></a><div class="props_rev_3"><a id="GUID-BE995DE8-6E36-4728-A2D3-2F8B8438D305" name="GUID-BE995DE8-6E36-4728-A2D3-2F8B8438D305"></a><h4 id="LNPLS-GUID-BE995DE8-6E36-4728-A2D3-2F8B8438D305" class="sect4"><span class="enumeration_section">8.9.2</span>无法过载的子程序</h4>
                  <div>
                     <p>您不能重载这些子程序：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>独立子程序</p>
                        </li>
                        <li>
                           <p>形式参数仅在模式上不同的子程序;例如：</p><pre class="oac_no_warn" dir="ltr">程序s（p <span class="bold">IN</span> VARCHAR2）是......程序s（p <span class="bold">OUT</span> VARCHAR2）是......
</pre></li>
                        <li>
                           <p>形式参数仅在子类型上不同的子程序;例如：</p><pre class="oac_no_warn" dir="ltr">程序s（p <span class="bold">INTEGER</span> ）是......程序s（p <span class="bold">REAL</span> ）是......
</pre><p><code class="codeph">INTEGER</code>和<code class="codeph">REAL</code>是<code class="codeph">NUMBER</code>子类型，因此它们属于同一数据类型系列。
                           </p>
                        </li>
                        <li>
                           <p>即使数据类型在不同的系列中，仅在返回值数据类型方面不同的函数;例如：</p><pre class="oac_no_warn" dir="ltr">功能f（p INTEGER）返回<span class="bold">BOOLEAN</span>是......功能f（p INTEGER）返回<span class="bold">INTEGER</span>是......</pre></li>
                     </ul>
                  </div>
               </div><a id="LNPLS675"></a><a id="LNPLS676"></a><a id="LNPLS677"></a><a id="LNPLS582"></a><a id="LNPLS584"></a><a id="LNPLS678"></a><a id="LNPLS679"></a><a id="LNPLS674"></a><div class="props_rev_3"><a id="GUID-ACE7A3B5-CF77-47C7-ACAD-B2D7BC729D45" name="GUID-ACE7A3B5-CF77-47C7-ACAD-B2D7BC729D45"></a><h4 id="LNPLS-GUID-ACE7A3B5-CF77-47C7-ACAD-B2D7BC729D45" class="sect4"><span class="enumeration_section">8.9.3</span>子程序过载错误</h4>
                  <div>
                     <p>PL / SQL编译器一旦确定无法确定调用哪个子程序，就会捕获重载错误。当子程序具有相同的标题时，编译器会在您尝试编译子程序本身（如果它们是嵌套的）或者您尝试编译声明它们的包规范时捕获重载错误。否则，当您尝试编译子程序的模糊调用时，编译器会捕获错误。</p>
                     <p>当您尝试编译<a href="plsql-subprograms.html#GUID-ACE7A3B5-CF77-47C7-ACAD-B2D7BC729D45__BABHJBBI">示例8-27中</a>的包规范时，它会声明具有相同标题的子程序，您将得到编译时错误PLS-00305。
                     </p>
                     <p>虽然<a href="plsql-subprograms.html#GUID-ACE7A3B5-CF77-47C7-ACAD-B2D7BC729D45__BABEHEGI">例8-28中</a>的包规范违反了规则，即不能使其形式参数仅在子类型上有所不同的子程序过载，但您可以编译它而不会出错。
                     </p>
                     <p>但是，当您尝试编译<code class="codeph">pkg2</code>的调用时。 <code class="codeph">s</code> ，如<a href="plsql-subprograms.html#GUID-ACE7A3B5-CF77-47C7-ACAD-B2D7BC729D45__BABEBCCA">例8-29所示</a> ，您得到编译时错误PLS-00307。
                     </p>
                     <p>假设您通过给出重载子程序的形式参数不同名称来纠正<a href="plsql-subprograms.html#GUID-ACE7A3B5-CF77-47C7-ACAD-B2D7BC729D45__BABEHEGI">示例8-28中</a>的过载错误，如<a href="plsql-subprograms.html#GUID-ACE7A3B5-CF77-47C7-ACAD-B2D7BC729D45__CIHBEGCB">例8-30所示</a> 。
                     </p>
                     <p>现在您可以编译<code class="codeph">pkg2</code>的调用。 <code class="codeph">s</code>没有错误，如果你指定带有指定符号的实际参数，如<a href="plsql-subprograms.html#GUID-ACE7A3B5-CF77-47C7-ACAD-B2D7BC729D45__CIHEEDIJ">例8-31</a> 。（如果使用位置表示法指定实际参数，如<a href="plsql-subprograms.html#GUID-ACE7A3B5-CF77-47C7-ACAD-B2D7BC729D45__BABEBCCA">例8-29所示</a> ，仍然会出现编译时错误PLS-00307。）
                     </p>
                     <p><a href="plsql-subprograms.html#GUID-ACE7A3B5-CF77-47C7-ACAD-B2D7BC729D45__BABJDDCJ">例8-32中</a>的包规范违反了无过载规则并且编译没有错误。但是，在调用其重载过程时，您仍然可以获得编译时错误PLS-00307，如<a href="plsql-subprograms.html#GUID-ACE7A3B5-CF77-47C7-ACAD-B2D7BC729D45__BABHCIFC">例8-33</a>中的第二次调用。
                     </p>
                     <p>在尝试确定调用哪个子程序时，如果PL / SQL编译器隐式地将一个参数转换为匹配类型，则编译器会查找可以隐式转换为匹配类型的其他参数。如果存在多个匹配，则发生编译时错误PLS-00307，如<a href="plsql-subprograms.html#GUID-ACE7A3B5-CF77-47C7-ACAD-B2D7BC729D45__CHDECAHC">例8-34所示</a> 。
                     </p>
                     <div class="example" id="GUID-ACE7A3B5-CF77-47C7-ACAD-B2D7BC729D45__BABHJBBI">
                        <p class="titleinexample">例8-27重载错误导致编译时错误</p><pre class="oac_no_warn" dir="ltr">创建或替换包装pkg1 AUTHID DEFINER是程序s（p VARCHAR2）;程序s（p VARCHAR2）;结束pkg1; /</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-ACE7A3B5-CF77-47C7-ACAD-B2D7BC729D45__BABEHEGI">
                        <p class="titleinexample">例8-28过载错误成功编译</p><pre class="oac_no_warn" dir="ltr">创建或替换包pkg2 AUTHID DEFINER是SUBTYPE t1 IS VARCHAR2（10）; SUBTYPE t2 IS VARCHAR2（10）;程序s（p <span class="bold">t1</span> ）;程序s（p <span class="bold">t2</span> ）;结束pkg2; /</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-ACE7A3B5-CF77-47C7-ACAD-B2D7BC729D45__BABEBCCA">
                        <p class="titleinexample">示例8-29在<span><a href="plsql-subprograms.html#GUID-ACE7A3B5-CF77-47C7-ACAD-B2D7BC729D45__BABEHEGI">示例8-28中</a></span>调用子程序会导致编译时错误</p><pre class="oac_no_warn" dir="ltr">创建或替换程序p AUTHID DEFINER是pkg2.t1：='a'; BEGIN <span class="bold">pkg2.s（a）; - 导致编译时错误PLS-00307</span> END p; /</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-ACE7A3B5-CF77-47C7-ACAD-B2D7BC729D45__CIHBEGCB">
                        <p class="titleinexample">例8-30纠正<span><a href="plsql-subprograms.html#GUID-ACE7A3B5-CF77-47C7-ACAD-B2D7BC729D45__BABEHEGI">例8-28中的</a></span>过载错误</p><pre class="oac_no_warn" dir="ltr">创建或替换包pkg2 AUTHID DEFINER是SUBTYPE t1 IS VARCHAR2（10）; SUBTYPE t2 IS VARCHAR2（10）;程序s（ <span class="bold">p1</span> t1）;程序s（ <span class="bold">p2</span> t2）;结束pkg2; /</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-ACE7A3B5-CF77-47C7-ACAD-B2D7BC729D45__CIHEEDIJ">
                        <p class="titleinexample">例8-31在<span><a href="plsql-subprograms.html#GUID-ACE7A3B5-CF77-47C7-ACAD-B2D7BC729D45__CIHBEGCB">例8-30中</a></span>调用子程序</p><pre class="oac_no_warn" dir="ltr">创建或替换程序p AUTHID DEFINER是pkg2.t1：='a'; BEGIN <span class="bold">pkg2.s（p1 =&gt; a）; - 编译无错误</span> END p; /</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-ACE7A3B5-CF77-47C7-ACAD-B2D7BC729D45__BABJDDCJ">
                        <p class="titleinexample">例8-32没有过载错误的包规范</p><pre class="oac_no_warn" dir="ltr">创建或替换包装pkg3 AUTHID DEFINER是程序s（p1 VARCHAR2）;程序s（p1 VARCHAR2，p2 VARCHAR2：='p2'）; END pkg3; /</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-ACE7A3B5-CF77-47C7-ACAD-B2D7BC729D45__BABHCIFC">
                        <p class="titleinexample">例8-33正确重载子程序的不正确调用</p><pre class="oac_no_warn" dir="ltr">创建或替换程序p AUTHID DEFINER是a1 VARCHAR2（10）：='a1'; a2 VARCHAR2（10）：='a2'; BEGIN <span class="bold">pkg3.s（p1 =&gt; a1，p2 =&gt; a2）; - 编译没有错误</span> <span class="bold">pkg3.s（p1 =&gt; a1）; - 导致编译时错误PLS-00307</span> END p; /</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-ACE7A3B5-CF77-47C7-ACAD-B2D7BC729D45__CHDECAHC">
                        <p class="titleinexample">示例8-34隐式转换参数导致过载错误</p><pre class="oac_no_warn" dir="ltr">创建或替换包装pack1 AUTHID DEFINER作为程序proc1（NUMBER，b VARCHAR2）; PROCEDURE proc1（一个数字，一个数字）;结束; / CREATE OR REPLACE PACKAGE BODY pack1 AS PROCEDURE proc1（NUMBER，b VARCHAR2）是BEGIN NULL;结束; PROCEDURE proc1（一个数字，一个数字）是BEGIN NULL;结束;结束; / BEGIN <span class="bold">pack1.proc1（1，'2'）; - 编译没有错误</span> <span class="bold">pack1.proc1（1,2）; - 编译时没有错误</span> <span class="bold">pack1.proc1（'1'，'2'）; - 导致编译时错误PLS-</span> <span class="bold">00307 pack1.proc1（'1'，2）; - 导致编译时错误PLS-00307</span> END; /</pre></div>
                     <!-- class="example" -->
                  </div>
               </div>
            </div><a id="LNPLS585"></a><a id="LNPLS586"></a><a id="LNPLS00810"></a><div class="props_rev_3"><a id="GUID-E093EF16-0477-44B4-B3E2-37D7CEF4F25C" name="GUID-E093EF16-0477-44B4-B3E2-37D7CEF4F25C"></a><h3 id="LNPLS-GUID-E093EF16-0477-44B4-B3E2-37D7CEF4F25C" class="sect3"><span class="enumeration_section">8.10</span>递归子程序</h3>
               <div>
                  <p><span class="bold">递归子程序</span>调用自身。递归是一种简化算法的强大技术。
                  </p>
                  <p>递归子程序必须至少有两个执行路径 - 一个导致递归调用，另一个导致终止条件。如果没有后者，递归将继续，直到PL / SQL内存不足并引发预定义的异常<code class="codeph">STORAGE_ERROR</code> 。</p>
                  <p>在<a href="plsql-subprograms.html#GUID-E093EF16-0477-44B4-B3E2-37D7CEF4F25C__CHDGEBJC">例8-35中</a> ，该函数实现了<span class="italic">n</span>阶乘（ <span class="italic">n！</span> ）的以下递归定义，它是从1到<span class="italic">n</span>的所有整数的乘积：</p><pre class="oac_no_warn" dir="ltr">N！= n *（n  -  1）！</pre><p>在<a href="plsql-subprograms.html#GUID-E093EF16-0477-44B4-B3E2-37D7CEF4F25C__CHDBEFAJ">例8-36中</a> ，函数返回第<span class="italic">n</span>个Fibonacci数，它是<span class="italic">n</span> -1st和<span class="italic">n-</span> second Fibonacci数之和。第一和第二斐波纳契数分别为零和一。
                  </p>
                  <div class="infoboxnote" id="GUID-E093EF16-0477-44B4-B3E2-37D7CEF4F25C__GUID-A5894BD6-E58C-4D9E-8643-29EBDE18F4A3">
                     <p class="notep1">注意：</p>
                     <p><a href="plsql-subprograms.html#GUID-E093EF16-0477-44B4-B3E2-37D7CEF4F25C__CHDBEFAJ">例8-36中</a>的函数是结果缓存的一个很好的候选者。有关更多信息，请参阅<span class="q">“ <a href="plsql-subprograms.html#GUID-EA53AF86-8BC6-467C-9FFA-968D45B63D17">结果缓存递归函数</a> ”</span> 。
                     </p>
                  </div>
                  <p>每个子程序的递归调用都会创建子程序声明的每个项的实例以及它执行的每个SQL语句。</p>
                  <p>在游标<code class="codeph">FOR</code> <code class="codeph">LOOP</code>语句内或在<code class="codeph">OPEN</code>或<code class="codeph">OPEN</code> <code class="codeph">FOR</code>语句与<code class="codeph">CLOSE</code>语句之间的递归调用会在每次调用时打开另一个游标，这可能导致打开游标的数量超过数据库初始化参数<code class="codeph">OPEN_CURSORS</code>设置的限制。</p>
                  <div class="example" id="GUID-E093EF16-0477-44B4-B3E2-37D7CEF4F25C__CHDGEBJC">
                     <p class="titleinexample">例8-35递归函数返回n Factorial（n！）</p><pre class="oac_no_warn" dir="ltr">创建或替换函数factorial（n POSITIVE）返回正定AUTHID DEFINER如果<span class="bold">n = 1则开始</span> <span class="bold">- 终止条件</span> RETURN n; ELSE RETURN n * <span class="bold">factorial（n-1</span> ）; <span class="bold">- 递归调用</span> END IF;结束; / BEGIN for i IN 1..5 LOOP DBMS_OUTPUT.PUT_LINE（i ||'！='|| <span class="bold">factorial（i）</span> ）;结束循环;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">1！= 1 2！= 2 3！= 6 4！= 24 5！= 120</pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-E093EF16-0477-44B4-B3E2-37D7CEF4F25C__CHDBEFAJ">
                     <p class="titleinexample">例8-36递归函数返回第n个Fibonacci数</p><pre class="oac_no_warn" dir="ltr">创建或替换函数fibonacci（n PLS_INTEGER）返回PLS_INTEGER AUTHID DEFINER是fib_1 PLS_INTEGER：= 0; fib_2 PLS_INTEGER：= 1; BEGIN IF <span class="bold">n = 1</span> THEN <span class="bold">- 终止条件</span> RETURN fib_1; ELSIF <span class="bold">n = 2</span>然后返回fib_2; <span class="bold">- 终止条件</span> ELSE RETURN <span class="bold">斐波那契（n-2）</span> + <span class="bold">斐波那契（n-1）</span> ; <span class="bold">- 递归调用</span> END IF;结束; / BEGIN FOR i IN 1..10 LOOP DBMS_OUTPUT.PUT（ <span class="bold">fibonacci（i）</span> ）;如果我&lt;10那么DBMS_OUTPUT.PUT（'，'）;万一;结束循环; DBMS_OUTPUT.PUT_LINE（'...“）;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">0,1,1,2,3,5,8,13,21,34 ......</pre></div>
                  <!-- class="example" -->
               </div>
            </div><a id="LNPLS00814"></a><div class="props_rev_3"><a id="GUID-6C6A828F-8FA0-4278-97D2-6D5649A66A9A" name="GUID-6C6A828F-8FA0-4278-97D2-6D5649A66A9A"></a><h3 id="LNPLS-GUID-6C6A828F-8FA0-4278-97D2-6D5649A66A9A" class="sect3"><span class="enumeration_section">8.11</span>子程序副作用</h3>
               <div>
                  <p>如果子程序除了自身局部变量的值之外发生任何变化，则会产生副作用。例如，更改以下任何一项的子程序会产生副作用：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>它自己的<code class="codeph">OUT</code>或<code class="codeph">IN</code> <code class="codeph">OUT</code>参数</p>
                     </li>
                     <li>
                        <p>全局变量</p>
                     </li>
                     <li>
                        <p>包中的公共变量</p>
                     </li>
                     <li>
                        <p>数据库表</p>
                     </li>
                     <li>
                        <p>数据库</p>
                     </li>
                     <li>
                        <p>外部状态（例如，通过调用<code class="codeph">DBMS_OUTPUT</code>或发送电子邮件）</p>
                     </li>
                  </ul>
                  <p>副作用可以阻止查询的并行化，产生依赖于顺序（因此，不确定）的结果，或者要求跨用户会话维护包状态。</p>
                  <p>在为要调用的SQL语句定义结果缓存函数或存储函数时，最小化副作用尤为重要。</p>
                  <div class="infoboxnotealso" id="GUID-6C6A828F-8FA0-4278-97D2-6D5649A66A9A__GUID-C58A4B34-6043-4D84-99FB-EC39A405762B">
                     <p class="notep1">也可以看看：</p>
                     <p><a href="../adfns/coding-subprograms-and-packages.html#ADFNS384" target="_blank"><span class="italic">“Oracle数据库开发指南”</span></a> ，了解有关控制从SQL语句调用的PL / SQL函数中的副作用的信息</p>
                  </div>
               </div>
            </div><a id="LNPLS587"></a><a id="LNPLS00817"></a><div class="props_rev_3"><a id="GUID-250BDBBB-0CD6-4D56-9DDF-6FCEDC110D00" name="GUID-250BDBBB-0CD6-4D56-9DDF-6FCEDC110D00"></a><h3 id="LNPLS-GUID-250BDBBB-0CD6-4D56-9DDF-6FCEDC110D00" class="sect3"><span class="enumeration_section">8.12</span> PL / SQL函数结果缓存</h3>
               <div>
                  <p>当PL / SQL函数具有<code class="codeph">RESULT_CACHE</code>选项时，其结果将缓存在共享全局区域（SGA）中，因此连接到同一实例的会话可以在可用时重用这些结果。
                  </p>
                  <p>Oracle数据库自动检测在结果缓存函数运行时查询的所有数据源（表和视图）。如果提交了对任何这些数据源的更改，则缓存的结果将在所有实例中变为无效。结果缓存的最佳候选者是经常调用的函数，但依赖于不经常更改或从不更改的信息。</p>
                  <div class="section">
                     <p class="subhead2" id="GUID-250BDBBB-0CD6-4D56-9DDF-6FCEDC110D00__GUID-B4552D3D-3CCF-428C-8B3A-D6F3FB6913B3">话题</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="plsql-subprograms.html#GUID-4389252A-5F5F-45FD-9D5B-24F7358BB42D">为函数启用结果缓存</a></p>
                        </li>
                        <li>
                           <p><a href="plsql-subprograms.html#GUID-E7506691-0AF7-4907-8DCA-4119D956027A">使用结果缓存函数开发应用程序</a></p>
                        </li>
                        <li>
                           <p><a href="plsql-subprograms.html#GUID-72DC4B02-9AB6-4AE1-9EE0-EB00E73BB490">结果缓存函数的要求</a></p>
                        </li>
                        <li>
                           <p><a href="plsql-subprograms.html#GUID-0F00DAC5-8F3D-426F-BBA4-86424CD7BD75">结果缓存函数的示例</a></p>
                        </li>
                        <li>
                           <p><a href="plsql-subprograms.html#GUID-267D2E0E-18B1-4815-9903-965C1B4A5A1B" title="PL / SQL函数结果缓存与结果缓存共享其管理和可管理性基础结构。">高级结果缓存功能主题</a></p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
               </div><a id="LNPLS699"></a><a id="LNPLS698"></a><div class="props_rev_3"><a id="GUID-4389252A-5F5F-45FD-9D5B-24F7358BB42D" name="GUID-4389252A-5F5F-45FD-9D5B-24F7358BB42D"></a><h4 id="LNPLS-GUID-4389252A-5F5F-45FD-9D5B-24F7358BB42D" class="sect4"><span class="enumeration_section">8.12.1</span>启用函数的结果缓存</h4>
                  <div>
                     <div class="section">
                        <p>要使函数结果缓存，请在函数声明和定义中包含<code class="codeph">RESULT_CACHE</code>子句。有关语法的详细信息，请参阅<span class="q">“ <a href="function-declaration-and-definition.html#GUID-4E19FB09-46B5-4CE5-8A5B-CD815C29DA1C" title="在调用函数之前，必须声明并定义它。您可以先声明它（使用function_declaration），然后在同一个块，子程序或包中（使用function_definition）定义它，或者同时声明和定义它（使用function_definition）。">函数声明和定义</a> ”</span> 。
                        </p>
                        <div class="infoboxnote" id="GUID-4389252A-5F5F-45FD-9D5B-24F7358BB42D__GUID-F15FCB31-0C35-4D40-9BD3-212CD09CB58A">
                           <p class="notep1">注意：</p>
                           <p>有关配置和管理数据库服务器结果缓存的详细信息，请参阅“ <a href="../refrn/RESULT_CACHE_MODE.html#REFRN10270" target="_blank"><span class="italic">Oracle数据库参考</span></a>和<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/lnpls&amp;id=TGDBA640" target="_blank"><span class="italic">Oracle数据库性能调整指南”</span></a> 。
                           </p>
                        </div>
                        <p>在<a href="plsql-subprograms.html#GUID-4389252A-5F5F-45FD-9D5B-24F7358BB42D__G3307801">例8-37中</a> ，包<code class="codeph">department_pkg</code>声明然后定义结果缓存函数<code class="codeph">get_dept_info</code> ，该函数返回有关给定部门的信息记录。该函数取决于数据库表<code class="codeph">DEPARTMENTS</code>和<code class="codeph">EMPLOYEES</code> 。</p>
                        <p>在调用任何函数时调用函数<code class="codeph">get_dept_info</code> 。例如，此调用返回有关部门号10的信息记录：</p><pre class="oac_no_warn" dir="ltr">department_pkg.get_dept_info（10）;</pre><p>此调用仅返回部门号10的名称：</p><pre class="oac_no_warn" dir="ltr">department_pkg.get_dept_info（10）.dept_name;</pre><p>如果<code class="codeph">get_dept_info(10)</code>的结果在结果缓存中，则从缓存返回结果;否则，计算结果并将其添加到缓存中。因为<code class="codeph">get_dept_info</code>依赖于<code class="codeph">DEPARTMENTS</code>和<code class="codeph">EMPLOYEES</code>表，所以对<code class="codeph">DEPARTMENTS</code>或<code class="codeph">EMPLOYEES</code>任何已提交更改都会使<code class="codeph">get_dept_info</code>所有缓存结果无效，从而使您无法在<code class="codeph">DEPARTMENTS</code>或<code class="codeph">EMPLOYEES</code>可能更改的任何位置编程缓存失效逻辑。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-4389252A-5F5F-45FD-9D5B-24F7358BB42D__G3307801">
                        <p class="titleinexample">例8-37声明和定义结果缓存函数</p><pre class="oac_no_warn" dir="ltr">创建或替换包装department_pkg AUTHID DEFINER是TYPE dept_info_record是RECORD（dept_name departments.department_name％TYPE，mgr_name employees.last_name％TYPE，dept_size PLS_INTEGER）; <span class="bold">- 函数声明</span> FUNCTION get_dept_info（dept_id NUMBER）RETURN dept_info_record <span class="bold">RESULT_CACHE</span> ; END department_pkg; / CREATE OR REPLACE PACKAGE BODY department_pkg IS <span class="bold">- 函数定义</span> FUNCTION get_dept_info（dept_id NUMBER）RETURN dept_info_record <span class="bold">RESULT_CACHE</span>是rec dept_info_record; BEGIN SELECT department_name INTO rec.dept_name FROM departments WHERE department_id = dept_id; SELECT e.last_name INTO rec.mgr_name FROM departments d，employees e WHERE d.department_id = dept_id AND d.manager_id = e.employee_id; SELECT COUNT（*）INTO rec.dept_size FROM EMPLOYEES WHERE department_id = dept_id;返回rec; END get_dept_info; END department_pkg; /</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="LNPLS700"></a><div class="props_rev_3"><a id="GUID-E7506691-0AF7-4907-8DCA-4119D956027A" name="GUID-E7506691-0AF7-4907-8DCA-4119D956027A"></a><h4 id="LNPLS-GUID-E7506691-0AF7-4907-8DCA-4119D956027A" class="sect4"><span class="enumeration_section">8.12.2</span>使用结果缓存函数开发应用程序</h4>
                  <div>
                     <div class="section">
                        <p>在开发使用结果缓存函数的应用程序时，不要假设函数体对于给定的参数值集运行的次数。</p>
                        <p>结果缓存函数的主体运行的一些情况是：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p>此数据库实例上的会话第一次使用这些参数值调用该函数</p>
                           </li>
                           <li>
                              <p>当这些参数值的缓存结果<span class="bold">无效时</span></p>
                              <p>当提交对函数所依赖的任何数据源的更改时，缓存的结果将变为无效。</p>
                           </li>
                           <li>
                              <p>当这些参数值的缓存结果已老化时</p>
                              <p>如果系统需要内存，则可能会丢弃最早的缓存值。</p>
                           </li>
                           <li>
                              <p>当该函数绕过缓存时（请参阅<span class="q">“ <a href="plsql-subprograms.html#GUID-F9B72877-32FB-43B3-8E95-63DC29BA276E">结果缓存旁路</a> ”</span> ）</p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPLS701"></a><div class="props_rev_3"><a id="GUID-72DC4B02-9AB6-4AE1-9EE0-EB00E73BB490" name="GUID-72DC4B02-9AB6-4AE1-9EE0-EB00E73BB490"></a><h4 id="LNPLS-GUID-72DC4B02-9AB6-4AE1-9EE0-EB00E73BB490" class="sect4"><span class="enumeration_section">8.12.3</span>结果缓存函数的要求</h4>
                  <div>
                     <p>结果缓存的PL / SQL函数是安全的，如果它没有用<code class="codeph">RESULT_CACHE</code>标记它将产生的任何输入产生相同的输出。只有满足以下条件，才能保证这种安全：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>执行该功能时，它没有副作用。</p>
                           <p>有关副作用的信息，请参阅<span class="q">“ <a href="plsql-subprograms.html#GUID-6C6A828F-8FA0-4278-97D2-6D5649A66A9A">子程序副作用</a> ”</span> 。
                           </p>
                        </li>
                        <li>
                           <p>函数访问的所有表都是与函数位于同一数据库中的普通非<code class="codeph">SYS</code>永久表。
                           </p>
                        </li>
                        <li>
                           <p>函数的结果必须仅由输入实际的向量以及它引用的表在当前<code class="codeph">SCN</code>处的提交内容确定。
                           </p>
                        </li>
                     </ul>
                     <p>建议结果缓存函数也符合以下条件：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>它不依赖于会话特定的设置。</p>
                           <p>有关更多信息，请参阅<span class="q">“ <a href="plsql-subprograms.html#GUID-3A24DD0F-DC69-43B7-A820-0950D86AB9AB">使结果缓存函数处理特定于会话的设置</a> ”</span> 。
                           </p>
                        </li>
                        <li>
                           <p>它不依赖于特定于会话的应用程序上下文。</p>
                           <p>有关更多信息，请参阅<span class="q">“ <a href="plsql-subprograms.html#GUID-F14A3A45-C880-4175-B42D-55EFB29EDEAE">使结果缓存函数处理特定于会话的应用程序上下文</a> ”</span> 。
                           </p>
                        </li>
                     </ul>
                     <p>有关更多信息，请参见“ <a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/lnpls&amp;id=TGDBA642" target="_blank"><span class="italic">Oracle数据库性能调整指南”</span></a> 。
                     </p>
                  </div>
               </div><a id="LNPLS702"></a><div class="props_rev_3"><a id="GUID-0F00DAC5-8F3D-426F-BBA4-86424CD7BD75" name="GUID-0F00DAC5-8F3D-426F-BBA4-86424CD7BD75"></a><h4 id="LNPLS-GUID-0F00DAC5-8F3D-426F-BBA4-86424CD7BD75" class="sect4"><span class="enumeration_section">8.12.4</span>结果缓存函数的示例</h4>
                  <div>
                     <p>结果缓存的最佳候选者是经常调用的函数，但依赖于不经常更改的信息（如第一个示例中的情况）。结果缓存避免了递归函数中的冗余计算。</p>
                     <p>例子：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="plsql-subprograms.html#GUID-801471B1-3CBC-469C-AF7D-6820F3E51A78">结果缓存的应用程序配置参数</a></p>
                        </li>
                        <li>
                           <p><a href="plsql-subprograms.html#GUID-EA53AF86-8BC6-467C-9FFA-968D45B63D17">结果缓存的递归函数</a></p>
                        </li>
                     </ul>
                  </div><a id="LNPLS704"></a><a id="LNPLS703"></a><div class="props_rev_3"><a id="GUID-801471B1-3CBC-469C-AF7D-6820F3E51A78" name="GUID-801471B1-3CBC-469C-AF7D-6820F3E51A78"></a><h5 id="LNPLS-GUID-801471B1-3CBC-469C-AF7D-6820F3E51A78" class="sect5"><span class="enumeration_section">8.12.4.1</span>结果缓存的应用程序配置参数</h5>
                     <div>
                        <p>考虑具有可在全局级别，应用程序级别或角色级别设置的配置参数的应用程序。应用程序将配置信息存储在这些表中：</p><pre class="oac_no_warn" dir="ltr">- 全局配置设置DROP TABLE global_config_params; CREATE TABLE global_config_params（名称VARCHAR2（20）， - 参数名称val VARCHAR2（20）， - 参数VALUE PRIMARY KEY（name））; - 应用程序级配置设置CREATE TABLE app_level_config_params（app_id VARCHAR2（20）， -  application ID name VARCHAR2（20）， -  parameter NAME val VARCHAR2（20）， -  parameter VALUE PRIMARY KEY（app_id，name））; - 角色级配置设置CREATE TABLE role_level_config_params（role_id VARCHAR2（20）， -  application（role）ID name VARCHAR2（20）， -  parameter NAME val VARCHAR2（20）， -  parameter VALUE PRIMARY KEY（role_id，name ））;</pre><p>对于每个配置参数，角色级别设置将覆盖应用程序级别设置，该设置将覆盖全局设置。要确定哪个设置适用于参数，应用程序将定义PL / SQL函数<code class="codeph">get_value</code> 。给定参数名称，应用程序ID和角色ID， <code class="codeph">get_value</code>返回应用于参数的设置。
                        </p>
                        <p>如果频繁调用并且配置信息不经常更改，则函数<code class="codeph">get_value</code>是结果缓存的良好候选者。
                        </p>
                        <p><a href="plsql-subprograms.html#GUID-801471B1-3CBC-469C-AF7D-6820F3E51A78__g3299007">例8-38</a>显示了<code class="codeph">get_value</code>的可能定义。假设对于一组参数值，全局设置确定<code class="codeph">get_value</code>的结果。当<code class="codeph">get_value</code>正在运行时，数据库会检测到三个表被查询 - <code class="codeph">role_level_config_params</code> ， <code class="codeph">app_level_config_params</code>和<code class="codeph">global_config_params</code> 。如果提交了对这三个表中的任何一个的更改，则此参数值集的缓存结果将失效，必须重新计算。
                        </p>
                        <p>现在假设，对于第二组参数值，角色级设置确定<code class="codeph">get_value</code>的结果。当<code class="codeph">get_value</code>正在运行时，数据库会检测到只查询了<code class="codeph">role_level_config_params</code>表。如果提交了对<code class="codeph">role_level_config_params</code>的更改，则第二组参数值的缓存结果将失效;但是，对<code class="codeph">app_level_config_params</code>或<code class="codeph">global_config_params</code>提交更改不会影响缓存的结果。
                        </p>
                        <div class="example" id="GUID-801471B1-3CBC-469C-AF7D-6820F3E51A78__g3299007">
                           <p class="titleinexample">例8-38 Result-Cached函数返回配置参数设置</p><pre class="oac_no_warn" dir="ltr">CREATE或REPLACE FUNCTION get_value（p_param VARCHAR2，p_app_id NUMBER，p_role_id NUMBER）RETURN VARCHAR2 <span class="bold">RESULT_CACHE</span> AUTHID DEFINER是answer VARCHAR2（20）; BEGIN <span class="bold">- 参数是否设置为角色级别？</span>BEGIN SELECT val INTO answer <span class="bold">from role_level_config_params</span> WHERE role_id = p_role_id AND name = p_param;回答答案; - 当no_data_found THEN NULL时发现EXCEPTION; - 落到下面的代码END; <span class="bold"> - 参数是否设置在应用程序级别？</span>BEGIN SELECT val INTO answer <span class="bold">from app_level_config_params</span> WHERE app_id = p_app_id AND name = p_param;回答答案; - 当no_data_found THEN NULL时发现EXCEPTION; - 落到下面的代码END; <span class="bold"> - 参数设置为全局级别吗？</span>SELECT val INTO answer <span class="bold">from global_config_params</span> WHERE name = p_param;回答答案;结束;</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="LNPLS705"></a><div class="props_rev_3"><a id="GUID-EA53AF86-8BC6-467C-9FFA-968D45B63D17" name="GUID-EA53AF86-8BC6-467C-9FFA-968D45B63D17"></a><h5 id="LNPLS-GUID-EA53AF86-8BC6-467C-9FFA-968D45B63D17" class="sect5"><span class="enumeration_section">8.12.4.2</span>结果缓存的递归函数</h5>
                     <div>
                        <p>用于查找反映该系列的数学定义的斐波纳契数列的第<span class="italic">n</span>项的递归函数可以进行许多冗余计算。例如，为了评估<code class="codeph">fibonacci(7)</code> ，该函数必须计算<code class="codeph">fibonacci(6)</code>和<code class="codeph">fibonacci(5)</code> 。为了计算<code class="codeph">fibonacci(6)</code> ，该函数必须计算<code class="codeph">fibonacci(5)</code>和<code class="codeph">fibonacci(4)</code> 。因此， <code class="codeph">fibonacci(5)</code>和其他几个术语被冗余地计算。结果缓存避免了这些冗余计算。
                        </p>
                        <div class="infoboxnote" id="GUID-EA53AF86-8BC6-467C-9FFA-968D45B63D17__GUID-90390B78-AF0E-44EF-BF5C-DD889BCCE4F4">
                           <p class="notep1">注意：</p>
                           <p>缓存的最大递归调用数为128。</p>
                        </div><pre class="oac_no_warn" dir="ltr">创建或替换功能斐波纳契（n NUMBER）返回编号<span class="bold">RESULT_CACHE</span> AUTHID DEFINER从B开始IF（n = 0）或（n = 1）然后返回1; ELSE RETURN斐波那契（n  -  1）+斐波那契（n  -  2）;万一;结束; /</pre></div>
                  </div>
               </div><a id="LNPLS588"></a><a id="LNPLS706"></a><div class="props_rev_3"><a id="GUID-267D2E0E-18B1-4815-9903-965C1B4A5A1B" name="GUID-267D2E0E-18B1-4815-9903-965C1B4A5A1B"></a><h4 id="LNPLS-GUID-267D2E0E-18B1-4815-9903-965C1B4A5A1B" class="sect4"><span class="enumeration_section">8.12.5</span>高级结果缓存功能主题</h4>
                  <div>
                     <div class="section">
                        <p class="subhead3" id="GUID-267D2E0E-18B1-4815-9903-965C1B4A5A1B__GUID-366E9A64-AB7E-4686-94A6-B0DFE437DA53">话题</p>
                     </div>
                     <!-- class="section" -->
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="plsql-subprograms.html#GUID-B7FA8EB2-2075-4EAC-9A15-8E710EDE987A">缓存命中规则</a></p>
                        </li>
                        <li>
                           <p><a href="plsql-subprograms.html#GUID-F9B72877-32FB-43B3-8E95-63DC29BA276E">结果缓存旁路</a></p>
                        </li>
                        <li>
                           <p><a href="plsql-subprograms.html#GUID-3A24DD0F-DC69-43B7-A820-0950D86AB9AB">使结果缓存函数处理特定于会话的设置</a></p>
                        </li>
                        <li>
                           <p><a href="plsql-subprograms.html#GUID-F14A3A45-C880-4175-B42D-55EFB29EDEAE">使结果缓存函数处理特定于会话的应用程序上下文</a></p>
                        </li>
                        <li>
                           <p><a href="plsql-subprograms.html#GUID-63930E6C-9244-4A1A-97FC-49B0A44888AC">选择结果缓存粒度</a></p>
                        </li>
                        <li>
                           <p><a href="plsql-subprograms.html#GUID-8F7227E9-4388-4A64-9D1C-5F134A3022F2">Oracle RAC环境中的结果缓存</a></p>
                        </li>
                        <li>
                           <p><a href="plsql-subprograms.html#GUID-4051143D-CABC-4395-BF7C-915253CA4CAB" title="PL / SQL函数结果缓存与结果缓存共享其管理和可管理性基础结构。">结果缓存管理</a></p>
                        </li>
                        <li>
                           <p><a href="plsql-subprograms.html#GUID-7AEE971F-0A1E-4417-B13F-2E87D59A0441">结果缓存函数依赖的热补丁PL / SQL单元</a></p>
                        </li>
                     </ul>
                  </div><a id="LNPLS707"></a><div class="props_rev_3"><a id="GUID-B7FA8EB2-2075-4EAC-9A15-8E710EDE987A" name="GUID-B7FA8EB2-2075-4EAC-9A15-8E710EDE987A"></a><h5 id="LNPLS-GUID-B7FA8EB2-2075-4EAC-9A15-8E710EDE987A" class="sect5"><span class="enumeration_section">8.12.5.1</span>缓存命中规则</h5>
                     <div>
                        <p>每次使用不同的参数值调用结果缓存函数时，这些参数及其结果都存储在缓存中。随后，当使用相同的参数值调用相同的函数时（即，当存在<span class="bold">缓存命中时</span> ），将从缓存中检索结果，而不是重新计算。
                        </p>
                        <p>缓存命中的参数比较规则与PL / SQL“等于”（=）运算符的规则不同，如下所示：</p>
                        <div class="tblformal" id="GUID-B7FA8EB2-2075-4EAC-9A15-8E710EDE987A__GUID-00874D87-989D-47C3-833D-BC09EB61D08A">
                           <table cellpadding="4" cellspacing="0" class="Formal" title="" width="100%" border="1" summary="This table compares the rules for determining whether two parameter values are the same (for a cache hit) to the rules for determining whether two values are equal." frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="23%" id="d58247e6585">类别</th>
                                    <th align="left" valign="bottom" width="36%" id="d58247e6588">缓存命中规则</th>
                                    <th align="left" valign="bottom" width="41%" id="d58247e6591">“等于”运营商规则</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="23%" id="d58247e6596" headers="d58247e6585 ">
                                       <p>NULL比较</p>
                                    </td>
                                    <td align="left" valign="top" width="36%" headers="d58247e6596 d58247e6588 ">
                                       <p><code class="codeph">NULL</code>等于<code class="codeph">NULL</code></p>
                                    </td>
                                    <td align="left" valign="top" width="41%" headers="d58247e6596 d58247e6591 ">
                                       <p><code class="codeph">NULL = NULL</code>计算结果为<code class="codeph">NULL</code> 。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="23%" id="d58247e6615" headers="d58247e6585 ">
                                       <p>非空标量比较</p>
                                    </td>
                                    <td align="left" valign="top" width="36%" headers="d58247e6615 d58247e6588 ">
                                       <p>当且仅当它们的值相同时，非null标量才相同;也就是说，当且仅当它们的值在给定平台上具有相同的位模式时。例如， <code class="codeph">CHAR</code>值<code class="codeph">'AA'</code>和<code class="codeph">'AA '</code>是不同的。（此规则比“等于”运算符的规则更严格。）
                                       </p>
                                    </td>
                                    <td align="left" valign="top" width="41%" headers="d58247e6615 d58247e6591 ">
                                       <p>即使它们的值在给定平台上没有相同的位模式，非null标量也可以相等;例如， <code class="codeph">CHAR</code>值<code class="codeph">'AA'</code>和<code class="codeph">'AA '</code>相等。
                                       </p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                     </div>
                  </div><a id="LNPLS708"></a><div class="props_rev_3"><a id="GUID-F9B72877-32FB-43B3-8E95-63DC29BA276E" name="GUID-F9B72877-32FB-43B3-8E95-63DC29BA276E"></a><h5 id="LNPLS-GUID-F9B72877-32FB-43B3-8E95-63DC29BA276E" class="sect5"><span class="enumeration_section">8.12.5.2</span>结果缓存旁路</h5>
                     <div>
                        <p>在某些情况下，会绕过缓存。绕过缓存时：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>该函数计算结果，而不是从缓存中检索它。</p>
                           </li>
                           <li>
                              <p>函数计算的结果不会添加到缓存中。</p>
                           </li>
                        </ul>
                        <p>绕过高速缓存的一些示例是：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>缓存不适用于所有会话。</p>
                              <p>例如，数据库管理员在应用程序修补期间禁用了结果缓存的使用（如<span class="q">“ <a href="plsql-subprograms.html#GUID-7AEE971F-0A1E-4417-B13F-2E87D59A0441">结果缓存函数所依赖的热补丁PL / SQL单元</a> ”</span> ）。
                              </p>
                           </li>
                           <li>
                              <p>会话正在对结果缓存函数所依赖的表或视图执行DML语句。</p>
                              <p>会话绕过该函数的结果缓存，直到DML语句完成 - 提交或回滚。如果回滚该语句，则会话将使用该功能的缓存继续。</p>
                              <p>缓存旁路确保：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>每个会话的用户都会看到他或她自己未提交的更改。</p>
                                 </li>
                                 <li>
                                    <p>PL / SQL函数结果缓存仅提交了对所有会话可见的更改，因此一个会话中的未提交更改对其他会话不可见。</p>
                                 </li>
                              </ul>
                           </li>
                        </ul>
                     </div>
                  </div><a id="LNPLS710"></a><a id="LNPLS709"></a><div class="props_rev_3"><a id="GUID-3A24DD0F-DC69-43B7-A820-0950D86AB9AB" name="GUID-3A24DD0F-DC69-43B7-A820-0950D86AB9AB"></a><h5 id="LNPLS-GUID-3A24DD0F-DC69-43B7-A820-0950D86AB9AB" class="sect5"><span class="enumeration_section">8.12.5.3创建</span>结果缓存函数处理特定于会话的设置</h5>
                     <div>
                        <div class="section">
                           <p>如果函数依赖于会话之间可能不同的设置（例如<code class="codeph">NLS_DATE_FORMAT</code>和<code class="codeph">TIME ZONE</code> ），则只有在您可以修改函数以处理各种设置时才使函数结果缓存。
                           </p>
                           <p>例8-39中的函数<code class="codeph">get_hire_date</code>使用<code class="codeph">TO_CHAR</code>函数将<code class="codeph">DATE</code>项转换为<code class="codeph">VARCHAR</code>项。函数<code class="codeph">get_hire_date</code>未指定格式掩码，因此格式掩码默认为<code class="codeph">NLS_DATE_FORMAT</code>指定的格式掩码。如果调用<code class="codeph">get_hire_date</code>会话具有不同的<code class="codeph">NLS_DATE_FORMAT</code>设置，则缓存的结果可以具有不同的格式。如果由一个会话计算的缓存结果老化，而另一个会话重新计算它，则即使对于相同的参数值，格式也可能不同。如果会话获得其格式与其自身格式不同的缓存结果，则该结果可能不正确。
                           </p>
                           <p>这个问题的一些可能的解决方案是：</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>将<code class="codeph">get_hire_date</code>的返回类型更改为<code class="codeph">DATE</code>并让每个会话调用<code class="codeph">TO_CHAR</code>函数。
                                 </p>
                              </li>
                              <li>
                                 <p>如果所有会话都可以使用通用格式，请指定格式掩码，删除对<code class="codeph">NLS_DATE_FORMAT</code>的依赖性。例如：</p><pre class="oac_no_warn" dir="ltr">TO_CHAR（date_hired，'mm / dd / yy'）;</pre></li>
                              <li>
                                 <p>将格式掩码参数添加到<code class="codeph">get_hire_date</code> 。例如：</p><pre class="oac_no_warn" dir="ltr">创建或替换函数get_hire_date（emp_id NUMBER， <span class="bold">fmt VARCHAR</span> ）RETURN VARCHAR RESULT_CACHE AUTHID DEFINER是date_hired DATE; BEGIN SELECT hire_date INTO date_hired FROM HR.EMPLOYEES WHERE EMPLOYEE_ID = emp_id; RETURN TO_CHAR（date_hired， <span class="bold">fmt</span> ）;结束; /</pre></li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-3A24DD0F-DC69-43B7-A820-0950D86AB9AB__GUID-E286AD42-90B8-4E9A-A390-329DC3ECC4DB">
                           <p class="titleinexample">示例8-39结果缓存功能处理特定于会话的设置</p><pre class="oac_no_warn" dir="ltr">创建或替换函数get_hire_date（emp_id NUMBER）RETURN VARCHAR <span class="bold">RESULT_CACHE</span> AUTHID DEFINER是date_hired DATE; BEGIN SELECT hire_date INTO date_hired FROM HR.EMPLOYEES WHERE EMPLOYEE_ID = emp_id; RETURN <span class="bold">TO_CHAR</span> （date_hired）;结束; /</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="LNPLS712"></a><a id="LNPLS711"></a><div class="props_rev_3"><a id="GUID-F14A3A45-C880-4175-B42D-55EFB29EDEAE" name="GUID-F14A3A45-C880-4175-B42D-55EFB29EDEAE"></a><h5 id="LNPLS-GUID-F14A3A45-C880-4175-B42D-55EFB29EDEAE" class="sect5"><span class="enumeration_section">8.12.5.4</span>使结果缓存函数处理特定于会话的应用程序上下文</h5>
                     <div>
                        <div class="section">
                           <p><span class="bold">应用程序上下文</span>可以是全局的，也可以是特定于会话的，是一组属性及其值。如果PL / SQL函数执行以下一项或多项操作，它将依赖于特定于会话的应用程序上下文：</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>直接调用SQL函数<code class="codeph">SYS_CONTEXT</code> ，它返回指定上下文中指定属性的值</p>
                              </li>
                              <li>
                                 <p>通过使用虚拟专用数据库（VPD）机制间接调用<code class="codeph">SYS_CONTEXT</code>以实现细粒度的安全性</p>
                                 <p>（有关VPD的信息，请参阅<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/lnpls&amp;id=DBSEG007" target="_blank"><span class="italic">Oracle数据库安全指南</span></a> 。）
                                 </p>
                              </li>
                           </ul>
                           <p>PL / SQL函数结果缓存功能不会自动处理对特定于会话的应用程序上下文的依赖。如果必须缓存依赖于特定于会话的应用程序上下文的函数的结果，则必须将应用程序上下文作为参数传递给函数。您可以为参数指定默认值，以便不是每个用户都必须指定它。</p>
                           <p>在<a href="plsql-subprograms.html#GUID-F14A3A45-C880-4175-B42D-55EFB29EDEAE__g3297326">示例8-40中</a> ，假设表<code class="codeph">config_tab</code>具有可转换此查询的VPD策略：</p><pre class="oac_no_warn" dir="ltr">SELECT值FROM config_tab WHERE name = param_name;</pre><p>对于此查询：</p><pre class="oac_no_warn" dir="ltr">SELECT值FROM config_tab WHERE name = param_name <span class="bold">AND app_id = SYS_CONTEXT（'Config'，'App_ID'）</span> ;</pre></div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-F14A3A45-C880-4175-B42D-55EFB29EDEAE__g3297326">
                           <p class="titleinexample">示例8-40结果缓存功能处理特定于会话的应用程序上下文</p><pre class="oac_no_warn" dir="ltr">创建或替换函数get_param_value（param_name VARCHAR，appctx VARCHAR DEFAULT SYS_CONTEXT（'Config'，'App_ID'））RETURN VARCHAR RESULT_CACHE AUTHID DEFINER是rec VARCHAR（2000）; BEGIN SELECT val INTO rec FROM config_tab WHERE name = param_name;返回rec;结束; /</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="LNPLS714"></a><a id="LNPLS715"></a><a id="LNPLS716"></a><a id="LNPLS713"></a><div class="props_rev_3"><a id="GUID-63930E6C-9244-4A1A-97FC-49B0A44888AC" name="GUID-63930E6C-9244-4A1A-97FC-49B0A44888AC"></a><h5 id="LNPLS-GUID-63930E6C-9244-4A1A-97FC-49B0A44888AC" class="sect5"><span class="enumeration_section">8.12.5.5</span>选择结果缓存粒度</h5>
                     <div>
                        <div class="section">
                           <p>PL / SQL提供了函数结果缓存，但您选择了缓存粒度。要了解粒度的概念，请考虑订单输入（ <code class="codeph">OE</code> ）示例模式中的<code class="codeph">Product_Descriptions</code>表：</p><pre class="oac_no_warn" dir="ltr">NAME是吗？TYPE ---------------------- -------- --------------- PRODUCT_ID NOT NULL NUMBER （6）LANGUAGE_ID NOT NULL VARCHAR2（3）TRANSLATED_NAME NOT NULL NVARCHAR2（50）TRANSLATED_DESCRIPTION NOT NULL NVARCHAR2（2000）</pre><p>该表以多种语言显示每种产品的名称和描述。每行的唯一键是<code class="codeph">PRODUCT_ID,LANGUAGE_ID</code> 。</p>
                           <p>假设您必须定义一个带有<code class="codeph">PRODUCT_ID</code>和<code class="codeph">LANGUAGE_ID</code>的函数，并返回关联的<code class="codeph">TRANSLATED_NAME</code> 。您还想缓存已翻译的名称。缓存名称的一些粒度选择是：</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>一次一个名称（更精细的粒度）</p>
                              </li>
                              <li>
                                 <p>一次一种语言（较粗粒度）</p>
                              </li>
                           </ul>
                           <div class="tblformal" id="GUID-63930E6C-9244-4A1A-97FC-49B0A44888AC__GUID-526367F9-070F-4A85-9FBE-75FD0009088B">
                              <p class="titleintable">表8-4更精细和更粗糙的缓存粒度</p>
                              <table cellpadding="4" cellspacing="0" class="Formal" title="更精细和更粗糙的缓存粒度" width="100%" border="1" summary="This table compares finest- and coarsest-grained function result caching." frame="hsides" rules="rows">
                                 <thead>
                                    <tr align="left" valign="top">
                                       <th align="left" valign="bottom" width="32%" id="d58247e7160">粒度</th>
                                       <th align="left" valign="bottom" width="68%" id="d58247e7163">优点</th>
                                    </tr>
                                 </thead>
                                 <tbody>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="32%" id="d58247e7168" headers="d58247e7160 ">
                                          <p>细</p>
                                       </td>
                                       <td align="left" valign="top" width="68%" headers="d58247e7168 d58247e7163 ">
                                          <p>每个功能结果对应一个逻辑结果。</p>
                                          <p>仅存储至少需要一次的数据。</p>
                                          <p>每个数据项都会逐渐老化。</p>
                                          <p>不允许批量加载优化。</p>
                                       </td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="32%" id="d58247e7181" headers="d58247e7160 ">
                                          <p>较粗</p>
                                       </td>
                                       <td align="left" valign="top" width="68%" headers="d58247e7181 d58247e7163 ">
                                          <p>每个函数结果都包含许多逻辑子结果。</p>
                                          <p>可能存储从未使用过的数据。</p>
                                          <p>一个老化的数据项会使整个集合老化。</p>
                                          <p>允许批量加载优化。</p>
                                       </td>
                                    </tr>
                                 </tbody>
                              </table>
                           </div>
                           <!-- class="inftblhruleinformal" -->
                           <p>在<a href="plsql-subprograms.html#GUID-63930E6C-9244-4A1A-97FC-49B0A44888AC__BABDDJCD">示例8-41</a>和<a href="plsql-subprograms.html#GUID-63930E6C-9244-4A1A-97FC-49B0A44888AC__BABCDECH">示例8-42中</a> ，函数<code class="codeph">productName</code>接受<code class="codeph">PRODUCT_ID</code>和<code class="codeph">LANGUAGE_ID</code>并返回关联的<code class="codeph">TRANSLATED_NAME</code> 。每个版本的<code class="codeph">productName</code>缓存已翻译的名称，但格式不同。
                           </p>
                           <p>在<a href="plsql-subprograms.html#GUID-63930E6C-9244-4A1A-97FC-49B0A44888AC__BABDDJCD">示例8-41中</a> ， <code class="codeph">get_product_name_1</code>是结果缓存函数。每当使用不同的<code class="codeph">PRODUCT_ID</code>和<code class="codeph">LANGUAGE_ID</code>调用<code class="codeph">get_product_name_1</code> ，它都会缓存关联的<code class="codeph">TRANSLATED_NAME</code> 。每次调用<code class="codeph">get_product_name_1</code> ，最多<code class="codeph">get_product_name_1</code>将一个<code class="codeph">TRANSLATED_NAME</code>添加到缓存中。
                           </p>
                           <p>在<a href="plsql-subprograms.html#GUID-63930E6C-9244-4A1A-97FC-49B0A44888AC__BABCDECH">示例8-42中</a> ， <code class="codeph">get_product_name_2</code>定义了结果缓存函数<code class="codeph">all_product_names</code> 。每当<code class="codeph">get_product_name_2</code>使用不同的<code class="codeph">LANGUAGE_ID</code>调用<code class="codeph">all_product_names</code>时， <code class="codeph">all_product_names</code>缓存与该<code class="codeph">LANGUAGE_ID</code>关联的每个<code class="codeph">TRANSLATED_NAME</code> 。每次调用<code class="codeph">all_product_names</code>将最多一个<code class="codeph">LANGUAGE_ID</code>每个<code class="codeph">TRANSLATED_NAME</code>添加到缓存中。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-63930E6C-9244-4A1A-97FC-49B0A44888AC__BABDDJCD">
                           <p class="titleinexample">示例8-41一次缓存一个名称（更精细的粒度）</p><pre class="oac_no_warn" dir="ltr">创建或替换函数get_product_name_1（prod_id NUMBER，lang_id VARCHAR2）RETURN NVARCHAR2 <span class="bold">RESULT_CACHE</span> AUTHID DEFINER是result_ VARCHAR2（50）; BEGIN SELECT translated_name INTO result_ FROM OE.Product_Descriptions WHERE PRODUCT_ID = prod_id AND LANGUAGE_ID = lang_id;返回结果_;结束; /</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-63930E6C-9244-4A1A-97FC-49B0A44888AC__BABCDECH">
                           <p class="titleinexample">示例8-42一次缓存转换名称一种语言（较粗粒度）</p><pre class="oac_no_warn" dir="ltr">创建或替换函数get_product_name_2（prod_id NUMBER，lang_id VARCHAR2）RETURN NVARCHAR2 AUTHID DEFINER是TYPE product_names是NVARCHAR2的表（50）INDEX BY PLS_INTEGER;功能all_product_names（lang_id VARCHAR2）RETURN product_names <span class="bold">RESULT_CACHE</span>是all_names product_names; BEGIN FOR c IN（SELECT * FROM OE.Product_Descriptions WHERE LANGUAGE_ID = lang_id）LOOP all_names（c。PRODUCT_ID）：= c。TRANSLATED_NAME;结束循环;返回all_names;结束; BEGIN RETURN all_product_names（lang_id）（prod_id）;结束; /</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="LNPLS717"></a><div class="props_rev_3"><a id="GUID-8F7227E9-4388-4A64-9D1C-5F134A3022F2" name="GUID-8F7227E9-4388-4A64-9D1C-5F134A3022F2"></a><h5 id="LNPLS-GUID-8F7227E9-4388-4A64-9D1C-5F134A3022F2" class="sect5"><span class="enumeration_section">8.12.5.6</span> Oracle RAC环境中的结果缓存</h5>
                     <div>
                        <p>缓存结果存储在系统全局区域（SGA）中。在Oracle RAC环境中，每个数据库实例都管理自己的本地函数结果缓存。但是，连接到其他Oracle RAC实例的会话可以访问本地结果缓存的内容。如果本地实例的结果缓存中缺少必需的结果，则可能从另一个实例的本地缓存中检索结果，而不是在本地计算。</p>
                        <p>实例的访问模式和工作负载确定其本地缓存中的结果集;因此，不同实例的本地缓存可以具有不同的结果集。</p>
                        <p>虽然每个数据库实例可能都有自己的一组缓存结果，但处理无效结果的机制是Oracle RAC环境范围。如果结果仅在本地实例的结果缓存中无效，则其他实例可能使用无效结果。例如，考虑从数据库表中的数据计算的项目价格的结果缓存。如果以影响项目价格的方式更新这些数据库表中的任何一个，则必须在Oracle RAC环境中的每个数据库实例中使该项的缓存价格无效。</p>
                     </div>
                  </div><a id="LNPLS718"></a><div class="props_rev_3"><a id="GUID-4051143D-CABC-4395-BF7C-915253CA4CAB" name="GUID-4051143D-CABC-4395-BF7C-915253CA4CAB"></a><h5 id="LNPLS-GUID-4051143D-CABC-4395-BF7C-915253CA4CAB" class="sect5"><span class="enumeration_section">8.12.5.7</span>结果缓存管理</h5>
                     <div>
                        <p>PL / SQL函数结果缓存与结果缓存共享其管理和可管理性基础结构。</p>
                        <p>数据库管理员通过指定<code class="codeph">RESULT_CACHE_MAX_SIZE</code> ， <code class="codeph">RESULT_CACHE_MAX_RESULT</code>和<code class="codeph">RESULT_CACHE_REMOTE_EXPIRATION</code>初始化参数来管理服务器结果缓存。
                        </p>
                        <p><code class="codeph">DBMS_RESULT_CACHE</code>包提供了一个接口，允许DBA管理SQL结果缓存和PL / SQL函数结果缓存使用的共享池的那部分。
                        </p>
                        <p>动态性能视图提供监视服务器和客户端结果缓存的信息。</p>
                        <div class="infoboxnotealso" id="GUID-4051143D-CABC-4395-BF7C-915253CA4CAB__GUID-A7211E9B-D84D-44A8-8BE4-569DC0E68559">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>有关<code class="codeph">RESULT_CACHE_MAX_SIZE</code>更多信息，请<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/lnpls&amp;id=REFRN10272" target="_blank"><span class="italic">参见Oracle数据库参考</span></a></p>
                              </li>
                              <li>
                                 <p>有关<code class="codeph">RESULT_CACHE_MAX_RESULT</code>更多信息，请<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/lnpls&amp;id=REFRN10298" target="_blank"><span class="italic">参见Oracle数据库参考</span></a></p>
                              </li>
                              <li>
                                 <p>有关结果缓存概念的详细信息，请<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/lnpls&amp;id=TGDBA631" target="_blank"><span class="italic">参见“Oracle数据库性能调整指南</span></a></p>
                              </li>
                              <li>
                                 <p>有关<code class="codeph">DBMS_RESULT_CACHE</code>包的更多信息，请<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/lnpls&amp;id=ARPLS202" target="_blank"><span class="italic">参见Oracle Database PL / SQL包和类型参考</span></a></p>
                              </li>
                              <li>
                                 <p>有关<code class="codeph">V$RESULT_CACHE_STATISTICS</code>更多信息，请<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/lnpls&amp;id=REFRN30439" target="_blank"><span class="italic">参见Oracle数据库参考</span></a></p>
                              </li>
                              <li>
                                 <p>有关<code class="codeph">V$RESULT_CACHE_MEMORY</code>更多信息，请<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/lnpls&amp;id=REFRN30437" target="_blank"><span class="italic">参见Oracle数据库参考</span></a></p>
                              </li>
                              <li>
                                 <p>有关<code class="codeph">V$RESULT_CACHE_OBJECTS</code>更多信息，请<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/lnpls&amp;id=REFRN30438" target="_blank"><span class="italic">参见Oracle数据库参考</span></a></p>
                              </li>
                              <li>
                                 <p>有关<code class="codeph">V$RESULT_CACHE_DEPENDENCY</code>更多信息，请<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/lnpls&amp;id=REFRN30436" target="_blank"><span class="italic">参见Oracle数据库参考</span></a></p>
                              </li>
                           </ul>
                        </div>
                     </div>
                  </div><a id="LNPLS719"></a><div class="props_rev_3"><a id="GUID-7AEE971F-0A1E-4417-B13F-2E87D59A0441" name="GUID-7AEE971F-0A1E-4417-B13F-2E87D59A0441"></a><h5 id="LNPLS-GUID-7AEE971F-0A1E-4417-B13F-2E87D59A0441" class="sect5"><span class="enumeration_section">8.12.5.8</span>结果缓存函数<span class="enumeration_section">依赖的</span>热补丁PL / SQL单元</h5>
                     <div>
                        <div class="section">
                           <p>当您对结果缓存函数所依赖的PL / SQL单元（直接或间接）进行热修补时，与结果缓存函数关联的缓存结果可能不会在所有情况下自动刷新。</p>
                           <p>例如，假设结果缓存函数<code class="codeph">P1</code> 。 <code class="codeph">foo()</code>取决于包子程序<code class="codeph">P2</code> 。 <code class="codeph">bar()</code> 。如果加载了包<code class="codeph">P2</code>的主体的新版本，则缓存的结果与<code class="codeph">P1</code>相关联。 <code class="codeph">foo()</code>不会自动刷新。
                           </p>
                           <p>因此，这是热修补PL / SQL单元的推荐过程：</p>
                           <div class="infoboxnote" id="GUID-7AEE971F-0A1E-4417-B13F-2E87D59A0441__GUID-CD7E2AD7-1974-4FE6-A1F0-3756D983D07D">
                              <p class="notep1">注意：</p>
                              <p>要执行这些步骤，您必须具有<code class="codeph">DBMS_RESULT_CACHE</code>包的<code class="codeph">EXECUTE</code>特权。</p>
                           </div>
                        </div>
                        <!-- class="section" -->
                        <ol>
                           <li class="stepexpand"><span>将结果缓存置于旁路模式并刷新现有结果：</span><div><pre class="oac_no_warn" dir="ltr">BEGIN DBMS_RESULT_CACHE.Bypass（TRUE）; DBMS_RESULT_CACHE.Flush;结束; /</pre><p>在Oracle RAC环境中，对每个数据库实例执行此步骤。</p>
                              </div>
                           </li>
                           <li class="stepexpand"><span>修补PL / SQL代码。</span></li>
                           <li class="stepexpand"><span>使用结果缓存继续：</span><div><pre class="oac_no_warn" dir="ltr">BEGIN DBMS_RESULT_CACHE.Bypass（FALSE）;结束; /</pre><p>在Oracle RAC环境中，对每个数据库实例执行此步骤。</p>
                              </div>
                           </li>
                        </ol>
                     </div>
                  </div>
               </div>
            </div><a id="LNPLS99890"></a><div class="props_rev_3"><a id="GUID-4FC97312-AC30-4A6E-8337-996198191E29" name="GUID-4FC97312-AC30-4A6E-8337-996198191E29"></a><h3 id="LNPLS-GUID-4FC97312-AC30-4A6E-8337-996198191E29" class="sect3"><span class="enumeration_section">8.13</span> SQL语句可以调用的PL / SQL函数</h3>
               <div>
                  <p>要从SQL语句中调用，存储的函数（以及它调用的任何子程序）必须遵守以下纯度规则，这些规则旨在控制副作用：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>从<code class="codeph">SELECT</code>语句或并行<code class="codeph">INSERT</code> ， <code class="codeph">UPDATE</code> ， <code class="codeph">DELETE</code>或<code class="codeph">MERGE</code>语句调用时，子程序无法修改任何数据库表。
                        </p>
                     </li>
                     <li>
                        <p>从<code class="codeph">INSERT</code> ， <code class="codeph">UPDATE</code> ， <code class="codeph">DELETE</code>或<code class="codeph">MERGE</code>语句调用时，子程序无法查询或修改由该语句修改的任何数据库表。
                        </p>
                        <p>如果函数查询或修改表，并且该表上的DML语句调用该函数，则会发生ORA-04091（变异表错误）。有一个例外：如果不在<code class="codeph">FORALL</code>语句中的单行<code class="codeph">INSERT</code>语句调用<code class="codeph">VALUES</code>子句中的函数，则不会发生ORA-04091。
                        </p>
                     </li>
                     <li>
                        <p>从<code class="codeph">SELECT</code> ， <code class="codeph">INSERT</code> ， <code class="codeph">UPDATE</code> ， <code class="codeph">DELETE</code>或<code class="codeph">MERGE</code>语句调用时，子程序不能执行以下任何SQL语句（除非指定了<code class="codeph">PRAGMA</code> <code class="codeph">AUTONOMOUS_TRANSACTION</code> ）：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>事务控制语句（如<code class="codeph">COMMIT</code> ）</p>
                           </li>
                           <li>
                              <p>会话控制语句（例如<code class="codeph">SET</code> <code class="codeph">ROLE</code> ）</p>
                           </li>
                           <li>
                              <p>系统控制语句（如<code class="codeph">ALTER</code> <code class="codeph">SYSTEM</code> ）</p>
                           </li>
                           <li>
                              <p>自动提交的数据库定义语言（DDL）语句（如<code class="codeph">CREATE</code> ）</p>
                           </li>
                        </ul>
                        <p>（有关<code class="codeph">PRAGMA</code> <code class="codeph">AUTONOMOUS_TRANSACTION</code>的说明，请参阅<span class="q">“ <a href="AUTONOMOUS_TRANSACTION-pragma.html#GUID-AD33D949-081B-4CD3-A240-C29773E908C3" title="AUTONOMOUS_TRANSACTION编译指示将例程标记为自治;也就是说，独立于主要交易。">AUTONOMOUS_TRANSACTION Pragma</a> ”</span> 。）
                        </p>
                     </li>
                  </ul>
                  <p>如果函数执行部分中的任何SQL语句违反规则，则在解析该语句时会发生运行时错误。</p>
                  <p>函数的副作用越少，在<code class="codeph">SELECT</code>语句中优化得越好，特别是如果使用选项<code class="codeph">DETERMINISTIC</code>或<code class="codeph">PARALLEL_ENABLE</code>声明函数（有关这些选项的说明，请参阅<span class="q">“ <a href="DETERMINISTIC-clause.html#GUID-6AECC957-27CC-4334-9F43-0FBE88F92654" title="deterministic选项标记一个返回可预测结果且没有副作用的函数。">DETERMINISTIC子句</a> ”</span>和<span class="q">“ <a href="PARALLEL_ENABLE-clause.html#GUID-CFF3C7D3-6438-44C2-9FAF-569F246C37CA" title="启用并行执行功能，使其可以安全地用于并行DML评估的从属会话。">PARALLEL_ENABLE子句</a> ”</span> ）。
                  </p>
                  <div class="infoboxnotealso" id="GUID-4FC97312-AC30-4A6E-8337-996198191E29__GUID-9E97F4A4-F9BC-44D2-BF4A-C5BCBA9C6B1E">
                     <p class="notep1">也可以看看：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>有关SQL语句可以调用的PL / SQL函数限制的信息，请参见<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/lnpls&amp;id=ADFNS00908" target="_blank"><span class="italic">“Oracle数据库开发指南”</span></a></p>
                        </li>
                        <li>
                           <p><span class="q">“ <a href="plsql-optimization-and-tuning.html#GUID-C54C68DB-2C26-4D25-983D-1581C0CFDEDB" title="在查询中调用的函数可能会运行数百万次。不要在不必要的情况下调用查询中的函数，并使调用尽可能高效。">在查询中调整函数调用</a> ”</span></p>
                        </li>
                     </ul>
                  </div>
               </div>
            </div><a id="LNPLS591"></a><a id="LNPLS00809"></a><div class="props_rev_3"><a id="GUID-41D23DE7-3C07-41CF-962B-F92B696594B5" name="GUID-41D23DE7-3C07-41CF-962B-F92B696594B5"></a><h3 id="LNPLS-GUID-41D23DE7-3C07-41CF-962B-F92B696594B5" class="sect3"><span class="enumeration_section">8.14</span>祈求者的权利和定义者权利（AUTHID财产）</h3>
               <div>
                  <p>存储的PL / SQL单元的<code class="codeph">AUTHID</code>属性会影响单元在运行时发出的SQL语句的名称解析和权限检查。<code class="codeph">AUTHID</code>属性不会影响编译，对于没有代码的单元（例如集合类型）没有意义。
                  </p>
                  <p><code class="codeph">AUTHID</code>属性值在静态数据字典视图<code class="codeph">*_PROCEDURES</code> 。对于<code class="codeph">AUTHID</code>有意义的单位，视图显示值<code class="codeph">CURRENT_USER</code>或<code class="codeph">DEFINER</code> ;对于其他单位，视图显示<code class="codeph">NULL</code> 。</p>
                  <p>对于使用以下语句创建或更改的存储PL / SQL单元，可以使用可选的<code class="codeph">AUTHID</code>子句指定<code class="codeph">DEFINER</code> （默认值，用于向后兼容）或<code class="codeph">CURRENT_USER</code> （首选用法）：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><span class="q">“ <a href="CREATE-FUNCTION-statement.html#GUID-B71BC5BD-B87C-4054-AAA5-213E856651F2" title="CREATE FUNCTION语句创建或替换独立函数或调用规范。">创造功能声明</a> ”</span></p>
                     </li>
                     <li>
                        <p><span class="q">“ <a href="CREATE-PACKAGE-statement.html#GUID-03A70A54-90FF-4293-B6B8-F0B35E184AC5" title="CREATE PACKAGE语句创建或替换存储包的规范，存储包是数据库中作为一个单元存储的相关过程，函数和其他程序对象的封装集合。">CREATE PACKAGE声明</a> ”</span></p>
                     </li>
                     <li>
                        <p><span class="q">“ <a href="CREATE-PROCEDURE-statement.html#GUID-5F84DB47-B5BE-4292-848F-756BF365EC54" title="CREATE PROCEDURE语句创建或替换独立过程或调用规范。">CREATE PROCEDURE声明</a> ”</span></p>
                     </li>
                     <li>
                        <p><span class="q">“ <a href="CREATE-TYPE-statement.html#GUID-389D603D-FBD0-452A-8414-240BBBC57034" title="CREATE TYPE语句指定类型的名称及其属性，方法和其他属性。">创建类型声明</a> ”</span></p>
                     </li>
                     <li>
                        <p><span class="q">“ <a href="ALTER-TYPE-statement.html#GUID-A8B449E7-E3A8-48F4-A4C6-5BB87B1841CD" title="使用ALTER TYPE语句添加或删除成员属性或方法。您可以更改对象类型的现有属性，并可以修改该类型的标量属性。您还可以使用此语句重新编译类型的规范或正文，或通过添加新的对象成员子程序规范来更改对象类型的规范。">ALTER TYPE声明</a> ”</span></p>
                     </li>
                  </ul>
                  <p><code class="codeph">AUTHID</code>值为<code class="codeph">CURRENT_USER</code> <span class="bold">的单位</span>称为<span class="bold">调用者权限单位</span>或<span class="bold">IR单位</span> 。<code class="codeph">AUTHID</code>值为<code class="codeph">DEFINER</code> （默认值） <span class="bold">的单位</span>称为<span class="bold">定义者权限单位</span>或<span class="bold">DR单位</span> 。您无法指定<code class="codeph">AUTHID</code>值的PL / SQL单元和架构对象的行为如下：</p>
                  <div class="tblformal" id="GUID-41D23DE7-3C07-41CF-962B-F92B696594B5__GUID-1AC8A030-B00B-4617-9DB4-08576216FE95">
                     <table cellpadding="4" cellspacing="0" class="Formal" title="" width="100%" border="1" summary="Behavior of PL/SQL units and schema objects for which you cannot specify AUTHID values." frame="hsides" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="38%" id="d58247e8265">PL / SQL单元或模式对象</th>
                              <th align="left" valign="bottom" width="62%" id="d58247e8268">行为</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="38%" id="d58247e8273" headers="d58247e8265 ">
                                 <p>匿名阻止</p>
                              </td>
                              <td align="left" valign="top" width="62%" headers="d58247e8273 d58247e8268 ">
                                 <p>红外线单位</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="38%" id="d58247e8280" headers="d58247e8265 ">
                                 <p><code class="codeph">BEQUEATH</code> <code class="codeph">CURRENT_USER</code>视图</p>
                              </td>
                              <td align="left" valign="top" width="62%" headers="d58247e8280 d58247e8268 ">
                                 <p>有点像IR单元 - 请参阅<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/lnpls&amp;id=DBSEG586" target="_blank"><span class="italic">Oracle数据库安全指南</span></a> 。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="38%" id="d58247e8297" headers="d58247e8265 ">
                                 <p><code class="codeph">BEQUEATH</code> <code class="codeph">DEFINER</code>视图</p>
                              </td>
                              <td align="left" valign="top" width="62%" headers="d58247e8297 d58247e8268 ">
                                 <p>DR单位</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="38%" id="d58247e8309" headers="d58247e8265 ">
                                 <p>触发</p>
                              </td>
                              <td align="left" valign="top" width="62%" headers="d58247e8309 d58247e8268 ">
                                 <p>DR单位</p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
                  <p>单元的<code class="codeph">AUTHID</code>属性确定单元是IR还是DR，并且它在运行时影响名称解析和权限检查：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>名称解析的上下文是<code class="codeph">CURRENT_SCHEMA</code> 。</p>
                     </li>
                     <li>
                        <p>检查的权限是<code class="codeph">CURRENT_USER</code>和已启用角色的权限。
                        </p>
                     </li>
                  </ul>
                  <p>会话启动时， <code class="codeph">CURRENT_SCHEMA</code>具有<code class="codeph">SESSION_USER</code>拥有的架构的值，而<code class="codeph">CURRENT_USER</code>具有与<code class="codeph">SESSION_USER</code>相同的值。 （要获取<code class="codeph">CURRENT_SCHEMA</code> ， <code class="codeph">CURRENT_USER</code>或<code class="codeph">SESSION_USER</code>的当前值，请使用<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/lnpls&amp;id=SQLRF06117" target="_blank"><span class="italic">Oracle数据库SQL语言参考中</span></a>记录的<code class="codeph">SYS_CONTEXT</code>函数。）
                  </p>
                  <p><code class="codeph">CURRENT_SCHEMA</code>可以用SQL语句的会话过程中改变<code class="codeph">ALTER</code> <code class="codeph">SESSION</code> <code class="codeph">SET</code> <code class="codeph">CURRENT_SCHEMA</code> 。无法以编程方式更改<code class="codeph">CURRENT_USER</code> ，但是当PL / SQL单元或视图被推入或弹出调用堆栈时，它可能会更改。
                  </p>
                  <div class="infoboxnote" id="GUID-41D23DE7-3C07-41CF-962B-F92B696594B5__GUID-BDF0C8F3-276E-488D-8BEB-CE27141B5F63">
                     <p class="notep1">注意：</p>
                     <p>Oracle建议不要在存储的PL / SQL单元中发出<code class="codeph">ALTER</code> <code class="codeph">SESSION</code> <code class="codeph">SET</code> <code class="codeph">CURRENT_SCHEMA</code> 。
                     </p>
                  </div>
                  <p>在服务器调用期间，当DR单元被推入调用堆栈时，数据库将存储当前启用的角色以及<code class="codeph">CURRENT_USER</code>和<code class="codeph">CURRENT_SCHEMA</code>的当前值。然后，它将<code class="codeph">CURRENT_USER</code>和<code class="codeph">CURRENT_SCHEMA</code>都更改为DR单元的所有者，并仅启用角色<code class="codeph">PUBLIC</code> 。 （存储的和新的角色和值不一定不同。）从调用堆栈弹出DR单元时，数据库将恢复存储的角色和值。相反，当IR单元被推入或弹出调用堆栈时， <code class="codeph">CURRENT_USER</code>和<code class="codeph">CURRENT_SCHEMA</code>的值以及当前启用的角色不会更改（除非角色被授予IR单元本身 - 请参阅<span class="q">“ <a href="plsql-subprograms.html#GUID-56F9EB4F-C777-445C-8C6F-0AA3800E37A5">授予角色到PL / SQL包和独立子程序</a> “</span> ）。
                  </p>
                  <p>对于PL / SQL单元发出的动态SQL语句，名称解析和权限检查在运行时完成一次。对于静态SQL语句，名称解析和权限检查会执行两次：首先，编译PL / SQL单元，然后再运行时。在编译时， <code class="codeph">AUTHID</code>属性不起作用 -  DR和IR单元都被视为DR单元。但是，在运行时， <code class="codeph">AUTHID</code>属性确定单元是IR还是DR，并相应地处理该单元。
                  </p>
                  <p>进入IR单元后，运行时系统会在进行任何初始化或运行任何代码之前检查权限。如果单位的老板既没有<code class="codeph">INHERIT</code> <code class="codeph">PRIVILEGES</code>的调用，也不是特权<code class="codeph">INHERIT</code> <code class="codeph">ANY</code> <code class="codeph">PRIVILEGES</code>的特权，那么运行时系统会引发错误ORA-06598。
                  </p>
                  <div class="infoboxnote" id="GUID-41D23DE7-3C07-41CF-962B-F92B696594B5__GUID-7BEC4F76-6CA4-4D22-B2FA-4B0DCB53DCAB">
                     <p class="notep1">注意：</p>
                     <p>如果单位所有者具有所需的权限，则其中一个语句授予它：</p><pre class="oac_no_warn" dir="ltr">GRANT INHERIT特权ON <span class="italic">CURRENT_USER</span>公共GRANT INHERIT特权ON <span class="italic">CURRENT_USER</span> TO <span class="italic">unit_owner</span> GRANT继承任何权限才能<span class="italic">unit_owner</span></pre><p>有关<code class="codeph">GRANT</code>语句的信息，请参见<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/lnpls&amp;id=SQLRF01603" target="_blank"><span class="italic">Oracle数据库SQL语言参考</span></a> 。
                     </p>
                  </div>
                  <div class="infoboxnotealso" id="GUID-41D23DE7-3C07-41CF-962B-F92B696594B5__GUID-239BF71D-D506-4BAB-87C1-1EB4BB9201CE">
                     <p class="notep1">也可以看看：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>有关管理DR和IR单元安全性的信息，请参见<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/lnpls&amp;id=DBSEG658" target="_blank"><span class="italic">“Oracle数据库安全指南”</span></a></p>
                        </li>
                        <li>
                           <p>有关捕获编译DR和IR程序单元所需的权限的信息，请参见<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/lnpls&amp;id=DBSEG-GUID-44CB644B-7B59-4B3B-B375-9F9B96F60186" target="_blank">“Oracle数据库安全指南”</a></p>
                        </li>
                     </ul>
                  </div>
                  <div class="section">
                     <p class="subhead2" id="GUID-41D23DE7-3C07-41CF-962B-F92B696594B5__GUID-69A9F146-F75F-4CCC-9FE0-0AD3158BCA41">话题</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="plsql-subprograms.html#GUID-56F9EB4F-C777-445C-8C6F-0AA3800E37A5">授予PL / SQL包和独立子程序的角色</a></p>
                        </li>
                        <li>
                           <p><a href="plsql-subprograms.html#GUID-84EF0E35-40E5-4EB7-BDA3-F0410A300BB4">IR单位需要模板对象</a></p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
               </div><a id="LNPLS599"></a><div class="props_rev_3"><a id="GUID-56F9EB4F-C777-445C-8C6F-0AA3800E37A5" name="GUID-56F9EB4F-C777-445C-8C6F-0AA3800E37A5"></a><h4 id="LNPLS-GUID-56F9EB4F-C777-445C-8C6F-0AA3800E37A5" class="sect4"><span class="enumeration_section">8.14.1</span>授予PL / SQL包和独立子程序的角色</h4>
                  <div>
                     <div class="section">
                        <p>使用SQL <code class="codeph">GRANT</code>命令，可以将角色授予PL / SQL包和独立子程序。授予PL / SQL单元的角色不会影响编译。它们会影响单元在运行时发出的SQL语句的权限检查：该单元以其自己的角色和任何其他当前启用的角色的权限运行。
                        </p>
                        <p>通常，您将角色授予IR单元，以便权限低于您的用户可以仅使用所需的权限运行该单元。仅当DR单元发出动态SQL（仅在运行时检查）时，才将角色授予DR单元（其调用者以所有权限运行它）。</p>
                        <p>向PL / SQL单元授予角色的基本语法是：</p><pre class="oac_no_warn" dir="ltr">GRANT <span class="italic">角色</span> [， <span class="italic">角色</span> ] ......<span class="italic">单位</span> [， <span class="italic">单位</span> ] ......
</pre><p>例如，此命令将角色<code class="codeph">read</code>和<code class="codeph">execute</code>授予<code class="codeph">scott</code>函数。 <code class="codeph">func</code>和包<code class="codeph">sys</code> 。 <code class="codeph">pkg</code> ：</p><pre class="oac_no_warn" dir="ltr">GRANT读取，执行TO FUNCTION scott.func，PACKAGE sys.pkg</pre><p>有关<code class="codeph">GRANT</code>命令的完整语法和语义，请参见<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/lnpls&amp;id=SQLRF01603" target="_blank"><span class="italic">Oracle数据库SQL语言参考</span></a> 。
                        </p>
                        <div class="infoboxnotealso" id="GUID-56F9EB4F-C777-445C-8C6F-0AA3800E37A5__GUID-0FFE500A-E5EA-49DA-8C84-6498C927378A">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>有关<code class="codeph">REVOKE</code>命令的信息，请参阅<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/lnpls&amp;id=SQLRF01609" target="_blank"><span class="italic">Oracle数据库SQL语言参考</span></a> ，该命令允许您从PL / SQL单元撤消角色</p>
                              </li>
                              <li>
                                 <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/lnpls&amp;id=DBSEG977" target="_blank"><span class="italic">“Oracle数据库安全指南”</span></a> ，了解有关配置应用程序用户和应用程序角</p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPLS684"></a><div class="props_rev_3"><a id="GUID-84EF0E35-40E5-4EB7-BDA3-F0410A300BB4" name="GUID-84EF0E35-40E5-4EB7-BDA3-F0410A300BB4"></a><h4 id="LNPLS-GUID-84EF0E35-40E5-4EB7-BDA3-F0410A300BB4" class="sect4"><span class="enumeration_section">8.14.2</span> IR单位需要模板对象</h4>
                  <div>
                     <p>一个用户（即一个模式）拥有IR单元，其他用户在其模式中运行它。如果IR单元发出静态SQL语句，那么这些语句所影响的模式对象必须在编译时存在于所有者的模式中（以便编译器可以解析引用）并且在运行时在调用程序的模式中。相应模式对象的定义必须匹配（例如，相应的表必须具有相同的名称和列）;否则，您会收到错误或意外结果。但是，所有者架构中的对象不需要包含数据，因为编译器不需要它;因此，它们被称为<span class="bold">模板对象</span> 。
                     </p>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-4E2AB647-B417-49C4-B7C6-C68DB086456F" name="GUID-4E2AB647-B417-49C4-B7C6-C68DB086456F"></a><h4 id="LNPLS-GUID-4E2AB647-B417-49C4-B7C6-C68DB086456F" class="sect4"><span class="enumeration_section">8.14.3</span> DR单元中的已连接用户数据库链接</h4>
                  <div>
                     <p>如果在DR单元（定义者权限单元）中包含已连接的用户数据库链接，则必须向将运行DR单元的用户授予<code class="codeph">INHERIT REMOTE PRIVILEGES</code>权限。
                     </p>
                     <p>授予用户此权限使用户能够执行DR单元;否则， <code class="codeph">ORA-25433: User does not have INHERIT REMOTE PRIVILEGES</code>执行将失败<code class="codeph">ORA-25433: User does not have INHERIT REMOTE PRIVILEGES</code>错误。要在定义者权限（DR）过程中包含已连接的用户数据库链接，请在过程中包含<code class="codeph">@ <span class="codeinlineitalic">database_link</span></code> 。
                     </p>
                     <p>以下示例显示DR单元如何使用名为<code class="codeph">dblink</code>的数据库链接访问<code class="codeph">HR.EMPLOYEES</code>表的<code class="codeph">EMPLOYEE_ID</code>列：</p>
                     <div class="example" id="GUID-4E2AB647-B417-49C4-B7C6-C68DB086456F__GUID-6B4EC395-688A-40D7-AE31-F98EA1E393B5">
                        <p class="titleinexample">例8-43 DR单元中的数据库链接</p><pre class="oac_no_warn" dir="ltr">创建或替换过程hr_remote_db_link AS v_employee_id VARCHAR（50）; BEGIN EXECUTE IMMEDIATE'SELECT employee_id FROM employees @ dblink'into v_employee_id; DBMS_OUTPUT.PUT_LINE（'employee_id：'|| v_employee_id）;结束 ; /</pre></div>
                     <!-- class="example" -->
                     <div class="section">
                        <div class="infoboxnotealso" id="GUID-4E2AB647-B417-49C4-B7C6-C68DB086456F__GUID-6AA7D12A-0516-4066-8C45-9EFDEEBF7A59">
                           <p class="notep1">也可以看看：</p>
                           <p>有关使用<code class="codeph">INHERIT REMOTE PRIVILEGES</code>权限的更多信息，请参阅<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/lnpls&amp;id=DBSEG-GUID-B354724F-BD35-47C7-A699-93C2B6389555" target="_blank"><span><cite>“Oracle数据库安全指南”</cite></span></a> ，包括有关DR单元如何使用数据库链接的教程</p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="LNPLS601"></a><a id="LNPLS693"></a><a id="LNPLS00812"></a><div class="props_rev_3"><a id="GUID-96B5DE2B-D809-4296-9CDE-B317B81895F8" name="GUID-96B5DE2B-D809-4296-9CDE-B317B81895F8"></a><h3 id="LNPLS-GUID-96B5DE2B-D809-4296-9CDE-B317B81895F8" class="sect3"><span class="enumeration_section">8.15</span>外部子程序</h3>
               <div>
                  <p>如果C过程或Java方法存储在数据库中，则可以将其作为外部子程序发布，然后从PL / SQL调用它。</p>
                  <p>要发布外部子程序，请使用调用规范定义存储的PL / SQL子程序。调用规范将外部子程序的名称，参数类型和返回类型映射到PL / SQL等效项。通过PL / SQL名称调用已发布的外部子程序。</p>
                  <p>例如，假设此Java类<code class="codeph">Adjuster</code>存储在数据库中：</p><pre class="oac_no_warn" dir="ltr">import java.sql。*; import oracle.jdbc.driver。*; <span class="bold">public class Adjuster</span> { <span class="bold">public static void raiseSalary（int empNo，float percent）</span> throws SQLException {Connection conn = new OracleDriver（）。defaultConnection（）; String sql =“UPDATE员工SET薪水=薪水*？WHERE employee_id =？“; try {PreparedStatement pstmt = conn.prepareStatement（sql）; pstmt.setFloat（1，（1 + percent / 100））; pstmt.setInt（2，empNo）; pstmt.executeUpdate（）; pstmt.close（）; } catch（SQLException e）{System.err.println（e.getMessage（））;}}}</pre><p>Java类<code class="codeph">Adjuster</code>有一个方法<code class="codeph">raiseSalary</code> ，它以指定的百分比提高指定员工的工资。因为<code class="codeph">raiseSalary</code>是一个<code class="codeph">void</code>方法，所以将它作为PL / SQL过程（而不是函数）发布。
                  </p>
                  <p><a href="plsql-subprograms.html#GUID-96B5DE2B-D809-4296-9CDE-B317B81895F8__CHDHHBGB">例8-44</a>将存储的Java方法<code class="codeph">Adjuster.raiseSalary</code>作为PL / SQL独立过程发布，将Java方法名称<code class="codeph">Adjuster.raiseSalary</code>映射到PL / SQL过程名称<code class="codeph">raise_salary</code> ，并将Java数据类型<code class="codeph">int</code>和<code class="codeph">float</code>映射到PL / SQL数据输入<code class="codeph">NUMBER</code> 。然后匿名块调用<code class="codeph">raise_salary</code> 。
                  </p>
                  <p><a href="plsql-subprograms.html#GUID-96B5DE2B-D809-4296-9CDE-B317B81895F8__CHDFAGDA">例8-45</a>发布了存储的Java方法<code class="codeph">java.lang.Thread.sleep</code>作为PL / SQL程序独立，映射Java方法名的PL / SQL程序名称<code class="codeph">java_sleep</code>和Java数据类型<code class="codeph">long</code>到PL / SQL数据类型<code class="codeph">NUMBER</code> 。 PL / SQL独立过程<code class="codeph">sleep</code>调用<code class="codeph">java_sleep</code> 。
                  </p>
                  <div class="infoboxnotealso" id="GUID-96B5DE2B-D809-4296-9CDE-B317B81895F8__GUID-3BFC9151-677E-4CC6-8590-445D34E6A8AE">
                     <p class="notep1">也可以看看：</p>
                     <p>有关调用外部程序的详细信息，请参阅<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/lnpls&amp;id=ADFNS010" target="_blank"><span class="italic">Oracle数据库开发指</span></a></p>
                  </div>
                  <div class="example" id="GUID-96B5DE2B-D809-4296-9CDE-B317B81895F8__CHDHHBGB">
                     <p class="titleinexample">例8-44 PL / SQL匿名块调用外部过程</p><pre class="oac_no_warn" dir="ltr">- 将Adjuster.raiseSalary作为独立的PL / SQL过程发布：CREATE OR REPLACE PROCEDURE raise_salary（empid NUMBER，pct NUMBER）AS LANGUAGE JAVA NAME'Paulter.raiseSalary（int，float）'; -  call specification / BEGIN raise_salary（120,10）; - 通过PL / SQL名称END调用Adjuster.raiseSalary; /</pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-96B5DE2B-D809-4296-9CDE-B317B81895F8__CHDFAGDA">
                     <p class="titleinexample">例8-45 PL / SQL独立过程调用外部过程</p><pre class="oac_no_warn" dir="ltr">-  Java调用规范：CREATE PROCEDURE java_sleep（milli_seconds IN NUMBER）AS <span class="bold">LANGUAGE JAVA NAME'java.lang <span class="bold">。Thread.sleep（long）'</span> ; / CREATE OR REPLACE PROCEDURE sleep（mill__conds in NUMBER）AUTHID DEFINER BEGIN DBMS_OUTPUT.PUT_LINE（DBMS_UTILITY.get_time（））; <span class="bold">java_sleep（milli_seconds）;</span> DBMS_OUTPUT.PUT_LINE（DBMS_UTILITY.get_time（））;结束; /</pre></div>
                  <!-- class="example" -->
               </div>
            </div>
         </div>
      </article>
   </body>
</html>