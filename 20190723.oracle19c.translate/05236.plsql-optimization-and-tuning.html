<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <meta name="abstract" content="This chapter explains how the PL/SQL compiler optimizes your code and how to write efficient PL/SQL code and improve existing PL/SQL code."></meta>
      <meta name="description" content="This chapter explains how the PL/SQL compiler optimizes your code and how to write efficient PL/SQL code and improve existing PL/SQL code."></meta>
      <title>PL / SQL优化和调优</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Database PL/SQL Language Reference "></meta>
      <meta property="og:description" content="This chapter explains how the PL/SQL compiler optimizes your code and how to write efficient PL/SQL code and improve existing PL/SQL code."></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Database PL/SQL Language Reference"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="database-pl-sql-language-reference.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-13T20:26:20-08:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="1996, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96448-02"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="plsql-error-handling.html" title="Previous" type="text/html"></link>
      <link rel="next" href="plsql-language-elements.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Database PL/SQL Language Reference"></meta>
    <meta name="dcterms.isVersionOf" content="LNPLS"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="plsql-error-handling.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="plsql-language-elements.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">数据库PL / SQL语言参考</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">PL / SQL优化和调优</li>
            </ol>
            <a id="GUID-12C08950-12A4-45F4-92F1-49B19417BCD5" name="GUID-12C08950-12A4-45F4-92F1-49B19417BCD5"></a><a id="LNPLS766"></a><a id="LNPLS012"></a>
            
            <h2 id="LNPLS-GUID-12C08950-12A4-45F4-92F1-49B19417BCD5" class="sect2"><span class="enumeration_chapter">12</span> PL / SQL优化和调优</h2>
         </header>
         <div class="ind">
            <div>
               <p>本章介绍PL / SQL编译器如何优化代码以及如何编写有效的PL / SQL代码以及改进现有的PL / SQL代码。</p>
               <div class="section">
                  <p class="subhead1" id="GUID-12C08950-12A4-45F4-92F1-49B19417BCD5__GUID-D96A464E-DB11-4496-858A-F10173023AD9">话题</p>
               </div>
               <!-- class="section" -->
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="plsql-optimization-and-tuning.html#GUID-8BC4231B-2E5C-47D6-BE14-6D75CE14C57E" title="编译器可以执行的一个优化是子程序内联。">PL / SQL优化器</a></p>
                  </li>
                  <li>
                     <p><a href="plsql-optimization-and-tuning.html#GUID-1640FEEA-4237-4A0D-B445-621EF2A420C6">调整的候选人</a></p>
                  </li>
                  <li>
                     <p><a href="plsql-optimization-and-tuning.html#GUID-C2DC6043-17CC-4F9F-934D-A075133FBD01" title="在查询中调用的函数可能会运行数百万次。不要在不必要的情况下调用查询中的函数，并使调用尽可能高效。如果子程序具有OUT或IN OUT参数，则有时可以通过使用NOCOPY提示声明这些参数来减少其调用开销。">最小化CPU开销</a></p>
                  </li>
                  <li>
                     <p><a href="plsql-optimization-and-tuning.html#GUID-61D1B533-DBB9-4150-91F9-0A4C9428391E" title="批量SQL最大限度地减少了PL / SQL和SQL之间通信的性能开销。包含批量SQL的PL / SQL功能是FORALL语句和BULK COLLECT子句。为SQL语句中出现的PL / SQL变量赋值称为绑定。">批量SQL和批量绑定</a></p>
                  </li>
                  <li>
                     <p><a href="plsql-optimization-and-tuning.html#GUID-ED557894-EC08-47E0-A629-0E4AEDDBB77B" title="表函数是用户定义的PL / SQL函数，它返回行的集合（关联数组，嵌套表或varray）。">链接流水线表功能进行多次转换</a></p>
                  </li>
                  <li>
                     <p><a href="plsql-optimization-and-tuning.html#GUID-981102A8-5204-4931-B10A-93486304B184" title="多态表函数（PTF）是表函数，其操作数可以有多种类型。返回类型由PTF调用参数列表确定。表类型的实际参数通常决定行输出形状，但并非总是如此。">多态表函数概述</a></p>
                  </li>
                  <li>
                     <p><a href="plsql-optimization-and-tuning.html#GUID-AD1BDE75-DDC1-496E-8964-CA0D41B0C76A">并行更新大表</a></p>
                  </li>
                  <li>
                     <p><a href="plsql-optimization-and-tuning.html#GUID-AD358676-E837-45EB-9301-36A094A3BB22">收集有关用户定义标识符的数据</a></p>
                  </li>
                  <li>
                     <p><a href="plsql-optimization-and-tuning.html#GUID-D99A60B1-E3ED-4252-A85C-8FA732EE9957" title="为了帮助您隔离大型PL / SQL程序中的性能问题，PL / SQL提供了这些工具，实现为PL / SQL包。">分析和跟踪PL / SQL程序</a></p>
                  </li>
                  <li>
                     <p><a href="plsql-optimization-and-tuning.html#GUID-7C4557E7-4C35-4CAB-A95D-CB96BDC6D487">编译本机执行的PL / SQL单元</a></p>
                  </li>
               </ul>
               <div class="infoboxnotealso" id="GUID-12C08950-12A4-45F4-92F1-49B19417BCD5__GUID-11E50C2E-81B4-40C4-9AA4-EE932104A009">
                  <p class="notep1">也可以看看：</p>
                  <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/lnpls&amp;id=ADFNS160" target="_blank"><span class="italic">Oracle数据库开发指南</span></a> ，了解游标变量的缺点</p>
               </div>
            </div><a id="LNPLS01201"></a><div class="props_rev_3"><a id="GUID-8BC4231B-2E5C-47D6-BE14-6D75CE14C57E" name="GUID-8BC4231B-2E5C-47D6-BE14-6D75CE14C57E"></a><h3 id="LNPLS-GUID-8BC4231B-2E5C-47D6-BE14-6D75CE14C57E" class="sect3"><span class="enumeration_section">12.1</span> PL / SQL优化器</h3>
               <div>
                  <p>在Oracle Database 10g第1版之前，PL / SQL编译器将源文本转换为系统代码，而不应用许多更改来提高性能。现在，PL / SQL使用一个优化器，可以重新排列代码以获得更好的性能。</p>
                  <p>默认情况下启用优化程序。在极少数情况下，如果优化程序的开销使得非常大的应用程序的编译速度太慢，则可以通过设置编译参数<code class="codeph">PLSQL_OPTIMIZE_LEVEL=1</code>而不是其默认值2来降低优化。在更罕见的情况下，PL / SQL可能会提前发布异常，或者根本不会发生异常。设置<code class="codeph">PLSQL_OPTIMIZE_LEVEL=1</code>可防止重新排列代码。
                  </p>
                  <div class="infoboxnotealso" id="GUID-8BC4231B-2E5C-47D6-BE14-6D75CE14C57E__GUID-DA5E60E8-C791-4F4F-8002-47500C9D691C">
                     <p class="notep1">也可以看看：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>有关<code class="codeph">PLSQL_OPTIMIZE_LEVEL</code>编译参数的信息，请<code class="codeph">PLSQL_OPTIMIZE_LEVEL</code> <a href="../refrn/PLSQL_OPTIMIZE_LEVEL.html#REFRN10255" target="_blank"><span class="italic">Oracle数据库参考</span></a></p>
                        </li>
                        <li>
                           <p>有关更改<code class="codeph">PLSQL_OPTIMIZE_LEVEL</code>编译参数的示例，请<code class="codeph">PLSQL_OPTIMIZE_LEVEL</code> <a href="../adfns/coding-subprograms-and-packages.html#ADFNS1422" target="_blank"><span class="italic">“Oracle数据库开发指南”</span></a></p>
                        </li>
                        <li>
                           <p>有关静态字典视图<code class="codeph">ALL_PLSQL_OBJECT_SETTINGS</code>信息，请<a href="../refrn/ALL_PLSQL_OBJECT_SETTINGS.html#REFRN20385" target="_blank"><span class="italic">参见Oracle数据库参考</span></a></p>
                        </li>
                     </ul>
                  </div>
               </div><a id="LNPLS1219"></a><a id="LNPLS1220"></a><a id="LNPLS1221"></a><a id="LNPLS1222"></a><a id="LNPLS99951"></a><div class="props_rev_3"><a id="GUID-2E78813E-CF29-409D-9F8B-AA24B294BFA2" name="GUID-2E78813E-CF29-409D-9F8B-AA24B294BFA2"></a><h4 id="LNPLS-GUID-2E78813E-CF29-409D-9F8B-AA24B294BFA2" class="sect4"><span class="enumeration_section">12.1.1</span>子程序内联</h4>
                  <div>
                     <p>编译器可以执行的一个优化是<span class="bold">子程序内联</span> 。
                     </p>
                     <p>子程序内联将子程序调用替换为调用的子程序的副本（如果调用的子程序和调用的子程序位于同一程序单元中）。要允许子程序内联，请接受<code class="codeph">PLSQL_OPTIMIZE_LEVEL</code>编译参数的默认值（即2）或将其设置为3。
                     </p>
                     <p>如果<code class="codeph">PLSQL_OPTIMIZE_LEVEL=2</code> ，则必须使用<code class="codeph">INLINE</code>编译指示指定要内联的每个子程序：</p><pre class="oac_no_warn" dir="ltr">PRAGMA INLINE（ <span class="italic">子程序</span> ，'YES'）</pre><p>如果<span class="italic"><code class="codeph">subprogram</code></span>过载，则前面的编译指示适用于具有该名称的每个子程序。
                     </p>
                     <p><code class="codeph">PLSQL_OPTIMIZE_LEVEL=3</code> ，PL / SQL编译器会寻找内联子程序的机会。您无需指定要内联的子程序。但是，您可以使用<code class="codeph">INLINE</code>编译指示（使用前面的语法）为子程序提供内联的高优先级，然后编译器将其内联，除非其他注意事项或限制使内联不受欢迎。
                     </p>
                     <p>如果内联特定子程序，性能几乎总是会提高。但是，由于编译器在优化过程的早期内联子程序，子程序内联可能会排除以后更强大的优化。</p>
                     <p>如果子程序内联减慢了特定PL / SQL程序的性能，则使用PL / SQL分层分析器来识别要关闭内联的子程序。要关闭子程序的内联，请使用<code class="codeph">INLINE</code>编译指示：</p><pre class="oac_no_warn" dir="ltr">PRAGMA INLINE（ <span class="italic">子程序</span> ，'NO'）</pre><p><code class="codeph">INLINE</code>编译指示仅影响紧随其后的声明或语句，并且仅影响某些类型的语句。
                     </p>
                     <p>当<code class="codeph">INLINE</code>编译指示紧接在声明之前时，它会影响：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>在该声明中每次调用指定的子程序</p>
                        </li>
                        <li>
                           <p>除了记录的默认初始化值之外，该声明中的每个初始化值</p>
                        </li>
                     </ul>
                     <p>当<code class="codeph">INLINE</code>编译指示紧接在其中一个语句之前时，该编译指示会影响该语句中指定子程序的每次调用：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>分配</p>
                        </li>
                        <li>
                           <p><code class="codeph">呼叫</code></p>
                        </li>
                        <li>
                           <p>条件</p>
                        </li>
                        <li>
                           <p><code class="codeph">案件</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">CONTINUE</code> <code class="codeph">WHEN</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">EXECUTE</code> <code class="codeph">IMMEDIATE</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">EXIT</code> <code class="codeph">WHEN</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">环</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">返回</code></p>
                        </li>
                     </ul>
                     <p><code class="codeph">INLINE</code>编译指示不会影响前面列表中没有的语句。
                     </p>
                     <p>多个pragma可以影响相同的声明或语句。每个pragma都将自己的效果应用于语句。如果<code class="codeph">PRAGMA</code> <code class="codeph">INLINE(</code> <span class="italic"><code class="codeph">subprogram,</code></span> <code class="codeph">'YES')</code>和<code class="codeph">PRAGMA</code> <code class="codeph">INLINE(</code> <span class="italic"><code class="codeph">identifier,</code></span> <code class="codeph">'NO')</code>具有相同的<span class="italic"><code class="codeph">subprogram</code></span> ，则<code class="codeph">'NO'</code>覆盖<code class="codeph">'YES'</code> 。一个<code class="codeph">PRAGMA</code> <code class="codeph">INLINE(</code> <span class="italic"><code class="codeph">subprogram,</code></span> <code class="codeph">'NO')</code>会覆盖<code class="codeph">PRAGMA</code> <code class="codeph">INLINE(</code> <span class="italic"><code class="codeph">subprogram,</code></span> <code class="codeph">'YES')</code>任意数量，并且这些pragma的顺序并不重要。
                     </p>
                     <div class="infoboxnotealso" id="GUID-2E78813E-CF29-409D-9F8B-AA24B294BFA2__GUID-9E10AC95-93E9-4F66-9D91-9E2E77F0853C">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>有关PL / SQL分层分析器的更多信息，请参见<a href="../adfns/hierarchical-profiler.html#ADFNS023" target="_blank"><span class="italic">“Oracle数据库开发指南”</span></a></p>
                           </li>
                           <li>
                              <p>有关<code class="codeph">PLSQL_OPTIMIZE_LEVEL</code>编译参数的信息，请<code class="codeph">PLSQL_OPTIMIZE_LEVEL</code> <a href="../refrn/PLSQL_OPTIMIZE_LEVEL.html#REFRN10255" target="_blank"><span class="italic">Oracle数据库参考</span></a></p>
                           </li>
                           <li>
                              <p>有关静态字典视图<code class="codeph">ALL_PLSQL_OBJECT_SETTINGS</code>信息，请<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/lnpls&amp;id=REFRN20385" target="_blank"><span class="italic">参见Oracle数据库参考</span></a></p>
                           </li>
                        </ul>
                     </div>
                     <div class="example" id="GUID-2E78813E-CF29-409D-9F8B-AA24B294BFA2__CHDBGJDJ">
                        <p class="titleinexample">例12-1指定要内联子程序</p>
                        <p>在此示例中，如果<code class="codeph">PLSQL_OPTIMIZE_LEVEL=2</code> ，则<code class="codeph">INLINE</code>编译指示会影响过程调用<code class="codeph">p1(1)</code>和<code class="codeph">p1(2)</code> ，但不会影响过程调用<code class="codeph">p1(3)</code>和<code class="codeph">p1(4)</code> 。
                        </p><pre class="oac_no_warn" dir="ltr">程序p1（x PLS_INTEGER）是.........
<span class="bold">PRAGMA INLINE（第1页，'是'）;</span> x：= p1（1）+ p1（2）+17; - 对p1的这2次调用是内联的......x：= p1（3）+ p1（4）+17; - 这两次对p1的调用没有内联......
</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-2E78813E-CF29-409D-9F8B-AA24B294BFA2__CHDIJCGI">
                        <p class="titleinexample">示例12-2指定要内联重载的子程序</p>
                        <p>在此示例中，如果<code class="codeph">PLSQL_OPTIMIZE_LEVEL=2</code> ，则<code class="codeph">INLINE</code>编译指示会影响名为<code class="codeph">p2</code>两个函数。
                        </p><pre class="oac_no_warn" dir="ltr">功能p2（p boolean）返回PLS_INTEGER IS ...功能p2（x PLS_INTEGER）返回PLS_INTEGER IS ......
<span class="bold">PRAGMA INLINE（第2页，'是'）;</span> x：= p2（真）+ p2（3）;</pre><pre class="oac_no_warn" dir="ltr">...
</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-2E78813E-CF29-409D-9F8B-AA24B294BFA2__CHDGAGBH">
                        <p class="titleinexample">示例12-3指定不要内联子程序</p>
                        <p>在此示例中， <code class="codeph">INLINE</code>编译指示影响过程调用<code class="codeph">p1(1)</code>和<code class="codeph">p1(2)</code> ，但不影响过程调用<code class="codeph">p1(3)</code>和<code class="codeph">p1(4)</code> 。
                        </p><pre class="oac_no_warn" dir="ltr">程序p1（x PLS_INTEGER）是.........
<span class="bold">PRAGMA INLINE（p1，'NO'）;</span> x：= p1（1）+ p1（2）+17; - 这两次对p1的调用没有内联......x：= p1（3）+ p1（4）+17; - 这两个对p1的调用可能是内联的......
</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-2E78813E-CF29-409D-9F8B-AA24B294BFA2__CHDJCIEJ">
                        <p class="titleinexample">例12-4 PRAGMA INLINE ...'NO'覆盖PRAGMA INLINE ...'是'</p>
                        <p>在此示例中，第二个<code class="codeph">INLINE</code>编译指示将覆盖第一个和第三个<code class="codeph">INLINE</code>编译指示。
                        </p><pre class="oac_no_warn" dir="ltr">程序p1（x PLS_INTEGER）是.........
<span class="bold">PRAGMA INLINE（第1页，'是'）;</span> <span class="bold">PRAGMA INLINE（p1，'NO'）;</span> <span class="bold">PRAGMA INLINE（第1页，'是'）;</span> x：= p1（1）+ p1（2）+17; - 这两次对p1的调用没有内联......</pre></div>
                     <!-- class="example" -->
                  </div>
               </div>
            </div><a id="LNPLS01212"></a><div class="props_rev_3"><a id="GUID-1640FEEA-4237-4A0D-B445-621EF2A420C6" name="GUID-1640FEEA-4237-4A0D-B445-621EF2A420C6"></a><h3 id="LNPLS-GUID-1640FEEA-4237-4A0D-B445-621EF2A420C6" class="sect3"><span class="enumeration_section">12.2</span>调整的候选人</h3>
               <div>
                  <p>以下类型的PL / SQL代码很可能从调优中受益：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>较旧的代码，不利用新的PL / SQL语言功能。</p>
                        <div class="infobox-tip" id="GUID-1640FEEA-4237-4A0D-B445-621EF2A420C6__GUID-B2F9C5CB-9939-45A7-98FA-1FE1AB35CE05">
                           <p class="notep1">小费：</p>
                           <p>在调整旧代码之前，对当前系统进行基准测试并分析程序调用的旧子程序（请参阅<span class="q">“ <a href="plsql-optimization-and-tuning.html#GUID-D99A60B1-E3ED-4252-A85C-8FA732EE9957" title="为了帮助您隔离大型PL / SQL程序中的性能问题，PL / SQL提供了这些工具，实现为PL / SQL包。">分析和跟踪PL / SQL程序</a> ”</span> ）。通过PL / SQL优化器的许多自动优化（在<span class="q">“ <a href="plsql-optimization-and-tuning.html#GUID-8BC4231B-2E5C-47D6-BE14-6D75CE14C57E" title="编译器可以执行的一个优化是子程序内联。">PL / SQL优化器</a> ”中描述</span> ），您可能会在进行任何调整之前看到性能改进。
                           </p>
                        </div>
                     </li>
                     <li>
                        <p>使用<code class="codeph">DBMS_SQL</code>包编写的较旧的动态SQL语句。
                        </p>
                        <p>如果您在编译时知道动态SQL语句的输入和输出变量的数量和数据类型，那么您可以在本机动态SQL中重写该语句，该语句的运行速度明显快于使用<code class="codeph">DBMS_SQL</code>包的等效代码（特别是当它可以由编译器优化）。有关更多信息，请参阅<a href="dynamic-sql.html#GUID-7E2F596F-9CA3-4DC8-8333-0C117962DB73" title="动态SQL是一种在运行时生成和运行SQL语句的编程方法。">PL / SQL动态SQL</a> 。</p>
                     </li>
                     <li>
                        <p>花费大量时间处理SQL语句的代码。</p>
                        <p>请参阅<span class="q">“ <a href="plsql-optimization-and-tuning.html#GUID-B7F4934F-1CE2-4B86-B1A3-659B6D89F1D9">调整SQL语句</a> ”</span> 。
                        </p>
                     </li>
                     <li>
                        <p>在查询中调用的函数，可能会运行数百万次。</p>
                        <p>请参阅<span class="q">“ <a href="plsql-optimization-and-tuning.html#GUID-C54C68DB-2C26-4D25-983D-1581C0CFDEDB" title="在查询中调用的函数可能会运行数百万次。不要在不必要的情况下调用查询中的函数，并使调用尽可能高效。">查询中的调整函数调用</a> ”</span> 。
                        </p>
                     </li>
                     <li>
                        <p>花费大量时间循环查询结果的代码。</p>
                        <p>请参阅<span class="q">“ <a href="plsql-optimization-and-tuning.html#GUID-E95E2D71-F51D-4F09-B4BE-21093F760368">调整循环</a> ”</span> 。
                        </p>
                     </li>
                     <li>
                        <p>执行许多数值计算的代码。</p>
                        <p>请参阅<span class="q">“ <a href="plsql-optimization-and-tuning.html#GUID-72F6B95C-4D02-4363-AA2C-82F9DB1C84B9">调整计算 - 密集型PL / SQL代码</a> ”</span> 。
                        </p>
                     </li>
                     <li>
                        <p>花费大量时间处理PL / SQL语句的代码（与发布PL / SQL直接传递给SQL的数据库定义语言（DDL）语句相反）。</p>
                        <p>请参阅<span class="q">“ <a href="plsql-optimization-and-tuning.html#GUID-7C4557E7-4C35-4CAB-A95D-CB96BDC6D487">为本机执行编译PL / SQL单元</a> ”</span> 。
                        </p>
                     </li>
                  </ul>
               </div>
            </div><a id="LNPLS767"></a><a id="LNPLS863"></a><div class="props_rev_3"><a id="GUID-C2DC6043-17CC-4F9F-934D-A075133FBD01" name="GUID-C2DC6043-17CC-4F9F-934D-A075133FBD01"></a><h3 id="LNPLS-GUID-C2DC6043-17CC-4F9F-934D-A075133FBD01" class="sect3"><span class="enumeration_section">12.3</span>最小化CPU开销</h3>
               <div>
                  <div class="section">
                     <p class="subhead2" id="GUID-C2DC6043-17CC-4F9F-934D-A075133FBD01__GUID-8E3642EA-DC3D-41FC-8ED9-91554A57EE2D">话题</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="plsql-optimization-and-tuning.html#GUID-B7F4934F-1CE2-4B86-B1A3-659B6D89F1D9">调整SQL语句</a></p>
                        </li>
                        <li>
                           <p><a href="plsql-optimization-and-tuning.html#GUID-C54C68DB-2C26-4D25-983D-1581C0CFDEDB" title="在查询中调用的函数可能会运行数百万次。不要在不必要的情况下调用查询中的函数，并使调用尽可能高效。">在查询中调整函数调用</a></p>
                        </li>
                        <li>
                           <p><a href="plsql-optimization-and-tuning.html#GUID-2D616F80-2E1D-453A-B2A5-2B4E3288E33F" title="如果子程序具有OUT或IN OUT参数，则有时可以通过使用NOCOPY提示声明这些参数来减少其调用开销。">调整子程序调用</a></p>
                        </li>
                        <li>
                           <p><a href="plsql-optimization-and-tuning.html#GUID-E95E2D71-F51D-4F09-B4BE-21093F760368">调整循环</a></p>
                        </li>
                        <li>
                           <p><a href="plsql-optimization-and-tuning.html#GUID-72F6B95C-4D02-4363-AA2C-82F9DB1C84B9">调整计算密集型PL / SQL代码</a></p>
                        </li>
                        <li>
                           <p><a href="plsql-optimization-and-tuning.html#GUID-1DD8891A-DC28-4B06-8788-C65008A1682D">使用SQL字符函数</a></p>
                        </li>
                        <li>
                           <p><a href="plsql-optimization-and-tuning.html#GUID-84E8BD95-8E52-4168-85C7-816E653B41B3">首先进行至少昂贵的条件测试</a></p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
               </div><a id="LNPLS864"></a><div class="props_rev_3"><a id="GUID-B7F4934F-1CE2-4B86-B1A3-659B6D89F1D9" name="GUID-B7F4934F-1CE2-4B86-B1A3-659B6D89F1D9"></a><h4 id="LNPLS-GUID-B7F4934F-1CE2-4B86-B1A3-659B6D89F1D9" class="sect4"><span class="enumeration_section">12.3.1</span>调整SQL语句</h4>
                  <div>
                     <div class="section">
                        <p>PL / SQL程序缓慢的最常见原因是SQL语句缓慢。要使PL / SQL程序中的SQL语句尽可能高效：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p>使用适当的索引。</p>
                              <p>有关详细信息，请参阅<a href="../admin/managing-indexes.html#ADMIN-GUID-E4149397-FF37-4367-A12F-675433715904" target="_blank">Oracle数据库性能调整指南</a> 。
                              </p>
                           </li>
                           <li>
                              <p>使用查询提示可避免不必要的全表扫描。</p>
                              <p>有关详细信息，请参阅<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/lnpls&amp;id=SQLRF51107" target="_blank"><span class="italic">Oracle数据库SQL语言参考</span></a> 。
                              </p>
                           </li>
                           <li>
                              <p>使用<code class="codeph">DBMS_STATS</code>包中的子程序收集所有表的当前统计信息。
                              </p>
                              <p>有关详细信息，请参阅<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/lnpls&amp;id=TGSQL389" target="_blank"><span class="italic">Oracle数据库性能调整指南</span></a> 。
                              </p>
                           </li>
                           <li>
                              <p>使用以下方法分析SQL语句的执行计划和性能：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p><code class="codeph">EXPLAIN</code> <code class="codeph">PLAN</code>声明</p>
                                    <p>有关详细信息，请参阅<a href="../tgsql/generating-and-displaying-execution-plans.html#TGSQL271" target="_blank"><span class="italic">Oracle数据库性能调整指南</span></a> 。
                                    </p>
                                 </li>
                                 <li>
                                    <p>带有<code class="codeph">TKPROF</code>实用程序的SQL跟踪工具</p>
                                    <p>有关详细信息，请参阅<a href="../tgsql/performing-application-tracing.html#TGSQL809" target="_blank"><span class="italic">Oracle数据库性能调整指南</span></a> 。
                                    </p>
                                 </li>
                              </ul>
                           </li>
                           <li>
                              <p>使用批量SQL，这是一组PL / SQL功能，可最大限度地降低PL / SQL和SQL之间通信的性能开销。</p>
                              <p>有关详细信息，请参阅<span class="q">“ <a href="plsql-optimization-and-tuning.html#GUID-61D1B533-DBB9-4150-91F9-0A4C9428391E" title="批量SQL最大限度地减少了PL / SQL和SQL之间通信的性能开销。包含批量SQL的PL / SQL功能是FORALL语句和BULK COLLECT子句。为SQL语句中出现的PL / SQL变量赋值称为绑定。">批量SQL和批量绑定</a> ”</span> 。
                              </p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPLS866"></a><a id="LNPLS865"></a><div class="props_rev_3"><a id="GUID-C54C68DB-2C26-4D25-983D-1581C0CFDEDB" name="GUID-C54C68DB-2C26-4D25-983D-1581C0CFDEDB"></a><h4 id="LNPLS-GUID-C54C68DB-2C26-4D25-983D-1581C0CFDEDB" class="sect4"><span class="enumeration_section">12.3.2</span>查询中的调整函数调用</h4>
                  <div>
                     <p>在查询中调用的函数可能会运行数百万次。不要在不必要的情况下调用查询中的函数，并使调用尽可能高效。</p>
                     <div class="section">
                        <p>在查询中的表上创建基于函数的索引。<code class="codeph">CREATE</code> <code class="codeph">INDEX</code>语句可能需要一段时间，但查询可以更快地运行，因为每行的函数值都被缓存。
                        </p>
                        <p>如果查询将列传递给函数，则查询不能在该列上使用用户创建的索引，因此查询可能会为表的每一行（可能非常大）调用该函数。要最小化函数调用的数量，请使用嵌套查询。让内部查询将结果集过滤为少量行，并让外部查询仅为那些行调用该函数。</p>
                        <div class="infoboxnotealso" id="GUID-C54C68DB-2C26-4D25-983D-1581C0CFDEDB__GUID-7F783E3E-1358-47F4-9DE9-5AB73A2BD4E4">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>有关<code class="codeph">CREATE</code> <code class="codeph">INDEX</code>语句语法的详细信息，请<a href="../sqlrf/CREATE-INDEX.html#SQLRF01209" target="_blank"><span class="italic">参见Oracle数据库SQL语言参考</span></a></p>
                              </li>
                              <li>
                                 <p><span class="q">“ <a href="plsql-subprograms.html#GUID-250BDBBB-0CD6-4D56-9DDF-6FCEDC110D00" title="When a PL/SQL function has the RESULT_CACHE option, its results are cached in the shared global area (SGA) so sessions connected to the same instance can reuse these results when available.">PL / SQL函数结果缓存</a> ”，</span>用于缓存有关缓存<span class="q"><a href="plsql-subprograms.html#GUID-250BDBBB-0CD6-4D56-9DDF-6FCEDC110D00" title="当PL / SQL函数具有RESULT_CACHE选项时，其结果将缓存在共享全局区域（SGA）中，因此连接到同一实例的会话可以在可用时重用这些结果。">PL / SQL函数结果</a></span>的信息</p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-C54C68DB-2C26-4D25-983D-1581C0CFDEDB__BABFCFDB">
                        <p class="titleinexample">示例12-5嵌套查询可提高性能</p>
                        <p>在此示例中，两个查询生成相同的结果集，但第二个查询比第一个查询更有效。（在示例中，时间和时间差异非常小，因为<code class="codeph">EMPLOYEES</code>表非常小。对于一张非常大的桌子，它们会非常重要。）
                        </p><pre class="oac_no_warn" dir="ltr">DECLARE starting_time TIMESTAMP WITH TIME ZONE; ending_time TIMESTAMP WITH TIME ZONE; BEGIN <span class="bold">- 为employees表的每一行调用SQRT：</span> SELECT SYSTIMESTAMP INTO starting_time FROM DUAL; FOR item IN（SELECT <span class="bold">DISTINCT（SQRT（department_id））</span> col_alias FROM employees ORDER BY col_alias）LOOP DBMS_OUTPUT.PUT_LINE（'dept的平方根。ID ='|| item.col_alias）;结束循环; SELECT SYSTIMESTAMP INTO ending_time FROM DUAL; DBMS_OUTPUT.PUT_LINE（'Time ='|| TO_CHAR（ending_time  -  starting_time））; <span class="bold">- 为employees表的每个不同department_id调用SQRT：</span> SELECT SYSTIMESTAMP INTO starting_time FROM DUAL; FOR项目IN（SELECT <span class="bold">SQRT（department_id）</span> col_alias FROM <span class="bold">（SELECT DISTINCT department_id FROM employees）</span> ORDER BY col_alias）LOOP IF item.col_alias IS NOT NULL，然后是DBMS_OUTPUT.PUT_LINE（'dept的平方根）。ID ='|| item.col_alias）;万一;结束循环; SELECT SYSTIMESTAMP INTO ending_time FROM DUAL; DBMS_OUTPUT.PUT_LINE（'Time ='|| TO_CHAR（ending_time  -  starting_time））;结束; /</pre><p>结果类似于：</p><pre class="oac_no_warn" dir="ltr">部门的平方根。ID = 3.16227766016837933199889354443271853372部门的平方根。ID = 4.47213595499957939281834733746255247088部门的平方根。ID = 5.47722557505166113456969782800802133953部门的平方根。ID = 6.32455532033675866399778708886543706744部门的平方根。ID = 7.07106781186547524400844362104849039285部门的平方根。ID = 7.74596669241483377035853079956479922167部门的平方根。ID = 8.36660026534075547978172025785187489393部门的平方根。ID = 8.94427190999915878563669467492510494176部门的平方根。ID = 9.48683298050513799599668063329815560116部门的平方根。ID = 10平方根。ID = 10.48808848170151546991453513679937598475 <span class="bold">时间= +000000000 00：00：00.046000000</span>部门的平方根。ID = 3.16227766016837933199889354443271853372部门的平方根。ID = 4.47213595499957939281834733746255247088部门的平方根。ID = 5.47722557505166113456969782800802133953部门的平方根。ID = 6.32455532033675866399778708886543706744部门的平方根。ID = 7.07106781186547524400844362104849039285部门的平方根。ID = 7.74596669241483377035853079956479922167部门的平方根。ID = 8.36660026534075547978172025785187489393部门的平方根。ID = 8.94427190999915878563669467492510494176部门的平方根。ID = 9.48683298050513799599668063329815560116部门的平方根。ID = 10平方根。ID = 10.48808848170151546991453513679937598475 <span class="bold">时间= +000000000 00：00：00.000000000</span></pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="LNPLS908"></a><a id="LNPLS01208"></a><div class="props_rev_3"><a id="GUID-2D616F80-2E1D-453A-B2A5-2B4E3288E33F" name="GUID-2D616F80-2E1D-453A-B2A5-2B4E3288E33F"></a><h4 id="LNPLS-GUID-2D616F80-2E1D-453A-B2A5-2B4E3288E33F" class="sect4"><span class="enumeration_section">12.3.3</span>调整子程序调用</h4>
                  <div>
                     <p>如果子程序具有<code class="codeph">OUT</code>或<code class="codeph">IN</code> <code class="codeph">OUT</code>参数，则有时可以通过使用<code class="codeph">NOCOPY</code>提示声明这些参数来减少其调用开销。
                     </p>
                     <div class="section">
                        <p>当<code class="codeph">OUT</code>或<code class="codeph">IN</code> <code class="codeph">OUT</code>参数表示大型数据结构（如集合，记录和ADT实例）时，复制它们会降低执行速度并增加内存使用量 - 尤其是对于ADT实例。</p>
                        <p>对于ADT方法的每次调用，PL / SQL都会复制ADT的每个属性。如果方法正常退出，则PL / SQL将应用该方法对属性所做的任何更改。如果退出方法时出现未处理的异常，则PL / SQL不会更改属性。</p>
                        <p>如果子程序以未处理的异常结束，程序不要求<code class="codeph">OUT</code>或<code class="codeph">IN</code> <code class="codeph">OUT</code>参数保留其预调用值，则在参数声明中包含<code class="codeph">NOCOPY</code>提示。<code class="codeph">NOCOPY</code>提示请求（但不确保）编译器通过引用而不是值传递相应的实际参数。
                        </p>
                        <div class="infoboxnote" id="GUID-2D616F80-2E1D-453A-B2A5-2B4E3288E33F__GUID-6AF3E7BE-B6DE-4C92-A502-E66B839867CB">
                           <p class="notep1">警告：</p>
                           <p>不依赖于<code class="codeph">NOCOPY</code> （编译器可能会或可能不会遵循特定的调用）来确保实际参数或ADT属性在子程序退出时出现未处理的异常时保留其预调用值。相反，请确保子程序处理所有异常。
                           </p>
                        </div>
                        <div class="infoboxnotealso" id="GUID-2D616F80-2E1D-453A-B2A5-2B4E3288E33F__GUID-68D36380-21A2-49D1-A12C-015C41258F4A">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>有关<code class="codeph">NOCOPY</code>提示的更多信息，请<code class="codeph">NOCOPY</code> <span class="q">“ <a href="formal-parameter-declaration.html#GUID-5BA8E033-96B9-439A-A4FC-4844FEC14AD8__CJACJCGJ">NOCOPY</a> ”</span></p>
                              </li>
                              <li>
                                 <p><a href="../adobj/design-considerations-for-methods.html#ADOBJ00853" target="_blank"><span class="italic">Oracle数据库对象关系开发人员指南</span></a> ，了解有关将<code class="codeph">NOCOPY</code>与ADT成员方法一起使用的信息</p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-2D616F80-2E1D-453A-B2A5-2B4E3288E33F__BABDDAFG">
                        <p class="titleinexample">例12-6 NOCOPY子程序参数</p>
                        <p>在此示例中，如果编译器遵循调用<code class="codeph">do_nothing2</code>的<code class="codeph">NOCOPY</code>提示，则<code class="codeph">do_nothing2</code>的调用比调用<code class="codeph">do_nothing1</code>更快。
                        </p><pre class="oac_no_warn" dir="ltr">DECLARE TYPE EmpTabTyp IS员工表％ROWTYPE; emp_tab EmpTabTyp：= EmpTabTyp（NULL）; - 初始化t1 NUMBER; t2 NUMBER; t3号码;程序get_time（t OUT NUMBER）是开始时t：= DBMS_UTILITY.get_time;结束; <span class="bold">PROCEDURE do_nothing1（tab IN OUT EmpTabTyp）</span>是BEGIN NULL;结束; <span class="bold">程序do_nothing2（标签IN OUT NOCOPY EmpTabTyp）</span>是BEGIN NULL;结束; BEGIN SELECT * INTO emp_tab（1）FROM employees WHERE employee_id = 100; emp_tab。EXTEND（49999,1）; - 将元素1复制到2..50000 get_time（t1）; do_nothing1（emp_tab）; - 传入IN OUT参数get_time（t2）; do_nothing2（emp_tab）; - 传入IN OUT NOCOPY参数get_time（t3）; DBMS_OUTPUT.PUT_LINE（'呼叫持续时间（秒）'）; DBMS_OUTPUT.PUT_LINE（'--------------------'）; DBMS_OUTPUT.PUT_LINE（'Just IN OUT：'|| TO_CHAR（（t2-t1）/100.0））; DBMS_OUTPUT.PUT_LINE（'与NOCOPY：'|| TO_CHAR（（t3-t2））/ 100.0）;结束; /</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="LNPLS867"></a><div class="props_rev_3"><a id="GUID-E95E2D71-F51D-4F09-B4BE-21093F760368" name="GUID-E95E2D71-F51D-4F09-B4BE-21093F760368"></a><h4 id="LNPLS-GUID-E95E2D71-F51D-4F09-B4BE-21093F760368" class="sect4"><span class="enumeration_section">12.3.4</span>调整循环</h4>
                  <div>
                     <div class="section">
                        <p>由于PL / SQL应用程序通常是围绕循环构建的，因此优化循环本身及其中的代码非常重要。</p>
                        <p>如果必须多次遍历结果集，或者在循环结果集时发出其他查询，则可以更改原始查询以准确提供所需的结果。探索可以组合多个查询的SQL集合运算符，如<a href="../sqlrf/The-UNION-ALL-INTERSECT-MINUS-Operators.html#SQLRF52341" target="_blank"><span class="italic">Oracle数据库SQL语言参考中所述</span></a> 。
                        </p>
                        <p>您还可以使用子查询在多个阶段中进行过滤和排序 - 请参阅<span class="q">“ <a href="static-sql.html#GUID-8DD487B1-1CC5-4F26-98F2-97753A7EEF70" title="如果通过循环遍历查询结果集并为每行运行另一个查询来处理查询结果集，则可以通过从循环内部删除第二个查询并使其成为第一个查询的子查询来提高性能。">使用子查询处理查询结果集</a> ”</span> 。
                        </p>
                        <div class="infoboxnotealso" id="GUID-E95E2D71-F51D-4F09-B4BE-21093F760368__GUID-5DFD80F5-D3B5-4405-867D-CA0FC4A058CF">
                           <p class="notep1">也可以看看：</p>
                           <p><span class="q">“ <a href="plsql-optimization-and-tuning.html#GUID-61D1B533-DBB9-4150-91F9-0A4C9428391E" title="批量SQL最大限度地减少了PL / SQL和SQL之间通信的性能开销。包含批量SQL的PL / SQL功能是FORALL语句和BULK COLLECT子句。为SQL语句中出现的PL / SQL变量赋值称为绑定。">批量SQL和批量绑定</a> ”</span></p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPLS768"></a><a id="LNPLS01206"></a><div class="props_rev_3"><a id="GUID-72F6B95C-4D02-4363-AA2C-82F9DB1C84B9" name="GUID-72F6B95C-4D02-4363-AA2C-82F9DB1C84B9"></a><h4 id="LNPLS-GUID-72F6B95C-4D02-4363-AA2C-82F9DB1C84B9" class="sect4"><span class="enumeration_section">12.3.5</span>调整计算 - 密集型PL / SQL代码</h4>
                  <div>
                     <div class="section">
                        <p>这些建议特别适用于（但不仅限于）计算密集型PL / SQL代码。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-72F6B95C-4D02-4363-AA2C-82F9DB1C84B9__GUID-74A4B6A3-A26B-4B05-8DE9-4090665942C0">话题</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="plsql-optimization-and-tuning.html#GUID-CB9BF149-8E00-45F1-99E8-AC42795CF6D0">使用使用硬件算术的数据类型</a></p>
                           </li>
                           <li>
                              <p><a href="plsql-optimization-and-tuning.html#GUID-216633A5-8719-48B2-B95D-78DBF3DF0D4B">在性能关键代码中避免使用约束子类型</a></p>
                           </li>
                           <li>
                              <p><a href="plsql-optimization-and-tuning.html#GUID-F7BAB3B2-3492-4246-A7D0-83AE9F015D85">最小化隐式数据类型转换</a></p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div><a id="LNPLS99859"></a><div class="sect4"><a id="GUID-CB9BF149-8E00-45F1-99E8-AC42795CF6D0" name="GUID-CB9BF149-8E00-45F1-99E8-AC42795CF6D0"></a><h5 id="LNPLS-GUID-CB9BF149-8E00-45F1-99E8-AC42795CF6D0" class="sect5"><span class="enumeration_section">12.3.5.1</span>使用使用硬件算术的数据类型</h5>
                     <div>
                        <p>避免在<code class="codeph">NUMBER</code>数据类型系列中使用数据类型（在<span class="q">“ <a href="plsql-predefined-data-types.html#GUID-1D28B7B6-15AE-454A-8134-F8724551AE8B__CDFJEBIF">NUMBER数据类型系列</a> ”中描述</span> ）。这些数据类型在内部表示为为便携性和任意比例和精度而设计的格式，而不是性能。对这些类型的数据的操作使用库算术，而对<code class="codeph">PLS_INTEGER</code> ， <code class="codeph">BINARY_FLOAT</code>和<code class="codeph">BINARY_DOUBLE</code> <code class="codeph">BINARY_FLOAT</code> <code class="codeph">BINARY_DOUBLE</code>使用硬件算法。
                        </p>
                        <p>对于本地整数变量，使用<code class="codeph">PLS_INTEGER</code> ，在<span class="q">“</span>描述<span class="q"><a href="plsql-data-types.html#GUID-9517B7AC-9CEA-4C36-A454-52588BEEBE8F" title="PL / SQL数据类型PLS_INTEGER和BINARY_INTEGER是相同的。">PLS_INTEGER和BINARY_INTEGER数据类型</a> ”。</span>对于性能关键代码中使用的变量，它永远不会为<code class="codeph">NULL</code> ，并且不需要溢出检查，请使用<code class="codeph">SIMPLE_INTEGER</code> ，如<span class="q">“ <a href="plsql-data-types.html#GUID-84C413B0-BDCA-4ABC-B402-3B8CED013DAF" title="SIMPLE_INTEGER是PLS_INTEGER数据类型的预定义子类型。">PLP_INTEGER的SIMPLE_INTEGER子类型</a> ”中所述</span> 。
                        </p>
                        <p>对于浮点变量，请使用<a href="../sqlrf/Data-Types.html#SQLRF00209" target="_blank"><span class="italic">Oracle数据库SQL语言参考中</span></a>描述的<code class="codeph">BINARY_FLOAT</code>或<code class="codeph">BINARY_DOUBLE</code> 。对于性能关键代码中使用的变量，它永远不会具有<code class="codeph">NULL</code> ，并且不需要溢出检查，请使用<code class="codeph">SIMPLE_FLOAT</code>或<code class="codeph">SIMPLE_DOUBLE</code> ，在<span class="q">“ <a href="plsql-data-types.html#GUID-48101DAA-B168-4648-A05A-CA81A9512E8C">BINARY_FLOAT和BINARY_DOUBLE的附加PL / SQL子类型</a> ”中进行了解释</span> 。
                        </p>
                        <div class="infoboxnote" id="GUID-CB9BF149-8E00-45F1-99E8-AC42795CF6D0__GUID-8020B380-E847-4131-AB7B-B07A830F93F1">
                           <p class="notep1">注意：</p>
                           <p><code class="codeph">BINARY_FLOAT</code>和<code class="codeph">BINARY_DOUBLE</code>及其子类型不太适合精度至关重要的财务代码，因为它们并不总是精确地表示小数值，并且处理舍入方式与<code class="codeph">NUMBER</code>类型不同。
                           </p>
                        </div>
                        <p>许多SQL数字函数（在<a href="../sqlrf/Single-Row-Functions.html#SQLRF20031" target="_blank"><span class="italic">Oracle数据库SQL语言参考中</span></a>描述）重载了接受<code class="codeph">BINARY_FLOAT</code>和<code class="codeph">BINARY_DOUBLE</code>参数的版本。可以加快通过使这些数据类型到这样的功能的变量计算密集型代码，并通过调用转换函数<code class="codeph">TO_BINARY_FLOAT</code> （描述在<a href="../sqlrf/TO_BINARY_FLOAT.html#SQLRF06310" target="_blank"><span class="italic">Oracle数据库SQL语言参考</span></a>和） <code class="codeph">TO_BINARY_DOUBLE</code> （描述<a href="../sqlrf/TO_BINARY_DOUBLE.html#SQLRF06309" target="_blank"><span class="italic">Oracle数据库的SQL语言参考</span></a>传递表达式时）这样的功能。
                        </p>
                     </div>
                  </div><a id="LNPLS99858"></a><div class="props_rev_3"><a id="GUID-216633A5-8719-48B2-B95D-78DBF3DF0D4B" name="GUID-216633A5-8719-48B2-B95D-78DBF3DF0D4B"></a><h5 id="LNPLS-GUID-216633A5-8719-48B2-B95D-78DBF3DF0D4B" class="sect5"><span class="enumeration_section">12.3.5.2</span>在性能关键代码中避免约束子类型</h5>
                     <div>
                        <div class="section">
                           <p>在性能关键代码中，避免使用受约束的子类型（在<span class="q">“ <a href="plsql-data-types.html#GUID-FDC366F3-66AA-4F6A-A59B-5A08DCBD4F9F" title="受约束的子类型仅具有其基本类型的值的子集。">约束子类型</a> ”中</span>描述）。对受约束子类型的变量或参数的每个赋值都需要在运行时进行额外检查，以确保要分配的值不违反约束。
                           </p>
                           <div class="infoboxnotealso" id="GUID-216633A5-8719-48B2-B95D-78DBF3DF0D4B__GUID-DD034082-05DD-4630-8509-90D01B53A59F">
                              <p class="notep1">也可以看看：</p>
                              <p><a href="plsql-predefined-data-types.html#GUID-1D28B7B6-15AE-454A-8134-F8724551AE8B">PL / SQL预定义数据类型</a>包括预定义的约束子类型</p>
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNPLS870"></a><div class="props_rev_3"><a id="GUID-F7BAB3B2-3492-4246-A7D0-83AE9F015D85" name="GUID-F7BAB3B2-3492-4246-A7D0-83AE9F015D85"></a><h5 id="LNPLS-GUID-F7BAB3B2-3492-4246-A7D0-83AE9F015D85" class="sect5"><span class="enumeration_section">12.3.5.3</span>最小化隐式数据类型转换</h5>
                     <div>
                        <div class="section">
                           <p>在运行时，PL / SQL在必要时隐式（自动）在不同数据类型之间进行转换。例如，如果将<code class="codeph">PLS_INTEGER</code>变量分配给<code class="codeph">NUMBER</code>变量，则PL / SQL会将<code class="codeph">PLS_INTEGER</code>值转换为<code class="codeph">NUMBER</code>值（因为值的内部表示不同）。
                           </p>
                           <p>尽可能减少隐式转换。例如：</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>如果要将变量插入表列或从表列分配值，则为变量提供与表列相同的数据类型。</p>
                                 <div class="infobox-tip" id="GUID-F7BAB3B2-3492-4246-A7D0-83AE9F015D85__GUID-59A6F2A9-6943-4DEB-90E1-021C95553BCF">
                                    <p class="notep1">小费：</p>
                                    <p>使用<code class="codeph">%TYPE</code>属性声明变量，在<span class="q">“ <a href="TYPE-attribute.html#GUID-EAB44F7E-B2AB-4AC6-B83D-B586193D75FC" title="％TYPE属性允许您将常量，变量，集合元素，记录字段或子程序参数声明为与先前声明的变量或列具有相同的数据类型（不知道该类型是什么）。">％TYPE Attribute</a> ”中</span>描述。
                                    </p>
                                 </div>
                              </li>
                              <li>
                                 <p>使每个文字与分配给它的变量或它出现的表达式具有相同的数据类型。</p>
                              </li>
                              <li>
                                 <p>将值从SQL数据类型转换为PL / SQL数据类型，然后在表达式中使用转换后的值。</p>
                                 <p>例如，将<code class="codeph">NUMBER</code>值转换为<code class="codeph">PLS_INTEGER</code>值，然后在表达式中使用<code class="codeph">PLS_INTEGER</code>值。<code class="codeph">PLS_INTEGER</code>操作使用硬件算法，因此它们比使用库算术的<code class="codeph">NUMBER</code>操作更快。有关<code class="codeph">PLS_INTEGER</code>数据类型的更多信息，请参阅<span class="q">“ <a href="plsql-data-types.html#GUID-9517B7AC-9CEA-4C36-A454-52588BEEBE8F" title="PL / SQL数据类型PLS_INTEGER和BINARY_INTEGER是相同的。">PLS_INTEGER和BINARY_INTEGER数据类型</a> ”</span> 。
                                 </p>
                              </li>
                              <li>
                                 <p>在将一个SQL数据类型的值分配给另一个SQL数据类型的变量之前，使用SQL转换函数显式地将源值转换为目标数据类型（有关SQL转换函数的信息，请参阅<a href="../sqlrf/Single-Row-Functions.html#SQLRF20034" target="_blank"><span class="italic">Oracle数据库SQL语言参考</span></a> ）。
                                 </p>
                              </li>
                              <li>
                                 <p>使用接受不同数据类型参数的版本重载子程序，并针对其参数类型优化每个版本。有关重载子程序的信息，请参阅<span class="q">“ <a href="plsql-subprograms.html#GUID-47D5A50E-7AAF-4C80-A06A-37593EA2526A">重载子程序</a> ”</span> 。
                                 </p>
                              </li>
                           </ul>
                           <div class="infoboxnotealso" id="GUID-F7BAB3B2-3492-4246-A7D0-83AE9F015D85__GUID-BB2C2512-1A0B-4685-8C6B-746F80495B97">
                              <p class="notep1">也可以看看：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>有关SQL数据类型（也是PL / SQL数据类型）的隐式转换的信息，请<a href="../sqlrf/Data-Type-Comparison-Rules.html#SQLRF51047" target="_blank"><span class="italic">参见Oracle数据库SQL语言参考</span></a></p>
                                 </li>
                                 <li>
                                    <p><span class="q">“ <a href="plsql-data-types.html#GUID-126CB7F3-7E65-40BC-B6CD-2244B63240A7" title="如果两个子类型在同一数据类型族中具有不同的基类型，则只有在源值不违反目标子类型的约束时，才能将一个子类型隐式转换为另一个子类型。">具有相同数据类型族的基类型的子类型</a> ”</span></p>
                                 </li>
                              </ul>
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="LNPLS868"></a><div class="props_rev_3"><a id="GUID-1DD8891A-DC28-4B06-8788-C65008A1682D" name="GUID-1DD8891A-DC28-4B06-8788-C65008A1682D"></a><h4 id="LNPLS-GUID-1DD8891A-DC28-4B06-8788-C65008A1682D" class="sect4"><span class="enumeration_section">12.3.6</span>使用SQL字符函数</h4>
                  <div>
                     <div class="section">
                        <p>SQL有许多高度优化的字符函数，它们使用比PL / SQL代码更高效的低级代码。使用这些函数而不是编写PL / SQL代码来执行相同的操作。</p>
                        <div class="infoboxnote" id="GUID-1DD8891A-DC28-4B06-8788-C65008A1682D__GUID-442DE351-A1CA-454B-8C14-4ADE0CDAE862">
                           <p class="notep1">看到：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>有关返回字符值的SQL字符函数的信息，请<a href="../sqlrf/Single-Row-Functions.html#SQLRF20032" target="_blank"><span class="italic">参见“Oracle数据库SQL语言参考</span></a> ”</p>
                              </li>
                              <li>
                                 <p>有关返回NLS字符值的SQL字符函数的信息，请<a href="../sqlrf/Single-Row-Functions.html#SQLRF51179" target="_blank"><span class="italic">参见“Oracle数据库SQL语言参考</span></a> ”</p>
                              </li>
                              <li>
                                 <p>有关返回数字值的SQL字符函数的信息，请<a href="../sqlrf/Single-Row-Functions.html#SQLRF51180" target="_blank"><span class="italic">参见Oracle数据库SQL语言参考</span></a></p>
                              </li>
                              <li>
                                 <p><a href="static-sql.html#GUID-9DEED64C-A87E-4EAD-97DA-ABDD3FDF172C__BABCFDJE">例6-6</a>给出了使用SQL字符函数<code class="codeph">REGEXP_LIKE</code>的PL / SQL代码<code class="codeph">REGEXP_LIKE</code></p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPLS869"></a><div class="props_rev_3"><a id="GUID-84E8BD95-8E52-4168-85C7-816E653B41B3" name="GUID-84E8BD95-8E52-4168-85C7-816E653B41B3"></a><h4 id="LNPLS-GUID-84E8BD95-8E52-4168-85C7-816E653B41B3" class="sect4"><span class="enumeration_section">12.3.7</span>首先进行最低成本的条件测试</h4>
                  <div>
                     <div class="section">
                        <p>PL / SQL一旦确定结果就停止评估逻辑表达式。利用这种短路评估，尽可能在逻辑表达式中首先评估最便宜的条件。例如，在测试函数返回值之前测试PL / SQL变量的值，这样如果变量测试失败，PL / SQL就不需要调用函数：</p><pre class="oac_no_warn" dir="ltr">IF <span class="italic">boolean_variable</span> OR（ <span class="italic">number</span> &gt; 10）或<span class="italic">boolean_function</span> （ <span class="italic">参数</span> ）那么......</pre><div class="infoboxnotealso" id="GUID-84E8BD95-8E52-4168-85C7-816E653B41B3__GUID-0738870E-0C76-4165-B697-04EB59B79008">
                           <p class="notep1">也可以看看：</p>
                           <p><span class="q">“ <a href="plsql-language-fundamentals.html#GUID-26565CE3-726A-4E29-8A24-1F6AD8EC780B" title="在评估逻辑表达式时，PL / SQL使用短路评估。也就是说，PL / SQL一旦确定结果就会停止评估表达式。">短路评估</a> ”</span></p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="LNPLS791"></a><a id="LNPLS01205"></a><div class="props_rev_3"><a id="GUID-61D1B533-DBB9-4150-91F9-0A4C9428391E" name="GUID-61D1B533-DBB9-4150-91F9-0A4C9428391E"></a><h3 id="LNPLS-GUID-61D1B533-DBB9-4150-91F9-0A4C9428391E" class="sect3"><span class="enumeration_section">12.4</span>批量SQL和批量绑定</h3>
               <div>
                  <p><span class="bold">批量SQL</span>最大限度地减少了PL / SQL和SQL之间通信的性能开销。包含批量SQL的PL / SQL功能是<code class="codeph">FORALL</code>语句和<code class="codeph">BULK</code> <code class="codeph">COLLECT</code>子句。为SQL语句中出现的PL / SQL变量赋值称为<span class="bold">绑定</span> 。
                  </p>
                  <p>PL / SQL和SQL通信如下：要运行<code class="codeph">SELECT</code> <code class="codeph">INTO</code>或DML语句，PL / SQL引擎将查询或DML语句发送到SQL引擎。SQL引擎运行查询或DML语句并将结果返回给PL / SQL引擎。
                  </p>
                  <p><code class="codeph">FORALL</code>语句将PL / SQL中的DML语句批量发送到SQL，而不是一次发送一个。<code class="codeph">BULK</code> <code class="codeph">COLLECT</code>子句将结果从SQL返回到PL / SQL，而不是一次返回一个。如果查询或DML语句影响四个或更多数据库行，则批量SQL可以显着提高性能。
                  </p>
                  <div class="infoboxnote" id="GUID-61D1B533-DBB9-4150-91F9-0A4C9428391E__GUID-32867868-3D37-429A-A90D-4E2E002C7C34">
                     <p class="notep1">注意：</p>
                     <p>您无法在远程表上执行批量SQL。</p>
                  </div>
                  <p>PL / SQL绑定操作属于以下类别：</p>
                  <div class="tblformal" id="GUID-61D1B533-DBB9-4150-91F9-0A4C9428391E__GUID-CE1025C0-7705-40DC-9085-EFBC7E941016">
                     <table cellpadding="4" cellspacing="0" class="Formal" title="" width="100%" border="1" summary="This table summarizes the categories of PL/SQL binding operations." frame="hsides" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="22%" id="d89034e2693">绑定类别</th>
                              <th align="left" valign="bottom" width="78%" id="d89034e2696">何时发生此绑定</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="22%" id="d89034e2701" headers="d89034e2693 ">
                                 <p>在绑定</p>
                              </td>
                              <td align="left" valign="top" width="78%" headers="d89034e2701 d89034e2696 ">
                                 <p><code class="codeph">INSERT</code> ， <code class="codeph">UPDATE</code>或<code class="codeph">MERGE</code>语句在数据库中存储PL / SQL或主机变量时</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="22%" id="d89034e2717" headers="d89034e2693 ">
                                 <p>出绑定</p>
                              </td>
                              <td align="left" valign="top" width="78%" headers="d89034e2717 d89034e2696 ">
                                 <p><code class="codeph">INSERT</code> ， <code class="codeph">UPDATE</code>或<code class="codeph">DELETE</code>语句的<code class="codeph">RETURNING</code> <code class="codeph">INTO</code>子句将数据库值分配给PL / SQL或主变量时</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="22%" id="d89034e2739" headers="d89034e2693 ">
                                 <p><code class="codeph">限定</code></p>
                              </td>
                              <td align="left" valign="top" width="78%" headers="d89034e2739 d89034e2696 ">
                                 <p>当<code class="codeph">SELECT</code>或<code class="codeph">FETCH</code>语句将数据库值分配给PL / SQL或主机变量时</p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
                  <p>对于in-binds和out-binds，批量SQL使用<span class="bold">批量绑定</span> ;也就是说，它会立即绑定整个值集合。对于<span class="italic">n个</span>元素的集合，批量SQL使用单个操作来执行<span class="italic">n</span> <code class="codeph">SELECT</code> <code class="codeph">INTO</code>或DML语句的等效操作。使用批量SQL的查询可以返回任意数量的行，而不为每个行使用<code class="codeph">FETCH</code>语句。
                  </p>
                  <div class="infoboxnote" id="GUID-61D1B533-DBB9-4150-91F9-0A4C9428391E__GUID-BEBFDA2B-4EFF-4470-837D-DF24B72517BC">
                     <p class="notep1">注意：</p>
                     <p>使用批量SQL禁用并行DML。</p>
                  </div>
                  <div class="section">
                     <p class="subhead2" id="GUID-61D1B533-DBB9-4150-91F9-0A4C9428391E__GUID-07706C23-15FC-424A-8786-92B4E51925B0">话题</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="plsql-optimization-and-tuning.html#GUID-6D4A1425-64DD-4723-8AAE-87B0A51A2854" title="FORALL语句是批量SQL的一个特性，它将批处理中的DML语句从PL / SQL发送到SQL，而不是一次发送一个。">FORALL声明</a></p>
                        </li>
                        <li>
                           <p><a href="plsql-optimization-and-tuning.html#GUID-19F50644-C88E-49AF-B31C-3EE4B4432714" title="BULK COLLECT子句是批量SQL的一个特性，它将结果从SQL返回到PL / SQL，而不是一次返回一个。">BULK COLLECT条款</a></p>
                        </li>
                        <li>
                           <p><a href="plsql-optimization-and-tuning.html#GUID-D67D19A6-4717-4556-B027-15C3DED0519A" title="在FORALL语句中，DML语句可以具有RETURNING BULK COLLECT INTO子句。对于FORALL语句的每次迭代，DML语句将指定的值存储在指定的集合中，而不会覆盖先前的值，因为相同的DML语句将在FOR LOOP语句中执行。">一起使用FORALL语句和BULK COLLECT子句</a></p>
                        </li>
                        <li>
                           <p><a href="plsql-optimization-and-tuning.html#GUID-14F071C6-C0AE-4D39-803F-420840FD34AB" title="客户端程序（例如OCI和Pro * C程序）可以使用PL / SQL匿名块来批量绑定输入和输出主机阵列。这是将集合传入和传出数据库服务器的最有效方法。">客户端批量绑定主机阵列</a></p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
               </div><a id="LNPLS799"></a><a id="LNPLS792"></a><a id="LNPLS793"></a><a id="LNPLS881"></a><a id="LNPLS882"></a><a id="LNPLS879"></a><div class="props_rev_3"><a id="GUID-6D4A1425-64DD-4723-8AAE-87B0A51A2854" name="GUID-6D4A1425-64DD-4723-8AAE-87B0A51A2854"></a><h4 id="LNPLS-GUID-6D4A1425-64DD-4723-8AAE-87B0A51A2854" class="sect4"><span class="enumeration_section">12.4.1</span> FORALL声明</h4>
                  <div>
                     <p><code class="codeph">FORALL</code>语句是批量SQL的一个特性， <code class="codeph">FORALL</code>批处理中的DML语句从PL / SQL发送到SQL，而不是一次发送一个。
                     </p>
                     <p>要理解<code class="codeph">FORALL</code>语句，首先要考虑<a href="plsql-optimization-and-tuning.html#GUID-6D4A1425-64DD-4723-8AAE-87B0A51A2854__BABBCECH">例12-7中</a>的<code class="codeph">FOR</code> <code class="codeph">LOOP</code>语句。它一次将这些DML语句从PL / SQL发送到SQL：</p><pre class="oac_no_warn" dir="ltr">DELETE FROM employees_temp WHERE department_id = depts（10）; DELETE FROM employees_temp WHERE department_id = depts（30）; DELETE FROM employees_temp WHERE department_id = depts（70）;</pre><p>现在考虑<a href="plsql-optimization-and-tuning.html#GUID-6D4A1425-64DD-4723-8AAE-87B0A51A2854__BABDBAAJ">例12-8中</a>的<code class="codeph">FORALL</code>语句。它将PL / SQL中相同的三个DML语句作为批处理发送到SQL。
                     </p>
                     <p><code class="codeph">FORALL</code>语句通常比等效的<code class="codeph">FOR</code> <code class="codeph">LOOP</code>语句快得多。但是， <code class="codeph">FOR</code> <code class="codeph">LOOP</code>语句可以包含多个DML语句，而<code class="codeph">FORALL</code>语句只能包含一个。<code class="codeph">FORALL</code>语句发送给SQL的一批DML语句仅在其<code class="codeph">VALUES</code>和<code class="codeph">WHERE</code>子句中有所不同。这些子句中的值必须来自现有的，已填充的集合。
                     </p>
                     <div class="infoboxnote" id="GUID-6D4A1425-64DD-4723-8AAE-87B0A51A2854__GUID-35DC51EA-1809-4D27-A740-40D5973A8E1D">
                        <p class="notep1">注意：</p>
                        <p><code class="codeph">FORALL</code>语句中的DML语句可以引用多个集合，但性能优势仅适用于使用<code class="codeph">FORALL</code>索引变量作为索引的集合引用。
                        </p>
                     </div>
                     <p><a href="plsql-optimization-and-tuning.html#GUID-6D4A1425-64DD-4723-8AAE-87B0A51A2854__BABEDFJE">例12-9</a>将相同的集合元素插入到两个数据库表中，使用第一个表的<code class="codeph">FOR</code> <code class="codeph">LOOP</code>语句和第二个表的<code class="codeph">FORALL</code>语句，并显示每个语句所用的时间。（时间因运行而异。）
                     </p>
                     <p>在<a href="plsql-optimization-and-tuning.html#GUID-6D4A1425-64DD-4723-8AAE-87B0A51A2854__BABIIEEI">示例12-10中</a> ， <code class="codeph">FORALL</code>语句适用于集合的子集。
                     </p>
                     <div class="section">
                        <p class="subhead3" id="GUID-6D4A1425-64DD-4723-8AAE-87B0A51A2854__GUID-D3C60FDF-E024-4F92-9505-659DE4548684">话题</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="plsql-optimization-and-tuning.html#GUID-82049618-CB67-4CF1-8455-02AC6AEB5F8E" title="如果FORALL语句bounds子句引用稀疏集合，则使用INDICES OF或VALUES OF子句仅指定现有索引值。">对稀疏集合使用FORALL语句</a></p>
                           </li>
                           <li>
                              <p><a href="plsql-optimization-and-tuning.html#GUID-D294AADE-1742-442B-B97A-D2C3C2CED8A5" title="在没有SAVE EXCEPTIONS子句的FORALL语句中，如果一个DML语句引发未处理的异常，则PL / SQL将停止FORALL语句并回滚先前DML语句所做的所有更改。">FORALL语句中未处理的异常</a></p>
                           </li>
                           <li>
                              <p><a href="plsql-optimization-and-tuning.html#GUID-42AF6F5C-B06D-4EB6-9C7A-630FF65DBD5D" title="要立即处理FORALL语句中引发的异常，请省略SAVE EXCEPTIONS子句并编写相应的异常处理程序。">立即处理FORALL异常</a></p>
                           </li>
                           <li>
                              <p><a href="plsql-optimization-and-tuning.html#GUID-DAF46F06-EF3F-4B1A-A518-5238B80C69FA" title="要允许FORALL语句继续，即使它的某些DML语句失败，也包括SAVE EXCEPTIONS子句。当DML语句失败时，PL / SQL不会引发异常;相反，它保存了有关失败的信息。FORALL语句完成后，PL / SQL为FORALL语句（ORA-24381）引发一个异常。">在FORALL语句完成后处理FORALL异常</a></p>
                           </li>
                           <li>
                              <p><a href="plsql-optimization-and-tuning.html#GUID-DDB5CCDA-8060-4511-BA20-4D1F2C478412" title="FORALL语句完成后，您可以从隐式游标属性SQL％BULK_ROWCOUNT获取每个DML语句影响的行数。">获取受FORALL语句影响的行数</a></p>
                           </li>
                        </ul>
                        <div class="infoboxnotealso" id="GUID-6D4A1425-64DD-4723-8AAE-87B0A51A2854__GUID-0198D5FC-A4FE-458B-A1EF-1211FA35A59E">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><span class="q">“ <a href="FORALL-statement.html#GUID-C45B8241-F9DF-4C93-8577-C840A25963DB" title="FORALL语句多次运行一个DML语句，在VALUES和WHERE子句中使用不同的值。">FORALL语句</a> ”</span>的完整语法和语义，包括限制</p>
                              </li>
                              <li>
                                 <p><span class="q">“ <a href="static-sql.html#GUID-596C1961-5A94-40ED-9920-668BB05632C5">隐式游标</a> ”，</span>用于获取有关一般隐式游标属性的信息以及可与<code class="codeph">FORALL</code>语句一起使用的其他隐式游标属性</p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-6D4A1425-64DD-4723-8AAE-87B0A51A2854__BABBCECH">
                        <p class="titleinexample">例12-7 FOR LOOP语句中的DELETE语句</p><pre class="oac_no_warn" dir="ltr">DROP TABLE employees_temp; CREATE TABLE employees_temp AS SELECT * FROM employees; DECLARE TYPE NumList IS VARRAY（20）OF NUMBER; depts NumList：= NumList（10,30,70）; - 部门编号开始<span class="bold">为我在部署。FIRST..depts。最后一次循环</span> <span class="bold">从employees_temp删除</span> <span class="bold">WHERE department_id = depts（i）;</span> <span class="bold">结束循环;</span>结束; /</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-6D4A1425-64DD-4723-8AAE-87B0A51A2854__BABDBAAJ">
                        <p class="titleinexample">例12-8 FORALL语句中的DELETE语句</p><pre class="oac_no_warn" dir="ltr">DROP TABLE employees_temp; CREATE TABLE employees_temp AS SELECT * FROM employees; DECLARE TYPE NumList IS VARRAY（20）OF NUMBER; depts NumList：= NumList（10,30,70）; - 部门编号BEGIN <span class="bold">FORALL i IN depts。FIRST..depts。最后一次</span> <span class="bold">从employees_temp删除</span> <span class="bold">WHERE department_id = depts（i）;</span>结束; /</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-6D4A1425-64DD-4723-8AAE-87B0A51A2854__BABEDFJE">
                        <p class="titleinexample">例12-9 FOR LOOP和FORALL语句中INSERT语句的时间差</p><pre class="oac_no_warn" dir="ltr">DROP TABLE parts1; CREATE TABLE parts1（pnum INTEGER，pname VARCHAR2（15））; DROP TABLE parts2; CREATE TABLE parts2（pnum INTEGER，pname VARCHAR2（15））; DECLARE TYPE NumTab是TABLE of parts1.pnum％TYPE INDEX BY PLS_INTEGER; TYPE NameTab是TABLE of parts1.pname％TYPE INDEX BY PLS_INTEGER; pnums NumTab; pnames NameTab;迭代CONSTANT PLS_INTEGER：= 50000; t1 INTEGER; t2 INTEGER; t3 INTEGER; BEGIN FOR j IN 1..iterations LOOP  - 填充集合pnums（j）：= j; pnames（j）：='零件号'|| TO_CHAR（J）;结束循环; t1：= DBMS_UTILITY.get_time; <span class="bold">FOR i IN 1 ..项目LOOP</span> <span class="bold">INSERT INTO parts1（pnum，pname）</span> <span class="bold">VALUES（pnums（i），pnames（i））;</span> <span class="bold">结束循环;</span> t2：= DBMS_UTILITY.get_time; <span class="bold">FORALL IN IN 1 ..项目</span> <span class="bold">INSERT INTO parts2（pnum，pname）</span> <span class="bold">VALUES（pnums（i），pnames（i））;</span> t3：= DBMS_UTILITY.get_time; DBMS_OUTPUT.PUT_LINE（'执行时间（秒）'）; DBMS_OUTPUT.PUT_LINE（ '---------------------'）; DBMS_OUTPUT.PUT_LINE（'FOR LOOP：'|| TO_CHAR（（t2-t1）/ 100））; DBMS_OUTPUT.PUT_LINE（'FORALL：'|| TO_CHAR（（t3-t2）/ 100））;承诺;结束; /</pre><p>结果类似于：</p><pre class="oac_no_warn" dir="ltr">执行时间（秒）--------------------- FOR LOOP：5.97 FORALL：.07 PL / SQL过程成功完成。
</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-6D4A1425-64DD-4723-8AAE-87B0A51A2854__BABIIEEI">
                        <p class="titleinexample">例12-10集合子集的FORALL语句</p><pre class="oac_no_warn" dir="ltr">DROP TABLE employees_temp; CREATE TABLE employees_temp AS SELECT * FROM employees; DECLARE TYPE NumList IS VARRAY（10）OF NUMBER; depts NumList：= NumList（5,10,20,30,50,55,57,60,70,75）; BEGIN <span class="bold">FORALL j IN 4..7</span> DELETE FROM employees_temp WHERE department_id = depts（j）;结束; /</pre></div>
                     <!-- class="example" -->
                  </div><a id="LNPLS883"></a><a id="LNPLS99862"></a><div class="props_rev_3"><a id="GUID-82049618-CB67-4CF1-8455-02AC6AEB5F8E" name="GUID-82049618-CB67-4CF1-8455-02AC6AEB5F8E"></a><h5 id="LNPLS-GUID-82049618-CB67-4CF1-8455-02AC6AEB5F8E" class="sect5"><span class="enumeration_section">12.4.1.1</span>对稀疏集合使用FORALL语句</h5>
                     <div>
                        <p>如果<code class="codeph">FORALL</code>语句bounds子句引用稀疏集合，则使用<code class="codeph">INDICES</code> <code class="codeph">OF</code>或<code class="codeph">VALUES</code> <code class="codeph">OF</code>子句仅指定现有索引值。
                        </p>
                        <div class="section">
                           <p>除了由string索引的关联数组外<code class="codeph">OF</code>您可以将<code class="codeph">INDICES</code> <code class="codeph">OF</code>用于任何集合。您只能将<code class="codeph">VALUES</code> <code class="codeph">OF</code>用于由<code class="codeph">PLS_INTEGER</code>索引的<code class="codeph">PLS_INTEGER</code>元素的集合。</p>
                           <p>由<code class="codeph">PLS_INTEGER</code>索引的<code class="codeph">PLS_INTEGER</code>元素的集合可以是<span class="bold">索引集合</span> ;也就是说，指向另一个集合（ <span class="bold">索引集合</span> ）元素的指针<span class="bold">集合</span> 。
                           </p>
                           <p>索引集合对于使用不同的<code class="codeph">FORALL</code>语句处理同一集合的不同子集很有用。不是将原始集合的元素复制到表示子集（可以使用大量时间和内存）的新集合中，而是使用索引集合表示每个子集，然后在不同<code class="codeph">FORALL</code>语句的<code class="codeph">VALUES</code> <code class="codeph">OF</code>子句中使用每个索引集合。
                           </p>
                           <div class="infoboxnotealso" id="GUID-82049618-CB67-4CF1-8455-02AC6AEB5F8E__GUID-F6FAF1D3-70B8-4352-B5D3-8ACDA5D20EBB">
                              <p class="notep1">也可以看看：</p>
                              <p><span class="q">“ <a href="plsql-optimization-and-tuning.html#GUID-7D957671-D29A-42C3-8141-560C82035B74">稀疏集合和SQL％BULK_EXCEPTIONS</a> ”</span></p>
                           </div>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-82049618-CB67-4CF1-8455-02AC6AEB5F8E__BABJCEFE">
                           <p class="titleinexample">例12-11稀疏集合及其子集的FORALL语句</p>
                           <p>此示例使用带有<code class="codeph">INDICES</code> <code class="codeph">OF</code>子句的<code class="codeph">FORALL</code>语句来使用稀疏集合的元素填充表。然后它使用两个带有<code class="codeph">VALUES</code> <code class="codeph">OF</code>子句的<code class="codeph">FORALL</code>语句来填充具有集合子集的两个表。
                           </p><pre class="oac_no_warn" dir="ltr">DROP TABLE valid_orders; CREATE TABLE valid_orders（cust_name VARCHAR2（32），NUMBER（10,2））; DROP TABLE big_orders; CREATE TABLE big_orders AS SELECT * FROM valid_orders WHERE 1 = 0; DROP TABLE rejected_orders; CREATE TABLE rejected_orders AS SELECT * FROM valid_orders WHERE 1 = 0; DECLARE SUBTYPE cust_name IS valid_orders.cust_name％TYPE; TYPE cust_typ IS TABLE of cust_name; <span class="bold">cust_tab cust_typ; - 客户名称</span>集合SUBTYPE order_amount IS valid_orders.amount％TYPE; TYPE amount_typ是数字表; <span class="bold">amount_tab amount_typ; - 订单金额的收集</span> TYPE index_pointer_t IS TABLE <span class="bold">of</span> PLS_INTEGER; <span class="bold">/ *指向cust_tab集合元素的指针的集合</span> <span class="bold">（表示cust_tab的两个子集）：* /</span> big_order_tab index_pointer_t：= index_pointer_t（）; rejected_order_tab index_pointer_t：= index_pointer_t（）;程序populate_data_collections IS BEGIN cust_tab：= cust_typ（'Company1'，'Company2'，'Company3'，'Company4'，'Company5'）; amount_tab：= amount_typ（5000.01,0,150.25,4000.00，NULL）;结束; BEGIN <span class="bold">populate_data_collections;</span> DBMS_OUTPUT.PUT_LINE（'---原始订单数据---'）; FOR i IN 1..cust_tab。最后的循环DBMS_OUTPUT.PUT_LINE（'Customer＃'|| i ||'，'|| cust_tab（i）||'：$'|| amount_tab（i））;结束循环; <span class="bold">- 删除无效订单：</span> FOR i IN 1..cust_tab。最后循环如果amount_tab（i）IS NULL或amount_tab（i）= 0那么cust_tab.delete（i）; amount_tab.delete（ⅰ）;万一;结束循环; <span class="bold"> -  cust_tab现在是一个稀疏集合。</span>DBMS_OUTPUT.PUT_LINE（'---删除无效订单的订单数据---'）; FOR i IN 1..cust_tab。最后的循环IF cust_tab。EXISTS（i）那么DBMS_OUTPUT.PUT_LINE（'Customer＃'|| i ||'，'|| cust_tab（i）||'：$'|| amount_tab（i））;万一;结束循环; <span class="bold">- 使用稀疏集合，填充valid_orders表：</span> <span class="bold">FORALL i IN INDICES OF cust_tab</span> INSERT INTO valid_orders（cust_name，amount）VALUES（cust_tab（i），amount_tab（i））; <span class="bold">populate_data_collections; - 恢复原始订单数据</span> <span class="bold">-  cust_tab再次是一个密集的集合。</span>
 
  <span class="bold">/ *填充指向cust_tab集合元素的指针集合</span> <span class="bold">（表示cust_tab的两个子集）：* /</span> FOR i IN cust_tab。FIRST .. cust_tab。最后的循环如果amount_tab（i）IS NULL或amount_tab（i）= 0那么rejected_order_tab。延伸; rejected_order_tab（rejected_order_tab。最后）：= i;万一; IF amount_tab（i）&gt; 2000 THEN big_order_tab。延伸; big_order_tab（big_order_tab。最后）：= i;万一;结束循环; <span class="bold">/ *使用不同FORALL语句中的每个子集，</span> <span class="bold">填充rejected_orders和big_orders表：* /</span> <span class="bold">FORALL i IN VALUES OF rejected_order_tab</span> INSERT INTO rejected_orders（cust_name，amount）VALUES（cust_tab（i），amount_tab（i））; <span class="bold">FORALL我在big_order_tab的值中</span> INSERT INTO big_orders（cust_name，amount）VALUES（cust_tab（i），amount_tab（i））;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">---原始订单数据---客户＃1，公司1：$ 5000.01客户＃2，公司2：$ 0客户＃3，公司3：$ 150.25客户＃4，公司4：$ 4000客户＃5，公司5：$ ---数据无效订单已删除---客户＃1，公司1：$ 5000.01客户＃3，公司3：$ 150.25客户＃4，公司4：$ 4000</pre><p>确认存储了正确的订单详细信息：</p><pre class="oac_no_warn" dir="ltr">SELECT cust_name“Customer”，amount“有效订单金额”FROM valid_orders ORDER BY cust_name;</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">客户有效订单金额-------------------------------- -------------- ----公司1 5000.01公司3 150.25公司4 4000选3排。
</pre><p>查询：</p><pre class="oac_no_warn" dir="ltr">SELECT cust_name“Customer”，金额“大订单金额”FROM big_orders ORDER BY cust_name;</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">客户大订单金额-------------------------------- -------------- -  Company1 5000.01 Company4 4000 2行选择。
</pre><p>查询：</p><pre class="oac_no_warn" dir="ltr">SELECT cust_name“Customer”，金额“拒绝订单金额”FROM rejected_orders ORDER BY cust_name;</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">客户拒绝订单金额-------------------------------- -------------- ------- Company2 0公司5选2行。</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="LNPLS99861"></a><div class="props_rev_3"><a id="GUID-D294AADE-1742-442B-B97A-D2C3C2CED8A5" name="GUID-D294AADE-1742-442B-B97A-D2C3C2CED8A5"></a><h5 id="LNPLS-GUID-D294AADE-1742-442B-B97A-D2C3C2CED8A5" class="sect5"><span class="enumeration_section">12.4.1.2</span> FORALL语句中的未处理异常</h5>
                     <div>
                        <p>在没有<code class="codeph">SAVE</code> <code class="codeph">EXCEPTIONS</code>子句的<code class="codeph">FORALL</code>语句中，如果一个DML语句引发未处理的异常，则PL / SQL将停止<code class="codeph">FORALL</code>语句并回滚先前DML语句所做的所有更改。
                        </p>
                        <p>例如， <a href="plsql-optimization-and-tuning.html#GUID-6D4A1425-64DD-4723-8AAE-87B0A51A2854__BABDBAAJ">示例12-8中</a>的<code class="codeph">FORALL</code>语句按此顺序执行这些DML语句，除非其中一个引发未处理的异常：</p><pre class="oac_no_warn" dir="ltr">DELETE FROM employees_temp WHERE department_id = depts（10）; DELETE FROM employees_temp WHERE department_id = depts（30）; DELETE FROM employees_temp WHERE department_id = depts（70）;</pre><p>如果第三个语句引发了未处理的异常，那么PL / SQL将回滚第一个和第二个语句所做的更改。如果第二个语句引发未处理的异常，则PL / SQL将回滚第一个语句所做的更改，并且永远不会运行第三个语句。</p>
                        <p>您可以通过以下任一方式处理<code class="codeph">FORALL</code>语句中引发的异常：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>引发每个异常（请参阅<span class="q">“ <a href="plsql-optimization-and-tuning.html#GUID-42AF6F5C-B06D-4EB6-9C7A-630FF65DBD5D" title="要立即处理FORALL语句中引发的异常，请省略SAVE EXCEPTIONS子句并编写相应的异常处理程序。">立即处理FORALL异常</a> ”</span> ）</p>
                           </li>
                           <li>
                              <p><code class="codeph">FORALL</code>语句完成执行后，通过包含<code class="codeph">SAVE</code> <code class="codeph">EXCEPTIONS</code>子句（请参阅<span class="q">“ <a href="plsql-optimization-and-tuning.html#GUID-DAF46F06-EF3F-4B1A-A518-5238B80C69FA" title="要允许FORALL语句继续，即使它的某些DML语句失败，也包括SAVE EXCEPTIONS子句。当DML语句失败时，PL / SQL不会引发异常;相反，它保存了有关失败的信息。FORALL语句完成后，PL / SQL为FORALL语句（ORA-24381）引发一个异常。">处理FORALL语句完成后的FORALL异常</a> ”</span> ）</p>
                           </li>
                        </ul>
                     </div>
                  </div><a id="LNPLS885"></a><a id="LNPLS884"></a><div class="props_rev_3"><a id="GUID-42AF6F5C-B06D-4EB6-9C7A-630FF65DBD5D" name="GUID-42AF6F5C-B06D-4EB6-9C7A-630FF65DBD5D"></a><h5 id="LNPLS-GUID-42AF6F5C-B06D-4EB6-9C7A-630FF65DBD5D" class="sect5"><span class="enumeration_section">12.4.1.3</span>立即处理FORALL异常</h5>
                     <div>
                        <p>要立即处理<code class="codeph">FORALL</code>语句中引发的异常，请省略<code class="codeph">SAVE</code> <code class="codeph">EXCEPTIONS</code>子句并编写相应的异常处理程序。
                        </p>
                        <div class="section">
                           <p>如果一个DML语句引发了一个已处理的异常，那么PL / SQL将回滚该语句所做的更改，但不会回滚先前DML语句所做的更改。</p>
                           <p>在<a href="plsql-optimization-and-tuning.html#GUID-42AF6F5C-B06D-4EB6-9C7A-630FF65DBD5D__BABBBJCF">例12-12中</a> ， <code class="codeph">FORALL</code>语句用于运行三个<code class="codeph">UPDATE</code>语句。然而，第二个提出了一个例外。异常处理程序处理异常，显示错误消息并提交第一个<code class="codeph">UPDATE</code>语句所做的更改。第三个<code class="codeph">UPDATE</code>语句永远不会运行。
                           </p>
                           <p>有关异常处理程序的信息，请参阅<a href="plsql-error-handling.html#GUID-0502DC1A-F0A5-4180-A912-6A5CDC855F56" title="在编译存储的PL / SQL单元时，PL / SQL编译器会为不足以导致错误并阻止编译的条件生成警告 - 例如，使用不推荐的PL / SQL功能。">PL / SQL错误处理</a> 。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-42AF6F5C-B06D-4EB6-9C7A-630FF65DBD5D__BABBBJCF">
                           <p class="titleinexample">例12-12立即处理FORALL异常</p><pre class="oac_no_warn" dir="ltr">DROP TABLE emp_temp; CREATE TABLE emp_temp（deptno NUMBER（2），job VARCHAR2（18））;创建或替换过程作为类型NumList的AUTHID DEFINER是数字表; depts NumList：= NumList（10,20,30）; error_message VARCHAR2（100）; BEGIN  - 填充表：INSERT INTO emp_temp（deptno，job）VALUES（10，'Clerk'）; INSERT INTO emp_temp（deptno，job）VALUES（20，'Bookkeeper'）; INSERT INTO emp_temp（deptno，job）VALUES（30，'Analyst'）;承诺; - 为每个作业附加9个字符的字符串： <span class="bold">FORALL j IN depts。FIRST..depts。最后</span> <span class="bold">更新emp_temp SET job = job || '（高级）'在</span> <span class="bold">哪里deptno = depts（j）;</span> <span class="bold">异常</span> <span class="bold">，当OTHERS THEN</span> <span class="bold">ERROR_MESSAGE：= SQLERRM;</span> <span class="bold">DBMS_OUTPUT.PUT_LINE（error_message）;</span> <span class="bold">承诺; - 提交成功更新的结果</span> RAISE;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">程序已创建。
</pre><p>调用程序：</p><pre class="oac_no_warn" dir="ltr">开始p;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr"><span class="bold">ORA-12899：列“HR”的值太大。“EMP_TEMP”。“JOB”（实际：19，</span> <span class="bold">最大值：18）</span> <span class="bold">第1行的</span> <span class="bold">BEGIN</span> <span class="bold">*</span> <span class="bold">ERROR：</span> <span class="bold">ORA-12899：值“HR”列太大。“ EMP_TEMP“。”JOB“（实际：19，</span> <span class="bold">最大值：18）</span> <span class="bold">ORA-06512：在”HR.P“，第27行</span> <span class="bold">ORA-06512：在第2行</span>
</pre><p>查询：</p><pre class="oac_no_warn" dir="ltr">SELECT * FROM emp_temp;</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">DEPTNO JOB ---------- ------------------ 10职员<span class="bold">（高级）</span> 20簿记员30分析员3行选中。</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="LNPLS800"></a><a id="LNPLS889"></a><div class="props_rev_3"><a id="GUID-DAF46F06-EF3F-4B1A-A518-5238B80C69FA" name="GUID-DAF46F06-EF3F-4B1A-A518-5238B80C69FA"></a><h5 id="LNPLS-GUID-DAF46F06-EF3F-4B1A-A518-5238B80C69FA" class="sect5"><span class="enumeration_section">12.4.1.4</span> FORALL语句完成后处理FORALL异常</h5>
                     <div>
                        <p>要允许<code class="codeph">FORALL</code>语句继续，即使它的某些DML语句失败，也包括<code class="codeph">SAVE</code> <code class="codeph">EXCEPTIONS</code>子句。当DML语句失败时，PL / SQL不会引发异常;相反，它保存了有关失败的信息。<code class="codeph">FORALL</code>语句完成后，PL / SQL为<code class="codeph">FORALL</code>语句（ORA-24381）引发一个异常。
                        </p>
                        <div class="section">
                           <p>在ORA-24381的异常处理程序中，您可以从隐式游标属性<code class="codeph">SQL%BULK_EXCEPTIONS</code>获取有关每个DML语句失败的信息。</p>
                           <p><code class="codeph">SQL%BULK_EXCEPTIONS</code>类似于关于在最近运行的<code class="codeph">FORALL</code>语句期间失败的DML语句的关联信息数组。
                           </p>
                           <p><code class="codeph">SQL%BULK_EXCEPTIONS</code> 。 <code class="codeph">COUNT</code>是失败的DML语句数。如果是<code class="codeph">SQL%BULK_EXCEPTIONS</code> 。 <code class="codeph">COUNT</code>不为零，然后对于每个索引值<span class="italic">i</span>从1到<code class="codeph">SQL%BULK_EXCEPTIONS</code> 。 <code class="codeph">COUNT</code> ：</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">SQL%BULK_EXCEPTIONS(</code> <span class="italic"><code class="codeph">i</code></span> <code class="codeph">)</code> 。<code class="codeph">ERROR_INDEX</code>是失败的DML语句的编号。
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">SQL%BULK_EXCEPTIONS(</code> <span class="italic"><code class="codeph">i</code></span> <code class="codeph">)</code> 。<code class="codeph">ERROR_CODE</code>是失败的Oracle数据库错误代码。
                                 </p>
                              </li>
                           </ul>
                           <p>例如，如果<code class="codeph">FORALL</code> <code class="codeph">SAVE</code> <code class="codeph">EXCEPTIONS</code>语句运行100个DML语句，并且第十和第64个语句分别因错误代码ORA-12899和ORA-19278而失败，则：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">SQL%BULK_EXCEPTIONS</code> 。 <code class="codeph">COUNT</code> = 2</p>
                              </li>
                              <li>
                                 <p><code class="codeph">SQL%BULK_EXCEPTIONS(1)</code> 。<code class="codeph">ERROR_INDEX</code> = 10</p>
                              </li>
                              <li>
                                 <p><code class="codeph">SQL%BULK_EXCEPTIONS(1)</code> 。<code class="codeph">ERROR_CODE</code> = 12899</p>
                              </li>
                              <li>
                                 <p><code class="codeph">SQL%BULK_EXCEPTIONS(2)</code> 。<code class="codeph">ERROR_INDEX</code> = 64</p>
                              </li>
                              <li>
                                 <p><code class="codeph">SQL%BULK_EXCEPTIONS(2)</code> 。<code class="codeph">ERROR_CODE</code> = 19278</p>
                              </li>
                           </ul>
                           <div class="infoboxnote" id="GUID-DAF46F06-EF3F-4B1A-A518-5238B80C69FA__GUID-CE0CB20B-4F42-4AB9-B38E-DB98CD7C9CA3">
                              <p class="notep1">注意：</p>
                              <p>在<span class="italic">没有</span> <code class="codeph">SAVE</code> <code class="codeph">EXCEPTIONS</code>子句的<code class="codeph">FORALL</code>语句引发异常后， <code class="codeph">SQL%BULK_EXCEPTIONS</code> 。 <code class="codeph">COUNT</code> = 1。
                              </p>
                           </div>
                           <p>使用错误代码，您可以使用<code class="codeph">SQLERRM</code>函数获取关联的错误消息（在<span class="q">“ <a href="SQLERRM-function.html#GUID-D4468C8F-62D9-42A5-AF72-C1098C866DC5" title="SQLERRM函数返回与错误代码关联的错误消息。">SQLERRM函数</a> ”中</span>描述）：</p><pre class="oac_no_warn" dir="ltr">SQLERRM（ - （SQL％BULK_EXCEPTIONS（I）。错误代码））</pre><p>但是， <code class="codeph">SQLERRM</code>返回的错误消息排除了任何替换参数（比较<a href="plsql-optimization-and-tuning.html#GUID-42AF6F5C-B06D-4EB6-9C7A-630FF65DBD5D__BABBBJCF">示例12-12</a>和<a href="plsql-optimization-and-tuning.html#GUID-DAF46F06-EF3F-4B1A-A518-5238B80C69FA__BABGBABA">示例12-13中</a>的错误消息）。
                           </p>
                           <p><a href="plsql-optimization-and-tuning.html#GUID-DAF46F06-EF3F-4B1A-A518-5238B80C69FA__BABGBABA">例12-13</a>与<a href="plsql-optimization-and-tuning.html#GUID-42AF6F5C-B06D-4EB6-9C7A-630FF65DBD5D__BABBBJCF">例12-12</a>类似，不同的是：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">FORALL</code>语句包含<code class="codeph">SAVE</code> <code class="codeph">EXCEPTIONS</code>子句。
                                 </p>
                              </li>
                              <li>
                                 <p>异常处理部分有一个ORA-24381的异常处理程序，这是PL / SQL在批量操作引发和保存异常时隐式引发的内部定义的异常。该示例为ORA-24381提供了用户定义的名称<code class="codeph">dml_errors</code> 。
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">dml_errors</code>的异常处理程序使用<code class="codeph">SQL%BULK_EXCEPTIONS</code>和<code class="codeph">SQLERRM</code> （以及一些局部变量）来显示错误消息以及哪个语句，集合项和字符串导致错误。
                                 </p>
                              </li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-DAF46F06-EF3F-4B1A-A518-5238B80C69FA__BABGBABA">
                           <p class="titleinexample">例12-13在FORALL语句完成后处理FORALL异常</p><pre class="oac_no_warn" dir="ltr">创建或替换过程作为类型NumList的AUTHID DEFINER是数字表; depts NumList：= NumList（10,20,30）; error_message VARCHAR2（100）; <span class="bold">bad_stmt_no PLS_INTEGER;</span> <span class="bold">bad_deptno emp_temp.deptno％TYPE;</span> <span class="bold">bad_job emp_temp.job％TYPE;</span> <span class="bold">dml_errors EXCEPTION;</span> <span class="bold">PRAGMA EXCEPTION_INIT（dml_errors，-24381）;</span> BEGIN  - 填充表：INSERT INTO emp_temp（deptno，job）VALUES（10，'Clerk'）; INSERT INTO emp_temp（deptno，job）VALUES（20，'Bookkeeper'）; INSERT INTO emp_temp（deptno，job）VALUES（30，'Analyst'）;承诺; - 为每个作业附加9个字符的字符串：FORALL j IN depts。FIRST..depts。最后<span class="bold">保存EXCEPTIONS</span> UPDATE emp_temp SET job = job || '（高级）'在哪里deptno = depts（j）;当dml_errors出现在<span class="bold">我身上时的异常<span class="bold">...SQL％BULK_EXCEPTIONS.COUNT LOOP</span> <span class="bold">error_message：= SQLERRM（ - （SQL％BULK_EXCEPTIONS（i）。错误代码））;</span> <span class="bold">DBMS_OUTPUT.PUT_LINE（error_message）;</span> <span class="bold">bad_stmt_no：= SQL％BULK_EXCEPTIONS（i）。ERROR_INDEX;</span> <span class="bold">DBMS_OUTPUT.PUT_LINE（'错误语句＃：'|| bad_stmt_no）;</span> <span class="bold">bad_deptno：= depts（bad_stmt_no）;</span> <span class="bold">DBMS_OUTPUT.PUT_LINE（'坏部门＃：'|| bad_deptno）;</span> <span class="bold">SELECT job INTO bad_job FROM emp_temp WHERE deptno = bad_deptno;</span> <span class="bold">DBMS_OUTPUT.PUT_LINE（'糟糕的工作：'|| bad_job）;</span> <span class="bold">结束循环;</span>承诺; -提交成功更新<span class="bold">时OTHERS THEN</span> <span class="bold">DBMS_OUTPUT.PUT_LINE（'无法识别的错误的结果<span class="bold">。“）;</span>提高;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">程序已创建。
</pre><p>调用程序：</p><pre class="oac_no_warn" dir="ltr">开始p;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr"><span class="bold">ORA-12899：列值太大（实际：，最大值:)</span> <span class="bold">错误语句＃：2</span> <span class="bold">错误部门＃：20</span> <span class="bold">错误作业：簿记员</span> PL / SQL过程成功完成。
</pre><p>查询：</p><pre class="oac_no_warn" dir="ltr">SELECT * FROM emp_temp;</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">DEPTNO JOB ---------- ------------------ 10职员（高级）20簿记员30分析员<span class="bold">（高级）</span>选择3行。</pre></div>
                        <!-- class="example" -->
                     </div><a id="LNPLS99860"></a><div class="props_rev_3"><a id="GUID-7D957671-D29A-42C3-8141-560C82035B74" name="GUID-7D957671-D29A-42C3-8141-560C82035B74"></a><h6 id="LNPLS-GUID-7D957671-D29A-42C3-8141-560C82035B74" class="sect6"><span class="enumeration_section">12.4.1.4.1</span>稀疏集合和SQL％BULK_EXCEPTIONS</h6>
                        <div>
                           <div class="section">
                              <p>如果<code class="codeph">FORALL</code>语句bounds子句引用稀疏集合，那么要查找导致DML语句失败的集合元素，必须逐个单步执行元素，直到找到索引为<code class="codeph">SQL%BULK_EXCEPTIONS(i)</code>的元素。<code class="codeph">ERROR_INDEX</code> 。然后，如果<code class="codeph">FORALL</code>语句使用<code class="codeph">VALUES</code> <code class="codeph">OF</code>子句引用指向另一个集合的指针集合，则必须找到索引为<code class="codeph">SQL%BULK_EXCEPTIONS(i)</code>的其他集合的元素。<code class="codeph">ERROR_INDEX</code> 。</p>
                           </div>
                           <!-- class="section" -->
                        </div>
                     </div>
                  </div><a id="LNPLS887"></a><a id="LNPLS888"></a><a id="LNPLS886"></a><div class="props_rev_3"><a id="GUID-DDB5CCDA-8060-4511-BA20-4D1F2C478412" name="GUID-DDB5CCDA-8060-4511-BA20-4D1F2C478412"></a><h5 id="LNPLS-GUID-DDB5CCDA-8060-4511-BA20-4D1F2C478412" class="sect5"><span class="enumeration_section">12.4.1.5</span>获取受FORALL语句影响的行数</h5>
                     <div>
                        <p><code class="codeph">FORALL</code>语句完成后，您可以从隐式游标属性<code class="codeph">SQL%BULK_ROWCOUNT</code>获取每个DML语句影响的行数。</p>
                        <div class="section">
                           <p>要获取受<code class="codeph">FORALL</code>语句影响的总行数，请使用隐式游标属性<code class="codeph">SQL%ROWCOUNT</code> ，如<span class="q">“ <a href="static-sql.html#GUID-0C789D68-82D8-4896-97BF-AF2356B9C8D5">SQL％ROWCOUNT属性：受影响的行数？</a>“</span> 。
                           </p>
                           <p><code class="codeph">SQL%BULK_ROWCOUNT</code>类似于关联数组，其第<span class="italic">i</span>个元素是最近完成的<code class="codeph">FORALL</code>语句中受第<span class="italic">i</span>个DML语句影响的行数。元素的数据类型是<code class="codeph">INTEGER</code> 。</p>
                           <div class="infoboxnote" id="GUID-DDB5CCDA-8060-4511-BA20-4D1F2C478412__GUID-D7390533-E729-43E8-9C79-9C3010697203">
                              <p class="notep1">注意：</p>
                              <p>如果服务器是Oracle Database 12c或更高版本且其客户端是Oracle Database 11g第2版或更早版本（或反向），则<code class="codeph">SQL%BULK_ROWCOUNT</code>返回的最大数量为4,294,967,295。
                              </p>
                           </div>
                           <p><a href="plsql-optimization-and-tuning.html#GUID-DDB5CCDA-8060-4511-BA20-4D1F2C478412__BABDJBDH">示例12-14</a>使用<code class="codeph">SQL%BULK_ROWCOUNT</code>显示<code class="codeph">FORALL</code>语句中每个<code class="codeph">DELETE</code>语句删除的行数和<code class="codeph">SQL%ROWCOUNT</code>以显示已删除的总行数。
                           </p>
                           <p><a href="plsql-optimization-and-tuning.html#GUID-DDB5CCDA-8060-4511-BA20-4D1F2C478412__BABICGJE">例12-15</a>使用<code class="codeph">SQL%BULK_ROWCOUNT</code>显示插入<code class="codeph">FORALL</code>语句中每个<code class="codeph">INSERT</code> <code class="codeph">SELECT</code>构造的行数，以及显示插入的总行数的<code class="codeph">SQL%ROWCOUNT</code> 。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-DDB5CCDA-8060-4511-BA20-4D1F2C478412__BABDJBDH">
                           <p class="titleinexample">示例12-14显示FORALL中每个DELETE影响的行数</p><pre class="oac_no_warn" dir="ltr">DROP TABLE emp_temp; CREATE TABLE emp_temp AS SELECT * FROM employees; DECLARE TYPE NumList是数字表; depts NumList：= NumList（30,50,60）; BEGIN FORALL j IN depts。FIRST..depts。最后一次删除来自emp_temp WHERE department_id = depts（j）;对于我的部署。FIRST..depts。LAST LOOP DBMS_OUTPUT.PUT_LINE（'Statement＃'|| i ||'deleted'|| <span class="bold">SQL％BULK_ROWCOUNT（i）</span> ||'行。'）;结束循环; DBMS_OUTPUT.PUT_LINE（'删除的总行数：'|| <span class="bold">SQL％ROWCOUNT</span> ）;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">声明＃1删除了6行。声明＃2删除了45行。声明＃3删除了5行。删除的总行数：56</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-DDB5CCDA-8060-4511-BA20-4D1F2C478412__BABICGJE">
                           <p class="titleinexample">例12-15显示FORALL中每个INSERT SELECT影响的行数</p><pre class="oac_no_warn" dir="ltr">DROP TABLE emp_by_dept; CREATE TABLE emp_by_dept AS SELECT employee_id，department_id FROM employees WHERE 1 = 0; DECLARE TYPE dept_tab IS表格departments.department_id％TYPE; deptnums dept_tab; BEGIN SELECT department_id BULK收集来自部门的deptnums; <span class="bold">FORALL IN IN 1..deptnums。COUNT</span> <span class="bold">INSERT INTO emp_by_dept（employee_id，department_id）</span> <span class="bold">SELECT employee_id，department_id</span> <span class="bold">FROM employees</span> <span class="bold">WHERE department_id = deptnums（i）</span> <span class="bold">ORDER BY department_id，employee_id;</span> FOR i IN 1..deptnums。COUNT LOOP  - 计算每个部门插入的行数;也就是说， - 每个部门有多少员工。DBMS_OUTPUT.PUT_LINE（'dept'|| deptnums（i）||'：inserted'|| <span class="bold">SQL％BULK_ROWCOUNT（i）</span> ||'records'）;结束循环; DBMS_OUTPUT.PUT_LINE（'插入的总记录数：'|| <span class="bold">SQL％ROWCOUNT</span> ）;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">部门10：插入1个记录部门20：插入2个记录部门30：插入6个记录部门40：插入1个记录部门50：插入45个记录部门60：插入5个记录部门70：插入1个记录部门80：插入34个记录部门90 ：插入3条记录部门100：插入6条记录部门110：插入2条记录部门120：插入0记录部门130：插入0记录部门140：插入0记录部门150：插入0记录部门160：插入0记录部门170：插入0记录部门180：插入0记录部门190：插入0记录部门200：插入0记录部门210：插入0记录部门220：插入0记录部门230：插入0记录部门240：插入0记录部门250：插入0记录部门260：插入0记录部门270：插入0记录部门280：插入0记录插入的总记录：106</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div>
               </div><a id="LNPLS801"></a><a id="LNPLS891"></a><div class="props_rev_3"><a id="GUID-19F50644-C88E-49AF-B31C-3EE4B4432714" name="GUID-19F50644-C88E-49AF-B31C-3EE4B4432714"></a><h4 id="LNPLS-GUID-19F50644-C88E-49AF-B31C-3EE4B4432714" class="sect4"><span class="enumeration_section">12.4.2</span>批量收集条款</h4>
                  <div>
                     <p><code class="codeph">BULK</code> <code class="codeph">COLLECT</code>子句是批量SQL的一个特性，它将结果从SQL返回到PL / SQL，而不是一次返回一个。
                     </p>
                     <p><code class="codeph">BULK</code> <code class="codeph">COLLECT</code>子句可以出现在：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">SELECT</code> <code class="codeph">INTO</code>语句</p>
                        </li>
                        <li>
                           <p><code class="codeph">FETCH</code>语句</p>
                        </li>
                        <li>
                           <p><code class="codeph">RETURNING</code> <code class="codeph">INTO</code>条款：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">DELETE</code>语句</p>
                              </li>
                              <li>
                                 <p><code class="codeph">INSERT</code>语句</p>
                              </li>
                              <li>
                                 <p><code class="codeph">UPDATE</code>声明</p>
                              </li>
                              <li>
                                 <p><code class="codeph">EXECUTE</code> <code class="codeph">IMMEDIATE</code>语句</p>
                              </li>
                           </ul>
                        </li>
                     </ul>
                     <p>使用<code class="codeph">BULK</code> <code class="codeph">COLLECT</code>子句，前面的每个语句都会检索整个结果集，并将其存储在单个操作中的一个或多个集合变量中（这比使用循环语句一次检索一个结果行更有效）。
                     </p>
                     <div class="infoboxnote" id="GUID-19F50644-C88E-49AF-B31C-3EE4B4432714__GUID-4D9E4554-0F1A-479C-955D-D83BF57F8B11">
                        <p class="notep1">注意：</p>
                        <p>PL / SQL处理<code class="codeph">BULK</code> <code class="codeph">COLLECT</code>子句，类似于处理<code class="codeph">LOOP</code>语句中的<code class="codeph">FETCH</code>语句的方式。当具有<code class="codeph">BULK</code> <code class="codeph">COLLECT</code>子句的语句不返回任何行时，PL / SQL不会引发异常。您必须检查目标集合是否空白，如<a href="plsql-optimization-and-tuning.html#GUID-541A8B35-9B8F-432F-9E30-E73305A6E17C__BABCCJCB">例12-22所示</a> 。
                        </p>
                     </div>
                     <div class="section">
                        <p class="subhead3" id="GUID-19F50644-C88E-49AF-B31C-3EE4B4432714__GUID-040DA890-F13D-4B00-BCD3-14CC0F0C3823">话题</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="plsql-optimization-and-tuning.html#GUID-6E09E4FC-28C0-43C8-9E7C-A54D6398D1DE" title="带有BULK COLLECT子句的SELECT INTO语句（也称为SELECT BULK COLLECT INTO语句）将整个结果集选择为一个或多个集合变量。">使用BULK COLLECT条款选择INTO语句</a></p>
                           </li>
                           <li>
                              <p><a href="plsql-optimization-and-tuning.html#GUID-541A8B35-9B8F-432F-9E30-E73305A6E17C" title="具有BULK COLLECT子句（也称为FETCH BULK COLLECT语句）的FETCH语句将整个结果集提取到一个或多个集合变量中。">FETCH语句与BULK COLLECT子句</a></p>
                           </li>
                           <li>
                              <p><a href="plsql-optimization-and-tuning.html#GUID-33749752-0DC6-4749-8A84-77CF3AC6FD6A" title="带有BULK COLLECT子句的RETURNING INTO子句（也称为RETURNING BULK COLLECT INTO子句）可以出现在INSERT，UPDATE，DELETE或EXECUTE IMMEDIATE语句中。使用RETURNING BULK COLLECT INTO子句，该语句将其结果集存储在一个或多个集合中。">通过BULK COLLECT条款返回条款</a></p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div><a id="LNPLS803"></a><a id="LNPLS892"></a><a id="LNPLS802"></a><a id="LNPLS99877"></a><div class="props_rev_3"><a id="GUID-6E09E4FC-28C0-43C8-9E7C-A54D6398D1DE" name="GUID-6E09E4FC-28C0-43C8-9E7C-A54D6398D1DE"></a><h5 id="LNPLS-GUID-6E09E4FC-28C0-43C8-9E7C-A54D6398D1DE" class="sect5"><span class="enumeration_section">12.4.2.1</span>使用BULK COLLECT子句选择INTO语句</h5>
                     <div>
                        <p>带有<code class="codeph">BULK</code> <code class="codeph">COLLECT</code>子句的<code class="codeph">SELECT</code> <code class="codeph">INTO</code>语句（也称为<code class="codeph">SELECT</code> <code class="codeph">BULK</code> <code class="codeph">COLLECT</code> <code class="codeph">INTO</code>语句）将整个结果集选择为一个或多个集合变量。
                        </p>
                        <p>有关更多信息，请参阅<span class="q">“ <a href="SELECT-INTO-statement.html#GUID-6E14E04D-4344-45F3-BE80-979DD26C7A90" title="SELECT INTO语句从一个或多个数据库表中检索值（如SQL SELECT语句所做的那样）并将它们存储在变量中（SQL SELECT语句不这样做）。">SELECT INTO语句</a> ”</span> 。
                        </p>
                        <div class="infoboxnote" id="GUID-6E09E4FC-28C0-43C8-9E7C-A54D6398D1DE__GUID-B53BE4A6-1347-441E-A6CF-6B3B78159A47">
                           <p class="notep1">警告：</p>
                           <p><code class="codeph">SELECT</code> <code class="codeph">BULK</code> <code class="codeph">COLLECT</code> <code class="codeph">INTO</code>语句容易受到别名的影响，这会导致意外的结果。有关详细信息，请参阅<span class="q">“ <a href="plsql-optimization-and-tuning.html#GUID-8731CD7C-7460-4836-8A3D-C706E5BEC0EA">选择BULK收集语句和别名</a> ”</span> 。
                           </p>
                        </div>
                        <p><a href="plsql-optimization-and-tuning.html#GUID-6E09E4FC-28C0-43C8-9E7C-A54D6398D1DE__BABJCBGD">例12-16</a>使用<code class="codeph">SELECT</code> <code class="codeph">BULK</code> <code class="codeph">COLLECT</code> <code class="codeph">INTO</code>语句将两个数据库列选择为两个集合（嵌套表）。
                        </p>
                        <p><a href="plsql-optimization-and-tuning.html#GUID-6E09E4FC-28C0-43C8-9E7C-A54D6398D1DE__CIHGGBGF">例12-17</a>使用<code class="codeph">SELECT</code> <code class="codeph">BULK</code> <code class="codeph">COLLECT</code> <code class="codeph">INTO</code>语句将结果集选择到嵌套的记录表中。
                        </p>
                        <div class="section">
                           <p class="subhead3" id="GUID-6E09E4FC-28C0-43C8-9E7C-A54D6398D1DE__GUID-7D0F656F-7948-42B2-A3C9-5FF9D7A08D82">话题</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><a href="plsql-optimization-and-tuning.html#GUID-8731CD7C-7460-4836-8A3D-C706E5BEC0EA">SELECT BULK收集语句和别名</a></p>
                              </li>
                              <li>
                                 <p><a href="plsql-optimization-and-tuning.html#GUID-9E6FC4CF-A6B7-4C79-996D-50FF22AD3A9D">SELECT BULK的行限制收集到语句中</a></p>
                              </li>
                              <li>
                                 <p><a href="plsql-optimization-and-tuning.html#GUID-7254F181-2AF7-4DD7-8278-CF911B548F25">循环收集指南</a></p>
                              </li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-6E09E4FC-28C0-43C8-9E7C-A54D6398D1DE__BABJCBGD">
                           <p class="titleinexample">示例12-16批量选择两个数据库列为两个嵌套表</p><pre class="oac_no_warn" dir="ltr">DECLARE TYPE NumTab IS TABLE OF employees.employee_id％TYPE; TYPE NameTab IS TABLE OF employees.last_name％TYPE;枚举NumTab;名字NameTab;程序print_first_n（n POSITIVE）如果枚举则开始。COUNT = 0那么DBMS_OUTPUT.PUT_LINE（'集合为空。“）; ELSE DBMS_OUTPUT.PUT_LINE（'First'|| n ||'employees：'）; FOR i IN 1 .. n LOOP DBMS_OUTPUT.PUT_LINE（'Employee＃'|| enums（i）||'：'|| names（i））;结束循环;万一;结束; BEGIN <span class="bold">SELECT employee_id，last_name</span> <span class="bold">BULK COLLECT INTO enums，names</span> <span class="bold">FROM employees</span> <span class="bold">ORDER BY employee_id;</span> print_first_n（3）; print_first_n（6）;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">前3名员工：员工＃100：King员工＃101：Kochhar员工＃102：De Haan前6名员工：员工＃100：King员工＃101：Kochhar员工＃102：De Haan员工＃103：Hunold员工＃104：Ernst员工＃105：奥斯汀</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-6E09E4FC-28C0-43C8-9E7C-A54D6398D1DE__CIHGGBGF">
                           <p class="titleinexample">示例12-17批量选择嵌套记录表</p><pre class="oac_no_warn" dir="ltr">DECLARE CURSOR c1 IS SELECT first_name，last_name，hire_date FROM employees; TYPE NameSet IS TABLE OF c1％ROWTYPE; stock_managers NameSet; - 嵌套记录表BEGIN  - 将值分配给嵌套记录表： <span class="bold">SELECT first_name，last_name，hire_date</span> <span class="bold">BULK COLLECT INTO stock_managers</span> <span class="bold">FROM employees</span> <span class="bold">WHERE job_id ='ST_MAN'ORDER</span> <span class="bold">BY hire_date;</span> - 打印嵌套的记录表：FOR i IN stock_managers。首先.. stock_managers。LAST LOOP DBMS_OUTPUT.PUT_LINE（stock_managers（i）.hire_date ||''|| stock_managers（i）.last_name ||'，'|| stock_managers（i）.first_name）; END LOOP; END; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">01-MAY-03 Kaufling，Payam 18-JUL-04 Weiss，Matthew 10-APR-05 Fripp，Adam 10-OCT-05 Vollman，Shanta 16-NOV-07 Mourgos，Kevin</pre></div>
                        <!-- class="example" -->
                     </div><a id="LNPLS905"></a><a id="LNPLS906"></a><a id="LNPLS907"></a><a id="LNPLS904"></a><div class="props_rev_3"><a id="GUID-8731CD7C-7460-4836-8A3D-C706E5BEC0EA" name="GUID-8731CD7C-7460-4836-8A3D-C706E5BEC0EA"></a><h6 id="LNPLS-GUID-8731CD7C-7460-4836-8A3D-C706E5BEC0EA" class="sect6"><span class="enumeration_section">12.4.2.1.1</span>选择批量收集报表和别名</h6>
                        <div>
                           <p>在表格的声明中</p><pre class="oac_no_warn" dir="ltr">SELECT <span class="italic">列</span> BULK COLLECT INTO <span class="italic">集合</span> FROM <span class="italic">表</span> ...
</pre><p><span class="italic"><code class="codeph">column</code></span>和<span class="italic"><code class="codeph">collection</code></span>分别类似于<code class="codeph">IN</code> <code class="codeph">NOCOPY</code>和<code class="codeph">OUT</code> <code class="codeph">NOCOPY</code>子程序参数，PL / SQL通过引用传递它们。与通过引用传递的子程序参数一样，别名可能会导致意外结果。
                           </p>
                           <div class="infoboxnotealso" id="GUID-8731CD7C-7460-4836-8A3D-C706E5BEC0EA__GUID-CB16C98B-F206-4CD7-8584-11661690DD4F">
                              <p class="notep1">也可以看看：</p>
                              <p><span class="q">“ <a href="plsql-subprograms.html#GUID-1D93EBAE-406B-45CE-B89F-A456E37415CB">参考传递参数的子程序参数别名</a> ”</span></p>
                           </div>
                           <p>在<a href="plsql-optimization-and-tuning.html#GUID-8731CD7C-7460-4836-8A3D-C706E5BEC0EA__BABGIGII">示例12-18中</a> ，目的是从集合<code class="codeph">numbers1</code>选择特定值，然后将它们存储在同一集合中。意外的结果是删除了<code class="codeph">numbers1</code>所有元素。有关变通方法，请参见<a href="plsql-optimization-and-tuning.html#GUID-8731CD7C-7460-4836-8A3D-C706E5BEC0EA__BABCEEDG">例12-19</a>和<a href="plsql-optimization-and-tuning.html#GUID-8731CD7C-7460-4836-8A3D-C706E5BEC0EA__BABGHCAJ">例12-20</a> 。
                           </p>
                           <p><a href="plsql-optimization-and-tuning.html#GUID-8731CD7C-7460-4836-8A3D-C706E5BEC0EA__BABCEEDG">例12-19</a>使用游标来实现<a href="plsql-optimization-and-tuning.html#GUID-8731CD7C-7460-4836-8A3D-C706E5BEC0EA__BABGIGII">例12-18所</a>预期的结果。
                           </p>
                           <p><a href="plsql-optimization-and-tuning.html#GUID-8731CD7C-7460-4836-8A3D-C706E5BEC0EA__BABGHCAJ">例12-20</a>从集合<code class="codeph">numbers1</code>选择特定值，然后将它们存储在不同的集合<code class="codeph">numbers2</code> 。<a href="plsql-optimization-and-tuning.html#GUID-8731CD7C-7460-4836-8A3D-C706E5BEC0EA__BABGHCAJ">示例12-20</a>比<a href="plsql-optimization-and-tuning.html#GUID-8731CD7C-7460-4836-8A3D-C706E5BEC0EA__BABCEEDG">示例12-19</a>运行得更快。
                           </p>
                           <div class="example" id="GUID-8731CD7C-7460-4836-8A3D-C706E5BEC0EA__BABGIGII">
                              <p class="titleinexample">示例12-18选择BULK收集到具有意外结果的语句</p><pre class="oac_no_warn" dir="ltr">创建或替换类型numbers_type IS整数表/创建或替换过程p（i IN INTEGER）AUTHID DEFINER是numbers1 numbers_type：= numbers_type（1,2,3,4,5）; BEGIN DBMS_OUTPUT.PUT_LINE（'在SELECT语句之前'）; DBMS_OUTPUT.PUT_LINE（'numbers1。COUNT（）='|| numbers1。计数（））; FOR j IN 1..numbers1。COUNT（）LOOP DBMS_OUTPUT.PUT_LINE（'numbers1（'|| j ||'）='|| numbers1（j））;结束循环; - 自选BULK COLLECT INTO子句： <span class="bold">选择a。COLUMN_VALUE</span> <span class="bold">BULK收集数字1</span> <span class="bold">FROM TABLE（numbers1）a</span> <span class="bold">WHERE a。COLUMN_VALUE&gt; pi</span> <span class="bold">订购一个。COLUMN_VALUE;</span> DBMS_OUTPUT.PUT_LINE（'在SELECT语句之后'）; DBMS_OUTPUT.PUT_LINE（'numbers1。COUNT（）='|| numbers1。计数（））;结束p; /</pre><p>调用<code class="codeph">p</code> ：</p><pre class="oac_no_warn" dir="ltr">开始<span class="bold">p（2）;</span>结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr"><span class="bold">在SELECT语句</span> <span class="bold">number1 <span class="bold">之前</span> <span class="bold">。COUNT（）= 5个</span>数字1（1）= 1个数字1（2）= 2个数字1（3）= 3个数字1（4）= 4个数字1（5）= 5 <span class="bold">在SELECT语句</span> <span class="bold">数字 1 <span class="bold">之后</span> <span class="bold">。COUNT（）= 0</span> PL / SQL过程成功完成。
</pre><p>调用<code class="codeph">p</code> ：</p><pre class="oac_no_warn" dir="ltr">BEGIN <span class="bold">p（10）;</span>结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr"><span class="bold">在SELECT语句</span> <span class="bold">number1 <span class="bold">之前</span> <span class="bold">。COUNT（）= 5个</span>数字1（1）= 1个数字1（2）= 2个数字1（3）= 3个数字1（4）= 4个数字1（5）= 5 <span class="bold">在SELECT语句</span> <span class="bold">数字 1 <span class="bold">之后</span> <span class="bold">。COUNT（）= 0</span>
</pre></div>
                           <!-- class="example" -->
                           <div class="example" id="GUID-8731CD7C-7460-4836-8A3D-C706E5BEC0EA__BABCEEDG">
                              <p class="titleinexample">示例12-19 <span><a href="plsql-optimization-and-tuning.html#GUID-8731CD7C-7460-4836-8A3D-C706E5BEC0EA__BABGIGII">示例12-18的</a></span>游标变通方法</p><pre class="oac_no_warn" dir="ltr">创建或替换类型numbers_type IS整数表/创建或替换过程p（i IN INTEGER）AUTHID DEFINER是numbers1 numbers_type：= numbers_type（1,2,3,4,5）; <span class="bold">CURSOR c IS</span> <span class="bold">SELECT a。COLUMN_VALUE</span> <span class="bold">FROM TABLE（numbers1）a</span> <span class="bold">WHERE a。COLUMN_VALUE&gt; pi</span> <span class="bold">订购一个。COLUMN_VALUE;</span> BEGIN DBMS_OUTPUT.PUT_LINE（'在FETCH语句之前'）; DBMS_OUTPUT.PUT_LINE（'numbers1。COUNT（）='|| numbers1。计数（））; FOR j IN 1..numbers1。COUNT（）LOOP DBMS_OUTPUT.PUT_LINE（'numbers1（'|| j ||'）='|| numbers1（j））;结束循环; <span class="bold">OPEN c;</span> <span class="bold">FETCH c BULK收集数字1;</span> <span class="bold">关闭c;</span> DBMS_OUTPUT.PUT_LINE（'在FETCH语句之后'）; DBMS_OUTPUT.PUT_LINE（'numbers1。COUNT（）='|| numbers1。计数（））;如果数字1。COUNT（）&gt; 0那么j IN 1..numbers1。COUNT（）LOOP DBMS_OUTPUT.PUT_LINE（'numbers1（'|| j ||'）='|| numbers1（j））;结束循环;万一;结束p; /</pre><p>调用<code class="codeph">p</code> ：</p><pre class="oac_no_warn" dir="ltr">开始<span class="bold">p（2）;</span>结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr"><span class="bold">在FETCH语句</span> <span class="bold">编号 <span class="bold">之前</span> <span class="bold">1。COUNT（）= 5个</span>数字1（1）= 1个数字1（2）= 2个数字1（3）= 3个数字1（4）= 4个数字1（5）= 5 <span class="bold">在FETCH语句</span> <span class="bold">数字 1 <span class="bold">之后</span> <span class="bold">。COUNT（）= 3个</span>数字1（1）= 3个数字1（2）= 4个数字1（3）= 5</pre><p>调用<code class="codeph">p</code> ：</p><pre class="oac_no_warn" dir="ltr">BEGIN <span class="bold">p（10）;</span>结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr"><span class="bold">在FETCH语句</span> <span class="bold">编号 <span class="bold">之前</span> <span class="bold">1。COUNT（）= 5个</span>数字1（1）= 1个数字1（2）= 2个数字1（3）= 3个数字1（4）= 4个数字1（5）= 5 <span class="bold">在FETCH语句</span> <span class="bold">数字 1 <span class="bold">之后</span> <span class="bold">。COUNT（）= 0</span>
</pre></div>
                           <!-- class="example" -->
                           <div class="example" id="GUID-8731CD7C-7460-4836-8A3D-C706E5BEC0EA__BABGHCAJ">
                              <p class="titleinexample">示例12-20 <span><a href="plsql-optimization-and-tuning.html#GUID-8731CD7C-7460-4836-8A3D-C706E5BEC0EA__BABGIGII">示例12-18的</a></span>第二个集合解决方法</p><pre class="oac_no_warn" dir="ltr">创建或替换类型numbers_type IS整数表/创建或替换过程p（i IN INTEGER）AUTHID DEFINER是numbers1 numbers_type：= numbers_type（1,2,3,4,5）; <span class="bold">numbers2 numbers_type：= numbers_type（0,0,0,0,0）;</span> BEGIN DBMS_OUTPUT.PUT_LINE（'在SELECT语句之前'）; DBMS_OUTPUT.PUT_LINE（'numbers1。COUNT（）='|| numbers1。计数（））; FOR j IN 1..numbers1。COUNT（）LOOP DBMS_OUTPUT.PUT_LINE（'numbers1（'|| j ||'）='|| numbers1（j））;结束循环; DBMS_OUTPUT.PUT_LINE（'numbers2。COUNT（）='|| numbers2。计数（））; FOR j IN 1..numbers2。COUNT（）LOOP DBMS_OUTPUT.PUT_LINE（'numbers2（'|| j ||'）='|| numbers2（j））;结束循环;选择一个。COLUMN_VALUE <span class="bold">BULK收集到number2  - 数字2出现在这里</span> <span class="bold">FROM TABLE（numbers1）a  -  numbers1出现在这里</span> 。COLUMN_VALUE&gt; pi订购一个。COLUMN_VALUE; DBMS_OUTPUT.PUT_LINE（'在SELECT语句之后'）; DBMS_OUTPUT.PUT_LINE（'numbers1。COUNT（）='|| numbers1。计数（））;如果数字1。COUNT（）&gt; 0那么j IN 1..numbers1。COUNT（）LOOP DBMS_OUTPUT.PUT_LINE（'numbers1（'|| j ||'）='|| numbers1（j））;结束循环;万一; DBMS_OUTPUT.PUT_LINE（'numbers2。COUNT（）='|| numbers2。计数（））;如果数字2。COUNT（）&gt; 0那么j IN 1..numbers2。COUNT（）LOOP DBMS_OUTPUT.PUT_LINE（'numbers2（'|| j ||'）='|| numbers2（j））;结束循环;万一;结束p; /</pre><p>调用<code class="codeph">p</code> ：</p><pre class="oac_no_warn" dir="ltr">开始<span class="bold">p（2）;</span>结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr"><span class="bold">在SELECT语句</span> <span class="bold">number1 <span class="bold">之前</span> <span class="bold">。COUNT（）= 5个</span>数字1（1）= 1个数字1（2）= 2个数字1（3）= 3个数字1（4）= 4个数字1（5）= 5个<span class="bold">数字2。COUNT（）= 5个</span>数字2（1）= 0个数字2（2）= 0个数字2（3）= 0个数字2（4）= 0个数字2（5）= 0 <span class="bold">在SELECT语句</span> <span class="bold">number1之后。COUNT（）= 5个</span>数字1（1）= 1个数字1（2）= 2个数字1（3）= 3个数字1（4）= 4个数字1（5）= 5个<span class="bold">数字2。COUNT（）= 3个</span>数字2（1）= 3个数字2（2）= 4个数字2（3）= 5个PL / SQL过程成功完成。
</pre><p>调用<code class="codeph">p</code> ：</p><pre class="oac_no_warn" dir="ltr">BEGIN <span class="bold">p（10）;</span>结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr"><span class="bold">在SELECT语句</span> <span class="bold">number1 <span class="bold">之前</span> <span class="bold">。COUNT（）= 5个</span>数字1（1）= 1个数字1（2）= 2个数字1（3）= 3个数字1（4）= 4个数字1（5）= 5个<span class="bold">数字2。COUNT（）= 5个</span>数字2（1）= 0个数字2（2）= 0个数字2（3）= 0个数字2（4）= 0个数字2（5）= 0 <span class="bold">在SELECT语句</span> <span class="bold">number1之后。COUNT（）= 5个</span>数字1（1）= 1个数字1（2）= 2个数字1（3）= 3个数字1（4）= 4个数字1（5）= 5个<span class="bold">数字2。COUNT（）= 0</span></pre></div>
                           <!-- class="example" -->
                        </div>
                     </div><a id="LNPLS893"></a><a id="LNPLS99876"></a><div class="props_rev_3"><a id="GUID-9E6FC4CF-A6B7-4C79-996D-50FF22AD3A9D" name="GUID-9E6FC4CF-A6B7-4C79-996D-50FF22AD3A9D"></a><h6 id="LNPLS-GUID-9E6FC4CF-A6B7-4C79-996D-50FF22AD3A9D" class="sect6"><span class="enumeration_section">12.4.2.1.2</span> SELECT BULK收集到报表的行限制</h6>
                        <div>
                           <p><code class="codeph">SELECT</code> <code class="codeph">BULK</code> <code class="codeph">COLLECT</code> <code class="codeph">INTO</code>语句返回大量行会产生大量集合。要限制行数和集合大小，请使用以下方法之一：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">ROWNUM</code>伪列（在<a href="../sqlrf/ROWNUM-Pseudocolumn.html#SQLRF00255" target="_blank"><span class="italic">Oracle数据库SQL语言参考中</span></a>描述）</p>
                              </li>
                              <li>
                                 <p><code class="codeph">SAMPLE</code>子句（在<a href="../sqlrf/SELECT.html#SQLRF55293" target="_blank"><span class="italic">Oracle数据库SQL语言参考中</span></a>描述）</p>
                              </li>
                              <li>
                                 <p><code class="codeph">FETCH</code> <code class="codeph">FIRST</code>子句（在<a href="../sqlrf/SELECT.html#SQLRF55640" target="_blank"><span class="italic">Oracle数据库SQL语言参考中</span></a>描述）</p>
                              </li>
                           </ul>
                           <p><a href="plsql-optimization-and-tuning.html#GUID-9E6FC4CF-A6B7-4C79-996D-50FF22AD3A9D__BCGFEDDI">例12-21</a>显示了几种限制<code class="codeph">SELECT</code> <code class="codeph">BULK</code> <code class="codeph">COLLECT</code> <code class="codeph">INTO</code>语句返回的行数的方法。
                           </p>
                           <div class="example" id="GUID-9E6FC4CF-A6B7-4C79-996D-50FF22AD3A9D__BCGFEDDI">
                              <p class="titleinexample">例12-21使用ROWNUM，SAMPLE和FETCH优先限制批量选择</p><pre class="oac_no_warn" dir="ltr">DECLARE TYPE SalList IS TABLE OF employees.salary％TYPE; sals SalList; BEGIN SELECT工资BULK收集来自员工的信息<span class="bold">WHERE ROWNUM &lt;= 50</span> ; SELECT salary BULK COLLECT INTO sals FROM employees <span class="bold">SAMPLE（10）</span> ;选择工资BULK收集来自员工的sals <span class="bold">仅限第一行50行</span> ;结束; /</pre></div>
                           <!-- class="example" -->
                        </div>
                     </div><a id="LNPLS99875"></a><div class="props_rev_3"><a id="GUID-7254F181-2AF7-4DD7-8278-CF911B548F25" name="GUID-7254F181-2AF7-4DD7-8278-CF911B548F25"></a><h6 id="LNPLS-GUID-7254F181-2AF7-4DD7-8278-CF911B548F25" class="sect6"><span class="enumeration_section">12.4.2.1.3</span>循环收集指南</h6>
                        <div>
                           <p>当结果集存储在集合中时，很容易遍历行并引用不同的列。这种技术可以非常快，但也非常耗费内存。如果您经常使用它：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>要循环遍历结果集，请使用游标<code class="codeph">FOR</code> <code class="codeph">LOOP</code> （请参阅<span class="q">“ <a href="static-sql.html#GUID-25917214-FD91-499D-AB39-CE21484AB167" title="游标FOR LOOP语句允许您运行SELECT语句，然后立即循环遍历结果集的行。">使用光标处理查询结果集以获取LOOP语句</a> ”</span> ）。
                                 </p>
                                 <p>该技术避免了存储结果集副本的内存开销。</p>
                              </li>
                              <li>
                                 <p>而不是循环遍历结果集以搜索某些值或将结果过滤到较小的集合中，而是在<code class="codeph">SELECT</code> <code class="codeph">INTO</code>语句的查询中进行搜索或过滤。
                                 </p>
                                 <p>例如，在简单查询中，使用<code class="codeph">WHERE</code>子句;在比较多个结果集的查询中，使用诸如<code class="codeph">INTERSECT</code>和<code class="codeph">MINUS</code>类的集合运算符。有关集合运算符的信息，请参见<a href="../sqlrf/The-UNION-ALL-INTERSECT-MINUS-Operators.html#SQLRF52341" target="_blank"><span class="italic">Oracle数据库SQL语言参考</span></a> 。
                                 </p>
                              </li>
                              <li>
                                 <p>不是循环遍历结果集并为每个结果行运行另一个查询，而是在<code class="codeph">SELECT</code> <code class="codeph">INTO</code>语句的查询中使用子查询（请参阅<span class="q">“ <a href="static-sql.html#GUID-8DD487B1-1CC5-4F26-98F2-97753A7EEF70" title="如果通过循环遍历查询结果集并为每行运行另一个查询来处理查询结果集，则可以通过从循环内部删除第二个查询并使其成为第一个查询的子查询来提高性能。">使用子查询处理查询结果集</a> ”</span> ）。
                                 </p>
                              </li>
                              <li>
                                 <p>不是循环遍历结果集并为每个结果行运行另一个DML语句，而是使用<code class="codeph">FORALL</code>语句（请参阅<span class="q">“ <a href="plsql-optimization-and-tuning.html#GUID-6D4A1425-64DD-4723-8AAE-87B0A51A2854" title="FORALL语句是批量SQL的一个特性，它将批处理中的DML语句从PL / SQL发送到SQL，而不是一次发送一个。">FORALL语句</a> ”</span> ）。
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </div>
                  </div><a id="LNPLS895"></a><a id="LNPLS805"></a><a id="LNPLS894"></a><div class="props_rev_3"><a id="GUID-541A8B35-9B8F-432F-9E30-E73305A6E17C" name="GUID-541A8B35-9B8F-432F-9E30-E73305A6E17C"></a><h5 id="LNPLS-GUID-541A8B35-9B8F-432F-9E30-E73305A6E17C" class="sect5"><span class="enumeration_section">12.4.2.2</span>带有BULK COLLECT子句的FETCH语句</h5>
                     <div>
                        <p>该<code class="codeph">FETCH</code>用语句<code class="codeph">BULK</code> <code class="codeph">COLLECT</code>子句（也称为<code class="codeph">FETCH</code> <code class="codeph">BULK</code> <code class="codeph">COLLECT</code>语句）获取的整个结果集到一个或多个收集的变量。
                        </p>
                        <p>有关更多信息，请参阅<span class="q">“ <a href="FETCH-statement.html#GUID-75BC6E63-841A-4103-9B96-8AC97F5C28BB" title="FETCH语句从多行查询的结果集中检索数据行 - 一次一行，一次几行，或一次所有行 - 并将数据存储在变量，记录或集合中。">FETCH语句</a> ”</span> 。
                        </p>
                        <p><a href="plsql-optimization-and-tuning.html#GUID-541A8B35-9B8F-432F-9E30-E73305A6E17C__BABCCJCB">例12-22</a>使用<code class="codeph">FETCH</code> <code class="codeph">BULK</code> <code class="codeph">COLLECT</code>语句将整个结果集提取到两个集合（嵌套表）中。
                        </p>
                        <p><a href="plsql-optimization-and-tuning.html#GUID-541A8B35-9B8F-432F-9E30-E73305A6E17C__CIHBDHIB">例12-23</a>使用<code class="codeph">FETCH</code> <code class="codeph">BULK</code> <code class="codeph">COLLECT</code>语句将结果集提取到记录的集合（嵌套表）中。
                        </p>
                        <div class="example" id="GUID-541A8B35-9B8F-432F-9E30-E73305A6E17C__BABCCJCB">
                           <p class="titleinexample">例12-22批量获取两个嵌套表</p><pre class="oac_no_warn" dir="ltr">DECLARE TYPE NameList IS TABLE OF employees.last_name％TYPE; TYPE SalList IS TABLE OF employees.salary％TYPE; CURSOR c1 IS SELECT last_name，salary FROM employees WHERE salary&gt; 10000 ORDER BY last_name;名字NameList; sals SalList; TYPE RecList IS TABLE OF c1％ROWTYPE; recs RecList; v_limit PLS_INTEGER：= 10; PROCEDURE print_results IS BEGIN <span class="bold">- 检查集合是否为空：</span> IF名称为空或名称。COUNT = 0那么DBMS_OUTPUT.PUT_LINE（'没有结果！“）; ELSE DBMS_OUTPUT.PUT_LINE（'结果：'）;我的名字。第一..名字。最后的循环DBMS_OUTPUT.PUT_LINE（'员工'||姓名（i）||'：$'|| sals（i））;结束循环;万一;结束; BEGIN DBMS_OUTPUT.PUT_LINE（'---同时处理所有结果---'）;打开c1; FETCH c1 BULK收集名称，sals;关闭c1; print_results（）; DBMS_OUTPUT.PUT_LINE（'---处理'|| v_limit ||'行一次---'）;打开c1; LOOP FETCH c1 BULK收集名称，sals LIMIT v_limit;退出时的名字。COUNT = 0; print_results（）;结束循环;关闭c1; DBMS_OUTPUT.PUT_LINE（'---获取记录而不是列---'）;打开c1; FETCH c1 BULK COLLECT INTO recs; FOR i IN recs。FIRST .. recs。最后的循环 - 现在结果集中的所有列都来自一条记录DBMS_OUTPUT.PUT_LINE（'Employee'|| recs（i）.last_name ||'：$'|| recs（i）.salary）;结束循环;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">---同时处理所有结果---结果：员工Abel：$ 11000员工Cambrault：$ 11000员工De Haan：$ 17000员工Errazuriz：$ 12000员工Fripp：$ 10418.1员工Greenberg：$ 12008员工Hartstein：$ 13000员工Higgins：$ 12008员工Kaufling：$ 10036.95员工King：$ 24000员工Kochhar：$ 17000员工Ozer：$ 11500员工合作伙伴：$ 13500员工Raphaely：$ 11000员工Russell：$ 14000员工Vishney：$ 10500员工Weiss：$ 10418.1员工Zlotkey：$ 10500 ---一次处理10行---结果：员工Abel：11000美元员工Cambrault：11000美元员工De Haan：17000美元员工Errazuriz：12000美元员工Fripp：$ 10418.1员工Greenberg：$ 12008员工Hartstein：$ 13000员工Higgins：$ 12008员工Kaufling：$ 10036.95员工King：$ 24000结果：员工Kochhar：$ 17000员工Ozer：$ 11500员工合作伙伴：13500美元员工Raphaely：11000美元员工罗素：14000美元员工Vishney：10500美元员工Weiss：10418.1美元员工Zlotkey：10500美元---获取记录而不是专栏---员工Abel：11000美元员工Cambrault：11000美元员工De Haan：17000美元员工Errazuriz：12000美元员工Fripp：$ 10418.1员工Greenberg：$ 12008员工Hartstein：$ 13000员工Higgins：$ 12008员工Kaufling： $ 10036.95员工金：$ 24000员工Kochhar：$ 17000员工Ozer：$ 11500员工合作伙伴：$ 13500员工Raphaely：$ 11000员工Russell：$ 14000员工Vishney：$ 10500员工Weiss：$ 10418.1员工Zlotkey：$ 10500</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-541A8B35-9B8F-432F-9E30-E73305A6E17C__CIHBDHIB">
                           <p class="titleinexample">示例12-23批量获取嵌套记录表</p><pre class="oac_no_warn" dir="ltr">DECLARE CURSOR c1 IS SELECT first_name，last_name，hire_date FROM employees; TYPE NameSet IS TABLE OF c1％ROWTYPE; stock_managers NameSet; - 嵌套记录表TYPE cursor_var_type是REF CURSOR; cv cursor_var_type; BEGIN  - 为嵌套记录表分配值：OPEN cv FOR SELECT first_name，last_name，hire_date FROM employees WHERE job_id ='ST_MAN'ORDER BY hire_date; FETCH cvBUL收集到stock_managers;关闭cv; - 打印嵌套的记录表：FOR i IN stock_managers。首先.. stock_managers。LAST LOOP DBMS_OUTPUT.PUT_LINE（stock_managers（i）.hire_date ||''|| stock_managers（i）.last_name ||'，'|| stock_managers（i）.first_name）; END LOOP; END; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">01-MAY-03 Kaufling，Payam 18-JUL-04 Weiss，Matthew 10-APR-05 Fripp，Adam 10-OCT-05 Vollman，Shanta 16-NOV-07 Mourgos，Kevin</pre></div>
                        <!-- class="example" -->
                     </div><a id="LNPLS898"></a><a id="LNPLS897"></a><div class="props_rev_3"><a id="GUID-2AD6C621-3B71-4D27-8E94-574A54BB93A6" name="GUID-2AD6C621-3B71-4D27-8E94-574A54BB93A6"></a><h6 id="LNPLS-GUID-2AD6C621-3B71-4D27-8E94-574A54BB93A6" class="sect6"><span class="enumeration_section">12.4.2.2.1</span> FETCH BULK COLLECT语句的行限制</h6>
                        <div>
                           <p>返回大量行的<code class="codeph">FETCH</code> <code class="codeph">BULK</code> <code class="codeph">COLLECT</code>语句会产生一个大集合。要限制行数和集合大小，请使用<code class="codeph">LIMIT</code>子句。
                           </p>
                           <p>在<a href="plsql-optimization-and-tuning.html#GUID-2AD6C621-3B71-4D27-8E94-574A54BB93A6__BABJIAFH">例12-24中</a> ，随着<code class="codeph">LOOP</code>语句的每次迭代， <code class="codeph">FETCH</code>语句将10行（或更少）读取到关联数组<code class="codeph">empids</code> （覆盖先前的值）。请注意<code class="codeph">LOOP</code>语句的退出条件。
                           </p>
                           <div class="example" id="GUID-2AD6C621-3B71-4D27-8E94-574A54BB93A6__BABJIAFH">
                              <p class="titleinexample">例12-24用LIMIT限制Bulk FETCH</p><pre class="oac_no_warn" dir="ltr">DECLARE TYPE numtab是由PLS_INTEGER表示的数字索引; CURSOR c1 IS SELECT employee_id FROM employees WHERE department_id = 80 ORDER BY employee_id; empids numtab;开始打开c1; LOOP <span class="bold">- 在每次迭代中获取10行或更少行</span> FETCH c1 BULK COLLECT INTO empids <span class="bold">LIMIT 10</span> ; DBMS_OUTPUT.PUT_LINE（'-------一次批量获取的结果--------'）; FOR I IN 1 ..empids。COUNT LOOP DBMS_OUTPUT.PUT_LINE（'员工ID：'|| empids（i））;结束循环; <span class="bold">退出时c1％NOTFOUND;</span>结束循环;关闭c1;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">-------一次批量获取的结果--------员工ID：145员工ID：146员工ID：147员工ID：148员工ID：149员工ID：150员工ID：151员工ID ：152员工ID：153员工ID：154 -------一次批量获取结果--------员工ID：155员工ID：156员工ID：157员工ID：158员工ID：159员工ID：160员工ID：161员工ID：162员工ID：163员工ID：164 -------一次批量提取结果--------员工ID：165员工ID：166员工ID ：167员工身份：168员工身份：169员工身份：170员工身份：171员工身份：172员工身份：173员工身份：174 -------一次批量提取结果--------员工ID：175员工ID：176员工ID：177员工ID：179</pre></div>
                           <!-- class="example" -->
                        </div>
                     </div>
                  </div><a id="LNPLS900"></a><a id="LNPLS899"></a><div class="props_rev_3"><a id="GUID-33749752-0DC6-4749-8A84-77CF3AC6FD6A" name="GUID-33749752-0DC6-4749-8A84-77CF3AC6FD6A"></a><h5 id="LNPLS-GUID-33749752-0DC6-4749-8A84-77CF3AC6FD6A" class="sect5"><span class="enumeration_section">12.4.2.3</span>通过BULK COLLECT条款返回条款</h5>
                     <div>
                        <p>带有<code class="codeph">BULK</code> <code class="codeph">COLLECT</code>子句的<code class="codeph">RETURNING</code> <code class="codeph">INTO</code>子句（也称为<code class="codeph">RETURNING</code> <code class="codeph">BULK</code> <code class="codeph">COLLECT</code> <code class="codeph">INTO</code>子句）可以出现在<code class="codeph">INSERT</code> ， <code class="codeph">UPDATE</code> ， <code class="codeph">DELETE</code>或<code class="codeph">EXECUTE</code> <code class="codeph">IMMEDIATE</code>语句中。使用<code class="codeph">RETURNING</code> <code class="codeph">BULK</code> <code class="codeph">COLLECT</code> <code class="codeph">INTO</code>子句，该语句将其结果集存储在一个或多个集合中。
                        </p>
                        <p>有关更多信息，请参阅<span class="q">“返回<a href="RETURNING-INTO-clause.html#GUID-38F735B9-1100-45AF-AE71-18FB74A899BE" title="RETURNING INTO子句指定用于存储子句所属语句返回的值的变量。">条款</a> ”</span> 。
                        </p>
                        <p><a href="plsql-optimization-and-tuning.html#GUID-33749752-0DC6-4749-8A84-77CF3AC6FD6A__BABHDFDE">例12-25</a>使用<code class="codeph">DELETE</code>语句和<code class="codeph">RETURNING</code> <code class="codeph">BULK</code> <code class="codeph">COLLECT</code> <code class="codeph">INTO</code>子句从表中删除行并将它们返回到两个集合（嵌套表）中。
                        </p>
                        <div class="example" id="GUID-33749752-0DC6-4749-8A84-77CF3AC6FD6A__BABHDFDE">
                           <p class="titleinexample">示例12-25返回两个嵌套表中的已删除行</p><pre class="oac_no_warn" dir="ltr">DROP TABLE emp_temp; CREATE TABLE emp_temp AS SELECT * FROM employees ORDER BY employee_id; DECLARE TYPE NumList IS TABLE OF employees.employee_id％TYPE;枚举NumList; TYPE NameList IS TABLE OF employees.last_name％TYPE;名字NameList; BEGIN DELETE FROM emp_temp WHERE department_id = 30 RETURNING <span class="bold">employee_id，last_name</span> <span class="bold">BULK COLLECT INTO enums，names</span> ; DBMS_OUTPUT.PUT_LINE（'Deleted'|| SQL％ROWCOUNT ||'rows：'）; FOR i IN enums。FIRST ..枚举。LAST LOOP DBMS_OUTPUT.PUT_LINE（'Employee＃'|| enums（i）||'：'|| names（i））;结束循环;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">删除了6行：员工＃114：Raphaely员工＃115：Khoo员工＃116：Baida员工＃117：Tobias员工＃118：Himuro员工＃119：Colmenares</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div>
               </div><a id="LNPLS902"></a><a id="LNPLS806"></a><a id="LNPLS901"></a><div class="props_rev_3"><a id="GUID-D67D19A6-4717-4556-B027-15C3DED0519A" name="GUID-D67D19A6-4717-4556-B027-15C3DED0519A"></a><h4 id="LNPLS-GUID-D67D19A6-4717-4556-B027-15C3DED0519A" class="sect4"><span class="enumeration_section">12.4.3一起</span>使用FORALL语句和BULK COLLECT子句</h4>
                  <div>
                     <p>在<code class="codeph">FORALL</code>语句中，DML语句可以具有<code class="codeph">RETURNING</code> <code class="codeph">BULK</code> <code class="codeph">COLLECT</code> <code class="codeph">INTO</code>子句。对于<code class="codeph">FORALL</code>语句的每次迭代，DML语句将指定的值存储在指定的集合中，而不会覆盖先前的值，因为相同的DML语句将在<code class="codeph">FOR</code> <code class="codeph">LOOP</code>语句中执行。
                     </p>
                     <div class="section">
                        <p>在<a href="plsql-optimization-and-tuning.html#GUID-D67D19A6-4717-4556-B027-15C3DED0519A__BABEJHDE">例12-26中</a> ， <code class="codeph">FORALL</code>语句运行<code class="codeph">DELETE</code>语句，该语句具有<code class="codeph">RETURNING</code> <code class="codeph">BULK</code> <code class="codeph">COLLECT</code> <code class="codeph">INTO</code>子句。对于<code class="codeph">FORALL</code>语句的每次迭代， <code class="codeph">DELETE</code>语句分别将已删除行的<code class="codeph">employee_id</code>和<code class="codeph">department_id</code>值存储在集合<code class="codeph">e_ids</code>和<code class="codeph">d_ids</code> 。
                        </p>
                        <p><a href="plsql-optimization-and-tuning.html#GUID-D67D19A6-4717-4556-B027-15C3DED0519A__BABDCEBE">示例12-27</a>与<a href="plsql-optimization-and-tuning.html#GUID-D67D19A6-4717-4556-B027-15C3DED0519A__BABEJHDE">示例12-26</a>类似，不同之处在于它使用<code class="codeph">FOR</code> <code class="codeph">LOOP</code>语句而不是<code class="codeph">FORALL</code>语句。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-D67D19A6-4717-4556-B027-15C3DED0519A__BABEJHDE">
                        <p class="titleinexample">示例12-26在FORALL语句中使用RETURN BULK收集DELTO进行DELETE</p><pre class="oac_no_warn" dir="ltr">DROP TABLE emp_temp; CREATE TABLE emp_temp AS SELECT * FROM employees ORDER BY employee_id，department_id; DECLARE TYPE NumList是数字表; depts NumList：= NumList（10,20,30）; TYPE enum_t IS TABLE OF employees.employee_id％TYPE; e_ids enum_t; TYPE dept_t IS TABLE OF employees.department_id％TYPE; d_ids dept_t; BEGIN <span class="bold">FORALL</span> j IN depts。FIRST..depts。最后删除来自emp_temp WHERE department_id = depts（j） <span class="bold">RETURNING</span> employee_id，department_id <span class="bold">BULK COLLECT INTO</span> e_ids，d_ids; DBMS_OUTPUT.PUT_LINE（'Deleted'|| SQL％ROWCOUNT ||'rows：'）;为了我在e_ids。FIRST .. e_ids。最后的循环DBMS_OUTPUT.PUT_LINE（'员工＃'|| e_ids（i）||'来自dept＃'|| d_ids（i））;结束循环;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">删除了9行：员工＃200来自部门＃10员工＃201来自部门＃20员工＃202来自部门＃20员工＃114来自部门＃30员工＃115来自部门＃30员工＃116来自部门＃30员工＃117来自部门＃30员工＃118来自部门＃30员工＃119来自部门＃30</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-D67D19A6-4717-4556-B027-15C3DED0519A__BABDCEBE">
                        <p class="titleinexample">示例12-27在FOR LOOP语句中使用RETURN BULK收集DELETE DELETE</p><pre class="oac_no_warn" dir="ltr">DECLARE TYPE NumList是数字表; depts NumList：= NumList（10,20,30）; TYPE enum_t IS TABLE OF employees.employee_id％TYPE; e_ids enum_t; TYPE dept_t IS TABLE OF employees.department_id％TYPE; d_ids dept_t;开始<span class="bold">为</span> j IN depts。FIRST..depts。最后一次<span class="bold">循环</span>从emp_temp删除WHERE department_id = depts（j） <span class="bold">RETURNING</span> employee_id，department_id <span class="bold">BULK COLLECT INTO</span> e_ids，d_ids;结束循环; DBMS_OUTPUT.PUT_LINE（'Deleted'|| SQL％ROWCOUNT ||'rows：'）;为了我在e_ids。FIRST .. e_ids。最后的循环DBMS_OUTPUT.PUT_LINE（'员工＃'|| e_ids（i）||'来自dept＃'|| d_ids（i））;结束循环;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">删除了6行：员工＃114来自部门＃30员工＃115来自部门＃30员工＃116来自部门＃30员工＃117来自部门＃30员工＃118来自部门＃30员工＃119来自部门＃30</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="LNPLS807"></a><a id="LNPLS903"></a><div class="props_rev_3"><a id="GUID-14F071C6-C0AE-4D39-803F-420840FD34AB" name="GUID-14F071C6-C0AE-4D39-803F-420840FD34AB"></a><h4 id="LNPLS-GUID-14F071C6-C0AE-4D39-803F-420840FD34AB" class="sect4"><span class="enumeration_section">12.4.4</span>主机阵列的客户端批量绑定</h4>
                  <div>
                     <p>客户端程序（例如OCI和Pro * C程序）可以使用PL / SQL匿名块来批量绑定输入和输出主机阵列。这是将集合传入和传出数据库服务器的最有效方法。</p>
                     <p>在客户端程序中，声明并将值分配给要在匿名块中引用的主机变量。在匿名块中，使用冒号（:)为每个主机变量名称添加前缀，以将其与PL / SQL集合变量名称区分开来。当客户端程序运行时，数据库服务器运行PL / SQL匿名块。</p>
                     <p>在<a href="plsql-optimization-and-tuning.html#GUID-14F071C6-C0AE-4D39-803F-420840FD34AB__BABJFFFB">例12-28中</a> ，匿名块使用<code class="codeph">FORALL</code>语句批量绑定主机输入数组。在<code class="codeph">FORALL</code>语句中， <code class="codeph">DELETE</code>语句引用四个主变量：scalars <code class="codeph">lower</code> ， <code class="codeph">upper</code>和<code class="codeph">emp_id</code>以及array <code class="codeph">depts</code> 。
                     </p>
                     <div class="example" id="GUID-14F071C6-C0AE-4D39-803F-420840FD34AB__BABJFFFB">
                        <p class="titleinexample">例12-28匿名块批量绑定输入主机阵列</p><pre class="oac_no_warn" dir="ltr">BEGIN FORALL i IN <span class="bold">：lower</span> .. <span class="bold">：upper</span> DELETE FROM employees WHERE department_id = <span class="bold">：depts</span> （i）;结束; /</pre></div>
                     <!-- class="example" -->
                  </div>
               </div>
            </div><a id="LNPLS808"></a><a id="LNPLS01210"></a><div class="props_rev_3"><a id="GUID-ED557894-EC08-47E0-A629-0E4AEDDBB77B" name="GUID-ED557894-EC08-47E0-A629-0E4AEDDBB77B"></a><h3 id="LNPLS-GUID-ED557894-EC08-47E0-A629-0E4AEDDBB77B" class="sect3"><span class="enumeration_section">12.5</span>链接用于多个转换的流水线表函数</h3>
               <div>
                  <div class="section">
                     <p>链接流水线表函数是对数据执行多个转换的有效方法。</p>
                     <div class="infoboxnote" id="GUID-ED557894-EC08-47E0-A629-0E4AEDDBB77B__GUID-9AFBBB9C-B647-498E-8EE7-8148D76636C9">
                        <p class="notep1">注意：</p>
                        <p>您无法在数据库链接上运行管道化表函数。原因是流水线表函数的返回类型是SQL用户定义的类型，只能在单个数据库中使用（如<a href="../adobj/Sql-object-types-and-references.html#ADOBJ7083" target="_blank"><span class="italic">Oracle数据库对象关系开发人员指南中所述</span></a> ）。虽然流水线表函数的返回类型可能看起来是PL / SQL类型，但数据库实际上将该PL / SQL类型转换为相应的SQL用户定义类型。
                        </p>
                     </div>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-ED557894-EC08-47E0-A629-0E4AEDDBB77B__GUID-D3676553-6971-4826-A7F8-C1FFAFB9C597">话题</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="plsql-optimization-and-tuning.html#GUID-4E10CBFA-4B6A-4761-8905-83C26C112694" title="表函数是用户定义的PL / SQL函数，它返回行的集合（关联数组，嵌套表或varray）。">表函数概述</a></p>
                        </li>
                        <li>
                           <p><a href="plsql-optimization-and-tuning.html#GUID-58D850B2-A416-47EA-8803-8936E2D6748A">创建流水线表函数</a></p>
                        </li>
                        <li>
                           <p><a href="plsql-optimization-and-tuning.html#GUID-6C5DE334-7A63-41A3-BB4C-7B32CBF5607E">流水线表函数作为转换函数</a></p>
                        </li>
                        <li>
                           <p><a href="plsql-optimization-and-tuning.html#GUID-F99730AD-EBF2-4BD6-B63D-BFEFBF569A1E">链接流水线表功能</a></p>
                        </li>
                        <li>
                           <p><a href="plsql-optimization-and-tuning.html#GUID-66AF0686-5781-4BCB-B067-6F03BA9B23AE">从流水线表函数的结果中获取</a></p>
                        </li>
                        <li>
                           <p><a href="plsql-optimization-and-tuning.html#GUID-BC13A2D1-A182-46C7-A3DC-959724DD5BD6">将CURSOR表达式传递给流水线表函数</a></p>
                        </li>
                        <li>
                           <p><a href="plsql-optimization-and-tuning.html#GUID-4903A047-B1E7-4654-A842-630E9EDFDF14">流水线表函数结果的DML语句</a></p>
                        </li>
                        <li>
                           <p><a href="plsql-optimization-and-tuning.html#GUID-4B0E1C6B-8C73-4905-9E97-37C2667D2184">NO_DATA_NEEDED异常</a></p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
               </div><a id="LNPLS915"></a><div class="props_rev_3"><a id="GUID-4E10CBFA-4B6A-4761-8905-83C26C112694" name="GUID-4E10CBFA-4B6A-4761-8905-83C26C112694"></a><h4 id="LNPLS-GUID-4E10CBFA-4B6A-4761-8905-83C26C112694" class="sect4"><span class="enumeration_section">12.5.1</span>表函数概述</h4>
                  <div>
                     <p><span class="bold">表函数</span>是用户定义的PL / SQL函数，它返回行的集合（关联数组，嵌套表或varray）。
                     </p>
                     <p>通过在<code class="codeph">SELECT</code>语句中调用<code class="codeph">TABLE</code>子句中的表函数，可以从此集合中进行选择，就像它是数据库表一样。TABLE运算符是可选的。
                     </p>
                     <p>例如：</p><pre class="oac_no_warn" dir="ltr">SELECT * FROM TABLE（ <span class="italic">table_function_name</span> （ <span class="italic">parameter_list</span> ））</pre><p>或者，可以在没有TABLE运算符的情况下编写相同的查询，如下所示：</p><pre class="oac_no_warn" dir="ltr">SELECT * FROM <span class="italic">table_function_name</span> （ <span class="italic">parameter_list</span> ）</pre><p>表函数可以将行的集合作为输入（也就是说，它可以具有作为嵌套表，varray或游标变量的输入参数）。因此，表函数<code class="codeph">tf1</code>输出可以输入到表函数<code class="codeph">tf2</code> ，并且从<code class="codeph">tf2</code>输出可以输入到表函数<code class="codeph">tf3</code> ，依此类推。
                     </p>
                     <p>要提高表函数的性能，您可以：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>使用<code class="codeph">PARALLEL_ENABLE</code>选项启用并行执行功能。
                           </p>
                           <p>启用并行执行的函数可以并发运行。</p>
                        </li>
                        <li>
                           <p>使用Oracle Streams将函数结果直接传递到下一个进程。</p>
                           <p>流式传输消除了进程之间的中间分段。</p>
                        </li>
                        <li>
                           <p>使用<code class="codeph">PIPELINED</code>选项管道功能结果。
                           </p>
                           <p><span class="bold">流水线表函数</span>在处理该行后立即向其调用者返回一行并继续处理行。响应时间得到改善，因为在查询返回单个结果行之前，无需构造整个集合并将其返回到服务器。（此外，该函数需要更少的内存，因为对象缓存不需要实现整个集合。）
                           </p>
                           <div class="infoboxnote" id="GUID-4E10CBFA-4B6A-4761-8905-83C26C112694__GUID-7C0FFF2A-FA95-413F-83E4-15C34A108D99">
                              <p class="notep1">警告：</p>
                              <p>流水线表函数始终引用数据的当前状态。如果在光标打开集合后集合中的数据发生更改，则光标会反映更改。PL / SQL变量是会话专用的，不是事务性的。因此，读取一致性（因其对表数据的适用性而众所周知）不适用于PL / SQL集合变量。</p>
                           </div>
                        </li>
                     </ul>
                     <div class="infoboxnotealso" id="GUID-4E10CBFA-4B6A-4761-8905-83C26C112694__GUID-959E1FAE-503A-4A95-8D3E-4E8AC64A34BA">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="plsql-optimization-and-tuning.html#GUID-F99730AD-EBF2-4BD6-B63D-BFEFBF569A1E">链接流水线表功能</a></p>
                           </li>
                           <li>
                              <p>有关<code class="codeph">SELECT</code>语句的<code class="codeph">TABLE</code>子句的更多信息，请<a href="../sqlrf/SELECT.html#SQLRF55241" target="_blank"><span class="italic">参见Oracle数据库SQL语言参考</span></a></p>
                           </li>
                           <li>
                              <p>有关使用流水线和并行表函数的信息，请<a href="../addci/using-pipelined-and-parallel-table-functions.html#ADDCI2140" target="_blank"><span class="italic">参见Oracle数据库数据盒开发人员指南</span></a></p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="LNPLS812"></a><a id="LNPLS814"></a><a id="LNPLS815"></a><a id="LNPLS817"></a><a id="LNPLS818"></a><a id="LNPLS819"></a><a id="LNPLS820"></a><a id="LNPLS821"></a><a id="LNPLS822"></a><a id="LNPLS917"></a><a id="LNPLS916"></a><div class="props_rev_3"><a id="GUID-58D850B2-A416-47EA-8803-8936E2D6748A" name="GUID-58D850B2-A416-47EA-8803-8936E2D6748A"></a><h4 id="LNPLS-GUID-58D850B2-A416-47EA-8803-8936E2D6748A" class="sect4"><span class="enumeration_section">12.5.2</span>创建流水线表功能</h4>
                  <div>
                     <p>流水线表函数必须是独立函数或包函数。</p>
                     <div class="section">
                        <p class="subhead3" id="GUID-58D850B2-A416-47EA-8803-8936E2D6748A__GUID-41A5E255-6CE6-4C9F-885E-629CDC346391">PIPELINED选项（必填）</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>对于独立函数，请在<code class="codeph">CREATE</code> <code class="codeph">FUNCTION</code>语句中指定<code class="codeph">PIPELINED</code>选项（有关语法，请参阅<span class="q">“ <a href="CREATE-FUNCTION-statement.html#GUID-B71BC5BD-B87C-4054-AAA5-213E856651F2" title="CREATE FUNCTION语句创建或替换独立函数或调用规范。">CREATE FUNCTION语句</a> ”</span> ）。对于包函数，在函数声明和函数定义中指定<code class="codeph">PIPELINED</code>选项（有关语法，请参阅<span class="q">“ <a href="function-declaration-and-definition.html#GUID-4E19FB09-46B5-4CE5-8A5B-CD815C29DA1C" title="在调用函数之前，必须声明并定义它。您可以先声明它（使用function_declaration），然后在同一个块，子程序或包中（使用function_definition）定义它，或者同时声明和定义它（使用function_definition）。">函数声明和定义</a> ”</span> ）。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-58D850B2-A416-47EA-8803-8936E2D6748A__GUID-CA0BC3A1-06BA-4A57-8B43-9877CF7920C9">PARALLEL_ENABLE选项（推荐）</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>要提高其性能，请通过指定<code class="codeph">PARALLEL_ENABLE</code>选项启用流水线表函数以进行并行执行。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-58D850B2-A416-47EA-8803-8936E2D6748A__GUID-C2E6238D-0092-48B3-8AE9-6E376A017B55">自主转移语用</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>如果流水线表函数运行DML语句，则使用<code class="codeph">AUTONOMOUS_TRANSACTION</code>编译指示使其自治（在<span class="q">“ <a href="AUTONOMOUS_TRANSACTION-pragma.html#GUID-AD33D949-081B-4CD3-A240-C29773E908C3" title="The AUTONOMOUS_TRANSACTION pragma marks a routine as autonomous; that is, independent of the main transaction.">AUTONOMOUS_TRANSACTION Pragma</a> ”</span>中<span class="q"><a href="AUTONOMOUS_TRANSACTION-pragma.html#GUID-AD33D949-081B-4CD3-A240-C29773E908C3" title="AUTONOMOUS_TRANSACTION编译指示将例程标记为自治;也就是说，独立于主要交易。">描述</a></span> ）。然后，在并行执行期间，函数的每个实例都会创建一个独立的事务。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-58D850B2-A416-47EA-8803-8936E2D6748A__GUID-495A9DF1-3DD7-421F-ADF3-64A867141604">DETERMINISTIC选项（推荐）</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>在同一查询或单独查询中多次调用流水线表函数会导致底层实现的多次执行。如果函数是确定性的，请指定<code class="codeph">DETERMINISTIC</code>选项，如<span class="q">“ <a href="DETERMINISTIC-clause.html#GUID-6AECC957-27CC-4334-9F43-0FBE88F92654" title="deterministic选项标记一个返回可预测结果且没有副作用的函数。">DETERMINISTIC子句</a> ”中所述</span> 。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-58D850B2-A416-47EA-8803-8936E2D6748A__GUID-78C71E9A-32AB-4423-848A-B085420AB9B7">参数</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>通常，流水线表函数具有一个或多个游标变量参数。有关光标变量作为函数参数的信息，请参见<span class="q">“ <a href="static-sql.html#GUID-9713DFC2-3C2E-49B2-922F-02D43F9D0619" title="您可以使用游标变量作为子程序参数，这使得它可以在子程序之间传递查询结果。">光标变量作为子程序参数</a> ”</span> 。
                        </p>
                        <div class="infoboxnotealso" id="GUID-58D850B2-A416-47EA-8803-8936E2D6748A__GUID-99E1FA89-3D24-490D-B2A6-9B019685B4A2">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>有关游标变量的一般信息，请参见<span class="q">“ <a href="static-sql.html#GUID-4A6E054A-4002-418D-A1CA-DE849CD7E6D5" title="要创建游标变量，请声明预定义类型SYS_REFCURSOR的变量或定义REF CURSOR类型，然后声明该类型的变量。打开游标变量后，可以使用FETCH语句获取查询结果集的行。您可以为PL / SQL游标变量分配另一个PL / SQL游标变量或主机游标变量的值。与游标变量关联的查询可以引用其范围中的任何变量。您可以使用游标变量作为子程序参数，这使得它可以在子程序之间传递查询结果。您可以将游标变量用作主变量，这使得在PL / SQL存储的子程序及其客户端之间传递查询结果非常有用。">游标变量</a> ”</span></p>
                              </li>
                              <li>
                                 <p><span class="q">“ <a href="plsql-subprograms.html#GUID-C0397690-70F4-480D-ADC9-02D277DAA1BB">子程序参数</a> ”</span> ，了解有关子程序参数的一般信息</p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-58D850B2-A416-47EA-8803-8936E2D6748A__GUID-77C6682E-71FE-4AB6-B50D-BC33EFE6E3EE">返回数据类型</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>流水线表函数返回的值的数据类型必须是在模式级别或包内定义的集合类型（因此，它不能是关联数组类型）。集合类型的元素必须是SQL数据类型，而不是PL / SQL支持的数据类型（例如<code class="codeph">PLS_INTEGER</code>和<code class="codeph">BOOLEAN</code> ）。有关集合类型的信息，请参阅<span class="q">“ <a href="plsql-collections-and-records.html#GUID-7E9034D5-0D33-43A1-9012-918350FE148C" title="PL / SQL有三种集合类型 - 关联数组，VARRAY（可变大小数组）和嵌套表。">集合类型</a> ”</span> 。有关SQL数据类型的信息，请参见<a href="../sqlrf/Basic-Elements-of-Oracle-SQL.html#SQLRF002" target="_blank"><span class="italic">Oracle数据库SQL语言参考</span></a> 。
                        </p>
                        <p>您可以使用SQL数据类型<code class="codeph">ANYTYPE</code> ， <code class="codeph">ANYDATA</code>和<code class="codeph">ANYDATASET</code>来动态地封装和访问任何其他SQL类型的类型描述，数据实例和数据实例集，包括对象和集合类型。您还可以使用这些类型来创建未命名的类型，包括匿名集合类型。有关这些类型的信息，请参阅<a href="../arpls/DBMS_TYPES.html#ARPLS076" target="_blank"><span class="italic">Oracle Database PL / SQL包和类型参考</span></a> 。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-58D850B2-A416-47EA-8803-8936E2D6748A__GUID-378C1F09-915F-4470-B275-C5F6398396D5">PIPE ROW声明</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>在流水线表函数内部，使用<code class="codeph">PIPE</code> <code class="codeph">ROW</code>语句将一个集合元素返回给调用者，而不将控制权返回给调用者。有关其语法和语义，请参阅<span class="q">“ <a href="PIPE-ROW-statement.html#GUID-AD2713A9-062A-42DD-B49E-804C6120378B" title="PIPE ROW语句只能出现在流水线表函数的主体中，它会向函数的调用者返回一个表行（但不是控件）。">PIPE ROW语句</a> ”</span> 。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-58D850B2-A416-47EA-8803-8936E2D6748A__GUID-4EF5A313-685A-41FA-ABEE-B3AC8FE583B9">返回声明</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>与每个函数一样，流水线表函数中的每个执行路径都必须生成一个<code class="codeph">RETURN</code>语句，该语句将控制返回给调用者。但是，在流水线表函数中， <code class="codeph">RETURN</code>语句不需要向调用者返回值。有关其语法和语义，请参阅<span class="q">“ <a href="RETURN-statement.html#GUID-2DCDD1F2-041A-479C-A2F8-B3B68F50FE5D" title="RETURN语句立即结束子程序或包含它的匿名块的执行。">RETURN语句</a> ”</span> 。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-58D850B2-A416-47EA-8803-8936E2D6748A__GUID-3F621E40-EBFE-45E3-82B0-D9BBAF013C08">例</p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-58D850B2-A416-47EA-8803-8936E2D6748A__BABDGCDH">
                        <p class="titleinexample">示例12-29创建和调用流水线表函数</p>
                        <p>此示例创建一个包含流水线表函数<code class="codeph">f1</code>的包，然后从<code class="codeph">f1</code>返回的行集合中进行选择。
                        </p><pre class="oac_no_warn" dir="ltr">创建或替换包装pkg1 AUTHID DEFINER类型numset_t是数字表; <span class="bold">功能f1（x NUMBER）RETURN numset_t PIPELINED;</span>结束pkg1; /</pre><p>创建一个流水线表函数f1，它返回一组元素（1,2,3，... x）。</p><pre class="oac_no_warn" dir="ltr">创建或替换包装体pkg1作为<span class="bold">功能f1（x NUMBER）返回numset_t管道开始于</span> i IN 1..x循环<span class="bold">管道（i）;</span>结束循环; <span class="bold">返回;</span> END f1;结束pkg1;</pre><pre class="oac_no_warn" dir="ltr">SELECT * FROM <span class="bold">TABLE（pkg1.f1（5）</span> ）;</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">COLUMN_VALUE ------------ 1 2 3 4 5 5行选中。</pre><pre class="oac_no_warn" dir="ltr">SELECT * FROM <span class="bold">pkg1.f1（2）</span> ;</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">COLUMN_VALUE ------------ 1 2</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="LNPLS919"></a><a id="LNPLS918"></a><div class="props_rev_3"><a id="GUID-6C5DE334-7A63-41A3-BB4C-7B32CBF5607E" name="GUID-6C5DE334-7A63-41A3-BB4C-7B32CBF5607E"></a><h4 id="LNPLS-GUID-6C5DE334-7A63-41A3-BB4C-7B32CBF5607E" class="sect4"><span class="enumeration_section">12.5.3</span>流水线表函数作为转换函数</h4>
                  <div>
                     <p>具有游标变量参数的流水线表函数可以用作变换函数。使用游标变量，该函数获取输入行。使用<code class="codeph">PIPE</code> <code class="codeph">ROW</code>语句，该函数将转换后的行管道传递给调用者。如果<code class="codeph">FETCH</code>和<code class="codeph">PIPE</code> <code class="codeph">ROW</code>语句在<code class="codeph">LOOP</code>语句内，则该函数可以转换多个输入行。
                     </p>
                     <p>在<a href="plsql-optimization-and-tuning.html#GUID-6C5DE334-7A63-41A3-BB4C-7B32CBF5607E__BABIEICA">例12-30中</a> ，流水线表函数将<code class="codeph">employees</code>表的每个选定行转换为两个嵌套表行，它们将管道传递给调用它的<code class="codeph">SELECT</code>语句。对应于正式游标变量参数的实际参数是<code class="codeph">CURSOR</code>表达式;有关这些的信息，请参阅<span class="q">“将<a href="plsql-optimization-and-tuning.html#GUID-BC13A2D1-A182-46C7-A3DC-959724DD5BD6">CURSOR表达式传递给流水线表函数</a> ”</span> 。
                     </p>
                     <div class="example" id="GUID-6C5DE334-7A63-41A3-BB4C-7B32CBF5607E__BABIEICA">
                        <p class="titleinexample">例12-30流水线表函数将每行转换为两行</p><pre class="oac_no_warn" dir="ltr">创建或替换包装refcur_pkg AUTHID DEFINER是TYPE refcur_t是REF CURSOR RETURN员工％ROWTYPE; TYPE outrec_typ IS RECORD（var_num NUMBER（6），var_char1 VARCHAR2（30），var_char2 VARCHAR2（30））; TYPE outrecset IS TABLE OF outrec_typ;功能f_trans（p refcur_t）RETURN outrecset PIPELINED; END refcur_pkg; / CREATE OR REPLACE PACKAGE BODY refcur_pkg IS <span class="bold">FUNCTION f_trans（p refcur_t）RETURN outrecset PIPELINED IS</span> out_rec outrec_typ; in_rec p％ROWTYPE; BEGIN LOOP <span class="bold">FETCH p INTO in_rec; -</span>当p％NOTFOUND时<span class="bold">输入行</span> EXIT; out_rec.var_num：= in_rec.employee_id; out_rec.var_char1：= in_rec.first_name; out_rec.var_char2：= in_rec.last_name; <span class="bold">PIPE ROW（out_rec）; - 第一个转换输出行</span> out_rec.var_char1：= in_rec.email; out_rec.var_char2：= in_rec.phone_number; <span class="bold">PIPE ROW（out_rec）; - 第二次变换输出行</span> END LOOP;关闭p;返回; END f_trans; END refcur_pkg; / SELECT * FROM <span class="bold">TABLE（</span> <span class="bold">refcur_pkg.f_trans（</span> <span class="bold">CURSOR（SELECT * FROM employees WHERE department_id = 60）</span> <span class="bold">）</span> ）;</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">VAR_NUM VAR_CHAR1 VAR_CHAR2 ---------- ------------------------------ ------- ----------------------- 103 Alexander Hunold 103 AHUNOLD 590.423.4567 104 Bruce Ernst 104 BERNST 590.423.4568 105 David Austin 105 DAUSTIN 590.423.4569 106 Valli Pataballa 106 VPATABAL 590.423.4560 107 Diana Lorentz 107 DLORENTZ 590.423.5567选择10行。</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="LNPLS921"></a><div class="props_rev_3"><a id="GUID-F99730AD-EBF2-4BD6-B63D-BFEFBF569A1E" name="GUID-F99730AD-EBF2-4BD6-B63D-BFEFBF569A1E"></a><h4 id="LNPLS-GUID-F99730AD-EBF2-4BD6-B63D-BFEFBF569A1E" class="sect4"><span class="enumeration_section">12.5.4</span>链接流水线表功能</h4>
                  <div>
                     <div class="section">
                        <p>到<span class="bold">链</span>流水线表函数<code class="codeph">tf1</code>和<code class="codeph">tf2</code>是使输出<code class="codeph">tf1</code>的输入<code class="codeph">tf2</code> 。例如：</p><pre class="oac_no_warn" dir="ltr">SELECT * FROM TABLE（tf2（CURSOR（SELECT * FROM TABLE（tf1（）））））;</pre><p>该行<code class="codeph">tf1</code>管出来必须是正规输入参数兼容的实际参数<code class="codeph">tf2</code> 。
                        </p>
                        <p>如果为并行执行启用了链接流水线表函数，则每个函数都在不同的进程（或一组进程）中运行。</p>
                        <div class="infoboxnotealso" id="GUID-F99730AD-EBF2-4BD6-B63D-BFEFBF569A1E__GUID-FB6C185F-0FEB-41AC-9956-839D8AE69926">
                           <p class="notep1">也可以看看：</p>
                           <p><span class="q">“将<a href="plsql-optimization-and-tuning.html#GUID-BC13A2D1-A182-46C7-A3DC-959724DD5BD6">CURSOR表达式传递给流水线表函数</a> ”</span></p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPLS823"></a><a id="LNPLS923"></a><div class="props_rev_3"><a id="GUID-66AF0686-5781-4BCB-B067-6F03BA9B23AE" name="GUID-66AF0686-5781-4BCB-B067-6F03BA9B23AE"></a><h4 id="LNPLS-GUID-66AF0686-5781-4BCB-B067-6F03BA9B23AE" class="sect4"><span class="enumeration_section">12.5.5</span>从流水线表函数的结果中获取</h4>
                  <div>
                     <div class="section">
                        <p>您可以将命名游标与调用管道化表函数的查询相关联。这样的游标没有特殊的获取语义，这样的游标变量没有特殊的赋值语义。</p>
                        <p>但是，SQL优化器不会跨PL / SQL语句进行优化。因此，在<a href="plsql-optimization-and-tuning.html#GUID-66AF0686-5781-4BCB-B067-6F03BA9B23AE__BABFHAIG">例12-31中</a> ，第一个PL / SQL语句比第二个PL / SQL语句慢 - 尽管在第二个PL / SQL语句中运行两个SQL语句的开销，即使函数结果在两个SQL语句之间传递第一个PL / SQL语句。
                        </p>
                        <p>在<a href="plsql-optimization-and-tuning.html#GUID-66AF0686-5781-4BCB-B067-6F03BA9B23AE__BABFHAIG">例12-31中</a> ，假设<code class="codeph">f</code>和<code class="codeph">g</code>是流水线表函数，并且每个函数都接受一个游标变量参数。第一个PL / SQL语句将游标变量<code class="codeph">r</code>与调用<code class="codeph">f</code>的查询相关联，然后将<code class="codeph">r</code>传递给<code class="codeph">g</code> 。第二个PL / SQL语句将<code class="codeph">CURSOR</code>表达式传递给<code class="codeph">f</code>和<code class="codeph">g</code> 。
                        </p>
                        <div class="infoboxnotealso" id="GUID-66AF0686-5781-4BCB-B067-6F03BA9B23AE__GUID-7C858138-7612-4350-8C16-9DBE92636DD1">
                           <p class="notep1">也可以看看：</p>
                           <p><span class="q">“ <a href="static-sql.html#GUID-9713DFC2-3C2E-49B2-922F-02D43F9D0619" title="您可以使用游标变量作为子程序参数，这使得它可以在子程序之间传递查询结果。">光标变量作为子程序参数</a> ”</span></p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-66AF0686-5781-4BCB-B067-6F03BA9B23AE__BABFHAIG">
                        <p class="titleinexample">例12-31从流水线表函数的结果中获取</p><pre class="oac_no_warn" dir="ltr">DECLARE r SYS_REFCURSOR; ...- 第一个PL / SQL语句（较慢）：BEGIN OPEN r FOR SELECT * FROM TABLE（f（CURSOR（SELECT * FROM tab）））; SELECT * BULK COLLECT INTO rec_tab FROM TABLE（g（r））; - 注意：当g完成时，它会关闭r。结束; - 第二个PL / SQL语句（更快）：SELECT * FROM TABLE（g（CURSOR（SELECT * FROM TABLE（f（CURSOR（SELECT * FROM tab））））））; /</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="LNPLS925"></a><a id="LNPLS926"></a><a id="LNPLS924"></a><div class="props_rev_3"><a id="GUID-BC13A2D1-A182-46C7-A3DC-959724DD5BD6" name="GUID-BC13A2D1-A182-46C7-A3DC-959724DD5BD6"></a><h4 id="LNPLS-GUID-BC13A2D1-A182-46C7-A3DC-959724DD5BD6" class="sect4"><span class="enumeration_section">12.5.6将</span> CURSOR表达式传递给流水线表函数</h4>
                  <div>
                     <div class="section">
                        <p>如<a href="plsql-optimization-and-tuning.html#GUID-66AF0686-5781-4BCB-B067-6F03BA9B23AE__BABFHAIG">例12-31</a>所示，流水线表函数的游标变量参数的实际参数可以是游标变量或<code class="codeph">CURSOR</code>表达式，后者更有效。
                        </p>
                        <div class="infoboxnote" id="GUID-BC13A2D1-A182-46C7-A3DC-959724DD5BD6__GUID-9BA2A27B-49BF-49D7-82FC-ED63B7ED46B5">
                           <p class="notep1">注意：</p>
                           <p>当SQL <code class="codeph">SELECT</code>语句将<code class="codeph">CURSOR</code>表达式传递给函数时，引用的游标在函数开始运行时打开，在函数完成时关闭。
                           </p>
                        </div>
                        <div class="infoboxnotealso" id="GUID-BC13A2D1-A182-46C7-A3DC-959724DD5BD6__GUID-D8856691-7B0F-4AAE-8CA6-D3367D9BADB4">
                           <p class="notep1">也可以看看：</p>
                           <p>有关<code class="codeph">CURSOR</code>表达式的一般信息的<span class="q">“ <a href="static-sql.html#GUID-77FF2850-F338-4C77-9577-0FE3399D39BA" title="CURSOR表达式返回嵌套游标。">CURSOR表达式</a> ”</span></p>
                        </div>
                        <p><a href="plsql-optimization-and-tuning.html#GUID-BC13A2D1-A182-46C7-A3DC-959724DD5BD6__BABEIAIG">例12-32</a>创建一个包，其中包含带有两个游标变量参数的流水线表函数，然后使用<code class="codeph">CURSOR</code>表达式为实际参数调用<code class="codeph">SELECT</code>语句中的函数。
                        </p>
                        <p><a href="plsql-optimization-and-tuning.html#GUID-BC13A2D1-A182-46C7-A3DC-959724DD5BD6__BABEEIHA">例12-33</a>使用流水线表函数作为聚合函数，它接受一组输入行并返回单个结果。<code class="codeph">SELECT</code>语句选择函数结果。（有关伪列<code class="codeph">COLUMN_VALUE</code> ，请参阅<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/lnpls&amp;id=SQLRF50950" target="_blank"><span class="italic">Oracle数据库SQL语言参考</span></a> 。）
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-BC13A2D1-A182-46C7-A3DC-959724DD5BD6__BABEIAIG">
                        <p class="titleinexample">例12-32具有两个游标变量参数的流水线表函数</p><pre class="oac_no_warn" dir="ltr">创建或替换包装refcur_pkg AUTHID DEFINER是TYPE类型refcur_t1是REF CURSOR RETURN员工％ROWTYPE; TYPE refcur_t2是REF CURSOR RETURN部门％ROWTYPE; TYPE outrec_typ IS RECORD（var_num NUMBER（6），var_char1 VARCHAR2（30），var_char2 VARCHAR2（30））; TYPE outrecset IS TABLE OF outrec_typ; <span class="bold">功能g_trans（p1 refcur_t1，p2 refcur_t2）RETURN outrecset PIPELINED;</span> END refcur_pkg; /</pre><pre class="oac_no_warn" dir="ltr">CREATE PACKAGE BODY refcur_pkg IS FUNCTION g_trans（p1 refcur_t1，p2 refcur_t2）RETURN outrecset PIPELINED IS out_rec outrec_typ; in_rec1 p1％ROWTYPE; in_rec2 p2％ROWTYPE; BEGIN LOOP FETCH p2 INTO in_rec2;退出时p2％未找到;结束循环;关闭p2; LOOP FETCH p1 INTO in_rec1;当p1％未找到时退出; - 第一行out_rec.var_num：= in_rec1.employee_id; out_rec.var_char1：= in_rec1.first_name; out_rec.var_char2：= in_rec1.last_name; PIPE ROW（out_rec）; - 第二行out_rec.var_num：= in_rec2.department_id; out_rec.var_char1：= in_rec2.department_name; out_rec.var_char2：= TO_CHAR（in_rec2.location_id）; PIPE ROW（out_rec）;结束循环;关闭p1;返回;结束g_trans; END refcur_pkg; /</pre><pre class="oac_no_warn" dir="ltr">SELECT * FROM TABLE（refcur_pkg.g_trans（ <span class="bold">CURSOR（SELECT * FROM employees WHERE department_id = 60）</span> ， <span class="bold">CURSOR（SELECT * FROM departments WHERE department_id = 60）</span> ））;</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">VAR_NUM VAR_CHAR1 VAR_CHAR2 ---------- ------------------------------ ------- ----------------------- 103 Alexander Hunold 60 IT 1400 104 Bruce Ernst 60 IT 1400 105 David Austin 60 IT 1400 106 Valli Pataballa 60 IT 1400 107 Diana Lorentz选择60 IT 1400 10行。
</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-BC13A2D1-A182-46C7-A3DC-959724DD5BD6__BABEEIHA">
                        <p class="titleinexample">例12-33流水线表函数作为聚合函数</p><pre class="oac_no_warn" dir="ltr">DROP TABLE等级报告; CREATE TABLE gradereport（学生VARCHAR2（30），主题VARCHAR2（30），权重NUMBER，等级NUMBER）; INSERT INTO年级报告（学生，科目，体重，年级）价值观（'Mark'，'Physics'，4,4）; INSERT INTO年级报告（学生，科目，体重，年级）VALUES（'Mark'，'Chemistry'，4,3）; INSERT INTO年级报告（学生，科目，体重，年级）价值观（'马克'，'数学'，3,3）; INSERT INTO年级报告（学生，科目，体重，年级）价值观（'Mark'，'Economics'，3,4）;</pre><pre class="oac_no_warn" dir="ltr">CREATE PACKAGE pkg_gpa AUTHID DEFINER是类型gpa是数字表; FUNCTION weighted_average（input_values SYS_REFCURSOR）RETURN gpa PIPELINED; END pkg_gpa; CREATE PACKAGE BODY pkg_gpa IS <span class="bold">FUNCTION weighted_average（input_values SYS_REFCURSOR）</span> <span class="bold">RETURN gpa PIPELINED</span>是等级NUMBER;总数：= 0; total_weight NUMBER：= 0;重量NUMBER：= 0; BEGIN <span class="bold">LOOP</span> <span class="bold">FETCH input_values INTO重量，等级;</span> <span class="bold">当input_values％NOTFOUND时退出;</span> total_weight：= total_weight + weight; - 累计加权平均总数：=总+等级*重量;结束循环; <span class="bold">PIPE ROW（总/ total_weight）;</span>返回; - 返回单个结果END weighted_average; END pkg_gpa;</pre><p>此查询显示如何在没有可选TABLE运算符的情况下调用表函数。</p><pre class="oac_no_warn" dir="ltr">选择w。 <span class="bold">column_value</span> “加权结果”FROM pkg_gpa.weighted_average（ <span class="bold">CURSOR（SELECT weight，grade FROM gradereport）</span> ）w;</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">加权结果--------------- 3.5选择1行。</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="LNPLS928"></a><div class="props_rev_3"><a id="GUID-4903A047-B1E7-4654-A842-630E9EDFDF14" name="GUID-4903A047-B1E7-4654-A842-630E9EDFDF14"></a><h4 id="LNPLS-GUID-4903A047-B1E7-4654-A842-630E9EDFDF14" class="sect4"><span class="enumeration_section">12.5.7</span>流水线表函数结果的DML语句</h4>
                  <div>
                     <p>流水线表函数返回的“表”不能是<code class="codeph">DELETE</code> ， <code class="codeph">INSERT</code> ， <code class="codeph">UPDATE</code>或<code class="codeph">MERGE</code>语句的目标表。但是，您可以创建此类表的视图并在视图上创建<code class="codeph">INSTEAD</code> <code class="codeph">OF</code>触发器。有关<code class="codeph">INSTEAD</code> <code class="codeph">OF</code>触发器的信息，请参阅<span class="q">“ <a href="plsql-triggers.html#GUID-9F06D45C-7C60-434E-A597-114A0C445671" title="INSTEAD OF DML触发器是在非编辑视图或非编辑视图的嵌套表列上创建的DML触发器。数据库触发INSTEAD OF触发器而不是运行触发DML语句。">INSTEAD OF DML触发器</a> ”</span> 。
                     </p>
                     <div class="infoboxnotealso" id="GUID-4903A047-B1E7-4654-A842-630E9EDFDF14__GUID-8B394893-91D3-4211-A59B-B0DF29C166DC">
                        <p class="notep1">也可以看看：</p>
                        <p>有关<code class="codeph">CREATE</code> <code class="codeph">VIEW</code>语句的信息，请<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/lnpls&amp;id=SQLRF01504" target="_blank"><span class="italic">参见Oracle数据库SQL语言参考</span></a></p>
                     </div>
                  </div>
               </div><a id="LNPLS824"></a><a id="LNPLS825"></a><a id="LNPLS929"></a><div class="props_rev_3"><a id="GUID-4B0E1C6B-8C73-4905-9E97-37C2667D2184" name="GUID-4B0E1C6B-8C73-4905-9E97-37C2667D2184"></a><h4 id="LNPLS-GUID-4B0E1C6B-8C73-4905-9E97-37C2667D2184" class="sect4"><span class="enumeration_section">12.5.8</span> NO_DATA_NEEDED异常</h4>
                  <div>
                     <p>在两种情况下，您必须了解预定义的异常<code class="codeph">NO_DATA_NEEDED</code> ：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>您在包含<code class="codeph">PIPE</code> <code class="codeph">ROW</code>语句的块中包含<code class="codeph">OTHERS</code>异常处理程序</p>
                        </li>
                        <li>
                           <p>您提供<code class="codeph">PIPE</code> <code class="codeph">ROW</code>语句的代码必须遵循清理过程</p>
                           <p>通常，清理过程会释放代码不再需要的资源。</p>
                        </li>
                     </ul>
                     <p>当流水线表函数的调用者不再需要函数中的行时， <code class="codeph">PIPE</code> <code class="codeph">ROW</code>语句引发<code class="codeph">NO_DATA_NEEDED</code> 。如果流水线表函数不处理<code class="codeph">NO_DATA_NEEDED</code> ，如<a href="plsql-optimization-and-tuning.html#GUID-4B0E1C6B-8C73-4905-9E97-37C2667D2184__CHDEEGJD">例12-34所示</a> ，则函数调用将终止，但调用语句不会终止。如果流水线表函数处理<code class="codeph">NO_DATA_NEEDED</code> ，则其异常处理程序可以释放它不再需要的资源，如<a href="plsql-optimization-and-tuning.html#GUID-4B0E1C6B-8C73-4905-9E97-37C2667D2184__CHDIAFFB">例12-35所示</a> 。
                     </p>
                     <p>在<a href="plsql-optimization-and-tuning.html#GUID-4B0E1C6B-8C73-4905-9E97-37C2667D2184__CHDEEGJD">例12-34中</a> ，流水线表函数<code class="codeph">pipe_rows</code>不处理<code class="codeph">NO_DATA_NEEDED</code>异常。调用<code class="codeph">pipe_rows</code>的<code class="codeph">SELECT</code>语句只需要四行。因此，在第五次调用<code class="codeph">pipe_rows</code>期间， <code class="codeph">PIPE</code> <code class="codeph">ROW</code>语句引发异常<code class="codeph">NO_DATA_NEEDED</code> 。 <code class="codeph">pipe_rows</code>的第五次调用终止，但<code class="codeph">SELECT</code>语句不会终止。
                     </p>
                     <p>如果包含<code class="codeph">PIPE</code> <code class="codeph">ROW</code>语句的块的异常处理部分包含用于处理意外异常的<code class="codeph">OTHERS</code>异常处理程序，则它还必须包含预期的<code class="codeph">NO_DATA_NEEDED</code>异常的异常处理程序。否则， <code class="codeph">OTHERS</code>异常处理程序处理<code class="codeph">NO_DATA_NEEDED</code>异常，将其视为意外错误。以下异常处理程序重新引发<code class="codeph">NO_DATA_NEEDED</code>异常，而不是将其视为不可恢复的错误：</p><pre class="oac_no_warn" dir="ltr"><span class="bold">NO_DATA_NEEDED升起时的</span>异常<span class="bold">;</span>那么其他 - （在此处输入错误记录代码）RAISE_APPLICATION_ERROR（-20000，'致命错误。“）;结束;</pre><p>在<a href="plsql-optimization-and-tuning.html#GUID-4B0E1C6B-8C73-4905-9E97-37C2667D2184__CHDIAFFB">例12-35中</a> ，假设包<code class="codeph">External_Source</code>包含以下公共项：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>过程<code class="codeph">Init</code> ，用于分配和初始化<code class="codeph">Next_Row</code>所需的资源</p>
                        </li>
                        <li>
                           <p>函数<code class="codeph">Next_Row</code> ，当外部源没有更多数据时，返回来自特定外部源的一些数据并引发用户定义的异常<code class="codeph">Done</code> （也是包中的公共项）</p>
                        </li>
                        <li>
                           <p>过程<code class="codeph">Clean_Up</code> ，释放<code class="codeph">Init</code>分配的资源</p>
                        </li>
                     </ul>
                     <p>流水线表函数<code class="codeph">get_external_source_data</code>通过调用<code class="codeph">External_Source.来自外部源的行<code class="codeph">External_Source.Next_Row</code>直到：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>外部源没有更多行。</p>
                           <p>在这种情况下， <code class="codeph">External_Source.Next_Row</code>函数引发用户定义的异常<code class="codeph">External_Source.Done</code> 。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">get_external_source_data</code>需要行。
                           </p>
                           <p>在这种情况下， <code class="codeph">get_external_source_data</code>的<code class="codeph">PIPE</code> <code class="codeph">ROW</code>语句会引发<code class="codeph">NO_DATA_NEEDED</code>异常。
                           </p>
                        </li>
                     </ul>
                     <p>在任何一种情况下， <code class="codeph">get_external_source_data</code>中块<code class="codeph">b</code>中的异常处理程序<code class="codeph">get_external_source_data</code>调用<code class="codeph">External_Source.Clean_Up</code> ，它释放<code class="codeph">Next_Row</code>正在使用的资源。
                     </p>
                     <div class="example" id="GUID-4B0E1C6B-8C73-4905-9E97-37C2667D2184__CHDEEGJD">
                        <p class="titleinexample">示例12-34流水线表函数不处理NO_DATA_NEEDED</p><pre class="oac_no_warn" dir="ltr">创建类型t是数字表/创建或替换功能pipe_rows返回已管道的AUTHID DEFINER是n NUMBER：= 0; BEGIN LOOP n：= n + 1; PIPE ROW（n）;结束循环; END pipe_rows; / SELECT COLUMN_VALUE <span class="bold">FROM TABLE（pipe_rows（））</span> <span class="bold">WHERE ROWNUM &lt;5</span> /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">COLUMN_VALUE ------------ 1 2 3 4选择了4行。
</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-4B0E1C6B-8C73-4905-9E97-37C2667D2184__CHDIAFFB">
                        <p class="titleinexample">例12-35流水线表函数处理NO_DATA_NEEDED</p><pre class="oac_no_warn" dir="ltr">创建或替换功能get_external_source_data返回已启用的AUTHID DEFINER是BEGIN External_Source。在里面（）; - 初始化。&lt;&lt; b &gt;&gt; BEGIN LOOP  - 来自外部源的管道行。PIPE ROW（External_Source。Next_Row（））;结束循环; External_Source时的<span class="bold">异常</span> 。完成那么 - 当没有更多行可用时，External_Source。清理（）; -  清理。当<span class="bold">NO_DATA_NEEDED</span>那么 - 当不再需要行时，External_Source。清理（）; -  清理。提升NO_DATA_NEEDED; - 可选，相当于RETURN。结束b; END get_external_source_data; /</pre></div>
                     <!-- class="example" -->
                  </div>
               </div>
            </div>
            <div class="sect2"><a id="GUID-981102A8-5204-4931-B10A-93486304B184" name="GUID-981102A8-5204-4931-B10A-93486304B184"></a><h3 id="LNPLS-GUID-981102A8-5204-4931-B10A-93486304B184" class="sect3"><span class="enumeration_section">12.6</span>多态表函数概述</h3>
               <div>
                  <p>多态表函数（PTF）是表函数，其操作数可以有多种类型。返回类型由PTF调用参数列表确定。表类型的实际参数通常决定行输出形状，但并非总是如此。</p>
                  <div class="section">
                     <p class="subhead2" id="GUID-981102A8-5204-4931-B10A-93486304B184__GUID-2473DA16-33A6-40AD-83E2-3BF06F9A4ADB">多态表函数简介</p>
                     <p>多态表函数（PTF）是用户定义的函数，可以在SQL查询块的<code class="codeph">FROM</code>子句中调用。它们能够处理在定义时未声明行类型的表，并生成一个结果表，其行类型可能在定义时声明也可能不声明。多态表函数利用动态SQL功能来创建功能强大且复杂的自定义函数。这对于要求具有适用于任意输入表或查询的通用扩展的接口的应用程序非常有用。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p>PTF作者创建了一个定义表的过程机制的接口。PTF作者定义，记录和实施PTF。</p>
                     <p>查询作者只能描述已发布的接口并在查询中调用PTF功能。</p>
                     <p>数据库是PTF指挥。它管理PTF的编译和执行状态。数据库和PTF作者可以看到一系列相关的SQL调用过程，称为PTF组件过程，可能还有其他私有数据（如变量和游标）。</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-981102A8-5204-4931-B10A-93486304B184__GUID-3BCEAF5A-BE45-4307-9E07-A5F9B3C424D7">多态表函数的类型</p>
                     <div class="p">多态表函数类型是根据其形式参数列表语义指定的：<ul style="list-style-type:disc">
                           <li>
                              <p>如果输入<code class="codeph">TABLE</code>参数具有<code class="codeph">Row Semantics</code> ，则输入是单行。
                              </p>
                           </li>
                           <li>
                              <p>如果输入<code class="codeph">TABLE</code>参数具有<code class="codeph">Table Semantics</code> ，则输入是一组行。当从查询中调用<code class="codeph">Table Semantics</code> PTF时，可以选择使用<code class="codeph">PARTITION BY</code>子句或<code class="codeph">ORDER BY</code>子句或两者扩展table参数。
                              </p>
                           </li>
                        </ul>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div>
               <div class="sect3"><a id="GUID-A496E727-7A54-4F6E-9E8E-82DF7558063E" name="GUID-A496E727-7A54-4F6E-9E8E-82DF7558063E"></a><h4 id="LNPLS-GUID-A496E727-7A54-4F6E-9E8E-82DF7558063E" class="sect4"><span class="enumeration_section">12.6.1</span>多态表函数定义</h4>
                  <div>
                     <p>PTF作者定义，记录和实现多态表函数（PTF）。</p>
                     <div class="section">
                        <p>PTF有两部分：</p>
                        <p>1。PL / SQL包，包含PTF实现的客户端接口。</p>
                        <p>2。用于命名PTF及其关联实现包的独立或包函数。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-C18593DB-7A73-441D-A17D-30F54E25937A" name="GUID-C18593DB-7A73-441D-A17D-30F54E25937A"></a><h4 id="LNPLS-GUID-C18593DB-7A73-441D-A17D-30F54E25937A" class="sect4"><span class="enumeration_section">12.6.2</span>多态表功能实现</h4>
                  <div>
                     <p>多态表函数（PTF）实现客户端接口是一组具有固定名称的子程序，每个PTF必须提供这些子程序。</p>
                     <div class="section">
                        <p class="subhead3" id="GUID-C18593DB-7A73-441D-A17D-30F54E25937A__GUID-C066864D-CF61-4C74-9B4F-EBD7DD831421">实现多态表函数的步骤</p>
                        <ol>
                           <li>
                              <p>创建包含<code class="codeph">DESCRIBE</code>函数（必需）和<code class="codeph">OPEN</code> ， <code class="codeph">FETCH_ROWS</code>和<code class="codeph">CLOSE</code>过程（可选）的实现包。
                              </p>
                           </li>
                           <li>
                              <p>创建命名PTF的函数规范。可以在创建包之后在顶层创建该函数，也可以在实现包（在第一步中创建的包）中创建包函数。多态表函数没有函数定义（ <code class="codeph">FUNCTION</code> <code class="codeph">BODY</code> ），该定义封装在关联的实现包中。
                              </p>
                              <p>函数定义指定：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>多态表函数（PTF）名称</p>
                                 </li>
                                 <li>
                                    <p>完全是类型<code class="codeph">TABLE</code>一个正式参数和任何数量的非<code class="codeph">TABLE</code>参数</p>
                                 </li>
                                 <li>
                                    <p>PTF的返回类型为<code class="codeph">TABLE</code></p>
                                 </li>
                                 <li>
                                    <p>PTF函数的类型（ <code class="codeph">row</code>或<code class="codeph">table semantics</code> ）</p>
                                 </li>
                                 <li>
                                    <p>PTF实现包名称</p>
                                 </li>
                              </ul>
                           </li>
                        </ol>
                        <div class="infoboxnotealso" id="GUID-C18593DB-7A73-441D-A17D-30F54E25937A__GUID-3BEB5575-EAAA-436F-9AA3-054F3AD140C7">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>有关<code class="codeph">DESCRIBE</code> Only多态表函数的信息<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/lnpls&amp;id=ARPLS-GUID-6E589F68-6693-42A1-8766-61AF1476DE1C" target="_blank"><span class="italic">，请参见Oracle Database PL / SQL包和类型参考</span></a></p>
                              </li>
                              <li>
                                 <p>有关如何指定PTF实现包和使用<code class="codeph">DBMS_TF</code>实用程序的详细信息，请参阅<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/lnpls&amp;id=ARPLS-GUID-47E8026F-B66B-4F8D-A2E2-D4324AAB2CED" target="_blank"><span class="italic">Oracle数据库PL / SQL包和类型参考</span></a></p>
                              </li>
                              <li>
                                 <p><a href="PIPELINED-clause.html#GUID-FA182210-C68D-4E03-85B9-A6C681099705" title="指示数据库迭代地返回表函数或多态表函数的结果。">PIPELINED子句</a>用于独立或包多态表函数创建语法和语义</p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-4847CB51-6939-44C4-9913-CC3CE13B6730" name="GUID-4847CB51-6939-44C4-9913-CC3CE13B6730"></a><h4 id="LNPLS-GUID-4847CB51-6939-44C4-9913-CC3CE13B6730" class="sect4"><span class="enumeration_section">12.6.3</span>多态表函数调用</h4>
                  <div>
                     <p>通过在SQL查询块的<code class="codeph">FROM</code>子句中指定其名称后跟参数列表来调用多态表函数。
                     </p>
                     <div class="section">
                        <p>PTF参数可以是可以传递给常规表函数的标准标量参数，但PTF可以另外采用表参数。表参数是<code class="codeph">WITH</code>子句查询或<code class="codeph">FROM</code>子句中允许的模式级对象（例如表，视图或表函数）。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-4847CB51-6939-44C4-9913-CC3CE13B6730__GUID-F683BFDF-FF62-42EC-B913-0B86C8346E45">句法</p>
                        <p><span class="italic">table_argument</span> :: = <span class="italic">table</span> [PARTITION BY <span class="italic">column_list</span> ] [ORDER BY <span class="italic">order_column_list</span> ]</p>
                        <p><span class="italic">column_list</span> :: = <span class="italic">identifier</span> | （ <span class="italic">标识符</span> [， <span class="italic">标识符</span> ...]）</p>
                        <p><span class="italic">order_column_list</span> :: = <span class="italic">order_column_name</span> | （ <span class="italic">order_column_name</span> [， <span class="italic">order_column_name</span> ...]）</p>
                        <p><span class="italic">order_column_name</span> :: = <span class="italic">identifier</span> [ASC | DESC] [NULLS FIRST | NULLS LAST]</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-4847CB51-6939-44C4-9913-CC3CE13B6730__GUID-7FD97D62-A820-4435-A826-5EBF40D8AD2F">语义</p>
                        <p>每个标识符都是相应表中的一列。</p>
                        <p>PTF具有<code class="codeph">Table Semantics</code> 。
                        </p>
                        <p>查询可以选择分区和排序<code class="codeph">Table Semantics</code> PTF输入。<code class="codeph">Row Semantics</code> PTF输入不允许这样做。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>多态表函数（PTF）不能是DML语句的目标。PTF的任何表参数都按名称传递。</p>
                        <p>例如，noop PTF可用于查询，例如：</p><pre class="oac_no_warn" dir="ltr">SELECT * FROM noop（emp）;</pre><p>要么</p><pre class="oac_no_warn" dir="ltr">with e AS（SELECT * FROM emp NATURAL JOIN dept）SELECT t。* FROM noop（e）t;</pre><p>输入表参数必须是基本表名。</p>
                        <div class="p">表标识符的名称解析规则（按优先级顺序）如下：<ol>
                              <li>
                                 <p>标识符被解析为列名称（例如来自外部查询块的相关列）。</p>
                              </li>
                              <li>
                                 <p>标识符在当前或某个外部查询块中被解析为公用表表达式（CTE）名称。CTE通常称为<code class="codeph">WITH</code>子句。
                                 </p>
                              </li>
                              <li>
                                 <p>标识符被解析为模式级表，视图或表函数（常规或多态，并在模式级或包内定义）。</p>
                              </li>
                           </ol>
                        </div>
                        <p><code class="codeph">FROM</code>子句中允许的许多类型的表表达式不能直接用作PTF的表参数（例如ANSI连接，绑定变量，内联视图， <code class="codeph">CURSOR</code>运算符， <code class="codeph">TABLE</code>运算符）。要将此类表表达式用作PTF参数，必须通过将这些表表达式包装在CTE中，然后将CTE名称传递到PTF中，将这些表表达式间接传递到PTF中。</p>
                        <p>PTF可以在<code class="codeph">FROM</code>子句中用作表引用，因此可以是ANSI Join和LATERAL语法的一部分。另外，PTF可以是PIVOT / UNPIVOT和MATCH_RECOGNIZE的源表。 PTF不允许使用表格和视图（例如SAMPLING，PARTITION，CONTAINERS）的某些表修改子句。</p>
                        <p>允许直接函数组成PTF（例如嵌套的PTF游标表达式调用或PTF（TF（））嵌套）。但是，不允许嵌套的PTF（例如PTF（PTF（））嵌套）。</p>
                        <p>PTF的标量参数可以是任何SQL标量表达式。当常量标量值按原样传递给<code class="codeph">DESCRIBE</code>函数时，所有其他值都作为NULL传递。如果这些值不是行形状确定，这通常不是PTF实现的问题，否则<code class="codeph">DESCRIBE</code>函数可能引发错误;通常，PTF附带的文档将说明哪些标量参数（如果有）是形状定义，因此必须具有恒定的非空值。请注意，在查询执行期间（在<code class="codeph">OPEN</code> ， <code class="codeph">FETCH_ROWS</code> ， <code class="codeph">CLOSE</code>期间），将计算表达式，并将它们的实际值传递给这些PTF执行过程。返回类型由PTF调用参数列表确定。
                        </p>
                        <p>使用<code class="codeph">WITH</code>子句将查询参数传递给PTF。
                        </p>
                        <p>当表函数参数列表或空列表（）出现时， <code class="codeph">TABLE</code>运算符是可选的。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div class="sect4"><a id="GUID-A3123AB1-E06D-4E00-A856-6052527482CE" name="GUID-A3123AB1-E06D-4E00-A856-6052527482CE"></a><h5 id="LNPLS-GUID-A3123AB1-E06D-4E00-A856-6052527482CE" class="sect5"><span class="enumeration_section">12.6.3.1</span>可变参数伪运算符</h5>
                     <div>
                        <p>可变参数伪运算符使用可变数量的操作数进行操作。</p>
                        <div class="section">
                           <p>从Oracle Database Release 18c开始，我们将可变参数伪运算符的概念引入到SQL表达式语言中，以支持多态表函数（PTF）。伪运算符可用于将标识符列表（例如列名称）传递给PTF。伪运算符只能作为PTF的参数出现，并由SQL编译器像其他SQL运算符或PL / SQL函数调用一样进行解析。伪运算符具有可变数量的参数，但必须至少有一个。伪运算符没有与之关联的任何执行函数，并且在PTF编译完成后它们将完全从SQL游标中删除。在SQL编译期间，伪运算符将转换为相应的DBMS_TF类型，然后传递给<code class="codeph">DESCRIBE</code>方法。没有与这些运算符关联的输出类型。在一般的SQL表达式中嵌入伪运算符是不可能的。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-AB520C25-6735-4E5D-AC01-6237CD32BE17" name="GUID-AB520C25-6735-4E5D-AC01-6237CD32BE17"></a><h5 id="LNPLS-GUID-AB520C25-6735-4E5D-AC01-6237CD32BE17" class="sect5"><span class="enumeration_section">12.6.3.2列</span>伪运算符</h5>
                     <div>
                        <p>您可以使用COLUMNS伪运算符在SQL查询块的FROM子句中指定多态表函数（PTF）调用的参数。</p>
                        <div class="section">
                           <p><code class="codeph">COLUMNS</code>伪运算符参数指定列名列表或具有关联类型的列名列表。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-AB520C25-6735-4E5D-AC01-6237CD32BE17__GUID-6A5AEDBE-F866-415C-B3AC-1C8E305D03F5">句法</p>
                           <p><span class="italic">column_operator</span> :: = COLUMNS（ <span class="italic">column_list</span> ）</p>
                           <p><span class="italic">column_list</span> :: = <span class="italic">column_name_list</span> | <span class="italic">column_type_list</span></p>
                           <p><span class="italic">column_name_list</span> :: = <span class="italic">identifier</span> [， <span class="italic">标识符</span> ......]</p>
                           <p><span class="italic">column_type_list</span> :: = <span class="italic">identifier</span> <span class="italic">column_type</span> [， <span class="italic">identifier</span> <span class="italic">column_type</span> ...]</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-AB520C25-6735-4E5D-AC01-6237CD32BE17__GUID-7EF6F5D9-BB87-4215-B766-FBE4CE6F6D8C">语义</p>
                           <p><code class="codeph">COLUMNS</code>伪运算符只能作为PTF的参数出现。它不能出现在除PTF表达式本身之外的任何其他SQL表达式中。
                           </p>
                           <p><span class="italic">column_type</span>必须是标量类型。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-C0FBB1E4-2D75-4D52-BA85-BCF910AF0DD0" name="GUID-C0FBB1E4-2D75-4D52-BA85-BCF910AF0DD0"></a><h4 id="LNPLS-GUID-C0FBB1E4-2D75-4D52-BA85-BCF910AF0DD0" class="sect4"><span class="enumeration_section">12.6.4</span>多态表函数编译和执行</h4>
                  <div>
                     <p>数据库满足多形表函数（PTF）指挥角色。因此，它负责PTF编译，执行及其相关状态。</p>
                     <div class="section">
                        <div class="p">数据库管理：<ul style="list-style-type:disc">
                              <li>
                                 <p>编译状态：这是<code class="codeph">DESCRIBE</code>生成的不可变状态，在执行之前需要它。
                                 </p>
                              </li>
                              <li>
                                 <p>执行状态：这是<code class="codeph">Table semantics</code> PTF的执行过程使用的状态。</p>
                              </li>
                           </ul>。
                        </div>
                        <div class="infoboxnotealso" id="GUID-C0FBB1E4-2D75-4D52-BA85-BCF910AF0DD0__GUID-FCF7112B-4BA8-48B4-8A91-65C3D74F9A54">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>有关数据库如何管理PTF的编译和执行状态的更多信息，请参阅<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/lnpls&amp;id=ARPLS-GUID-EAC49A1C-F4EB-48C8-B726-A143643A479C" target="_blank"><span class="italic">Oracle数据库PL / SQL包和类型参考</span></a></p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-0999E5D7-EB9B-4DCD-964C-C5F6B278B5DB" name="GUID-0999E5D7-EB9B-4DCD-964C-C5F6B278B5DB"></a><h4 id="LNPLS-GUID-0999E5D7-EB9B-4DCD-964C-C5F6B278B5DB" class="sect4"><span class="enumeration_section">12.6.5</span>多态表功能优化</h4>
                  <div>
                     <p>多态表函数（PTF）提供了一种有效且可扩展的机制来扩展数据库的分析功能。</p>
                     <div class="section">
                        <p>主要好处是：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>最小数据移动：仅将感兴趣的列传递给PTF</p>
                           </li>
                           <li>
                              <p>谓词/预测/分区被推入基础表/查询（在语义上可行）</p>
                           </li>
                           <li>
                              <p>批量数据传入和传出PTF</p>
                           </li>
                           <li>
                              <p>并行性基于PTF的类型和查询指定的分区（如果有的话）</p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-695FBA1A-89EA-45B4-9C81-CA99F6C794A5" name="GUID-695FBA1A-89EA-45B4-9C81-CA99F6C794A5"></a><h4 id="LNPLS-GUID-695FBA1A-89EA-45B4-9C81-CA99F6C794A5" class="sect4"><span class="enumeration_section">12.6.6</span> Skip_col多态表功能示例</h4>
                  <div>
                     <p>此PTF示例演示了行语义，仅描述，包表功能和重载功能。</p>
                     <div class="section">
                        <div class="infoboxnotealso" id="GUID-695FBA1A-89EA-45B4-9C81-CA99F6C794A5__GUID-EA9D7C23-D156-415D-BCF2-37D64CD9835F">
                           <p class="notep1">也可以看看：</p>
                           <p>有关更多多态表函数（PTF）示例的<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/lnpls&amp;id=ARPLS-GUID-2D97C0CD-6AD9-4F86-86E6-C806D688C57A" target="_blank"><span class="italic">Oracle Database PL / SQL包和类型参考</span></a></p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-695FBA1A-89EA-45B4-9C81-CA99F6C794A5__GUID-CFF59A63-42BE-4217-A104-42E41EEABC15">
                        <p class="titleinexample">例12-36 Skip_col多态表功能示例</p>
                        <p>skip_col多态表函数（PTF）返回表中除PTF输入参数中指定的列之外的所有列。skip_col PTF根据列名（重载1）或列数据类型（重载2）跳过列。</p>
                        <div class="infoboxnote" id="GUID-695FBA1A-89EA-45B4-9C81-CA99F6C794A5__GUID-46DC7C38-8CB1-4EAC-B3FE-261F6C048588">
                           <p class="notep1">实时SQL：</p>
                           <p>您可以在<a href="https://livesql.oracle.com/apex/livesql/docs/lnpls/ptf/ptfskpcol.html" target="_blank">18c Skip_col多态表函数的</a> Oracle Live SQL上查看和运行此示例</p>
                        </div>
                        <p>创建名为skip_col_pkg的实现包，其中包含skip_col多态表函数（PTF）的<code class="codeph">DESCRIBE</code>函数。调用<code class="codeph">DESCRIBE</code>函数以确定PTF生成的行形状。它返回一个<code class="codeph">DBMS_TF.DESCRIBE_T</code>表。它超载了。<code class="codeph">FETCH_ROWS</code>过程不是必需的，因为它确实需要为给定的行子集生成关联的新列值。
                        </p><pre class="pre codeblock"><code>CREATE PACKAGE skip_col_pkg AS  -  OVERLOAD 1：按名称跳过 - 功能skip_col（tab TABLE，col COLUMNS）RETURN TABLE PIPLINING ROW POLYMORPHIC使用skip_col_pkg; FUNCTION描述（选项卡IN OUT DBMS_TF.TABLE_T，col DBMS_TF.COLUMNS_T）RETURN DBMS_TF.DESCRIBE_T; -  OVERLOAD 2：按类型跳过 -  FUNCTION skip_col（tab TABLE，type_name VARCHAR2，flip VARCHAR2 DEFAULT'False'）RETURN TABLE PIPLINING ROW POLYMORPHIC使用skip_col_pkg; FUNCTION描述（选项卡IN OUT DBMS_TF.TABLE_T，type_name VARCHAR2，翻转VARCHAR2 DEFAULT'False'）RETURN DBMS_TF.DESCRIBE_T; END skip_col_pkg;</code></pre><p>创建包含多态表函数定义的实现包主体。</p><pre class="pre codeblock"><code>CREATE PACKAGE BODY skip_col_pkg AS / * OVERLOAD 1：按名称跳过*包PTF名称：skip_col_pkg.skip_col *独立PTF名称：skip_col_by_name * * PARAMETERS：* tab  - 输入表* col  - 要从输出中删除的列的名称* *说明：*此PTF从PTF的输出*中删除col中列出的所有输入列。 * / FUNCTION描述（选项卡IN OUT DBMS_TF.TABLE_T，col DBMS_TF.COLUMNS_T）RETURN DBMS_TF.DESCRIBE_T AS new_cols DBMS_TF.COLUMNS_NEW_T; col_id PLS_INTEGER：= 1; BEGIN FOR i IN 1 .. tab.column.count（）LOOP FOR j IN 1 .. col.count（）LOOP tab.column（i）。PASS_THROUGH：= tab.column（i）。DESCRIPTION.NAME！= col（j）;退出时不是tab.column（i）。PASS_THROUGH;结束循环;结束循环;返回NULL;结束; / * OVERLOAD 2：跳过类型*包PTF名称：skip_col_pkg.skip_col *独立PTF名称：skip_col_by_type * * PARAMETERS：* tab  - 输入表* type_name  - 表示要跳过的列类型的字符串* flip  - 'False'[ default] =&gt;匹配给定type_name的列*否则=&gt;忽略给定type_name的列* * DESCRIPTION：*此PTF从给定表中删除给定类型的列。* / FUNCTION描述（选项卡IN OUT DBMS_TF.TABLE_T，type_name VARCHAR2，翻转VARCHAR2 DEFAULT'False'）RETURN DBMS_TF.DESCRIBE_T AS typ CONSTANT VARCHAR2（1024）：= UPPER（TRIM（type_name））; BEGIN FOR i IN 1 .. tab.column.count（）LOOP tab.column（i）。PASS_THROUGH：= CASE UPPER（SUBSTR（翻转，1,1））当'F'那么DBMS_TF.column_type_name（tab.column（i）。描述）！= typ ELSE DBMS_TF.column_type_name（tab.column（i）。DESCRIPTION）= typ END / * case * /;结束循环;返回NULL;结束; END skip_col_pkg;</code></pre><p>为重载1创建名为skip_col_by_name的独立多态表函数。准确指定<code class="codeph">TABLE</code>类型的一个形式参数，将PTF的返回类型指定为<code class="codeph">TABLE</code> ，指定<code class="codeph">Row Semantics</code> PTF类型，并指示要使用的PTF实现包是skip_col_pkg。
                        </p><pre class="pre codeblock"><code>CREATE FUNCTION skip_col_by_name（tab TABLE，col COLUMNS）RETURN TABLE PIPLINING ROW POLYMORPHIC使用skip_col_pkg;</code></pre><p>为重载2创建名为skip_col_by_type的独立多态表函数。准确指定<code class="codeph">TABLE</code>类型的一个形式参数，将PTF的返回类型指定为<code class="codeph">TABLE</code> ，指定<code class="codeph">Row Semantics</code> PTF类型，并指示要使用的PTF实现包是skip_col_pkg。
                        </p><pre class="pre codeblock"><code>CREATE FUNCTION skip_col_by_type（tab TABLE，type_name VARCHAR2，flip VARCHAR2 DEFAULT'False'）RETURN TABLE PIPLINING ROW POLYMORPHIC使用skip_col_pkg;</code></pre><p>调用包skip_col PTF（重载1）以仅从<code class="codeph">SCOTT.DEPT</code>表中报告类型不是<code class="codeph">NUMBER</code>列。</p><pre class="pre codeblock"><code>SELECT * FROM skip_col_pkg.skip_col（scott.dept，'number'）;</code></pre><pre class="oac_no_warn" dir="ltr">DNAME LOC -------------- -------------会计纽约研究达拉斯销售芝加哥运营波士顿</pre><p>通过调用独立的skip_col_by_type PTF来从<code class="codeph">SCOTT.DEPT</code>表中仅报告类型不是<code class="codeph">NUMBER</code>列，可以实现相同的结果。</p><pre class="pre codeblock"><code>SELECT * FROM skip_col_by_type（scott.dept，'number'）;</code></pre><pre class="oac_no_warn" dir="ltr">DNAME LOC -------------- -------------会计纽约研究达拉斯销售芝加哥运营波士顿</pre><p>调用包skip_col PTF（重载2）以仅从<code class="codeph">SCOTT.DEPT</code>表中报告类型为<code class="codeph">NUMBER</code>列。</p><pre class="pre codeblock"><code>SELECT * FROM skip_col_pkg.skip_col（scott.dept，'number'，flip =&gt;'True'）;</code></pre><pre class="oac_no_warn" dir="ltr">DEPTNO ---------- 10 20 30 40</pre><p>通过调用独立的skip_col_by_type PTF来从<code class="codeph">SCOTT.DEPT</code>表中仅报告类型为<code class="codeph">NUMBER</code>列，可以实现相同的结果。</p><pre class="pre codeblock"><code>SELECT * FROM skip_col_by_type（scott.dept，'number'，flip =&gt;'True'）;</code></pre><pre class="oac_no_warn" dir="ltr">DEPTNO ---------- 10 20 30 40</pre><p>调用包skip_col PTF以从<code class="codeph">SCOTT.EMP</code>表报告除了<code class="codeph">COMM</code> ， <code class="codeph">HIREDATE</code>和<code class="codeph">MGR</code>之外的所有列的部门20中的所有员工。</p><pre class="pre codeblock"><code>SELECT * FROM skip_col_pkg.skip_col（scott.emp，COLUMNS（comm，hiredate，mgr））WHERE deptno = 20;</code></pre><pre class="oac_no_warn" dir="ltr">EMPNO ENAME JOB SAL DEPTNO ---------- ---------- --------- ---------- ------ ---- 7369 SMITH CLERK 800 20 7566 JONES MANAGER 2975 20 7788 SCOTT ANALYST 3000 20 7876 ADAMS CLERK 1100 20 7902 FORD ANALYST 3000 20</pre></div>
                     <!-- class="example" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-F8E13DDD-710D-4626-824E-B344849C5AFE" name="GUID-F8E13DDD-710D-4626-824E-B344849C5AFE"></a><h4 id="LNPLS-GUID-F8E13DDD-710D-4626-824E-B344849C5AFE" class="sect4"><span class="enumeration_section">12.6.7</span> To_doc多态表功能示例</h4>
                  <div>
                     <p>to_doc PTF示例将指定列的列表组合到单个文档列中。</p>
                     <div class="example" id="GUID-F8E13DDD-710D-4626-824E-B344849C5AFE__GUID-4DC9A4E9-B1C8-4BB6-9EE9-673C385DDFEA">
                        <p class="titleinexample">例12-37 To_doc多态表功能示例</p>
                        <p>to_doc PTF将列列表组合到像JSON对象一样构造的文档列中。</p>
                        <div class="infoboxnote" id="GUID-F8E13DDD-710D-4626-824E-B344849C5AFE__GUID-ED9A985B-2DAC-4E20-BA49-45DC11ED9242">
                           <p class="notep1">实时SQL：</p>
                           <p>您可以在<a href="https://livesql.oracle.com/apex/livesql/docs/lnpls/ptf/ptftodoc.html" target="_blank">18c To_doc多态表函数的</a> Oracle Live SQL上查看和运行此示例</p>
                        </div>
                        <p>创建包含<code class="codeph">DESCRIBE</code>函数的实现包to_doc_p和to_doc多态表函数（PTF）的<code class="codeph">FETCH_ROWS</code>过程。
                        </p>
                        <div class="p">PTF参数是：<ul style="list-style-type:disc">
                              <li>
                                 <p>tab：输入表（tab参数的类型<code class="codeph">DBMS_TF</code> <code class="codeph">TABLE_T</code> ，表描述符记录类型）</p>
                              </li>
                              <li>
                                 <p>cols（可选）：要转换为文档的列的列表。（该cols参数是类型<code class="codeph">DBMS_TF</code> 。 <code class="codeph">COLUMNS_T</code> ，列描述符记录类型）</p>
                              </li>
                           </ul>
                        </div><pre class="pre codeblock"><code>CREATE PACKAGE to_doc_p AS FUNCTION describe（tab IN OUT DBMS_TF.TABLE_T，cols IN DBMS_TF.COLUMNS_T DEFAULT NULL）RETURN DBMS_TF.DESCRIBE_T;程序fetch_rows; END to_doc_p;</code></pre><p>创建包含<code class="codeph">DESCRIBE</code>函数和<code class="codeph">FETCH_ROWS</code>过程的包。需要<code class="codeph">FETCH_ROWS</code>过程才能在输出行集中生成名为DOCUMENT的新列。<code class="codeph">DESCRIBE</code>函数通过在输入表描述符<code class="codeph">TABLE_T</code>注释它们来指示读取列。只会获取指示的读取列，因此可在<code class="codeph">FETCH_ROWS</code>期间进行处理。查询中的PTF调用可以使用COLUMNS伪运算符来指示查询希望PTF读取哪些列，并将此信息传递给<code class="codeph">DESCRIBE</code>函数，然后<code class="codeph">DESCRIBE</code>函数又设置<code class="codeph">COLUMN_T</code> 。 <code class="codeph">FOR_READ</code>布尔标志。只有标量SQL数据类型才允许读取列。<code class="codeph">COLUMN_T</code> 。 <code class="codeph">PASS_THROUGH</code>布尔标志表示从PTF的输入表传递到输出的列，没有任何修改。
                        </p><pre class="pre codeblock"><code>CREATE PACKAGE BODY to_doc_p AS FUNCTION describe（tab IN OUT DBMS_TF.TABLE_T，cols IN DBMS_TF.COLUMNS_T DEFAULT NULL）RETURN DBMS_TF.DESCRIBE_T AS BEGIN FOR i IN 1 .. tab.column.count LOOP CONTINUE WHEN NOT DBMS_TF.SUPPORTED_TYPE（tab。列（i）中。DESCRIPTION.TYPE）; IF cols IS NULL THEN tab.column（i）。FOR_READ：= TRUE; tab.column（i）中。PASS_THROUGH：= FALSE;继续;万一; FOR j IN 1 .. cols.count LOOP IF（tab.column（i）。DESCRIPTION.NAME = cols（j））那么tab.column（i）。FOR_READ：= TRUE; tab.column（i）中。PASS_THROUGH：= FALSE;万一;结束循环;结束循环; RETURN DBMS_TF.describe_t（new_columns =&gt; DBMS_TF.COLUMNS_NEW_T（1 =&gt; DBMS_TF.COLUMN_METADATA_T（name =&gt;'DOCUMENT'）））;结束;程序fetch_rows AS first DBMS_TF.ROW_SET_T; col DBMS_TF.TAB_VARCHAR2_T; PLS_INTEGER; BEGIN DBMS_TF.GET_ROW_SET（rst，row_count =&gt; rct）; FOR OUT IN 1 .. rct LOOP col（rid）：= DBMS_TF.ROW_TO_CHAR（rst，rid）;结束循环; DBMS_TF.PUT_COL（1，col）;结束; END to_doc_p;</code></pre><p>创建独立的to_doc PTF。准确指定<code class="codeph">TABLE</code>类型的一个形式参数，将PTF的返回类型指定为<code class="codeph">TABLE</code> ，指定行语义PTF类型，并指示要使用的PTF实现包是to_doc_p。
                        </p><pre class="pre codeblock"><code>创建函数to_doc（tab TABLE，cols COLUMNS DEFAULT NULL）返回表使用to_doc_p管道行多态？</code></pre><p>调用to_doc PTF以显示表<code class="codeph">SCOTT</code>所有列。 <code class="codeph">DEPT</code>作为一个组合的<code class="codeph">DOCUMENT</code>列。
                        </p><pre class="pre codeblock"><code>SELECT * FROM to_doc（scott.dept）;</code></pre><pre class="oac_no_warn" dir="ltr">文件------------------------------------------------- -  {“DEPTNO”：10，“DNAME”：“会计”，“LOC”：“纽约”} {“DEPTNO”：20，“DNAME”：“研究”，“LOC”：“达拉斯”} {“ DEPTNO“：30，”DNAME“：”销售“，”LOC“：”芝加哥“} {”DEPTNO“：40，”DNAME“：”操作“，”LOC“：”波士顿“}</pre><p>对于部门10和部门30中的所有员工，显示<code class="codeph">DEPTNO</code>和<code class="codeph">ENAME</code>订购的<code class="codeph">DEPTNO</code> ， <code class="codeph">ENAME</code>和<code class="codeph">DOCUMENT</code>列。使用<code class="codeph">COLUMNS</code>伪运算符调用to_doc PTF以选择表<code class="codeph">SCOTT</code>列<code class="codeph">EMPNO</code> ， <code class="codeph">JOB</code> ， <code class="codeph">MGR</code> ， <code class="codeph">HIREDATE</code> ， <code class="codeph">SAL</code>和<code class="codeph">COMM</code> 。 <code class="codeph">EMP</code> 。PTF将这些列组合到<code class="codeph">DOCUMENT</code>列中。
                        </p><pre class="pre codeblock"><code>SELECT deptno，ename，document FROM to_doc（scott.emp，COLUMNS（empno，job，mgr，hiredate，sal，comm））WHERE deptno IN（10,30）ORDER BY 1,2;</code></pre><pre class="oac_no_warn" dir="ltr">DEPTNO ENAME文件------ ---------- ------------------------------- -------------------------------------------------- 10 CLARK {“EMPNO”：7782，“JOB”：“MANAGER”，“MGR”：7839，“HIREDATE”：“09-JUN-81”，“SAL”：2450} 10 KING {“EMPNO”：7839， “JOB”：“PRESIDENT”，“HIREDATE”：“17-NOV-81”，“SAL”：5000} 10 MILLER {“EMPNO”：7934，“JOB”：“CLERK”，“MGR”：7782，“ HIREDATE“：”23-JAN-82“，”SAL“：1300} 30 ALLEN {”EMPNO“：7499，”JOB“：”SALESMAN“，”MGR“：7698，”HIREDATE“：”20-FEB-81 “，”SAL“：1600，”COMM“：300} 30 BLAKE {”EMPNO“：7698，”JOB“：”MANAGER“，”MGR“：7839，”HIREDATE“：”01-MAY-81“，” SAL“：2850} 30 JAMES {”EMPNO“：7900，”JOB“：”CLERK“，”MGR“：7698，”HIREDATE“：”03-DEC-81“，”SAL“：950} 30 MARTIN {” EMPNO“：7654，”JOB“：”SALESMAN“，”MGR“：7698，”HIREDATE“：”28-SEP-81“，”SAL“：1250，”COMM“：1400} 30 TURNER {”EMPNO“： 7844，“JOB”：“SALESMAN”，“MGR”：7698，“HIREDATE”：“08-SEP-81”，“SAL”：1500，“COMM”：0} 30 WARD {“EMPNO”：7521，“ JOB“：”SALESMAN“，”MGR“：7698，”HIREDATE“：”22-FEB-81“，”SAL“：1250，”COMM“：500}</pre><p>使用名为<code class="codeph">E</code>的子查询，显示<code class="codeph">DOC_ID</code>和<code class="codeph">DOCUMENT</code>列。报告所有职员员工，他们的薪水，部门和部门位置。使用to_doc PTF将<code class="codeph">NAME</code> ， <code class="codeph">SAL</code> ， <code class="codeph">DEPTNO</code>和<code class="codeph">LOC</code>列合并到<code class="codeph">DOCUMENT</code>列中。
                        </p><pre class="pre codeblock"><code>WITH e AS（SELECT ename name，sal，deptno，loc FROM scott.emp NATURAL JOIN scott.dept WHERE job ='CLERK'）SELECT ROWNUM doc_id，t。* FROM to_doc（e）t;</code></pre><pre class="oac_no_warn" dir="ltr">DOC_ID文档---------- -------------------------------------- ----------------- 1 {“NAME”：“MILLER”，“SAL”：1300，“DEPTNO”：10，“LOC”：“NEW YORK”} 2 { “NAME”：“SMITH”，“SAL”：800，“DEPTNO”：20，“LOC”：“DALLAS”} 3 {“NAME”：“ADAMS”，“SAL”：1100，“DEPTNO”：20， “LOC”：“DALLAS”} 4 {“NAME”：“JAMES”，“SAL”：950，“DEPTNO”：30，“LOC”：“CHICAGO”}</pre><p>使用子查询块显示转换为<code class="codeph">DOCUMENT</code>列的c1，c2，c3列值。
                        </p><pre class="pre codeblock"><code>WITH t（c1，c2，c3）AS（SELECT NULL，NULL，NULL FROM双UNION ALL SELECT 1，NULL，NULL FROM双UNION ALL SELECT NULL，2，NULL FROM双UNION ALL SELECT 0，NULL，3 FROM dual） SELECT * FROM to_doc（t）;</code></pre><pre class="oac_no_warn" dir="ltr">文件--------------- {} {“C1”：1} {“C2”：2} {“C1”：0，“C3”：3}</pre><p>对于部门30中的所有员工，显示具有属性名称<code class="codeph">ENAME</code>和<code class="codeph">COMM</code>的成员的值。来自<code class="codeph">SCOTT</code>的PTF调用报告。 <code class="codeph">EMP</code>表生成<code class="codeph">DOCUMENT</code>列，可用作<code class="codeph">JSON_VALUE</code>函数的输入。此函数从某些JSON数据中选择标量值。
                        </p><pre class="pre codeblock"><code>SELECT JSON_VALUE（document，'$。ENAME'）ename，JSON_VALUE（文件，'$。COMM'）comm FROM to_doc（scott.emp）WHERE JSON_VALUE（document，'$。DEPTNO'）= 30;</code></pre><pre class="oac_no_warn" dir="ltr">ENAME COMM ---------- ---- ALLEN 300 WARD 500 MARTIN 1400 BLAKE TURNER 0 JAMES</pre></div>
                     <!-- class="example" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-CF5859FE-4938-4EBF-BE5F-A7C857B77B8C" name="GUID-CF5859FE-4938-4EBF-BE5F-A7C857B77B8C"></a><h4 id="LNPLS-GUID-CF5859FE-4938-4EBF-BE5F-A7C857B77B8C" class="sect4"><span class="enumeration_section">12.6.8</span> Implicit_echo多态表函数示例</h4>
                  <div>
                     <p>implicit_echo PTF示例演示了当在同一个包中定义多态表函数和DESCRIBE函数时，USING子句是可选的。</p>
                     <div class="example" id="GUID-CF5859FE-4938-4EBF-BE5F-A7C857B77B8C__IMPLICIT_ECHOPOLYMORPHICTABLE-B0FD91C4">
                        <p class="titleinexample">例12-38 Implicit_echo多态表函数示例</p>
                        <p><code class="codeph">implicit_echo</code> PTF接受表和列，并生成具有相同值的新列。
                        </p>
                        <p>此PTF返回输入表选项卡中的列，并向其添加列中列出的列，但列名称前缀为<code class="codeph">"ECHO_"</code> 。
                        </p>
                        <p>创建包含<code class="codeph">DESCRIBE</code>函数， <code class="codeph">implicit_echo</code>多态表函数（PTF）和<code class="codeph">FETCH_ROWS</code>过程的实现包<code class="codeph">implicit_echo_package</code> 。
                        </p><pre class="pre codeblock"><code>CREATE PACKAGE implicit_echo_package AS前缀DBMS_ID：='“ECHO_'; FUNCTION DESCRIBE（选项卡IN OUT DBMS_TF.TABLE_T，cols IN DBMS_TF.COLUMNS_T）RETURN DBMS_TF.DESCRIBE_T; PROCEDURE FETCH_ROWS;  -  PTF功能：不使用条款 - 功能implicit_echo（ tab TABLE，cols COLUMNS）RETURN TABLE PIPLINING ROW POLYMORPHIC; END implicit_echo_package;</code></pre><p>创建包含<code class="codeph">DESCRIBE</code>函数的包，该函数包含要读取的输入表参数和列参数。调用此函数以确定多态表函数生成的行的类型。该函数返回一个表<code class="codeph">DBMS_TF.DESCRIBE_T</code> 。需要<code class="codeph">FETCH_ROWS</code>过程来生成指示的读取列以及输出行<code class="codeph">"ECHO_"</code>以<code class="codeph">"ECHO_"</code>为前缀的新列。<code class="codeph">implicit_echo</code>是PTF函数，包含两个参数<code class="codeph">tab</code>和<code class="codeph">cols</code> ，其值从查询中获取，并且此信息将传递给<code class="codeph">DESCRIBE</code>函数。Row语义指定PTF类型但没有<code class="codeph">USING</code>子句。从SQL查询调用此函数。
                        </p>
                        <p>创建包含PTF定义的实现包主体<code class="codeph">implicit_echo_package</code> 。
                        </p><pre class="pre codeblock"><code>CREATE PACKAGE BODY implicit_echo_package AS功能DESCRIBE（选项卡IN OUT DBMS_TF.TABLE_T，cols IN DBMS_TF.COLUMNS_T）RETURN DBMS_TF.DESCRIBE_T AS new_cols DBMS_TF.COLUMNS_NEW_T; col_id PLS_INTEGER：= 1;开始为我在1 .. tab.column。CO在1 ... cols的循环。COUNT LOOP IF（tab.column（i）.description.name = cols（j））那么如果（不是DBMS_TF.SUPPORTED_TYPE（tab.column（i）.description.type））那么RAISE_APPLICATION_ERROR（-20102，'不支持的列类型['|| tab.column（i）.description.type ||']'）;万一; tab.column（i）.for_read：= TRUE; new_cols（col_id）：= tab.column（i）.description; new_cols（col_id）.name：= prefix || REGEXP_REPLACE（tab.column（i）.description.name，'^“|”$'）; col_id：= col_id + 1;出口;万一;结束循环;结束循环; / *验证所有列发现* / IF（col_id  -  1！= cols。COUNT）然后RAISE_APPLICATION_ERROR（-20101，'列不匹配['|| col_id-1 ||']，['|| cols。COUNT || ']'）;万一; RETURN DBMS_TF.DESCRIBE_T（new_columns =&gt; new_cols）;结束; PROCEDURE FETCH_ROWS AS rowset DBMS_TF.ROW_SET_T; BEGIN DBMS_TF.GET_ROW_SET（rowset）; DBMS_TF.PUT_ROW_SET（行集）;结束; END implicit_echo_package;</code></pre><p>调用PTF以显示表<code class="codeph">SCOTT</code> ENAME列。 <code class="codeph">EMP</code>并将其与另一列具有相同值的<code class="codeph">ECHO_ENAME</code>一起显示。
                        </p><pre class="pre codeblock"><code>SELECT ENAME，ECHO_ENAME FROM implicit_echo_package.implicit_echo（SCOTT.EMP，COLUMNS（SCOTT.ENAME））;</code></pre><pre class="oac_no_warn" dir="ltr">ENAME ECHO_ENAME ---------- ---------- SMITH SMITH ALLEN ALLEN WARD JARD JONES JONES MARTIN MARTIN BLAKE BLAKE CLARK CLARK SCOTT SCOTT KING KING TURNER TURNER ADAMS ADAMS JAMES JAMES FORD FORD MILLER MILLER</pre></div>
                     <!-- class="example" -->
                  </div>
               </div>
            </div><a id="LNPLS930"></a><div class="props_rev_3"><a id="GUID-AD1BDE75-DDC1-496E-8964-CA0D41B0C76A" name="GUID-AD1BDE75-DDC1-496E-8964-CA0D41B0C76A"></a><h3 id="LNPLS-GUID-AD1BDE75-DDC1-496E-8964-CA0D41B0C76A" class="sect3"><span class="enumeration_section">12.7</span>并行更新大表</h3>
               <div>
                  <div class="section">
                     <p><code class="codeph">DBMS_PARALLEL_EXECUTE</code>包允许您以两个高级步骤并行地逐步更新大表中的数据：</p>
                  </div>
                  <!-- class="section" -->
                  <ol>
                     <li><span>将表中的行集合成较小的块。</span></li>
                     <li><span>并行地将所需的<code class="codeph">UPDATE</code>语句应用于块，每次处理完块时提交。</span></li>
                  </ol>
                  <div class="section">
                     <p>无论何时更新大量数据，都建议使用此技术。它的优点是：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>您一次只锁定一组行，时间相对较短，而不是锁定整个表。</p>
                        </li>
                        <li>
                           <p>如果在整个操作完成之前出现故障，您不会丢失已完成的工作。</p>
                        </li>
                        <li>
                           <p>减少回滚空间消耗。</p>
                        </li>
                        <li>
                           <p>你提高了性能。</p>
                        </li>
                     </ul>
                     <div class="infoboxnotealso" id="GUID-AD1BDE75-DDC1-496E-8964-CA0D41B0C76A__GUID-0CBBE551-B1A5-47DD-A51C-E34290D0E6E9">
                        <p class="notep1">也可以看看：</p>
                        <p>有关<code class="codeph">DBMS_PARALLEL_EXECUTE</code>包的更多信息，请<code class="codeph">DBMS_PARALLEL_EXECUTE</code> <a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/lnpls&amp;id=ARPLS233" target="_blank"><span class="italic">Oracle Database PL / SQL包和类型参考</span></a></p>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div>
            </div><a id="LNPLS01213"></a><div class="props_rev_3"><a id="GUID-AD358676-E837-45EB-9301-36A094A3BB22" name="GUID-AD358676-E837-45EB-9301-36A094A3BB22"></a><h3 id="LNPLS-GUID-AD358676-E837-45EB-9301-36A094A3BB22" class="sect3"><span class="enumeration_section">12.8</span>收集有关用户定义标识符的数据</h3>
               <div>
                  <div class="section">
                     <p>PL / Scope从PL / SQL源文本中提取，组织和存储有关PL / SQL和SQL标识符以及SQL语句的数据。您可以使用静态数据字典视图<code class="codeph">*_IDENTIFIERS</code>和* _STATEMENTS检索标识符和语句数据。</p>
                     <div class="infoboxnotealso" id="GUID-AD358676-E837-45EB-9301-36A094A3BB22__GUID-1AF0FA52-829B-4A08-A033-06029B8820A4">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="overview.html#GUID-DF63BC59-22C2-4BA8-9240-F74D505D5102" title="PL / SQL单元受PL / SQL编译参数（一类数据库初始化参数）的影响。不同的PL / SQL单元（例如，包规范及其主体）可以具有不同的编译参数设置。">PL / SQL单元和编译参数</a>有关PLSQL_SETTINGS参数的更多信息</p>
                           </li>
                           <li>
                              <p>有关使用PL / Scope的更多信息，请参见<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/lnpls&amp;id=ADFNS022" target="_blank"><span class="italic">Oracle数据库开发指南</span></a></p>
                           </li>
                        </ul>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div>
            </div><a id="LNPLS829"></a><a id="LNPLS01214"></a><div class="props_rev_3"><a id="GUID-D99A60B1-E3ED-4252-A85C-8FA732EE9957" name="GUID-D99A60B1-E3ED-4252-A85C-8FA732EE9957"></a><h3 id="LNPLS-GUID-D99A60B1-E3ED-4252-A85C-8FA732EE9957" class="sect3"><span class="enumeration_section">12.9</span>分析和跟踪PL / SQL程序</h3>
               <div>
                  <p>为了帮助您隔离大型PL / SQL程序中的性能问题，PL / SQL提供了这些工具，实现为PL / SQL包。</p>
                  <div class="section">
                     <div class="tblformal" id="GUID-D99A60B1-E3ED-4252-A85C-8FA732EE9957__GUID-B01BC7C5-2CB3-4A5D-B52C-23CD21E42A39">
                        <p class="titleintable">表12-1概要分析和跟踪工具摘要</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="分析和跟踪工具摘要" width="100%" border="1" summary="This table summarizes the profiling and tracing tools." frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="14%" id="d89034e10669">工具</th>
                                 <th align="left" valign="bottom" width="35%" id="d89034e10672">包</th>
                                 <th align="left" valign="bottom" width="50%" id="d89034e10675">描述</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="14%" id="d89034e10680" headers="d89034e10669 ">
                                    <p>Profiler界面</p>
                                 </td>
                                 <td align="left" valign="top" width="35%" headers="d89034e10680 d89034e10672 ">
                                    <p><code class="codeph">DBMS_PROFILER</code></p>
                                 </td>
                                 <td align="left" valign="top" width="50%" headers="d89034e10680 d89034e10675 ">
                                    <p>计算PL / SQL程序在每一行和每个子程序中花费的时间。</p>
                                    <p>您必须对要分析的单元具有<code class="codeph">CREATE</code>权限。
                                    </p>
                                    <p>在数据库表中保存运行时统计信息，您可以查询。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="14%" id="d89034e10698" headers="d89034e10669 ">
                                    <p>跟踪界面</p>
                                 </td>
                                 <td align="left" valign="top" width="35%" headers="d89034e10698 d89034e10672 ">
                                    <p><code class="codeph">DBMS_TRACE</code></p>
                                 </td>
                                 <td align="left" valign="top" width="50%" headers="d89034e10698 d89034e10675 ">
                                    <p>跟踪子程序运行的顺序。</p>
                                    <p>您可以指定要跟踪的子程序和跟踪级别。</p>
                                    <p>在数据库表中保存运行时统计信息，您可以查询。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="14%" id="d89034e10713" headers="d89034e10669 ">
                                    <p>PL / SQL分层分析器</p>
                                 </td>
                                 <td align="left" valign="top" width="35%" headers="d89034e10713 d89034e10672 ">
                                    <p><code class="codeph">DBMS_HPROF</code></p>
                                 </td>
                                 <td align="left" valign="top" width="50%" headers="d89034e10713 d89034e10675 ">
                                    <p>报告PL / SQL程序的动态执行程序配置文件，由子程序调用组织。分别考虑SQL和PL / SQL执行时间。</p>
                                    <p>不需要特殊的源代码或编译时准备。</p>
                                    <p>以HTML格式生成报告。提供在数据库表中以关系格式存储分析器数据和结果的选项，以生成自定义报告（例如第三方工具提供）。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="14%" id="d89034e10728" headers="d89034e10669 ">
                                    <p>SQL跟踪</p>
                                 </td>
                                 <td align="left" valign="top" width="35%" headers="d89034e10728 d89034e10672 ">
                                    <p><code class="codeph">DBMS_APPLICATION_INFO</code></p>
                                 </td>
                                 <td align="left" valign="top" width="50%" headers="d89034e10728 d89034e10675 ">
                                    <p>使用带有Oracle Trace的<code class="codeph">DBMS_APPLICATION_INFO</code>包和SQL跟踪工具来记录数据库中正在执行的模块或事务的名称，以便以后在跟踪各种模块的性能和调试时使用。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="14%" id="d89034e10742" headers="d89034e10669 ">
                                    <p>PL / SQL基本块覆盖</p>
                                 </td>
                                 <td align="left" valign="top" width="35%" headers="d89034e10742 d89034e10672 ">
                                    <p><code class="codeph">DBMS_PLSQL_CODE_COVERAGE</code></p>
                                 </td>
                                 <td align="left" valign="top" width="50%" headers="d89034e10742 d89034e10675 ">
                                    <p>收集和分析基本块覆盖数据。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="14%" id="d89034e10753" headers="d89034e10669 ">
                                    <p>调用堆栈实用程序</p>
                                 </td>
                                 <td align="left" valign="top" width="35%" headers="d89034e10753 d89034e10672 ">
                                    <p><code class="codeph">UTL_CALL_STACK</code></p>
                                 </td>
                                 <td align="left" valign="top" width="50%" headers="d89034e10753 d89034e10675 ">
                                    <p>提供有关当前正在执行的子程序（例如子程序名称，单元名称，所有者名称，版本名称和错误堆栈信息）的信息，您可以使用这些信息创建更具启发性的错误日志和应用程序执行跟踪。</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-D99A60B1-E3ED-4252-A85C-8FA732EE9957__GUID-7347CFBD-AA2C-431A-897A-566881B1EBD8">相关话题</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>有关<code class="codeph">DBMS_APPLICATION_INFO</code>包的更多信息，请<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/lnpls&amp;id=ARPLS003" target="_blank"><span class="italic">参见Oracle Database PL / SQL包和类型参考</span></a></p>
                        </li>
                        <li>
                           <p>有关<code class="codeph">DBMS_HPROF</code>包的更多信息，请<code class="codeph">DBMS_HPROF</code> <a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/lnpls&amp;id=ARPLS146" target="_blank"><span class="italic">Oracle Database PL / SQL包和类型参考</span></a></p>
                        </li>
                        <li>
                           <p>有关<code class="codeph">DBMS_PLSQL_CODE_COVERAGE</code>包的更多信息，请<code class="codeph">DBMS_PLSQL_CODE_COVERAGE</code> <a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/lnpls&amp;id=ARPLS-GUID-55A9E502-9EC2-4118-B292-DC79E6DC465E" target="_blank"><span class="italic">Oracle Database PL / SQL包和类型参考</span></a></p>
                        </li>
                        <li>
                           <p>有关<code class="codeph">DBMS_PROFILER</code>包的更多信息，请<code class="codeph">DBMS_PROFILER</code> <a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/lnpls&amp;id=ARPLS039" target="_blank"><span class="italic">Oracle Database PL / SQL包和类型参考</span></a></p>
                        </li>
                        <li>
                           <p>有关<code class="codeph">DBMS_TRACE</code>包的更多信息，请<code class="codeph">DBMS_TRACE</code> <a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/lnpls&amp;id=ARPLS060" target="_blank"><span class="italic">Oracle Database PL / SQL包和类型参考</span></a></p>
                           <p>有关<code class="codeph">UTL_CALL_STACK</code>包的更多信息，请<code class="codeph">UTL_CALL_STACK</code> <a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/lnpls&amp;id=ARPLS-GUID-2BE2AEB4-51DA-48CA-8B55-0AB6827EF612" target="_blank"><span class="italic">Oracle Database PL / SQL包和类型参考</span></a></p>
                        </li>
                        <li>
                           <p><a href="COVERAGE-pragma.html#GUID-38A315DC-020B-41BD-90CD-DBF4D937EE83" title="COVERAGE编译指示标记PL / SQL代码，这对于测试覆盖率是不可行的。这些标记提高了覆盖度量标准。">COVERAGE</a>用于<code class="codeph">COVERAGE PRAGMA</code>的语法和语义的<code class="codeph">COVERAGE PRAGMA</code> 
                           </p>
                        </li>
                        <li>
                           <p>有关使用PL / SQL基本块覆盖的更多信息，请参见<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/lnpls&amp;id=ADFNS-GUID-35842E6A-630A-418F-8314-6A30F1FBDF83" target="_blank"><span class="italic">“Oracle数据库开发指南”</span></a></p>
                        </li>
                        <li>
                           <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/lnpls&amp;id=ADFNS023" target="_blank"><span class="italic">Oracle数据库开发指南</span></a> ，了解PL / SQL分层分析器的详细说明</p>
                        </li>
                        <li>
                           <p>有关分析和调试存储的子程序的详细信息，请参见<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/lnpls&amp;id=ADFNS99873" target="_blank"><span class="italic">“Oracle数据库开发指南</span></a></p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
               </div>
            </div><a id="LNPLS830"></a><a id="LNPLS01209"></a><div class="props_rev_3"><a id="GUID-7C4557E7-4C35-4CAB-A95D-CB96BDC6D487" name="GUID-7C4557E7-4C35-4CAB-A95D-CB96BDC6D487"></a><h3 id="LNPLS-GUID-7C4557E7-4C35-4CAB-A95D-CB96BDC6D487" class="sect3"><span class="enumeration_section">12.10</span>编译本机执行的PL / SQL单元</h3>
               <div>
                  <div class="section">
                     <p>您通常可以通过将PL / SQL单元编译为本机代码（依赖于处理器的系统代码）来加速PL / SQL单元，该代码存储在SYSTEM表空间中。</p>
                     <p>您可以本地编译任何类型的PL / SQL单元，包括Oracle数据库提供的那些单元。</p>
                     <p>本机编译的程序单元适用于所有服务器环境，包括共享服务器配置（以前称为“多线程服务器”）和Oracle Real Application Clusters（Oracle RAC）。</p>
                     <p>在大多数平台上，PL / SQL本机编译不需要特殊的设置或维护。在某些平台上，DBA可能希望进行一些可选配置。</p>
                     <div class="infoboxnotealso" id="GUID-7C4557E7-4C35-4CAB-A95D-CB96BDC6D487__GUID-DD757A86-5DC2-4CB2-8B3C-6063ED98A629">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>有关配置数据库的信息，请参见<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/lnpls&amp;id=ADMIN002" target="_blank"><span class="italic">“Oracle数据库管理员指南”</span></a></p>
                           </li>
                           <li>
                              <p>适用于您平台的特定于平台的配置文档</p>
                           </li>
                        </ul>
                     </div>
                     <p>您可以通过启用PL / SQL本机编译来测试您可以获得多少性能增益。</p>
                     <p>如果您已确定PL / SQL本机编译将在数据库操作中提供显着的性能提升，则Oracle建议将整个数据库编译为本机模式，这需要DBA权限。这会加速您自己的代码和对Oracle数据库提供的PL / SQL包的调用。</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-7C4557E7-4C35-4CAB-A95D-CB96BDC6D487__GUID-B4EE801C-B77C-4465-9F61-2D66549AADF9">话题</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="plsql-optimization-and-tuning.html#GUID-F87C76F7-5044-4A8F-AD73-2A946EFFB31D">确定是否使用PL / SQL本机编译</a></p>
                        </li>
                        <li>
                           <p><a href="plsql-optimization-and-tuning.html#GUID-C01C53DD-0C0C-4D17-B03A-D00CC183A4EF">PL / SQL本机编译的工作原理</a></p>
                        </li>
                        <li>
                           <p><a href="plsql-optimization-and-tuning.html#GUID-0C95D77E-EA4C-4421-BA1B-7C58027E4C5B">依赖关系，无效和重新验证</a></p>
                        </li>
                        <li>
                           <p><a href="plsql-optimization-and-tuning.html#GUID-248986EB-62CA-4324-BC51-B20F54392240">为PL / SQL本机编译设置新数据库</a> *</p>
                        </li>
                        <li>
                           <p><a href="plsql-optimization-and-tuning.html#GUID-86BD3AC4-AC0A-4CFF-8A69-5297287A8F03">编译PL / SQL Native或Interpreted编译的整个数据库</a> *</p>
                        </li>
                     </ul>
                     <p>*需要DBA权限。</p>
                  </div>
                  <!-- class="section" -->
               </div><a id="LNPLS910"></a><div class="props_rev_3"><a id="GUID-F87C76F7-5044-4A8F-AD73-2A946EFFB31D" name="GUID-F87C76F7-5044-4A8F-AD73-2A946EFFB31D"></a><h4 id="LNPLS-GUID-F87C76F7-5044-4A8F-AD73-2A946EFFB31D" class="sect4"><span class="enumeration_section">12.10.1</span>确定是否使用PL / SQL本机编译</h4>
                  <div>
                     <div class="section">
                        <p>是否为本机模式或解释模式编译PL / SQL单元取决于您在开发周期中的位置以及程序单元的作用。</p>
                        <p>在调试程序单元并经常重新编译它们时，解释模式具有以下优点：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p>您可以在为解释模式编译的程序单元上使用PL / SQL调试工具（但不适用于为本机模式编译的程序单元）。</p>
                           </li>
                           <li>
                              <p>编译解释模式比编译本机模式更快。</p>
                           </li>
                        </ul>
                        <p>在开发的调试阶段之后，在确定是否为本机模式编译PL / SQL单元时，请考虑：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>PL / SQL本机编译为计算密集型过程操作提供了最大的性能提升。示例是数据仓库应用程序和具有用于显示的数据的广泛服务器端转换的应用程序。</p>
                           </li>
                           <li>
                              <p>PL / SQL本机编译为PL / SQL子程序提供了最少的性能提升，这些子程序大部分时间都在运行SQL。</p>
                           </li>
                           <li>
                              <p>当许多程序单元（通常超过15,000个）被编译为本机执行并且同时处于活动状态时，所需的大量共享内存可能会影响系统性能。</p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPLS911"></a><div class="props_rev_3"><a id="GUID-C01C53DD-0C0C-4D17-B03A-D00CC183A4EF" name="GUID-C01C53DD-0C0C-4D17-B03A-D00CC183A4EF"></a><h4 id="LNPLS-GUID-C01C53DD-0C0C-4D17-B03A-D00CC183A4EF" class="sect4"><span class="enumeration_section">12.10.2</span> PL / SQL本机编译的工作<span class="enumeration_section">原理</span></h4>
                  <div>
                     <p>如果没有本机编译，PL / SQL单元中的PL / SQL语句将被编译为中间形式的系统代码，该代码存储在目录中并在运行时进行解释。</p>
                     <p>使用PL / SQL本机编译，PL / SQL单元中的PL / SQL语句将编译为本机代码并存储在目录中。无需在运行时解释本机代码，因此运行速度更快。</p>
                     <p>由于本机编译仅适用于PL / SQL语句，因此仅使用SQL语句的PL / SQL单元在本机编译时可能运行得不快，但它的运行速度至少与相应的解释代码一样快。已编译的代码和解释的代码进行相同的库调用，因此它们的操作是相同的。</p>
                     <p>第一次运行本机编译的PL / SQL单元时，它会从SYSTEM表空间提取到共享内存中。无论有多少会话调用程序单元，共享内存只有一个副本。如果未使用程序单元，则可以释放它正在使用的共享内存，以减少内存负载。</p>
                     <p>本机编译的子程序和解释的子程序可以相互调用。</p>
                     <p>PL / SQL本机编译在Oracle Real Application Clusters（Oracle RAC）环境中透明地工作。</p>
                     <p><code class="codeph">PLSQL_CODE_TYPE</code>编译参数确定是否本机编译或解释PL / SQL代码。有关此编译参数的信息，请参阅<span class="q">“ <a href="overview.html#GUID-DF63BC59-22C2-4BA8-9240-F74D505D5102" title="PL / SQL单元受PL / SQL编译参数（一类数据库初始化参数）的影响。不同的PL / SQL单元（例如，包规范及其主体）可以具有不同的编译参数设置。">PL / SQL单元和编译参数</a> ”</span> 。
                     </p>
                  </div>
               </div><a id="LNPLS912"></a><div class="props_rev_3"><a id="GUID-0C95D77E-EA4C-4421-BA1B-7C58027E4C5B" name="GUID-0C95D77E-EA4C-4421-BA1B-7C58027E4C5B"></a><h4 id="LNPLS-GUID-0C95D77E-EA4C-4421-BA1B-7C58027E4C5B" class="sect4"><span class="enumeration_section">12.10.3</span>依赖关系，无效和重新验证</h4>
                  <div>
                     <p>使用无效的PL / SQL模块自动重新编译。例如，如果本机编译的PL / SQL子程序所依赖的对象发生变化，则子程序无效。下次调用相同的子程序时，数据库会自动重新编译子程序。由于<code class="codeph">PLSQL_CODE_TYPE</code>设置存储在每个子程序的库单元内，因此自动重新编译将此存储的设置用于代码类型。
                     </p>
                     <p>显式重新编译不一定使用存储的<code class="codeph">PLSQL_CODE_TYPE</code>设置。有关显式重新编译使用存储设置的条件，请参阅<span class="q">“ <a href="overview.html#GUID-DF63BC59-22C2-4BA8-9240-F74D505D5102" title="PL / SQL单元受PL / SQL编译参数（一类数据库初始化参数）的影响。不同的PL / SQL单元（例如，包规范及其主体）可以具有不同的编译参数设置。">PL / SQL单元和编译参数</a> ”</span> 。
                     </p>
                  </div>
               </div><a id="LNPLS913"></a><div class="props_rev_3"><a id="GUID-248986EB-62CA-4324-BC51-B20F54392240" name="GUID-248986EB-62CA-4324-BC51-B20F54392240"></a><h4 id="LNPLS-GUID-248986EB-62CA-4324-BC51-B20F54392240" class="sect4"><span class="enumeration_section">12.10.4</span>为PL / SQL本机编译设置新数据库</h4>
                  <div>
                     <div class="section">
                        <p>如果您具有DBA权限，则可以通过将编译参数<code class="codeph">PLSQL_CODE_TYPE</code>设置为<code class="codeph">NATIVE</code>来为PL / SQL本机编译设置新数据库。性能优势适用于Oracle数据库提供的PL / SQL包，这些包用于许多数据库操作。
                        </p>
                        <div class="infoboxnote" id="GUID-248986EB-62CA-4324-BC51-B20F54392240__GUID-73A7CDDB-31E8-424B-A04B-CDA0A5668D45">
                           <p class="notep1">注意：</p>
                           <p>如果将整个数据库编译为<code class="codeph">NATIVE</code> ，Oracle建议您在系统级别设置<code class="codeph">PLSQL_CODE_TYPE</code> 。
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPLS914"></a><div class="props_rev_3"><a id="GUID-86BD3AC4-AC0A-4CFF-8A69-5297287A8F03" name="GUID-86BD3AC4-AC0A-4CFF-8A69-5297287A8F03"></a><h4 id="LNPLS-GUID-86BD3AC4-AC0A-4CFF-8A69-5297287A8F03" class="sect4"><span class="enumeration_section">12.10.5</span>为PL / SQL本机或解释编译编译整个数据库</h4>
                  <div>
                     <div class="section">
                        <p>如果您具有DBA权限，则可以使用<code class="codeph">dbmsupgnv</code>将现有数据库中的所有PL / SQL模块重新编译为<code class="codeph">NATIVE</code>或<code class="codeph">INTERPRETED</code> 。 <code class="codeph">sql</code>和<code class="codeph">dbmsupgin</code> 。本节中介绍的过程中分别使用<code class="codeph">sql</code>脚本。在进行转换之前，请查看<span class="q">“ <a href="plsql-optimization-and-tuning.html#GUID-F87C76F7-5044-4A8F-AD73-2A946EFFB31D">确定是否使用PL / SQL本机编译</a> ”</span> 。
                        </p>
                        <div class="infoboxnote" id="GUID-86BD3AC4-AC0A-4CFF-8A69-5297287A8F03__GUID-55D22C41-DD3A-4DBF-964B-3B95876DD29D">
                           <p class="notep1">注意：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>如果将整个数据库编译为<code class="codeph">NATIVE</code> ，Oracle建议您在系统级别设置<code class="codeph">PLSQL_CODE_TYPE</code> 。
                                 </p>
                              </li>
                              <li>
                                 <p>如果启用了Database Vault，则可以运行<code class="codeph">dbmsupgnv</code> 。仅当Database Vault管理员授予您<code class="codeph">DV_PATCH_ADMIN</code>角色时才使用<code class="codeph">sql</code> 。
                                 </p>
                              </li>
                           </ul>
                        </div>
                        <p>在转换为本机编译期间， <code class="codeph">dbmsupgnv</code>不会重新编译<code class="codeph">TYPE</code>规范。 <code class="codeph">sql</code>到<code class="codeph">NATIVE</code>因为这些规范不包含可执行代码。
                        </p>
                        <p>包规范很少包含可执行代码，因此编译为<code class="codeph">NATIVE</code>的运行时优势是不可测量的。您可以将<code class="codeph">TRUE</code>命令行参数与<code class="codeph">dbmsupgnv</code> 。 <code class="codeph">sql</code>脚本将包规范从重新编译排除到<code class="codeph">NATIVE</code> ，从而节省了转换过程的时间。
                        </p>
                        <p>转换为解释编译时， <code class="codeph">dbmsupgin</code> 。 <code class="codeph">sql</code>脚本不接受任何参数，也不排除任何PL / SQL单元。
                        </p>
                        <div class="infoboxnote" id="GUID-86BD3AC4-AC0A-4CFF-8A69-5297287A8F03__GUID-42D4A093-84C9-413E-AA7B-B12C3F47A767">
                           <p class="notep1">注意：</p>
                           <p>以下过程描述了到本机编译的转换。如果必须重新编译所有PL / SQL模块以进行解释编译，请在步骤中进行这些更改。</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>跳过第一步。</p>
                              </li>
                              <li>
                                 <p>将<code class="codeph">PLSQL_CODE_TYPE</code>编译参数设置为<code class="codeph">INTERPRETED</code>而不是<code class="codeph">NATIVE</code> 。</p>
                              </li>
                              <li>
                                 <p>替换<code class="codeph">dbmsupgin</code> 。用于<code class="codeph">dbmsupgnv</code> <code class="codeph">sql</code> 。 <code class="codeph">sql</code>脚本。
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>确保可以编译测试PL / SQL单元。例如：</span><div><pre class="oac_no_warn" dir="ltr">ALTER PROCEDURE my_proc COMPILE PLSQL_CODE_TYPE = NATIVE REUSE SETTINGS;</pre></div>
                        </li>
                        <li class="stepexpand"><span>关闭应用程序服务，侦听器和数据库。</span><div>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>关闭所有应用程序服务，包括表单进程，Web服务器，报表服务器和并发管理器服务器。关闭所有应用程序服务后，请确保终止与数据库的所有连接。</p>
                                 </li>
                                 <li>
                                    <p>关闭数据库的TNS监听器以确保没有建立新连接。</p>
                                 </li>
                                 <li>
                                    <p>以用户<code class="codeph">SYS</code>以正常或立即模式关闭数据库。请参见“ <a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/lnpls&amp;id=ADMIN004" target="_blank"><span class="italic">Oracle数据库管理员指南”</span></a> 。
                                    </p>
                                 </li>
                              </ul>
                           </div>
                        </li>
                        <li class="stepexpand"><span>在编译参数文件中将<code class="codeph">PLSQL_CODE_TYPE</code>设置为<code class="codeph">NATIVE</code> 。如果数据库正在使用服务器参数文件，则在数据库启动后设置此项。</span><div>
                              <p>在这些步骤中， <code class="codeph">PLSQL_CODE_TYPE</code>的值不会影响PL / SQL单元的转换。但是，它确实会影响所有后续编译的单元，因此请将其明确设置为所需的编译类型。
                              </p>
                           </div>
                        </li>
                        <li class="stepexpand"><span>使用<code class="codeph">UPGRADE</code>选项以升级模式启动数据库。有关SQL * Plus <code class="codeph">STARTUP</code> ，请参阅<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/lnpls&amp;id=SQPUG127" target="_blank"><span class="italic">SQL * Plus用户指南和参考</span></a> 。</span></li>
                        <li class="stepexpand" id="GUID-86BD3AC4-AC0A-4CFF-8A69-5297287A8F03__BCGJBEHE"><span>运行此代码以列出无效的PL / SQL单元。您可以使用SQL <code class="codeph">SPOOL</code>语句保存查询的输出以供将来参考：</span><div><pre class="oac_no_warn" dir="ltr">- 要将查询的输出保存到文件： <span class="bold">SPOOL pre_update_invalid.log</span> SELECT o。所有者，o。OBJECT_NAME，o。OBJECT_TYPE FROM DBA_OBJECTS o，DBA_PLSQL_OBJECT_SETTINGS s WHERE o。OBJECT_NAME = s。姓名和o。STATUS = '无效'; - 停止输出假脱机： <span class="bold">SPOOL OFF</span>
</pre><p>如果任何Oracle提供的单元无效，请尝试通过重新编译来验证它们。例如：</p><pre class="oac_no_warn" dir="ltr">ALTER PACKAGE SYS.DBMS_OUTPUT COMPILE BODY REUSE SETTINGS;</pre><p>如果无法验证单元，请保存假脱机日志以供将来解决并继续。</p>
                           </div>
                        </li>
                        <li class="stepexpand" id="GUID-86BD3AC4-AC0A-4CFF-8A69-5297287A8F03__BCGBFAEE"><span>运行此查询以确定编译了多少对象<code class="codeph">NATIVE</code>和<code class="codeph">INTERPRETED</code> （保存输出，使用SQL <code class="codeph">SPOOL</code>语句）：</span><div><pre class="oac_no_warn" dir="ltr">SELECT TYPE，PLSQL_CODE_TYPE，COUNT（*）FROM DBA_PLSQL_OBJECT_SETTINGS WHERE PLSQL_CODE_TYPE IS NOT NOT GROUP BY TYPE，PLSQL_CODE_TYPE ORDER BY TYPE，PLSQL_CODE_TYPE;</pre><p>任何具有<code class="codeph">NULL</code> <code class="codeph">plsql_code_type</code>的对象都是特殊的内部对象，可以忽略。
                              </p>
                           </div>
                        </li>
                        <li class="stepexpand"><span>运行<code class="codeph">$ORACLE_HOME/rdbms/admin/dbmsupgnv</code> 。 <code class="codeph">sql</code>脚本作为用户<code class="codeph">SYS</code>将<code class="codeph">plsql_code_type</code>设置更新为所有PL / SQL单元的字典表中的<code class="codeph">NATIVE</code> 。此过程也会使单位无效。对脚本使用<code class="codeph">TRUE</code>以排除包规范; <code class="codeph">FALSE</code>包含包规范。</span><div>
                              <p>必须在数据库处于<code class="codeph">UPGRADE</code>模式时执行此更新。保证脚本成功完成或回滚所有更改。
                              </p>
                           </div>
                        </li>
                        <li class="stepexpand"><span>关闭数据库并以<code class="codeph">NORMAL</code>模式重新启动。</span></li>
                        <li class="stepexpand"><span>在运行<code class="codeph">utlrp</code>之前。 <code class="codeph">sql</code>脚本中，Oracle建议不要连接其他会话以避免可能的问题。您可以使用以下声明确保：</span><div><pre class="oac_no_warn" dir="ltr">更改系统启用限制会话;</pre></div>
                        </li>
                        <li class="stepexpand"><span>运行<code class="codeph">$ORACLE_HOME/rdbms/admin/utlrp</code> 。 <code class="codeph">sql</code>脚本作为用户<code class="codeph">SYS</code> 。此脚本使用默认的并行度重新编译所有PL / SQL模块。有关显式设置度数的信息，请参阅脚本中的注释。</span><div>
                              <p>如果由于任何原因脚本异常终止，请重新运行<code class="codeph">utlrp</code> 。 <code class="codeph">sql</code>脚本重新编译任何剩余的无效PL / SQL模块。
                              </p>
                           </div>
                        </li>
                        <li class="stepexpand"><span>编译成功完成后，验证在步骤<a href="plsql-optimization-and-tuning.html#GUID-86BD3AC4-AC0A-4CFF-8A69-5297287A8F03__BCGJBEHE">5中</a>使用查询没有无效的PL / SQL单元。您可以将查询的输出假脱机到<code class="codeph">post_upgrade_invalid</code> 。 <code class="codeph">log</code>文件并将内容与<code class="codeph">pre_upgrade_invalid</code>进行比较。 <code class="codeph">log</code>文件，如果它是先前创建的。</span></li>
                        <li class="stepexpand"><span>在步骤<a href="plsql-optimization-and-tuning.html#GUID-86BD3AC4-AC0A-4CFF-8A69-5297287A8F03__BCGBFAEE">6中</a>重新执行查询。如果使用<code class="codeph">dbmsupgnv</code>重新编译。 <code class="codeph">sql</code> ，确认所有PL / SQL单元（除了<code class="codeph">TYPE</code>规范和包规范除外）都是<code class="codeph">NATIVE</code> 。如果使用<code class="codeph">dbmsupgin</code>重新编译。 <code class="codeph">sql</code> ，确认所有PL / SQL单元都是<code class="codeph">INTERPRETED</code> 。</span></li>
                        <li class="stepexpand"><span>禁用数据库的受限会话模式，然后启动先前关闭的服务。要禁用受限会话模式，请使用以下语句：</span><div><pre class="oac_no_warn" dir="ltr">更改系统禁用受限制的会议;</pre></div>
                        </li>
                     </ol>
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>