<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html xml:lang="en-us" lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta name="abstract" content="This chapter explains how the PL/SQL compiler optimizes your code and how to write efficient PL/SQL code and improve existing PL/SQL code.">
      <meta name="description" content="This chapter explains how the PL/SQL compiler optimizes your code and how to write efficient PL/SQL code and improve existing PL/SQL code.">
      <title>PL/SQL Optimization and Tuning</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="Database PL/SQL Language Reference ">
      <meta property="og:description" content="This chapter explains how the PL/SQL compiler optimizes your code and how to write efficient PL/SQL code and improve existing PL/SQL code.">
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="Database PL/SQL Language Reference">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="database-pl-sql-language-reference.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2019-01-13T20:26:20-08:00">
      
      <meta name="dcterms.dateCopyrighted" content="1996, 2019">
      <meta name="dcterms.category" content="database">
      <meta name="dcterms.identifier" content="E96448-02">
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19">
      
      <link rel="prev" href="plsql-error-handling.html" title="Previous" type="text/html">
      <link rel="next" href="plsql-language-elements.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Database PL/SQL Language Reference">
    <meta name="dcterms.isVersionOf" content="LNPLS">
    <meta name="dcterms.release" content="Release 19">
  </head>
   <body>
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="plsql-error-handling.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>Previous</a>
         <a href="plsql-language-elements.html" class="pull-right">Next<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a>
         <span class="fa fa-exclamation-triangle" aria-hidden="true"></span> JavaScript must be enabled to correctly display this content
        
      </div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">Database PL/SQL Language Reference </span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">PL/SQL Optimization and Tuning</li>
            </ol>
            <a id="GUID-12C08950-12A4-45F4-92F1-49B19417BCD5" name="GUID-12C08950-12A4-45F4-92F1-49B19417BCD5"></a><a id="LNPLS766"></a><a id="LNPLS012"></a>
            
            <h2 id="LNPLS-GUID-12C08950-12A4-45F4-92F1-49B19417BCD5" class="sect2"><span class="enumeration_chapter">12 </span>PL/SQL Optimization and Tuning
            </h2>
         </header>
         <div class="ind">
            <div>
               <p>This chapter explains how the PL/SQL compiler optimizes your code and how to write efficient PL/SQL code and improve existing PL/SQL code.</p>
               <div class="section">
                  <p class="subhead1" id="GUID-12C08950-12A4-45F4-92F1-49B19417BCD5__GUID-D96A464E-DB11-4496-858A-F10173023AD9">Topics</p>
               </div>
               <!-- class="section" -->
               <ul style="list-style-type: disc;">
                  <li>
                     <p><a href="plsql-optimization-and-tuning.html#GUID-8BC4231B-2E5C-47D6-BE14-6D75CE14C57E" title="One optimization that the compiler can perform is subprogram inlining.">PL/SQL Optimizer</a></p>
                  </li>
                  <li>
                     <p><a href="plsql-optimization-and-tuning.html#GUID-1640FEEA-4237-4A0D-B445-621EF2A420C6">Candidates for Tuning</a></p>
                  </li>
                  <li>
                     <p><a href="plsql-optimization-and-tuning.html#GUID-C2DC6043-17CC-4F9F-934D-A075133FBD01" title="Functions invoked in queries might run millions of times. Do not invoke a function in a query unnecessarily, and make the invocation as efficient as possible.If a subprogram has OUT or IN OUT parameters, you can sometimes decrease its invocation overhead by declaring those parameters with the NOCOPY hint.">Minimizing CPU Overhead</a></p>
                  </li>
                  <li>
                     <p><a href="plsql-optimization-and-tuning.html#GUID-61D1B533-DBB9-4150-91F9-0A4C9428391E" title="Bulk SQL minimizes the performance overhead of the communication between PL/SQL and SQL. The PL/SQL features that comprise bulk SQL are the FORALL statement and the BULK COLLECT clause. Assigning values to PL/SQL variables that appear in SQL statements is called binding.">Bulk SQL and Bulk Binding</a></p>
                  </li>
                  <li>
                     <p><a href="plsql-optimization-and-tuning.html#GUID-ED557894-EC08-47E0-A629-0E4AEDDBB77B" title="A table function is a user-defined PL/SQL function that returns a collection of rows (an associative array, nested table or varray).">Chaining Pipelined Table Functions for Multiple Transformations</a></p>
                  </li>
                  <li>
                     <p><a href="plsql-optimization-and-tuning.html#GUID-981102A8-5204-4931-B10A-93486304B184" title="Polymorphic table functions (PTF) are table functions whose operands can have more than one type. The return type is determined by the PTF invocation arguments list. The actual arguments to the table type usually determines the row output shape, but not always.">Overview of Polymorphic Table Functions</a></p>
                  </li>
                  <li>
                     <p><a href="plsql-optimization-and-tuning.html#GUID-AD1BDE75-DDC1-496E-8964-CA0D41B0C76A">Updating Large Tables in Parallel</a></p>
                  </li>
                  <li>
                     <p><a href="plsql-optimization-and-tuning.html#GUID-AD358676-E837-45EB-9301-36A094A3BB22">Collecting Data About User-Defined Identifiers</a></p>
                  </li>
                  <li>
                     <p><a href="plsql-optimization-and-tuning.html#GUID-D99A60B1-E3ED-4252-A85C-8FA732EE9957" title="To help you isolate performance problems in large PL/SQL programs, PL/SQL provides these tools, implemented as PL/SQL packages.">Profiling and Tracing PL/SQL Programs</a></p>
                  </li>
                  <li>
                     <p><a href="plsql-optimization-and-tuning.html#GUID-7C4557E7-4C35-4CAB-A95D-CB96BDC6D487">Compiling PL/SQL Units for Native Execution</a></p>
                  </li>
               </ul>
               <div class="infoboxnotealso" id="GUID-12C08950-12A4-45F4-92F1-49B19417BCD5__GUID-11E50C2E-81B4-40C4-9AA4-EE932104A009">
                  <p class="notep1">See Also:</p>
                  <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/lnpls&amp;id=ADFNS160" target="_blank"><span class="italic">Oracle Database Development Guide</span></a> for disadvantages of cursor variables
                  </p>
               </div>
            </div><a id="LNPLS01201"></a><div class="props_rev_3"><a id="GUID-8BC4231B-2E5C-47D6-BE14-6D75CE14C57E" name="GUID-8BC4231B-2E5C-47D6-BE14-6D75CE14C57E"></a><h3 id="LNPLS-GUID-8BC4231B-2E5C-47D6-BE14-6D75CE14C57E" class="sect3"><span class="enumeration_section">12.1 </span>PL/SQL Optimizer
               </h3>
               <div>
                  <p>Prior to Oracle Database 10g release 1, the PL/SQL compiler translated your source text to system code without applying many changes to improve performance. Now, PL/SQL uses an optimizer that can rearrange code for better performance.</p>
                  <p>The optimizer is enabled by default. In rare cases, if the overhead of the optimizer makes compilation of very large applications too slow, you can lower the optimization by setting the compilation parameter <code class="codeph">PLSQL_OPTIMIZE_LEVEL=1</code> instead of its default value 2. In even rarer cases, PL/SQL might raise an exception earlier than expected or not at all. Setting <code class="codeph">PLSQL_OPTIMIZE_LEVEL=1</code> prevents the code from being rearranged.
                  </p>
                  <div class="infoboxnotealso" id="GUID-8BC4231B-2E5C-47D6-BE14-6D75CE14C57E__GUID-DA5E60E8-C791-4F4F-8002-47500C9D691C">
                     <p class="notep1">See Also:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="../refrn/PLSQL_OPTIMIZE_LEVEL.html#REFRN10255" target="_blank"><span class="italic">Oracle Database Reference</span></a> for information about the <code class="codeph">PLSQL_OPTIMIZE_LEVEL</code> compilation parameter
                           </p>
                        </li>
                        <li>
                           <p><a href="../adfns/coding-subprograms-and-packages.html#ADFNS1422" target="_blank"><span class="italic">Oracle Database Development Guide</span></a> for examples of changing the <code class="codeph">PLSQL_OPTIMIZE_LEVEL</code> compilation parameter
                           </p>
                        </li>
                        <li>
                           <p><a href="../refrn/ALL_PLSQL_OBJECT_SETTINGS.html#REFRN20385" target="_blank"><span class="italic">Oracle Database Reference</span></a> for information about the static dictionary view <code class="codeph">ALL_PLSQL_OBJECT_SETTINGS</code></p>
                        </li>
                     </ul>
                  </div>
               </div><a id="LNPLS1219"></a><a id="LNPLS1220"></a><a id="LNPLS1221"></a><a id="LNPLS1222"></a><a id="LNPLS99951"></a><div class="props_rev_3"><a id="GUID-2E78813E-CF29-409D-9F8B-AA24B294BFA2" name="GUID-2E78813E-CF29-409D-9F8B-AA24B294BFA2"></a><h4 id="LNPLS-GUID-2E78813E-CF29-409D-9F8B-AA24B294BFA2" class="sect4"><span class="enumeration_section">12.1.1 </span>Subprogram Inlining
                  </h4>
                  <div>
                     <p>One optimization that the compiler can perform is <span class="bold">subprogram inlining</span>.
                     </p>
                     <p> Subprogram inlining replaces a subprogram invocation with a copy of the invoked subprogram (if the invoked and invoking subprograms are in the same program unit). To allow subprogram inlining, either accept the default value of the <code class="codeph">PLSQL_OPTIMIZE_LEVEL</code> compilation parameter (which is 2) or set it to 3.
                     </p>
                     <p>With <code class="codeph">PLSQL_OPTIMIZE_LEVEL=2</code>, you must specify each subprogram to be inlined with the <code class="codeph">INLINE</code> pragma:
                     </p><pre class="oac_no_warn" dir="ltr">PRAGMA INLINE (<span class="italic">subprogram</span>, 'YES')
</pre><p>If <span class="italic"><code class="codeph">subprogram</code></span> is overloaded, then the preceding pragma applies to every subprogram with that name.
                     </p>
                     <p>With <code class="codeph">PLSQL_OPTIMIZE_LEVEL=3</code>, the PL/SQL compiler seeks opportunities to inline subprograms. You need not specify subprograms to be inlined. However, you can use the <code class="codeph">INLINE</code> pragma (with the preceding syntax) to give a subprogram a high priority for inlining, and then the compiler inlines it unless other considerations or limits make the inlining undesirable.
                     </p>
                     <p>If a particular subprogram is inlined, performance almost always improves. However, because the compiler inlines subprograms early in the optimization process, it is possible for subprogram inlining to preclude later, more powerful optimizations.</p>
                     <p>If subprogram inlining slows the performance of a particular PL/SQL program, then use the PL/SQL hierarchical profiler to identify subprograms for which you want to turn off inlining. To turn off inlining for a subprogram, use the <code class="codeph">INLINE</code> pragma:
                     </p><pre class="oac_no_warn" dir="ltr">PRAGMA INLINE (<span class="italic">subprogram</span>, 'NO')
</pre><p>The <code class="codeph">INLINE</code> pragma affects only the immediately following declaration or statement, and only some kinds of statements.
                     </p>
                     <p>When the <code class="codeph">INLINE</code> pragma immediately precedes a declaration, it affects:
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Every invocation of the specified subprogram in that declaration</p>
                        </li>
                        <li>
                           <p>Every initialization value in that declaration except the default initialization values of records</p>
                        </li>
                     </ul>
                     <p>When the <code class="codeph">INLINE</code> pragma immediately precedes one of these statements, the pragma affects every invocation of the specified subprogram in that statement:
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Assignment</p>
                        </li>
                        <li>
                           <p><code class="codeph">CALL</code></p>
                        </li>
                        <li>
                           <p>Conditional</p>
                        </li>
                        <li>
                           <p><code class="codeph">CASE</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">CONTINUE</code> <code class="codeph">WHEN</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">EXECUTE</code> <code class="codeph">IMMEDIATE</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">EXIT</code> <code class="codeph">WHEN</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">LOOP</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">RETURN</code></p>
                        </li>
                     </ul>
                     <p>The <code class="codeph">INLINE</code> pragma does not affect statements that are not in the preceding list.
                     </p>
                     <p>Multiple pragmas can affect the same declaration or statement. Each pragma applies its own effect to the statement. If <code class="codeph">PRAGMA</code> <code class="codeph">INLINE(</code><span class="italic"><code class="codeph">subprogram,</code></span><code class="codeph">'YES')</code> and <code class="codeph">PRAGMA</code> <code class="codeph">INLINE(</code><span class="italic"><code class="codeph">identifier,</code></span><code class="codeph">'NO')</code> have the same <span class="italic"><code class="codeph">subprogram</code></span>, then <code class="codeph">'NO'</code> overrides <code class="codeph">'YES'</code>. One <code class="codeph">PRAGMA</code> <code class="codeph">INLINE(</code><span class="italic"><code class="codeph">subprogram,</code></span><code class="codeph">'NO')</code> overrides any number of occurrences of <code class="codeph">PRAGMA</code> <code class="codeph">INLINE(</code><span class="italic"><code class="codeph">subprogram,</code></span><code class="codeph">'YES')</code>, and the order of these pragmas is not important.
                     </p>
                     <div class="infoboxnotealso" id="GUID-2E78813E-CF29-409D-9F8B-AA24B294BFA2__GUID-9E10AC95-93E9-4F66-9D91-9E2E77F0853C">
                        <p class="notep1">See Also:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><a href="../adfns/hierarchical-profiler.html#ADFNS023" target="_blank"><span class="italic">Oracle Database Development Guide</span></a> for more information about PL/SQL hierarchical profiler 
                              </p>
                           </li>
                           <li>
                              <p><a href="../refrn/PLSQL_OPTIMIZE_LEVEL.html#REFRN10255" target="_blank"><span class="italic">Oracle Database Reference</span></a> for information about the <code class="codeph">PLSQL_OPTIMIZE_LEVEL</code> compilation parameter
                              </p>
                           </li>
                           <li>
                              <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/lnpls&amp;id=REFRN20385" target="_blank"><span class="italic">Oracle Database Reference</span></a> for information about the static dictionary view <code class="codeph">ALL_PLSQL_OBJECT_SETTINGS</code></p>
                           </li>
                        </ul>
                     </div>
                     <div class="example" id="GUID-2E78813E-CF29-409D-9F8B-AA24B294BFA2__CHDBGJDJ">
                        <p class="titleinexample">Example 12-1 Specifying that Subprogram Is To Be Inlined</p>
                        <p>In this example, if <code class="codeph">PLSQL_OPTIMIZE_LEVEL=2</code>, the <code class="codeph">INLINE</code> pragma affects the procedure invocations <code class="codeph">p1(1)</code> and <code class="codeph">p1(2)</code>, but not the procedure invocations <code class="codeph">p1(3)</code> and <code class="codeph">p1(4)</code>.
                        </p><pre class="oac_no_warn" dir="ltr">PROCEDURE p1 (x PLS_INTEGER) IS ...
...
<span class="bold">PRAGMA INLINE (p1, 'YES');</span>
x:= p1(1) + p1(2) + 17;    -- These 2 invocations to p1 are inlined
...
x:= p1(3) + p1(4) + 17;    -- These 2 invocations to p1 are not inlined
...
</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-2E78813E-CF29-409D-9F8B-AA24B294BFA2__CHDIJCGI">
                        <p class="titleinexample">Example 12-2 Specifying that Overloaded Subprogram Is To Be Inlined</p>
                        <p>In this example, if <code class="codeph">PLSQL_OPTIMIZE_LEVEL=2</code>, the <code class="codeph">INLINE</code> pragma affects both functions named <code class="codeph">p2</code>.
                        </p><pre class="oac_no_warn" dir="ltr">FUNCTION p2 (p boolean) return PLS_INTEGER IS ...
FUNCTION p2 (x PLS_INTEGER) return PLS_INTEGER IS ...
...
<span class="bold">PRAGMA INLINE(p2, 'YES');</span>
x := p2(true) + p2(3);</pre><pre class="oac_no_warn" dir="ltr">...
</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-2E78813E-CF29-409D-9F8B-AA24B294BFA2__CHDGAGBH">
                        <p class="titleinexample">Example 12-3 Specifying that Subprogram Is Not To Be Inlined</p>
                        <p>In this example, the <code class="codeph">INLINE</code> pragma affects the procedure invocations <code class="codeph">p1(1)</code> and <code class="codeph">p1(2)</code>, but not the procedure invocations <code class="codeph">p1(3)</code> and <code class="codeph">p1(4)</code>.
                        </p><pre class="oac_no_warn" dir="ltr">PROCEDURE p1 (x PLS_INTEGER) IS ...
...
<span class="bold">PRAGMA INLINE (p1, 'NO');</span>
x:= p1(1) + p1(2) + 17;    -- These 2 invocations to p1 are not inlined
...
x:= p1(3) + p1(4) + 17;    -- These 2 invocations to p1 might be inlined
...
</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-2E78813E-CF29-409D-9F8B-AA24B294BFA2__CHDJCIEJ">
                        <p class="titleinexample">Example 12-4 PRAGMA INLINE ... 'NO' Overrides PRAGMA INLINE ... 'YES'</p>
                        <p>In this example, the second <code class="codeph">INLINE</code> pragma overrides both the first and third <code class="codeph">INLINE</code> pragmas.
                        </p><pre class="oac_no_warn" dir="ltr">PROCEDURE p1 (x PLS_INTEGER) IS ...
...
<span class="bold">PRAGMA INLINE (p1, 'YES');</span>
<span class="bold">PRAGMA INLINE (p1, 'NO');</span>
<span class="bold">PRAGMA INLINE (p1, 'YES');</span>
x:= p1(1) + p1(2) + 17;    -- These 2 invocations to p1 are not inlined
...</pre></div>
                     <!-- class="example" -->
                  </div>
               </div>
            </div><a id="LNPLS01212"></a><div class="props_rev_3"><a id="GUID-1640FEEA-4237-4A0D-B445-621EF2A420C6" name="GUID-1640FEEA-4237-4A0D-B445-621EF2A420C6"></a><h3 id="LNPLS-GUID-1640FEEA-4237-4A0D-B445-621EF2A420C6" class="sect3"><span class="enumeration_section">12.2 </span>Candidates for Tuning
               </h3>
               <div>
                  <p>The following kinds of PL/SQL code are very likely to benefit from tuning:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>Older code that does not take advantage of new PL/SQL language features.</p>
                        <div class="infobox-tip" id="GUID-1640FEEA-4237-4A0D-B445-621EF2A420C6__GUID-B2F9C5CB-9939-45A7-98FA-1FE1AB35CE05">
                           <p class="notep1">Tip:</p>
                           <p>Before tuning older code, benchmark the current system and profile the older subprograms that your program invokes (see <span class="q">"<a href="plsql-optimization-and-tuning.html#GUID-D99A60B1-E3ED-4252-A85C-8FA732EE9957" title="To help you isolate performance problems in large PL/SQL programs, PL/SQL provides these tools, implemented as PL/SQL packages.">Profiling and Tracing PL/SQL Programs</a>"</span>). With the many automatic optimizations of the PL/SQL optimizer (described in <span class="q">"<a href="plsql-optimization-and-tuning.html#GUID-8BC4231B-2E5C-47D6-BE14-6D75CE14C57E" title="One optimization that the compiler can perform is subprogram inlining.">PL/SQL Optimizer</a>"</span>), you might see performance improvements before doing any tuning.
                           </p>
                        </div>
                     </li>
                     <li>
                        <p>Older dynamic SQL statements written with the <code class="codeph">DBMS_SQL</code> package.
                        </p>
                        <p>If you know at compile time the number and data types of the input and output variables of a dynamic SQL statement, then you can rewrite the statement in native dynamic SQL, which runs noticeably faster than equivalent code that uses the <code class="codeph">DBMS_SQL</code> package (especially when it can be optimized by the compiler). For more information, see <a href="dynamic-sql.html#GUID-7E2F596F-9CA3-4DC8-8333-0C117962DB73" title="Dynamic SQL is a programming methodology for generating and running SQL statements at run time.">PL/SQL Dynamic SQL</a>.
                        </p>
                     </li>
                     <li>
                        <p>Code that spends much time processing SQL statements.</p>
                        <p>See <span class="q">"<a href="plsql-optimization-and-tuning.html#GUID-B7F4934F-1CE2-4B86-B1A3-659B6D89F1D9">Tune SQL Statements</a>"</span>.
                        </p>
                     </li>
                     <li>
                        <p>Functions invoked in queries, which might run millions of times.</p>
                        <p>See <span class="q">"<a href="plsql-optimization-and-tuning.html#GUID-C54C68DB-2C26-4D25-983D-1581C0CFDEDB" title="Functions invoked in queries might run millions of times. Do not invoke a function in a query unnecessarily, and make the invocation as efficient as possible.">Tune Function Invocations in Queries</a>"</span>.
                        </p>
                     </li>
                     <li>
                        <p>Code that spends much time looping through query results.</p>
                        <p>See <span class="q">"<a href="plsql-optimization-and-tuning.html#GUID-E95E2D71-F51D-4F09-B4BE-21093F760368">Tune Loops</a>"</span>.
                        </p>
                     </li>
                     <li>
                        <p>Code that does many numeric computations.</p>
                        <p>See <span class="q">"<a href="plsql-optimization-and-tuning.html#GUID-72F6B95C-4D02-4363-AA2C-82F9DB1C84B9">Tune Computation-Intensive PL/SQL Code</a>"</span>.
                        </p>
                     </li>
                     <li>
                        <p>Code that spends much time processing PL/SQL statements (as opposed to issuing database definition language (DDL) statements that PL/SQL passes directly to SQL).</p>
                        <p>See <span class="q">"<a href="plsql-optimization-and-tuning.html#GUID-7C4557E7-4C35-4CAB-A95D-CB96BDC6D487">Compiling PL/SQL Units for Native Execution</a>"</span>.
                        </p>
                     </li>
                  </ul>
               </div>
            </div><a id="LNPLS767"></a><a id="LNPLS863"></a><div class="props_rev_3"><a id="GUID-C2DC6043-17CC-4F9F-934D-A075133FBD01" name="GUID-C2DC6043-17CC-4F9F-934D-A075133FBD01"></a><h3 id="LNPLS-GUID-C2DC6043-17CC-4F9F-934D-A075133FBD01" class="sect3"><span class="enumeration_section">12.3 </span>Minimizing CPU Overhead
               </h3>
               <div>
                  <div class="section">
                     <p class="subhead2" id="GUID-C2DC6043-17CC-4F9F-934D-A075133FBD01__GUID-8E3642EA-DC3D-41FC-8ED9-91554A57EE2D">Topics</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="plsql-optimization-and-tuning.html#GUID-B7F4934F-1CE2-4B86-B1A3-659B6D89F1D9">Tune SQL Statements</a></p>
                        </li>
                        <li>
                           <p><a href="plsql-optimization-and-tuning.html#GUID-C54C68DB-2C26-4D25-983D-1581C0CFDEDB" title="Functions invoked in queries might run millions of times. Do not invoke a function in a query unnecessarily, and make the invocation as efficient as possible.">Tune Function Invocations in Queries</a></p>
                        </li>
                        <li>
                           <p><a href="plsql-optimization-and-tuning.html#GUID-2D616F80-2E1D-453A-B2A5-2B4E3288E33F" title="If a subprogram has OUT or IN OUT parameters, you can sometimes decrease its invocation overhead by declaring those parameters with the NOCOPY hint.">Tune Subprogram Invocations</a></p>
                        </li>
                        <li>
                           <p><a href="plsql-optimization-and-tuning.html#GUID-E95E2D71-F51D-4F09-B4BE-21093F760368">Tune Loops</a></p>
                        </li>
                        <li>
                           <p><a href="plsql-optimization-and-tuning.html#GUID-72F6B95C-4D02-4363-AA2C-82F9DB1C84B9">Tune Computation-Intensive PL/SQL Code</a></p>
                        </li>
                        <li>
                           <p><a href="plsql-optimization-and-tuning.html#GUID-1DD8891A-DC28-4B06-8788-C65008A1682D">Use SQL Character Functions</a></p>
                        </li>
                        <li>
                           <p><a href="plsql-optimization-and-tuning.html#GUID-84E8BD95-8E52-4168-85C7-816E653B41B3">Put Least Expensive Conditional Tests First</a></p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
               </div><a id="LNPLS864"></a><div class="props_rev_3"><a id="GUID-B7F4934F-1CE2-4B86-B1A3-659B6D89F1D9" name="GUID-B7F4934F-1CE2-4B86-B1A3-659B6D89F1D9"></a><h4 id="LNPLS-GUID-B7F4934F-1CE2-4B86-B1A3-659B6D89F1D9" class="sect4"><span class="enumeration_section">12.3.1 </span>Tune SQL Statements
                  </h4>
                  <div>
                     <div class="section">
                        <p>The most common cause of slowness in PL/SQL programs is slow SQL statements. To make SQL statements in a PL/SQL program as efficient as possible:</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Use appropriate indexes.</p>
                              <p>For details, see <a href="../admin/managing-indexes.html#ADMIN-GUID-E4149397-FF37-4367-A12F-675433715904" target="_blank">Oracle Database Performance Tuning Guide</a>.
                              </p>
                           </li>
                           <li>
                              <p>Use query hints to avoid unnecessary full-table scans.</p>
                              <p>For details, see <a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/lnpls&amp;id=SQLRF51107" target="_blank"><span class="italic">Oracle Database SQL Language Reference</span></a>.
                              </p>
                           </li>
                           <li>
                              <p>Collect current statistics on all tables, using the subprograms in the <code class="codeph">DBMS_STATS</code> package.
                              </p>
                              <p>For details, see <a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/lnpls&amp;id=TGSQL389" target="_blank"><span class="italic">Oracle Database Performance Tuning Guide</span></a>.
                              </p>
                           </li>
                           <li>
                              <p>Analyze the execution plans and performance of the SQL statements, using:</p>
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p><code class="codeph">EXPLAIN</code> <code class="codeph">PLAN</code> statement
                                    </p>
                                    <p>For details, see <a href="../tgsql/generating-and-displaying-execution-plans.html#TGSQL271" target="_blank"><span class="italic">Oracle Database Performance Tuning Guide</span></a>.
                                    </p>
                                 </li>
                                 <li>
                                    <p>SQL Trace facility with <code class="codeph">TKPROF</code> utility
                                    </p>
                                    <p>For details, see <a href="../tgsql/performing-application-tracing.html#TGSQL809" target="_blank"><span class="italic">Oracle Database Performance Tuning Guide</span></a>.
                                    </p>
                                 </li>
                              </ul>
                           </li>
                           <li>
                              <p>Use bulk SQL, a set of PL/SQL features that minimizes the performance overhead of the communication between PL/SQL and SQL.</p>
                              <p>For details, see <span class="q">"<a href="plsql-optimization-and-tuning.html#GUID-61D1B533-DBB9-4150-91F9-0A4C9428391E" title="Bulk SQL minimizes the performance overhead of the communication between PL/SQL and SQL. The PL/SQL features that comprise bulk SQL are the FORALL statement and the BULK COLLECT clause. Assigning values to PL/SQL variables that appear in SQL statements is called binding.">Bulk SQL and Bulk Binding</a>"</span>.
                              </p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPLS866"></a><a id="LNPLS865"></a><div class="props_rev_3"><a id="GUID-C54C68DB-2C26-4D25-983D-1581C0CFDEDB" name="GUID-C54C68DB-2C26-4D25-983D-1581C0CFDEDB"></a><h4 id="LNPLS-GUID-C54C68DB-2C26-4D25-983D-1581C0CFDEDB" class="sect4"><span class="enumeration_section">12.3.2 </span>Tune Function Invocations in Queries
                  </h4>
                  <div>
                     <p>Functions invoked in queries might run millions of times. Do not invoke a function in a query unnecessarily, and make the invocation as efficient as possible.</p>
                     <div class="section">
                        <p>Create a function-based index on the table in the query. The <code class="codeph">CREATE</code> <code class="codeph">INDEX</code> statement might take a while, but the query can run much faster because the function value for each row is cached.
                        </p>
                        <p>If the query passes a column to a function, then the query cannot use user-created indexes on that column, so the query might invoke the function for every row of the table (which might be very large). To minimize the number of function invocations, use a nested query. Have the inner query filter the result set to a small number of rows, and have the outer query invoke the function for only those rows.</p>
                        <div class="infoboxnotealso" id="GUID-C54C68DB-2C26-4D25-983D-1581C0CFDEDB__GUID-7F783E3E-1358-47F4-9DE9-5AB73A2BD4E4">
                           <p class="notep1">See Also:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><a href="../sqlrf/CREATE-INDEX.html#SQLRF01209" target="_blank"><span class="italic">Oracle Database SQL Language Reference</span></a> for more information about <code class="codeph">CREATE</code> <code class="codeph">INDEX</code> statement syntax
                                 </p>
                              </li>
                              <li>
                                 <p><span class="q">"<a href="plsql-subprograms.html#GUID-250BDBBB-0CD6-4D56-9DDF-6FCEDC110D00" title="When a PL/SQL function has the RESULT_CACHE option, its results are cached in the shared global area (SGA) so sessions connected to the same instance can reuse these results when available.">PL/SQL Function Result Cache</a>"</span> for information about caching the results of PL/SQL functions
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-C54C68DB-2C26-4D25-983D-1581C0CFDEDB__BABFCFDB">
                        <p class="titleinexample">Example 12-5 Nested Query Improves Performance</p>
                        <p>In this example, the two queries produce the same result set, but the second query is more efficient than the first. (In the example, the times and time difference are very small, because the <code class="codeph">EMPLOYEES</code> table is very small. For a very large table, they would be significant.)
                        </p><pre class="oac_no_warn" dir="ltr">DECLARE
  starting_time  TIMESTAMP WITH TIME ZONE;
  ending_time    TIMESTAMP WITH TIME ZONE;
BEGIN
  <span class="bold">-- Invokes SQRT for every row of employees table:</span>
 
  SELECT SYSTIMESTAMP INTO starting_time FROM DUAL;
 
  FOR item IN (
    SELECT <span class="bold">DISTINCT(SQRT(department_id))</span> col_alias
    FROM employees
    ORDER BY col_alias
  )
  LOOP
    DBMS_OUTPUT.PUT_LINE('Square root of dept. ID = ' || item.col_alias);
  END LOOP;
 
  SELECT SYSTIMESTAMP INTO ending_time FROM DUAL;
 
  DBMS_OUTPUT.PUT_LINE('Time = ' || TO_CHAR(ending_time - starting_time));
 
  <span class="bold">-- Invokes SQRT for every distinct department_id of employees table:</span>
 
  SELECT SYSTIMESTAMP INTO starting_time FROM DUAL;
 
  FOR item IN (
    SELECT <span class="bold">SQRT(department_id)</span> col_alias
    FROM <span class="bold">(SELECT DISTINCT department_id FROM employees)</span>
    ORDER BY col_alias
  )
  LOOP
    IF item.col_alias IS NOT NULL THEN
      DBMS_OUTPUT.PUT_LINE('Square root of dept. ID = ' || item.col_alias);
    END IF;
  END LOOP;
 
  SELECT SYSTIMESTAMP INTO ending_time FROM DUAL;
 
  DBMS_OUTPUT.PUT_LINE('Time = ' || TO_CHAR(ending_time - starting_time));
END;
/
</pre><p>Result is similar to:</p><pre class="oac_no_warn" dir="ltr">Square root of dept. ID = 3.16227766016837933199889354443271853372
Square root of dept. ID = 4.47213595499957939281834733746255247088
Square root of dept. ID = 5.47722557505166113456969782800802133953
Square root of dept. ID = 6.32455532033675866399778708886543706744
Square root of dept. ID = 7.07106781186547524400844362104849039285
Square root of dept. ID = 7.74596669241483377035853079956479922167
Square root of dept. ID = 8.36660026534075547978172025785187489393
Square root of dept. ID = 8.94427190999915878563669467492510494176
Square root of dept. ID = 9.48683298050513799599668063329815560116
Square root of dept. ID = 10
Square root of dept. ID = 10.48808848170151546991453513679937598475
<span class="bold">Time = +000000000 00:00:00.046000000</span>
Square root of dept. ID = 3.16227766016837933199889354443271853372
Square root of dept. ID = 4.47213595499957939281834733746255247088
Square root of dept. ID = 5.47722557505166113456969782800802133953
Square root of dept. ID = 6.32455532033675866399778708886543706744
Square root of dept. ID = 7.07106781186547524400844362104849039285
Square root of dept. ID = 7.74596669241483377035853079956479922167
Square root of dept. ID = 8.36660026534075547978172025785187489393
Square root of dept. ID = 8.94427190999915878563669467492510494176
Square root of dept. ID = 9.48683298050513799599668063329815560116
Square root of dept. ID = 10
Square root of dept. ID = 10.48808848170151546991453513679937598475
<span class="bold">Time = +000000000 00:00:00.000000000</span></pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="LNPLS908"></a><a id="LNPLS01208"></a><div class="props_rev_3"><a id="GUID-2D616F80-2E1D-453A-B2A5-2B4E3288E33F" name="GUID-2D616F80-2E1D-453A-B2A5-2B4E3288E33F"></a><h4 id="LNPLS-GUID-2D616F80-2E1D-453A-B2A5-2B4E3288E33F" class="sect4"><span class="enumeration_section">12.3.3 </span>Tune Subprogram Invocations
                  </h4>
                  <div>
                     <p>If a subprogram has <code class="codeph">OUT</code> or <code class="codeph">IN</code> <code class="codeph">OUT</code> parameters, you can sometimes decrease its invocation overhead by declaring those parameters with the <code class="codeph">NOCOPY</code> hint.
                     </p>
                     <div class="section">
                        <p>When <code class="codeph">OUT</code> or <code class="codeph">IN</code> <code class="codeph">OUT</code> parameters represent large data structures such as collections, records, and instances of ADTs, copying them slows execution and increases memory use—especially for an instance of an ADT.
                        </p>
                        <p>For each invocation of an ADT method, PL/SQL copies every attribute of the ADT. If the method is exited normally, then PL/SQL applies any changes that the method made to the attributes. If the method is exited with an unhandled exception, then PL/SQL does not change the attributes.</p>
                        <p>If your program does not require that an <code class="codeph">OUT</code> or <code class="codeph">IN</code> <code class="codeph">OUT</code> parameter retain its pre-invocation value if the subprogram ends with an unhandled exception, then include the <code class="codeph">NOCOPY</code> hint in the parameter declaration. The <code class="codeph">NOCOPY</code> hint requests (but does not ensure) that the compiler pass the corresponding actual parameter by reference instead of value.
                        </p>
                        <div class="infoboxnote" id="GUID-2D616F80-2E1D-453A-B2A5-2B4E3288E33F__GUID-6AF3E7BE-B6DE-4C92-A502-E66B839867CB">
                           <p class="notep1">Caution:</p>
                           <p>Do not rely on <code class="codeph">NOCOPY</code> (which the compiler might or might not obey for a particular invocation) to ensure that an actual parameter or ADT attribute retains its pre-invocation value if the subprogram is exited with an unhandled exception. Instead, ensure that the subprogram handle all exceptions.
                           </p>
                        </div>
                        <div class="infoboxnotealso" id="GUID-2D616F80-2E1D-453A-B2A5-2B4E3288E33F__GUID-68D36380-21A2-49D1-A12C-015C41258F4A">
                           <p class="notep1">See Also:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><span class="q">"<a href="formal-parameter-declaration.html#GUID-5BA8E033-96B9-439A-A4FC-4844FEC14AD8__CJACJCGJ">NOCOPY</a>"</span> for more information about <code class="codeph">NOCOPY</code> hint
                                 </p>
                              </li>
                              <li>
                                 <p><a href="../adobj/design-considerations-for-methods.html#ADOBJ00853" target="_blank"><span class="italic">Oracle Database Object-Relational Developer's Guide</span></a> for information about using <code class="codeph">NOCOPY</code> with member methods of ADTs
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-2D616F80-2E1D-453A-B2A5-2B4E3288E33F__BABDDAFG">
                        <p class="titleinexample">Example 12-6 NOCOPY Subprogram Parameters</p>
                        <p>In this example, if the compiler obeys the <code class="codeph">NOCOPY</code> hint for the invocation of <code class="codeph">do_nothing2</code>, then the invocation of <code class="codeph">do_nothing2</code> is faster than the invocation of <code class="codeph">do_nothing1</code>.
                        </p><pre class="oac_no_warn" dir="ltr">DECLARE
  TYPE EmpTabTyp IS TABLE OF employees%ROWTYPE;
  emp_tab EmpTabTyp := EmpTabTyp(NULL);  -- initialize
  t1 NUMBER;
  t2 NUMBER;
  t3 NUMBER;

  PROCEDURE get_time (t OUT NUMBER) IS
  BEGIN
    t := DBMS_UTILITY.get_time;
  END;

  <span class="bold">PROCEDURE do_nothing1 (tab IN OUT EmpTabTyp)</span> IS
  BEGIN
    NULL;
  END;

  <span class="bold">PROCEDURE do_nothing2 (tab IN OUT NOCOPY EmpTabTyp)</span> IS
  BEGIN
    NULL;
  END;

BEGIN
  SELECT * INTO emp_tab(1)
  FROM employees
  WHERE employee_id = 100;

  emp_tab.EXTEND(49999, 1);  -- Copy element 1 into 2..50000
  get_time(t1);
  do_nothing1(emp_tab);  -- Pass IN OUT parameter
  get_time(t2);
  do_nothing2(emp_tab);  -- Pass IN OUT NOCOPY parameter
  get_time(t3);
  DBMS_OUTPUT.PUT_LINE ('Call Duration (secs)');
  DBMS_OUTPUT.PUT_LINE ('--------------------');
  DBMS_OUTPUT.PUT_LINE ('Just IN OUT: ' || TO_CHAR((t2 - t1)/100.0));
  DBMS_OUTPUT.PUT_LINE ('With NOCOPY: ' || TO_CHAR((t3 - t2))/100.0);
END;
/</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="LNPLS867"></a><div class="props_rev_3"><a id="GUID-E95E2D71-F51D-4F09-B4BE-21093F760368" name="GUID-E95E2D71-F51D-4F09-B4BE-21093F760368"></a><h4 id="LNPLS-GUID-E95E2D71-F51D-4F09-B4BE-21093F760368" class="sect4"><span class="enumeration_section">12.3.4 </span>Tune Loops
                  </h4>
                  <div>
                     <div class="section">
                        <p>Because PL/SQL applications are often built around loops, it is important to optimize both the loops themselves and the code inside them.</p>
                        <p>If you must loop through a result set more than once, or issue other queries as you loop through a result set, you might be able to change the original query to give you exactly the results you want. Explore the SQL set operators that let you combine multiple queries, described in <a href="../sqlrf/The-UNION-ALL-INTERSECT-MINUS-Operators.html#SQLRF52341" target="_blank"><span class="italic">Oracle Database SQL Language Reference</span></a>.
                        </p>
                        <p>You can also use subqueries to do the filtering and sorting in multiple stages—see <span class="q">"<a href="static-sql.html#GUID-8DD487B1-1CC5-4F26-98F2-97753A7EEF70" title="If you process a query result set by looping through it and running another query for each row, then you can improve performance by removing the second query from inside the loop and making it a subquery of the first query.">Processing Query Result Sets with Subqueries</a>"</span>.
                        </p>
                        <div class="infoboxnotealso" id="GUID-E95E2D71-F51D-4F09-B4BE-21093F760368__GUID-5DFD80F5-D3B5-4405-867D-CA0FC4A058CF">
                           <p class="notep1">See Also:</p>
                           <p><span class="q">"<a href="plsql-optimization-and-tuning.html#GUID-61D1B533-DBB9-4150-91F9-0A4C9428391E" title="Bulk SQL minimizes the performance overhead of the communication between PL/SQL and SQL. The PL/SQL features that comprise bulk SQL are the FORALL statement and the BULK COLLECT clause. Assigning values to PL/SQL variables that appear in SQL statements is called binding.">Bulk SQL and Bulk Binding</a>"</span></p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPLS768"></a><a id="LNPLS01206"></a><div class="props_rev_3"><a id="GUID-72F6B95C-4D02-4363-AA2C-82F9DB1C84B9" name="GUID-72F6B95C-4D02-4363-AA2C-82F9DB1C84B9"></a><h4 id="LNPLS-GUID-72F6B95C-4D02-4363-AA2C-82F9DB1C84B9" class="sect4"><span class="enumeration_section">12.3.5 </span>Tune Computation-Intensive PL/SQL Code
                  </h4>
                  <div>
                     <div class="section">
                        <p>These recommendations apply especially (but not only) to computation-intensive PL/SQL code.</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-72F6B95C-4D02-4363-AA2C-82F9DB1C84B9__GUID-74A4B6A3-A26B-4B05-8DE9-4090665942C0">Topics</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><a href="plsql-optimization-and-tuning.html#GUID-CB9BF149-8E00-45F1-99E8-AC42795CF6D0">Use Data Types that Use Hardware Arithmetic</a></p>
                           </li>
                           <li>
                              <p><a href="plsql-optimization-and-tuning.html#GUID-216633A5-8719-48B2-B95D-78DBF3DF0D4B">Avoid Constrained Subtypes in Performance-Critical Code</a></p>
                           </li>
                           <li>
                              <p><a href="plsql-optimization-and-tuning.html#GUID-F7BAB3B2-3492-4246-A7D0-83AE9F015D85">Minimize Implicit Data Type Conversion</a></p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div><a id="LNPLS99859"></a><div class="sect4"><a id="GUID-CB9BF149-8E00-45F1-99E8-AC42795CF6D0" name="GUID-CB9BF149-8E00-45F1-99E8-AC42795CF6D0"></a><h5 id="LNPLS-GUID-CB9BF149-8E00-45F1-99E8-AC42795CF6D0" class="sect5"><span class="enumeration_section">12.3.5.1 </span>Use Data Types that Use Hardware Arithmetic
                     </h5>
                     <div>
                        <p>Avoid using data types in the <code class="codeph">NUMBER</code> data type family (described in <span class="q">"<a href="plsql-predefined-data-types.html#GUID-1D28B7B6-15AE-454A-8134-F8724551AE8B__CDFJEBIF">NUMBER Data Type Family</a>"</span>). These data types are represented internally in a format designed for portability and arbitrary scale and precision, not for performance. Operations on data of these types use library arithmetic, while operations on data of the types <code class="codeph">PLS_INTEGER</code>, <code class="codeph">BINARY_FLOAT</code> and <code class="codeph">BINARY_DOUBLE</code> use hardware arithmetic.
                        </p>
                        <p>For local integer variables, use <code class="codeph">PLS_INTEGER</code>, described in <span class="q">"<a href="plsql-data-types.html#GUID-9517B7AC-9CEA-4C36-A454-52588BEEBE8F" title="The PL/SQL data types PLS_INTEGER and BINARY_INTEGER are identical.">PLS_INTEGER and BINARY_INTEGER Data Types</a>"</span>. For variables used in performance-critical code, that can never have the value <code class="codeph">NULL</code>, and do not need overflow checking, use <code class="codeph">SIMPLE_INTEGER</code>, described in <span class="q">"<a href="plsql-data-types.html#GUID-84C413B0-BDCA-4ABC-B402-3B8CED013DAF" title="SIMPLE_INTEGER is a predefined subtype of the PLS_INTEGER data type.">SIMPLE_INTEGER Subtype of PLS_INTEGER</a>"</span>.
                        </p>
                        <p>For floating-point variables, use  <code class="codeph">BINARY_FLOAT</code> or <code class="codeph">BINARY_DOUBLE</code>, described in <a href="../sqlrf/Data-Types.html#SQLRF00209" target="_blank"><span class="italic">Oracle Database SQL Language Reference</span></a>. For variables used in performance-critical code, that can never have the value <code class="codeph">NULL</code>, and that do not need overflow checking, use <code class="codeph">SIMPLE_FLOAT</code> or <code class="codeph">SIMPLE_DOUBLE</code>, explained in <span class="q">"<a href="plsql-data-types.html#GUID-48101DAA-B168-4648-A05A-CA81A9512E8C">Additional PL/SQL Subtypes of BINARY_FLOAT and BINARY_DOUBLE</a>"</span>.
                        </p>
                        <div class="infoboxnote" id="GUID-CB9BF149-8E00-45F1-99E8-AC42795CF6D0__GUID-8020B380-E847-4131-AB7B-B07A830F93F1">
                           <p class="notep1">Note:</p>
                           <p><code class="codeph">BINARY_FLOAT</code> and <code class="codeph">BINARY_DOUBLE</code> and their subtypes are less suitable for financial code where accuracy is critical, because they do not always represent fractional values precisely, and handle rounding differently than the <code class="codeph">NUMBER</code> types.
                           </p>
                        </div>
                        <p>Many SQL numeric functions (described in <a href="../sqlrf/Single-Row-Functions.html#SQLRF20031" target="_blank"><span class="italic">Oracle Database SQL Language Reference</span></a>) are overloaded with versions that accept <code class="codeph">BINARY_FLOAT</code> and <code class="codeph">BINARY_DOUBLE</code> parameters. You can speed up computation-intensive code by passing variables of these data types to such functions, and by invoking the conversion functions <code class="codeph">TO_BINARY_FLOAT</code> (described in <a href="../sqlrf/TO_BINARY_FLOAT.html#SQLRF06310" target="_blank"><span class="italic">Oracle Database SQL Language Reference</span></a>) and <code class="codeph">TO_BINARY_DOUBLE</code> (described in <a href="../sqlrf/TO_BINARY_DOUBLE.html#SQLRF06309" target="_blank"><span class="italic">Oracle Database SQL Language Reference</span></a>) when passing expressions to such functions.
                        </p>
                     </div>
                  </div><a id="LNPLS99858"></a><div class="props_rev_3"><a id="GUID-216633A5-8719-48B2-B95D-78DBF3DF0D4B" name="GUID-216633A5-8719-48B2-B95D-78DBF3DF0D4B"></a><h5 id="LNPLS-GUID-216633A5-8719-48B2-B95D-78DBF3DF0D4B" class="sect5"><span class="enumeration_section">12.3.5.2 </span>Avoid Constrained Subtypes in Performance-Critical Code
                     </h5>
                     <div>
                        <div class="section">
                           <p>In performance-critical code, avoid constrained subtypes (described in <span class="q">"<a href="plsql-data-types.html#GUID-FDC366F3-66AA-4F6A-A59B-5A08DCBD4F9F" title="A constrained subtype has only a subset of the values of its base type.">Constrained Subtypes</a>"</span>). Each assignment to a variable or parameter of a constrained subtype requires extra checking at run time to ensure that the value to be assigned does not violate the constraint.
                           </p>
                           <div class="infoboxnotealso" id="GUID-216633A5-8719-48B2-B95D-78DBF3DF0D4B__GUID-DD034082-05DD-4630-8509-90D01B53A59F">
                              <p class="notep1">See Also:</p>
                              <p><a href="plsql-predefined-data-types.html#GUID-1D28B7B6-15AE-454A-8134-F8724551AE8B">PL/SQL Predefined Data Types</a> includes predefined constrained subtypes
                              </p>
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNPLS870"></a><div class="props_rev_3"><a id="GUID-F7BAB3B2-3492-4246-A7D0-83AE9F015D85" name="GUID-F7BAB3B2-3492-4246-A7D0-83AE9F015D85"></a><h5 id="LNPLS-GUID-F7BAB3B2-3492-4246-A7D0-83AE9F015D85" class="sect5"><span class="enumeration_section">12.3.5.3 </span>Minimize Implicit Data Type Conversion
                     </h5>
                     <div>
                        <div class="section">
                           <p>At run time, PL/SQL converts between different data types implicitly (automatically) if necessary. For example, if you assign a <code class="codeph">PLS_INTEGER</code> variable to a <code class="codeph">NUMBER</code> variable, then PL/SQL converts the <code class="codeph">PLS_INTEGER</code> value to a <code class="codeph">NUMBER</code> value (because the internal representations of the values differ).
                           </p>
                           <p>Whenever possible, minimize implicit conversions. For example:</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>If a variable is to be either inserted into a table column or assigned a value from a table column, then give the variable the same data type as the table column.</p>
                                 <div class="infobox-tip" id="GUID-F7BAB3B2-3492-4246-A7D0-83AE9F015D85__GUID-59A6F2A9-6943-4DEB-90E1-021C95553BCF">
                                    <p class="notep1">Tip:</p>
                                    <p>Declare the variable with the <code class="codeph">%TYPE</code> attribute, described in <span class="q">"<a href="TYPE-attribute.html#GUID-EAB44F7E-B2AB-4AC6-B83D-B586193D75FC" title="The %TYPE attribute lets you declare a constant, variable, collection element, record field, or subprogram parameter to be of the same data type as a previously declared variable or column (without knowing what that type is).">%TYPE Attribute</a>"</span>.
                                    </p>
                                 </div>
                              </li>
                              <li>
                                 <p>Make each literal the same data type as the variable to which it is assigned or the expression in which it appears.</p>
                              </li>
                              <li>
                                 <p>Convert values from SQL data types to PL/SQL data types and then use the converted values in expressions.</p>
                                 <p>For example, convert <code class="codeph">NUMBER</code> values to <code class="codeph">PLS_INTEGER</code> values and then use the <code class="codeph">PLS_INTEGER</code> values in expressions. <code class="codeph">PLS_INTEGER</code> operations use hardware arithmetic, so they are faster than <code class="codeph">NUMBER</code> operations, which use library arithmetic. For more information about the <code class="codeph">PLS_INTEGER</code> data type, see <span class="q">"<a href="plsql-data-types.html#GUID-9517B7AC-9CEA-4C36-A454-52588BEEBE8F" title="The PL/SQL data types PLS_INTEGER and BINARY_INTEGER are identical.">PLS_INTEGER and BINARY_INTEGER Data Types</a>"</span>.
                                 </p>
                              </li>
                              <li>
                                 <p>Before assigning a value of one SQL data type to a variable of another SQL data type, explicitly convert the source value to the target data type, using a SQL conversion function (for information about SQL conversion functions, see <a href="../sqlrf/Single-Row-Functions.html#SQLRF20034" target="_blank"><span class="italic">Oracle Database SQL Language Reference</span></a>).
                                 </p>
                              </li>
                              <li>
                                 <p>Overload your subprograms with versions that accept parameters of different data types and optimize each version for its parameter types. For information about overloaded subprograms, see <span class="q">"<a href="plsql-subprograms.html#GUID-47D5A50E-7AAF-4C80-A06A-37593EA2526A">Overloaded Subprograms</a>"</span>.
                                 </p>
                              </li>
                           </ul>
                           <div class="infoboxnotealso" id="GUID-F7BAB3B2-3492-4246-A7D0-83AE9F015D85__GUID-BB2C2512-1A0B-4685-8C6B-746F80495B97">
                              <p class="notep1">See Also:</p>
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p><a href="../sqlrf/Data-Type-Comparison-Rules.html#SQLRF51047" target="_blank"><span class="italic">Oracle Database SQL Language Reference</span></a> for information about implicit conversion of SQL data types (which are also PL/SQL data types)
                                    </p>
                                 </li>
                                 <li>
                                    <p><span class="q">"<a href="plsql-data-types.html#GUID-126CB7F3-7E65-40BC-B6CD-2244B63240A7" title="If two subtypes have different base types in the same data type family, then one subtype can be implicitly converted to the other only if the source value does not violate a constraint of the target subtype.">Subtypes with Base Types in Same Data Type Family</a>"</span></p>
                                 </li>
                              </ul>
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="LNPLS868"></a><div class="props_rev_3"><a id="GUID-1DD8891A-DC28-4B06-8788-C65008A1682D" name="GUID-1DD8891A-DC28-4B06-8788-C65008A1682D"></a><h4 id="LNPLS-GUID-1DD8891A-DC28-4B06-8788-C65008A1682D" class="sect4"><span class="enumeration_section">12.3.6 </span>Use SQL Character Functions
                  </h4>
                  <div>
                     <div class="section">
                        <p>SQL has many highly optimized character functions, which use low-level code that is more efficient than PL/SQL code. Use these functions instead of writing PL/SQL code to do the same things.</p>
                        <div class="infoboxnote" id="GUID-1DD8891A-DC28-4B06-8788-C65008A1682D__GUID-442DE351-A1CA-454B-8C14-4ADE0CDAE862">
                           <p class="notep1">See:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><a href="../sqlrf/Single-Row-Functions.html#SQLRF20032" target="_blank"><span class="italic">Oracle Database SQL Language Reference</span></a> for information about SQL character functions that return character values
                                 </p>
                              </li>
                              <li>
                                 <p><a href="../sqlrf/Single-Row-Functions.html#SQLRF51179" target="_blank"><span class="italic">Oracle Database SQL Language Reference</span></a> for information about SQL character functions that return NLS character values
                                 </p>
                              </li>
                              <li>
                                 <p><a href="../sqlrf/Single-Row-Functions.html#SQLRF51180" target="_blank"><span class="italic">Oracle Database SQL Language Reference</span></a> for information about SQL character functions that return number values
                                 </p>
                              </li>
                              <li>
                                 <p><a href="static-sql.html#GUID-9DEED64C-A87E-4EAD-97DA-ABDD3FDF172C__BABCFDJE">Example 6-6</a> for an example of PL/SQL code that uses SQL character function <code class="codeph">REGEXP_LIKE</code></p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPLS869"></a><div class="props_rev_3"><a id="GUID-84E8BD95-8E52-4168-85C7-816E653B41B3" name="GUID-84E8BD95-8E52-4168-85C7-816E653B41B3"></a><h4 id="LNPLS-GUID-84E8BD95-8E52-4168-85C7-816E653B41B3" class="sect4"><span class="enumeration_section">12.3.7 </span>Put Least Expensive Conditional Tests First
                  </h4>
                  <div>
                     <div class="section">
                        <p>PL/SQL stops evaluating a logical expression as soon as it can determine the result. Take advantage of this short-circuit evaluation by putting the conditions that are least expensive to evaluate first in logical expressions whenever possible. For example, test the values of PL/SQL variables before testing function return values, so that if the variable tests fail, PL/SQL need not invoke the functions:</p><pre class="oac_no_warn" dir="ltr">IF <span class="italic">boolean_variable</span> OR (<span class="italic">number</span> &gt; 10) OR <span class="italic">boolean_function</span>(<span class="italic">parameter</span>) THEN ...</pre><div class="infoboxnotealso" id="GUID-84E8BD95-8E52-4168-85C7-816E653B41B3__GUID-0738870E-0C76-4165-B697-04EB59B79008">
                           <p class="notep1">See Also:</p>
                           <p><span class="q">"<a href="plsql-language-fundamentals.html#GUID-26565CE3-726A-4E29-8A24-1F6AD8EC780B" title="When evaluating a logical expression, PL/SQL uses short-circuit evaluation. That is, PL/SQL stops evaluating the expression as soon as it can determine the result.">Short-Circuit Evaluation</a>"</span></p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="LNPLS791"></a><a id="LNPLS01205"></a><div class="props_rev_3"><a id="GUID-61D1B533-DBB9-4150-91F9-0A4C9428391E" name="GUID-61D1B533-DBB9-4150-91F9-0A4C9428391E"></a><h3 id="LNPLS-GUID-61D1B533-DBB9-4150-91F9-0A4C9428391E" class="sect3"><span class="enumeration_section">12.4 </span>Bulk SQL and Bulk Binding
               </h3>
               <div>
                  <p><span class="bold">Bulk SQL</span> minimizes the performance overhead of the communication between PL/SQL and SQL. The PL/SQL features that comprise bulk SQL are the <code class="codeph">FORALL</code> statement and the <code class="codeph">BULK</code> <code class="codeph">COLLECT</code> clause. Assigning values to PL/SQL variables that appear in SQL statements is called <span class="bold">binding</span>.
                  </p>
                  <p>PL/SQL and SQL communicate as follows: To run a <code class="codeph">SELECT</code> <code class="codeph">INTO</code> or DML statement, the PL/SQL engine sends the query or DML statement to the SQL engine. The SQL engine runs the query or DML statement and returns the result to the PL/SQL engine.
                  </p>
                  <p>The <code class="codeph">FORALL</code> statement sends DML statements from PL/SQL to SQL in batches rather than one at a time. The <code class="codeph">BULK</code> <code class="codeph">COLLECT</code> clause returns results from SQL to PL/SQL in batches rather than one at a time. If a query or DML statement affects four or more database rows, then bulk SQL can significantly improve performance.
                  </p>
                  <div class="infoboxnote" id="GUID-61D1B533-DBB9-4150-91F9-0A4C9428391E__GUID-32867868-3D37-429A-A90D-4E2E002C7C34">
                     <p class="notep1">Note:</p>
                     <p>You cannot perform bulk SQL on remote tables.</p>
                  </div>
                  <p> PL/SQL binding operations fall into these categories:</p>
                  <div class="tblformal" id="GUID-61D1B533-DBB9-4150-91F9-0A4C9428391E__GUID-CE1025C0-7705-40DC-9085-EFBC7E941016">
                     <table cellpadding="4" cellspacing="0" class="Formal" title="" summary="This table summarizes the categories of PL/SQL binding operations." width="100%" frame="hsides" border="1" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="22%" id="d89034e2693">Binding Category</th>
                              <th align="left" valign="bottom" width="78%" id="d89034e2696">When This Binding Occurs</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="22%" id="d89034e2701" headers="d89034e2693 ">
                                 <p>In-bind</p>
                              </td>
                              <td align="left" valign="top" width="78%" headers="d89034e2701 d89034e2696 ">
                                 <p>When an <code class="codeph">INSERT</code>, <code class="codeph">UPDATE</code>, or <code class="codeph">MERGE</code> statement stores a PL/SQL or host variable in the database
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="22%" id="d89034e2717" headers="d89034e2693 ">
                                 <p>Out-bind</p>
                              </td>
                              <td align="left" valign="top" width="78%" headers="d89034e2717 d89034e2696 ">
                                 <p>When the <code class="codeph">RETURNING</code> <code class="codeph">INTO</code> clause of an <code class="codeph">INSERT</code>, <code class="codeph">UPDATE</code>, or <code class="codeph">DELETE</code> statement assigns a database value to a PL/SQL or host variable
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="22%" id="d89034e2739" headers="d89034e2693 ">
                                 <p><code class="codeph">DEFINE</code></p>
                              </td>
                              <td align="left" valign="top" width="78%" headers="d89034e2739 d89034e2696 ">
                                 <p>When a <code class="codeph">SELECT</code> or <code class="codeph">FETCH</code> statement assigns a database value to a PL/SQL or host variable
                                 </p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
                  <p>For in-binds and out-binds, bulk SQL uses <span class="bold">bulk binding</span>; that is, it binds an entire collection of values at once. For a collection of <span class="italic">n</span> elements, bulk SQL uses a single operation to perform the equivalent of <span class="italic">n</span> <code class="codeph">SELECT</code> <code class="codeph">INTO</code> or DML statements. A query that uses bulk SQL can return any number of rows, without using a <code class="codeph">FETCH</code> statement for each one.
                  </p>
                  <div class="infoboxnote" id="GUID-61D1B533-DBB9-4150-91F9-0A4C9428391E__GUID-BEBFDA2B-4EFF-4470-837D-DF24B72517BC">
                     <p class="notep1">Note:</p>
                     <p>Parallel DML is disabled with bulk SQL.</p>
                  </div>
                  <div class="section">
                     <p class="subhead2" id="GUID-61D1B533-DBB9-4150-91F9-0A4C9428391E__GUID-07706C23-15FC-424A-8786-92B4E51925B0">Topics</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="plsql-optimization-and-tuning.html#GUID-6D4A1425-64DD-4723-8AAE-87B0A51A2854" title="The FORALL statement, a feature of bulk SQL, sends DML statements from PL/SQL to SQL in batches rather than one at a time.">FORALL Statement</a></p>
                        </li>
                        <li>
                           <p><a href="plsql-optimization-and-tuning.html#GUID-19F50644-C88E-49AF-B31C-3EE4B4432714" title="The BULK COLLECT clause, a feature of bulk SQL, returns results from SQL to PL/SQL in batches rather than one at a time.">BULK COLLECT Clause</a></p>
                        </li>
                        <li>
                           <p><a href="plsql-optimization-and-tuning.html#GUID-D67D19A6-4717-4556-B027-15C3DED0519A" title="In a FORALL statement, the DML statement can have a RETURNING BULK COLLECT INTO clause. For each iteration of the FORALL statement, the DML statement stores the specified values in the specified collections—without overwriting the previous values, as the same DML statement would do in a FOR LOOP statement.">Using FORALL Statement and BULK COLLECT Clause Together</a></p>
                        </li>
                        <li>
                           <p><a href="plsql-optimization-and-tuning.html#GUID-14F071C6-C0AE-4D39-803F-420840FD34AB" title="Client programs (such as OCI and Pro*C programs) can use PL/SQL anonymous blocks to bulk-bind input and output host arrays. This is the most efficient way to pass collections to and from the database server.">Client Bulk-Binding of Host Arrays</a></p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
               </div><a id="LNPLS799"></a><a id="LNPLS792"></a><a id="LNPLS793"></a><a id="LNPLS881"></a><a id="LNPLS882"></a><a id="LNPLS879"></a><div class="props_rev_3"><a id="GUID-6D4A1425-64DD-4723-8AAE-87B0A51A2854" name="GUID-6D4A1425-64DD-4723-8AAE-87B0A51A2854"></a><h4 id="LNPLS-GUID-6D4A1425-64DD-4723-8AAE-87B0A51A2854" class="sect4"><span class="enumeration_section">12.4.1 </span>FORALL Statement
                  </h4>
                  <div>
                     <p>The <code class="codeph">FORALL</code> statement, a feature of bulk SQL, sends DML statements from PL/SQL to SQL in batches rather than one at a time. 
                     </p>
                     <p>To understand the <code class="codeph">FORALL</code> statement, first consider the <code class="codeph">FOR</code> <code class="codeph">LOOP</code> statement in <a href="plsql-optimization-and-tuning.html#GUID-6D4A1425-64DD-4723-8AAE-87B0A51A2854__BABBCECH">Example 12-7</a>. It sends these DML statements from PL/SQL to SQL one at a time:
                     </p><pre class="oac_no_warn" dir="ltr">DELETE FROM employees_temp WHERE department_id = depts(10);
DELETE FROM employees_temp WHERE department_id = depts(30);
DELETE FROM employees_temp WHERE department_id = depts(70);</pre><p>Now consider the <code class="codeph">FORALL</code> statement in <a href="plsql-optimization-and-tuning.html#GUID-6D4A1425-64DD-4723-8AAE-87B0A51A2854__BABDBAAJ">Example 12-8</a>. It sends the same three DML statements from PL/SQL to SQL as a batch.
                     </p>
                     <p>A <code class="codeph">FORALL</code> statement is usually much faster than an equivalent <code class="codeph">FOR</code> <code class="codeph">LOOP</code> statement. However, a <code class="codeph">FOR</code> <code class="codeph">LOOP</code> statement can contain multiple DML statements, while a <code class="codeph">FORALL</code> statement can contain only one. The batch of DML statements that a <code class="codeph">FORALL</code> statement sends to SQL differ only in their <code class="codeph">VALUES</code> and <code class="codeph">WHERE</code> clauses. The values in those clauses must come from existing, populated collections.
                     </p>
                     <div class="infoboxnote" id="GUID-6D4A1425-64DD-4723-8AAE-87B0A51A2854__GUID-35DC51EA-1809-4D27-A740-40D5973A8E1D">
                        <p class="notep1">Note:</p>
                        <p>The DML statement in a <code class="codeph">FORALL</code> statement can reference multiple collections, but performance benefits apply only to collection references that use the <code class="codeph">FORALL</code> index variable as an index.
                        </p>
                     </div>
                     <p><a href="plsql-optimization-and-tuning.html#GUID-6D4A1425-64DD-4723-8AAE-87B0A51A2854__BABEDFJE">Example 12-9</a> inserts the same collection elements into two database tables, using a <code class="codeph">FOR</code> <code class="codeph">LOOP</code> statement for the first table and a <code class="codeph">FORALL</code> statement for the second table and showing how long each statement takes. (Times vary from run to run.)
                     </p>
                     <p>In <a href="plsql-optimization-and-tuning.html#GUID-6D4A1425-64DD-4723-8AAE-87B0A51A2854__BABIIEEI">Example 12-10</a>, the <code class="codeph">FORALL</code> statement applies to a subset of a collection.
                     </p>
                     <div class="section">
                        <p class="subhead3" id="GUID-6D4A1425-64DD-4723-8AAE-87B0A51A2854__GUID-D3C60FDF-E024-4F92-9505-659DE4548684">Topics</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><a href="plsql-optimization-and-tuning.html#GUID-82049618-CB67-4CF1-8455-02AC6AEB5F8E" title="If the FORALL statement bounds clause references a sparse collection, then specify only existing index values, using either the INDICES OF or VALUES OF clause.">Using FORALL Statements for Sparse Collections</a></p>
                           </li>
                           <li>
                              <p><a href="plsql-optimization-and-tuning.html#GUID-D294AADE-1742-442B-B97A-D2C3C2CED8A5" title="In a FORALL statement without the SAVE EXCEPTIONS clause, if one DML statement raises an unhandled exception, then PL/SQL stops the FORALL statement and rolls back all changes made by previous DML statements.">Unhandled Exceptions in FORALL Statements</a></p>
                           </li>
                           <li>
                              <p><a href="plsql-optimization-and-tuning.html#GUID-42AF6F5C-B06D-4EB6-9C7A-630FF65DBD5D" title="To handle exceptions raised in a FORALL statement immediately, omit the SAVE EXCEPTIONS clause and write the appropriate exception handlers.">Handling FORALL Exceptions Immediately</a></p>
                           </li>
                           <li>
                              <p><a href="plsql-optimization-and-tuning.html#GUID-DAF46F06-EF3F-4B1A-A518-5238B80C69FA" title="To allow a FORALL statement to continue even if some of its DML statements fail, include the SAVE EXCEPTIONS clause. When a DML statement fails, PL/SQL does not raise an exception; instead, it saves information about the failure. After the FORALL statement completes, PL/SQL raises a single exception for the FORALL statement (ORA-24381).">Handling FORALL Exceptions After FORALL Statement Completes</a></p>
                           </li>
                           <li>
                              <p><a href="plsql-optimization-and-tuning.html#GUID-DDB5CCDA-8060-4511-BA20-4D1F2C478412" title="After a FORALL statement completes, you can get the number of rows that each DML statement affected from the implicit cursor attribute SQL%BULK_ROWCOUNT.">Getting Number of Rows Affected by FORALL Statement</a></p>
                           </li>
                        </ul>
                        <div class="infoboxnotealso" id="GUID-6D4A1425-64DD-4723-8AAE-87B0A51A2854__GUID-0198D5FC-A4FE-458B-A1EF-1211FA35A59E">
                           <p class="notep1">See Also:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><span class="q">"<a href="FORALL-statement.html#GUID-C45B8241-F9DF-4C93-8577-C840A25963DB" title="The FORALL statement runs one DML statement multiple times, with different values in the VALUES and WHERE clauses.">FORALL Statement</a>"</span> for its complete syntax and semantics, including restrictions
                                 </p>
                              </li>
                              <li>
                                 <p><span class="q">"<a href="static-sql.html#GUID-596C1961-5A94-40ED-9920-668BB05632C5">Implicit Cursors</a>"</span> for information about implicit cursor attributes in general and other implicit cursor attributes that you can use with the <code class="codeph">FORALL</code> statement
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-6D4A1425-64DD-4723-8AAE-87B0A51A2854__BABBCECH">
                        <p class="titleinexample">Example 12-7 DELETE Statement in FOR LOOP Statement</p><pre class="oac_no_warn" dir="ltr">DROP TABLE employees_temp;
CREATE TABLE employees_temp AS SELECT * FROM employees;

DECLARE
  TYPE NumList IS VARRAY(20) OF NUMBER;
  depts NumList := NumList(10, 30, 70);  -- department numbers
BEGIN
  <span class="bold">FOR i IN depts.FIRST..depts.LAST LOOP</span>
    <span class="bold">DELETE FROM employees_temp</span>
    <span class="bold">WHERE department_id = depts(i);</span>
  <span class="bold">END LOOP;</span>
END;
/
</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-6D4A1425-64DD-4723-8AAE-87B0A51A2854__BABDBAAJ">
                        <p class="titleinexample">Example 12-8 DELETE Statement in FORALL Statement</p><pre class="oac_no_warn" dir="ltr">DROP TABLE employees_temp;
CREATE TABLE employees_temp AS SELECT * FROM employees;

DECLARE
  TYPE NumList IS VARRAY(20) OF NUMBER;
  depts NumList := NumList(10, 30, 70);  -- department numbers
BEGIN
  <span class="bold">FORALL i IN depts.FIRST..depts.LAST</span>
    <span class="bold">DELETE FROM employees_temp</span>
    <span class="bold">WHERE department_id = depts(i);</span>
END;
/
</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-6D4A1425-64DD-4723-8AAE-87B0A51A2854__BABEDFJE">
                        <p class="titleinexample">Example 12-9 Time Difference for INSERT Statement in FOR LOOP and FORALL Statements</p><pre class="oac_no_warn" dir="ltr">DROP TABLE parts1;
CREATE TABLE parts1 (
  pnum INTEGER,
  pname VARCHAR2(15)
);
 
DROP TABLE parts2;
CREATE TABLE parts2 (
  pnum INTEGER,
  pname VARCHAR2(15)
);

DECLARE
  TYPE NumTab IS TABLE OF parts1.pnum%TYPE INDEX BY PLS_INTEGER;
  TYPE NameTab IS TABLE OF parts1.pname%TYPE INDEX BY PLS_INTEGER;
  pnums   NumTab;
  pnames  NameTab;
  iterations  CONSTANT PLS_INTEGER := 50000;
  t1  INTEGER;
  t2  INTEGER;
  t3  INTEGER;
BEGIN
  FOR j IN 1..iterations LOOP  -- populate collections
    pnums(j) := j;
    pnames(j) := 'Part No. ' || TO_CHAR(j);
  END LOOP;

  t1 := DBMS_UTILITY.get_time;

  <span class="bold">FOR i IN 1..iterations LOOP</span>
    <span class="bold">INSERT INTO parts1 (pnum, pname)</span>
    <span class="bold">VALUES (pnums(i), pnames(i));</span>
  <span class="bold">END LOOP;</span>

  t2 := DBMS_UTILITY.get_time;

  <span class="bold">FORALL i IN 1..iterations</span>
    <span class="bold">INSERT INTO parts2 (pnum, pname)</span>
    <span class="bold">VALUES (pnums(i), pnames(i));</span>

  t3 := DBMS_UTILITY.get_time;

  DBMS_OUTPUT.PUT_LINE('Execution Time (secs)');
  DBMS_OUTPUT.PUT_LINE('---------------------');
  DBMS_OUTPUT.PUT_LINE('FOR LOOP: ' || TO_CHAR((t2 - t1)/100));
  DBMS_OUTPUT.PUT_LINE('FORALL:   ' || TO_CHAR((t3 - t2)/100));
  COMMIT;
END;
/
</pre><p>Result is similar to:</p><pre class="oac_no_warn" dir="ltr">Execution Time (secs)
---------------------
FOR LOOP: 5.97
FORALL:   .07
 
PL/SQL procedure successfully completed.
</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-6D4A1425-64DD-4723-8AAE-87B0A51A2854__BABIIEEI">
                        <p class="titleinexample">Example 12-10 FORALL Statement for Subset of Collection</p><pre class="oac_no_warn" dir="ltr">DROP TABLE employees_temp;
CREATE TABLE employees_temp AS SELECT * FROM employees;

DECLARE
  TYPE NumList IS VARRAY(10) OF NUMBER;
  depts NumList := NumList(5,10,20,30,50,55,57,60,70,75);
BEGIN
  <span class="bold">FORALL j IN 4..7</span>
    DELETE FROM employees_temp WHERE department_id = depts(j);
END;
/</pre></div>
                     <!-- class="example" -->
                  </div><a id="LNPLS883"></a><a id="LNPLS99862"></a><div class="props_rev_3"><a id="GUID-82049618-CB67-4CF1-8455-02AC6AEB5F8E" name="GUID-82049618-CB67-4CF1-8455-02AC6AEB5F8E"></a><h5 id="LNPLS-GUID-82049618-CB67-4CF1-8455-02AC6AEB5F8E" class="sect5"><span class="enumeration_section">12.4.1.1 </span>Using FORALL Statements for Sparse Collections
                     </h5>
                     <div>
                        <p>If the <code class="codeph">FORALL</code> statement bounds clause references a sparse collection, then specify only existing index values, using either the <code class="codeph">INDICES</code> <code class="codeph">OF</code> or <code class="codeph">VALUES</code> <code class="codeph">OF</code> clause. 
                        </p>
                        <div class="section">
                           <p>You can use <code class="codeph">INDICES</code> <code class="codeph">OF</code> for any collection except an associative array indexed by string. You can use <code class="codeph">VALUES</code> <code class="codeph">OF</code> only for a collection of <code class="codeph">PLS_INTEGER</code> elements indexed by <code class="codeph">PLS_INTEGER</code>.
                           </p>
                           <p>A collection of <code class="codeph">PLS_INTEGER</code> elements indexed by <code class="codeph">PLS_INTEGER</code> can be an <span class="bold">index collection</span>; that is, a collection of pointers to elements of another collection (the <span class="bold">indexed collection</span>).
                           </p>
                           <p>Index collections are useful for processing different subsets of the same collection with different <code class="codeph">FORALL</code> statements. Instead of copying elements of the original collection into new collections that represent the subsets (which can use significant time and memory), represent each subset with an index collection and then use each index collection in the <code class="codeph">VALUES</code> <code class="codeph">OF</code> clause of a different <code class="codeph">FORALL</code> statement.
                           </p>
                           <div class="infoboxnotealso" id="GUID-82049618-CB67-4CF1-8455-02AC6AEB5F8E__GUID-F6FAF1D3-70B8-4352-B5D3-8ACDA5D20EBB">
                              <p class="notep1">See Also:</p>
                              <p><span class="q">"<a href="plsql-optimization-and-tuning.html#GUID-7D957671-D29A-42C3-8141-560C82035B74">Sparse Collections and SQL%BULK_EXCEPTIONS</a>"</span></p>
                           </div>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-82049618-CB67-4CF1-8455-02AC6AEB5F8E__BABJCEFE">
                           <p class="titleinexample">Example 12-11 FORALL Statements for Sparse Collection and Its Subsets</p>
                           <p>This example uses a <code class="codeph">FORALL</code> statement with the <code class="codeph">INDICES</code> <code class="codeph">OF</code> clause to populate a table with the elements of a sparse collection. Then it uses two <code class="codeph">FORALL</code> statements with <code class="codeph">VALUES</code> <code class="codeph">OF</code> clauses to populate two tables with subsets of a collection.
                           </p><pre class="oac_no_warn" dir="ltr">DROP TABLE valid_orders;
CREATE TABLE valid_orders (
  cust_name  VARCHAR2(32),
  amount     NUMBER(10,2)
);
 
DROP TABLE big_orders;
CREATE TABLE big_orders AS
  SELECT * FROM valid_orders
  WHERE 1 = 0;
 
DROP TABLE rejected_orders;
CREATE TABLE rejected_orders AS
  SELECT * FROM valid_orders
  WHERE 1 = 0;
 
DECLARE
  SUBTYPE cust_name IS valid_orders.cust_name%TYPE;
  TYPE cust_typ IS TABLE OF cust_name;
  <span class="bold">cust_tab  cust_typ;  -- Collection of customer names</span>
 
  SUBTYPE order_amount IS valid_orders.amount%TYPE;
  TYPE amount_typ IS TABLE OF NUMBER;
  <span class="bold">amount_tab  amount_typ;  -- Collection of order amounts</span>
 
  TYPE index_pointer_t IS TABLE OF PLS_INTEGER;
 
  <span class="bold">/* Collections for pointers to elements of cust_tab collection</span>
     <span class="bold">(to represent two subsets of cust_tab): */</span>
 
  big_order_tab       index_pointer_t := index_pointer_t();
  rejected_order_tab  index_pointer_t := index_pointer_t();
 
  PROCEDURE populate_data_collections IS
  BEGIN
    cust_tab := cust_typ(
      'Company1','Company2','Company3','Company4','Company5'
    );
 
    amount_tab := amount_typ(5000.01, 0, 150.25, 4000.00, NULL);
  END;
 
BEGIN
  <span class="bold">populate_data_collections;</span>
 
  DBMS_OUTPUT.PUT_LINE ('--- Original order data ---');
 
  FOR i IN 1..cust_tab.LAST LOOP
    DBMS_OUTPUT.PUT_LINE (
      'Customer #' || i || ', ' || cust_tab(i) || ': $' || amount_tab(i)
    );
  END LOOP;
 
  <span class="bold">-- Delete invalid orders:</span>
 
  FOR i IN 1..cust_tab.LAST LOOP
    IF amount_tab(i) IS NULL OR amount_tab(i) = 0 THEN
      cust_tab.delete(i);
      amount_tab.delete(i);
    END IF;
  END LOOP;
 
  <span class="bold">-- cust_tab is now a sparse collection.</span>
 
  DBMS_OUTPUT.PUT_LINE ('--- Order data with invalid orders deleted ---');
 
  FOR i IN 1..cust_tab.LAST LOOP
    IF cust_tab.EXISTS(i) THEN
      DBMS_OUTPUT.PUT_LINE (
        'Customer #' || i || ', ' || cust_tab(i) || ': $' || amount_tab(i)
      );
    END IF;
  END LOOP;
 
  <span class="bold">-- Using sparse collection, populate valid_orders table:</span>
 
  <span class="bold">FORALL i IN INDICES OF cust_tab</span>
    INSERT INTO valid_orders (cust_name, amount)
    VALUES (cust_tab(i), amount_tab(i));
 
  <span class="bold">populate_data_collections;  -- Restore original order data</span>
 
  <span class="bold">-- cust_tab is a dense collection again.</span>
 
  <span class="bold">/* Populate collections of pointers to elements of cust_tab collection</span>
     <span class="bold">(which represent two subsets of cust_tab): */</span>
 
  FOR i IN cust_tab.FIRST .. cust_tab.LAST LOOP
    IF amount_tab(i) IS NULL OR amount_tab(i) = 0 THEN
      rejected_order_tab.EXTEND;
      rejected_order_tab(rejected_order_tab.LAST) := i; 
    END IF;
 
    IF amount_tab(i) &gt; 2000 THEN
      big_order_tab.EXTEND;
      big_order_tab(big_order_tab.LAST) := i;
    END IF;
  END LOOP;
 
  <span class="bold">/* Using each subset in a different FORALL statement,</span>
     <span class="bold">populate rejected_orders and big_orders tables: */</span>
 
  <span class="bold">FORALL i IN VALUES OF rejected_order_tab</span>
    INSERT INTO rejected_orders (cust_name, amount)
    VALUES (cust_tab(i), amount_tab(i));
 
  <span class="bold">FORALL i IN VALUES OF big_order_tab</span>
    INSERT INTO big_orders (cust_name, amount)
    VALUES (cust_tab(i), amount_tab(i));
END;
/
</pre><p>Result:</p><pre class="oac_no_warn" dir="ltr">--- Original order data ---
Customer #1, Company1: $5000.01
Customer #2, Company2: $0
Customer #3, Company3: $150.25
Customer #4, Company4: $4000
Customer #5, Company5: $
--- Data with invalid orders deleted ---
Customer #1, Company1: $5000.01
Customer #3, Company3: $150.25
Customer #4, Company4: $4000
</pre><p>Verify that correct order details were stored:</p><pre class="oac_no_warn" dir="ltr">SELECT cust_name "Customer", amount "Valid order amount"
FROM valid_orders
ORDER BY cust_name;
</pre><p>Result:</p><pre class="oac_no_warn" dir="ltr">Customer                         Valid order amount
-------------------------------- ------------------
Company1                                    5000.01
Company3                                     150.25
Company4                                       4000
 
3 rows selected.
</pre><p>Query:</p><pre class="oac_no_warn" dir="ltr">
SELECT cust_name "Customer", amount "Big order amount"
FROM big_orders
ORDER BY cust_name;
</pre><p>Result:</p><pre class="oac_no_warn" dir="ltr">Customer                         Big order amount
-------------------------------- ----------------
Company1                                  5000.01
Company4                                     4000
 
2 rows selected.
</pre><p>Query:</p><pre class="oac_no_warn" dir="ltr">SELECT cust_name "Customer", amount "Rejected order amount"
FROM rejected_orders
ORDER BY cust_name;
</pre><p>Result:</p><pre class="oac_no_warn" dir="ltr">Customer                         Rejected order amount
-------------------------------- ---------------------
Company2                                             0
Company5
 
2 rows selected.</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="LNPLS99861"></a><div class="props_rev_3"><a id="GUID-D294AADE-1742-442B-B97A-D2C3C2CED8A5" name="GUID-D294AADE-1742-442B-B97A-D2C3C2CED8A5"></a><h5 id="LNPLS-GUID-D294AADE-1742-442B-B97A-D2C3C2CED8A5" class="sect5"><span class="enumeration_section">12.4.1.2 </span>Unhandled Exceptions in FORALL Statements
                     </h5>
                     <div>
                        <p>In a <code class="codeph">FORALL</code> statement without the <code class="codeph">SAVE</code> <code class="codeph">EXCEPTIONS</code> clause, if one DML statement raises an unhandled exception, then PL/SQL stops the <code class="codeph">FORALL</code> statement and rolls back all changes made by previous DML statements.
                        </p>
                        <p>For example, the <code class="codeph">FORALL</code> statement in <a href="plsql-optimization-and-tuning.html#GUID-6D4A1425-64DD-4723-8AAE-87B0A51A2854__BABDBAAJ">Example 12-8</a> executes these DML statements in this order, unless one of them raises an unhandled exception:
                        </p><pre class="oac_no_warn" dir="ltr">DELETE FROM employees_temp WHERE department_id = depts(10);
DELETE FROM employees_temp WHERE department_id = depts(30);
DELETE FROM employees_temp WHERE department_id = depts(70);
</pre><p>If the third statement raises an unhandled exception, then PL/SQL rolls back the changes that the first and second statements made. If the second statement raises an unhandled exception, then PL/SQL rolls back the changes that the first statement made and never runs the third statement.</p>
                        <p>You can handle exceptions raised in a <code class="codeph">FORALL</code> statement in either of these ways:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>As each exception is raised (see <span class="q">"<a href="plsql-optimization-and-tuning.html#GUID-42AF6F5C-B06D-4EB6-9C7A-630FF65DBD5D" title="To handle exceptions raised in a FORALL statement immediately, omit the SAVE EXCEPTIONS clause and write the appropriate exception handlers.">Handling FORALL Exceptions Immediately</a>"</span>)
                              </p>
                           </li>
                           <li>
                              <p>After the <code class="codeph">FORALL</code> statement completes execution, by including the <code class="codeph">SAVE</code> <code class="codeph">EXCEPTIONS</code> clause (see <span class="q">"<a href="plsql-optimization-and-tuning.html#GUID-DAF46F06-EF3F-4B1A-A518-5238B80C69FA" title="To allow a FORALL statement to continue even if some of its DML statements fail, include the SAVE EXCEPTIONS clause. When a DML statement fails, PL/SQL does not raise an exception; instead, it saves information about the failure. After the FORALL statement completes, PL/SQL raises a single exception for the FORALL statement (ORA-24381).">Handling FORALL Exceptions After FORALL Statement Completes</a>"</span>)
                              </p>
                           </li>
                        </ul>
                     </div>
                  </div><a id="LNPLS885"></a><a id="LNPLS884"></a><div class="props_rev_3"><a id="GUID-42AF6F5C-B06D-4EB6-9C7A-630FF65DBD5D" name="GUID-42AF6F5C-B06D-4EB6-9C7A-630FF65DBD5D"></a><h5 id="LNPLS-GUID-42AF6F5C-B06D-4EB6-9C7A-630FF65DBD5D" class="sect5"><span class="enumeration_section">12.4.1.3 </span>Handling FORALL Exceptions Immediately
                     </h5>
                     <div>
                        <p>To handle exceptions raised in a <code class="codeph">FORALL</code> statement immediately, omit the <code class="codeph">SAVE</code> <code class="codeph">EXCEPTIONS</code> clause and write the appropriate exception handlers. 
                        </p>
                        <div class="section">
                           <p>If one DML statement raises a handled exception, then PL/SQL rolls back the changes made by that statement, but does not roll back changes made by previous DML statements.</p>
                           <p>In <a href="plsql-optimization-and-tuning.html#GUID-42AF6F5C-B06D-4EB6-9C7A-630FF65DBD5D__BABBBJCF">Example 12-12</a>, the <code class="codeph">FORALL</code> statement is designed to run three <code class="codeph">UPDATE</code> statements. However, the second one raises an exception. An exception handler handles the exception, displaying the error message and committing the change made by the first <code class="codeph">UPDATE</code> statement. The third <code class="codeph">UPDATE</code> statement never runs.
                           </p>
                           <p>For information about exception handlers, see <a href="plsql-error-handling.html#GUID-0502DC1A-F0A5-4180-A912-6A5CDC855F56" title="While compiling stored PL/SQL units, the PL/SQL compiler generates warnings for conditions that are not serious enough to cause errors and prevent compilation—for example, using a deprecated PL/SQL feature.">PL/SQL Error Handling</a>. 
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-42AF6F5C-B06D-4EB6-9C7A-630FF65DBD5D__BABBBJCF">
                           <p class="titleinexample">Example 12-12 Handling FORALL Exceptions Immediately</p><pre class="oac_no_warn" dir="ltr">DROP TABLE emp_temp;
CREATE TABLE emp_temp (
  deptno NUMBER(2),
  job VARCHAR2(18)
);
 
CREATE OR REPLACE PROCEDURE p AUTHID DEFINER AS
  TYPE NumList IS TABLE OF NUMBER;
 
  depts          NumList := NumList(10, 20, 30);
  error_message  VARCHAR2(100);
 
BEGIN
  -- Populate table:
 
  INSERT INTO emp_temp (deptno, job) VALUES (10, 'Clerk');
  INSERT INTO emp_temp (deptno, job) VALUES (20, 'Bookkeeper');
  INSERT INTO emp_temp (deptno, job) VALUES (30, 'Analyst');
  COMMIT;
 
  -- Append 9-character string to each job:
 
  <span class="bold">FORALL j IN depts.FIRST..depts.LAST</span>
    <span class="bold">UPDATE emp_temp SET job = job || ' (Senior)'</span>
    <span class="bold">WHERE deptno = depts(j);</span>
 
<span class="bold">EXCEPTION</span>
  <span class="bold">WHEN OTHERS THEN</span>
    <span class="bold">error_message := SQLERRM;</span>
    <span class="bold">DBMS_OUTPUT.PUT_LINE (error_message);</span>
 
    <span class="bold">COMMIT;  -- Commit results of successful updates</span>
    RAISE;
END;
/
</pre><p>Result:</p><pre class="oac_no_warn" dir="ltr">Procedure created.
</pre><p>Invoke procedure:</p><pre class="oac_no_warn" dir="ltr">BEGIN
  p;
END;
/
</pre><p>Result:</p><pre class="oac_no_warn" dir="ltr"><span class="bold">ORA-12899: value too large for column "HR"."EMP_TEMP"."JOB" (actual: 19,</span>
<span class="bold">maximum: 18)</span>
<span class="bold">BEGIN</span>
<span class="bold">*</span>
<span class="bold">ERROR at line 1:</span>
<span class="bold">ORA-12899: value too large for column "HR"."EMP_TEMP"."JOB" (actual: 19,</span>
<span class="bold">maximum: 18)</span>
<span class="bold">ORA-06512: at "HR.P", line 27</span>
<span class="bold">ORA-06512: at line 2</span>
</pre><p>Query:</p><pre class="oac_no_warn" dir="ltr">SELECT * FROM emp_temp;
</pre><p>Result:</p><pre class="oac_no_warn" dir="ltr">    DEPTNO JOB
---------- ------------------
        10 Clerk <span class="bold">(Senior)</span>
        20 Bookkeeper
        30 Analyst
 
3 rows selected.</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="LNPLS800"></a><a id="LNPLS889"></a><div class="props_rev_3"><a id="GUID-DAF46F06-EF3F-4B1A-A518-5238B80C69FA" name="GUID-DAF46F06-EF3F-4B1A-A518-5238B80C69FA"></a><h5 id="LNPLS-GUID-DAF46F06-EF3F-4B1A-A518-5238B80C69FA" class="sect5"><span class="enumeration_section">12.4.1.4 </span>Handling FORALL Exceptions After FORALL Statement Completes
                     </h5>
                     <div>
                        <p>To allow a <code class="codeph">FORALL</code> statement to continue even if some of its DML statements fail, include the <code class="codeph">SAVE</code> <code class="codeph">EXCEPTIONS</code> clause. When a DML statement fails, PL/SQL does not raise an exception; instead, it saves information about the failure.  After the <code class="codeph">FORALL</code> statement completes, PL/SQL raises a single exception for the <code class="codeph">FORALL</code> statement (ORA-24381). 
                        </p>
                        <div class="section">
                           <p>In the exception handler for ORA-24381, you can get information about each individual DML statement failure from the implicit cursor attribute <code class="codeph">SQL%BULK_EXCEPTIONS</code>.
                           </p>
                           <p><code class="codeph">SQL%BULK_EXCEPTIONS</code> is like an associative array of information about the DML statements that failed during the most recently run <code class="codeph">FORALL</code> statement.
                           </p>
                           <p><code class="codeph">SQL%BULK_EXCEPTIONS</code>.<code class="codeph">COUNT</code> is the number of DML statements that failed. If <code class="codeph">SQL%BULK_EXCEPTIONS</code>.<code class="codeph">COUNT</code> is not zero, then for each index value <span class="italic">i</span> from 1 through <code class="codeph">SQL%BULK_EXCEPTIONS</code>.<code class="codeph">COUNT</code>:
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><code class="codeph">SQL%BULK_EXCEPTIONS(</code><span class="italic"><code class="codeph">i</code></span><code class="codeph">)</code>.<code class="codeph">ERROR_INDEX</code> is the number of the DML statement that failed.
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">SQL%BULK_EXCEPTIONS(</code><span class="italic"><code class="codeph">i</code></span><code class="codeph">)</code>.<code class="codeph">ERROR_CODE</code> is the Oracle Database error code for the failure.
                                 </p>
                              </li>
                           </ul>
                           <p>For example, if a <code class="codeph">FORALL</code> <code class="codeph">SAVE</code> <code class="codeph">EXCEPTIONS</code> statement runs 100 DML statements, and the tenth and sixty-fourth ones fail with error codes ORA-12899 and ORA-19278, respectively, then:
                           </p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><code class="codeph">SQL%BULK_EXCEPTIONS</code>.<code class="codeph">COUNT</code> = 2
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">SQL%BULK_EXCEPTIONS(1)</code>.<code class="codeph">ERROR_INDEX</code> = 10
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">SQL%BULK_EXCEPTIONS(1)</code>.<code class="codeph">ERROR_CODE</code> = 12899
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">SQL%BULK_EXCEPTIONS(2)</code>.<code class="codeph">ERROR_INDEX</code> = 64
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">SQL%BULK_EXCEPTIONS(2)</code>.<code class="codeph">ERROR_CODE</code> = 19278
                                 </p>
                              </li>
                           </ul>
                           <div class="infoboxnote" id="GUID-DAF46F06-EF3F-4B1A-A518-5238B80C69FA__GUID-CE0CB20B-4F42-4AB9-B38E-DB98CD7C9CA3">
                              <p class="notep1">Note:</p>
                              <p>After a <code class="codeph">FORALL</code> statement <span class="italic">without</span> the <code class="codeph">SAVE</code> <code class="codeph">EXCEPTIONS</code> clause raises an exception, <code class="codeph">SQL%BULK_EXCEPTIONS</code>.<code class="codeph">COUNT</code> = 1.
                              </p>
                           </div>
                           <p>With the error code, you can get the associated error message with the <code class="codeph">SQLERRM</code> function (described in <span class="q">"<a href="SQLERRM-function.html#GUID-D4468C8F-62D9-42A5-AF72-C1098C866DC5" title="The SQLERRM function returns the error message associated with an error code.">SQLERRM Function</a>"</span>):
                           </p><pre class="oac_no_warn" dir="ltr">SQLERRM(-(SQL%BULK_EXCEPTIONS(i).ERROR_CODE))
</pre><p>However, the error message that <code class="codeph">SQLERRM</code> returns excludes any substitution arguments (compare the error messages in <a href="plsql-optimization-and-tuning.html#GUID-42AF6F5C-B06D-4EB6-9C7A-630FF65DBD5D__BABBBJCF">Example 12-12</a> and <a href="plsql-optimization-and-tuning.html#GUID-DAF46F06-EF3F-4B1A-A518-5238B80C69FA__BABGBABA">Example 12-13</a>).
                           </p>
                           <p><a href="plsql-optimization-and-tuning.html#GUID-DAF46F06-EF3F-4B1A-A518-5238B80C69FA__BABGBABA">Example 12-13</a> is like <a href="plsql-optimization-and-tuning.html#GUID-42AF6F5C-B06D-4EB6-9C7A-630FF65DBD5D__BABBBJCF">Example 12-12</a> except:
                           </p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>The <code class="codeph">FORALL</code> statement includes the <code class="codeph">SAVE</code> <code class="codeph">EXCEPTIONS</code> clause.
                                 </p>
                              </li>
                              <li>
                                 <p>The exception-handling part has an exception handler for ORA-24381, the internally defined exception that PL/SQL raises implicitly when a bulk operation raises and saves exceptions. The example gives ORA-24381 the user-defined name <code class="codeph">dml_errors</code>.
                                 </p>
                              </li>
                              <li>
                                 <p>The exception handler for <code class="codeph">dml_errors</code> uses <code class="codeph">SQL%BULK_EXCEPTIONS</code> and <code class="codeph">SQLERRM</code> (and some local variables) to show the error message and which statement, collection item, and string caused the error.
                                 </p>
                              </li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-DAF46F06-EF3F-4B1A-A518-5238B80C69FA__BABGBABA">
                           <p class="titleinexample">Example 12-13 Handling FORALL Exceptions After FORALL Statement Completes</p><pre class="oac_no_warn" dir="ltr">CREATE OR REPLACE PROCEDURE p AUTHID DEFINER AS
  TYPE NumList IS TABLE OF NUMBER;
  depts        NumList := NumList(10, 20, 30);
 
  error_message  VARCHAR2(100);
  <span class="bold">bad_stmt_no    PLS_INTEGER;</span>
  <span class="bold">bad_deptno     emp_temp.deptno%TYPE;</span>
  <span class="bold">bad_job        emp_temp.job%TYPE;</span>
 
  <span class="bold">dml_errors  EXCEPTION;</span>
  <span class="bold">PRAGMA EXCEPTION_INIT(dml_errors, -24381);</span>
BEGIN
  -- Populate table:
 
  INSERT INTO emp_temp (deptno, job) VALUES (10, 'Clerk');
  INSERT INTO emp_temp (deptno, job) VALUES (20, 'Bookkeeper');
  INSERT INTO emp_temp (deptno, job) VALUES (30, 'Analyst');
  COMMIT;
 
  -- Append 9-character string to each job:
 
  FORALL j IN depts.FIRST..depts.LAST <span class="bold">SAVE EXCEPTIONS</span>
    UPDATE emp_temp SET job = job || ' (Senior)'
    WHERE deptno = depts(j); 
 
EXCEPTION
  WHEN dml_errors THEN
    <span class="bold">FOR i IN 1..SQL%BULK_EXCEPTIONS.COUNT LOOP</span>
      <span class="bold">error_message := SQLERRM(-(SQL%BULK_EXCEPTIONS(i).ERROR_CODE));</span>
      <span class="bold">DBMS_OUTPUT.PUT_LINE (error_message);</span>
 
      <span class="bold">bad_stmt_no := SQL%BULK_EXCEPTIONS(i).ERROR_INDEX;</span>
      <span class="bold">DBMS_OUTPUT.PUT_LINE('Bad statement #: ' || bad_stmt_no);</span>
 
      <span class="bold">bad_deptno := depts(bad_stmt_no);</span>
      <span class="bold">DBMS_OUTPUT.PUT_LINE('Bad department #: ' || bad_deptno);</span>
 
      <span class="bold">SELECT job INTO bad_job FROM emp_temp WHERE deptno = bad_deptno;</span>
 
      <span class="bold">DBMS_OUTPUT.PUT_LINE('Bad job: ' || bad_job);</span>
    <span class="bold">END LOOP;</span>
 
    COMMIT;  -- Commit results of successful updates

    <span class="bold">WHEN OTHERS THEN</span>
      <span class="bold">DBMS_OUTPUT.PUT_LINE('Unrecognized error.');</span>
      RAISE;
END;
/
 </pre><p>Result:</p><pre class="oac_no_warn" dir="ltr">Procedure created.
</pre><p>Invoke procedure:</p><pre class="oac_no_warn" dir="ltr">BEGIN
  p;
END;
/
</pre><p>Result:</p><pre class="oac_no_warn" dir="ltr"><span class="bold">ORA-12899: value too large for column  (actual: , maximum: )</span>
<span class="bold">Bad statement #: 2</span>
<span class="bold">Bad department #: 20</span>
<span class="bold">Bad job: Bookkeeper</span>
 
PL/SQL procedure successfully completed.
</pre><p>Query:</p><pre class="oac_no_warn" dir="ltr">SELECT * FROM emp_temp;
</pre><p>Result:</p><pre class="oac_no_warn" dir="ltr">    DEPTNO JOB
---------- ------------------
        10 Clerk (Senior)
        20 Bookkeeper
        30 Analyst <span class="bold">(Senior)</span>
 
3 rows selected.</pre></div>
                        <!-- class="example" -->
                     </div><a id="LNPLS99860"></a><div class="props_rev_3"><a id="GUID-7D957671-D29A-42C3-8141-560C82035B74" name="GUID-7D957671-D29A-42C3-8141-560C82035B74"></a><h6 id="LNPLS-GUID-7D957671-D29A-42C3-8141-560C82035B74" class="sect6"><span class="enumeration_section">12.4.1.4.1 </span>Sparse Collections and SQL%BULK_EXCEPTIONS
                        </h6>
                        <div>
                           <div class="section">
                              <p>If the <code class="codeph">FORALL</code> statement bounds clause references a sparse collection, then to find the collection element that caused a DML statement to fail, you must step through the elements one by one until you find the element whose index is <code class="codeph">SQL%BULK_EXCEPTIONS(i)</code>.<code class="codeph">ERROR_INDEX</code>. Then, if the <code class="codeph">FORALL</code> statement uses the <code class="codeph">VALUES</code> <code class="codeph">OF</code> clause to reference a collection of pointers into another collection, you must find the element of the other collection whose index is <code class="codeph">SQL%BULK_EXCEPTIONS(i)</code>.<code class="codeph">ERROR_INDEX</code>.
                              </p>
                           </div>
                           <!-- class="section" -->
                        </div>
                     </div>
                  </div><a id="LNPLS887"></a><a id="LNPLS888"></a><a id="LNPLS886"></a><div class="props_rev_3"><a id="GUID-DDB5CCDA-8060-4511-BA20-4D1F2C478412" name="GUID-DDB5CCDA-8060-4511-BA20-4D1F2C478412"></a><h5 id="LNPLS-GUID-DDB5CCDA-8060-4511-BA20-4D1F2C478412" class="sect5"><span class="enumeration_section">12.4.1.5 </span>Getting Number of Rows Affected by FORALL Statement
                     </h5>
                     <div>
                        <p>After a <code class="codeph">FORALL</code> statement completes, you can get the number of rows that each DML statement affected from the implicit cursor attribute <code class="codeph">SQL%BULK_ROWCOUNT</code>.
                        </p>
                        <div class="section">
                           <p>To get the total number of rows affected by the <code class="codeph">FORALL</code> statement, use the implicit cursor attribute <code class="codeph">SQL%ROWCOUNT</code>, described in <span class="q">"<a href="static-sql.html#GUID-0C789D68-82D8-4896-97BF-AF2356B9C8D5">SQL%ROWCOUNT Attribute: How Many Rows Were Affected?</a>"</span>.
                           </p>
                           <p><code class="codeph">SQL%BULK_ROWCOUNT</code> is like an associative array whose <span class="italic">i</span>th element is the number of rows affected by the <span class="italic">i</span>th DML statement in the most recently completed <code class="codeph">FORALL</code> statement. The data type of the element is <code class="codeph">INTEGER</code>.
                           </p>
                           <div class="infoboxnote" id="GUID-DDB5CCDA-8060-4511-BA20-4D1F2C478412__GUID-D7390533-E729-43E8-9C79-9C3010697203">
                              <p class="notep1">Note:</p>
                              <p>If a server is Oracle Database 12c or later and its client is Oracle Database 11g release 2 or earlier (or the reverse), then the maximum number that <code class="codeph">SQL%BULK_ROWCOUNT</code> returns is 4,294,967,295.
                              </p>
                           </div>
                           <p><a href="plsql-optimization-and-tuning.html#GUID-DDB5CCDA-8060-4511-BA20-4D1F2C478412__BABDJBDH">Example 12-14</a> uses <code class="codeph">SQL%BULK_ROWCOUNT</code> to show how many rows each <code class="codeph">DELETE</code> statement in the <code class="codeph">FORALL</code> statement deleted and <code class="codeph">SQL%ROWCOUNT</code> to show the total number of rows deleted.
                           </p>
                           <p><a href="plsql-optimization-and-tuning.html#GUID-DDB5CCDA-8060-4511-BA20-4D1F2C478412__BABICGJE">Example 12-15</a> uses <code class="codeph">SQL%BULK_ROWCOUNT</code> to show how many rows each <code class="codeph">INSERT</code> <code class="codeph">SELECT</code> construct in the <code class="codeph">FORALL</code> statement inserted and <code class="codeph">SQL%ROWCOUNT</code> to show the total number of rows inserted.
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-DDB5CCDA-8060-4511-BA20-4D1F2C478412__BABDJBDH">
                           <p class="titleinexample">Example 12-14 Showing Number of Rows Affected by Each DELETE in FORALL</p><pre class="oac_no_warn" dir="ltr">DROP TABLE emp_temp;
CREATE TABLE emp_temp AS SELECT * FROM employees;

DECLARE
  TYPE NumList IS TABLE OF NUMBER;
  depts NumList := NumList(30, 50, 60);
BEGIN
  FORALL j IN depts.FIRST..depts.LAST
    DELETE FROM emp_temp WHERE department_id = depts(j);

  FOR i IN depts.FIRST..depts.LAST LOOP
    DBMS_OUTPUT.PUT_LINE (
      'Statement #' || i || ' deleted ' ||
      <span class="bold">SQL%BULK_ROWCOUNT(i)</span> || ' rows.'
    );
  END LOOP;

  DBMS_OUTPUT.PUT_LINE('Total rows deleted: ' || <span class="bold">SQL%ROWCOUNT</span>);
END;
/
</pre><p>Result:</p><pre class="oac_no_warn" dir="ltr">Statement #1 deleted 6 rows.
Statement #2 deleted 45 rows.
Statement #3 deleted 5 rows.
Total rows deleted: 56
</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-DDB5CCDA-8060-4511-BA20-4D1F2C478412__BABICGJE">
                           <p class="titleinexample">Example 12-15 Showing Number of Rows Affected by Each INSERT SELECT in FORALL</p><pre class="oac_no_warn" dir="ltr">DROP TABLE emp_by_dept;
CREATE TABLE emp_by_dept AS
  SELECT employee_id, department_id
  FROM employees
  WHERE 1 = 0;

DECLARE
  TYPE dept_tab IS TABLE OF departments.department_id%TYPE;
  deptnums  dept_tab;
BEGIN
  SELECT department_id BULK COLLECT INTO deptnums FROM departments;

  <span class="bold">FORALL i IN 1..deptnums.COUNT</span>
    <span class="bold">INSERT INTO emp_by_dept (employee_id, department_id)</span>
      <span class="bold">SELECT employee_id, department_id</span>
      <span class="bold">FROM employees</span>
      <span class="bold">WHERE department_id = deptnums(i)</span>
      <span class="bold">ORDER BY department_id, employee_id;</span>

  FOR i IN 1..deptnums.COUNT LOOP
    -- Count how many rows were inserted for each department; that is,
    -- how many employees are in each department.
    DBMS_OUTPUT.PUT_LINE (
      'Dept '||deptnums(i)||': inserted '||
      <span class="bold">SQL%BULK_ROWCOUNT(i)</span>||' records'
    );
  END LOOP;
  DBMS_OUTPUT.PUT_LINE('Total records inserted: ' || <span class="bold">SQL%ROWCOUNT</span>);
END;
/
</pre><p>Result:</p><pre class="oac_no_warn" dir="ltr">Dept 10: inserted 1 records
Dept 20: inserted 2 records
Dept 30: inserted 6 records
Dept 40: inserted 1 records
Dept 50: inserted 45 records
Dept 60: inserted 5 records
Dept 70: inserted 1 records
Dept 80: inserted 34 records
Dept 90: inserted 3 records
Dept 100: inserted 6 records
Dept 110: inserted 2 records
Dept 120: inserted 0 records
Dept 130: inserted 0 records
Dept 140: inserted 0 records
Dept 150: inserted 0 records
Dept 160: inserted 0 records
Dept 170: inserted 0 records
Dept 180: inserted 0 records
Dept 190: inserted 0 records
Dept 200: inserted 0 records
Dept 210: inserted 0 records
Dept 220: inserted 0 records
Dept 230: inserted 0 records
Dept 240: inserted 0 records
Dept 250: inserted 0 records
Dept 260: inserted 0 records
Dept 270: inserted 0 records
Dept 280: inserted 0 records
Total records inserted: 106</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div>
               </div><a id="LNPLS801"></a><a id="LNPLS891"></a><div class="props_rev_3"><a id="GUID-19F50644-C88E-49AF-B31C-3EE4B4432714" name="GUID-19F50644-C88E-49AF-B31C-3EE4B4432714"></a><h4 id="LNPLS-GUID-19F50644-C88E-49AF-B31C-3EE4B4432714" class="sect4"><span class="enumeration_section">12.4.2 </span>BULK COLLECT Clause
                  </h4>
                  <div>
                     <p>The <code class="codeph">BULK</code> <code class="codeph">COLLECT</code> clause, a feature of bulk SQL, returns results from SQL to PL/SQL in batches rather than one at a time. 
                     </p>
                     <p>The <code class="codeph">BULK</code> <code class="codeph">COLLECT</code> clause can appear in:
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><code class="codeph">SELECT</code> <code class="codeph">INTO</code> statement
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">FETCH</code> statement
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">RETURNING</code> <code class="codeph">INTO</code> clause of:
                           </p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><code class="codeph">DELETE</code> statement
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">INSERT</code> statement
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">UPDATE</code> statement
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">EXECUTE</code> <code class="codeph">IMMEDIATE</code> statement
                                 </p>
                              </li>
                           </ul>
                        </li>
                     </ul>
                     <p>With the <code class="codeph">BULK</code> <code class="codeph">COLLECT</code> clause, each of the preceding statements retrieves an entire result set and stores it in one or more collection variables in a single operation (which is more efficient than using a loop statement to retrieve one result row at a time).
                     </p>
                     <div class="infoboxnote" id="GUID-19F50644-C88E-49AF-B31C-3EE4B4432714__GUID-4D9E4554-0F1A-479C-955D-D83BF57F8B11">
                        <p class="notep1">Note:</p>
                        <p>PL/SQL processes the <code class="codeph">BULK</code> <code class="codeph">COLLECT</code> clause similar to the way it processes a <code class="codeph">FETCH</code> statement inside a <code class="codeph">LOOP</code> statement. PL/SQL does not raise an exception when a statement with a <code class="codeph">BULK</code> <code class="codeph">COLLECT</code> clause returns no rows. You must check the target collections for emptiness, as in <a href="plsql-optimization-and-tuning.html#GUID-541A8B35-9B8F-432F-9E30-E73305A6E17C__BABCCJCB">Example 12-22</a>.
                        </p>
                     </div>
                     <div class="section">
                        <p class="subhead3" id="GUID-19F50644-C88E-49AF-B31C-3EE4B4432714__GUID-040DA890-F13D-4B00-BCD3-14CC0F0C3823">Topics</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><a href="plsql-optimization-and-tuning.html#GUID-6E09E4FC-28C0-43C8-9E7C-A54D6398D1DE" title="The SELECT INTO statement with the BULK COLLECT clause (also called the SELECT BULK COLLECT INTO statement) selects an entire result set into one or more collection variables.">SELECT INTO Statement with BULK COLLECT Clause</a></p>
                           </li>
                           <li>
                              <p><a href="plsql-optimization-and-tuning.html#GUID-541A8B35-9B8F-432F-9E30-E73305A6E17C" title="The FETCH statement with the BULK COLLECT clause (also called the FETCH BULK COLLECT statement) fetches an entire result set into one or more collection variables.">FETCH Statement with BULK COLLECT Clause</a></p>
                           </li>
                           <li>
                              <p><a href="plsql-optimization-and-tuning.html#GUID-33749752-0DC6-4749-8A84-77CF3AC6FD6A" title="The RETURNING INTO clause with the BULK COLLECT clause (also called the RETURNING BULK COLLECT INTO clause) can appear in an INSERT, UPDATE, DELETE, or EXECUTE IMMEDIATE statement. With the RETURNING BULK COLLECT INTO clause, the statement stores its result set in one or more collections.">RETURNING INTO Clause with BULK COLLECT Clause</a></p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div><a id="LNPLS803"></a><a id="LNPLS892"></a><a id="LNPLS802"></a><a id="LNPLS99877"></a><div class="props_rev_3"><a id="GUID-6E09E4FC-28C0-43C8-9E7C-A54D6398D1DE" name="GUID-6E09E4FC-28C0-43C8-9E7C-A54D6398D1DE"></a><h5 id="LNPLS-GUID-6E09E4FC-28C0-43C8-9E7C-A54D6398D1DE" class="sect5"><span class="enumeration_section">12.4.2.1 </span>SELECT INTO Statement with BULK COLLECT Clause
                     </h5>
                     <div>
                        <p>The <code class="codeph">SELECT</code> <code class="codeph">INTO</code> statement with the <code class="codeph">BULK</code> <code class="codeph">COLLECT</code> clause (also called the <code class="codeph">SELECT</code> <code class="codeph">BULK</code> <code class="codeph">COLLECT</code> <code class="codeph">INTO</code> statement) selects an entire result set into one or more collection variables. 
                        </p>
                        <p>For more information, see <span class="q">"<a href="SELECT-INTO-statement.html#GUID-6E14E04D-4344-45F3-BE80-979DD26C7A90" title="The SELECT INTO statement retrieves values from one or more database tables (as the SQL SELECT statement does) and stores them in variables (which the SQL SELECT statement does not do).">SELECT INTO Statement</a>"</span>.
                        </p>
                        <div class="infoboxnote" id="GUID-6E09E4FC-28C0-43C8-9E7C-A54D6398D1DE__GUID-B53BE4A6-1347-441E-A6CF-6B3B78159A47">
                           <p class="notep1">Caution:</p>
                           <p>The <code class="codeph">SELECT</code> <code class="codeph">BULK</code> <code class="codeph">COLLECT</code> <code class="codeph">INTO</code> statement is vulnerable to aliasing, which can cause unexpected results. For details, see <span class="q">"<a href="plsql-optimization-and-tuning.html#GUID-8731CD7C-7460-4836-8A3D-C706E5BEC0EA">SELECT BULK COLLECT INTO Statements and Aliasing</a>"</span>.
                           </p>
                        </div>
                        <p><a href="plsql-optimization-and-tuning.html#GUID-6E09E4FC-28C0-43C8-9E7C-A54D6398D1DE__BABJCBGD">Example 12-16</a> uses a <code class="codeph">SELECT</code> <code class="codeph">BULK</code> <code class="codeph">COLLECT</code> <code class="codeph">INTO</code> statement to select two database columns into two collections (nested tables).
                        </p>
                        <p><a href="plsql-optimization-and-tuning.html#GUID-6E09E4FC-28C0-43C8-9E7C-A54D6398D1DE__CIHGGBGF">Example 12-17</a> uses a <code class="codeph">SELECT</code> <code class="codeph">BULK</code> <code class="codeph">COLLECT</code> <code class="codeph">INTO</code> statement to select a result set into a nested table of records.
                        </p>
                        <div class="section">
                           <p class="subhead3" id="GUID-6E09E4FC-28C0-43C8-9E7C-A54D6398D1DE__GUID-7D0F656F-7948-42B2-A3C9-5FF9D7A08D82">Topics</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><a href="plsql-optimization-and-tuning.html#GUID-8731CD7C-7460-4836-8A3D-C706E5BEC0EA">SELECT BULK COLLECT INTO Statements and Aliasing</a></p>
                              </li>
                              <li>
                                 <p><a href="plsql-optimization-and-tuning.html#GUID-9E6FC4CF-A6B7-4C79-996D-50FF22AD3A9D">Row Limits for SELECT BULK COLLECT INTO Statements</a></p>
                              </li>
                              <li>
                                 <p><a href="plsql-optimization-and-tuning.html#GUID-7254F181-2AF7-4DD7-8278-CF911B548F25">Guidelines for Looping Through Collections</a></p>
                              </li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-6E09E4FC-28C0-43C8-9E7C-A54D6398D1DE__BABJCBGD">
                           <p class="titleinexample">Example 12-16 Bulk-Selecting Two Database Columns into Two Nested Tables</p><pre class="oac_no_warn" dir="ltr">DECLARE
  TYPE NumTab IS TABLE OF employees.employee_id%TYPE;
  TYPE NameTab IS TABLE OF employees.last_name%TYPE;
 
  enums NumTab;
  names NameTab;
 
  PROCEDURE print_first_n (n POSITIVE) IS
  BEGIN
    IF enums.COUNT = 0 THEN
      DBMS_OUTPUT.PUT_LINE ('Collections are empty.');
    ELSE
      DBMS_OUTPUT.PUT_LINE ('First ' || n || ' employees:');
 
      FOR i IN 1 .. n LOOP
        DBMS_OUTPUT.PUT_LINE (
          '  Employee #' || enums(i) || ': ' || names(i));
      END LOOP;
    END IF;
  END;
 
BEGIN
  <span class="bold">SELECT employee_id, last_name</span>
  <span class="bold">BULK COLLECT INTO enums, names</span>
  <span class="bold">FROM employees</span>
  <span class="bold">ORDER BY employee_id;</span>
 
  print_first_n(3);
  print_first_n(6);
END;
/
</pre><p>Result:</p><pre class="oac_no_warn" dir="ltr">First 3 employees:
Employee #100: King
Employee #101: Kochhar
Employee #102: De Haan
First 6 employees:
Employee #100: King
Employee #101: Kochhar
Employee #102: De Haan
Employee #103: Hunold
Employee #104: Ernst
Employee #105: Austin
</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-6E09E4FC-28C0-43C8-9E7C-A54D6398D1DE__CIHGGBGF">
                           <p class="titleinexample">Example 12-17 Bulk-Selecting into Nested Table of Records</p><pre class="oac_no_warn" dir="ltr">DECLARE
  CURSOR c1 IS
    SELECT first_name, last_name, hire_date
    FROM employees;
  
  TYPE NameSet IS TABLE OF c1%ROWTYPE;
 
  stock_managers  NameSet;  -- nested table of records
 
BEGIN 
  -- Assign values to nested table of records:
 
  <span class="bold">SELECT first_name, last_name, hire_date</span>
    <span class="bold">BULK COLLECT INTO stock_managers</span>
    <span class="bold">FROM employees</span>
    <span class="bold">WHERE job_id = 'ST_MAN'</span>
    <span class="bold">ORDER BY hire_date;</span>
 
  -- Print nested table of records:
 
    FOR i IN stock_managers.FIRST .. stock_managers.LAST LOOP
      DBMS_OUTPUT.PUT_LINE (
        stock_managers(i).hire_date || ' ' ||
        stock_managers(i).last_name  || ', ' ||
        stock_managers(i).first_name
      );
    END LOOP;END;
/
</pre><p>Result:</p><pre class="oac_no_warn" dir="ltr">01-MAY-03 Kaufling, Payam
18-JUL-04 Weiss, Matthew
10-APR-05 Fripp, Adam
10-OCT-05 Vollman, Shanta
16-NOV-07 Mourgos, Kevin</pre></div>
                        <!-- class="example" -->
                     </div><a id="LNPLS905"></a><a id="LNPLS906"></a><a id="LNPLS907"></a><a id="LNPLS904"></a><div class="props_rev_3"><a id="GUID-8731CD7C-7460-4836-8A3D-C706E5BEC0EA" name="GUID-8731CD7C-7460-4836-8A3D-C706E5BEC0EA"></a><h6 id="LNPLS-GUID-8731CD7C-7460-4836-8A3D-C706E5BEC0EA" class="sect6"><span class="enumeration_section">12.4.2.1.1 </span>SELECT BULK COLLECT INTO Statements and Aliasing
                        </h6>
                        <div>
                           <p>In a statement of the form</p><pre class="oac_no_warn" dir="ltr">SELECT <span class="italic">column</span> BULK COLLECT INTO <span class="italic">collection</span> FROM <span class="italic">table</span> ...
</pre><p><span class="italic"><code class="codeph">column</code></span> and <span class="italic"><code class="codeph">collection</code></span> are analogous to <code class="codeph">IN</code> <code class="codeph">NOCOPY</code> and <code class="codeph">OUT</code> <code class="codeph">NOCOPY</code> subprogram parameters, respectively, and PL/SQL passes them by reference. As with subprogram parameters that are passed by reference, aliasing can cause unexpected results.
                           </p>
                           <div class="infoboxnotealso" id="GUID-8731CD7C-7460-4836-8A3D-C706E5BEC0EA__GUID-CB16C98B-F206-4CD7-8584-11661690DD4F">
                              <p class="notep1">See Also:</p>
                              <p><span class="q">"<a href="plsql-subprograms.html#GUID-1D93EBAE-406B-45CE-B89F-A456E37415CB">Subprogram Parameter Aliasing with Parameters Passed by Reference</a>"</span></p>
                           </div>
                           <p>In <a href="plsql-optimization-and-tuning.html#GUID-8731CD7C-7460-4836-8A3D-C706E5BEC0EA__BABGIGII">Example 12-18</a>, the intention is to select specific values from a collection, <code class="codeph">numbers1</code>, and then store them in the same collection. The unexpected result is that all elements of <code class="codeph">numbers1</code> are deleted. For workarounds, see <a href="plsql-optimization-and-tuning.html#GUID-8731CD7C-7460-4836-8A3D-C706E5BEC0EA__BABCEEDG">Example 12-19</a> and <a href="plsql-optimization-and-tuning.html#GUID-8731CD7C-7460-4836-8A3D-C706E5BEC0EA__BABGHCAJ">Example 12-20</a>.
                           </p>
                           <p><a href="plsql-optimization-and-tuning.html#GUID-8731CD7C-7460-4836-8A3D-C706E5BEC0EA__BABCEEDG">Example 12-19</a> uses a cursor to achieve the result intended by <a href="plsql-optimization-and-tuning.html#GUID-8731CD7C-7460-4836-8A3D-C706E5BEC0EA__BABGIGII">Example 12-18</a>.
                           </p>
                           <p><a href="plsql-optimization-and-tuning.html#GUID-8731CD7C-7460-4836-8A3D-C706E5BEC0EA__BABGHCAJ">Example 12-20</a> selects specific values from a collection, <code class="codeph">numbers1</code>, and then stores them in a different collection, <code class="codeph">numbers2</code>. <a href="plsql-optimization-and-tuning.html#GUID-8731CD7C-7460-4836-8A3D-C706E5BEC0EA__BABGHCAJ">Example 12-20</a> runs faster than <a href="plsql-optimization-and-tuning.html#GUID-8731CD7C-7460-4836-8A3D-C706E5BEC0EA__BABCEEDG">Example 12-19</a>.
                           </p>
                           <div class="example" id="GUID-8731CD7C-7460-4836-8A3D-C706E5BEC0EA__BABGIGII">
                              <p class="titleinexample">Example 12-18 SELECT BULK COLLECT INTO Statement with Unexpected Results</p><pre class="oac_no_warn" dir="ltr">CREATE OR REPLACE TYPE numbers_type IS
  TABLE OF INTEGER
/
CREATE OR REPLACE PROCEDURE p (i IN INTEGER) AUTHID DEFINER IS
  numbers1  numbers_type := numbers_type(1,2,3,4,5);
BEGIN
  DBMS_OUTPUT.PUT_LINE('Before SELECT statement');
  DBMS_OUTPUT.PUT_LINE('numbers1.COUNT() = ' || numbers1.COUNT());
  
  FOR j IN 1..numbers1.COUNT() LOOP
    DBMS_OUTPUT.PUT_LINE('numbers1(' || j || ') = ' || numbers1(j));
  END LOOP;
 
  --Self-selecting BULK COLLECT INTO clause:
 
  <span class="bold">SELECT a.COLUMN_VALUE</span>
  <span class="bold">BULK COLLECT INTO numbers1</span>
  <span class="bold">FROM TABLE(numbers1) a</span>
  <span class="bold">WHERE a.COLUMN_VALUE &gt; p.i</span>
  <span class="bold">ORDER BY a.COLUMN_VALUE;</span>
 
  DBMS_OUTPUT.PUT_LINE('After SELECT statement');
  DBMS_OUTPUT.PUT_LINE('numbers1.COUNT() = ' || numbers1.COUNT());
END p;
/
</pre><p>Invoke <code class="codeph">p</code>:
                              </p><pre class="oac_no_warn" dir="ltr">BEGIN
  <span class="bold">p(2);</span>
END;
/
</pre><p>Result:</p><pre class="oac_no_warn" dir="ltr"><span class="bold">Before SELECT statement</span>
<span class="bold">numbers1.COUNT() = 5</span>
numbers1(1) = 1
numbers1(2) = 2
numbers1(3) = 3
numbers1(4) = 4
numbers1(5) = 5
<span class="bold">After SELECT statement</span>
<span class="bold">numbers1.COUNT() = 0</span>
 
PL/SQL procedure successfully completed.
</pre><p>Invoke <code class="codeph">p</code>:
                              </p><pre class="oac_no_warn" dir="ltr">BEGIN
  <span class="bold">p(10);</span>
END;
/
</pre><p>Result:</p><pre class="oac_no_warn" dir="ltr"><span class="bold">Before SELECT statement</span>
<span class="bold">numbers1.COUNT() = 5</span>
numbers1(1) = 1
numbers1(2) = 2
numbers1(3) = 3
numbers1(4) = 4
numbers1(5) = 5
<span class="bold">After SELECT statement</span>
<span class="bold">numbers1.COUNT() = 0</span>
</pre></div>
                           <!-- class="example" -->
                           <div class="example" id="GUID-8731CD7C-7460-4836-8A3D-C706E5BEC0EA__BABCEEDG">
                              <p class="titleinexample">Example 12-19 Cursor Workaround for <span><a href="plsql-optimization-and-tuning.html#GUID-8731CD7C-7460-4836-8A3D-C706E5BEC0EA__BABGIGII">Example 12-18</a></span></p><pre class="oac_no_warn" dir="ltr">CREATE OR REPLACE TYPE numbers_type IS
  TABLE OF INTEGER
/
CREATE OR REPLACE PROCEDURE p (i IN INTEGER) AUTHID DEFINER IS
  numbers1  numbers_type := numbers_type(1,2,3,4,5);
  
  <span class="bold">CURSOR c IS</span>
    <span class="bold">SELECT a.COLUMN_VALUE</span>
    <span class="bold">FROM TABLE(numbers1) a</span>
    <span class="bold">WHERE a.COLUMN_VALUE &gt; p.i</span>
    <span class="bold">ORDER BY a.COLUMN_VALUE;</span>
  BEGIN
    DBMS_OUTPUT.PUT_LINE('Before FETCH statement');
    DBMS_OUTPUT.PUT_LINE('numbers1.COUNT() = ' || numbers1.COUNT());
 
    FOR j IN 1..numbers1.COUNT() LOOP
      DBMS_OUTPUT.PUT_LINE('numbers1(' || j || ') = ' || numbers1(j));
    END LOOP;
 
  <span class="bold">OPEN c;</span>
  <span class="bold">FETCH c BULK COLLECT INTO numbers1;</span>
  <span class="bold">CLOSE c;</span>
 
  DBMS_OUTPUT.PUT_LINE('After FETCH statement');
  DBMS_OUTPUT.PUT_LINE('numbers1.COUNT() = ' || numbers1.COUNT());
 
  IF numbers1.COUNT() &gt; 0 THEN
    FOR j IN 1..numbers1.COUNT() LOOP
      DBMS_OUTPUT.PUT_LINE('numbers1(' || j || ') = ' || numbers1(j));
    END LOOP;
  END IF;
END p;
/
</pre><p>Invoke <code class="codeph">p</code>:
                              </p><pre class="oac_no_warn" dir="ltr">BEGIN
  <span class="bold">p(2);</span>
END;
/
</pre><p>Result:</p><pre class="oac_no_warn" dir="ltr"><span class="bold">Before FETCH statement</span>
<span class="bold">numbers1.COUNT() = 5</span>
numbers1(1) = 1
numbers1(2) = 2
numbers1(3) = 3
numbers1(4) = 4
numbers1(5) = 5
<span class="bold">After FETCH statement</span>
<span class="bold">numbers1.COUNT() = 3</span>
numbers1(1) = 3
numbers1(2) = 4
numbers1(3) = 5
</pre><p>Invoke <code class="codeph">p</code>:
                              </p><pre class="oac_no_warn" dir="ltr">BEGIN
  <span class="bold">p(10);</span>
END;
/
</pre><p>Result:</p><pre class="oac_no_warn" dir="ltr"><span class="bold">Before FETCH statement</span>
<span class="bold">numbers1.COUNT() = 5</span>
numbers1(1) = 1
numbers1(2) = 2
numbers1(3) = 3
numbers1(4) = 4
numbers1(5) = 5
<span class="bold">After FETCH statement</span>
<span class="bold">numbers1.COUNT() = 0</span>
</pre></div>
                           <!-- class="example" -->
                           <div class="example" id="GUID-8731CD7C-7460-4836-8A3D-C706E5BEC0EA__BABGHCAJ">
                              <p class="titleinexample">Example 12-20 Second Collection Workaround for <span><a href="plsql-optimization-and-tuning.html#GUID-8731CD7C-7460-4836-8A3D-C706E5BEC0EA__BABGIGII">Example 12-18</a></span></p><pre class="oac_no_warn" dir="ltr">CREATE OR REPLACE TYPE numbers_type IS
  TABLE OF INTEGER
/
CREATE OR REPLACE PROCEDURE p (i IN INTEGER) AUTHID DEFINER IS
  numbers1  numbers_type := numbers_type(1,2,3,4,5);
 <span class="bold">numbers2  numbers_type := numbers_type(0,0,0,0,0);</span>
  
BEGIN
  DBMS_OUTPUT.PUT_LINE('Before SELECT statement');
  
  DBMS_OUTPUT.PUT_LINE('numbers1.COUNT() = ' || numbers1.COUNT());
  
  FOR j IN 1..numbers1.COUNT() LOOP
    DBMS_OUTPUT.PUT_LINE('numbers1(' || j || ') = ' || numbers1(j));
  END LOOP;
 
  DBMS_OUTPUT.PUT_LINE('numbers2.COUNT() = ' || numbers2.COUNT());
 
  FOR j IN 1..numbers2.COUNT() LOOP
    DBMS_OUTPUT.PUT_LINE('numbers2(' || j || ') = ' || numbers2(j));
  END LOOP;
 
  SELECT a.COLUMN_VALUE
  <span class="bold">BULK COLLECT INTO numbers2      -- numbers2 appears here</span>
  <span class="bold">FROM TABLE(numbers1) a        -- numbers1 appears here</span>
  WHERE a.COLUMN_VALUE &gt; p.i
  ORDER BY a.COLUMN_VALUE;
 
  DBMS_OUTPUT.PUT_LINE('After SELECT statement');
  DBMS_OUTPUT.PUT_LINE('numbers1.COUNT() = ' || numbers1.COUNT());
 
  IF numbers1.COUNT() &gt; 0 THEN
    FOR j IN 1..numbers1.COUNT() LOOP
      DBMS_OUTPUT.PUT_LINE('numbers1(' || j || ') = ' || numbers1(j));
    END LOOP;
  END IF;
 
  DBMS_OUTPUT.PUT_LINE('numbers2.COUNT() = ' || numbers2.COUNT());
 
  IF numbers2.COUNT() &gt; 0 THEN
    FOR j IN 1..numbers2.COUNT() LOOP
      DBMS_OUTPUT.PUT_LINE('numbers2(' || j || ') = ' || numbers2(j));
    END LOOP;
  END IF;
END p;
/
</pre><p>Invoke <code class="codeph">p</code>:
                              </p><pre class="oac_no_warn" dir="ltr">BEGIN
  <span class="bold">p(2);</span>
 END;
/
</pre><p>Result:</p><pre class="oac_no_warn" dir="ltr"><span class="bold">Before SELECT statement</span>
<span class="bold">numbers1.COUNT() = 5</span>
numbers1(1) = 1
numbers1(2) = 2
numbers1(3) = 3
numbers1(4) = 4
numbers1(5) = 5
<span class="bold">numbers2.COUNT() = 5</span>
numbers2(1) = 0
numbers2(2) = 0
numbers2(3) = 0
numbers2(4) = 0
numbers2(5) = 0
<span class="bold">After SELECT statement</span>
<span class="bold">numbers1.COUNT() = 5</span>
numbers1(1) = 1
numbers1(2) = 2
numbers1(3) = 3
numbers1(4) = 4
numbers1(5) = 5
<span class="bold">numbers2.COUNT() = 3</span>
numbers2(1) = 3
numbers2(2) = 4
numbers2(3) = 5
 
PL/SQL procedure successfully completed.
</pre><p>Invoke <code class="codeph">p</code>:
                              </p><pre class="oac_no_warn" dir="ltr">BEGIN
  <span class="bold">p(10);</span>
END;
/
</pre><p>Result:</p><pre class="oac_no_warn" dir="ltr"><span class="bold">Before SELECT statement</span>
<span class="bold">numbers1.COUNT() = 5</span>
numbers1(1) = 1
numbers1(2) = 2
numbers1(3) = 3
numbers1(4) = 4
numbers1(5) = 5
<span class="bold">numbers2.COUNT() = 5</span>
numbers2(1) = 0
numbers2(2) = 0
numbers2(3) = 0
numbers2(4) = 0
numbers2(5) = 0
<span class="bold">After SELECT statement</span>
<span class="bold">numbers1.COUNT() = 5</span>
numbers1(1) = 1
numbers1(2) = 2
numbers1(3) = 3
numbers1(4) = 4
numbers1(5) = 5
<span class="bold">numbers2.COUNT() = 0</span></pre></div>
                           <!-- class="example" -->
                        </div>
                     </div><a id="LNPLS893"></a><a id="LNPLS99876"></a><div class="props_rev_3"><a id="GUID-9E6FC4CF-A6B7-4C79-996D-50FF22AD3A9D" name="GUID-9E6FC4CF-A6B7-4C79-996D-50FF22AD3A9D"></a><h6 id="LNPLS-GUID-9E6FC4CF-A6B7-4C79-996D-50FF22AD3A9D" class="sect6"><span class="enumeration_section">12.4.2.1.2 </span>Row Limits for SELECT BULK COLLECT INTO Statements
                        </h6>
                        <div>
                           <p>A <code class="codeph">SELECT</code> <code class="codeph">BULK</code> <code class="codeph">COLLECT</code> <code class="codeph">INTO</code> statement that returns a large number of rows produces a large collection. To limit the number of rows and the collection size, use one of these:
                           </p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><code class="codeph">ROWNUM</code> pseudocolumn (described in <a href="../sqlrf/ROWNUM-Pseudocolumn.html#SQLRF00255" target="_blank"><span class="italic">Oracle Database SQL Language Reference</span></a>)
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">SAMPLE</code> clause (described in <a href="../sqlrf/SELECT.html#SQLRF55293" target="_blank"><span class="italic">Oracle Database SQL Language Reference</span></a>)
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">FETCH</code> <code class="codeph">FIRST</code> clause (described in <a href="../sqlrf/SELECT.html#SQLRF55640" target="_blank"><span class="italic">Oracle Database SQL Language Reference</span></a>)
                                 </p>
                              </li>
                           </ul>
                           <p><a href="plsql-optimization-and-tuning.html#GUID-9E6FC4CF-A6B7-4C79-996D-50FF22AD3A9D__BCGFEDDI">Example 12-21</a> shows several ways to limit the number of rows that a <code class="codeph">SELECT</code> <code class="codeph">BULK</code> <code class="codeph">COLLECT</code> <code class="codeph">INTO</code> statement returns.
                           </p>
                           <div class="example" id="GUID-9E6FC4CF-A6B7-4C79-996D-50FF22AD3A9D__BCGFEDDI">
                              <p class="titleinexample">Example 12-21 Limiting Bulk Selection with ROWNUM, SAMPLE, and FETCH FIRST</p><pre class="oac_no_warn" dir="ltr">DECLARE
  TYPE SalList IS TABLE OF employees.salary%TYPE;
  sals SalList;
BEGIN
  SELECT salary BULK COLLECT INTO sals FROM employees
    <span class="bold">WHERE ROWNUM &lt;= 50</span>;
 
  SELECT salary BULK COLLECT INTO sals FROM employees
    <span class="bold">SAMPLE (10)</span>;
 
  SELECT salary BULK COLLECT INTO sals FROM employees
    <span class="bold">FETCH FIRST 50 ROWS ONLY</span>;
END;
/</pre></div>
                           <!-- class="example" -->
                        </div>
                     </div><a id="LNPLS99875"></a><div class="props_rev_3"><a id="GUID-7254F181-2AF7-4DD7-8278-CF911B548F25" name="GUID-7254F181-2AF7-4DD7-8278-CF911B548F25"></a><h6 id="LNPLS-GUID-7254F181-2AF7-4DD7-8278-CF911B548F25" class="sect6"><span class="enumeration_section">12.4.2.1.3 </span>Guidelines for Looping Through Collections
                        </h6>
                        <div>
                           <p>When a result set is stored in a collection, it is easy to loop through the rows and refer to different columns. This technique can be very fast, but also very memory-intensive. If you use it often:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>To loop once through the result set, use a cursor <code class="codeph">FOR</code> <code class="codeph">LOOP</code> (see <span class="q">"<a href="static-sql.html#GUID-25917214-FD91-499D-AB39-CE21484AB167" title="The cursor FOR LOOP statement lets you run a SELECT statement and then immediately loop through the rows of the result set.">Processing Query Result Sets With Cursor FOR LOOP Statements</a>"</span>).
                                 </p>
                                 <p>This technique avoids the memory overhead of storing a copy of the result set.</p>
                              </li>
                              <li>
                                 <p>Instead of looping through the result set to search for certain values or filter the results into a smaller set, do the searching or filtering in the query of the <code class="codeph">SELECT</code> <code class="codeph">INTO</code> statement.
                                 </p>
                                 <p>For example, in simple queries, use <code class="codeph">WHERE</code> clauses; in queries that compare multiple result sets, use set operators such as <code class="codeph">INTERSECT</code> and <code class="codeph">MINUS</code>. For information about set operators, see <a href="../sqlrf/The-UNION-ALL-INTERSECT-MINUS-Operators.html#SQLRF52341" target="_blank"><span class="italic">Oracle Database SQL Language Reference</span></a>.
                                 </p>
                              </li>
                              <li>
                                 <p>Instead of looping through the result set and running another query for each result row, use a subquery in the query of the <code class="codeph">SELECT</code> <code class="codeph">INTO</code> statement (see <span class="q">"<a href="static-sql.html#GUID-8DD487B1-1CC5-4F26-98F2-97753A7EEF70" title="If you process a query result set by looping through it and running another query for each row, then you can improve performance by removing the second query from inside the loop and making it a subquery of the first query.">Processing Query Result Sets with Subqueries</a>"</span>).
                                 </p>
                              </li>
                              <li>
                                 <p>Instead of looping through the result set and running another DML statement for each result row, use the <code class="codeph">FORALL</code> statement (see <span class="q">"<a href="plsql-optimization-and-tuning.html#GUID-6D4A1425-64DD-4723-8AAE-87B0A51A2854" title="The FORALL statement, a feature of bulk SQL, sends DML statements from PL/SQL to SQL in batches rather than one at a time.">FORALL Statement</a>"</span>).
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </div>
                  </div><a id="LNPLS895"></a><a id="LNPLS805"></a><a id="LNPLS894"></a><div class="props_rev_3"><a id="GUID-541A8B35-9B8F-432F-9E30-E73305A6E17C" name="GUID-541A8B35-9B8F-432F-9E30-E73305A6E17C"></a><h5 id="LNPLS-GUID-541A8B35-9B8F-432F-9E30-E73305A6E17C" class="sect5"><span class="enumeration_section">12.4.2.2 </span>FETCH Statement with BULK COLLECT Clause
                     </h5>
                     <div>
                        <p>The <code class="codeph">FETCH</code> statement with the <code class="codeph">BULK</code> <code class="codeph">COLLECT</code> clause (also called the <code class="codeph">FETCH</code> <code class="codeph">BULK</code> <code class="codeph">COLLECT</code> statement) fetches an entire result set into one or more collection variables.
                        </p>
                        <p> For more information, see <span class="q">"<a href="FETCH-statement.html#GUID-75BC6E63-841A-4103-9B96-8AC97F5C28BB" title="The FETCH statement retrieves rows of data from the result set of a multiple-row query—one row at a time, several rows at a time, or all rows at once—and stores the data in variables, records, or collections.">FETCH Statement</a>"</span>.
                        </p>
                        <p><a href="plsql-optimization-and-tuning.html#GUID-541A8B35-9B8F-432F-9E30-E73305A6E17C__BABCCJCB">Example 12-22</a> uses a <code class="codeph">FETCH</code> <code class="codeph">BULK</code> <code class="codeph">COLLECT</code> statement to fetch an entire result set into two collections (nested tables).
                        </p>
                        <p><a href="plsql-optimization-and-tuning.html#GUID-541A8B35-9B8F-432F-9E30-E73305A6E17C__CIHBDHIB">Example 12-23</a> uses a <code class="codeph">FETCH</code> <code class="codeph">BULK</code> <code class="codeph">COLLECT</code> statement to fetch a result set into a collection (nested table) of records.
                        </p>
                        <div class="example" id="GUID-541A8B35-9B8F-432F-9E30-E73305A6E17C__BABCCJCB">
                           <p class="titleinexample">Example 12-22 Bulk-Fetching into Two Nested Tables</p><pre class="oac_no_warn" dir="ltr">DECLARE
  TYPE NameList IS TABLE OF employees.last_name%TYPE;
  TYPE SalList IS TABLE OF employees.salary%TYPE;

  CURSOR c1 IS
    SELECT last_name, salary
    FROM employees
    WHERE salary &gt; 10000
    ORDER BY last_name;

  names  NameList;
  sals   SalList;

  TYPE RecList IS TABLE OF c1%ROWTYPE;
  recs RecList;

  v_limit PLS_INTEGER := 10;

  PROCEDURE print_results IS
  BEGIN
    <span class="bold">-- Check if collections are empty:</span>

    IF names IS NULL OR names.COUNT = 0 THEN
      DBMS_OUTPUT.PUT_LINE('No results!');
    ELSE
      DBMS_OUTPUT.PUT_LINE('Result: ');
      FOR i IN names.FIRST .. names.LAST
      LOOP
        DBMS_OUTPUT.PUT_LINE('  Employee ' || names(i) || ': $' || sals(i));
      END LOOP;
    END IF;
  END;

BEGIN
  DBMS_OUTPUT.PUT_LINE ('--- Processing all results simultaneously ---');
  OPEN c1;
  FETCH c1 BULK COLLECT INTO names, sals;
  CLOSE c1;
  print_results();
  DBMS_OUTPUT.PUT_LINE ('--- Processing ' || v_limit || ' rows at a time ---');
  OPEN c1;
  LOOP
    FETCH c1 BULK COLLECT INTO names, sals LIMIT v_limit;
    EXIT WHEN names.COUNT = 0;
    print_results();
  END LOOP;
  CLOSE c1;
  DBMS_OUTPUT.PUT_LINE ('--- Fetching records rather than columns ---');
  OPEN c1;
  FETCH c1 BULK COLLECT INTO recs;
  FOR i IN recs.FIRST .. recs.LAST
  LOOP
    -- Now all columns from result set come from one record
    DBMS_OUTPUT.PUT_LINE (
      '  Employee ' || recs(i).last_name || ': $' || recs(i).salary
    );
  END LOOP;
END;
/
</pre><p>Result:</p><pre class="oac_no_warn" dir="ltr">--- Processing all results simultaneously ---
Result:
Employee Abel: $11000
Employee Cambrault: $11000
Employee De Haan: $17000
Employee Errazuriz: $12000
Employee Fripp: $10418.1
Employee Greenberg: $12008
Employee Hartstein: $13000
Employee Higgins: $12008
Employee Kaufling: $10036.95
Employee King: $24000
Employee Kochhar: $17000
Employee Ozer: $11500
Employee Partners: $13500
Employee Raphaely: $11000
Employee Russell: $14000
Employee Vishney: $10500
Employee Weiss: $10418.1
Employee Zlotkey: $10500
--- Processing 10 rows at a time ---
Result:
Employee Abel: $11000
Employee Cambrault: $11000
Employee De Haan: $17000
Employee Errazuriz: $12000
Employee Fripp: $10418.1
Employee Greenberg: $12008
Employee Hartstein: $13000
Employee Higgins: $12008
Employee Kaufling: $10036.95
Employee King: $24000
Result:
Employee Kochhar: $17000
Employee Ozer: $11500
Employee Partners: $13500
Employee Raphaely: $11000
Employee Russell: $14000
Employee Vishney: $10500
Employee Weiss: $10418.1
Employee Zlotkey: $10500
--- Fetching records rather than columns ---
Employee Abel: $11000
Employee Cambrault: $11000
Employee De Haan: $17000
Employee Errazuriz: $12000
Employee Fripp: $10418.1
Employee Greenberg: $12008
Employee Hartstein: $13000
Employee Higgins: $12008
Employee Kaufling: $10036.95
Employee King: $24000
Employee Kochhar: $17000
Employee Ozer: $11500
Employee Partners: $13500
Employee Raphaely: $11000
Employee Russell: $14000
Employee Vishney: $10500
Employee Weiss: $10418.1
Employee Zlotkey: $10500
</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-541A8B35-9B8F-432F-9E30-E73305A6E17C__CIHBDHIB">
                           <p class="titleinexample">Example 12-23 Bulk-Fetching into Nested Table of Records</p><pre class="oac_no_warn" dir="ltr">DECLARE
  CURSOR c1 IS
    SELECT first_name, last_name, hire_date
    FROM employees;
  
  TYPE NameSet IS TABLE OF c1%ROWTYPE;
  stock_managers  NameSet;  -- nested table of records
 
  TYPE cursor_var_type is REF CURSOR;
  cv cursor_var_type;
 
BEGIN 
  -- Assign values to nested table of records:
 
  OPEN cv FOR
    SELECT first_name, last_name, hire_date
    FROM employees
    WHERE job_id = 'ST_MAN'
    ORDER BY hire_date;
 
  FETCH cv BULK COLLECT INTO stock_managers;
  CLOSE cv;
 
  -- Print nested table of records:
 
    FOR i IN stock_managers.FIRST .. stock_managers.LAST LOOP
      DBMS_OUTPUT.PUT_LINE (
        stock_managers(i).hire_date || ' ' ||
        stock_managers(i).last_name  || ', ' ||
        stock_managers(i).first_name
      );
    END LOOP;END;
/
</pre><p>Result:</p><pre class="oac_no_warn" dir="ltr">01-MAY-03 Kaufling, Payam
18-JUL-04 Weiss, Matthew
10-APR-05 Fripp, Adam
10-OCT-05 Vollman, Shanta
16-NOV-07 Mourgos, Kevin</pre></div>
                        <!-- class="example" -->
                     </div><a id="LNPLS898"></a><a id="LNPLS897"></a><div class="props_rev_3"><a id="GUID-2AD6C621-3B71-4D27-8E94-574A54BB93A6" name="GUID-2AD6C621-3B71-4D27-8E94-574A54BB93A6"></a><h6 id="LNPLS-GUID-2AD6C621-3B71-4D27-8E94-574A54BB93A6" class="sect6"><span class="enumeration_section">12.4.2.2.1 </span>Row Limits for FETCH BULK COLLECT Statements
                        </h6>
                        <div>
                           <p>A <code class="codeph">FETCH</code> <code class="codeph">BULK</code> <code class="codeph">COLLECT</code> statement that returns a large number of rows produces a large collection. To limit the number of rows and the collection size, use the <code class="codeph">LIMIT</code> clause.
                           </p>
                           <p>In <a href="plsql-optimization-and-tuning.html#GUID-2AD6C621-3B71-4D27-8E94-574A54BB93A6__BABJIAFH">Example 12-24</a>, with each iteration of the <code class="codeph">LOOP</code> statement, the <code class="codeph">FETCH</code> statement fetches ten rows (or fewer) into associative array <code class="codeph">empids</code> (overwriting the previous values). Note the exit condition for the <code class="codeph">LOOP</code> statement.
                           </p>
                           <div class="example" id="GUID-2AD6C621-3B71-4D27-8E94-574A54BB93A6__BABJIAFH">
                              <p class="titleinexample">Example 12-24 Limiting Bulk FETCH with LIMIT</p><pre class="oac_no_warn" dir="ltr">DECLARE
  TYPE numtab IS TABLE OF NUMBER INDEX BY PLS_INTEGER;

  CURSOR c1 IS
    SELECT employee_id
    FROM employees
    WHERE department_id = 80
    ORDER BY employee_id;

  empids  numtab;
BEGIN
  OPEN c1;
  LOOP  <span class="bold">-- Fetch 10 rows or fewer in each iteration</span>
    FETCH c1 BULK COLLECT INTO empids <span class="bold">LIMIT 10</span>;
    DBMS_OUTPUT.PUT_LINE ('------- Results from One Bulk Fetch --------');
    FOR i IN 1..empids.COUNT LOOP
      DBMS_OUTPUT.PUT_LINE ('Employee Id: ' || empids(i));
    END LOOP;
    <span class="bold">EXIT WHEN c1%NOTFOUND;</span>
  END LOOP;
  CLOSE c1;
END;
/
</pre><p>Result:</p><pre class="oac_no_warn" dir="ltr">------- Results from One Bulk Fetch --------
Employee Id: 145
Employee Id: 146
Employee Id: 147
Employee Id: 148
Employee Id: 149
Employee Id: 150
Employee Id: 151
Employee Id: 152
Employee Id: 153
Employee Id: 154
------- Results from One Bulk Fetch --------
Employee Id: 155
Employee Id: 156
Employee Id: 157
Employee Id: 158
Employee Id: 159
Employee Id: 160
Employee Id: 161
Employee Id: 162
Employee Id: 163
Employee Id: 164
------- Results from One Bulk Fetch --------
Employee Id: 165
Employee Id: 166
Employee Id: 167
Employee Id: 168
Employee Id: 169
Employee Id: 170
Employee Id: 171
Employee Id: 172
Employee Id: 173
Employee Id: 174
------- Results from One Bulk Fetch --------
Employee Id: 175
Employee Id: 176
Employee Id: 177
Employee Id: 179</pre></div>
                           <!-- class="example" -->
                        </div>
                     </div>
                  </div><a id="LNPLS900"></a><a id="LNPLS899"></a><div class="props_rev_3"><a id="GUID-33749752-0DC6-4749-8A84-77CF3AC6FD6A" name="GUID-33749752-0DC6-4749-8A84-77CF3AC6FD6A"></a><h5 id="LNPLS-GUID-33749752-0DC6-4749-8A84-77CF3AC6FD6A" class="sect5"><span class="enumeration_section">12.4.2.3 </span>RETURNING INTO Clause with BULK COLLECT Clause
                     </h5>
                     <div>
                        <p>The <code class="codeph">RETURNING</code> <code class="codeph">INTO</code> clause with the <code class="codeph">BULK</code> <code class="codeph">COLLECT</code> clause (also called the <code class="codeph">RETURNING</code> <code class="codeph">BULK</code> <code class="codeph">COLLECT</code> <code class="codeph">INTO</code> clause) can appear in an <code class="codeph">INSERT</code>, <code class="codeph">UPDATE</code>, <code class="codeph">DELETE</code>, or <code class="codeph">EXECUTE</code> <code class="codeph">IMMEDIATE</code> statement. With the <code class="codeph">RETURNING</code> <code class="codeph">BULK</code> <code class="codeph">COLLECT</code> <code class="codeph">INTO</code> clause, the statement stores its result set in one or more collections. 
                        </p>
                        <p>For more information, see <span class="q">"<a href="RETURNING-INTO-clause.html#GUID-38F735B9-1100-45AF-AE71-18FB74A899BE" title="The RETURNING INTO clause specifies the variables in which to store the values returned by the statement to which the clause belongs.">RETURNING INTO Clause</a>"</span>.
                        </p>
                        <p><a href="plsql-optimization-and-tuning.html#GUID-33749752-0DC6-4749-8A84-77CF3AC6FD6A__BABHDFDE">Example 12-25</a> uses a <code class="codeph">DELETE</code> statement with the <code class="codeph">RETURNING</code> <code class="codeph">BULK</code> <code class="codeph">COLLECT</code> <code class="codeph">INTO</code> clause to delete rows from a table and return them in two collections (nested tables).
                        </p>
                        <div class="example" id="GUID-33749752-0DC6-4749-8A84-77CF3AC6FD6A__BABHDFDE">
                           <p class="titleinexample">Example 12-25 Returning Deleted Rows in Two Nested Tables</p><pre class="oac_no_warn" dir="ltr">DROP TABLE emp_temp;
CREATE TABLE emp_temp AS
SELECT * FROM employees
ORDER BY employee_id;

DECLARE
  TYPE NumList IS TABLE OF employees.employee_id%TYPE;
  enums  NumList;
  TYPE NameList IS TABLE OF employees.last_name%TYPE;
  names  NameList;
BEGIN
  DELETE FROM emp_temp
  WHERE department_id = 30
  <span class="bold">RETURNING employee_id, last_name</span>
  <span class="bold">BULK COLLECT INTO enums, names</span>;

  DBMS_OUTPUT.PUT_LINE ('Deleted ' || SQL%ROWCOUNT || ' rows:');
  FOR i IN enums.FIRST .. enums.LAST
  LOOP
    DBMS_OUTPUT.PUT_LINE ('Employee #' || enums(i) || ': ' || names(i));
  END LOOP;
END;
/
</pre><p>Result:</p><pre class="oac_no_warn" dir="ltr">Deleted 6 rows:
Employee #114: Raphaely
Employee #115: Khoo
Employee #116: Baida
Employee #117: Tobias
Employee #118: Himuro
Employee #119: Colmenares</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div>
               </div><a id="LNPLS902"></a><a id="LNPLS806"></a><a id="LNPLS901"></a><div class="props_rev_3"><a id="GUID-D67D19A6-4717-4556-B027-15C3DED0519A" name="GUID-D67D19A6-4717-4556-B027-15C3DED0519A"></a><h4 id="LNPLS-GUID-D67D19A6-4717-4556-B027-15C3DED0519A" class="sect4"><span class="enumeration_section">12.4.3 </span>Using FORALL Statement and BULK COLLECT Clause Together
                  </h4>
                  <div>
                     <p>In a <code class="codeph">FORALL</code> statement, the DML statement can have a <code class="codeph">RETURNING</code> <code class="codeph">BULK</code> <code class="codeph">COLLECT</code> <code class="codeph">INTO</code> clause. For each iteration of the <code class="codeph">FORALL</code> statement, the DML statement stores the specified values in the specified collections—without overwriting the previous values, as the same DML statement would do in a <code class="codeph">FOR</code> <code class="codeph">LOOP</code> statement.
                     </p>
                     <div class="section">
                        <p>In <a href="plsql-optimization-and-tuning.html#GUID-D67D19A6-4717-4556-B027-15C3DED0519A__BABEJHDE">Example 12-26</a>, the <code class="codeph">FORALL</code> statement runs a <code class="codeph">DELETE</code> statement that has a <code class="codeph">RETURNING</code> <code class="codeph">BULK</code> <code class="codeph">COLLECT</code> <code class="codeph">INTO</code> clause. For each iteration of the <code class="codeph">FORALL</code> statement, the <code class="codeph">DELETE</code> statement stores the <code class="codeph">employee_id</code> and <code class="codeph">department_id</code> values of the deleted row in the collections <code class="codeph">e_ids</code> and <code class="codeph">d_ids</code>, respectively.
                        </p>
                        <p><a href="plsql-optimization-and-tuning.html#GUID-D67D19A6-4717-4556-B027-15C3DED0519A__BABDCEBE">Example 12-27</a> is like <a href="plsql-optimization-and-tuning.html#GUID-D67D19A6-4717-4556-B027-15C3DED0519A__BABEJHDE">Example 12-26</a> except that it uses a <code class="codeph">FOR</code> <code class="codeph">LOOP</code> statement instead of a <code class="codeph">FORALL</code> statement.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-D67D19A6-4717-4556-B027-15C3DED0519A__BABEJHDE">
                        <p class="titleinexample">Example 12-26 DELETE with RETURN BULK COLLECT INTO in FORALL Statement</p><pre class="oac_no_warn" dir="ltr">DROP TABLE emp_temp;
CREATE TABLE emp_temp AS
SELECT * FROM employees
ORDER BY employee_id, department_id;

DECLARE
  TYPE NumList IS TABLE OF NUMBER;
  depts  NumList := NumList(10,20,30);

  TYPE enum_t IS TABLE OF employees.employee_id%TYPE;
  e_ids  enum_t;

  TYPE dept_t IS TABLE OF employees.department_id%TYPE;
  d_ids  dept_t;

BEGIN
  <span class="bold">FORALL</span> j IN depts.FIRST..depts.LAST
    DELETE FROM emp_temp
    WHERE department_id = depts(j)
    <span class="bold">RETURNING</span> employee_id, department_id
    <span class="bold">BULK COLLECT INTO</span> e_ids, d_ids;

  DBMS_OUTPUT.PUT_LINE ('Deleted ' || SQL%ROWCOUNT || ' rows:');

  FOR i IN e_ids.FIRST .. e_ids.LAST
  LOOP
    DBMS_OUTPUT.PUT_LINE (
      'Employee #' || e_ids(i) || ' from dept #' || d_ids(i)
    );
  END LOOP;
END;
/
</pre><p>Result:</p><pre class="oac_no_warn" dir="ltr">Deleted 9 rows:
Employee #200 from dept #10
Employee #201 from dept #20
Employee #202 from dept #20
Employee #114 from dept #30
Employee #115 from dept #30
Employee #116 from dept #30
Employee #117 from dept #30
Employee #118 from dept #30
Employee #119 from dept #30
</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-D67D19A6-4717-4556-B027-15C3DED0519A__BABDCEBE">
                        <p class="titleinexample">Example 12-27 DELETE with RETURN BULK COLLECT INTO in FOR LOOP Statement</p><pre class="oac_no_warn" dir="ltr">DECLARE
  TYPE NumList IS TABLE OF NUMBER;
  depts  NumList := NumList(10,20,30);
 
  TYPE enum_t IS TABLE OF employees.employee_id%TYPE;
  e_ids  enum_t;
 
  TYPE dept_t IS TABLE OF employees.department_id%TYPE;
  d_ids  dept_t;
 
BEGIN
  <span class="bold">FOR</span> j IN depts.FIRST..depts.LAST <span class="bold">LOOP</span>
    DELETE FROM emp_temp
    WHERE department_id = depts(j)
    <span class="bold">RETURNING</span> employee_id, department_id
    <span class="bold">BULK COLLECT INTO</span> e_ids, d_ids;
  END LOOP;
 
  DBMS_OUTPUT.PUT_LINE ('Deleted ' || SQL%ROWCOUNT || ' rows:');
 
  FOR i IN e_ids.FIRST .. e_ids.LAST
  LOOP
    DBMS_OUTPUT.PUT_LINE (
      'Employee #' || e_ids(i) || ' from dept #' || d_ids(i)
    );
  END LOOP;
END;
/
</pre><p>Result:</p><pre class="oac_no_warn" dir="ltr">Deleted 6 rows:
Employee #114 from dept #30
Employee #115 from dept #30
Employee #116 from dept #30
Employee #117 from dept #30
Employee #118 from dept #30
Employee #119 from dept #30</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="LNPLS807"></a><a id="LNPLS903"></a><div class="props_rev_3"><a id="GUID-14F071C6-C0AE-4D39-803F-420840FD34AB" name="GUID-14F071C6-C0AE-4D39-803F-420840FD34AB"></a><h4 id="LNPLS-GUID-14F071C6-C0AE-4D39-803F-420840FD34AB" class="sect4"><span class="enumeration_section">12.4.4 </span>Client Bulk-Binding of Host Arrays
                  </h4>
                  <div>
                     <p>Client programs (such as OCI and Pro*C programs) can use PL/SQL anonymous blocks to bulk-bind input and output host arrays. This is the most efficient way to pass collections to and from the database server.</p>
                     <p>In the client program, declare and assign values to the host variables to be referenced in the anonymous block. In the anonymous block, prefix each host variable name with a colon (:) to distinguish it from a PL/SQL collection variable name. When the client program runs, the database server runs the PL/SQL anonymous block.</p>
                     <p>In <a href="plsql-optimization-and-tuning.html#GUID-14F071C6-C0AE-4D39-803F-420840FD34AB__BABJFFFB">Example 12-28</a>, the anonymous block uses a <code class="codeph">FORALL</code> statement to bulk-bind a host input array. In the <code class="codeph">FORALL</code> statement, the <code class="codeph">DELETE</code> statement refers to four host variables: scalars <code class="codeph">lower</code>, <code class="codeph">upper</code>, and <code class="codeph">emp_id</code> and array <code class="codeph">depts</code>.
                     </p>
                     <div class="example" id="GUID-14F071C6-C0AE-4D39-803F-420840FD34AB__BABJFFFB">
                        <p class="titleinexample">Example 12-28 Anonymous Block Bulk-Binds Input Host Array</p><pre class="oac_no_warn" dir="ltr">BEGIN
  FORALL i IN <span class="bold">:lower</span>..<span class="bold">:upper</span>
    DELETE FROM employees
    WHERE department_id = <span class="bold">:depts</span>(i);
END;
/</pre></div>
                     <!-- class="example" -->
                  </div>
               </div>
            </div><a id="LNPLS808"></a><a id="LNPLS01210"></a><div class="props_rev_3"><a id="GUID-ED557894-EC08-47E0-A629-0E4AEDDBB77B" name="GUID-ED557894-EC08-47E0-A629-0E4AEDDBB77B"></a><h3 id="LNPLS-GUID-ED557894-EC08-47E0-A629-0E4AEDDBB77B" class="sect3"><span class="enumeration_section">12.5 </span>Chaining Pipelined Table Functions for Multiple Transformations
               </h3>
               <div>
                  <div class="section">
                     <p>Chaining pipelined table functions is an efficient way to perform multiple transformations on data.</p>
                     <div class="infoboxnote" id="GUID-ED557894-EC08-47E0-A629-0E4AEDDBB77B__GUID-9AFBBB9C-B647-498E-8EE7-8148D76636C9">
                        <p class="notep1">Note:</p>
                        <p>You cannot run a pipelined table function over a database link. The reason is that the return type of a pipelined table function is a SQL user-defined type, which can be used only in a single database (as explained in <a href="../adobj/Sql-object-types-and-references.html#ADOBJ7083" target="_blank"><span class="italic">Oracle Database Object-Relational Developer's Guide</span></a>). Although the return type of a pipelined table function might appear to be a PL/SQL type, the database actually converts that PL/SQL type to a corresponding SQL user-defined type.
                        </p>
                     </div>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-ED557894-EC08-47E0-A629-0E4AEDDBB77B__GUID-D3676553-6971-4826-A7F8-C1FFAFB9C597">Topics</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="plsql-optimization-and-tuning.html#GUID-4E10CBFA-4B6A-4761-8905-83C26C112694" title="A table function is a user-defined PL/SQL function that returns a collection of rows (an associative array, nested table or varray).">Overview of Table Functions</a></p>
                        </li>
                        <li>
                           <p><a href="plsql-optimization-and-tuning.html#GUID-58D850B2-A416-47EA-8803-8936E2D6748A">Creating Pipelined Table Functions</a></p>
                        </li>
                        <li>
                           <p><a href="plsql-optimization-and-tuning.html#GUID-6C5DE334-7A63-41A3-BB4C-7B32CBF5607E">Pipelined Table Functions as Transformation Functions</a></p>
                        </li>
                        <li>
                           <p><a href="plsql-optimization-and-tuning.html#GUID-F99730AD-EBF2-4BD6-B63D-BFEFBF569A1E">Chaining Pipelined Table Functions</a></p>
                        </li>
                        <li>
                           <p><a href="plsql-optimization-and-tuning.html#GUID-66AF0686-5781-4BCB-B067-6F03BA9B23AE">Fetching from Results of Pipelined Table Functions</a></p>
                        </li>
                        <li>
                           <p><a href="plsql-optimization-and-tuning.html#GUID-BC13A2D1-A182-46C7-A3DC-959724DD5BD6">Passing CURSOR Expressions to Pipelined Table Functions</a></p>
                        </li>
                        <li>
                           <p><a href="plsql-optimization-and-tuning.html#GUID-4903A047-B1E7-4654-A842-630E9EDFDF14">DML Statements on Pipelined Table Function Results</a></p>
                        </li>
                        <li>
                           <p><a href="plsql-optimization-and-tuning.html#GUID-4B0E1C6B-8C73-4905-9E97-37C2667D2184">NO_DATA_NEEDED Exception</a></p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
               </div><a id="LNPLS915"></a><div class="props_rev_3"><a id="GUID-4E10CBFA-4B6A-4761-8905-83C26C112694" name="GUID-4E10CBFA-4B6A-4761-8905-83C26C112694"></a><h4 id="LNPLS-GUID-4E10CBFA-4B6A-4761-8905-83C26C112694" class="sect4"><span class="enumeration_section">12.5.1 </span>Overview of Table Functions
                  </h4>
                  <div>
                     <p>A <span class="bold">table function</span> is a user-defined PL/SQL function that returns a collection of rows (an associative array, nested table or varray). 
                     </p>
                     <p>You can select from this collection as if it were a database table by invoking the table function inside the <code class="codeph">TABLE</code> clause in a <code class="codeph">SELECT</code> statement. The TABLE operator is optional.
                     </p>
                     <p>For example:</p><pre class="oac_no_warn" dir="ltr">SELECT * FROM TABLE(<span class="italic">table_function_name</span>(<span class="italic">parameter_list</span>))
</pre><p>Alternatively, the same query can be written without the TABLE operator as follow:</p><pre class="oac_no_warn" dir="ltr">SELECT * FROM <span class="italic">table_function_name</span>(<span class="italic">parameter_list</span>)
</pre><p>A table function can take a collection of rows as input (that is, it can have an input parameter that is a nested table, varray, or cursor variable). Therefore, output from table function <code class="codeph">tf1</code> can be input to table function <code class="codeph">tf2</code>, and output from <code class="codeph">tf2</code> can be input to table function <code class="codeph">tf3</code>, and so on. 
                     </p>
                     <p>To improve the performance of a table function, you can:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Enable the function for parallel execution, with the <code class="codeph">PARALLEL_ENABLE</code> option.
                           </p>
                           <p>Functions enabled for parallel execution can run concurrently.</p>
                        </li>
                        <li>
                           <p>Stream the function results directly to the next process, with Oracle Streams.</p>
                           <p>Streaming eliminates intermediate staging between processes. </p>
                        </li>
                        <li>
                           <p>Pipeline the function results, with the <code class="codeph">PIPELINED</code> option.
                           </p>
                           <p>A <span class="bold">pipelined table function</span> returns a row to its invoker immediately after processing that row and continues to process rows. Response time improves because the entire collection need not be constructed and returned to the server before the query can return a single result row. (Also, the function needs less memory, because the object cache need not materialize the entire collection.)
                           </p>
                           <div class="infoboxnote" id="GUID-4E10CBFA-4B6A-4761-8905-83C26C112694__GUID-7C0FFF2A-FA95-413F-83E4-15C34A108D99">
                              <p class="notep1">Caution:</p>
                              <p>A pipelined table function always references the current state of the data. If the data in the collection changes after the cursor opens for the collection, then the cursor reflects the changes. PL/SQL variables are private to a session and are not transactional. Therefore, read consistency, well known for its applicability to table data, does not apply to PL/SQL collection variables.</p>
                           </div>
                        </li>
                     </ul>
                     <div class="infoboxnotealso" id="GUID-4E10CBFA-4B6A-4761-8905-83C26C112694__GUID-959E1FAE-503A-4A95-8D3E-4E8AC64A34BA">
                        <p class="notep1">See Also:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><a href="plsql-optimization-and-tuning.html#GUID-F99730AD-EBF2-4BD6-B63D-BFEFBF569A1E">Chaining Pipelined Table Functions</a></p>
                           </li>
                           <li>
                              <p><a href="../sqlrf/SELECT.html#SQLRF55241" target="_blank"><span class="italic">Oracle Database SQL Language Reference</span></a> for more information about the <code class="codeph">TABLE</code> clause of the <code class="codeph">SELECT</code> statement
                              </p>
                           </li>
                           <li>
                              <p><a href="../addci/using-pipelined-and-parallel-table-functions.html#ADDCI2140" target="_blank"><span class="italic">Oracle Database Data Cartridge Developer's Guide</span></a> for information about using pipelined and parallel table functions
                              </p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="LNPLS812"></a><a id="LNPLS814"></a><a id="LNPLS815"></a><a id="LNPLS817"></a><a id="LNPLS818"></a><a id="LNPLS819"></a><a id="LNPLS820"></a><a id="LNPLS821"></a><a id="LNPLS822"></a><a id="LNPLS917"></a><a id="LNPLS916"></a><div class="props_rev_3"><a id="GUID-58D850B2-A416-47EA-8803-8936E2D6748A" name="GUID-58D850B2-A416-47EA-8803-8936E2D6748A"></a><h4 id="LNPLS-GUID-58D850B2-A416-47EA-8803-8936E2D6748A" class="sect4"><span class="enumeration_section">12.5.2 </span>Creating Pipelined Table Functions
                  </h4>
                  <div>
                     <p>A pipelined table function must be either a standalone function or a package function.</p>
                     <div class="section">
                        <p class="subhead3" id="GUID-58D850B2-A416-47EA-8803-8936E2D6748A__GUID-41A5E255-6CE6-4C9F-885E-629CDC346391">PIPELINED Option (Required)</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>For a standalone function, specify the <code class="codeph">PIPELINED</code> option in the <code class="codeph">CREATE</code> <code class="codeph">FUNCTION</code> statement (for syntax, see <span class="q">"<a href="CREATE-FUNCTION-statement.html#GUID-B71BC5BD-B87C-4054-AAA5-213E856651F2" title="The CREATE FUNCTION statement creates or replaces a standalone function or a call specification.">CREATE FUNCTION Statement</a>"</span>). For a package function, specify the <code class="codeph">PIPELINED</code> option in both the function declaration and function definition (for syntax, see <span class="q">"<a href="function-declaration-and-definition.html#GUID-4E19FB09-46B5-4CE5-8A5B-CD815C29DA1C" title="Before invoking a function, you must declare and define it. You can either declare it first (with function_declaration) and then define it later in the same block, subprogram, or package (with function_definition) or declare and define it at the same time (with function_definition).">Function Declaration and Definition</a>"</span>).
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-58D850B2-A416-47EA-8803-8936E2D6748A__GUID-CA0BC3A1-06BA-4A57-8B43-9877CF7920C9">PARALLEL_ENABLE Option (Recommended)</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>To improve its performance, enable the pipelined table function for parallel execution by specifying the <code class="codeph">PARALLEL_ENABLE</code> option.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-58D850B2-A416-47EA-8803-8936E2D6748A__GUID-C2E6238D-0092-48B3-8AE9-6E376A017B55">AUTONOMOUS_TRANSACTION Pragma</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>If the pipelined table function runs DML statements, then make it autonomous, with the <code class="codeph">AUTONOMOUS_TRANSACTION</code> pragma (described in <span class="q">"<a href="AUTONOMOUS_TRANSACTION-pragma.html#GUID-AD33D949-081B-4CD3-A240-C29773E908C3" title="The AUTONOMOUS_TRANSACTION pragma marks a routine as autonomous; that is, independent of the main transaction.">AUTONOMOUS_TRANSACTION Pragma</a>"</span>). Then, during parallel execution, each instance of the function creates an independent transaction.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-58D850B2-A416-47EA-8803-8936E2D6748A__GUID-495A9DF1-3DD7-421F-ADF3-64A867141604">DETERMINISTIC Option (Recommended)</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>Multiple invocations of a pipelined table function, in either the same query or separate queries, cause multiple executions of the underlying implementation. If the function is deterministic, specify the <code class="codeph">DETERMINISTIC</code> option, described in <span class="q">"<a href="DETERMINISTIC-clause.html#GUID-6AECC957-27CC-4334-9F43-0FBE88F92654" title="The deterministic option marks a function that returns predictable results and has no side effects.">DETERMINISTIC Clause</a>"</span>.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-58D850B2-A416-47EA-8803-8936E2D6748A__GUID-78C71E9A-32AB-4423-848A-B085420AB9B7">Parameters</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>Typically, a pipelined table function has one or more cursor variable parameters. For information about cursor variables as function parameters, see <span class="q">"<a href="static-sql.html#GUID-9713DFC2-3C2E-49B2-922F-02D43F9D0619" title="You can use a cursor variable as a subprogram parameter, which makes it useful for passing query results between subprograms.">Cursor Variables as Subprogram Parameters</a>"</span>.
                        </p>
                        <div class="infoboxnotealso" id="GUID-58D850B2-A416-47EA-8803-8936E2D6748A__GUID-99E1FA89-3D24-490D-B2A6-9B019685B4A2">
                           <p class="notep1">See Also:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><span class="q">"<a href="static-sql.html#GUID-4A6E054A-4002-418D-A1CA-DE849CD7E6D5" title="To create a cursor variable, either declare a variable of the predefined type SYS_REFCURSOR or define a REF CURSOR type and then declare a variable of that type.After opening a cursor variable, you can fetch the rows of the query result set with the FETCH statement.You can assign to a PL/SQL cursor variable the value of another PL/SQL cursor variable or host cursor variable.The query associated with a cursor variable can reference any variable in its scope.You can use a cursor variable as a subprogram parameter, which makes it useful for passing query results between subprograms.You can use a cursor variable as a host variable, which makes it useful for passing query results between PL/SQL stored subprograms and their clients.">Cursor Variables</a>"</span> for general information about cursor variables
                                 </p>
                              </li>
                              <li>
                                 <p><span class="q">"<a href="plsql-subprograms.html#GUID-C0397690-70F4-480D-ADC9-02D277DAA1BB">Subprogram Parameters</a>"</span> for general information about subprogram parameters
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-58D850B2-A416-47EA-8803-8936E2D6748A__GUID-77C6682E-71FE-4AB6-B50D-BC33EFE6E3EE">RETURN Data Type</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>The data type of the value that a pipelined table function returns must be a collection type defined either at schema level or inside a package (therefore, it cannot be an associative array type). The elements of the collection type must be SQL data types, not data types supported only by PL/SQL (such as <code class="codeph">PLS_INTEGER</code> and <code class="codeph">BOOLEAN</code>). For information about collection types, see <span class="q">"<a href="plsql-collections-and-records.html#GUID-7E9034D5-0D33-43A1-9012-918350FE148C" title="PL/SQL has three collection types—associative array, VARRAY (variable-size array), and nested table.">Collection Types</a>"</span>. For information about SQL data types, see <a href="../sqlrf/Basic-Elements-of-Oracle-SQL.html#SQLRF002" target="_blank"><span class="italic">Oracle Database SQL Language Reference</span></a>.
                        </p>
                        <p>You can use SQL data types <code class="codeph">ANYTYPE</code>, <code class="codeph">ANYDATA</code>, and <code class="codeph">ANYDATASET</code> to dynamically encapsulate and access type descriptions, data instances, and sets of data instances of any other SQL type, including object and collection types. You can also use these types to create unnamed types, including anonymous collection types. For information about these types, see <a href="../arpls/DBMS_TYPES.html#ARPLS076" target="_blank"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a>.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-58D850B2-A416-47EA-8803-8936E2D6748A__GUID-378C1F09-915F-4470-B275-C5F6398396D5">PIPE ROW Statement</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>Inside a pipelined table function, use the <code class="codeph">PIPE</code> <code class="codeph">ROW</code> statement to return a collection element to the invoker without returning control to the invoker. See <span class="q">"<a href="PIPE-ROW-statement.html#GUID-AD2713A9-062A-42DD-B49E-804C6120378B" title="The PIPE ROW statement, which can appear only in the body of a pipelined table function, returns a table row (but not control) to the invoker of the function.">PIPE ROW Statement</a>"</span> for its syntax and semantics.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-58D850B2-A416-47EA-8803-8936E2D6748A__GUID-4EF5A313-685A-41FA-ABEE-B3AC8FE583B9">RETURN Statement</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>As in every function, every execution path in a pipelined table function must lead to a <code class="codeph">RETURN</code> statement, which returns control to the invoker. However, in a pipelined table function, a <code class="codeph">RETURN</code> statement need not return a value to the invoker. See <span class="q">"<a href="RETURN-statement.html#GUID-2DCDD1F2-041A-479C-A2F8-B3B68F50FE5D" title="The RETURN statement immediately ends the execution of the subprogram or anonymous block that contains it.">RETURN Statement</a>"</span> for its syntax and semantics.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-58D850B2-A416-47EA-8803-8936E2D6748A__GUID-3F621E40-EBFE-45E3-82B0-D9BBAF013C08">Example</p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-58D850B2-A416-47EA-8803-8936E2D6748A__BABDGCDH">
                        <p class="titleinexample">Example 12-29 Creating and Invoking Pipelined Table Function</p>
                        <p>This example creates a package that includes a pipelined table function, <code class="codeph">f1</code>, and then selects from the collection of rows that <code class="codeph">f1</code> returns.
                        </p><pre class="oac_no_warn" dir="ltr">CREATE OR REPLACE PACKAGE pkg1 AUTHID DEFINER AS
  TYPE numset_t IS TABLE OF NUMBER;
  <span class="bold">FUNCTION f1(x NUMBER) RETURN numset_t PIPELINED;</span>
END pkg1;
/

</pre><p>Create a pipelined table function f1 that returns a collection of elements (1,2,3,... x).</p><pre class="oac_no_warn" dir="ltr">CREATE OR REPLACE PACKAGE BODY pkg1 AS
  <span class="bold">FUNCTION f1(x NUMBER) RETURN numset_t PIPELINED IS</span>
  BEGIN
    FOR i IN 1..x LOOP
      <span class="bold">PIPE ROW(i);</span>
    END LOOP;
    <span class="bold">RETURN;</span>
  END f1;
END pkg1;
</pre><pre class="oac_no_warn" dir="ltr">SELECT * FROM <span class="bold">TABLE(pkg1.f1(5)</span>);
</pre><p>Result:</p><pre class="oac_no_warn" dir="ltr">COLUMN_VALUE
------------
           1
           2
           3
           4
           5
 
5 rows selected.</pre><pre class="oac_no_warn" dir="ltr">SELECT * FROM <span class="bold">pkg1.f1(2)</span>;
</pre><p>Result:</p><pre class="oac_no_warn" dir="ltr">COLUMN_VALUE
------------
           1
           2
</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="LNPLS919"></a><a id="LNPLS918"></a><div class="props_rev_3"><a id="GUID-6C5DE334-7A63-41A3-BB4C-7B32CBF5607E" name="GUID-6C5DE334-7A63-41A3-BB4C-7B32CBF5607E"></a><h4 id="LNPLS-GUID-6C5DE334-7A63-41A3-BB4C-7B32CBF5607E" class="sect4"><span class="enumeration_section">12.5.3 </span>Pipelined Table Functions as Transformation Functions
                  </h4>
                  <div>
                     <p>A pipelined table function with a cursor variable parameter can serve as a transformation function. Using the cursor variable, the function fetches an input row. Using the <code class="codeph">PIPE</code> <code class="codeph">ROW</code> statement, the function pipes the transformed row or rows to the invoker. If the <code class="codeph">FETCH</code> and <code class="codeph">PIPE</code> <code class="codeph">ROW</code> statements are inside a <code class="codeph">LOOP</code> statement, the function can transform multiple input rows.
                     </p>
                     <p>In <a href="plsql-optimization-and-tuning.html#GUID-6C5DE334-7A63-41A3-BB4C-7B32CBF5607E__BABIEICA">Example 12-30</a>, the pipelined table function transforms each selected row of the <code class="codeph">employees</code> table to two nested table rows, which it pipes to the <code class="codeph">SELECT</code> statement that invokes it. The actual parameter that corresponds to the formal cursor variable parameter is a <code class="codeph">CURSOR</code> expression; for information about these, see <span class="q">"<a href="plsql-optimization-and-tuning.html#GUID-BC13A2D1-A182-46C7-A3DC-959724DD5BD6">Passing CURSOR Expressions to Pipelined Table Functions</a>"</span>.
                     </p>
                     <div class="example" id="GUID-6C5DE334-7A63-41A3-BB4C-7B32CBF5607E__BABIEICA">
                        <p class="titleinexample">Example 12-30 Pipelined Table Function Transforms Each Row to Two Rows</p><pre class="oac_no_warn" dir="ltr">CREATE OR REPLACE PACKAGE refcur_pkg AUTHID DEFINER IS
  TYPE refcur_t IS REF CURSOR RETURN employees%ROWTYPE;
  TYPE outrec_typ IS RECORD (
    var_num    NUMBER(6),
    var_char1  VARCHAR2(30),
    var_char2  VARCHAR2(30)
  );
  TYPE outrecset IS TABLE OF outrec_typ;
  FUNCTION f_trans (p refcur_t) RETURN outrecset PIPELINED;
END refcur_pkg;
/

CREATE OR REPLACE PACKAGE BODY refcur_pkg IS
  <span class="bold">FUNCTION f_trans (p refcur_t) RETURN outrecset PIPELINED IS</span>
    out_rec outrec_typ;
    in_rec  p%ROWTYPE;
  BEGIN
    LOOP
      <span class="bold">FETCH p INTO in_rec;  -- input row</span>
      EXIT WHEN p%NOTFOUND;

      out_rec.var_num := in_rec.employee_id;
      out_rec.var_char1 := in_rec.first_name;
      out_rec.var_char2 := in_rec.last_name;
      <span class="bold">PIPE ROW(out_rec);  -- first transformed output row</span>

      out_rec.var_char1 := in_rec.email;
      out_rec.var_char2 := in_rec.phone_number;
      <span class="bold">PIPE ROW(out_rec);  -- second transformed output row</span>
    END LOOP;
    CLOSE p;
    RETURN;
  END f_trans;
END refcur_pkg;
/

SELECT * FROM <span class="bold">TABLE (</span>
  <span class="bold">refcur_pkg.f_trans (</span>
    <span class="bold">CURSOR (SELECT * FROM employees WHERE department_id = 60)</span>
  <span class="bold">)</span>
);
</pre><p>Result:</p><pre class="oac_no_warn" dir="ltr">   VAR_NUM VAR_CHAR1                      VAR_CHAR2
---------- ------------------------------ ------------------------------
       103 Alexander                      Hunold
       103 AHUNOLD                        590.423.4567
       104 Bruce                          Ernst
       104 BERNST                         590.423.4568
       105 David                          Austin
       105 DAUSTIN                        590.423.4569
       106 Valli                          Pataballa
       106 VPATABAL                       590.423.4560
       107 Diana                          Lorentz
       107 DLORENTZ                       590.423.5567

10 rows selected.</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="LNPLS921"></a><div class="props_rev_3"><a id="GUID-F99730AD-EBF2-4BD6-B63D-BFEFBF569A1E" name="GUID-F99730AD-EBF2-4BD6-B63D-BFEFBF569A1E"></a><h4 id="LNPLS-GUID-F99730AD-EBF2-4BD6-B63D-BFEFBF569A1E" class="sect4"><span class="enumeration_section">12.5.4 </span>Chaining Pipelined Table Functions
                  </h4>
                  <div>
                     <div class="section">
                        <p>To <span class="bold">chain</span> pipelined table functions <code class="codeph">tf1</code> and <code class="codeph">tf2</code> is to make the output of <code class="codeph">tf1</code> the input of <code class="codeph">tf2</code>. For example:
                        </p><pre class="oac_no_warn" dir="ltr">SELECT * FROM TABLE(tf2(CURSOR(SELECT * FROM TABLE(tf1()))));
</pre><p>The rows that <code class="codeph">tf1</code> pipes out must be compatible actual parameters for the formal input parameters of <code class="codeph">tf2</code>.
                        </p>
                        <p>If chained pipelined table functions are enabled for parallel execution, then each function runs in a different process (or set of processes).</p>
                        <div class="infoboxnotealso" id="GUID-F99730AD-EBF2-4BD6-B63D-BFEFBF569A1E__GUID-FB6C185F-0FEB-41AC-9956-839D8AE69926">
                           <p class="notep1">See Also:</p>
                           <p><span class="q">"<a href="plsql-optimization-and-tuning.html#GUID-BC13A2D1-A182-46C7-A3DC-959724DD5BD6">Passing CURSOR Expressions to Pipelined Table Functions</a>"</span></p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPLS823"></a><a id="LNPLS923"></a><div class="props_rev_3"><a id="GUID-66AF0686-5781-4BCB-B067-6F03BA9B23AE" name="GUID-66AF0686-5781-4BCB-B067-6F03BA9B23AE"></a><h4 id="LNPLS-GUID-66AF0686-5781-4BCB-B067-6F03BA9B23AE" class="sect4"><span class="enumeration_section">12.5.5 </span>Fetching from Results of Pipelined Table Functions
                  </h4>
                  <div>
                     <div class="section">
                        <p>You can associate a named cursor with a query that invokes a pipelined table function. Such a cursor has no special fetch semantics, and such a cursor variable has no special assignment semantics.</p>
                        <p>However, the SQL optimizer does not optimize across PL/SQL statements. Therefore, in <a href="plsql-optimization-and-tuning.html#GUID-66AF0686-5781-4BCB-B067-6F03BA9B23AE__BABFHAIG">Example 12-31</a>, the first PL/SQL statement is slower than the second—despite the overhead of running two SQL statements in the second PL/SQL statement, and even if function results are piped between the two SQL statements in the first PL/SQL statement.
                        </p>
                        <p>In <a href="plsql-optimization-and-tuning.html#GUID-66AF0686-5781-4BCB-B067-6F03BA9B23AE__BABFHAIG">Example 12-31</a>, assume that <code class="codeph">f</code> and <code class="codeph">g</code> are pipelined table functions, and that each function accepts a cursor variable parameter. The first PL/SQL statement associates cursor variable <code class="codeph">r</code> with a query that invokes <code class="codeph">f</code>, and then passes <code class="codeph">r</code> to <code class="codeph">g</code>. The second PL/SQL statement passes <code class="codeph">CURSOR</code> expressions to both <code class="codeph">f</code> and <code class="codeph">g</code>.
                        </p>
                        <div class="infoboxnotealso" id="GUID-66AF0686-5781-4BCB-B067-6F03BA9B23AE__GUID-7C858138-7612-4350-8C16-9DBE92636DD1">
                           <p class="notep1">See Also:</p>
                           <p><span class="q">"<a href="static-sql.html#GUID-9713DFC2-3C2E-49B2-922F-02D43F9D0619" title="You can use a cursor variable as a subprogram parameter, which makes it useful for passing query results between subprograms.">Cursor Variables as Subprogram Parameters</a>"</span></p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-66AF0686-5781-4BCB-B067-6F03BA9B23AE__BABFHAIG">
                        <p class="titleinexample">Example 12-31 Fetching from Results of Pipelined Table Functions</p><pre class="oac_no_warn" dir="ltr">
DECLARE
  r SYS_REFCURSOR;
  ...
  -- First PL/SQL statement (slower):
BEGIN
  OPEN r FOR SELECT * FROM TABLE(f(CURSOR(SELECT * FROM tab)));
  SELECT * BULK COLLECT INTO rec_tab FROM TABLE(g(r));

  -- NOTE: When g completes, it closes r.
END;

-- Second PL/SQL statement (faster):

SELECT * FROM TABLE(g(CURSOR(SELECT * FROM
  TABLE(f(CURSOR(SELECT * FROM tab))))));
/</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="LNPLS925"></a><a id="LNPLS926"></a><a id="LNPLS924"></a><div class="props_rev_3"><a id="GUID-BC13A2D1-A182-46C7-A3DC-959724DD5BD6" name="GUID-BC13A2D1-A182-46C7-A3DC-959724DD5BD6"></a><h4 id="LNPLS-GUID-BC13A2D1-A182-46C7-A3DC-959724DD5BD6" class="sect4"><span class="enumeration_section">12.5.6 </span>Passing CURSOR Expressions to Pipelined Table Functions
                  </h4>
                  <div>
                     <div class="section">
                        <p>As <a href="plsql-optimization-and-tuning.html#GUID-66AF0686-5781-4BCB-B067-6F03BA9B23AE__BABFHAIG">Example 12-31</a> shows, the actual parameter for the cursor variable parameter of a pipelined table function can be either a cursor variable or a <code class="codeph">CURSOR</code> expression, and the latter is more efficient.
                        </p>
                        <div class="infoboxnote" id="GUID-BC13A2D1-A182-46C7-A3DC-959724DD5BD6__GUID-9BA2A27B-49BF-49D7-82FC-ED63B7ED46B5">
                           <p class="notep1">Note:</p>
                           <p>When a SQL <code class="codeph">SELECT</code> statement passes a <code class="codeph">CURSOR</code> expression to a function, the referenced cursor opens when the function begins to run and closes when the function completes.
                           </p>
                        </div>
                        <div class="infoboxnotealso" id="GUID-BC13A2D1-A182-46C7-A3DC-959724DD5BD6__GUID-D8856691-7B0F-4AAE-8CA6-D3367D9BADB4">
                           <p class="notep1">See Also:</p>
                           <p><span class="q">"<a href="static-sql.html#GUID-77FF2850-F338-4C77-9577-0FE3399D39BA" title="A CURSOR expression returns a nested cursor.">CURSOR Expressions</a>"</span> for general information about <code class="codeph">CURSOR</code> expressions
                           </p>
                        </div>
                        <p><a href="plsql-optimization-and-tuning.html#GUID-BC13A2D1-A182-46C7-A3DC-959724DD5BD6__BABEIAIG">Example 12-32</a> creates a package that includes a pipelined table function with two cursor variable parameters and then invokes the function in a <code class="codeph">SELECT</code> statement, using <code class="codeph">CURSOR</code> expressions for actual parameters.
                        </p>
                        <p><a href="plsql-optimization-and-tuning.html#GUID-BC13A2D1-A182-46C7-A3DC-959724DD5BD6__BABEEIHA">Example 12-33</a> uses a pipelined table function as an aggregate function, which takes a set of input rows and returns a single result. The <code class="codeph">SELECT</code> statement selects the function result. (For information about the pseudocolumn <code class="codeph">COLUMN_VALUE</code>, see <a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/lnpls&amp;id=SQLRF50950" target="_blank"><span class="italic">Oracle Database SQL Language Reference</span></a>.)
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-BC13A2D1-A182-46C7-A3DC-959724DD5BD6__BABEIAIG">
                        <p class="titleinexample">Example 12-32 Pipelined Table Function with Two Cursor Variable Parameters</p><pre class="oac_no_warn" dir="ltr">CREATE OR REPLACE PACKAGE refcur_pkg AUTHID DEFINER IS
  TYPE refcur_t1 IS REF CURSOR RETURN employees%ROWTYPE;
  TYPE refcur_t2 IS REF CURSOR RETURN departments%ROWTYPE;
  TYPE outrec_typ IS RECORD (
    var_num    NUMBER(6),
    var_char1  VARCHAR2(30),
    var_char2  VARCHAR2(30)
  );
  TYPE outrecset IS TABLE OF outrec_typ;
  <span class="bold">FUNCTION g_trans (p1 refcur_t1, p2 refcur_t2) RETURN outrecset PIPELINED;</span>
END refcur_pkg;
/
</pre><pre class="oac_no_warn" dir="ltr">
CREATE PACKAGE BODY refcur_pkg IS
  FUNCTION g_trans (
    p1 refcur_t1,
    p2 refcur_t2
  ) RETURN outrecset PIPELINED
  IS
    out_rec outrec_typ;
    in_rec1 p1%ROWTYPE;
    in_rec2 p2%ROWTYPE;
  BEGIN
    LOOP
      FETCH p2 INTO in_rec2;
      EXIT WHEN p2%NOTFOUND;
    END LOOP;
    CLOSE p2;
    LOOP
      FETCH p1 INTO in_rec1;
      EXIT WHEN p1%NOTFOUND;
      -- first row
      out_rec.var_num := in_rec1.employee_id;
      out_rec.var_char1 := in_rec1.first_name;
      out_rec.var_char2 := in_rec1.last_name;
      PIPE ROW(out_rec);
      -- second row
      out_rec.var_num := in_rec2.department_id;
      out_rec.var_char1 := in_rec2.department_name;
      out_rec.var_char2 := TO_CHAR(in_rec2.location_id);
      PIPE ROW(out_rec);
    END LOOP;
    CLOSE p1;
    RETURN;
  END g_trans;
END refcur_pkg;
/
</pre><pre class="oac_no_warn" dir="ltr">
SELECT * FROM TABLE (
  refcur_pkg.g_trans (
    <span class="bold">CURSOR (SELECT * FROM employees WHERE department_id = 60)</span>,
    <span class="bold">CURSOR (SELECT * FROM departments WHERE department_id = 60)</span>
  )
);
</pre><p>Result:</p><pre class="oac_no_warn" dir="ltr">   VAR_NUM VAR_CHAR1                      VAR_CHAR2
---------- ------------------------------ ------------------------------
       103 Alexander                      Hunold
        60 IT                             1400
       104 Bruce                          Ernst
        60 IT                             1400
       105 David                          Austin
        60 IT                             1400
       106 Valli                          Pataballa
        60 IT                             1400
       107 Diana                          Lorentz
        60 IT                             1400
 
10 rows selected.
</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-BC13A2D1-A182-46C7-A3DC-959724DD5BD6__BABEEIHA">
                        <p class="titleinexample">Example 12-33 Pipelined Table Function as Aggregate Function</p><pre class="oac_no_warn" dir="ltr">DROP TABLE gradereport;
CREATE TABLE gradereport (
  student VARCHAR2(30),
  subject VARCHAR2(30),
  weight NUMBER,
  grade NUMBER
);

INSERT INTO gradereport (student, subject, weight, grade)
VALUES ('Mark', 'Physics', 4, 4);
 
INSERT INTO gradereport (student, subject, weight, grade) 
VALUES ('Mark','Chemistry', 4, 3);
 
INSERT INTO gradereport (student, subject, weight, grade) 
VALUES ('Mark','Maths', 3, 3);
 
INSERT INTO gradereport (student, subject, weight, grade) 
VALUES ('Mark','Economics', 3, 4);

</pre><pre class="oac_no_warn" dir="ltr">CREATE PACKAGE pkg_gpa AUTHID DEFINER IS
  TYPE gpa IS TABLE OF NUMBER;
  FUNCTION weighted_average(input_values SYS_REFCURSOR)
    RETURN gpa PIPELINED;
END pkg_gpa;

CREATE PACKAGE BODY pkg_gpa IS
  <span class="bold">FUNCTION weighted_average (input_values SYS_REFCURSOR)</span>
    <span class="bold">RETURN gpa PIPELINED</span>
  IS
    grade         NUMBER;
    total         NUMBER := 0;
    total_weight  NUMBER := 0;
    weight        NUMBER := 0;
  BEGIN
    <span class="bold">LOOP</span>
      <span class="bold">FETCH input_values INTO weight, grade;</span>
      <span class="bold">EXIT WHEN input_values%NOTFOUND;</span>
      total_weight := total_weight + weight;  -- Accumulate weighted average
      total := total + grade*weight;
    END LOOP;
    <span class="bold">PIPE ROW (total / total_weight);</span>
    RETURN; -- returns single result
  END weighted_average;
END pkg_gpa;

</pre><p>This query shows how the table function can be invoked without the optional TABLE operator.</p><pre class="oac_no_warn" dir="ltr">SELECT w.<span class="bold">column_value</span> "weighted result" 
FROM pkg_gpa.weighted_average (
    <span class="bold">CURSOR (SELECT weight, grade FROM gradereport)</span>
  ) w;
</pre><p>Result:</p><pre class="oac_no_warn" dir="ltr">weighted result
---------------
            3.5
 
1 row selected.</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="LNPLS928"></a><div class="props_rev_3"><a id="GUID-4903A047-B1E7-4654-A842-630E9EDFDF14" name="GUID-4903A047-B1E7-4654-A842-630E9EDFDF14"></a><h4 id="LNPLS-GUID-4903A047-B1E7-4654-A842-630E9EDFDF14" class="sect4"><span class="enumeration_section">12.5.7 </span>DML Statements on Pipelined Table Function Results
                  </h4>
                  <div>
                     <p>The "table" that a pipelined table function returns cannot be the target table of a <code class="codeph">DELETE</code>, <code class="codeph">INSERT</code>, <code class="codeph">UPDATE</code>, or <code class="codeph">MERGE</code> statement. However, you can create a view of such a table and create <code class="codeph">INSTEAD</code> <code class="codeph">OF</code> triggers on the view. For information about <code class="codeph">INSTEAD</code> <code class="codeph">OF</code> triggers, see <span class="q">"<a href="plsql-triggers.html#GUID-9F06D45C-7C60-434E-A597-114A0C445671" title="An INSTEAD OF DML trigger is a DML trigger created on a noneditioning view, or on a nested table column of a noneditioning view. The database fires the INSTEAD OF trigger instead of running the triggering DML statement.">INSTEAD OF DML Triggers</a>"</span>.
                     </p>
                     <div class="infoboxnotealso" id="GUID-4903A047-B1E7-4654-A842-630E9EDFDF14__GUID-8B394893-91D3-4211-A59B-B0DF29C166DC">
                        <p class="notep1">See Also:</p>
                        <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/lnpls&amp;id=SQLRF01504" target="_blank"><span class="italic">Oracle Database SQL Language Reference</span></a> for information about the <code class="codeph">CREATE</code> <code class="codeph">VIEW</code> statement
                        </p>
                     </div>
                  </div>
               </div><a id="LNPLS824"></a><a id="LNPLS825"></a><a id="LNPLS929"></a><div class="props_rev_3"><a id="GUID-4B0E1C6B-8C73-4905-9E97-37C2667D2184" name="GUID-4B0E1C6B-8C73-4905-9E97-37C2667D2184"></a><h4 id="LNPLS-GUID-4B0E1C6B-8C73-4905-9E97-37C2667D2184" class="sect4"><span class="enumeration_section">12.5.8 </span>NO_DATA_NEEDED Exception
                  </h4>
                  <div>
                     <p>You must understand the predefined exception <code class="codeph">NO_DATA_NEEDED</code> in two cases:
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>You include an <code class="codeph">OTHERS</code> exception handler in a block that includes a <code class="codeph">PIPE</code> <code class="codeph">ROW</code> statement
                           </p>
                        </li>
                        <li>
                           <p>Your code that feeds a <code class="codeph">PIPE</code> <code class="codeph">ROW</code> statement must be followed by a clean-up procedure
                           </p>
                           <p>Typically, the clean-up procedure releases resources that the code no longer needs.</p>
                        </li>
                     </ul>
                     <p>When the invoker of a pipelined table function needs no more rows from the function, the <code class="codeph">PIPE</code> <code class="codeph">ROW</code> statement raises <code class="codeph">NO_DATA_NEEDED</code>. If the pipelined table function does not handle <code class="codeph">NO_DATA_NEEDED</code>, as in <a href="plsql-optimization-and-tuning.html#GUID-4B0E1C6B-8C73-4905-9E97-37C2667D2184__CHDEEGJD">Example 12-34</a>, then the function invocation terminates but the invoking statement does not terminate. If the pipelined table function handles <code class="codeph">NO_DATA_NEEDED</code>, its exception handler can release the resources that it no longer needs, as in <a href="plsql-optimization-and-tuning.html#GUID-4B0E1C6B-8C73-4905-9E97-37C2667D2184__CHDIAFFB">Example 12-35</a>.
                     </p>
                     <p>In <a href="plsql-optimization-and-tuning.html#GUID-4B0E1C6B-8C73-4905-9E97-37C2667D2184__CHDEEGJD">Example 12-34</a>, the pipelined table function <code class="codeph">pipe_rows</code> does not handle the <code class="codeph">NO_DATA_NEEDED</code> exception. The <code class="codeph">SELECT</code> statement that invokes <code class="codeph">pipe_rows</code> needs only four rows. Therefore, during the fifth invocation of <code class="codeph">pipe_rows</code>, the <code class="codeph">PIPE</code> <code class="codeph">ROW</code> statement raises the exception <code class="codeph">NO_DATA_NEEDED</code>. The fifth invocation of <code class="codeph">pipe_rows</code> terminates, but the <code class="codeph">SELECT</code> statement does not terminate.
                     </p>
                     <p>If the exception-handling part of a block that includes a <code class="codeph">PIPE</code> <code class="codeph">ROW</code> statement includes an <code class="codeph">OTHERS</code> exception handler to handle unexpected exceptions, then it must also include an exception handler for the expected <code class="codeph">NO_DATA_NEEDED</code> exception. Otherwise, the <code class="codeph">OTHERS</code> exception handler handles the <code class="codeph">NO_DATA_NEEDED</code> exception, treating it as an unexpected error. The following exception handler reraises the <code class="codeph">NO_DATA_NEEDED</code> exception, instead of treating it as a irrecoverable error:
                     </p><pre class="oac_no_warn" dir="ltr">EXCEPTION
  <span class="bold">WHEN NO_DATA_NEEDED THEN</span>
    <span class="bold">RAISE;</span>
  WHEN OTHERS THEN
    -- (Put error-logging code here)
    RAISE_APPLICATION_ERROR(-20000, 'Fatal error.');
END;
</pre><p>In <a href="plsql-optimization-and-tuning.html#GUID-4B0E1C6B-8C73-4905-9E97-37C2667D2184__CHDIAFFB">Example 12-35</a>, assume that the package <code class="codeph">External_Source</code> contains these public items:
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Procedure <code class="codeph">Init</code>, which allocates and initializes the resources that <code class="codeph">Next_Row</code> needs
                           </p>
                        </li>
                        <li>
                           <p>Function <code class="codeph">Next_Row</code>, which returns some data from a specific external source and raises the user-defined exception <code class="codeph">Done</code> (which is also a public item in the package) when the external source has no more data
                           </p>
                        </li>
                        <li>
                           <p>Procedure <code class="codeph">Clean_Up</code>, which releases the resources that <code class="codeph">Init</code> allocated
                           </p>
                        </li>
                     </ul>
                     <p>The pipelined table function <code class="codeph">get_external_source_data</code> pipes rows from the external source by invoking <code class="codeph">External_Source.Next_Row</code> until either:
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>The external source has no more rows.</p>
                           <p>In this case, the <code class="codeph">External_Source.Next_Row</code> function raises the user-defined exception <code class="codeph">External_Source.Done</code>.
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">get_external_source_data</code> needs no more rows.
                           </p>
                           <p>In this case, the <code class="codeph">PIPE</code> <code class="codeph">ROW</code> statement in <code class="codeph">get_external_source_data</code> raises the <code class="codeph">NO_DATA_NEEDED</code> exception.
                           </p>
                        </li>
                     </ul>
                     <p>In either case, an exception handler in block <code class="codeph">b</code> in <code class="codeph">get_external_source_data</code> invokes <code class="codeph">External_Source.Clean_Up</code>, which releases the resources that <code class="codeph">Next_Row</code> was using.
                     </p>
                     <div class="example" id="GUID-4B0E1C6B-8C73-4905-9E97-37C2667D2184__CHDEEGJD">
                        <p class="titleinexample">Example 12-34 Pipelined Table Function Does Not Handle NO_DATA_NEEDED</p><pre class="oac_no_warn" dir="ltr">CREATE TYPE t IS TABLE OF NUMBER
/
CREATE OR REPLACE FUNCTION pipe_rows RETURN t PIPELINED AUTHID DEFINER IS
  n NUMBER := 0;
BEGIN
  LOOP
    n := n + 1;
    PIPE ROW (n);
  END LOOP;
END pipe_rows;
/
SELECT COLUMN_VALUE
  <span class="bold">FROM TABLE(pipe_rows())</span>
  <span class="bold">WHERE ROWNUM &lt; 5</span>
/
</pre><p>Result:</p><pre class="oac_no_warn" dir="ltr">COLUMN_VALUE
------------
           1
           2
           3
           4

4 rows selected.
</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-4B0E1C6B-8C73-4905-9E97-37C2667D2184__CHDIAFFB">
                        <p class="titleinexample">Example 12-35 Pipelined Table Function Handles NO_DATA_NEEDED</p><pre class="oac_no_warn" dir="ltr">CREATE OR REPLACE FUNCTION get_external_source_data
  RETURN t PIPELINED AUTHID DEFINER IS
BEGIN
  External_Source.Init();           -- Initialize.
  &lt;&lt;b&gt;&gt; BEGIN
    LOOP                            -- Pipe rows from external source.
      PIPE ROW (External_Source.Next_Row());
    END LOOP;
  <span class="bold">EXCEPTION</span>
    WHEN External_Source.Done THEN  -- When no more rows are available,
      External_Source.Clean_Up();   --  clean up.
    WHEN <span class="bold">NO_DATA_NEEDED</span> THEN        -- When no more rows are needed,
      External_Source.Clean_Up();   --  clean up.
      RAISE NO_DATA_NEEDED;           -- Optional, equivalent to RETURN.
  END b;
END get_external_source_data;
/</pre></div>
                     <!-- class="example" -->
                  </div>
               </div>
            </div>
            <div class="sect2"><a id="GUID-981102A8-5204-4931-B10A-93486304B184" name="GUID-981102A8-5204-4931-B10A-93486304B184"></a><h3 id="LNPLS-GUID-981102A8-5204-4931-B10A-93486304B184" class="sect3"><span class="enumeration_section">12.6 </span>Overview of Polymorphic Table Functions
               </h3>
               <div>
                  <p>Polymorphic table functions (PTF) are table functions whose operands can have more than one type. The return type is determined by the PTF invocation arguments list. The actual arguments to the table type usually determines the row output shape, but not always. </p>
                  <div class="section">
                     <p class="subhead2" id="GUID-981102A8-5204-4931-B10A-93486304B184__GUID-2473DA16-33A6-40AD-83E2-3BF06F9A4ADB">Introduction to Polymorphic Table Functions</p>
                     <p>Polymorphic Table Functions (PTF) are user-defined functions that can be invoked in the <code class="codeph">FROM</code> clause of a SQL query block. They are capable of processing tables whose row type is not declared at definition time and producing a result table whose row type may or may not be declared at definition time. Polymorphic table functions leverage dynamic SQL capabilities to create powerful and complex custom functions. This is useful for applications demanding an interface with generic extensions which work for arbitrary input tables or queries. 
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p>A PTF author creates an interface to a procedural mechanism that defines a table. The PTF author defines, documents, and implements the PTF. </p>
                     <p>The query author can only describe the published interface and invoke the PTF function in queries. </p>
                     <p>The database is the PTF conductor. It manages the compilation and execution states of the PTF. The database and the PTF author can see a family of related SQL invoked procedures, called the PTF component procedures, and possibly additional private data (such as variables and cursors).</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-981102A8-5204-4931-B10A-93486304B184__GUID-3BCEAF5A-BE45-4307-9E07-A5F9B3C424D7">Types of Polymorphic Table Functions</p>
                     <div class="p">The polymorphic table function type is specified based on their formal arguments list semantics:
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>If an input <code class="codeph">TABLE</code> argument has <code class="codeph">Row Semantics</code>, the input is a single row.
                              </p>
                           </li>
                           <li>
                              <p>If an input <code class="codeph">TABLE</code> argument has <code class="codeph">Table Semantics</code>, the input is a set of rows. When a <code class="codeph">Table Semantics</code> PTF is called from a query, the table argument can optionally be extended with either a <code class="codeph">PARTITION BY</code> clause or an <code class="codeph">ORDER BY</code> clause or both.
                              </p>
                           </li>
                        </ul>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div>
               <div class="sect3"><a id="GUID-A496E727-7A54-4F6E-9E8E-82DF7558063E" name="GUID-A496E727-7A54-4F6E-9E8E-82DF7558063E"></a><h4 id="LNPLS-GUID-A496E727-7A54-4F6E-9E8E-82DF7558063E" class="sect4"><span class="enumeration_section">12.6.1 </span>Polymorphic Table Function Definition
                  </h4>
                  <div>
                     <p>The PTF author defines, documents, and implements the Polymorphic Table Function (PTF).</p>
                     <div class="section">
                        <p>A PTF has two parts: </p>
                        <p>1. The PL/SQL package which contains the client interface for the PTF implementation.</p>
                        <p>2. The standalone or package function naming the PTF and its associated implementation package. </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-C18593DB-7A73-441D-A17D-30F54E25937A" name="GUID-C18593DB-7A73-441D-A17D-30F54E25937A"></a><h4 id="LNPLS-GUID-C18593DB-7A73-441D-A17D-30F54E25937A" class="sect4"><span class="enumeration_section">12.6.2 </span>Polymorphic Table Function Implementation
                  </h4>
                  <div>
                     <p>The Polymorphic Table Function (PTF) implementation client interface is a set of subprograms with fixed names that every PTF must provide. </p>
                     <div class="section">
                        <p class="subhead3" id="GUID-C18593DB-7A73-441D-A17D-30F54E25937A__GUID-C066864D-CF61-4C74-9B4F-EBD7DD831421">Steps to Implement a Polymorphic Table Function</p>
                        <ol>
                           <li>
                              <p>Create the implementation package containing the <code class="codeph">DESCRIBE</code>  function (required) and the <code class="codeph">OPEN</code>, <code class="codeph">FETCH_ROWS</code> , and <code class="codeph">CLOSE</code>  procedures (optional).
                              </p>
                           </li>
                           <li>
                              <p>Create the function specification naming the PTF. The function can be created at the top-level after the package has been created, or as a package function in the implementation package (the package created in the first step). Polymorphic table functions do not have a function definition (a <code class="codeph">FUNCTION</code> <code class="codeph">BODY</code>), the definition is encapsulated in the associated implementation package.
                              </p>
                              <p>The function definition specifies :</p>
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p>The Polymorphic Table Function (PTF) name</p>
                                 </li>
                                 <li>
                                    <p>Exactly one formal argument of type <code class="codeph">TABLE</code> and any number of non <code class="codeph">TABLE</code> arguments
                                    </p>
                                 </li>
                                 <li>
                                    <p>The return type of the PTF as <code class="codeph">TABLE</code></p>
                                 </li>
                                 <li>
                                    <p>The type of PTF function (<code class="codeph">row</code> or <code class="codeph">table semantics</code> )
                                    </p>
                                 </li>
                                 <li>
                                    <p>The PTF implementation package name</p>
                                 </li>
                              </ul>
                           </li>
                        </ol>
                        <div class="infoboxnotealso" id="GUID-C18593DB-7A73-441D-A17D-30F54E25937A__GUID-3BEB5575-EAAA-436F-9AA3-054F3AD140C7">
                           <p class="notep1">See Also:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/lnpls&amp;id=ARPLS-GUID-6E589F68-6693-42A1-8766-61AF1476DE1C" target="_blank"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for information about a <code class="codeph">DESCRIBE</code> Only polymorphic table function
                                 </p>
                              </li>
                              <li>
                                 <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/lnpls&amp;id=ARPLS-GUID-47E8026F-B66B-4F8D-A2E2-D4324AAB2CED" target="_blank"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for more information about how to specify the PTF implementation package and use the <code class="codeph">DBMS_TF</code> utilities
                                 </p>
                              </li>
                              <li>
                                 <p><a href="PIPELINED-clause.html#GUID-FA182210-C68D-4E03-85B9-A6C681099705" title="Instructs the database to iteratively return the results of a table function or polymorphic table function .">PIPELINED Clause</a> for the standalone or package polymorphic table function creation syntax and semantic
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-4847CB51-6939-44C4-9913-CC3CE13B6730" name="GUID-4847CB51-6939-44C4-9913-CC3CE13B6730"></a><h4 id="LNPLS-GUID-4847CB51-6939-44C4-9913-CC3CE13B6730" class="sect4"><span class="enumeration_section">12.6.3 </span>Polymorphic Table Function Invocation
                  </h4>
                  <div>
                     <p>A polymorphic table function is invoked by specifying its name followed by the argument list in the <code class="codeph">FROM</code> clause of a SQL query block.
                     </p>
                     <div class="section">
                        <p>The PTF arguments can be the standard scalar arguments that can be passed to a regular table function, but PTF's can additionally take a table argument. A table argument is either a <code class="codeph">WITH</code> clause query or a schema-level object that is allowed in a <code class="codeph">FROM</code> clause (such as tables, views, or table functions).
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-4847CB51-6939-44C4-9913-CC3CE13B6730__GUID-F683BFDF-FF62-42EC-B913-0B86C8346E45">Syntax</p>
                        <p><span class="italic">table_argument</span> ::= <span class="italic">table</span> [ PARTITION BY <span class="italic">column_list</span> ] [ORDER BY <span class="italic">order_column_list</span>]
                        </p>
                        <p><span class="italic">column_list</span> ::=<span class="italic"> identifier</span> | (<span class="italic"> identifier</span>[, <span class="italic">identifier</span>…])
                        </p>
                        <p><span class="italic">order_column_list</span> ::= <span class="italic">order_column_name</span> | (<span class="italic">order_column_name</span> [, <span class="italic">order_column_name</span>…])
                        </p>
                        <p><span class="italic">order_column_name</span> ::= <span class="italic">identifier</span> [ ASC | DESC ][ NULLS FIRST | NULLS LAST ]
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-4847CB51-6939-44C4-9913-CC3CE13B6730__GUID-7FD97D62-A820-4435-A826-5EBF40D8AD2F">Semantics</p>
                        <p>Each identifier is a column in the corresponding table.</p>
                        <p>The PTF has <code class="codeph">Table Semantics</code>.
                        </p>
                        <p>Query can optionally partition and order <code class="codeph">Table Semantics</code> PTF input. This is disallowed for <code class="codeph">Row Semantics</code> PTF input.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p> A polymorphic table function (PTF) cannot be the target of a DML statement. Any table argument of a PTF is passed in by name.</p>
                        <p>For example, the noop PTF can be used in a query such as :</p><pre class="oac_no_warn" dir="ltr">SELECT * 
FROM noop(emp);</pre><p>or </p><pre class="oac_no_warn" dir="ltr">WITH e AS 
 (SELECT * FROM emp NATURAL JOIN dept)
SELECT t.* FROM noop(e) t;</pre><p>The input table argument must be a basic table name. </p>
                        <div class="p">The name resolution rules of the table identifier are (in priority order) as follows :
                           <ol>
                              <li>
                                 <p>Identifier is resolved as a column name (such as a correlated column from an outer query block).</p>
                              </li>
                              <li>
                                 <p>Identifier is resolved as a Common Table Expression (CTE) name in the current or some outer query-block. CTE is commonly known as the <code class="codeph">WITH</code> clause.
                                 </p>
                              </li>
                              <li>
                                 <p>Identifier is resolved as a schema-level table, view, or table-function (regular or polymorphic, and defined either at the schema-level or inside a package).</p>
                              </li>
                           </ol>
                        </div>
                        <p>Many types of table expressions otherwise allowed in the <code class="codeph">FROM</code> clause cannot be directly used as a table argument for a PTF (such as ANSI Joins, bind-variables, in-line views, <code class="codeph">CURSOR</code> operators, <code class="codeph">TABLE</code> operators). To use such table expressions as a PTF argument, these table expressions must be passed indirectly into a PTF by wrapping them in a CTE and then passing the CTE name into the PTF.
                        </p>
                        <p>A PTF can be used as a table reference in the <code class="codeph">FROM</code> clause and thus can be part of the ANSI Join and LATERAL syntax. Additionally, a PTF can be the source table for PIVOT/UNPIVOT and MATCH_RECOGNIZE. Some table modification clauses that are meant for tables and views (such as SAMPLING, PARTITION, CONTAINERS) are disallowed for PTF.
                        </p>
                        <p>Direct function composition of PTF  is allowed (such as nested PTF cursor expression invocation or PTF(TF()) nesting). However, nested PTF is disallowed (such as PTF(PTF()) nesting).</p>
                        <p>The scalar arguments of a PTF can be any SQL scalar expression. While the constant scalar values are passed as-is to the <code class="codeph">DESCRIBE</code> function, all other values are passed as NULLs. This is usually not a problem for the PTF implementation if these values are not row shape determining, but otherwise the <code class="codeph">DESCRIBE</code> function can raise an error; typically the documentation accompanying the PTF will state which scalar parameters, if any, are shape defining and thus must have constant non-null values. Note, that during query execution (during <code class="codeph">OPEN</code>, <code class="codeph">FETCH_ROWS</code>, <code class="codeph">CLOSE</code>) the expressions are evaluated and their actual values are passed to these PTF execution procedures. The return type is determined by the PTF invocation arguments list.
                        </p>
                        <p>Query arguments are passed to PTF using a <code class="codeph">WITH</code> clause.
                        </p>
                        <p>The <code class="codeph">TABLE</code> operator is optional when the table function arguments list or empty list () appears.
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div class="sect4"><a id="GUID-A3123AB1-E06D-4E00-A856-6052527482CE" name="GUID-A3123AB1-E06D-4E00-A856-6052527482CE"></a><h5 id="LNPLS-GUID-A3123AB1-E06D-4E00-A856-6052527482CE" class="sect5"><span class="enumeration_section">12.6.3.1 </span>Variadic Pseudo-Operators
                     </h5>
                     <div>
                        <p>A variadic pseudo-operator operates with a variable number of operands. </p>
                        <div class="section">
                           <p>Starting with Oracle Database Release 18c, we introduce the concept of variadic pseudo-operator into the SQL expression language to support Polymorphic Table Functions (PTF). A pseudo-operator can be used to pass list of identifiers (such as column name) to a PTF. A pseudo-operator can only appear as arguments to PTFs, and are parsed by the SQL compiler like other SQL operators or PL/SQL function invocation. A pseudo-operator has a variable number of arguments but must have at least one. The pseudo-operator does not have any execution function associated with it, and they are completely removed from the SQL cursor after the PTF compilation is finished. During SQL compilation, the pseudo-operators are converted to corresponding DBMS_TF types and then passed to the <code class="codeph">DESCRIBE</code> method. There is no output type associated with these operators. It is not possible to embed a pseudo-operator inside a general SQL expression.
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-AB520C25-6735-4E5D-AC01-6237CD32BE17" name="GUID-AB520C25-6735-4E5D-AC01-6237CD32BE17"></a><h5 id="LNPLS-GUID-AB520C25-6735-4E5D-AC01-6237CD32BE17" class="sect5"><span class="enumeration_section">12.6.3.2 </span>COLUMNS Pseudo-Operator
                     </h5>
                     <div>
                        <p>You can use the COLUMNS pseudo-operator to specify arguments to a Polymorphic Table Function (PTF) invocation in the FROM clause of a SQL query block.</p>
                        <div class="section">
                           <p>The <code class="codeph">COLUMNS</code> pseudo-operator arguments specify the list of column names, or the list of column names with associated types.
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-AB520C25-6735-4E5D-AC01-6237CD32BE17__GUID-6A5AEDBE-F866-415C-B3AC-1C8E305D03F5">Syntax</p>
                           <p><span class="italic">column_operator </span> ::= COLUMNS ( <span class="italic">column_list</span> )
                           </p>
                           <p><span class="italic">column_list</span> ::= <span class="italic">column_name_list</span> | <span class="italic">column_type_list</span></p>
                           <p><span class="italic">column_name_list</span> ::=<span class="italic"> identifier</span> [, <span class="italic"> identifier</span> ... ]
                           </p>
                           <p><span class="italic">column_type_list</span>::= <span class="italic"> identifier</span> <span class="italic">column_type</span> [, <span class="italic"> identifier</span><span class="italic"> column_type</span>…]
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-AB520C25-6735-4E5D-AC01-6237CD32BE17__GUID-7EF6F5D9-BB87-4215-B766-FBE4CE6F6D8C">Semantics</p>
                           <p>The <code class="codeph">COLUMNS</code> pseudo-operator can only appear as an argument to a PTF. It cannot appear in any other SQL expression than the PTF expression itself. 
                           </p>
                           <p>The <span class="italic">column_type</span> must be a scalar type.
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-C0FBB1E4-2D75-4D52-BA85-BCF910AF0DD0" name="GUID-C0FBB1E4-2D75-4D52-BA85-BCF910AF0DD0"></a><h4 id="LNPLS-GUID-C0FBB1E4-2D75-4D52-BA85-BCF910AF0DD0" class="sect4"><span class="enumeration_section">12.6.4 </span>Polymorphic Table Function Compilation and Execution
                  </h4>
                  <div>
                     <p>The database fulfills the Polymorphic Table Functions (PTF) conductor role. As such, it is responsible for the PTF compilation, execution and its related states.</p>
                     <div class="section">
                        <div class="p">The database manages :
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>The compilation state : This is the immutable state that is generated by <code class="codeph">DESCRIBE</code> which is needed before execution.
                                 </p>
                              </li>
                              <li>
                                 <p>The execution state: This is the state used by the execution procedures of a <code class="codeph">Table semantics</code> PTF.
                                 </p>
                              </li>
                           </ul>.
                        </div>
                        <div class="infoboxnotealso" id="GUID-C0FBB1E4-2D75-4D52-BA85-BCF910AF0DD0__GUID-FCF7112B-4BA8-48B4-8A91-65C3D74F9A54">
                           <p class="notep1">See Also:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/lnpls&amp;id=ARPLS-GUID-EAC49A1C-F4EB-48C8-B726-A143643A479C" target="_blank"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for more information about how the database manages the compilation and execution states of the PTFs
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-0999E5D7-EB9B-4DCD-964C-C5F6B278B5DB" name="GUID-0999E5D7-EB9B-4DCD-964C-C5F6B278B5DB"></a><h4 id="LNPLS-GUID-0999E5D7-EB9B-4DCD-964C-C5F6B278B5DB" class="sect4"><span class="enumeration_section">12.6.5 </span>Polymorphic Table Function Optimization
                  </h4>
                  <div>
                     <p>A polymorphic table function (PTF) provides an efficient and scalable mechanism to extend the analytical capabilities of the database.</p>
                     <div class="section">
                        <p>The key benefits are:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Minimal data-movement: Only columns of interest are passed to PTF</p>
                           </li>
                           <li>
                              <p>Predicates/Projections/Partitioning are/is pushed into underlying table/query (where semantically possible)</p>
                           </li>
                           <li>
                              <p>Bulk data transfer into and out of PTF</p>
                           </li>
                           <li>
                              <p>Parallelism is based on type of PTF and query specified partitioning (if any)</p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-695FBA1A-89EA-45B4-9C81-CA99F6C794A5" name="GUID-695FBA1A-89EA-45B4-9C81-CA99F6C794A5"></a><h4 id="LNPLS-GUID-695FBA1A-89EA-45B4-9C81-CA99F6C794A5" class="sect4"><span class="enumeration_section">12.6.6 </span>Skip_col Polymorphic Table Function Example
                  </h4>
                  <div>
                     <p>This PTF example demonstrates Row Semantics, Describe Only, package table function, and overloading features.</p>
                     <div class="section">
                        <div class="infoboxnotealso" id="GUID-695FBA1A-89EA-45B4-9C81-CA99F6C794A5__GUID-EA9D7C23-D156-415D-BCF2-37D64CD9835F">
                           <p class="notep1">See Also:</p>
                           <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/lnpls&amp;id=ARPLS-GUID-2D97C0CD-6AD9-4F86-86E6-C806D688C57A" target="_blank"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span> </a> for more Polymorphic Table Function (PTF) examples
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-695FBA1A-89EA-45B4-9C81-CA99F6C794A5__GUID-CFF59A63-42BE-4217-A104-42E41EEABC15">
                        <p class="titleinexample">Example 12-36 Skip_col Polymorphic Table Function Example</p>
                        <p>The skip_col Polymorphic Table Function (PTF) returns all the columns in a table except the columns specified in the PTF input argument. The skip_col PTF skips columns based on column names (overload 1) or columns data type (overload 2). </p>
                        <div class="infoboxnote" id="GUID-695FBA1A-89EA-45B4-9C81-CA99F6C794A5__GUID-46DC7C38-8CB1-4EAC-B3FE-261F6C048588">
                           <p class="notep1">Live SQL:</p>
                           <p>You can view and run this example on Oracle Live SQL at <a href="https://livesql.oracle.com/apex/livesql/docs/lnpls/ptf/ptfskpcol.html" target="_blank">18c Skip_col Polymorphic Table Function</a></p>
                        </div>
                        <p>Create the implementation package named skip_col_pkg containing the <code class="codeph">DESCRIBE</code> function for the skip_col polymorphic table function (PTF). The <code class="codeph">DESCRIBE</code> function is invoked to determine the row shape produced by the PTF. It returns a <code class="codeph">DBMS_TF.DESCRIBE_T</code> table. It is overloaded. The <code class="codeph">FETCH_ROWS</code> procedure is not required because it does need to produce&nbsp;associated new column values for a given subset of rows.
                        </p><pre class="pre codeblock"><code>CREATE PACKAGE skip_col_pkg AS

  -- OVERLOAD 1: Skip by name --
  FUNCTION skip_col(tab TABLE, 
                    col COLUMNS)
           RETURN TABLE PIPELINED ROW POLYMORPHIC USING skip_col_pkg;

  FUNCTION describe(tab IN OUT DBMS_TF.TABLE_T, 
                    col        DBMS_TF.COLUMNS_T)
           RETURN DBMS_TF.DESCRIBE_T;

  -- OVERLOAD 2: Skip by type --
  FUNCTION skip_col(tab       TABLE, 
                    type_name VARCHAR2,
                    flip      VARCHAR2 DEFAULT 'False') 
           RETURN TABLE PIPELINED ROW POLYMORPHIC USING skip_col_pkg;

  FUNCTION describe(tab       IN OUT DBMS_TF.TABLE_T, 
                    type_name        VARCHAR2, 
                    flip             VARCHAR2 DEFAULT 'False') 
           RETURN DBMS_TF.DESCRIBE_T;

END skip_col_pkg; 
</code></pre><p>Create the implementation package body which contains the polymorphic table function definition. </p><pre class="pre codeblock"><code>CREATE PACKAGE BODY skip_col_pkg AS

/* OVERLOAD 1: Skip by name 
 * Package PTF name:  skip_col_pkg.skip_col
 * Standalone PTF name: skip_col_by_name
 *
 * PARAMETERS:
 * tab - The input table
 * col - The name of the columns to drop from the output
 *
 * DESCRIPTION:
 *   This PTF removes all the input columns listed in col from the output
 *   of the PTF.
*/  
 FUNCTION  describe(tab IN OUT DBMS_TF.TABLE_T, 
                    col        DBMS_TF.COLUMNS_T)
            RETURN DBMS_TF.DESCRIBE_T
  AS 
    new_cols DBMS_TF.COLUMNS_NEW_T;
    col_id   PLS_INTEGER := 1;
  BEGIN 
    FOR i IN 1 .. tab.column.count() LOOP
      FOR j IN 1 .. col.count() LOOP
        tab.column(i).PASS_THROUGH := tab.column(i).DESCRIPTION.NAME != col(j);
        EXIT WHEN NOT tab.column(i).PASS_THROUGH;
      END LOOP;
    END LOOP;

    RETURN NULL;
  END;  

/* OVERLOAD 2: Skip by type
 * Package PTF name:  skip_col_pkg.skip_col
 * Standalone PTF name: skip_col_by_type
 *
 * PARAMETERS:
 *   tab       - Input table
 *   type_name - A string representing the type of columns to skip
 *   flip      - 'False' [default] =&gt; Match columns with given type_name
 *               otherwise         =&gt; Ignore columns with given type_name
 *
 * DESCRIPTION:
 *   This PTF removes the given type of columns from the given table. 
*/ 
  FUNCTION describe(tab       IN OUT DBMS_TF.TABLE_T, 
                    type_name        VARCHAR2, 
                    flip             VARCHAR2 DEFAULT 'False') 
           RETURN DBMS_TF.DESCRIBE_T 
  AS 
    typ CONSTANT VARCHAR2(1024) := UPPER(TRIM(type_name));
  BEGIN 
    FOR i IN 1 .. tab.column.count() LOOP
       tab.column(i).PASS_THROUGH := 
         CASE UPPER(SUBSTR(flip,1,1))
           WHEN 'F' THEN DBMS_TF.column_type_name(tab.column(i).DESCRIPTION)!=typ
           ELSE          DBMS_TF.column_type_name(tab.column(i).DESCRIPTION) =typ
         END /* case */;
    END LOOP;

    RETURN NULL;
  END;

END skip_col_pkg; 

</code></pre><p>Create a standalone polymorphic table function named skip_col_by_name for overload 1. Specify exactly one formal argument of type <code class="codeph">TABLE</code>, specify the return type of the PTF as <code class="codeph">TABLE</code>, specify a <code class="codeph">Row Semantics</code> PTF type, and indicate the PTF implementation package to use is skip_col_pkg.  
                        </p><pre class="pre codeblock"><code>CREATE FUNCTION skip_col_by_name(tab TABLE, 
                                 col COLUMNS)
                  RETURN TABLE PIPELINED ROW POLYMORPHIC USING skip_col_pkg;
</code></pre><p>Create a standalone polymorphic table function named skip_col_by_type for overload 2. Specify exactly one formal argument of type <code class="codeph">TABLE</code>, specify the return type of the PTF as <code class="codeph">TABLE</code>, specify a <code class="codeph">Row Semantics</code> PTF type, and indicate the PTF implementation package to use is skip_col_pkg. 
                        </p><pre class="pre codeblock"><code>
CREATE FUNCTION skip_col_by_type(tab TABLE, 
                                 type_name VARCHAR2,
                                 flip VARCHAR2 DEFAULT 'False')
                  RETURN TABLE PIPELINED ROW POLYMORPHIC USING skip_col_pkg;
</code></pre><p>Invoke the package skip_col  PTF (overload 1) to report from the <code class="codeph">SCOTT.DEPT</code> table only columns whose type is not <code class="codeph">NUMBER</code>.
                        </p><pre class="pre codeblock"><code>SELECT * FROM skip_col_pkg.skip_col(scott.dept, 'number');</code></pre><pre class="oac_no_warn" dir="ltr">DNAME          LOC
-------------- -------------
ACCOUNTING     NEW YORK
RESEARCH       DALLAS
SALES          CHICAGO
OPERATIONS     BOSTON
</pre><p>The same result can be achieved by invoking the standalone skip_col_by_type PTF to report from the <code class="codeph">SCOTT.DEPT</code> table only columns whose type is not <code class="codeph">NUMBER</code>.
                        </p><pre class="pre codeblock"><code>SELECT * FROM skip_col_by_type(scott.dept, 'number');</code></pre><pre class="oac_no_warn" dir="ltr">DNAME          LOC
-------------- -------------
ACCOUNTING     NEW YORK
RESEARCH       DALLAS
SALES          CHICAGO
OPERATIONS     BOSTON
</pre><p>Invoke the package skip_col PTF (overload 2) to report from the <code class="codeph">SCOTT.DEPT</code> table only columns whose type is <code class="codeph">NUMBER</code>.
                        </p><pre class="pre codeblock"><code>SELECT * FROM skip_col_pkg.skip_col(scott.dept, 'number', flip =&gt; 'True');</code></pre><pre class="oac_no_warn" dir="ltr">   DEPTNO
----------
        10
        20
        30
        40
</pre><p>The same result can be achieved by invoking the standalone skip_col_by_type PTF to report from the <code class="codeph">SCOTT.DEPT</code> table only columns whose type is <code class="codeph">NUMBER</code>.
                        </p><pre class="pre codeblock"><code>SELECT * FROM skip_col_by_type(scott.dept, 'number', flip =&gt; 'True');</code></pre><pre class="oac_no_warn" dir="ltr">   DEPTNO
----------
        10
        20
        30
        40
</pre><p>Invoke the package skip_col PTF to report all employees in department 20 from the <code class="codeph">SCOTT.EMP</code> table all columns except <code class="codeph">COMM</code>, <code class="codeph">HIREDATE</code> and <code class="codeph">MGR</code>. 
                        </p><pre class="pre codeblock"><code>SELECT *
FROM skip_col_pkg.skip_col(scott.emp, COLUMNS(comm, hiredate, mgr))
WHERE deptno = 20;</code></pre><pre class="oac_no_warn" dir="ltr">    EMPNO ENAME      JOB              SAL     DEPTNO
---------- ---------- --------- ---------- ----------
      7369 SMITH      CLERK            800         20
      7566 JONES      MANAGER         2975         20
      7788 SCOTT      ANALYST         3000         20
      7876 ADAMS      CLERK           1100         20
      7902 FORD       ANALYST         3000         20
</pre></div>
                     <!-- class="example" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-F8E13DDD-710D-4626-824E-B344849C5AFE" name="GUID-F8E13DDD-710D-4626-824E-B344849C5AFE"></a><h4 id="LNPLS-GUID-F8E13DDD-710D-4626-824E-B344849C5AFE" class="sect4"><span class="enumeration_section">12.6.7 </span>To_doc Polymorphic Table Function Example
                  </h4>
                  <div>
                     <p>The to_doc PTF example combines a list of specified columns into a single document column.</p>
                     <div class="example" id="GUID-F8E13DDD-710D-4626-824E-B344849C5AFE__GUID-4DC9A4E9-B1C8-4BB6-9EE9-673C385DDFEA">
                        <p class="titleinexample">Example 12-37 To_doc Polymorphic Table Function Example</p>
                        <p>The to_doc PTF combines  a list of columns into a document column constructed like a JSON object.</p>
                        <div class="infoboxnote" id="GUID-F8E13DDD-710D-4626-824E-B344849C5AFE__GUID-ED9A985B-2DAC-4E20-BA49-45DC11ED9242">
                           <p class="notep1">Live SQL:</p>
                           <p>You can view and run this example on Oracle Live SQL at <a href="https://livesql.oracle.com/apex/livesql/docs/lnpls/ptf/ptftodoc.html" target="_blank">18c To_doc Polymorphic Table Function</a></p>
                        </div>
                        <p>Create the implementation package to_doc_p containing the <code class="codeph">DESCRIBE</code> function and <code class="codeph">FETCH_ROWS</code> procedure for the to_doc polymorphic table function (PTF).
                        </p>
                        <div class="p">The PTF parameters are :
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>tab  : The input table (The tab parameter is of type <code class="codeph">DBMS_TF</code>.<code class="codeph">TABLE_T</code>, a table descriptor record type)
                                 </p>
                              </li>
                              <li>
                                 <p>cols (optional) : The list of columns to convert to document. (The cols parameter is type <code class="codeph">DBMS_TF</code>.<code class="codeph">COLUMNS_T</code> , a column descriptor record type)
                                 </p>
                              </li>
                           </ul>
                        </div><pre class="pre codeblock"><code>CREATE PACKAGE to_doc_p AS
   FUNCTION describe(tab      IN OUT DBMS_TF.TABLE_T,
                     cols     IN     DBMS_TF.COLUMNS_T DEFAULT NULL)
		       RETURN DBMS_TF.DESCRIBE_T;
   
   PROCEDURE fetch_rows;
END to_doc_p;
</code></pre><p>Create the package containing the <code class="codeph">DESCRIBE</code> function and <code class="codeph">FETCH_ROWS</code> procedure. The <code class="codeph">FETCH_ROWS</code> procedure is required to produce a new column named DOCUMENT in the output rowset. The <code class="codeph">DESCRIBE</code> function indicates the read columns by annotating them in the input table descriptor, <code class="codeph">TABLE_T</code>. Only the indicated read columns will be fetched and thus available for processing during <code class="codeph">FETCH_ROWS</code>. The PTF invocation in a query can use the COLUMNS pseudo-operator to indicate which columns the query wants the PTF to read, and this information is passed to the <code class="codeph">DESCRIBE</code> function which then in turn sets the <code class="codeph">COLUMN_T</code>.<code class="codeph">FOR_READ</code> boolean flag. Only scalar SQL data types are allowed for the read columns. The <code class="codeph">COLUMN_T</code>.<code class="codeph">PASS_THROUGH</code> boolean flag indicates columns that are passed from the input table of the PTF to the output, without any modifications.
                        </p><pre class="pre codeblock"><code>CREATE PACKAGE BODY to_doc_p AS
   
FUNCTION describe(tab      IN OUT DBMS_TF.TABLE_T,
                  cols     IN     DBMS_TF.COLUMNS_T DEFAULT NULL)
		    RETURN DBMS_TF.DESCRIBE_T AS
BEGIN
  FOR i IN 1 .. tab.column.count LOOP 
	 CONTINUE WHEN NOT DBMS_TF.SUPPORTED_TYPE(tab.column(i).DESCRIPTION.TYPE);
	 
	  IF cols IS NULL THEN
	     tab.column(i).FOR_READ     := TRUE;
	     tab.column(i).PASS_THROUGH := FALSE;
	     CONTINUE;
	   END IF;
	 
	  FOR j IN 1 .. cols.count LOOP
	    IF (tab.column(i).DESCRIPTION.NAME = cols(j)) THEN
	        tab.column(i).FOR_READ     := TRUE;
	        tab.column(i).PASS_THROUGH := FALSE;
	    END IF;
	  END LOOP;
	 
  END LOOP;
      
  RETURN DBMS_TF.describe_t(new_columns =&gt; DBMS_TF.COLUMNS_NEW_T(1 =&gt;
	                          DBMS_TF.COLUMN_METADATA_T(name =&gt;'DOCUMENT')));   
END;
   
 PROCEDURE fetch_rows AS 
      rst DBMS_TF.ROW_SET_T;
      col DBMS_TF.TAB_VARCHAR2_T;
      rct PLS_INTEGER;
 BEGIN
      DBMS_TF.GET_ROW_SET(rst, row_count =&gt; rct);
      FOR rid IN 1 .. rct LOOP 
	       col(rid) := DBMS_TF.ROW_TO_CHAR(rst, rid); 
      END LOOP;
      DBMS_TF.PUT_COL(1, col);
 END; 
   
END to_doc_p;</code></pre><p>Create the standalone to_doc PTF. Specify exactly one formal argument of type <code class="codeph">TABLE</code>, specify the return type of the PTF as <code class="codeph">TABLE</code>, specify a Row Semantics PTF type, and indicate the PTF implementation package to use is to_doc_p.
                        </p><pre class="pre codeblock"><code>CREATE FUNCTION to_doc(
                 tab  TABLE, 
       			    cols  COLUMNS DEFAULT NULL) 
       			    RETURN TABLE
    PIPELINED ROW POLYMORPHIC USING to_doc_p;
 </code></pre><p>Invoke the to_doc PTF to display all columns of table <code class="codeph">SCOTT</code>.<code class="codeph">DEPT</code> as one combined <code class="codeph">DOCUMENT</code> column.
                        </p><pre class="pre codeblock"><code>SELECT * FROM to_doc(scott.dept);</code></pre><pre class="oac_no_warn" dir="ltr">DOCUMENT
--------------------------------------------------
{"DEPTNO":10, "DNAME":"ACCOUNTING", "LOC":"NEW YORK"}
{"DEPTNO":20, "DNAME":"RESEARCH", "LOC":"DALLAS"}
{"DEPTNO":30, "DNAME":"SALES", "LOC":"CHICAGO"}
{"DEPTNO":40, "DNAME":"OPERATIONS", "LOC":"BOSTON"}
</pre><p>For all employees in departments 10 and 30, display the <code class="codeph">DEPTNO</code>, <code class="codeph">ENAME</code> and <code class="codeph">DOCUMENT</code> columns ordered by <code class="codeph">DEPTNO</code> and <code class="codeph">ENAME</code>. Invoke the to_doc PTF with the <code class="codeph">COLUMNS</code> pseudo-operator to select columns <code class="codeph">EMPNO</code>, <code class="codeph">JOB</code>, <code class="codeph">MGR</code>, <code class="codeph">HIREDATE</code>, <code class="codeph">SAL</code> and <code class="codeph">COMM</code> of table <code class="codeph">SCOTT</code>.<code class="codeph">EMP</code> . The PTF combines these columns into the <code class="codeph">DOCUMENT</code> column.
                        </p><pre class="pre codeblock"><code>SELECT deptno, ename, document 
FROM   to_doc(scott.emp, COLUMNS(empno,job,mgr,hiredate,sal,comm))
WHERE  deptno IN (10, 30) 
ORDER BY 1, 2;</code></pre><pre class="oac_no_warn" dir="ltr">DEPTNO ENAME      DOCUMENT
------ ---------- ---------------------------------------------------------------------------------
    10 CLARK      {"EMPNO":7782, "JOB":"MANAGER", "MGR":7839, "HIREDATE":"09-JUN-81", "SAL":2450}
    10 KING       {"EMPNO":7839, "JOB":"PRESIDENT", "HIREDATE":"17-NOV-81", "SAL":5000}
    10 MILLER     {"EMPNO":7934, "JOB":"CLERK", "MGR":7782, "HIREDATE":"23-JAN-82", "SAL":1300}
    30 ALLEN      {"EMPNO":7499, "JOB":"SALESMAN", "MGR":7698, "HIREDATE":"20-FEB-81", "SAL":1600, "COMM":300}
    30 BLAKE      {"EMPNO":7698, "JOB":"MANAGER", "MGR":7839, "HIREDATE":"01-MAY-81", "SAL":2850}
    30 JAMES      {"EMPNO":7900, "JOB":"CLERK", "MGR":7698, "HIREDATE":"03-DEC-81", "SAL":950}
    30 MARTIN     {"EMPNO":7654, "JOB":"SALESMAN", "MGR":7698, "HIREDATE":"28-SEP-81", "SAL":1250, "COMM":1400}
    30 TURNER     {"EMPNO":7844, "JOB":"SALESMAN", "MGR":7698, "HIREDATE":"08-SEP-81", "SAL":1500, "COMM":0}
    30 WARD       {"EMPNO":7521, "JOB":"SALESMAN", "MGR":7698, "HIREDATE":"22-FEB-81", "SAL":1250, "COMM":500}
</pre><p>With the subquery named <code class="codeph">E</code>, display the <code class="codeph">DOC_ID</code> and <code class="codeph">DOCUMENT</code> columns. Report all clerk employees, their salary, department and department location. Use the to_doc PTF to combine the <code class="codeph">NAME</code>, <code class="codeph">SAL</code>, <code class="codeph">DEPTNO</code> and <code class="codeph">LOC</code> columns into the <code class="codeph">DOCUMENT</code> column.
                        </p><pre class="pre codeblock"><code>WITH e AS (
       SELECT ename name, sal, deptno, loc 
	     FROM scott.emp NATURAL JOIN scott.dept 
        WHERE job = 'CLERK')
	  SELECT ROWNUM doc_id, t.*
	    FROM to_doc(e) t;</code></pre><pre class="oac_no_warn" dir="ltr">    DOC_ID DOCUMENT
---------- -------------------------------------------------------
         1 {"NAME":"MILLER", "SAL":1300, "DEPTNO":10, "LOC":"NEW YORK"}
         2 {"NAME":"SMITH", "SAL":800, "DEPTNO":20, "LOC":"DALLAS"}
         3 {"NAME":"ADAMS", "SAL":1100, "DEPTNO":20, "LOC":"DALLAS"}
         4 {"NAME":"JAMES", "SAL":950, "DEPTNO":30, "LOC":"CHICAGO"}
</pre><p>Use a subquery block to display c1, c2, c3 column values converted into the <code class="codeph">DOCUMENT</code> column.
                        </p><pre class="pre codeblock"><code>WITH t(c1,c2,c3)  AS (
    SELECT NULL, NULL, NULL FROM dual 
    UNION ALL
    SELECT    1, NULL, NULL FROM dual 
    UNION ALL
    SELECT NULL,    2, NULL FROM dual 
    UNION ALL
    SELECT    0, NULL,    3 FROM dual)
  SELECT * 
    FROM to_doc(t);</code></pre><pre class="oac_no_warn" dir="ltr">DOCUMENT
---------------
{}
{"C1":1}
{"C2":2}
{"C1":0, "C3":3}
</pre><p>For all employees in department 30, display the values of the member with property names <code class="codeph">ENAME</code> and <code class="codeph">COMM</code>. The PTF invocation reporting from the <code class="codeph">SCOTT</code>.<code class="codeph">EMP</code> table produces the <code class="codeph">DOCUMENT</code> column which can be used as input to the <code class="codeph">JSON_VALUE</code> function. This function selects a scalar value from some JSON data.
                        </p><pre class="pre codeblock"><code>SELECT JSON_VALUE(document, '$.ENAME') ename, 
       JSON_VALUE(document, '$.COMM')  comm 
FROM   to_doc(scott.emp)
WHERE  JSON_VALUE(document, '$.DEPTNO') = 30;</code></pre><pre class="oac_no_warn" dir="ltr">ENAME      COMM
---------- ----
ALLEN      300
WARD       500
MARTIN     1400
BLAKE
TURNER     0
JAMES
</pre></div>
                     <!-- class="example" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-CF5859FE-4938-4EBF-BE5F-A7C857B77B8C" name="GUID-CF5859FE-4938-4EBF-BE5F-A7C857B77B8C"></a><h4 id="LNPLS-GUID-CF5859FE-4938-4EBF-BE5F-A7C857B77B8C" class="sect4"><span class="enumeration_section">12.6.8 </span>Implicit_echo Polymorphic Table Function Example
                  </h4>
                  <div>
                     <p>The implicit_echo PTF example demonstrates that the USING clause is optional when the Polymorphic Table Function and the DESCRIBE function are defined in the same package.</p>
                     <div class="example" id="GUID-CF5859FE-4938-4EBF-BE5F-A7C857B77B8C__IMPLICIT_ECHOPOLYMORPHICTABLE-B0FD91C4">
                        <p class="titleinexample">Example 12-38 Implicit_echo Polymorphic Table Function Example</p>
                        <p>The <code class="codeph">implicit_echo</code> PTF, takes in a table and a column and produces a new column with the same value.
                        </p>
                        <p>This PTF returns the column in the input table tab, and adds to it the column listed in cols but with the column names prefixed with <code class="codeph">"ECHO_"</code>.
                        </p>
                        <p>Create the implementation package <code class="codeph">implicit_echo_package</code> containing the <code class="codeph">DESCRIBE</code> function, <code class="codeph">implicit_echo</code> polymorphic table function (PTF) and <code class="codeph">FETCH_ROWS</code> procedure.
                        </p><pre class="pre codeblock"><code>CREATE PACKAGE implicit_echo_package AS
  prefix   DBMS_ID := '"ECHO_';

  FUNCTION DESCRIBE(tab   IN OUT DBMS_TF.TABLE_T,
                    cols  IN     DBMS_TF.COLUMNS_T)
           RETURN DBMS_TF.DESCRIBE_T;
  
  PROCEDURE FETCH_ROWS;

  -- PTF FUNCTION: WITHOUT USING CLAUSE --
  FUNCTION implicit_echo(tab TABLE, cols COLUMNS)
           RETURN TABLE PIPELINED ROW POLYMORPHIC;

END implicit_echo_package;</code></pre><p>Create the package containing the <code class="codeph">DESCRIBE</code> function containing the input table parameter and the column parameter to be read. This function is invoked to determine the type of rows produced by the Polymorphic Table Function. The function returns a table <code class="codeph">DBMS_TF.DESCRIBE_T</code>. The <code class="codeph">FETCH_ROWS</code> procedure is required to produce the indicated read column along with a new column prefixed with <code class="codeph">"ECHO_"</code> in the output rowset. The <code class="codeph">implicit_echo</code> is the PTF function and contains two arguments, <code class="codeph">tab</code> and <code class="codeph">cols</code>, whose values are obtained from the query and this information is passed to the <code class="codeph">DESCRIBE</code> function. The Row semantics specifies a PTF type but without the <code class="codeph">USING</code> clause. This function is invoked from the SQL query.
                        </p>
                        <p>Create the implementation package body <code class="codeph">implicit_echo_package</code> which contains the PTF definition.
                        </p><pre class="pre codeblock"><code>CREATE PACKAGE BODY implicit_echo_package AS

FUNCTION DESCRIBE(tab  IN  OUT DBMS_TF.TABLE_T,
                  cols IN      DBMS_TF.COLUMNS_T)
          RETURN DBMS_TF.DESCRIBE_T
AS
  new_cols DBMS_TF.COLUMNS_NEW_T;
  col_id   PLS_INTEGER := 1;

BEGIN
 FOR i in 1 .. tab.column.COUNT LOOP
 
   FOR j in 1 .. cols.COUNT LOOP
    
     IF (tab.column(i).description.name = cols(j)) THEN
       
       IF (NOT DBMS_TF.SUPPORTED_TYPE(tab.column(i).description.type)) THEN
            RAISE_APPLICATION_ERROR(-20102, 'Unsupported column type['||
                                    tab.column(i).description.type||']');
       END IF;

       tab.column(i).for_read := TRUE;
       new_cols(col_id)       := tab.column(i).description;
       new_cols(col_id).name  := prefix||
                                 REGEXP_REPLACE(tab.column(i).description.name,
                                                                      '^"|"$');
       col_id                 := col_id + 1;
       EXIT;

     END IF;

    END LOOP;

 END LOOP;

/* VERIFY ALL COLUMNS WERE FOUND */
 IF (col_id - 1 != cols.COUNT) then
    RAISE_APPLICATION_ERROR(-20101,'Column mismatch['||col_id-1||'],
                                                   ['||cols.COUNT||']');
 END IF;

 RETURN DBMS_TF.DESCRIBE_T(new_columns =&gt; new_cols);

END;

 PROCEDURE FETCH_ROWS AS
	 rowset DBMS_TF.ROW_SET_T;
 BEGIN
         DBMS_TF.GET_ROW_SET(rowset);
         DBMS_TF.PUT_ROW_SET(rowset);
 END;

END implicit_echo_package;</code></pre><p>Invoke the PTF to display ENAME column of table <code class="codeph">SCOTT</code>.<code class="codeph">EMP</code> and display it along with another column  <code class="codeph">ECHO_ENAME</code> having the same value.
                        </p><pre class="pre codeblock"><code>SELECT ENAME, ECHO_ENAME
FROM implicit_echo_package.implicit_echo(SCOTT.EMP, COLUMNS(SCOTT.ENAME));</code></pre><pre class="oac_no_warn" dir="ltr">ENAME      ECHO_ENAME
---------- ----------
SMITH      SMITH
ALLEN      ALLEN
WARD       WARD
JONES      JONES
MARTIN     MARTIN
BLAKE      BLAKE
CLARK      CLARK
SCOTT      SCOTT
KING       KING
TURNER     TURNER
ADAMS      ADAMS
JAMES      JAMES
FORD       FORD
MILLER     MILLER
</pre></div>
                     <!-- class="example" -->
                  </div>
               </div>
            </div><a id="LNPLS930"></a><div class="props_rev_3"><a id="GUID-AD1BDE75-DDC1-496E-8964-CA0D41B0C76A" name="GUID-AD1BDE75-DDC1-496E-8964-CA0D41B0C76A"></a><h3 id="LNPLS-GUID-AD1BDE75-DDC1-496E-8964-CA0D41B0C76A" class="sect3"><span class="enumeration_section">12.7 </span>Updating Large Tables in Parallel
               </h3>
               <div>
                  <div class="section">
                     <p>The <code class="codeph">DBMS_PARALLEL_EXECUTE</code> package lets you incrementally update the data in a large table in parallel, in two high-level steps:
                     </p>
                  </div>
                  <!-- class="section" -->
                  <ol>
                     <li><span>Group sets of rows in the table into smaller chunks.</span></li>
                     <li><span>Apply the desired <code class="codeph">UPDATE</code> statement to the chunks in parallel, committing each time you have finished processing a chunk.</span></li>
                  </ol>
                  <div class="section">
                     <p>This technique is recommended whenever you are updating a lot of data. Its advantages are:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>You lock only one set of rows at a time, for a relatively short time, instead of locking the entire table.</p>
                        </li>
                        <li>
                           <p>You do not lose work that has been done if something fails before the entire operation finishes.</p>
                        </li>
                        <li>
                           <p>You reduce rollback space consumption.</p>
                        </li>
                        <li>
                           <p>You improve performance.</p>
                        </li>
                     </ul>
                     <div class="infoboxnotealso" id="GUID-AD1BDE75-DDC1-496E-8964-CA0D41B0C76A__GUID-0CBBE551-B1A5-47DD-A51C-E34290D0E6E9">
                        <p class="notep1">See Also:</p>
                        <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/lnpls&amp;id=ARPLS233" target="_blank"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for more information about the <code class="codeph">DBMS_PARALLEL_EXECUTE</code> package
                        </p>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div>
            </div><a id="LNPLS01213"></a><div class="props_rev_3"><a id="GUID-AD358676-E837-45EB-9301-36A094A3BB22" name="GUID-AD358676-E837-45EB-9301-36A094A3BB22"></a><h3 id="LNPLS-GUID-AD358676-E837-45EB-9301-36A094A3BB22" class="sect3"><span class="enumeration_section">12.8 </span>Collecting Data About User-Defined Identifiers
               </h3>
               <div>
                  <div class="section">
                     <p>PL/Scope extracts, organizes, and stores data about PL/SQL and SQL identifiers and SQL statements from PL/SQL source text. You can retrieve the identifiers and statements data with the static data dictionary views <code class="codeph">*_IDENTIFIERS</code> and *_STATEMENTS.
                     </p>
                     <div class="infoboxnotealso" id="GUID-AD358676-E837-45EB-9301-36A094A3BB22__GUID-1AF0FA52-829B-4A08-A033-06029B8820A4">
                        <p class="notep1">See Also:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><a href="overview.html#GUID-DF63BC59-22C2-4BA8-9240-F74D505D5102" title="PL/SQL units are affected by PL/SQL compilation parameters (a category of database initialization parameters). Different PL/SQL units—for example, a package specification and its body—can have different compilation parameter settings.">PL/SQL Units and Compilation Parameters</a> for more information about PLSQL_SETTINGS parameter
                              </p>
                           </li>
                           <li>
                              <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/lnpls&amp;id=ADFNS022" target="_blank"><span class="italic">Oracle Database Development Guide</span></a> for more information about using PL/Scope
                              </p>
                           </li>
                        </ul>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div>
            </div><a id="LNPLS829"></a><a id="LNPLS01214"></a><div class="props_rev_3"><a id="GUID-D99A60B1-E3ED-4252-A85C-8FA732EE9957" name="GUID-D99A60B1-E3ED-4252-A85C-8FA732EE9957"></a><h3 id="LNPLS-GUID-D99A60B1-E3ED-4252-A85C-8FA732EE9957" class="sect3"><span class="enumeration_section">12.9 </span>Profiling and Tracing PL/SQL Programs
               </h3>
               <div>
                  <p>To help you isolate performance problems in large PL/SQL programs, PL/SQL provides these tools, implemented as PL/SQL packages.</p>
                  <div class="section">
                     <div class="tblformal" id="GUID-D99A60B1-E3ED-4252-A85C-8FA732EE9957__GUID-B01BC7C5-2CB3-4A5D-B52C-23CD21E42A39">
                        <p class="titleintable">Table 12-1 Profiling and Tracing Tools Summary</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="Profiling and Tracing Tools Summary" summary="This table summarizes the profiling and tracing tools." width="100%" frame="hsides" border="1" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="14%" id="d89034e10669">Tool</th>
                                 <th align="left" valign="bottom" width="35%" id="d89034e10672">Package</th>
                                 <th align="left" valign="bottom" width="50%" id="d89034e10675">Description</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="14%" id="d89034e10680" headers="d89034e10669 ">
                                    <p>Profiler interface</p>
                                 </td>
                                 <td align="left" valign="top" width="35%" headers="d89034e10680 d89034e10672 ">
                                    <p><code class="codeph">DBMS_PROFILER</code></p>
                                 </td>
                                 <td align="left" valign="top" width="50%" headers="d89034e10680 d89034e10675 ">
                                    <p>Computes the time that your PL/SQL program spends at each line and in each subprogram.</p>
                                    <p>You must have <code class="codeph">CREATE</code> privileges on the units to be profiled.
                                    </p>
                                    <p>Saves runtime statistics in database tables, which you can query.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="14%" id="d89034e10698" headers="d89034e10669 ">
                                    <p>Trace interface</p>
                                 </td>
                                 <td align="left" valign="top" width="35%" headers="d89034e10698 d89034e10672 ">
                                    <p><code class="codeph">DBMS_TRACE</code></p>
                                 </td>
                                 <td align="left" valign="top" width="50%" headers="d89034e10698 d89034e10675 ">
                                    <p>Traces the order in which subprograms run.</p>
                                    <p>You can specify the subprograms to trace and the tracing level.</p>
                                    <p>Saves runtime statistics in database tables, which you can query.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="14%" id="d89034e10713" headers="d89034e10669 ">
                                    <p>PL/SQL hierarchical profiler</p>
                                 </td>
                                 <td align="left" valign="top" width="35%" headers="d89034e10713 d89034e10672 ">
                                    <p><code class="codeph">DBMS_HPROF</code></p>
                                 </td>
                                 <td align="left" valign="top" width="50%" headers="d89034e10713 d89034e10675 ">
                                    <p>Reports the dynamic execution program profile of your PL/SQL program, organized by subprogram invocations. Accounts for SQL and PL/SQL execution times separately.</p>
                                    <p>Requires no special source or compile-time preparation.</p>
                                    <p>Generates reports in HTML. Provides the option of storing profiler data and results in relational format in database tables for custom report generation (such as third-party tools offer).</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="14%" id="d89034e10728" headers="d89034e10669 ">
                                    <p>SQL trace</p>
                                 </td>
                                 <td align="left" valign="top" width="35%" headers="d89034e10728 d89034e10672 ">
                                    <p><code class="codeph">DBMS_APPLICATION_INFO</code></p>
                                 </td>
                                 <td align="left" valign="top" width="50%" headers="d89034e10728 d89034e10675 ">
                                    <p>Uses the <code class="codeph">DBMS_APPLICATION_INFO</code> package with Oracle Trace and the SQL trace facility to record names of executing modules or transactions in the database for later use when tracking the performance of various modules and debugging.
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="14%" id="d89034e10742" headers="d89034e10669 ">
                                    <p>PL/SQL Basic Block Coverage</p>
                                 </td>
                                 <td align="left" valign="top" width="35%" headers="d89034e10742 d89034e10672 ">
                                    <p><code class="codeph">DBMS_PLSQL_CODE_COVERAGE</code></p>
                                 </td>
                                 <td align="left" valign="top" width="50%" headers="d89034e10742 d89034e10675 ">
                                    <p>Collects and analyzes basic block coverage data.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="14%" id="d89034e10753" headers="d89034e10669 ">
                                    <p>Call Stack Utilities</p>
                                 </td>
                                 <td align="left" valign="top" width="35%" headers="d89034e10753 d89034e10672 ">
                                    <p><code class="codeph">UTL_CALL_STACK</code></p>
                                 </td>
                                 <td align="left" valign="top" width="50%" headers="d89034e10753 d89034e10675 ">
                                    <p>Provides information about currently executing subprograms (such as subprogram names, unit names, owner names, edition names, and error stack information) that you can use to create more revealing error logs and application execution traces.</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-D99A60B1-E3ED-4252-A85C-8FA732EE9957__GUID-7347CFBD-AA2C-431A-897A-566881B1EBD8">Related Topics</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/lnpls&amp;id=ARPLS003" target="_blank"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for more information about the <code class="codeph">DBMS_APPLICATION_INFO</code>  package
                           </p>
                        </li>
                        <li>
                           <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/lnpls&amp;id=ARPLS146" target="_blank"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for more information about the <code class="codeph">DBMS_HPROF</code> package
                           </p>
                        </li>
                        <li>
                           <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/lnpls&amp;id=ARPLS-GUID-55A9E502-9EC2-4118-B292-DC79E6DC465E" target="_blank"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for more information about the <code class="codeph">DBMS_PLSQL_CODE_COVERAGE</code>  package
                           </p>
                        </li>
                        <li>
                           <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/lnpls&amp;id=ARPLS039" target="_blank"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a>  for more information about the <code class="codeph">DBMS_PROFILER</code> package
                           </p>
                        </li>
                        <li>
                           <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/lnpls&amp;id=ARPLS060" target="_blank"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for more information about the <code class="codeph">DBMS_TRACE</code> package
                           </p>
                           <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/lnpls&amp;id=ARPLS-GUID-2BE2AEB4-51DA-48CA-8B55-0AB6827EF612" target="_blank"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for more information about the <code class="codeph">UTL_CALL_STACK</code> package
                           </p>
                        </li>
                        <li>
                           <p><a href="COVERAGE-pragma.html#GUID-38A315DC-020B-41BD-90CD-DBF4D937EE83" title="The COVERAGE pragma marks PL/SQL code which is infeasible to test for coverage. These marks improve coverage metric accuracy.">COVERAGE Pragma</a> for the syntax and semantics of <code class="codeph">COVERAGE PRAGMA</code> 
                           </p>
                        </li>
                        <li>
                           <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/lnpls&amp;id=ADFNS-GUID-35842E6A-630A-418F-8314-6A30F1FBDF83" target="_blank"><span class="italic">Oracle Database Development Guide</span></a> for more information about using PL/SQL basic block coverage
                           </p>
                        </li>
                        <li>
                           <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/lnpls&amp;id=ADFNS023" target="_blank"><span class="italic">Oracle Database Development Guide</span></a> for a detailed description of PL/SQL hierarchical profiler
                           </p>
                        </li>
                        <li>
                           <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/lnpls&amp;id=ADFNS99873" target="_blank"><span class="italic">Oracle Database Development Guide</span></a> for more information about analyzing and debugging stored subprograms
                           </p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
               </div>
            </div><a id="LNPLS830"></a><a id="LNPLS01209"></a><div class="props_rev_3"><a id="GUID-7C4557E7-4C35-4CAB-A95D-CB96BDC6D487" name="GUID-7C4557E7-4C35-4CAB-A95D-CB96BDC6D487"></a><h3 id="LNPLS-GUID-7C4557E7-4C35-4CAB-A95D-CB96BDC6D487" class="sect3"><span class="enumeration_section">12.10 </span>Compiling PL/SQL Units for Native Execution
               </h3>
               <div>
                  <div class="section">
                     <p>You can usually speed up PL/SQL units by compiling them into native code (processor-dependent system code), which is stored in the SYSTEM tablespace.</p>
                     <p>You can natively compile any PL/SQL unit of any type, including those that Oracle Database supplies.</p>
                     <p>Natively compiled program units work in all server environments, including shared server configuration (formerly called "multithreaded server") and Oracle Real Application Clusters (Oracle RAC).</p>
                     <p>On most platforms, PL/SQL native compilation requires no special set-up or maintenance. On some platforms, the DBA might want to do some optional configuration.</p>
                     <div class="infoboxnotealso" id="GUID-7C4557E7-4C35-4CAB-A95D-CB96BDC6D487__GUID-DD757A86-5DC2-4CB2-8B3C-6063ED98A629">
                        <p class="notep1">See Also:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/lnpls&amp;id=ADMIN002" target="_blank"><span class="italic">Oracle Database Administrator's Guide</span></a> for information about configuring a database
                              </p>
                           </li>
                           <li>
                              <p>Platform-specific configuration documentation for your platform</p>
                           </li>
                        </ul>
                     </div>
                     <p>You can test to see how much performance gain you can get by enabling PL/SQL native compilation.</p>
                     <p>If you have determined that PL/SQL native compilation will provide significant performance gains in database operations, Oracle recommends compiling the entire database for native mode, which requires DBA privileges. This speeds up both your own code and calls to the PL/SQL packages that Oracle Database supplies.</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-7C4557E7-4C35-4CAB-A95D-CB96BDC6D487__GUID-B4EE801C-B77C-4465-9F61-2D66549AADF9">Topics</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="plsql-optimization-and-tuning.html#GUID-F87C76F7-5044-4A8F-AD73-2A946EFFB31D">Determining Whether to Use PL/SQL Native Compilation</a></p>
                        </li>
                        <li>
                           <p><a href="plsql-optimization-and-tuning.html#GUID-C01C53DD-0C0C-4D17-B03A-D00CC183A4EF">How PL/SQL Native Compilation Works</a></p>
                        </li>
                        <li>
                           <p><a href="plsql-optimization-and-tuning.html#GUID-0C95D77E-EA4C-4421-BA1B-7C58027E4C5B">Dependencies, Invalidation, and Revalidation</a></p>
                        </li>
                        <li>
                           <p><a href="plsql-optimization-and-tuning.html#GUID-248986EB-62CA-4324-BC51-B20F54392240">Setting Up a New Database for PL/SQL Native Compilation</a>*
                           </p>
                        </li>
                        <li>
                           <p><a href="plsql-optimization-and-tuning.html#GUID-86BD3AC4-AC0A-4CFF-8A69-5297287A8F03">Compiling the Entire Database for PL/SQL Native or Interpreted Compilation</a>*
                           </p>
                        </li>
                     </ul>
                     <p>* Requires DBA privileges.</p>
                  </div>
                  <!-- class="section" -->
               </div><a id="LNPLS910"></a><div class="props_rev_3"><a id="GUID-F87C76F7-5044-4A8F-AD73-2A946EFFB31D" name="GUID-F87C76F7-5044-4A8F-AD73-2A946EFFB31D"></a><h4 id="LNPLS-GUID-F87C76F7-5044-4A8F-AD73-2A946EFFB31D" class="sect4"><span class="enumeration_section">12.10.1 </span>Determining Whether to Use PL/SQL Native Compilation
                  </h4>
                  <div>
                     <div class="section">
                        <p>Whether to compile a PL/SQL unit for native or interpreted mode depends on where you are in the development cycle and on what the program unit does.</p>
                        <p>While you are debugging program units and recompiling them frequently, interpreted mode has these advantages:</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>You can use PL/SQL debugging tools on program units compiled for interpreted mode (but not for those compiled for native mode).</p>
                           </li>
                           <li>
                              <p>Compiling for interpreted mode is faster than compiling for native mode.</p>
                           </li>
                        </ul>
                        <p>After the debugging phase of development, in determining whether to compile a PL/SQL unit for native mode, consider:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>PL/SQL native compilation provides the greatest performance gains for computation-intensive procedural operations. Examples are data warehouse applications and applications with extensive server-side transformations of data for display.</p>
                           </li>
                           <li>
                              <p>PL/SQL native compilation provides the least performance gains for PL/SQL subprograms that spend most of their time running SQL.</p>
                           </li>
                           <li>
                              <p>When many program units (typically over 15,000) are compiled for native execution, and are simultaneously active, the large amount of shared memory required might affect system performance.</p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPLS911"></a><div class="props_rev_3"><a id="GUID-C01C53DD-0C0C-4D17-B03A-D00CC183A4EF" name="GUID-C01C53DD-0C0C-4D17-B03A-D00CC183A4EF"></a><h4 id="LNPLS-GUID-C01C53DD-0C0C-4D17-B03A-D00CC183A4EF" class="sect4"><span class="enumeration_section">12.10.2 </span>How PL/SQL Native Compilation Works
                  </h4>
                  <div>
                     <p>Without native compilation, the PL/SQL statements in a PL/SQL unit are compiled into an intermediate form, system code, which is stored in the catalog and interpreted at run time.</p>
                     <p>With PL/SQL native compilation, the PL/SQL statements in a PL/SQL unit are compiled into native code and stored in the catalog. The native code need not be interpreted at run time, so it runs faster.</p>
                     <p>Because native compilation applies only to PL/SQL statements, a PL/SQL unit that uses only SQL statements might not run faster when natively compiled, but it does run at least as fast as the corresponding interpreted code. The compiled code and the interpreted code make the same library calls, so their action is the same.</p>
                     <p>The first time a natively compiled PL/SQL unit runs, it is fetched from the SYSTEM tablespace into shared memory. Regardless of how many sessions invoke the program unit, shared memory has only one copy it. If a program unit is not being used, the shared memory it is using might be freed, to reduce memory load.</p>
                     <p>Natively compiled subprograms and interpreted subprograms can invoke each other.</p>
                     <p>PL/SQL native compilation works transparently in an Oracle Real Application Clusters (Oracle RAC) environment.</p>
                     <p>The <code class="codeph">PLSQL_CODE_TYPE</code> compilation parameter determines whether PL/SQL code is natively compiled or interpreted. For information about this compilation parameters, see <span class="q">"<a href="overview.html#GUID-DF63BC59-22C2-4BA8-9240-F74D505D5102" title="PL/SQL units are affected by PL/SQL compilation parameters (a category of database initialization parameters). Different PL/SQL units—for example, a package specification and its body—can have different compilation parameter settings.">PL/SQL Units and Compilation Parameters</a>"</span>.
                     </p>
                  </div>
               </div><a id="LNPLS912"></a><div class="props_rev_3"><a id="GUID-0C95D77E-EA4C-4421-BA1B-7C58027E4C5B" name="GUID-0C95D77E-EA4C-4421-BA1B-7C58027E4C5B"></a><h4 id="LNPLS-GUID-0C95D77E-EA4C-4421-BA1B-7C58027E4C5B" class="sect4"><span class="enumeration_section">12.10.3 </span>Dependencies, Invalidation, and Revalidation
                  </h4>
                  <div>
                     <p>Recompilation is automatic with invalidated PL/SQL modules. For example, if an object on which a natively compiled PL/SQL subprogram depends changes, the subprogram is invalidated. The next time the same subprogram is called, the database recompiles the subprogram automatically. Because the <code class="codeph">PLSQL_CODE_TYPE</code> setting is stored inside the library unit for each subprogram, the automatic recompilation uses this stored setting for code type.
                     </p>
                     <p>Explicit recompilation does not necessarily use the stored <code class="codeph">PLSQL_CODE_TYPE</code> setting. For the conditions under which explicit recompilation uses stored settings, see <span class="q">"<a href="overview.html#GUID-DF63BC59-22C2-4BA8-9240-F74D505D5102" title="PL/SQL units are affected by PL/SQL compilation parameters (a category of database initialization parameters). Different PL/SQL units—for example, a package specification and its body—can have different compilation parameter settings.">PL/SQL Units and Compilation Parameters</a>"</span>.
                     </p>
                  </div>
               </div><a id="LNPLS913"></a><div class="props_rev_3"><a id="GUID-248986EB-62CA-4324-BC51-B20F54392240" name="GUID-248986EB-62CA-4324-BC51-B20F54392240"></a><h4 id="LNPLS-GUID-248986EB-62CA-4324-BC51-B20F54392240" class="sect4"><span class="enumeration_section">12.10.4 </span>Setting Up a New Database for PL/SQL Native Compilation
                  </h4>
                  <div>
                     <div class="section">
                        <p>If you have DBA privileges, you can set up a new database for PL/SQL native compilation by setting the compilation parameter <code class="codeph">PLSQL_CODE_TYPE</code> to <code class="codeph">NATIVE</code>. The performance benefits apply to the PL/SQL packages that Oracle Database supplies, which are used for many database operations.
                        </p>
                        <div class="infoboxnote" id="GUID-248986EB-62CA-4324-BC51-B20F54392240__GUID-73A7CDDB-31E8-424B-A04B-CDA0A5668D45">
                           <p class="notep1">Note:</p>
                           <p>If you compile the whole database as <code class="codeph">NATIVE</code>, Oracle recommends that you set <code class="codeph">PLSQL_CODE_TYPE</code> at the system level.
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPLS914"></a><div class="props_rev_3"><a id="GUID-86BD3AC4-AC0A-4CFF-8A69-5297287A8F03" name="GUID-86BD3AC4-AC0A-4CFF-8A69-5297287A8F03"></a><h4 id="LNPLS-GUID-86BD3AC4-AC0A-4CFF-8A69-5297287A8F03" class="sect4"><span class="enumeration_section">12.10.5 </span>Compiling the Entire Database for PL/SQL Native or Interpreted Compilation
                  </h4>
                  <div>
                     <div class="section">
                        <p>If you have DBA privileges, you can recompile all PL/SQL modules in an existing database to <code class="codeph">NATIVE</code> or <code class="codeph">INTERPRETED</code>, using the <code class="codeph">dbmsupgnv</code>.<code class="codeph">sql</code> and <code class="codeph">dbmsupgin</code>.<code class="codeph">sql</code> scripts respectively during the process explained in this section. Before making the conversion, review <span class="q">"<a href="plsql-optimization-and-tuning.html#GUID-F87C76F7-5044-4A8F-AD73-2A946EFFB31D">Determining Whether to Use PL/SQL Native Compilation</a>"</span>.
                        </p>
                        <div class="infoboxnote" id="GUID-86BD3AC4-AC0A-4CFF-8A69-5297287A8F03__GUID-55D22C41-DD3A-4DBF-964B-3B95876DD29D">
                           <p class="notep1">Note:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>If you compile the whole database as <code class="codeph">NATIVE</code>, Oracle recommends that you set <code class="codeph">PLSQL_CODE_TYPE</code> at the system level.
                                 </p>
                              </li>
                              <li>
                                 <p>If Database Vault is enabled, then you can run <code class="codeph">dbmsupgnv</code>.<code class="codeph">sql</code> only if the Database Vault administrator has granted you the <code class="codeph">DV_PATCH_ADMIN</code> role.
                                 </p>
                              </li>
                           </ul>
                        </div>
                        <p>During the conversion to native compilation, <code class="codeph">TYPE</code> specifications are not recompiled by <code class="codeph">dbmsupgnv</code>.<code class="codeph">sql</code> to <code class="codeph">NATIVE</code> because these specifications do not contain executable code.
                        </p>
                        <p>Package specifications seldom contain executable code so the runtime benefits of compiling to <code class="codeph">NATIVE</code> are not measurable. You can use the <code class="codeph">TRUE</code> command-line parameter with the <code class="codeph">dbmsupgnv</code>.<code class="codeph">sql</code> script to exclude package specs from recompilation to <code class="codeph">NATIVE</code>, saving time in the conversion process.
                        </p>
                        <p>When converting to interpreted compilation, the <code class="codeph">dbmsupgin</code>.<code class="codeph">sql</code> script does not accept any parameters and does not exclude any PL/SQL units.
                        </p>
                        <div class="infoboxnote" id="GUID-86BD3AC4-AC0A-4CFF-8A69-5297287A8F03__GUID-42D4A093-84C9-413E-AA7B-B12C3F47A767">
                           <p class="notep1">Note:</p>
                           <p>The following procedure describes the conversion to native compilation. If you must recompile all PL/SQL modules to interpreted compilation, make these changes in the steps.</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>Skip the first step.</p>
                              </li>
                              <li>
                                 <p>Set the <code class="codeph">PLSQL_CODE_TYPE</code> compilation parameter to <code class="codeph">INTERPRETED</code> rather than <code class="codeph">NATIVE</code>.
                                 </p>
                              </li>
                              <li>
                                 <p>Substitute <code class="codeph">dbmsupgin</code>.<code class="codeph">sql</code> for the <code class="codeph">dbmsupgnv</code>.<code class="codeph">sql</code> script. 
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>Ensure that a test PL/SQL unit can be compiled. For example:</span><div><pre class="oac_no_warn" dir="ltr">ALTER PROCEDURE my_proc COMPILE PLSQL_CODE_TYPE=NATIVE REUSE SETTINGS;
</pre></div>
                        </li>
                        <li class="stepexpand"><span>Shut down application services, the listener, and the database.</span><div>
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p>Shut down all of the Application services including the Forms Processes, Web Servers, Reports Servers, and Concurrent Manager Servers. After shutting down all of the Application services, ensure that all of the connections to the database were terminated.</p>
                                 </li>
                                 <li>
                                    <p>Shut down the TNS listener of the database to ensure that no new connections are made.</p>
                                 </li>
                                 <li>
                                    <p>Shut down the database in normal or immediate mode as the user <code class="codeph">SYS</code>. See <a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/lnpls&amp;id=ADMIN004" target="_blank"><span class="italic">Oracle Database Administrator's Guide</span></a>.
                                    </p>
                                 </li>
                              </ul>
                           </div>
                        </li>
                        <li class="stepexpand"><span>Set <code class="codeph">PLSQL_CODE_TYPE</code> to <code class="codeph">NATIVE</code> in the compilation parameter file. If the database is using a server parameter file, then set this after the database has started.</span><div>
                              <p>The value of <code class="codeph">PLSQL_CODE_TYPE</code> does not affect the conversion of the PL/SQL units in these steps. However, it does affect all subsequently compiled units, so explicitly set it to the desired compilation type.
                              </p>
                           </div>
                        </li>
                        <li class="stepexpand"><span>Start up the database in upgrade mode, using the <code class="codeph">UPGRADE</code> option. For information about SQL*Plus <code class="codeph">STARTUP</code>, see <a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/lnpls&amp;id=SQPUG127" target="_blank"><span class="italic">SQL*Plus User's Guide and Reference</span></a>.</span></li>
                        <li class="stepexpand" id="GUID-86BD3AC4-AC0A-4CFF-8A69-5297287A8F03__BCGJBEHE"><span>Run this code to list the invalid PL/SQL units. You can save the output of the query for future reference with the SQL <code class="codeph">SPOOL</code> statement:</span><div><pre class="oac_no_warn" dir="ltr">-- To save the output of the query to a file:
  <span class="bold">SPOOL pre_update_invalid.log</span>
SELECT o.OWNER, o.OBJECT_NAME, o.OBJECT_TYPE 
FROM DBA_OBJECTS o, DBA_PLSQL_OBJECT_SETTINGS s 
WHERE o.OBJECT_NAME = s.NAME AND o.STATUS='INVALID';
-- To stop spooling the output: <span class="bold">SPOOL OFF</span>
</pre><p>If any Oracle supplied units are invalid, try to validate them by recompiling them. For example:</p><pre class="oac_no_warn" dir="ltr">ALTER PACKAGE SYS.DBMS_OUTPUT COMPILE BODY REUSE SETTINGS;
</pre><p>If the units cannot be validated, save the spooled log for future resolution and continue.</p>
                           </div>
                        </li>
                        <li class="stepexpand" id="GUID-86BD3AC4-AC0A-4CFF-8A69-5297287A8F03__BCGBFAEE"><span>Run this query to determine how many objects are compiled <code class="codeph">NATIVE</code> and <code class="codeph">INTERPRETED</code> (to save the output, use the SQL <code class="codeph">SPOOL</code> statement):</span><div><pre class="oac_no_warn" dir="ltr">SELECT TYPE, PLSQL_CODE_TYPE, COUNT(*)
FROM DBA_PLSQL_OBJECT_SETTINGS
WHERE PLSQL_CODE_TYPE IS NOT NULL
GROUP BY TYPE, PLSQL_CODE_TYPE
ORDER BY TYPE, PLSQL_CODE_TYPE;
</pre><p>Any objects with a <code class="codeph">NULL</code> <code class="codeph">plsql_code_type</code> are special internal objects and can be ignored.
                              </p>
                           </div>
                        </li>
                        <li class="stepexpand"><span>Run the <code class="codeph">$ORACLE_HOME/rdbms/admin/dbmsupgnv</code>.<code class="codeph">sql</code> script as the user <code class="codeph">SYS</code> to update the <code class="codeph">plsql_code_type</code> setting to <code class="codeph">NATIVE</code> in the dictionary tables for all PL/SQL units. This process also invalidates the units. Use <code class="codeph">TRUE</code> with the script to exclude package specifications; <code class="codeph">FALSE</code> to include the package specifications.</span><div>
                              <p>This update must be done when the database is in <code class="codeph">UPGRADE</code> mode. The script is guaranteed to complete successfully or rollback all the changes.
                              </p>
                           </div>
                        </li>
                        <li class="stepexpand"><span>Shut down the database and restart in <code class="codeph">NORMAL</code> mode.</span></li>
                        <li class="stepexpand"><span>Before you run the <code class="codeph">utlrp</code>.<code class="codeph">sql</code> script, Oracle recommends that no other sessions are connected to avoid possible problems. You can ensure this with this statement:</span><div><pre class="oac_no_warn" dir="ltr">ALTER SYSTEM ENABLE RESTRICTED SESSION;
</pre></div>
                        </li>
                        <li class="stepexpand"><span>Run the <code class="codeph">$ORACLE_HOME/rdbms/admin/utlrp</code>.<code class="codeph">sql</code> script as the user <code class="codeph">SYS</code>. This script recompiles all the PL/SQL modules using a default degree of parallelism. See the comments in the script for information about setting the degree explicitly. </span><div>
                              <p>If for any reason the script is abnormally terminated, rerun the <code class="codeph">utlrp</code>.<code class="codeph">sql</code> script to recompile any remaining invalid PL/SQL modules.
                              </p>
                           </div>
                        </li>
                        <li class="stepexpand"><span>After the compilation completes successfully, verify that there are no invalid PL/SQL units using the query in step <a href="plsql-optimization-and-tuning.html#GUID-86BD3AC4-AC0A-4CFF-8A69-5297287A8F03__BCGJBEHE">5</a>. You can spool the output of the query to the <code class="codeph">post_upgrade_invalid</code>.<code class="codeph">log</code> file and compare the contents with the <code class="codeph">pre_upgrade_invalid</code>.<code class="codeph">log</code> file, if it was created previously.</span></li>
                        <li class="stepexpand"><span>Re-execute the query in step <a href="plsql-optimization-and-tuning.html#GUID-86BD3AC4-AC0A-4CFF-8A69-5297287A8F03__BCGBFAEE">6</a>. If recompiling with <code class="codeph">dbmsupgnv</code>.<code class="codeph">sql</code>, confirm that all PL/SQL units, except <code class="codeph">TYPE</code> specifications and package specifications if excluded, are <code class="codeph">NATIVE</code>. If recompiling with <code class="codeph">dbmsupgin</code>.<code class="codeph">sql</code>, confirm that all PL/SQL units are <code class="codeph">INTERPRETED</code>.</span></li>
                        <li class="stepexpand"><span>Disable the restricted session mode for the database, then start the services that you previously shut down. To disable restricted session mode, use this statement:</span><div><pre class="oac_no_warn" dir="ltr">ALTER SYSTEM DISABLE RESTRICTED SESSION;</pre></div>
                        </li>
                     </ol>
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>