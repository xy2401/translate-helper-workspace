<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <title>新功能</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Programmer&#39;s Guide to the Oracle Precompilers"></meta>
      <meta property="og:description" content=""></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Programmer&#39;s Guide to the Oracle Precompilers"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="programmers-guide-oracle-precompilers.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-11T01:36:30-08:00"></meta>
      <meta name="dcterms.title" content="Programmer&#39;s Guide to the Oracle Precompilers"></meta>
      <meta name="dcterms.dateCopyrighted" content="2008, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96474-01"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="writing-user-exits.html" title="Previous" type="text/html"></link>
      <link rel="next" href="Oracle-reserved-words-keywords-namespaces.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.isVersionOf" content="ZZPRE"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="writing-user-exits.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="Oracle-reserved-words-keywords-namespaces.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">程序员指南Oracle预编译器</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">新功能</li>
            </ol>
            <a id="GUID-72AD8498-57D9-4D46-833D-49388783C750" name="GUID-72AD8498-57D9-4D46-833D-49388783C750"></a><a id="ZZPRE942"></a>
            
            <h2 id="ZZPRE-GUID-72AD8498-57D9-4D46-833D-49388783C750" class="sect2"><span class="enumeration_chapter">一个</span>新的特点</h2>
         </header>
         <div class="ind">
            <div>
               <p><a id="d75586e19" class="indexterm-anchor"></a>本附录着眼于改进和<a id="d75586e22" class="indexterm-anchor"></a> Oracle预编译器1.8版提供的新功能。旨在满足专业软件开发人员的实际需求，这些功能将帮助您构建有效，可靠的应用程序。
               </p>
            </div><a id="ZZPRE943"></a><div class="props_rev_3"><a id="GUID-A57FCAD2-F60D-4876-BC8F-5DF7D724F96F" name="GUID-A57FCAD2-F60D-4876-BC8F-5DF7D724F96F"></a><h3 id="ZZPRE-GUID-A57FCAD2-F60D-4876-BC8F-5DF7D724F96F" class="sect3"><span class="enumeration_section">A.1</span>关于在不使用指示符变量的情况下获取NULL</h3>
               <div>
                  <p><a id="d75586e48" class="indexterm-anchor"></a>对于Oracle预编译器<code class="codeph">ORA-01405</code>和1.7版本，如果将<code class="codeph">NULL</code>返回到主机变量，则将数据<code class="codeph">FETCH</code>数据导入主变量而没有关联的指示符变量的源文件会在运行时返回<code class="codeph">ORA-01405</code>消息。对于版本1.8，当您指定<code class="codeph">MODE=ORACLE</code>和<code class="codeph">DBMS=V7</code> ，您还可以通过指定<code class="codeph">UNSAFE_NULL=YES</code>来禁用<code class="codeph">ORA-01405</code>消息。</p>
                  <p>在为Oracle数据库开发应用程序时，首选做法是为任何可能返回<code class="codeph">NULL</code>主机变量包含指示符变量。但是，将应用程序从Oracle V6迁移到Oracle数据库版本7时， <code class="codeph">UNSAFE_NULL</code>选项可以显着简化该过程。
                  </p>
                  <p>有关更多信息，请参阅<span class="q">“ <a href="running-Oracle-precompilers.html#GUID-9BD762BA-BFF8-4B91-8188-8D5E64ADF6A7">UNSAFE_NULL</a> ”</span>和<span class="q">“ <a href="using-embedded-SQL.html#GUID-E4FC1AF8-5BCC-49CB-B3A5-83C99CA7A45A">关于使用指示符变量</a> ”</span> 。
                  </p>
               </div><a id="ZZPRE944"></a><div class="props_rev_3"><a id="GUID-9F36F7FF-3D48-4EFA-A929-DE80EEB71FFA" name="GUID-9F36F7FF-3D48-4EFA-A929-DE80EEB71FFA"></a><h4 id="ZZPRE-GUID-9F36F7FF-3D48-4EFA-A929-DE80EEB71FFA" class="sect4"><span class="enumeration_section">A.1.1</span>关于使用DBMS = V7和MODE = ORACLE</h4>
                  <div>
                     <p>使用<code class="codeph">MODE=ORACLE</code>和<code class="codeph">DBMS=V7</code>预编译的应用程序在运行时返回<code class="codeph">ORA-01405</code>错误，如果在没有关联的指示符变量时将<code class="codeph">NULL</code>返回到主机变量。在使用指定的这些选项升级到Oracle数据库版本7时，您需要以两种方式之一迁移应用程序：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>修改源代码以包含必要的指示符变量</p>
                        </li>
                        <li>
                           <p>在命令行上指定<code class="codeph">UNSAFE_NULL=YES</code></p>
                        </li>
                     </ul>
                     <p>如果要升级到Oracle数据库版本7并在预编译时使用<code class="codeph">DBMS=V7</code> ，或者如果您打算使用与Oracle版本6不同的新Oracle数据库版本7功能，则在大多数情况下，更改只需对源文件进行最少的修改。但是，如果您的应用程序可能将无效值<code class="codeph">FETCH</code>值转换为没有关联指示符变量的主变量，请指定<code class="codeph">UNSAFE_NULL</code> <code class="codeph">=YES</code>以禁用<code class="codeph">ORA-01405</code>消息并避免将相关指示符变量添加到源文件中。
                     </p>
                  </div>
               </div><a id="ZZPRE945"></a><div class="props_rev_3"><a id="GUID-E2F1E11F-8114-43FA-AFEE-7034F205BCE9" name="GUID-E2F1E11F-8114-43FA-AFEE-7034F205BCE9"></a><h4 id="ZZPRE-GUID-E2F1E11F-8114-43FA-AFEE-7034F205BCE9" class="sect4"><span class="enumeration_section">A.1.2</span>相关错误消息</h4>
                  <div>
                     <p>有关与<code class="codeph">UNSAFE_NULL</code>选项关联的预编译时间消息的信息，请参阅<a href="../errmg/index.html" target="_blank"><span class="italic">Oracle数据库错误消息</span></a> 。
                     </p>
                  </div>
               </div>
            </div><a id="ZZPRE946"></a><div class="props_rev_3"><a id="GUID-09E603C0-ECED-4C03-BF6C-EDBF56637ECE" name="GUID-09E603C0-ECED-4C03-BF6C-EDBF56637ECE"></a><h3 id="ZZPRE-GUID-09E603C0-ECED-4C03-BF6C-EDBF56637ECE" class="sect3"><span class="enumeration_section">A.2</span>附加阵列插入/选择语法</h3>
               <div>
                  <p>Oracle预编译器现在支持DB2预编译器的数组INSERT和数组SELECT语法。可选的ROWSET和ROWSET STARTING AT子句用于获取方向（FIRST，PRIOR，NEXT，LAST，CURRENT，RELATIVE和ABSOLUTE）。有关新INSERT / SELECT语法的更多信息，请参阅<a href="../lnpcb/introduction-and-concepts.html#LNPCB-GUID-5B383B0F-9628-443B-8CB7-D2C01607EED6" target="_blank"><span class="italic">Pro * COBOL程序员指南</span></a>和<a href="../lnpcc/introduction-and-concepts.html#LNPCC-GUID-F1207879-4ADF-4AD3-BC24-43F3A6211111" target="_blank"><span class="italic">Pro * C / C ++程序员指南</span></a> 。
                  </p>
               </div>
            </div><a id="ZZPRE947"></a><div class="props_rev_3"><a id="GUID-56A6014D-F18C-4D0D-BC68-6ECF320A8F09" name="GUID-56A6014D-F18C-4D0D-BC68-6ECF320A8F09"></a><h3 id="ZZPRE-GUID-56A6014D-F18C-4D0D-BC68-6ECF320A8F09" class="sect3"><span class="enumeration_section">A.3</span> SQL99语法支持</h3>
               <div>
                  <p>SQL标准支持SQL应用程序在所有符合标准的软件产品中的可移植性。Oracle功能符合ANSI / ISO SQL99标准，包括符合ANSI标准的连接。Pro * Cobol支持Oracle数据库支持的所有SQL99功能，这意味着支持SELECT，INSERT，DELETE和UPDATE语句的SQL99语法以及DECLARE CURSOR语句中的游标主体。</p>
               </div>
            </div><a id="ZZPRE948"></a><div class="props_rev_3"><a id="GUID-9AEF8C4E-A5E8-4AB7-870A-9FCCB9372FC9" name="GUID-9AEF8C4E-A5E8-4AB7-870A-9FCCB9372FC9"></a><h3 id="ZZPRE-GUID-9AEF8C4E-A5E8-4AB7-870A-9FCCB9372FC9" class="sect3"><span class="enumeration_section">A.4</span>关于修复执行计划</h3>
               <div>
                  <p>要修复Pro * C / C ++或Pro * Cobol开发环境中使用的SQL的执行计划，您需要在预编译时使用Oracle的大纲功能。大纲实现为一组与SQL语句关联的优化程序提示。如果您为语句启用了大纲，Oracle会自动考虑存储的提示，并尝试根据这些提示生成执行计划。通过这种方式，您可以确保在将模块集成或部署到不同环境时不会影响性能。</p>
                  <p>您可以使用以下SQL语句在Pro * C / C ++和Pro * Cobol中创建轮廓：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><code class="codeph">选择</code></p>
                     </li>
                     <li>
                        <p><code class="codeph">删除</code></p>
                     </li>
                     <li>
                        <p><code class="codeph">UPDATE</code></p>
                     </li>
                     <li>
                        <p><code class="codeph">插入...选择</code></p>
                     </li>
                     <li>
                        <p><code class="codeph">创建表...选择</code></p>
                     </li>
                  </ul>
                  <p>如果设置了outline选项，则预编译器会在成功预编译结束时生成两个文件，一个SQL文件和一个LOG文件。命令行选项<code class="codeph">outline</code>和<code class="codeph">outlnprefix</code>控制<code class="codeph">outline</code>的生成。每个生成的大纲名称都是唯一的由于应用程序中使用的文件名是唯一的，因此此信息用于生成大纲名称。此外，类别名称也是前缀。
                  </p>
                  <div class="infoboxnote" id="GUID-9AEF8C4E-A5E8-4AB7-870A-9FCCB9372FC9__GUID-8A54F838-45D1-4BBB-9A5C-8951818D8B84">
                     <p class="notep1">注意：</p>
                     <p>Oracle只允许30个字节的大纲名称。如果超出限制，预编译器将标记错误。您可以使用<code class="codeph">outlnprefix</code>选项限制大纲名称的长度。
                     </p>
                  </div>
                  <div class="infoboxnotealso" id="GUID-9AEF8C4E-A5E8-4AB7-870A-9FCCB9372FC9__GUID-D0319107-60D0-4D18-9924-44D18FBB7BE8">
                     <p class="notep1">也可以看看：</p>
                     <p></p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="../lnpcb/introduction-and-concepts.html#LNPCB-GUID-5B383B0F-9628-443B-8CB7-D2C01607EED6" target="_blank"><span class="italic">Pro * COBOL程序员指南</span></a></p>
                        </li>
                        <li>
                           <p><a href="../lnpcc/introduction-and-concepts.html#LNPCC-GUID-F1207879-4ADF-4AD3-BC24-43F3A6211111" target="_blank"><span class="italic">Pro * C / C ++程序员指南</span></a></p>
                        </li>
                     </ul>
                  </div>
               </div>
            </div><a id="ZZPRE949"></a><div class="props_rev_3"><a id="GUID-0F8D827C-BE97-4647-B452-B0A586B4D9F1" name="GUID-0F8D827C-BE97-4647-B452-B0A586B4D9F1"></a><h3 id="ZZPRE-GUID-0F8D827C-BE97-4647-B452-B0A586B4D9F1" class="sect3"><span class="enumeration_section">A.5</span>关于使用隐式缓冲插入</h3>
               <div>
                  <p>为了提高性能，应用程序开发人员可以在嵌入式SQL语句中引用主机数组。这提供了一种通过单次往返数据库来执行SQL语句数组的方法。尽管阵列执行提供了显着的性能改进，但一些开发人员选择不使用此功能，因为它不是ANSI标准。例如，使用IBM的预编译器无法预编译在Oracle中利用数组执行编写的应用程序。</p>
                  <p>一种解决方法是使用缓冲的INSERT语句，这使您可以在保留ANSI标准嵌入式SQL语法的同时获得性能优势。</p>
                  <p>命令行选项“max_row_insert”控制在执行INSERT语句之前要缓冲的行数。默认情况下，它为零，并且禁用该功能。要启用此功能，请指定任何大于零的数字。</p>
                  <div class="infoboxnotealso" id="GUID-0F8D827C-BE97-4647-B452-B0A586B4D9F1__GUID-F30EA12A-8B0E-42B5-99B6-194BD7CE2A07">
                     <p class="notep1">也可以看看：</p>
                     <p>有关使用隐式缓冲区插入功能的更多信息，请参阅：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="../lnpcb/introduction-and-concepts.html#LNPCB-GUID-5B383B0F-9628-443B-8CB7-D2C01607EED6" target="_blank"><span class="italic">Pro * COBOL程序员指南</span></a></p>
                        </li>
                        <li>
                           <p><a href="../lnpcc/introduction-and-concepts.html#LNPCC-GUID-F1207879-4ADF-4AD3-BC24-43F3A6211111" target="_blank"><span class="italic">Pro * C / C ++程序员指南</span></a></p>
                        </li>
                     </ul>
                  </div>
               </div>
            </div><a id="ZZPRE951"></a><a id="ZZPRE950"></a><div class="props_rev_3"><a id="GUID-EE8FBADD-EA23-4F1A-AF98-65AB7A7E2A81" name="GUID-EE8FBADD-EA23-4F1A-AF98-65AB7A7E2A81"></a><h3 id="ZZPRE-GUID-EE8FBADD-EA23-4F1A-AF98-65AB7A7E2A81" class="sect3"><span class="enumeration_section">A.6</span>动态SQL语句缓存</h3>
               <div>
                  <p>语句缓存是指为每个会话提供和管理语句缓存的功能。在服务器中，这意味着可以使用游标，而无需再次解析语句。可以在预编译器应用程序中启用语句缓存，这将有助于提高依赖于动态SQL语句的所有应用程序的性能。通过消除在重用时解析动态语句的开销来实现性能改进。</p>
                  <p>您可以使用新的命令行选项<code class="codeph">stmt_cache</code> （对于语句高速缓存大小）来获得此性能改进，该选项将启用动态语句的语句高速缓存。通过启用新选项，将在会话创建时创建语句缓存。缓存仅适用于动态语句，静态语句的游标缓存与此功能共存。
                  </p>
                  <p>命令行选项<code class="codeph">stmt_cache</code>可以给出0到65535范围内的任何值。默认情况下禁用语句缓存（值0）。可以将<code class="codeph">stmt_cache</code>选项设置为保存应用程序中预期的不同动态SQL语句数。
                  </p>
                  <div class="example" id="GUID-EE8FBADD-EA23-4F1A-AF98-65AB7A7E2A81__GUID-86D78131-0D4B-46C6-B8F3-F635A0A05A5F">
                     <p class="titleinexample">示例A-1使用stmt_cache选项</p>
                     <p>此示例演示了<code class="codeph">stmt_cache</code>选项的<code class="codeph">stmt_cache</code> 。在此程序中，您将行插入表中，并使用循环中的光标选择插入的行。使用stmt_cache选项预编译此程序时，与正常的预编译相比，性能会提高。
                     </p><pre class="oac_no_warn" dir="ltr">/ * * stmtcache.pc * *注意：*当使用此程序测量带有和不带* stmt_cache选项的性能时，请在程序中执行以下更改，* 1。将ROWSCNT增加到高值，比如10000。* 2。删除所有打印语句，通常占总程序执行时间的重要*部分。* *提示：在Linux中，gettimeofday（）可用于测量时间。* / #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; #include &lt;sqlca.h&gt; #include &lt;oraca.h&gt; #define ROWSCNT 10 char * username =“aaaaa”; char * password =“bbbbb”; / *函数原型* / void sql_error（char * msg）; void selectdata（）; void insertdata（）; int main（）{EXEC SQL WHENEVER SQLERROR DO sql_error（“Oracle error”）; / *使用默认架构连接aaaaa / bbbbb * / EXEC SQL CONNECT：username IDENTIFIED BY：password; / *核心函数插入和选择数据* / insertdata（）; selectdata（）; / *回滚pll更改并断开与Oracle的连接。* / EXEC SQL ROLLBACK工作版;出口（0）; / / *将ROWSCNT项的数据插入到tpc2sc01 * / void insertdata（）{varchar dynstmt [80]; int i; varchar ename [10];浮动通讯; char * str; / *分配临时缓冲区* / str =（char *）malloc（11 * sizeof（char））; strcpy（（char *）dynstmt.arr，“INSERT INTO bonus（ename，comm）VALUES（：ename，：comm）”）; dynstmt.len = strlen（dynstmt.arr）; EXEC SQL PREPARE S FROM：dynstmt; printf（“使用动态SQL语句将％d行插入奖励表\ n”，ROWSCNT）; for（i = 1; i &lt;= ROWSCNT; i ++）{sprintf（str，“EMP_％05d”，i）; strcpy（ename.arr，str）; comm = i; ename.len = strlen（ename.arr）; EXEC SQL EXECUTE S使用：ename，：comm; } free（str）; / *使用游标选择数据* / void selectdata（）{varchar dynstmt [80]; varchar ename [10];浮动通讯; int i; strcpy（（char *）dynstmt.arr，“SELECT ename，comm FROM bonus WHERE comm =：v1”）; dynstmt.len =（unsigned short）strlen（（char *）dynstmt.arr）; printf（“使用动态SQL语句获取插入的行\ n \ n”）; printf（“ENAME COMMISSION \ n \ n”）; for（i = 1; i &lt;= ROWSCNT; i ++）{/ *在循环中进行准备，以便stmt_caching的优势可见* / EXEC SQL PREPARE S FROM：dynstmt;用于S的EXEC SQL DECLARE C CURSOR; EXEC SQL OPEN C使用：i; EXEC SQL WHENEVER NOT FOUND DO break; / *循环直到检测到NOT FOUND条件。* / for（;;）{EXEC SQL FETCH C INTO：ename，：comm; ename.arr [ename.len] ='\ 0'; printf（“％10s％7.2f \ n”，ename.arr，comm）; } / *关闭游标，以便stmt_cache * / EXEC SQL CLOSE C不需要重新分析; void sql_error（char * msg）{printf（“\ n％s”，msg）; sqlca.sqlerrm.sqlerrmc [sqlca.sqlerrm.sqlerrml] ='\ 0'; oraca.orastxt.orastxtc [oraca.orastxt.orastxtl] ='\ 0'; oraca.orasfnm.orasfnmc [oraca.orasfnm.orasfnml] ='\ 0'; printf（“\ n％s \ n”，sqlca.sqlerrm.sqlerrmc）; printf（“in \”％s ... \“\ n”，oraca.orastxt.orastxtc）; printf（“％s上的％d。\ n \ n”，oraca.oraslnr，oraca.orasfnm.orasfnmc）; / *如果在此例程中发生另一个错误，则禁用ORACLE错误检查以避免无限循环*。* / EXEC SQL WHENEVER SQLERROR CONTINUE; / *释放与游标关联的资源。* / EXEC SQL CLOSE C; / *回滚任何挂起的更改并断开与Oracle的连接。* / EXEC SQL ROLLBACK工作版;出口（1）; }</pre></div>
                  <!-- class="example" -->
               </div>
            </div><a id="ZZPRE952"></a><div class="props_rev_3"><a id="GUID-F19378A8-414F-43CA-868C-52B6B8864D90" name="GUID-F19378A8-414F-43CA-868C-52B6B8864D90"></a><h3 id="ZZPRE-GUID-F19378A8-414F-43CA-868C-52B6B8864D90" class="sect3"><span class="enumeration_section">A.7可</span>滚动游标</h3>
               <div>
                  <p>可滚动游标是Oracle执行SQL语句并存储在执行期间处理的信息的工作区。执行游标时，查询结果将放入一组称为结果集的行中。结果集可以按顺序或非顺序获取。非顺序结果集称为可滚动游标。可滚动游标使用户能够以前向，后向和随机方式访问数据库结果集的行。此可滚动游标使程序可以获取结果集中的任何行。有关可滚动游标的更多信息，请参阅<a href="../lnpcb/embedded-SQL.html#LNPCB-GUID-6FAE64C1-BB1E-46AB-A0CE-64E6F356B611" target="_blank">Scrollable Cursors</a> 。
                  </p>
               </div>
            </div><a id="ZZPRE954"></a><a id="ZZPRE953"></a><div class="props_rev_3"><a id="GUID-96057B71-B6B9-4A6F-86FA-05946649E82D" name="GUID-96057B71-B6B9-4A6F-86FA-05946649E82D"></a><h3 id="ZZPRE-GUID-96057B71-B6B9-4A6F-86FA-05946649E82D" class="sect3"><span class="enumeration_section">A.8</span>平台字节序支持</h3>
               <div>
                  <p>Oracle存储的unicode数据（UTF16）始终采用big-endian形式。目前，客户端应用程序在不同平台上运行Linux和Windows具有little-endian表示，Solaris具有big-endian表示。插入或选择UTF16数据时，Pro * Cobol不会在服务器和客户端之间转换字节序形式。这会导致PIC N变量中的UTF16（UCS2）字符串损坏。</p>
                  <p>可以使用命令行选项<code class="codeph">picn_endian</code>维护PIC N变量中的平台字节序（Linux和Windows的Little-endian形式，Solaris的Big-endian形式）。
                  </p>
                  <div class="section">
                     <p class="subhead2" id="GUID-96057B71-B6B9-4A6F-86FA-05946649E82D__GUID-DAE430A3-7956-4258-A938-EE0E1B369D8B">新命令行选项</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section"><pre class="oac_no_warn" dir="ltr">picn_endian = {BIG | OS}</pre><p>如果picn_endian = big，则PIC N变量与字符集ID AL16UTF16绑定。</p>
                     <p>如果picn_endian = os，则PIC N变量与字符集ID UCS2绑定。</p>
                     <p>此选项的默认值为“big”以保留当前行为。如果NLS_NCHAR不是AL16UTF16，则忽略此选项。</p>
                     <p>可以使用现有的Pro * Cobol命令行选项设置PIC N变量的字符集形式：</p><pre class="oac_no_warn" dir="ltr">charset_picn = {nchar_charset |值为db_charset}</pre></div>
                  <!-- class="section" -->
               </div>
            </div><a id="ZZPRE955"></a><div class="props_rev_3"><a id="GUID-1BA03CD9-A182-44DC-B2F9-582E5B2F3E7C" name="GUID-1BA03CD9-A182-44DC-B2F9-582E5B2F3E7C"></a><h3 id="ZZPRE-GUID-1BA03CD9-A182-44DC-B2F9-582E5B2F3E7C" class="sect3"><span class="enumeration_section">A.9</span>灵活的B区长度</h3>
               <div>
                  <p>当格式设置为ANSI时，Pro * Cobol程序的B区长度限制为72。 Cobol编译器现在可以支持B区长度高达253。这为程序员提供了键入超过72列的行的灵活性。Pro * Cobol现在支持B区域长度高达253，当Pro * Cobol应用程序预编译时</p>
                  <p><code class="codeph">FORMAT =变量</code> 
                  </p>
                  <p>选项。</p>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>