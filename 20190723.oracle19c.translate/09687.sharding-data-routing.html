<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <meta name="abstract" content="Oracle Sharding supports direct, key-based, routing to a shard, routing by proxy, and routing to mid-tiers."></meta>
      <meta name="description" content="Oracle Sharding supports direct, key-based, routing to a shard, routing by proxy, and routing to mid-tiers."></meta>
      <title>在Sharded数据库环境中请求路由</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Using Oracle Sharding"></meta>
      <meta property="og:description" content="Oracle Sharding supports direct, key-based, routing to a shard, routing by proxy, and routing to mid-tiers."></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Using Oracle Sharding"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="using-oracle-sharding.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-02-14T12:19:13-08:00"></meta>
      <meta name="dcterms.title" content="Using Oracle Sharding"></meta>
      <meta name="dcterms.dateCopyrighted" content="2018, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E87088-04"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="sharding-application-development.html" title="Previous" type="text/html"></link>
      <link rel="next" href="sharding-high-availability.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.isVersionOf" content="SHARD"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="sharding-application-development.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="sharding-high-availability.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">使用Oracle Sharding</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">在Sharded数据库环境中请求路由</li>
            </ol>
            <a id="GUID-7001A9CC-B681-4DFA-B461-6FD653D9D62D" name="GUID-7001A9CC-B681-4DFA-B461-6FD653D9D62D"></a>
            
            <h2 id="SHARD-GUID-7001A9CC-B681-4DFA-B461-6FD653D9D62D" class="sect2"><span class="enumeration_chapter">6</span>在Sharded数据库环境中请求路由</h2>
         </header>
         <div class="ind">
            <div>
               <p>Oracle Sharding支持直接，基于密钥，路由到分片，按代理路由和路由到中间层。</p>
               <p>以下主题描述了分片数据库环境中的路由。</p>
            </div>
            <div>
               <ul class="ullinks">
                  <li class="ulchildlink"><a href="sharding-data-routing.html#GUID-64CAD794-FAAA-406B-9E20-0C35E96D3FA8">直接路由到分片</a><br>Oracle客户端和连接池能够识别连接字符串中指定的分片密钥，以实现高性能数据相关路由。连接层中的分片路由缓存用于将数据库请求直接路由到数据所在的分片。
                  </li>
                  <li class="ulchildlink"><a href="sharding-data-routing.html#GUID-EFC30D99-D4A8-40F6-A0DC-D15FE7BDC7F4">Sharded数据库中具有代理路由的查询和DML</a><br>Sharding支持对未指定分片键的查询进行路由。这允许任何数据库应用程序灵活地在表格被分片或复制的系统中执行SQL语句（包括<code>SELECT</code>和<code>DML</code> ），而无需指定应执行查询的分片。
                  </li>
                  <li class="ulchildlink"><a href="sharding-data-routing.html#GUID-F5D3C0B6-83F9-457A-97A9-429AC9EE4550">在中间层连接池和碎片之间创建亲和力</a><br>称为中间层路由的Oracle通用连接池（UCP）功能允许智能路由器（例如，F5 BigIP）路由到与分片密钥关联的中间层。它将分片数据库拓扑发布到路由器层，以便基于特定分片密钥的请求被路由到适当的应用程序中间层，从而在给定的分片子集上建立连接。
                  </li>
               </ul>
            </div>
            
            <div class="sect2"><a id="GUID-64CAD794-FAAA-406B-9E20-0C35E96D3FA8" name="GUID-64CAD794-FAAA-406B-9E20-0C35E96D3FA8"></a><h3 id="SHARD-GUID-64CAD794-FAAA-406B-9E20-0C35E96D3FA8" class="sect3"><span class="enumeration_section">6.1</span>直接路由到分片</h3>
               <div>
                  <p>Oracle客户端和连接池能够识别连接字符串中指定的分片密钥，以实现高性能数据相关路由。连接层中的分片路由缓存用于将数据库请求直接路由到数据所在的分片。</p>
                  <p>以下主题描述了到分片的直接，基于密钥的路由：</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="sharding-data-routing.html#GUID-2C0F1289-4B10-4282-A652-4C661D0A6FB4">关于直接路由到分片</a><br>在直接，基于密钥的路由到路径中，建立与单个相关分片的连接，该分片包含使用分片密钥与所需事务相关的数据。
                     </li>
                     <li class="ulchildlink"><a href="sharding-data-routing.html#GUID-A49CEDDD-49F7-49EF-B83B-74048A63021E">分片API</a><br>Oracle连接池和驱动程序支持Oracle Sharding。
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="sharding-data-routing.html#GUID-7001A9CC-B681-4DFA-B461-6FD653D9D62D" title="Oracle Sharding支持直接，基于密钥，路由到分片，按代理路由和路由到中间层。">在Sharded数据库环境中请求路由</a></p>
                     </div>
                  </div>
               </div>
               
               <div class="sect3"><a id="GUID-2C0F1289-4B10-4282-A652-4C661D0A6FB4" name="GUID-2C0F1289-4B10-4282-A652-4C661D0A6FB4"></a><h4 id="SHARD-GUID-2C0F1289-4B10-4282-A652-4C661D0A6FB4" class="sect4"><span class="enumeration_section">6.1.1</span>关于直接路由到分片</h4>
                  <div>
                     <p>在直接，基于密钥的路由到路径中，建立与单个相关分片的连接，该分片包含使用分片密钥与所需事务相关的数据。</p>
                     <p>在连接检出期间，分片密钥用于在用户会话级别路由数据库连接请求。复合分片方法需要分片键和超分片键。直接的，基于密钥的路由需要将分片密钥（或超级分片密钥）作为连接的一部分传递。基于该信息，建立与相关分片的连接，该分片包含与给定分片密钥或超分片密钥相关的数据。</p>
                     <p>使用分片建立会话后，将在给定分片的范围内支持和执行所有SQL查询和DML。此路由很快，并且用于执行分片内事务的所有OLTP工作负载。建议对需要最高性能和可用性的所有OLTP工作负载采用直接路由。</p>
                     <p>为了支持Oracle Sharding，对Oracle连接池和驱动程序进行了重要增强。JDBC，通用连接池（UCP），OCI会话池（OCI）和Oracle Data Provider for .NET（ODP.NET）提供API以在连接创建期间传递分片键。Apache Tomcat，IBM Websphere，Oracle WebLogic Server和JBOSS可以利用JDBC / UCP支持并使用分片。PHP，Python，Perl和Node.js可以利用OCI支持。</p>
                     <p>分片拓扑缓存是分片键范围到分片的映射。Oracle集成连接池在其内存中维护此分片拓扑缓存。在第一次连接到给定分片时（在池初始化期间或池连接到较新的分片时），从分片中收集分片键范围映射以动态构建分片拓扑缓存。</p>
                     <p>缓存分片拓扑会创建分片的快速路径，并加快创建与分片的连接的过程。当使用分片键建立连接请求时，连接池将查找存在此特定分片键的相应分片（来自其拓扑缓存）。如果池中有匹配的连接，则池通过应用其内部连接选择算法返回与该分片的连接。</p>
                     <p>任何缓存拓扑图中给定分片键的数据库连接请求直接进入分片（即绕过分片导向器）。连接池还订阅来自SDB的RLB通知，并根据运行时负载平衡建议分配最佳连接。建立连接后，客户端直接在分片上执行事务。在执行了给定分片键的所有事务之后，应用程序必须返回到池的连接并获取另一个键的连接。</p>
                     <p>如果池中没有匹配的连接，则通过将带有分片键的连接请求转发给分片导向器来创建新连接。</p>
                     <p>初始化池并基于所有分片构建分片拓扑缓存后，分片导向器中断对直接路由没有影响。</p>
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-2C0F1289-4B10-4282-A652-4C661D0A6FB4__GUID-973B0EBF-CCF4-4352-B8C2-CCC171BCDC36">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="sharding-data-routing.html#GUID-64CAD794-FAAA-406B-9E20-0C35E96D3FA8" title="Oracle客户端和连接池能够识别连接字符串中指定的分片密钥，以实现高性能数据相关路由。连接层中的分片路由缓存用于将数据库请求直接路由到数据所在的分片。">直接路由到分片</a></p>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="sharding-data-routing.html#GUID-64CAD794-FAAA-406B-9E20-0C35E96D3FA8" title="Oracle客户端和连接池能够识别连接字符串中指定的分片密钥，以实现高性能数据相关路由。连接层中的分片路由缓存用于将数据库请求直接路由到数据所在的分片。">直接路由到分片</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="sect3"><a id="GUID-A49CEDDD-49F7-49EF-B83B-74048A63021E" name="GUID-A49CEDDD-49F7-49EF-B83B-74048A63021E"></a><h4 id="SHARD-GUID-A49CEDDD-49F7-49EF-B83B-74048A63021E" class="sect4"><span class="enumeration_section">6.1.2分片</span> API</h4>
                  <div>
                     <p>Oracle连接池和驱动程序支持Oracle Sharding。</p>
                     <p>JDBC，UCP，OCI和Oracle Data Provider for .NET（ODP.NET）将分片密钥识别为连接检查的一部分。Apache Tomcat，Websphere和WebLogic利用UCP支持分片，PHP，Python，Perl和Node.js利用OCI支持。</p>
                     <div class="section">
                        <p class="subhead3" id="GUID-A49CEDDD-49F7-49EF-B83B-74048A63021E__GUID-F897CC91-29E8-4C95-9151-5922E6F4EC6D">为Oracle UCP分片API</p>
                        <p>通过使用增强的分片API调用<code class="codeph">createShardingKeyBuilder</code>和<code class="codeph">createConnectionBuilder</code>指定分片键，分片感知应用程序获得与给定分片的连接。
                        </p>
                        <p>在高级别，在使用Sharded Database进行应用程序时必须遵循以下步骤：</p>
                        <ol>
                           <li>
                              <p>更新URL以反映分片导向器和全局服务。</p>
                           </li>
                           <li>
                              <p>在池级别和分片级别设置池参数：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>使用<code class="codeph">setInitialPoolSize</code>启动UCP时要创建的初始连接数</p>
                                 </li>
                                 <li>
                                    <p>池在运行时使用<code class="codeph">setMinPoolSize</code>维护的最小连接数</p>
                                 </li>
                                 <li>
                                    <p>UCP属性，用于设置使用<code class="codeph">setMaxPoolSize</code>在连接池上允许的最大连接数</p>
                                 </li>
                                 <li>
                                    <p>使用<code class="codeph">setMaxConnectionsPerShard</code>设置每个分片的最大连接数</p>
                                 </li>
                              </ul>
                           </li>
                           <li>
                              <p>使用<code class="codeph">createShardingKeyBuilder</code>构建分片键对象。
                              </p>
                           </li>
                           <li>
                              <p>使用<code class="codeph">createConnectionBuilder</code>建立连接。
                              </p>
                           </li>
                           <li>
                              <p>在给定分片的范围内执行事务。</p>
                           </li>
                        </ol>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-A49CEDDD-49F7-49EF-B83B-74048A63021E__GUID-0C81050C-FC81-4CE1-8EAE-59AC42C587C1">
                        <p class="titleinexample">示例6-1使用UCP Sharding API建立连接</p>
                        <p>以下是一个代码片段，说明了如何构建分片键以及如何使用UCP Sharding API调用建立连接。</p><pre class="pre codeblock"><code>...PoolDataSource pds = PoolDataSourceFactory.getPoolDataSource（）; //设置连接池属性pds.setURL（DB_URL）; pds.setUser（ “HR”）; pds.setPassword（ “****”）; pds.setInitialPoolSize（10）; pds.setMinPoolSize（20）; pds.setMaxPoolSize（30）; //构建分片键对象OracleShardingKey shardingKey = pds.createShardingKeyBuilder（）.subkey（“mary.smith@example.com”，OracleType。VARCHAR2）.build（）; //为分片获取UCP连接连接conn = pds.createConnectionBuilder（）。shardingKey（shardingKey）.build（）; ...</code></pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-A49CEDDD-49F7-49EF-B83B-74048A63021E__GUID-33BFD16B-5472-41D4-A38B-12A7ECEB7E9F">
                        <p class="titleinexample">示例6-2使用UCP连接池的示例分片感知应用程序代码</p>
                        <p>在此示例中，池设置在池级别和分片级别定义。</p><pre class="pre codeblock"><code>import java.sql。连接; import java.sql。ResultSet的; import java.sql。的SQLException; import java.sql。声明; import oracle.jdbc。OracleShardingKey; import oracle.jdbc。OracleType; import oracle.jdbc.pool。OracleDataSource; import oracle.ucp.jdbc。PoolDataSource; import oracle.ucp.jdbc。PoolDataSourceFactory; public class MaxConnPerShard {public static void main（String [] args）抛出SQLException { <span class="bold">String url =“jdbc：oracle：thin：@（DESCRIPTION =（ADDRESS =（HOST = <span class="variable" translate="no">shard-dir1</span> ）（PORT = 3216）（PROTOCOL = tcp） ））（CONNECT_DATA =（SERVICE_NAME = shsvc.shpool.oradbcloud）（REGION =东侧）））“; String user =“testuser1”，pwd =“testuser1”;</span> <span class="bold">int maxPerShard = 100，initPoolSize = 20;</span> PoolDataSource pds = PoolDataSourceFactory.getPoolDataSource（）; pds.setConnectionFactoryClassName（OracleDataSource.class.getName（））; pds.setURL（URL）; pds.setUser（用户）; pds.setPassword（PWD）; pds.setConnectionPoolName（ “测试池中”）; <span class="bold">pds.setInitialPoolSize（initPoolSize）;</span> <span class="bold">//为每个碎片设置最大连接数pds.setMaxConnectionsPerShard（maxPerShard）;</span> System.out.println（“每个分片的最大连接数为：”+ pds.getMaxConnectionsPerShard（））; <span class="bold">//在shardingKeyVal = 123中构建分片关键对象; OracleShardingKey sdkey = pds.createShardingKeyBuilder（）.subkey（shardingKeyVal，OracleType。NUMBER）.build（）;</span> //尝试使用分片键建立maxPerShard连接Connection [] conns = new Connection [maxPerShard]; for（int i = 0; i &lt;maxPerShard; i ++）{ <span class="bold">conns [i] = pds.createConnectionBuilder（）。shardingKey（sdkey）.build（）;</span>语句stmt = conns [i] .createStatement（）; ResultSet rs = stmt.executeQuery（“select sys_context（'userenv'，'instance_name'），sys_context（'userenv'，'chunk_id'）from dual”）; while（rs.next（））{System.out.println（（i + 1）+“ -  inst：”+ rs.getString（1）+“，chunk：”+ rs.getString（2））; } rs.close（）; stmt.close（）; System.out.println（“尝试构建”+（maxPerShard + 1）+“连接......”）;尝试{Connection conn = pds.createConnectionBuilder（）.shardingKey（sdkey）.build（）;语句stmt = conn.createStatement（）; ResultSet rs = stmt.executeQuery（“select sys_context（'userenv'，'instance_name'），sys_context（'userenv'，'chunk_id'）from dual”）; while（rs.next（））{System.out.println（（maxPerShard + 1）+“ -  inst：”+ rs.getString（1）+“，chunk：”+ rs.getString（2））; } rs.close（）; stmt.close（）;的System.out.println（“问题！无法构建连接，因为每个分片的max-connections超出“）; conn.close（）;} catch（SQLException e）{System.out.println（”每个分片遇到的最大连接数，无法再建立连接，预期的异常：“+ e.getMessage（））;} for（int i = 0; i &lt;conns.length; i ++）{conns [i] .close（）;}}}</code></pre></div>
                     <!-- class="example" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-A49CEDDD-49F7-49EF-B83B-74048A63021E__GUID-594E12DA-8248-43D3-877B-FA8F27A99032">ODP.NET Sharding API</p>
                        <p>支持分片的应用程序通过使用ODP.NET API指定分片键和超分片键来获取与给定分片的连接，例如<code class="codeph">OracleConnection</code>类上的<code class="codeph">SetShardingKey(OracleShardingKey shardingKey, OracleShardingKey superShardingKey)</code>实例方法。
                        </p>
                        <p>在较高的层次上，.NET应用程序使用Sharded Database需要执行以下步骤：</p>
                        <ol>
                           <li>
                              <p>使用ODP.NET，非托管驱动程序。</p>
                              <p>无论是否有ODP.NET连接池，都支持分片。每个池都可以保持与分片数据库的不同分片的连接。</p>
                           </li>
                           <li>
                              <p>使用<code class="codeph">OracleShardingKey</code>类设置分片键和超级分片键的另一个实例。
                              </p>
                           </li>
                           <li>
                              <p>调用<code class="codeph">OracleConnection.调用<code class="codeph">OracleConnection.之前的SetShardingKey()</code>方法<code class="codeph">OracleConnection.Open()</code>以便ODP.NET可以使用指定的分片键和超级分片键返回连接。
                              </p>
                              <p>当<code class="codeph">OracleConnection</code>处于Closed状态时，必须设置这些键，否则抛出异常。
                              </p>
                           </li>
                        </ol>
                        <p></p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-A49CEDDD-49F7-49EF-B83B-74048A63021E__GUID-5DD88D24-08B8-4EAC-A094-076301374AE5">
                        <p class="titleinexample">示例6-3使用ODP.NET的示例分片感知应用程序代码</p><pre class="pre codeblock"><code>使用系统;使用Oracle。数据访问。客户; class Sharding {static void Main（）{OracleConnection con = new OracleConnection（“user id = hr; password = hr; Data Source = orcl;”）; //设置分片键OracleShardingKey shardingKey = new OracleShardingKey（OracleDbType。Int32,123）; //为复合键shardingKey设置第二个分片键值。SetShardingKey（OracleDbType。Varchar2，“gold”）; //创建和设置超级分片键OracleShardingKey superShardingKey = new OracleShardingKey（）; superShardingKey。SetShardingKey（OracleDbType。Int32,1000）; //在连接con上设置超级分片键和分片键。SetShardingKey（shardingKey，superShardingKey）; CON。打开（）; //执行SQL查询}}</code></pre></div>
                     <!-- class="example" -->
                     <div class="section"></div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-A49CEDDD-49F7-49EF-B83B-74048A63021E__GUID-57C6BE35-A449-4212-96F9-3333A3B61125">
                        <p class="notep1">也可以看看：</p>
                        <p>有关Oracle Sharding的JDBC支持的信息，请参见<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/shard&amp;id=JJDBC-GUID-1D7795CA-79DC-452B-9FCC-0EF430F87461" target="_blank"><span><cite>“Oracle数据库JDBC开发人员指南”</cite></span></a></p>
                        <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/shard&amp;id=JJUCP-GUID-12685D3A-F083-433A-90DF-C5533009B841" target="_blank"><span><cite>Oracle通用连接池开发人员指南</cite></span></a> ，了解有关Oracle Sharding的UCP支持的信息</p>
                        <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/shard&amp;id=ODPNT8599" target="_blank"><span><cite>适用于.NET的Oracle数据提供程序开发人员指南（适用于Microsoft Windows），</cite></span></a>以获取有关Oracle Sharding的ODP.NET支持的信息</p>
                        <p><a href="../lnoci/oci-interface-for-using-shards.html#LNOCI-GUID-C64136C2-CF65-4507-8811-9A03946CC817" target="_blank"><span><cite>Oracle Call Interface Programmer's Guide</cite></span></a> ，了解有关使用分片的OCI接口的信息</p>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="sharding-data-routing.html#GUID-64CAD794-FAAA-406B-9E20-0C35E96D3FA8" title="Oracle客户端和连接池能够识别连接字符串中指定的分片密钥，以实现高性能数据相关路由。连接层中的分片路由缓存用于将数据库请求直接路由到数据所在的分片。">直接路由到分片</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div>
            <div class="sect2"><a id="GUID-EFC30D99-D4A8-40F6-A0DC-D15FE7BDC7F4" name="GUID-EFC30D99-D4A8-40F6-A0DC-D15FE7BDC7F4"></a><h3 id="SHARD-GUID-EFC30D99-D4A8-40F6-A0DC-D15FE7BDC7F4" class="sect3"><span class="enumeration_section">6.2分</span>片数据库中具有代理路由的查询和DML</h3>
               <div>
                  <p>Sharding支持对未指定分片键的查询进行路由。这允许任何数据库应用程序灵活地在表格被分片或复制的系统中执行SQL语句（包括<code>SELECT</code>和<code>DML</code> ），而无需指定应执行查询的分片。
                  </p>
                  <p>以下主题详细描述了代理路由：</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="sharding-data-routing.html#GUID-7227ADD2-B9B3-4CB4-B0A8-C385415EECF1">关于Sharded数据库中的代理路由</a><br>代理路由是一种辅助使用模式，旨在方便开发人员。它需要与协调器建立连接。
                     </li>
                     <li class="ulchildlink"><a href="sharding-data-routing.html#GUID-9C13DCC4-0018-4049-94D8-70F518008504">Oracle Sharding多分片查询协调器</a><br>多分片查询协调器数据库包含分片拓扑的元数据，并为分片数据库提供查询处理支持。
                     </li>
                     <li class="ulchildlink"><a href="sharding-data-routing.html#GUID-E58EA3C1-8EB6-4F51-88BD-FC887035A624">使用代理路由查询和DML</a><br>代理路由可以跨分片聚合数据和报告。它还允许任何数据库应用程序灵活地在表格被分片或复制的系统中执行SQL语句（包括SELECT和DML），而无需指定语句应执行的分片键（在连接期间）。
                     </li>
                     <li class="ulchildlink"><a href="sharding-data-routing.html#GUID-1BC28361-73D8-460E-A5E4-C11FCD721ECC">单分片查询的代理路由</a><br>单分片查询是一种查询，它只需要扫描来自一个分片的数据，而不需要从任何其他分片中查找数据。
                     </li>
                     <li class="ulchildlink"><a href="sharding-data-routing.html#GUID-E3CF0022-FA38-4DD0-A5D5-7A409EA45F76">多分片查询的代理路由</a><br>多分片查询必须扫描来自多个分片的数据，并且每个分片上的处理独立于任何其他分片。
                     </li>
                     <li class="ulchildlink"><a href="sharding-data-routing.html#GUID-EE5D2C35-6CB2-45CC-B936-CABA2C329E1B">代理路由中支持的查询形状</a><br>Oracle Sharding支持单个和多个分片查询形状，但有一些限制。
                     </li>
                     <li class="ulchildlink"><a href="sharding-data-routing.html#GUID-51377035-217B-4624-88CD-A5D5DE125606">代理路由的执行计划</a><br>在多分片查询中，每个分片都会生成一个独立的执行计划，该计划可能与查询中其他分片上的计划不同。
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="sharding-data-routing.html#GUID-7001A9CC-B681-4DFA-B461-6FD653D9D62D" title="Oracle Sharding支持直接，基于密钥，路由到分片，按代理路由和路由到中间层。">在Sharded数据库环境中请求路由</a></p>
                     </div>
                  </div>
               </div>
               
               <div class="sect3"><a id="GUID-7227ADD2-B9B3-4CB4-B0A8-C385415EECF1" name="GUID-7227ADD2-B9B3-4CB4-B0A8-C385415EECF1"></a><h4 id="SHARD-GUID-7227ADD2-B9B3-4CB4-B0A8-C385415EECF1" class="sect4"><span class="enumeration_section">6.2.1</span>关于Sharded数据库中的代理路由</h4>
                  <div>
                     <p>代理路由是一种辅助使用模式，旨在方便开发人员。它需要与协调器建立连接。</p>
                     <p>分片目录数据库承担协调器数据库的角色。协调器使用分片拓扑的元数据，并为分片数据库提供查询处理支持。SQL编译器自动识别相关分片，并协调所有参与分片的查询执行。与协调器建立会话后，将执行SQL查询和DML，无需修改。</p>
                     <p>代理路由适用于以下场景：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>当应用程序在连接期间无法传递分片键时</p>
                        </li>
                        <li>
                           <p>当应用程序需要从驻留在多个分片上的分片表中访问数据时</p>
                        </li>
                        <li>
                           <p>通常用于报告的SQL查询，例如销售数据的聚合</p>
                        </li>
                     </ul>
                     <p>使用协调器进行路由允许应用程序提交SQL语句，而不会在连接期间传递分片键值。协调器的SQL编译器分析查询并将其重写为由参与的分片发送和执行的查询片段。重写查询，以便大多数查询处理在参与的分片上完成，然后由协调器聚合。本质上，分片充当协调器执行的查询的计算节点。因为计算被推送到数据，所以减少了分片和协调器之间的数据移动。这种安排还能够通过尽可能地将协调器上的处理卸载到分片上来有效地使用资源。</p>
                     <p>建议应用程序将其工作负载分开以进行直接路由和代理路由。必须为这些工作负载创建单独的连接池。</p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="sharding-data-routing.html#GUID-EFC30D99-D4A8-40F6-A0DC-D15FE7BDC7F4" title="Sharding支持对未指定分片键的查询进行路由。这允许任何数据库应用程序灵活地在表格被分片或复制的系统中执行SQL语句（包括SELECT和DML），而无需指定应执行查询的分片。">在分片数据库中具有代理路由的查询和DML</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="sect3"><a id="GUID-9C13DCC4-0018-4049-94D8-70F518008504" name="GUID-9C13DCC4-0018-4049-94D8-70F518008504"></a><h4 id="SHARD-GUID-9C13DCC4-0018-4049-94D8-70F518008504" class="sect4"><span class="enumeration_section">6.2.2</span> Oracle Sharding多分片查询协调器</h4>
                  <div>
                     <p>多分片查询协调器数据库包含分片拓扑的元数据，并为分片数据库提供查询处理支持。</p>
                     <p> </p>
                     <div class="section">
                        <p class="subhead3" id="GUID-9C13DCC4-0018-4049-94D8-70F518008504__GUID-09E91297-065F-45C1-827E-1CC49B0A6660">连接到多分片协调器</p>
                        <p>要执行多分片查询，请使用分片目录数据库上的GDS $ CATALOG服务连接到多分片协调器：</p><pre class="pre codeblock"><code>sqlplus app_schema / app_schema @shardcatvm：1521 / GDS \ $ CATALOG.oradbcloud</code></pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-9C13DCC4-0018-4049-94D8-70F518008504__GUID-82F6FFDB-0121-4827-9A14-68D40BBD5A8E">多分片协调器高可用性</p>
                        <p>多分片协调器的可用性会影响基于代理路由的工作负载，因此强烈建议在启用快速启动故障切换的最高可用性保护模式（零数据丢失故障切换）中使用Data Guard保护协调器。协调器可以选择启用Oracle RAC以获得额外的可用性和可伸缩性。</p>
                        <p>为了提高多分片查询工作负载的可伸缩性和可用性，只读模式下的Oracle Active Data Guard备用分片目录数据库可以充当多分片查询协调器。对于目录数据库的每个活动副本，特殊协调器服务GDS $ COORDINATOR。 <span class="variable" translate="no">cloud_name</span> （其中<span class="variable" translate="no">cloud_name</span>是为GDSCTL命令中的<code class="codeph">configname</code>参数指定的值， <code class="codeph">create shardcatalog</code> ，默认情况下为oradbcloud）正在所有分片导向器上运行并注册。客户端可以在任何副本上连接到此服务并执行多分片查询，允许分片导向器在运行时负载平衡方面分发多分片查询工作负载，并减少主分片目录中的负载，这是主要的分片目录Oracle Sharding框架的组件。此外，如果设置了数据库的区域，并且客户端在连接字符串中指定了区域，则分片导向器会根据区域关联性路由连接。
                        </p>
                        <p>多分片查询协调器的可用性对使用直接路由的工作负载没有任何影响。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-9C13DCC4-0018-4049-94D8-70F518008504__GUID-A3330ED0-5051-4ED4-8033-B5ADDF4CC94A">多分片查询协调器数据库大小调整</p>
                        <p>分片目录和多分片查询协调器承载以下关键信息：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>分片数据库拓扑的元数据</p>
                           </li>
                           <li>
                              <p>分片应用程序的模式</p>
                           </li>
                           <li>
                              <p>复制表的主副本</p>
                           </li>
                        </ul>
                        <p>元数据和模式的大小是名义上的;但是，在调整多分片查询协调器的大小时，应计划重复表的数量及其占用的空间。</p>
                        <p>除了上述内容之外，还应调整多分片查询协调器的大小以处理代理路由，基于SQL查询和正在处理的数据量，代理路由可以是CPU，I / O和内存密集型。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="sharding-data-routing.html#GUID-8CB6442A-9326-4242-892A-4383E05C1C48">代理路由的弹性</a><br>强烈建议协调器使用Data Guard进行保护，具有快速启动故障切换功能，并且可选择启用Oracle RAC以实现可用性和可伸缩性</li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="sharding-data-routing.html#GUID-EFC30D99-D4A8-40F6-A0DC-D15FE7BDC7F4" title="Sharding支持对未指定分片键的查询进行路由。这允许任何数据库应用程序灵活地在表格被分片或复制的系统中执行SQL语句（包括SELECT和DML），而无需指定应执行查询的分片。">在分片数据库中具有代理路由的查询和DML</a></p>
                        </div>
                     </div>
                  </div>
                  
                  <div class="sect4"><a id="GUID-8CB6442A-9326-4242-892A-4383E05C1C48" name="GUID-8CB6442A-9326-4242-892A-4383E05C1C48"></a><h5 id="SHARD-GUID-8CB6442A-9326-4242-892A-4383E05C1C48" class="sect5"><span class="enumeration_section">6.2.2.1</span>代理路由的弹性</h5>
                     <div>
                        <p>强烈建议协调器使用Data Guard进行保护，具有快速启动故障切换功能，并且可选择启用Oracle RAC以实现可用性和可伸缩性</p>
                        <p>协调器失败会影响通过协调器路由的多分片和单分片查询。以下是查询时的故障情况以及代理路由的预期行为：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>如果参与的分片已关闭，则协调器将查询发送到具有相同数据的另一个分片。</p>
                           </li>
                           <li>
                              <p>如果在参与的分片上执行查询期间发生故障，则用户将收到错误。</p>
                           </li>
                        </ul>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="sharding-data-routing.html#GUID-9C13DCC4-0018-4049-94D8-70F518008504" title="多分片查询协调器数据库包含分片拓扑的元数据，并为分片数据库提供查询处理支持。">Oracle Sharding多分片查询协调器</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div>
               <div class="sect3"><a id="GUID-E58EA3C1-8EB6-4F51-88BD-FC887035A624" name="GUID-E58EA3C1-8EB6-4F51-88BD-FC887035A624"></a><h4 id="SHARD-GUID-E58EA3C1-8EB6-4F51-88BD-FC887035A624" class="sect4"><span class="enumeration_section">6.2.3</span>使用代理路由查询和DML</h4>
                  <div>
                     <p>代理路由可以跨分片聚合数据和报告。它还允许任何数据库应用程序灵活地在表格被分片或复制的系统中执行SQL语句（包括SELECT和DML），而无需指定语句应执行的分片键（在连接期间）。</p>
                     <p>在没有分片密钥用例的聚合和SQL执行中，与直接的，基于密钥的路由相比，用户接受的性能水平降低。</p>
                     <p>在分片数据库（SDB）中，有两种类型的表：分片表和重复表。</p>
                     <p>分片表在分片键上是等分的。</p><pre class="pre codeblock"><code>S = S1 <span class="bold">U</span> S2 <span class="bold">U</span> ... <span class="bold">U</span> Sn</code></pre><p>所有分片上的重复表都相同。</p><pre class="pre codeblock"><code>R = R1 = ...... = Rn</code></pre><p>SDB中的代理路由提供了一种透明机制，用于执行从分片和重复表访问数据的典型SQL查询，而无需应用程序指定相关分片SQL编译器自动识别相关分片并协调所有参与分片的查询执行。数据库链接用于协调器和分片之间的通信。</p>
                     <p>在高级别，协调器将每个传入的查询Q重写为由两个查询CQ和SQ组成的分布形式，其中SQ（分片查询）是在每个参与的分片上执行的Q的部分，并且CQ（协调器查询）是在协调器分片上执行的部分。</p><pre class="pre codeblock"><code>Q =&gt; CQ（Shard_Iterator（SQ））</code></pre><p>以下是为了进行帧间分片执行而将Q1重写为Q1'的聚合查询示例：</p><pre class="pre codeblock"><code>Q1：SELECT COUNT（*）FROM customers Q1'：SELECT SUM（sc）FROM（Shard_Iterator（SELECT COUNT（*）sc FROM s1（i）））</code></pre><p>这个过程有两个关键要素：（1）识别相关分片（2）将查询重写为分布形式，以及分片迭代。</p>
                     <p>在协调器数据库上编译查询期间，查询编译器分析分片键上的谓词，并提取可用于标识参与分片的谓词，即将为查询中引用的分片表贡献行的分片。其余的碎片称为修剪碎片。</p>
                     <p>在仅识别出一个参与分片的情况下，将完整查询路由到该分片以进行完全执行。这称为单分片查询。如果有多个参与分片，则查询称为多分片查询并重写。重写过程考虑了查询计算的表达式以及查询形状。</p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="sharding-data-routing.html#GUID-EFC30D99-D4A8-40F6-A0DC-D15FE7BDC7F4" title="Sharding支持对未指定分片键的查询进行路由。这允许任何数据库应用程序灵活地在表格被分片或复制的系统中执行SQL语句（包括SELECT和DML），而无需指定应执行查询的分片。">在分片数据库中具有代理路由的查询和DML</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="sect3"><a id="GUID-1BC28361-73D8-460E-A5E4-C11FCD721ECC" name="GUID-1BC28361-73D8-460E-A5E4-C11FCD721ECC"></a><h4 id="SHARD-GUID-1BC28361-73D8-460E-A5E4-C11FCD721ECC" class="sect4"><span class="enumeration_section">6.2.4</span>单分片查询的代理路由</h4>
                  <div>
                     <p>单分片查询是一种查询，它只需要扫描来自一个分片的数据，而不需要从任何其他分片中查找数据。</p>
                     <p>单分片查询类似于连接到特定分片并在该分片上发出查询的客户端。在这种情况下，整个查询将在单个参与的分片上执行，协调器只将已处理的行传递回客户端。协调器上的计划类似于远程映射游标。</p>
                     <p>例如，以下查询完全映射到单个分片，因为客户123的数据仅位于该分片上。</p><pre class="pre codeblock"><code>SELECT count（*）FROM customers c，orders o WHERE c.custno = o.custno and c.custno = 123;</code></pre><p>该查询在shard键上包含一个条件，该条件映射到一个且只有一个在查询编译时（文字）或查询开始时间（bind）已知的分片。查询在合格分片上完全执行。</p>
                     <p>支持单个分片查询：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>平等和列表，例如<code class="codeph">Area = 'West'</code></p>
                        </li>
                        <li>
                           <p>包含文字和绑定的文字，绑定或表达的条件，例如</p><pre class="pre codeblock"><code>Area =：bind Area = CASE：bind &lt;10 THEN'West'ELSE'East'END</code></pre></li>
                        <li>
                           <p><code class="codeph">SELECT</code> ， <code class="codeph">UPDATE</code> ， <code class="codeph">DELETE</code> ， <code class="codeph">INSERT</code> ， <code class="codeph">FOR UPDATE</code>和<code class="codeph">MERGE</code> 。 <code class="codeph">UPSERT</code>不受支持。
                           </p>
                        </li>
                     </ul>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="sharding-data-routing.html#GUID-EFC30D99-D4A8-40F6-A0DC-D15FE7BDC7F4" title="Sharding支持对未指定分片键的查询进行路由。这允许任何数据库应用程序灵活地在表格被分片或复制的系统中执行SQL语句（包括SELECT和DML），而无需指定应执行查询的分片。">在分片数据库中具有代理路由的查询和DML</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="sect3"><a id="GUID-E3CF0022-FA38-4DD0-A5D5-7A409EA45F76" name="GUID-E3CF0022-FA38-4DD0-A5D5-7A409EA45F76"></a><h4 id="SHARD-GUID-E3CF0022-FA38-4DD0-A5D5-7A409EA45F76" class="sect4"><span class="enumeration_section">6.2.5</span>多分片查询的代理路由</h4>
                  <div>
                     <p>多分片查询必须扫描来自多个分片的数据，并且每个分片上的处理独立于任何其他分片。</p>
                     <p>多分片查询映射到多个分片，协调器可能需要在将结果发送到客户端之前进行一些处理。例如，以下查询获取每个客户下达的订单数量。</p><pre class="pre codeblock"><code>SELECT count（*），c.custno FROM customers c，orders o WHERE c.custno = o.custno GROUP BY c.custno;</code></pre><p>协调器将查询转换为以下内容。</p><pre class="pre codeblock"><code>SELECT sum（count_col），custno FROM（SELECT count（*）count_col，c.custno FROM customers c，orders o WHERE c.custno = o.custno GROUP BY c.custno）GROUP BY custno;</code></pre><p>内联查询块作为远程映射查询块映射到每个分片。协调器在所有分片的结果集之上执行进一步聚合和<code class="codeph">GROUP BY</code> 。每个分片上的执行单元是内联查询块。
                     </p>
                     <p>仅对<code class="codeph">SELECT</code>语句支持多分片查询。查询可以访问单个分片（在相等过滤器的情况下），也可以访问所有分片（如果在分片键上没有过滤谓词）。
                     </p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="sharding-data-routing.html#GUID-902C8750-EF4E-4551-AF75-AC4B95FC7D03">在多分片查询中指定一致性级别</a><br>在跨分片执行多分片查询时，可以使用初始化参数MULTISHARD_QUERY_DATA_CONSISTENCY设置不同的一致性级别。
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="sharding-data-routing.html#GUID-EFC30D99-D4A8-40F6-A0DC-D15FE7BDC7F4" title="Sharding支持对未指定分片键的查询进行路由。这允许任何数据库应用程序灵活地在表格被分片或复制的系统中执行SQL语句（包括SELECT和DML），而无需指定应执行查询的分片。">在分片数据库中具有代理路由的查询和DML</a></p>
                        </div>
                     </div>
                  </div>
                  
                  <div class="sect4"><a id="GUID-902C8750-EF4E-4551-AF75-AC4B95FC7D03" name="GUID-902C8750-EF4E-4551-AF75-AC4B95FC7D03"></a><h5 id="SHARD-GUID-902C8750-EF4E-4551-AF75-AC4B95FC7D03" class="sect5"><span class="enumeration_section">6.2.5.1</span>在多分片查询中指定一致性级别</h5>
                     <div>
                        <p>在跨分片执行多分片查询时，可以使用初始化参数MULTISHARD_QUERY_DATA_CONSISTENCY设置不同的一致性级别。</p>
                        <p>您可以为多分片查询指定不同的一致性级别。例如，您可能需要一些查询来避免跨分片的SCN同步成本，并且这些分片可以是全局分布的。另一个用例是当你使用备用数据库进行复制时，多分片查询可以接受稍微陈旧的数据，因为结果可以从主数据库及其备用数据库获取。</p>
                        <p>默认模式为strong，它在所有分片上执行SCN同步。其他模式跳过SCN同步。delayed_standby_allowed级别允许从备用数据库中获取数据，具体取决于负载平衡和其他因素，并且可能包含过时数据。</p>
                        <p>可以在系统级别或会话级别设置此参数。</p>
                     </div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-902C8750-EF4E-4551-AF75-AC4B95FC7D03__GUID-411DF42A-BBD9-438B-ADF2-459FFB35F647">
                           <p class="notep1">也可以看看：</p>
                           <p>有关MULTISHARD_QUERY_DATA_CONSISTENCY用法的详细信息，请参阅<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/shard&amp;id=REFRN-GUID-313D79DE-1A42-482C-BF41-6F821C8F3307" target="_blank"><span><cite>Oracle数据库参考</cite></span></a> 。
                           </p>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="sharding-data-routing.html#GUID-E3CF0022-FA38-4DD0-A5D5-7A409EA45F76" title="多分片查询必须扫描来自多个分片的数据，并且每个分片上的处理独立于任何其他分片。">多碎片查询的代理路由</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div>
               <div class="sect3"><a id="GUID-EE5D2C35-6CB2-45CC-B936-CABA2C329E1B" name="GUID-EE5D2C35-6CB2-45CC-B936-CABA2C329E1B"></a><h4 id="SHARD-GUID-EE5D2C35-6CB2-45CC-B936-CABA2C329E1B" class="sect4"><span class="enumeration_section">6.2.6</span>代理路由中支持的查询形状</h4>
                  <div>
                     <p>Oracle Sharding支持单个和多个分片查询形状，但有一些限制。</p>
                     <div class="section">
                        <p class="subhead3" id="GUID-EE5D2C35-6CB2-45CC-B936-CABA2C329E1B__GUID-ACE4058D-5510-4CD5-887B-8BFA731BB5D2">限制</p>
                        <p>以下是在Oracle Sharding中使用查询结构的限制：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>下面的交易部分中的示例给出了对DML的限制。</p>
                           </li>
                           <li>
                              <p>不支持<code class="codeph">CONNECT BY</code>查询。
                              </p>
                           </li>
                           <li>
                              <p>仅在<code class="codeph">SELECT</code>子句中的多分片查询中允许用户定义的PL / SQL。如果在<code class="codeph">WHERE</code>子句中指定了它，则抛出错误。
                              </p>
                              <p>不支持XLATE，XML查询和对象类型列。</p>
                           </li>
                           <li>
                              <p>不支持协调器上的分片表上的IAS。</p>
                           </li>
                           <li>
                              <p>不支持<code class="codeph">MODEL</code>子句。
                              </p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-EE5D2C35-6CB2-45CC-B936-CABA2C329E1B__GUID-91DF1B49-1CE2-4C41-B697-A139003AF5B0">查询仅涉及重复的表</p>
                        <p>对于仅涉及重复表的查询，查询形状没有限制。查询在协调器上执行。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-EE5D2C35-6CB2-45CC-B936-CABA2C329E1B__GUID-22F4E52A-FDE3-4096-93F6-E11CC42190C8">查询仅涉及分片表</p>
                        <p>对于单个表查询，查询可以在限定分片的分片键上具有相等性过滤器。对于连接查询，应使用分片键上的相等性来连接所有表。以下是涉及分片表的查询的一些示例。</p>
                        <p>内连接，其中equi-join仅用于分片键。</p><pre class="pre codeblock"><code>SELECT ... FROM s1 INNER JOIN s2 ON s1.sk = s2.sk WHERE any_filter（s1）AND any_filter（s2）</code></pre><p>左外连接仅在分片键上。</p><pre class="pre codeblock"><code>SELECT ... FROM s1 LEFT OUTER JOIN s2 ON s1.sk = s2.sk</code></pre><p>右外连接，与左外连接相同。</p><pre class="pre codeblock"><code>SELECT ... FROM s1 RIGHT OUTER JOIN s2 ON s1.sk = s2.sk</code></pre><p>仅在分片键上进行全外连接，但仅当Native有效且需要等连接时才有效。</p><pre class="pre codeblock"><code>SELECT ... FROM s1 FULL OUTER JOIN s2 ON s1.sk = s2.sk WHERE any_filter（s1）AND any_filter（s2）</code></pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-EE5D2C35-6CB2-45CC-B936-CABA2C329E1B__GUID-D71A9767-639F-422D-90D5-71CF5E691507">查询涉及分片和重复表</p>
                        <p>基于分片键上的谓词，涉及分片和重复表的查询可以是单分片或多分片查询。唯一的区别是查询将包含在每个分片上重复的非分片表。</p>
                        <p>分片表和重复表之间的连接可以使用任何比较运算符（= &lt;&gt; &lt;=&gt; =）甚至任意连接表达式在任何列上。以下是连接模式的示例。</p>
                        <p>内部联接</p><pre class="pre codeblock"><code>SELECT ... FROM s1 INNER JOIN r1 ON any_join_condition（s1，r1）WHERE any_filter（s1）AND any_filter（r1）</code></pre><p>左/右外连接</p>
                        <p>分片表是<code class="codeph">LEFT OUTER JOIN</code>的第一个表：</p><pre class="pre codeblock"><code>SELECT ... FROM <span class="bold">s1</span> LEFT OUTER JOIN r1 ON any_join_condition（s1，r1）WHERE any_filter（s1）AND any_filter（r1）SELECT ... FROM r1 LEFT OUTER JOIN <span class="bold">s1</span> ON any_join_condition（s1，s2）AND any_filter（r1）AND <span class="bold">filter_one_shard（s1）</span></code></pre><p>分片表是<code class="codeph">RIGHT OUTER JOIN</code>第二个表：</p><pre class="pre codeblock"><code>SELECT ... FROM r1 RIGHT OUTER JOIN <span class="bold">s1</span> ON any_join_condition（s1，r1）WHERE any_filter（s1）AND any_filter（r1）SELECT ... FROM <span class="bold">s1</span> RIGHT OUTER JOIN r1 ON any_join_condition（s1，s2 <span class="bold">）</span> AND filter_one_shard（ <span class="bold">s1）</span> AND any_filter（r1）</code></pre><p>全外连接</p><pre class="pre codeblock"><code>SELECT ... FROM s1 FULL OUTER JOIN r1 ON s1.sk = s2.sk WHERE any_filter（s1）AND any_filter（s2）</code></pre><p>半连接（ <code class="codeph">EXISTS</code> ）</p><pre class="pre codeblock"><code>SELECT ... FROM s1 EXISTS（SELECT 1 FROM r1 WHERE r1.anykey = s1.anykey）SELECT ... FROM r1 EXISTS（SELECT 1 FROM s1 WHERE r1.anykey = s1.anykey和filter_one_shard（s1））</code></pre><p>反加入（ <code class="codeph">NOT EXISTS</code> ）</p><pre class="pre codeblock"><code>SELECT ... FROM s1 NOT EXISTS（SELECT 1 FROM r1 WHERE r1.anykey = s1.anykey）</code></pre><p>左/右外连接</p>
                        <p>复制表是<code class="codeph">LEFT OUTER JOIN</code>的第一个表，或者分片表是第一个，它根据分片键上的过滤谓词映射到单个分片：</p><pre class="pre codeblock"><code>SELECT ... FROM r1 LEFT OUTER JOIN s1 ON any_join_condition（s1，s2）AND any_filter（r1）AND any_filter（s1）</code></pre><p>其中重复的表是<code class="codeph">RIGHT OUTER JOIN</code>的第二个表，或者分片表是第二个，它根据分片键上的过滤谓词映射到单个分片：</p><pre class="pre codeblock"><code>SELECT ... FROM s1 RIGHT OUTER JOIN r1 ON any_join_condition（s1，s2）AND any_filter（s1）AND any_filter（r1）</code></pre><p>完全外部加入</p>
                        <p>需要访问多个分片的分片表：</p><pre class="pre codeblock"><code>SELECT ... FROM s1 FULL OUTER JOIN r1 ON s1.non_sk = s2.non_sk WHERE any_filter（s1）AND any_filter（s2）</code></pre><p>半连接（ <code class="codeph">EXISTS</code> ）</p>
                        <p>分片表位于子查询中，需要访问多个分片：</p><pre class="pre codeblock"><code>SELECT ... FROM r1 EXISTS（SELECT 1 FROM s1 WHERE r1.anykey = s1.anykey）</code></pre><p>反加入（ <code class="codeph">NOT EXISTS</code> ）</p>
                        <p>分片表在子查询中：</p><pre class="pre codeblock"><code>SELECT ... FROM r1 NOT EXISTS（SELECT 1 FROM s1 WHERE r1.anykey = s1.anykey</code></pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-EE5D2C35-6CB2-45CC-B936-CABA2C329E1B__GUID-885861C9-D473-4B22-9D74-6AC1951C0D50">聚合函数</p>
                        <p>代理路由支持以下聚合：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">计数</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">和</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">MIN</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">MAX</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">AVG</code></p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-EE5D2C35-6CB2-45CC-B936-CABA2C329E1B__GUID-1974D8DE-2376-47DA-85DF-92E7EFA3ED0F">多分片查询和全局CR</p>
                        <p>多分片查询必须通过在所有分片的最高公共SCN上发出查询来维护全局读取一致性（CR）。有关如何设置一致性级别的信息，请参阅<a href="sharding-data-routing.html#GUID-902C8750-EF4E-4551-AF75-AC4B95FC7D03" title="在跨分片执行多分片查询时，可以使用初始化参数MULTISHARD_QUERY_DATA_CONSISTENCY设置不同的一致性级别。">在多个分片查询中指定一致性级别</a> 。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-EE5D2C35-6CB2-45CC-B936-CABA2C329E1B__GUID-153720B4-2DF6-452C-9F69-0AE9B37FABFC">交易</p>
                        <p><span class="underline">仅</span>支持<span class="underline">仅影响</span>一个分片的DML语句。例如，</p><pre class="pre codeblock"><code>更新S1 set col = ...其中<span class="bold">sk = &lt;constant&gt;</span> ;</code></pre><p>不支持影响多个分片的DML语句。例如，</p><pre class="pre codeblock"><code>更新S1 set col = ...;</code></pre><p>在事务中，可以在不同的分片上执行多个单个分片DML。例如，</p><pre class="pre codeblock"><code>插入S1值（...）;更新S1设置col = ...其中<span class="bold">sk = <span class="variable" translate="no">constant</span></span> ;删除S1，其中<span class="bold">sk = <span class="variable" translate="no">constant</span></span> ;承诺;</code></pre><p>对于多分片DML，协调器使用数据库链接，启动分布式事务并执行两阶段提交以保证分布式事务的一致性。对于不确定事务，数据库管理员必须手动恢复它。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-EE5D2C35-6CB2-45CC-B936-CABA2C329E1B__GUID-66A389F7-D1F0-46F7-8A4C-7116E83F4489">在多分片查询中传递提示</p>
                        <p>协调器上原始查询中指定的任何提示都会传播到分片。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-EE5D2C35-6CB2-45CC-B936-CABA2C329E1B__GUID-EBD29518-E44D-42CB-9DC4-FC9A95B1DC98">跟踪和排除慢速运行的多分片查询</p>
                        <p>在协调<code class="codeph">shard_sql</code>上设置跟踪事件<code class="codeph">shard_sql</code>以跟踪查询重写和分片修剪。观察到的一个常见性能问题是，由于分片的某些限制，GROUP BY未被推送到分片。检查是否所有可能的操作都被推送到分片，协调器只需要很少的工作来合并分片的结果。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="sharding-data-routing.html#GUID-EFC30D99-D4A8-40F6-A0DC-D15FE7BDC7F4" title="Sharding支持对未指定分片键的查询进行路由。这允许任何数据库应用程序灵活地在表格被分片或复制的系统中执行SQL语句（包括SELECT和DML），而无需指定应执行查询的分片。">在分片数据库中具有代理路由的查询和DML</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="sect3"><a id="GUID-51377035-217B-4624-88CD-A5D5DE125606" name="GUID-51377035-217B-4624-88CD-A5D5DE125606"></a><h4 id="SHARD-GUID-51377035-217B-4624-88CD-A5D5DE125606" class="sect4"><span class="enumeration_section">6.2.7</span>代理路由的执行计划</h4>
                  <div>
                     <p>在多分片查询中，每个分片都会生成一个独立的执行计划，该计划可能与查询中其他分片上的计划不同。</p>
                     <p>您无需连接到单个分片即可查看SQL分段的解释计划。<code class="codeph">dbms_xplan.display_cursor()</code>提供的接口在协调器上显示在分片上执行的SQL段的计划， <code class="codeph">[V/X]$SHARD_SQL</code>将<code class="codeph">[V/X]$SHARD_SQL</code>片查询的分片SQL片段唯一地映射到目标分片数据库。
                     </p>
                     <div class="section">
                        <p class="subhead3" id="GUID-51377035-217B-4624-88CD-A5D5DE125606__GUID-94DB70CE-D8C0-4DD8-960F-836AA88EFC86">dbms_xplan.display_cursor（）的SQL段接口</p>
                        <p>两个接口显示在分片上执行的SQL段的计划。接口将分片ID作为参数，以显示指定分片中的计划。<code class="codeph">ALL_SHARDS</code>格式显示所有分片的计划。
                        </p>
                        <p>要从分片打印所有计划，请使用格式ALL_SHARDS，如下所示。</p><pre class="pre codeblock"><code>select * from table（dbms_xplan.display_cursor（sql_id =&gt;：sqlid，cursor_child_no =&gt;：childno，format =&gt;'BASIC + <span class="bold">ALL_SHARDS</span> '，shard_ids =&gt; shard_ids））</code></pre><p>要从分片打印选择性计划，请在<code class="codeph">display_cursor()</code>函数中传递分片ID。对于来自多个分片的计划，在<code class="codeph">shard_ids</code>参数中传递包含感兴趣的分<code class="codeph">shard_ids</code> ID的数字数组，如此处所示。
                        </p><pre class="pre codeblock"><code>select * from table（dbms_xplan.display_cursor（sql_id =&gt;：sqlid，cursor_child_no =&gt;：childno，format =&gt;'BASIC'， <span class="bold">shard_ids =&gt; ids</span> ））</code></pre><p>要从一个分片返回计划，请将分片ID直接传递给<code class="codeph">shard_id</code>参数，如此处所示。
                        </p><pre class="pre codeblock"><code>select * from table（dbms_xplan.display_cursor（sql_id =&gt;：sqlid，cursor_child_no =&gt;：childno，format =&gt;'BASIC'， <span class="bold">shard_id =&gt; 1</span> ））</code></pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-51377035-217B-4624-88CD-A5D5DE125606__GUID-C827DA36-3151-42EC-9606-2AD0D0963C7D">[V / X] $ SHARD_SQL</p>
                        <p><code class="codeph">[V/X]$SHARD_SQL</code>将<code class="codeph">[V/X]$SHARD_SQL</code>片查询的分片SQL片段唯一映射到目标分片数据库。此视图仅与分片协调器数据库相关，以存储为给定多分片查询的每个分片SQL片段访问的分片列表。每次执行多分片查询都可以在不同的分片集上执行分片SQL片段，因此每次执行都会更新分片ID。此视图维护每个REMOTE节点的分片SQL片段的SQL ID以及执行分片SQL片段的SHARD ID。
                        </p><pre class="pre codeblock"><code>名字空？输入----------------------------------------- -------- ---------------------------- SQL_ID VARCHAR2（13）CHILD_NUMBER NUMBER NODE_ID NUMBER SHARD_SQL_ID VARCHAR2（13）SHARD_ID NUMBER SHARD_CHILD_NUMBER NUMBER</code></pre><ul style="list-style-type:disc">
                           <li>
                              <p><span class="bold">SQL_ID</span> - 协调器上<span class="bold">多分片</span>查询的SQL ID</p>
                           </li>
                           <li>
                              <p><span class="bold">CHILD_NUMBER</span> - 协调器上<span class="bold">多分片</span>查询的游标子编号</p>
                           </li>
                           <li>
                              <p><span class="bold">NODE_ID</span> - 多分片查询的分片SQL片段的REMOTE节点的ID</p>
                           </li>
                           <li>
                              <p><span class="bold">SHARD_SQL_ID</span> - 给定远程NODE ID的分片SQL片段的SQL ID</p>
                           </li>
                           <li>
                              <p><span class="bold">SHARD_ID</span> - 执行分片SQL片段的分片的ID</p>
                           </li>
                           <li>
                              <p><span class="bold">SHARD _CHILD_NUMBER</span> - 分片上碎片SQL片段的游标子编号（默认为0）</p>
                           </li>
                        </ul>
                        <p>以下是分片数据库和执行计划上的多分片查询的示例。</p><pre class="pre codeblock"><code>SQL&gt;从存在的部门a中选择count（*）（从部门b中选择不同的department_id，其中b.department_id = 60）; ------------------------------------------------ | Id |操作|名称| ------------------------------------------------ | 0 |选择声明| | | 1 | SORT AGGREGATE | | | 2 |过滤器| | | 3 |查看| VW_SHARD_377C5901 | | 4 | SHARD ITERATOR | | | 5 | <span class="bold">REMOTE</span> | | | 6 |查看| VW_SHARD_EEC581E4 | | 7 | SHARD ITERATOR | | | 8 | <span class="bold">REMOTE</span> | | ------------------------------------------------</code></pre><p>在<code class="codeph">V$SHARD_SQL</code>视图上查询<code class="codeph">V$SHARD_SQL</code> 。
                        </p><pre class="pre codeblock"><code>SQL&gt;从v $ shard_sql中选择*，其中SQL_ID ='1m024z033271u'; SQL_ID NODE_ID SHARD_SQL_ID SHARD_ID ------------- ------- -------------- -------- 1m024z033271u 5 5z386yz9suujt 1 1m024z033271u 5 5z386yz9suujt 11 1m024z033271u 5 5z386yz9suujt 21 1m024z033271u 8 8f50ctj1a2tbs 11</code></pre></div>
                     <!-- class="section" -->
                     <div class="section"></div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-51377035-217B-4624-88CD-A5D5DE125606__GUID-570F1CD0-8191-4F5C-BCBD-1CBED91EA578">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/shard&amp;id=ARPLS-GUID-BEE6D488-0381-4864-9B19-6299DE2B6210" target="_blank"><span><cite>Oracle数据库PL / SQL包和类型参考</cite></span></a></p>
                        <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/shard&amp;id=REFRN-GUID-35400A54-B329-4C50-96AB-830152437737" target="_blank"><span><cite>Oracle数据库参考</cite></span></a></p>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="sharding-data-routing.html#GUID-EFC30D99-D4A8-40F6-A0DC-D15FE7BDC7F4" title="Sharding支持对未指定分片键的查询进行路由。这允许任何数据库应用程序灵活地在表格被分片或复制的系统中执行SQL语句（包括SELECT和DML），而无需指定应执行查询的分片。">在分片数据库中具有代理路由的查询和DML</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div>
            <div class="sect2"><a id="GUID-F5D3C0B6-83F9-457A-97A9-429AC9EE4550" name="GUID-F5D3C0B6-83F9-457A-97A9-429AC9EE4550"></a><h3 id="SHARD-GUID-F5D3C0B6-83F9-457A-97A9-429AC9EE4550" class="sect3"><span class="enumeration_section">6.3</span>在中间层连接池和碎片之间创建亲和力</h3>
               <div>
                  <p>称为中间层路由的Oracle通用连接池（UCP）功能允许智能路由器（例如，F5 BigIP）路由到与分片密钥关联的中间层。它将分片数据库拓扑发布到路由器层，以便基于特定分片密钥的请求被路由到适当的应用程序中间层，从而在给定的分片子集上建立连接。</p>
                  <p>在典型的Oracle Sharding环境中，中间层连接池将数据库请求路由到特定分片。这可能导致每个中间层连接池与每个分片建立连接的情况。这可能会创建与数据库的连接太多。可以通过在中间层和分片之间创建亲和性来解决该问题。在这种情况下，为每个数据中心或云专用中间层（Web服务器，应用程序服务器）以及将客户端请求直接路由到包含客户端数据的分片（对应于客户端分片）的中间层是理想的钥匙）居住。用于这种设置的常用术语是泳道，其中每个泳道是专用堆栈，从Web服务器到应用服务器一直到数据库。</p>
                  <p>Oracle通用连接池（UCP）通过提供中间层路由API解决了这个问题，该API可用于将客户端请求路由到相关的中间层。<code class="codeph">OracleShardRoutingCache</code>类公开了UCP中间层API。此类的实例表示UCP内部分片路由缓存，可以通过提供连接属性（如用户，密码和URL）来创建。路由缓存连接到分片目录以检索分片映射拓扑的密钥并将其存储在其缓存中。
                  </p>
                  <p>路由缓存由UCP中间层API <code class="codeph">getShardInfoForKey(shardKey,superShardKey)</code> ，它接受分片键作为输入，并返回映射到输入分片键的一组<code class="codeph">ShardInfo</code>实例。<code class="codeph">ShardInfo</code>实例封装了一个唯一的分片名称和分片的优先级。使用中间层API的应用程序可以将返回的唯一分片名称值映射到具有与特定分片的连接的中间层。通过订阅相应的ONS事件，在分块或将其移动到其他分片时，路由缓存会自动更新。
                  </p>
                  <p>以下代码示例说明了Oracle UCP中间层路由API的用法。</p>
                  <div class="example" id="GUID-F5D3C0B6-83F9-457A-97A9-429AC9EE4550__GUID-5D4DAF99-8CF1-4D44-B188-DC10264559E1">
                     <p class="titleinexample">示例6-4使用UCP API的中间层路由</p><pre class="pre codeblock"><code>import java.sql。的SQLException; import java.util。性能; import java.util。随机; import java.util。组; import oracle.jdbc。OracleShardingKey; import oracle.jdbc。OracleType; import oracle.ucp。UniversalConnectionPoolException; import oracle.ucp.routing。ShardInfo; import oracle.ucp.routing.oracle。OracleShardRoutingCache; / ** *代码示例说明了UCP的中间层路由功能的使用。* API接受分片键作为输入，并返回映射到分片键的ShardInfo *实例集。ShardInfo实例封装*唯一的分片名称和优先级。然后，可以将唯一的分片名称*映射到连接到特定分片的中间层服务器。* * / public class MidtierShardingExample {private static String user =“testuser1”; private static String password =“testuser1”; // catalog DB URL private static String url =“jdbc：oracle：thin：@ // hostName：1521 / catalogServiceName”; private static String region =“regionName”; public static void main（String args []）throws Exception {testMidTierRouting（）; static void testMidTierRouting（）抛出UniversalConnectionPoolException，SQLException {Properties dbConnectProperties = new Properties（）; dbConnectProperties.setProperty（OracleShardRoutingCache。USER，user）; dbConnectProperties.setProperty（OracleShardRoutingCache。密码，密码）; //中间层路由API接受目录数据库URL dbConnectProperties.setProperty（OracleShardRoutingCache。URL，网址）; //获取ONS配置字符串dbConnectProperties.setProperty（OracleShardRoutingCache）需要区域名称。地区，地区）; OracleShardRoutingCache routingCache = new OracleShardRoutingCache（dbConnectProperties）; final int COUNT = 10;随机随机= new Random（）; for（int i = 0; i &lt;COUNT; i ++）{int key = random.nextInt（）; OracleShardingKey shardKey = routingCache.getShardingKeyBuilder（）.subkey（key，OracleType。NUMBER）.build（）; OracleShardingKey superShardKey = null;设置&lt;ShardInfo&gt; shardInfoSet = routingCache.getShardInfoForKey（shardKey，superShardKey）; for（ShardInfo shardInfo：shardInfoSet）{System.out.println（“Sharding Key =”+ key +“Shard Name =”+ shardInfo.getName（）+“Priority =”+ shardInfo.getPriority（））; }}}}</code></pre></div>
                  <!-- class="example" -->
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/shard&amp;id=JJUCP-GUID-6B3483EE-6E38-4B76-AAAC-0192E5827C3A" target="_blank">使用UCP的中间层路由</a></li>
                     </ul>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="sharding-data-routing.html#GUID-7001A9CC-B681-4DFA-B461-6FD653D9D62D" title="Oracle Sharding支持直接，基于密钥，路由到分片，按代理路由和路由到中间层。">在Sharded数据库环境中请求路由</a></p>
                     </div>
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>