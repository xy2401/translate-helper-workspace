<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <title>关键编程注意事项</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="SQLJ Developer&#39;s Guide "></meta>
      <meta property="og:description" content=""></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="SQLJ Developer&#39;s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="sqlj-developers-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-11T08:20:03-08:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="1999, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96458-01"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="intro-to-SQLJ.html" title="Previous" type="text/html"></link>
      <link rel="next" href="basic-language-features.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="SQLJ Developer&#39;s Guide"></meta>
    <meta name="dcterms.isVersionOf" content="JSQLJ"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="intro-to-SQLJ.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="basic-language-features.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">SQLJ开发人员指南</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">关键编程注意事项</li>
            </ol>
            <a id="GUID-89D0620E-5E57-492D-9D3A-6A04F2171701" name="GUID-89D0620E-5E57-492D-9D3A-6A04F2171701"></a><a id="JSQLJ185"></a>
            
            <h2 id="JSQLJ-GUID-89D0620E-5E57-492D-9D3A-6A04F2171701" class="sect2"><span class="enumeration_chapter">4</span>关键编程注意事项</h2>
         </header>
         <div class="ind">
            <div>
               <p>本章讨论在开发和运行SQLJ应用程序之前要考虑的关键问题，还提供了摘要和示例应用程序。讨论了以下主题：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="key-programming-considerations.html#GUID-91CC986D-B9AA-4073-AAC6-5265BB9B250A">选择JDBC驱动程序</a></p>
                  </li>
                  <li>
                     <p><a href="key-programming-considerations.html#GUID-02A50813-2D4D-4DC1-AD1A-014AF1EDC03D">连接注意事项</a></p>
                  </li>
                  <li>
                     <p><a href="key-programming-considerations.html#GUID-EA345D88-D2AE-4118-986A-472764A6E1A4">NULL处理</a></p>
                  </li>
                  <li>
                     <p><a href="key-programming-considerations.html#GUID-10C3A27F-878A-468D-BC78-D9DC8A2079A0">异常处理基础知识</a></p>
                  </li>
                  <li>
                     <p><a href="key-programming-considerations.html#GUID-6F37BE89-6EA0-4B27-884A-C0D4E8746E97">基本交易控制</a></p>
                  </li>
                  <li>
                     <p><a href="key-programming-considerations.html#GUID-E1A4C501-C265-43F6-98A3-D3F46044348A">摘要：SQLJ代码的第一步</a></p>
                  </li>
                  <li>
                     <p><a href="key-programming-considerations.html#GUID-E0F0C310-400E-4F9C-8036-B44FB2A3E2FD">特定于Oracle的代码生成（无配置文件）</a></p>
                  </li>
                  <li>
                     <p><a href="key-programming-considerations.html#GUID-841EEFAD-3954-43D0-A270-679762CFBDED">ISO标准代码生成</a></p>
                  </li>
                  <li>
                     <p><a href="key-programming-considerations.html#GUID-6AE4F277-58B0-4DC6-A516-4D6A6C5E839A">命名的要求和限制</a></p>
                  </li>
                  <li>
                     <p><a href="key-programming-considerations.html#GUID-55421A92-C6F6-47F1-8B40-A19B04D79C34">SQLJ在中间层的注意事项</a></p>
                  </li>
               </ul>
            </div><a id="JSQLJ186"></a><div class="props_rev_3"><a id="GUID-91CC986D-B9AA-4073-AAC6-5265BB9B250A" name="GUID-91CC986D-B9AA-4073-AAC6-5265BB9B250A"></a><h3 id="JSQLJ-GUID-91CC986D-B9AA-4073-AAC6-5265BB9B250A" class="sect3">选择JDBC驱动程序</h3>
               <div>
                  <p>您必须考虑哪种Java数据库连接（JDBC）驱动程序适合您的情况，以及使用不同的驱动程序进行转换和运行时是否有利。您必须为每个驱动程序选择或注册相应的驱动程序类，然后在连接URL中指定驱动程序。</p>
                  <div class="infoboxnote" id="GUID-91CC986D-B9AA-4073-AAC6-5265BB9B250A__GUID-0CB42930-D50B-4C24-B317-784718CACAEE">
                     <p class="notep1">注意：</p>
                     <p>如果您使用Oracle特定的代码生成，或者如果您使用Oracle自定义程序生成ISO SQLJ标准代码，则您的应用程序将需要Oracle JDBC驱动程序，即使您的代码实际上并未使用Oracle特定的功能。</p>
                  </div>
                  <p>本节包括以下主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="key-programming-considerations.html#GUID-C876AE82-C45C-4234-9C29-38B9050BEBD7">Oracle JDBC驱动程序概述</a></p>
                     </li>
                     <li>
                        <p><a href="key-programming-considerations.html#GUID-E46F37A1-9E59-416E-A735-B5804D7A3094">翻译的驱动程序选择</a></p>
                     </li>
                     <li>
                        <p><a href="key-programming-considerations.html#GUID-EDC7B103-DC71-490F-BF36-9FD95B155425">运行时的驱动程序选择和注册</a></p>
                     </li>
                  </ul>
               </div><a id="JSQLJ188"></a><a id="JSQLJ189"></a><a id="JSQLJ190"></a><a id="JSQLJ191"></a><a id="JSQLJ192"></a><a id="JSQLJ187"></a><div class="props_rev_3"><a id="GUID-C876AE82-C45C-4234-9C29-38B9050BEBD7" name="GUID-C876AE82-C45C-4234-9C29-38B9050BEBD7"></a><h4 id="JSQLJ-GUID-C876AE82-C45C-4234-9C29-38B9050BEBD7" class="sect4">Oracle JDBC驱动程序概述</h4>
                  <div>
                     <p>Oracle提供以下JDBC驱动程序：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>Oracle调用接口（OCI）驱动程序：用于客户端使用Oracle客户端安装。</p>
                        </li>
                        <li>
                           <p>瘦驱动程序：用于客户端使用的纯Java驱动程序，尤其适用于applet。它不需要安装Oracle客户端。</p>
                        </li>
                        <li>
                           <p>服务器端瘦驱动程序：在功能上与客户端瘦驱动程序相同，但适用于在Oracle数据库实例内运行且需要访问远程服务器的代码。</p>
                        </li>
                        <li>
                           <p>服务器端内部驱动程序：对于在目标服务器内运行的代码，即在必须访问的Oracle数据库实例内部。</p>
                        </li>
                     </ul>
                     <p>Oracle Database 12 <span class="italic">c</span>第1版（12.1）提供了与JDK 6和JDK 7兼容的客户端驱动程序。
                     </p>
                     <div class="infoboxnotealso" id="GUID-C876AE82-C45C-4234-9C29-38B9050BEBD7__GUID-AEFEC7BA-81C0-4547-A933-20583517BB65">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="../jjdbc/introducing-JDBC.html#JJDBC-GUID-D6975767-9F5A-4B30-8910-9298DDD7FEF0" target="_blank"><span class="italic">Oracle数据库JDBC开发人员指南</span></a></p>
                     </div>
                     <div class="infoboxnote" id="GUID-C876AE82-C45C-4234-9C29-38B9050BEBD7__GUID-905852A1-47DC-4D29-A1E7-694DF7D3F931">
                        <p class="notep1">注意：</p>
                        <p>请记住，您的选择可能因翻译时间和运行时间而异。例如，您可能希望在转换时使用Oracle JDBC OCI驱动程序进行语义检查，但在运行时使用Oracle JDBC Thin驱动程序。</p>
                     </div>
                     <div class="section">
                        <p class="subhead3" id="GUID-C876AE82-C45C-4234-9C29-38B9050BEBD7__GUID-9548D4B8-9B70-474E-A41B-5C4A433FC47E">核心JDBC功能</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>所有Oracle JDBC驱动程序的核心功能都是相同的。它们支持相同的功能集，语法，编程接口和Oracle扩展。</p>
                        <p><code class="codeph">oracle.jdbc.支持所有Oracle JDBC驱动程序<code class="codeph">oracle.jdbc.OracleDriver</code>类。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-C876AE82-C45C-4234-9C29-38B9050BEBD7__GUID-0344D805-84F7-4403-B0B8-BE69EFB602DE">JDBC OCI驱动程序</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>Oracle JDBC OCI驱动程序通过直接从Java调用OCI来访问数据库，从而提供与不同Oracle数据库版本的最高兼容性。这些驱动程序支持已安装的Oracle Net适配器，包括进程间通信（IPC），命名管道，TCP / IP和IPX / SPX。</p>
                        <p>使用本机方法调用C入口点会使OCI驱动程序依赖于Oracle平台，从而需要安装包含Oracle Net的Oracle客户端。因此它不适合applet。</p>
                        <p>OCI驱动程序的连接strs gs具有以下形式，其中<span class="italic"><code class="codeph">tns</code></span>是可选的TNS别名或完整的TNS规范：</p><pre class="oac_no_warn" dir="ltr">jdbc：oracle：oci：@ &lt; <span class="italic">tns</span> &gt;</pre><div class="infoboxnote" id="GUID-C876AE82-C45C-4234-9C29-38B9050BEBD7__GUID-402FBB1B-9C41-4BA1-AD9B-A89D7BB2CD83">
                           <p class="notep1">注意：</p>
                           <p>为了向后兼容， <code class="codeph">oci8</code>仍然可以接受，而不是<code class="codeph">oci</code> 。
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-C876AE82-C45C-4234-9C29-38B9050BEBD7__GUID-7FDFA77F-AC81-4FA9-8835-9EABD30FC177">JDBC瘦驱动程序</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>Oracle JDBC Thin驱动程序是一个独立于平台的纯Java实现，它使用Java套接字从任何Oracle或非Oracle客户端直接连接到Oracle数据库。它可以在运行Java applet的同时下载到浏览器中。</p>
                        <p>JDBC Thin驱动程序仅支持TCP / IP协议，并且要求TNS侦听器从数据库服务器侦听TCP / IP套接字。当JDBC Thin驱动程序与applet一起使用时，客户端浏览器必须具有支持Java套接字的功能。</p>
                        <p>JDBC Thin驱动程序的连接字符串通常具有以下形式：</p><pre class="oac_no_warn" dir="ltr">jdbc：oracle：thin：@ <span class="italic">host</span> ： <span class="italic">port</span> / <span class="italic">servicename</span>
</pre><div class="infoboxnotealso" id="GUID-C876AE82-C45C-4234-9C29-38B9050BEBD7__GUID-6391BCFD-AFAD-4913-AFEF-CCF711730266">
                           <p class="notep1">也可以看看：</p>
                           <p>有关数据库服务名称的信息，请<a href="../jjdbc/introducing-JDBC.html#JJDBC-GUID-D6975767-9F5A-4B30-8910-9298DDD7FEF0" target="_blank"><span class="italic">参见Oracle数据库JDBC开发人员指南</span></a></p>
                        </div>
                        <p>在Oracle Database 12 <span class="italic">c</span>第2版（12.2）中，不推荐使用SID的连接字符串，但仍支持向后兼容性：</p><pre class="oac_no_warn" dir="ltr">jdbc：oracle：thin：@ <span class="italic">host</span> ： <span class="italic">port</span> ： <span class="italic">sid</span></pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-C876AE82-C45C-4234-9C29-38B9050BEBD7__GUID-F8E386C5-E19B-4BC7-8F03-311BE5849705">JDBC服务器端瘦驱动程序</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>Oracle JDBC服务器端Thin驱动程序提供与客户端JDBC Thin驱动程序相同的功能，但在数据库内运行并访问远程服务器。这对于从另一个内部访问一个Oracle数据库实例很有用，例如从Java存储过程访问。</p>
                        <p>服务器端Thin驱动程序的连接strs gs与客户端瘦驱动程序的连接strin gs相同。
                        </p>
                        <div class="infoboxnote" id="GUID-C876AE82-C45C-4234-9C29-38B9050BEBD7__GUID-5E6FB464-4CE9-4EEA-BEF3-9865D5A47C31">
                           <p class="notep1">注意：</p>
                           <p>要在使用服务器端Thin驱动程序时离开原始数据库，用户帐户必须分配<code class="codeph">SocketPermission</code> 。有关更多信息，请参阅<a href="../jjdbc/JDBC-getting-started.html#JJDBC-GUID-782A399A-78F5-4D1A-A4F3-F5AE35DE62DA" target="_blank"><span class="italic">Oracle数据库JDBC开发人员指南</span></a> 。另外，有关<code class="codeph">SocketPermission</code>和其他权限的一般信息，请参阅<a href="../jjdev/database-contents-Oracle-JVM-security.html#JJDEV-GUID-54515619-575D-4EFB-B745-F857A07813A6" target="_blank"><span class="italic">Oracle数据库Java开发人员指南</span></a> 。
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-C876AE82-C45C-4234-9C29-38B9050BEBD7__GUID-134F9E31-40BD-4DB4-9C69-9CF478B7B754">JDBC服务器端内部驱动程序</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>Oracle JDBC服务器端内部驱动程序为在要执行SQL操作的目标Oracle数据库实例内运行的任何Java代码提供支持。服务器端内部驱动程序使Oracle Java虚拟机（JVM）能够直接与SQL引擎通信。此驱动程序是SQLJ代码的缺省JDBC驱动程序，在Oracle Database 12 <span class="italic">c</span>第2版（12.2）中作为存储过程，存储函数或触发器运行。
                        </p>
                        <p>服务器端内部驱动程序的连接字符串具有以下形式：</p><pre class="oac_no_warn" dir="ltr">JDBC：神谕：kprb：</pre><p>如果您的SQLJ代码使用默认连接上下文，则SQLJ会自动将此驱动程序用于在Oracle JVM中运行的代码。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ193"></a><div class="props_rev_3"><a id="GUID-E46F37A1-9E59-416E-A735-B5804D7A3094" name="GUID-E46F37A1-9E59-416E-A735-B5804D7A3094"></a><h4 id="JSQLJ-GUID-E46F37A1-9E59-416E-A735-B5804D7A3094" class="sect4">翻译的驱动程序选择</h4>
                  <div>
                     <div class="section">
                        <p>在命令行或属性文件中使用SQLJ选项设置来选择驱动程序管理器类并指定用于转换的驱动程序。</p>
                        <p>使用SQLJ <code class="codeph">-driver</code>选项选择除<code class="codeph">OracleDriver</code>之外的任何驱动程序管理器类，这是默认设置。
                        </p>
                        <p>指定要选择的特定JDBC驱动程序，例如JDBC Thin或JDBC OCI for Oracle Database，作为您在SQLJ <code class="codeph">-url</code>选项中指定的连接URL的一部分。
                        </p>
                        <div class="infoboxnotealso" id="GUID-E46F37A1-9E59-416E-A735-B5804D7A3094__GUID-D3754998-DE62-4ABC-A67B-58E354617C46">
                           <p class="notep1">也可以看看：</p>
                           <p><span class="q">“ <a href="translator-command-line-and-options.html#GUID-E001FA35-824A-47A1-8973-AA5771B0DFE5">连接选项</a> ”</span></p>
                        </div>
                        <p>您通常（但不一定）使用在源代码中用于运行时连接的相同驱动程序。</p>
                        <div class="infoboxnote" id="GUID-E46F37A1-9E59-416E-A735-B5804D7A3094__GUID-E5CE27DC-3F52-4C85-9D4E-9B669CCA97A7">
                           <p class="notep1">注意：</p>
                           <p>请记住， <code class="codeph">-driver</code>选项不会选择特定的驱动程序。它使用驱动程序管理器注册驱动程序类。一个驱动程序类可能用于多个驱动程序协议，例如<code class="codeph">OracleDriver</code> ，它用于所有Oracle JDBC协议。
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ194"></a><div class="props_rev_3"><a id="GUID-EDC7B103-DC71-490F-BF36-9FD95B155425" name="GUID-EDC7B103-DC71-490F-BF36-9FD95B155425"></a><h4 id="JSQLJ-GUID-EDC7B103-DC71-490F-BF36-9FD95B155425" class="sect4">运行时的驱动程序选择和注册</h4>
                  <div>
                     <div class="section">
                        <p>要在运行时连接到数据库，您必须<span class="italic">注册</span>一个或多个驱动程序，这些驱动程序将了解您为任何连接实例指定的URL，无论它们是<code class="codeph">sqlj.runtime.ref.实例<code class="codeph">sqlj.runtime.ref.DefaultContext</code>类或您声明的任何连接上下文类。
                        </p>
                        <p>如果您使用Oracle JDBC驱动程序并使用<code class="codeph">Oracle.connect()</code>方法创建默认连接，则SQLJ会自动处理此问题。<code class="codeph">Oracle.connect()</code>方法注册<code class="codeph">oracle.jdbc.OracleDriver</code>类。
                        </p>
                        <p>如果您使用的是Oracle JDBC驱动程序，但不使用<code class="codeph">Oracle.connect()</code> ，则必须手动注册<code class="codeph">OracleDriver</code>类，如下所示：</p><pre class="oac_no_warn" dir="ltr">DriverManager.registerDriver（新的oracle.jdbc。一个OracleDriver（））;</pre><p>如果您不使用Oracle JDBC驱动程序，则必须注册一些适当的驱动程序类，如下所示：</p><pre class="oac_no_warn" dir="ltr">DriverManager.registerDriver（new <span class="italic">mydriver.jdbc.driver。MyDriver（）</span> ）;</pre><p>在任何情况下，您还必须设置连接URL，用户名和密码。</p>
                        <div class="infoboxnotealso" id="GUID-EDC7B103-DC71-490F-BF36-9FD95B155425__GUID-AFAFAF43-1E44-4A4C-964D-52ACB9DE9F80">
                           <p class="notep1">也可以看看：</p>
                           <p><span class="q">“ <a href="key-programming-considerations.html#GUID-DFB81879-F28E-47FD-A419-67C647F34B04">使用DefaultContext的单个连接或多个连接</a> ”</span></p>
                        </div>
                        <div class="infoboxnote" id="GUID-EDC7B103-DC71-490F-BF36-9FD95B155425__GUID-F71E74ED-0699-45D3-9A0A-CEA7E8A6241E">
                           <p class="notep1">注意：</p>
                           <p>作为使用JDBC驱动程序管理器建立JDBC连接的替代方法，您可以使用数据源。您可以在<code class="codeph">with</code>子句中指定数据源，如<span class="q">“ <a href="basic-language-features.html#GUID-5E97C2F0-7249-48FD-A75B-AB5A465147C7">声明WITH子句</a> ”中所述</span> 。有关数据源的一般信息，请参阅<a href="../jjdbc/data-sources-and-URLs.html#JJDBC-GUID-38C56493-EC9F-45CA-B650-411C6A2A7AF0" target="_blank"><span class="italic">Oracle数据库JDBC开发人员指南</span></a> 。
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="JSQLJ195"></a><div class="props_rev_3"><a id="GUID-02A50813-2D4D-4DC1-AD1A-014AF1EDC03D" name="GUID-02A50813-2D4D-4DC1-AD1A-014AF1EDC03D"></a><h3 id="JSQLJ-GUID-02A50813-2D4D-4DC1-AD1A-014AF1EDC03D" class="sect3">连接注意事项</h3>
               <div>
                  <div class="section">
                     <p>在确定SQLJ应用程序所需的数据库连接或连接时，请考虑以下事项：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>您只需要一个数据库连接还是多个连接？</p>
                        </li>
                        <li>
                           <p>如果使用多个连接（可能是多个模式），那么每个连接将使用相同名称的SQL实体：同名的表，相同名称和数据类型的列，相同名称和签名的存储过程，等等？</p>
                        </li>
                        <li>
                           <p>您是否需要不同的翻译和运行时间连接，或者两者都需要相同的连接？</p>
                        </li>
                     </ul>
                     <p>SQLJ可执行语句可以为其数据库连接指定特定的连接上下文实例（ <code class="codeph">DefaultContext</code>或声明的连接上下文类）。或者，它可以省略连接上下文规范并使用默认连接，默认连接是以前设置为默认值的<code class="codeph">DefaultContext</code>实例。
                     </p>
                     <div class="infoboxnote" id="GUID-02A50813-2D4D-4DC1-AD1A-014AF1EDC03D__GUID-DF1EBA5B-8DFE-4A64-B2EA-F9A90743A9D7">
                        <p class="notep1">注意：</p>
                        <p>如果您的操作将使用不同的SQL实体集，那么您通常需要声明并使用其他连接上下文类。</p>
                     </div>
                     <p>本节包括以下主题：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="key-programming-considerations.html#GUID-DFB81879-F28E-47FD-A419-67C647F34B04">使用DefaultContext的单个连接或多个连接</a></p>
                        </li>
                        <li>
                           <p><a href="key-programming-considerations.html#GUID-B255B6E1-449E-4FE1-ACFE-6FCD2AFCFBDC">关闭连接</a></p>
                        </li>
                        <li>
                           <p><a href="key-programming-considerations.html#GUID-9B855A2A-CAB3-43E2-BE27-E7E5F239B73C">使用声明的连接上下文类的多个连接</a></p>
                        </li>
                        <li>
                           <p><a href="key-programming-considerations.html#GUID-5838209F-A715-4935-AD3F-7EFDD5CE4BF3">有关Oracle类的更多信息</a></p>
                        </li>
                        <li>
                           <p><a href="key-programming-considerations.html#GUID-8D05EAA4-E034-495C-A74D-EFEF9778ABC1">有关DefaultContext类的更多信息</a></p>
                        </li>
                        <li>
                           <p><a href="key-programming-considerations.html#GUID-2867AB26-AF5A-4336-AD57-3247E0A44DB9">翻译连接</a></p>
                        </li>
                        <li>
                           <p><a href="key-programming-considerations.html#GUID-7D345B91-B0C0-4A64-8ABA-5A1A62F2277F">自定义连接</a></p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
               </div><a id="JSQLJ197"></a><a id="JSQLJ198"></a><a id="JSQLJ196"></a><div class="props_rev_3"><a id="GUID-DFB81879-F28E-47FD-A419-67C647F34B04" name="GUID-DFB81879-F28E-47FD-A419-67C647F34B04"></a><h4 id="JSQLJ-GUID-DFB81879-F28E-47FD-A419-67C647F34B04" class="sect4">使用DefaultContext的单个连接或多个连接</h4>
                  <div>
                     <div class="section">
                        <p>本节讨论仅使用<code class="codeph">DefaultContext</code>类的连接实例的方案。
                        </p>
                        <p>如果您使用单个连接，或者使用具有相同名称和数据类型的SQL实体的多个连接，则这是典型的。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-DFB81879-F28E-47FD-A419-67C647F34B04__GUID-CAB8F78E-979A-4E9A-A762-87FC9C6CED60">单一连接</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>对于单个连接，在构造<code class="codeph">DefaultContext</code>对象时，使用<code class="codeph">DefaultContext</code>类的一个实例来指定数据库URL，用户名和密码。
                        </p>
                        <p>您可以使用<code class="codeph">oracle.sqlj.runtime.的<code class="codeph">connect()</code>方法<code class="codeph">oracle.sqlj.runtime.Oracle</code>类来实现这一目标。调用此方法会自动初始化默认连接上下文实例。此方法有几个签名，包括允许您直接或使用属性文件指定用户名，密码和URL的签名。在以下示例中，使用了属性文件<code class="codeph">connect.properties</code> ：</p><pre class="oac_no_warn" dir="ltr">Oracle.connect（ <span class="italic">MyClass。</span>类，“connect.properties”）;</pre><div class="infoboxnote" id="GUID-DFB81879-F28E-47FD-A419-67C647F34B04__GUID-1538380B-EB1D-4E27-BBF7-D4495EE5649F">
                           <p class="notep1">注意：</p>
                           <p>将针对指定的类搜索<code class="codeph">connect.properties</code>文件。在示例中，如果<code class="codeph">MyClass</code>位于<code class="codeph">my-package</code> ，则必须在相同的包位置<code class="codeph">my-package</code>找到<code class="codeph">connect.properties</code> 。
                           </p>
                        </div>
                        <p>如果使用<code class="codeph">connect.properties</code> ，则必须对其进行适当编辑并将其与应用程序打包在一起。在此示例中，您还必须导入<code class="codeph">oracle.sqlj.runtime.Oracle</code>类。
                        </p>
                        <p>或者，您可以直接指定用户名，密码和URL：</p><pre class="oac_no_warn" dir="ltr">Oracle.connect（“jdbc：oracle：thin：@localhost：5221 / myservice”，“HR”，“hr”）;</pre><p>在此示例中，连接将使用JDBC Thin驱动程序将<code class="codeph">HR</code>用户的密码<code class="codeph">hr</code>连接到计算机上的数据库<code class="codeph">localhost</code> ，通过端口<code class="codeph">5221</code> ，其中<code class="codeph">myservice</code>是连接的数据库服务的名称。
                        </p>
                        <p>这些示例中的任何一个都会创建<code class="codeph">DefaultContext</code>类的特殊静态实例，并将其安装为默认连接。没有必要直接对此<code class="codeph">DefaultContext</code>实例执行任何操作。
                        </p>
                        <p>完成这些步骤后，如果希望所有SQLJ可执行语句都使用默认连接，则无需为应用程序中的任何SQLJ可执行语句指定连接。</p>
                        <p>请注意，在使用JDBC Thin驱动程序时，URL必须包含主机名，端口号和服务名称（或SID，在Oracle Database 12 <span class="italic">c</span>第2版（12.2）中已弃用），如上例所示。此外，数据库必须具有在指定端口运行的侦听器。在使用JDBC OCI驱动程序时，如果您打算使用客户端的默认帐户，则不需要服务名称（或SID），本文档中的示例就是这种情况。或者，您可以使用名称 - 值对。
                        </p>
                        <div class="infoboxnotealso" id="GUID-DFB81879-F28E-47FD-A419-67C647F34B04__GUID-239303B2-1B6C-407E-9195-AE70FC1BCD24">
                           <p class="notep1">也可以看看：</p>
                           <p>有关更多信息，请<a href="../jjdbc/index.html" target="_blank"><span class="italic">参见Oracle数据库JDBC开发人员指南</span></a></p>
                        </div>
                        <p>以下URL将连接到客户端的默认帐户：</p><pre class="oac_no_warn" dir="ltr">JDBC：神谕：OCI：@</pre><div class="infoboxnote" id="GUID-DFB81879-F28E-47FD-A419-67C647F34B04__GUID-D9D7FD59-75EF-4B4A-9030-EAB1CA4614F9">
                           <p class="notep1">注意：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>如果已经设置了默认连接， <code class="codeph">Oracle.connect()</code>将不会设置默认连接。在这种情况下，它返回<code class="codeph">null</code> 。这使您可以在客户端或服务器中使用相同的代码。如果您确实要覆盖默认连接，请使用<code class="codeph">DefaultContext</code>的静态<code class="codeph">setDefaultContext()</code>方法。
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">Oracle.connect()</code>方法默认为自动提交标志的<code class="codeph">false</code>设置。但是，它也有签名来明确设置它。在Oracle JDBC实现中，自动提交标志默认为<code class="codeph">true</code> 。
                                 </p>
                              </li>
                              <li>
                                 <p>只要不从静态方法调用<code class="codeph">getClass()</code> ，就可以选择在<code class="codeph">Oracle.connect()</code>调用中指定<code class="codeph">getClass()</code>而不是<code class="codeph">MyClass.class</code> 。<code class="codeph">getClass()</code>方法用于某些SQLJ演示应用程序。
                                 </p>
                              </li>
                              <li>
                                 <p>您可以访问与默认连接对应的静态<code class="codeph">DefaultContext</code>实例，如下所示：</p><pre class="oac_no_warn" dir="ltr">DefaultContext.getDefaultContext（）;</pre></li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-DFB81879-F28E-47FD-A419-67C647F34B04__GUID-360EF2DC-8DD9-49F2-8043-A1FA225802C4">多个连接</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>对于多个连接，您可以创建和使用<code class="codeph">DefaultContext</code>类的其他实例，同时仍然可以使用默认连接。
                        </p>
                        <p>您可以使用<code class="codeph">Oracle.getConnection()</code>方法实例化<code class="codeph">DefaultContext</code> ，如以下示例所示。
                        </p>
                        <p>首先，考虑一种情况，您希望大多数语句使用默认连接，但其他语句使用不同的连接。您必须创建一个另外的<code class="codeph">DefaultContext</code>实例：</p><pre class="oac_no_warn" dir="ltr">DefaultContext ctx = Oracle.getConnection（“jdbc：oracle：thin：@ localhost2：5221 / myservice2”，“bill”，“lion”）;</pre><div class="infoboxnote" id="GUID-DFB81879-F28E-47FD-A419-67C647F34B04__GUID-DD65EDB6-69E3-498F-9859-3484B28F85B5">
                           <p class="notep1">注意：</p>
                           <p>如果要在同一模式上执行多组操作， <code class="codeph">ctx</code>也可以使用<code class="codeph">HR</code> / <code class="codeph">hr</code>模式。
                           </p>
                        </div>
                        <p>如果要使用默认连接，则无需指定连接上下文：</p><pre class="oac_no_warn" dir="ltr">#sql {SQL operation};</pre><p>这实际上是以下的快捷方式：</p><pre class="oac_no_warn" dir="ltr">#sql [DefaultContext.getDefaultContext（）] { <span class="italic">SQL operation</span> };</pre><p>如果要使用其他连接，请将<code class="codeph">ctx</code>指定为连接：</p><pre class="oac_no_warn" dir="ltr">#sql [ctx] { <span class="italic">SQL operation</span> };</pre><p>接下来，考虑要使用多个连接的情况，其中每个连接都是一个名为<code class="codeph">DefaultContext</code>实例。这使您可以来回切换连接。
                        </p>
                        <p>以下语句建立与同一模式的多个连接（例如，如果您要使用多个Oracle数据库会话或事务）。为您需要的每个连接实例化<code class="codeph">DefaultContext</code>类：</p><pre class="oac_no_warn" dir="ltr">DefaultContext ctx1 = Oracle.getConnection（“jdbc：oracle：thin：@ localhost1：5221 / myservice1”，“HR”，“hr”）; DefaultContext ctx2 = Oracle.getConnection（“jdbc：oracle：thin：@ localhost1：5221 / myservice1”，“HR”，“hr”）;</pre><p>这将创建两个连接上下文实例，这些实例将使用相同的模式，使用Oracle JDBC Thin驱动程序使用计算机<code class="codeph">localhost1</code>上的service <code class="codeph">myservice1</code>连接到<code class="codeph">HR/hr</code> 。
                        </p>
                        <p>现在，考虑一种情况，您希望多个连接到不同的模式。再次，为您需要的每个连接实例化<code class="codeph">DefaultContext</code>类：</p><pre class="oac_no_warn" dir="ltr">DefaultContext ctx1 = Oracle.getConnection（“jdbc：oracle：thin：@ localhost1：5221 / myservice1”，“HR”，“hr”）; DefaultContext ctx2 = Oracle.getConnection（“jdbc：oracle：thin：@ localhost2：5221 / myservice2”，“bill”，“lion”）;</pre><p>这将创建两个使用Oracle JDBC Thin驱动程序但使用不同模式的连接上下文实例。<code class="codeph">ctx1</code>对象使用计算机<code class="codeph">localhost1</code>上的service <code class="codeph">myservice1</code>连接到<code class="codeph">HR/hr</code> ，而<code class="codeph">ctx2</code>对象使用计算机<code class="codeph">localhost2</code>上的service <code class="codeph">myservice2</code>连接到<code class="codeph">bill/lion</code> 。
                        </p>
                        <p>对于应用程序中的SQLJ可执行语句，有两种方法可以在这些连接之间来回切换：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>如果频繁来回切换，则可以为应用程序中的每个语句指定连接：</p><pre class="oac_no_warn" dir="ltr">#sql [ctx1] { <span class="italic">SQL operation</span> }; ...#sql [ctx2] { <span class="italic">SQL operation</span> };</pre><div class="infoboxnote" id="GUID-DFB81879-F28E-47FD-A419-67C647F34B04__GUID-941D383C-4F97-484B-9D08-8E10638DD98F">
                                 <p class="notep1">注意：</p>
                                 <p>在连接上下文实例名称周围包括方括号;它们是语法的一部分。</p>
                              </div>
                           </li>
                           <li>
                              <p><a id="d8416e911" class="indexterm-anchor"></a>如果在代码流中连续多次使用其中一个连接，则可以定期使用<code class="codeph">DefaultContext</code>类的静态<code class="codeph">setDefaultContext()</code>方法重置默认连接。此方法初始化默认连接上下文实例。这样，您可以避免在SQLJ语句中指定连接。
                              </p><pre class="oac_no_warn" dir="ltr">DefaultContext.setDefaultContext（CTX1）; #sql { <span class="italic">SQL operation</span> }; //这三个语句都使用ctx1 #sql { <span class="italic">SQL operation</span> }; #sql { <span class="italic">SQL operation</span> }; ...DefaultContext.setDefaultContext（ctx2）; #sql { <span class="italic">SQL operation</span> }; //这三个语句都使用ctx2 #sql { <span class="italic">SQL operation</span> }; #sql { <span class="italic">SQL operation</span> };</pre><div class="infoboxnote" id="GUID-DFB81879-F28E-47FD-A419-67C647F34B04__GUID-0FAC9209-D1B8-4BC2-94A1-8A760FBBEC61">
                                 <p class="notep1">注意：</p>
                                 <p>因为前面的语句没有指定连接上下文，所以在转换时它们都将根据默认连接上下文进行检查。</p>
                              </div>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ199"></a><div class="props_rev_3"><a id="GUID-B255B6E1-449E-4FE1-ACFE-6FCD2AFCFBDC" name="GUID-B255B6E1-449E-4FE1-ACFE-6FCD2AFCFBDC"></a><h4 id="JSQLJ-GUID-B255B6E1-449E-4FE1-ACFE-6FCD2AFCFBDC" class="sect4">关闭连接</h4>
                  <div>
                     <div class="section">
                        <p>建议在完成后关闭连接上下文实例，最好是在<code class="codeph">try</code>块的<code class="codeph">finally</code>子句中（如果应用程序以异常终止）。
                        </p>
                        <p><code class="codeph">DefaultContext</code>类以及您声明的任何连接上下文类都包含<code class="codeph">close()</code>方法。调用此方法将关闭SQLJ连接上下文实例，并且默认情况下还会关闭基础JDBC连接实例和物理连接。
                        </p>
                        <p>另外，还有<code class="codeph">oracle.sqlj.runtime.Oracle</code>类有一个静态<code class="codeph">close()</code>方法来关闭默认连接。在以下示例中，假定<code class="codeph">ctx</code>是任何连接上下文类的实例：</p><pre class="oac_no_warn" dir="ltr">...终于{ctx.close（）; } ...
</pre><p>或者，如果遇到SQL异常， <code class="codeph">finally</code>子句不在<code class="codeph">try</code>块中：</p><pre class="oac_no_warn" dir="ltr">...终于{try {ctx.close（）; } catch（SQLException ex）{...}} ...
</pre><p>或者，要关闭默认连接， <code class="codeph">Oracle</code>类还提供<code class="codeph">close()</code>方法：</p><pre class="oac_no_warn" dir="ltr">...终于{Oracle.close（）; } ...
</pre><p>在关闭连接之前，始终提交或回滚任何挂起的更改。JDBC标准中未指定是否存在隐式<code class="codeph">COMMIT</code>操作，因为连接已关闭，并且可能因供应商而异。对于Oracle，在连接关闭时存在隐式<code class="codeph">COMMIT</code> ，在连接被垃圾收集而未关闭时存在隐式<code class="codeph">ROLLBACK</code> ，但不建议依赖这些机制。
                        </p>
                        <div class="infoboxnote" id="GUID-B255B6E1-449E-4FE1-ACFE-6FCD2AFCFBDC__GUID-BF05E52D-85EA-47C4-BE04-19E3462E53F3">
                           <p class="notep1">注意：</p>
                           <p>也可以在不关闭底层连接的情况下关闭连接上下文实例（如果共享底层连接）。</p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ200"></a><div class="props_rev_3"><a id="GUID-9B855A2A-CAB3-43E2-BE27-E7E5F239B73C" name="GUID-9B855A2A-CAB3-43E2-BE27-E7E5F239B73C"></a><h4 id="JSQLJ-GUID-9B855A2A-CAB3-43E2-BE27-E7E5F239B73C" class="sect4">使用声明的连接上下文类的多个连接</h4>
                  <div>
                     <p>对于使用不同SQL实体集的多个连接，使用连接上下文声明来定义其他连接上下文类是有利的。为您使用的每组SQL实体提供单独的连接上下文类使SQLJ能够对代码执行更严格的语义检查。</p>
                     <div class="infoboxnotealso" id="GUID-9B855A2A-CAB3-43E2-BE27-E7E5F239B73C__GUID-4C96E253-DC1D-45CC-AC30-287DE4463D1B">
                        <p class="notep1">也可以看看：</p>
                        <p><span class="q">“ <a href="advanced-language-features.html#GUID-DE7D99A8-ED65-4DEA-B274-3BC09EE0056A">连接上下文</a> ”</span></p>
                     </div>
                  </div>
               </div><a id="JSQLJ202"></a><a id="JSQLJ203"></a><a id="JSQLJ201"></a><div class="props_rev_3"><a id="GUID-5838209F-A715-4935-AD3F-7EFDD5CE4BF3" name="GUID-5838209F-A715-4935-AD3F-7EFDD5CE4BF3"></a><h4 id="JSQLJ-GUID-5838209F-A715-4935-AD3F-7EFDD5CE4BF3" class="sect4">有关Oracle类的更多信息</h4>
                  <div>
                     <p>Oracle SQLJ实现提供了<code class="codeph">oracle.sqlj.runtime.Oracle</code>类简化了创建和使用<code class="codeph">DefaultContext</code>类实例的过程。
                     </p>
                     <p>static <code class="codeph">connect()</code>方法初始化默认连接上下文实例，实例化<code class="codeph">DefaultContext</code>对象并将其安装为默认连接。您不需要分配或使用<code class="codeph">connect()</code>返回的<code class="codeph">DefaultContext</code>实例。如果您已经建立了默认连接，则<code class="codeph">connect()</code>返回<code class="codeph">null</code> 。
                     </p>
                     <p>静态<code class="codeph">getConnection()</code>方法只是实例化一个<code class="codeph">DefaultContext</code>对象并返回它。您可以根据需要使用返回的实例。
                     </p>
                     <p>如果是<code class="codeph">oracle.jdbc.这两种方法都会自动注册Oracle JDBC驱动程序管理器<code class="codeph">oracle.jdbc.OracleDriver</code>类位于<code class="codeph">CLASSPATH</code> 。静态<code class="codeph">close()</code>方法关闭默认连接。
                     </p>
                     <div class="section">
                        <p class="subhead3" id="GUID-5838209F-A715-4935-AD3F-7EFDD5CE4BF3__GUID-2A842A7A-1D3A-4035-983E-0BC7DF3ED3E6">Oracle.connect（）和Oracle.getConnection（）方法的签名</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>这两种方法都有签名，将以下参数集作为输入：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>URL（ <code class="codeph">String</code> ），用户名（ <code class="codeph">String</code> ），密码（ <code class="codeph">String</code> ）</p>
                           </li>
                           <li>
                              <p>URL（ <code class="codeph">String</code> ），用户名（ <code class="codeph">String</code> ），密码（ <code class="codeph">String</code> ），自动提交标志（ <code class="codeph">boolean</code> ）</p>
                           </li>
                           <li>
                              <p>URL（ <code class="codeph">String</code> ）， <code class="codeph">java.util.包含连接Properties</code>对象</p>
                           </li>
                           <li>
                              <p>URL（ <code class="codeph">String</code> ）， <code class="codeph">java.util.Properties</code>对象，自动提交标志（ <code class="codeph">boolean</code> ）</p>
                           </li>
                           <li>
                              <p>URL（ <code class="codeph">String</code> ）完全指定连接，包括用户名和密码</p>
                              <p>以下是使用Oracle JDBC驱动程序（在本例中为JDBC Thin驱动程序）中指定用户名（ <code class="codeph">HR</code> ）和密码（ <code class="codeph">hr</code> ）的URL字符串格式的示例：</p><pre class="oac_no_warn" dir="ltr">“JDBC：预言：瘦：HR /小时@本地：5221 /为MyService”</pre></li>
                           <li>
                              <p>URL（ <code class="codeph">String</code> ），自动提交标志（ <code class="codeph">boolean</code> ）</p>
                           </li>
                           <li>
                              <p>一个<code class="codeph">java.lang.与属性文件相关的类的Class</code>对象，属性文件名（ <code class="codeph">String</code> ）</p>
                           </li>
                           <li>
                              <p>一个<code class="codeph">java.lang.Class</code>对象，属性文件名（ <code class="codeph">String</code> ），自动提交标志（ <code class="codeph">boolean</code> ）</p>
                           </li>
                           <li>
                              <p>一个<code class="codeph">java.lang.Class</code>对象，属性文件名（ <code class="codeph">String</code> ），用户名（ <code class="codeph">String</code> ），密码（ <code class="codeph">String</code> ）</p>
                           </li>
                           <li>
                              <p>一个<code class="codeph">java.lang.Class</code>对象，属性文件名（ <code class="codeph">String</code> ），用户名（ <code class="codeph">String</code> ），密码（ <code class="codeph">String</code> ），自动提交标志（ <code class="codeph">boolean</code> ）</p>
                           </li>
                           <li>
                              <p>JDBC连接对象（ <code class="codeph">Connection</code> ）</p>
                           </li>
                           <li>
                              <p>SQLJ连接上下文对象</p>
                           </li>
                        </ul>
                        <p>最后两个签名继承了现有的数据库连接。继承连接时，还将继承该连接的自动提交设置。</p>
                        <p>auto-commit标志指定是否自动提交SQL操作。仅对于<code class="codeph">Oracle.connect()</code>和<code class="codeph">Oracle.getConnection()</code>方法，默认值为<code class="codeph">false</code> 。如果这是您想要的设置，那么您可以使用其中一个不将自动提交作为输入的签名。但是，只要使用构造函数创建连接上下文类的实例（包括<code class="codeph">DefaultContext</code> ，就必须指定自动提交设置。在Oracle JDBC实现中，auto-commit标志的缺省值为<code class="codeph">true</code> 。
                        </p>
                        <div class="infoboxnotealso" id="GUID-5838209F-A715-4935-AD3F-7EFDD5CE4BF3__GUID-689BBE2A-7AB8-4A1A-A555-4EE8D623282C">
                           <p class="notep1">也可以看看：</p>
                           <p><span class="q">“ <a href="key-programming-considerations.html#GUID-6F37BE89-6EA0-4B27-884A-C0D4E8746E97">基本事务控制</a> ”</span>和<span class="q">“ <a href="key-programming-considerations.html#GUID-DFB81879-F28E-47FD-A419-67C647F34B04">使用DefaultContext的单个连接或多个连接</a> ”</span></p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-5838209F-A715-4935-AD3F-7EFDD5CE4BF3__GUID-5D0E0DC9-96FD-4A4F-9725-6101B8F40301">可选的Oracle.close（）方法参数</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>在使用<code class="codeph">Oracle.close()</code>方法关闭默认连接时，您可以选择是否关闭基础物理数据库连接。默认情况下它已关闭。如果要在多个连接对象（SQLJ连接上下文实例或JDBC连接实例）之间共享此物理连接，则这是相关的。
                        </p>
                        <p>您可以按如下方式打开底层物理连接：</p><pre class="oac_no_warn" dir="ltr">Oracle.close（ConnectionContext。KEEP_CONNECTION）;</pre><p>您可以按如下方式关闭基础物理连接（默认行为）：</p><pre class="oac_no_warn" dir="ltr">Oracle.close（ConnectionContext。CLOSE_CONNECTION）;</pre><p><code class="codeph">KEEP_CONNECTION</code>和<code class="codeph">CLOSE_CONNECTION</code>是<code class="codeph">ConnectionContext</code>接口的静态常量。
                        </p>
                        <div class="infoboxnotealso" id="GUID-5838209F-A715-4935-AD3F-7EFDD5CE4BF3__GUID-6F98EB3E-0104-4BB8-A125-32483ED5F168">
                           <p class="notep1">也可以看看：</p>
                           <p><span class="q">“ <a href="advanced-language-features.html#GUID-340AFCEF-E421-46F9-B136-DF9CC3723310__I1007208">关闭共享连接</a> ”</span></p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ205"></a><a id="JSQLJ206"></a><a id="JSQLJ207"></a><a id="JSQLJ208"></a><a id="JSQLJ204"></a><div class="props_rev_3"><a id="GUID-8D05EAA4-E034-495C-A74D-EFEF9778ABC1" name="GUID-8D05EAA4-E034-495C-A74D-EFEF9778ABC1"></a><h4 id="JSQLJ-GUID-8D05EAA4-E034-495C-A74D-EFEF9778ABC1" class="sect4">有关DefaultContext类的更多信息</h4>
                  <div>
                     <p><code class="codeph">sqlj.runtime.ref.DefaultContext</code>类提供连接上下文类的完整默认实现。与使用连接上下文声明创建的类一样， <code class="codeph">DefaultContext</code>类实现<code class="codeph">sqlj.runtime.ConnectionContext</code>接口。<code class="codeph">DefaultContext</code>类具有与SQLJ转换器从声明生成的相同的类定义：</p><pre class="oac_no_warn" dir="ltr">#sql public context DefaultContext;</pre><div class="section">
                        <p class="subhead3" id="GUID-8D05EAA4-E034-495C-A74D-EFEF9778ABC1__GUID-25464FBB-2DDE-4500-BC25-40245AABB2E1">DefaultContext方法</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>以下是<code class="codeph">DefaultContext</code>类的关键方法：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">的getConnection（）</code></p>
                              <p>获取基础JDBC连接对象。如果要在应用程序中使用JDBC代码，这很有用，这是使用动态SQL操作的一种方法。您还可以使用基础JDBC连接对象的<code class="codeph">setAutoCommit()</code>方法为连接设置自动提交标志。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">setDefaultContext（）</code></p>
                              <p>设置应用程序使用的默认连接。这是一个<code class="codeph">static</code>方法，并将<code class="codeph">DefaultContext</code>实例作为输入。未指定连接上下文实例的SQLJ可执行语句将使用您使用此方法或<code class="codeph">Oracle.connect()</code>方法定义的默认连接。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">getDefaultContext（）</code></p>
                              <p>返回当前定义为应用程序的默认连接的<code class="codeph">DefaultContext</code>实例。这是一种<code class="codeph">static</code>方法。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">关（）</code></p>
                              <p>关闭连接上下文实例。</p>
                           </li>
                        </ul>
                        <p><code class="codeph">getConnection()</code>和<code class="codeph">close()</code>方法在<code class="codeph">sqlj.runtime.中指定<code class="codeph">sqlj.runtime.ConnectionContext</code>接口。
                        </p>
                        <div class="infoboxnote" id="GUID-8D05EAA4-E034-495C-A74D-EFEF9778ABC1__GUID-CCFD9BDD-2276-4964-BB1D-ECF47B0FCBEE">
                           <p class="notep1">注意：</p>
                           <p>在客户端上，如果先前未调用<code class="codeph">setDefaultContext()</code> ，则<code class="codeph">getDefaultContext()</code>将返回<code class="codeph">null</code> 。但是，如果数据源对象已绑定在JNDI中的“ <code class="codeph">jdbc/defaultDataSource</code> ”下，则客户端将使用此数据源对象作为其默认连接。
                           </p>
                           <p>在服务器中， <code class="codeph">getDefaultContext()</code>返回默认连接，即与服务器本身的连接。
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-8D05EAA4-E034-495C-A74D-EFEF9778ABC1__GUID-2CF45392-2A16-4135-A3C4-B487253B0855">DefaultContext构造函数</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>通常使用<code class="codeph">Oracle.connect()</code>或<code class="codeph">Oracle.getConnection()</code>方法实例化<code class="codeph">DefaultContext</code> 。但是，如果要直接创建实例，则<code class="codeph">DefaultContext</code>有五个构造函数。这些构造函数的不同输入参数集是：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>URL（ <code class="codeph">String</code> ），用户名（ <code class="codeph">String</code> ），密码（ <code class="codeph">String</code> ），自动提交（ <code class="codeph">boolean</code> ）</p>
                           </li>
                           <li>
                              <p>URL（ <code class="codeph">String</code> ）， <code class="codeph">java.util.Properties</code>对象，自动提交（ <code class="codeph">boolean</code> ）</p>
                           </li>
                           <li>
                              <p>URL（完全指定连接并包括用户名和密码的<code class="codeph">String</code> ），自动提交设置（ <code class="codeph">boolean</code> ）</p>
                              <p>以下是使用Oracle JDBC驱动程序时指定用户名和密码的URL格式示例，在本例中为JDBC Thin驱动程序：</p><pre class="oac_no_warn" dir="ltr">“JDBC：预言：瘦：HR /小时@本地：5221 /为MyService”</pre></li>
                           <li>
                              <p>JDBC连接对象（ <code class="codeph">Connection</code> ）</p>
                           </li>
                           <li>
                              <p>SQLJ连接上下文对象</p>
                           </li>
                        </ul>
                        <p>最后两个签名继承现有的数据库连接。继承连接时，还将继承该连接的自动提交设置。</p>
                        <p>以下是构造<code class="codeph">DefaultContext</code>实例的示例：</p><pre class="oac_no_warn" dir="ltr">DefaultContext defctx = new DefaultContext（“jdbc：oracle：thin：@localhost：5221 / myservice”，“HR”，“hr”，false）;</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-8D05EAA4-E034-495C-A74D-EFEF9778ABC1__GUID-24500EC5-B80A-49E7-BA9C-6970578E2571">关于连接上下文构造函数的说明：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <div class="infoboxnote" id="GUID-8D05EAA4-E034-495C-A74D-EFEF9778ABC1__GUID-67FF6542-92B2-4197-AF33-E0E24CEA3820">
                           <p class="notep1">注意：</p>
                           <p>使用连接上下文构造函数时，必须牢记以下几点：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>值得注意的是，与<code class="codeph">Oracle.connect()</code>方法不同，连接上下文类构造函数需要自动提交设置。
                                 </p>
                              </li>
                              <li>
                                 <p>要使用列出的前三个构造函数中的任何一个，必须首先注册JDBC驱动程序。如果您使用的是Oracle JDBC驱动程序并调用<code class="codeph">Oracle.connect()</code>则会自动执行此操作。请参阅<span class="q">“ <a href="key-programming-considerations.html#GUID-EDC7B103-DC71-490F-BF36-9FD95B155425">运行时选择和注册</a> ”</span> 。
                                 </p>
                              </li>
                              <li>
                                 <p>您声明的连接上下文类通常具有与<code class="codeph">DefaultContext</code>类相同的构造函数签名。但是，如果声明要与数据源关联的连接上下文类，则会提供一组不同的构造函数。有关更多信息，请参阅<span class="q">“ <a href="advanced-language-features.html#GUID-BBB6A8DE-EEF3-454B-BF98-C12E32A81314">标准数据源支持</a> ”</span> 。
                                 </p>
                              </li>
                              <li>
                                 <p>使用带有JDBC连接对象的构造函数时，请不要使用空JDBC连接初始化连接上下文实例。</p>
                              </li>
                              <li>
                                 <p>自动提交设置确定是否自动提交SQL操作。有关更多信息，请参阅<span class="q">“ <a href="key-programming-considerations.html#GUID-6F37BE89-6EA0-4B27-884A-C0D4E8746E97">基本事务控制</a> ”</span> 。
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-8D05EAA4-E034-495C-A74D-EFEF9778ABC1__GUID-18CADC75-479F-4BFD-BAD0-0C0F39097EA7">可选的DefaultContext close（）方法参数</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>关闭连接上下文实例时，可以选择是否关闭基础物理连接。默认情况下它已关闭。如果要共享多个连接对象（SQLJ连接上下文实例或JDBC连接实例）之间的物理连接，则这是相关的。以下示例假定<code class="codeph">DefaultContext</code>实例<code class="codeph">defctx</code> 。
                        </p>
                        <p>要保持底层物理连接处于打开状态，请使用以下命令：</p><pre class="oac_no_warn" dir="ltr">defctx.close（ConnectionContext。KEEP_CONNECTION）;</pre><p>要关闭底层物理连接（默认行为），请使用以下命令：</p><pre class="oac_no_warn" dir="ltr">defctx.close（ConnectionContext。CLOSE_CONNECTION）;</pre><p><code class="codeph">KEEP_CONNECTION</code>和<code class="codeph">CLOSE_CONNECTION</code>是<code class="codeph">ConnectionContext</code>接口的静态常量。
                        </p>
                        <div class="infoboxnotealso" id="GUID-8D05EAA4-E034-495C-A74D-EFEF9778ABC1__GUID-C4CF2F07-5C8F-4416-A97C-F98EB2D58703">
                           <p class="notep1">也可以看看：</p>
                           <p><span class="q">“ <a href="advanced-language-features.html#GUID-340AFCEF-E421-46F9-B136-DF9CC3723310__I1007208">关闭共享连接</a> ”</span>以获取有关使用这些参数和共享连接的更多信息</p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ209"></a><div class="props_rev_3"><a id="GUID-2867AB26-AF5A-4336-AD57-3247E0A44DB9" name="GUID-2867AB26-AF5A-4336-AD57-3247E0A44DB9"></a><h4 id="JSQLJ-GUID-2867AB26-AF5A-4336-AD57-3247E0A44DB9" class="sect4">翻译连接</h4>
                  <div>
                     <div class="section">
                        <p>如果要在转换期间使用联机语义检查，则必须为SQLJ指定要使用的数据库连接。这些被称为<span class="bold">示例模式</span> 。
                        </p>
                        <div class="infoboxnotealso" id="GUID-2867AB26-AF5A-4336-AD57-3247E0A44DB9__GUID-E1F28580-BDC0-4D47-A236-454914D10875">
                           <p class="notep1">也可以看看：</p>
                           <p><span class="q">“ <a href="advanced-language-features.html#GUID-7756F849-1D32-4AEC-9D2E-C14F344F0E8E">连接上下文概念</a> ”</span></p>
                        </div>
                        <p>您可以使用不同的连接进行翻译和运行。事实上，这样做通常是必要的或者更可取的。如果您不在与其运行的相同类型的环境中开发应用程序，则可能是必要的。但即使在翻译期间可以使用运行时连接，也可能最好创建一个资源较少的帐户，以便您的在线检查更紧密。如果您的应用程序仅使用运行时连接中可用的一小部分SQL实体，则会出现这种情况。如果您创建仅包含应用程序实际使用的SQL实体的示例模式，那么您的在线检查将更紧凑，更有意义。</p>
                        <p>在命令行或属性文件中使用SQLJ转换程序连接选项指定转换连接。</p>
                        <div class="infoboxnotealso" id="GUID-2867AB26-AF5A-4336-AD57-3247E0A44DB9__GUID-ACC8594B-D41F-4C5A-9EA5-FF8ADCC4C17F">
                           <p class="notep1">也可以看看：</p>
                           <p><span class="q">“ <a href="translator-command-line-and-options.html#GUID-E001FA35-824A-47A1-8973-AA5771B0DFE5">连接选项</a> ”</span></p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ210"></a><div class="props_rev_3"><a id="GUID-7D345B91-B0C0-4A64-8ABA-5A1A62F2277F" name="GUID-7D345B91-B0C0-4A64-8ABA-5A1A62F2277F"></a><h4 id="JSQLJ-GUID-7D345B91-B0C0-4A64-8ABA-5A1A62F2277F" class="sect4">自定义连接</h4>
                  <div>
                     <p>通常，Oracle自定义不需要数据库连接。但是，Oracle SQLJ实现确实支持自定义程序连接。这在两种情况下很有用：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>如果您在启用了<code class="codeph">optcols</code>选项的情况下使用Oracle自定义程序，则需要连接。此选项允许使用迭代器列类型和大小定义来进行性能优化。
                           </p>
                        </li>
                        <li>
                           <p>如果您正在使用<code class="codeph">SQLCheckerCustomizer</code> ，一个对配置文件执行语义检查的专用定制程序，那么如果您使用在线检查程序则需要连接，默认情况下为true。
                           </p>
                        </li>
                     </ul>
                     <p>对于特定于Oracle的代码生成，SQLJ转换器具有<code class="codeph">-optcols</code>选项，具有相同的功能。通过Oracle customizer harness <code class="codeph">verify</code>选项调用<code class="codeph">SQLCheckerCustomizer</code> 。根据需要，使用自定义程序线束<code class="codeph">user</code> ， <code class="codeph">password</code> ， <code class="codeph">url</code>和<code class="codeph">driver</code>选项为您正在使用的任何自定义<code class="codeph">driver</code>指定连接参数。
                     </p>
                     <div class="infoboxnotealso" id="GUID-7D345B91-B0C0-4A64-8ABA-5A1A62F2277F__GUID-6DF2B38E-33C0-43AE-8FF4-03192A23E2B5">
                        <p class="notep1">也可以看看：</p>
                        <p></p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><span class="q">“ <a href="appendix.html#GUID-B2FDCFA4-3938-417B-BD40-4A9EAB8DB4FA">Oracle Customizer列定义选项（optcols）</a> ”</span> 。
                              </p>
                           </li>
                           <li>
                              <p><span class="q">“ <a href="appendix.html#GUID-B0B2AAD4-3AE2-43F1-A38E-37D48343C353">SQLCheckerCustomizer for Profile Semantics-Checking</a> ”</span></p>
                           </li>
                           <li>
                              <p><span class="q">“ <a href="appendix.html#GUID-C5D50F74-E805-4DDA-AC81-353C94C40A21">连接的定制器线束选项</a> ”</span></p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div>
            </div><a id="JSQLJ211"></a><div class="props_rev_3"><a id="GUID-EA345D88-D2AE-4118-986A-472764A6E1A4" name="GUID-EA345D88-D2AE-4118-986A-472764A6E1A4"></a><h3 id="JSQLJ-GUID-EA345D88-D2AE-4118-986A-472764A6E1A4" class="sect3">NULL处理</h3>
               <div>
                  <p>Java原始类型（如<code class="codeph">int</code> ， <code class="codeph">double</code>或<code class="codeph">float</code> ）不能具有空值。在选择结果表达式和宿主表达式类型时必须考虑这一点。
                  </p>
                  <p>本节包括以下主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="key-programming-considerations.html#GUID-0C865EA3-6881-46EA-AD86-7491F19494B2">用于NULL处理的包装类</a></p>
                     </li>
                     <li>
                        <p><a href="key-programming-considerations.html#GUID-70958B5D-E010-4C42-9F1C-297B398DC938">NULL处理的示例</a></p>
                     </li>
                  </ul>
               </div><a id="JSQLJ212"></a><div class="props_rev_3"><a id="GUID-0C865EA3-6881-46EA-AD86-7491F19494B2" name="GUID-0C865EA3-6881-46EA-AD86-7491F19494B2"></a><h4 id="JSQLJ-GUID-0C865EA3-6881-46EA-AD86-7491F19494B2" class="sect4">用于NULL处理的包装类</h4>
                  <div>
                     <p>与JDBC相比，SQLJ始终强制检索SQL <code class="codeph">NULL</code>为Java <code class="codeph">null</code> ，而JDBC对于某些数据类型检索<code class="codeph">NULL</code>为<code class="codeph">0</code>或<code class="codeph">false</code> 。因此，在可能接收到SQL <code class="codeph">NULL</code>情况下，不要在SQLJ中使用Java原语类型作为输出变量，因为Java原语类型不能采用<code class="codeph">null</code>值。
                     </p>
                     <p>这与结果表达式，输出或输入输出主机表达式以及迭代器列类型有关。如果接收Java类型是原始的并且尝试检索SQL <code class="codeph">NULL</code> ， <code class="codeph">sqlj.runtime.抛出SQLNullException</code>并且不进行任何赋值。
                     </p>
                     <p>要避免将<code class="codeph">NULL</code>分配给Java原语的可能性，请使用以下包装类而不是基本类型：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">java.lang中。布尔</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">java.lang中。字节</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">java.lang中。短</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">java.lang中。整数</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">java.lang中。长</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">java.lang中。双</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">java.lang中。浮动</code></p>
                        </li>
                     </ul>
                     <p>如果必须转换回原始值，则每个包装类都有一个<span class="italic"><code class="codeph">xxx</code></span> <code class="codeph">Value()</code>方法。例如， <code class="codeph">intValue()</code>从<code class="codeph">Integer</code>对象返回一个<code class="codeph">int</code>值， <code class="codeph">floatValue()</code>从<code class="codeph">Float</code>对象返回一个<code class="codeph">float</code>值。例如，假设<code class="codeph">intobj</code>是一个<code class="codeph">Integer</code>对象：</p><pre class="oac_no_warn" dir="ltr">int j = intobj.intValue（）;</pre><div class="infoboxnote" id="GUID-0C865EA3-6881-46EA-AD86-7491F19494B2__GUID-4BBAB10B-14C1-4CA9-9F66-8DF0F805C0CF">
                        <p class="notep1">注意：</p>
                        <p></p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">SQLNullException</code>是标准<code class="codeph">java.sql.的子类<code class="codeph">java.sql.SQLException</code>类。
                              </p>
                           </li>
                           <li>
                              <p>因为Java对象可以具有<code class="codeph">null</code>值，所以SQLJ中不需要指示符变量，例如在C，C ++和COBOL等其他主机语言中使用的变量。</p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="JSQLJ214"></a><a id="JSQLJ215"></a><a id="JSQLJ213"></a><div class="props_rev_3"><a id="GUID-70958B5D-E010-4C42-9F1C-297B398DC938" name="GUID-70958B5D-E010-4C42-9F1C-297B398DC938"></a><h4 id="JSQLJ-GUID-70958B5D-E010-4C42-9F1C-297B398DC938" class="sect4">NULL处理的示例</h4>
                  <div>
                     <div class="section">
                        <p>以下示例显示了使用<code class="codeph">java.lang</code>包装类来处理<code class="codeph">NULL</code> 。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-70958B5D-E010-4C42-9F1C-297B398DC938__GUID-D58FBB6E-B849-4332-978A-FA2E83C8EB6F">示例：空输入主机变量</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>在以下示例中， <code class="codeph">Float</code>对象用于将<code class="codeph">null</code>值传递给数据库：</p><pre class="oac_no_warn" dir="ltr">int empno = 7499;浮动佣金= null; #sql {UPDATE employees SET commission_pct =：Commission WHERE employee_id =：empno};</pre><p>您不能使用Java基元类型<code class="codeph">float</code>来完成此任务。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-70958B5D-E010-4C42-9F1C-297B398DC938__GUID-A34344DF-B5C8-4B64-8B18-C621DC17FD84">示例：Null Iterator行</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>在以下示例中，在迭代器中使用<code class="codeph">Double</code>列类型以允许<code class="codeph">null</code>数据的可能性。
                        </p>
                        <p>对于<code class="codeph">employee</code>表中薪水至少为50,000美元的每个员工，将在迭代器中选择员工姓名（ <code class="codeph">FIRST_NAME</code> ）和佣金（ <code class="codeph">COMMISSION_PCT</code> ）。然后测试每一行以确定<code class="codeph">COMMISSION_PCT</code>字段实际上是否为空。如果是，则相应地进行处理。
                        </p><pre class="oac_no_warn" dir="ltr">#sql iterator EmployeeIter（String first_name，Double commission）; EmployeeIter ei; #sql ei = {SELECT first_name，commission_pct FROM employees WHERE salary&gt; = 50000}; while（ei.next（））{if（ei.commission_pct（）== null）System.out.println（ei.first_name（）+“不在委托中。”）; } ei.close（）; ...
</pre><div class="infoboxnote" id="GUID-70958B5D-E010-4C42-9F1C-297B398DC938__GUID-3B97D3EA-0F0A-442A-B3FF-81DE6E8BA14F">
                           <p class="notep1">注意：</p>
                           <p>要对<code class="codeph">NULL</code>执行<code class="codeph">WHERE</code>子句比较，请使用以下SQL语法：</p><pre class="oac_no_warn" dir="ltr">...WHERE：x IS NULL</pre></div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="JSQLJ216"></a><div class="props_rev_3"><a id="GUID-10C3A27F-878A-468D-BC78-D9DC8A2079A0" name="GUID-10C3A27F-878A-468D-BC78-D9DC8A2079A0"></a><h3 id="JSQLJ-GUID-10C3A27F-878A-468D-BC78-D9DC8A2079A0" class="sect3">异常处理基础知识</h3>
               <div>
                  <p>本节介绍在SQLJ应用程序中处理异常的基础知识，包括错误检查的要求。本节包括以下主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="key-programming-considerations.html#GUID-8CF5EB2B-8FC1-47DC-BE4C-A9FDCA448A8E">SQLJ和JDBC异常处理要求</a></p>
                     </li>
                     <li>
                        <p><a href="key-programming-considerations.html#GUID-889158EE-29C1-4F10-A955-B94801353C67">处理例外</a></p>
                     </li>
                     <li>
                        <p><a href="key-programming-considerations.html#GUID-9EA4834A-717F-4177-9901-418F806A8EC2">使用SQLException子类</a></p>
                     </li>
                  </ul>
               </div><a id="JSQLJ218"></a><a id="JSQLJ217"></a><div class="props_rev_3"><a id="GUID-8CF5EB2B-8FC1-47DC-BE4C-A9FDCA448A8E" name="GUID-8CF5EB2B-8FC1-47DC-BE4C-A9FDCA448A8E"></a><h4 id="JSQLJ-GUID-8CF5EB2B-8FC1-47DC-BE4C-A9FDCA448A8E" class="sect4">SQLJ和JDBC异常处理要求</h4>
                  <div>
                     <p>因为SQLJ可执行语句通过<code class="codeph">sqlj.runtime</code>导致JDBC调用，并且JDBC需要捕获或抛出SQL异常，所以SQLJ还要求在包含SQLJ可执行语句的任何块中捕获或抛出SQL异常。如果不包含适当的异常处理，则源代码将在编译期间生成错误。
                     </p>
                     <p>处理SQL异常需要<code class="codeph">SQLException</code>类，该类包含在标准JDBC <code class="codeph">java.sql.*</code>包中。
                     </p>
                     <div class="section">
                        <p class="subhead3" id="GUID-8CF5EB2B-8FC1-47DC-BE4C-A9FDCA448A8E__GUID-8346C744-1111-4D9D-980A-042A53812C71">示例：异常处理</p>
                     </div>
                     <!-- class="section" -->
                     <p>此示例演示SQLJ应用程序中所需的基本异常处理。该代码使用<code class="codeph">try/catch</code>块和另一个方法声明一个<code class="codeph">main</code>方法，该方法在遇到异常时抛出<code class="codeph">SQLException</code> 。代码如下：</p><pre class="oac_no_warn" dir="ltr">/ *导入SQLExceptions类。SQLException来自JDBC。可执行的#sql子句导致对JDBC的调用，因此包含可执行的#sql子句的方法必须捕获或抛出SQLException。* / import java.sql。*; import oracle.sqlj.runtime。甲骨文; //选择#sql迭代器MyIter（String ITEM_NAME）的迭代器; public class TestInstallSQLJ {//主方法public static void main（String args []）{try {//设置在connect.properties文件中指定的URL，用户和密码的默认连接Oracle.connect（TestInstallSQLJ。 class，“connect.properties”）; TestInstallSQLJ ti = new TestInstallSQLJ（）; //此方法抛出SQLException。因此，它在try块中调用了ti.runExample（）; } catch（SQLException e）{System.err.println（“运行示例时出错：”+ e）; //方法的结束main //运行示例的方法void runExample（）抛出SQLException {//发出SQL命令以清除SALES表#sql {DELETE FROM SALES}; #sql {INSERT INTO SALES（ITEM_NAME）VALUES（'你好，SQLJ！“）}; MyIter iter; #sql iter = {SELECT ITEM_NAME FROM SALES}; while（iter.next（））{System.out.println（iter。项目名称（））; }}}</pre></div>
               </div><a id="JSQLJ220"></a><a id="JSQLJ221"></a><a id="JSQLJ219"></a><div class="props_rev_3"><a id="GUID-889158EE-29C1-4F10-A955-B94801353C67" name="GUID-889158EE-29C1-4F10-A955-B94801353C67"></a><h4 id="JSQLJ-GUID-889158EE-29C1-4F10-A955-B94801353C67" class="sect4">处理例外</h4>
                  <div>
                     <div class="section">
                        <p>本节讨论在SQLJ应用程序中处理和解释异常的方法。在运行时，可能会出现以下任何异常：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p>SQLJ运行时</p>
                           </li>
                           <li>
                              <p>JDBC驱动程序</p>
                           </li>
                           <li>
                              <p>RDBMS</p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-889158EE-29C1-4F10-A955-B94801353C67__GUID-9468E406-CE40-426E-BDAF-FBE5D18837E9">打印错误文本</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>上一节中的示例显示了如何捕获SQL异常并输出错误消息。部分代码如下：</p><pre class="oac_no_warn" dir="ltr">...尝试{...} catch（SQLException e）{System.err.println（“运行示例时出错：”+ e）; } ...
</pre><p>这将从<code class="codeph">SQLException</code>对象中打印错误文本。
                        </p>
                        <p>您还可以使用<code class="codeph">SQLException</code>类的<code class="codeph">getMessage()</code> ， <code class="codeph">getErrorCode()</code>和<code class="codeph">getSQLState()</code>方法检索错误信息。
                        </p>
                        <p>打印错误文本（如本示例中所示）将打印错误消息，其中包含一些其他文本，例如<code class="codeph">SQLException</code> 。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-889158EE-29C1-4F10-A955-B94801353C67__I1006260">
                        <p class="subhead3" id="GUID-889158EE-29C1-4F10-A955-B94801353C67__GUID-A83A6B23-AAB3-4D55-87F9-ED6D47C92DFD">检索SQL状态和错误代码</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p><code class="codeph">java.sql.SQLException</code>类和子类包括<code class="codeph">getMessage()</code> ， <code class="codeph">getErrorCode()</code>和<code class="codeph">getSQLState()</code>方法。根据异常或错误的来源以及在那里实现它们的方式，以下方法提供了其他信息：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">String getMessage（）</code></p>
                              <p>如果错误源自SQLJ运行时或JDBC驱动程序，则此方法返回不带前缀的错误消息。如果错误源自RDBMS，则它返回以<code class="codeph">ORA</code>编号为前缀的错误消息。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">int getErrorCode（）</code></p>
                              <p>如果错误源自SQLJ运行时，则此方法不返回任何有意义的信息。如果错误源自JDBC驱动程序或RDBMS，则它将五位<code class="codeph">ORA</code>编号作为整数返回。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">String getSQLState（）</code></p>
                              <p>如果错误源自SQLJ运行时，则此方法返回一个字符串，其中包含指示SQL状态的五位数代码。如果错误源自JDBC驱动程序，则它不返回任何有意义的信息。如果错误源自RDBMS，则它返回五位SQL状态。您的应用程序应具有适当的代码来处理返回的<code class="codeph">null</code>值。
                              </p>
                           </li>
                        </ul>
                        <p>以下示例打印错误消息并检查SQL状态：</p><pre class="oac_no_warn" dir="ltr">...尝试{...} catch（SQLException e）{System.err.println（“运行示例时出错：”+ e）; String sqlState = e.getSQLState（）; System.err.println（“SQL state =”+ sqlState）; } ...
</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ222"></a><div class="props_rev_3"><a id="GUID-9EA4834A-717F-4177-9901-418F806A8EC2" name="GUID-9EA4834A-717F-4177-9901-418F806A8EC2"></a><h4 id="JSQLJ-GUID-9EA4834A-717F-4177-9901-418F806A8EC2" class="sect4">使用SQLException子类</h4>
                  <div>
                     <div class="section">
                        <p>要进行更具体的错误检查，请使用<code class="codeph">java.sql.任何可用且适当的子类<code class="codeph">java.sql.SQLException</code>类。
                        </p>
                        <p>SQLJ提供了<code class="codeph">sqlj.runtime.NullException</code>类，它是<code class="codeph">java.sql.的子类<code class="codeph">java.sql.SQLException</code> 。您可以在可能将<code class="codeph">NULL</code>返回到Java原始变量的情况下使用此异常。
                        </p>
                        <p>对于启用批处理的环境，还有标准的<code class="codeph">java.sql.BatchUpdateException</code>子类。有关详细信息，请参阅<span class="q">“ <a href="performance-and-debugging.html#GUID-E764E87E-1320-4DBE-B59E-7B03150BF803__I1006173">批处理执行期间的错误条件</a> ”</span> 。
                        </p>
                        <p>当您使用<code class="codeph">SQLException</code>的子类时，在捕获<code class="codeph">SQLException</code>之前捕获子类异常，如下例所示：</p><pre class="oac_no_warn" dir="ltr">...尝试{...} catch（SQLNullException ne）{System.err.println（“遇到空值：”+ ne）; } catch（SQLException e）{System.err.println（“运行示例时出错：”+ e）; } ...
</pre><p>这是因为子类异常也可以作为<code class="codeph">SQLException</code>捕获。如果首先捕获<code class="codeph">SQLException</code> ，则执行将不会进入您为子类异常编码特殊处理的部分。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="JSQLJ223"></a><div class="props_rev_3"><a id="GUID-6F37BE89-6EA0-4B27-884A-C0D4E8746E97" name="GUID-6F37BE89-6EA0-4B27-884A-C0D4E8746E97"></a><h3 id="JSQLJ-GUID-6F37BE89-6EA0-4B27-884A-C0D4E8746E97" class="sect3">基本交易控制</h3>
               <div>
                  <p>本节讨论如何管理数据更新。它包括以下主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="key-programming-considerations.html#GUID-6F534A06-48D0-4CDD-A547-75747A1808AD">交易概述</a></p>
                     </li>
                     <li>
                        <p><a href="key-programming-considerations.html#GUID-EA99733D-F1FE-43FB-8C77-6F5E8AA9DFDB">自动提交与手动提交</a></p>
                     </li>
                     <li>
                        <p><a href="key-programming-considerations.html#GUID-E226849C-2017-489F-BAAF-66B79C6D1982">在定义连接时指定自动提交</a></p>
                     </li>
                     <li>
                        <p><a href="key-programming-considerations.html#GUID-A5ECD155-3F2F-41DD-A87B-3A0345317404">修改现有连接中的自动提交</a></p>
                     </li>
                     <li>
                        <p><a href="key-programming-considerations.html#GUID-25F6527A-8A45-4679-868E-FB53CFFDB0B7">使用手动COMMIT和ROLLBACK</a></p>
                     </li>
                     <li>
                        <p><a href="key-programming-considerations.html#GUID-CD1AE63C-8165-45FD-B749-FBAA4AF8626B">提交和回滚对迭代器和结果集的影响</a></p>
                     </li>
                     <li>
                        <p><a href="key-programming-considerations.html#GUID-6A5E522A-4B6B-4B59-B644-85A45C82EDE5">使用保存点</a></p>
                     </li>
                  </ul>
                  <div class="infoboxnotealso" id="GUID-6F37BE89-6EA0-4B27-884A-C0D4E8746E97__GUID-7DFD9605-74AA-4EEF-A0F4-64DF0A6D4B33">
                     <p class="notep1">也可以看看：</p>
                     <p><span class="q">“ <a href="advanced-language-features.html#GUID-3B7EEA7A-5E45-4455-8255-2A5C1334DAD8">高级交易控制</a> ”</span></p>
                  </div>
               </div><a id="JSQLJ224"></a><div class="props_rev_3"><a id="GUID-6F534A06-48D0-4CDD-A547-75747A1808AD" name="GUID-6F534A06-48D0-4CDD-A547-75747A1808AD"></a><h4 id="JSQLJ-GUID-6F534A06-48D0-4CDD-A547-75747A1808AD" class="sect4">交易概述</h4>
                  <div>
                     <p><span class="bold">事务</span>是Oracle将其视为单个单元的一系列SQL操作。事务从以下任何一个后面的第一个可执行SQL语句开始：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>连接数据库</p>
                        </li>
                        <li>
                           <p><code class="codeph">COMMIT</code> （自动或手动提交数据更新）</p>
                        </li>
                        <li>
                           <p><code class="codeph">ROLLBACK</code> （取消数据更新）</p>
                        </li>
                     </ul>
                     <p>事务以<code class="codeph">COMMIT</code>或<code class="codeph">ROLLBACK</code>操作结束。
                     </p>
                     <div class="infoboxnote" id="GUID-6F534A06-48D0-4CDD-A547-75747A1808AD__GUID-58412C19-4172-4470-A6DD-CEE6D049E28F">
                        <p class="notep1">注意：</p>
                        <p>在Oracle Database 12 <span class="italic">c</span>第2版（12.2）中，所有数据定义语言（DDL）语句（如<code class="codeph">CREATE</code>和<code class="codeph">ALTER</code> ）都包含隐式<code class="codeph">COMMIT</code> 。这不仅会提交DDL语句，还会提交尚未提交或回滚的所有前面的数据操作语言（DML）语句，例如<code class="codeph">INSERT</code> ， <code class="codeph">DELETE</code>和<code class="codeph">UPDATE</code> 。
                        </p>
                     </div>
                  </div>
               </div><a id="JSQLJ225"></a><div class="props_rev_3"><a id="GUID-EA99733D-F1FE-43FB-8C77-6F5E8AA9DFDB" name="GUID-EA99733D-F1FE-43FB-8C77-6F5E8AA9DFDB"></a><h4 id="JSQLJ-GUID-EA99733D-F1FE-43FB-8C77-6F5E8AA9DFDB" class="sect4">自动提交与手动提交</h4>
                  <div>
                     <p>在使用SQLJ或JDBC时，您可以自动提交数据更新，也可以手动提交。在任何一种情况下，每个<code class="codeph">COMMIT</code>操作都会启动一个新事务。您可以通过启用自动提交标志来指定自动提交更改。这可以在定义SQLJ连接时使用，也可以使用现有连接的基础JDBC连接对象的<code class="codeph">setAutoCommit()</code>方法完成。您可以通过禁用自动提交标志并使用SQLJ <code class="codeph">COMMIT</code>和<code class="codeph">ROLLBACK</code>语句来使用手动控制。
                     </p>
                     <p>启用自动提交可能更方便，但可以减少控制。例如，您无法回滚更改。此外，某些SQLJ或JDBC功能与自动提交模式不兼容。例如，必须禁用更新批处理的自动提交标志或<code class="codeph">SELECT FOR UPDATE</code>语法才能正常工作。
                     </p>
                  </div>
               </div><a id="JSQLJ226"></a><div class="props_rev_3"><a id="GUID-E226849C-2017-489F-BAAF-66B79C6D1982" name="GUID-E226849C-2017-489F-BAAF-66B79C6D1982"></a><h4 id="JSQLJ-GUID-E226849C-2017-489F-BAAF-66B79C6D1982" class="sect4">在定义连接时指定自动提交</h4>
                  <div>
                     <p>使用<code class="codeph">Oracle.connect()</code>或<code class="codeph">Oracle.getConnection()</code>方法创建<code class="codeph">DefaultContext</code>实例并定义连接时，默认情况下自动提交标志设置为<code class="codeph">false</code> 。但是，这些方法的签名使您可以显式设置此标志。自动提交标志始终是最后一个参数。
                     </p>
                     <p>以下是实例化<code class="codeph">DefaultContext</code>并使用自动提交模式的默认<code class="codeph">false</code>设置的示例：</p><pre class="oac_no_warn" dir="ltr">Oracle.getConnection（“jdbc：oracle：thin：@localhost：5221 / myservice”，“HR”，“hr”）;</pre><p>或者，您可以指定<code class="codeph">true</code>设置，如下所示：</p><pre class="oac_no_warn" dir="ltr">Oracle.getConnection（“jdbc：oracle：thin：@localhost：5221 / myservice”，“HR”，“hr”，true）;</pre><div class="infoboxnotealso" id="GUID-E226849C-2017-489F-BAAF-66B79C6D1982__GUID-7EBB3568-728C-4B61-AC15-8979D0D9DE59">
                        <p class="notep1">也可以看看：</p>
                        <p><span class="q">“ <a href="key-programming-considerations.html#GUID-5838209F-A715-4935-AD3F-7EFDD5CE4BF3">关于Oracle类的更多信息</a> ”</span></p>
                     </div>
                     <p>如果使用构造函数创建连接上下文实例（ <code class="codeph">DefaultContext</code>或声明的连接上下文类），则必须指定自动提交设置。同样，它是最后一个参数，如下例所示：</p><pre class="oac_no_warn" dir="ltr">DefaultContext ctx = new DefaultContext（“jdbc：oracle：thin：@localhost：5221 / myservice”，“HR”，“hr”，false）;</pre><div class="infoboxnotealso" id="GUID-E226849C-2017-489F-BAAF-66B79C6D1982__GUID-CD68D3C1-8056-4AD9-AB40-484AE26E974B">
                        <p class="notep1">也可以看看：</p>
                        <p><span class="q">“ <a href="key-programming-considerations.html#GUID-8D05EAA4-E034-495C-A74D-EFEF9778ABC1">关于DefaultContext类的更多信息</a> ”</span></p>
                     </div>
                     <p>如果您有理由直接创建JDBC <code class="codeph">Connection</code>实例，则默认情况下，如果程序在客户端上运行，则auto-commit标志设置为<code class="codeph">true</code> ;如果在服务器中运行，则默认设置为<code class="codeph">false</code> 。直接创建JDBC <code class="codeph">Connection</code>实例时，不能指定自动提交设置，但可以使用<code class="codeph">setAutoCommit()</code>方法更改设置。
                     </p>
                     <div class="infoboxnote" id="GUID-E226849C-2017-489F-BAAF-66B79C6D1982__GUID-ACEBD3BC-4518-4D6F-8251-ADB650ABDC6B">
                        <p class="notep1">注意：</p>
                        <p>JDBC服务器端内部驱动程序<span class="italic">不</span>支持自动提交功能。
                        </p>
                     </div>
                  </div>
               </div><a id="JSQLJ227"></a><div class="props_rev_3"><a id="GUID-A5ECD155-3F2F-41DD-A87B-3A0345317404" name="GUID-A5ECD155-3F2F-41DD-A87B-3A0345317404"></a><h4 id="JSQLJ-GUID-A5ECD155-3F2F-41DD-A87B-3A0345317404" class="sect4">修改现有连接中的自动提交</h4>
                  <div>
                     <div class="section">
                        <p>通常没有理由更改现有连接的自动提交标志设置，但您可以根据需要进行更改。您可以使用基础JDBC连接对象的<code class="codeph">setAutoCommit()</code>方法来完成此操作。
                        </p>
                        <p>您可以使用任何SQLJ连接上下文实例的<code class="codeph">getConnection()</code>方法检索基础JDBC连接对象，无论它是<code class="codeph">DefaultContext</code>类的实例还是您声明的连接上下文类的实例。
                        </p>
                        <p>您可以一次完成这两个步骤，如下所示：</p><pre class="oac_no_warn" dir="ltr">。ctx.getConnection（）的setAutoCommit（假）;</pre><p>要么：</p><pre class="oac_no_warn" dir="ltr">。ctx.getConnection（）的setAutoCommit（真）;</pre><p>在这些示例中， <code class="codeph">ctx</code>是SQLJ连接上下文实例。
                        </p>
                        <div class="infoboxnote" id="GUID-A5ECD155-3F2F-41DD-A87B-3A0345317404__GUID-1453BFB3-C9F4-41EE-AAAB-B575A69C881B">
                           <p class="notep1">注意：</p>
                           <p><span class="italic">不要</span>改变自动提交的事务中的设置。
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ228"></a><div class="props_rev_3"><a id="GUID-25F6527A-8A45-4679-868E-FB53CFFDB0B7" name="GUID-25F6527A-8A45-4679-868E-FB53CFFDB0B7"></a><h4 id="JSQLJ-GUID-25F6527A-8A45-4679-868E-FB53CFFDB0B7" class="sect4">使用手动COMMIT和ROLLBACK</h4>
                  <div>
                     <div class="section">
                        <p>如果禁用自动提交标志，则必须手动提交任何数据更新。要提交自上次<code class="codeph">COMMIT</code>操作以来已执行的任何更改，请使用SQLJ <code class="codeph">COMMIT</code>语句，如下所示：</p><pre class="oac_no_warn" dir="ltr">#sql {COMMIT};</pre><p>要回滚自上次<code class="codeph">COMMIT</code>操作以来已执行的任何更改，请使用SQLJ <code class="codeph">ROLLBACK</code>语句，如下所示：</p><pre class="oac_no_warn" dir="ltr">#sql {ROLLBACK};</pre><div class="infoboxnote" id="GUID-25F6527A-8A45-4679-868E-FB53CFFDB0B7__GUID-A1101A79-50EF-49B2-B6BA-2759DFFC2F1B">
                           <p class="notep1">注意：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>启用自动提交时，请勿使用<code class="codeph">COMMIT</code>和<code class="codeph">ROLLBACK</code>命令。这将导致未指定的行为，甚至可能引发SQL异常。
                                 </p>
                              </li>
                              <li>
                                 <p>您还可以回滚到指定的保存点。请参阅<span class="q">“ <a href="key-programming-considerations.html#GUID-6A5E522A-4B6B-4B59-B644-85A45C82EDE5">使用保存点</a> ”</span> 。
                                 </p>
                              </li>
                              <li>
                                 <p>Oracle SQL语法中的所有DDL语句都包含隐式<code class="codeph">COMMIT</code>操作。在这方面没有特殊的SQLJ功能。此类语句遵循标准Oracle SQL规则。
                                 </p>
                              </li>
                              <li>
                                 <p>如果自动提交模式已关闭并且您从客户端应用程序关闭连接上下文实例，则除非您使用<code class="codeph">KEEP_CONNECTION</code>关闭连接上下文实例，否则将提交自上次<code class="codeph">COMMIT</code>以来的任何更改。有关更多信息，请参阅<span class="q">“ <a href="advanced-language-features.html#GUID-340AFCEF-E421-46F9-B136-DF9CC3723310__I1007208">关闭共享连接</a> ”</span> 。
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ229"></a><div class="props_rev_3"><a id="GUID-CD1AE63C-8165-45FD-B749-FBAA4AF8626B" name="GUID-CD1AE63C-8165-45FD-B749-FBAA4AF8626B"></a><h4 id="JSQLJ-GUID-CD1AE63C-8165-45FD-B749-FBAA4AF8626B" class="sect4">提交和回滚对迭代器和结果集的影响</h4>
                  <div>
                     <div class="section">
                        <p><code class="codeph">COMMIT</code>和<code class="codeph">ROLLBACK</code>操作<span class="italic">不会</span>影响打开的结果集和迭代器。结果集和迭代器仍将打开。通常，与其内容相关的所有内容都是在执行填充它们的<code class="codeph">SELECT</code>语句时数据库的状态。
                        </p>
                        <div class="infoboxnote" id="GUID-CD1AE63C-8165-45FD-B749-FBAA4AF8626B__GUID-27045A12-841B-4FF8-9403-54CECE27F15B">
                           <p class="notep1">注意：</p>
                           <p>例外情况是，如果声明了一个<code class="codeph">sensitivity=SENSITIVE</code>的迭代器类。在这种情况下，只要迭代器在其窗口大小之外滚动，就可以看到对底层结果集的更改。有关可滚动迭代器的更多信息，请参阅<span class="q">“</span>可滚动迭代<span class="q"><a href="advanced-language-features.html#GUID-398B03B4-138D-41E6-A34B-B4911ACF7A18">器</a> ”</span> 。有关基础可滚动结果集的更多信息，请参阅<a href="../jjdbc/resultset.html#JJDBC-GUID-41D05006-5470-4C1C-ACA0-A4B487B4D1C0" target="_blank"><span class="italic">Oracle数据库JDBC开发人员指南</span></a> 。
                           </p>
                        </div>
                        <p>这也适用于在<code class="codeph">SELECT</code>语句之后执行的<code class="codeph">UPDATE</code> ， <code class="codeph">INSERT</code>和<code class="codeph">DELETE</code>语句。执行这些语句不会影响打开的结果集和迭代器的内容。
                        </p>
                        <p>考虑一种情况，你<code class="codeph">SELECT</code> ，然后<code class="codeph">UPDATE</code> ，然后<code class="codeph">COMMIT</code> 。由<code class="codeph">SELECT</code>语句填充的非敏感结果集或迭代器不受<code class="codeph">UPDATE</code>和<code class="codeph">COMMIT</code> 。</p>
                        <p>作为另一个例子，考虑一种情况，你<code class="codeph">UPDATE</code> ，然后<code class="codeph">SELECT</code> ，然后<code class="codeph">ROLLBACK</code> 。 <code class="codeph">SELECT</code>填充的非敏感结果集或迭代器仍将包含更新的数据，而不管后续的<code class="codeph">ROLLBACK</code> 。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ231"></a><a id="JSQLJ232"></a><a id="JSQLJ230"></a><div class="props_rev_3"><a id="GUID-6A5E522A-4B6B-4B59-B644-85A45C82EDE5" name="GUID-6A5E522A-4B6B-4B59-B644-85A45C82EDE5"></a><h4 id="JSQLJ-GUID-6A5E522A-4B6B-4B59-B644-85A45C82EDE5" class="sect4">使用保存点</h4>
                  <div>
                     <div class="section">
                        <p>JDBC 3.0规范增加了对保存点的支持。<span class="bold">保存点</span>是事务中的已定义点，您可以根据需要回滚到该点，而不是回滚整个事务。保存点是出现<code class="codeph">SAVEPOINT</code>语句的事务中的点。
                        </p>
                        <p>在Oracle9 <span class="italic">i</span> Database Release 2（9.2）中，SQLJ首先包含特定于Oracle的语法以支持保存点。在Oracle Database 12 <span class="italic">c</span>第2版（12.2）中，SQLJ添加了对ISO SQLJ标准保存点语法的支持。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-6A5E522A-4B6B-4B59-B644-85A45C82EDE5__GUID-3EA842B2-7BAE-4E1D-B3D0-3E8E63F69A07">支持ISO SQLJ标准保存点语法</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>在ISO SQLJ标准语法中，在<code class="codeph">SAVEPOINT</code>语句中使用字符串文字来指定保存点的名称。这可以按如下方式完成：</p><pre class="oac_no_warn" dir="ltr">#sql {SAVEPOINT savepoint1};</pre><p>如果要回滚对该保存点的更改，则可以稍后在<code class="codeph">ROLLBACK TO</code>语句中引用指定的名称，如下所示：</p><pre class="oac_no_warn" dir="ltr">#sql {ROLLBACK TO savepoint1};</pre><p>如果不再需要保存点，请使用<code class="codeph">RELEASE SAVEPOINT</code>语句：</p><pre class="oac_no_warn" dir="ltr">#sql {RELEASE SAVEPOINT savepoint1};</pre><p>保存点保存在SQLJ执行上下文中，该上下文具有与这三个语句的功能并行的方法。</p>
                        <div class="infoboxnotealso" id="GUID-6A5E522A-4B6B-4B59-B644-85A45C82EDE5__GUID-C84800EF-D3D6-4A3A-AB6F-A13B1FE37E04">
                           <p class="notep1">也可以看看：</p>
                           <p><span class="q">“ <a href="advanced-language-features.html#GUID-8A773E63-0B14-4F39-ADE6-38B8C476B123">保存点方法</a> ”</span></p>
                        </div>
                        <p>因为任何<code class="codeph">COMMIT</code>操作都会结束事务，所以这也会释放事务的所有保存点。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-6A5E522A-4B6B-4B59-B644-85A45C82EDE5__GUID-9CDD0D04-4D92-48E5-847D-2039EA653809">Oracle SQLJ保存点语法</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>除了ISO SQLJ标准语法之外，还支持以下针对保存点的Oracle特定语法。请注意，Oracle语法使用字符串主机表达式，而不是字符串文字。</p>
                        <p>您可以按如下方式设置保存点：</p><pre class="oac_no_warn" dir="ltr">#sql {SET SAVEPOINT： <span class="italic">savepoint</span> };</pre><p>此示例中的主机表达式<span class="italic"><code class="codeph">savepoint</code></span>是一个变量，它将保存点的名称指定为Java <code class="codeph">String</code> 。
                        </p>
                        <p>您可以按如下方式回滚到保存点：</p><pre class="oac_no_warn" dir="ltr">#sql {ROLLBACK TO： <span class="italic">savepoint</span> };</pre><p>要释放保存点，请使用以下SQLJ语句：</p><pre class="oac_no_warn" dir="ltr">#sql {RELEASE： <span class="italic">savepoint</span> };</pre><div class="infoboxnote" id="GUID-6A5E522A-4B6B-4B59-B644-85A45C82EDE5__GUID-1CD8CB90-2AD0-4441-ABEB-89DDE1B46B62">
                           <p class="notep1">注意：</p>
                           <p>为了向后兼容，将继续支持特定于Oracle的语法。请注意Oracle语法和ISO SQLJ标准语法之间的以下区别：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>Oracle语法采用字符串变量而不是字符串文字。</p>
                              </li>
                              <li>
                                 <p>Oracle语法使用<code class="codeph">SET SAVEPOINT</code>而不是<code class="codeph">SAVEPOINT</code> 。</p>
                              </li>
                              <li>
                                 <p>Oracle语法使用<code class="codeph">RELEASE</code>而不是<code class="codeph">RELEASE SAVEPOINT</code> 。</p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="JSQLJ234"></a><a id="JSQLJ235"></a><a id="JSQLJ236"></a><a id="JSQLJ237"></a><a id="JSQLJ238"></a><a id="JSQLJ239"></a><a id="JSQLJ240"></a><a id="JSQLJ233"></a><div class="props_rev_3"><a id="GUID-E1A4C501-C265-43F6-98A3-D3F46044348A" name="GUID-E1A4C501-C265-43F6-98A3-D3F46044348A"></a><h3 id="JSQLJ-GUID-E1A4C501-C265-43F6-98A3-D3F46044348A" class="sect3">摘要：SQLJ代码的第一步</h3>
               <div>
                  <p>总结之前讨论的SQLJ可执行语句特性和功能的最佳方法是检查简短但完整的程序。本节介绍两个这样的例子。</p>
                  <p>第一个示例，一次呈现一个步骤，然后再次完整呈现，使用<code class="codeph">SELECT INTO</code>语句对员工表中的两列执行单行查询。如果要运行该示例，请确保将<code class="codeph">connect.properties</code>文件中的参数更改为允许您连接到适当数据库的设置。
                  </p>
                  <p>第二个示例稍微复杂一点，将使用SQLJ迭代器进行多行查询。</p>
                  <div class="section">
                     <p class="subhead2" id="GUID-E1A4C501-C265-43F6-98A3-D3F46044348A__GUID-4AD92035-6A85-425C-9E74-45E7D8FDC141">导入必需的类</p>
                  </div>
                  <!-- class="section" -->
                  <p>导入您需要的任何JDBC或SQLJ包。您至少需要<code class="codeph">java.sql</code>包中的一些类：</p><pre class="oac_no_warn" dir="ltr">import java.sql。*;</pre><p>您可能不需要所有<code class="codeph">java.sql</code>包。关键类是<code class="codeph">java.sql.SQLException</code>和您明确引用的任何类。例如， <code class="codeph">java.sql.Date</code>和<code class="codeph">java.sql.ResultSet</code> 。
                  </p>
                  <p>您将需要<code class="codeph">Oracle</code>类的以下包，通常用于实例化<code class="codeph">DefaultContext</code>对象并建立默认连接：</p><pre class="oac_no_warn" dir="ltr">import oracle.sqlj.runtime。*;</pre><p>如果您将直接在代码中使用任何SQLJ运行时类，则导入以下包：</p><pre class="oac_no_warn" dir="ltr">import sqlj.runtime。*; import sqlj.runtime.ref。*;</pre><p>但是，即使您的代码不直接使用任何SQLJ运行时类，也只需将它们放在<code class="codeph">CLASSPATH</code> 。</p>
                  <p>主要运行时类包括<code class="codeph">ResultSetIterator</code>和<code class="codeph">ExecutionContext</code>中<code class="codeph">sqlj.runtime</code>封装<code class="codeph">DefaultContext</code>在<code class="codeph">sqlj.runtime.ref</code>包。
                  </p>
                  <div class="section">
                     <p class="subhead2" id="GUID-E1A4C501-C265-43F6-98A3-D3F46044348A__GUID-C3D20B50-15DB-49D6-91F4-7FB92AF42460">注册JDBC驱动程序并设置默认连接</p>
                  </div>
                  <!-- class="section" -->
                  <p>使用构造函数声明<code class="codeph">SimpleExample</code>类，该构造函数使用静态<code class="codeph">Oracle.connect()</code>方法设置默认连接。这也注册了Oracle JDBC驱动程序。
                  </p>
                  <p>它使用<code class="codeph">connect()</code>的签名，该签名从<code class="codeph">connect.properties</code>文件中获取URL，用户名和密码。此文件的示例位于<span class="italic"><code class="codeph">ORACLE_HOME</code></span> <code class="codeph">/sqlj/demo</code>目录中，也位于<span class="q">“ <a href="getting-started.html#GUID-896CA936-1CD5-4478-90CD-1E0738E94204">设置运行时连接</a> ”中</span> 。
                  </p><pre class="oac_no_warn" dir="ltr">public class SimpleExample {public SimpleExample（）throws SQLException {//设置默认连接（在connect.properties中定义）。Oracle.connect（getClass（），“connect.properties”）; }</pre><div class="section">
                     <p class="subhead2" id="GUID-E1A4C501-C265-43F6-98A3-D3F46044348A__GUID-2D3A22AF-D03B-410A-89E7-21433B7322E8">设置异常处理</p>
                  </div>
                  <!-- class="section" -->
                  <p>创建一个调用<code class="codeph">SimpleExample</code>构造函数的<code class="codeph">main()</code> ，然后设置一个<code class="codeph">try/catch</code>块来处理<code class="codeph">runExample()</code>方法抛出的任何SQL异常，它执行此应用程序的实际工作：</p><pre class="oac_no_warn" dir="ltr">...public static void main（String [] args）{try {SimpleExample o1 = new SimpleExample（）; o1.runExample（）; } catch（SQLException ex）{System.err.println（“运行示例时出错：”+ ex）; } ...
</pre><p>当你关闭连接时，你也可以在<code class="codeph">finally</code>子句中使用<code class="codeph">try/catch</code>块，假设在SQL异常的情况下<code class="codeph">finally</code>子句不在<code class="codeph">try/catch</code>块中：</p><pre class="oac_no_warn" dir="ltr">终于{try {Oracle.close（）; } catch（SQLException ex）{...}}</pre><div class="section">
                     <p class="subhead2" id="GUID-E1A4C501-C265-43F6-98A3-D3F46044348A__GUID-0EF134D5-7B22-4604-89A3-84000FF674A8">设置主机变量，执行SQLJ子句，处理结果</p>
                  </div>
                  <!-- class="section" -->
                  <p>创建执行以下操作的<code class="codeph">runExample()</code>方法：</p>
                  <ol>
                     <li>
                        <p>将任何SQL异常抛出到<code class="codeph">main()</code>方法进行处理。
                        </p>
                     </li>
                     <li>
                        <p>声明Java主机变量。</p>
                     </li>
                     <li>
                        <p>执行将Java主机变量绑定到嵌入式<code class="codeph">SELECT</code>语句的SQLJ子句，并将数据选择到主机变量中。
                        </p>
                     </li>
                     <li>
                        <p>打印结果。</p>
                     </li>
                  </ol>
                  <p>此方法的代码如下：</p><pre class="oac_no_warn" dir="ltr">void runExample（）抛出SQLException {System.out.println（“运行示例 - ”）; //声明两个Java主变量 -  Float salary;字符串empname; //使用SELECT INTO语句执行查询和检索值。#sql {SELECT first_name，salary INTO：empname，：salary FROM employees WHERE employee_id = 7499}; //打印结果 -  System.out.println（“Name is”+ empname +“，Salary是”+ salary“）;关闭SimpleExample类的大括号</pre><p>此示例将<code class="codeph">salary</code>和<code class="codeph">empname</code>声明为Java主机变量。然后，SQLJ子句从<code class="codeph">employees</code>表的<code class="codeph">first_name</code>和<code class="codeph">salary</code>列中选择数据，并将数据放入主机变量中。最后，打印<code class="codeph">salary</code>和<code class="codeph">empname</code>的值。
                  </p>
                  <p>请注意，此<code class="codeph">SELECT</code>语句只能选择<code class="codeph">employees</code>表的一行，因为<code class="codeph">WHERE</code>子句中的<code class="codeph">employee_id</code>列是表的主键。
                  </p>
                  <div class="section">
                     <p class="subhead2" id="GUID-E1A4C501-C265-43F6-98A3-D3F46044348A__GUID-15ABEF01-8919-49FB-9489-7A4E980E8B90">使用SELECT INTO的单行查询示例</p>
                  </div>
                  <!-- class="section" -->
                  <p>本节介绍前面逐步部分中的整个<code class="codeph">SimpleExample</code>类。因为这是单行查询，所以不需要迭代器。
                  </p><pre class="oac_no_warn" dir="ltr">//导入SQLJ类：import sqlj.runtime。*; import sqlj.runtime.ref。*; import oracle.sqlj.runtime。*; //导入标准java.sql包：import java.sql。*; public class SimpleExample {public SimpleExample（）throws SQLException {//设置默认连接（在connect.properties中定义）。Oracle.connect（getClass（），“connect.properties”）; public static void main（String [] args）抛出SQLException {try {SimpleExample o1 = new SimpleExample（）; o1.runExample（）; } catch（SQLException ex）{System.err.println（“运行示例时出错：”+ ex）;终于{try {Oracle.close（）; } catch（SQLException ex）{...}void runExample（）抛出SQLException {System.out.println（“运行example--”）; //声明两个Java主变量 -  Float salary;字符串empname; //使用SELECT INTO语句执行查询和检索值。#sql {SELECT first_name，salary INTO：empname，：salary FROM employees WHERE employee_id = 7499}; //打印结果 -  System.out.println（“Name is”+ empname +“，Salary是”+ salary“）; }}</pre><div class="section">
                     <p class="subhead2" id="GUID-E1A4C501-C265-43F6-98A3-D3F46044348A__GUID-75E7D96E-C42C-4B74-93F7-A5B2D11AA39D">设置命名迭代器</p>
                  </div>
                  <!-- class="section" -->
                  <p>此示例基于前一个示例，通过添加命名迭代器并将其用于多行查询。</p>
                  <p>首先，声明迭代器类。使用对象类型<code class="codeph">Integer</code>和<code class="codeph">Float</code> ，而不是原始类型<code class="codeph">int</code>和<code class="codeph">float</code> ，只要有<code class="codeph">NULL</code>值的可能性。
                  </p><pre class="oac_no_warn" dir="ltr">#sql iterator EmpRecs（int empno，//此列不能为null，因此int是正确的.//（如果可以为null，请使用Integer。）String ename，String job，Integer mgr，Date hiredate，Float sal，Float comm，int deptno）;</pre><p>接下来，实例化<code class="codeph">EmpRecs</code>类并使用查询结果填充它。
                  </p><pre class="oac_no_warn" dir="ltr">EmpRecs员工; #sql employees = {SELECT employee_id，first_name，job_id，manager_id，hire_date，salary，commission_pct，department_tno FROM employees};</pre><p>然后，使用迭代器的<code class="codeph">next()</code>方法打印结果。
                  </p><pre class="oac_no_warn" dir="ltr">while（employees.next（））{System.out.println（“Name：”+ employees.first_name（））; System.out.println（“EMPNO：”+ employees.employee_id（））; System.out.println（“Job：”+ employees.job_id（））; System.out.println（“Manager：”+ employees.manager_id））; System.out.println（“Date雇用：”+ employees.hire_date（））; System.out.println（“薪水：”+ employees.salary（））; System.out.println（“Commission：”+ employees.commission_pct（））; System.out.println（“Department：”+ employees.department_no（））;的System.out.println（）; }</pre><p>最后，关闭迭代器。</p><pre class="oac_no_warn" dir="ltr">employees.close（）;</pre><div class="section">
                     <p class="subhead2" id="GUID-E1A4C501-C265-43F6-98A3-D3F46044348A__GUID-6A94BA4E-F4C5-4F25-A12A-81C98D74BDF7">使用命名迭代器的多行查询示例</p>
                  </div>
                  <!-- class="section" -->
                  <p>此示例使用命名迭代器进行多行查询，该查询从员工表中选择多列数据。</p>
                  <p>除了使用命名迭代器之外，此示例在概念上与前一个单行查询示例类似。</p><pre class="oac_no_warn" dir="ltr">//导入SQLJ类：import sqlj.runtime。*; import sqlj.runtime.ref。*; import oracle.sqlj.runtime。*; //导入标准java.sql包：import java.sql。*; //声明一个SQLJ迭代器。//使用对象类型（Integer，Float）表示mgr，sal和comm，而不是原始类型，以允许可能的空选择。#sql iterator EmpRecs（int empno，//此列不能为null，因此int是正确的.//（如果可以为null，则需要Integer。）String ename，String job，Integer mgr，Date hiredate，Float sal，Float comm，int deptno）; //这是应用程序类。public class EmpDemo1App {public EmpDemo1App（）throws SQLException {//设置默认连接（在connect.properties中定义）。Oracle.connect（getClass（），“connect.properties”）; public static void main（String [] args）{try {EmpDemo1App app = new EmpDemo1App（）; app.runExample（）; } catch（SQLException异常）{System.err.println（“运行示例时出错：”+异常）;终于{try {Oracle.close（）; } catch（SQLException ex）{...}void runExample（）抛出SQLException {System.out.println（“\ n运行示例。\ n”）; //查询创建迭代器的新实例，并将其存储在'EmpRecs'类型的变量'employees'中。SQLJ转换器//自动声明了迭代器，以便它具有//访问结果集的行和列的方法。EmpRecs员工; #sql employees = {SELECT employee_id，first_name，job_id，manager_id，hire_date，salary，commission_pct，department_no FROM employees}; //使用迭代器打印结果。//注意如何使用方法'next（）'访问下一行，以及如何使用以//实际数据库列名命名的方法访问列。while（employees.next（））{System.out.println（“Name：”+ employees.first_name（））; System.out.println（“EMPNO：”+ employees.employee_id（））; System.out.println（“Job：”+ employees.job_id（））; System.out.println（“Manager：”+ employees.manager_id（））; System.out.println（“Date雇用：”+ employees.hire_date（））; System.out.println（“薪水：”+ employees.salary（））; System.out.println（“Commission：”+ employees.commission_pct（））; System.out.println（“Department：”+ employees.department_no（））;的System.out.println（）; } //当不再需要迭代器时，必须关闭它。employees.close（）; }}</pre></div>
            </div><a id="JSQLJ241"></a><div class="props_rev_3"><a id="GUID-E0F0C310-400E-4F9C-8036-B44FB2A3E2FD" name="GUID-E0F0C310-400E-4F9C-8036-B44FB2A3E2FD"></a><h3 id="JSQLJ-GUID-E0F0C310-400E-4F9C-8036-B44FB2A3E2FD" class="sect3">特定于Oracle的代码生成（无配置文件）</h3>
               <div>
                  <p>在本手册中，对SQLJ运行时层和SQLJ配置文件进行了一般性和标准性的讨论。但是，默认情况下，Oracle SQLJ实现会生成特定于Oracle的代码，并直接调用Oracle JDBC驱动程序，而不是生成调用SQLJ运行时的ISO SQLJ标准代码。使用Oracle特定的代码生成时，没有配置文件，并且在程序执行期间SQLJ运行时层的角色会大大减少。特定于Oracle的代码支持所有特定于Oracle的扩展功能。</p>
                  <p>代码生成是通过SQLJ转换器<code class="codeph">-codegen</code>选项确定的。Oracle特定代码生成的默认设置是<code class="codeph">-codegen=oracle</code> 。或者，您可以根据ISO SQLJ标准设置<code class="codeph">-codegen=iso</code>以生成代码。
                  </p>
                  <p>本节包括以下主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="key-programming-considerations.html#GUID-E4C877C3-6E29-4053-BA8F-D0694B5D4968">Oracle特定代码生成的代码注意事项和限制</a></p>
                     </li>
                     <li>
                        <p><a href="key-programming-considerations.html#GUID-82E999E2-B04C-4182-956F-0FC08B70BE36">SQLJ用法随Oracle特定代码生成而变化</a></p>
                     </li>
                     <li>
                        <p><a href="key-programming-considerations.html#GUID-A19B87D2-C37F-43F2-B7B8-00E383441565">Oracle特定代码生成的优缺点</a></p>
                     </li>
                  </ul>
               </div><a id="JSQLJ242"></a><div class="props_rev_3"><a id="GUID-CB050C2E-5712-470F-AEDD-600313EEDDE9" name="GUID-CB050C2E-5712-470F-AEDD-600313EEDDE9"></a><h4 id="JSQLJ-GUID-CB050C2E-5712-470F-AEDD-600313EEDDE9" class="sect4">特定于Oracle的代码生成的环境要求</h4>
                  <div>
                     <div class="section">
                        <p>如果使用特定于Oracle的代码生成，请注意以下环境要求：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>因为Oracle特定的代码生成需要JDBC语句缓存功能，您必须使用ORACLE11 <span class="italic">g</span>或更高版本的JDBC驱动程序的版本。
                              </p>
                           </li>
                           <li>
                              <p>特定于Oracle的代码生成不支持通用SQLJ运行时库（ <code class="codeph">runtime</code> 。您必须在<code class="codeph">CLASSPATH</code>具有以下Oracle SQLJ运行时库之一：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p><code class="codeph">runtime12.jar</code></p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">runtime12ee.jar</code></p>
                                 </li>
                              </ul>
                              <div class="infoboxnotealso" id="GUID-CB050C2E-5712-470F-AEDD-600313EEDDE9__GUID-124D88A3-0D60-474F-AD95-640242D669C5">
                                 <p class="notep1">也可以看看：</p>
                                 <p><span class="q">“ <a href="getting-started.html#GUID-59D43923-4D2A-42FB-8F03-9CF1F3B60C67">使用Oracle SQLJ实现的要求</a> ”</span></p>
                              </div>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ243"></a><div class="props_rev_3"><a id="GUID-E4C877C3-6E29-4053-BA8F-D0694B5D4968" name="GUID-E4C877C3-6E29-4053-BA8F-D0694B5D4968"></a><h4 id="JSQLJ-GUID-E4C877C3-6E29-4053-BA8F-D0694B5D4968" class="sect4">Oracle特定代码生成的代码注意事项和限制</h4>
                  <div>
                     <div class="section">
                        <p>在编写将使用Oracle特定代码生成的SQLJ应用程序时，请注意以下编程注意事项和限制：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>要使用非默认语句高速缓存大小，必须在代码中包含适当的方法调用，因为Oracle定制程序<code class="codeph">stmtcache</code>选项不可用。
                              </p>
                           </li>
                           <li>
                              <p>不要将Oracle特定生成的代码与ISO SQLJ标准生成的代码混合在同一个应用程序中。但是，如果特定于Oracle的代码和ISO SQLJ标准代码<span class="italic">必须</span>共享同一连接，请执行以下操作之一：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>确保特定于Oracle的代码和ISO标准代码使用不同的SQLJ执行上下文实例。有关SQLJ执行上下文的信息，请参阅<span class="q">“ <a href="advanced-language-features.html#GUID-BC1805F7-AECB-4D97-B74C-1E0D71BDE603">执行上下文</a> ”</span> 。
                                    </p>
                                 </li>
                                 <li>
                                    <p>在两种代码之间放置一个事务边界，即作为手动<code class="codeph">COMMIT</code>或<code class="codeph">ROLLBACK</code>语句。
                                    </p>
                                 </li>
                              </ul>
                              <p>混合代码的这种限制对于服务器端代码尤为重要，因为在给定会话中运行的所有Java代码都使用相同的JDBC连接和SQLJ连接上下文。</p>
                           </li>
                           <li>
                              <p>从数据库返回值时，不要依赖参数表达式中的副作用。特定于Oracle的代码生成不会创建临时变量来评估<code class="codeph">OUT</code>参数， <code class="codeph">IN OUT</code>参数， <code class="codeph">SELECT INTO</code>变量或SQL语句的返回参数。
                              </p>
                              <p>例如，避免使用如下语句：</p><pre class="oac_no_warn" dir="ltr">#sql {SELECT * FROM EMPLOYEES INTO：（x [i ++]），：（f_with_sideffect（）[i ++]），：（ab [i]）};</pre><p>要么：</p><pre class="oac_no_warn" dir="ltr">#sql x [i ++] = {VALUES f（：INOUT（x [i ++]）,: OUT（f_with_sideffect（）））};</pre><p>参数的评估在生成的代码<span class="italic">中就地</span>执行。与根据ISO SQLJ标准进行评估时相比，这可能会导致不同的行为。
                              </p>
                           </li>
                           <li>
                              <p>Oracle对象功能的类型映射假定相应的Java类实现<code class="codeph">java.sql.SQLData</code>接口。如果对Oracle对象功能使用类型映射，那么迭代器声明和连接上下文声明必须指定相同的类型映射。通过<code class="codeph">with</code>子句指定它。
                              </p>
                              <p>例如，如果您声明连接上下文类，如下所示：</p><pre class="oac_no_warn" dir="ltr">#sql context TypeMapContext with（typeMap =“MyTypeMap”）;</pre><p>并从使用此连接上下文类的实例的SQLJ语句填充迭代器实例，如下所示：</p><pre class="oac_no_warn" dir="ltr">TypeMapContext tmc = new TypeMapContext（...）; ...MyIterator吧; #sql [tmc] it =（SELECT pers，addr FROM tab WHERE ...）;</pre><p>那么迭代器声明需要指定相同的类型映射，如下所示：</p><pre class="oac_no_warn" dir="ltr">#sql iterator MyIterator with（typeMap =“MyTypeMap”）（Person pers，Address addr）;</pre><div class="infoboxnotealso" id="GUID-E4C877C3-6E29-4053-BA8F-D0694B5D4968__GUID-F99BF9D5-2A70-475B-84DB-C63DCDAD10B4">
                                 <p class="notep1">也可以看看：</p>
                                 <p><span class="q">“ <a href="objects-collections-and-OPAQUE-types.html#GUID-240D3A7C-D69A-4599-8B9B-6E0B9312853D">自定义Java类要求</a> ”</span>和<span class="q">“ <a href="basic-language-features.html#GUID-5E97C2F0-7249-48FD-A75B-AB5A465147C7">声明条款</a> ”</span></p>
                              </div>
                              <div class="infoboxnote" id="GUID-E4C877C3-6E29-4053-BA8F-D0694B5D4968__GUID-4F738BA6-7E0E-42FA-961B-9F4D5BD1369B">
                                 <p class="notep1">注意：</p>
                                 <p>这种限制的原因在于，通过Oracle特定的代码生成，所有迭代器getter方法都是在转换期间作为Oracle JDBC调用完全生成的。要生成正确的调用，SQLJ转换器必须知道迭代器是否将与特定类型映射一起使用。</p>
                              </div>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ244"></a><div class="props_rev_3"><a id="GUID-82E999E2-B04C-4182-956F-0FC08B70BE36" name="GUID-82E999E2-B04C-4182-956F-0FC08B70BE36"></a><h4 id="JSQLJ-GUID-82E999E2-B04C-4182-956F-0FC08B70BE36" class="sect4">SQLJ用法随Oracle特定代码生成而变化</h4>
                  <div>
                     <p>以前仅作为Oracle自定义程序选项提供的某些选项对于特定于Oracle的代码生成也很有用。由于配置文件自定义不适用于特定于Oracle的代码生成，因此这些选项已通过其他方式提供。</p>
                     <p>要在生成特定于Oracle的代码时更改语句高速缓存大小或禁用语句高速缓存，请在代码中使用方法调用，而不是使用定制程序<code class="codeph">stmtcache</code>选项。<code class="codeph">sqlj.runtime.ref.DefaultContext</code>类以及您声明的任何连接上下文类现在具有以下静态方法：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">setDefaultStmtCacheSize（INT）</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">int getDefaultStmtCacheSize（）</code></p>
                        </li>
                     </ul>
                     <p>它还具有以下实例方法：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">setStmtCacheSize（INT）</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">int getStmtCacheSize（）</code></p>
                        </li>
                     </ul>
                     <p>默认情况下，启用语句缓存。</p>
                     <div class="infoboxnotealso" id="GUID-82E999E2-B04C-4182-956F-0FC08B70BE36__GUID-3F467AA3-77DC-43CD-A87D-B243929FBA94">
                        <p class="notep1">也可以看看：</p>
                        <p><span class="q">“ <a href="performance-and-debugging.html#GUID-5DA139D6-A47B-466E-BCA5-3B04D710792A">声明缓存</a> ”</span></p>
                     </div>
                     <p>此外，以下选项可用作前端Oracle SQLJ转换程序选项以及Oracle自定义程序选项：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">-optcols</code> ：启用迭代器列类型和大小定义以优化性能。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">-optparams</code> ：启用参数大小定义以优化JDBC资源分配。此选项与<code class="codeph">optparamdefaults</code>一起使用。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">-optparamdefaults</code> ：为特定数据类型设置参数大小默认值。此选项与<code class="codeph">optparams</code>结合使用。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">-fixedchar</code> ：为<code class="codeph">WHERE</code>子句启用<code class="codeph">CHAR</code>比较和空白填充。
                           </p>
                        </li>
                     </ul>
                     <div class="infoboxnotealso" id="GUID-82E999E2-B04C-4182-956F-0FC08B70BE36__GUID-21F6BC4A-4E9A-4641-BF04-5968527A9237">
                        <p class="notep1">也可以看看：</p>
                        <p><span class="q">“ <a href="translator-command-line-and-options.html#GUID-51E9826F-8FD9-48CD-9423-9DA8CDC10180">Code Generation_ Optimizations_和CHAR Comparisons的选项</a> ”</span></p>
                     </div>
                     <p>请注意以下事项：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>仅当您使用在线语义检查时才使用<code class="codeph">-optcols</code>选项，其中您已经适当地使用SQLJ转换程序<code class="codeph">-user</code> ， <code class="codeph">-password</code>和<code class="codeph">-url</code>选项在转换期间请求数据库连接。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">-optcols</code> ， <code class="codeph">-optparams</code>和<code class="codeph">-optparamdefaults</code>选项的功能（包括默认值）与相应的自定义程序选项相同。
                           </p>
                        </li>
                     </ul>
                  </div>
               </div><a id="JSQLJ246"></a><div class="props_rev_3"><a id="GUID-A19B87D2-C37F-43F2-B7B8-00E383441565" name="GUID-A19B87D2-C37F-43F2-B7B8-00E383441565"></a><h4 id="JSQLJ-GUID-A19B87D2-C37F-43F2-B7B8-00E383441565" class="sect4">Oracle特定代码生成的优缺点</h4>
                  <div>
                     <p>与ISO标准代码生成相比，Oracle特定代码生成具有以下优势：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>应用程序运行更有效。该代码直接调用JDBC应用程序编程接口（API），将运行时性能直接放在JDBC级别。在程序执行期间，中间SQLJ运行时层的角色大大减少。</p>
                        </li>
                        <li>
                           <p>应用程序尺寸较小。</p>
                        </li>
                        <li>
                           <p>不生成任何配置文件（ <code class="codeph">.ser</code> ）。如果要将已翻译的应用程序加载到数据库或将其移植到另一个系统，这是特别方便的，因为组件较少。
                           </p>
                        </li>
                        <li>
                           <p>翻译速度更快，因为没有配置文件自定义步骤。</p>
                        </li>
                        <li>
                           <p>在执行期间，Oracle SQLJ运行时和Oracle JDBC驱动程序使用相同的语句缓存资源，因此不必在两者之间分配资源。</p>
                        </li>
                        <li>
                           <p>将特定于SQL的信息显示在Java类文件中而不是单独的配置文件中可避免潜在的安全问题。</p>
                        </li>
                        <li>
                           <p>您无需重写代码即可利用未来可能的Oracle JDBC性能增强功能，例如考虑执行静态SQL代码的增强功能。Oracle SQLJ转换器的未来版本将自动处理此问题。</p>
                        </li>
                        <li>
                           <p>消除了在运行时使用Java反射，从而为浏览器环境提供了完全的可移植性。</p>
                        </li>
                     </ul>
                     <p>然而。有一些缺点：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>特定于Oracle的生成代码可能无法移植到通用JDBC平台。</p>
                        </li>
                        <li>
                           <p>特定于配置文件的功能不可用。例如，您无法在以后执行自定义以使用Oracle自定义程序工具<code class="codeph">-debug</code> ， <code class="codeph">-verify</code>和<code class="codeph">-print</code>选项。
                           </p>
                           <div class="infoboxnotealso" id="GUID-A19B87D2-C37F-43F2-B7B8-00E383441565__GUID-F7E19961-18EF-40B9-A52A-82EC868C4A36">
                              <p class="notep1">也可以看看：</p>
                              <p><span class="q">“ <a href="appendix.html#GUID-C5D50F74-E805-4DDA-AC81-353C94C40A21">用于连接的自定义程序线束选项</a> ”</span>和<span class="q">“ <a href="appendix.html#GUID-B820810A-DDDF-4E42-A3C9-AF04F4DC7075">用于调试的AuditorInstaller自定义程序</a> ”</span></p>
                           </div>
                        </li>
                     </ul>
                  </div>
               </div>
            </div><a id="JSQLJ247"></a><div class="props_rev_3"><a id="GUID-841EEFAD-3954-43D0-A270-679762CFBDED" name="GUID-841EEFAD-3954-43D0-A270-679762CFBDED"></a><h3 id="JSQLJ-GUID-841EEFAD-3954-43D0-A270-679762CFBDED" class="sect3">ISO标准代码生成</h3>
               <div>
                  <p>本节包括以下主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="key-programming-considerations.html#GUID-2381F925-E6BF-4D99-AFED-52542E882ECE">ISO标准代码生成的环境要求</a></p>
                     </li>
                     <li>
                        <p><a href="key-programming-considerations.html#GUID-7A1FD4B1-A6F8-43C5-806B-631BF6DEAF73">SQLJ转换器和SQLJ运行时</a></p>
                     </li>
                     <li>
                        <p><a href="key-programming-considerations.html#GUID-41FD26F1-774D-4944-B048-8787AA128B46">SQLJ配置文件</a></p>
                     </li>
                     <li>
                        <p><a href="key-programming-considerations.html#GUID-C11983AD-9623-45AF-B649-56438BC8B8E0">SQLJ翻译步骤</a></p>
                     </li>
                     <li>
                        <p><a href="key-programming-considerations.html#GUID-45D9DBCC-4FC0-4931-8ED1-A0B9631C4C93">译者输入输出综述</a></p>
                     </li>
                     <li>
                        <p><a href="key-programming-considerations.html#GUID-7E45FD80-5D57-495A-8849-154C8271FCDC">SQLJ运行时处理</a></p>
                     </li>
                     <li>
                        <p><a href="key-programming-considerations.html#GUID-00713D81-0AA9-42B3-90FE-8E873C64FFEC">部署方案</a></p>
                     </li>
                  </ul>
               </div><a id="JSQLJ248"></a><div class="props_rev_3"><a id="GUID-2381F925-E6BF-4D99-AFED-52542E882ECE" name="GUID-2381F925-E6BF-4D99-AFED-52542E882ECE"></a><h4 id="JSQLJ-GUID-2381F925-E6BF-4D99-AFED-52542E882ECE" class="sect4">ISO标准代码生成的环境要求</h4>
                  <div>
                     <p>默认情况下，Oracle SQLJ实现通过直接调用Oracle JDBC驱动程序生成特定于Oracle的代码，而不是生成调用SQLJ运行时的ISO标准代码。以下是ISO标准代码生成的典型环境设置：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>SQLJ代码生成： <code class="codeph">-codegen=iso</code></p>
                        </li>
                        <li>
                           <p>SQLJ翻译库： <code class="codeph">translator.jar</code></p>
                        </li>
                        <li>
                           <p>SQLJ运行时库：带有JDK 6或JDK 7的<code class="codeph">runtime12.jar</code>和Oracle Database 12 <span class="italic">c</span>第2版（12.2）</p>
                        </li>
                        <li>
                           <p>JDBC驱动程序：Oracle Database 12 <span class="italic">c</span>第2版（12.2） <code class="codeph">ojdbc6.jar</code>或<code class="codeph">ojdbc7.jar</code></p>
                        </li>
                        <li>
                           <p>JDK版本：JDK 6或JDK 7</p>
                        </li>
                     </ul>
                  </div>
               </div><a id="JSQLJ249"></a><div class="props_rev_3"><a id="GUID-7A1FD4B1-A6F8-43C5-806B-631BF6DEAF73" name="GUID-7A1FD4B1-A6F8-43C5-806B-631BF6DEAF73"></a><h4 id="JSQLJ-GUID-7A1FD4B1-A6F8-43C5-806B-631BF6DEAF73" class="sect4">SQLJ转换器和SQLJ运行时</h4>
                  <div>
                     <p>以下部分描述了在生成ISO标准代码时Oracle SQLJ实现的差异：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>SQLJ转换器：与<code class="codeph">.java</code>文件一起，转换器还为ISO标准代码生成生成一个或多个SQLJ配置文件。这些配置文件包含有关嵌入式SQL操作的信息。然后，SQLJ自动调用Java编译器从<code class="codeph">.java</code>文件生成<code class="codeph">.class</code>文件。
                           </p>
                           <div class="infoboxnotealso" id="GUID-7A1FD4B1-A6F8-43C5-806B-631BF6DEAF73__GUID-2715F2A6-F467-44CB-AE48-20B3E05177F0">
                              <p class="notep1">也可以看看：</p>
                              <p><span class="q">“ <a href="intro-to-SQLJ.html#GUID-BDC15EAD-5848-43A6-8261-19D3BD12C189">SQLJ翻译功能</a> ”</span></p>
                           </div>
                        </li>
                        <li>
                           <p>SQLJ运行时：对于ISO标准代码生成，SQLJ运行时通过使用JDBC驱动程序访问数据库来实现SQL操作的所需操作。通用ISO SQLJ标准不要求SQLJ运行时使用JDBC驱动程序来访问数据库。</p>
                           <div class="infoboxnotealso" id="GUID-7A1FD4B1-A6F8-43C5-806B-631BF6DEAF73__GUID-EDBD5168-F7BE-4C98-B551-6269B57D6AC9">
                              <p class="notep1">也可以看看：</p>
                              <p><span class="q">“ <a href="intro-to-SQLJ.html#GUID-FADAA0D5-A849-4E26-BEFE-47D7073D21B6">SQLJ运行时</a> ”</span> <a href="translator-run-time-functionality.html#GUID-AFF5C519-028E-4554-98E8-B8FF103515D1">SQLJ运行时</a></p>
                           </div>
                        </li>
                     </ul>
                     <p>除了翻译和运行时，还有一个称为。的组件<a id="d8416e4168" class="indexterm-anchor"></a> <span class="bold">定制器</span>发挥作用。定制程序为特定数据库实现和特定于供应商的功能和数据类型定制SQLJ配置文件。默认情况下，对于ISO标准代码，SQLJ前端调用Oracle自定义程序来定制Oracle数据库实例和Oracle特定功能和数据类型的配置文件。
                     </p>
                     <p>在转换期间使用Oracle自定义程序时，应用程序在运行时将需要SQLJ运行时和Oracle JDBC驱动程序。</p>
                     <div class="infoboxnote" id="GUID-7A1FD4B1-A6F8-43C5-806B-631BF6DEAF73__GUID-AE9AB712-4F1F-49C8-9BF0-B783E070CF29">
                        <p class="notep1">注意：</p>
                        <p>自Oracle Database <span class="italic">10g</span>第1版以来，SQLJ仅支持Oracle JDBC驱动程序。</p>
                     </div>
                  </div>
               </div><a id="JSQLJ250"></a><div class="props_rev_3"><a id="GUID-41FD26F1-774D-4944-B048-8787AA128B46" name="GUID-41FD26F1-774D-4944-B048-8787AA128B46"></a><h4 id="JSQLJ-GUID-41FD26F1-774D-4944-B048-8787AA128B46" class="sect4">SQLJ配置文件</h4>
                  <div>
                     <p>使用ISO标准代码生成，SQLJ概要文件是由SQLJ转换器生成的序列化Java资源或类，其中包含有关嵌入式SQL语句的详细信息。翻译人员创建这些配置文件。然后，根据转换程序选项设置，它将序列化配置文件并将它们放入二进制资源文件或将它们放入<code class="codeph">.class</code>文件中。
                     </p>
                     <p>本节包括以下主题：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="key-programming-considerations.html#GUID-330EDB33-4131-46B6-9A29-3841364AB613">配置文件概述</a></p>
                        </li>
                        <li>
                           <p><a href="key-programming-considerations.html#GUID-957F54E4-3F66-40CC-A251-50F2A11295EF">二进制便携性</a></p>
                        </li>
                     </ul>
                  </div><a id="JSQLJ251"></a><div class="props_rev_3"><a id="GUID-330EDB33-4131-46B6-9A29-3841364AB613" name="GUID-330EDB33-4131-46B6-9A29-3841364AB613"></a><h5 id="JSQLJ-GUID-330EDB33-4131-46B6-9A29-3841364AB613" class="sect5">配置文件概述</h5>
                     <div>
                        <p>SQLJ概要文件在ISO标准代码中用于在SQLJ可执行语句中实现嵌入式SQL操作。配置文件包含有关SQL操作以及所访问数据的类型和模式的信息。概要文件由一组条目组成，每个条目映射到一个SQL操作。每个条目都完全指定相应的SQL操作，描述处理该指令时使用的每个参数。</p>
                        <p>SQLJ为应用程序中的每个连接上下文类生成一个配置文件，其中每个连接上下文类对应于您在数据库操作中使用的一组特定SQL实体。有一个默认的连接上下文类，您可以声明其他类。ISO SQLJ标准要求配置文件具有标准格式和内容。因此，要使应用程序使用特定于供应商的扩展功能，必须自定义配置文件。默认情况下，这会自动发生，您的配置文件会自定义为使用特定于Oracle的扩展功能。</p>
                        <p>配置文件自定义使供应商能够通过以下方式增加价值：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>供应商可以支持自己的特定数据类型和SQL语法。例如，Oracle定制程序将已翻译的SQLJ代码中的标准JDBC <code class="codeph">PreparedStatement</code>方法调用映射到<code class="codeph">OraclePreparedStatement</code>方法调用，后者为Oracle类型扩展提供支持。
                              </p>
                           </li>
                           <li>
                              <p>供应商可以通过特定的优化来提高性能。</p>
                           </li>
                        </ul>
                        <div class="infoboxnote" id="GUID-330EDB33-4131-46B6-9A29-3841364AB613__GUID-C5E80838-B6D8-47B9-A0E3-BD7363198355">
                           <p class="notep1">注意：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>默认情况下，SQLJ配置文件文件名具有<code class="codeph">.ser</code>扩展名，但这并不意味着所有<code class="codeph">.ser</code>文件都是配置文件。其他序列化对象可以使用此扩展，并且SQLJ程序单元可以使用除其配置文件之外的序列化对象。（可选）可以将配置文件转换为<code class="codeph">.class</code>文件而不是<code class="codeph">.ser</code>文件。
                                 </p>
                              </li>
                              <li>
                                 <p>如果源代码中没有SQLJ可执行语句，则不会生成SQLJ概要文件。</p>
                              </li>
                           </ul>
                        </div>
                     </div>
                  </div><a id="JSQLJ252"></a><div class="props_rev_3"><a id="GUID-957F54E4-3F66-40CC-A251-50F2A11295EF" name="GUID-957F54E4-3F66-40CC-A251-50F2A11295EF"></a><h5 id="JSQLJ-GUID-957F54E4-3F66-40CC-A251-50F2A11295EF" class="sect5">二进制便携性</h5>
                     <div>
                        <p>SQLJ生成的配置文件支持二进制可移植性。也就是说，如果您没有使用特定于供应商的数据类型或功能，则可以按原样移植它们并将其与其他类型的数据库或其他环境一起使用。对于生成的<code class="codeph">.class</code>文件也是如此。
                        </p>
                     </div>
                  </div>
               </div><a id="JSQLJ254"></a><a id="JSQLJ253"></a><div class="props_rev_3"><a id="GUID-C11983AD-9623-45AF-B649-56438BC8B8E0" name="GUID-C11983AD-9623-45AF-B649-56438BC8B8E0"></a><h4 id="JSQLJ-GUID-C11983AD-9623-45AF-B649-56438BC8B8E0" class="sect4">SQLJ翻译步骤</h4>
                  <div>
                     <p>对于ISO标准代码生成（ <code class="codeph">-codegen=iso</code> ），转换程序处理SQLJ源代码，将SQL操作转换为SQLJ运行时调用，并生成Java输出代码和一个或多个SQLJ配置文件。为源代码中的每个连接上下文类生成单独的配置文件，其中不同的连接上下文类通常用于操作中使用的每个相互关联的SQL实体集。
                     </p>
                     <p>生成的Java代码放入包含以下内容的<code class="codeph">.java</code>输出文件中：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>来自<code class="codeph">.sqlj</code>源文件的任何类定义和Java代码</p>
                        </li>
                        <li>
                           <p>作为SQLJ迭代器和连接上下文声明的结果创建的类定义</p>
                           <div class="infoboxnotealso" id="GUID-C11983AD-9623-45AF-B649-56438BC8B8E0__GUID-13B25BDB-97D2-4927-9D63-A055AA4065B9">
                              <p class="notep1">也可以看看：</p>
                              <p><span class="q">“ <a href="basic-language-features.html#GUID-74A36C5C-B63E-4489-A464-47387ABCB24E">SQLJ声明概述</a> ”</span></p>
                           </div>
                        </li>
                        <li>
                           <p>一个称为的专门类的类定义<a id="d8416e4376" class="indexterm-anchor"></a> SQLJ生成并与配置文件一起使用的<span class="bold">profile-keys</span>类（仅用于ISO标准SQLJ代码生成）</p>
                        </li>
                        <li>
                           <p>调用<span>SQLJ运行时</span>来实现嵌入式SQL操作的操作</p>
                        </li>
                     </ul>
                     <p>生成的配置文件包含有关SQLJ源代码中所有嵌入式SQL语句的信息，例如要执行的操作，要操作的数据类型以及正在访问的表。运行应用程序时，SQLJ运行时访问配置文件以检索SQL操作并将它们传递给JDBC驱动程序。</p>
                     <p>默认情况下，配置文件放入<code class="codeph">.ser</code>序列化资源文件，但SQLJ可以选择将<code class="codeph">.ser</code>文件转换为<code class="codeph">.class</code>文件作为转换的一部分。
                     </p>
                     <p>编译器编译生成的Java源文件并根据需要生成Java <code class="codeph">.class</code>文件。这包括为每个定义的类，每个SQLJ声明和profile-keys类的<code class="codeph">.class</code>文件。然后，JVM调用Oracle定制程序或其他指定的定制程序来自定义生成的概要文件。
                     </p>
                     <div class="infoboxnotealso" id="GUID-C11983AD-9623-45AF-B649-56438BC8B8E0__GUID-4C825FDA-558D-4076-B486-7BFDDEEAFD36">
                        <p class="notep1">也可以看看：</p>
                        <p><span class="q">“ <a href="translator-run-time-functionality.html#GUID-D48A9F0A-67FD-4B49-B219-7EC6FEE1F4E3">内部翻译操作</a> ”</span></p>
                     </div>
                     <div class="section">
                        <p class="subhead3" id="GUID-C11983AD-9623-45AF-B649-56438BC8B8E0__GUID-791A6B65-5B0D-4816-A844-454E0AE041D0">一般SQLJ笔记</p>
                     </div>
                     <!-- class="section" -->
                     <p>在为特定于ISO的代码生成转换和运行SQLJ应用程序时，请考虑以下事项：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>除了在命令行上编译现有的<code class="codeph">.java</code>文件并使它们可用于类型解析之外，对于Oracle特定的代码生成，您还需要：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>自定义现有配置文件</p>
                              </li>
                              <li>
                                 <p>自定义包含配置文件的Java Archive（JAR）文件</p>
                              </li>
                           </ul>
                           <div class="infoboxnotealso" id="GUID-C11983AD-9623-45AF-B649-56438BC8B8E0__GUID-AE5CB55E-F78F-4085-8688-3A85A892F9D2">
                              <p class="notep1">也可以看看：</p>
                              <p><span class="q">“ <a href="translator-command-line-and-options.html#GUID-F40E0AE9-4103-4878-B21B-7B0BC275F67C">翻译命令行和属性文件</a> ”</span></p>
                           </div>
                        </li>
                        <li>
                           <p>仅当源代码包含SQLJ可执行语句时，SQLJ才会生成概要文件和概要文件密钥类。</p>
                        </li>
                        <li>
                           <p>如果在转换期间使用Oracle自定义程序，那么即使您的代码不使用Oracle特定的功能，您的应用程序在运行时也需要Oracle SQLJ运行时和Oracle JDBC驱动程序。您可以通过在翻译时指定<code class="codeph">-profile=false</code>来避免这种情况，从而绕过特定于Oracle的自定义。
                           </p>
                        </li>
                     </ul>
                  </div>
               </div><a id="JSQLJ255"></a><div class="props_rev_3"><a id="GUID-45D9DBCC-4FC0-4931-8ED1-A0B9631C4C93" name="GUID-45D9DBCC-4FC0-4931-8ED1-A0B9631C4C93"></a><h4 id="JSQLJ-GUID-45D9DBCC-4FC0-4931-8ED1-A0B9631C4C93" class="sect4">译者输入输出综述</h4>
                  <div>
                     <p>我们已经看到了SQLJ转换器作为输入的内容，它作为输出产生的内容，以及在特定于Oracle的代码生成的情况下将其输出放在何处。本节介绍了ISO标准代码生成的相同主题：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="key-programming-considerations.html#GUID-45B0510B-7684-4001-94D0-03ABAFEAA962">译者输入</a></p>
                        </li>
                        <li>
                           <p><a href="key-programming-considerations.html#GUID-9704CCB3-9348-4711-AA9D-872B29DF6B85">译者输出</a></p>
                        </li>
                        <li>
                           <p><a href="key-programming-considerations.html#GUID-B27B2B29-F108-40AB-BBF6-2F04C9DB863D">输出文件位置</a></p>
                        </li>
                     </ul>
                     <div class="infoboxnotealso" id="GUID-45D9DBCC-4FC0-4931-8ED1-A0B9631C4C93__GUID-828BD0ED-85D7-4126-ADF8-335692DA10F8">
                        <p class="notep1">也可以看看：</p>
                        <p><span class="q">“ <a href="intro-to-SQLJ.html#GUID-68C57EA9-1ECC-424A-902C-25C087DB9AA0">译者输入和输出摘要</a> ”</span></p>
                     </div>
                  </div><a id="JSQLJ256"></a><div class="props_rev_3"><a id="GUID-45B0510B-7684-4001-94D0-03ABAFEAA962" name="GUID-45B0510B-7684-4001-94D0-03ABAFEAA962"></a><h5 id="JSQLJ-GUID-45B0510B-7684-4001-94D0-03ABAFEAA962" class="sect5">译者输入</h5>
                     <div>
                        <p>与Oracle特定代码生成类似，SQLJ转换器将一个或多个<code class="codeph">.sqlj</code>源文件作为输入，可以在命令行中指定。主<code class="codeph">.sqlj</code>文件的名称基于它定义的公共类，如果有的话，在它定义的第一个类上。
                        </p>
                        <div class="infoboxnotealso" id="GUID-45B0510B-7684-4001-94D0-03ABAFEAA962__GUID-C728BA11-D297-4CFF-B7F0-6E5F04FDDF57">
                           <p class="notep1">也可以看看：</p>
                           <p><span class="q">“ <a href="intro-to-SQLJ.html#GUID-F6F8C7BD-70B8-4C22-B98F-CD44962D3243">译者输入</a> ”</span></p>
                        </div>
                     </div>
                  </div><a id="JSQLJ257"></a><div class="props_rev_3"><a id="GUID-9704CCB3-9348-4711-AA9D-872B29DF6B85" name="GUID-9704CCB3-9348-4711-AA9D-872B29DF6B85"></a><h5 id="JSQLJ-GUID-9704CCB3-9348-4711-AA9D-872B29DF6B85" class="sect5">译者输出</h5>
                     <div>
                        <p>转换步骤为应用程序中的每个<code class="codeph">.sqlj</code>文件生成Java源文件，并为ISO标准代码生成至少一个应用程序配置文件，假设源代码使用SQLJ可执行语句。
                        </p>
                        <p>SQLJ生成Java源文件和应用程序配置文件，如下所示：</p>
                        <div class="infoboxnotealso" id="GUID-9704CCB3-9348-4711-AA9D-872B29DF6B85__GUID-A6EB9074-65B9-4E0F-A4E7-F0E7C216366F">
                           <p class="notep1">也可以看看：</p>
                           <p><span class="q">“ <a href="intro-to-SQLJ.html#GUID-AB5D0342-DC8A-4435-8B40-8EE70875DBB3">翻译输出</a> ”</span></p>
                        </div>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>与Oracle特定的代码生成类似，Java源文件是<code class="codeph">.java</code>文件，其基本名称与<code class="codeph">.sqlj</code>文件相同。
                              </p>
                           </li>
                           <li>
                              <p>应用程序概要文件（如果适用）包含有关SQLJ应用程序的SQL操作的信息。应用程序中使用的每个连接类都有一个配置文件。配置文件的名称与主<code class="codeph">.sqlj</code>文件具有相同的基本名称，并具有以下扩展名：</p><pre class="oac_no_warn" dir="ltr">_SJProfile0.ser _SJProfile1.ser _SJProfile2.ser ...
</pre><p>例如，对于<code class="codeph">MyClass.sqlj</code> ，翻译器生成：</p><pre class="oac_no_warn" dir="ltr">MyClass_SJProfile0.ser</pre><p><code class="codeph">.ser</code>文件扩展名表示配置文件已序列化。<code class="codeph">.ser</code>文件是二进制文件。
                              </p>
                              <div class="infoboxnote" id="GUID-9704CCB3-9348-4711-AA9D-872B29DF6B85__GUID-4B9A5A56-B581-45F6-889C-7CF654FBD511">
                                 <p class="notep1">注意：</p>
                                 <p><code class="codeph">-ser2class</code>转换程序选项指示转换程序将配置文件生成为<code class="codeph">.class</code>文件而不是<code class="codeph">.ser</code>文件。除了文件扩展名，命名是相同的。
                                 </p>
                              </div>
                           </li>
                        </ul>
                        <p>与Oracle特定代码生成的编译步骤类似，将Java源文件编译为多个类文件会为<code class="codeph">.sqlj</code>源文件中定义的每个类生成一个<code class="codeph">.class</code>文件。但是在生成ISO代码的情况下，还会为称为的类生成<code class="codeph">.class</code>文件<a id="d8416e4621" class="indexterm-anchor"></a> <span class="bold">profile-keys</span>类，翻译器生成并与配置文件一起使用以实现SQL操作。如果声明任何SQLJ迭代器或连接上下文，则会生成其他<code class="codeph">.class</code>文件。此外，与Oracle特定的代码生成一样，为代码中的任何内部类或匿名类生成单独的<code class="codeph">.class</code>文件。
                        </p>
                        <div class="infoboxnotealso" id="GUID-9704CCB3-9348-4711-AA9D-872B29DF6B85__GUID-3BB5BBAA-C232-453D-9F84-ADDBE9D80128">
                           <p class="notep1">也可以看看：</p>
                           <p><span class="q">“ <a href="basic-language-features.html#GUID-74A36C5C-B63E-4489-A464-47387ABCB24E">SQLJ声明概述</a> ”</span></p>
                        </div>
                        <p><code class="codeph">.class</code>文件的名称如下：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>与特定于Oracle的代码生成一样，定义的每个类的类文件都包含具有<code class="codeph">.class</code>扩展名的类的名称。
                              </p>
                           </li>
                           <li>
                              <p>转换程序生成的profile-keys类是根据主<code class="codeph">.sqlj</code>文件的基本名称命名的，还包括以下内容：</p><pre class="oac_no_warn" dir="ltr">_SJProfileKeys</pre><p>因此，类文件具有以下扩展名：</p><pre class="oac_no_warn" dir="ltr">_SJProfileKeys.class</pre><p>例如，对于<code class="codeph">MyClass.sqlj</code> ，翻译器与编译器一起生成：</p><pre class="oac_no_warn" dir="ltr">MyClass_SJProfileKeys.class</pre></li>
                           <li>
                              <p>与特定于Oracle的代码生成一样，转换程序根据您声明它们的方式命名迭代器类和连接上下文类。</p>
                           </li>
                        </ul>
                        <p>自定义步骤会更改配置文件，但不会产生额外的输出。</p>
                        <div class="infoboxnotealso" id="GUID-9704CCB3-9348-4711-AA9D-872B29DF6B85__GUID-9680D6F5-5B44-4294-843B-55B1DF25512E">
                           <p class="notep1">也可以看看：</p>
                           <p><span class="q">“ <a href="translator-run-time-functionality.html#GUID-1C3E2732-1185-4961-BA6B-5BA97A35EA48">配置文件定制（ISO代码生成）</a> ”</span></p>
                        </div>
                        <div class="infoboxnote" id="GUID-9704CCB3-9348-4711-AA9D-872B29DF6B85__GUID-24EDEE96-542F-4BA2-882D-4BAEE28753B0">
                           <p class="notep1">注意：</p>
                           <p>没有必要直接引用SQLJ配置文件或profile-keys类。这一切都是自动处理的。</p>
                        </div>
                     </div>
                  </div><a id="JSQLJ258"></a><div class="props_rev_3"><a id="GUID-B27B2B29-F108-40AB-BBF6-2F04C9DB863D" name="GUID-B27B2B29-F108-40AB-BBF6-2F04C9DB863D"></a><h5 id="JSQLJ-GUID-B27B2B29-F108-40AB-BBF6-2F04C9DB863D" class="sect5">输出文件位置</h5>
                     <div>
                        <p>对于特定于Oracle的代码生成和ISO标准代码生成，输出文件位置都相同。</p>
                        <div class="infoboxnotealso" id="GUID-B27B2B29-F108-40AB-BBF6-2F04C9DB863D__GUID-E4F17A1B-CD8B-4B67-A7A2-67789A0DD958">
                           <p class="notep1">也可以看看：</p>
                           <p><span class="q">“ <a href="intro-to-SQLJ.html#GUID-88DCEAAC-F9CD-43BD-BC31-CE3F3745FBD7">输出文件位置</a> ”</span></p>
                        </div>
                     </div>
                  </div>
               </div><a id="JSQLJ259"></a><div class="props_rev_3"><a id="GUID-7E45FD80-5D57-495A-8849-154C8271FCDC" name="GUID-7E45FD80-5D57-495A-8849-154C8271FCDC"></a><h4 id="JSQLJ-GUID-7E45FD80-5D57-495A-8849-154C8271FCDC" class="sect4">SQLJ运行时处理</h4>
                  <div>
                     <p>本节讨论程序执行期间ISO标准代码的运行时处理。</p>
                     <p>对于ISO标准SQLJ应用程序，SQLJ运行时读取配置文件并创建包含数据库连接的连接配置文件。每次应用程序必须访问数据库时，都会发生以下情况：</p>
                     <ol>
                        <li>
                           <p>SQLJ生成的应用程序代码使用SQLJ生成的profile-keys类中的方法来访问连接的配置文件并读取相关的SQL操作。应用程序中的SQLJ可执行语句与概要文件中的SQL操作之间存在映射。</p>
                        </li>
                        <li>
                           <p>SQLJ生成的应用程序代码调用SQLJ运行时，该运行时从配置文件中读取SQL操作。</p>
                        </li>
                        <li>
                           <p>SQLJ运行时调用JDBC驱动程序并将SQL操作传递给驱动程序。</p>
                        </li>
                        <li>
                           <p>SQLJ运行时将任何输入参数传递给JDBC驱动程序。</p>
                        </li>
                        <li>
                           <p>JDBC驱动程序执行SQL操作。</p>
                        </li>
                        <li>
                           <p>如果要返回任何数据，则数据库将其发送到JDBC驱动程序，该驱动程序将其发送到SQLJ运行时以供应用程序使用。</p>
                        </li>
                     </ol>
                     <div class="infoboxnote" id="GUID-7E45FD80-5D57-495A-8849-154C8271FCDC__GUID-CF10EACA-F8EA-4DD9-8A1B-A0E55C1D1AAD">
                        <p class="notep1">注意：</p>
                        <p>传递输入参数也可以称为绑定输入参数或绑定主机表达式。术语宿主变量，主机表达式，绑定变量和绑定表达式都用于描述用作SQL操作的输入或输出的Java变量或表达式。</p>
                     </div>
                  </div>
               </div><a id="JSQLJ260"></a><div class="props_rev_3"><a id="GUID-00713D81-0AA9-42B3-90FE-8E873C64FFEC" name="GUID-00713D81-0AA9-42B3-90FE-8E873C64FFEC"></a><h4 id="JSQLJ-GUID-00713D81-0AA9-42B3-90FE-8E873C64FFEC" class="sect4">部署方案</h4>
                  <div>
                     <p>我们已经讨论了如何在以下场景中运行Oracle特定的SQLJ代码：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>从小程序</p>
                        </li>
                        <li>
                           <p>在服务器中（也可选择在服务器中运行SQLJ转换器）</p>
                        </li>
                     </ul>
                     <p>从applet运行ISO标准代码时，需要考虑以下几点：</p>
                     <div class="infoboxnotealso" id="GUID-00713D81-0AA9-42B3-90FE-8E873C64FFEC__GUID-8F075DE2-C541-4659-A512-62EC3DD7D5F4">
                        <p class="notep1">也可以看看：</p>
                        <p><span class="q">“ <a href="intro-to-SQLJ.html#GUID-24B99BA3-A097-447B-82F6-E234FFD7B9CA">替代部署方案</a> ”</span></p>
                     </div>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>您必须使用applet打包所有SQLJ运行时包。包裹是：</p><pre class="oac_no_warn" dir="ltr">sqlj.runtime sqlj.runtime.ref sqlj.runtime.profile sqlj.runtime.profile.ref sqlj.runtime.error</pre><p>如果您使用Oracle自定义，还要打包以下内容：</p><pre class="oac_no_warn" dir="ltr">oracle.sqlj.runtime oracle.sqlj.runtime.error</pre><p>这些包随Oracle安装一起包含在<span class="italic"><code class="codeph">ORACLE_HOME</code></span> <code class="codeph">/lib</code>目录中的多个运行时库之一中。
                           </p>
                           <div class="infoboxnotealso" id="GUID-00713D81-0AA9-42B3-90FE-8E873C64FFEC__GUID-18822C04-ACAB-4BB2-8710-528B09D7BAA1">
                              <p class="notep1">也可以看看：</p>
                              <p><span class="q">“ <a href="getting-started.html#GUID-59D43923-4D2A-42FB-8F03-9CF1F3B60C67">使用Oracle SQLJ实现的要求</a> ”</span></p>
                           </div>
                        </li>
                        <li>
                           <p>某些浏览器（如Netscape Navigator 4.x）不支持扩展名为<code class="codeph">.ser</code>资源文件，该扩展名是用于配置文件的SQLJ序列化对象文件所使用的扩展名。但是，Sun Microsystems Java插件支持<code class="codeph">.ser</code>文件。
                           </p>
                           <p>或者，如果您不想使用该插件，则Oracle SQLJ实现提供<code class="codeph">-ser2class</code>选项，以便在转换期间将<code class="codeph">.ser</code>文件转换为<code class="codeph">.class</code>文件。
                           </p>
                           <div class="infoboxnote" id="GUID-00713D81-0AA9-42B3-90FE-8E873C64FFEC__GUID-E169ECA7-E861-48E4-9B42-550706509E06">
                              <p class="notep1">注意：</p>
                              <p>这方面的考虑<span class="italic">并不</span>适用于默认的Oracle特定的代码生成，其中的配置文件没有生产。
                              </p>
                           </div>
                        </li>
                        <li>
                           <p>使用Oracle特定功能的Applet需要Oracle SQLJ运行时才能运行。Oracle SQLJ运行时由<code class="codeph">oracle.sqlj.下的SQLJ运行时库文件中的类组成<code class="codeph">oracle.sqlj.*</code> 。Oracle SQLJ <code class="codeph">runtime.jar</code>库需要Java Reflection API， <code class="codeph">java.lang.reflect.*</code> 。大多数浏览器不支持Reflection API或强加安全限制，但Sun Microsystems Java插件提供对Reflection API的支持。</p>
                           <p>使用ISO标准代码生成时，无论您使用的SQLJ运行时版本如何，以下SQLJ语言功能始终都需要Java Reflection API：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">CAST</code>语句</p>
                              </li>
                              <li>
                                 <p><code class="codeph">REF CURSOR</code>参数或<code class="codeph">REF CURSOR</code>列作为SQLJ迭代器的实例从数据库中检索</p>
                              </li>
                              <li>
                                 <p>检索<code class="codeph">java.sql.Ref</code> ， <code class="codeph">Struct</code> ， <code class="codeph">Array</code> ， <code class="codeph">Blob</code>或<code class="codeph">Clob</code>对象</p>
                              </li>
                              <li>
                                 <p>检索SQL对象作为实现<code class="codeph">oracle.sql.的Java类的实例<code class="codeph">oracle.sql.ORAData</code>或<code class="codeph">java.sql.SQLData</code>接口</p>
                                 <div class="infoboxnote" id="GUID-00713D81-0AA9-42B3-90FE-8E873C64FFEC__GUID-B29A307C-3983-4A02-B03D-252D28225339">
                                    <p class="notep1">注意：</p>
                                    <ul style="list-style-type:disc">
                                       <li>
                                          <p>如果您在与ISO完全兼容的模式下使用SQLJ，则前面的例外情况就是如此。也就是说，如果在符合J2EE的环境中使用SQLJ，并使用SQLJ <code class="codeph">runtime12ee.jar</code>库转换和运行程序，并使用ISO指定的连接上下文类型映射。在这种情况下， <code class="codeph">java.sql.实例<code class="codeph">java.sql.在不使用反射的情况下检索Ref</code> ， <code class="codeph">Struct</code> ， <code class="codeph">Array</code> ， <code class="codeph">Blob</code> ， <code class="codeph">Clob</code>和<code class="codeph">SQLData</code> 。
                                          </p>
                                       </li>
                                       <li>
                                          <p>如果您使用特定于Oracle的代码生成，那么您将在列出的所有实例中消除反射的使用。</p>
                                       </li>
                                    </ul>
                                 </div>
                              </li>
                           </ul>
                        </li>
                     </ul>
                  </div>
               </div>
            </div><a id="JSQLJ261"></a><div class="props_rev_3"><a id="GUID-C45C47C7-D321-4162-8287-180A05B36BF3" name="GUID-C45C47C7-D321-4162-8287-180A05B36BF3"></a><h3 id="JSQLJ-GUID-C45C47C7-D321-4162-8287-180A05B36BF3" class="sect3">Oracle专用代码生成与ISO标准代码生成</h3>
               <div>
                  <p>Oracle SQLJ实现提供了Oracle特定代码生成选项，其中Oracle JDBC调用直接在代码中生成。这是默认行为。对于特定于Oracle的代码生成，您必须了解以下内容：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>没有配置文件，因此在翻译期间没有自定义步骤。</p>
                     </li>
                     <li>
                        <p>在运行时，SQL操作不必通过SQLJ运行时层，因为JDBC调用而不是SQLJ运行时调用直接在已转换的代码中生成。</p>
                     </li>
                  </ul>
               </div>
            </div><a id="JSQLJ262"></a><div class="props_rev_3"><a id="GUID-6AE4F277-58B0-4DC6-A516-4D6A6C5E839A" name="GUID-6AE4F277-58B0-4DC6-A516-4D6A6C5E839A"></a><h3 id="JSQLJ-GUID-6AE4F277-58B0-4DC6-A516-4D6A6C5E839A" class="sect3">命名的要求和限制</h3>
               <div>
                  <div class="section">
                     <p>在讨论命名要求，命名限制和保留字时，需要考虑四个方面：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>Java命名空间，包括SQLJ对局部变量和类的命名施加的额外限制</p>
                        </li>
                        <li>
                           <p>SQLJ名称空间</p>
                        </li>
                        <li>
                           <p>SQL命名空间</p>
                        </li>
                        <li>
                           <p>源文件名</p>
                        </li>
                     </ul>
                     <p>本节包括以下主题：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="key-programming-considerations.html#GUID-8D5F394B-1827-44E8-80A4-FC211E4FDBBF">Java命名空间：本地变量和类命名限制</a></p>
                        </li>
                        <li>
                           <p><a href="key-programming-considerations.html#GUID-4E1BC950-4C47-4E87-BBB1-9E8B81D6462D">SQLJ命名空间</a></p>
                        </li>
                        <li>
                           <p><a href="key-programming-considerations.html#GUID-2F273683-DDBA-4118-9D4B-740148B010CB">SQL命名空间</a></p>
                        </li>
                        <li>
                           <p><a href="key-programming-considerations.html#GUID-DB98C1EB-8A20-4D85-90F0-3F46D8689805">文件名要求和限制</a></p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
               </div><a id="JSQLJ264"></a><a id="JSQLJ265"></a><a id="JSQLJ263"></a><div class="props_rev_3"><a id="GUID-8D5F394B-1827-44E8-80A4-FC211E4FDBBF" name="GUID-8D5F394B-1827-44E8-80A4-FC211E4FDBBF"></a><h4 id="JSQLJ-GUID-8D5F394B-1827-44E8-80A4-FC211E4FDBBF" class="sect4">Java命名空间：本地变量和类命名限制</h4>
                  <div>
                     <p>Java命名空间适用于所有标准Java语句和声明，包括Java类和局部变量的命名。所有标准Java命名限制都适用，您应该避免使用Java保留字。</p>
                     <p>此外，SQLJ对局部变量和类的命名设置了一些小的限制。</p>
                     <div class="infoboxnote" id="GUID-8D5F394B-1827-44E8-80A4-FC211E4FDBBF__GUID-36C1CD79-A49F-45DC-ADCB-CBE5B7B85E96">
                        <p class="notep1">注意：</p>
                        <p><span class="q">“ <a href="basic-language-features.html#GUID-AE6CB258-0865-40BB-AC83-7057FC1798F7">主机表达式限制</a> ”</span>中讨论了特定于主机变量的命名限制。
                        </p>
                     </div>
                     <div class="section">
                        <p class="subhead3" id="GUID-8D5F394B-1827-44E8-80A4-FC211E4FDBBF__GUID-D67AE11F-D7DA-4B94-9027-F64EEA27DA3D">本地变量命名限制</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>SQLJ转换器的某些功能在命名局部变量时会产生一些小的限制。SQLJ转换器将每个SQLJ可执行语句替换为语句块，其中SQLJ可执行语句具有标准语法：</p><pre class="oac_no_warn" dir="ltr">#sql {SQL operation};</pre><p>SQLJ可以在生成的语句块中使用临时变量声明。任何此类临时变量的名称都将包含以下前缀：</p><pre class="oac_no_warn" dir="ltr">__sJT_</pre><div class="infoboxnote" id="GUID-8D5F394B-1827-44E8-80A4-FC211E4FDBBF__GUID-BEC66924-FE37-44A2-8A47-9B04D3DCD0B2">
                           <p class="notep1">注意：</p>
                           <p>开头有两个下划线，后面有一个下划线。</p>
                        </div>
                        <p>以下声明是SQLJ生成的语句块中可能出现的声明的示例：</p><pre class="oac_no_warn" dir="ltr">int __sJT_index;对象__sJT_key; java.sql中。PreparedStatement __sJT_stmt;</pre><p>字符串<code class="codeph">__sJT_</code>是SQLJ生成的变量名的保留前缀。SQLJ程序员不得将此字符串用作以下内容的前缀：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>在包含可执行SQL语句的块中声明的变量的名称</p>
                           </li>
                           <li>
                              <p>包含可执行SQL语句的方法的参数名称</p>
                           </li>
                           <li>
                              <p>包含可执行SQL语句的类中的字段名称，或其子类或封闭类包含可执行SQL语句的字段的名称</p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-8D5F394B-1827-44E8-80A4-FC211E4FDBBF__GUID-EC4977A2-DB56-4423-AD86-CD48986A1A10">类命名限制</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>请注意SQLJ应用程序中命名类的以下小限制：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>您不得声明可能与SQLJ内部类冲突的类名。特别是，顶级类不能具有以下形式的名称，其中<code class="codeph">a</code>是SQLJ应用程序中现有类的名称：</p><pre class="oac_no_warn" dir="ltr">a_SJb</pre><p>其中， <code class="codeph">a</code>和<code class="codeph">b</code>是合法的Java标识符。
                              </p>
                              <p>例如，如果您的应用程序类在文件<code class="codeph">Foo.sqlj</code>是<code class="codeph">Foo</code> ，则SQLJ会生成名为<code class="codeph">Foo_SJProfileKeys</code>的profile-keys类。不要声明与此冲突的类名。
                              </p>
                           </li>
                           <li>
                              <p>包含SQLJ可执行语句的类的名称不得与包含应用程序中使用的Java类型的任何包的名称的第一个组件相同。要避免的类名的示例是<code class="codeph">java</code> ， <code class="codeph">sqlj</code>和<code class="codeph">oracle</code> （区分大小写）。另一个例子，如果您的SQLJ语句使用类型为<code class="codeph">abc.def.主机变量<code class="codeph">abc.def.MyClass</code> ，那么你不能使用<code class="codeph">abc</code>作为使用这些宿主变量的类的名称。
                              </p>
                              <p>要避免此限制，请遵循Java命名约定，建议程序包名称以小写字母开头，类名称以大写字母开头。</p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ266"></a><div class="props_rev_3"><a id="GUID-4E1BC950-4C47-4E87-BBB1-9E8B81D6462D" name="GUID-4E1BC950-4C47-4E87-BBB1-9E8B81D6462D"></a><h4 id="JSQLJ-GUID-4E1BC950-4C47-4E87-BBB1-9E8B81D6462D" class="sect4">SQLJ命名空间</h4>
                  <div>
                     <p><span class="bold">SQLJ名称空间</span>引用<code class="codeph">#sql</code>类声明和大括号外的<code class="codeph">#sql</code>可执行语句部分。
                     </p>
                     <div class="infoboxnote" id="GUID-4E1BC950-4C47-4E87-BBB1-9E8B81D6462D__GUID-57EEA60E-F96E-4018-B4D0-C9803A13A62E">
                        <p class="notep1">注意：</p>
                        <p><span class="q">“ <a href="basic-language-features.html#GUID-FF318201-3A54-450E-AC86-616665E03DE2">使用命名迭代器</a> ”</span>中讨论了特定于迭代器列命名的限制。
                        </p>
                     </div>
                     <p>避免使用以下SQLJ保留字作为声明的连接上下文类或迭代器类， <code class="codeph">with</code>或<code class="codeph">implements</code>子句或迭代器列类型声明列表中的类名：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">迭代器</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">上下文</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">同</code></p>
                        </li>
                     </ul>
                     <p>例如，没有称为<code class="codeph">iterator</code>的迭代器类或实例或称为<code class="codeph">context</code>的连接上下文类或实例。
                     </p>
                     <p>但是，请注意，允许使用存储函数返回变量，其名称是这些单词中的任何一个。</p>
                  </div>
               </div><a id="JSQLJ267"></a><div class="props_rev_3"><a id="GUID-2F273683-DDBA-4118-9D4B-740148B010CB" name="GUID-2F273683-DDBA-4118-9D4B-740148B010CB"></a><h4 id="JSQLJ-GUID-2F273683-DDBA-4118-9D4B-740148B010CB" class="sect4">SQL命名空间</h4>
                  <div>
                     <p><span class="bold">SQL命名空间</span>引用大括号内的SQLJ可执行语句的一部分。标准SQL命名限制适用于此处。
                     </p>
                     <div class="infoboxnotealso" id="GUID-2F273683-DDBA-4118-9D4B-740148B010CB__GUID-D0CF8246-EBCA-480E-8962-2040E88EDBBC">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="../sqlrf/Syntax-for-Schema-Objects-and-Parts-in-SQL-Statements.html#SQLRF-GUID-1164C6E0-ABAB-49C2-8821-6B6C5047FEDD" target="_blank"><span class="italic">Oracle数据库SQL语言参考</span></a></p>
                     </div>
                     <p>但请注意，主机表达式遵循Java命名空间的规则，而不是SQL命名空间。这适用于主机变量的名称以及主机表达式的外括号之间的所有内容。</p>
                  </div>
               </div><a id="JSQLJ268"></a><div class="props_rev_3"><a id="GUID-DB98C1EB-8A20-4D85-90F0-3F46D8689805" name="GUID-DB98C1EB-8A20-4D85-90F0-3F46D8689805"></a><h4 id="JSQLJ-GUID-DB98C1EB-8A20-4D85-90F0-3F46D8689805" class="sect4">文件名要求和限制</h4>
                  <div>
                     <div class="section">
                        <p>SQLJ源文件具有<code class="codeph">.sqlj</code>文件扩展名。如果源文件声明了一个公共类（最多一个），则该文件的基本名称必须与此类的名称匹配（区分大小写）。如果源文件未声明公共类，则文件名仍必须是合法的Java标识符，并且建议文件名与第一个定义的类的名称匹配。
                        </p>
                        <p>例如，如果在源文件中定义公共类<code class="codeph">MySource</code> ，则文件名必须为：</p><pre class="oac_no_warn" dir="ltr">MySource.sqlj</pre><div class="infoboxnote" id="GUID-DB98C1EB-8A20-4D85-90F0-3F46D8689805__GUID-E4992A85-BFB0-44B4-AAA7-D1A00FA85FB1">
                           <p class="notep1">注意：</p>
                           <p>这些文件命名要求遵循Java语言规范（JLS），并且不是SQLJ特定的。这些要求不直接适用于Oracle Database 12 <span class="italic">c</span>第2版（12.2），但仍建议您遵守这些要求。
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="JSQLJ269"></a><div class="props_rev_3"><a id="GUID-55421A92-C6F6-47F1-8B40-A19B04D79C34" name="GUID-55421A92-C6F6-47F1-8B40-A19B04D79C34"></a><h3 id="JSQLJ-GUID-55421A92-C6F6-47F1-8B40-A19B04D79C34" class="sect3">SQLJ在中间层的注意事项</h3>
               <div>
                  <div class="section">
                     <p>如果在中间层运行SQLJ，则需要特别注意，例如在Oracle9 <span class="italic">i</span> Application Server Containers for J2EE（OC4J）环境中。
                     </p>
                     <p>Oracle JDBC驱动程序在<code class="codeph">oracle.jdbc</code>包中提供特定于Oracle的接口。Oracle SQLJ库<code class="codeph">runtime12.jar</code>和<code class="codeph">runtime12ee.jar</code>充分利用了这些接口，但这些库与Oracle9 <span class="italic">i</span> Application Server之前的Oracle JDBC实现不兼容。
                     </p>
                     <p>在Oracle9 <span class="italic">i</span> Application Server中，通过数据源建立连接，数据源通常返回<code class="codeph">oracle.jdbc.实例<code class="codeph">oracle.jdbc.OracleConnection</code>接口而不是旧的<code class="codeph">oracle.jdbc.driver.OracleConnection</code>类。这对于某些连接功能是必需的，例如分布式事务（XA）。要支持此类功能，连接对象必须实现新接口。
                     </p>
                     <p>这具有以下结果，与Oracle9 <span class="italic">i</span> Application Server中间层环境或使用数据源的任何情况相关：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>为了获得代码的最大可移植性和灵活性，请使用<code class="codeph">oracle.jdbc.OracleXXX</code>类型而不是<code class="codeph">oracle.jdbc.driver.OracleXXX</code>类型。
                           </p>
                        </li>
                        <li>
                           <p>对于自定义Java类型（通常用于SQL对象和集合），请实现<code class="codeph">oracle.sql.ORAData</code> 。
                           </p>
                        </li>
                        <li>
                           <p>不要使用SQLJ <code class="codeph">runtime</code>库。请改用<code class="codeph">runtime12</code>或<code class="codeph">runtime12ee</code> （取决于您的环境）。运行时库向后兼容旧的JDBC驱动程序，例如Oracle8 <span class="italic">i</span> Database 8.1.7中的驱动程序，因此支持<code class="codeph">oracle.jdbc.driver.OracleXXX</code>类型，而不是<code class="codeph">oracle.jdbc.OracleXXX</code>类型。
                           </p>
                           <p>但是，如果由于某种原因必须使用<code class="codeph">runtime</code>库，则在转换期间设置选项<code class="codeph">-profile=false</code> 。在这种情况下，您的程序将不使用特定于Oracle的自定义，因此，如果传递了<code class="codeph">oracle.jdbc. ，则不会失败<code class="codeph">oracle.jdbc.OracleConnection</code>实例而不是<code class="codeph">oracle.jdbc.driver.OracleConnection</code>实例。在这种情况下，将<span class="italic">不</span>支持特定于Oracle的功能。
                           </p>
                        </li>
                     </ul>
                     <p>为了便于管理通过数据源和连接JavaBeans（对于SQLJ JavaServer Pages）获得的连接，Oracle SQLJ实现在<code class="codeph">runtime12ee</code>库中提供了许多API。
                     </p>
                     <p>有关SQLJ对数据源和连接JavaBeans的支持的一般信息，请参阅以下部分：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><span class="q">“ <a href="advanced-language-features.html#GUID-BBB6A8DE-EEF3-454B-BF98-C12E32A81314">标准数据源支持</a> ”</span></p>
                        </li>
                        <li>
                           <p><span class="q">“ <a href="advanced-language-features.html#GUID-861032F9-E30B-4765-9BD6-12CCF54D2D75">SQLJ特定数据源</a> ”</span></p>
                        </li>
                        <li>
                           <p><span class="q">“ <a href="advanced-language-features.html#GUID-51755815-E5DB-41A3-8427-8969A0B90404">用于JavaServer Pages的SQLJ特定连接JavaBeans</a> ”</span></p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
               </div>
            </div>
         </div>
      </article>
   </body>
</html>