<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <meta name="abstract" content="This chapter describes how OCI manages transaction operations."></meta>
      <meta name="description" content="This chapter describes how OCI manages transaction operations."></meta>
      <title>管理可扩展平台</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Programmer&#39;s Guide"></meta>
      <meta property="og:description" content="This chapter describes how OCI manages transaction operations."></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Programmer&#39;s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="oracle-call-interface-programmers-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-14T08:46:00-08:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="1996, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96204-01"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="lobs-and-bfile-operations.html" title="Previous" type="text/html"></link>
      <link rel="next" href="session-and-connection-pooling.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Oracle Call Interface Programmer&#39;s Guide"></meta>
    <meta name="dcterms.isVersionOf" content="LNOCI"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="lobs-and-bfile-operations.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="session-and-connection-pooling.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">程序员指南</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">管理可扩展平台</li>
            </ol>
            <a id="GUID-F7F03E35-68F1-49CB-AAA7-231675506C62" name="GUID-F7F03E35-68F1-49CB-AAA7-231675506C62"></a><a id="LNOCI080"></a>
            
            <h2 id="LNOCI-GUID-F7F03E35-68F1-49CB-AAA7-231675506C62" class="sect2"><span class="enumeration_chapter">10</span>管理可扩展平台</h2>
         </header>
         <div class="ind">
            <div>
               <p>本章介绍OCI如何管理事务操作。</p>
               <p>本章包含以下主题：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="managing-scalable-platforms.html#GUID-3E96017A-64D3-4A29-B617-C9879610B5F2" title="OCI有一组API调用来支持本地和全局事务的操作。">OCI对交易的支持</a></p>
                  </li>
                  <li>
                     <p><a href="managing-scalable-platforms.html#GUID-AE6D1A12-06BA-4E37-971E-5B7B7111359E" title="OCI支持多个级别的事务复杂性。">交易复杂程度</a></p>
                  </li>
                  <li>
                     <p><a href="managing-scalable-platforms.html#GUID-5579C27E-2536-4B21-96DB-3EDFECF576B5" title="OCI可以验证和维护多个用户。">密码和会话管理</a></p>
                  </li>
                  <li>
                     <p><a href="managing-scalable-platforms.html#GUID-A5830D58-3079-45DD-BE3A-81C41991DA70" title="中间层应用程序接收来自浏览器客户端的请求。">OCI中的中间层应用</a></p>
                  </li>
                  <li>
                     <p><a href="managing-scalable-platforms.html#GUID-301306B2-A746-484D-BA6B-6A029B54FE75" title="外部初始化的上下文是可以从OCI初始化属性的应用程序上下文。使用SQL语句CREATE CONTEXT在服务器中使用选项INITIALIZED EXTERNALLY创建上下文命名空间。">OCI中的外部初始化上下文</a></p>
                  </li>
                  <li>
                     <p><a href="managing-scalable-platforms.html#GUID-01D8848B-FF4C-4332-B0AA-C4CDF064A65D" title="应用程序上下文使数据库客户端（例如中间层应用程序）能够设置任意会话数据并将其发送到服务器，每个执行的语句只需一次往返。">客户应用背景</a></p>
                  </li>
                  <li>
                     <p><a href="managing-scalable-platforms.html#GUID-2F470037-FE5A-4F21-A7FC-352BD083CAE5" title="一个版本提供了一个临时区域" editionabl="=" ="">使用基于版本的重新定义</a></p>
                  </li>
                  <li>
                     <p><a href="managing-scalable-platforms.html#GUID-73D8C87C-ABD9-463A-921D-3D5F1E232F85" title="以下安全增强功能使用init.ora文件或sqlnet.ora文件中的已配置参数（后一个文件专门针对该功能而注明）。">OCI安全增强功能</a></p>
                  </li>
                  <li>
                     <p><a href="managing-scalable-platforms.html#GUID-FB0528A0-460A-4778-9703-52BB0932E911" title="线程是存在于更大进程中的轻量级进程。">OCI多线程开发概述</a></p>
                  </li>
                  <li>
                     <p><a href="managing-scalable-platforms.html#GUID-AAE70C09-E0D8-4264-8E88-1D6916ABF717" title="OCIThread包提供了一些常用的线程原语。">OCIThread包</a></p>
                  </li>
               </ul>
            </div><a id="LNOCI16529"></a><div class="props_rev_3"><a id="GUID-3E96017A-64D3-4A29-B617-C9879610B5F2" name="GUID-3E96017A-64D3-4A29-B617-C9879610B5F2"></a><h3 id="LNOCI-GUID-3E96017A-64D3-4A29-B617-C9879610B5F2" class="sect3"><span class="enumeration_section">10.1</span> OCI对交易的支持</h3>
               <div>
                  <p>OCI有一组API调用来支持本地和全局事务的操作。</p>
                  <p>这些调用包括对象支持，因此如果OCI应用程序在对象模式下运行，则提交和回滚调用会将对象缓存与事务状态同步。</p>
                  <p>稍后列出的函数执行事务操作。每个调用都使用一个服务上下文句柄，必须使用正确的服务器上下文和用户会话句柄进行初始化。事务句柄是服务上下文的第三个元素;它存储与交易相关的特定信息。准备好SQL语句时，它与特定的服务上下文相关联。执行语句时，其效果（查询，获取，插入）将成为当前与服务上下文关联的事务的一部分。</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><code class="codeph">OCITransStart()</code>标志着事务的开始。
                        </p>
                     </li>
                     <li>
                        <p><code class="codeph">OCITransDetach()</code>分离事务。
                        </p>
                     </li>
                     <li>
                        <p><code class="codeph">OCITransCommit()</code>提交一个事务。
                        </p>
                     </li>
                     <li>
                        <p><code class="codeph">OCITransRollback()</code>回滚一个事务。
                        </p>
                     </li>
                     <li>
                        <p><code class="codeph">OCITransPrepare()</code>准备要在分布式处理环境中提交的事务。
                        </p>
                     </li>
                     <li>
                        <p><code class="codeph">OCITransMultiPrepare()</code>在单个调用中准备具有多个分支的事务。
                        </p>
                     </li>
                     <li>
                        <p><code class="codeph">OCITransForget()</code>导致服务器忘记启发式完成的全局事务。
                        </p>
                     </li>
                  </ul>
                  <p>根据应用程序中事务复杂程度的不同，您可能需要全部或仅需几个这些调用。以下部分将更详细地讨论这一点。</p>
                  <div class="infoboxnotealso" id="GUID-3E96017A-64D3-4A29-B617-C9879610B5F2__GUID-C7AB60F6-B834-4D50-B2BF-25E86A4729EA">
                     <p class="notep1">也可以看看：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="transaction-functions.html#GUID-69F748A0-89C2-431C-A126-1C0DF0552084" title="列出并描述交易功能。">交易功能</a></p>
                        </li>
                        <li>
                           <p><a href="transaction-functions.html#GUID-81E5963B-4DE7-47E1-ABB0-C1490AF3BAA8" title="设置事务的开始。">OCITransStart（）</a></p>
                        </li>
                        <li>
                           <p><a href="transaction-functions.html#GUID-03AB7BAB-C8F0-4DFF-BD10-7CE0F3C8CE09" title="分离全局事务。">OCITransDetach（）</a></p>
                        </li>
                        <li>
                           <p><a href="transaction-functions.html#GUID-DDAE3122-8769-4A30-8D78-EB2A3CCF77D4" title="提交与指定服务上下文关联的事务。">OCITransCommit（）</a></p>
                        </li>
                        <li>
                           <p><a href="transaction-functions.html#GUID-06EF9A0A-01A3-40CE-A0B7-DF0504A93366" title="回滚当前交易。">OCITransRollback（）</a></p>
                        </li>
                        <li>
                           <p><a href="transaction-functions.html#GUID-B8ADEE8D-9A5F-48C6-A862-4FFE280BA0D3" title="准备提交的全局事务。">OCITransPrepare（）</a></p>
                        </li>
                        <li>
                           <p><a href="transaction-functions.html#GUID-8278951C-98FA-4C08-A48B-5F24EADA6BD7" title="在一次调用中准备具有多个分支的事务。">OCITransMultiPrepare（）</a></p>
                        </li>
                        <li>
                           <p><a href="transaction-functions.html#GUID-1BBB1A11-66F5-424D-B0CA-8034085C7E00" title="导致服务器忘记启发式完成的全局事务。">OCITransForget（）</a></p>
                        </li>
                     </ul>
                     <p>  </p>
                  </div>
               </div>
            </div><a id="LNOCI16530"></a><div class="props_rev_3"><a id="GUID-AE6D1A12-06BA-4E37-971E-5B7B7111359E" name="GUID-AE6D1A12-06BA-4E37-971E-5B7B7111359E"></a><h3 id="LNOCI-GUID-AE6D1A12-06BA-4E37-971E-5B7B7111359E" class="sect3"><span class="enumeration_section">10.2</span>交易复杂程度</h3>
               <div>
                  <p>OCI支持多个级别的事务复杂性。</p>
                  <p>这些级别的交易复杂性包括：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="managing-scalable-platforms.html#GUID-7190D8FF-EA02-4D7B-9967-62A3FC458605" title="许多应用程序仅使用简单的本地事务。">简单的本地交易</a></p>
                     </li>
                     <li>
                        <p><a href="managing-scalable-platforms.html#GUID-5D71AFC0-8891-48E9-AA98-4F0ED8EA5C88" title="需要可序列化或只读事务的应用程序需要额外的OCI OCITransStart（）调用来启动事务。">可序列化或只读本地事务</a></p>
                     </li>
                     <li>
                        <p><a href="managing-scalable-platforms.html#GUID-7FE56616-EE7C-4565-A5EF-010A6B0A550B" title="全局事务仅在更复杂的事务处理应用程序中是必需的。">全球交易</a></p>
                     </li>
                  </ul>
                  <div class="p">本节包括以下附加主题：<ul style="list-style-type:disc">
                        <li>
                           <p><a href="managing-scalable-platforms.html#GUID-19B0B50B-3FA7-4796-9ABF-30C9F3D27F19" title="显示如何使用事务OCI调用。">交易示例</a></p>
                        </li>
                        <li>
                           <p><a href="managing-scalable-platforms.html#GUID-373004EB-EB38-4CC0-BDD3-217DFB5EAEF4" title="两个初始化参数涉及全局事务分支和可迁移开放连接的使用。">初始化参数</a></p>
                        </li>
                     </ul>
                  </div>
               </div><a id="LNOCI16531"></a><div class="props_rev_3"><a id="GUID-7190D8FF-EA02-4D7B-9967-62A3FC458605" name="GUID-7190D8FF-EA02-4D7B-9967-62A3FC458605"></a><h4 id="LNOCI-GUID-7190D8FF-EA02-4D7B-9967-62A3FC458605" class="sect4"><span class="enumeration_section">10.2.1</span>简单的本地事务</h4>
                  <div>
                     <p>许多应用程序仅使用简单的本地事务。</p>
                     <p>在这些应用程序中，当应用程序进行数据库更改时会创建隐式事务。此类应用程序所需的唯一特定于事务的调用是：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">OCITransCommit()</code>提交事务</p>
                        </li>
                        <li>
                           <p><code class="codeph">OCITransRollback()</code>回滚事务</p>
                        </li>
                     </ul>
                     <p>只要提交或回滚了一个事务，对数据库的下一次修改就会为应用程序创建一个新的隐式事务。</p>
                     <p>在服务上下文中，任何时候只能有一个隐式事务处于活动状态。隐式事务的属性对用户是不透明的。</p>
                     <p>如果应用程序创建多个会话，则每个会话都可以具有与之关联的隐式事务。</p>
                     <div class="infoboxnotealso" id="GUID-7190D8FF-EA02-4D7B-9967-62A3FC458605__GUID-910CDE78-04A4-45C2-82DC-BAA5D53CA3BF">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="transaction-functions.html#GUID-DDAE3122-8769-4A30-8D78-EB2A3CCF77D4" title="提交与指定服务上下文关联的事务。">OCITransCommit（）</a>用于显示简单本地事务使用的示例代码</p>
                           </li>
                           <li>
                              <p><a href="transaction-functions.html#GUID-06EF9A0A-01A3-40CE-A0B7-DF0504A93366" title="回滚当前交易。">OCITransRollback（）</a></p>
                           </li>
                        </ul>
                        <p> </p>
                     </div>
                  </div>
               </div><a id="LNOCI16532"></a><div class="props_rev_3"><a id="GUID-5D71AFC0-8891-48E9-AA98-4F0ED8EA5C88" name="GUID-5D71AFC0-8891-48E9-AA98-4F0ED8EA5C88"></a><h4 id="LNOCI-GUID-5D71AFC0-8891-48E9-AA98-4F0ED8EA5C88" class="sect4"><span class="enumeration_section">10.2.2可</span>序列化或只读本地事务</h4>
                  <div>
                     <p>需要可序列化或只读事务的应用程序需要额外的OCI <code class="codeph">OCITransStart()</code>调用来启动事务。
                     </p>
                     <p><code class="codeph">OCITransStart()</code>调用必须根据需要为<code class="codeph">flags</code>参数指定<code class="codeph">OCI_TRANS_SERIALIZABLE</code>或<code class="codeph">OCI_TRANS_READONLY</code> 。如果未指定标志，则标准读/写事务的缺省值为<code class="codeph">OCI_TRANS_READWRITE</code> 。
                     </p>
                     <p>在<code class="codeph">OCITransStart()</code>调用中指定只读选项可以使应用程序执行服务器往返以执行<code class="codeph">SET TRANSACTION READ ONLY</code>语句。
                     </p>
                     <div class="infoboxnotealso" id="GUID-5D71AFC0-8891-48E9-AA98-4F0ED8EA5C88__GUID-3E2E2903-92B4-4EA8-A253-2BA8B028BF73">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="transaction-functions.html#GUID-81E5963B-4DE7-47E1-ABB0-C1490AF3BAA8" title="设置事务的开始。">OCITransStart（）</a></p>
                     </div>
                  </div>
               </div><a id="LNOCI16533"></a><div class="props_rev_3"><a id="GUID-7FE56616-EE7C-4565-A5EF-010A6B0A550B" name="GUID-7FE56616-EE7C-4565-A5EF-010A6B0A550B"></a><h4 id="LNOCI-GUID-7FE56616-EE7C-4565-A5EF-010A6B0A550B" class="sect4"><span class="enumeration_section">10.2.3</span>全球交易</h4>
                  <div>
                     <p>全局事务仅在更复杂的事务处理应用程序中是必需的。</p>
                     <div class="p">本节包括以下主题：<ul style="list-style-type:disc">
                           <li>
                              <p><a href="managing-scalable-platforms.html#GUID-538CC7A5-8E2D-4E1D-9F4E-F942A4FA4182" title="事务处理（TP）监视器等三层应用程序创建和管理全局事务。">交易标识符</a></p>
                           </li>
                           <li>
                              <p><a href="managing-scalable-platforms.html#GUID-EF8493A6-3BA7-454B-9CA6-DE5786E18307" title="在事务句柄中设置此属性时，名称的长度最多为64个字节。">属性OCI_ATTR_TRANS_NAME</a></p>
                           </li>
                           <li>
                              <p><a href="managing-scalable-platforms.html#GUID-9C16201F-7975-4E14-8162-62695B1C9AE4" title="在单个全局事务中，Oracle数据库支持一对分支之间的紧耦合和松散耦合关系。">交易分支</a></p>
                           </li>
                           <li>
                              <p><a href="managing-scalable-platforms.html#GUID-4279B122-6581-47B0-8D1D-E4AE6E0D8DF9" title="事务分支分为两种状态：活动分支和非活动分支。">分支国家</a></p>
                           </li>
                           <li>
                              <p><a href="managing-scalable-platforms.html#GUID-334DF00F-A4B2-45AD-AF3D-C794C488F172" title="当OCI应用程序使用OCITransDetach（）调用将其分离时，分支将变为非活动状态。">分离和恢复分支</a></p>
                           </li>
                           <li>
                              <p><a href="managing-scalable-platforms.html#GUID-BAFC9277-5659-4000-AD46-EB8C2B6B93F9" title="服务器句柄具有OCI_ATTR_EXTERNAL_NAME和OCI_ATTR_INTERNAL_NAME属性。">关于设置客户端数据库名称</a></p>
                           </li>
                           <li>
                              <p><a href="managing-scalable-platforms.html#GUID-E249AA40-2C56-4BA7-B64E-136BFB3E15A2" title="全局事务可以在一个或两个阶段中提交。">单阶段提交与两阶段提交</a></p>
                           </li>
                           <li>
                              <p><a href="managing-scalable-platforms.html#GUID-AF8253A5-CECB-42CD-9973-C5D78FBAA82C" title="有时，当多个应用程序对同一Oracle数据库使用全局事务的不同分支时。">在单个消息中准备多个分支</a></p>
                           </li>
                        </ul>
                     </div>
                  </div><a id="LNOCI16535"></a><a id="LNOCI16534"></a><div class="props_rev_3"><a id="GUID-538CC7A5-8E2D-4E1D-9F4E-F942A4FA4182" name="GUID-538CC7A5-8E2D-4E1D-9F4E-F942A4FA4182"></a><h5 id="LNOCI-GUID-538CC7A5-8E2D-4E1D-9F4E-F942A4FA4182" class="sect5"><span class="enumeration_section">10.2.3.1</span>交易标识符</h5>
                     <div>
                        <p>事务处理（TP）监视器等三层应用程序创建和管理全局事务。</p>
                        <p>它们提供服务器与本地事务关联的<span class="italic">全局事务标识符</span> （ <code class="codeph">XID</code> ）。
                        </p>
                        <p>全局事务具有一个或多个<span class="italic">分支</span> 。每个分支由<code class="codeph">XID</code>标识。 <code class="codeph">XID</code>由<span class="italic">全局事务标识符</span> （ <code class="codeph">gtrid</code> ）和<span class="italic">分支限定符</span> （ <code class="codeph">bqual</code> ）组成。该结构基于标准XA规范。
                        </p>
                        <p><a href="managing-scalable-platforms.html#GUID-538CC7A5-8E2D-4E1D-9F4E-F942A4FA4182__BGBDGIAF" title="该表有2列。第1列是组件名称，第2列描述其值。">表10-1</a>提供了一个可能的<code class="codeph">XID</code>为1234的结构。
                        </p>
                        <div class="tblformal" id="GUID-538CC7A5-8E2D-4E1D-9F4E-F942A4FA4182__BGBDGIAF">
                           <p class="titleintable">表10-1全局事务标识符</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="全球交易标识符" width="100%" border="1" summary="This table has 2 columns. Column 1 is the component name and column 2 describes its value. " frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="50%" id="d106260e1799">零件</th>
                                    <th align="left" valign="bottom" width="50%" id="d106260e1802">值</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="50%" id="d106260e1807" headers="d106260e1799 ">
                                       <p><code class="codeph">的gtrid</code></p>
                                    </td>
                                    <td align="left" valign="top" width="50%" headers="d106260e1807 d106260e1802 ">
                                       <p><code class="codeph">12</code></p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="50%" id="d106260e1816" headers="d106260e1799 ">
                                       <p><code class="codeph">的bqual</code></p>
                                    </td>
                                    <td align="left" valign="top" width="50%" headers="d106260e1816 d106260e1802 ">
                                       <p><code class="codeph">34</code></p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="50%" id="d106260e1825" headers="d106260e1799 ">
                                       <p><code class="codeph">的gtrid +的bqual = XID</code></p>
                                    </td>
                                    <td align="left" valign="top" width="50%" headers="d106260e1825 d106260e1802 ">
                                       <p><code class="codeph">1234</code></p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <p>OCI事务调用使用的事务标识符通过使用<code class="codeph">OCIAttrSet()</code>在事务句柄的<code class="codeph">OCI_ATTR_XID</code>属性中设置。或者，可以通过<code class="codeph">OCI_ATTR_TRANS_NAME</code>属性中设置的名称来标识事务。
                        </p>
                        <div class="infoboxnotealso" id="GUID-538CC7A5-8E2D-4E1D-9F4E-F942A4FA4182__GUID-473BC002-201D-4420-814D-EC38F2AABC76">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="handle-and-descriptor-functions.html#GUID-3741D7BD-7652-4D7A-8813-AC2AEA8D3B03" title="设置句柄或描述符的属性值。">OCIAttrSet（）</a></p>
                        </div>
                     </div>
                  </div><a id="LNOCI16536"></a><div class="props_rev_3"><a id="GUID-EF8493A6-3BA7-454B-9CA6-DE5786E18307" name="GUID-EF8493A6-3BA7-454B-9CA6-DE5786E18307"></a><h5 id="LNOCI-GUID-EF8493A6-3BA7-454B-9CA6-DE5786E18307" class="sect5"><span class="enumeration_section">10.2.3.2</span>属性OCI_ATTR_TRANS_NAME</h5>
                     <div>
                        <p>在事务句柄中设置此属性时，名称的长度最多为64个字节。</p>
                        <p><code class="codeph">XID</code>的<code class="codeph">formatid</code>为0，分支限定符为0。
                        </p>
                        <p>从事务句柄检索此属性时，返回的事务名称是全局事务标识符。大小是全局事务标识符的长度。</p>
                     </div>
                  </div><a id="LNOCI16538"></a><a id="LNOCI16539"></a><a id="LNOCI16537"></a><div class="props_rev_3"><a id="GUID-9C16201F-7975-4E14-8162-62695B1C9AE4" name="GUID-9C16201F-7975-4E14-8162-62695B1C9AE4"></a><h5 id="LNOCI-GUID-9C16201F-7975-4E14-8162-62695B1C9AE4" class="sect5"><span class="enumeration_section">10.2.3.3</span>交易分支</h5>
                     <div>
                        <p>在单个全局事务中，Oracle数据库支持一对分支之间的紧耦合和松散耦合关系。</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>紧密耦合的分支共享相同的本地事务。<code class="codeph">gtrid</code>引用唯一的本地事务，多个分支指向同一事务。事务的所有者是首先创建的分支。
                              </p>
                           </li>
                           <li>
                              <p>松散耦合的分支使用不同的本地事务。<code class="codeph">gtrid</code>和<code class="codeph">bqual</code>一起映射到唯一的本地事务。每个分支指向不同的事务。
                              </p>
                           </li>
                        </ul>
                        <p><code class="codeph">OCITransStart()</code>的<code class="codeph">flags</code>参数允许应用程序传递<code class="codeph">OCI_TRANS_TIGHT</code>或<code class="codeph">OCI_TRANS_LOOSE</code>值以指定耦合类型。
                        </p>
                        <p>会话对应于使用<code class="codeph">OCISessionBegin()</code>创建的用户会话。
                        </p>
                        <p><a href="managing-scalable-platforms.html#GUID-9C16201F-7975-4E14-8162-62695B1C9AE4__I443620">图10-1</a>说明了应用程序中紧密耦合的分支。两个分支（B1和B2）的<code class="codeph">XID</code>共享相同的<code class="codeph">gtrid</code> ，因为它们在同一个事务（T）上运行，但它们具有不同的<code class="codeph">bqual</code> ，因为它们位于不同的分支上。
                        </p>
                        <div class="figure" id="GUID-9C16201F-7975-4E14-8162-62695B1C9AE4__I443620">
                           <p class="titleinfigure">图10-1多个紧密耦合的分支</p><img src="img/lnoci023.gif" alt="下面是图10-1的描述" title="下面是图10-1的描述" longdesc="img_text/lnoci023.html"><br><a href="img_text/lnoci023.html">“图10-1多个紧密耦合的分支”的描述</a></div>
                        <!-- class="figure" -->
                        <p><a href="managing-scalable-platforms.html#GUID-9C16201F-7975-4E14-8162-62695B1C9AE4__I433197">图10-2</a>说明了单个会话如何在不同分支上运行。<code class="codeph">XID</code>的<code class="codeph">gtrid</code>组件是不同的，因为它们代表单独的全局事务。
                        </p>
                        <div class="figure" id="GUID-9C16201F-7975-4E14-8162-62695B1C9AE4__I433197">
                           <p class="titleinfigure">图10-2多个分支上的会话操作</p><img src="img/lnoci024.gif" alt="下面是图10-2的描述" title="下面是图10-2的描述" longdesc="img_text/lnoci024.html"><br><a href="img_text/lnoci024.html">“图10-2在多个分支上运行的会话”的描述</a></div>
                        <!-- class="figure" -->
                        <p>单个会话可以在共享相同事务的多个分支上运行，但是这种情况没有太大的实际价值。</p>
                        <div class="infoboxnotealso" id="GUID-9C16201F-7975-4E14-8162-62695B1C9AE4__GUID-C9FFB30E-B9FE-4D22-8E20-BA957B8C5DB3">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><a href="transaction-functions.html#GUID-81E5963B-4DE7-47E1-ABB0-C1490AF3BAA8" title="设置事务的开始。">OCITransStart（）</a>用于演示此场景的示例代码</p>
                              </li>
                              <li>
                                 <p><a href="connect-authorize-and-initialize-functions.html#GUID-31B1FDB3-056E-4AF9-9B89-8DA6AA156947" title="创建用户会话并开始给定服务器的用户会话。">OCISessionBegin（）</a></p>
                              </li>
                           </ul>
                           <p></p>
                        </div>
                     </div>
                  </div><a id="LNOCI16540"></a><div class="props_rev_3"><a id="GUID-4279B122-6581-47B0-8D1D-E4AE6E0D8DF9" name="GUID-4279B122-6581-47B0-8D1D-E4AE6E0D8DF9"></a><h5 id="LNOCI-GUID-4279B122-6581-47B0-8D1D-E4AE6E0D8DF9" class="sect5"><span class="enumeration_section">10.2.3.4</span>分支机构</h5>
                     <div>
                        <p>事务分支分为两种状态： <span class="italic">活动分支</span>和<span class="italic">非活动分支</span> 。
                        </p>
                        <p>如果服务器进程正在分支上执行请求，则分支处于活动状态。如果没有服务器进程正在分支中执行请求，则分支处于非活动状态。在这种情况下，没有会话是分支的父级，并且分支由服务器中的<code class="codeph">PMON</code>进程拥有。
                        </p>
                     </div>
                  </div><a id="LNOCI16541"></a><div class="props_rev_3"><a id="GUID-334DF00F-A4B2-45AD-AF3D-C794C488F172" name="GUID-334DF00F-A4B2-45AD-AF3D-C794C488F172"></a><h5 id="LNOCI-GUID-334DF00F-A4B2-45AD-AF3D-C794C488F172" class="sect5"><span class="enumeration_section">10.2.3.5</span>分离和恢复分支</h5>
                     <div>
                        <p>当OCI应用程序使用<code class="codeph">OCITransDetach()</code>调用将其分离时，分支将变为非活动状态。
                        </p>
                        <p>通过调用<code class="codeph">OCITransStart()</code>并将<code class="codeph">flags</code>参数设置为<code class="codeph">OCI_TRANS_RESUME</code>来恢复分支，可以使分支再次<code class="codeph">OCI_TRANS_RESUME</code> 。</p>
                        <p>当应用程序使用<code class="codeph">OCITransDetach()</code>分离分支时，它使用创建分支的<code class="codeph">OCITransStart()</code>调用的<code class="codeph">timeout</code>参数中指定的值。<code class="codeph">timeout</code>指定事务在被删除之前作为<code class="codeph">PMON</code>的子<code class="codeph">PMON</code>保持休眠的秒数。
                        </p>
                        <p>要恢复分支，应用程序调用<code class="codeph">OCITransStart()</code> ，将分支的<code class="codeph">XID</code>指定为事务句柄的属性，将<code class="codeph">flags</code>参数<code class="codeph">OCI_TRANS_RESUME</code>为<code class="codeph">OCI_TRANS_RESUME</code> ，以及指定不同的<code class="codeph">timeout</code>参数。此调用的此<span class="italic">超时</span>值指定会话等待分支在其他进程当前正在使用时变为可用的时间长度。如果没有其他进程正在访问分支，则可以立即恢复。如果该进程与分离事务的进程具有相同的授权，则可以通过与分离它的进程不同的进程来恢复该事务。
                        </p>
                        <div class="infoboxnotealso" id="GUID-334DF00F-A4B2-45AD-AF3D-C794C488F172__GUID-30548B3F-0C41-48A3-8BE7-53C5BA465F3B">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><a href="transaction-functions.html#GUID-03AB7BAB-C8F0-4DFF-BD10-7CE0F3C8CE09" title="分离全局事务。">OCITransDetach（）</a></p>
                              </li>
                              <li>
                                 <p><a href="transaction-functions.html#GUID-81E5963B-4DE7-47E1-ABB0-C1490AF3BAA8" title="设置事务的开始。">OCITransStart（）</a></p>
                              </li>
                           </ul>
                        </div>
                     </div>
                  </div><a id="LNOCI16542"></a><div class="props_rev_3"><a id="GUID-BAFC9277-5659-4000-AD46-EB8C2B6B93F9" name="GUID-BAFC9277-5659-4000-AD46-EB8C2B6B93F9"></a><h5 id="LNOCI-GUID-BAFC9277-5659-4000-AD46-EB8C2B6B93F9" class="sect5"><span class="enumeration_section">10.2.3.6</span>关于设置客户端数据库名称</h5>
                     <div>
                        <p>服务器句柄具有<code class="codeph">OCI_ATTR_EXTERNAL_NAME</code>和<code class="codeph">OCI_ATTR_INTERNAL_NAME</code>属性。
                        </p>
                        <p>这些属性设置执行全局事务时记录的客户端数据库名称。数据库管理员可以使用该名称来跟踪由于故障而可能在准备状态中挂起的事务。</p>
                        <div class="infoboxnote" id="GUID-BAFC9277-5659-4000-AD46-EB8C2B6B93F9__GUID-34E57CA8-EC4F-446B-B25D-79664098BBE3">
                           <p class="notep1">注意：</p>
                           <p>OCI应用程序通过在登录和使用全局事务之前使用<code class="codeph">OCIAttrSet()</code>来设置这些属性。
                           </p>
                        </div>
                        <div class="infoboxnotealso" id="GUID-BAFC9277-5659-4000-AD46-EB8C2B6B93F9__GUID-E6064F0A-FE09-4686-BB3A-43E4189E0C26">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="handle-and-descriptor-functions.html#GUID-3741D7BD-7652-4D7A-8813-AC2AEA8D3B03" title="设置句柄或描述符的属性值。">OCIAttrSet（）</a></p>
                        </div>
                     </div>
                  </div><a id="LNOCI16543"></a><div class="props_rev_3"><a id="GUID-E249AA40-2C56-4BA7-B64E-136BFB3E15A2" name="GUID-E249AA40-2C56-4BA7-B64E-136BFB3E15A2"></a><h5 id="LNOCI-GUID-E249AA40-2C56-4BA7-B64E-136BFB3E15A2" class="sect5"><span class="enumeration_section">10.2.3.7</span>单阶段提交与两阶段提交</h5>
                     <div>
                        <p>全局事务可以在一个或两个阶段中提交。</p>
                        <p>最简单的情况是单个事务针对单个数据库进行操作。在这种情况下，应用程序可以通过调用<code class="codeph">OCITransCommit()</code>来执行事务的单阶段提交，因为调用的默认值是用于单阶段提交。
                        </p>
                        <p>如果应用程序正在处理针对多个Oracle数据库的事务，则情况会更复杂。在这种情况下，需要两阶段提交。两阶段提交操作包括以下步骤：</p>
                        <ol>
                           <li>
                              <p>准备 - 应用程序针对每个事务发出<code class="codeph">OCITransPrepare()</code>调用。每个事务返回一个值，指示它是否可以提交其当前工作（ <code class="codeph">OCI_SUCCESS</code> ）（ <code class="codeph">OCI_ERROR</code> ）。
                              </p>
                           </li>
                           <li>
                              <p>提交 - 如果每个<code class="codeph">OCITransPrepare()</code>调用返回值<code class="codeph">OCI_SUCCESS</code> ，则应用程序可以对每个事务发出<code class="codeph">OCITransCommit()</code>调用。必须将提交调用的<code class="codeph">flags</code>参数显式设置为<code class="codeph">OCI_TRANS_TWOPHASE</code>以获取相应的行为，因为此调用的缺省值是用于单阶段提交。
                              </p>
                              <div class="infoboxnote" id="GUID-E249AA40-2C56-4BA7-B64E-136BFB3E15A2__GUID-4ACF2293-F360-488B-A357-D4BBEF7AC858">
                                 <p class="notep1">注意：</p>
                                 <p>如果事务必须指示它是只读的，则<code class="codeph">OCITransPrepare()</code>调用也可以返回<code class="codeph">OCI_SUCCESS_WITH_INFO</code> 。因此，提交既不合适也不必要。
                                 </p>
                              </div>
                           </li>
                        </ol>
                        <p>另一个调用<code class="codeph">OCITransForget()</code>会导致数据库“忘记”已完成的事务。此调用适用于发生问题的情况，该问题要求终止两阶段提交。当Oracle数据库收到<code class="codeph">OCITransForget()</code>调用时，它会删除有关该事务的所有信息。
                        </p>
                        <div class="infoboxnotealso" id="GUID-E249AA40-2C56-4BA7-B64E-136BFB3E15A2__GUID-F6D15239-468C-4C1A-B872-4CA898491733">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><a href="transaction-functions.html#GUID-DDAE3122-8769-4A30-8D78-EB2A3CCF77D4" title="提交与指定服务上下文关联的事务。">OCITransCommit（）</a></p>
                              </li>
                              <li>
                                 <p><a href="transaction-functions.html#GUID-B8ADEE8D-9A5F-48C6-A862-4FFE280BA0D3" title="准备提交的全局事务。">OCITransPrepare（）</a></p>
                              </li>
                              <li>
                                 <p><a href="transaction-functions.html#GUID-1BBB1A11-66F5-424D-B0CA-8034085C7E00" title="导致服务器忘记启发式完成的全局事务。">OCITransForget（）</a></p>
                              </li>
                           </ul>
                        </div>
                     </div>
                  </div><a id="LNOCI16544"></a><div class="props_rev_3"><a id="GUID-AF8253A5-CECB-42CD-9973-C5D78FBAA82C" name="GUID-AF8253A5-CECB-42CD-9973-C5D78FBAA82C"></a><h5 id="LNOCI-GUID-AF8253A5-CECB-42CD-9973-C5D78FBAA82C" class="sect5"><span class="enumeration_section">10.2.3.8</span>在单个消息中准备多个分支</h5>
                     <div>
                        <p>有时，当多个应用程序对同一Oracle数据库使用全局事务的不同分支时。</p>
                        <p>在提交此类事务之前，必须准备好所有分支。</p>
                        <p>大多数情况下，使用分支机构的应用程序负责准备自己的分支机构。但是，某些体系结构将此责任转交给外部事务服务。然后，此外部事务服务必须准备全局事务的每个分支。传统的<code class="codeph">OCITransPrepare()</code>调用对于此任务来说效率低，因为每个分支必须单独准备。<code class="codeph">OCITransMultiPrepare()</code>调用在一次往返中准备涉及同一全局事务的多个分支。此调用更有效，可以大大减少从客户端发送到服务器的消息数量。
                        </p>
                        <div class="infoboxnotealso" id="GUID-AF8253A5-CECB-42CD-9973-C5D78FBAA82C__GUID-AFB86446-4810-4146-9F34-3F57BB528651">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><a href="transaction-functions.html#GUID-B8ADEE8D-9A5F-48C6-A862-4FFE280BA0D3" title="准备提交的全局事务。">OCITransPrepare（）</a></p>
                              </li>
                              <li>
                                 <p><a href="transaction-functions.html#GUID-8278951C-98FA-4C08-A48B-5F24EADA6BD7" title="在一次调用中准备具有多个分支的事务。">OCITransMultiPrepare（）</a></p>
                              </li>
                           </ul>
                        </div>
                     </div>
                  </div>
               </div><a id="LNOCI16545"></a><div class="props_rev_3"><a id="GUID-19B0B50B-3FA7-4796-9ABF-30C9F3D27F19" name="GUID-19B0B50B-3FA7-4796-9ABF-30C9F3D27F19"></a><h4 id="LNOCI-GUID-19B0B50B-3FA7-4796-9ABF-30C9F3D27F19" class="sect4"><span class="enumeration_section">10.2.4</span>交易示例</h4>
                  <div>
                     <p>显示如何使用事务OCI调用。</p>
                     <p><a href="managing-scalable-platforms.html#GUID-538CC7A5-8E2D-4E1D-9F4E-F942A4FA4182__BGBDGIAF" title="该表有2列。第1列是组件名称，第2列描述其值。">表10-1</a>到<a href="managing-scalable-platforms.html#GUID-7E9DAAEC-C836-4AFF-88FA-CEACAFC5415A__BGBJJFHC" title="该表有5列。第1列是步骤编号，第2列是OCI操作，第3列是XID值，第4列是标志值，第5列是结果。">表10-5</a>说明了如何使用事务OCI调用。
                     </p>
                     <p>它们显示了一系列OCI调用和其他操作，以及它们产生的行为。为简单起见，并未列出这些调用的所有参数;相反，它是正在展示的呼叫流程。</p>
                     <p>OCI操作列指示OCI应用程序正在执行的操作或正在进行的调用。必要时， <code class="codeph">XID</code>列列出事务标识符。Flags列列出了<code class="codeph">flags</code>参数中传递的值。“结果”列描述了呼叫的结果。
                     </p>
                  </div>
               </div><a id="LNOCI16546"></a><div class="props_rev_3"><a id="GUID-373004EB-EB38-4CC0-BDD3-217DFB5EAEF4" name="GUID-373004EB-EB38-4CC0-BDD3-217DFB5EAEF4"></a><h4 id="LNOCI-GUID-373004EB-EB38-4CC0-BDD3-217DFB5EAEF4" class="sect4"><span class="enumeration_section">10.2.5</span>初始化参数</h4>
                  <div>
                     <p>两个初始化参数涉及全局事务分支和可迁移开放连接的使用。</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">TRANSACTIONS</code> - 此参数指定整个系统中的最大全局事务分支数。相反，单个全局事务的最大分支数为8。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">OPEN_LINKS_PER_INSTANCE</code> - 此参数指定可迁移的打开连接的最大数量。提交事务后，全局事务使用可迁移的打开连接来缓存连接。将其与<code class="codeph">OPEN_LINKS</code>参数进行对比，该参数控制会话的连接数，不适用于使用全局事务的应用程序。
                           </p>
                        </li>
                     </ul>
                     <div class="p">本节包括以下主题：<ul style="list-style-type:disc">
                           <li>
                              <p><a href="managing-scalable-platforms.html#GUID-10517B08-0320-43D3-9B84-7FDF3B1091C1" title="列出单阶段提交操作的步骤。">显示更新成功，单阶段提交</a></p>
                           </li>
                           <li>
                              <p><a href="managing-scalable-platforms.html#GUID-6D657924-E7C3-4DC0-90AF-CBD294271520" title="列出两阶段提交操作的步骤。">显示启动事务，分离，恢复，准备，两阶段提交</a></p>
                           </li>
                           <li>
                              <p><a href="managing-scalable-platforms.html#GUID-E686C22B-8290-44C3-AC89-23B57CE1F3A5" title="在失败的只读更新操作中执行步骤。">显示只读更新失败</a></p>
                           </li>
                           <li>
                              <p><a href="managing-scalable-platforms.html#GUID-7E9DAAEC-C836-4AFF-88FA-CEACAFC5415A" title="列出只读事务的步骤。">显示启动只读事务，选择和提交</a></p>
                           </li>
                        </ul>
                     </div>
                  </div><a id="LNOCI16548"></a><a id="LNOCI16547"></a><div class="props_rev_3"><a id="GUID-10517B08-0320-43D3-9B84-7FDF3B1091C1" name="GUID-10517B08-0320-43D3-9B84-7FDF3B1091C1"></a><h5 id="LNOCI-GUID-10517B08-0320-43D3-9B84-7FDF3B1091C1" class="sect5"><span class="enumeration_section">10.2.5.1</span>显示更新成功，单阶段提交</h5>
                     <div>
                        <p>列出单阶段提交操作的步骤。</p>
                        <div class="section">
                           <p><a href="managing-scalable-platforms.html#GUID-10517B08-0320-43D3-9B84-7FDF3B1091C1__BGBCCHBE" title="该表有5列。第1列是步骤编号，第2列是OCI操作，第3列是XID值，第4列是标志值，第5列是结果。">表10-2</a>列出了单阶段提交操作的步骤。
                           </p>
                           <div class="tblformalwide" id="GUID-10517B08-0320-43D3-9B84-7FDF3B1091C1__BGBCCHBE">
                              <p class="titleintable">表10-2单阶段提交</p>
                              <table cellpadding="4" cellspacing="0" class="FormalWide" title="一阶段提交" width="100%" border="1" summary="This table has 5 columns. Column 1 is the step number, column 2 is the OCI action, column 3 is the XID value, column 4 is the flags value, and column 5 is the result. " frame="hsides" rules="rows">
                                 <thead>
                                    <tr align="left" valign="top">
                                       <th align="left" valign="bottom" width="9%" id="d106260e4189">步</th>
                                       <th align="left" valign="bottom" width="26%" id="d106260e4192">OCI行动</th>
                                       <th align="left" valign="bottom" width="9%" id="d106260e4195">XID</th>
                                       <th align="left" valign="bottom" width="24%" id="d106260e4198">旗</th>
                                       <th align="left" valign="bottom" width="33%" id="d106260e4201">结果</th>
                                    </tr>
                                 </thead>
                                 <tbody>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="9%" id="d106260e4206" headers="d106260e4189 ">
                                          <p>1</p>
                                       </td>
                                       <td align="left" valign="top" width="26%" headers="d106260e4206 d106260e4192 "><pre class="oac_no_warn" dir="ltr">OCITransStart（）</pre></td>
                                       <td align="left" valign="top" width="9%" headers="d106260e4206 d106260e4195 ">
                                          <p>1234</p>
                                       </td>
                                       <td align="left" valign="top" width="24%" headers="d106260e4206 d106260e4198 ">
                                          <p><code class="codeph">OCI_TRANS_NEW</code></p>
                                       </td>
                                       <td align="left" valign="top" width="33%" headers="d106260e4206 d106260e4201 ">
                                          <p>启动新的读/写事务</p>
                                       </td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="9%" id="d106260e4223" headers="d106260e4189 ">
                                          <p>2</p>
                                       </td>
                                       <td align="left" valign="top" width="26%" headers="d106260e4223 d106260e4192 "><pre class="oac_no_warn" dir="ltr">SQL UPDATE</pre></td>
                                       <td align="left" valign="top" width="9%" headers="d106260e4223 d106260e4195 ">
                                          <p>-</p>
                                       </td>
                                       <td align="left" valign="top" width="24%" headers="d106260e4223 d106260e4198 ">
                                          <p>-</p>
                                       </td>
                                       <td align="left" valign="top" width="33%" headers="d106260e4223 d106260e4201 ">
                                          <p>更新行</p>
                                       </td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="9%" id="d106260e4239" headers="d106260e4189 ">
                                          <p>3</p>
                                       </td>
                                       <td align="left" valign="top" width="26%" headers="d106260e4239 d106260e4192 "><pre class="oac_no_warn" dir="ltr">OCITransCommit（）</pre></td>
                                       <td align="left" valign="top" width="9%" headers="d106260e4239 d106260e4195 ">
                                          <p>-</p>
                                       </td>
                                       <td align="left" valign="top" width="24%" headers="d106260e4239 d106260e4198 ">
                                          <p>-</p>
                                       </td>
                                       <td align="left" valign="top" width="33%" headers="d106260e4239 d106260e4201 ">
                                          <p>提交成功。</p>
                                       </td>
                                    </tr>
                                 </tbody>
                              </table>
                           </div>
                           <!-- class="inftblhruleinformal" -->
                           <div class="infoboxnotealso" id="GUID-10517B08-0320-43D3-9B84-7FDF3B1091C1__GUID-FC39B9A9-CC78-4A59-B6EA-2526F6D8A842">
                              <p class="notep1">也可以看看：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p><a href="transaction-functions.html#GUID-81E5963B-4DE7-47E1-ABB0-C1490AF3BAA8" title="设置事务的开始。">OCITransStart（）</a></p>
                                 </li>
                                 <li>
                                    <p><a href="transaction-functions.html#GUID-DDAE3122-8769-4A30-8D78-EB2A3CCF77D4" title="提交与指定服务上下文关联的事务。">OCITransCommit（）</a></p>
                                 </li>
                              </ul>
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNOCI16550"></a><a id="LNOCI16549"></a><div class="props_rev_3"><a id="GUID-6D657924-E7C3-4DC0-90AF-CBD294271520" name="GUID-6D657924-E7C3-4DC0-90AF-CBD294271520"></a><h5 id="LNOCI-GUID-6D657924-E7C3-4DC0-90AF-CBD294271520" class="sect5"><span class="enumeration_section">10.2.5.2</span>显示启动事务，分离，恢复，准备，两阶段提交</h5>
                     <div>
                        <p>列出两阶段提交操作的步骤。</p>
                        <div class="section">
                           <p><a href="managing-scalable-platforms.html#GUID-6D657924-E7C3-4DC0-90AF-CBD294271520__BGBECJCF" title="该表有5列。第1列是步骤编号，第2列是OCI操作，第3列是XID值，第4列是标志值，第5列是结果。">表10-3</a>列出了两阶段提交操作的步骤。
                           </p>
                           <div class="tblformalwide" id="GUID-6D657924-E7C3-4DC0-90AF-CBD294271520__BGBECJCF">
                              <p class="titleintable">表10-3两阶段提交</p>
                              <table cellpadding="4" cellspacing="0" class="FormalWide" title="两阶段提交" width="100%" border="1" summary="This table has 5 columns. Column 1 is the step number, column 2 is the OCI action, column 3 is the XID value, column 4 is the flags value, and column 5 is the result. " frame="hsides" rules="rows">
                                 <thead>
                                    <tr align="left" valign="top">
                                       <th align="left" valign="bottom" width="8%" id="d106260e4485">步</th>
                                       <th align="left" valign="bottom" width="34%" id="d106260e4488">OCI行动</th>
                                       <th align="left" valign="bottom" width="8%" id="d106260e4491">XID</th>
                                       <th align="left" valign="bottom" width="21%" id="d106260e4495">旗</th>
                                       <th align="left" valign="bottom" width="29%" id="d106260e4498">结果</th>
                                    </tr>
                                 </thead>
                                 <tbody>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="8%" id="d106260e4503" headers="d106260e4485 ">
                                          <p>1</p>
                                       </td>
                                       <td align="left" valign="top" width="34%" headers="d106260e4503 d106260e4488 "><pre class="oac_no_warn" dir="ltr">OCITransStart（）</pre></td>
                                       <td align="left" valign="top" width="8%" headers="d106260e4503 d106260e4491 ">
                                          <p>1234</p>
                                       </td>
                                       <td align="left" valign="top" width="21%" headers="d106260e4503 d106260e4495 ">
                                          <p><code class="codeph">OCI_TRANS_NEW</code></p>
                                       </td>
                                       <td align="left" valign="top" width="29%" headers="d106260e4503 d106260e4498 ">
                                          <p>启动新的只读事务</p>
                                       </td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="8%" id="d106260e4520" headers="d106260e4485 ">
                                          <p>2</p>
                                       </td>
                                       <td align="left" valign="top" width="34%" headers="d106260e4520 d106260e4488 "><pre class="oac_no_warn" dir="ltr">SQL UPDATE</pre></td>
                                       <td align="left" valign="top" width="8%" headers="d106260e4520 d106260e4491 ">
                                          <p>-</p>
                                       </td>
                                       <td align="left" valign="top" width="21%" headers="d106260e4520 d106260e4495 ">
                                          <p>-</p>
                                       </td>
                                       <td align="left" valign="top" width="29%" headers="d106260e4520 d106260e4498 ">
                                          <p>更新行</p>
                                       </td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="8%" id="d106260e4536" headers="d106260e4485 ">
                                          <p>3</p>
                                       </td>
                                       <td align="left" valign="top" width="34%" headers="d106260e4536 d106260e4488 "><pre class="oac_no_warn" dir="ltr">OCITransDetach（）</pre></td>
                                       <td align="left" valign="top" width="8%" headers="d106260e4536 d106260e4491 ">
                                          <p>-</p>
                                       </td>
                                       <td align="left" valign="top" width="21%" headers="d106260e4536 d106260e4495 ">
                                          <p>-</p>
                                       </td>
                                       <td align="left" valign="top" width="29%" headers="d106260e4536 d106260e4498 ">
                                          <p>交易是分离的。</p>
                                       </td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="8%" id="d106260e4552" headers="d106260e4485 ">
                                          <p>4</p>
                                       </td>
                                       <td align="left" valign="top" width="34%" headers="d106260e4552 d106260e4488 "><pre class="oac_no_warn" dir="ltr">OCITransStart（）</pre></td>
                                       <td align="left" valign="top" width="8%" headers="d106260e4552 d106260e4491 ">
                                          <p>1234</p>
                                       </td>
                                       <td align="left" valign="top" width="21%" headers="d106260e4552 d106260e4495 ">
                                          <p><code class="codeph">OCI_TRANS_RESUME</code></p>
                                       </td>
                                       <td align="left" valign="top" width="29%" headers="d106260e4552 d106260e4498 ">
                                          <p>交易恢复。</p>
                                       </td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="8%" id="d106260e4569" headers="d106260e4485 ">
                                          <p>五</p>
                                       </td>
                                       <td align="left" valign="top" width="34%" headers="d106260e4569 d106260e4488 "><pre class="oac_no_warn" dir="ltr">SQL UPDATE</pre></td>
                                       <td align="left" valign="top" width="8%" headers="d106260e4569 d106260e4491 ">
                                          <p>-</p>
                                       </td>
                                       <td align="left" valign="top" width="21%" headers="d106260e4569 d106260e4495 ">
                                          <p>-</p>
                                       </td>
                                       <td align="left" valign="top" width="29%" headers="d106260e4569 d106260e4498 ">
                                          <p>-</p>
                                       </td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="8%" id="d106260e4585" headers="d106260e4485 ">
                                          <p>6</p>
                                       </td>
                                       <td align="left" valign="top" width="34%" headers="d106260e4585 d106260e4488 "><pre class="oac_no_warn" dir="ltr">OCITransPrepare（）</pre></td>
                                       <td align="left" valign="top" width="8%" headers="d106260e4585 d106260e4491 ">
                                          <p>-</p>
                                       </td>
                                       <td align="left" valign="top" width="21%" headers="d106260e4585 d106260e4495 ">
                                          <p>-</p>
                                       </td>
                                       <td align="left" valign="top" width="29%" headers="d106260e4585 d106260e4498 ">
                                          <p>交易准备用于两阶段提交。</p>
                                       </td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="8%" id="d106260e4601" headers="d106260e4485 ">
                                          <p>7</p>
                                       </td>
                                       <td align="left" valign="top" width="34%" headers="d106260e4601 d106260e4488 "><pre class="oac_no_warn" dir="ltr">OCITransCommit（）</pre></td>
                                       <td align="left" valign="top" width="8%" headers="d106260e4601 d106260e4491 ">
                                          <p>-</p>
                                       </td>
                                       <td align="left" valign="top" width="21%" headers="d106260e4601 d106260e4495 ">
                                          <p><code class="codeph">OCI_TRANS_TWOPHASE</code></p>
                                       </td>
                                       <td align="left" valign="top" width="29%" headers="d106260e4601 d106260e4498 ">
                                          <p>交易已提交。</p>
                                       </td>
                                    </tr>
                                 </tbody>
                              </table>
                           </div>
                           <!-- class="inftblhruleinformal" -->
                           <p>在步骤4中，只要具有相同的授权，就可以通过不同的进程恢复事务。</p>
                           <div class="infoboxnotealso" id="GUID-6D657924-E7C3-4DC0-90AF-CBD294271520__GUID-DBD00368-FD52-4F0A-95EF-A5AC78DBEA07">
                              <p class="notep1">也可以看看：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p><a href="transaction-functions.html#GUID-81E5963B-4DE7-47E1-ABB0-C1490AF3BAA8" title="设置事务的开始。">OCITransStart（）</a></p>
                                 </li>
                                 <li>
                                    <p><a href="transaction-functions.html#GUID-03AB7BAB-C8F0-4DFF-BD10-7CE0F3C8CE09" title="分离全局事务。">OCITransDetach（）</a></p>
                                 </li>
                                 <li>
                                    <p><a href="transaction-functions.html#GUID-B8ADEE8D-9A5F-48C6-A862-4FFE280BA0D3" title="准备提交的全局事务。">OCITransPrepare（）</a></p>
                                 </li>
                                 <li>
                                    <p><a href="transaction-functions.html#GUID-DDAE3122-8769-4A30-8D78-EB2A3CCF77D4" title="提交与指定服务上下文关联的事务。">OCITransCommit（）</a></p>
                                 </li>
                              </ul>
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNOCI16552"></a><a id="LNOCI16551"></a><div class="props_rev_3"><a id="GUID-E686C22B-8290-44C3-AC89-23B57CE1F3A5" name="GUID-E686C22B-8290-44C3-AC89-23B57CE1F3A5"></a><h5 id="LNOCI-GUID-E686C22B-8290-44C3-AC89-23B57CE1F3A5" class="sect5"><span class="enumeration_section">10.2.5.3</span>显示只读更新失败</h5>
                     <div>
                        <p>在失败的只读更新操作中执行步骤。</p>
                        <div class="section">
                           <p><a href="managing-scalable-platforms.html#GUID-E686C22B-8290-44C3-AC89-23B57CE1F3A5__BGBBHJGC" title="该表有5列。第1列是步骤编号，第2列是OCI操作，第3列是XID值，第4列是标志值，第5列是结果。">表10-4</a>列出了只读更新操作失败的步骤。
                           </p>
                           <div class="tblformalwide" id="GUID-E686C22B-8290-44C3-AC89-23B57CE1F3A5__BGBBHJGC">
                              <p class="titleintable">表10-4只读更新失败</p>
                              <table cellpadding="4" cellspacing="0" class="FormalWide" title="只读更新失败" width="100%" border="1" summary="This table has 5 columns. Column 1 is the step number, column 2 is the OCI action, column 3 is the XID value, column 4 is the flags value, and column 5 is the result. " frame="hsides" rules="rows">
                                 <thead>
                                    <tr align="left" valign="top">
                                       <th align="left" valign="bottom" width="8%" id="d106260e4863">步</th>
                                       <th align="left" valign="bottom" width="30%" id="d106260e4866">OCI行动</th>
                                       <th align="left" valign="bottom" width="8%" id="d106260e4869">XID</th>
                                       <th align="left" valign="bottom" width="22%" id="d106260e4872">旗</th>
                                       <th align="left" valign="bottom" width="31%" id="d106260e4875">结果</th>
                                    </tr>
                                 </thead>
                                 <tbody>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="8%" id="d106260e4880" headers="d106260e4863 ">
                                          <p>1</p>
                                       </td>
                                       <td align="left" valign="top" width="30%" headers="d106260e4880 d106260e4866 "><pre class="oac_no_warn" dir="ltr">OCITransStart（）</pre></td>
                                       <td align="left" valign="top" width="8%" headers="d106260e4880 d106260e4869 ">
                                          <p>1234</p>
                                       </td>
                                       <td align="left" valign="top" width="22%" headers="d106260e4880 d106260e4872 ">
                                          <p><code class="codeph">OCI_TRANS_NEW</code> |</p>
                                          <p><code class="codeph">OCI_TRANS_READONLY</code></p>
                                       </td>
                                       <td align="left" valign="top" width="31%" headers="d106260e4880 d106260e4875 ">
                                          <p>启动新的只读事务。</p>
                                       </td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="8%" id="d106260e4901" headers="d106260e4863 ">
                                          <p>2</p>
                                       </td>
                                       <td align="left" valign="top" width="30%" headers="d106260e4901 d106260e4866 "><pre class="oac_no_warn" dir="ltr">SQL UPDATE</pre></td>
                                       <td align="left" valign="top" width="8%" headers="d106260e4901 d106260e4869 ">
                                          <p>-</p>
                                       </td>
                                       <td align="left" valign="top" width="22%" headers="d106260e4901 d106260e4872 ">
                                          <p>-</p>
                                       </td>
                                       <td align="left" valign="top" width="31%" headers="d106260e4901 d106260e4875 ">
                                          <p>更新失败，因为事务是只读的。</p>
                                       </td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="8%" id="d106260e4917" headers="d106260e4863 ">
                                          <p>3</p>
                                       </td>
                                       <td align="left" valign="top" width="30%" headers="d106260e4917 d106260e4866 "><pre class="oac_no_warn" dir="ltr">OCITransCommit（）</pre></td>
                                       <td align="left" valign="top" width="8%" headers="d106260e4917 d106260e4869 ">
                                          <p>-</p>
                                       </td>
                                       <td align="left" valign="top" width="22%" headers="d106260e4917 d106260e4872 ">
                                          <p>-</p>
                                       </td>
                                       <td align="left" valign="top" width="31%" headers="d106260e4917 d106260e4875 ">
                                          <p>提交无效。</p>
                                       </td>
                                    </tr>
                                 </tbody>
                              </table>
                           </div>
                           <!-- class="inftblhruleinformal" -->
                           <div class="infoboxnotealso" id="GUID-E686C22B-8290-44C3-AC89-23B57CE1F3A5__GUID-0027593C-0B2D-4597-A371-2243D6F88752">
                              <p class="notep1">也可以看看：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p><a href="transaction-functions.html#GUID-81E5963B-4DE7-47E1-ABB0-C1490AF3BAA8" title="设置事务的开始。">OCITransStart（）</a></p>
                                 </li>
                                 <li>
                                    <p><a href="transaction-functions.html#GUID-DDAE3122-8769-4A30-8D78-EB2A3CCF77D4" title="提交与指定服务上下文关联的事务。">OCITransCommit（）</a></p>
                                 </li>
                              </ul>
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNOCI16554"></a><a id="LNOCI16553"></a><div class="props_rev_3"><a id="GUID-7E9DAAEC-C836-4AFF-88FA-CEACAFC5415A" name="GUID-7E9DAAEC-C836-4AFF-88FA-CEACAFC5415A"></a><h5 id="LNOCI-GUID-7E9DAAEC-C836-4AFF-88FA-CEACAFC5415A" class="sect5"><span class="enumeration_section">10.2.5.4</span>显示启动只读事务，选择和提交</h5>
                     <div>
                        <p>列出只读事务的步骤。</p>
                        <div class="section">
                           <p><a href="managing-scalable-platforms.html#GUID-7E9DAAEC-C836-4AFF-88FA-CEACAFC5415A__BGBJJFHC" title="该表有5列。第1列是步骤编号，第2列是OCI操作，第3列是XID值，第4列是标志值，第5列是结果。">表10-5</a>列出了只读事务的步骤。
                           </p>
                           <div class="tblformalwide" id="GUID-7E9DAAEC-C836-4AFF-88FA-CEACAFC5415A__BGBJJFHC">
                              <p class="titleintable">表10-5只读事务</p>
                              <table cellpadding="4" cellspacing="0" class="FormalWide" title="只读事务" width="100%" border="1" summary="This table has 5 columns. Column 1 is the step number, column 2 is the OCI action, column 3 is the XID value, column 4 is the flags value, and column 5 is the result. " frame="hsides" rules="rows">
                                 <thead>
                                    <tr align="left" valign="top">
                                       <th align="left" valign="bottom" width="9%" id="d106260e5156">步</th>
                                       <th align="left" valign="bottom" width="27%" id="d106260e5159">OCI行动</th>
                                       <th align="left" valign="bottom" width="9%" id="d106260e5162">XID</th>
                                       <th align="left" valign="bottom" width="23%" id="d106260e5165">旗</th>
                                       <th align="left" valign="bottom" width="32%" id="d106260e5168">结果</th>
                                    </tr>
                                 </thead>
                                 <tbody>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="9%" id="d106260e5173" headers="d106260e5156 ">
                                          <p>1</p>
                                       </td>
                                       <td align="left" valign="top" width="27%" headers="d106260e5173 d106260e5159 "><pre class="oac_no_warn" dir="ltr">OCITransStart（）</pre></td>
                                       <td align="left" valign="top" width="9%" headers="d106260e5173 d106260e5162 ">
                                          <p>1234</p>
                                       </td>
                                       <td align="left" valign="top" width="23%" headers="d106260e5173 d106260e5165 ">
                                          <p><code class="codeph">OCI_TRANS_NEW</code> |</p>
                                          <p><code class="codeph">OCI_TRANS_READONLY</code></p>
                                       </td>
                                       <td align="left" valign="top" width="32%" headers="d106260e5173 d106260e5168 ">
                                          <p>启动新的只读事务</p>
                                       </td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="9%" id="d106260e5194" headers="d106260e5156 ">
                                          <p>2</p>
                                       </td>
                                       <td align="left" valign="top" width="27%" headers="d106260e5194 d106260e5159 "><pre class="oac_no_warn" dir="ltr">SQL SELECT</pre></td>
                                       <td align="left" valign="top" width="9%" headers="d106260e5194 d106260e5162 ">
                                          <p>-</p>
                                       </td>
                                       <td align="left" valign="top" width="23%" headers="d106260e5194 d106260e5165 ">
                                          <p>-</p>
                                       </td>
                                       <td align="left" valign="top" width="32%" headers="d106260e5194 d106260e5168 ">
                                          <p>查询数据库</p>
                                       </td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="9%" id="d106260e5210" headers="d106260e5156 ">
                                          <p>3</p>
                                       </td>
                                       <td align="left" valign="top" width="27%" headers="d106260e5210 d106260e5159 "><pre class="oac_no_warn" dir="ltr">OCITransCommit（）</pre></td>
                                       <td align="left" valign="top" width="9%" headers="d106260e5210 d106260e5162 ">
                                          <p>-</p>
                                       </td>
                                       <td align="left" valign="top" width="23%" headers="d106260e5210 d106260e5165 ">
                                          <p>-</p>
                                       </td>
                                       <td align="left" valign="top" width="32%" headers="d106260e5210 d106260e5168 ">
                                          <p>无效 - 交易是只读的，不做任何更改</p>
                                       </td>
                                    </tr>
                                 </tbody>
                              </table>
                           </div>
                           <!-- class="inftblhruleinformal" -->
                           <div class="infoboxnotealso" id="GUID-7E9DAAEC-C836-4AFF-88FA-CEACAFC5415A__GUID-B7DF7ADB-0F62-4544-9C01-3335C332CE57">
                              <p class="notep1">也可以看看：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p><a href="transaction-functions.html#GUID-81E5963B-4DE7-47E1-ABB0-C1490AF3BAA8" title="设置事务的开始。">OCITransStart（）</a></p>
                                 </li>
                                 <li>
                                    <p><a href="transaction-functions.html#GUID-DDAE3122-8769-4A30-8D78-EB2A3CCF77D4" title="提交与指定服务上下文关联的事务。">OCITransCommit（）</a></p>
                                 </li>
                              </ul>
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div>
            </div><a id="LNOCI16555"></a><div class="props_rev_3"><a id="GUID-5579C27E-2536-4B21-96DB-3EDFECF576B5" name="GUID-5579C27E-2536-4B21-96DB-3EDFECF576B5"></a><h3 id="LNOCI-GUID-5579C27E-2536-4B21-96DB-3EDFECF576B5" class="sect3"><span class="enumeration_section">10.3</span>密码和会话管理</h3>
               <div>
                  <p>OCI可以验证和维护多个用户。</p>
                  <div class="p">本节包括以下主题：<ul style="list-style-type:disc">
                        <li>
                           <p><a href="managing-scalable-platforms.html#GUID-0C150A00-8DE9-4A8C-83BC-802D25503CA5" title="OCISessionBegin（）调用针对服务上下文句柄中设置的服务器对用户进行身份验证。">OCI认证管理</a></p>
                        </li>
                        <li>
                           <p><a href="managing-scalable-platforms.html#GUID-D3FDA896-99A8-401B-8DD7-EE775DB133F6" title="OCIPasswordChange（）调用允许应用程序根据需要修改用户的数据库密码。">OCI密码管理</a></p>
                        </li>
                        <li>
                           <p><a href="managing-scalable-platforms.html#GUID-9B8EC09D-7347-4FB4-90A4-08A2984DAED7" title="对于应用程序使用密码凭据连接到数据库的大规模部署，可以将此类凭据存储在客户端Oracle钱包中。">安全外部密码存储</a></p>
                        </li>
                        <li>
                           <p><a href="managing-scalable-platforms.html#GUID-69A0AE8C-3F8D-4EDD-A817-730F17B3DF3E" title="通过在几个服务器连接上复用用户会话来主动平衡用户负载的事务服务器必须将这些连接组合到服务器组中。">OCI会话管理</a></p>
                        </li>
                     </ul>
                  </div>
               </div><a id="LNOCI16556"></a><div class="props_rev_3"><a id="GUID-0C150A00-8DE9-4A8C-83BC-802D25503CA5" name="GUID-0C150A00-8DE9-4A8C-83BC-802D25503CA5"></a><h4 id="LNOCI-GUID-0C150A00-8DE9-4A8C-83BC-802D25503CA5" class="sect4"><span class="enumeration_section">10.3.1</span> OCI认证管理</h4>
                  <div>
                     <p><code class="codeph">OCISessionBegin()</code>调用针对服务上下文句柄中设置的服务器对用户进行身份验证。
                     </p>
                     <p>它必须是任何给定服务器句柄的第一次调用。<code class="codeph">OCISessionBegin()</code>对用户进行身份验证，以访问服务器句柄和调用的服务上下文指定的Oracle数据库：在<code class="codeph">OCIServerAttach()</code>初始化服务器句柄后，必须调用<code class="codeph">OCISessionBegin()</code>来验证该服务器的用户。
                     </p>
                     <p>在服务器句柄上首次调用<code class="codeph">OCISessionBegin()</code>时，可能无法在可迁移模式（ <code class="codeph">OCI_MIGRATE</code> ）中创建用户会话。之后<code class="codeph">OCISessionBegin()</code>被调用的服务器处理，应用程序可以调用<code class="codeph">OCISessionBegin()</code>再次来初始化不同或相同的证书和不同或相同的操作模式的另一个用户会话句柄。对于在<code class="codeph">OCI_MIGRATE</code>模式下对用户进行身份验证的应用程序，服务句柄必须已与不可迁移的用户句柄相关联。该用户句柄的<code class="codeph">userid</code>成为可迁移用户会话的所有者标识。每个可迁移的会话都必须具有不可迁移的父会话。
                     </p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>如果未指定<code class="codeph">OCI_MIGRATE</code>模式，则用户会话上下文只能与<code class="codeph">OCISessionBegin()</code>指定的服务器句柄一起使用。
                           </p>
                        </li>
                        <li>
                           <p>如果指定了<code class="codeph">OCI_MIGRATE</code>模式，则可以使用其他服务器句柄设置用户身份验证。但是，用户会话上下文只能与解析为同一数据库实例的服务器句柄一起使用。在会话切换期间执行安全检查。
                           </p>
                        </li>
                     </ul>
                     <p>仅当会话的所有者ID与当前连接到同一服务器的不可迁移会话的<code class="codeph">userid</code> ID匹配时，可迁移会话才能切换到不同的服务器句柄。
                     </p>
                     <p><code class="codeph">OCI_SYSDBA</code> ， <code class="codeph">OCI_SYSOPER</code> ， <code class="codeph">OCI_SYSBKP</code> ， <code class="codeph">OCI_SYSDGD</code> ， <code class="codeph">OCI_SYSKMT</code> ， <code class="codeph">OCI_SYSRAC</code> ， <code class="codeph">OCI_SYSASM</code>和<code class="codeph">OCI_PRELIM_AUTH</code>设置只能与主用户会话上下文一起使用。对于<code class="codeph">OCI_SYSASM</code> ，SYSASM连接仅适用于ASM实例（不是数据库实例）。
                     </p>
                     <p>可迁移会话可以切换或迁移到由环境句柄表示的环境中的服务器句柄。它还可以在同一进程中的另一个环境中迁移或克隆到服务器句柄，或者以不同的方式在不同的进程中克隆。要执行此迁移或克隆，您必须执行以下操作：</p>
                     <ol>
                        <li>
                           <p>使用<code class="codeph">OCI_ATTR_MIGSESSION</code>从会话句柄中提取会话ID。这是一个字节数组，调用者不得修改。
                           </p>
                        </li>
                        <li>
                           <p>将此会话ID传输到另一个进程。</p>
                        </li>
                        <li>
                           <p>在新环境中，创建会话句柄并使用<code class="codeph">OCI_ATTR_MIGSESSION</code>设置会话ID。</p>
                        </li>
                        <li>
                           <p>执行<code class="codeph">OCISessionBegin()</code> 。生成的会话句柄已完全通过身份验证。
                           </p>
                        </li>
                     </ol>
                     <p>要为调用<code class="codeph">OCISessionBegin()</code>提供凭据，必须在用户会话句柄参数中为数据库身份验证提供有效的用户名和密码对。这涉及使用<code class="codeph">OCIAttrSet()</code>在用户会话句柄上设置<code class="codeph">OCI_ATTR_USERNAME</code>和<code class="codeph">OCI_ATTR_PASSWORD</code>属性。然后<code class="codeph">OCISessionBegin()</code>被调用<code class="codeph">OCI_CRED_RDBMS</code> 。</p>
                     <p>当使用<code class="codeph">OCISessionEnd()</code>终止用户会话句柄时，用户名和密码属性会更改，因此在将来调用<code class="codeph">OCISessionBegin()</code>无法重用。必须在下一次<code class="codeph">OCISessionBegin()</code>调用之前将它们重置为新值。
                     </p>
                     <p>或者，您可以提供外部凭据。在调用<code class="codeph">OCISessionBegin()</code>之前，不需要在用户会话句柄上设置任何属性。凭证类型是<code class="codeph">OCI_CRED_EXT</code> 。如果值被设置为<code class="codeph">OCI_ATTR_USERNAME</code>和<code class="codeph">OCI_ATTR_PASSWORD</code> ，如果这些被忽略<code class="codeph">OCI_CRED_EXT</code>使用。
                     </p>
                     <div class="infoboxnotealso" id="GUID-0C150A00-8DE9-4A8C-83BC-802D25503CA5__GUID-69D20040-BA46-47CF-A85C-5EE93EF4B7CA">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="handle-and-descriptor-attributes.html#GUID-FB263210-118E-4DB3-A840-1769EF0CB977" title="列出并描述用户会话句柄属性。">用户会话句柄属性</a>有关<code class="codeph">OCI_ATTR_MIGSESSION</code>更多信息</p>
                           </li>
                           <li>
                              <p><a href="connect-authorize-and-initialize-functions.html#GUID-31B1FDB3-056E-4AF9-9B89-8DA6AA156947" title="创建用户会话并开始给定服务器的用户会话。">OCISessionBegin（）</a></p>
                           </li>
                           <li>
                              <p><a href="connect-authorize-and-initialize-functions.html#GUID-B6291228-DA2F-4CE9-870A-F94243141757" title="为OCI操作创建数据源的访问路径。">OCIServerAttach（）</a></p>
                           </li>
                           <li>
                              <p><a href="handle-and-descriptor-functions.html#GUID-3741D7BD-7652-4D7A-8813-AC2AEA8D3B03" title="设置句柄或描述符的属性值。">OCIAttrSet（）</a></p>
                           </li>
                           <li>
                              <p><a href="connect-authorize-and-initialize-functions.html#GUID-2AE88BDC-2C44-4958-B26A-434B0407F06F" title="终止由OCISessionBegin（）创建的用户会话上下文。">OCISessionEnd（）</a></p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="LNOCI16557"></a><div class="props_rev_3"><a id="GUID-D3FDA896-99A8-401B-8DD7-EE775DB133F6" name="GUID-D3FDA896-99A8-401B-8DD7-EE775DB133F6"></a><h4 id="LNOCI-GUID-D3FDA896-99A8-401B-8DD7-EE775DB133F6" class="sect4"><span class="enumeration_section">10.3.2</span> OCI密码管理</h4>
                  <div>
                     <p><code class="codeph">OCIPasswordChange()</code>调用允许应用程序根据需要修改用户的数据库密码。
                     </p>
                     <p>如果对<code class="codeph">OCISessionBegin()</code>的调用返回错误消息或警告，指示用户的密码已过期，则此功能尤其有用。
                     </p>
                     <p>应用程序还可以使用<code class="codeph">OCIPasswordChange()</code>来建立用户身份验证上下文并更改密码。如果使用未初始化的服务上下文调用<code class="codeph">OCIPasswordChange()</code> ，它将使用旧密码建立服务上下文并验证用户的帐户，然后将密码更改为新密码。如果设置了<code class="codeph">OCI_AUTH</code>标志，则呼叫将初始化用户会话。否则，清除用户会话。
                     </p>
                     <p>如果已初始化传递给<code class="codeph">OCIPasswordChange()</code>的服务上下文，则<code class="codeph">OCIPasswordChange()</code>使用旧密码对给定帐户进行身份验证，并将密码更改为新密码。在这种情况下，无论如何设置标志，用户会话仍保持初始化。
                     </p>
                     <div class="infoboxnotealso" id="GUID-D3FDA896-99A8-401B-8DD7-EE775DB133F6__GUID-4C30DEDF-72B3-4D23-971D-2D50047701F8">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="miscellaneous-functions.html#GUID-5C677395-E96C-4CCF-8448-AA3ADA22C26B" title="更改帐户的密码。">OCIPasswordChange（）</a></p>
                           </li>
                           <li>
                              <p><a href="connect-authorize-and-initialize-functions.html#GUID-31B1FDB3-056E-4AF9-9B89-8DA6AA156947" title="创建用户会话并开始给定服务器的用户会话。">OCISessionBegin（）</a></p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="LNOCI13251"></a><div class="props_rev_3"><a id="GUID-9B8EC09D-7347-4FB4-90A4-08A2984DAED7" name="GUID-9B8EC09D-7347-4FB4-90A4-08A2984DAED7"></a><h4 id="LNOCI-GUID-9B8EC09D-7347-4FB4-90A4-08A2984DAED7" class="sect4"><span class="enumeration_section">10.3.3</span>安全外部密码存储</h4>
                  <div>
                     <p>对于应用程序使用密码凭据连接到数据库的大规模部署，可以将此类凭据存储在客户端Oracle钱包中。</p>
                     <p>Oracle钱包是一个安全的软件容器，用于存储身份验证和签名凭据。</p>
                     <p>在客户端Oracle钱包中存储数据库密码凭证，无需在应用程序代码，批处理作业或脚本中嵌入用户名和密码。这样可以降低在脚本和应用程序代码中以明文形式泄露密码的风险，并简化维护，因为每次用户名和密码更改时都不需要更改代码。此外，无需更改应用程序代码，可以更轻松地为这些用户帐户实施密码管理策略。</p>
                     <p>将客户端配置为使用外部密码存储时，应用程序可以使用以下语法连接到使用密码身份验证的数据库：</p><pre class="oac_no_warn" dir="ltr">CONNECT / @ <span class="italic">database_alias</span>
</pre><p>请注意，您无需在此<code class="codeph">CONNECT</code>语句中指定数据库登录凭据。相反，您的系统会在客户端钱包中查找数据库登录凭据。
                     </p>
                     <div class="infoboxnotealso" id="GUID-9B8EC09D-7347-4FB4-90A4-08A2984DAED7__GUID-9FF6515E-9770-4915-A269-F392EAF0A3C8">
                        <p class="notep1">也可以看看：</p>
                        <p>有关配置客户端以使用安全外部密码存储库的信息，请参见<a href="../admin/creating-and-configuring-an-oracle-database.html#ADMIN11133" target="_blank"><span><cite>“Oracle数据库管理员指南”</cite></span></a></p>
                     </div>
                  </div>
               </div><a id="LNOCI72640"></a><a id="LNOCI16558"></a><div class="props_rev_3"><a id="GUID-69A0AE8C-3F8D-4EDD-A817-730F17B3DF3E" name="GUID-69A0AE8C-3F8D-4EDD-A817-730F17B3DF3E"></a><h4 id="LNOCI-GUID-69A0AE8C-3F8D-4EDD-A817-730F17B3DF3E" class="sect4"><span class="enumeration_section">10.3.4</span> OCI会话管理</h4>
                  <div>
                     <p>通过在几个服务器连接上复用用户会话来主动平衡用户负载的事务服务器必须将这些连接组合到服务器组中。</p>
                     <p>Oracle数据库使用服务器组来标识这些连接，以便可以有效且安全地管理会话。</p>
                     <p>必须定义属性<code class="codeph">OCI_ATTR_SERVER_GROUP</code>以使用<code class="codeph">OCIAttrSet()</code>调用指定服务器组名称，如<a href="managing-scalable-platforms.html#GUID-69A0AE8C-3F8D-4EDD-A817-730F17B3DF3E__BGBFFEAB">例10-1</a>所示。
                     </p>
                     <p>服务器组名称是不超过30个字符的字母数字字符串。只能<span class="italic">在</span>调用<code class="codeph">OCIServerAttach()</code> <span class="italic">后</span>设置此属性。在创建使用该上下文的第一个非可迁移会话之前，必须在服务器上下文中设置<code class="codeph">OCI_ATTR_SERVER_GROUP</code>属性。成功创建会话并建立与服务器的连接后，无法更改服务器组名称。
                     </p>
                     <p>在服务器组内的服务器上创建的所有可迁移会话只能迁移到同一服务器组中的其他服务器。终止的服务器将从服务器组中删除。可以随时在现有服务器组中创建新服务器。</p>
                     <p>服务器组的使用是可选的。如果未指定服务器组，则在名为<code class="codeph">DEFAULT</code>的服务器组中创建服务器。</p>
                     <p>在非默认服务器组中创建的第一个不可迁移会话的所有者将成为服务器组的所有者。此服务器组中任何服务器的所有后续非迁移会话必须由服务器组的所有者创建。</p>
                     <p>使用专用服务器时，服务器组功能非常有用。它对共享服务器没有影响。所有共享服务器实际上都属于服务器组<code class="codeph">DEFAULT</code> 。</p>
                     <div class="example" id="GUID-69A0AE8C-3F8D-4EDD-A817-730F17B3DF3E__BGBFFEAB">
                        <p class="titleinexample">示例10-1定义OCI_ATTR_SERVER_GROUP属性以传递服务器组名称</p><pre class="oac_no_warn" dir="ltr">OCIAttrSet（（void *）srvhp，（ub4）OCI_HTYPE_SERVER，（void *）group_name，（ub4）strlen（（CONST char *）group_name），（ub4）OCI_ATTR_SERVER_GROUP，errhp）;</pre></div>
                     <!-- class="example" -->
                     <div class="section">
                        <div class="infoboxnotealso" id="GUID-69A0AE8C-3F8D-4EDD-A817-730F17B3DF3E__GUID-AF9B0214-A3CD-4AAD-BFA8-C712A07D8A10">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><a href="handle-and-descriptor-attributes.html#GUID-2B6D06A7-8EDF-46FF-BDEF-320D293DCA65" title="列出并描述服务器句柄属性。">服务器句柄属性</a>有关<code class="codeph">OCI_ATTR_SERVER_GROUP</code>属性的更多信息</p>
                              </li>
                              <li>
                                 <p><a href="handle-and-descriptor-functions.html#GUID-3741D7BD-7652-4D7A-8813-AC2AEA8D3B03" title="设置句柄或描述符的属性值。">OCIAttrSet（）</a></p>
                              </li>
                              <li>
                                 <p><a href="connect-authorize-and-initialize-functions.html#GUID-B6291228-DA2F-4CE9-870A-F94243141757" title="为OCI操作创建数据源的访问路径。">OCIServerAttach（）</a></p>
                              </li>
                           </ul>
                           <p></p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="LNOCI16559"></a><div class="props_rev_3"><a id="GUID-A5830D58-3079-45DD-BE3A-81C41991DA70" name="GUID-A5830D58-3079-45DD-BE3A-81C41991DA70"></a><h3 id="LNOCI-GUID-A5830D58-3079-45DD-BE3A-81C41991DA70" class="sect3"><span class="enumeration_section">10.4</span> OCI中的中间层应用</h3>
               <div>
                  <p>中间层应用程序接收来自浏览器客户端的请求。</p>
                  <p>应用程序确定数据库访问以及是否生成HTML页面。应用程序可在单个数据库会话中拥有多个<span class="italic">轻量级</span>用户会话。这些轻量级会话允许对每个用户进行身份验证，而无需单独数据库连接的开销，并且它们通过中间层保留真实用户的身份。
                  </p>
                  <p>只要客户端使用中间层对自身进行身份验证，并且中间层使用数据库对自身进行身份验证，并且中间层被授权由管理员代表客户端进行操作，则客户端身份可以一直维护到数据库中不损害客户的安全性。</p>
                  <p>安全三层架构的设计围绕一组三个信任区域开发。</p>
                  <p>第一个是客户信任区。连接到Web应用程序服务器的客户端由中间层使用任何方式进行身份验证：密码，加密令牌或其他方式。该方法可以与用于建立其他信任区域的方法完全不同。</p>
                  <p>第二个信任区域是应用程序服务器。数据服务器验证应用程序服务器的身份并信任它以传递客户端的正确标识。</p>
                  <p>第三个信任区域是与授权服务器的数据服务器交互，以获取分配给客户端和应用服务器的角色。</p>
                  <p>应用程序服务器在连接到服务器后为自己创建主会话。它以正常方式对数据库进行身份验证，从而创建应用程序服务器信任区域。应用程序服务器标识现在是众所周知的，并且受数据服务器的信任。</p>
                  <p>当应用程序验证连接到应用程序服务器的客户端的身份时，它会创建第一个信任区域。应用程序服务器现在需要客户端的会话句柄，以便它可以为客户端请求提供服务。中间层进程分配会话句柄，然后使用<code class="codeph">OCIAttrSet()</code>设置客户端的以下属性：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><code class="codeph">OCI_ATTR_USERNAME</code>设置客户端的数据库用户名。
                        </p>
                     </li>
                     <li>
                        <p><code class="codeph">OCI_ATTR_PROXY_CREDENTIALS</code>表示发出代理请求的经过身份验证的应用程序。</p>
                     </li>
                  </ul>
                  <p>要指定激活后的应用程序服务器连接的客户端角色的列表，它可以调用<code class="codeph">OCIAttrSet()</code>与属性<code class="codeph">OCI_ATTR_INITIAL_CLIENT_ROLES</code>和字符串数组，其中包含了之前的角色列表<code class="codeph">OCISessionBegin()</code>调用。然后建立角色并在一次往返中验证代理能力。如果不允许应用程序服务器代表客户端操作，或者不允许应用程序服务器激活指定的角色，则<code class="codeph">OCISessionBegin()</code>调用将失败。
                  </p>
                  <p>本节包括以下主题： <a href="managing-scalable-platforms.html#GUID-B95CE5B4-1B9A-45F7-964B-614B4D151A83" title="使用以下属性可以指定客户端的外部名称和初始权限。">中间层应用程序的OCI属性</a> 。
                  </p>
                  <div class="infoboxnotealso" id="GUID-A5830D58-3079-45DD-BE3A-81C41991DA70__GUID-4D201B07-B29C-4717-B6FF-804CB856EF2A">
                     <p class="notep1">也可以看看：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="handle-and-descriptor-functions.html#GUID-3741D7BD-7652-4D7A-8813-AC2AEA8D3B03" title="设置句柄或描述符的属性值。">OCIAttrSet（）</a></p>
                        </li>
                        <li>
                           <p><a href="connect-authorize-and-initialize-functions.html#GUID-31B1FDB3-056E-4AF9-9B89-8DA6AA156947" title="创建用户会话并开始给定服务器的用户会话。">OCISessionBegin（）</a></p>
                        </li>
                     </ul>
                  </div>
               </div><a id="LNOCI16560"></a><div class="props_rev_3"><a id="GUID-B95CE5B4-1B9A-45F7-964B-614B4D151A83" name="GUID-B95CE5B4-1B9A-45F7-964B-614B4D151A83"></a><h4 id="LNOCI-GUID-B95CE5B4-1B9A-45F7-964B-614B4D151A83" class="sect4"><span class="enumeration_section">10.4.1</span>中间层应用程序的OCI属性</h4>
                  <div>
                     <p>使用以下属性可以指定客户端的外部名称和初始权限。</p>
                     <p>应用程序使用这些凭据作为识别或验证客户端的替代方法。</p>
                     <div class="p">这些属性包括：<ul style="list-style-type:disc">
                           <li>
                              <p><a href="managing-scalable-platforms.html#GUID-FF1A654F-6B03-4378-B325-024E92BEAF19" title="使用OCI_CRED_PROXY作为OCISessionBegin（）的credt参数中传递的值。">OCI_CRED_PROXY</a></p>
                           </li>
                           <li>
                              <p><a href="managing-scalable-platforms.html#GUID-385D595C-F915-458F-A8E4-1A7CC4BF6C19" title="使用OCI_ATTR_PROXY_CREDENTIALS属性在客户端身份验证中指定应用程序服务器的凭据。">OCI_ATTR_PROXY_CREDENTIALS</a></p>
                           </li>
                           <li>
                              <p><a href="managing-scalable-platforms.html#GUID-D4106D41-743B-411E-82D6-7C41BDAF44C5" title="使用OCI_ATTR_DISTINGUISHED_NAME传递客户端的可分辨名称。">OCI_ATTR_DISTINGUISHED_NAME</a></p>
                           </li>
                           <li>
                              <p><a href="managing-scalable-platforms.html#GUID-69416D35-A689-41EB-9086-7B77B3331C9D" title="将来的Oracle数据库版本不支持使用OCI_ATTR_CERTIFICATE的基于证书的代理身份验证。">OCI_ATTR_CERTIFICATE</a></p>
                           </li>
                           <li>
                              <p><a href="managing-scalable-platforms.html#GUID-B835FE41-2149-4912-9CB7-B65B15E1ABB1" title="使用OCI_ATTR_INITIAL_CLIENT_ROLES属性指定应用程序服务器连接到Oracle数据库时客户端将拥有的角色。">OCI_ATTR_INITIAL_CLIENT_ROLES</a></p>
                           </li>
                           <li>
                              <p><a href="managing-scalable-platforms.html#GUID-8A9F1295-4360-4AC6-99A4-050C5C82E0B0" title="在中间层上使用OCI_ATTR_CLIENT_IDENTIFIER来跟踪最终用户身份。">OCI_ATTR_CLIENT_IDENTIFIER</a></p>
                           </li>
                           <li>
                              <p><a href="managing-scalable-platforms.html#GUID-BAD07740-13A4-4760-A794-8552A040E70A" title="要在中间层上使用客户端的密码进行验证，应用程序服务器可以使用现有属性OCI_ATTR_PASSWORD和客户端的身份验证数据。">OCI_ATTR_PASSWORD</a></p>
                           </li>
                        </ul>
                     </div>
                  </div><a id="LNOCI16561"></a><div class="props_rev_3"><a id="GUID-FF1A654F-6B03-4378-B325-024E92BEAF19" name="GUID-FF1A654F-6B03-4378-B325-024E92BEAF19"></a><h5 id="LNOCI-GUID-FF1A654F-6B03-4378-B325-024E92BEAF19" class="sect5"><span class="enumeration_section">10.4.1.1</span> OCI_CRED_PROXY</h5>
                     <div>
                        <p>使用<code class="codeph">OCI_CRED_PROXY</code>作为<code class="codeph">OCISessionBegin()</code>的<code class="codeph">credt</code>参数中传递的值。
                        </p>
                        <p>当应用程序服务器代表客户端启动会话时，请使用<code class="codeph">OCI_CRED_PROXY</code>作为<code class="codeph">OCISessionBegin()</code>的<code class="codeph">credt</code>参数中传递的值，而不是<code class="codeph">OCI_CRED_RDBMS</code> （需要数据库用户名和密码）或<code class="codeph">OCI_CRED_EXT</code> （外部提供的凭据）。
                        </p>
                        <div class="infoboxnotealso" id="GUID-FF1A654F-6B03-4378-B325-024E92BEAF19__GUID-4A184AC3-377B-40B0-A184-21695AA0A413">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="connect-authorize-and-initialize-functions.html#GUID-31B1FDB3-056E-4AF9-9B89-8DA6AA156947" title="创建用户会话并开始给定服务器的用户会话。">OCISessionBegin（）</a></p>
                        </div>
                     </div>
                  </div><a id="LNOCI72641"></a><a id="LNOCI16562"></a><div class="props_rev_3"><a id="GUID-385D595C-F915-458F-A8E4-1A7CC4BF6C19" name="GUID-385D595C-F915-458F-A8E4-1A7CC4BF6C19"></a><h5 id="LNOCI-GUID-385D595C-F915-458F-A8E4-1A7CC4BF6C19" class="sect5"><span class="enumeration_section">10.4.1.2</span> OCI_ATTR_PROXY_CREDENTIALS</h5>
                     <div>
                        <p>使用<code class="codeph">OCI_ATTR_PROXY_CREDENTIALS</code>属性在客户端身份验证中指定应用程序服务器的凭据。
                        </p>
                        <p>您可以编写以下声明和<code class="codeph">OCIAttrSet()</code>调用，如<a href="managing-scalable-platforms.html#GUID-385D595C-F915-458F-A8E4-1A7CC4BF6C19__BGBEJIGA">例10-2</a>所示。
                        </p>
                        <div class="example" id="GUID-385D595C-F915-458F-A8E4-1A7CC4BF6C19__BGBEJIGA">
                           <p class="titleinexample">示例10-2定义OCI_ATTR_PROXY_CREDENTIALS属性以指定用于客户端身份验证的Application Server的凭据</p><pre class="oac_no_warn" dir="ltr">OCISession * session_handle; OCISvcCtx * application_server_session_handle; OCIError * error_handle; ...OCIAttrSet（（void *）session_handle，（ub4）OCI_HTYPE_SESSION，（void *）application_server_session_handle，（ub4）0，OCI_ATTR_PROXY_CREDENTIALS，error_handle）;</pre></div>
                        <!-- class="example" -->
                        <div class="section">
                           <div class="infoboxnotealso" id="GUID-385D595C-F915-458F-A8E4-1A7CC4BF6C19__GUID-7A650D2D-EE2A-485C-9791-8E8BFF4ECC89">
                              <p class="notep1">也可以看看：</p>
                              <p><a href="handle-and-descriptor-functions.html#GUID-3741D7BD-7652-4D7A-8813-AC2AEA8D3B03" title="设置句柄或描述符的属性值。">OCIAttrSet（）</a></p>
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNOCI72642"></a><a id="LNOCI16563"></a><div class="props_rev_3"><a id="GUID-D4106D41-743B-411E-82D6-7C41BDAF44C5" name="GUID-D4106D41-743B-411E-82D6-7C41BDAF44C5"></a><h5 id="LNOCI-GUID-D4106D41-743B-411E-82D6-7C41BDAF44C5" class="sect5"><span class="enumeration_section">10.4.1.3</span> OCI_ATTR_DISTINGUISHED_NAME</h5>
                     <div>
                        <p>使用<code class="codeph">OCI_ATTR_DISTINGUISHED_NAME</code>传递客户端的可分辨名称。
                        </p>
                        <p>您的应用程序可以使用X.509证书中包含的专有名称作为客户端的登录名，而不是数据库用户名。</p>
                        <p>要传递客户端的可分辨名称，中间层服务器调用<code class="codeph">OCIAttrSet()</code> ，并传递<code class="codeph">OCI_ATTR_DISTINGUISHED_NAME</code> ，如<a href="managing-scalable-platforms.html#GUID-D4106D41-743B-411E-82D6-7C41BDAF44C5__BGBIGEGE">例10-3</a>所示。
                        </p>
                        <div class="example" id="GUID-D4106D41-743B-411E-82D6-7C41BDAF44C5__BGBIGEGE">
                           <p class="titleinexample">示例10-3定义OCI_ATTR_DISTINGUISHED_NAME属性以传递客户端的可分辨名称</p><pre class="oac_no_warn" dir="ltr">/ *声明* / ...OCIAttrSet（（void *）session_handle，（ub4）OCI_HTYPE_SESSION，（void *）distinguished_name，（ub4）0，OCI_ATTR_DISTINGUISHED_NAME，error_handle）;</pre></div>
                        <!-- class="example" -->
                        <div class="section">
                           <div class="infoboxnotealso" id="GUID-D4106D41-743B-411E-82D6-7C41BDAF44C5__GUID-E5973470-A9BB-4691-A9B5-3594620E36AC">
                              <p class="notep1">也可以看看：</p>
                              <p><a href="handle-and-descriptor-functions.html#GUID-3741D7BD-7652-4D7A-8813-AC2AEA8D3B03" title="设置句柄或描述符的属性值。">OCIAttrSet（）</a></p>
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNOCI72643"></a><a id="LNOCI16564"></a><div class="props_rev_3"><a id="GUID-69416D35-A689-41EB-9086-7B77B3331C9D" name="GUID-69416D35-A689-41EB-9086-7B77B3331C9D"></a><h5 id="LNOCI-GUID-69416D35-A689-41EB-9086-7B77B3331C9D" class="sect5"><span class="enumeration_section">10.4.1.4</span> OCI_ATTR_CERTIFICATE</h5>
                     <div>
                        <p>将来的Oracle数据库版本不支持使用<code class="codeph">OCI_ATTR_CERTIFICATE</code>的基于证书的代理身份验证。
                        </p>
                        <p>请改用<code class="codeph">OCI_ATTR_DISTINGUISHED_NAME</code>或<code class="codeph">OCI_ATTR_USERNAME</code>属性。这种身份验证方法类似于使用可分辨名称。整个X.509证书由中间层服务器传递到数据库。
                        </p>
                        <p>要传递整个证书，中间层调用<code class="codeph">OCIAttrSet()</code> ，传递<code class="codeph">OCI_ATTR_CERTIFICATE</code> ，如<a href="managing-scalable-platforms.html#GUID-69416D35-A689-41EB-9086-7B77B3331C9D__BGBCCFFC">例10-4</a>所示。
                        </p>
                        <div class="example" id="GUID-69416D35-A689-41EB-9086-7B77B3331C9D__BGBCCFFC">
                           <p class="titleinexample">示例10-4定义OCI_ATTR_CERTIFICATE属性以传递整个X.509证书</p><pre class="oac_no_warn" dir="ltr">OCIAttrSet（（void *）session_handle，（ub4）OCI_HTYPE_SESSION，（void *）证书，ub4 certificate_length，OCI_ATTR_CERTIFICATE，error_handle）;</pre></div>
                        <!-- class="example" -->
                        <div class="section">
                           <div class="infoboxnotealso" id="GUID-69416D35-A689-41EB-9086-7B77B3331C9D__GUID-4DCF7449-7C46-4845-B27E-D9AEE6DC484E">
                              <p class="notep1">也可以看看：</p>
                              <p><a href="handle-and-descriptor-functions.html#GUID-3741D7BD-7652-4D7A-8813-AC2AEA8D3B03" title="设置句柄或描述符的属性值。">OCIAttrSet（）</a></p>
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNOCI72644"></a><a id="LNOCI16565"></a><div class="props_rev_3"><a id="GUID-B835FE41-2149-4912-9CB7-B65B15E1ABB1" name="GUID-B835FE41-2149-4912-9CB7-B65B15E1ABB1"></a><h5 id="LNOCI-GUID-B835FE41-2149-4912-9CB7-B65B15E1ABB1" class="sect5"><span class="enumeration_section">10.4.1.5</span> OCI_ATTR_INITIAL_CLIENT_ROLES</h5>
                     <div>
                        <p>使用<code class="codeph">OCI_ATTR_INITIAL_CLIENT_ROLES</code>属性指定应用程序服务器连接到Oracle数据库时客户端将拥有的角色。
                        </p>
                        <p>要启用一组角色，将使用属性，一个<code class="codeph">NULL</code> -terminated字符串数组以及数组中的字符串数来调用函数<code class="codeph">OCIAttrSet()</code> ，如<a href="managing-scalable-platforms.html#GUID-B835FE41-2149-4912-9CB7-B65B15E1ABB1__BGBCGEEF">例10-5</a>所示。
                        </p>
                        <div class="example" id="GUID-B835FE41-2149-4912-9CB7-B65B15E1ABB1__BGBCGEEF">
                           <p class="titleinexample">示例10-5定义OCI_ATTR_INITIAL_CLIENT_ROLES属性以传递客户端角色</p><pre class="oac_no_warn" dir="ltr">OCIAttrSet（（void *）session_handle，（ub4）OCI_HTYPE_SESSION，（void *）role_array，（ub4）number_of_strings，OCI_ATTR_INITIAL_CLIENT_ROLES，error_handle）;</pre></div>
                        <!-- class="example" -->
                        <div class="section">
                           <div class="infoboxnotealso" id="GUID-B835FE41-2149-4912-9CB7-B65B15E1ABB1__GUID-BCA2230A-2239-4014-9E19-8B5EBDFB07C9">
                              <p class="notep1">也可以看看：</p>
                              <p><a href="handle-and-descriptor-functions.html#GUID-3741D7BD-7652-4D7A-8813-AC2AEA8D3B03" title="设置句柄或描述符的属性值。">OCIAttrSet（）</a></p>
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNOCI72645"></a><a id="LNOCI16566"></a><div class="props_rev_3"><a id="GUID-8A9F1295-4360-4AC6-99A4-050C5C82E0B0" name="GUID-8A9F1295-4360-4AC6-99A4-050C5C82E0B0"></a><h5 id="LNOCI-GUID-8A9F1295-4360-4AC6-99A4-050C5C82E0B0" class="sect5"><span class="enumeration_section">10.4.1.6</span> OCI_ATTR_CLIENT_IDENTIFIER</h5>
                     <div>
                        <p>在中间层上使用<code class="codeph">OCI_ATTR_CLIENT_IDENTIFIER</code>来跟踪最终用户身份。
                        </p>
                        <p>许多中间层应用程序作为应用程序连接到数据库，并依赖中间层来跟踪最终用户身份。为了在各种数据库组件中集成对这些用户的身份的跟踪，数据库客户端可以随时在会话句柄中设置<code class="codeph">CLIENT_IDENTIFIER</code> （来自应用程序上下文命名空间<code class="codeph">USERENV</code>的预定义属性）。在<code class="codeph">OCIAttrSet()</code>调用中使用OCI属性<code class="codeph">OCI_ATTR_CLIENT_IDENTIFIER</code> ，如<a href="managing-scalable-platforms.html#GUID-8A9F1295-4360-4AC6-99A4-050C5C82E0B0__BGBIEGGA">例10-6</a>所示。在对服务器的下一个请求中，信息被传播并存储在服务器会话中。
                        </p>
                        <p><code class="codeph">CLIENT_IDENTIFIER</code>也可以使用<code class="codeph">DBMS_SESSION.SET_IDENTIFIER</code>过程设置，如果提供的输入超过64字节，则会自动截断，因为客户端ID的最大大小为64字节。
                        </p>
                        <p><code class="codeph">OCI_ATTR_CLIENT_IDENTIFIER</code>还可以与全局应用程序上下文一起使用，以将上下文的可用性限制为这些用户的所选标识。
                        </p>
                        <p>当客户端具有多个会话时，请使用相同的客户端标识符为每个会话执行<code class="codeph">OCIAttrSet()</code> 。必须手动为通过透明应用程序故障转移（TAF）重新建立的会话执行<code class="codeph">OCIAttrSet()</code> ）。
                        </p>
                        <p>客户端标识符在<code class="codeph">V$SESSION</code>作为<code class="codeph">CLIENT_IDENTIFIER</code>列或通过具有此SQL语句的系统上下文找到：</p><pre class="oac_no_warn" dir="ltr">SELECT <code class="codeph">SYS_CONTEXT</code> （'userenv'，'client_identifier'）FROM DUAL;</pre><div class="example" id="GUID-8A9F1295-4360-4AC6-99A4-050C5C82E0B0__BGBIEGGA">
                           <p class="titleinexample">示例10-6定义传递最终用户标识的OCI_ATTR_CLIENT_IDENTIFIER属性</p><pre class="oac_no_warn" dir="ltr">OCIAttrSet（（void *）session_handle，（ub4）OCI_HTYPE_SESSION，（void *）“janedoe”，（ub4）strlen（“janedoe”），OCI_ATTR_CLIENT_IDENTIFIER，error_handle）;</pre></div>
                        <!-- class="example" -->
                        <div class="section">
                           <div class="infoboxnotealso" id="GUID-8A9F1295-4360-4AC6-99A4-050C5C82E0B0__GUID-FE06E10E-B455-499C-BFA7-756EAE3A7A78">
                              <p class="notep1">也可以看看：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p><a href="../dbseg/configuring-authentication.html#DBSEG15003" target="_blank"><span><cite>“Oracle数据库安全指南</cite></span></a> ”中有关在多层环境中保留用户身份的部分“</p>
                                 </li>
                                 <li>
                                    <p><a href="high-availability-in-oci.html#GUID-F7817CD2-4A2C-4D37-BD36-56DBABD4725F" title="透明应用程序故障转移（TAF）是一种客户端功能，旨在最大程度地减少由于实例或网络故障导致数据库连接失败时发生的对最终用户应用程序的中断。">OCI中的透明应用程序故障转移</a></p>
                                 </li>
                                 <li>
                                    <p><a href="handle-and-descriptor-functions.html#GUID-3741D7BD-7652-4D7A-8813-AC2AEA8D3B03" title="设置句柄或描述符的属性值。">OCIAttrSet（）</a></p>
                                 </li>
                              </ul>
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNOCI72646"></a><a id="LNOCI72647"></a><a id="LNOCI16567"></a><div class="props_rev_3"><a id="GUID-BAD07740-13A4-4760-A794-8552A040E70A" name="GUID-BAD07740-13A4-4760-A794-8552A040E70A"></a><h5 id="LNOCI-GUID-BAD07740-13A4-4760-A794-8552A040E70A" class="sect5"><span class="enumeration_section">10.4.1.7</span> OCI_ATTR_PASSWORD</h5>
                     <div>
                        <p>要在中间层上使用客户端的密码进行验证，应用程序服务器可以使用现有属性<code class="codeph">OCI_ATTR_PASSWORD</code>和客户端的身份验证数据。
                        </p>
                        <p>中间层可以要求数据库服务器通过验证客户端的密码而不是自己进行身份验证来代表客户端对客户端进行身份验证。虽然看起来这与客户端/服务器连接相同，但客户端不必在客户端系统上安装Oracle数据库软件即可执行数据库操作。要使用客户端的密码，应用程序服务器使用现有属性<code class="codeph">OCI_ATTR_PASSWORD</code>为<code class="codeph">OCIAttrSet()</code>提供身份验证数据，如<a href="managing-scalable-platforms.html#GUID-BAD07740-13A4-4760-A794-8552A040E70A__BGBCIHIA">例10-7</a>所示。
                        </p>
                        <p><a href="managing-scalable-platforms.html#GUID-BAD07740-13A4-4760-A794-8552A040E70A__BGBBBEFJ">示例10-8</a>显示了OCI属性，使您可以指定客户端的外部名称和初始权限。OCI应用程序使用这些凭证作为识别或验证客户端的替代方法。
                        </p>
                        <div class="example" id="GUID-BAD07740-13A4-4760-A794-8552A040E70A__BGBCIHIA">
                           <p class="titleinexample">示例10-7定义OCI_ATTR_PASSWORD属性以传递验证密码</p><pre class="oac_no_warn" dir="ltr">OCIAttrSet（（void *）session_handle，（ub4）OCI_HTYPE_SESSION，（void *）password，（ub4）0，OCI_ATTR_PASSWORD，error_handle）;</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-BAD07740-13A4-4760-A794-8552A040E70A__BGBBBEFJ">
                           <p class="titleinexample">示例10-8允许您指定客户端的外部名称和初始权限的OCI属性</p><pre class="oac_no_warn" dir="ltr">...* OCIEnv * environment_handle; OCIServer * data_server_handle; OCIError * error_handle; OCISvcCtx * application_server_service_handle; OraText * client_roles [2]; OCISession * first_client_session_handle，second_client_session_handle; .../ * **一般初始化和上下文分配。* /（void）OCIInitialize（（ub4）OCI_DEFAULT，（void *）0，（void *（*）（void *，size_t））0，（void *（*）（void *，void *，size_t））0 ，（void（*）（void *，void *））0）; （void）OCIEnvInit（（OCIEnv **）＆environment_handle，OCI_DEFAULT，（size_t）0，（void **）0）; （void）OCIHandleAlloc（（void *）environment_handle，（void **）＆error_handle，OCI_HTYPE_ERROR，（size_t）0，（void **）0）; / * **分配并初始化**应用程序服务器使用的服务器和服务上下文。* /（void）OCIHandleAlloc（（void *）environment_handle，（void **）＆data_server_handle，OCI_HTYPE_SERVER，（size_t）0，（void **）0）; （void）OCIHandleAlloc（（void *）environment_handle，（void **）＆application_server_service_handle，OCI_HTYPE_SVCCTX，（size_t）0，（void **）0）; （void）OCIAttrSet（（void *）application_server_service_handle，OCI_HTYPE_SVCCTX，（void *）data_server_handle，（ub4）0，OCI_ATTR_SERVER，error_handle）; / * **验证应用程序服务器。在这种情况下，使用外部认证。* /（void）OCIHandleAlloc（（void *）environment_handle，（void **）＆application_server_session_handle，（ub4）OCI_HTYPE_SESSION，（size_t）0，（void **）0）; checkerr（error_handle，OCISessionBegin（application_server_service_handle，error_handle，application_server_session_handle，OCI_CRED_EXT，OCI_DEFAULT））; / * **验证第一个客户端。**请注意，**应用程序服务器没有为客户端指定密码，因为它是受信任的。* /（void）OCIHandleAlloc（（void *）environment_handle，（void **）＆first_client_session_handle，（ub4）OCI_HTYPE_SESSION，（size_t）0，（void **）0）; （void）OCIAttrSet（（void *）first_client_session_handle，（ub4）OCI_HTYPE_SESSION，（void *）“jeff”，（ub4）strlen（“jeff”），OCI_ATTR_USERNAME，error_handle）; / * **代替指定密码，改为传递应用程序**服务器的会话句柄。* /（void）OCIAttrSet（（void *）first_client_session_handle，（ub4）OCI_HTYPE_SESSION，（void *）application_server_session_handle，（ub4）0，OCI_ATTR_PROXY_CREDENTIALS，error_handle）; （void）OCIAttrSet（（void *）first_client_session_handle，（ub4）OCI_HTYPE_SESSION，（void *）“jeff@VeryBigBank.com”，（ub4）strlen（“jeff@VeryBigBank.com”），OCI_ATTR_EXTERNAL_NAME，error_handle）; / * **建立应用程序服务器可用作客户端的角色。* / client_roles [0] =（OraText *）“TELLER”; client_roles [1] =（OraText *）“SUPERVISOR”; （void）OCIAttrSet（（void *）first_client_session_handle，OCI_ATTR_INITIAL_CLIENT_ROLES，error_handle）; checkerr（error_handle，OCISessionBegin（application_server_service_handle，error_handle，first_client_session_handle，OCI_CRED_PROXY，OCI_DEFAULT））; / * **要将会话作为另一个客户端启动，应用程序服务器执行以下**。**此代码与当前的会话切换方式相同。* /（void）OCIHandleAlloc（（void *）environment_handle，（void **）＆second_client_session_handle，（ub4）OCI_HTYPE_SESSION，（size_t）0，（void **）0）; （void）OCIAttrSet（（void *）second_client_session_handle，（ub4）OCI_HTYPE_SESSION，（void *）“mutt”，（ub4）strlen（“mutt”），OCI_ATTR_USERNAME，error_handle）; （void）OCIAttrSet（（void *）second_client_session_handle，（ub4）OCI_HTYPE_SESSION，（void *）application_server_session_handle，（ub4）0，OCI_ATTR_PROXY_CREDENTIALS，error_handle）; （void）OCIAttrSet（（void *）second_client_session_handle，（ub4）OCI_HTYPE_SESSION，（void *）“mutt@VeryBigBank.com”，（ub4）strlen（“mutt@VeryBigBank.com”），OCI_ATTR_EXTERNAL_NAME，error_handle）; / * **请注意，应用程序服务器尚未指定任何初始角色将**作为第二个客户端。* / checkerr（error_handle，OCISessionBegin（application_server_service_handle，error_handle，second_client_session_handle，OCI_CRED_PROXY，OCI_DEFAULT））; / * **要切换到第一个用户，应用程序服务器应用第一个** OCISessionBegin（）调用获得的会话**句柄。这与目前的情况相同。* /（void）OCIAttrSet（（void *）application_server_service_handle，（ub4）OCI_HTYPE_SVCCTX，（void *）first_client_session_handle，（ub4）0，（ub4）OCI_ATTR_SESSION，error_handle）; / * **执行某些操作后，应用程序服务器可以切换到**第二个客户端。该**由以下调用完成：* /（void）OCIAttrSet（（void *）application_server_service_handle，（ub4）OCI_HTYPE_SVCCTX，（void *）second_client_session_handle，（ub4）0，（ub4）OCI_ATTR_SESSION，error_handle）; / * **然后做那个客户的操作* / ...
</pre></div>
                        <!-- class="example" -->
                        <div class="section">
                           <div class="infoboxnotealso" id="GUID-BAD07740-13A4-4760-A794-8552A040E70A__GUID-FC3804B2-7F22-4D48-80C1-01B02A7204D8">
                              <p class="notep1">也可以看看：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p><a href="handle-and-descriptor-attributes.html#GUID-FB263210-118E-4DB3-A840-1769EF0CB977" title="列出并描述用户会话句柄属性。">用户会话句柄属性</a></p>
                                 </li>
                                 <li>
                                    <p><a href="handle-and-descriptor-functions.html#GUID-3741D7BD-7652-4D7A-8813-AC2AEA8D3B03" title="设置句柄或描述符的属性值。">OCIAttrSet（）</a></p>
                                 </li>
                              </ul>
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div>
            </div><a id="LNOCI840"></a><div class="props_rev_3"><a id="GUID-301306B2-A746-484D-BA6B-6A029B54FE75" name="GUID-301306B2-A746-484D-BA6B-6A029B54FE75"></a><h3 id="LNOCI-GUID-301306B2-A746-484D-BA6B-6A029B54FE75" class="sect3"><span class="enumeration_section">10.5</span> OCI中的外部初始化上下文</h3>
               <div>
                  <p>外部初始化的上下文是可以从OCI初始化属性的应用程序上下文。使用SQL语句<code class="codeph">CREATE</code> <code class="codeph">CONTEXT</code>在服务器中使用选项<code class="codeph">INITIALIZED</code> <code class="codeph">EXTERNALLY</code>创建上下文命名空间。</p>
                  <p>然后，您可以在使用<code class="codeph">OCIAttrSet()</code>和<code class="codeph">OCISessionBegin()</code>建立会话时初始化OCI接口。仅使用<code class="codeph">CREATE</code> <code class="codeph">CONTEXT</code>语句中指定的PL / SQL包发出后续命令以写入命名空间内的任何属性。
                  </p>
                  <p>您可以通过<code class="codeph">OCISessionBegin()</code>调用设置默认值和其他会话属性，从而减少服务器往返次数。
                  </p>
                  <div class="p">本节包括以下主题：<ul style="list-style-type:disc">
                        <li>
                           <p><a href="managing-scalable-platforms.html#GUID-301306B2-A746-484D-BA6B-6A029B54FE75" title="外部初始化的上下文是可以从OCI初始化属性的应用程序上下文。使用SQL语句CREATE CONTEXT在服务器中使用选项INITIALIZED EXTERNALLY创建上下文命名空间。">OCI中的外部初始化上下文</a></p>
                        </li>
                        <li>
                           <p><a href="managing-scalable-platforms.html#GUID-477E1BD7-E650-4E9C-B5C7-F9FACBCF2494" title="使用以下属性来测量服务器调用时间，不包括服务器往返。">端到端应用程序跟踪</a></p>
                        </li>
                        <li>
                           <p><a href="managing-scalable-platforms.html#GUID-1BB0936C-DF43-45E2-94C9-29FA597F28C8" title="当您调用OCISessionBegin（）时，会话句柄中设置的上下文将被推送到服务器。">使用带有外部初始化上下文的OCISessionBegin（）</a></p>
                        </li>
                     </ul>
                  </div>
                  <div class="infoboxnotealso" id="GUID-301306B2-A746-484D-BA6B-6A029B54FE75__GUID-72A2AAB7-39B8-441A-B6FD-BAC51DC0B0DE">
                     <p class="notep1">也可以看看：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="../dbseg/managing-security-for-application-developers.html#DBSEG005" target="_blank"><span><cite>Oracle数据库安全指南</cite></span></a>有关管理应用程序开发人员安全性的章节</p>
                        </li>
                        <li>
                           <p><a href="../sqlrf/CREATE-CONTEXT.html#SQLRF01202" target="_blank"><span><cite>Oracle数据库SQL语言参考</cite></span></a> <code class="codeph">CREATE</code> <code class="codeph">CONTEXT</code>语句和<code class="codeph">SYS_CONTEXT</code>函数</p>
                        </li>
                        <li>
                           <p><a href="handle-and-descriptor-functions.html#GUID-3741D7BD-7652-4D7A-8813-AC2AEA8D3B03" title="设置句柄或描述符的属性值。">OCIAttrSet（）</a></p>
                        </li>
                        <li>
                           <p><a href="connect-authorize-and-initialize-functions.html#GUID-31B1FDB3-056E-4AF9-9B89-8DA6AA156947" title="创建用户会话并开始给定服务器的用户会话。">OCISessionBegin（）</a></p>
                        </li>
                     </ul>
                  </div>
               </div><a id="LNOCI16573"></a><div class="props_rev_3"><a id="GUID-6BE7672C-39B7-4929-939B-07726F15F6B5" name="GUID-6BE7672C-39B7-4929-939B-07726F15F6B5"></a><h4 id="LNOCI-GUID-6BE7672C-39B7-4929-939B-07726F15F6B5" class="sect4"><span class="enumeration_section">10.5.1</span> OCI中的外部初始化上下文属性</h4>
                  <div>
                     <p>您开发的客户端应用程序可以在身份验证之前在会话句柄中显式设置应用程序上下文。</p>
                     <div class="p">为此，请在OCI函数中使用以下属性：<ul style="list-style-type:disc">
                           <li>
                              <p><a href="managing-scalable-platforms.html#GUID-953B21F5-4C1A-4B09-AB57-A37D2754C82F" title="使用OCI_ATTR_APPCTX_SIZE属性在OCIAttrSet（）调用中使用所需数量的上下文属性初始化上下文数组大小。">OCI_ATTR_APPCTX_SIZE</a></p>
                           </li>
                           <li>
                              <p><a href="managing-scalable-platforms.html#GUID-1AF00FA2-D9B4-42CC-8DF2-37F04F98F635" title="使用OCI_ATTR_APPCTX_LIST属性获取OCIAttrGet（）调用中会话的应用程序上下文列表描述符的句柄。">OCI_ATTR_APPCTX_LIST</a></p>
                           </li>
                           <li>
                              <p><a href="managing-scalable-platforms.html#GUID-921FC680-5D91-438E-9FD4-ED0F23395C19" title="演示如何为应用程序上下文设置适当的会话句柄属性值。">用于设置外部初始化上下文的会话句柄属性</a></p>
                           </li>
                        </ul>
                     </div>
                  </div><a id="LNOCI72648"></a><a id="LNOCI16574"></a><div class="props_rev_3"><a id="GUID-953B21F5-4C1A-4B09-AB57-A37D2754C82F" name="GUID-953B21F5-4C1A-4B09-AB57-A37D2754C82F"></a><h5 id="LNOCI-GUID-953B21F5-4C1A-4B09-AB57-A37D2754C82F" class="sect5"><span class="enumeration_section">10.5.1.1</span> OCI_ATTR_APPCTX_SIZE</h5>
                     <div>
                        <p>使用<code class="codeph">OCI_ATTR_APPCTX_SIZE</code>属性在<code class="codeph">OCIAttrSet()</code>调用中使用所需数量的上下文属性初始化上下文数组大小。
                        </p>
                        <p>这在<a href="managing-scalable-platforms.html#GUID-953B21F5-4C1A-4B09-AB57-A37D2754C82F__BGBFJCBI">例10-9中显示</a> 。
                        </p>
                        <div class="example" id="GUID-953B21F5-4C1A-4B09-AB57-A37D2754C82F__BGBFJCBI">
                           <p class="titleinexample">示例10-9定义OCI_ATTR_APPCTX_SIZE属性以使用所需的上下文属性数初始化上下文数组大小</p><pre class="oac_no_warn" dir="ltr">OCIAttrSet（session，（ub4）OCI_HTYPE_SESSION，（void *）＆size，（ub4）0，OCI_ATTR_APPCTX_SIZE，error_handle）;</pre></div>
                        <!-- class="example" -->
                        <div class="section">
                           <div class="infoboxnotealso" id="GUID-953B21F5-4C1A-4B09-AB57-A37D2754C82F__GUID-59B536DD-B66E-4A60-8A3C-6BB8B08EB927">
                              <p class="notep1">也可以看看：</p>
                              <p><a href="handle-and-descriptor-functions.html#GUID-3741D7BD-7652-4D7A-8813-AC2AEA8D3B03" title="设置句柄或描述符的属性值。">OCIAttrSet（）</a></p>
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNOCI72649"></a><a id="LNOCI72650"></a><a id="LNOCI16575"></a><div class="props_rev_3"><a id="GUID-1AF00FA2-D9B4-42CC-8DF2-37F04F98F635" name="GUID-1AF00FA2-D9B4-42CC-8DF2-37F04F98F635"></a><h5 id="LNOCI-GUID-1AF00FA2-D9B4-42CC-8DF2-37F04F98F635" class="sect5"><span class="enumeration_section">10.5.1.2</span> OCI_ATTR_APPCTX_LIST</h5>
                     <div>
                        <p>使用<code class="codeph">OCI_ATTR_APPCTX_LIST</code>属性获取<code class="codeph">OCIAttrGet()</code>调用中会话的应用程序上下文列表描述符的<code class="codeph">OCIAttrGet()</code> 。
                        </p>
                        <p>这在<a href="managing-scalable-platforms.html#GUID-1AF00FA2-D9B4-42CC-8DF2-37F04F98F635__BGBFBIAI">例10-10中</a>示出。（参数<code class="codeph">ctxl_desc</code>必须是数据类型<code class="codeph">OCIParam *</code> ）。
                        </p>
                        <p><a href="managing-scalable-platforms.html#GUID-1AF00FA2-D9B4-42CC-8DF2-37F04F98F635__BGBHJGAG">示例10-11</a>显示了如何使用应用程序上下文列表描述符在调用<code class="codeph">OCIParamGet()</code>获取第i个应用程序上下文的单独描述符。
                        </p>
                        <div class="example" id="GUID-1AF00FA2-D9B4-42CC-8DF2-37F04F98F635__BGBFBIAI">
                           <p class="titleinexample">示例10-10使用OCI_ATTR_APPCTX_LIST属性获取会话的应用程序上下文列表描述符的句柄</p><pre class="oac_no_warn" dir="ltr">OCIAttrGet（session，（ub4）OCI_HTYPE_SESSION，（void *）＆ctxl_desc，（ub4）0，OCI_ATTR_APPCTX_LIST，error_handle）;</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-1AF00FA2-D9B4-42CC-8DF2-37F04F98F635__BGBHJGAG">
                           <p class="titleinexample">示例10-11调用OCIParamGet（）以使用应用程序上下文列表描述符获取第i个应用程序上下文的单个描述符</p><pre class="oac_no_warn" dir="ltr">OCIParamGet（ctxl_desc，OCI_DTYPE_PARAM，error_handle，（void **）＆ctx_desc，i）;</pre></div>
                        <!-- class="example" -->
                        <div class="section">
                           <div class="infoboxnotealso" id="GUID-1AF00FA2-D9B4-42CC-8DF2-37F04F98F635__GUID-E6CA5353-52FE-4777-98E2-D5ECC55B40D4">
                              <p class="notep1">也可以看看：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p><a href="handle-and-descriptor-functions.html#GUID-FA199A99-4D7A-42C2-BB0A-C20047B95DF9" title="获取句柄属性的值。">OCIAttrGet（）</a></p>
                                 </li>
                                 <li>
                                    <p><a href="handle-and-descriptor-functions.html#GUID-35D2FF91-139B-4A5C-97C8-8BC29866CCA4" title="返回由describe句柄或语句句柄中的position指定的参数的描述符。">OCIParamGet（）</a></p>
                                 </li>
                              </ul>
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNOCI72651"></a><a id="LNOCI16576"></a><div class="props_rev_3"><a id="GUID-921FC680-5D91-438E-9FD4-ED0F23395C19" name="GUID-921FC680-5D91-438E-9FD4-ED0F23395C19"></a><h5 id="LNOCI-GUID-921FC680-5D91-438E-9FD4-ED0F23395C19" class="sect5"><span class="enumeration_section">10.5.1.3</span>用于设置外部初始化上下文的会话句柄属性</h5>
                     <div>
                        <p>演示如何为应用程序上下文设置适当的会话句柄属性值。</p>
                        <p>使用以下属性设置应用程序上下文的适当值：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">OCI_ATTR_APPCTX_NAME</code>设置上下文的名称空间，该名称空间必须是有效的SQL标识符。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">OCI_ATTR_APPCTX_ATTR</code>用于在给定上下文中设置属性名称，这是一个不区分大小写的字符串，最多30个字节。
                              </p>
                           </li>
                           <li>
                              <p> <code class="codeph">OCI_ATTR_APPCTX_VALUE</code>用于设置给定上下文中属性的值。
                              </p>
                           </li>
                        </ul>
                        <p>每个名称空间可以有许多属性，每个属性都有一个值。<a href="managing-scalable-platforms.html#GUID-921FC680-5D91-438E-9FD4-ED0F23395C19__BGBHCHGH">例10-12</a>显示了可用于设置它们的调用。
                        </p>
                        <p>请注意，仅支持字符类型，因为应用程序上下文操作基于<code class="codeph">VARCHAR2</code>数据类型。
                        </p>
                        <div class="example" id="GUID-921FC680-5D91-438E-9FD4-ED0F23395C19__BGBHCHGH">
                           <p class="titleinexample">示例10-12定义会话句柄属性以设置外部初始化的上下文</p><pre class="oac_no_warn" dir="ltr">OCIAttrSet（ctx_desc，OCI_DTYPE_PARAM，（void *）ctx_name，sizeof（ctx_name），OCI_ATTR_APPCTX_NAME，error_handle）; OCIAttrSet（ctx_desc，OCI_DTYPE_PARAM，（void *）attr_name，sizeof（attr_name），OCI_ATTR_APPCTX_ATTR，error_handle）; OCIAttrSet（ctx_desc，OCI_DTYPE_PARAM，（void *）value，sizeof（value），OCI_ATTR_APPCTX_VALUE，error_handle）;</pre></div>
                        <!-- class="example" -->
                        <div class="section">
                           <div class="infoboxnotealso" id="GUID-921FC680-5D91-438E-9FD4-ED0F23395C19__GUID-63ED9BD7-2FD6-48AB-A102-36B0D9B79D5D">
                              <p class="notep1">也可以看看：</p>
                              <p><a href="handle-and-descriptor-attributes.html#GUID-FB263210-118E-4DB3-A840-1769EF0CB977" title="列出并描述用户会话句柄属性。">用户会话句柄属性</a></p>
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="LNOCI16569"></a><div class="props_rev_3"><a id="GUID-477E1BD7-E650-4E9C-B5C7-F9FACBCF2494" name="GUID-477E1BD7-E650-4E9C-B5C7-F9FACBCF2494"></a><h4 id="LNOCI-GUID-477E1BD7-E650-4E9C-B5C7-F9FACBCF2494" class="sect4"><span class="enumeration_section">10.5.2</span>端到端应用程序跟踪</h4>
                  <div>
                     <p>使用以下属性来测量服务器调用时间，不包括服务器往返。</p>
                     <p>也可以使用PL / SQL程序包<code class="codeph">DBMS_APPLICATION_INFO</code>来设置这些属性，这会导致一次往返服务器。使用OCI设置属性不会产生往返。
                     </p>
                     <div class="p">本节包括以下主题：<ul style="list-style-type:disc">
                           <li>
                              <p><a href="managing-scalable-platforms.html#GUID-3DAC717B-3F1D-4881-9328-E8D19BA86EFD" title="使用属性OCI_ATTR_COLLECT_CALL_TIME并将值设置为TRUE以使服务器能够测量每个呼叫时间。">OCI_ATTR_COLLECT_CALL_TIME</a></p>
                           </li>
                           <li>
                              <p><a href="managing-scalable-platforms.html#GUID-0EE33BBC-E0CF-4820-951B-CBD20614012B" title="使用属性OCI_ATTR_CALL_TIME获取上次服务器调用的已用时间。">OCI_ATTR_CALL_TIME</a></p>
                           </li>
                           <li>
                              <p><a href="managing-scalable-platforms.html#GUID-624A4771-58C5-4E2B-8131-E3389F58A0D6" title="使用这些属性可以监视，跟踪和调试应用程序。">端到端应用程序跟踪的属性</a></p>
                           </li>
                        </ul>
                     </div>
                  </div><a id="LNOCI16570"></a><div class="props_rev_3"><a id="GUID-3DAC717B-3F1D-4881-9328-E8D19BA86EFD" name="GUID-3DAC717B-3F1D-4881-9328-E8D19BA86EFD"></a><h5 id="LNOCI-GUID-3DAC717B-3F1D-4881-9328-E8D19BA86EFD" class="sect5"><span class="enumeration_section">10.5.2.1</span> OCI_ATTR_COLLECT_CALL_TIME</h5>
                     <div>
                        <p>使用属性<code class="codeph">OCI_ATTR_COLLECT_CALL_TIME</code>并将值设置为<code class="codeph">TRUE</code>以使服务器能够测量每个呼叫时间。
                        </p>
                        <p>将<code class="codeph">boolean</code>变量设置为<code class="codeph">TRUE</code>或<code class="codeph">FALSE</code> 。通过调用<code class="codeph">OCIAttrSet()</code>设置<code class="codeph">OCI_ATTR_COLLECT_CALL_TIME</code>属性后，服务器会测量每个调用时间。测量将变量设置为<code class="codeph">TRUE</code>并将其设置为<code class="codeph">FALSE</code>之间的所有服务器时间。
                        </p>
                        <div class="infoboxnotealso" id="GUID-3DAC717B-3F1D-4881-9328-E8D19BA86EFD__GUID-A31FA396-6EFC-4D0F-88D8-5D89F8CE0CDE">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="handle-and-descriptor-functions.html#GUID-3741D7BD-7652-4D7A-8813-AC2AEA8D3B03" title="设置句柄或描述符的属性值。">OCIAttrSet（）</a></p>
                        </div>
                     </div>
                  </div><a id="LNOCI72652"></a><a id="LNOCI16571"></a><div class="props_rev_3"><a id="GUID-0EE33BBC-E0CF-4820-951B-CBD20614012B" name="GUID-0EE33BBC-E0CF-4820-951B-CBD20614012B"></a><h5 id="LNOCI-GUID-0EE33BBC-E0CF-4820-951B-CBD20614012B" class="sect5"><span class="enumeration_section">10.5.2.2</span> OCI_ATTR_CALL_TIME</h5>
                     <div>
                        <p>使用属性<code class="codeph">OCI_ATTR_CALL_TIME</code>获取上次服务器调用的已用时间。
                        </p>
                        <p>所用的时间，以微秒，最后服务器调用的返回在<code class="codeph">ub8</code>通过调用变量<code class="codeph">OCIAttrGet()</code>与<code class="codeph">OCI_ATTR_CALL_TIME</code>属性。<a href="managing-scalable-platforms.html#GUID-0EE33BBC-E0CF-4820-951B-CBD20614012B__BGBDBFIE">例10-13</a>显示了如何在代码片段中执行此操作。
                        </p>
                        <div class="example" id="GUID-0EE33BBC-E0CF-4820-951B-CBD20614012B__BGBDBFIE">
                           <p class="titleinexample">示例10-13使用OCI_ATTR_CALL_TIME属性获取上次服务器调用的经过时间</p><pre class="oac_no_warn" dir="ltr">boolean enable_call_time; ub8 call_time; ...enable_call_time = TRUE; OCIAttrSet（session，OCI_HTYPE_SESSION，（void *）＆enable_call_time，（ub4）0，OCI_ATTR_COLLECT_CALL_TIME，（OCIError *）error_handle）; OCIStmtExecute（...）; OCIAttrGet（session，OCI_HTYPE_SESSION，（void *）＆call_time，（ub4）0，OCI_ATTR_CALL_TIME，（OCIError *）error_handle）; ...
</pre></div>
                        <!-- class="example" -->
                        <div class="section">
                           <div class="infoboxnotealso" id="GUID-0EE33BBC-E0CF-4820-951B-CBD20614012B__GUID-73FC1D0F-7635-48A7-A937-FFEF500B4AC7">
                              <p class="notep1">也可以看看：</p>
                              <p><a href="handle-and-descriptor-functions.html#GUID-FA199A99-4D7A-42C2-BB0A-C20047B95DF9" title="获取句柄属性的值。">OCIAttrGet（）</a></p>
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNOCI16572"></a><div class="props_rev_3"><a id="GUID-624A4771-58C5-4E2B-8131-E3389F58A0D6" name="GUID-624A4771-58C5-4E2B-8131-E3389F58A0D6"></a><h5 id="LNOCI-GUID-624A4771-58C5-4E2B-8131-E3389F58A0D6" class="sect5"><span class="enumeration_section">10.5.2.3</span>端到端应用程序跟踪的属性</h5>
                     <div>
                        <p>使用这些属性可以监视，跟踪和调试应用程序。</p>
                        <p>为监视，跟踪和调试应用程序设置这些属性：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">OCI_ATTR_MODULE</code> - 客户端应用程序中当前模块的名称。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">OCI_ATTR_ACTION</code> - 当前模块中当前操作的名称。如果您不想指定操作，请设置为<code class="codeph">NULL</code> 。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">OCI_ATTR_DBOP</code> - 要在数据库中监视的客户端应用程序设置的数据库操作的名称。如果要结束监视当前正在运行的数据库操作，请设置为<code class="codeph">NULL</code> 。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">OCI_ATTR_CLIENT_INFO</code> - 客户端应用程序的附加信息。
                              </p>
                              <div class="infoboxnotealso" id="GUID-624A4771-58C5-4E2B-8131-E3389F58A0D6__GUID-A2E783EF-47A5-4CE9-A542-EF7C49167A8B">
                                 <p class="notep1">也可以看看：</p>
                                 <p><a href="handle-and-descriptor-attributes.html#GUID-FB263210-118E-4DB3-A840-1769EF0CB977" title="列出并描述用户会话句柄属性。">用户会话句柄属性</a></p>
                                 <p>在<span><cite>Oracle数据库SQL调优指南中</cite></span> <a href="../tgsql/monitoring-database-operations.html#TGSQL-GUID-C941CE9D-97E1-42F8-91ED-4949B2B710BF" target="_blank">监视数据库操作</a></p>
                                 <p>在<span><cite>Oracle数据库2天+性能调整指南中</cite></span> <a href="../tdppt/monitoring-real-time-database-performance.html#TDPPT-GUID-EB19F9B4-A912-4354-8D8D-F89EEFD56704" target="_blank">监控实时数据库性能</a></p>
                              </div>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="LNOCI72653"></a><a id="LNOCI16577"></a><div class="props_rev_3"><a id="GUID-1BB0936C-DF43-45E2-94C9-29FA597F28C8" name="GUID-1BB0936C-DF43-45E2-94C9-29FA597F28C8"></a><h4 id="LNOCI-GUID-1BB0936C-DF43-45E2-94C9-29FA597F28C8" class="sect4"><span class="enumeration_section">10.5.3</span>将OCISessionBegin（）与外部初始化上下文一起使用</h4>
                  <div>
                     <p>当您调用<code class="codeph">OCISessionBegin()</code> ，会话句柄中设置的上下文将被推送到服务器。
                     </p>
                     <div class="section">
                        <p>没有其他上下文传播到服务器会话。<a href="managing-scalable-platforms.html#GUID-1BB0936C-DF43-45E2-94C9-29FA597F28C8__BGBCCBGF">例10-14</a>说明了这些调用和属性的使用。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-1BB0936C-DF43-45E2-94C9-29FA597F28C8__BGBCCBGF">
                        <p class="titleinexample">示例10-14将OCISessionBegin（）与外部初始化上下文一起使用</p><pre class="oac_no_warn" dir="ltr">#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;oci.h&gt; static OraText * username =（OraText *）“HR”; static OraText * password =（OraText *）“HR”; static OCIEnv * envhp; static OCIError * errhp; int main（/ * _ int argc，char * argv [] _ * /）;静态剑状态; int main（argc，argv）int argc; char * argv []; {OCISession * authp =（OCISession *）0; OCIServer * srvhp; OCISvcCtx * svchp; OCIDefine * defnp =（OCIDefine *）0; void * parmdp; ub4 ctxsize; OCIParam * ctxldesc; OCIParam * ctxedesc; OCIEnvCreate（＆envhp，OCI_DEFAULT，（void *）0,0,0,0，（size_t）0，（void *）0）; （void）OCIHandleAlloc（（void *）envhp，（void **）＆errhp，OCI_HTYPE_ERROR，（size_t）0，（void **）0）; / * server contexts * /（void）OCIHandleAlloc（（void *）envhp，（void **）＆srvhp，OCI_HTYPE_SERVER，（size_t）0，（void **）0）; （void）OCIHandleAlloc（（void *）envhp，（void **）＆svchp，OCI_HTYPE_SVCCTX，（size_t）0，（void **）0）; （void）OCIServerAttach（srvhp，errhp，（OraText *）“”，strlen（“”），0）; / *在服务上下文中设置属性服务器上下文* /（void）OCIAttrSet（（void *）svchp，OCI_HTYPE_SVCCTX，（void *）srvhp，（ub4）0，OCI_ATTR_SERVER，（OCIError *）errhp）; （void）OCIHandleAlloc（（void *）envhp，（void **）＆authp，（ub4）OCI_HTYPE_SESSION，（size_t）0，（void **）0）; / **************************************** / / *将app ctx大小设置为2因为你想设置2个应用程序上下文* / ctxsize = 2; / *设置app ctx buffer * /（void）OCIAttrSet（（void *）authp，（ub4）OCI_HTYPE_SESSION，（void *）＆ctxsize，（ub4）0，（ub4）OCI_ATTR_APPCTX_SIZE，errhp）; / *检索列表描述符* /（void）OCIAttrGet（（void *）authp，（ub4）OCI_HTYPE_SESSION，（void *）＆ctxldesc，0，OCI_ATTR_APPCTX_LIST，errhp）; / *检索第一个ctx元素描述符* /（void）OCIParamGet（ctxldesc，OCI_DTYPE_PARAM，errhp，（void **）＆ctxedesc，1）; （void）OCIAttrSet（（void *）ctxedesc，（ub4）OCI_DTYPE_PARAM，（void *）“HR”，（ub4）strlen（（char *）“HR”），（ub4）OCI_ATTR_APPCTX_NAME，errhp）; （void）OCIAttrSet（（void *）ctxedesc，（ub4）OCI_DTYPE_PARAM，（void *）“ATTR1”，（ub4）strlen（（char *）“ATTR1”），（ub4）OCI_ATTR_APPCTX_ATTR，errhp）; （void）OCIAttrSet（（void *）ctxedesc，（ub4）OCI_DTYPE_PARAM，（void *）“VALUE1”，（ub4）strlen（（char *）“VALUE1”），（ub4）OCI_ATTR_APPCTX_VALUE，errhp）; / *设置第二个上下文* /（void）OCIParamGet（ctxldesc，OCI_DTYPE_PARAM，errhp，（void **）＆ctxedesc，2）; （void）OCIAttrSet（（void *）ctxedesc，（ub4）OCI_DTYPE_PARAM，（void *）“HR”，（ub4）strlen（（char *）“HR”），（ub4）OCI_ATTR_APPCTX_NAME，errhp）; （void）OCIAttrSet（（void *）ctxedesc，（ub4）OCI_DTYPE_PARAM，（void *）“ATTR2”，（ub4）strlen（（char *）“ATTR2”），（ub4）OCI_ATTR_APPCTX_ATTR，errhp）; （void）OCIAttrSet（（void *）ctxedesc，（ub4）OCI_DTYPE_PARAM，（void *）“VALUE2”，（ub4）strlen（（char *）“VALUE2”），（ub4）OCI_ATTR_APPCTX_VALUE，errhp）; / **************************************** /（无效）OCIAttrSet（（*） ）authp，（ub4）OCI_HTYPE_SESSION，（void *）username，（ub4）strlen（（char *）username），（ub4）OCI_ATTR_USERNAME，errhp）; （void）OCIAttrSet（（void *）authp，（ub4）OCI_HTYPE_SESSION，（void *）password，（ub4）strlen（（char *）password），（ub4）OCI_ATTR_PASSWORD，errhp）; OCISessionBegin（svchp，errhp，authp，OCI_CRED_EXT，（ub4）OCI_DEFAULT）; }</pre></div>
                     <!-- class="example" -->
                     <div class="section">
                        <div class="infoboxnotealso" id="GUID-1BB0936C-DF43-45E2-94C9-29FA597F28C8__GUID-38A86E13-32CB-4928-A4E8-FD1EAD7BCC24">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="connect-authorize-and-initialize-functions.html#GUID-31B1FDB3-056E-4AF9-9B89-8DA6AA156947" title="创建用户会话并开始给定服务器的用户会话。">OCISessionBegin（）</a></p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="LNOCI3605"></a><div class="props_rev_3"><a id="GUID-01D8848B-FF4C-4332-B0AA-C4CDF064A65D" name="GUID-01D8848B-FF4C-4332-B0AA-C4CDF064A65D"></a><h3 id="LNOCI-GUID-01D8848B-FF4C-4332-B0AA-C4CDF064A65D" class="sect3"><span class="enumeration_section">10.6</span>客户端应用程序上下文</h3>
               <div>
                  <p>应用程序上下文使数据库客户端（例如中间层应用程序）能够设置任意会话数据并将其发送到服务器，每个执行的语句只需一次往返。</p>
                  <p>服务器在语句执行之前将此数据存储在会话上下文中，从中可以使用它来限制查询或DML操作。所有数据库功能（如视图，触发器，虚拟专用数据库（VPD）策略或PL / SQL存储过程）都可以使用会话数据来约束其操作。</p>
                  <p>创建公共可写命名空间<code class="codeph">nm</code> ：</p><pre class="oac_no_warn" dir="ltr">使用hr.package1创建上下文nm;</pre><p>要修改在该命名空间中分组的数据，用户必须执行指定的PL / SQL包<code class="codeph">hr.package1</code> 。但是，在用户会话中查询此信息不需要任何权限。
                  </p>
                  <p>存储在用户会话中的可变长度应用程序上下文数据采用在上下文命名空间下分组的属性和值对的形式。</p>
                  <p>例如，如果您希望人力资源应用程序在用户会话中存储最终用户的责任信息，那么它可以创建一个<code class="codeph">nm</code>命名空间和一个名为“责任”的属性，可以为其分配一个值，例如“manager”或“会计”。这在本文档中称为<span class="italic">设置操作</span> 。
                  </p>
                  <p>如果希望应用程序清除<code class="codeph">nm</code>命名空间中“责任”属性的值，则可以将其设置为<code class="codeph">NULL</code>或空字符串。这在本文档中称为<span class="italic">清除操作</span> 。
                  </p>
                  <p>要清除<code class="codeph">nm</code>命名空间中的所有信息，应用程序可以将命名空间信息作为clear-all操作的一部分发送到服务器。这在本文档中称为名称空间中的<span class="italic">clear-all操作</span> 。
                  </p>
                  <p>如果没有为命名空间定义包安全性，则该命名空间被视为客户端命名空间，并且任何OCI客户端都可以将该命名空间的数据传输到服务器。没有进行权限或包安全检查。</p>
                  <p>应用程序上下文数据的网络传输在服务器的单个往返中完成。</p>
                  <div class="p">本节包括以下主题：<ul style="list-style-type:disc">
                        <li>
                           <p><a href="managing-scalable-platforms.html#GUID-80DDC2E5-11B8-4154-90B9-1C3DDEEB22D7" title="使用OCIAppCtxSet（）函数对其执行一系列设置操作" responsibilit="=" ="">使用多个SET操作</a></p>
                        </li>
                        <li>
                           <p><a href="managing-scalable-platforms.html#GUID-6D968D96-DEFD-40CB-BE01-46B8F9076B68" title="您可以使用OCIAppCtxClearAll（）函数清除特定客户端命名空间中的所有上下文信息，并且在下一次网络传输期间也将在服务器端用户会话中清除它。">在SET操作之间使用CLEAR-ALL操作</a></p>
                        </li>
                        <li>
                           <p><a href="managing-scalable-platforms.html#GUID-A85FF5D3-77C5-4F26-A37C-8EB0E88A2BD4" title="应用程序可能会将OCIStmtExecute（）调用的应用程序上下文信息发送到服务器，并且还可以通过执行DBMS_SESSION程序包尝试在该调用期间更改相同的上下文信息。">客户端命名空间上的网络传输和PL / SQL</a></p>
                        </li>
                     </ul>
                  </div>
               </div><a id="LNOCI72654"></a><a id="LNOCI72655"></a><a id="LNOCI16578"></a><div class="props_rev_3"><a id="GUID-80DDC2E5-11B8-4154-90B9-1C3DDEEB22D7" name="GUID-80DDC2E5-11B8-4154-90B9-1C3DDEEB22D7"></a><h4 id="LNOCI-GUID-80DDC2E5-11B8-4154-90B9-1C3DDEEB22D7" class="sect4"><span class="enumeration_section">10.6.1</span>使用多个SET操作</h4>
                  <div>
                     <p>使用<code class="codeph">OCIAppCtxSet()</code>函数对<code class="codeph">CLIENTCONTEXT</code>命名空间中的“责任”属性执行一系列设置操作。
                     </p>
                     <div class="section">
                        <p>将此信息发送到服务器时，命名空间中该特定属性的最新值占优势。要将<code class="codeph">CLIENTCONTEXT</code>命名空间中“responsibility”属性的值从“manager”更改为“vp”，请使用客户端上的<a href="managing-scalable-platforms.html#GUID-80DDC2E5-11B8-4154-90B9-1C3DDEEB22D7__BGBCEJGD">示例10-15中</a>所示的代码片段。当此信息传输到服务器时，服务器会在<code class="codeph">CLIENTCONTEXT</code>命名空间中显示“责任”属性的最新值“vp”。
                        </p>
                        <p>您可以清除客户端命名空间中的特定属性信息。这可以通过将属性的值设置为<code class="codeph">NULL</code>或空字符串来完成，如<a href="managing-scalable-platforms.html#GUID-80DDC2E5-11B8-4154-90B9-1C3DDEEB22D7__BGBCHDHB">示例10-16中</a>所示，使用<code class="codeph">OCIAppCtxSet()</code>函数。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-80DDC2E5-11B8-4154-90B9-1C3DDEEB22D7__BGBCEJGD">
                        <p class="titleinexample">示例10-15更改CLIENTCONTEXT命名空间中的“责任”属性值</p><pre class="oac_no_warn" dir="ltr">err = OCIAppCtxSet（（void *）sesshndl，（void *）“CLIENTCONTEXT”，（ub4）13，（void *）“责任”，14（void *）“manager”，7，errhp，OCI_DEFAULT）; err = OCIAppCtxSet（（void *）sesshndl，（void *）“CLIENTCONTEXT”，13，（void *）“责任”，14，（void *）“vp”，2，errhp，OCI_DEFAULT）;</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-80DDC2E5-11B8-4154-90B9-1C3DDEEB22D7__BGBCHDHB">
                        <p class="titleinexample">示例10-16清除客户端命名空间中的特定属性信息的两种方法</p><pre class="oac_no_warn" dir="ltr">（void）OCIAppCtxSet（（void *）sesshndl，（void *）“CLIENTCONTEXT”，13，（void *）“responsibility”，14，（void *）0,0，errhp，OCI_DEFAULT）; （void）OCIAppCtxSet（（void *）sesshndl，（void *）“CLIENTCONTEXT”，13（void *）“responsibility”，14，（void *）“”，0，errhp，OCI_DEFAULT）;</pre></div>
                     <!-- class="example" -->
                     <div class="section">
                        <div class="infoboxnotealso" id="GUID-80DDC2E5-11B8-4154-90B9-1C3DDEEB22D7__GUID-49EDE835-058C-4DCE-8756-5BCBF75B7BE8">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="connect-authorize-and-initialize-functions.html#GUID-1F4B1879-4D91-4F06-BE5C-8F2324F3B4E7" title="在应用程序上下文的命名空间中设置属性及其关联值。">OCIAppCtxSet（）</a></p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNOCI72656"></a><a id="LNOCI16579"></a><div class="props_rev_3"><a id="GUID-6D968D96-DEFD-40CB-BE01-46B8F9076B68" name="GUID-6D968D96-DEFD-40CB-BE01-46B8F9076B68"></a><h4 id="LNOCI-GUID-6D968D96-DEFD-40CB-BE01-46B8F9076B68" class="sect4"><span class="enumeration_section">10.6.2</span>在SET操作之间使用CLEAR-ALL操作</h4>
                  <div>
                     <p>您可以使用<code class="codeph">OCIAppCtxClearAll()</code>函数清除特定客户端命名空间中的所有上下文信息，并且在下一次网络传输期间也将在服务器端用户会话中清除它。
                     </p>
                     <div class="section">
                        <p>如果客户端应用程序在多次设置操作之后在命名空间中执行全部清除操作，则在此清除所有操作之前设置的该命名空间中的所有属性的值将在客户端和服务器端清除。只有在全部清除操作之后完成的设置操作才会反映在服务器端。在客户端，代码出现，如<a href="managing-scalable-platforms.html#GUID-6D968D96-DEFD-40CB-BE01-46B8F9076B68__BGBDGIEA">例10-17</a>所示。
                        </p>
                        <p>clear-all操作清除命名空间<code class="codeph">CLIENTCONTEXT</code>先前操作设置的任何信息：“responsibility”=“manager”被删除。随后设置的信息不会反映在服务器端。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-6D968D96-DEFD-40CB-BE01-46B8F9076B68__BGBDGIEA">
                        <p class="titleinexample">示例10-17清除特定客户端命名空间中的所有上下文信息</p><pre class="oac_no_warn" dir="ltr">err = OCIAppCtxSet（（void *）sesshndl，（void *）“CLIENTCONTEXT”，13，（void *）“责任”，14，（void *）“manager”，7，errhp，OCI_DEFAULT）; err = OCIAppCtxClearAll（（void *）sesshndl，（void *）“CLIENTCONTEXT”，13，errhp，OCI_DEFAULT）; err = OCIAppCtxSet（（void *）sesshndl，（void *）“CLIENTCONTEXT”，13（void *）“office”，6，（void *）“2op123”，5，errhp，OCI_DEFAULT）;</pre></div>
                     <!-- class="example" -->
                     <div class="section">
                        <div class="infoboxnotealso" id="GUID-6D968D96-DEFD-40CB-BE01-46B8F9076B68__GUID-E31CBD2F-49C0-4692-AEE1-AD175283A636">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="connect-authorize-and-initialize-functions.html#GUID-D60E78B5-E600-4CDE-87A7-B4ACDA9FEE5E" title="清除应用程序上下文的命名空间中的所有属性值信息。">OCIAppCtxClearAll（）</a></p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNOCI16580"></a><div class="props_rev_3"><a id="GUID-A85FF5D3-77C5-4F26-A37C-8EB0E88A2BD4" name="GUID-A85FF5D3-77C5-4F26-A37C-8EB0E88A2BD4"></a><h4 id="LNOCI-GUID-A85FF5D3-77C5-4F26-A37C-8EB0E88A2BD4" class="sect4"><span class="enumeration_section">10.6.3</span>客户端命名空间上的网络传输和PL / SQL</h4>
                  <div>
                     <p>应用程序可能会将<code class="codeph">OCIStmtExecute()</code>调用的应用程序上下文信息发送到服务器，并且还可以通过执行<code class="codeph">DBMS_SESSION</code>程序包尝试在该调用期间更改相同的上下文信息。
                     </p>
                     <p>通常，在服务器端，首先处理传输的信息，然后处理主呼叫。此行为也适用于应用程序上下文网络传输。</p>
                     <p>如果它们都写入相同的客户端命名空间和属性集，则主调用的信息将覆盖快速网络传输机制提供的信息集。如果网络传输呼叫中发生错误，则不执行主呼叫。</p>
                     <p>但是，主呼叫中的错误不会影响网络传输呼叫的处理。处理完网络传输呼叫后，就无法撤消它。当错误被报告给调用者时（通过OCI函数），它被报告为通用ORA错误。目前，没有简单的方法来区分网络传输呼叫中的错误和主呼叫中的错误。客户端不应该假设来自主调用的错误将撤消往返网络处理，并且应该实现适当的异常处理机制以防止任何不一致。</p>
                     <div class="infoboxnotealso" id="GUID-A85FF5D3-77C5-4F26-A37C-8EB0E88A2BD4__GUID-7ADBFC2B-8B9D-4237-9E9F-31F6198A8DEA">
                        <p class="notep1">也可以看看：</p>
                        <p> </p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="statement-functions.html#GUID-98B26708-3E02-45C0-8258-5D5544F32BE9" title="将应用程序请求与服务器关联。">OCIStmtExecute（）</a></p>
                           </li>
                           <li>
                              <p><a href="connect-authorize-and-initialize-functions.html#GUID-D60E78B5-E600-4CDE-87A7-B4ACDA9FEE5E" title="清除应用程序上下文的命名空间中的所有属性值信息。">OCIAppCtxClearAll（）</a></p>
                           </li>
                           <li>
                              <p><a href="connect-authorize-and-initialize-functions.html#GUID-1F4B1879-4D91-4F06-BE5C-8F2324F3B4E7" title="在应用程序上下文的命名空间中设置属性及其关联值。">OCIAppCtxSet（）</a></p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div>
            </div><a id="LNOCI72657"></a><a id="LNOCI08100"></a><div class="props_rev_3"><a id="GUID-2F470037-FE5A-4F21-A7FC-352BD083CAE5" name="GUID-2F470037-FE5A-4F21-A7FC-352BD083CAE5"></a><h3 id="LNOCI-GUID-2F470037-FE5A-4F21-A7FC-352BD083CAE5" class="sect3"><span class="enumeration_section">10.7</span>使用基于版本的重新定义</h3>
               <div>
                  <p>版本提供了一个暂存区域，可以在现有应用程序仍然可用的情况下安装和执行由应用程序补丁更改的“可编辑”对象。</p>
                  <div class="section">
                     <p>通过在会话启动时设置属性<code class="codeph">OCI_ATTR_EDITION</code> ，可以指定数据库默认以外的版本。应用程序可以调用<code class="codeph">OCIAttrSet()</code>来指定此属性名称和版本作为值，如<a href="managing-scalable-platforms.html#GUID-2F470037-FE5A-4F21-A7FC-352BD083CAE5__BGBHHAFE">例10-18</a>所示。
                     </p>
                     <p>如果未调用<code class="codeph">OCIAttrSet()</code> ，则从操作系统环境变量<code class="codeph">ORA_EDITION</code>获取版本名称的值。如果未设置该变量，则<code class="codeph">OCI_ATTR_EDITION</code>值为空字符串。如果指定了非空值，则服务器为会话设置指定版本，或者会话使用数据库缺省版本。然后，服务器检查用户是否具有该版本的<code class="codeph">USE</code>权限。如果没有，则连接失败。如果指定了不存在的版本名称，则返回错误。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-2F470037-FE5A-4F21-A7FC-352BD083CAE5__BGBHHAFE">
                     <p class="titleinexample">示例10-18调用OCIAttrSet（）以设置OCI_ATTR_EDITION属性</p><pre class="oac_no_warn" dir="ltr">static void workerFunction（）{OCISvcCtx * svchp =（OCISvcCtx *）0; OCIAuthInfo * authp =（OCIAuthInfo *）0;剑错; err = OCIHandleAlloc（（void *）envhp，（void **）＆authp，（ub4）OCI_HTYPE_AUTHINFO，（size_t）0，（void **）0）; if（err）checkerr（errhp，err）; checkerr（errhp，OCIAttrSet（（void *）authp，（ub4）OCI_HTYPE_AUTHINFO，（void *）username，（ub4）strlen（（char *）username），（ub4）OCI_ATTR_USERNAME，errhp））; checkerr（errhp，OCIAttrSet（（void *）authp，（ub4）OCI_HTYPE_AUTHINFO，（void *）password，（ub4）strlen（（char *）password），（ub4）OCI_ATTR_PASSWORD，errhp））; （void）OCIAttrSet（（void *）authp，（ub4）OCI_HTYPE_SESSION，（void *）“Patch_Bug_12345”，（ub4）strlen（（char *）“Patch_Bug_12345”），（ub4）OCI_ATTR_EDITION，errhp）; printf（（“创建一个连接到指定版本的新会话\ n”）; if（err = OCISessionGet（envhp，errhp，＆svchp，authp，（OraText *）connstr，（ub4）strlen（（char *）connstr） ，NULL，0，NULL，NULL，NULL，OCI_DEFAULT））{checkerr（errhp，err）; exit（1）;} checkerr（errhp，OCISessionRelease（svchp，errhp，NULL，（ub4）0，OCI_DEFAULT））; OCIHandleFree （（void *）authp，OCI_HTYPE_AUTHINFO）;}</pre></div>
                  <!-- class="example" -->
                  <div class="section">
                     <div class="infoboxnotealso" id="GUID-2F470037-FE5A-4F21-A7FC-352BD083CAE5__GUID-35DFE6AA-932D-48BC-AAD0-2AF9D5A5332B">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>OCI_ATTR_EDITION中的<a href="handle-and-descriptor-attributes.html#GUID-FB263210-118E-4DB3-A840-1769EF0CB977__BAJHBAFA">OCI_ATTR_EDITION</a></p>
                           </li>
                           <li>
                              <p><a href="../adfns/editions.html#ADFNS020" target="_blank"><span><cite>“Oracle数据库开发指南”，</cite></span></a>用于更完整地描述基于版本的重新定义</p>
                           </li>
                           <li>
                              <p><a href="connect-authorize-and-initialize-functions.html#GUID-890DFBC4-718B-4339-A0EA-6226A25B8241" title="获取一个会话。">OCISessionGet（）中</a>对OCI会话池支持的属性的限制</p>
                           </li>
                           <li>
                              <p><a href="handle-and-descriptor-functions.html#GUID-3741D7BD-7652-4D7A-8813-AC2AEA8D3B03" title="设置句柄或描述符的属性值。">OCIAttrSet（）</a></p>
                           </li>
                        </ul>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div>
            </div><a id="LNOCI08103"></a><div class="props_rev_3"><a id="GUID-73D8C87C-ABD9-463A-921D-3D5F1E232F85" name="GUID-73D8C87C-ABD9-463A-921D-3D5F1E232F85"></a><h3 id="LNOCI-GUID-73D8C87C-ABD9-463A-921D-3D5F1E232F85" class="sect3"><span class="enumeration_section">10.8</span> OCI安全增强功能</h3>
               <div>
                  <p>以下安全增强功能使用<code class="codeph">init.ora</code>文件或<code class="codeph">sqlnet.ora</code>文件中的已配置参数（后一个文件专门针对该功能而注明）。
                  </p>
                  <p>“ <span><cite>Oracle数据库安全指南”</cite></span>中更详细地介绍了这些安全增强功能。这些初始化参数适用于数据库的所有实例。
                  </p>
                  <div class="infoboxnotealso" id="GUID-73D8C87C-ABD9-463A-921D-3D5F1E232F85__GUID-00BFF1B8-FE8F-4930-A021-36F7643526CA">
                     <p class="notep1">也可以看看：</p>
                     <p><a href="../dbseg/using-application-contexts-to-retrieve-user-information.html#DBSEG70785" target="_blank"><span><cite>“Oracle数据库安全指南”</cite></span></a> ，关于在中间层应用程序中嵌入调用以获取，设置和清除客户端会话ID的部分</p>
                  </div>
                  <div class="p">本节包括以下主题：<ul style="list-style-type:disc">
                        <li>
                           <p><a href="managing-scalable-platforms.html#GUID-9D521FEA-88FD-47BB-8F9E-93BC3A0FC5CC" title="可以在身份验证之前（在调用OCIServerAttach（）之后在连接的服务器句柄上）发出OCIServerVersion（）函数以获取数据库版本。">控制显示的数据库版本标题</a></p>
                        </li>
                        <li>
                           <p><a href="managing-scalable-platforms.html#GUID-C666E5EF-8F59-4660-B7A8-904E60831C94" title="以下系统范围的参数位于sqlnet.ora中，并警告用户未经授权的访问以及可能的用户操作审核。">未经授权的访问和用户操作审计的横幅</a></p>
                        </li>
                        <li>
                           <p><a href="managing-scalable-platforms.html#GUID-85391B02-0993-423F-9F45-8C4D005732BA" title="不再支持应用程序的非延迟链接，并修改Makefile以将其删除。">非延期联动</a></p>
                        </li>
                     </ul>
                  </div>
               </div><a id="LNOCI16581"></a><div class="props_rev_3"><a id="GUID-9D521FEA-88FD-47BB-8F9E-93BC3A0FC5CC" name="GUID-9D521FEA-88FD-47BB-8F9E-93BC3A0FC5CC"></a><h4 id="LNOCI-GUID-9D521FEA-88FD-47BB-8F9E-93BC3A0FC5CC" class="sect4"><span class="enumeration_section">10.8.1</span>控制显示的数据库版本标题</h4>
                  <div>
                     <p>可以在身份验证之前（在调用<code class="codeph">OCIServerAttach()</code>之后在连接的服务器句柄上<code class="codeph">OCIServerVersion()</code>发出<code class="codeph">OCIServerVersion()</code>函数以获取数据库版本。
                     </p>
                     <div class="section">
                        <p>要避免在身份验证之前公开数据库版本字符串，请将<code class="codeph">SEC_RETURN_SERVER_RELEASE_BANNER</code>初始化参数设置为<code class="codeph">NO</code> 。例如：</p><pre class="oac_no_warn" dir="ltr">SEC_RETURN_SERVER_RELEASE_BANNER = NO</pre><p>这将显示Oracle Database Release 11.1以及所有后续11.1版本和补丁集的以下字符串：</p><pre class="oac_no_warn" dir="ltr">Oracle Database 11g 11.1.0.0.0版 - 生产</pre><p>将<code class="codeph">SEC_RETURN_SERVER_RELEASE_BANNER</code>设置为<code class="codeph">YES</code> ，然后显示当前横幅。如果已安装Oracle Database 11.2.0.2，则显示的标题为：</p><pre class="oac_no_warn" dir="ltr">Oracle Database 11g企业版11.2.0.2版 - 生产</pre><p>此功能适用于Oracle Database Release 11.1或更高版本的服务器以及任何版本客户端。</p>
                        <div class="infoboxnotealso" id="GUID-9D521FEA-88FD-47BB-8F9E-93BC3A0FC5CC__GUID-304E432F-EEC3-46E5-8B45-4B12DA592FC4">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><a href="miscellaneous-functions.html#GUID-5EED124F-6D98-40EA-8B3F-09374F020B89" title="返回Oracle数据库版本字符串。">OCIServerVersion（）</a></p>
                              </li>
                              <li>
                                 <p><a href="connect-authorize-and-initialize-functions.html#GUID-B6291228-DA2F-4CE9-870A-F94243141757" title="为OCI操作创建数据源的访问路径。">OCIServerAttach（）</a></p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNOCI16582"></a><div class="props_rev_3"><a id="GUID-C666E5EF-8F59-4660-B7A8-904E60831C94" name="GUID-C666E5EF-8F59-4660-B7A8-904E60831C94"></a><h4 id="LNOCI-GUID-C666E5EF-8F59-4660-B7A8-904E60831C94" class="sect4"><span class="enumeration_section">10.8.2</span>未经授权访问和用户操作审计的横幅</h4>
                  <div>
                     <p>以下系统范围的参数位于<code class="codeph">sqlnet.ora</code>并警告用户未经授权的访问以及可能的用户操作审核。
                     </p>
                     <p>Oracle Database 11.1版及更高版本的服务器和客户端中提供了这些功能。横幅的内容位于数据库管理员创建的文本文件中。用于显示标题内容的缓冲区限制为512字节。如果超出此缓冲区限制，横幅内容将显示为已切断。访问标题语法是：</p><pre class="oac_no_warn" dir="ltr">SEC_USER_UNAUTHORIZED_ACCESS_BANNER = <span class="italic">file_path1</span>
</pre><p>在此语法中， <span class="italic"><code class="codeph">file_path1</code></span>是文本文件的路径。要检索横幅，请在调用<code class="codeph">OCIServerAttach()</code>或<code class="codeph">OCISessionGet()</code>后从服务器句柄获取属性<code class="codeph">OCI_ATTR_ACCESS_BANNER</code>的值。
                     </p>
                     <p>审计标志语法是：</p><pre class="oac_no_warn" dir="ltr">SEC_USER_AUDIT_ACTION_BANNER = <span class="italic">file_path2</span>
</pre><p>在此语法中， <span class="italic"><code class="codeph">file_path2</code></span>是文本文件的路径。要检索横幅，请在调用<code class="codeph">OCISessionBegin()</code> ， <code class="codeph">OCISessionGet()</code> ， <code class="codeph">OCILogon()</code>或<code class="codeph">OCILogon2()</code>之后从会话句柄中获取属性<code class="codeph">OCI_ATTR_AUDIT_BANNER</code>的值。
                     </p>
                     <div class="infoboxnotealso" id="GUID-C666E5EF-8F59-4660-B7A8-904E60831C94__GUID-832C4668-5693-42EC-B630-3F277EB65444">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="handle-and-descriptor-attributes.html#GUID-2B6D06A7-8EDF-46FF-BDEF-320D293DCA65__CHDBBEEC">OCI_ATTR_ACCESS_BANNER</a></p>
                           </li>
                           <li>
                              <p><a href="handle-and-descriptor-attributes.html#GUID-FB263210-118E-4DB3-A840-1769EF0CB977__BAJIFFFE">OCI_ATTR_AUDIT_BANNER</a></p>
                           </li>
                           <li>
                              <p><a href="connect-authorize-and-initialize-functions.html#GUID-B6291228-DA2F-4CE9-870A-F94243141757" title="为OCI操作创建数据源的访问路径。">OCIServerAttach（）</a></p>
                           </li>
                           <li>
                              <p><a href="connect-authorize-and-initialize-functions.html#GUID-890DFBC4-718B-4339-A0EA-6226A25B8241" title="获取一个会话。">OCISessionGet（）</a></p>
                           </li>
                           <li>
                              <p><a href="connect-authorize-and-initialize-functions.html#GUID-31B1FDB3-056E-4AF9-9B89-8DA6AA156947" title="创建用户会话并开始给定服务器的用户会话。">OCISessionBegin（）</a></p>
                           </li>
                           <li>
                              <p><a href="connect-authorize-and-initialize-functions.html#GUID-F4592576-BE9D-4583-83AD-5D56D2E592E6" title="创建一个简单的登录会话。">OCILogon（）</a></p>
                           </li>
                           <li>
                              <p><a href="connect-authorize-and-initialize-functions.html#GUID-425D4B32-257C-480E-B69C-7112BE9482E6" title="获取一个会话。">OCILogon2（）</a></p>
                           </li>
                        </ul>
                        <p></p>
                     </div>
                  </div>
               </div><a id="LNOCI16583"></a><div class="props_rev_3"><a id="GUID-85391B02-0993-423F-9F45-8C4D005732BA" name="GUID-85391B02-0993-423F-9F45-8C4D005732BA"></a><h4 id="LNOCI-GUID-85391B02-0993-423F-9F45-8C4D005732BA" class="sect4"><span class="enumeration_section">10.8.3</span>非延期联动</h4>
                  <div>
                     <p>不再支持应用程序的非延迟链接，并修改<code class="codeph">Makefile</code>以将其删除。
                     </p>
                     <p>这种连接方法在OCI V7之前使用。</p>
                  </div>
               </div>
            </div><a id="LNOCI16584"></a><div class="props_rev_3"><a id="GUID-FB0528A0-460A-4778-9703-52BB0932E911" name="GUID-FB0528A0-460A-4778-9703-52BB0932E911"></a><h3 id="LNOCI-GUID-FB0528A0-460A-4778-9703-52BB0932E911" class="sect3"><span class="enumeration_section">10.9</span> OCI多线程开发概述</h3>
               <div>
                  <p>线程是存在于更大进程中的轻量级进程。</p>
                  <p>线程共享相同的代码和数据段，但有自己的程序计数器，系统寄存器和堆栈。全局变量和静态变量对于所有线程都是通用的，并且需要互斥机制来管理来自应用程序内多个线程的这些变量的访问。</p>
                  <p>一旦产生，线程就彼此异步运行。他们可以访问公共数据元素并以任何顺序进行OCI调用。由于对数据元素的这种共享访问，需要同步机制来维护被访问数据的完整性。</p>
                  <p>管理数据访问的机制采用<span class="italic">互斥锁</span> （互斥锁）的形式。实现此机制是为了确保多个线程访问对用户不透明的共享内部数据之间不会发生冲突。在OCI中，为每个环境句柄授予互斥锁。
                  </p>
                  <p>Oracle数据库和OCI库的线程安全功能允许开发人员在多线程环境中使用OCI。线程安全性确保代码可以重入，多个线程进行OCI调用而没有副作用。</p>
                  <div class="infoboxnote" id="GUID-FB0528A0-460A-4778-9703-52BB0932E911__GUID-14179E39-21D2-407C-A965-8E74606A51FC">
                     <p class="notep1">注意：</p>
                     <p>每个操作系统都不提供线程安全性。有关更多信息，请查看Oracle数据库系统特定的文档。</p>
                     <p>在多线程Linux或UNIX环境中，在用户信号处理程序中不允许使用<code class="codeph">OCIBreak()</code>以外的OCI调用。
                     </p>
                     <p>使用和释放句柄的正确方法是创建句柄，使用句柄，然后在应用程序终止时，仅在所有线程被销毁后释放句柄。</p>
                  </div>
                  <div class="p">本节包括以下主题：<ul style="list-style-type:disc">
                        <li>
                           <p><a href="managing-scalable-platforms.html#GUID-7AB8E442-FDFD-4B66-AE84-DFB4B9FD0CF3" title="列出了实现线程安全的优点。">OCI线程安全的优点</a></p>
                        </li>
                        <li>
                           <p><a href="managing-scalable-platforms.html#GUID-2E7DE663-CB17-4AA8-90D2-9F24F2BA458A" title="除了客户端/服务器应用程序（客户端可以是多线程程序）之外，多线程应用程序的典型用途是三层（客户端 - 代理 - 服务器）体系结构。">OCI线程安全和三层架构</a></p>
                        </li>
                        <li>
                           <p><a href="managing-scalable-platforms.html#GUID-17B33216-F71E-4CD8-9E07-AD8F551A9C69" title="要利用线程安全性，应用程序必须在线程安全的操作系统上运行。">关于实现线程安全</a></p>
                        </li>
                     </ul>
                  </div>
                  <div class="infoboxnotealso" id="GUID-FB0528A0-460A-4778-9703-52BB0932E911__GUID-A237430A-E586-450D-A9DE-B88DEEE73A70">
                     <p class="notep1">也可以看看：</p>
                     <p><a href="miscellaneous-functions.html#GUID-A414B5DE-07A3-4593-A448-B6023F87C2D0" title="执行立即异步中断。">OCIBreak（）</a></p>
                  </div>
               </div><a id="LNOCI16585"></a><div class="props_rev_3"><a id="GUID-7AB8E442-FDFD-4B66-AE84-DFB4B9FD0CF3" name="GUID-7AB8E442-FDFD-4B66-AE84-DFB4B9FD0CF3"></a><h4 id="LNOCI-GUID-7AB8E442-FDFD-4B66-AE84-DFB4B9FD0CF3" class="sect4"><span class="enumeration_section">10.9.1</span> OCI线程安全的优点</h4>
                  <div>
                     <p>列出了实现线程安全的优点。</p>
                     <p>在OCI中实现线程安全具有以下优点：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>多个执行线程可以使OCI调用与单个线程进行的连续调用具有相同的结果。</p>
                        </li>
                        <li>
                           <p>当多个线程进行OCI调用时，线程之间没有副作用。</p>
                        </li>
                        <li>
                           <p>不编写多线程程序的用户不会因使用线程安全的OCI调用而降低性能。</p>
                        </li>
                        <li>
                           <p>使用多个线程可以提高程序性能。在多处理器系统中可以看到增益，其中线程在单独的处理器上并发运行，并且在单处理器系统上可以在较慢的操作和较快的操作之间发生重叠。</p>
                        </li>
                     </ul>
                  </div>
               </div><a id="LNOCI16586"></a><div class="props_rev_3"><a id="GUID-2E7DE663-CB17-4AA8-90D2-9F24F2BA458A" name="GUID-2E7DE663-CB17-4AA8-90D2-9F24F2BA458A"></a><h4 id="LNOCI-GUID-2E7DE663-CB17-4AA8-90D2-9F24F2BA458A" class="sect4"><span class="enumeration_section">10.9.2</span> OCI线程安全和三层体系结构</h4>
                  <div>
                     <p>除了客户端/服务器应用程序（客户端可以是多线程程序）之外，多线程应用程序的典型用途是三层（客户端 - 代理 - 服务器）体系结构。</p>
                     <p>在此体系结构中，客户端仅关注表示服务。代理（应用程序服务器）处理客户端应用程序的应用程序逻辑。通常，此关系是多对一关系，多个客户端共享同一应用程序服务器。</p>
                     <p>此方案中的服务器层是数据库。应用程序服务器（代理）非常适合作为多线程应用程序服务器，每个线程服务于单个客户端应用程序。在Oracle数据库环境中，此应用程序服务器是OCI或预编译器程序。</p>
                  </div>
               </div><a id="LNOCI16587"></a><div class="props_rev_3"><a id="GUID-17B33216-F71E-4CD8-9E07-AD8F551A9C69" name="GUID-17B33216-F71E-4CD8-9E07-AD8F551A9C69"></a><h4 id="LNOCI-GUID-17B33216-F71E-4CD8-9E07-AD8F551A9C69" class="sect4"><span class="enumeration_section">10.9.3</span>关于实现线程安全</h4>
                  <div>
                     <p>要利用线程安全性，应用程序必须在线程安全的操作系统上运行。</p>
                     <p>应用程序通过使用<code class="codeph">OCI_THREADED</code>作为<code class="codeph">mode</code>参数的值进行<code class="codeph">OCIEnvNlsCreate()</code>调用来指定它在多线程环境中运行。
                     </p>
                     <p>所有后续对<code class="codeph">OCIEnvNlsCreate()</code>调用也必须使用<code class="codeph">OCI_THREADED</code> 。</p>
                     <div class="infoboxnote" id="GUID-17B33216-F71E-4CD8-9E07-AD8F551A9C69__GUID-52009A99-1755-4E82-8B35-721EAEEE9489">
                        <p class="notep1">注意：</p>
                        <p>在非线程安全操作系统上运行的应用程序不得将<code class="codeph">OCI_THREADED</code>值传递给<code class="codeph">OCI_THREADED</code> <code class="codeph">OCIEnvCreate()</code>或<code class="codeph">OCIEnvNlsCreate()</code> 。
                        </p>
                     </div>
                     <p>如果应用程序是单线程的，操作系统是否是线程安全的，该应用程序必须通过的值<code class="codeph">OCI_DEFAULT</code>到<code class="codeph">OCIEnvCreate()</code>或<code class="codeph">OCIEnvNlsCreate()</code>以<code class="codeph">OCI_THREADED</code>模式运行的单线程应用程序可能会降低性能。
                     </p>
                     <p>如果多线程应用程序在线程安全的操作系统上运行，则OCI库为每个环境句柄管理应用程序的互斥锁。应用程序可以通过在<code class="codeph">OCI_ENV_NO_MUTEX</code> <code class="codeph">OCIEnvCreate()</code>或<code class="codeph">OCIEnvNlsCreate()</code>调用的<code class="codeph">mode</code>参数中指定<code class="codeph">OCI_ENV_NO_MUTEX</code>的值来覆盖此功能并维护其自己的互斥锁方案。
                     </p>
                     <p>以下方案是可能的，具体取决于每个环境句柄中存在多少个连接，以及每个连接中生成的线程数。</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>如果应用程序具有多个环境句柄，每个句柄中都有一个线程，则不需要互斥锁。</p>
                        </li>
                        <li>
                           <p>如果以<code class="codeph">OCI_THREADED</code>模式运行的应用程序维护一个或多个具有多个连接的环境句柄，则它具有以下选项：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>将<code class="codeph">OCI_ENV_NO_MUTEX</code>的值传递给<code class="codeph">OCIEnvNlsCreate()</code>的<code class="codeph">mode</code> 。应用程序必须为在同一环境句柄上进行的OCI调用设置互斥锁（互斥锁）。这具有可以针对应用设计优化互斥方案的优点。程序员还必须确保在任何给定时间环境句柄连接上只有一个OCI调用正在进行中。
                                 </p>
                              </li>
                              <li>
                                 <p>为<code class="codeph">OCIEnvNlsCreate()</code> <code class="codeph">mode</code>传递<code class="codeph">OCI_DEFAULT</code>值。OCI库在相同环境句柄上的每个OCI调用上自动获取互斥锁。
                                 </p>
                                 <div class="infoboxnote" id="GUID-17B33216-F71E-4CD8-9E07-AD8F551A9C69__GUID-4282E2C6-5193-4A2E-8081-508AFA4FFA94">
                                    <p class="notep1">注意：</p>
                                    <p>大多数OCI调用的处理都发生在服务器上，因此如果使用OCI调用的两个线程转到同一个连接，则其中一个线程可以被阻塞，而另一个线程在服务器上完成处理。</p>
                                    <p>对应用程序中的每个线程使用一个错误句柄，因为OCI错误可以被其他线程覆盖。</p>
                                 </div>
                              </li>
                           </ul>
                        </li>
                     </ul>
                     <div class="p">本节包括以下主题：<ul style="list-style-type:disc">
                           <li>
                              <p><a href="managing-scalable-platforms.html#GUID-B7FE3C01-69E3-4E44-BEA3-B41B5DC3488D" title="OCI支持轮询模式操作。">关于轮询模式操作和线程安全</a></p>
                           </li>
                           <li>
                              <p><a href="managing-scalable-platforms.html#GUID-33640C43-C7F2-4031-B0D7-740F23077AD1" title="如果应用程序正在混合更高版本和7.x OCI调用，并且应用程序已初始化为线程安全（使用更高版本的相应调用），则无需调用opinit（）来实现线程安全性。">混合7.x和更高版本发布OCI调用</a></p>
                           </li>
                        </ul>
                     </div>
                     <div class="infoboxnotealso" id="GUID-17B33216-F71E-4CD8-9E07-AD8F551A9C69__GUID-9FCE1EF8-74D2-4DD0-81B9-A56DFA6874AB">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="connect-authorize-and-initialize-functions.html#GUID-0B6911A9-4B46-476C-BC5E-B87581666CD9" title="创建并初始化OCI函数的环境句柄。">OCIEnvNlsCreate（）</a></p>
                           </li>
                           <li>
                              <p><a href="connect-authorize-and-initialize-functions.html#GUID-16BDA1F1-7DAF-41CA-9EE1-C9A4CB467244" title="创建并初始化OCI函数的环境句柄。">OCIEnvCreate（）</a></p>
                           </li>
                        </ul>
                     </div>
                  </div><a id="LNOCI72658"></a><div class="props_rev_3"><a id="GUID-B7FE3C01-69E3-4E44-BEA3-B41B5DC3488D" name="GUID-B7FE3C01-69E3-4E44-BEA3-B41B5DC3488D"></a><h5 id="LNOCI-GUID-B7FE3C01-69E3-4E44-BEA3-B41B5DC3488D" class="sect5"><span class="enumeration_section">10.9.3.1</span>关于轮询模式操作和线程安全</h5>
                     <div>
                        <p>OCI支持轮询模式操作。</p>
                        <p>当OCI以线程模式运行时，OCI调用该轮询完成时，在OCI调用正在执行时获取互斥锁。但是，当OCI将控制权返回给应用程序时，OCI会释放任何获取的互斥锁。调用方应确保在轮询模式正在进行的OCI操作完成之前，不会对连接进行其他OCI调用。</p>
                        <div class="infoboxnotealso" id="GUID-B7FE3C01-69E3-4E44-BEA3-B41B5DC3488D__GUID-051F15BF-230B-45BE-9A47-598FAE101B78">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="oci-programming-basics.html#GUID-83F4D3B1-56A7-4EEE-A905-BB84D399713D" title="OCI呼吁完成民意调查。">OCI中的轮询模式操作</a></p>
                        </div>
                     </div>
                  </div><a id="LNOCI16588"></a><div class="props_rev_3"><a id="GUID-33640C43-C7F2-4031-B0D7-740F23077AD1" name="GUID-33640C43-C7F2-4031-B0D7-740F23077AD1"></a><h5 id="LNOCI-GUID-33640C43-C7F2-4031-B0D7-740F23077AD1" class="sect5"><span class="enumeration_section">10.9.3.2</span>混合7.x及更高版本发布OCI呼叫</h5>
                     <div>
                        <p>如果应用程序正在混合更高版本和7.x OCI调用，并且应用程序已初始化为线程安全（使用更高版本的相应调用），则无需调用<code class="codeph">opinit()</code>来实现线程安全性。
                        </p>
                        <p>应用程序在任何后续7.x函数调用中获得7.x行为。</p>
                     </div>
                  </div>
               </div>
            </div><a id="LNOCI16589"></a><div class="props_rev_3"><a id="GUID-AAE70C09-E0D8-4264-8E88-1D6916ABF717" name="GUID-AAE70C09-E0D8-4264-8E88-1D6916ABF717"></a><h3 id="LNOCI-GUID-AAE70C09-E0D8-4264-8E88-1D6916ABF717" class="sect3"><span class="enumeration_section">10.10</span> OCIThread包</h3>
               <div>
                  <p><code class="codeph">OCIThread</code>包提供了一些常用的线程原语。
                  </p>
                  <p><code class="codeph">OCIThread</code>包为各种操作系统原生的线程功能提供了可移植的接口，但是没有在没有本机线程功能的操作系统上实现线程。
                  </p>
                  <p><code class="codeph">OCIThread</code>不提供可移植的实现，但它作为一组用于本机多线程设施的便携式覆盖。因此，没有多线程本机支持的操作系统只能支持<code class="codeph">OCIThread</code>包的有限实现。因此，依赖于所有<code class="codeph">OCIThread</code>功能的产品不会移植到所有操作系统。必须移植到所有操作系统的产品必须仅使用<code class="codeph">OCIThread</code>功能的子集。
                  </p>
                  <p><code class="codeph">OCIThread</code> API由三个主要部分组成。这里简要介绍每个部分。以下小节将更详细地描述每个小节：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="managing-scalable-platforms.html#GUID-CB94E283-B577-48E5-99D8-844D22DE45F5" title="本节中描述的类型和函数与OCIThread包的初始化和终止相关联。必须先初始化OCIThread，然后才能使用其任何功能。">初始化和终止</a> 。这些调用处理<code class="codeph">OCIThread</code>上下文的初始化和终止，这是其他<code class="codeph">OCIThread</code>调用所必需的。
                        </p>
                        <p><code class="codeph">OCIThread</code>仅要求在多线程应用程序中使用<code class="codeph">OCIThread</code>时调用进程初始化函数<code class="codeph">OCIThreadProcessInit()</code> 。无法在单线程应用程序中调用<code class="codeph">OCIThreadProcessInit()</code>不是错误。
                        </p>
                        <p>对<code class="codeph">OCIThreadInit()</code>单独调用都返回相同的<code class="codeph">OCIThread</code>上下文。每次调用<code class="codeph">OCIThreadInit()</code>最终都必须通过调用<code class="codeph">OCIThreadTerm()</code>进行匹配。
                        </p>
                     </li>
                     <li>
                        <p><a href="managing-scalable-platforms.html#GUID-B8E195BF-33E6-4408-991C-2BF9610DA00F" title="列出被动线程原语函数。">被动线程原语</a> 。<span>被动</span>线程原语用于操纵互斥锁（互斥锁），线程ID和特定于线程的数据键。这些原语被描述为被动，因为虽然它们的规范允许存在多个线程，但它们并不需要它。这些原语可以在单线程和多线程环境中根据规范实现。因此，仅使用这些原语的<code class="codeph">OCIThread</code>客户端不需要多线程环境即可正常工作。它们能够在单线程环境中工作而无需分支代码。
                        </p>
                     </li>
                     <li>
                        <p><a href="managing-scalable-platforms.html#GUID-A80A28BF-5AFF-49FA-825D-DB43CAA16B8A" title="列出活动线程基元，它处理实际线程的操作。">主动线程基元</a> 。活动线程原语处理线程的创建，终止和操作。这些原语被描述为<span class="italic">活动的，</span>因为它们只能用于真正的多线程环境。他们的规范明确要求多个线程。如果必须在运行时确定是否处于多线程环境中，请在使用<code class="codeph">OCIThread</code>活动线程原语之前调用<code class="codeph">OCIThreadIsMulti()</code> 。
                        </p>
                        <p>要编写在单线程操作系统上运行的同一应用程序的版本，有必要对代码进行分支，无论是通过分支源文件的版本还是通过在运行时使用<code class="codeph">OCIThreadIsMuilt()</code>调用进行分支。
                        </p>
                     </li>
                  </ul>
                  <div class="infoboxnotealso" id="GUID-AAE70C09-E0D8-4264-8E88-1D6916ABF717__GUID-82364962-D0AB-44EC-A9A9-73E6075F2B49">
                     <p class="notep1">也可以看看：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="thread-management-functions.html#GUID-41E79A5A-4D95-4610-9496-49CA5AC65FA5" title="列出并描述了线程管理功能。">线程管理功能</a></p>
                        </li>
                        <li>
                           <p><code class="codeph">demo</code>目录中的<code class="codeph">cdemothr.c</code>是多线程应用程序的一个示例</p>
                        </li>
                        <li>
                           <p><a href="thread-management-functions.html#GUID-F13EFBDB-F51E-4838-AA70-F8E70D1AB613" title="执行OCIThread进程初始化。">OCIThreadProcessInit（）</a></p>
                        </li>
                        <li>
                           <p><a href="thread-management-functions.html#GUID-B1CD9DB9-9362-4C4B-97D7-98F2C755CE21" title="初始化OCIThread上下文。">OCIThreadInit（）</a></p>
                        </li>
                        <li>
                           <p><a href="thread-management-functions.html#GUID-FDB9D57D-EA5D-490A-941C-A04E4FA57065" title="释放OCIThread上下文。">OCIThreadTerm（）</a></p>
                        </li>
                        <li>
                           <p><a href="thread-management-functions.html#GUID-D36F5FBC-56DA-4365-92E4-3B6B78F75F09" title="告诉调用者应用程序是在多线程环境还是单线程环境中运行。">OCIThreadIsMulti（）</a></p>
                        </li>
                     </ul>
                  </div>
               </div><a id="LNOCI16591"></a><a id="LNOCI16590"></a><div class="props_rev_3"><a id="GUID-CB94E283-B577-48E5-99D8-844D22DE45F5" name="GUID-CB94E283-B577-48E5-99D8-844D22DE45F5"></a><h4 id="LNOCI-GUID-CB94E283-B577-48E5-99D8-844D22DE45F5" class="sect4"><span class="enumeration_section">10.10.1</span>初始化和终止</h4>
                  <div>
                     <p>本节中描述的类型和函数与<code class="codeph">OCIThread</code>包的初始化和终止相关联。必须先初始化<code class="codeph">OCIThread</code>然后才能使用其任何功能。
                     </p>
                     <div class="section">
                        <p>无论<code class="codeph">OCIThread</code>是在单线程还是多线程环境中，初始化和终止函数的观察行为都是相同的。<a href="managing-scalable-platforms.html#GUID-CB94E283-B577-48E5-99D8-844D22DE45F5__G473609" title="该表有2列。第1列是函数名称，第2列描述其用途。">表10-6</a>列出了线程初始化和终止的功能。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="tblformal" id="GUID-CB94E283-B577-48E5-99D8-844D22DE45F5__G473609">
                        <p class="titleintable">表10-6初始化和终止多线程函数</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="初始化和终止多线程函数" width="100%" border="1" summary="This table has 2 columns. Column 1 is the function name and column 2 describes its purpose." frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="42%" id="d106260e15256">功能</th>
                                 <th align="left" valign="bottom" width="58%" id="d106260e15259">目的</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="42%" id="d106260e15264" headers="d106260e15256 ">
                                    <p><a href="thread-management-functions.html#GUID-F13EFBDB-F51E-4838-AA70-F8E70D1AB613" title="执行OCIThread进程初始化。">OCIThreadProcessInit（）</a></p>
                                 </td>
                                 <td align="left" valign="top" width="58%" headers="d106260e15264 d106260e15259 ">
                                    <p>执行OCIThread进程初始化</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="42%" id="d106260e15276" headers="d106260e15256 ">
                                    <p><a href="thread-management-functions.html#GUID-B1CD9DB9-9362-4C4B-97D7-98F2C755CE21" title="初始化OCIThread上下文。">OCIThreadInit（）</a></p>
                                 </td>
                                 <td align="left" valign="top" width="58%" headers="d106260e15276 d106260e15259 ">
                                    <p>初始化OCIThread上下文</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="42%" id="d106260e15288" headers="d106260e15256 ">
                                    <p><a href="thread-management-functions.html#GUID-FDB9D57D-EA5D-490A-941C-A04E4FA57065" title="释放OCIThread上下文。">OCIThreadTerm（）</a></p>
                                 </td>
                                 <td align="left" valign="top" width="58%" headers="d106260e15288 d106260e15259 ">
                                    <p>终止OCIThread层并释放上下文内存</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="42%" id="d106260e15300" headers="d106260e15256 ">
                                    <p><a href="thread-management-functions.html#GUID-D36F5FBC-56DA-4365-92E4-3B6B78F75F09" title="告诉调用者应用程序是在多线程环境还是单线程环境中运行。">OCIThreadIsMulti（）</a></p>
                                 </td>
                                 <td align="left" valign="top" width="58%" headers="d106260e15300 d106260e15259 ">
                                    <p>告诉调用者应用程序是在多线程环境还是单线程环境中运行</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <div class="section">
                        <p>本节包括以下主题： <a href="managing-scalable-platforms.html#GUID-99D37BBB-6205-4427-8555-C63029FA18F9" title="大多数对OCIThread函数的调用都使用OCI环境或用户会话句柄作为参数。">OCIThread上下文</a> 。
                        </p>
                        <div class="infoboxnotealso" id="GUID-CB94E283-B577-48E5-99D8-844D22DE45F5__GUID-53A0836D-B3D7-4539-8DF4-9D7929C2F9EE">
                           <p class="notep1">也可以看看：</p>
                           <p> <a href="thread-management-functions.html#GUID-41E79A5A-4D95-4610-9496-49CA5AC65FA5" title="列出并描述了线程管理功能。">线程管理功能</a></p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div><a id="LNOCI16592"></a><div class="props_rev_3"><a id="GUID-99D37BBB-6205-4427-8555-C63029FA18F9" name="GUID-99D37BBB-6205-4427-8555-C63029FA18F9"></a><h5 id="LNOCI-GUID-99D37BBB-6205-4427-8555-C63029FA18F9" class="sect5"><span class="enumeration_section">10.10.1.1</span> OCIThread上下文</h5>
                     <div>
                        <p>大多数对<code class="codeph">OCIThread</code>函数的调用都使用OCI环境或用户会话句柄作为参数。
                        </p>
                        <p><code class="codeph">OCIThread</code>上下文是OCI环境或用户会话句柄的一部分，必须通过调用<code class="codeph">OCIThreadInit()</code>来初始化它。通过调用<code class="codeph">OCIThreadTerm()</code>终止<code class="codeph">OCIThread</code>上下文。
                        </p>
                        <div class="infoboxnote" id="GUID-99D37BBB-6205-4427-8555-C63029FA18F9__GUID-96621A3B-0085-48DF-9BCF-EE5BF1A6F65C">
                           <p class="notep1">注意：</p>
                           <p><code class="codeph">OCIThread</code>上下文是不透明的数据结构。不要试图检查上下文的内容。
                           </p>
                        </div>
                        <div class="infoboxnotealso" id="GUID-99D37BBB-6205-4427-8555-C63029FA18F9__GUID-B3256976-F5DC-4717-BD31-A0D009BEECA9">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><a href="thread-management-functions.html#GUID-B1CD9DB9-9362-4C4B-97D7-98F2C755CE21" title="初始化OCIThread上下文。">OCIThreadInit（）</a></p>
                              </li>
                              <li>
                                 <p><a href="thread-management-functions.html#GUID-FDB9D57D-EA5D-490A-941C-A04E4FA57065" title="释放OCIThread上下文。">OCIThreadTerm（）</a></p>
                              </li>
                           </ul>
                        </div>
                     </div>
                  </div>
               </div><a id="LNOCI16594"></a><a id="LNOCI16593"></a><div class="props_rev_3"><a id="GUID-B8E195BF-33E6-4408-991C-2BF9610DA00F" name="GUID-B8E195BF-33E6-4408-991C-2BF9610DA00F"></a><h4 id="LNOCI-GUID-B8E195BF-33E6-4408-991C-2BF9610DA00F" class="sect4"><span class="enumeration_section">10.10.2</span>被动线程基元</h4>
                  <div>
                     <p>列出被动线程原语函数。</p>
                     <div class="section">
                        <p>被动线程原语处理互斥锁，线程ID和线程特定数据的操作。由于这些原语的规范不需要存在多个线程，因此它们可以在多线程和单线程操作系统中使用。<a href="managing-scalable-platforms.html#GUID-B8E195BF-33E6-4408-991C-2BF9610DA00F__G473537" title="该表有2列。第1列是函数名称，第2列描述其用途。">表10-7</a>列出了用于实现被动线程的函数。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="tblformal" id="GUID-B8E195BF-33E6-4408-991C-2BF9610DA00F__G473537">
                        <p class="titleintable">表10-7被动线程基元</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="被动线程原语" width="100%" border="1" summary="This table has 2 columns. Column 1 is the function name and column 2 describes its purpose." frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="35%" id="d106260e15762">功能</th>
                                 <th align="left" valign="bottom" width="65%" id="d106260e15765">目的</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="35%" id="d106260e15770" headers="d106260e15762 ">
                                    <p><a href="thread-management-functions.html#GUID-C7D25B80-DFD4-4C67-9624-0ED40F69F518" title="分配并初始化互斥锁。">OCIThreadMutexInit（）</a></p>
                                 </td>
                                 <td align="left" valign="top" width="65%" headers="d106260e15770 d106260e15765 ">
                                    <p>分配并初始化互斥锁</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="35%" id="d106260e15782" headers="d106260e15762 ">
                                    <p><a href="thread-management-functions.html#GUID-CDC1183C-006E-4F09-8BCB-CA079774B56C" title="销毁和释放互斥锁。">OCIThreadMutexDestroy（）</a></p>
                                 </td>
                                 <td align="left" valign="top" width="65%" headers="d106260e15782 d106260e15765 ">
                                    <p>销毁和释放互斥锁</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="35%" id="d106260e15794" headers="d106260e15762 ">
                                    <p><a href="thread-management-functions.html#GUID-BE59FB94-FF0F-4A2C-80CC-2DE6F2586517" title="获取调用它的线程的互斥锁。">OCIThreadMutexAcquire（）</a></p>
                                 </td>
                                 <td align="left" valign="top" width="65%" headers="d106260e15794 d106260e15765 ">
                                    <p>获取调用它的线程的互斥锁</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="35%" id="d106260e15806" headers="d106260e15762 ">
                                    <p><a href="thread-management-functions.html#GUID-B1B2121E-A22D-40B6-984B-B9A129D353DE" title="释放互斥锁。">OCIThreadMutexRelease（）</a></p>
                                 </td>
                                 <td align="left" valign="top" width="65%" headers="d106260e15806 d106260e15765 ">
                                    <p>释放互斥锁</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="35%" id="d106260e15818" headers="d106260e15762 ">
                                    <p><a href="thread-management-functions.html#GUID-DA9EA87A-19A5-4D8F-BACB-7E7502787825" title="创建一个键。">OCIThreadKeyInit（）</a></p>
                                 </td>
                                 <td align="left" valign="top" width="65%" headers="d106260e15818 d106260e15765 ">
                                    <p>分配并生成新密钥</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="35%" id="d106260e15830" headers="d106260e15762 ">
                                    <p><a href="thread-management-functions.html#GUID-7AF48B2F-FFF8-46A8-8D36-E84C62E58791" title="销毁并释放密钥指向的密钥。">OCIThreadKeyDestroy（）</a></p>
                                 </td>
                                 <td align="left" valign="top" width="65%" headers="d106260e15830 d106260e15765 ">
                                    <p>销毁并取消分配密钥</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="35%" id="d106260e15845" headers="d106260e15762 ">
                                    <p><a href="thread-management-functions.html#GUID-28097F63-B1FB-45D7-BE66-5C567B1395DD" title="获取调用线程的键的当前值。">OCIThreadKeyGet（）</a></p>
                                 </td>
                                 <td align="left" valign="top" width="65%" headers="d106260e15845 d106260e15765 ">
                                    <p>获取调用线程的键的当前值</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="35%" id="d106260e15857" headers="d106260e15762 ">
                                    <p><a href="thread-management-functions.html#GUID-1F70DBC5-AAC8-427D-A68B-B6903D1B215E" title="设置键的调用线程值。">OCIThreadKeySet（）</a></p>
                                 </td>
                                 <td align="left" valign="top" width="65%" headers="d106260e15857 d106260e15765 ">
                                    <p>设置键的调用线程值</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="35%" id="d106260e15869" headers="d106260e15762 ">
                                    <p><a href="thread-management-functions.html#GUID-E6695C5A-DC79-42D7-936A-F2D0441139F2" title="分配并初始化线程ID tid。">OCIThreadIdInit（）</a></p>
                                 </td>
                                 <td align="left" valign="top" width="65%" headers="d106260e15869 d106260e15765 ">
                                    <p>分配并初始化线程ID</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="35%" id="d106260e15884" headers="d106260e15762 ">
                                    <p><a href="thread-management-functions.html#GUID-B9999844-44F2-4631-AEEA-B4BBA183C4AA" title="销毁并释放线程ID。">OCIThreadIdDestroy（）</a></p>
                                 </td>
                                 <td align="left" valign="top" width="65%" headers="d106260e15884 d106260e15765 ">
                                    <p>销毁并释放线程ID</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="35%" id="d106260e15896" headers="d106260e15762 ">
                                    <p><a href="thread-management-functions.html#GUID-0AE9F3AC-C8D8-438D-932B-2A5AF1BCB570" title="将一个OCIThreadId设置为另一个。">OCIThreadIdSet（）</a></p>
                                 </td>
                                 <td align="left" valign="top" width="65%" headers="d106260e15896 d106260e15765 ">
                                    <p>将一个线程ID设置为另一个</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="35%" id="d106260e15912" headers="d106260e15762 ">
                                    <p><a href="thread-management-functions.html#GUID-3229209A-999B-4D08-A454-3C6200FD3DBE" title="将NULL线程ID设置为给定的OCIThreadId。">OCIThreadIdSetNull（）</a></p>
                                 </td>
                                 <td align="left" valign="top" width="65%" headers="d106260e15912 d106260e15765 ">
                                    <p>Nulls一个线程ID</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="35%" id="d106260e15930" headers="d106260e15762 ">
                                    <p><a href="thread-management-functions.html#GUID-9D60F215-4E65-4533-B926-DD4D73C35CE7" title="检索调用它的线程的OCIThreadId。">OCIThreadIdGet（）</a></p>
                                 </td>
                                 <td align="left" valign="top" width="65%" headers="d106260e15930 d106260e15765 ">
                                    <p>检索调用它的线程的线程ID</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="35%" id="d106260e15945" headers="d106260e15762 ">
                                    <p><a href="thread-management-functions.html#GUID-6C5A2E82-05E8-48D6-872F-1F4D453943D6" title="确定两个OCIThreadIds是否表示相同的线程。">OCIThreadIdSame（）</a></p>
                                 </td>
                                 <td align="left" valign="top" width="65%" headers="d106260e15945 d106260e15765 ">
                                    <p>确定两个线程ID是否表示相同的线程</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="35%" id="d106260e15960" headers="d106260e15762 ">
                                    <p><a href="thread-management-functions.html#GUID-1E466BF0-506A-42F0-A110-44F1484C1537" title="确定给定的OCIThreadId是否为NULL线程ID。">OCIThreadIdNull（）</a></p>
                                 </td>
                                 <td align="left" valign="top" width="65%" headers="d106260e15960 d106260e15765 ">
                                    <p>确定线程ID是否为<code class="codeph">NULL</code></p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <div class="section">
                        <div class="p">本节包括以下主题：<ul style="list-style-type:disc">
                              <li>
                                 <p><a href="managing-scalable-platforms.html#GUID-5470400F-35D3-464B-8C9A-7C192F62F4B7" title="OCIThreadMutex数据类型用于表示互斥锁。">OCIThreadMutex</a></p>
                              </li>
                              <li>
                                 <p><a href="managing-scalable-platforms.html#GUID-2446894A-9B59-4CC0-A969-FE9C16EF1AEE" title="数据类型OCIThreadKey可以被视为具有特定于线程的值的进程范围变量。">OCIThreadKey</a></p>
                              </li>
                              <li>
                                 <p><a href="managing-scalable-platforms.html#GUID-349E94ED-D50C-43BC-8964-00B330375BC0" title="OCIThreadKeyDestFunc是指向键的析构函数例程的指针类型。">OCIThreadKeyDestFunc</a></p>
                              </li>
                              <li>
                                 <p><a href="managing-scalable-platforms.html#GUID-8F0A4417-7196-4AAD-910B-739E8A608321" title="OCIThreadId数据类型用于标识线程。">OCIThreadId</a></p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div><a id="LNOCI16595"></a><div class="props_rev_3"><a id="GUID-5470400F-35D3-464B-8C9A-7C192F62F4B7" name="GUID-5470400F-35D3-464B-8C9A-7C192F62F4B7"></a><h5 id="LNOCI-GUID-5470400F-35D3-464B-8C9A-7C192F62F4B7" class="sect5"><span class="enumeration_section">10.10.2.1</span> OCIThreadMutex</h5>
                     <div>
                        <p><code class="codeph">OCIThreadMutex</code>数据类型用于表示互斥锁。
                        </p>
                        <p>此互斥锁用于确保：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>一次只有一个线程访问给定的数据集</p>
                           </li>
                           <li>
                              <p>一次只有一个线程执行给定的关键代码段</p>
                           </li>
                        </ul>
                        <p>互斥指针可以声明为客户端结构的一部分或独立变量。在使用它们之前，必须使用<code class="codeph">OCIThreadMutexInit()</code>初始化它们。一旦不再需要它们，就必须使用<code class="codeph">OCIThreadMutexDestroy()</code>销毁它们。
                        </p>
                        <p>线程可以使用<code class="codeph">OCIThreadMutexAcquire()</code>获取互斥锁。这确保了一次只允许一个线程持有给定的互斥锁。包含互斥锁的线程可以通过调用<code class="codeph">OCIThreadMutexRelease()</code>来释放它。
                        </p>
                        <div class="infoboxnotealso" id="GUID-5470400F-35D3-464B-8C9A-7C192F62F4B7__GUID-571F6387-9168-4D79-B5A9-BF998B42764A">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><a href="thread-management-functions.html#GUID-C7D25B80-DFD4-4C67-9624-0ED40F69F518" title="分配并初始化互斥锁。">OCIThreadMutexInit（）</a></p>
                              </li>
                              <li>
                                 <p><a href="thread-management-functions.html#GUID-CDC1183C-006E-4F09-8BCB-CA079774B56C" title="销毁和释放互斥锁。">OCIThreadMutexDestroy（）</a></p>
                              </li>
                              <li>
                                 <p><a href="thread-management-functions.html#GUID-BE59FB94-FF0F-4A2C-80CC-2DE6F2586517" title="获取调用它的线程的互斥锁。">OCIThreadMutexAcquire（）</a></p>
                              </li>
                              <li>
                                 <p><a href="thread-management-functions.html#GUID-B1B2121E-A22D-40B6-984B-B9A129D353DE" title="释放互斥锁。">OCIThreadMutexRelease（）</a></p>
                              </li>
                           </ul>
                        </div>
                     </div>
                  </div><a id="LNOCI16596"></a><div class="props_rev_3"><a id="GUID-2446894A-9B59-4CC0-A969-FE9C16EF1AEE" name="GUID-2446894A-9B59-4CC0-A969-FE9C16EF1AEE"></a><h5 id="LNOCI-GUID-2446894A-9B59-4CC0-A969-FE9C16EF1AEE" class="sect5"><span class="enumeration_section">10.10.2.2</span> OCIThreadKey</h5>
                     <div>
                        <p>数据类型<code class="codeph">OCIThreadKey</code>可以被视为具有特定于线程的值的进程范围变量。
                        </p>
                        <p>因此，进程中的所有线程都可以使用给定的密钥，但每个线程可以独立于其他线程检查或修改该密钥。线程在检查密钥时看到的值始终与它最后为密钥设置的值相同。它没有看到其他线程为该键设置的任何值。键持有的值的数据类型是<code class="codeph">void *</code>泛型指针。
                        </p>
                        <p>可以使用<code class="codeph">OCIThreadKeyInit()</code>创建密钥。所有线程的键值都初始化为<code class="codeph">NULL</code> 。
                        </p>
                        <p>线程可以使用<code class="codeph">OCIThreadKeySet()</code>设置键的值。线程可以使用<code class="codeph">OCIThreadKeyGet()</code>获取密钥的值。
                        </p>
                        <p><code class="codeph">OCIThread</code>键函数保存和检索特定于线程的数据。当客户端维护一个线程池并将它们分配给不同的任务时，任务可能不适合使用<code class="codeph">OCIThread</code>键功能来保存与之关联的数据。
                        </p>
                        <p>这是一个事情如何失败的场景：分配一个线程来执行任务的初始化。在初始化期间，任务使用<code class="codeph">OCIThread</code>键功能将数据存储在线程中。初始化后，线程返回到线程池。稍后，线程池管理器分配另一个线程以对该任务执行某些操作，并且该任务必须在初始化时检索它先前存储的数据。由于任务在另一个线程中运行，因此无法检索相同的数据。使用线程池的应用程序开发人员必须意识到这一点。
                        </p>
                        <div class="infoboxnotealso" id="GUID-2446894A-9B59-4CC0-A969-FE9C16EF1AEE__GUID-7422B2D5-AC81-434D-8107-C79D7DB17473">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><a href="thread-management-functions.html#GUID-DA9EA87A-19A5-4D8F-BACB-7E7502787825" title="创建一个键。">OCIThreadKeyInit（）</a></p>
                              </li>
                              <li>
                                 <p><a href="thread-management-functions.html#GUID-1F70DBC5-AAC8-427D-A68B-B6903D1B215E" title="设置键的调用线程值。">OCIThreadKeySet（）</a></p>
                              </li>
                              <li>
                                 <p><a href="thread-management-functions.html#GUID-28097F63-B1FB-45D7-BE66-5C567B1395DD" title="获取调用线程的键的当前值。">OCIThreadKeyGet（）</a></p>
                              </li>
                           </ul>
                        </div>
                     </div>
                  </div><a id="LNOCI16597"></a><div class="props_rev_3"><a id="GUID-349E94ED-D50C-43BC-8964-00B330375BC0" name="GUID-349E94ED-D50C-43BC-8964-00B330375BC0"></a><h5 id="LNOCI-GUID-349E94ED-D50C-43BC-8964-00B330375BC0" class="sect5"><span class="enumeration_section">10.10.2.3</span> OCIThreadKeyDestFunc</h5>
                     <div>
                        <p><code class="codeph">OCIThreadKeyDestFunc</code>是指向键的析构函数例程的指针类型。
                        </p>
                        <p>当使用<code class="codeph">OCIThreadKeyInit()</code>创建密钥时，密钥可以与析构函数例程相关联。只要具有非<code class="codeph">NULL</code>值的线程终止，就会调用密钥的析构函数例程。析构函数例程不返回任何内容并且接受一个参数，即线程终止时为key设置的值。
                        </p>
                        <p>在线程终止之后和进程终止之前，保证析构函数例程在键中的线程值上被调用。对于析构函数例程调用的时间安排，不能做出更精确的保证;该过程中的任何代码都不能假设析构函数例程的任何后置条件。特别是，在终止线程的连接调用返回之前，不保证析构函数执行。</p>
                        <div class="infoboxnotealso" id="GUID-349E94ED-D50C-43BC-8964-00B330375BC0__GUID-2C575F7F-1F01-4B2D-B905-4C533A585287">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="thread-management-functions.html#GUID-DA9EA87A-19A5-4D8F-BACB-7E7502787825" title="创建一个键。">OCIThreadKeyInit（）</a></p>
                        </div>
                     </div>
                  </div><a id="LNOCI16598"></a><div class="props_rev_3"><a id="GUID-8F0A4417-7196-4AAD-910B-739E8A608321" name="GUID-8F0A4417-7196-4AAD-910B-739E8A608321"></a><h5 id="LNOCI-GUID-8F0A4417-7196-4AAD-910B-739E8A608321" class="sect5"><span class="enumeration_section">10.10.2.4</span> OCIThreadId</h5>
                     <div>
                        <p><code class="codeph">OCIThreadId</code>数据类型用于标识线程。
                        </p>
                        <p>在任何给定的时间，没有两个线程可以具有相同的<code class="codeph">OCIThreadId</code> ，但<code class="codeph">OCIThreadId</code>值可以被回收;线程死后，可能会创建一个具有相同<code class="codeph">OCIThreadId</code>值的新线程。特别是，线程ID必须唯一地标识进程内的线程<code class="codeph">T</code> ，并且它必须在进程的所有线程<code class="codeph">U</code>中保持一致且有效，可以保证<code class="codeph">T</code>与<code class="codeph">U</code>同时运行。线程<code class="codeph">T</code>的线程ID必须在线程<code class="codeph">T</code>可检索。这是使用<code class="codeph">OCIThreadIdGet()</code> 。
                        </p>
                        <p><code class="codeph">OCIThreadId</code>类型支持<code class="codeph">NULL</code>线程ID的概念： <code class="codeph">NULL</code>线程ID永远不能与实际线程的ID相同。
                        </p>
                        <div class="infoboxnotealso" id="GUID-8F0A4417-7196-4AAD-910B-739E8A608321__GUID-D1D45893-F96A-47E7-B998-5D5F74123EC4">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="thread-management-functions.html#GUID-9D60F215-4E65-4533-B926-DD4D73C35CE7" title="检索调用它的线程的OCIThreadId。">OCIThreadIdGet（）</a></p>
                        </div>
                     </div>
                  </div>
               </div><a id="LNOCI16600"></a><a id="LNOCI16599"></a><div class="props_rev_3"><a id="GUID-A80A28BF-5AFF-49FA-825D-DB43CAA16B8A" name="GUID-A80A28BF-5AFF-49FA-825D-DB43CAA16B8A"></a><h4 id="LNOCI-GUID-A80A28BF-5AFF-49FA-825D-DB43CAA16B8A" class="sect4"><span class="enumeration_section">10.10.3</span>主动线程基元</h4>
                  <div>
                     <p>列出活动线程基元，它处理实际线程的操作。</p>
                     <p>由于大多数这些原语的规范需要多个线程，因此它们仅在启用的<code class="codeph">OCIThread</code>正常工作。在禁用的<code class="codeph">OCIThread</code> ，它们总是返回错误。<code class="codeph">OCIThreadHandleGet()</code> ;它可以在单线程环境中调用，但不起作用。
                     </p>
                     <p>活动基元只能由在多线程环境中运行的代码调用。您可以调用<code class="codeph">OCIThreadIsMulti()</code>来确定环境是多线程还是单线程。<a href="managing-scalable-platforms.html#GUID-A80A28BF-5AFF-49FA-825D-DB43CAA16B8A__G473467" title="该表有2列。第1列是函数名称，第2列描述其用途。">表10-8</a>列出了用于实现活动线程的函数。
                     </p>
                     <div class="tblformal" id="GUID-A80A28BF-5AFF-49FA-825D-DB43CAA16B8A__G473467">
                        <p class="titleintable">表10-8主动线程基元</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="主动线程基元" width="100%" border="1" summary="This table has 2 columns. Column 1 is the function name and column 2 describes its purpose." frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="45%" id="d106260e17181">功能</th>
                                 <th align="left" valign="bottom" width="55%" id="d106260e17184">目的</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="45%" id="d106260e17189" headers="d106260e17181 ">
                                    <p><a href="thread-management-functions.html#GUID-1D3F6256-B071-436D-B6D6-5C34AF691304" title="分配并初始化线程句柄。">OCIThreadHndInit（）</a></p>
                                 </td>
                                 <td align="left" valign="top" width="55%" headers="d106260e17189 d106260e17184 ">
                                    <p>分配并初始化线程句柄</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="45%" id="d106260e17201" headers="d106260e17181 ">
                                    <p><a href="thread-management-functions.html#GUID-4D18C196-37FA-4A98-812D-6DDB09478BAF" title="销毁并释放线程句柄。">OCIThreadHndDestroy（）</a></p>
                                 </td>
                                 <td align="left" valign="top" width="55%" headers="d106260e17201 d106260e17184 ">
                                    <p>销毁并释放线程句柄</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="45%" id="d106260e17213" headers="d106260e17181 ">
                                    <p><a href="thread-management-functions.html#GUID-1F526093-3270-4899-9284-D807854694CE" title="创建一个新线程。">OCIThreadCreate（）</a></p>
                                 </td>
                                 <td align="left" valign="top" width="55%" headers="d106260e17213 d106260e17184 ">
                                    <p>创建一个新线程</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="45%" id="d106260e17225" headers="d106260e17181 ">
                                    <p><a href="thread-management-functions.html#GUID-3065242A-47F0-48EB-A124-96CF95E89254" title="允许调用线程与另一个线程连接。">OCIThreadJoin（）</a></p>
                                 </td>
                                 <td align="left" valign="top" width="55%" headers="d106260e17225 d106260e17184 ">
                                    <p>允许调用线程与另一个线程连接</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="45%" id="d106260e17237" headers="d106260e17181 ">
                                    <p><a href="thread-management-functions.html#GUID-E461E3CB-5F38-4F50-B822-681065D18822" title="关闭一个线程句柄。">OCIThreadClose（）</a></p>
                                 </td>
                                 <td align="left" valign="top" width="55%" headers="d106260e17237 d106260e17184 ">
                                    <p>关闭一个线程句柄</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="45%" id="d106260e17249" headers="d106260e17181 ">
                                    <p><a href="thread-management-functions.html#GUID-6CAE9E6B-4402-4038-A5FD-4B7A485E96DD" title="检索调用它的线程的OCIThreadHandle。">OCIThreadHandleGet（）</a></p>
                                 </td>
                                 <td align="left" valign="top" width="55%" headers="d106260e17249 d106260e17184 ">
                                    <p>检索线程句柄</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <p>本节包括以下主题： <a href="managing-scalable-platforms.html#GUID-E7BA1A77-6643-4CAE-81C3-CCB21556554C" title="数据类型OCIThreadHandle用于操作活动基元中的线程，OCIThreadJoin（）和OCIThreadClose（）。">OCIThreadHandle</a> 。
                     </p>
                     <div class="infoboxnotealso" id="GUID-A80A28BF-5AFF-49FA-825D-DB43CAA16B8A__GUID-D8D10F29-BDBE-473D-B663-72E9B40FE7CA">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="thread-management-functions.html#GUID-D36F5FBC-56DA-4365-92E4-3B6B78F75F09" title="告诉调用者应用程序是在多线程环境还是单线程环境中运行。">OCIThreadIsMulti（）</a></p>
                     </div>
                  </div><a id="LNOCI16601"></a><div class="props_rev_3"><a id="GUID-E7BA1A77-6643-4CAE-81C3-CCB21556554C" name="GUID-E7BA1A77-6643-4CAE-81C3-CCB21556554C"></a><h5 id="LNOCI-GUID-E7BA1A77-6643-4CAE-81C3-CCB21556554C" class="sect5"><span class="enumeration_section">10.10.3.1</span> OCIThreadHandle</h5>
                     <div>
                        <p>数据类型<code class="codeph">OCIThreadHandle</code>用于操作活动基元中的线程， <code class="codeph">OCIThreadJoin()</code>和<code class="codeph">OCIThreadClose()</code> 。
                        </p>
                        <p>必须在对<code class="codeph">OCIThreadClose()</code>的匹配调用中关闭<code class="codeph">OCIThreadCreate()</code>打开的线程句柄。调用<code class="codeph">OCIThreadClose()</code>后，线程句柄无效。
                        </p>
                        <div class="infoboxnotealso" id="GUID-E7BA1A77-6643-4CAE-81C3-CCB21556554C__GUID-A64CEF6D-21CF-4F88-9B4A-392E354DD7A2">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><a href="thread-management-functions.html#GUID-3065242A-47F0-48EB-A124-96CF95E89254" title="允许调用线程与另一个线程连接。">OCIThreadJoin（）</a></p>
                              </li>
                              <li>
                                 <p><a href="thread-management-functions.html#GUID-E461E3CB-5F38-4F50-B822-681065D18822" title="关闭一个线程句柄。">OCIThreadClose（）</a></p>
                              </li>
                              <li>
                                 <p><a href="thread-management-functions.html#GUID-1F526093-3270-4899-9284-D807854694CE" title="创建一个新线程。">OCIThreadCreate（）</a></p>
                              </li>
                           </ul>
                        </div>
                     </div>
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>