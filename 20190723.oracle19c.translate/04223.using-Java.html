<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html xml:lang="en-us" lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <title>About Using Java in Oracle Database</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="Java Developer's Guide ">
      <meta property="og:description" content>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="Java Developer's Guide">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="java-developers-guide.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2019-01-11T00:55:24-08:00">
      
      <meta name="dcterms.dateCopyrighted" content="1999, 2019">
      <meta name="dcterms.category" content="database">
      <meta name="dcterms.identifier" content="E96468-01">
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19">
      
      <link rel="prev" href="Java-overview.html" title="Previous" type="text/html">
      <link rel="next" href="Oracle-JVM-overview.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Java Developer's Guide">
    <meta name="dcterms.isVersionOf" content="JJDEV">
    <meta name="dcterms.release" content="Release 19">
  </head>
   <body>
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="Java-overview.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>Previous</a>
         <a href="Oracle-JVM-overview.html" class="pull-right">Next<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a>
         <span class="fa fa-exclamation-triangle" aria-hidden="true"></span> JavaScript must be enabled to correctly display this content
        
      </div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">Java Developer's Guide </span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="Java-introduction.html" property="item" typeof="WebPage"><span property="name"> Introduction to Java in Oracle Database </span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">About Using Java in Oracle Database</li>
            </ol>
            <a id="GUID-740E7303-60E4-4DFF-9370-3AEEFEE8E394" name="GUID-740E7303-60E4-4DFF-9370-3AEEFEE8E394"></a><a id="JJDEV01200"></a>
            
            <h2 id="JJDEV-GUID-740E7303-60E4-4DFF-9370-3AEEFEE8E394" class="sect2"><span class="enumeration_section">1.2 </span>About Using Java in Oracle Database
            </h2>
         </header>
         <div class="ind">
            <div>
               <p>You can write and load Java applications within the database because it is a safe language with a lot of security features. Java has been developed to prevent anyone from tampering with the operating system where the Java code resides in. Some languages, such as C, can introduce security problems within the database. However, Java, because of its design, is a robust language that can be used within the database.</p>
               <p>Although the Java language presents many advantages to developers, providing an implementation of a JVM that supports Java server applications in a scalable manner is a challenge. This section discusses the following challenges:</p>
               <ul style="list-style-type: disc;">
                  <li>
                     <p><a href="using-Java.html#GUID-9420C7BA-8EBF-4804-9C01-C4F6C089FDCA">Java and RDBMS: A Robust Combination</a></p>
                  </li>
                  <li>
                     <p><a href="using-Java.html#GUID-F7932DDD-EE2E-43BA-9F72-8C1C8903AF58">About Multithreading</a></p>
                  </li>
                  <li>
                     <p><a href="using-Java.html#GUID-1A6572CA-4057-467A-AAB3-A4F5EF8D31C5">Memory Spaces Management</a></p>
                  </li>
                  <li>
                     <p><a href="using-Java.html#GUID-B429EC9B-D0E8-4D31-ADCF-D4B69CE55A48">Footprint</a></p>
                  </li>
                  <li>
                     <p><a href="using-Java.html#GUID-9774A951-CCBC-4F1F-90C1-5C386E01B5FE">Performance of an Oracle JVM</a></p>
                  </li>
                  <li>
                     <p><a href="using-Java.html#GUID-7044909A-7ACF-408E-A87F-94635937D2FB">Dynamic Class Loading</a></p>
                  </li>
               </ul>
            </div><a id="JJDEV13022"></a><a id="JJDEV13021"></a><div class="props_rev_3"><a id="GUID-9420C7BA-8EBF-4804-9C01-C4F6C089FDCA" name="GUID-9420C7BA-8EBF-4804-9C01-C4F6C089FDCA"></a><h3 id="JJDEV-GUID-9420C7BA-8EBF-4804-9C01-C4F6C089FDCA" class="sect3"><span class="enumeration_section">1.2.1 </span>Java and RDBMS: A Robust Combination
               </h3>
               <div>
                  <p>Oracle Database provides Java applications with a dynamic data-processing engine that supports complex queries and different views of the same data. All client requests are assembled as data queries for immediate processing, and query results are generated dynamically.</p>
                  <p>The combination of Java and Oracle Database helps you to create component-based, network-centric applications that can be easily updated as business needs change. In addition, you can move applications and data stores off the desktop and onto intelligent networks and network-centric servers. More important, you can access those applications and data stores from any client device.</p>
                  <p><a id="d4670e219" class="indexterm-anchor"></a><a href="using-Java.html#GUID-9420C7BA-8EBF-4804-9C01-C4F6C089FDCA__BABBHGJB">Figure 1-5</a> shows a traditional two-tier, client/server configuration in which clients call Java stored procedures the same way they call PL/SQL stored procedures. The figure also shows how Oracle Net Services Connection Manager can combine many network connections into a single database connection. This enables Oracle Database to support a large number of concurrent users.
                  </p>
                  <div class="figure" id="GUID-9420C7BA-8EBF-4804-9C01-C4F6C089FDCA__BABBHGJB">
                     <p class="titleinfigure">Figure 1-5 Two-Tier Client/Server Configuration</p><img src="img/two_tier_config.gif" alt="Description of Figure 1-5 follows" title="Description of Figure 1-5 follows" longdesc="img_text/two_tier_config.html"><br><a href="img_text/two_tier_config.html">Description of "Figure 1-5 Two-Tier Client/Server Configuration"</a></div>
                  <!-- class="figure" -->
               </div>
            </div><a id="JJDEV13023"></a><div class="props_rev_3"><a id="GUID-F7932DDD-EE2E-43BA-9F72-8C1C8903AF58" name="GUID-F7932DDD-EE2E-43BA-9F72-8C1C8903AF58"></a><h3 id="JJDEV-GUID-F7932DDD-EE2E-43BA-9F72-8C1C8903AF58" class="sect3"><span class="enumeration_section">1.2.2 </span>About Multithreading
               </h3>
               <div>
                  <p>Multithreading is one of the key scalability features of the Java language. The Java language and class libraries make it simpler to write multithreaded applications in Java than many other languages, but it is still a daunting task in any language to write reliable, scalable multithreaded code.</p>
                  <p>Oracle Database server efficiently schedules work for thousands of users. The Oracle JVM takes advantage of the session architecture of Oracle database to concurrently run Java applications for hundreds to thousands of users. Although Oracle Database supports Java language-level threads required by the JLS and JCK, scalability will not increase by using threads within the scope of the database. By using the embedded scalability of the database, the need for writing multithreaded Java servers is eliminated.</p>
                  <p>You should use the facilities of Oracle Database for scheduling users by writing single-threaded Java applications. The database can schedule processes between each application, and thus, you achieve scalability without having to manage threads. You can still write multithreaded Java applications, but multiple Java threads will not increase the performance of the server.</p>
                  <p><a id="d4670e334" class="indexterm-anchor"></a>One complication multithreading creates is the interaction of threads and automated storage management or garbage collection. The garbage collector running in a generic JVM has no knowledge of which Java language threads are running or how the underlying operating system schedules them. The difference between a non-Oracle Database model and an Oracle JVM model is as follows:
                  </p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>Non-Oracle Database model</p>
                        <p>A single user maps to a single Java thread and a single garbage collector manages all garbage from all users. Different techniques typically deal with allocation and collection of objects of varying lifetimes and sizes. The result in a heavily multithreaded application is, at best, dependent upon operating system support for native threads, which can be unreliable and limited in scalability. High levels of scalability for such implementations have not been convincingly demonstrated.</p>
                     </li>
                     <li>
                        <p>Oracle JVM model</p>
                        <p>Even when thousands of users connect to the server and run the same Java code, each user experiences it as if he or she is running his or her own Java code on his or her own JVM. The responsibility of an Oracle JVM is to make use of operating system processes and threads and the scalable approach of Oracle Database. As a result of this approach, the garbage collector of the Oracle JVM is more reliable and efficient because it never collects garbage from more than one user at any time.</p>
                        <div class="infoboxnotealso" id="GUID-F7932DDD-EE2E-43BA-9F72-8C1C8903AF58__GUID-D371303F-0127-4E92-95F3-4BD2A57D917F">
                           <p class="notep1">See Also:</p>
                           <p><span class="q">"<a href="threading-in-database.html#GUID-7A51D651-181B-405D-BD98-F74037496902">Overview of Threading in Oracle Database</a>"</span></p>
                        </div>
                     </li>
                  </ul>
               </div>
            </div><a id="JJDEV13025"></a><a id="JJDEV13024"></a><div class="props_rev_3"><a id="GUID-1A6572CA-4057-467A-AAB3-A4F5EF8D31C5" name="GUID-1A6572CA-4057-467A-AAB3-A4F5EF8D31C5"></a><h3 id="JJDEV-GUID-1A6572CA-4057-467A-AAB3-A4F5EF8D31C5" class="sect3"><span class="enumeration_section">1.2.3 </span>Memory Spaces Management
               </h3>
               <div>
                  <p><a id="d4670e450" class="indexterm-anchor"></a>Garbage collection is a major function of the automated storage management feature of Java, eliminating the need for Java developers to allocate and free memory explicitly. Consequently, this eliminates a large source of memory leaks that are commonly found in C and C++ programs. However, garbage collection contributes to the overhead of program execution speed and footprint.
                  </p>
                  <p>Garbage collection imposes a challenge to the JVM developer seeking to supply a highly scalable and fast Java platform. An Oracle JVM meets these challenges in the following ways:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>The Oracle JVM uses Oracle Database scheduling facilities, which can manage multiple users efficiently.</p>
                     </li>
                     <li>
                        <p>Garbage collection is performed consistently for multiple users, because garbage collection is focused on a single user within a single session. The Oracle JVM has an advantage, because the burden and complexity of the job of the memory manager does not increase as the number of users increases. The memory manager performs the allocation and collection of objects within a single session, which typically translates to the activity of a single user.</p>
                     </li>
                     <li>
                        <p>The Oracle JVM uses different garbage collection techniques depending on the type of memory used. These techniques provide high efficiency and low overhead.</p>
                     </li>
                  </ul>
                  <p>The two types of memory space are call space and session space.</p>
                  <div class="tblformal" id="GUID-1A6572CA-4057-467A-AAB3-A4F5EF8D31C5__GUID-16E037CE-6C93-4B32-ADC0-229669A24801">
                     <table cellpadding="4" cellspacing="0" class="Formal" title summary="table" width="100%" frame="hsides" border="1" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="24%" id="d4670e477">Memory space</th>
                              <th align="left" valign="bottom" width="76%" id="d4670e480">Description</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="24%" id="d4670e485" headers="d4670e477 ">
                                 <p>Call space</p>
                              </td>
                              <td align="left" valign="top" width="76%" headers="d4670e485 d4670e480 ">
                                 <p>It is a fast and inexpensive type of memory. It primarily exists for the length of a call. Call memory space is divided into new and old segments. All new objects are created within new memory. Objects that have survived several scavenges are moved into old memory.</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="24%" id="d4670e492" headers="d4670e477 ">
                                 <p>Session space</p>
                              </td>
                              <td align="left" valign="top" width="76%" headers="d4670e492 d4670e480 ">
                                 <p>It is an expensive, performance-wise memory. It primarily exists for the length of a session. All <code class="codeph">static</code> fields and any objects that exist beyond the lifetime of a call exist here.
                                 </p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
                  <p><a href="using-Java.html#GUID-1A6572CA-4057-467A-AAB3-A4F5EF8D31C5__BABDGIDI">Figure 1-6</a> illustrates the different actions performed by the garbage collector.
                  </p>
                  <div class="figure" id="GUID-1A6572CA-4057-467A-AAB3-A4F5EF8D31C5__BABDGIDI">
                     <p class="titleinfigure">Figure 1-6 Garbage Collection</p><img src="img/entapa_02.gif" alt="Description of Figure 1-6 follows" title="Description of Figure 1-6 follows" longdesc="img_text/entapa_02.html"><br><a href="img_text/entapa_02.html">Description of "Figure 1-6 Garbage Collection"</a></div>
                  <!-- class="figure" -->
                  <p>Garbage collection algorithms within an Oracle JVM adhere to the following rules:</p>
                  <ol>
                     <li>
                        <p>New objects are created within a new call space.</p>
                     </li>
                     <li>
                        <p>Scavenging occurs at a set interval. Some programmers create objects frequently for only a short duration. These types of objects are created and garbage-collected quickly within the new call space. This is known as <span class="bold">scavenging</span>.
                        </p>
                     </li>
                     <li>
                        <p>Any objects that have survived several iterations of scavenging are considered to be objects that can exist for a while. These objects are moved out of new call space into old call space. During the move, they are also compacted. Old call space is scavenged or garbage collected less often and, therefore, provides better performance.</p>
                     </li>
                     <li>
                        <p>At the end of the call, any objects that are to exist beyond the call are moved into session space.</p>
                     </li>
                  </ol>
                  <p><a href="using-Java.html#GUID-1A6572CA-4057-467A-AAB3-A4F5EF8D31C5__BABDGIDI">Figure 1-6</a> illustrates the steps listed in the preceding text. This approach applies sophisticated allocation and collection schemes tuned to the types and lifetimes of objects. For example, new objects are allocated in fast and inexpensive call memory, designed for quick allocation and access. Objects held in Java <code class="codeph">static</code> fields are migrated to the more precious and expensive session space.
                  </p>
               </div>
            </div><a id="JJDEV13026"></a><div class="props_rev_3"><a id="GUID-B429EC9B-D0E8-4D31-ADCF-D4B69CE55A48" name="GUID-B429EC9B-D0E8-4D31-ADCF-D4B69CE55A48"></a><h3 id="JJDEV-GUID-B429EC9B-D0E8-4D31-ADCF-D4B69CE55A48" class="sect3"><span class="enumeration_section">1.2.4 </span>Footprint
               </h3>
               <div>
                  <p>The footprint of a running Java program is affected by many factors:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>Size of the program</p>
                        <p>The size of the program depends on the number of classes and methods and how much code they contain.</p>
                     </li>
                     <li>
                        <p>Complexity of the program</p>
                        <p>The complexity of the program depends on the number of core class libraries that the Oracle JVM uses as the program runs, as opposed to the program itself.</p>
                     </li>
                     <li>
                        <p>Amount of space the JVM uses</p>
                        <p>The amount of space the JVM uses depends on the number of objects the JVM allocates, how large these objects are, and how many objects must be retained across calls.</p>
                     </li>
                     <li>
                        <p>Ability of the garbage collector and memory manager to deal with the demands of the program running</p>
                        <p>This can not be determined often. The speed with which objects are allocated and the way they are held on to by other objects influences the importance of this factor.</p>
                     </li>
                  </ul>
                  <p>From a scalability perspective, the key to supporting multiple clients concurrently is a minimum per-user session footprint. The Oracle JVM keeps the per-user session footprint to a minimum by placing all read-only data for users, such as Java bytecodes, in shared memory. Appropriate garbage collection algorithms are applied against call and session memories to maintain a small footprint for the user's session. The Oracle JVM uses the following types of garbage collection algorithms to maintain the user's session memory:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>Generational scavenging for short-lived objects</p>
                     </li>
                     <li>
                        <p>Mark and lazy sweep collection for objects that exist for the life of a single call</p>
                     </li>
                     <li>
                        <p>Copying collector for long-lived objects, that is, objects that live across calls within a session</p>
                     </li>
                  </ul>
               </div>
            </div><a id="JJDEV13028"></a><a id="JJDEV13027"></a><div class="props_rev_3"><a id="GUID-9774A951-CCBC-4F1F-90C1-5C386E01B5FE" name="GUID-9774A951-CCBC-4F1F-90C1-5C386E01B5FE"></a><h3 id="JJDEV-GUID-9774A951-CCBC-4F1F-90C1-5C386E01B5FE" class="sect3"><span class="enumeration_section">1.2.5 </span>Performance of an Oracle JVM
               </h3>
               <div>
                  <p>The <a id="d4670e749" class="indexterm-anchor"></a><a id="d4670e753" class="indexterm-anchor"></a>performance of an Oracle JVM is enhanced by the embedding of an innovative Just-In-Time compiler similar to HotSpot on standard JVM. The platform-independent Java bytecodes run on top of a JVM, and the JVM interacts with the specific hardware platform. Any time you add levels within software, the performance is degraded. Because Java requires going through an intermediary to interpret the bytecodes, a degree of inefficiency exists for Java applications as compared to applications developed using a platform-dependent language, such as C. To address this issue, several JVM suppliers create native compilers. Native compilers translate Java bytecodes into platform-dependent native code, which eliminates the interpreter step and improves performance.
                  </p>
                  <p><a id="d4670e759" class="indexterm-anchor"></a>The following table describes two methods for native compilation:
                  </p>
                  <div class="tblformal" id="GUID-9774A951-CCBC-4F1F-90C1-5C386E01B5FE__GUID-EE5F65F4-83F4-49C2-9664-B211A6A33D77">
                     <table cellpadding="4" cellspacing="0" class="Formal" title summary="table" width="100%" frame="hsides" border="1" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="21%" id="d4670e772">Compiler</th>
                              <th align="left" valign="bottom" width="79%" id="d4670e775">Description</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="21%" id="d4670e780" headers="d4670e772 ">
                                 <p>Just-In-Time (JIT) Compilation</p>
                              </td>
                              <td align="left" valign="top" width="79%" headers="d4670e780 d4670e775 ">
                                 <p>JIT compilers quickly compile Java bytecodes to platform-specific, or native, machine code during run time. These compilers do not produce an executable file to be run on the platform. Instead, they provide platform-dependent code from Java bytecodes that is run directly after it is translated. JIT compilers should be used for Java code that is run frequently and at speeds closer to that of code developed in other languages, such as C.</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="21%" id="d4670e787" headers="d4670e772 ">
                                 <p>Ahead-of-Time Compilation</p>
                              </td>
                              <td align="left" valign="top" width="79%" headers="d4670e787 d4670e775 ">
                                 <p>This compilation translates Java bytecodes to platform-independent C code before run time. Then a standard C compiler compiles the C code into an executable file for the target platform. This approach is more suitable for Java applications that are not modified frequently. This approach takes advantage of the mature and efficient platform-specific compilation technology found in modern C compilers.</p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
                  <p>Oracle Database uses Just-In-Time (JIT) compilation to deliver its core Java class libraries, such as JDBC code, in natively compiled form. The JIT compiler is enabled without the support of any plug-ins and it is applicable across all the platforms that Oracle supports.</p>
                  <p>The following figure illustrates how natively compiled code runs up to 10 times faster than interpreted code. As a result, the more native code your program uses, the faster it runs.</p>
                  <div class="figure" id="GUID-9774A951-CCBC-4F1F-90C1-5C386E01B5FE__BABJGGIA">
                     <p class="titleinfigure">Figure 1-7 Interpreter versus Accelerator</p><img src="img/interpreter_vs_accelerator.gif" alt="Description of Figure 1-7 follows" title="Description of Figure 1-7 follows" longdesc="img_text/interpreter_vs_accelerator.html"><br><a href="img_text/interpreter_vs_accelerator.html">Description of "Figure 1-7 Interpreter versus Accelerator"</a></div>
                  <!-- class="figure" -->
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>Related Topics</strong></p>
                     <ul>
                        <li><a href="Oracle-JVM-JIT.html#GUID-23D5BA60-A2B3-45F9-93DF-81A3D971CA50">Oracle JVM Just-in-Time Compiler (JIT)</a></li>
                     </ul>
                  </div>
               </div>
               
            </div><a id="JJDEV13029"></a><div class="props_rev_3"><a id="GUID-7044909A-7ACF-408E-A87F-94635937D2FB" name="GUID-7044909A-7ACF-408E-A87F-94635937D2FB"></a><h3 id="JJDEV-GUID-7044909A-7ACF-408E-A87F-94635937D2FB" class="sect3"><span class="enumeration_section">1.2.6 </span>Dynamic Class Loading
               </h3>
               <div>
                  <p>Another strong feature of Java is dynamic class loading. The class loader loads classes from the disk and places them in the JVM-specific memory structures necessary for interpretation. The class loader locates the classes in <code class="codeph">CLASSPATH</code> and loads them only when they are used while the program is running. This approach, which works well for applets, poses the following problems in a server environment:
                  </p>
                  <div class="tblformal" id="GUID-7044909A-7ACF-408E-A87F-94635937D2FB__GUID-D708E2FF-CC49-43E7-A1DA-B79426713784">
                     <table cellpadding="4" cellspacing="0" class="Formal" title summary="table" width="100%" frame="hsides" border="1" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="16%" id="d4670e923">Problem</th>
                              <th align="left" valign="bottom" width="41%" id="d4670e926">Description</th>
                              <th align="left" valign="bottom" width="43%" id="d4670e929">Solution</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="16%" id="d4670e934" headers="d4670e923 ">
                                 <p>Predictability</p>
                              </td>
                              <td align="left" valign="top" width="41%" headers="d4670e934 d4670e926 ">
                                 <p>The class loading operation places a severe penalty when the program is run for the first time. A simple program can cause an Oracle JVM to load many core classes to support its needs. A programmer cannot easily predict or determine the number of classes loaded.</p>
                              </td>
                              <td align="left" valign="top" width="43%" headers="d4670e934 d4670e929 ">
                                 <p>The Oracle JVM loads classes dynamically, just as with any other JVM. The same one-time class loading speed hit is encountered. However, because the classes are loaded into shared memory, no other users of those classes will cause the classes to load again, and they will use the same preloaded classes.</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="16%" id="d4670e944" headers="d4670e923 ">
                                 <p>Reliability</p>
                              </td>
                              <td align="left" valign="top" width="41%" headers="d4670e944 d4670e926 ">
                                 <p>A benefit of dynamic class loading is that it supports program updating. For example, you would update classes on a server, and clients, who download the program and load it dynamically, see the update whenever they next use the program. Server programs tend to emphasize reliability. As a developer, you must know that every client runs a specific program configuration. You do not want clients to inadvertently load some classes that you did not intend them to load.</p>
                              </td>
                              <td align="left" valign="top" width="43%" headers="d4670e944 d4670e929 ">
                                 <p>Oracle Database separates the upload and resolve operation from the class loading operation at run time. You upload Java code you developed to the server using the <code class="codeph">loadjava</code> tool. Instead of using <code class="codeph">CLASSPATH</code>, you specify a resolver at installation time. The resolver is analogous to <code class="codeph">CLASSPATH</code>, but enables you to specify the schemas in which the classes reside. This separation of resolution from class loading ensures that you always know what programs users run.
                                 </p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
               </div>
            </div>
         </div>
      </article>
   </body>
</html>