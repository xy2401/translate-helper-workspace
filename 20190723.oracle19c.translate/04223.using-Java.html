<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <title>关于在Oracle数据库中使用Java</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Java Developer&#39;s Guide "></meta>
      <meta property="og:description" content=""></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Java Developer&#39;s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="java-developers-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-11T00:55:24-08:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="1999, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96468-01"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="Java-overview.html" title="Previous" type="text/html"></link>
      <link rel="next" href="Oracle-JVM-overview.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Java Developer&#39;s Guide"></meta>
    <meta name="dcterms.isVersionOf" content="JJDEV"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="Java-overview.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="Oracle-JVM-overview.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">Java开发人员指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="Java-introduction.html" property="item" typeof="WebPage"><span property="name">Oracle数据库中的Java简介</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">关于在Oracle数据库中使用Java</li>
            </ol>
            <a id="GUID-740E7303-60E4-4DFF-9370-3AEEFEE8E394" name="GUID-740E7303-60E4-4DFF-9370-3AEEFEE8E394"></a><a id="JJDEV01200"></a>
            
            <h2 id="JJDEV-GUID-740E7303-60E4-4DFF-9370-3AEEFEE8E394" class="sect2"><span class="enumeration_section">1.2</span>关于在Oracle数据库中使用Java</h2>
         </header>
         <div class="ind">
            <div>
               <p>您可以在数据库中编写和加载Java应用程序，因为它是一种具有许多安全功能的安全语言。Java的开发是为了防止任何人篡改Java代码所在的操作系统。某些语言（如C）可能会在数据库中引入安全问题。但是，由于Java的设计，Java是一种可以在数据库中使用的健壮语言。</p>
               <p>虽然Java语言为开发人员带来了许多好处，但提供以可伸缩方式支持Java服务器应用程序的JVM实现是一项挑战。本节讨论以下挑战：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="using-Java.html#GUID-9420C7BA-8EBF-4804-9C01-C4F6C089FDCA">Java和RDBMS：一个强大的组合</a></p>
                  </li>
                  <li>
                     <p><a href="using-Java.html#GUID-F7932DDD-EE2E-43BA-9F72-8C1C8903AF58">关于多线程</a></p>
                  </li>
                  <li>
                     <p><a href="using-Java.html#GUID-1A6572CA-4057-467A-AAB3-A4F5EF8D31C5">记忆空间管理</a></p>
                  </li>
                  <li>
                     <p><a href="using-Java.html#GUID-B429EC9B-D0E8-4D31-ADCF-D4B69CE55A48">脚印</a></p>
                  </li>
                  <li>
                     <p><a href="using-Java.html#GUID-9774A951-CCBC-4F1F-90C1-5C386E01B5FE">Oracle JVM的性能</a></p>
                  </li>
                  <li>
                     <p><a href="using-Java.html#GUID-7044909A-7ACF-408E-A87F-94635937D2FB">动态类加载</a></p>
                  </li>
               </ul>
            </div><a id="JJDEV13022"></a><a id="JJDEV13021"></a><div class="props_rev_3"><a id="GUID-9420C7BA-8EBF-4804-9C01-C4F6C089FDCA" name="GUID-9420C7BA-8EBF-4804-9C01-C4F6C089FDCA"></a><h3 id="JJDEV-GUID-9420C7BA-8EBF-4804-9C01-C4F6C089FDCA" class="sect3"><span class="enumeration_section">1.2.1</span> Java和RDBMS：一种强大的组合</h3>
               <div>
                  <p>Oracle数据库为Java应用程序提供了动态数据处理引擎，该引擎支持复杂查询和相同数据的不同视图。所有客户端请求都被组合为数据查询以便立即处理，并且动态生成查询结果。</p>
                  <p>Java和Oracle数据库的结合可帮助您创建基于组件的，以网络为中心的应用程序，这些应用程序可随业务需求的变化而轻松更新。此外，您还可以将应用程序和数据存储从桌面移到智能网络和以网络为中心的服务器上。更重要的是，您可以从任何客户端设备访问这些应用程序和数据存储。</p>
                  <p><a id="d4670e219" class="indexterm-anchor"></a> <a href="using-Java.html#GUID-9420C7BA-8EBF-4804-9C01-C4F6C089FDCA__BABBHGJB">图1-5</a>显示了传统的双层客户端/服务器配置，其中客户端调用Java存储过程的方式与调用PL / SQL存储过程的方式相同。该图还显示了Oracle Net Services Connection Manager如何将多个网络连接组合到单个数据库连接中。这使Oracle数据库能够支持大量并发用户。
                  </p>
                  <div class="figure" id="GUID-9420C7BA-8EBF-4804-9C01-C4F6C089FDCA__BABBHGJB">
                     <p class="titleinfigure">图1-5双层客户/服务器配置</p><img src="img/two_tier_config.gif" alt="下面是图1-5的描述" title="下面是图1-5的描述" longdesc="img_text/two_tier_config.html"><br><a href="img_text/two_tier_config.html">“图1-5双层客户端/服务器配置”的描述</a></div>
                  <!-- class="figure" -->
               </div>
            </div><a id="JJDEV13023"></a><div class="props_rev_3"><a id="GUID-F7932DDD-EE2E-43BA-9F72-8C1C8903AF58" name="GUID-F7932DDD-EE2E-43BA-9F72-8C1C8903AF58"></a><h3 id="JJDEV-GUID-F7932DDD-EE2E-43BA-9F72-8C1C8903AF58" class="sect3"><span class="enumeration_section">1.2.2</span>关于多线程</h3>
               <div>
                  <p>多线程是Java语言的关键可伸缩性功能之一。Java语言和类库使得用Java编写多线程应用程序比使用许多其他语言更简单，但是编写可靠，可伸缩的多线程代码在任何语言中仍然是一项艰巨的任务。</p>
                  <p>Oracle数据库服务器可以有效地为数千名用户安排工作。Oracle JVM利用Oracle数据库的会话体系结构，为数百到数千个用户同时运行Java应用程序。虽然Oracle数据库支持JLS和JCK所需的Java语言级线程，但是使用数据库范围内的线程不会增加可伸缩性。通过使用数据库的嵌入式可伸缩性，消除了编写多线程Java服务器的需要。</p>
                  <p>您应该使用Oracle数据库的工具通过编写单线程Java应用程序来安排用户。数据库可以在每个应用程序之间调度进程，因此，您无需管理线程即可实现可伸缩性。您仍然可以编写多线程Java应用程序，但多个Java线程不会提高服务器的性能。</p>
                  <p><a id="d4670e334" class="indexterm-anchor"></a>多线程创建的一个复杂因素是线程与自动存储管理或垃圾收集的交互。在通用JVM中运行的垃圾收集器不知道正在运行哪些Java语言线程或底层操作系统如何调度它们。非Oracle数据库模型和Oracle JVM模型之间的区别如下：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>非Oracle数据库模型</p>
                        <p>单个用户映射到单个Java线程，单个垃圾收集器管理来自所有用户的所有垃圾。不同的技术通常涉及不同寿命和大小的对象的分配和收集。大量多线程应用程序的结果充其量取决于对本机线程的操作系统支持，这可能是不可靠的并且在可伸缩性方面受到限制。这种实现的高度可扩展性尚未得到令人信服的证明。</p>
                     </li>
                     <li>
                        <p>Oracle JVM模型</p>
                        <p>即使成千上万的用户连接到服务器并运行相同的Java代码，每个用户也会体验它，就像他或她在自己的JVM上运行自己的Java代码一样。 Oracle JVM的职责是利用操作系统进程和线程以及Oracle数据库的可扩展方法。作为这种方法的结果，Oracle JVM的垃圾收集器更加可靠和高效，因为它永远不会从多个用户收集垃圾。</p>
                        <div class="infoboxnotealso" id="GUID-F7932DDD-EE2E-43BA-9F72-8C1C8903AF58__GUID-D371303F-0127-4E92-95F3-4BD2A57D917F">
                           <p class="notep1">也可以看看：</p>
                           <p><span class="q">“ <a href="threading-in-database.html#GUID-7A51D651-181B-405D-BD98-F74037496902">Oracle数据库中的线程概述</a> ”</span></p>
                        </div>
                     </li>
                  </ul>
               </div>
            </div><a id="JJDEV13025"></a><a id="JJDEV13024"></a><div class="props_rev_3"><a id="GUID-1A6572CA-4057-467A-AAB3-A4F5EF8D31C5" name="GUID-1A6572CA-4057-467A-AAB3-A4F5EF8D31C5"></a><h3 id="JJDEV-GUID-1A6572CA-4057-467A-AAB3-A4F5EF8D31C5" class="sect3"><span class="enumeration_section">1.2.3</span>记忆空间管理</h3>
               <div>
                  <p><a id="d4670e450" class="indexterm-anchor"></a>垃圾收集是Java自动存储管理功能的主要功能，无需Java开发人员明确分配和释放内存。因此，这消除了C和C ++程序中常见的大量内存泄漏。但是，垃圾收集会导致程序执行速度和占用空间的开销。
                  </p>
                  <p>垃圾收集给寻求提供高度可扩展和快速Java平台的JVM开发人员带来了挑战。Oracle JVM通过以下方式应对这些挑战：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>Oracle JVM使用Oracle数据库调度工具，可以有效地管理多个用户。</p>
                     </li>
                     <li>
                        <p>对多个用户一致地执行垃圾收集，因为垃圾收集集中在单个会话中的单个用户。Oracle JVM具有优势，因为内存管理器的工作负担和复杂性不会随着用户数量的增加而增加。内存管理器在单个会话中执行对象的分配和收集，这通常转换为单个用户的活动。</p>
                     </li>
                     <li>
                        <p>Oracle JVM根据使用的内存类型使用不同的垃圾收集技术。这些技术提供高效率和低开销。</p>
                     </li>
                  </ul>
                  <p>两种类型的存储空间是调用空间和会话空间。</p>
                  <div class="tblformal" id="GUID-1A6572CA-4057-467A-AAB3-A4F5EF8D31C5__GUID-16E037CE-6C93-4B32-ADC0-229669A24801">
                     <table cellpadding="4" cellspacing="0" class="Formal" title="" width="100%" border="1" summary="table" frame="hsides" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="24%" id="d4670e477">记忆空间</th>
                              <th align="left" valign="bottom" width="76%" id="d4670e480">描述</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="24%" id="d4670e485" headers="d4670e477 ">
                                 <p>呼叫空间</p>
                              </td>
                              <td align="left" valign="top" width="76%" headers="d4670e485 d4670e480 ">
                                 <p>它是一种快速且廉价的存储器。它主要存在于呼叫的长度。呼叫存储空间分为新旧段。所有新对象都在新内存中创建。在几次清除中幸存下来的物体被移入旧记忆中。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="24%" id="d4670e492" headers="d4670e477 ">
                                 <p>会话空间</p>
                              </td>
                              <td align="left" valign="top" width="76%" headers="d4670e492 d4670e480 ">
                                 <p>这是一种昂贵的，性能方面的记忆。它主要存在于会话的长度。此处存在所有<code class="codeph">static</code>字段以及在调用生命周期之外存在的任何对象。
                                 </p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
                  <p><a href="using-Java.html#GUID-1A6572CA-4057-467A-AAB3-A4F5EF8D31C5__BABDGIDI">图1-6</a>说明了垃圾收集器执行的不同操作。
                  </p>
                  <div class="figure" id="GUID-1A6572CA-4057-467A-AAB3-A4F5EF8D31C5__BABDGIDI">
                     <p class="titleinfigure">图1-6垃圾收集</p><img src="img/entapa_02.gif" alt="下面描述图1-6" title="下面描述图1-6" longdesc="img_text/entapa_02.html"><br><a href="img_text/entapa_02.html">“图1-6垃圾收集”的描述</a></div>
                  <!-- class="figure" -->
                  <p>Oracle JVM中的垃圾收集算法遵循以下规则：</p>
                  <ol>
                     <li>
                        <p>在新的调用空间中创建新对象。</p>
                     </li>
                     <li>
                        <p>清除以设定的间隔发生。一些程序员经常在短时间内创建对象。在新的调用空间内快速创建和垃圾收集这些类型的对象。这被称为<span class="bold">清除</span> 。
                        </p>
                     </li>
                     <li>
                        <p>在几次扫气迭代中幸存的任何对象都被认为是可以存在一段时间的对象。这些对象从新的调用空间移出到旧的调用空间。搬家期间，他们也被压缩了。旧的呼叫空间被清除或垃圾收集较少，因此提供了更好的性能。</p>
                     </li>
                     <li>
                        <p>在调用结束时，除调用之外存在的任何对象都将移动到会话空间中。</p>
                     </li>
                  </ol>
                  <p><a href="using-Java.html#GUID-1A6572CA-4057-467A-AAB3-A4F5EF8D31C5__BABDGIDI">图1-6</a>说明了前面文本中列出的步骤。这种方法适用于针对对象的类型和生命周期调整的复杂分配和收集方案。例如，新对象在快速且廉价的呼叫存储器中分配，用于快速分配和访问。Java <code class="codeph">static</code>字段中保存的对象将迁移到更珍贵和昂贵的会话空间。
                  </p>
               </div>
            </div><a id="JJDEV13026"></a><div class="props_rev_3"><a id="GUID-B429EC9B-D0E8-4D31-ADCF-D4B69CE55A48" name="GUID-B429EC9B-D0E8-4D31-ADCF-D4B69CE55A48"></a><h3 id="JJDEV-GUID-B429EC9B-D0E8-4D31-ADCF-D4B69CE55A48" class="sect3"><span class="enumeration_section">1.2.4</span>足迹</h3>
               <div>
                  <p>正在运行的Java程序的占用空间受许多因素的影响：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>程序的大小</p>
                        <p>程序的大小取决于类和方法的数量以及它们包含的代码量。</p>
                     </li>
                     <li>
                        <p>程序的复杂性</p>
                        <p>程序的复杂性取决于程序运行时Oracle JVM使用的核心类库的数量，而不是程序本身。</p>
                     </li>
                     <li>
                        <p>JVM使用的空间量</p>
                        <p>JVM使用的空间量取决于JVM分配的对象数，这些对象的大小以及调用期间必须保留的对象数。</p>
                     </li>
                     <li>
                        <p>垃圾收集器和内存管理器能够处理程序运行的需求</p>
                        <p>这不能经常确定。分配对象的速度以及它们被其他对象保持的方式会影响该因素的重要性。</p>
                     </li>
                  </ul>
                  <p>从可伸缩性的角度来看，同时支持多个客户端的关键是每个用户的最小会话占用空间。通过将用户的所有只读数据（例如Java字节码）放在共享内存中，Oracle JVM将每用户会话占用空间降至最低。针对呼叫和会话存储器应用适当的垃圾收集算法以维持用户会话的小占用空间。Oracle JVM使用以下类型的垃圾收集算法来维护用户的会话内存：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>对短命物体的代际清除</p>
                     </li>
                     <li>
                        <p>标记和延迟扫描集合，用于在单个调用的生命周期中存在的对象</p>
                     </li>
                     <li>
                        <p>为长期对象复制收集器，即在会话中跨越调用的对象</p>
                     </li>
                  </ul>
               </div>
            </div><a id="JJDEV13028"></a><a id="JJDEV13027"></a><div class="props_rev_3"><a id="GUID-9774A951-CCBC-4F1F-90C1-5C386E01B5FE" name="GUID-9774A951-CCBC-4F1F-90C1-5C386E01B5FE"></a><h3 id="JJDEV-GUID-9774A951-CCBC-4F1F-90C1-5C386E01B5FE" class="sect3"><span class="enumeration_section">1.2.5</span> Oracle JVM的性能</h3>
               <div>
                  <p>该<a id="d4670e749" class="indexterm-anchor"></a><a id="d4670e753" class="indexterm-anchor"></a>通过在标准JVM上嵌入类似于HotSpot的创新型Just-In-Time编译器，可以增强Oracle JVM的性能。独立于平台的Java字节码在JVM之上运行，JVM与特定硬件平台交互。无论何时在软件中添加级别，性能都会降低。由于Java需要通过中介来解释字节码，因此与使用平台相关语言（如C）开发的应用程序相比，Java应用程序存在一定程度的低效率。为了解决此问题，一些JVM供应商创建了本机编译器。本机编译器将Java字节码转换为依赖于平台的本机代码，从而消除了解释器步骤并提高了性能。
                  </p>
                  <p><a id="d4670e759" class="indexterm-anchor"></a>下表描述了两种本机编译方法：</p>
                  <div class="tblformal" id="GUID-9774A951-CCBC-4F1F-90C1-5C386E01B5FE__GUID-EE5F65F4-83F4-49C2-9664-B211A6A33D77">
                     <table cellpadding="4" cellspacing="0" class="Formal" title="" width="100%" border="1" summary="table" frame="hsides" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="21%" id="d4670e772">编译器</th>
                              <th align="left" valign="bottom" width="79%" id="d4670e775">描述</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="21%" id="d4670e780" headers="d4670e772 ">
                                 <p>即时（JIT）编译</p>
                              </td>
                              <td align="left" valign="top" width="79%" headers="d4670e780 d4670e775 ">
                                 <p>JIT编译器在运行时快速将Java字节码编译为特定于平台或本机的机器代码。这些编译器不会生成要在平台上运行的可执行文件。相反，它们提供来自Java字节码的平台相关代码，这些代码在翻译后直接运行。JIT编译器应该用于经常运行且速度更接近其他语言（如C语言）开发的代码的Java代码。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="21%" id="d4670e787" headers="d4670e772 ">
                                 <p>提前编译</p>
                              </td>
                              <td align="left" valign="top" width="79%" headers="d4670e787 d4670e775 ">
                                 <p>此编译在运行时之前将Java字节码转换为与平台无关的C代码。然后，标准C编译器将C代码编译为目标平台的可执行文件。此方法更适合未经常修改的Java应用程序。这种方法利用了现代C编译器中成熟，高效的平台特定编译技术。</p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
                  <p>Oracle数据库使用实时（JIT）编译以本机编译的形式提供其核心Java类库，例如JDBC代码。JIT编译器在没有任何插件支持的情况下启用，并且适用于Oracle支持的所有平台。</p>
                  <p>下图说明了本机编译代码的运行速度比解释代码快10倍。因此，程序使用的本机代码越多，运行速度就越快。</p>
                  <div class="figure" id="GUID-9774A951-CCBC-4F1F-90C1-5C386E01B5FE__BABJGGIA">
                     <p class="titleinfigure">图1-7解释器与加速器</p><img src="img/interpreter_vs_accelerator.gif" alt="下面是图1-7的描述" title="下面是图1-7的描述" longdesc="img_text/interpreter_vs_accelerator.html"><br><a href="img_text/interpreter_vs_accelerator.html">“图1-7解释器与加速器”的说明</a></div>
                  <!-- class="figure" -->
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="Oracle-JVM-JIT.html#GUID-23D5BA60-A2B3-45F9-93DF-81A3D971CA50">Oracle JVM即时编译器（JIT）</a></li>
                     </ul>
                  </div>
               </div>
               
            </div><a id="JJDEV13029"></a><div class="props_rev_3"><a id="GUID-7044909A-7ACF-408E-A87F-94635937D2FB" name="GUID-7044909A-7ACF-408E-A87F-94635937D2FB"></a><h3 id="JJDEV-GUID-7044909A-7ACF-408E-A87F-94635937D2FB" class="sect3"><span class="enumeration_section">1.2.6</span>动态类加载</h3>
               <div>
                  <p>Java的另一个强大功能是动态类加载。类加载器从磁盘加载类并将它们放在解释所需的特定于JVM的内存结构中。类加载器在<code class="codeph">CLASSPATH</code>定位类，并仅在程序运行时使用它们时才加载它们。这种方法适用于applet，在服务器环境中存在以下问题：</p>
                  <div class="tblformal" id="GUID-7044909A-7ACF-408E-A87F-94635937D2FB__GUID-D708E2FF-CC49-43E7-A1DA-B79426713784">
                     <table cellpadding="4" cellspacing="0" class="Formal" title="" width="100%" border="1" summary="table" frame="hsides" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="16%" id="d4670e923">问题</th>
                              <th align="left" valign="bottom" width="41%" id="d4670e926">描述</th>
                              <th align="left" valign="bottom" width="43%" id="d4670e929">解</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="16%" id="d4670e934" headers="d4670e923 ">
                                 <p>可预测性</p>
                              </td>
                              <td align="left" valign="top" width="41%" headers="d4670e934 d4670e926 ">
                                 <p>当程序第一次运行时，类加载操作会造成严重的惩罚。一个简单的程序可以使Oracle JVM加载许多核心类以支持其需求。程序员不能轻易预测或确定加载的类数。</p>
                              </td>
                              <td align="left" valign="top" width="43%" headers="d4670e934 d4670e929 ">
                                 <p>Oracle JVM动态加载类，就像使用任何其他JVM一样。遇到相同的一次性加载速度命中。但是，因为类被加载到共享内存中，所以这些类的其他用户不会再次加载类，并且它们将使用相同的预加载类。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="16%" id="d4670e944" headers="d4670e923 ">
                                 <p>可靠性</p>
                              </td>
                              <td align="left" valign="top" width="41%" headers="d4670e944 d4670e926 ">
                                 <p>动态类加载的一个好处是它支持程序更新。例如，您将更新服务器上的类，下载程序并动态加载它的客户端会在下次使用该程序时查看更新。服务器程序倾向于强调可靠性。作为开发人员，您必须知道每个客户端都运行特定的程序配置。您不希望客户端无意中加载您不打算加载的某些类。</p>
                              </td>
                              <td align="left" valign="top" width="43%" headers="d4670e944 d4670e929 ">
                                 <p>Oracle数据库在运行时将上载和解析操作与类加载操作分开。您使用<code class="codeph">loadjava</code>工具将开发的Java代码上载到服务器。您可以在安装时指定解析程序，而不是使用<code class="codeph">CLASSPATH</code> 。解析器类似于<code class="codeph">CLASSPATH</code> ，但允许您指定类所在的模式。这种分辨率与类加载的分离可确保您始终了解用户运行的程序。
                                 </p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
               </div>
            </div>
         </div>
      </article>
   </body>
</html>