<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <meta name="abstract" content="This chapter describes the most important optimizer techniques for transforming queries."></meta>
      <meta name="description" content="This chapter describes the most important optimizer techniques for transforming queries."></meta>
      <title>查询转换</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="SQL Tuning Guide"></meta>
      <meta property="og:description" content="This chapter describes the most important optimizer techniques for transforming queries."></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="SQL Tuning Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="sql-tuning-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-31T14:57:08-08:00"></meta>
      <meta name="dcterms.title" content="SQL Tuning Guide"></meta>
      <meta name="dcterms.dateCopyrighted" content="2013, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96095-03"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="query-optimizer-concepts.html" title="Previous" type="text/html"></link>
      <link rel="next" href="query-execution-plans.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.isVersionOf" content="TGSQL"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="query-optimizer-concepts.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="query-execution-plans.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">SQL调优指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="query-optimizer-fundamentals.html" property="item" typeof="WebPage"><span property="name">查询优化工具基础知识</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">查询转换</li>
            </ol>
            <a id="GUID-B2914447-CD6D-411C-8467-6E10E78F3DE0" name="GUID-B2914447-CD6D-411C-8467-6E10E78F3DE0"></a><a id="TGSQL94896"></a>
            
            <h2 id="TGSQL-GUID-B2914447-CD6D-411C-8467-6E10E78F3DE0" class="sect2"><span class="enumeration_chapter">5</span>查询转换</h2>
         </header>
         <div class="ind">
            <div>
               <p>本章介绍了用于转换查询的最重要的优化器技术。</p>
               <p>优化程序根据成本决定是否使用可用的转换。由于各种原因（包括提示或缺少约束），优化器可能无法进行转换。例如，子查询取消等转换不适用于混合分区表，其中包含不支持约束的外部分区。</p>
               <p>本章包含以下主题：</p>
            </div>
            <div>
               <ul class="ullinks">
                  <li class="ulchildlink"><a href="query-transformations.html#GUID-0D5B9093-CDEA-45AC-A607-1F0D8F2615DD">或扩展</a><br>在<code class="codeph">OR</code>扩展中，优化器将包含顶级析取的查询块转换为包含两个或更多分支的<code class="codeph">UNION ALL</code>查询的形式。
                  </li>
                  <li class="ulchildlink"><a href="query-transformations.html#GUID-6045D0F4-79A9-4688-A844-85F225DFA7DD">查看合并</a><br>在<strong class="term">视图合并</strong> ，优化器合并表示的视图到包含它的查询块<strong class="term">查询的块</strong> 。
                  </li>
                  <li class="ulchildlink"><a href="query-transformations.html#GUID-D2E2DE0D-A013-41C2-8527-A797B1F35709">谓词推动</a><br>在<strong class="term">谓词推送中</strong> ，优化器将包含查询块的相关谓词“推送”到视图查询块中。
                  </li>
                  <li class="ulchildlink"><a href="query-transformations.html#GUID-EBE60A08-5660-44BF-BC89-AD36E941B066">子查询无法解释</a><br>在<strong class="term">子查询中</strong> ，优化程序将嵌套查询转换为等效的连接语句，然后优化连接。
                  </li>
                  <li class="ulchildlink"><a href="query-transformations.html#GUID-C736EE4D-336F-44A4-98CC-CC826103CBCB">使用物化视图重写查询</a><br><strong class="term">物化视图</strong>是存储在表中的查询结果。
                  </li>
                  <li class="ulchildlink"><a href="query-transformations.html#GUID-4CB77742-41A2-49D3-A04F-5C79EE237A3A">基于统计的查询转换</a><br>在某些情况下，Oracle数据库可以通过查询表统计信息而不是表本身来满足查询。
                  </li>
                  <li class="ulchildlink"><a href="query-transformations.html#GUID-EA178F1F-7564-4621-B884-19A202943421">明星转型</a><br>星型转换是一种优化器转换，可避免对星型模式中的事实表进行全表扫描。
                  </li>
                  <li class="ulchildlink"><a href="query-transformations.html#GUID-91434A26-E81E-4609-800B-4E179A63EDBC">内存中聚合（VECTOR GROUP BY）</a><br>内存中聚合的关键优化是在扫描时聚合。
                  </li>
                  <li class="ulchildlink"><a href="query-transformations.html#GUID-C1AE164B-E99F-418A-9B2A-1ADB036048DF">游标持续时间临时表</a><br>为了实现查询的中间结果，Oracle数据库可以在查询编译期间在内存中隐式创建<strong class="term">游标持续时间临时表</strong> 。
                  </li>
                  <li class="ulchildlink"><a href="query-transformations.html#GUID-6A6748FA-5803-4837-9A9F-525ED09BE481">表扩展</a><br>在<strong class="term">表扩展中</strong> ，优化器生成一个计划，该计划在分区表的读取主要部分上使用索引，但不在表的活动部分上使用索引。
                  </li>
                  <li class="ulchildlink"><a href="query-transformations.html#GUID-B47BEFB3-D72D-462A-9B96-C3B1F8F48C06">加入分解</a><br>在称为<strong class="term">连接因子分解</strong>的基于成本的转换中，优化器可以对来自<code class="codeph">UNION ALL</code>查询的分支的公共计算进行分解。
                  </li>
               </ul>
               <div class="familylinks">
                  <div class="parentlink">
                     <p><strong>父主题：</strong> <a href="query-optimizer-fundamentals.html#GUID-EF45F82A-F17D-4C79-9B6A-8CBBB95F0684" title="要调优Oracle SQL，您必须了解查询优化器。优化器是内置软件，用于确定语句访问数据的最有效方法。">查询优化器基础知识</a></p>
                  </div>
               </div>
            </div>
            <a id="TGSQL207"></a><a id="TGSQL208"></a><a id="TGSQL94842"></a><a id="TGSQL206"></a><div class="props_rev_3"><a id="GUID-0D5B9093-CDEA-45AC-A607-1F0D8F2615DD" name="GUID-0D5B9093-CDEA-45AC-A607-1F0D8F2615DD"></a><h3 id="TGSQL-GUID-0D5B9093-CDEA-45AC-A607-1F0D8F2615DD" class="sect3"><span class="enumeration_section">5.1</span>或扩展</h3>
               <div>
                  <p>在<code class="codeph">OR</code>扩展中，优化器将包含顶级析取的查询块转换为包含两个或更多分支的<code class="codeph">UNION ALL</code>查询的形式。
                  </p>
                  <p>优化器通过将析取分解为其组件，然后将每个组件与<code class="codeph">UNION ALL</code>查询的分支相关联来实现此目标。优化器可以出于各种原因选择<code class="codeph">OR</code>扩展。例如，它可以启用更有效的访问路径或避免笛卡尔积的替代连接方法。与往常一样，仅当转换语句的开销低于原始语句的开销时，优化器才会执行扩展。
                  </p>
                  <p>在以前的版本中，优化器使用<code class="codeph">CONCATENATION</code>运算符执行<code class="codeph">OR</code>扩展。从<span>Oracle Database 12c</span>第2版（12.2）开始，优化程序使用<code class="codeph">UNION-ALL</code>运算符。该框架提供以下增强功能：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>实现各种转换之间的交互</p>
                     </li>
                     <li>
                        <p>避免共享查询结构</p>
                     </li>
                     <li>
                        <p>实现各种搜索策略的探索</p>
                     </li>
                     <li>
                        <p>提供成本注释的重用</p>
                     </li>
                     <li>
                        <p>支持标准SQL语法</p>
                     </li>
                  </ul>
                  <div class="example" id="GUID-0D5B9093-CDEA-45AC-A607-1F0D8F2615DD__BABJJCIC">
                     <p class="titleinexample">示例5-1已转换的查询：UNION ALL条件</p>
                     <p>要准备此示例，请以管理员身份登录数据库，执行以下语句以向<code class="codeph">hr.departments.department_name</code>列添加唯一约束，然后向<code class="codeph">hr.employees</code>表添加100,000行：</p><pre class="pre codeblock"><code>ALTER TABLE hr.departments ADD CONSTRAINT department_name_uk UNIQUE（department_name）; DELETE FROM hr.employees WHERE employee_id&gt; 999; DECLARE v_counter NUMBER（7）：= 1000;开始为i IN 1..100000 LOOP INSERT INTO hr.employees VALUES（v_counter，null，'Doe'，'Doe'|| v_counter ||'@ example.com'，null，'07 -JUN-02'，' AC_ACCOUNT”，NULL，NULL，NULL，50）; v_counter：= v_counter + 1;结束循环;结束; / COMMIT; EXEC DBMS_STATS.GATHER_TABLE_STATS（ownname =&gt;'hr'，tabname =&gt;'employees'）;</code></pre><p>然后以用户<code class="codeph">hr</code>身份连接，并执行以下查询，该查询将连接<code class="codeph">employees</code>和<code class="codeph">departments</code>表：</p><pre class="pre codeblock"><code>SELECT * FROM employees e，departments d WHERE（e.email ='SSTILES'或d.department_name ='Treasury'）AND e.department_id = d.department_id;</code></pre><p>如果没有<code class="codeph">OR</code>扩展，优化器会将<code class="codeph">e.email='SSTILES' OR d.department_name='Treasury'</code>视为一个单元。因此，优化程序无法在<code class="codeph">e.email</code>或<code class="codeph">d.department_name</code>列上使用索引，因此<code class="codeph">e.email</code> <code class="codeph">employees</code>和<code class="codeph">departments</code>执行全表扫描。
                     </p>
                     <p>通过<code class="codeph">OR</code>扩展，优化器将析取谓词分解为两个独立谓词，如以下示例所示：</p><pre class="pre codeblock"><code>SELECT * FROM employees e，departments d WHERE e.email ='SSTILES'和e.department_id = d.department_id UNION ALL SELECT * FROM employees e，departments d WHERE d.department_name ='Treasury'AND e.department_id = d.department_id ;</code></pre><p>此转换使<code class="codeph">e.email</code>和<code class="codeph">d.department_name</code>列可用作索引键。性能得到改善，因为数据库使用两个唯一索引而不是两个全表扫描来过滤数据，如以下执行计划中所示：</p><pre class="pre codeblock"><code>计划哈希值：2512933241 --------------------------------------------- -------------------------------------------------- | ID |操作|名称|行|字节|成本（％CPU）|时间| -------------------------------------------------- --------------------------------------------- | 0 |选择声明| | | | 122（100）| | | 1 |查看| VW_ORE_19FF4E3E | 9102 | 1679K | 122（5）| 00:00:01 | | 2 | UNION-ALL | | | | | | | 3 | NESTED LOOPS | | 1 | 78 | 4（0）| 00:00:01 | | 4 |按INDEX ROWID表的访问权限|员工| 1 | 57 | 3（0）| 00:00:01 | | * 5 | INDEX UNIQUE SCAN | EMP_EMAIL_UK | 1 | | 2（0）| 00:00:01 | | 6 |按INDEX ROWID表的访问权限|部门| 1 | 21 | 1（0）| 00:00:01 | | * 7 | INDEX UNIQUE SCAN | DEPT_ID_PK | 1 | | 0（0）| | | 8 | NESTED LOOPS | | 9101 | 693K | 118（5）| 00:00:01 | | 9 |按INDEX ROWID表的访问权限|部门| 1 | 21 | 1（0）| 00:00:01 | | * 10 | INDEX UNIQUE SCAN | DEPARTMENT_NAME_UK | 1 | | 0（0）| | | * 11 |通过INDEX ROWID BATCHED表的访问权限员工| 9101 | 506K | 117（5）| 00:00：01 | | * 12 | INDEX RANGE SCAN | EMP_DEPARTMENT_IX | 9101 | | 35（6）| 00:00:01 | -------------------------------------------------- ---------------------------------------------谓词信息（由操作ID）：---------------------------------------------- ----- 5  - 访问（“E”。“EMAIL”='SSTILES'）7  - 访问（“E”。“DEPARTMENT_ID”=“D”。“DEPARTMENT_ID”）10  - 访问（“D”。“ DEPARTMENT_NAME“='财政部'）11  - 过滤器（LNNVL（”E“。”EMAIL“='SSTILES'））12  - 访问（”E“。”DEPARTMENT_ID“=”D“。”DEPARTMENT_ID“）选择35行。
</code></pre></div>
                  <!-- class="example" -->
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="query-transformations.html#GUID-B2914447-CD6D-411C-8467-6E10E78F3DE0" title="本章介绍了用于转换查询的最重要的优化器技术。">查询转换</a></p>
                     </div>
                  </div>
               </div>
               
            </div><a id="TGSQL209"></a><div class="props_rev_3"><a id="GUID-6045D0F4-79A9-4688-A844-85F225DFA7DD" name="GUID-6045D0F4-79A9-4688-A844-85F225DFA7DD"></a><h3 id="TGSQL-GUID-6045D0F4-79A9-4688-A844-85F225DFA7DD" class="sect3"><span class="enumeration_section">5.2</span>查看合并</h3>
               <div>
                  <p>在<strong class="term">视图合并</strong> ，优化器合并表示的视图到包含它的查询块<strong class="term">查询的块</strong> 。
                  </p>
                  <p>通过使优化器能够考虑其他连接顺序，访问方法和其他转换，查看合并可以改进计划。例如，在合并视图并且多个表驻留在一个查询块中之后，视图中的表可能允许优化器使用<a href="glossary.html#GUID-420638C3-79BE-4ED0-955F-B7EF70685DBC"><span class="xrefglossterm">连接消除</span></a>来移除视图外的表。
                  </p>
                  <p>对于某些简单视图，其中合并始终会产生更好的计划，优化程序会自动合并视图而不考虑成本。否则，优化程序使用成本进行确定。优化器可能出于多种原因选择不合并视图，包括成本或有效性限制。</p>
                  <p>如果<code class="codeph">OPTIMIZER_SECURE_VIEW_MERGING</code>为<code class="codeph">true</code> （默认值），则Oracle数据库会执行检查以确保视图合并和谓词推送不会违反视图创建者的安全意图。要为特定视图禁用这些附加安全检查，可以为此视图授予用户<code class="codeph">MERGE VIEW</code>权限。要禁用特定用户的所有视图的其他安全检查，可以向该用户授予<code class="codeph">MERGE ANY VIEW</code>权限。
                  </p>
                  <div class="infoboxnote" id="GUID-6045D0F4-79A9-4688-A844-85F225DFA7DD__GUID-FFE63A81-9918-4A8E-A0CC-7499D026B110">
                     <p class="notep1">注意：</p>
                     <p>您可以使用提示来覆盖由于成本或启发式而拒绝的视图合并，但不是有效性。</p>
                  </div>
                  <p>本节包含以下主题：</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="query-transformations.html#GUID-38C9EAE6-4E31-4C11-B090-583DD32CE2ED">查看合并中的查询块</a><br>优化程序通过单独的查询块表示每个嵌套的<strong class="term">子查询</strong>或未合并的视图。
                     </li>
                     <li class="ulchildlink"><a href="query-transformations.html#GUID-FE039264-7B1A-42DA-A0E7-7374A510FA9B">简单视图合并</a><br>在<strong class="term">简单视图合并中</strong> ，优化器合并select-project-join视图。
                     </li>
                     <li class="ulchildlink"><a href="query-transformations.html#GUID-D6EEB613-F820-4E27-8FEF-CB0A653F703D">复杂视图合并</a><br>在<strong class="term">视图合并中</strong> ，优化器合并包含<code class="codeph">GROUP BY</code>和<code class="codeph">DISTINCT</code>视图的视图。与简单视图合并一样，复杂合并使优化器能够考虑其他连接顺序和访问路径。
                     </li>
                  </ul>
                  <div class="infoboxnotealso" id="GUID-6045D0F4-79A9-4688-A844-85F225DFA7DD__GUID-EF1046B0-7581-4A82-8DE0-E169FF0A75AD">
                     <p class="notep1">也可以看看：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>有关<code class="codeph">MERGE ANY VIEW</code>和<code class="codeph">MERGE VIEW</code>权限的更多信息，请<a href="../sqlrf/GRANT.html#SQLRF01603" target="_blank"><span><cite>参见Oracle数据库SQL语言参考</cite></span></a></p>
                        </li>
                        <li>
                           <p>有关<code class="codeph">OPTIMIZER_SECURE_VIEW_MERGING</code>初始化参数的详细信息，请<a href="../refrn/OPTIMIZER_SECURE_VIEW_MERGING.html#REFRN10262" target="_blank"><span><cite>参见Oracle数据库参考</cite></span></a></p>
                        </li>
                     </ul>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="query-transformations.html#GUID-B2914447-CD6D-411C-8467-6E10E78F3DE0" title="本章介绍了用于转换查询的最重要的优化器技术。">查询转换</a></p>
                     </div>
                  </div>
               </div>
               <a id="TGSQL94843"></a><div class="props_rev_3"><a id="GUID-38C9EAE6-4E31-4C11-B090-583DD32CE2ED" name="GUID-38C9EAE6-4E31-4C11-B090-583DD32CE2ED"></a><h4 id="TGSQL-GUID-38C9EAE6-4E31-4C11-B090-583DD32CE2ED" class="sect4"><span class="enumeration_section">5.2.1</span>视图合并中的查询块</h4>
                  <div>
                     <p>优化程序通过单独的查询块表示每个嵌套的<strong class="term">子查询</strong>或未合并的视图。
                     </p>
                     <p>数据库从下到上分别优化查询块。因此，数据库首先优化最内层的查询块，为其生成计划的一部分，然后为外部查询块生成表示整个查询的计划。</p>
                     <p>解析器将查询中引用的每个视图扩展为单独的查询块。该块实质上表示视图定义，因此也表示视图的结果。优化器的一个选项是分别分析视图查询块，生成视图子计划，然后使用视图子计划处理查询的其余部分以生成整体执行计划。但是，此技术可能会导致次优的执行计划，因为视图是单独优化的。</p>
                     <p>查看合并有时可以提高性能。如<span class="q">“ <a href="query-transformations.html#GUID-FE039264-7B1A-42DA-A0E7-7374A510FA9B__BABIIIJD">示例5-2</a> ”所示</span> ，视图合并将视图中的表合并到外部查询块中，从而删除内部查询块。因此，不必单独优化视图。
                     </p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="query-transformations.html#GUID-6045D0F4-79A9-4688-A844-85F225DFA7DD" title="在视图合并中，优化器将表示视图的查询块合并到包含它的查询块中。">查看合并</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="TGSQL94845"></a><a id="TGSQL94844"></a><div class="props_rev_3"><a id="GUID-FE039264-7B1A-42DA-A0E7-7374A510FA9B" name="GUID-FE039264-7B1A-42DA-A0E7-7374A510FA9B"></a><h4 id="TGSQL-GUID-FE039264-7B1A-42DA-A0E7-7374A510FA9B" class="sect4"><span class="enumeration_section">5.2.2</span>简单视图合并</h4>
                  <div>
                     <p>在<strong class="term">简单视图合并中</strong> ，优化器合并select-project-join视图。
                     </p>
                     <p>例如， <code class="codeph">employees</code>表的查询包含一个子查询，该子查询连接<code class="codeph">departments</code>和<code class="codeph">locations</code>表。
                     </p>
                     <p>由于合并后可用的附加连接顺序和访问路径，经常合并的简单视图会产生更优化的计划。视图可能对简单视图合并无效，因为：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>该视图包含未包含在select-project-join视图中的构造，包括：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">通过...分组</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">不同</code></p>
                              </li>
                              <li>
                                 <p>外联接</p>
                              </li>
                              <li>
                                 <p><code class="codeph">模型</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">连接</code></p>
                              </li>
                              <li>
                                 <p>设置运营商</p>
                              </li>
                              <li>
                                 <p>聚合</p>
                              </li>
                           </ul>
                        </li>
                        <li>
                           <p>视图出现在<a href="glossary.html#GUID-EA539BF9-F0F2-479B-90B5-1855CD8E34B9"><span class="xrefglossterm">半连接</span></a>或<a href="glossary.html#GUID-4EF44AED-32FD-4FF4-9ECB-24F0011A667E"><span class="xrefglossterm">反</span></a> <a href="glossary.html#GUID-EA539BF9-F0F2-479B-90B5-1855CD8E34B9"><span class="xrefglossterm">连接的</span></a> <a href="glossary.html#GUID-4EF44AED-32FD-4FF4-9ECB-24F0011A667E"><span class="xrefglossterm">右侧</span></a> 。
                           </p>
                        </li>
                        <li>
                           <p>该视图包含<code class="codeph">SELECT</code>列表中的子查询。
                           </p>
                        </li>
                        <li>
                           <p>外部查询块包含PL / SQL函数。</p>
                        </li>
                        <li>
                           <p>视图参与外部联接，并且不满足确定是否可以合并视图的几个附加有效性要求之一。</p>
                        </li>
                     </ul>
                     <div class="example" id="GUID-FE039264-7B1A-42DA-A0E7-7374A510FA9B__BABIIIJD">
                        <p class="titleinexample">示例5-2简单视图合并</p>
                        <p>以下查询将<code class="codeph">hr.employees</code>表与<code class="codeph">dept_locs_v</code>视图连接<code class="codeph">hr.employees</code> ，该视图返回每个部门的街道地址。 <code class="codeph">dept_locs_v</code>是<code class="codeph">departments</code>和<code class="codeph">locations</code>表的连接。
                        </p><pre class="pre codeblock"><code>SELECT e.first_name，e.last_name，dept_locs_v.street_address，dept_locs_v.postal_code FROM employees e，（SELECT d.department_id，d.department_name，l.street_address，l.postal_code FROM departments d，locations l WHERE d.location_id = l。 location_id）dept_locs_v WHERE dept_locs_v.department_id = e.department_id AND e.last_name ='Smith';</code></pre><p>数据库可以通过连接<code class="codeph">departments</code>和<code class="codeph">locations</code>来执行前面的查询，以生成视图的行，然后将此结果连接到<code class="codeph">employees</code> 。由于查询包含视图<code class="codeph">dept_locs_v</code> ，并且此视图包含两个表，因此优化程序必须使用以下连接顺序之一：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">employees</code> ， <code class="codeph">dept_locs_v</code> （ <code class="codeph">departments</code> ， <code class="codeph">locations</code> ）</p>
                           </li>
                           <li>
                              <p><code class="codeph">employees</code> ， <code class="codeph">dept_locs_v</code> （ <code class="codeph">locations</code> ， <code class="codeph">departments</code> ）</p>
                           </li>
                           <li>
                              <p><code class="codeph">dept_locs_v</code> （ <code class="codeph">departments</code> ， <code class="codeph">locations</code> ）， <code class="codeph">employees</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">dept_locs_v</code> （ <code class="codeph">locations</code> ， <code class="codeph">departments</code> ）， <code class="codeph">employees</code></p>
                           </li>
                        </ul>
                        <p>加入方法也受到限制。对于以<code class="codeph">employees</code>开头的连接订单，基于索引的嵌套循环连接不可行，因为此视图中的列上不存在索引。如果没有视图合并，优化程序将生成以下执行计划：</p><pre class="pre codeblock"><code>-------------------------------------------------- --------------- | Id |操作|名称|成本（％CPU）| -------------------------------------------------- --------------- | 0 |选择声明| | 7（15）| | * 1 | HASH JOIN | | 7（15）| | 2 |按INDEX ROWID表的访问权限|员工| 2（0）| | * 3 | INDEX RANGE SCAN | EMP_NAME_IX | 1（0）| | 4 |查看| | 5（20）| | * 5 | HASH JOIN | | 5（20）| | 6 |表访问完全|地点| 2（0）| | 7 |表访问完全|部门| 2（0）| -------------------------------------------------- ---------------谓词信息（由操作ID标识）：-------------------------- ------------------------- 1  -  access（“DEPT_LOCS_V”。“DEPARTMENT_ID”=“E”。“DEPARTMENT_ID”）3  - 访问（“ E“。”LAST_NAME“='史密斯'）5  - 访问（”D“。”LOCATION_ID“=”L“。”LOCATION_ID“）</code></pre><p>视图合并将视图中的表合并到外部查询块中，从而删除内部查询块。查看合并后，查询如下：</p><pre class="pre codeblock"><code>SELECT e.first_name，e.last_name，l.street_address，l.postal_code FROM employees e，departments d，locations l WHERE d.location_id = l.location_id AND d.department_id = e.department_id AND e.last_name ='Smith';</code></pre><p>由于所有三个表都出现在一个查询块中，因此优化程序可以从以下六个连接顺序中进行选择：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">employees</code> ， <code class="codeph">departments</code> ， <code class="codeph">locations</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">employees</code> ， <code class="codeph">locations</code> ， <code class="codeph">departments</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">departments</code> ， <code class="codeph">employees</code> ， <code class="codeph">locations</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">departments</code> ， <code class="codeph">locations</code> ， <code class="codeph">employees</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">locations</code> ， <code class="codeph">employees</code> ， <code class="codeph">departments</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">locations</code> ， <code class="codeph">departments</code> ， <code class="codeph">employees</code></p>
                           </li>
                        </ul>
                        <p>现在， <code class="codeph">employees</code>和<code class="codeph">departments</code>的联接可以基于索引。在视图合并之后，优化器选择以下更有效的计划，该计划使用嵌套循环：</p><pre class="pre codeblock"><code>-------------------------------------------------- ----------------- | Id |操作|名称|成本（％CPU）| -------------------------------------------------- ----------------- | 0 |选择声明| | 4（0）| | 1 | NESTED LOOPS | | | | 2 | NESTED LOOPS | | 4（0）| | 3 | NESTED LOOPS | | 3（0）| | 4 |按INDEX ROWID表的访问权限|员工| 2（0）| | * 5 | INDEX RANGE SCAN | EMP_NAME_IX | 1（0）| | 6 |按INDEX ROWID表的访问权限|部门| 1（0）| | * 7 | INDEX UNIQUE SCAN | DEPT_ID_PK | 0（0）| | * 8 | INDEX UNIQUE SCAN | LOC_ID_PK | 0（0）| | 9 |按INDEX ROWID表的访问权限|地点| 1（0）| -------------------------------------------------- -----------------谓词信息（由操作ID标识）：------------------------ --------------------------- 5  - 访问（“E”。“LAST_NAME”='史密斯'）7  - 访问（“E” 。“DEPARTMENT_ID”=“D”。“DEPARTMENT_ID”）8  - 访问（“D”。“LOCATION_ID”=“L”。“LOCATION_ID”）</code></pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-FE039264-7B1A-42DA-A0E7-7374A510FA9B__GUID-5319C04F-6E6E-445C-B8DD-8A8BB70EE44D">
                        <p class="notep1">也可以看看：</p>
                        <p>位于<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/tgsql&amp;id=optimizer_blog" target="_blank"><code class="codeph">https://blogs.oracle.com/optimizer/</code></a>的Oracle Optimizer博客了解外连接视图合并，这是简单视图合并的一个特例</p>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="query-transformations.html#GUID-6045D0F4-79A9-4688-A844-85F225DFA7DD" title="在视图合并中，优化器将表示视图的查询块合并到包含它的查询块中。">查看合并</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="TGSQL94847"></a><a id="TGSQL94848"></a><a id="TGSQL94846"></a><div class="props_rev_3"><a id="GUID-D6EEB613-F820-4E27-8FEF-CB0A653F703D" name="GUID-D6EEB613-F820-4E27-8FEF-CB0A653F703D"></a><h4 id="TGSQL-GUID-D6EEB613-F820-4E27-8FEF-CB0A653F703D" class="sect4"><span class="enumeration_section">5.2.3</span>复杂视图合并</h4>
                  <div>
                     <p>在<strong class="term">视图合并中</strong> ，优化器合并包含<code class="codeph">GROUP BY</code>和<code class="codeph">DISTINCT</code>视图的视图。与简单视图合并一样，复杂合并使优化器能够考虑其他连接顺序和访问路径。
                     </p>
                     <p>优化程序可以延迟对<code class="codeph">GROUP BY</code>或<code class="codeph">DISTINCT</code>操作的评估，直到它评估了连接。根据数据特征，延迟这些操作可以改善或恶化性能。如果连接使用过滤器，则延迟操作直到连接后可以减少要执行操作的数据集。尽早评估操作可以减少后续连接要处理的数据量，或者连接可以增加操作要处理的数据量。优化程序使用cost来评估视图合并，并仅在较低成本选项时合并视图。
                     </p>
                     <p>除了成本之外，优化器可能无法执行复杂的视图合并，原因如下：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>外部查询表没有rowid或唯一列。</p>
                        </li>
                        <li>
                           <p>该视图显示在<code class="codeph">CONNECT BY</code>查询块中。
                           </p>
                        </li>
                        <li>
                           <p>该视图包含<code class="codeph">GROUPING SETS</code> ， <code class="codeph">ROLLUP</code>或<code class="codeph">PIVOT</code>子句。
                           </p>
                        </li>
                        <li>
                           <p>视图或外部查询块包含<code class="codeph">MODEL</code>子句。
                           </p>
                        </li>
                     </ul>
                     <div class="example" id="GUID-D6EEB613-F820-4E27-8FEF-CB0A653F703D__GUID-A04538AB-A8AE-4ADB-8AB2-A7F9AD56720D">
                        <p class="titleinexample">示例5-3使用GROUP BY的复杂视图连接</p>
                        <p>以下视图使用<code class="codeph">GROUP BY</code>子句：</p><pre class="pre codeblock"><code>CREATE VIEW cust_prod_totals_v AS SELECT SUM（s.quantity_sold）total，s.cust_id，s.prod_id FROM sales s GROUP BY s.cust_id，s.prod_id;</code></pre><p>以下查询查找了购买了至少100件毛皮边饰毛衣的美国所有客户：</p><pre class="pre codeblock"><code>SELECT c.cust_id，c.cust_first_name，c.cust_last_name，c.cust_email FROM customers c，products p，cust_prod_totals_v WHERE c.country_id = 52790 AND c.cust_id = cust_prod_totals_v.cust_id AND cust_prod_totals_v.total&gt; 100 AND cust_prod_totals_v.prod_id = p .prod_id AND p.prod_name ='T3人造毛边修身毛衣';</code></pre><p><code class="codeph">cust_prod_totals_v</code>视图适用于复杂视图合并。合并后，查询如下：</p><pre class="pre codeblock"><code>SELECT c.cust_id，cust_first_name，cust_last_name，cust_email FROM customers c，products p，sales s WHERE c.country_id = 52790 AND c.cust_id = s.cust_id AND s.prod_id = p.prod_id AND p.prod_name ='T3 Faux Fur -Trimmed Sweater'GROUP BY s.cust_id，s.prod_id，p.rowid，c.rowid，c.cust_email，c.cust_last_name，c.cust_first_name，c.cust_id HAVING SUM（s.quantity_sold）&gt; 100;</code></pre><p>转换后的查询比未转换的查询便宜，因此优化器选择合并视图。在未转换的查询中， <code class="codeph">GROUP BY</code>运算符适用于视图中的整个<code class="codeph">sales</code>表。在转换后的查询中， <code class="codeph">products</code>和<code class="codeph">customers</code>的联接会从<code class="codeph">sales</code>表中过滤掉大部分行，因此<code class="codeph">GROUP BY</code>操作的成本较低。连接更加昂贵，因为<code class="codeph">sales</code>表没有减少，但它并不便宜，因为<code class="codeph">GROUP BY</code>操作不会在原始查询中大大减少行集的大小。如果要更改上述任何特征，合并视图可能不再是更低的成本。最终计划不包括视图，如下：</p><pre class="pre codeblock"><code>-------------------------------------------------- ------ | Id |操作|名称|成本（％CPU）| -------------------------------------------------- ------ | 0 |选择声明| | 2101（18）| | * 1 |过滤器| | | | 2 | HASH GROUP BY | | 2101（18）| | * 3 | HASH JOIN | | 2099（18）| | * 4 | HASH JOIN | | 1801（19）| | * 5 |表访问完全|产品| 96（5）| | 6 |表访问完全|销售| 1620（15）| | * 7 |表访问完全|客户| 296（11）| -------------------------------------------------- ------谓词信息（由操作ID标识）：----------------------------------- ---------------- 1  - 过滤器（SUM（“QUANTITY_SOLD”）&gt; 100）3  - 访问（“C”。“CUST_ID”=“CUST_ID”）4  - 访问（“ PROD_ID“=”P“。”PROD_ID“）5  - 过滤器（”P“。”PROD_NAME“='T3人造毛边修身毛衣'）7  - 过滤器（”C“。”COUNTRY_ID“='美国'）</code></pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-D6EEB613-F820-4E27-8FEF-CB0A653F703D__GUID-0E0A4E8B-9D0A-4C83-97DA-FF16AFF543A6">
                        <p class="titleinexample">示例5-4使用DISTINCT的复杂视图连接</p>
                        <p>以下<code class="codeph">cust_prod_v</code>视图查询使用<code class="codeph">DISTINCT</code>运算符：</p><pre class="pre codeblock"><code>SELECT c.cust_id，c.cust_first_name，c.cust_last_name，c.cust_email FROM customers c，products p，（SELECT DISTINCT s.cust_id，s.prod_id FROM sales s）cust_prod_v WHERE c.country_id = 52790 AND c.cust_id = cust_prod_v .cust_id AND cust_prod_v.prod_id = p.prod_id AND p.prod_name ='T3 Faux Fur-Trimmed Sweater';</code></pre><p>在确定视图合并产生较低成本计划后，优化程序将查询重写为此等效查询：</p><pre class="pre codeblock"><code>SELECT nwvw.cust_id，nwvw.cust_first_name，nwvw.cust_last_name，nwvw.cust_email FROM（SELECT DISTINCT（c.rowid），p.rowid，s.prod_id，s.cust_id，c.cust_first_name，c.cust_last_name，c.cust_email FROM客户c，产品p，销售s WHERE c.country_id = 52790 AND c.cust_id = s.cust_id AND s.prod_id = p.prod_id AND p.prod_name ='T3 Faux Fur-Trimmed Sweater'）nwvw;</code></pre><p>上述查询的计划如下：</p><pre class="pre codeblock"><code>------------------------------------------- | Id |操作|名称| ------------------------------------------- | 0 |选择声明| | | 1 |查看| VM_NWVW_1 | | 2 | HASH UNIQUE | | | * 3 | HASH JOIN | | | * 4 | HASH JOIN | | | * 5 |表访问完全|产品| | 6 |表访问完全|销售| | * 7 |表访问完全|客户| -------------------------------------------谓词信息（由操作ID标识）：------------------------------------------------ --- 3  - 访问（“C”。“CUST_ID”=“S”。“CUST_ID”）4  - 访问（“S”。“PROD_ID”=“P”。“PROD_ID”）5  - 过滤器（“P” 。“PROD_NAME”='T3人造毛边修身毛衣'）7  - 过滤器（“C”。“COUNTRY_ID”='美国'）</code></pre><p>即使在发生视图合并之后，上一个计划也包含一个名为<code class="codeph">vm_nwvw_1</code>的视图，称为<a href="glossary.html#GUID-D55A3D23-BD08-4112-AF78-98347EF1F0C3"><span class="xrefglossterm">投影视图</span></a> 。投影视图出现在已合并<code class="codeph">DISTINCT</code>视图的查询中，或者<code class="codeph">GROUP BY</code>视图合并到也包含<code class="codeph">GROUP BY</code> ， <code class="codeph">HAVING</code>或聚合的外部查询块中。在后一种情况下，投影视图包含来自原始外部查询块的<code class="codeph">GROUP BY</code> ， <code class="codeph">HAVING</code>和聚合。
                        </p>
                        <p>在前面的投影视图示例中，当优化器合并视图时，它会将<code class="codeph">DISTINCT</code>运算符移动到外部查询块，然后添加几个附加列以保持与原始查询的语义等效。之后，查询只能选择外部查询块的<code class="codeph">SELECT</code>列表中的所需列。优化保留了视图合并的所有好处：所有表都在一个查询块中，优化器可以根据需要在最终连接顺序中置换它们，并且<code class="codeph">DISTINCT</code>操作已延迟到所有连接完成之后。
                        </p>
                     </div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="query-transformations.html#GUID-6045D0F4-79A9-4688-A844-85F225DFA7DD" title="在视图合并中，优化器将表示视图的查询块合并到包含它的查询块中。">查看合并</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div><a id="TGSQL210"></a><div class="props_rev_3"><a id="GUID-D2E2DE0D-A013-41C2-8527-A797B1F35709" name="GUID-D2E2DE0D-A013-41C2-8527-A797B1F35709"></a><h3 id="TGSQL-GUID-D2E2DE0D-A013-41C2-8527-A797B1F35709" class="sect3"><span class="enumeration_section">5.3</span>谓词推动</h3>
               <div>
                  <p>在<strong class="term">谓词推送中</strong> ，优化器将包含查询块的相关谓词“推送”到视图查询块中。
                  </p>
                  <p>对于未合并的视图，此技术可改进未合并视图的子计划。数据库可以使用推入的谓词来访问索引或用作过滤器。</p>
                  <p>例如，假设您创建一个表<code class="codeph">hr.contract_workers</code> ，如下所示：</p><pre class="pre codeblock"><code>DROP TABLE contract_workers; CREATE TABLE contract_workers AS（SELECT * FROM employees，其中1 = 2）; INSERT INTO contract_workers VALUES（306，'Bill'，'Jones'，'BJONES'，'555.555.2000'，'07 -JUN-02'，'AC_ACCOUNT'，8300,0,205,110）; INSERT INTO contract_workers VALUES（406，'Jill'，'Ashworth'，'JASHWORTH'，'555.999.8181'，'09 -JUN-05'，'AC_ACCOUNT'，8300,0,205,50）; INSERT INTO contract_workers VALUES（506，'Marcie'，'Lunsford'，'MLUNSFORD'，'555.888.2233'，'22 -JUL-01'，'AC_ACCOUNT'，8300,0,205,110）;承诺;关于contract_workers（department_id）的CREATE INDEX contract_workers_index;</code></pre><p>您创建一个引用<code class="codeph">employees</code>和<code class="codeph">contract_workers</code>工作者的视图。视图使用<code class="codeph">UNION</code>集合运算符定义，如下所示：</p><pre class="pre codeblock"><code>CREATE VIEW all_employees_vw AS（SELECT employee_id，last_name，job_id，commission_pct，department_id FROM employees）UNION（SELECT employee_id，last_name，job_id，commission_pct，department_id FROM contract_workers）;</code></pre><p>然后，您按如下方式查询视图：</p><pre class="pre codeblock"><code>SELECT last_name FROM all_employees_vw WHERE <span class="bold">department_id = 50</span> ;</code></pre><p>由于视图是<code class="codeph">UNION</code>集查询，因此优化程序无法将视图的查询合并到访问查询块中。相反，优化器可以通过将其谓词<code class="codeph">WHERE</code>子句条件<code class="codeph">department_id=50</code>推入视图的<code class="codeph">UNION</code>集查询来转换访问语句。等效的转换查询如下：</p><pre class="pre codeblock"><code>SELECT last_name FROM（SELECT employee_id，last_name，job_id，commission_pct，department_id FROM employees WHERE <span class="bold">department_id = 50</span> UNION SELECT employee_id，last_name，job_id，commission_pct，department_id FROM contract_workers WHERE <span class="bold">department_id = 50</span> ）;</code></pre><p>转换后的查询现在可以考虑每个查询块中的索引访问。</p>
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="query-transformations.html#GUID-B2914447-CD6D-411C-8467-6E10E78F3DE0" title="本章介绍了用于转换查询的最重要的优化器技术。">查询转换</a></p>
                     </div>
                  </div>
               </div>
               
            </div><a id="TGSQL211"></a><div class="props_rev_3"><a id="GUID-EBE60A08-5660-44BF-BC89-AD36E941B066" name="GUID-EBE60A08-5660-44BF-BC89-AD36E941B066"></a><h3 id="TGSQL-GUID-EBE60A08-5660-44BF-BC89-AD36E941B066" class="sect3"><span class="enumeration_section">5.4</span>子查询无法解释</h3>
               <div>
                  <p>在<strong class="term">子查询中</strong> ，优化程序将嵌套查询转换为等效的连接语句，然后优化连接。
                  </p>
                  <p>此转换使优化器能够在访问路径，连接方法和连接顺序选择期间考虑子查询表。仅当结果join语句保证返回与原始语句相同的行，并且子查询不包含聚合函数（如<code class="codeph">AVG</code> ，优化程序才能执行此转换。</p>
                  <p>例如，假设您以用户<code class="codeph">sh</code>身份连接并执行以下查询：</p><pre class="pre codeblock"><code>SELECT * FROM sales WHERE cust_id IN（SELECT cust_id FROM customers）;</code></pre><p>因为<code class="codeph">customers.cust_id</code>列是主键，所以优化器可以将复杂查询转换为以下连接语句，该语句保证返回相同的数据：</p><pre class="pre codeblock"><code>选择销售。* FROM销售，客户WHERE sales.cust_id = customers.cust_id;</code></pre><p>如果优化器无法将复杂语句转换为连接语句，则它会选择父语句和子查询的执行计划，就好像它们是单独的语句一样。然后，优化器执行子查询并使用返回的行来执行父查询。为了提高整体执行计划的执行速度，优化程序有效地对子计划进行排序。</p>
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="query-transformations.html#GUID-B2914447-CD6D-411C-8467-6E10E78F3DE0" title="本章介绍了用于转换查询的最重要的优化器技术。">查询转换</a></p>
                     </div>
                  </div>
               </div>
               
            </div><a id="TGSQL212"></a><div class="props_rev_3"><a id="GUID-C736EE4D-336F-44A4-98CC-CC826103CBCB" name="GUID-C736EE4D-336F-44A4-98CC-CC826103CBCB"></a><h3 id="TGSQL-GUID-C736EE4D-336F-44A4-98CC-CC826103CBCB" class="sect3"><span class="enumeration_section">5.5</span>使用物化视图重写查询</h3>
               <div>
                  <p><strong class="term">物化视图</strong>是存储在表中的查询结果。
                  </p>
                  <p>当优化器找到与与实例化视图关联的查询兼容的用户查询时，数据库可以根据实例化视图重写查询。此技术改进了查询执行，因为数据库已预先计算了大部分查询结果。</p>
                  <p>优化程序查找与用户查询兼容的实体化视图，然后使用基于成本的算法选择实体化视图以重写查询。除非物化视图的成本低于使用物化视图生成的计划，否则优化程序在计划生成时不会重写查询。</p>
                  <p>本节包含以下主题：</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="query-transformations.html#GUID-D43AE3AB-0778-49EA-9C8D-983F0910FE05">关于查询重写和优化程序</a><br>查询经过多次检查以确定它是否是查询重写的候选者。如果查询未通过任何检查，则查询将应用于详细信息表而不是物化视图。在响应时间和处理能力方面，无法重写可能代价高昂。
                     </li>
                     <li class="ulchildlink"><a href="query-transformations.html#GUID-51E02736-2656-4F44-8392-98980067A97F">关于查询重写的初始化参数</a><br>查询重写行为由某些数据库初始化参数控制。
                     </li>
                     <li class="ulchildlink"><a href="query-transformations.html#GUID-34CBC168-E1C8-4983-B271-0AB0B639CE7D">关于查询重写的准确性</a><br>查询重写提供三个级别的重写完整性，由初始化参数<code class="codeph">QUERY_REWRITE_INTEGRITY</code> 。</li>
                     <li class="ulchildlink"><a href="query-transformations.html#GUID-19F8E323-0EE4-45AE-A88D-D29E76420206">查询重写示例</a><br>此示例说明了使用实体化视图重写查询的强大功能。
                     </li>
                  </ul>
                  <div class="infoboxnotealso" id="GUID-C736EE4D-336F-44A4-98CC-CC826103CBCB__GUID-D965CAB2-A6F5-40C6-BE2A-1DF5991C4371">
                     <p class="notep1">也可以看看：</p>
                     <p><a href="../dwhsg/basic-query-rewrite-materialized-views.html#DWHSG-GUID-DB76286B-8557-446B-A6CC-BC987C378076" target="_blank"><span><cite>Oracle数据库数据仓库指南</cite></span></a> ，了解有关查询重写的更多信息</p>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="query-transformations.html#GUID-B2914447-CD6D-411C-8467-6E10E78F3DE0" title="本章介绍了用于转换查询的最重要的优化器技术。">查询转换</a></p>
                     </div>
                  </div>
               </div>
               
               <div class="props_rev_3"><a id="GUID-D43AE3AB-0778-49EA-9C8D-983F0910FE05" name="GUID-D43AE3AB-0778-49EA-9C8D-983F0910FE05"></a><h4 id="TGSQL-GUID-D43AE3AB-0778-49EA-9C8D-983F0910FE05" class="sect4"><span class="enumeration_section">5.5.1</span>关于查询重写和优化器</h4>
                  <div>
                     <p>查询经过多次检查以确定它是否是查询重写的候选者。如果查询未通过任何检查，则查询将应用于详细信息表而不是物化视图。在响应时间和处理能力方面，无法重写可能代价高昂。</p>
                     <p>优化程序使用两种不同的方法来确定何时根据实例化视图重写查询。第一种方法将查询的SQL文本与实例化视图定义的SQL文本相匹配。如果第一个方法失败，则优化程序使用更通用的方法来比较查询和物化视图之间的连接，选择，数据列，分组列和聚合函数。</p>
                     <p>查询重写对以下类型的SQL语句中的查询和子查询进行操作：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">选择</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">CREATE TABLE ... AS SELECT</code> 
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">插入...选择</code> 
                           </p>
                        </li>
                     </ul>
                     <p>它还对集合运算符<code class="codeph">UNION</code> ， <code class="codeph">UNION ALL</code> ， <code class="codeph">INTERSECT</code>和<code class="codeph">MINUS</code>子查询以及DML语句（如<code class="codeph">INSERT</code> ， <code class="codeph">DELETE</code>和<code class="codeph">UPDATE</code>子查询进行操作。</p>
                     <p>维度，约束和重写完整性级别会影响是否重写查询以使用实例化视图。此外，可以通过<code class="codeph">REWRITE</code>和<code class="codeph">NOREWRITE</code>提示以及<code class="codeph">QUERY_REWRITE_ENABLED</code>会话参数启用或禁用查询重写。
                     </p>
                     <p><code class="codeph">DBMS_MVIEW.EXPLAIN_REWRITE</code>过程建议是否可以对查询进行查询重写，如果可以，则建议使用哪些实例化视图。它还解释了为什么无法重写查询。
                     </p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="query-transformations.html#GUID-C736EE4D-336F-44A4-98CC-CC826103CBCB" title="物化视图是存储在表中的查询结果。">使用实体化视图查询重写</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="props_rev_3"><a id="GUID-51E02736-2656-4F44-8392-98980067A97F" name="GUID-51E02736-2656-4F44-8392-98980067A97F"></a><h4 id="TGSQL-GUID-51E02736-2656-4F44-8392-98980067A97F" class="sect4"><span class="enumeration_section">5.5.2</span>关于Query Rewrite的初始化参数</h4>
                  <div>
                     <p>查询重写行为由某些数据库初始化参数控制。</p>
                     <div class="tblformal" id="GUID-51E02736-2656-4F44-8392-98980067A97F__GUID-A20BF7CE-ECB9-4FA6-9237-34D926C834C3">
                        <p class="titleintable">表5-1控制查询重写行为的初始化参数</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="控制查询重写行为的初始化参数" border="1" summary="This table describes the initialization parameters that control query rewrite behavior." frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="20%" id="d16801e2267">初始化参数名称</th>
                                 <th align="left" valign="bottom" width="20%" id="d16801e2269">初始化参数值</th>
                                 <th align="left" valign="bottom" width="20%" id="d16801e2271">查询重写的行为</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="20%" id="d16801e2275" headers="d16801e2267 "><code class="codeph">OPTIMIZER_MODE</code></td>
                                 <td align="left" valign="top" width="20%" headers="d16801e2275 d16801e2269 "><code class="codeph">ALL_ROWS</code> （默认）， <code class="codeph">FIRST_ROWS</code>或<code class="codeph">FIRST_ROWS_</code> <span class="italic"><code class="codeph">n</code></span></td>
                                 <td align="left" valign="top" width="20%" headers="d16801e2275 d16801e2271 ">
                                    <p>将<code class="codeph">OPTIMIZER_MODE</code>设置为<code class="codeph">FIRST_ROWS</code> ，优化程序会使用成本和启发式方法的组合来查找快速交付前几行的最佳计划。设置为<code class="codeph">FIRST_ROWS_</code> <span class="italic"><code class="codeph">n</code></span> ，优化程序使用基于成本的方法，并以最佳响应时间为目标进行优化，以返回前<span class="italic"><code class="codeph">n</code></span>行（其中n = 1,10,100,1000）。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="20%" id="d16801e2310" headers="d16801e2267 "><code class="codeph">QUERY_REWRITE_ENABLED</code></td>
                                 <td align="left" valign="top" width="20%" headers="d16801e2310 d16801e2269 "><code class="codeph">TRUE</code> （默认值）， <code class="codeph">FALSE</code>或<code class="codeph">FORCE</code></td>
                                 <td align="left" valign="top" width="20%" headers="d16801e2310 d16801e2271 ">
                                    <p>此选项启用优化程序的查询重写功能，使优化程序能够利用实例化视图来增强性能。如果设置为<code class="codeph">FALSE</code> ，则此选项将禁用优化程序的查询重写功能，并指示优化程序不使用实例化视图重写查询，即使unrewritten查询的估计查询成本较低也是如此。
                                    </p>
                                    <p>如果设置为<code class="codeph">FORCE</code> ，则此选项启用优化程序的查询重写功能，并指示优化程序使用实例化视图重写查询，即使unrewritten查询的估计查询成本较低也是如此。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="20%" id="d16801e2334" headers="d16801e2267 "><code class="codeph">QUERY_REWRITE_INTEGRITY</code></td>
                                 <td align="left" valign="top" width="20%" headers="d16801e2334 d16801e2269 "><code class="codeph">STALE_TOLERATED</code> ， <code class="codeph">TRUSTED</code>或<code class="codeph">ENFORCED</code> （默认）</td>
                                 <td align="left" valign="top" width="20%" headers="d16801e2334 d16801e2271 ">
                                    <p>此参数是可选的。但是，如果已设置，则该值必须是“初始化参数值”列中指定的值之一。</p>
                                    <p>默认情况下，完整性级别设置为<code class="codeph">ENFORCED</code> 。在此模式下，必须验证所有约束。因此，如果您使用<code class="codeph">ENABLE NOVALIDATE RELY</code> ，某些类型的查询重写可能无效。要在此环境中启用查询重写（尚未验证约束），应将完整性级别设置为较低的粒度级别，例如<code class="codeph">TRUSTED</code>或<code class="codeph">STALE_TOLERATED</code> 。</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="query-transformations.html#GUID-34CBC168-E1C8-4983-B271-0AB0B639CE7D" title="查询重写提供三个级别的重写完整性，由初始化参数QUERY_REWRITE_INTEGRITY控制。">关于查询重写的准确性</a></li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="query-transformations.html#GUID-C736EE4D-336F-44A4-98CC-CC826103CBCB" title="物化视图是存储在表中的查询结果。">使用实体化视图查询重写</a></p>
                        </div>
                     </div>
                  </div>
               </div>
               <div class="props_rev_3"><a id="GUID-34CBC168-E1C8-4983-B271-0AB0B639CE7D" name="GUID-34CBC168-E1C8-4983-B271-0AB0B639CE7D"></a><h4 id="TGSQL-GUID-34CBC168-E1C8-4983-B271-0AB0B639CE7D" class="sect4"><span class="enumeration_section">5.5.3</span>关于查询重写的准确性</h4>
                  <div>
                     <p>查询重写提供三个级别的重写完整性，由初始化参数<code class="codeph">QUERY_REWRITE_INTEGRITY</code> 。</p>
                     <p>您可以为<code class="codeph">QUERY_REWRITE_INTEGRITY</code>参数设置的值如下：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">ENFORCED</code></p>
                           <p>这是默认模式。优化程序仅使用物化视图中的新数据，并仅使用基于<code class="codeph">ENABLED VALIDATED</code>主键，唯一键或外键约束的那些关系。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">可信</code></p>
                           <p>在<code class="codeph">TRUSTED</code>模式下，优化器信任在维度和<code class="codeph">RELY</code>约束中声明的关系是正确的。在此模式下，优化程序还使用基于视图的预构建物化视图或物化视图，并使用未强制执行的关系以及强制执行的关系。它还信任使用维度指定的<code class="codeph">ENABLED VALIDATED</code>声明但不是<code class="codeph">ENABLED VALIDATED</code>主要或唯一键约束和数据关系。此模式提供更强的查询重写功能，但如果您声明的任何可信关系不正确，也会产生不正确结果的风险。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">STALE_TOLERATED</code></p>
                           <p>在<code class="codeph">STALE_TOLERATED</code>模式下，优化程序使用有效但具有过时数据的<code class="codeph">STALE_TOLERATED</code>化视图以及包含新数据的视图。此模式提供最大重写功能，但会产生产生不准确结果的风险。
                           </p>
                        </li>
                     </ul>
                     <p>如果将重写完整性设置为最安全的级别<code class="codeph">ENFORCED</code> ，则优化程序仅使用强制主键约束和参照完整性约束来确保查询结果与直接访问详细信息表时的结果相同。
                     </p>
                     <p>如果重写完整性设置为<code class="codeph">ENFORCED</code>以外的<code class="codeph">ENFORCED</code> ，则有几种情况下重写的输出可能与没有重写的输出不同：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>物化视图可能与数据的主副本不同步。这通常是因为物化视图刷新过程在对物化视图的一个或多个详细信息表进行批量加载或DML操作之后处于未决状态。在某些数据仓库站点，这种情况是可取的，因为某些物化视图在某些时间间隔刷新并不罕见。</p>
                        </li>
                        <li>
                           <p>维度对象隐含的关系无效。例如，层次结构中某个级别的值不会累积到恰好一个父值。</p>
                        </li>
                        <li>
                           <p>存储在预构建的物化视图表中的值可能不正确。</p>
                        </li>
                        <li>
                           <p>由于未强制的表或视图约束定义的错误数据关系，可能会出现错误的答案。</p>
                        </li>
                     </ul>
                     <p>您可以在初始化参数文件中或使用<code class="codeph">ALTER SYSTEM</code>或<code class="codeph">ALTER SESSION</code>语句设置<code class="codeph">QUERY_REWRITE_INTEGRITY</code> 。
                     </p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="query-transformations.html#GUID-C736EE4D-336F-44A4-98CC-CC826103CBCB" title="物化视图是存储在表中的查询结果。">使用实体化视图查询重写</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="props_rev_3"><a id="GUID-19F8E323-0EE4-45AE-A88D-D29E76420206" name="GUID-19F8E323-0EE4-45AE-A88D-D29E76420206"></a><h4 id="TGSQL-GUID-19F8E323-0EE4-45AE-A88D-D29E76420206" class="sect4"><span class="enumeration_section">5.5.4</span>查询重写示例</h4>
                  <div>
                     <p>此示例说明了使用实体化视图重写查询的强大功能。</p>
                     <div class="section">
                        <p>请考虑以下物化视图<code class="codeph">cal_month_sales_mv</code> ，它提供每月销售的美元金额的汇总：</p><pre class="pre codeblock"><code>CREATE MATERIALIZED VIEW cal_month_sales_mv ENABLE QUERY REWRITE as SELECT t.calendar_month_desc，SUM（s.amount_sold）AS $ FROM sales s，times t WHERE s.time_id = t.time_id GROUP BY t.calendar_month_desc;</code></pre><p>让我们假设，在一个典型的月份，商店的销售数量约为一百万。因此，此物化聚合视图具有针对每个月销售的美元金额的预先计算的聚合。</p>
                        <p>请考虑以下查询，该查询要求每个日历月在商店销售的金额总和：</p><pre class="pre codeblock"><code>SELECT t.calendar_month_desc，SUM（s.amount_sold）FROM sales s，times t WHERE s.time_id = t.time_id GROUP BY t.calendar_month_desc;</code></pre><p>如果没有先前的物化视图和查询重写功能，Oracle数据库必须直接访问<code class="codeph">sales</code>表并计算<code class="codeph">sales</code>金额的总和以返回结果。这涉及从<code class="codeph">sales</code>表中读取数百万行，由于磁盘访问，这将总是增加查询响应时间。查询中的连接还将进一步减慢查询响应，因为需要在数百万行上计算连接。
                        </p>
                        <p>在物化视图<code class="codeph">cal_month_sales_mv</code>存在的情况下，查询重写将透明地将以前的查询重写为以下查询：</p><pre class="pre codeblock"><code>SELECT calendar_month，dollar FROM cal_month_sales_mv;</code></pre><p>由于物化视图中只有几十行<code class="codeph">cal_month_sales_mv</code>且没有连接，因此Oracle数据库会立即返回结果。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="query-transformations.html#GUID-C736EE4D-336F-44A4-98CC-CC826103CBCB" title="物化视图是存储在表中的查询结果。">使用实体化视图查询重写</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div>
            <div class="sect2"><a id="GUID-4CB77742-41A2-49D3-A04F-5C79EE237A3A" name="GUID-4CB77742-41A2-49D3-A04F-5C79EE237A3A"></a><h3 id="TGSQL-GUID-4CB77742-41A2-49D3-A04F-5C79EE237A3A" class="sect3"><span class="enumeration_section">5.6</span>基于统计的查询转换</h3>
               <div>
                  <p>在某些情况下，Oracle数据库可以通过查询表统计信息而不是表本身来满足查询。</p>
                  <p>基于统计的转换的优点是表统计信息通常比表小得多。元数据查询的性能不依赖于表中的行数，因此对于大型表，可以更好地扩展。</p>
                  <p>表统计信息包括行数和列级详细信息，例如最小值和最大值以及不同值（NDV）的数量。如果数据库知道统计信息是最新的，那么数据库可能会使用统计信息回答某些查询。数据库是否选择转换取决于几个内部因素，包括以下因素：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>聚合类型</p>
                        <p>例如，聚合可以是<code class="codeph">MIN</code> ， <code class="codeph">MAX</code> ， <code class="codeph">COUNT</code>或<code class="codeph">APPROXIMATE_COUNT_DISTINCT</code> 。</p>
                     </li>
                     <li>
                        <p>统计数据的准确性</p>
                        <p>当数据可能与统计信息不匹配时，优化程序不会执行转换。可能导致统计信息不准确的因素包括部分（采样）统计信息，在上次统计信息收集后发生DML，导入统计信息以及使用<code class="codeph">DBMS_STATS.SET_STATS</code>生成的人工统计信息。</p>
                     </li>
                     <li>
                        <p>查询类型</p>
                        <p>优化程序统计信息不保留有关一组值的聚合信息。例如， <code class="codeph">WHERE</code>子句谓词可能会阻止优化器选择转换。
                        </p>
                     </li>
                     <li>
                        <p>查询的位置</p>
                        <p>当查询在事务内时，优化器无法选择转换。</p>
                     </li>
                  </ul>
                  <div class="example" id="GUID-4CB77742-41A2-49D3-A04F-5C79EE237A3A__GUID-3682B894-DB77-49ED-A764-15CA927C72EA">
                     <p class="titleinexample">示例5-5示例查询</p>
                     <p>假设<code class="codeph">sales</code>表有8100万行。您发出以下查询：</p><pre class="pre codeblock"><code>SELECT MAX（amt），MAX（交易量）FROM sales;</code></pre><p>如果统计信息是最新的，则数据库可以将此查询转换为数据字典表的查询。在以下计划中，视图前缀为<code class="codeph">VW_SQT_</code>表示可以进行基于统计的转换：</p><pre class="pre codeblock"><code>-------------------------------------------------- ------------------------------ | Id |操作|名称|行|字节|成本（％CPU）| -------------------------------------------------- ------------------------------ | 0 |选择声明| | | | 636（100）| | 1 |查看| <span class="bold">VW_SQT_65BBF4BE</span> | 1 | 26 | 624（76）| | 2 | SORT AGGREGATE | | 1 | 7 | | | 3 | PX COORDINATOR | | | | | | 4 | PX SEND QC（RANDOM）| ：TQ10000 | 1 | 7 | | | 5 | SORT AGGREGATE | | 1 | 7 | | | 6 | PX BLOCK ITERATOR | | 81M | 546M | 624（76）| | 7 |表访问完全|销售| 81M | 546M | 624（76）| -------------------------------------------------- ------------------------------</code></pre><p><code class="codeph">VW_SQT_65BBF4BE</code>视图不能<span class="italic">证明</span>数据库从数据字典中检索统计信息，因为DML语句可能阻止了它。该计划表明数据库可能已扫描<code class="codeph">sales</code>表。
                     </p>
                  </div>
                  <!-- class="example" -->
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="query-transformations.html#GUID-B2914447-CD6D-411C-8467-6E10E78F3DE0" title="本章介绍了用于转换查询的最重要的优化器技术。">查询转换</a></p>
                     </div>
                  </div>
               </div>
               
            </div><a id="TGSQL94897"></a><div class="props_rev_3"><a id="GUID-EA178F1F-7564-4621-B884-19A202943421" name="GUID-EA178F1F-7564-4621-B884-19A202943421"></a><h3 id="TGSQL-GUID-EA178F1F-7564-4621-B884-19A202943421" class="sect3"><span class="enumeration_section">5.7</span>星变换</h3>
               <div>
                  <p>星型转换是一种优化器转换，可避免对星型模式中的事实表进行全表扫描。</p>
                  <p>本节包含以下主题：</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="query-transformations.html#GUID-76B6B58B-24B0-4DFE-AC1B-CFAC4D93C55A">关于Star Schemas</a><br><span class="bold">星型模式</span>将数据划分为事实和维度。
                     </li>
                     <li class="ulchildlink"><a href="query-transformations.html#GUID-2F24744C-EA75-4BC5-B065-B7181CB9299B">星变换的目的</a><br>在事实和维度表的连接中，星形转换可以避免事实表的完整扫描。
                     </li>
                     <li class="ulchildlink"><a href="query-transformations.html#GUID-959DE4A3-3536-470C-90D2-855E62EB85CB">星变换如何运作</a><br>星型转换添加子查询谓词，称为<span class="bold">位图半连接谓词</span> ，对应于约束维度。
                     </li>
                     <li class="ulchildlink"><a href="query-transformations.html#GUID-E4A7FDE1-9C5C-4E37-8C62-738F725E0E8F">星变换的控制</a><br><code class="codeph">STAR_TRANSFORMATION_ENABLED</code>初始化参数控制星形转换。
                     </li>
                     <li class="ulchildlink"><a href="query-transformations.html#GUID-0694077E-BF83-4D52-99E7-A436C29A6F6D">明星转型：场景</a><br>此方案演示了星型查询的星形转换。
                     </li>
                     <li class="ulchildlink"><a href="query-transformations.html#GUID-BAE74D96-194A-4168-9490-33523BB10C1C">临时表转换：场景</a><br>在上述方案中，优化程序不会将表<code class="codeph">channels</code>连接回<code class="codeph">sales</code>表，因为它未在外部引用，并且<code class="codeph">channel_id</code>是唯一的。
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="query-transformations.html#GUID-B2914447-CD6D-411C-8467-6E10E78F3DE0" title="本章介绍了用于转换查询的最重要的优化器技术。">查询转换</a></p>
                     </div>
                  </div>
               </div>
               <a id="TGSQL94899"></a><a id="TGSQL94898"></a><div class="props_rev_3"><a id="GUID-76B6B58B-24B0-4DFE-AC1B-CFAC4D93C55A" name="GUID-76B6B58B-24B0-4DFE-AC1B-CFAC4D93C55A"></a><h4 id="TGSQL-GUID-76B6B58B-24B0-4DFE-AC1B-CFAC4D93C55A" class="sect4"><span class="enumeration_section">5.7.1</span>关于星型模式</h4>
                  <div>
                     <p><span class="bold">星型模式</span>将数据划分为事实和维度。
                     </p>
                     <p>事实是对诸如销售之类的事件的测量，并且通常是数字。维度是标识事实的类别，例如日期，位置和产品。</p>
                     <p>事实表具有由模式的维度表的主键组成的复合键。维度表充当查找表或引用表，使您可以选择约束查询的值。</p>
                     <p>图表通常显示一个中心事实表，其中的线条将其连接到维度表，从而呈现出星形的外观。下图显示<code class="codeph">sales</code>作为事实表， <code class="codeph">products</code> ， <code class="codeph">times</code> ， <code class="codeph">customers</code>和<code class="codeph">channels</code>作为维度表。
                     </p>
                     <div class="figure" id="GUID-76B6B58B-24B0-4DFE-AC1B-CFAC4D93C55A__BABIFIGF">
                        <p class="titleinfigure">图5-1星型模式</p><img src="img/dwhsg007.gif" alt="下面是图5-1的描述" title="下面是图5-1的描述" longdesc="img_text/dwhsg007.html"><br><a href="img_text/dwhsg007.html">“图5-1星型模式”的描述</a></div>
                     <!-- class="figure" -->
                     <p><a href="glossary.html#GUID-67C99435-C3A9-4314-8533-D95973B6F12F"><span class="xrefglossterm">雪花模式</span></a>是星型模式，维度表在其中引用其他表。<a href="glossary.html#GUID-C78984EF-7A22-4DDC-A3F8-DBF9FB904BDF"><span class="xrefglossterm">暴风雪模式</span></a>是雪花模式的组合。
                     </p>
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-76B6B58B-24B0-4DFE-AC1B-CFAC4D93C55A__GUID-E202C3B2-8E47-4722-B553-4253838BE67E">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/tgsql&amp;id=DWHSG9069" target="_blank"><span class="italic">Oracle数据库数据仓库指南</span></a> ，了解有关星型模式的更多信息</p>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="query-transformations.html#GUID-EA178F1F-7564-4621-B884-19A202943421" title="星型转换是一种优化器转换，可避免对星型模式中的事实表进行全表扫描。">星形转换</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="TGSQL94900"></a><div class="props_rev_3"><a id="GUID-2F24744C-EA75-4BC5-B065-B7181CB9299B" name="GUID-2F24744C-EA75-4BC5-B065-B7181CB9299B"></a><h4 id="TGSQL-GUID-2F24744C-EA75-4BC5-B065-B7181CB9299B" class="sect4"><span class="enumeration_section">5.7.2</span>星变换的目的</h4>
                  <div>
                     <p>在事实和维度表的连接中，星形转换可以避免事实表的完整扫描。</p>
                     <p>星型转换通过仅提取连接到约束维度行的相关事实行来提高性能。在某些情况下，查询在维度表的其他列上具有限制性过滤器。过滤器的组合可以显着减少数据库从事实表中处理的数据集。</p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="query-transformations.html#GUID-EA178F1F-7564-4621-B884-19A202943421" title="星型转换是一种优化器转换，可避免对星型模式中的事实表进行全表扫描。">星形转换</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="TGSQL94901"></a><div class="props_rev_3"><a id="GUID-959DE4A3-3536-470C-90D2-855E62EB85CB" name="GUID-959DE4A3-3536-470C-90D2-855E62EB85CB"></a><h4 id="TGSQL-GUID-959DE4A3-3536-470C-90D2-855E62EB85CB" class="sect4"><span class="enumeration_section">5.7.3</span>星形转换的工作<span class="enumeration_section">原理</span></h4>
                  <div>
                     <p>星型转换添加子查询谓词，称为<span class="bold">位图半连接谓词</span> ，对应于约束维度。
                     </p>
                     <p>当事实连接列上存在索引时，优化器会执行转换。通过驱动子查询提供的键值的位图<code class="codeph">AND</code>和<code class="codeph">OR</code>运算，数据库只需要从事实表中检索相关的行。如果维度表上的谓词过滤掉重要数据，则转换可能比事实表上的完整扫描更有效。
                     </p>
                     <p>在数据库从事实表中检索相关行之后，数据库可能需要使用原始谓词将这些行连接回维度表。满足以下条件时，数据库可以消除维度表的连接：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>维度表上的所有谓词都是半连接子查询谓词的一部分。</p>
                        </li>
                        <li>
                           <p>从子查询中选择的列是唯一的。</p>
                        </li>
                        <li>
                           <p>维列不在<code class="codeph">SELECT</code>列表， <code class="codeph">GROUP BY</code>子句中，依此类推。
                           </p>
                        </li>
                     </ul>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="query-transformations.html#GUID-EA178F1F-7564-4621-B884-19A202943421" title="星型转换是一种优化器转换，可避免对星型模式中的事实表进行全表扫描。">星形转换</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="TGSQL94902"></a><div class="props_rev_3"><a id="GUID-E4A7FDE1-9C5C-4E37-8C62-738F725E0E8F" name="GUID-E4A7FDE1-9C5C-4E37-8C62-738F725E0E8F"></a><h4 id="TGSQL-GUID-E4A7FDE1-9C5C-4E37-8C62-738F725E0E8F" class="sect4"><span class="enumeration_section">5.7.4</span>星形转换的控制</h4>
                  <div>
                     <p><code class="codeph">STAR_TRANSFORMATION_ENABLED</code>初始化参数控制星形转换。
                     </p>
                     <p>此参数采用以下值：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">真正</code></p>
                           <p>优化程序通过自动识别事实和约束维度表来执行星形转换。仅当转换计划的成本低于备选方案时，优化程序才执行星形转换。此外，只要实现提高了性能，优化程序就会自动尝试临时表转换（请参阅<span class="q">“ <a href="query-transformations.html#GUID-BAE74D96-194A-4168-9490-33523BB10C1C" title="在上述方案中，优化程序不会将表通道连接回sales表，因为它未在外部引用，并且channel_id是唯一的。">临时表转换：方案</a> ”</span> ）。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">false</code> （默认）</p>
                           <p>优化器不执行星形转换。</p>
                        </li>
                        <li>
                           <p><code class="codeph">TEMP_DISABLE</code></p>
                           <p>除非优化程序不尝试临时表转换，否则此值与<code class="codeph">true</code>相同。
                           </p>
                        </li>
                     </ul>
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-E4A7FDE1-9C5C-4E37-8C62-738F725E0E8F__GUID-6AA338AA-9AED-4622-B90B-A7870A3D1416">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/tgsql&amp;id=REFRN10213" target="_blank"><span><cite>Oracle Database Reference</cite></span></a>了解<code class="codeph">STAR_TRANSFORMATION_ENABLED</code>初始化参数</p>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="query-transformations.html#GUID-EA178F1F-7564-4621-B884-19A202943421" title="星型转换是一种优化器转换，可避免对星型模式中的事实表进行全表扫描。">星形转换</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="TGSQL94904"></a><a id="TGSQL94905"></a><a id="TGSQL94906"></a><a id="TGSQL94903"></a><div class="props_rev_3"><a id="GUID-0694077E-BF83-4D52-99E7-A436C29A6F6D" name="GUID-0694077E-BF83-4D52-99E7-A436C29A6F6D"></a><h4 id="TGSQL-GUID-0694077E-BF83-4D52-99E7-A436C29A6F6D" class="sect4"><span class="enumeration_section">5.7.5</span>星变换：场景</h4>
                  <div>
                     <p>此方案演示了星型查询的星形转换。</p>
                     <div class="example" id="GUID-0694077E-BF83-4D52-99E7-A436C29A6F6D__BABFHIIH">
                        <p class="titleinexample">例5-6 Star Query</p>
                        <p>以下查询查找1999年第一季度和第二季度加利福尼亚州所有城市的互联网销售总额：</p><pre class="pre codeblock"><code>SELECT c.cust_city，t.calendar_quarter_desc，SUM（s.amount_sold）sales_amount FROM sales s，times t，customers c，channels ch WHERE s.time_id = t.time_id AND s.cust_id = c.cust_id AND s.channel_id = ch .channel_id AND c.cust_state_province ='CA'和ch.channel_desc ='Internet'AND t.calendar_quarter_desc IN（'1999-01'，'1999-02'）GROUP BY c.cust_city，t.calendar_quarter_desc;</code></pre><p>示例输出如下：</p><pre class="pre codeblock"><code>CUST_CITY CALENDA SALES_AMOUNT ------------------------------ ------- ---------- -  Montara 1999-02 1618.01 Pala 1999-01 3263.93 Cloverdale 1999-01 52.64 Cloverdale 1999-02 266.28。 。 。
</code></pre><p>在此示例中， <code class="codeph">sales</code>是事实表，其他表是维度表。<code class="codeph">sales</code>表每次销售产品时都包含一行，因此可以想象它包含数十亿的销售记录。但是，在指定的季度，只有少数产品通过互联网销售给加利福尼亚州的客户。
                        </p>
                     </div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-0694077E-BF83-4D52-99E7-A436C29A6F6D__BABDEJJD">
                        <p class="titleinexample">例5-7星变换</p>
                        <p>此示例显示了<a href="query-transformations.html#GUID-0694077E-BF83-4D52-99E7-A436C29A6F6D__BABFHIIH">示例5-6中</a>查询的星形转换。转换避免了<code class="codeph">sales</code>的全表扫描。
                        </p><pre class="pre codeblock"><code>SELECT c.cust_city，t.calendar_quarter_desc，SUM（s.amount_sold）sales_amount FROM sales s，times t，customers c WHERE s.time_id = t.time_id AND s.cust_id = c.cust_id AND c.cust_state_province ='CA'AND t.calendar_quarter_desc IN（'1999-01'，'1999-02'）AND s.time_id IN（SELECT time_id FROM times WHERE calendar_quarter_desc IN（'1999-01'，'1999-02'））AND s.cust_id IN（ SELECT cust_id FROM customers WHERE cust_state_province ='CA'）AND s.channel_id IN（SELECT channel_id FROM channels WHERE channel_desc ='Internet'）GROUP BY c.cust_city，t.calendar_quarter_desc;</code></pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-0694077E-BF83-4D52-99E7-A436C29A6F6D__BABJECFB">
                        <p class="titleinexample">例5-8星变换的部分执行计划</p>
                        <p>此示例显示了<a href="query-transformations.html#GUID-0694077E-BF83-4D52-99E7-A436C29A6F6D__BABDEJJD">示例5-7中</a>星形转换的执行计划的编辑版本。
                        </p>
                        <p>第26行显示<code class="codeph">sales</code>表具有索引访问路径而不是全表扫描。对于由<code class="codeph">channels</code> （第14行）， <code class="codeph">times</code> （第19行）和<code class="codeph">customers</code> （第24行）的子查询产生的每个键值，数据库从<code class="codeph">sales</code>事实表上的索引检索位图（第15,20,25行） 。
                        </p>
                        <p>位图中的每个位对应于事实表中的一行。当子查询中的键值与事实表的行中的值相同时，将设置该位。例如， <code class="codeph">101000...</code>图<code class="codeph">101000...</code> （省略号表示其余行的<code class="codeph">0</code> ）中，事实表的第1行和第3行具有来自子查询的匹配键值。
                        </p>
                        <p>第12,17和22行中的操作遍历子查询中的键并检索相应的位图。在<a href="query-transformations.html#GUID-0694077E-BF83-4D52-99E7-A436C29A6F6D__BABDEJJD">示例5-7中</a> ， <code class="codeph">customers</code>子查询查找其州或省为<code class="codeph">CA</code>的客户的ID。假设位图<code class="codeph">101000...</code>对应于来自<code class="codeph">customers</code>表子查询的客户ID密钥值<code class="codeph">103515</code> 。还假设<code class="codeph">customers</code>子查询使用位图<code class="codeph">103516</code> <code class="codeph">010000...</code>生成键值<code class="codeph">103516</code> ，这意味着只有<code class="codeph">sales</code>中的第2行具有来自子查询的匹配键值。
                        </p>
                        <p>数据库合并（使用<code class="codeph">OR</code>运算符）每个子查询的位图（第11,16,21行）。在我们的<code class="codeph">customers</code>示例中，数据库在合并两个位图后为<code class="codeph">customers</code>子查询生成单个位图<code class="codeph">111000...</code> ：</p><pre class="pre codeblock"><code>101000 ... #titmap对应键103515 010000 ... #bitmap对应键103516 --------- 111000 ...＃结果OR运算</code></pre><p>在第10行中，数据库将<code class="codeph">AND</code>运算符应用于合并的位图。假设数据库执行了所有<code class="codeph">OR</code>操作后，生成的<code class="codeph">channels</code>位图为<code class="codeph">100000...</code> 如果数据库对此位图和来自<code class="codeph">customers</code>子查询的位图执行<code class="codeph">AND</code>操作，则结果如下：</p><pre class="pre codeblock"><code>所有OR操作执行111000后的100000 ...＃通道位图...执行所有OR操作后的#customer位图--------- 100000 ...＃位图通道和客户的AND操作结果</code></pre><p>在第9行中，数据库生成最终位图的相应rowid。数据库使用rowid从<code class="codeph">sales</code>事实表中检索行（第26行）。在我们的示例中，数据库只生成一个rowid，它对应于第一行，因此只提取一行而不是扫描整个<code class="codeph">sales</code>表。
                        </p><pre class="pre codeblock"><code>-------------------------------------------------- ----------------------------- | Id |操作|名称  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  - - ------------------------------ | 0 |选择声明| | 1 | HASH GROUP BY | | * 2 | HASH JOIN | | * 3 |表访问完全|客户| * 4 | HASH JOIN | | * 5 |表访问完全|时代| 6 |查看| VW_ST_B1772830 | 7 | NESTED LOOPS | | 8 |分区范围子项| | 9 | BITMAP转换为ROWIDS | | 10 | BITMAP和| | 11 | BITMAP MERGE | | 12 | BITMAP KEY ITERATION | | 13 | BUFFER SORT | | * 14 |表访问完全| CHANNELS | * 15 | BITMAP INDEX RANGE SCAN | SALES_CHANNEL_BIX | 16 | BITMAP MERGE | | 17 | BITMAP KEY ITERATION | | 18 | BUFFER SORT | | * 19 |表访问完全|时间| * 20 | BITMAP INDEX RANGE SCAN | SALES_TIME_BIX | 21 | BITMAP MERGE | | 22 | BITMAP KEY ITERATION | | 23 | BUFFER SORT | | * 24 |表访问完全|客户| * 25 | BITMAP INDEX RANGE SCAN | SALES_CUST_BIX | 26 |通过USER ROWID表的访问权限| SALES ------------------------------------------------- ------------------------------谓词信息（由操作ID标识）：----------- ---------------------------------------- 2  -  access（“ITEM_1”=“C “。”CUST_ID“）3  - 过滤器（”C“。”CUST_STATE_PROVINCE“='CA'）4  - 访问（”ITEM_2“=”T“。”TIME_ID“）5  - 过滤器（（”T“。”CALENDAR_QUARTER_DESC“ ='1999-01'或“T”。“CALENDAR_QUARTER_DESC”='1999-02'））14  - 过滤器（“CH”。“CHANNEL_DESC”='互联网'）15  - 访问（“S”。“CHANNEL_ID”= “CH”。“CHANNEL_ID”）19  - 过滤器（（“T”。“CALENDAR_QUARTER_DESC”='1999-01'或“T”。“CALENDAR_QUARTER_DESC”='1999-02'））20  - 访问（“S”。 “TIME_ID”=“T”。“TIME_ID”）24  - 过滤器（“C”。“CUST_STATE_PROVINCE”='CA'）25  - 访问（“S”。“CUST_ID”=“C”。“CUST_ID”）注 - -----用于此声明的星形转换</code></pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="query-transformations.html#GUID-EA178F1F-7564-4621-B884-19A202943421" title="星型转换是一种优化器转换，可避免对星型模式中的事实表进行全表扫描。">星形转换</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="TGSQL94908"></a><a id="TGSQL94909"></a><a id="TGSQL94907"></a><div class="props_rev_3"><a id="GUID-BAE74D96-194A-4168-9490-33523BB10C1C" name="GUID-BAE74D96-194A-4168-9490-33523BB10C1C"></a><h4 id="TGSQL-GUID-BAE74D96-194A-4168-9490-33523BB10C1C" class="sect4"><span class="enumeration_section">5.7.6</span>临时表转换：场景</h4>
                  <div>
                     <p>在上述方案中，优化程序不会将表<code class="codeph">channels</code>连接回<code class="codeph">sales</code>表，因为它未在外部引用，并且<code class="codeph">channel_id</code>是唯一的。
                     </p>
                     <p>但是，如果优化器无法消除连接，则数据库会将子查询结果存储在临时表中，以避免重新扫描维度表以生成位图密钥并重新连接。此外，如果查询并行运行，则数据库实现结果，以便每个并行执行服务器可以从临时表中选择结果，而不是再次执行子查询。</p>
                     <div class="example" id="GUID-BAE74D96-194A-4168-9490-33523BB10C1C__BABFJIEJ">
                        <p class="titleinexample">例5-9使用临时表进行星形转换</p>
                        <p>在此示例中，数据库将<code class="codeph">customers</code>子查询的结果具体化为临时表：</p><pre class="pre codeblock"><code>SELECT t1.c1 cust_city，t.calendar_quarter_desc calendar_quarter_desc，SUM（s.amount_sold）sales_amount FROM sales s，sh.times t，sys_temp_0fd9d6621_e7e24 t1 WHERE s.time_id = t.time_id AND s.cust_id = t1.c0 AND（t.calendar_quarter_desc ='1999-q1'OR t.calendar_quarter_desc ='1999-q2'）AND s.cust_id IN（SELECT t1.c0 FROM sys_temp_0fd9d6621_e7e24 t1）AND s.channel_id IN（SELECT ch.channel_id FROM channels ch WHERE ch.channel_desc =' internet'）AND s.time_id IN（SELECT t.time_id FROM times t WHERE t.calendar_quarter_desc ='1999-q1't t.calendar_quarter_desc ='1999-q2'）GROUP BY t1.c1，t.calendar_quarter_desc</code></pre><div class="p">优化取代<code class="codeph">customers</code>与临时表<code class="codeph">sys_temp_0fd9d6621_e7e24</code> ，并取代以列的引用<code class="codeph">cust_id</code>和<code class="codeph">cust_city</code>与临时表的相应列。数据库创建具有两列的临时表： <code class="codeph">(c0 NUMBER, c1 VARCHAR2(30))</code> 。这些列对应于<code class="codeph">customers</code>表的<code class="codeph">cust_id</code>和<code class="codeph">cust_city</code> 。数据库通过在上一个查询执行开始时执行以下查询来填充临时表：<pre class="pre codeblock"><code>SELECT c.cust_id，c.cust_city FROM customers WHERE c.cust_state_province ='CA'</code></pre></div>
                     </div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-BAE74D96-194A-4168-9490-33523BB10C1C__BABFJJCH">
                        <p class="titleinexample">示例5-10使用临时表进行星形转换的部分执行计划</p>
                        <p>以下示例显示了<a href="query-transformations.html#GUID-BAE74D96-194A-4168-9490-33523BB10C1C__BABFJIEJ">示例5-9中</a>查询的执行计划的已编辑版本：</p><pre class="pre codeblock"><code>-------------------------------------------------- ----------------------------- | Id |操作|名称  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  - - ------------------------------ | 0 |选择声明| | 1 | TEMP TABLE TRANSFORMATION | | 2 |加载为选择| | * 3 |表访问完全|客户| 4 | HASH GROUP BY | | * 5 | HASH JOIN | | 6 |表访问完全| SYS_TEMP_0FD9D6613_C716F | * 7 | HASH JOIN | | * 8 |表访问完全|时代| 9 |查看| VW_ST_A3F94988 | 10 | NESTED LOOPS | | 11 |分区范围子项| | 12 | BITMAP转换为ROWIDS | | 13 | BITMAP和| | 14 | BITMAP MERGE | | 15 | BITMAP KEY ITERATION | | 16 | BUFFER SORT | | * 17 |表访问完全| CHANNELS | * 18 | BITMAP INDEX RANGE SCAN | SALES_CHANNEL_BIX | 19 | BITMAP MERGE | | 20 | BITMAP KEY ITERATION | | 21 | BUFFER SORT | | * 22 |表访问完全|时间| * 23 | BITMAP INDEX RANGE SCAN | SALES_TIME_BIX | 24 | BITMAP MERGE | | 25 | BITMAP KEY ITERATION | | 26 | BUFFER SORT | | 27 |表访问完全| SYS_TEMP_0FD9D6613_C716F | * 28 | BITMAP INDEX RANGE SCAN | SALES_CUST_BIX | 29 |通过USER ROWID表的访问权限| SALES ------------------------------------------------- ------------------------------谓词信息（由操作ID标识）：----------- ---------------------------------------- 3  - 过滤器（“C”。“CUST_STATE_PROVINCE “='CA'）5  - 访问（”ITEM_1“=”C0“）7  - 访问（”ITEM_2“=”T“。”TIME_ID“）8  - 过滤器（（”T“。”CALENDAR_QUARTER_DESC“='1999- 01'OR“T”。“CALENDAR_QUARTER_DESC”='1999-02'））17  - 过滤器（“CH”。“CHANNEL_DESC”='互联网'）18  - 访问（“S”。“CHANNEL_ID”=“CH”。 “CHANNEL_ID”）22  - 过滤器（（“T”。“CALENDAR_QUARTER_DESC”='1999-01'或“T”。“CALENDAR_QUARTER_DESC”='1999-02'））23  - 访问（“S”。“TIME_ID”= “T”。“TIME_ID”）28  - 访问（“S”。“CUST_ID”=“C0”）</code></pre><p>计划的第1行，第2行和第3行将<code class="codeph">customers</code>子查询实现到临时表中。在第6行中，数据库扫描临时表（而不是子查询）以从事实表构建位图。第27行扫描临时表以加入而不是扫描<code class="codeph">customers</code> 。数据库不需要对临时表上的<code class="codeph">customers</code>应用筛选器，因为在实现临时表时应用了筛选器。
                        </p>
                     </div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="query-transformations.html#GUID-EA178F1F-7564-4621-B884-19A202943421" title="星型转换是一种优化器转换，可避免对星型模式中的事实表进行全表扫描。">星形转换</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div>
            <div class="sect2"><a id="GUID-91434A26-E81E-4609-800B-4E179A63EDBC" name="GUID-91434A26-E81E-4609-800B-4E179A63EDBC"></a><h3 id="TGSQL-GUID-91434A26-E81E-4609-800B-4E179A63EDBC" class="sect3"><span class="enumeration_section">5.8</span>内存中聚合（VECTOR GROUP BY）</h3>
               <div>
                  <p>内存中聚合的关键优化是在扫描时聚合。</p>
                  <p>为了优化涉及从单个大表到多个小表的聚合和连接的查询块，例如在典型的星型查询中，转换使用<code class="codeph">KEY VECTOR</code>和<code class="codeph">VECTOR GROUP BY</code>操作。这些操作使用高效的内存数组进行连接和聚合，当底层表是内存中的列表时尤其有效。
                  </p>
               </div>
               <div>
                  <div class="infoboxnotealso" id="GUID-91434A26-E81E-4609-800B-4E179A63EDBC__GUID-750067BA-1F6C-4940-A511-94EED9B18972">
                     <p class="notep1">也可以看看：</p>
                     <p><a href="../inmem/optimizing-in-memory-aggregation.html#INMEM-GUID-2C4FA6C6-3DA8-4CEA-9EF0-294396D15077" target="_blank"><span><cite>Oracle Database In-Memory指南</cite></span></a>了解有关内存中聚合的更多信息</p>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="query-transformations.html#GUID-B2914447-CD6D-411C-8467-6E10E78F3DE0" title="本章介绍了用于转换查询的最重要的优化器技术。">查询转换</a></p>
                     </div>
                  </div>
               </div>
               
            </div>
            <div class="sect2"><a id="GUID-C1AE164B-E99F-418A-9B2A-1ADB036048DF" name="GUID-C1AE164B-E99F-418A-9B2A-1ADB036048DF"></a><h3 id="TGSQL-GUID-C1AE164B-E99F-418A-9B2A-1ADB036048DF" class="sect3"><span class="enumeration_section">5.9</span>游标持续时间临时表</h3>
               <div>
                  <p>为了实现查询的中间结果，Oracle数据库可以在查询编译期间在内存中隐式创建<strong class="term">游标持续时间临时表</strong> 。
                  </p>
                  <p>本节包含以下主题：</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="query-transformations.html#GUID-CB9634BE-46B9-4AA3-B9A2-6013442C7FDB">Cursor-Duration临时表的用途</a><br>复杂查询有时会多次处理同一个查询块，从而产生不必要的性能开销。
                     </li>
                     <li class="ulchildlink"><a href="query-transformations.html#GUID-A12A7ECA-069B-410D-8F01-E07BCBD5D754">游标持续时间临时表如何工作</a><br>游标定义临时表的定义驻留在内存中。表定义与游标相关联，并且仅对执行游标的会话可见。
                     </li>
                     <li class="ulchildlink"><a href="query-transformations.html#GUID-2832BCE0-5BE3-49A8-8CB6-90BF7D075E26">Cursor-Duration临时表：示例</a><br>重复相同子查询的<code class="codeph">WITH</code>查询有时可以从游标持续时间临时表中受益。
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="query-transformations.html#GUID-B2914447-CD6D-411C-8467-6E10E78F3DE0" title="本章介绍了用于转换查询的最重要的优化器技术。">查询转换</a></p>
                     </div>
                  </div>
               </div>
               
               <div class="sect3"><a id="GUID-CB9634BE-46B9-4AA3-B9A2-6013442C7FDB" name="GUID-CB9634BE-46B9-4AA3-B9A2-6013442C7FDB"></a><h4 id="TGSQL-GUID-CB9634BE-46B9-4AA3-B9A2-6013442C7FDB" class="sect4"><span class="enumeration_section">5.9.1</span>游标持续时间临时表的用途</h4>
                  <div>
                     <p>复杂查询有时会多次处理同一个查询块，从而产生不必要的性能开销。</p>
                     <p>为避免这种情况，Oracle数据库可以自动为查询结果创建临时表，并在游标持续时间内将它们存储在内存中。对于诸如<code class="codeph">WITH</code>子句查询，星形转换和分组集之类的复杂操作，此优化增强了重复使用的子查询的中间结果的实现。通过这种方式，游标持续时间临时表可以提高性能并优化I / O.</p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="query-transformations.html#GUID-C1AE164B-E99F-418A-9B2A-1ADB036048DF" title="为了实现查询的中间结果，Oracle数据库可以在查询编译期间在内存中隐式创建游标持续时间临时表。">Cursor-Duration临时表</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="sect3"><a id="GUID-A12A7ECA-069B-410D-8F01-E07BCBD5D754" name="GUID-A12A7ECA-069B-410D-8F01-E07BCBD5D754"></a><h4 id="TGSQL-GUID-A12A7ECA-069B-410D-8F01-E07BCBD5D754" class="sect4"><span class="enumeration_section">5.9.2</span>游标持续时间临时表的工作原理</h4>
                  <div>
                     <p>游标定义临时表的定义驻留在内存中。表定义与游标相关联，并且仅对执行游标的会话可见。</p>
                     <p>使用游标持续时间临时表时，数据库执行以下步骤：</p>
                     <ol>
                        <li>
                           <p>选择使用游标持续时间临时表的计划</p>
                        </li>
                        <li>
                           <p>使用唯一名称创建临时表</p>
                        </li>
                        <li>
                           <p>重写查询以引用临时表</p>
                        </li>
                        <li>
                           <p>将数据加载到内存中，直到没有内存，在这种情况下，它会在磁盘上创建临时段</p>
                        </li>
                        <li>
                           <p>执行查询，从临时表返回数据</p>
                        </li>
                        <li>
                           <p>截断表，释放内存和任何磁盘上的临时段</p>
                        </li>
                     </ol>
                     <div class="infoboxnote" id="GUID-A12A7ECA-069B-410D-8F01-E07BCBD5D754__GUID-28464ECB-EDE7-450C-B854-9BC61914674C">
                        <p class="notep1">注意：</p>
                        <p>只要光标在内存中，游标持续时间临时表的元数据就会保留在内存中。元数据不存储在数据字典中，这意味着它不能通过数据字典视图看到。您无法显式删除元数据。</p>
                     </div>
                     <p>上述方案取决于内存的可用性。对于串行查询，临时表使用PGA内存。</p>
                     <p>游标持续时间临时表的实现类似于排序。如果没有更多可用内存，则数据库会将数据写入临时段。对于游标持续时间临时表，差异如下：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>数据库在查询结束时释放内存和临时段，而不是<a href="glossary.html#GUID-BDE98BD8-BC33-45AD-97BF-81831BF94B04"><span class="xrefglossterm">在行源</span></a>不再处于活动状态时释放。
                           </p>
                        </li>
                        <li>
                           <p>内存中的数据保留在内存中，与数据可以在内存和临时段之间移动的排序不同。</p>
                        </li>
                     </ul>
                     <p>当数据库使用游标持续时间临时表时，关键字<code class="codeph">CURSOR DURATION MEMORY</code>出现在执行计划中。
                     </p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="query-transformations.html#GUID-C1AE164B-E99F-418A-9B2A-1ADB036048DF" title="为了实现查询的中间结果，Oracle数据库可以在查询编译期间在内存中隐式创建游标持续时间临时表。">Cursor-Duration临时表</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="sect3"><a id="GUID-2832BCE0-5BE3-49A8-8CB6-90BF7D075E26" name="GUID-2832BCE0-5BE3-49A8-8CB6-90BF7D075E26"></a><h4 id="TGSQL-GUID-2832BCE0-5BE3-49A8-8CB6-90BF7D075E26" class="sect4"><span class="enumeration_section">5.9.3</span>游标持续时间临时表：示例</h4>
                  <div>
                     <p>重复相同子查询的<code class="codeph">WITH</code>查询有时可以从游标持续时间临时表中受益。
                     </p>
                     <div class="section">
                        <p>以下查询使用<code class="codeph">WITH</code>子句创建三个子查询块：</p><pre class="pre codeblock"><code>WITH q1 AS（SELECT department_id，SUM（薪水）sum_sal FROM hr.employees GROUP BY department_id），q2 AS（SELECT * FROM q1），q3 AS（SELECT department_id，sum_sal FROM q1）SELECT * FROM q1 UNION ALL SELECT * FROM q2 UNION ALL SELECT * FROM q3;</code></pre><p>以下示例计划显示了转换：</p><pre class="pre codeblock"><code>SELECT * FROM TABLE（DBMS_XPLAN.DISPLAY_CURSOR（FORMAT =&gt;'BASIC + ROWS + COST'））; PLAN_TABLE_OUTPUT ------------------------------------------------- ------------------------------------------- | Id |操作|名称|行|成本（％CPU）| -------------------------------------------------- ------------------------------------------ | 0 |选择声明| | | 6（100）| | 1 | TEMP TABLE TRANSFORMATION | | | | | 2 | LOAD AS SELECT（ <span class="bold">CURSOR DURATION MEMORY</span> ）| SYS_TEMP_0FD9D6606_1AE004 | | | | 3 | HASH GROUP BY | | 11 | 3（34）| | 4 |表访问完全|员工| 107 | 2（0）| | 5 | UNION-ALL | | | | | 6 |查看| | 11 | 2（0）| | 7 |表访问完全| SYS_TEMP_0FD9D6606_1AE004 | 11 | 2（0）| | 8 |查看| | 11 | 2（0）| | 9 |表访问完全| SYS_TEMP_0FD9D6606_1AE004 | 11 | 2（0）| | 10 |查看| | 11 | 2（0）| | 11 |表访问完全| SYS_TEMP_0FD9D6606_1AE004 | 11 | 2（0）| -------------------------------------------------- ------------------------------------------</code></pre><p>在前面的计划中，步骤1中的<code class="codeph">TEMP TABLE TRANSFORMATION</code>指示数据库使用游标持续时间临时表来执行查询。步骤2中的<code class="codeph">CURSOR DURATION MEMORY</code>关键字指示数据库使用内存（如果可用）来存储<code class="codeph">SYS_TEMP_0FD9D6606_1AE004</code>的结果。如果内存不可用，则数据库将临时数据写入磁盘。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="query-transformations.html#GUID-C1AE164B-E99F-418A-9B2A-1ADB036048DF" title="为了实现查询的中间结果，Oracle数据库可以在查询编译期间在内存中隐式创建游标持续时间临时表。">Cursor-Duration临时表</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div><a id="TGSQL94910"></a><div class="props_rev_3"><a id="GUID-6A6748FA-5803-4837-9A9F-525ED09BE481" name="GUID-6A6748FA-5803-4837-9A9F-525ED09BE481"></a><h3 id="TGSQL-GUID-6A6748FA-5803-4837-9A9F-525ED09BE481" class="sect3"><span class="enumeration_section">5.10</span>表扩展</h3>
               <div>
                  <p>在<strong class="term">表扩展中</strong> ，优化器生成一个计划，该计划在分区表的读取主要部分上使用索引，但不在表的活动部分上使用索引。
                  </p>
                  <p>本节包含以下主题：</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="query-transformations.html#GUID-685FF0DE-A670-40BF-BC6F-0292A0CCCA21">表扩展的目的</a><br>基于索引的计划可以提高性能，但索引维护会产生开销。在许多数据库中，DML仅影响一小部分数据。
                     </li>
                     <li class="ulchildlink"><a href="query-transformations.html#GUID-1AD0BA3C-668E-482F-9EA6-F085BF3E68E0">表扩展如何工作</a><br>表分区使表扩展成为可能。
                     </li>
                     <li class="ulchildlink"><a href="query-transformations.html#GUID-74BE3861-35D4-453C-A983-F3317CDA8338">表扩展：场景</a><br>优化程序根据查询中出现的谓词，跟踪必须从每个表访问哪些分区。分区修剪使优化器能够使用表扩展来生成更优化的计划。
                     </li>
                     <li class="ulchildlink"><a href="query-transformations.html#GUID-C4E94706-3312-4BD6-B6C7-2F4264BB35E9">表扩展和星形转换：场景</a><br>星型转换支持特定类型的查询，以避免访问大部分大事实表。
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="query-transformations.html#GUID-B2914447-CD6D-411C-8467-6E10E78F3DE0" title="本章介绍了用于转换查询的最重要的优化器技术。">查询转换</a></p>
                     </div>
                  </div>
               </div>
               <a id="TGSQL94911"></a><div class="props_rev_3"><a id="GUID-685FF0DE-A670-40BF-BC6F-0292A0CCCA21" name="GUID-685FF0DE-A670-40BF-BC6F-0292A0CCCA21"></a><h4 id="TGSQL-GUID-685FF0DE-A670-40BF-BC6F-0292A0CCCA21" class="sect4"><span class="enumeration_section">5.10.1</span>表扩展的目的</h4>
                  <div>
                     <p>基于索引的计划可以提高性能，但索引维护会产生开销。在许多数据库中，DML仅影响一小部分数据。</p>
                     <p>表扩展使用基于索引的计划来处理高更新表。您只能在读取主要数据上创建索引，从而消除活动数据上的索引开销。通过这种方式，表扩展可以提高性能，同时避免索引维护。</p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="query-transformations.html#GUID-6A6748FA-5803-4837-9A9F-525ED09BE481" title="在表扩展中，优化器生成一个计划，该计划在分区表的读取主要部分上使用索引，但不在表的活动部分上使用索引。">表扩展</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="TGSQL94912"></a><div class="props_rev_3"><a id="GUID-1AD0BA3C-668E-482F-9EA6-F085BF3E68E0" name="GUID-1AD0BA3C-668E-482F-9EA6-F085BF3E68E0"></a><h4 id="TGSQL-GUID-1AD0BA3C-668E-482F-9EA6-F085BF3E68E0" class="sect4"><span class="enumeration_section">5.10.2</span>表扩展如何工作</h4>
                  <div>
                     <p>表分区使表扩展成为可能。</p>
                     <p>如果分区表上存在本地索引，则优化程序可以将索引标记为对特定分区不可用。实际上，某些分区未编入索引。</p>
                     <p>在表扩展中，优化器将查询转换为<code class="codeph">UNION ALL</code>语句，其中一些子查询访问索引分区，其他子查询访问未编制索引的分区。优化器可以为分区选择最有效的访问方法，无论它是否存在于查询中访问的所有分区。
                     </p>
                     <p>优化器并不总是选择表扩展：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>表扩展是基于成本的。</p>
                           <p>虽然数据库仅在<code class="codeph">UNION ALL</code>所有分支上访问扩展表的每个分区，但在每个分支中都会访问数据库连接到它的所有表。
                           </p>
                        </li>
                        <li>
                           <p>语义问题可能导致扩展无效。</p>
                           <p>例如，出现在外部联接右侧的表对于表扩展无效。</p>
                        </li>
                     </ul>
                     <p>您可以使用提示<code class="codeph">EXPAND_TABLE</code>提示来控制表扩展。提示会覆盖基于成本的决策，但不会覆盖语义检查。
                     </p>
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-1AD0BA3C-668E-482F-9EA6-F085BF3E68E0__GUID-A49F5B51-DA14-4F51-8FA0-5AC8CFFD0C1C">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><span class="q">“ <a href="influencing-the-optimizer.html#GUID-C558F7CF-446E-4078-B045-0B3BB026CB3C" title="优化程序提示是SQL语句中的特殊注释，它将指令传递给优化程序。">用提示影响优化器</a> ”</span></p>
                           </li>
                           <li>
                              <p><a href="../sqlrf/Comments.html#SQLRF00219" target="_blank"><span><cite>Oracle数据库SQL语言参考，</cite></span></a>以了解有关SQL提示的更多信息</p>
                           </li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="query-transformations.html#GUID-6A6748FA-5803-4837-9A9F-525ED09BE481" title="在表扩展中，优化器生成一个计划，该计划在分区表的读取主要部分上使用索引，但不在表的活动部分上使用索引。">表扩展</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="TGSQL94914"></a><a id="TGSQL94913"></a><div class="props_rev_3"><a id="GUID-74BE3861-35D4-453C-A983-F3317CDA8338" name="GUID-74BE3861-35D4-453C-A983-F3317CDA8338"></a><h4 id="TGSQL-GUID-74BE3861-35D4-453C-A983-F3317CDA8338" class="sect4"><span class="enumeration_section">5.10.3</span>表扩展：场景</h4>
                  <div>
                     <p>优化程序根据查询中出现的谓词，跟踪必须从每个表访问哪些分区。分区修剪使优化器能够使用表扩展来生成更优化的计划。</p>
                     <div class="section">
                        <p class="subhead3" id="GUID-74BE3861-35D4-453C-A983-F3317CDA8338__GUID-D7D5B988-6B9F-4142-8159-DFF3F7304753">假设</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>此方案假定以下内容：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>您希望针对<code class="codeph">sh.sales</code>表运行星型查询，该表在<code class="codeph">time_id</code>列上进行范围分区。
                              </p>
                           </li>
                           <li>
                              <p>您希望禁用特定分区上的索引以查看表扩展的好处。</p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-74BE3861-35D4-453C-A983-F3317CDA8338__GUID-6C7901A3-FE3B-4E46-8D2F-437A378F230A">要使用表扩展：</p>
                        <ol>
                           <li>
                              <p>以<code class="codeph">sh</code>用户身份登录数据库。
                              </p>
                           </li>
                           <li>
                              <p>运行以下查询：</p><pre class="pre codeblock"><code>SELECT * FROM sales WHERE time_id&gt; = TO_DATE（'2000-01-01 00:00:00'，'SYYYY-MM-DD HH24：MI：SS'）AND prod_id = 38;</code></pre></li>
                           <li>
                              <p>通过查询<code class="codeph">DBMS_XPLAN</code>来解释该计划：</p><pre class="pre codeblock"><code>SET LINESIZE 150 SET PAGESIZE 0 SELECT * FROM TABLE（DBMS_XPLAN.DISPLAY_CURSOR（format =&gt;'BASIC，PARTITION'））;</code></pre><p>如图中<code class="codeph">Pstart</code>和<code class="codeph">Pstop</code>列在下面的计划，优化器从仅在表28个分区的16必须被访问的过滤器确定：</p><pre class="pre codeblock"><code>计划哈希值：3087065703 --------------------------------------------- ----------------------------- | Id |操作|名称| Pstart | Pstop | -------------------------------------------------- ------------------------ | 0 |选择声明| | | | | 1 |分区范围ITERATOR | | 13 | 28 | | 2 |按本地索引ROWID批量表的访问权限|销售| 13 | 28 | | 3 | BITMAP转换为ROWIDS | | | | | * 4 | BITMAP INDEX单一价值| SALES_PROD_BIX | 13 | 28 | -------------------------------------------------- ------------------------谓词信息（由操作ID标识）：----------------- ---------------------------------- 4  -  access（“PROD_ID”= 38）</code></pre><p>在优化器确定要访问的分区之后，它会考虑在所有这些分区上可用的任何索引。在上一个计划中，优化器选择使用<code class="codeph">sales_prod_bix</code>位图索引。
                              </p>
                           </li>
                           <li>
                              <p>禁用<code class="codeph">sales</code>表的<code class="codeph">SALES_1995</code>分区上的索引：</p><pre class="pre codeblock"><code>一世</code></pre><p>前面的DDL禁用分区1上的索引，该索引包含1996年之前的所有销售。</p>
                              <div class="infoboxnote" id="GUID-74BE3861-35D4-453C-A983-F3317CDA8338__GUID-29D9127A-F87D-49B3-AEC0-85DBFFA916B8">
                                 <p class="notep1">注意：</p>
                                 <p>您可以通过查询<code class="codeph">USER_IND_PARTITIONS</code>视图来获取分区信息。
                                 </p>
                              </div>
                           </li>
                           <li>
                              <p>再次执行sales的查询，然后查询<code class="codeph">DBMS_XPLAN</code>以获取计划。
                              </p>
                              <p>输出显示该计划没有改变：</p><pre class="pre codeblock"><code>计划哈希值：3087065703 --------------------------------------------- ------------------------------ | Id |操作|名称| Pstart | Pstop --------------------------------------------- ------------------------------ | 0 |选择声明| | | | | 1 |分区范围ITERATOR | | 13 | 28 | | 2 |按本地索引ROWID批量表的访问权限|销售| 13 | 28 | | 3 | BITMAP转换为ROWIDS | | | | | * 4 | BITMAP INDEX单一价值| SALES_PROD_BIX | 13 | 28 | -------------------------------------------------- -------------------------谓词信息（由操作ID标识）：---------------- ----------------------------------- 4  -  access（“PROD_ID”= 38）</code></pre><p>计划是相同的，因为禁用的索引分区与查询无关。如果查询访问的所有分区都已编制索引，则数据库可以使用索引回答查询。由于查询仅访问分区16到28，因此禁用分区1上的索引不会影响计划。</p>
                           </li>
                           <li>
                              <p>禁用分区28（ <code class="codeph">SALES_Q4_2003</code> ）的索引，该索引是查询需要访问的分区：</p><pre class="pre codeblock"><code>ALTER INDEX sales_prod_bix MODIFY PARTITION sales_q4_2003 UNUSABLE; ALTER INDEX sales_time_bix MODIFY PARTITION sales_q4_2003 UNUSABLE;</code></pre><p>通过禁用查询确实需要访问的分区上的索引，查询不能再使用此索引（不使用表扩展）。</p>
                           </li>
                           <li>
                              <p>使用<code class="codeph">DBMS_XPLAN</code>查询计划。</p>
                              <p>如以下计划所示，优化器不使用索引：</p><pre class="pre codeblock"><code>计划哈希值：3087065703 --------------------------------------------- ------------------------------ | ID |操作|名称| Pstart | Pstop --------------------------------------------- ------------------------------ | 0 |选择声明| | | | | 1 |分区范围ITERATOR | | 13 | 28 | | * 2 |表访问完全|销售| 13 | 28 | -------------------------------------------------- -------------------------谓词信息（由操作ID标识）：---------------- ----------------------------------- 2  -  access（“PROD_ID”= 38）</code></pre><p>在前面的示例中，查询访问16个分区。在其中的15个分区中，索引可用，但最终分区没有可用的索引。由于优化器必须选择一个访问路径或另一个访问路径，因此优化器无法在任何分区上使用索引。</p>
                           </li>
                           <li>
                              <p>使用表扩展，优化程序将重写原始查询，如下所示：</p><pre class="pre codeblock"><code>SELECT * FROM sales WHERE time_id&gt; = TO_DATE（'2000-01-01 00:00:00'，'SYYYY-MM-DD HH24：MI：SS'）AND time_id <span class="bold">&lt;</span> TO_DATE（'2003-10-01 00:00 ：00'，'SYYYY-MM-DD HH24：MI：SS'）和prod_id = 38 UNION ALL SELECT * FROM sales WHERE time_id&gt; = TO_DATE（'2003-10-01 00:00:00'，'SYYYY-MM -DD HH24：MI：SS'）和time_id <span class="bold">&lt;</span> TO_DATE（'2004-01-01 00:00:00'，'SYYYY-MM-DD HH24：MI：SS'）和prod_id = 38;</code></pre><p>在前面的查询中， <code class="codeph">UNION ALL</code>的第一个查询块访问索引的分区，而第二个查询块访问不是的分区。这两个子查询使优化器能够选择在第一个查询块中使用索引，如果它比使用所访问的所有分区的表扫描更优化。
                              </p>
                           </li>
                           <li>
                              <p>使用<code class="codeph">DBMS_XPLAN</code>查询计划。</p>
                              <p>该计划如下：</p><pre class="pre codeblock"><code>计划哈希值：2120767686 --------------------------------------------- ------------------------------ | Id |操作|名称| Pstart | Pstop | -------------------------------------------------- ------------------------- | 0 |选择声明| | | | | 1 |查看| VW_TE_2 | | | | 2 | UNION-ALL | | | | | 3 |分区范围ITERATOR | | 13 | 27 | | 4 |按本地索引ROWID批量表的访问权限|销售| 13 | 27 | | 5 | BITMAP转换为ROWIDS | | | | | * 6 | BITMAP INDEX单一价值| SALES_PROD_BIX | 13 | 27 | | 7 | PARTITION RANGE SINGLE | | 28 | 28 | | * 8 |表访问完全|销售| 28 | 28 | -------------------------------------------------- -------------------------谓词信息（由操作ID标识）：---------------- ----------------------------------- 6  -  access（“PROD_ID”= 38）8  - 过滤器（“ PROD_ID“= 38）</code></pre><p>如前面的计划所示，优化器对两个查询块使用<code class="codeph">UNION ALL</code> （步骤2）。优化器选择索引以访问第一查询块中的分区13至27（步骤6）。因为没有索引可用于分区28，所以优化器在第二查询块中选择全表扫描（步骤8）。
                              </p>
                           </li>
                        </ol>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="query-transformations.html#GUID-6A6748FA-5803-4837-9A9F-525ED09BE481" title="在表扩展中，优化器生成一个计划，该计划在分区表的读取主要部分上使用索引，但不在表的活动部分上使用索引。">表扩展</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="TGSQL94916"></a><a id="TGSQL94915"></a><div class="props_rev_3"><a id="GUID-C4E94706-3312-4BD6-B6C7-2F4264BB35E9" name="GUID-C4E94706-3312-4BD6-B6C7-2F4264BB35E9"></a><h4 id="TGSQL-GUID-C4E94706-3312-4BD6-B6C7-2F4264BB35E9" class="sect4"><span class="enumeration_section">5.10.4</span>表扩展和星形转换：场景</h4>
                  <div>
                     <p>星型转换支持特定类型的查询，以避免访问大部分大事实表。</p>
                     <div class="section">
                        <p>星型转换需要定义多个索引，这些索引在主动更新的表中可能会产生开销。使用表扩展，您可以仅在非活动分区上定义索引，以便优化程序可以仅考虑表的索引部分上的星形转换。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-C4E94706-3312-4BD6-B6C7-2F4264BB35E9__GUID-FCFEED11-4D8A-4933-AEEB-8FC4C04745FB">假设</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>此方案假定以下内容：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>您查询<span class="q">“ <a href="query-transformations.html#GUID-0694077E-BF83-4D52-99E7-A436C29A6F6D" title="此方案演示了星型查询的星形转换。">Star Transformation：Scenario</a> ”中</span>使用的相同模式。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">sales</code>的最后一个分区正在积极更新，通常情况下是时间分区表。
                              </p>
                           </li>
                           <li>
                              <p>您希望优化器利用表扩展。</p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-C4E94706-3312-4BD6-B6C7-2F4264BB35E9__GUID-62BA2BF6-BFE1-4327-BC17-923935B4B477">要在星型查询中利用表扩展：</p>
                        <ol>
                           <li>
                              <p>禁用最后一个分区上的索引，如下所示：</p><pre class="pre codeblock"><code>ALTER INDEX sales_channel_bix MODIFY PARTITION sales_q4_2003 UNUSABLE; ALTER INDEX sales_cust_bix MODIFY PARTITION sales_q4_2003 UNUSABLE;</code></pre></li>
                           <li>
                              <p>执行以下星型查询：</p><pre class="pre codeblock"><code>SELECT t.calendar_quarter_desc，SUM（s.amount_sold）sales_amount FROM sales s，times t，customers c，channels ch WHERE s.time_id = t.time_id AND s.cust_id = c.cust_id AND s.channel_id = ch.channel_id AND c .cust_state_province ='CA'和ch.channel_desc ='互联网'和t.calendar_quarter_desc IN（'1999-01'，'1999-02'）GROUP BY t.calendar_quarter_desc;</code></pre></li>
                           <li>
                              <p>使用<code class="codeph">DBMS_XPLAN</code>查询游标，显示以下计划：</p><pre class="pre codeblock"><code>-------------------------------------------------- ------------------------- | Id |操作|名称| Pstart时| Pstop | -------------------------------------------------- ------------------------- | 0 |选择声明| | | | | 1 | HASH GROUP BY | | | | | 2 |查看| VW_TE_14 | | | | 3 | UNION-ALL | | | | | 4 | HASH JOIN | | | | | 5 |表访问完整|时间| | | | 6 |查看| VW_ST_1319B6D8 | | | | 7 | NESTED LOOPS | | | | | 8 |分区范围子项| | KEY（SQ）| KEY（SQ）| | 9 | BITMAP转换为ROWIDS | | | | | 10 | BITMAP和| | | | | 11 | BITMAP MERGE | | | | | 12 | BITMAP KEY ITERATION | | | | | 13 | BUFFER SORT | | | | | 14 |表访问完整|通道| | | | 15 | BITMAP INDEX RANGE SCAN | SALES_CHANNEL_BIX | KEY（SQ）| KEY（SQ）| | 16 | BITMAP MERGE | | | | | 17 | BITMAP KEY ITERATION | | | | | 18 | BUFFER SORT | | | | | 19 |表访问完整|时间| | | | 20 | BITMAP INDEX RANGE SCAN | SALES_TIME_BIX | KEY（SQ）| KEY（SQ）| | 21 | BITMAP MERGE | | | | | 22 | BITMAP KEY ITERATION | | | | | 23 | BUFFER SORT | | | | | 24 |表访问完整|客户| | | | 25 | BITMAP INDEX RANGE SCAN | SALES_CUST_BIX | KEY（SQ）| KEY（SQ）| | 26 |按用户进行表访问|销售| ROWID | ROWID | | 27 | NESTED LOOPS | | | | | 28 | NESTED LOOPS | | | | | 29 | NESTED LOOPS | | | | | 30 | NESTED LOOPS | | | | | 31 | PARTITION RANGE SINGLE | | 28 | 28 | | 32 | <span class="bold">表访问完全</span> | <span class="bold">销售</span> | <span class="bold">28</span> | <span class="bold">28</span> | | 33 |通过索引ROWID表示访问|通道| | | | 34 | INDEX UNIQUE SCAN | CHANNELS_PK | | | | 35 |通过INDEX ROWID表示访问权限|客户| | | | 36 | INDEX UNIQUE SCAN | CUSTOMERS_PK | | | | 37 | INDEX UNIQUE SCAN | TIMES_PK | | | | 38 |按INDEX ROWID表示访问权限|时间| | | -------------------------------------------------- -------------------------</code></pre><p>上述计划使用表扩展。正在访问除最后一个分区之外的每个分区的<code class="codeph">UNION ALL</code>分支使用星形转换。由于禁用了分区28上的索引，因此数据库使用全表扫描访问最终分区。
                              </p>
                           </li>
                        </ol>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="query-transformations.html#GUID-6A6748FA-5803-4837-9A9F-525ED09BE481" title="在表扩展中，优化器生成一个计划，该计划在分区表的读取主要部分上使用索引，但不在表的活动部分上使用索引。">表扩展</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div><a id="TGSQL94931"></a><div class="props_rev_3"><a id="GUID-B47BEFB3-D72D-462A-9B96-C3B1F8F48C06" name="GUID-B47BEFB3-D72D-462A-9B96-C3B1F8F48C06"></a><h3 id="TGSQL-GUID-B47BEFB3-D72D-462A-9B96-C3B1F8F48C06" class="sect3"><span class="enumeration_section">5.11</span>加入因式分解</h3>
               <div>
                  <p>在称为<strong class="term">连接因子分解</strong>的基于成本的转换中，优化器可以对来自<code class="codeph">UNION ALL</code>查询的分支的公共计算进行分解。
                  </p>
                  <p>本节包含以下主题：</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="query-transformations.html#GUID-41FA8384-23FF-4683-B1FC-61853209565C">连接因子分解的目的</a><br><code class="codeph">UNION ALL</code>查询在数据库应用程序中很常见，尤其是在数据集成应用程序中。
                     </li>
                     <li class="ulchildlink"><a href="query-transformations.html#GUID-253951D9-63D9-4989-86F6-FA4AC6AFF0BD">联合分解如何工作</a><br>连接因子分解可以分解多个表以及两个以上的<code class="codeph">UNION ALL</code>分支。
                     </li>
                     <li class="ulchildlink"><a href="query-transformations.html#GUID-E3AA79CC-74CA-44C0-A15B-1827FE27609D">分解和加入订单：场景</a><br>连接因子分解可以为连接顺序创建更多可能性</li>
                     <li class="ulchildlink"><a href="query-transformations.html#GUID-FA012F21-6BEF-444A-89E4-4DCDBC9F0225">外连接的因式分解：场景</a><br>数据库支持外连接，反连接和半连接的连接分解，但仅适用于此类连接中的右表。
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="query-transformations.html#GUID-B2914447-CD6D-411C-8467-6E10E78F3DE0" title="本章介绍了用于转换查询的最重要的优化器技术。">查询转换</a></p>
                     </div>
                  </div>
               </div>
               <a id="TGSQL94932"></a><div class="props_rev_3"><a id="GUID-41FA8384-23FF-4683-B1FC-61853209565C" name="GUID-41FA8384-23FF-4683-B1FC-61853209565C"></a><h4 id="TGSQL-GUID-41FA8384-23FF-4683-B1FC-61853209565C" class="sect4"><span class="enumeration_section">5.11.1</span>连接分解的目的</h4>
                  <div>
                     <p><code class="codeph">UNION ALL</code>查询在数据库应用程序中很常见，尤其是在数据集成应用程序中。
                     </p>
                     <p>通常， <code class="codeph">UNION ALL</code>查询中的分支引用相同的基表。如果没有连接因子分解，优化器将独立评估<code class="codeph">UNION ALL</code>查询的每个分支，从而导致重复处理，包括数据访问和连接。连接因子分解转换可以跨<code class="codeph">UNION ALL</code>分支共享公共计算。避免额外扫描大型基表可以带来巨大的性能提升。
                     </p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="query-transformations.html#GUID-B47BEFB3-D72D-462A-9B96-C3B1F8F48C06" title="在称为连接因子分解的基于成本的转换中，优化器可以对来自UNION ALL查询的分支的公共计算进行分解。">加入分解</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="TGSQL94934"></a><a id="TGSQL94935"></a><a id="TGSQL94933"></a><div class="props_rev_3"><a id="GUID-253951D9-63D9-4989-86F6-FA4AC6AFF0BD" name="GUID-253951D9-63D9-4989-86F6-FA4AC6AFF0BD"></a><h4 id="TGSQL-GUID-253951D9-63D9-4989-86F6-FA4AC6AFF0BD" class="sect4"><span class="enumeration_section">5.11.2</span>联接分解如何工作</h4>
                  <div>
                     <p>连接因子分解可以分解多个表以及两个以上的<code class="codeph">UNION ALL</code>分支。
                     </p>
                     <p>通过示例可以最好地解释连接因子分解。</p>
                     <div class="example" id="GUID-253951D9-63D9-4989-86F6-FA4AC6AFF0BD__BABCAIGD">
                        <p class="titleinexample">例5-11 UNION ALL查询</p>
                        <p>以下查询显示了对四个表（ <code class="codeph">t1</code> ， <code class="codeph">t2</code> ， <code class="codeph">t3</code>和<code class="codeph">t4</code> ）和两个<code class="codeph">UNION ALL</code>分支的查询：</p><pre class="pre codeblock"><code>SELECT t1.c1，t2.c2 FROM <span class="bold">t1</span> ，t2，t3 WHERE <span class="bold">t1.c1 = t2.c1</span> AND <span class="bold">t1.c1&gt; 1</span> AND t2.c2 = 2 AND t2.c2 = t3.c2 UNION ALL SELECT t1.c1，t2 .c2 FROM <span class="bold">t1</span> ，t2，t4 WHERE <span class="bold">t1.c1 = t2.c1</span> AND <span class="bold">t1.c1&gt; 1</span> AND t2.c3 = t4.c3</code></pre><p>在前面的查询中，表<code class="codeph">t1</code>出现在两个<code class="codeph">UNION ALL</code>分支中，过滤谓词<code class="codeph">t1.c1 &gt; 1</code>和连接谓词<code class="codeph">t1.c1 = t2.c1</code> 。如果没有任何转换，数据库必须对表<code class="codeph">t1</code>两次扫描和过滤，每次分支执行一次。
                        </p>
                     </div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-253951D9-63D9-4989-86F6-FA4AC6AFF0BD__BABFAEBB">
                        <p class="titleinexample">例5-12分解查询</p>以下查询使用连接因子分解来转换<a href="query-transformations.html#GUID-253951D9-63D9-4989-86F6-FA4AC6AFF0BD__BABCAIGD">示例5-11中</a>的查询。<pre class="pre codeblock"><code>SELECT t1.c1，VW_JF_1.item_2 FROM <span class="bold">t1</span> ，（SELECT t2.c1 item_1，t2.c2 item_2 FROM t2，t3 WHERE t2.c2 = t3.c2 AND t2.c2 = 2 UNION ALL SELECT t2.c1 item_1，t2。 c2 item_2 FROM t2，t4 WHERE t2.c3 = t4.c3）VW_JF_1 WHERE <span class="bold">t1.c1 = VW_JF_1.item_1</span> AND <span class="bold">t1.c1&gt; 1</span>
</code></pre><p>在这种情况下，因为表<code class="codeph">t1</code>是分解的，所以数据库只对<code class="codeph">t1</code>执行表扫描和过滤一次。如果<code class="codeph">t1</code>很大，那么这种因式分解避免了两次扫描和过滤<code class="codeph">t1</code>的巨大性能成本。
                        </p>
                        <div class="infoboxnote" id="GUID-253951D9-63D9-4989-86F6-FA4AC6AFF0BD__GUID-0A2942E9-58DE-454D-8690-1662E9A9027A">
                           <p class="notep1">注意：</p>
                           <p>如果<code class="codeph">UNION ALL</code>查询中的分支具有使用<code class="codeph">DISTINCT</code>函数的子句，则连接因子分解无效。
                           </p>
                        </div>
                     </div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="query-transformations.html#GUID-B47BEFB3-D72D-462A-9B96-C3B1F8F48C06" title="在称为连接因子分解的基于成本的转换中，优化器可以对来自UNION ALL查询的分支的公共计算进行分解。">加入分解</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="TGSQL94937"></a><a id="TGSQL94938"></a><a id="TGSQL94939"></a><a id="TGSQL94936"></a><div class="props_rev_3"><a id="GUID-E3AA79CC-74CA-44C0-A15B-1827FE27609D" name="GUID-E3AA79CC-74CA-44C0-A15B-1827FE27609D"></a><h4 id="TGSQL-GUID-E3AA79CC-74CA-44C0-A15B-1827FE27609D" class="sect4"><span class="enumeration_section">5.11.3因子</span>分解和连接顺序：场景</h4>
                  <div>
                     <p>连接因子分解可以为连接顺序创建更多可能性</p>
                     <div class="example" id="GUID-E3AA79CC-74CA-44C0-A15B-1827FE27609D__BABFEJHJ">
                        <p class="titleinexample">例5-13涉及五个表的查询</p>
                        <p>在以下查询中，视图<code class="codeph">V</code>与<a href="query-transformations.html#GUID-253951D9-63D9-4989-86F6-FA4AC6AFF0BD__BABCAIGD">示例5-11中</a>的查询相同：</p><pre class="pre codeblock"><code>SELECT * FROM t5，（SELECT t1.c1，t2.c2 FROM t1，t2，t3 WHERE t1.c1 = t2.c1 AND t1.c1&gt; 1 AND t2.c2 = 2 AND t2.c2 = t3.c2 UNION ALL SELECT t1.c1，t2.c2 FROM t1，t2，t4 WHERE t1.c1 = t2.c1 AND t1.c1&gt; 1 AND t2.c3 = t4.c3）V WHERE t5.c1 = V.c1</code></pre>在连接因子分解之前，数据库必须在加入<code class="codeph">t5</code>之前加入<code class="codeph">t1</code> ， <code class="codeph">t2</code>和<code class="codeph">t3</code> 。
                     </div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-E3AA79CC-74CA-44C0-A15B-1827FE27609D__BABIGECD">
                        <p class="titleinexample">实施例5-14来自视图V的t1的因子分解</p>
                        <p>如果连接因子分解从视图<code class="codeph">V</code>分解<code class="codeph">t1</code> ，如下面的查询所示，则数据库可以将<code class="codeph">t1</code>与<code class="codeph">t5</code> 。</p><pre class="pre codeblock"><code>SELECT * FROM <span class="bold">t5</span> ，（SELECT t1.c1，VW_JF_1.item_2 FROM <span class="bold">t1</span> ，（SELECT t2.c1 item_1，t2.c2 item_2 FROM t2，t3 WHERE t2.c2 = t3.c2 AND t2.c2 = 2 UNION ALL SELECT t2 .c1 item_1，t2.c2 item_2 FROM t2，t4 WHERE t2.c3 = t4.c3）VW_JF_1 WHERE t1.c1 = VW_JF_1.item_1 AND t1.c1&gt; 1）WHERE t5.c1 = V.c1</code></pre><p>前面的查询转换会打开新的连接顺序。但是，连接因子分解会强制执行特定的连接顺序。例如，在前面的查询中，表<code class="codeph">t2</code>和<code class="codeph">t3</code>出现在视图<code class="codeph">VW_JF_1</code> <code class="codeph">UNION ALL</code>查询的第一个分支中。该数据库必须加入<code class="codeph">t2</code>与<code class="codeph">t3</code>才能与加盟<code class="codeph">t1</code> ，这是不是中定义<code class="codeph">VW_JF_1</code>视图。强加的连接顺序可能不一定是最佳连接顺序。因此，优化器使用基于成本的转换框架执行连接因子分解。优化器使用和不使用连接因子分解来计算计划的成本，然后选择最便宜的计划。
                        </p>
                     </div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-E3AA79CC-74CA-44C0-A15B-1827FE27609D__BABFAEGB">
                        <p class="titleinexample">示例5-15已删除视图定义的视图V中t1的分解</p>
                        <p>以下查询与<a href="query-transformations.html#GUID-E3AA79CC-74CA-44C0-A15B-1827FE27609D__BABIGECD">示例5-14中的</a>查询相同，但删除了视图定义，以便更容易看到分解：</p><pre class="pre codeblock"><code>SELECT * FROM <span class="bold">t5</span> ，（SELECT t1.c1，VW_JF_1.item_2 FROM <span class="bold">t1</span> ，VW_JF_1 WHERE t1.c1 = VW_JF_1.item_1 AND t1.c1&gt; 1）WHERE t5.c1 = V.c1</code></pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="query-transformations.html#GUID-B47BEFB3-D72D-462A-9B96-C3B1F8F48C06" title="在称为连接因子分解的基于成本的转换中，优化器可以对来自UNION ALL查询的分支的公共计算进行分解。">加入分解</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="TGSQL94941"></a><a id="TGSQL94942"></a><a id="TGSQL94940"></a><div class="props_rev_3"><a id="GUID-FA012F21-6BEF-444A-89E4-4DCDBC9F0225" name="GUID-FA012F21-6BEF-444A-89E4-4DCDBC9F0225"></a><h4 id="TGSQL-GUID-FA012F21-6BEF-444A-89E4-4DCDBC9F0225" class="sect4"><span class="enumeration_section">5.11.4</span>外连接的<span class="enumeration_section">因子</span>分解：场景</h4>
                  <div>
                     <p>数据库支持外连接，反连接和半连接的连接分解，但仅适用于此类连接中的右表。</p>
                     <p>例如，连接因子分解可以通过分解<code class="codeph">t2</code>来转换以下<code class="codeph">UNION ALL</code>查询：</p><pre class="pre codeblock"><code>SELECT t1.c2，t2.c2 FROM t1，t2 WHERE t1.c1 = t2.c1（+）AND t1.c1 = 1 UNION ALL SELECT t1.c2，t2.c2 FROM t1，t2 WHERE t1.c1 = t2。 c1（+）AND t1.c1 = 2</code></pre><p>以下示例显示了转换。表<code class="codeph">t2</code>现在不再出现在子查询的<code class="codeph">UNION ALL</code>分支中。
                     </p><pre class="pre codeblock"><code>SELECT VW_JF_1.item_2，t2.c2 FROM t2，（SELECT t1.c1 item_1，t1.c2 item_2 FROM t1 WHERE t1.c1 = 1 UNION ALL SELECT t1.c1 item_1，t1.c2 item_2 FROM t1 WHERE t1.c1 = 2 ）VW_JF_1 WHERE VW_JF_1.item_1 = t2.c1（+）</code></pre></div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="query-transformations.html#GUID-B47BEFB3-D72D-462A-9B96-C3B1F8F48C06" title="在称为连接因子分解的基于成本的转换中，优化器可以对来自UNION ALL查询的分支的公共计算进行分解。">加入分解</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div>
         </div>
      </article>
   </body>
</html>