<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <meta name="abstract" content="Oracle Text offers various approaches to document classification."></meta>
      <meta name="description" content="Oracle Text offers various approaches to document classification."></meta>
      <title>在Oracle Text中对文档进行分类</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Application Developer&#39;s Guide "></meta>
      <meta property="og:description" content="Oracle Text offers various approaches to document classification."></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Application Developer&#39;s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="text-application-developers-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-07T01:45:16-08:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="2001, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96275-01"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="presenting-documents-in-oracle-text.html" title="Previous" type="text/html"></link>
      <link rel="next" href="tuning-oracle-text.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Text Application Developer&#39;s Guide"></meta>
    <meta name="dcterms.isVersionOf" content="CCAPP"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="presenting-documents-in-oracle-text.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="tuning-oracle-text.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">应用程序开发人员指南</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">在Oracle Text中对文档进行分类</li>
            </ol>
            <a id="GUID-D694A98B-3B18-48B2-B10E-FB884B436FAF" name="GUID-D694A98B-3B18-48B2-B10E-FB884B436FAF"></a><a id="CCAPP0600"></a>
            
            <h2 id="CCAPP-GUID-D694A98B-3B18-48B2-B10E-FB884B436FAF" class="sect2"><span class="enumeration_chapter">9</span>在Oracle Text中分类文档</h2>
         </header>
         <div class="ind">
            <div>
               <p>Oracle Text提供了各种文档分类方法。</p>
               <p>本章包含以下主题：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="classifying-documents-in-oracle-text.html#GUID-69EAD761-8C53-455D-91F3-C85E84F27A70">文档分类概述</a></p>
                  </li>
                  <li>
                     <p><a href="classifying-documents-in-oracle-text.html#GUID-78D0D7EE-4D60-49C0-B481-4D20A4F3246D">分类申请</a></p>
                  </li>
                  <li>
                     <p><a href="classifying-documents-in-oracle-text.html#GUID-0F765E2D-A7B2-48C5-A6A0-49EBBBD0E39F">分类方案</a></p>
                  </li>
                  <li>
                     <p><a href="classifying-documents-in-oracle-text.html#GUID-8D624E54-C32A-42A8-A6AF-DF64237242F2">基于规则的分类</a></p>
                  </li>
                  <li>
                     <p><a href="classifying-documents-in-oracle-text.html#GUID-D1458643-CD73-4092-B821-44BCFB85CAE6">监督分类</a></p>
                  </li>
                  <li>
                     <p><a href="classifying-documents-in-oracle-text.html#GUID-9318FD70-869D-4465-A51E-58FB7803AB4C">无监督分类（聚类）</a></p>
                  </li>
                  <li>
                     <p><a href="classifying-documents-in-oracle-text.html#GUID-BB043FA2-B89C-4D89-9C9B-E410D85629CC">无监督分类（聚类）示例</a></p>
                  </li>
               </ul>
            </div><a id="CCAPP9214"></a><div class="props_rev_3"><a id="GUID-69EAD761-8C53-455D-91F3-C85E84F27A70" name="GUID-69EAD761-8C53-455D-91F3-C85E84F27A70"></a><h3 id="CCAPP-GUID-69EAD761-8C53-455D-91F3-C85E84F27A70" class="sect3"><span class="enumeration_section">9.1</span>文档分类概述</h3>
               <div>
                  <p>每个主题都是单个单词，单个短语或父主题的分层列表。</p>
                  <p>要筛选大量文档，您可以使用关键字搜索引擎。但是，关键字搜索有局限性。一个主要缺点是关键字搜索不能通过上下文区分。在许多语言中，单词或短语可能具有多种含义，因此搜索可能会导致许多与特定主题无关的匹配。例如，关于短语<span class="italic">河岸</span>的查询可能会返回有关哈德逊河岸和信托公司的文件，因为单词<span class="italic">bank</span>有两个含义。
                  </p>
                  <p>或者，您可以对文档进行排序并按内容对其进行分类。这种方法对于大量文档是不可行的。</p>
                  <p>Oracle Text提供了各种文档分类方法。在<span class="italic">基于规则的分类</span> （有时称为<span class="italic">简单分类</span> ）下，您自己编写分类规则。通过<span class="italic">监督分类</span> ，Oracle Text基于您预分类的一组示例文档创建分类规则。最后，通过<span class="italic">无监督分类</span> （也称为<span class="italic">聚类</span> ），Oracle Text将执行从编写分类规则到为文档分类的所有步骤。
                  </p>
               </div>
            </div><a id="CCAPP9512"></a><a id="CCAPP9215"></a><div class="props_rev_3"><a id="GUID-78D0D7EE-4D60-49C0-B481-4D20A4F3246D" name="GUID-78D0D7EE-4D60-49C0-B481-4D20A4F3246D"></a><h3 id="CCAPP-GUID-78D0D7EE-4D60-49C0-B481-4D20A4F3246D" class="sect3"><span class="enumeration_section">9.2</span>分类申请</h3>
               <div>
                  <p>Oracle Text使您能够构建基于文档内容执行某些操作的文档分类应用程序。操作包括将类别ID分配给文档以供将来查找或将文档发送给用户。结果是分类文档的集合或流。<a href="classifying-documents-in-oracle-text.html#GUID-78D0D7EE-4D60-49C0-B481-4D20A4F3246D__I1008553">图9-1</a>说明了分类过程的工作原理。
                  </p>
                  <p>Oracle Text使您能够以不同方式创建文档分类应用程序。本章定义了典型的分类方案，并展示了如何使用Oracle Text构建解决方案。</p>
                  <div class="figure" id="GUID-78D0D7EE-4D60-49C0-B481-4D20A4F3246D__I1008553">
                     <p class="titleinfigure">图9-1文档分类应用程序概述</p><img src="img/ccapp_pb_018a.png" width="516" alt="下面是图9-1的描述" title="下面是图9-1的描述" longdesc="img_text/ccapp_pb_018a.html"><br><a href="img_text/ccapp_pb_018a.html">“图9-1文档分类应用程序概述”的说明</a></div>
                  <!-- class="figure" -->
               </div>
            </div><a id="CCAPP9216"></a><div class="props_rev_3"><a id="GUID-0F765E2D-A7B2-48C5-A6A0-49EBBBD0E39F" name="GUID-0F765E2D-A7B2-48C5-A6A0-49EBBBD0E39F"></a><h3 id="CCAPP-GUID-0F765E2D-A7B2-48C5-A6A0-49EBBBD0E39F" class="sect3"><span class="enumeration_section">9.3</span>分类解决方案</h3>
               <div>
                  <p>Oracle Text使您可以通过以下方式对文档进行分类：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="classifying-documents-in-oracle-text.html#GUID-8D624E54-C32A-42A8-A6AF-DF64237242F2">基于规则的分类</a> 。对于此解决方案，您可以对文档进行分组，选择类别，并制定定义这些类别的规则;这些规则实际上是查询短语。然后，您可以索引规则并使用<code class="codeph">MATCHES</code>运算符对文档进行分类。
                        </p>
                        <p><span class="bold">优点：</span>此解决方案对于小型文档集非常准确。结果总是基于您定义的内容，因为您编写规则。
                        </p>
                        <p><span class="bold">缺点：</span>对于具有许多类别的大型文档集，定义规则可能很繁琐。随着文档集的增长，您可能需要编写相应的更多规则。
                        </p>
                     </li>
                     <li>
                        <p><a href="classifying-documents-in-oracle-text.html#GUID-D1458643-CD73-4092-B821-44BCFB85CAE6">监督分类</a> 。此解决方案类似于基于规则的分类，但使用<code class="codeph">CTX_CLS.TRAIN.</code>自动执行规则编写步骤<code class="codeph">CTX_CLS.TRAIN.</code>此过程根据您提供的一组预先分类的文档制定一组分类规则。与基于规则的分类一样，您可以使用<code class="codeph">MATCHES</code>运算符对文档进行分类。
                        </p>
                        <p>Oracle Text提供两种版本的监督分类，一种使用<code class="codeph">RULE_CLASSIFIER</code>首选项，另一种使用<code class="codeph">SVM_CLASSIFIER</code>首选项。这些偏好在<span class="q">“ <a href="classifying-documents-in-oracle-text.html#GUID-D1458643-CD73-4092-B821-44BCFB85CAE6">监督分类</a> ”</span>中讨论。
                        </p>
                        <p><span class="bold">优点</span> ：自动为您编写规则。此方法对大型文档集很有用。
                        </p>
                        <p><span class="bold">缺点：</span>在生成规则之前，必须将文档分配给类别。规则可能不像您自己编写的那样具体或准确。
                        </p>
                     </li>
                     <li>
                        <p><a href="classifying-documents-in-oracle-text.html#GUID-9318FD70-869D-4465-A51E-58FB7803AB4C">无监督分类（聚类）</a> 。从分组文档到编写类别规则的所有步骤都通过<code class="codeph">CTX_CLS.CLUSTERING.</code>自动<code class="codeph">CTX_CLS.CLUSTERING.</code> Oracle Text统计分析您的文档集，并根据内容将它们与集群相关联。
                        </p>
                        <p><span class="bold">好处：</span>   
                        </p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>您无需提供分类规则或示例文档作为训练集。</p>
                           </li>
                           <li>
                              <p>此解决方案有助于发现文档集中忽略的模式和内容相似性。</p>
                              <p>实际上，当您对规则或分类没有明确的概念时，可以使用此解决方案。例如，使用它来提供一组初始类别，并通过监督分类建立类别。</p>
                           </li>
                        </ul>
                        <p><span class="bold">缺点：</span></p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>群集基于内部解决方案。它可能会导致意外分组，因为群集操作不是用户定义的。</p>
                           </li>
                           <li>
                              <p>您没有看到创建群集的规则。</p>
                           </li>
                           <li>
                              <p>群集操作是CPU密集型的，并且至少可以与索引相同。</p>
                           </li>
                        </ul>
                     </li>
                  </ul>
               </div>
            </div><a id="CCAPP9217"></a><div class="props_rev_3"><a id="GUID-8D624E54-C32A-42A8-A6AF-DF64237242F2" name="GUID-8D624E54-C32A-42A8-A6AF-DF64237242F2"></a><h3 id="CCAPP-GUID-8D624E54-C32A-42A8-A6AF-DF64237242F2" class="sect3"><span class="enumeration_section">9.4</span>基于规则的分类</h3>
               <div>
                  <p>基于规则的分类是创建Oracle Text分类应用程序的基本解决方案。</p>
                  <p>基于规则的分类的基本步骤如下。在该示例中更详细地探索了具体步骤。</p>
                  <ol>
                     <li>
                        <p>为要分类的文档创建一个表，然后填充它。</p>
                     </li>
                     <li>
                        <p>创建规则表（也称为<span class="italic">类别表</span> ）。规则表由您命名的类别组成，例如“药品”或“财务”，以及将文档分类到这些类别的规则。
                        </p>
                        <p>这些规则实际上是查询。例如，您将“药物”类别定义为包含“医院”，“医生”或“疾病”等字样的文档。因此，您将以“医院或医生或疾病”的形式制定规则。</p>
                     </li>
                     <li>
                        <p>在规则表上创建<code class="codeph">CTXRULE</code>索引。
                        </p>
                     </li>
                     <li>
                        <p>对文件进行分类。</p>
                     </li>
                  </ol>
                  <div class="infoboxnotealso" id="GUID-8D624E54-C32A-42A8-A6AF-DF64237242F2__GUID-28AF0D70-2ACD-4AB1-841D-2E415C52580D">
                     <p class="notep1">也可以看看：</p>
                     <p><span class="q">“ <a href="classifying-documents-in-oracle-text.html#GUID-247843B1-57A0-429E-8656-E7DCE4C2B299">CTXRULE参数和限制</a> ”，</span>用于获取有关哪些运算符进行查询的信息</p>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-63A3A20D-6EB4-4913-8687-BC24280E1434" name="GUID-63A3A20D-6EB4-4913-8687-BC24280E1434"></a><h4 id="CCAPP-GUID-63A3A20D-6EB4-4913-8687-BC24280E1434" class="sect4"><span class="enumeration_section">9.4.1</span>基于规则的分类示例</h4>
                  <div>
                     <div class="section">
                        <p>在此示例中，您将收集有关不同主题的新闻文章，然后对其进行分类。</p>
                        <p>创建规则后，可以对它们建立索引，然后使用<code class="codeph">MATCHES</code>语句对文档进行分类。
                        </p>
                        <p>要对文件进行分类：</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>创建架构以存储数据。</span><div>
                              <p><code class="codeph">news_table</code>存储要分类的文档。<code class="codeph">news_categories</code>表存储定义类别的类别和规则。<code class="codeph">news_id_cat</code>表在分类后存储文档ID及其关联的类别。
                              </p><pre class="oac_no_warn" dir="ltr">create table news_table（tk number primary key not null，title varchar2（1000），text clob）; create table news_categories（queryid number primary key not null，category varchar2（100），query varchar2（2000））; create table news_id_cat（tk number，category_id number）;</pre></div>
                        </li>
                        <li class="stepexpand"><span>使用SQLLDR加载文档。</span><div>
                              <p>使用<code class="codeph">SQLLDR</code>程序将HTML新闻文章加载到<code class="codeph">news_table.</code> 从<code class="codeph">loader.dat.</code>读取文件名和标题<code class="codeph">loader.dat.</code></p><pre class="oac_no_warn" dir="ltr">LOAD DATA INFILE'loading.dat'INTO TABLE news_table REPLACE FIELDS终止';' （tk INTEGER EXTERNAL，标题CHAR，text_file FILLER CHAR，文本LOBFILE（text_file）由EOF终止）</pre></div>
                        </li>
                        <li class="stepexpand"><span>创建类别并为每个类别编写规则。</span><div>
                              <p>定义的类别包括亚洲，欧洲，非洲，中东，拉丁美洲，美国，冲突，金融，技术，消费电子，世界政治，美国政治，天文学，古生物学，健康，自然灾害，法律和音乐新闻。</p>
                              <p>规则是选择类别文档的查询。例如，“亚洲”类别具有“中国或巴基斯坦或印度或日本”的规则。在<code class="codeph">news_categories</code>表中插入规则。
                              </p><pre class="oac_no_warn" dir="ltr">插入news_categories值（1，'美国'，'华盛顿或乔治布什或科林鲍威尔'）;插入news_categories值（2，'欧洲'，'英格兰或英国或德国'）;插入news_categories值（3，'中东'，'以色列或伊朗或巴勒斯坦'）;插入news_categories值（4，'亚洲'，'中国或巴基斯坦或印度或日本'）;插入news_categories值（5，'非洲'，'埃及或肯尼亚或尼日利亚'）;插入news_categories值（6，'冲突'，'战争或士兵或军队或部队'）;插入news_categories值（7，'财务'，'损益或华尔街'）;插入news_categories值（8，'技术'，'软件或计算机或Oracle或Intel或IBM或Microsoft'）;插入news_categories值（9，'消费电子产品'，'高清电视或电子产品'）;插入news_categories值（10，'拉丁美洲'，'委内瑞拉或哥伦比亚或阿根廷或巴西或智利'）;插入news_categories值（11，'世界政治'，'雨果查韦斯或乔治布什或托尼布莱尔或萨达姆侯赛因或联合国'）;插入news_categories值（12，'美国政治'，'乔治布什或民主党或共和党人或民权或参议院或白宫'）;插入news_categories值（13，'天文学'，'木星或地球或星球或行星或猎户座或金星或水星或火星或银河系或望远镜或天文学家或NASA或宇航员'）;插入news_categories值（14，'古生物学'，'化石或科学家或古生物学家或恐龙或自然'）;插入news_categories值（15，'健康'，'干细胞或胚胎或健康或医疗或药物或世界卫生组织或艾滋病或HIV或病毒或疾病控制或疫苗接种中心'）;插入news_categories值（16，'自然灾害'，'地震或飓风或龙卷风'）;插入news_categories值（17，'法律'，'堕胎或最高法院或非法或法律或立法'）;插入news_categories值（18，'音乐新闻'，'盗版或反盗版或美国唱片业协会或版权或版权保护或CD或音乐或艺术家或歌曲'）;承诺;</pre></div>
                        </li>
                        <li class="stepexpand"><span>在<code class="codeph">news_categories</code>查询列上创建<code class="codeph">CTXRULE</code>索引。</span><div><pre class="oac_no_warn" dir="ltr">在news_categories（查询）上创建索引news_cat_idx indextype是ctxsys.ctxrule;</pre></div>
                        </li>
                        <li class="stepexpand"><span>要对文档进行分类，请使用<code class="codeph">CLASSIFIER.THIS</code> PL / SQL过程（为此示例设计的简单过程）。</span><div>
                              <p>该过程滚动<code class="codeph">news_table,</code>将每个文档与类别匹配，并将分类结果写入<code class="codeph">news_id_cat</code>表。
                              </p><pre class="oac_no_warn" dir="ltr">创建或替换包分类器asprocedure this; end; / show errors创建或替换包体分类器作为过程这是v_document clob; v_item号码; v_doc号码; doc for doc in（select tk，text from news_table）loop v_document：= doc.text; v_item：= 0; v_doc：= doc.tk; for c in（select queryid，news_categories中的类别匹配（query，v_document）&gt; 0）loop v_item：= v_item + 1;插入news_id_cat值（doc.tk，c.queryid）;结束循环;结束循环;结束这个;结束; / show errors exec classifier.this</pre></div>
                        </li>
                     </ol>
                  </div>
               </div><a id="CCAPP9219"></a><div class="props_rev_3"><a id="GUID-247843B1-57A0-429E-8656-E7DCE4C2B299" name="GUID-247843B1-57A0-429E-8656-E7DCE4C2B299"></a><h4 id="CCAPP-GUID-247843B1-57A0-429E-8656-E7DCE4C2B299" class="sect4"><span class="enumeration_section">9.4.2</span> CTXRULE参数和限制</h4>
                  <div>
                     <p>以下注意事项适用于索引<code class="codeph">CTXRULE</code>索引：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a id="d23044e771" class="indexterm-anchor"></a><a id="d23044e775" class="indexterm-anchor"></a>如果使用<code class="codeph">SVM_CLASSIFIER</code>分类器，则可以使用<code class="codeph">BASIC_LEXER,</code> <code class="codeph">CHINESE_LEXER,</code> <code class="codeph">JAPANESE_LEXER,</code>或<code class="codeph">KOREAN_MORPH_LEXER</code>词法分析器。如果不使用<code class="codeph">SVM_CLASSIFIER,</code>则只能使用<code class="codeph">BASIC_LEXER</code>词法分类器类型来索引查询集。
                           </p>
                        </li>
                        <li>
                           <p>过滤器，内存，数据存储区和[no]填充参数不适用于<code class="codeph">CTXRULE</code>索引类型。
                           </p>
                        </li>
                        <li>
                           <p>支持<code class="codeph">CREATE</code> <code class="codeph">INDEX</code>存储子句在查询上创建索引。
                           </p>
                        </li>
                        <li>
                           <p>您的查询集上的词干分析操作支持Wordlists。</p>
                        </li>
                        <li>
                           <p><code class="codeph">CTXRULE</code>查询类似于<code class="codeph">CONTAINS</code>查询。支持基本措辞（“狗屋”），以及以下<code class="codeph">CONTAINS</code>运算符： <code class="codeph">ABOUT,</code> <code class="codeph">AND,</code> <code class="codeph">NEAR,</code> <code class="codeph">NOT,</code> <code class="codeph">OR,</code> <code class="codeph">STEM,</code> <code class="codeph">WITHIN,</code>和<code class="codeph">THESAURUS.</code>支持使用<code class="codeph">MATCHES</code>运算符对文档进行分类。还支持现场部分;但是， <code class="codeph">CTXRULE</code>不直接支持字段查询，因此必须在<code class="codeph">CONTEXT</code>查询上使用查询重写。
                           </p>
                        </li>
                        <li>
                           <p>在导出或降级数据库之前，必须删除<code class="codeph">CTXRULE</code>索引。
                           </p>
                        </li>
                     </ul>
                     <div class="infoboxnotealso" id="GUID-247843B1-57A0-429E-8656-E7DCE4C2B299__GUID-10AF621D-CEF7-425B-BD43-65DBAEDBF6D5">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>有关词法分析器和分类器首选项的更多信息，请参阅<a href="../ccref/oracle-text-indexing-elements.html#CCREF0200" target="_blank"><span class="italic">Oracle Text Reference</span></a></p>
                           </li>
                           <li>
                              <p><span class="q">“ <a href="creating-oracle-text-indexes.html#GUID-32E664C4-0379-4CC0-8040-67B2CFED020C">创建CTXRULE索引</a> ”</span></p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div>
            </div><a id="CCAPP9220"></a><div class="props_rev_3"><a id="GUID-D1458643-CD73-4092-B821-44BCFB85CAE6" name="GUID-D1458643-CD73-4092-B821-44BCFB85CAE6"></a><h3 id="CCAPP-GUID-D1458643-CD73-4092-B821-44BCFB85CAE6" class="sect3"><span class="enumeration_section">9.5</span>监督分类</h3>
               <div>
                  <p>使用监督分类，您可以使用<a href="../ccref/CTX_CLS-package.html#CCREF1500" target="_blank"><code class="codeph">CTX_CLS.TRAIN</code></a>过程自动执行规则编写步骤。<code class="codeph">CTX_CLS.TRAIN</code>使用一组训练样本文档来推导分类规则。与基于规则的分类相比，此训练集是主要优势，您必须编写分类规则。
                  </p>
                  <p>但是，在运行<code class="codeph">CTX_CLS.TRAIN</code>过程之前，必须手动创建类别并将示例训练集中的每个文档分配到一个类别。
                  </p>
                  <div class="infoboxnotealso" id="GUID-D1458643-CD73-4092-B821-44BCFB85CAE6__GUID-019C7C83-56B2-43A5-95DC-C7354686E5DA">
                     <p class="notep1">也可以看看：</p>
                     <p>有关<code class="codeph">CTX_CLS.TRAIN</code>更多信息，请<code class="codeph">CTX_CLS.TRAIN</code> <a href="../ccref/CTX_CLS-package.html#CCREF1500" target="_blank"><span class="italic">Oracle Text Reference</span></a></p>
                  </div>
                  <p>生成规则时，将其<code class="codeph">CTXRULE</code>索引以创建<code class="codeph">CTXRULE</code>索引。然后，您可以使用<code class="codeph">MATCHES</code>运算符对传入的新文档流进行分类。
                  </p>
                  <p>您可以为监督分类选择以下分类算法之一：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="classifying-documents-in-oracle-text.html#GUID-FCCA9B53-65A4-47A8-9B21-5F918F9393B3">决策树监督分类</a></p>
                        <p>这种分类的优点是易于观察（和修改）生成的规则。</p>
                     </li>
                     <li>
                        <p><a href="classifying-documents-in-oracle-text.html#GUID-1366708C-4B91-4FF4-A955-F083F059D3AF">基于SVM的监督分类</a></p>
                        <p>此分类使用支持向量机（SVM）算法来创建规则。这种分类的优点是它通常比决策树分类更准确。缺点是它生成二进制规则，因此规则本身是不透明的。</p>
                     </li>
                  </ul>
                  <div class="infoboxnotealso" id="GUID-D1458643-CD73-4092-B821-44BCFB85CAE6__GUID-316A823A-A82C-4941-ACDE-F1649F4BE76E">
                     <p class="notep1">也可以看看：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><span class="q">“ <a href="classifying-documents-in-oracle-text.html#GUID-17173FFD-EFDC-40C6-9F7E-9FCA38188D13">决策树监督分类示例</a> ”</span></p>
                        </li>
                        <li>
                           <p><span class="q">“ <a href="classifying-documents-in-oracle-text.html#GUID-9F2196D4-C073-4B2F-A3C2-6B9369249896">基于SVM的监督分类示例</a> ”</span></p>
                        </li>
                     </ul>
                  </div>
               </div><a id="CCAPP9221"></a><div class="props_rev_3"><a id="GUID-FCCA9B53-65A4-47A8-9B21-5F918F9393B3" name="GUID-FCCA9B53-65A4-47A8-9B21-5F918F9393B3"></a><h4 id="CCAPP-GUID-FCCA9B53-65A4-47A8-9B21-5F918F9393B3" class="sect4"><span class="enumeration_section">9.5.1</span>决策树监督分类</h4>
                  <div>
                     <p>要使用决策树分类，请将<code class="codeph">CTX_CLS.TRAIN</code>的首选参数设置为<code class="codeph">RULE_CLASSIFIER.</code></p>
                     <p>这种分类形式使用<span class="italic">决策树</span>算法来创建规则。一般而言，决策树是一种决定两种（或更多，但通常是两种）选择的方法。在文档分类中，选项是“文档与训练集匹配”或“文档与训练集不匹配”。</p>
                     <p>决策树具有一组可以测试的属性。在这种情况下，属性包括：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>文件中的文字</p>
                        </li>
                        <li>
                           <p>来自文档的单词的词干（例如， <span class="italic">运行</span>的词干<span class="italic">运行</span> ）</p>
                        </li>
                        <li>
                           <p>文档中的主题（如果使用的语言支持主题）</p>
                        </li>
                     </ul>
                     <p>Oracle Text中的学习算法为训练集中提供的每个类别构建一个或多个决策树。然后将这些决策树编码成适合<code class="codeph">CTXRULE</code>索引使用的查询。例如，一个类别具有“日本甲虫”的培训文档，另一个类别具有“日本货币”的文档。该算法可以基于“日语”，“甲虫”和“货币”创建决策树，然后相应地对文档进行分类。
                     </p>
                     <p>决策树包括<span class="italic">置信度</span>的概念<span class="italic">。</span> 在给定当前训练集的情况下，为每个生成的规则分配一个百分比值，该百分比值表示规则的准确性。在简单的例子中，准确度几乎总是100％，但这个百分比仅代表训练集的局限性。同样，从普通训练集生成的规则可能看起来比您预期的要少，但它们足以区分当前训练集中的不同类别。
                     </p>
                     <p>决策树分类的优点是它可以生成用户可以轻松检查和修改的规则。当您希望计算机生成大量规则时，决策树分类是有意义的，但您希望之后通过编辑规则集对它们进行微调。</p>
                  </div>
               </div><a id="CCAPP9222"></a><div class="props_rev_3"><a id="GUID-17173FFD-EFDC-40C6-9F7E-9FCA38188D13" name="GUID-17173FFD-EFDC-40C6-9F7E-9FCA38188D13"></a><h4 id="CCAPP-GUID-17173FFD-EFDC-40C6-9F7E-9FCA38188D13" class="sect4"><span class="enumeration_section">9.5.2</span>决策树监督分类示例</h4>
                  <div>
                     <p>以下SQL示例逐步创建文档和分类表，对文档进行分类以及生成规则。然后继续使用<code class="codeph">CTX_CLS.TRAIN</code>生成规则。</p>
                     <p>然后将规则编入索引以创建<code class="codeph">CTXRULE</code>索引，并使用<code class="codeph">MATCHES</code>新文档进行分类。</p>
                     <p><code class="codeph">CTX_CLS.TRAIN</code>过程需要输入培训文档集。训练集是一组已分配类别的文档。
                     </p>
                     <p>生成规则后，您可以先测试它们然后使用<code class="codeph">MATCHES</code>对新文档进行分类来测试它们。
                     </p>
                     <p></p>
                     <p>要创建和索引类别规则：</p>
                     <ol>
                        <li>
                           <p>创建并加载培训文档表。</p>
                           <p>此示例使用一组简单的三个快餐文档和三个计算机文档。</p><pre class="oac_no_warn" dir="ltr">create table docs（doc_id number primary key，doc_text clob）;插入docs值（1，'MacTavishes是一家专门从事汉堡，薯条和奶昔的快餐连锁店。汉堡显然是他们最重要的路线。“）;插入docs价值观（2，'汉堡王子是汉堡商店的高端市场连锁店，卖汉堡 - 和MacTavishes之类的竞争中的薯条。“）;插入docs值（3，'Shakes 2 Go是低成本餐厅竞技场的新尝试，专注于半液体冷冻水果味植物油产品。“）;插入docs值（4，'TCP / IP网络工程师通常需要了解路由器，防火墙，主机，跳线网络等'）;插入docs值（5，'防火墙用于保护网络免受远程主机的攻击，通常跨TCP / IP'）;</pre></li>
                        <li>
                           <p>创建类别表，类别描述和ID。</p><pre class="oac_no_warn" dir="ltr">-------------------------------------------------- --------------------------</pre><pre class="oac_no_warn" dir="ltr">- 创建类别表 - 请注意，此演示并不真正需要“category_descriptions” - 它只是在 -  doc_categories中提供类别编号的描述性名称------------- -------------------------------------------------- ------------- create table category_descriptions（cd_category number，cd_description varchar2（80））;创建表doc_categories（dc_category数，dc_doc_id数，主键（dc_category，dc_doc_id））组织索引; - 类别描述插入category_descriptions值（1，'快餐'）;插入category_descriptions值（2，'计算机网络'）;</pre></li>
                        <li>
                           <p>将每个文档分配到一个类别。</p>
                           <p>在这种情况下，快餐文件都进入第1类，计算机文件进入第2类。</p><pre class="oac_no_warn" dir="ltr">插入doc_categories值（1,1）;插入doc_categories值（1,2）;插入doc_categories值（1,3）;插入doc_categories值（2,4）;插入doc_categories值（2,5）;</pre></li>
                        <li>
                           <p>创建<code class="codeph">CTX_CLS.TRAIN.</code>使用的<code class="codeph">CONTEXT</code>索引<code class="codeph">CTX_CLS.TRAIN.</code></p>
                           <p>要试验打开和关闭主题的效果，请为索引创建Oracle Text首选项。</p><pre class="oac_no_warn" dir="ltr">exec ctx_ddl.create_preference（'my_lex'，'basic_lexer'）; exec ctx_ddl.set_attribute（'my_lex'，'index_themes'，'no'）; exec ctx_ddl.set_attribute（'my_lex'，'index_text'，'yes'）;在docs上创建索引docsindex（doc_text）indextype是ctxsys.context参数（'lexer my_lex'）;</pre></li>
                        <li>
                           <p>创建将由生成的规则填充的规则表。</p><pre class="oac_no_warn" dir="ltr">创建表规则（rule_cat_id number，rule_text varchar2（4000），rule_confidence number）;</pre></li>
                        <li>
                           <p>生成类别规则。</p>
                           <p>所有参数都是先前在此示例中创建的表，列或索引的名称。<code class="codeph">rules</code>表现在包含您可以查看的规则。
                           </p><pre class="oac_no_warn" dir="ltr">开始ctx_cls.train（index_name =&gt;'docsindex'，docid =&gt;'doc_id'，cattab =&gt;'doc_categories'，catdocid =&gt;'dc_doc_id'，catid =&gt;'dc_category'，restab =&gt;'规则'，rescatid =&gt; 'rule_cat_id'，resquery =&gt;'rule_text'，resconfid =&gt;'rule_confidence'）;结束; /</pre></li>
                        <li>
                           <p>获取按类别查看的生成规则。</p>
                           <p>为方便起见， <code class="codeph">rules</code>表与<code class="codeph">category_descriptions</code>以便您可以看到每个规则适用的类别。
                           </p><pre class="oac_no_warn" dir="ltr">从规则中选择cd_description，rule_confidence，rule_text，category_descriptions，其中cd_category = rule_cat_id;</pre></li>
                        <li>
                           <p>使用<code class="codeph">CREATE INDEX</code>语句在先前生成的规则上创建<code class="codeph">CTXRULE</code>索引。
                           </p><pre class="oac_no_warn" dir="ltr">在规则上创建索引rules_idx（rule_text）indextype是ctxsys.ctxrule;</pre></li>
                        <li>
                           <p>使用<code class="codeph">MATCHES.</code>测试传入的文档<code class="codeph">MATCHES.</code></p><pre class="oac_no_warn" dir="ltr">set serveroutput on;</pre><pre class="oac_no_warn" dir="ltr">声明incoming_doc clob; begin incoming_doc：='我一生都在管理卖汉堡的餐馆'; for c in（从规则中选择不同的cd_description，category_descriptions，其中cd_category = rule_cat_id并匹配（rule_text，incoming_doc）&gt; 0）循环dbms_output.put_line（'CATEGORY：'|| c.cd_description）;结束循环;结束; /</pre></li>
                     </ol>
                  </div>
               </div><a id="CCAPP9225"></a><div class="props_rev_3"><a id="GUID-1366708C-4B91-4FF4-A955-F083F059D3AF" name="GUID-1366708C-4B91-4FF4-A955-F083F059D3AF"></a><h4 id="CCAPP-GUID-1366708C-4B91-4FF4-A955-F083F059D3AF" class="sect4"><span class="enumeration_section">9.5.3</span>基于SVM的监督分类</h4>
                  <div>
                     <p>您可以用于培训目的的第二种方法是支持向量机（SVM）分类。SVM是一种源自统计学习理论的机器学习算法。SVM分类的一个属性是从非常小的样本集中学习的能力。</p>
                     <p>使用SVM分类器与使用决策树分类器非常相似，但以下区别除外：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>在对<code class="codeph">CTX_CLS.TRAIN,</code>的调用中<code class="codeph">CTX_CLS.TRAIN,</code>使用<code class="codeph">SVM_CLASSIFIER</code>首选项而不是<code class="codeph">RULE_CLASSIFIER</code>首选项。（如果您不想修改任何属性，请使用预定义的<code class="codeph">CTXSYS.SVM_CLASSIFIER</code>首选项。）
                           </p>
                        </li>
                        <li>
                           <p>如果您不想在表上填充<code class="codeph">CONTEXT</code>索引，请使用<code class="codeph">NOPOPULATE</code>关键字。分类器仅使用它来通过数据存储区和过滤器首选项查找文本的来源，并确定如何通过词法分析器和分段器首选项处理文本。
                           </p>
                        </li>
                        <li>
                           <p>在生成的规则表中，至少使用以下列：</p><pre class="oac_no_warn" dir="ltr">cat_id number，type number，rule blob;</pre></li>
                     </ul>
                     <p>如您所见，生成的规则将写入<code class="codeph">BLOB</code>列。因此，它对用户不透明，与决策树分类规则不同，它无法编辑或修改。这里的权衡是，使用SVM比使用决策树分类通常可以获得更高的准确性。
                     </p>
                     <p><a id="d23044e1423" class="indexterm-anchor"></a>通过SVM分类，分配的内存必须足够大才能加载SVM模型;否则，在SVM上构建的应用程序会导致内存不足错误。以下是如何计算内存分配：</p><pre class="oac_no_warn" dir="ltr"><span class="italic">最小内存请求（以字节为单位）</span> = <span class="italic">唯一类别</span> <span class="italic">数</span> x <span class="italic">特征数量</span>示例:( <span class="italic">MAX_FEATURES属性值</span> ）x 8</pre><p>如有必要满足最低内存要求，请增加以下内存之一：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>SGA（如果处于共享服务器模式）</p>
                        </li>
                        <li>
                           <p>PGA（如果在专用服务器模式下）</p>
                        </li>
                     </ul>
                  </div>
               </div><a id="CCAPP9226"></a><div class="props_rev_3"><a id="GUID-9F2196D4-C073-4B2F-A3C2-6B9369249896" name="GUID-9F2196D4-C073-4B2F-A3C2-6B9369249896"></a><h4 id="CCAPP-GUID-9F2196D4-C073-4B2F-A3C2-6B9369249896" class="sect4"><span class="enumeration_section">9.5.4</span>基于SVM的监督分类示例</h4>
                  <div>
                     <p>此示例使用基于SVM的分类。这些步骤与决策树示例基本相同，但以下差异除外：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>使用<code class="codeph">CTX_DDL.CREATE_PREFERENCE</code>设置<code class="codeph">SVM_CLASSIFIER</code>首选项，而不是在<code class="codeph">CTX_CLS.TRAIN.</code>设置它<code class="codeph">CTX_CLS.TRAIN.</code> （你可以这样做。）
                           </p>
                        </li>
                        <li>
                           <p>在类别表中包括类别说明。（你可以这样做。）</p>
                        </li>
                        <li>
                           <p>由于规则对用户不透明，因此在<code class="codeph">CTX_CLS.TRAIN.</code>使用较少的参数<code class="codeph">CTX_CLS.TRAIN.</code></p>
                        </li>
                     </ul>
                     <p>要创建基于SVM的监督分类：</p>
                     <ol>
                        <li>
                           <p>创建并填充培训文档表。</p><pre class="oac_no_warn" dir="ltr">create table doc（id number primary key，text varchar2（2000））;插入doc值（1，'1 2 3 4 5 6'）;插入doc值（2，'3 4 7 8 9 0'）;插入doc值（3，'abcde f'）;插入doc值（4，'ghijklmnopq r'）;插入doc值（5，'ghijkstuvwxy z'）;</pre></li>
                        <li>
                           <p>创建并填充类别表。</p><pre class="oac_no_warn" dir="ltr">create table testcategory（doc_id number，cat_id number，cat_name varchar2（100））;插入testcategory值（1,1，'number'）;插入testcategory值（2,1，'number'）;插入testcategory值（3,2，'letter'）;插入testcategory值（4,2，'letter'）;插入testcategory值（5,2，'letter'）;</pre></li>
                        <li>
                           <p>在文档表上创建<code class="codeph">CONTEXT</code>索引而不填充它。
                           </p><pre class="oac_no_warn" dir="ltr">在doc（text）上创建索引docx indextype是ctxsys.context参数（'nopopulate'）;</pre></li>
                        <li>
                           <p>设置<code class="codeph">SVM_CLASSIFIER.</code></p>
                           <p>您也可以在<code class="codeph">CTX.CLS_TRAIN.</code>设置<code class="codeph">CTX.CLS_TRAIN.</code></p><pre class="oac_no_warn" dir="ltr">exec ctx_ddl.create_preference（'my_classifier'，'SVM_CLASSIFIER'）; exec ctx_ddl.set_attribute（'my_classifier'，'MAX_FEATURES'，'100'）;</pre></li>
                        <li>
                           <p>创建结果（规则）表。</p><pre class="oac_no_warn" dir="ltr">create table restab（cat_id number，type number（3）not null，rule blob）;</pre></li>
                        <li>
                           <p>进行培训。</p><pre class="oac_no_warn" dir="ltr">exec ctx_cls.train（'docx'，'id'，'testcategory'，'doc_id'，'cat_id'，'restab'，'my_classifier'）;</pre></li>
                        <li>
                           <p>在规则表上创建<code class="codeph">CTXRULE</code>索引。
                           </p><pre class="oac_no_warn" dir="ltr">exec ctx_ddl.create_preference（'my_filter'，'NULL_FILTER'）;在restab上创建索引restabx（规则）indextype是ctxsys.ctxrule参数（'filter my_filter classifier my_classifier'）;</pre></li>
                     </ol>
                     <p>现在您可以对两个未知文档进行分类，如下所示：</p><pre class="oac_no_warn" dir="ltr">选择cat_id，match_score（1）来自restab匹配（规则，'4 5 6'，1）&gt; 50;从restab中选择cat_id，match_score（1）匹配（rule，'fh j'，1）&gt; 50; drop table doc; drop table testcategory;放下桌子; exec ctx_ddl.drop_preference（'my_classifier'）; exec ctx_ddl.drop_preference（'my_filter'）;</pre></div>
               </div>
            </div><a id="CCAPP9227"></a><div class="props_rev_3"><a id="GUID-9318FD70-869D-4465-A51E-58FB7803AB4C" name="GUID-9318FD70-869D-4465-A51E-58FB7803AB4C"></a><h3 id="CCAPP-GUID-9318FD70-869D-4465-A51E-58FB7803AB4C" class="sect3"><span class="enumeration_section">9.6</span>无监督分类（聚类）</h3>
               <div>
                  <p>使用<a href="classifying-documents-in-oracle-text.html#GUID-8D624E54-C32A-42A8-A6AF-DF64237242F2">基于规则的分类</a> ，您可以自己编写用于对文档进行分类的规则。通过<a href="classifying-documents-in-oracle-text.html#GUID-D1458643-CD73-4092-B821-44BCFB85CAE6">监督分类</a> ，Oracle Text会为您编写规则，但您必须提供一组预分类的培训文档。使用<span class="italic">无监督分类</span> （也称为<span class="italic">聚类</span> ），您不必提供一组训练文档。
                  </p>
                  <p>使用<code class="codeph">CTX_CLS.CLUSTERING</code>过程执行群集。<code class="codeph">CTX_CLS.CLUSTERING</code>创建文档组的层次结构，称为<span class="italic">集群，</span>并为每个文档返回所有叶集群的相关性分数。
                  </p>
                  <p>例如，假设您有大量关于动物的文档集合。<code class="codeph">CTX_CLS.CLUSTERING</code>创建了一个关于狗的叶簇，另一个关于猫，另一个关于鱼，第四个关于熊。（前三个可能在一个关于宠物的节点集群下分组。）进一步假设你有一个关于一种狗的文件，如吉娃娃。<code class="codeph">CTX_CLS.CLUSTERING</code>将<code class="codeph">CTX_CLS.CLUSTERING</code>分配给具有非常高的相关性得分的文档，而猫群被分配较低的分数，并且鱼和熊群仍然被分配较低的分数。在将所有群集的分数分配给所有文档之后，应用程序可以基于分数采取行动。
                  </p>
                  <p>如<span class="q">“ <a href="classifying-documents-in-oracle-text.html#GUID-FCCA9B53-65A4-47A8-9B21-5F918F9393B3">决策树监督分类</a> ”中所述</span> ，用于确定聚类的属性可以包括简单的单词（或标记），词干和主题（在支持的情况下）。
                  </p>
                  <p><code class="codeph">CTX_CLS.CLUSTERING</code>将输出分配给两个表（可能是内存表）：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>文档分配表，显示文档与每个叶簇的相似性。该信息采用文档识别，群集识别以及文档与群集之间的相似性得分的形式。</p>
                     </li>
                     <li>
                        <p>包含有关生成的集群的信息的集群描述表。此表包含群集标识，群集描述文本，建议的群集标签以及群集的质量分数。</p>
                     </li>
                  </ul>
                  <p><code class="codeph">CTX_CLS.CLUSTERING</code>使用<code class="codeph">K-MEAN</code>算法执行聚类。使用<code class="codeph">KMEAN_CLUSTERING</code>首选项确定<code class="codeph">CTX_CLS.CLUSTERING</code>工作方式。
                  </p>
                  <div class="infoboxnotealso" id="GUID-9318FD70-869D-4465-A51E-58FB7803AB4C__GUID-8B50E964-13E6-4C24-AE70-03D4FEC8EECB">
                     <p class="notep1">也可以看看：</p>
                     <p>有关群集类型和分层群集的详细信息，请参阅<a href="../ccref/oracle-text-indexing-elements.html#CCREF0200" target="_blank"><span class="italic">Oracle Text Reference</span></a></p>
                  </div>
               </div>
            </div><a id="CCAPP9228"></a><div class="props_rev_3"><a id="GUID-BB043FA2-B89C-4D89-9C9B-E410D85629CC" name="GUID-BB043FA2-B89C-4D89-9C9B-E410D85629CC"></a><h3 id="CCAPP-GUID-BB043FA2-B89C-4D89-9C9B-E410D85629CC" class="sect3"><span class="enumeration_section">9.7</span>无监督分类（聚类）示例</h3>
               <div>
                  <p>此SQL示例在集合表中创建一<code class="codeph">CONTEXT</code>文档，并创建<code class="codeph">CONTEXT</code>索引。然后，它创建一个文档分配和集群描述表，这些表填充了对<code class="codeph">CLUSTERING</code>过程的调用。然后使用select语句查看输出：</p><pre class="oac_no_warn" dir="ltr">将/ server文件中的serverout设置为表* / create table collection（id number primary key，text varchar2（4000））;插入集合值（1，'Oracle Text可以索引任何文档或文本内容。“）;插入集合值（2，'Ultra Search使用爬虫访问文档。“）;插入集合值（3，'XML是一种基于标签的标记语言。“）;插入集合值（4，'Oracle Database 11g XML DB将XML视为数据库中的本机数据类型。“）;插入集合值（5，'有三种Oracle Text索引类型可以满足所有文本搜索需求。“）;插入集合值（6，'Ultra Search还提供内容管理解决方案的API。“）;在集合（text）上创建索引collectionx indextype是ctxsys.context参数（'nopopulate'）; / *准备结果表，如果省略此步骤，程序将自动创建表* / create table restab（docid NUMBER，clusterid NUMBER，得分NUMBER）;创建表簇（clusterid NUMBER，descript varchar2（4000），label varchar2（200），size number，quality_score number，parent number）; / *设置首选项* / exec ctx_ddl.drop_preference（'my_cluster'）; exec ctx_ddl.create_preference（'my_cluster'，'KMEAN_CLUSTERING'）; exec ctx_ddl.set_attribute（'my_cluster'，'CLUSTER_NUM'，'3'）; / *做集群* / exec ctx_output.start_log（'my_log'）; exec ctx_cls.clustering（'collectionx'，'id'，'restab'，'clusters'，'my_cluster'）; exec ctx_output.end_log;</pre><div class="infoboxnotealso" id="GUID-BB043FA2-B89C-4D89-9C9B-E410D85629CC__GUID-C307A825-D189-4959-93CE-82564D66F8AD">
                     <p class="notep1">也可以看看：</p>
                     <p><code class="codeph">CTX_CLS.CLUSTERING</code>语法和示例的<a href="../ccref/CTX_CLS-package.html#CCREF1500" target="_blank"><span class="italic">Oracle Text Reference</span></a></p>
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>