<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <meta name="abstract" content="Effective applications are scalable and use recommended programming and security practices."></meta>
      <meta name="description" content="Effective applications are scalable and use recommended programming and security practices."></meta>
      <title>建立有效的应用</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="2 Day Developer&#39;s Guide "></meta>
      <meta property="og:description" content="Effective applications are scalable and use recommended programming and security practices."></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="2 Day Developer&#39;s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="2-day-developers-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-10T13:00:30-08:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="1996, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E94801-01"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="working-in-global-environment.html" title="Previous" type="text/html"></link>
      <link rel="next" href="developing-simple-database-application.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="2 Day Developer&#39;s Guide"></meta>
    <meta name="dcterms.isVersionOf" content="TDDDG"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="working-in-global-environment.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="developing-simple-database-application.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">2天开发人员指南</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">建立有效的应用</li>
            </ol>
            <a id="GUID-F6EB9789-00D7-472F-A36C-F55C143307BC" name="GUID-F6EB9789-00D7-472F-A36C-F55C143307BC"></a><a id="TDDDG99933"></a>
            
            <h2 id="TDDDG-GUID-F6EB9789-00D7-472F-A36C-F55C143307BC" class="sect2"><span class="enumeration_chapter">8</span>建立有效的应用</h2>
         </header>
         <div class="ind">
            <div>
               <p>有效的应用程序是可扩展的，并使用推荐的编程和安</p>
            </div>
            <div>
               <ul class="ullinks">
                  <li class="ulchildlink"><a href="building-effective-applications.html#GUID-BB351358-03F9-494C-8C38-180DFB7CAC4C">构建可扩展的应用</a><br>设计应用程序以使用相同的资源，无论用户群和数据量如何，都不会使系统资源过载。
                  </li>
                  <li class="ulchildlink"><a href="building-effective-applications.html#GUID-1E354949-D957-4C58-8670-92E11B928CD1">推荐的编程实践</a><br>使用以下推荐的编程实践。
                  </li>
                  <li class="ulchildlink"><a href="building-effective-applications.html#GUID-32FBC335-6B08-4B50-B039-06BB9F500908">推荐的安全实践</a><br>在为组成应用程序的模式对象授予权限时，请使用<strong class="term">最小权限原则</strong> 。
                  </li>
               </ul>
               <div class="infoboxnotealso" id="GUID-F6EB9789-00D7-472F-A36C-F55C143307BC__GUID-BB368B64-4348-4732-807D-FFB1CDAF085E">
                  <p class="notep1">也可以看看：</p>
                  <p>有关创建和部署针对Oracle数据库进行了优化的应用程序的详细信息，请参见<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/tdddg&amp;id=ADFNS116" target="_blank"><span class="italic">“Oracle数据库开发指</span></a></p>
               </div>
            </div>
            <a id="TDDDG99932"></a><div class="props_rev_4"><a id="GUID-BB351358-03F9-494C-8C38-180DFB7CAC4C" name="GUID-BB351358-03F9-494C-8C38-180DFB7CAC4C"></a><h3 id="TDDDG-GUID-BB351358-03F9-494C-8C38-180DFB7CAC4C" class="sect3"><span class="enumeration_section">8.1</span>构建可扩展应用程序</h3>
               <div>
                  <p>设计应用程序以使用相同的资源，无论用户群和数据量如何，都不会使系统资源过载。</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="building-effective-applications.html#GUID-D0FD8DFF-4763-4775-8045-50DF3F3EA558">关于可扩展应用</a><br><strong class="term">可伸缩</strong>应用程序可以通过按比例增加系统资源使用来处理更大的工作负载。
                     </li>
                     <li class="ulchildlink"><a href="building-effective-applications.html#GUID-5F486510-7FF2-4418-8D88-13B18F2E2606">使用绑定变量来提高可伸缩性</a><br>正确使用的绑定变量可让您开发高效，可伸缩的应用程序。
                     </li>
                     <li class="ulchildlink"><a href="building-effective-applications.html#GUID-D39CB5E6-0CC4-4780-AA7A-C41D96E615D1">使用PL / SQL提高可伸缩性</a><br>某些PL / SQL功能可以帮助您提高应用程序的可伸缩性。
                     </li>
                     <li class="ulchildlink"><a href="building-effective-applications.html#GUID-7D6B0A76-736A-472C-9AB2-F7757CB8993A">关于并发性和可伸缩性</a><br><strong class="term">并发</strong>是多个事务的同时执行。应用程序处理并发性越好，它的可伸缩性就越高。<strong class="term">可伸缩</strong>应用程序可以通过按比例增加系统资源使用来处理更大的工作负载。
                     </li>
                     <li class="ulchildlink"><a href="building-effective-applications.html#GUID-5381A407-3D62-4675-816C-BBB6FE34587C">限制并发会话数</a><br>您拥有的并发会话越多，您拥有的并发等待越多，响应时间就越慢。
                     </li>
                     <li class="ulchildlink"><a href="building-effective-applications.html#GUID-F9C3320A-832C-4762-BA39-30132C5E0EAA">将编程技术与Runstats进行比较</a><br>Runstats工具可以让您比较两种编程技术的性能，看看哪种更好。
                     </li>
                     <li class="ulchildlink"><a href="building-effective-applications.html#GUID-450ED4B7-CB1B-4121-8FE1-682A82B4F4B9">真实的性能和数据处理技术</a><br>数据仓库环境中的数据库应用程序中的常见任务是查询或修改庞大的数据集。应用程序开发人员面临的问题是如何在处理大型数据集时实现高性能。
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="building-effective-applications.html#GUID-F6EB9789-00D7-472F-A36C-F55C143307BC" title="有效的应用程序是可扩展的，并使用推荐的编程和安">构建有效的应用程序</a></p>
                     </div>
                  </div>
               </div>
               <a id="TDDDG99931"></a><div class="props_rev_3"><a id="GUID-D0FD8DFF-4763-4775-8045-50DF3F3EA558" name="GUID-D0FD8DFF-4763-4775-8045-50DF3F3EA558"></a><h4 id="TDDDG-GUID-D0FD8DFF-4763-4775-8045-50DF3F3EA558" class="sect4"><span class="enumeration_section">8.1.1</span>关于可扩展应用程序</h4>
                  <div>
                     <p><strong class="term">可伸缩</strong>应用程序可以通过按比例增加系统资源使用来处理更大的工作负载。
                     </p>
                     <p><strong class="term">可伸缩</strong>应用程序可以通过按比例增加系统资源使用来处理更大的工作负载。例如，如果您将其工作负载加倍，则可伸缩应用程序将使用两倍的系统资源。
                     </p>
                     <p><strong class="term">不可扩展的</strong>应用程序耗尽了系统资源;因此，如果增加应用程序工作负载，则无法实现更高的吞吐量。不可扩展的应用程序导致固定的吞吐量和较差的响应时间。
                     </p>
                     <p>资源耗尽的例子是：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>硬件耗尽</p>
                        </li>
                        <li>
                           <p>表扫描高容量事务，导致不可避免的磁盘输入/输出（I / O）短缺</p>
                        </li>
                        <li>
                           <p>网络请求过多导致网络和调度瓶颈</p>
                        </li>
                        <li>
                           <p>内存分配导致分页和交换</p>
                        </li>
                        <li>
                           <p>过多的进程和线程分配导致操作系统抖动</p>
                        </li>
                     </ul>
                     <p>设计应用程序以使用相同的资源，无论用户群和数据量如何，都不会使系统资源过载。</p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="building-effective-applications.html#GUID-BB351358-03F9-494C-8C38-180DFB7CAC4C" title="设计应用程序以使用相同的资源，无论用户群和数据量如何，都不会使系统资源过载。">构建可伸缩应用程序</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="TDDDG322"></a><a id="TDDDG99930"></a><div class="props_rev_3"><a id="GUID-5F486510-7FF2-4418-8D88-13B18F2E2606" name="GUID-5F486510-7FF2-4418-8D88-13B18F2E2606"></a><h4 id="TDDDG-GUID-5F486510-7FF2-4418-8D88-13B18F2E2606" class="sect4"><span class="enumeration_section">8.1.2</span>使用绑定变量提高可伸缩性</h4>
                  <div>
                     <p>正确使用的绑定变量可让您开发高效，可伸缩的应用程序。</p>
                     <p><strong class="term">绑定变量</strong>是SQL语句中的占位符，必须替换为有效的值或值地址才能成功执行语句。通过使用绑定变量，您可以编写一个在运行时接受输入或参数的SQL语句。
                     </p>
                     <p>正如子程序可以具有参数（其值由调用者提供）一样，SQL语句可以具有绑定变量占位符，其值（称为绑定变量）在运行时提供。正如子程序被编译一次然后使用不同的参数运行多次一样，具有绑定变量占位符的SQL语句被硬解析一次，然后使用不同的绑定变量进行软解析。</p>
                     <p><strong class="term">硬解析</strong>包括优化和行源生成，是一项非常耗费CPU的操作。<strong class="term">软解析</strong>跳过优化和行源生成并直接执行，通常比同一语句的硬解析快得多。（有关SQL处理的概述，包括硬解和软解析之间的区别，请参阅<a href="../cncpt/sql.html#CNCPT216" target="_blank"><span class="italic">Oracle数据库概念</span></a> 。）
                     </p>
                     <p>硬解析不仅是CPU密集型操作，而且是一种不可扩展的操作，因为它不能与许多其他操作同时完成。有关并发性和可伸缩性的更多信息，请参阅<span class="q">“ <a href="building-effective-applications.html#GUID-7D6B0A76-736A-472C-9AB2-F7757CB8993A" title="并发是多个事务的同时执行。应用程序处理并发性越好，它的可伸缩性就越高。可伸缩应用程序可以通过按比例增加系统资源使用来处理更大的工作负载。">关于并发性和可伸缩性</a> ”</span> 。
                     </p>
                     <p><a href="building-effective-applications.html#GUID-5F486510-7FF2-4418-8D88-13B18F2E2606__BACGGFEI">例8-1</a>显示了没有绑定变量的查询与带有绑定变量的语义等效查询之间的性能差异。前者较慢并且使用了更多的锁存器（有关锁存器如何影响可伸缩性的信息，请参阅<span class="q">“ <a href="building-effective-applications.html#GUID-005242DA-37C8-4EFD-A6B7-53183A151CB3" title="锁存器的增加意味着更多基于并发的等待，因此可伸缩性降低。">关于锁存器和并发</a> ”</span> ）。为了收集和显示性能统计信息，该示例使用Runstats工具，如<span class="q">“ <a href="building-effective-applications.html#GUID-F9C3320A-832C-4762-BA39-30132C5E0EAA" title="Runstats工具可以让您比较两种编程技术的性能，看看哪种更好。">将编程技术与Runstats进行比较</a> ”中所述</span> 。
                     </p>
                     <div class="infoboxnote" id="GUID-5F486510-7FF2-4418-8D88-13B18F2E2606__GUID-BB178830-ABB2-4FD3-BFB7-4FB835FDE501">
                        <p class="notep1">注意：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="building-effective-applications.html#GUID-5F486510-7FF2-4418-8D88-13B18F2E2606__BACGGFEI">例8-1</a>显示<span class="italic">了单个用户</span>的性能成本。随着更多用户的加入，成本迅速上升。
                              </p>
                           </li>
                           <li>
                              <p>使用此设置生成<a href="building-effective-applications.html#GUID-5F486510-7FF2-4418-8D88-13B18F2E2606__BACGGFEI">示例8-1</a>的结果：</p><pre class="oac_no_warn" dir="ltr">SET SERVEROUTPUT格式为TRUNCATED</pre></li>
                        </ul>
                     </div>
                     <div class="infoboxnote" id="GUID-5F486510-7FF2-4418-8D88-13B18F2E2606__GUID-DA56C1D7-A5A9-454B-9BE7-78D6FBC1BD3E">
                        <p class="notep1">注意：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>使用绑定变量而不是字符串文字是使代码无法受到SQL注入攻击的最有效方法。有关详细信息，请参阅<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/tdddg&amp;id=LNPLS646" target="_blank"><span class="italic">Oracle Database PL / SQL语言参考</span></a> 。
                              </p>
                           </li>
                           <li>
                              <p>绑定变量有时会降低数据仓库系统的效率。由于大多数查询需要很长时间，因此优化程序会尝试为每个查询生成最佳计划，而不是最佳通用查询。使用绑定变量有时会强制优化器生成最佳通用查询。有关提高数据仓库系统性能的信息，请参阅“ <a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/tdddg&amp;id=DWHSG019" target="_blank"><span class="italic">Oracle数据库数据仓库指南”</span></a> 。
                              </p>
                           </li>
                        </ul>
                     </div>
                     <p>虽然软解析比硬解析更有效，但是多次软解析语句的成本仍然非常高。要最大限度地提高应用程序的效率和可伸缩性，请尽量减少解析。最小化解析的最简单方法是使用PL / SQL。</p>
                     <div class="example" id="GUID-5F486510-7FF2-4418-8D88-13B18F2E2606__BACGGFEI">
                        <p class="titleinexample">例8-1绑定变量提高了性能</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE t（x VARCHAR2（5））; DECLARE TYPE rc是REF CURSOR; l_cursor rc; BEGIN runstats_pkg.rs_start; - 收集查询的统计信息，不带绑定变量FOR i IN 1 ..5000 LOOP OPEN l_cursor FOR'SELECT <span class="bold">x FROM t WHERE x ='|| TO_CHAR（i）</span> ;关闭l_cursor;结束循环; runstats_pkg.rs_middle; - 使用绑定变量FOR i IN 1收集查询的统计信息..5000 LOOP OPEN l_cursor FOR'SELECT <span class="bold">x FROM t WHERE x =：x'使用i</span> ;关闭l_cursor;结束循环; runstats_pkg.rs_stop（500）; - 停止收集统计结束; /</pre><p>结果类似于：</p><pre class="oac_no_warn" dir="ltr">运行1运行740 hsec运行2运行30 hsec <span class="bold">运行1运行2466.67％运行时间2</span>名称运行1运行2差异STAT ...递归cpu使用729 19 -710 STAT ...此sessio使用的CPU 742 30 -712 STAT ...解析时间已过去1,051 4 -1,047 STAT ...解析时间cpu 1,066 2 -1,064 STAT ...会话游标缓存hi 1 4,998 4,997 STAT ...表扫描（短tabl 5,000 1 -4,999 STAT ...解析计数（总计）10,003 5,004 -4,999 LATCH.session空闲位5,003 3 -5,000 LATCH.session allocation 5,003 3 -5,000 STAT ...执行计数10,003 5,003 -5,000 STAT ...已打开cursors cumulati 10,003 5,003 -5,000 STAT ...解析数（硬）10,001 5 -9,996 STAT ...CCursor + sql area evic 10,000 1 -9,999 STAT ... enqueue releases 10,008 7 -10,001 STAT ... enqueue requests 10,009 7 -10,002 STAT ... call to get snapshot s 20,005 5,006 -14,999 STAT ... call to kcmgcs 20,028 35 -19,993 STAT ...一致得到引脚（fa 20,013 17 -19,996 LATCH.call分配20,002 6 -19,996 STAT ...一致得到ca 20,014 18 -19,996 STAT ...一致得到20,014 18 -19,996 STAT ...一致得到引脚20,013 17 -19,996 LATCH.simulator hash latch 20,014 11 -20,003 STAT ... session logical reads 20,080 75 -20,005 LATCH.shared pool simulator 20,046 5 -20,041 LATCH.enqueue hash chains 20,343 15 -20,328 STAT ... recursive调用40,015 15,018 -24,997 LATCH.cache缓冲链40,480 294 -40,186 STAT ... session pga memory max 131,072 65,536 -65,536 STAT ... session pga memory 131,072 65,536 -65,536 LATCH.row缓存对象165,209 139 -165,070 STAT ... session uga memory max 219,000 0 -219,000 LATCH.shared pool 265,108 152 -264,956 STAT ...逻辑读取字节数164,495,360 614,400 -163 ，880,960 <span class="bold">与运行2相比</span> ， <span class="bold">运行1个锁存器 - 差异和百分比</span> <span class="bold">运行1运行2</span> <span class="bold">差异</span> <span class="bold">Pct</span> <span class="bold">562,092 864 -561,228 2,466.67％</span> PL / SQL过程成功完成。</pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="building-effective-applications.html#GUID-BB351358-03F9-494C-8C38-180DFB7CAC4C" title="设计应用程序以使用相同的资源，无论用户群和数据量如何，都不会使系统资源过载。">构建可伸缩应用程序</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="TDDDG99929"></a><div class="props_rev_4"><a id="GUID-D39CB5E6-0CC4-4780-AA7A-C41D96E615D1" name="GUID-D39CB5E6-0CC4-4780-AA7A-C41D96E615D1"></a><h4 id="TDDDG-GUID-D39CB5E6-0CC4-4780-AA7A-C41D96E615D1" class="sect4"><span class="enumeration_section">8.1.3</span>使用PL / SQL提高可伸缩性</h4>
                  <div>
                     <p>某些PL / SQL功能可以帮助您提高应用程序的可伸缩性。</p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="building-effective-applications.html#GUID-383477A2-2433-4CD7-A672-B66A01004B73">PL / SQL如何最小化解析</a><br>PL / SQL，针对数据库访问进行了优化，可以静默缓存语句。在PL / SQL中，当你关闭游标时，光标会从你的角度关闭 - 也就是说，你不能在需要打开游标的地方使用它 - 但是PL / SQL实际上保持游标打开并缓存它的语句。
                        </li>
                        <li class="ulchildlink"><a href="building-effective-applications.html#GUID-FB5423B5-339B-49A8-B27B-326621E05795">关于EXECUTE IMMEDIATE声明</a><br><span class="keyword">EXECUTE IMMEDIATE</span>语句在单个操作中构建并运行动态SQL语句。
                        </li>
                        <li class="ulchildlink"><a href="building-effective-applications.html#GUID-9D8B18A7-3C82-4536-9C9C-2C74ADF01301">关于OPEN FOR FOR声明</a><br><span class="keyword">OPEN FOR</span>语句具有以下基本语法。
                        </li>
                        <li class="ulchildlink"><a href="building-effective-applications.html#GUID-41BDF5B3-52D7-4CB7-9043-74B4BDB64AA0">关于DBMS_SQL包</a><br>DBMS_SQL包是用于构建，运行和描述动态SQL语句的API。如果PL / SQL编译器无法在编译时确定输出主机变量的数量或类型（选择列表项）或输入绑定变量，则必须使用DBMS_SQL包而不是<span class="keyword">EXECUTE IMMEDIATE</span>语句。
                        </li>
                        <li class="ulchildlink"><a href="building-effective-applications.html#GUID-93E72E33-189E-4F76-899E-1DF75C40BBEF">关于批量SQL</a><br>批量SQL减少了PL / SQL和SQL之间的“往返”次数，从而减少了资源使用量。
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="building-effective-applications.html#GUID-BB351358-03F9-494C-8C38-180DFB7CAC4C" title="设计应用程序以使用相同的资源，无论用户群和数据量如何，都不会使系统资源过载。">构建可伸缩应用程序</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="TDDDG273"></a><div class="props_rev_3"><a id="GUID-383477A2-2433-4CD7-A672-B66A01004B73" name="GUID-383477A2-2433-4CD7-A672-B66A01004B73"></a><h5 id="TDDDG-GUID-383477A2-2433-4CD7-A672-B66A01004B73" class="sect5"><span class="enumeration_section">8.1.3.1</span> PL / SQL如何最小化解析</h5>
                     <div>
                        <p>PL / SQL，针对数据库访问进行了优化，可以静默缓存语句。在PL / SQL中，当你关闭游标时，光标会从你的角度关闭 - 也就是说，你不能在需要打开游标的地方使用它 - 但是PL / SQL实际上保持游标打开并缓存它的语句。</p>
                        <p>如果再次使用缓存语句，PL / SQL将使用相同的游标，从而避免解析。（如果需要，PL / SQL会关闭缓存的语句 - 例如，如果您的程序必须打开另一个游标，但这样做会超出<span class="keyword">OPEN_CURSORS</span>的init.ora设置。）
                        </p>
                        <p>PL / SQL可以静默地仅缓存在运行时无法更改的SQL语句。</p>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="building-effective-applications.html#GUID-D39CB5E6-0CC4-4780-AA7A-C41D96E615D1" title="某些PL / SQL功能可以帮助您提高应用程序的可伸缩性。">使用PL / SQL提高可伸缩性</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TDDDG274"></a><div class="props_rev_3"><a id="GUID-FB5423B5-339B-49A8-B27B-326621E05795" name="GUID-FB5423B5-339B-49A8-B27B-326621E05795"></a><h5 id="TDDDG-GUID-FB5423B5-339B-49A8-B27B-326621E05795" class="sect5"><span class="enumeration_section">8.1.3.2</span>关于EXECUTE IMMEDIATE语句</h5>
                     <div>
                        <p><span class="keyword">EXECUTE IMMEDIATE</span>语句在单个操作中构建并运行动态SQL语句。
                        </p>
                        <p><span class="keyword">EXECUTE IMMEDIATE</span>语句的基本语法是：</p><pre class="oac_no_warn" dir="ltr">EXECUTE IMMEDIATE <span class="italic">sql_statement</span>
</pre><p><span class="synph">sql_statement</span>是表示SQL语句的字符串。如果每次运行<span class="keyword">EXECUTE IMMEDIATE</span>语句时<span class="synph">sql_statement</span>具有相同的值，则PL / SQL可以缓存<span class="keyword">EXECUTE IMMEDIATE</span>语句。如果每次运行<span class="keyword">EXECUTE IMMEDIATE</span>语句时<span class="synph">sql_statement</span>可能不同，则PL / SQL无法缓存<span class="keyword">EXECUTE IMMEDIATE</span>语句。
                        </p>
                     </div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-FB5423B5-339B-49A8-B27B-326621E05795__GUID-174FDD6A-A70D-4C6D-9A81-CE421BC5CBAF">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>有关<span class="keyword">EXECUTE IMMEDIATE的</span>信息，请<a href="../lnpls/dynamic-sql.html#LNPLS01115" target="_blank"><span class="italic">参见Oracle Database PL / SQL语言参考</span></a></p>
                              </li>
                              <li>
                                 <p><span class="q">“ <a href="building-effective-applications.html#GUID-41BDF5B3-52D7-4CB7-9043-74B4BDB64AA0" title="DBMS_SQL包是用于构建，运行和描述动态SQL语句的API。如果PL / SQL编译器无法在编译时确定输出主机变量的数量或类型（选择列表项）或输入绑定变量，则必须使用DBMS_SQL包而不是EXECUTE IMMEDIATE语句。">关于DBMS_SQL包</a> ”</span></p>
                              </li>
                           </ul>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="building-effective-applications.html#GUID-D39CB5E6-0CC4-4780-AA7A-C41D96E615D1" title="某些PL / SQL功能可以帮助您提高应用程序的可伸缩性。">使用PL / SQL提高可伸缩性</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TDDDG278"></a><div class="props_rev_3"><a id="GUID-9D8B18A7-3C82-4536-9C9C-2C74ADF01301" name="GUID-9D8B18A7-3C82-4536-9C9C-2C74ADF01301"></a><h5 id="TDDDG-GUID-9D8B18A7-3C82-4536-9C9C-2C74ADF01301" class="sect5"><span class="enumeration_section">8.1.3.3</span>关于OPEN FOR语句</h5>
                     <div>
                        <p><span class="keyword">OPEN FOR</span>语句具有以下基本语法。
                        </p>
                        <p><span class="keyword">OPEN FOR</span>语句的基本语法是：</p><pre class="oac_no_warn" dir="ltr">OPEN <span class="italic">cursor_variable</span> FOR <span class="italic">查询</span>
</pre><p>在关闭之前，您的应用程序可以为几个不同的查询打开<span class="synph">cursor_variable</span> 。因为PL / SQL在运行时无法确定不同查询的数量，PL / SQL无法缓存<span class="keyword">OPEN FOR</span>语句。
                        </p>
                        <p>如果您不需要使用游标变量，则使用声明的游标，以获得更好的性能和编程的简易性。有关详细信息，请参阅<a href="../adfns/coding-subprograms-and-packages.html#ADFNS160" target="_blank"><span class="italic">Oracle Database Development Guide</span></a> 。
                        </p>
                     </div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-9D8B18A7-3C82-4536-9C9C-2C74ADF01301__GUID-F31F0201-1392-4412-9DAB-1514B5228862">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>有关<span class="keyword">OPEN FOR的</span>信息，请<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/tdddg&amp;id=LNPLS629" target="_blank"><span class="italic">参见Oracle Database PL / SQL语言参考</span></a></p>
                              </li>
                              <li>
                                 <p><span class="q">“ <a href="stored-subprograms-packages.html#GUID-AAF33D3B-FE73-42AC-AB07-3FA1A45CE02B" title="游标变量就像一个游标，它不仅限于一个查询。您可以打开查询的游标变量，处理结果集，然后将游标变量用于另一个查询。游标变量对于在子程序之间传递查询结果很有用。">关于光标变量</a> ”</span></p>
                              </li>
                              <li>
                                 <p><span class="q">“ <a href="stored-subprograms-packages.html#GUID-05FA9E55-F394-4A5F-A3C6-39EC0F68549F" title="当Oracle数据库执行SQL语句时，它会将结果集和处理信息存储在未命名的私有SQL区域中。指向此未命名区域的指针（称为游标）允许您一次检索一行结果集。游标属性返回有关游标状态的信息。">关于游标</a> ”</span></p>
                              </li>
                           </ul>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="building-effective-applications.html#GUID-D39CB5E6-0CC4-4780-AA7A-C41D96E615D1" title="某些PL / SQL功能可以帮助您提高应用程序的可伸缩性。">使用PL / SQL提高可伸缩性</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TDDDG275"></a><div class="props_rev_3"><a id="GUID-41BDF5B3-52D7-4CB7-9043-74B4BDB64AA0" name="GUID-41BDF5B3-52D7-4CB7-9043-74B4BDB64AA0"></a><h5 id="TDDDG-GUID-41BDF5B3-52D7-4CB7-9043-74B4BDB64AA0" class="sect5"><span class="enumeration_section">8.1.3.4</span>关于DBMS_SQL包</h5>
                     <div>
                        <p>DBMS_SQL包是用于构建，运行和描述动态SQL语句的API。如果PL / SQL编译器无法在编译时确定输出主机变量的数量或类型（选择列表项）或输入绑定变量，则必须使用DBMS_SQL包而不是<span class="keyword">EXECUTE IMMEDIATE</span>语句。
                        </p>
                        <p>DBMS_SQL包是用于构建，运行和描述动态SQL语句的API。使用DBMS_SQL包比使用<span class="keyword">EXECUTE IMMEDIATE</span>语句需要更多的努力，但如果PL / SQL编译器无法在编译时确定输出主机变量的数量或类型（选择列表项）或输入绑定变量，则必须使用DBMS_SQL包。
                        </p>
                     </div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-41BDF5B3-52D7-4CB7-9043-74B4BDB64AA0__GUID-B2EB9D40-E6A5-48BB-87F3-F6CD8B008B9E">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>有关何时使用DBMS_SQL程序包的更多信息，请<a href="../lnpls/dynamic-sql.html#LNPLS011" target="_blank"><span class="italic">参见Oracle Database PL / SQL语言参考</span></a></p>
                              </li>
                              <li>
                                 <p>有关DBMS_SQL包的完整信息，请参阅<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/tdddg&amp;id=ARPLS058" target="_blank"><span class="italic">Oracle Database PL / SQL包和类型参考</span></a></p>
                              </li>
                              <li>
                                 <p><span class="q">“ <a href="building-effective-applications.html#GUID-FB5423B5-339B-49A8-B27B-326621E05795" title="EXECUTE IMMEDIATE语句在单个操作中构建并运行动态SQL语句。">关于EXECUTE IMMEDIATE声明</a> ”</span></p>
                              </li>
                           </ul>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="building-effective-applications.html#GUID-D39CB5E6-0CC4-4780-AA7A-C41D96E615D1" title="某些PL / SQL功能可以帮助您提高应用程序的可伸缩性。">使用PL / SQL提高可伸缩性</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TDDDG280"></a><a id="TDDDG336"></a><a id="TDDDG276"></a><div class="props_rev_3"><a id="GUID-93E72E33-189E-4F76-899E-1DF75C40BBEF" name="GUID-93E72E33-189E-4F76-899E-1DF75C40BBEF"></a><h5 id="TDDDG-GUID-93E72E33-189E-4F76-899E-1DF75C40BBEF" class="sect5"><span class="enumeration_section">8.1.3.5</span>关于批量SQL</h5>
                     <div>
                        <p>批量SQL减少了PL / SQL和SQL之间的“往返”次数，从而减少了资源使用量。</p>
                        <p>如果没有批量SQL，则从数据库（SQL）一次检索一行，处理它（PL / SQL），并将其返回到数据库（SQL）。使用批量SQL，您可以从数据库中检索一组行，处理行集，然后将整个集返回到数据库。</p>
                        <p>Oracle建议使用散装SQL当你从数据库中检索多行<span class="italic">，</span>并将其返回到数据库中，如<a href="building-effective-applications.html#GUID-93E72E33-189E-4F76-899E-1DF75C40BBEF__BACBCGDD">例8-2</a> 。如果检索多行但不返回它们，则不需要批量SQL;例如：</p><pre class="oac_no_warn" dir="ltr">FOR x IN（SELECT * FROM t WHERE ...） - 检索行集（隐式数组提取）LOOP DBMS_OUTPUT.PUT_LINE（tx）; - 处理行但不返回它们END LOOP;</pre><p><a href="building-effective-applications.html#GUID-93E72E33-189E-4F76-899E-1DF75C40BBEF__BACBCGDD">示例8-2</a>遍历带有列object_name的表t，检索100行的集合，处理它们并将它们返回到数据库。（将批量<span class="keyword">FETCH</span>语句限制为100行需要显式游标。）
                        </p>
                        <p><a href="building-effective-applications.html#GUID-93E72E33-189E-4F76-899E-1DF75C40BBEF__BACCGHEI">例8-3</a>执行与<a href="building-effective-applications.html#GUID-93E72E33-189E-4F76-899E-1DF75C40BBEF__BACBCGDD">例8-2</a>相同的工作，没有批量SQL。</p>
                        <p>正如<a href="building-effective-applications.html#GUID-93E72E33-189E-4F76-899E-1DF75C40BBEF__BACBCGDD">示例8-2</a>和<a href="building-effective-applications.html#GUID-93E72E33-189E-4F76-899E-1DF75C40BBEF__BACCGHEI">示例8-3的</a>这些TKPROF报告所示，使用批量SQL执行此作业所占用的CPU时间减少了近50％：</p><pre class="oac_no_warn" dir="ltr"><span class="bold">SELECT ROWID RID，OBJECT_NAME FROM T T_BULK</span>调用count cpu经过磁盘查询当前行------- ------ -------- ---------- --- ------- ---------- ---------- ----------总计721 0.17 0.17 0 22582 0 71825 ***** ************************************************** ************************* <span class="bold">UPDATE T SET OBJECT_NAME =：B1 WHERE ROWID =：B2</span>呼叫计数cpu经过磁盘查询当前行----- -  ------ -------- ---------- ---------- ---------- ---- ------ ---------- Parse 1 0.00 0.00 0 0 0 0执行<span class="bold">719 12.83</span> 13.77 0 71853 74185 71825取0 0.00 0.00 0 0 0 0 ------- --- --- -------- ---------- ---------- ---------- --------- -  ---------- total 720 12.83 13.77 0 71853 74185 71825 <span class="bold">SELECT ROWID RID，OBJECT_NAME FROM T T_SLOW_BY_SLOW</span> call count cpu elapsed disk query current rows ------- ------- ------ ---------- ---------- ---------- ---------- ---- ------总计721 0.17 0.17 0 22582 0 71825 ************************************ ******************************************** <span class="bold">更新T SET OBJECT_NAME = ：B2 WHERE ROWID =：B1</span>调用cpu经过磁盘查询当前行------- ------ -------- ---------- ---- ------ ---------- ---------- ---------- Parse 1 0.00 0.00 0 0 0 0执行<span class="bold">71824 21.25</span> 22.25 0 71836 73950 71824获取0 0.00 0.00 0 0 0 0 ------- ------ -------- ---------- --------- -  ---------- ---------- ----------总计71825 21.25 22.25 0 71836 73950 71824</pre><p>但是，对于此作业使用批量SQL比使用单个SQL语句使用更多的CPU时间和更多代码，因为此<code class="codeph">TKPROF</code>报告显示：</p><pre class="oac_no_warn" dir="ltr"><span class="bold">UPDATE T SET OBJECT_NAME = SUBSTR（OBJECT_NAME，2）|| SUBSTR（OBJECT_NAME，1,1）</span>调用cpu经过磁盘查询当前行------- ------ -------- ---------- --- ------- ---------- ---------- ---------- Parse 1 0.00 0.00 0 0 0 0执行<span class="bold">1 1.30</span> 1.44 0 2166 75736 71825取0 0.00 0.00 0 0 0 0 ------- ------ -------- ---------- -------- -  ---------- ---------- ----------总计2 1.30 1.44 0 2166 75736 71825</pre><div class="example" id="GUID-93E72E33-189E-4F76-899E-1DF75C40BBEF__BACBCGDD">
                           <p class="titleinexample">示例8-2批量SQL</p><pre class="oac_no_warn" dir="ltr">创建或替换程序批量AS类型ridArray是ROUID表; TYPE onameArray是表格t.object_name％TYPE; CURSOR c是SELECT ROWID rid，object_name <span class="bold">- 显式游标</span> FROM t t_bulk; l_rids ridArray; l_onames onameArray; N NUMBER：= 100; BEGIN OPEN c; <span class="bold">LOOP</span> FETCH c BULK COLLECT INTO l_rids，l_onames LIMIT N; <span class="bold">- 从</span> 1 ... l_rids中的<span class="bold">t</span> FOR i中<span class="bold">检索N行</span> 。COUNT LOOP <span class="bold">- 处理N行</span> l_onames（i）：= substr（l_onames（i），2）|| SUBSTR（l_onames（ⅰ），1,1）;结束循环; FORALL i in 1 .. l_rids.count <span class="bold">- 将已处理的行返回到t</span> UPDATE t SET object_name = l_onames（i）WHERE ROWID = l_rids（i）;退出时c％NOTFOUND; <span class="bold">结束循环;</span>关闭c;结束; /</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-93E72E33-189E-4F76-899E-1DF75C40BBEF__BACCGHEI">
                           <p class="titleinexample">例8-3没有批量SQL</p><pre class="oac_no_warn" dir="ltr">CREATE或REPLACE PROCEDURE slow_by_slow AS BEGIN FOR x IN（SELECT rowid rid，object_name FROM t t_slow_by_slow）LOOP x.object_name：= substr（x.object_name，2）|| SUBSTR（x.object_name，1,1）; UPDATE t SET object_name = x.object_name WHERE rowid = x.rid;结束循环;结束;</pre></div>
                        <!-- class="example" -->
                     </div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-93E72E33-189E-4F76-899E-1DF75C40BBEF__GUID-CCFFCF01-8564-432A-AB10-8CA0B4AA81BF">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/tdddg&amp;id=ADFNS343" target="_blank"><span class="italic">Oracle数据库开发指南</span></a> ，了解批量SQL的概述</p>
                              </li>
                              <li>
                                 <p>有关何时使用批量SQL的更具体信息，请<a href="../adfns/transaction-guard.html#ADFNS344" target="_blank"><span class="italic">参见“Oracle数据库开发指南”</span></a></p>
                              </li>
                              <li>
                                 <p>有关批量SQL的更多信息，请<a href="../lnpls/plsql-optimization-and-tuning.html#LNPLS01205" target="_blank"><span class="italic">参见Oracle Database PL / SQL语言参考</span></a></p>
                              </li>
                           </ul>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="building-effective-applications.html#GUID-D39CB5E6-0CC4-4780-AA7A-C41D96E615D1" title="某些PL / SQL功能可以帮助您提高应用程序的可伸缩性。">使用PL / SQL提高可伸缩性</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="TDDDG99928"></a><div class="props_rev_3"><a id="GUID-7D6B0A76-736A-472C-9AB2-F7757CB8993A" name="GUID-7D6B0A76-736A-472C-9AB2-F7757CB8993A"></a><h4 id="TDDDG-GUID-7D6B0A76-736A-472C-9AB2-F7757CB8993A" class="sect4"><span class="enumeration_section">8.1.4</span>关于并发和可伸缩性</h4>
                  <div>
                     <p><strong class="term">并发</strong>是多个事务的同时执行。应用程序处理并发性越好，它的可伸缩性就越高。<strong class="term">可伸缩</strong>应用程序可以通过按比例增加系统资源使用来处理更大的工作负载。
                     </p>
                     <p><strong class="term">并发</strong>是多个事务的同时执行。并发事务中的语句可以更新相同的数据。应用程序处理并发性越好，它的可伸缩性就越高。<strong class="term">可伸缩</strong>应用程序可以通过按比例增加系统资源使用来处理更大的工作负载。例如，如果您将其工作负载加倍，则可伸缩应用程序将使用两倍的系统资源。
                     </p>
                     <p>并发事务必须产生有意义且一致的结果。因此，多用户数据库必须提供以下内容：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><strong class="term">数据并发</strong> ，确保用户可以同时访问数据。
                           </p>
                        </li>
                        <li>
                           <p><strong class="term">数据一致性</strong> ，确保每个用户都能看到一致的数据视图，包括他或她自己的事务和其他用户的已提交事务的可见更改</p>
                        </li>
                     </ul>
                     <p>Oracle数据库通过使用多版本一致性模型和各种类型的锁和事务隔离级别来维护数据一致性。有关Oracle数据库锁定机制的概述，请参阅<a href="../cncpt/data-concurrency-and-consistency.html#CNCPT1331" target="_blank"><span class="italic">Oracle数据库概念</span></a> 。有关Oracle数据库事务隔离级别的概述，请参阅<a href="../cncpt/data-concurrency-and-consistency.html#CNCPT621" target="_blank"><span class="italic">Oracle数据库概念</span></a> 。
                     </p>
                     <p>为了描述事务并发运行时的一致事务行为，数据库研究人员定义了一个名为<strong class="term">serializable</strong>的事务隔离类别。可<strong class="term">序列化事务</strong>在看似单用户数据库的环境中运行。在特定情况下，可序列化事务是可取的，但对于99％的工作负载，读取提交隔离是完美的。
                     </p>
                     <p>Oracle数据库具有提高并发性和可伸缩性的功能 - 例如，序列，锁存器，非阻塞读取和写入以及共享SQL。</p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="building-effective-applications.html#GUID-84ACEDC2-88E5-412C-B719-B46D4D82DD54">关于序列和并发</a><br>序列消除了序列化，从而提高了应用程序的并发性和可伸缩性。
                        </li>
                        <li class="ulchildlink"><a href="building-effective-applications.html#GUID-005242DA-37C8-4EFD-A6B7-53183A151CB3">关于锁存和并发</a><br>锁存器的增加意味着更多基于并发的等待，因此可伸缩性降低。
                        </li>
                        <li class="ulchildlink"><a href="building-effective-applications.html#GUID-3AA5A96A-CE03-4A8D-B06D-2FE4AAE0B1DC">关于非阻塞读取和写入以及并发</a><br>在Oracle数据库中， <strong class="term">非阻塞读取和写入</strong>允许查询与它们正在读取的数据的更改同时执行，而不会阻塞或停止。非阻塞读取和写入允许一个会话读取数据，而另一个会话正在更改该数据。
                        </li>
                        <li class="ulchildlink"><a href="building-effective-applications.html#GUID-664969A9-F7F0-4B55-8663-C93FDD5A96DF">关于共享SQL和并发</a><br>Oracle数据库将SQL语句编译为可执行对象一次，然后其他会话可以在对象存在的情况下重用该对象。此Oracle数据库功能（称为<strong class="term">共享SQL</strong> ）允许数据库执行非常耗费资源的操作 - 仅编译和优化SQL语句一次，而不是每次会话使用相同的SQL语句时。
                        </li>
                     </ul>
                     <div class="infoboxnotealso" id="GUID-7D6B0A76-736A-472C-9AB2-F7757CB8993A__GUID-70BFC6F0-F874-4141-A79F-9842A8253EAA">
                        <p class="notep1">也可以看看：</p>
                        <p>有关数据并发性和一致性的更多信息，请参阅<a href="../cncpt/data-concurrency-and-consistency.html#CNCPT020" target="_blank"><span class="italic">Oracle数据库概念</span></a></p>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="building-effective-applications.html#GUID-BB351358-03F9-494C-8C38-180DFB7CAC4C" title="设计应用程序以使用相同的资源，无论用户群和数据量如何，都不会使系统资源过载。">构建可伸缩应用程序</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="TDDDG277"></a><div class="props_rev_3"><a id="GUID-84ACEDC2-88E5-412C-B719-B46D4D82DD54" name="GUID-84ACEDC2-88E5-412C-B719-B46D4D82DD54"></a><h5 id="TDDDG-GUID-84ACEDC2-88E5-412C-B719-B46D4D82DD54" class="sect5"><span class="enumeration_section">8.1.4.1</span>关于序列和并发</h5>
                     <div>
                        <p>序列消除了序列化，从而提高了应用程序的并发性和可伸缩性。</p>
                        <p><strong class="term">序列</strong>是一个架构对象，多个用户可以从中生成唯一的整数，这在您需要唯一主键时非常有用。
                        </p>
                        <p>如果没有序列，则必须以编程方式生成唯一的主键值。用户通过选择最近生成的值并递增它来获取新的主键值。此技术需要在事务期间锁定并导致多个用户等待下一个主键值 - 即事务序列化。序列消除了序列化，从而提高了应用程序的并发性和可伸缩性。</p>
                     </div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-84ACEDC2-88E5-412C-B719-B46D4D82DD54__GUID-1043D7F7-70AA-4896-B3B5-A1B522A279DA">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>有关并发访问序列的信息，请参阅<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/tdddg&amp;id=CNCPT88879" target="_blank"><span class="italic">Oracle数据库概念</span></a></p>
                              </li>
                              <li>
                                 <p><span class="q">“ <a href="creating-managing-schema-objects.html#GUID-474CBF2A-BDBF-498E-98DA-16B59E4D8050" title="序列是模式对象，您可以从中生成唯一的顺序值，这在您需要唯一主键时非常有用。序列通过伪列CURRVAL和NEXTVAL使用，它们分别返回序列的当前值和下一个值。">创建和管理序列</a> ”</span></p>
                              </li>
                           </ul>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="building-effective-applications.html#GUID-7D6B0A76-736A-472C-9AB2-F7757CB8993A" title="并发是多个事务的同时执行。应用程序处理并发性越好，它的可伸缩性就越高。可伸缩应用程序可以通过按比例增加系统资源使用来处理更大的工作负载。">关于并发和可伸缩性</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TDDDG279"></a><div class="props_rev_3"><a id="GUID-005242DA-37C8-4EFD-A6B7-53183A151CB3" name="GUID-005242DA-37C8-4EFD-A6B7-53183A151CB3"></a><h5 id="TDDDG-GUID-005242DA-37C8-4EFD-A6B7-53183A151CB3" class="sect5"><span class="enumeration_section">8.1.4.2</span>关于锁存和并发</h5>
                     <div>
                        <p>锁存器的增加意味着更多基于并发的等待，因此可伸缩性降低。</p>
                        <p><strong class="term">锁存器</strong>是一种简单的低级序列化机制，用于协调对共享数据结构的多用户访问。当多个进程访问时，锁存器可保护共享内存资源免受损坏。
                        </p>
                        <p>锁存器的增加意味着更多基于并发的等待，因此可伸缩性降低。如果您可以使用在开发期间运行速度稍快的方法或使用较少锁存器的方法，请使用后者。</p>
                     </div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-005242DA-37C8-4EFD-A6B7-53183A151CB3__GUID-66664CCF-CC07-4DD9-B9D2-D2653883FABF">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>有关锁存器的信息，请参见<a href="../cncpt/data-concurrency-and-consistency.html#CNCPT1358" target="_blank"><span class="italic">Oracle数据库概念</span></a></p>
                              </li>
                              <li>
                                 <p>有关互斥锁的信息，请参阅<a href="../cncpt/data-concurrency-and-consistency.html#CNCPT88983" target="_blank"><span class="italic">Oracle数据库概念</span></a> ，互斥锁类似于单个对象的锁存器</p>
                              </li>
                           </ul>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="building-effective-applications.html#GUID-7D6B0A76-736A-472C-9AB2-F7757CB8993A" title="并发是多个事务的同时执行。应用程序处理并发性越好，它的可伸缩性就越高。可伸缩应用程序可以通过按比例增加系统资源使用来处理更大的工作负载。">关于并发和可伸缩性</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TDDDG282"></a><div class="props_rev_3"><a id="GUID-3AA5A96A-CE03-4A8D-B06D-2FE4AAE0B1DC" name="GUID-3AA5A96A-CE03-4A8D-B06D-2FE4AAE0B1DC"></a><h5 id="TDDDG-GUID-3AA5A96A-CE03-4A8D-B06D-2FE4AAE0B1DC" class="sect5"><span class="enumeration_section">8.1.4.3</span>关于非阻塞读取和写入以及并发</h5>
                     <div>
                        <p>在Oracle数据库中， <strong class="term">非阻塞读取和写入</strong>允许查询与它们正在读取的数据的更改同时执行，而不会阻塞或停止。非阻塞读取和写入允许一个会话读取数据，而另一个会话正在更改该数据。
                        </p>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="building-effective-applications.html#GUID-7D6B0A76-736A-472C-9AB2-F7757CB8993A" title="并发是多个事务的同时执行。应用程序处理并发性越好，它的可伸缩性就越高。可伸缩应用程序可以通过按比例增加系统资源使用来处理更大的工作负载。">关于并发和可伸缩性</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TDDDG329"></a><div class="props_rev_3"><a id="GUID-664969A9-F7F0-4B55-8663-C93FDD5A96DF" name="GUID-664969A9-F7F0-4B55-8663-C93FDD5A96DF"></a><h5 id="TDDDG-GUID-664969A9-F7F0-4B55-8663-C93FDD5A96DF" class="sect5"><span class="enumeration_section">8.1.4.4</span>关于共享SQL和并发</h5>
                     <div>
                        <p>Oracle数据库将SQL语句编译为可执行对象一次，然后其他会话可以在对象存在的情况下重用该对象。此Oracle数据库功能（称为<strong class="term">共享SQL</strong> ）允许数据库执行非常耗费资源的操作 - 仅编译和优化SQL语句一次，而不是每次会话使用相同的SQL语句时。
                        </p>
                     </div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-664969A9-F7F0-4B55-8663-C93FDD5A96DF__GUID-4B5685CC-41F7-4111-B9F2-9A01F73DBAD4">
                           <p class="notep1">也可以看看：</p>
                           <p>有关共享SQL的更多信息，请<a href="../cncpt/memory-architecture.html#CNCPT1228" target="_blank"><span class="italic">参见Oracle数据库概念</span></a></p>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="building-effective-applications.html#GUID-7D6B0A76-736A-472C-9AB2-F7757CB8993A" title="并发是多个事务的同时执行。应用程序处理并发性越好，它的可伸缩性就越高。可伸缩应用程序可以通过按比例增加系统资源使用来处理更大的工作负载。">关于并发和可伸缩性</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="TDDDG99927"></a><div class="props_rev_3"><a id="GUID-5381A407-3D62-4675-816C-BBB6FE34587C" name="GUID-5381A407-3D62-4675-816C-BBB6FE34587C"></a><h4 id="TDDDG-GUID-5381A407-3D62-4675-816C-BBB6FE34587C" class="sect4"><span class="enumeration_section">8.1.5</span>限制并发会话数</h4>
                  <div>
                     <p>您拥有的并发会话越多，您拥有的并发等待越多，响应时间就越慢。</p>
                     <p>如果您的计算机有<span class="italic">n个</span> CPU核心，那么最多<span class="italic">n个</span>会话实际上可以同时处于活动状态。每个额外的“并发”会话必须等待CPU核心可用才能变为活动状态。如果某些等待会话仅等待I / O，则将并发会话数增加到略多于<span class="italic">n</span>可能会略微提高运行时性能。但是，过多增加并发会话数将显着降低运行时性能。
                     </p>
                     <p><span class="keyword">SESSIONS</span>初始化参数确定系统中的最大并发用户数。有关详细信息，请参阅<a href="../refrn/SESSIONS.html#REFRN10197" target="_blank"><span class="italic">Oracle Database Reference</span></a> 。
                     </p>
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-5381A407-3D62-4675-816C-BBB6FE34587C__GUID-1B60D621-6589-41B9-A345-9B685B219751">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="http://www.youtube.com/watch?v=xNDnVOCdvQ0" target="_blank"><code class="codeph">http://www.youtube.com/watch?v=xNDnVOCdvQ0</code></a>用于显示减少12个CPU核心数千到96个计算机上的并发会话数的效果的视频</p>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="building-effective-applications.html#GUID-BB351358-03F9-494C-8C38-180DFB7CAC4C" title="设计应用程序以使用相同的资源，无论用户群和数据量如何，都不会使系统资源过载。">构建可伸缩应用程序</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="TDDDG323"></a><div class="props_rev_4"><a id="GUID-F9C3320A-832C-4762-BA39-30132C5E0EAA" name="GUID-F9C3320A-832C-4762-BA39-30132C5E0EAA"></a><h4 id="TDDDG-GUID-F9C3320A-832C-4762-BA39-30132C5E0EAA" class="sect4"><span class="enumeration_section">8.1.6</span>将编程技术与Runstats进行比较</h4>
                  <div>
                     <p>Runstats工具可以让您比较两种编程技术的性能，看看哪种更好。</p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="building-effective-applications.html#GUID-EB0B6B9D-5F70-4E43-9238-C3AC4FF9F2D8">关于Runstats</a><br>Runstats工具可以让您比较两种编程技术的性能，看看哪种更好。
                        </li>
                        <li class="ulchildlink"><a href="building-effective-applications.html#GUID-9B3E3415-5DAB-4845-A28C-9D0C430B3B23">设置Runstats</a><br>Runstats工具实现为使用视图和临时表的包。
                        </li>
                        <li class="ulchildlink"><a href="building-effective-applications.html#GUID-7F1F2916-5990-4E5E-AE23-8DA903532DFA">使用Runstats</a><br>本主题提供了使用Runstats工具的语法。
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="building-effective-applications.html#GUID-BB351358-03F9-494C-8C38-180DFB7CAC4C" title="设计应用程序以使用相同的资源，无论用户群和数据量如何，都不会使系统资源过载。">构建可伸缩应用程序</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="TDDDG327"></a><div class="props_rev_3"><a id="GUID-EB0B6B9D-5F70-4E43-9238-C3AC4FF9F2D8" name="GUID-EB0B6B9D-5F70-4E43-9238-C3AC4FF9F2D8"></a><h5 id="TDDDG-GUID-EB0B6B9D-5F70-4E43-9238-C3AC4FF9F2D8" class="sect5"><span class="enumeration_section">8.1.6.1</span>关于RUNSTATS</h5>
                     <div>
                        <p>Runstats工具可以让您比较两种编程技术的性能，看看哪种更好。</p>
                        <p>Runstats措施：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>每个技术的经过时间，以百分之一秒（hsec）为单位</p>
                           </li>
                           <li>
                              <p>第一种技术的经过时间占第二种技术的百分比</p>
                           </li>
                           <li>
                              <p>两种技术的系统统计信息（例如，解析调用）</p>
                           </li>
                           <li>
                              <p>锁定这两种技术</p>
                           </li>
                        </ul>
                        <p>在前面的测量中，最重要的是锁存（参见<span class="q">“ <a href="building-effective-applications.html#GUID-005242DA-37C8-4EFD-A6B7-53183A151CB3" title="锁存器的增加意味着更多基于并发的等待，因此可伸缩性降低。">关于锁存和并发</a> ”</span> ）。
                        </p>
                     </div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-EB0B6B9D-5F70-4E43-9238-C3AC4FF9F2D8__GUID-C995D80B-2EF6-4635-A031-962A1D1C48D5">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="building-effective-applications.html#GUID-5F486510-7FF2-4418-8D88-13B18F2E2606__BACGGFEI">例8-1</a> ，它使用Runstats</p>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="building-effective-applications.html#GUID-F9C3320A-832C-4762-BA39-30132C5E0EAA" title="Runstats工具可以让您比较两种编程技术的性能，看看哪种更好。">将编程技术与Runstats进行比较</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TDDDG328"></a><a id="TDDDG324"></a><div class="props_rev_3"><a id="GUID-9B3E3415-5DAB-4845-A28C-9D0C430B3B23" name="GUID-9B3E3415-5DAB-4845-A28C-9D0C430B3B23"></a><h5 id="TDDDG-GUID-9B3E3415-5DAB-4845-A28C-9D0C430B3B23" class="sect5"><span class="enumeration_section">8.1.6.2</span>设置Runstats</h5>
                     <div>
                        <p>Runstats工具实现为使用视图和临时表的包。</p>
                        <div class="section">
                           <div class="infoboxnote" id="GUID-9B3E3415-5DAB-4845-A28C-9D0C430B3B23__GUID-FDF7ACC4-6992-42D3-84C8-359975E1939D">
                              <p class="notep1">注意：</p>
                              <p>对于以下过程的步骤<a href="building-effective-applications.html#GUID-9B3E3415-5DAB-4845-A28C-9D0C430B3B23__BACGFDGF">1</a> ，您需要动态性能视图<span class="keyword">V $ STATNAME</span> ， <span class="keyword">V $ MYSTAT</span>和<span class="keyword">V $ LATCH</span>的<span class="keyword">SELECT</span>权限。如果您无法获得此权限，则让拥有该权限的人在步骤<a href="building-effective-applications.html#GUID-9B3E3415-5DAB-4845-A28C-9D0C430B3B23__BACGFDGF">1中</a>创建该视图并授予您对该权限的<span class="keyword">SELECT</span>权限。
                              </p>
                           </div>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-9B3E3415-5DAB-4845-A28C-9D0C430B3B23__GUID-369C1975-A3BB-4598-A200-CF188B7935B0">要设置Runstats工具：</p>
                        </div>
                        <!-- class="section" -->
                        <ol>
                           <li class="stepexpand" id="GUID-9B3E3415-5DAB-4845-A28C-9D0C430B3B23__BACGFDGF"><span>创建Runstats使用的视图：</span><div><pre class="oac_no_warn" dir="ltr">创建或替换视图统计数据选择'STAT ...'|| a.name name，b.value FROM V $ STATNAME a，V $ MYSTAT b WHERE a.statistic＃= b.statistic #UNION ALL SELECT'LATCH。 ||名字，来自V $ LATCH;</pre></div>
                           </li>
                           <li class="stepexpand"><span>创建Runstats使用的临时表：</span><div><pre class="oac_no_warn" dir="ltr">DROP TABLE run_stats; CREATE GLOBAL TEMPORARY TABLE run_stats（runid VARCHAR2（15），name VARCHAR2（80），value INT）ON COMMIT PRESERVE ROWS;</pre></div>
                           </li>
                           <li class="stepexpand"><span>创建此包规范：</span><div><pre class="oac_no_warn" dir="ltr">创建或替换包运行runstats_pkg AS程序rs_start;程序rs_middle;程序rs_stop（p_difference_threshold IN NUMBER DEFAULT 0）;结束; /</pre><p>参数<span class="parmname" translate="no">p_difference_threshold</span>控制Runstats显示的统计数据和锁存数据。仅当两种技术的差异大于<span class="parmname" translate="no">p_difference_threshold</span>时，Runstats才会显示数据。默认情况下，Runstats显示所有数据。
                                 </p>
                              </div>
                           </li>
                           <li class="stepexpand"><span>创建这个包体：</span><div><pre class="oac_no_warn" dir="ltr">创建或替换包装体runstats_pkg AS g_start NUMBER; g_run1 NUMBER; g_run2 NUMBER;程序rs_start是从run_stats开始删除; INSERT INTO run_stats SELECT'before'，stats。* FROM stats; g_start：= DBMS_UTILITY.GET_TIME; END rs_start;程序rs_middle IS BEGIN g_run1：=（DBMS_UTILITY.GET_TIME  -  g_start）; INSERT INTO run_stats SELECT'1'后'，stats。* FROM stats; g_start：= DBMS_UTILITY.GET_TIME; END rs_middle;程序rs_stop（p_difference_threshold IN NUMBER DEFAULT 0）是BEGIN g_run2：=（DBMS_UTILITY.GET_TIME  -  g_start）; DBMS_OUTPUT.PUT_LINE（'运行1在'|| g_run1 ||'hsec'中运行）; DBMS_OUTPUT.PUT_LINE（'Run 2'in'|| g_run2 ||'hsec'）; DBMS_OUTPUT.PUT_LINE（'运行1运行'|| round（g_run1 / g_run2 * 100,2）||'运行时间的％''）; DBMS_OUTPUT.PUT_LINE（CHR（9））; INSERT INTO run_stats SELECT''2'之后，统计数据。* FROM stats; DBMS_OUTPUT.PUT_LINE（RPAD（'Name'，30）|| LPAD（'Run 1'，14）|| LPAD（'Run 2'，14）|| LPAD（'Difference'，14））; FOR x IN（SELECT RPAD（a.name，30）|| TO_CHAR（b.value  -  a.value，'9,999,999,999'）|| TO_CHAR（c.value  -  b.value，'9,999,999,999'）|| TO_CHAR（（ （c.value  -  b.value） - （b.value  -  a.value）），'9,999,999,999'）数据FROM run_stats a，run_stats b，run_stats c WHERE a.name = b.name AND b.name = c。 name AND a.runid ='before'AND b.runid ='after 1'AND c.runid ='after 2'AND（c.value  -  a.value）&gt; 0 AND abs（（c.value  -  b.value ） - （b.value  -  a.value））&gt; p_difference_threshold ORDER BY ABS（（c.value  -  b.value） - （b.value  -  a.value）））LOOP DBMS_OUTPUT.PUT_LINE（x.data）;结束循环; DBMS_OUTPUT.PUT_LINE（CHR（9））; DBMS_OUTPUT.PUT_LINE（'运行1锁存总数与运行2相比 - 差异和百分比'）; DBMS_OUTPUT.PUT_LINE（LPAD（'Run 1'，14）|| LPAD（'Run 2'，14）|| LPAD（'Diff'，14）|| LPAD（'Pct'，10））; FOR x IN（选择TO_CHAR（run1，'9,999,999,999'）|| TO_CHAR（run2，'9,999,999,999'）|| TO_CHAR（diff，'9,999,999,999'）|| TO_CHAR（ROUND（g_run1 / g_run2 * 100,2），'99,999.99 '）||'％'数据FROM（SELECT SUM（b.value  -  a.value）run1，SUM（c.value  -  b.value）run2，SUM（（c.value  -  b.value） - （b。 value  -  a.value））diff FROM run_stats a，run_stats b，run_stats c WHERE a.name = b.name AND b.name = c.name AND a.runid ='before'AND b.runid ='after 1' AND c.runid ='在'2之后'和a.name之类的'LATCH％'））LOOP DBMS_OUTPUT.PUT_LINE（x.data）;结束循环; END rs_stop;结束; /</pre></div>
                           </li>
                        </ol>
                        <div class="section"></div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-9B3E3415-5DAB-4845-A28C-9D0C430B3B23__GUID-A81308B1-2977-4FE9-A269-9917C9DA497B">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><span class="q">“ <a href="creating-managing-schema-objects.html#GUID-31755C84-1EE1-41FF-9EC8-FD8CDE2D5BC1" title="要创建视图，请使用SQL Developer工具Create View或DDL语句CREATE VIEW。">创建视图</a> ”</span></p>
                              </li>
                              <li>
                                 <p><span class="q">“ <a href="creating-managing-schema-objects.html#GUID-87AA2B05-2B7B-49D9-AD21-1B2877113D23" title="要创建表，请使用SQL Developer工具Create Table或DDL语句CREATE TABLE。">创建表</a> ”</span></p>
                              </li>
                              <li>
                                 <p><span class="q">“ <a href="stored-subprograms-packages.html#GUID-B781B764-7A16-43A4-B3E7-310F2D53AFDA" title="本教程介绍如何使用“创建包”工具为名为EMP_EVAL的包创建规范，该包出现在本文档的许多教程和示例中。">教程：创建包规范</a> ”</span></p>
                              </li>
                              <li>
                                 <p><span class="q">“ <a href="stored-subprograms-packages.html#GUID-056688EF-E8CD-4215-A832-D004ABFB993C" title="本教程介绍如何使用Create Body工具为EMP_EVAL包创建一个主体，该主题出现在本文档的许多示例和教程中。">教程：创建包体</a> ”</span></p>
                              </li>
                              <li>
                                 <p>有关动态性能视图的信息，请参阅<a href="../refrn/dynamic-performance-views.html#REFRN003" target="_blank"><span class="italic">Oracle Database Reference</span></a></p>
                              </li>
                           </ul>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="building-effective-applications.html#GUID-F9C3320A-832C-4762-BA39-30132C5E0EAA" title="Runstats工具可以让您比较两种编程技术的性能，看看哪种更好。">将编程技术与Runstats进行比较</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TDDDG325"></a><div class="props_rev_3"><a id="GUID-7F1F2916-5990-4E5E-AE23-8DA903532DFA" name="GUID-7F1F2916-5990-4E5E-AE23-8DA903532DFA"></a><h5 id="TDDDG-GUID-7F1F2916-5990-4E5E-AE23-8DA903532DFA" class="sect5"><span class="enumeration_section">8.1.6.3</span>使用Runstats</h5>
                     <div>
                        <p>本主题提供了使用Runstats工具的语法。</p>
                        <div class="section">
                           <p>要使用Runstats比较两种编程技术，请使用以下语法从匿名块调用runstats_pkg过程：</p><pre class="oac_no_warn" dir="ltr">[DECLARE <span class="italic">local_declarations</span> ] BEGIN <span class="bold">runstats_pkg.rs_start;</span> <span class="italic">code_for_first_technique</span> <span class="bold">runstats_pkg.rs_middle;</span> <span class="italic">code_for_second_technique</span> <span class="bold">runstats_pkg.rs_stop（</span> <span class="italic"><span class="bold"><code class="codeph">n</code></span></span> <span class="bold">）;</span>结束; /</pre></div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-7F1F2916-5990-4E5E-AE23-8DA903532DFA__GUID-AFC7A3E2-5EBE-4DFD-A5FD-849FE9336512">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="building-effective-applications.html#GUID-5F486510-7FF2-4418-8D88-13B18F2E2606__BACGGFEI">例8-1</a> ，它使用Runstats</p>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="building-effective-applications.html#GUID-F9C3320A-832C-4762-BA39-30132C5E0EAA" title="Runstats工具可以让您比较两种编程技术的性能，看看哪种更好。">将编程技术与Runstats进行比较</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div>
               <div class="props_rev_3"><a id="GUID-450ED4B7-CB1B-4121-8FE1-682A82B4F4B9" name="GUID-450ED4B7-CB1B-4121-8FE1-682A82B4F4B9"></a><h4 id="TDDDG-GUID-450ED4B7-CB1B-4121-8FE1-682A82B4F4B9" class="sect4"><span class="enumeration_section">8.1.7</span>实际性能和数据处理技术</h4>
                  <div>
                     <p>数据仓库环境中的数据库应用程序中的常见任务是查询或修改庞大的数据集。应用程序开发人员面临的问题是如何在处理大型数据集时实现高性能。</p>
                     <p>处理技术分为两类：迭代和基于集合。经过多年的测试，Real-World Performance小组发现<span class="bold">基于集合的处理技术可以更好地</span>处理处理大型数据集的数据库应用程序。
                     </p>
                     <p>本主题包括以下主要子主题：</p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="building-effective-applications.html#GUID-675848C8-A60F-4C92-A546-FED2E16ECF0A">关于迭代数据处理</a><br>在迭代处理中，应用程序使用条件逻辑来遍历一组行。
                        </li>
                        <li class="ulchildlink"><a href="building-effective-applications.html#GUID-FF4D4809-066C-4947-9061-BD820705D59B">关于基于集合的处理</a><br>基于集合的处理是一种处理数据库内数据集的SQL技术。
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="building-effective-applications.html#GUID-BB351358-03F9-494C-8C38-180DFB7CAC4C" title="设计应用程序以使用相同的资源，无论用户群和数据量如何，都不会使系统资源过载。">构建可伸缩应用程序</a></p>
                        </div>
                     </div>
                  </div>
                  
                  <div class="props_rev_3"><a id="GUID-675848C8-A60F-4C92-A546-FED2E16ECF0A" name="GUID-675848C8-A60F-4C92-A546-FED2E16ECF0A"></a><h5 id="TDDDG-GUID-675848C8-A60F-4C92-A546-FED2E16ECF0A" class="sect5"><span class="enumeration_section">8.1.7.1</span>关于迭代数据处理</h5>
                     <div>
                        <p>在迭代处理中，应用程序使用条件逻辑来遍历一组行。</p>
                        <p>通常，尽管不一定，迭代处理使用客户端/服务器模型，如下所示：</p>
                        <ol>
                           <li>
                              <p>将一组行从数据库服务器传输到客户端应用程序。</p>
                           </li>
                           <li>
                              <p>在客户端应用程序中处理该组。</p>
                           </li>
                           <li>
                              <p>将已处理的组传回数据库服务器。</p>
                           </li>
                        </ol>
                        <p>您可以使用三种主要技术实现迭代算法：逐行处理，数组处理和手动并行。</p>
                        <div class="section">
                           <p class="subhead3" id="GUID-675848C8-A60F-4C92-A546-FED2E16ECF0A__GUID-8776E719-03B6-46D4-A9FD-DBBD022B01C1"><span class="bold">迭代处理：逐行</span></p>
                           <p>在逐行处理中，单个进程循环遍历数据集并且一次在单行上操作。在典型的实现中，应用程序从数据库中检索每一行，在中间层处理它，然后将该行发送回数据库，该数据库执行DML并提交。</p>
                           <p>假设您的功能要求是查询名为ext_scan_events的外部表，然后将其行插入名为stage1_scan_events的堆组织的临时表中。以下PL / SQL块使用逐行技术来满足此要求：</p><pre class="pre codeblock"><code>声明光标c是从ext_scan_events s中选择s。*; RC％ROWTYPE;开始c;循环获取c到r; c％未发现时退出;插入stage1_scan_events d值r;承诺;结束循环;关闭c;结束;</code></pre><p>逐行技术具有以下优点：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>它在小型数据集上表现良好。</p>
                              </li>
                              <li>
                                 <p>循环算法对所有专业开发人员来说都很熟悉，易于编写，易于理解。</p>
                              </li>
                           </ul>
                           <p>逐行技术具有以下缺点：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>对于大型数据集，处理时间可能长得令人无法接受。</p>
                              </li>
                              <li>
                                 <p>应用程序串行执行，因此无法利用在现代硬件上运行的Oracle数据库的本机并行处理功能。</p>
                              </li>
                           </ul>
                           <p>另请参见：RWP＃7基于集合的处理</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-675848C8-A60F-4C92-A546-FED2E16ECF0A__GUID-70C46836-26D8-42CF-A6CB-5848B7465AB4"><span class="bold">迭代处理： <span class="bold">数组</span></span></p>
                           <p>数组处理与逐行处理相同，只是它在每次迭代中处理一组行而不是单行。</p>
                           <p>假设您的功能需求与示例XX中的相同：查询名为ext_scan_events的外部表，然后将其行插入名为stage1_scan_events的堆组织的临时表中。以下PL / SQL块使用数组技术来满足此要求：</p><pre class="pre codeblock"><code>声明光标c是从ext_scan_events s中选择s。*; type t是binary_integer的c％rowtype index表;在; rows binary_integer：= 0;开始c; loop fetch c bulk collect into limit array_size;当a.count = 0时退出; foall i in 1..a.count insert into stage1_scan_events d values a（i）;承诺;结束循环;关闭c;结束;</code></pre><p>前面的代码与FETCH STATEMENT中使用BULK COLLECT运算符的等效逐行代码不同，后者受PLS_INTEGER类型的<code class="codeph">array_size</code>值的限制。例如，如果<code class="codeph">array_size</code>设置为100，则应用程序将以100为一组获取行。
                           </p>
                           <p>与逐行技术相比，阵列技术具有以下优点：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>该阵列使应用程序能够同时处理一组行，这意味着它可以减少网络往返，COMMIT时间以及客户端和服务器中的代码路径。</p>
                              </li>
                              <li>
                                 <p>数据库更有效，因为服务器进程批量插入，并在每组插入之后而不是在每次插入之后提交。</p>
                              </li>
                           </ul>
                           <p>该技术的缺点与逐行处理相同。处理时间对于大型数据集来说是不可接受的。此外，应用程序必须在单个CPU内核上串行运行，因此无法利用Oracle数据库的本机并行性。</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-675848C8-A60F-4C92-A546-FED2E16ECF0A__GUID-D3C83919-3B21-4F1C-9CC5-AEC60A7296A0"><span class="bold">迭代处理： <span class="bold">手动并行</span></span></p>
                           <p>手动并行使用与逐行和数组处理相同的迭代算法，但允许多个服务器进程分割工作并并行运行。</p>
                           <p>假设功能要求与逐行和数组示例相同。主要区别如下：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>扫描事件记录存储在大量平面文件中。</p>
                              </li>
                              <li>
                                 <p>32个服务器进程必须并行运行，每个服务器进程查询不同的外部表。</p>
                              </li>
                              <li>
                                 <p>您可以通过执行同一PL / SQL程序的32个线程来使用PL / SQL来实现并行性，每个线程同时作为Oracle Scheduler管理的单独作业运行。工作是计划和计划的组合。</p>
                              </li>
                           </ul>
                           <p>以下PL / SQL代码使用手动并行：</p><pre class="pre codeblock"><code>声明sqlstmt varchar2（1024）：= q'[ -  BEGIN嵌入式匿名块游标c是从ext_scan_events _ $ {thr} s中选择s。*; type t是binary_integer的c％rowtype index表;在; rows binary_integer：= 0;以r开头（从ext_scan_events_dets中选择ext_file_name，其中ora_hash（file_seq_nbr，$ {thrs}）= $ {thr}）循环执行立即'alter table ext_scan_events _ $ {thr} location'|| '（'|| r.ext_file_name ||'）';打开c; loop fetch c bulk collect into limit $ {array_size};当a.count = 0时退出; foall i in 1..a.count insert into stage1_scan_events d values a（i）;承诺; -  demo instrumentation rows：= rows + a.count;如果rows&gt; 1e3则在没有sd_control.p_progress（'loading'，'userdefined'，rows）时退出; rows：= 0;万一;结束循环;关闭c;结束循环;结束; -  END嵌入匿名块]'; begin sqlstmt：= replace（sqlstmt，'$ {array_size}'，to_char（array_size））; sqlstmt：= replace（sqlstmt，'$ {thr}'，thr）; sqlstmt：= replace（sqlstmt，'$ {thrs}'，thrs）;执行立即sqlstmt;结束;</code></pre><p>ORA_HASH函数将ext_scan_events_dets表划分为32个均匀分布的存储桶，然后SELECT语句检索存储桶0的文件名。对于存储桶中的每个文件名，程序会将外部表的位置设置为此文件名。然后，程序使用批处理来查询外部表，插入到临时表中，然后提交。</p>
                           <p>当作业1正在执行时，其他31个Oracle Scheduler作业并行执行。通过这种方式，每个作业同时读取扫描事件文件的不同子集，并将记录从其子集插入到同一个登台表中。</p>
                           <p>与其他迭代技术相比，手动并行技术具有以下优点：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>它在大型数据集上的表现要好得多，因为服务器进程并行工作。</p>
                              </li>
                              <li>
                                 <p>当应用程序使用ORA_HASH分配工作负载时，每个执行线程都可以访问相同数量的数据，这意味着并行进程可以同时完成。</p>
                              </li>
                           </ul>
                           <p>手动并行技术具有以下缺点：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>代码相对冗长，复杂且难以理解。</p>
                              </li>
                              <li>
                                 <p>在数据库开始主要工作之前，应用程序必须执行一定量的准备工作，主要工作是并行处理行。</p>
                              </li>
                              <li>
                                 <p>如果多个线程对一组公共数据库对象执行相同的操作，则可以进行锁定和锁存争用。</p>
                              </li>
                              <li>
                                 <p>与竞争迭代技术相比，并行处理消耗大量CPU资源。</p>
                              </li>
                           </ul>
                           <p>另请参见：RWP＃8：基于集合的并行处理</p>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="building-effective-applications.html#GUID-450ED4B7-CB1B-4121-8FE1-682A82B4F4B9" title="数据仓库环境中的数据库应用程序中的常见任务是查询或修改庞大的数据集。应用程序开发人员面临的问题是如何在处理大型数据集时实现高性能。">实际性能和数据处理技术</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
                  <div class="props_rev_3"><a id="GUID-FF4D4809-066C-4947-9061-BD820705D59B" name="GUID-FF4D4809-066C-4947-9061-BD820705D59B"></a><h5 id="TDDDG-GUID-FF4D4809-066C-4947-9061-BD820705D59B" class="sect5"><span class="enumeration_section">8.1.7.2</span>关于基于集的处理</h5>
                     <div>
                        <p>基于集合的处理是一种处理数据库内数据集的SQL技术。</p>
                        <p>在基于集合的模型中，SQL语句定义结果，并允许数据库确定获取它的最有效方法。相反，迭代算法使用条件逻辑将每行或每组行从数据库拉到客户端应用程序，处理客户端上的数据，然后将数据发送回数据库。基于集合的处理消除了网络往返和数据库API开销，因为数据永远不会离开数据库。</p>
                        <p>假设与前面的例子中相同的功能要求。以下SQL语句使用基于集合的算法满足此要求：</p><pre class="pre codeblock"><code>alter session enable parallel dml;插入/ * + APPEND * / into stage1_scan_events d从ext_scan_events s中选择s。*;承诺;</code></pre><p>由于INSERT语句包含ext_scan_events表的子查询，因此<span class="italic">单个</span> SQL语句将读取和写入所有行。此外，应用程序在数据库插入所有行后执行<span class="italic">单个</span> COMMIT。相反，迭代应用程序在插入每行或每组行之后执行COMMIT。
                        </p>
                        <p>基于集合的技术与迭代技术相比具有明显的优势：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>正如在真实世界性能演示和类中所证明的那样，大型数据集的性能要快几个数量级。程序的运行时间从几小时降到几秒并不罕见。</p>
                           </li>
                           <li>
                              <p>处理速度的数量级增加的副作用是DBA可以实时消除长时间运行且容易出错的批处理作业和无聊的业务流程。</p>
                           </li>
                           <li>
                              <p>代码的长度明显更短，只需要两到三行代码，因为SQL定义了结果而不是访问方法。</p>
                           </li>
                           <li>
                              <p>与手动并行性相比，并行DML针对性能进行了优化，因为数据库而不是应用程序管理进程。</p>
                           </li>
                           <li>
                              <p>加入数据集时，数据库会自动使用高效的散列连接，而不是相对低效的应用程序级循环。</p>
                           </li>
                           <li>
                              <p>APPEND提示强制直接路径加载，这意味着数据库不会创建重做和撤消，从而避免浪费I / O和CPU。</p>
                           </li>
                        </ul>
                        <p>基于集合的处理确实存在一些潜在的缺点：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>许多数据库开发人员都不熟悉这些技术，因此它们可能更难。</p>
                           </li>
                           <li>
                              <p>因为基于集合的模型与迭代模型完全不同，所以更改它需要完全重写源代码。</p>
                           </li>
                        </ul>
                        <p>另请参见：RWP＃7基于集合的处理，RWP＃8：基于集合的并行处理，RWP＃9：基于集合的处理 - 重复数据删除，RWP＃10：基于集合的处理 - 数据转换和RWP＃ 11：基于集合的处理 - 数据聚合</p>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="building-effective-applications.html#GUID-450ED4B7-CB1B-4121-8FE1-682A82B4F4B9" title="数据仓库环境中的数据库应用程序中的常见任务是查询或修改庞大的数据集。应用程序开发人员面临的问题是如何在处理大型数据集时实现高性能。">实际性能和数据处理技术</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div>
            </div><a id="TDDDG99926"></a><div class="props_rev_4"><a id="GUID-1E354949-D957-4C58-8670-92E11B928CD1" name="GUID-1E354949-D957-4C58-8670-92E11B928CD1"></a><h3 id="TDDDG-GUID-1E354949-D957-4C58-8670-92E11B928CD1" class="sect3"><span class="enumeration_section">8.2</span>推荐的编程实践</h3>
               <div>
                  <p>使用以下推荐的编程实践。</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="building-effective-applications.html#GUID-599E1D75-50C0-423C-BC81-6A96B826FB6A">使用仪器包</a><br>Oracle数据库提供的检测包，其子程序允许应用程序在必要时生成跟踪信息。使用此跟踪信息，您可以在不使用调试器的情况下调试应用程序，并识别性能不佳的代码。
                     </li>
                     <li class="ulchildlink"><a href="building-effective-applications.html#GUID-FCB36240-011D-48CE-A32E-E5999A79E3B0">统计收集和应用程序跟踪</a><br>数据库统计信息提供有关数据库上的负载类型以及数据库使用的内部和外部资源的信息。要使用ADDM准确诊断数据库的性能问题，必须提供统计信息。
                     </li>
                     <li class="ulchildlink"><a href="building-effective-applications.html#GUID-681449ED-4B87-4434-9D57-1642BE5F6134">使用现有功能</a><br>使用现有功能的应用程序比不使用现有功能的应用程序更容易开发和维护，而且运行速度也更快。
                     </li>
                     <li class="ulchildlink"><a href="building-effective-applications.html#GUID-15E13CE8-9E37-40DE-B259-89E82C92FA03">使用版本视图覆盖数据库表</a><br>如果您的应用程序使用数据库表，则使用版本视图覆盖每个表，以便您可以使用基于版本的重新定义（EBR）在应用程序使用时升级其数据库组件，从而最大限度地减少或消除停机时间。
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="building-effective-applications.html#GUID-F6EB9789-00D7-472F-A36C-F55C143307BC" title="有效的应用程序是可扩展的，并使用推荐的编程和安">构建有效的应用程序</a></p>
                     </div>
                  </div>
               </div>
               <a id="TDDDG99925"></a><div class="props_rev_3"><a id="GUID-599E1D75-50C0-423C-BC81-6A96B826FB6A" name="GUID-599E1D75-50C0-423C-BC81-6A96B826FB6A"></a><h4 id="TDDDG-GUID-599E1D75-50C0-423C-BC81-6A96B826FB6A" class="sect4"><span class="enumeration_section">8.2.1</span>使用仪表包</h4>
                  <div>
                     <p>Oracle数据库提供的检测包，其子程序允许应用程序在必要时生成跟踪信息。使用此跟踪信息，您可以在不使用调试器的情况下调试应用程序，并识别性能不佳的代码。</p>
                     <p>Instrumentation为您的应用程序提供了相当多的功能因此，它不是开销。开销是您可以删除而不会失去太多好处的东西。</p>
                     <p>Oracle数据库提供的一些检测包是：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>DBMS_APPLICATION_INFO，使系统管理员能够按模块跟踪应用程序的性能。</p>
                           <p>有关DBMS_APPLICATION_INFO的详细信息，请参阅<a href="../arpls/DBMS_APPLICATION_INFO.html#ARPLS003" target="_blank"><span class="italic">Oracle Database PL / SQL包和类型参考</span></a> 。
                           </p>
                        </li>
                        <li>
                           <p>DBMS_SESSION，它使您的应用程序能够访问会话信息并设置首选项和安全级别</p>
                           <p>有关DBMS_SESSION的详细信息，请参阅<a href="../arpls/DBMS_SESSION.html#ARPLS054" target="_blank"><span class="italic">Oracle Database PL / SQL包和类型参考</span></a> 。
                           </p>
                        </li>
                        <li>
                           <p>UTL_FILE，它使您的应用程序能够读写操作系统文本文件</p>
                           <p>有关UTL_FILE的更多信息，请参阅<a href="../arpls/UTL_FILE.html#ARPLS069" target="_blank"><span class="italic">Oracle Database PL / SQL包和类型参考</span></a> 。
                           </p>
                        </li>
                     </ul>
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-599E1D75-50C0-423C-BC81-6A96B826FB6A__GUID-E4C7C11B-9E90-4538-B2C6-2BAE008E0D3E">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="../arpls/introduction-to-oracle-supplied-plsql-packages-and-types.html#ARPLS139" target="_blank"><span class="italic">Oracle Database PL / SQL包和类型参考</span></a> ，提供Oracle数据库提供的PL / SQL包的摘要</p>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="building-effective-applications.html#GUID-1E354949-D957-4C58-8670-92E11B928CD1" title="使用以下推荐的编程实践。">推荐的编程实践</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="TDDDG99924"></a><div class="props_rev_3"><a id="GUID-FCB36240-011D-48CE-A32E-E5999A79E3B0" name="GUID-FCB36240-011D-48CE-A32E-E5999A79E3B0"></a><h4 id="TDDDG-GUID-FCB36240-011D-48CE-A32E-E5999A79E3B0" class="sect4"><span class="enumeration_section">8.2.2</span>统计信息收集和应用跟踪</h4>
                  <div>
                     <p>数据库统计信息提供有关数据库上的负载类型以及数据库使用的内部和外部资源的信息。要使用ADDM准确诊断数据库的性能问题，必须提供统计信息。</p>
                     <p>有关统计信息收集的信息，请参阅<a href="../tdppt/oracle-database-performance-method.html#TDPPT007" target="_blank"><span class="italic">Oracle Database 2 Day +性能调整指南</span></a> 。
                     </p>
                     <div class="infoboxnote" id="GUID-FCB36240-011D-48CE-A32E-E5999A79E3B0__GUID-25C33ED5-748D-46B1-A859-EB013A75E478">
                        <p class="notep1">注意：</p>
                        <p>如果Oracle Enterprise Manager不可用，则可以使用DBMS_MONITOR子程序收集统计信息，如<a href="../arpls/DBMS_MONITOR.html#ARPLS091" target="_blank"><span class="italic">Oracle数据库PL / SQL包和类型参考中所述</span></a> 。
                        </p>
                     </div>
                     <p>Oracle数据库提供了多种跟踪工具，可以帮助您监视和分析Oracle数据库应用程序。有关详细信息，请参见“ <a href="../tgsql/performing-application-tracing.html#TGSQL791" target="_blank"><span class="italic">Oracle数据库SQL调优指南”</span></a> 。
                     </p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="building-effective-applications.html#GUID-1E354949-D957-4C58-8670-92E11B928CD1" title="使用以下推荐的编程实践。">推荐的编程实践</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="TDDDG281"></a><a id="TDDDG99922"></a><div class="props_rev_3"><a id="GUID-681449ED-4B87-4434-9D57-1642BE5F6134" name="GUID-681449ED-4B87-4434-9D57-1642BE5F6134"></a><h4 id="TDDDG-GUID-681449ED-4B87-4434-9D57-1642BE5F6134" class="sect4"><span class="enumeration_section">8.2.3</span>使用现有功能</h4>
                  <div>
                     <p>使用现有功能的应用程序比不使用现有功能的应用程序更容易开发和维护，而且运行速度也更快。</p>
                     <p>在开发应用程序时，请尽可能使用编程语言，操作系统，Oracle数据库的现有功能以及Oracle数据库提供的PL / SQL包和类型。</p>
                     <p>许多开发人员重新发明的现有功能的示例如下：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><span class="bold">约束</span></p>
                           <p>有关约束的介绍性信息，请参阅<span class="q">“ <a href="creating-managing-schema-objects.html#GUID-144C564C-0B08-40BF-9AC9-3035CFD03F66" title="要确保表中的数据满足应用程序建模的业务规则，可以使用约束，应用程序逻辑或两者。">确保表中的数据完整性</a> ”。</span></p>
                        </li>
                        <li>
                           <p><span class="bold">SQL函数</span> （“内置于”SQL中的函数）</p>
                           <p>有关SQL函数的信息，请参见<a href="../sqlrf/Functions.html#SQLRF006" target="_blank"><span class="italic">Oracle数据库SQL语言参考</span></a> 。
                           </p>
                        </li>
                        <li>
                           <p><span class="bold">序列</span> （可以生成唯一的顺序值）</p>
                           <p>请参阅<span class="q">“ <a href="creating-managing-schema-objects.html#GUID-474CBF2A-BDBF-498E-98DA-16B59E4D8050" title="序列是模式对象，您可以从中生成唯一的顺序值，这在您需要唯一主键时非常有用。序列通过伪列CURRVAL和NEXTVAL使用，它们分别返回序列的当前值和下一个值。">创建和管理序列</a> ”</span> 。
                           </p>
                        </li>
                        <li>
                           <p><span class="bold">审计</span> （监视和记录所选用户数据库操作）</p>
                           <p>有关审核的介绍性信息，请参阅“ <a href="../dbseg/introduction-to-auditing.html#DBSEG-GUID-94381464-53A3-421B-8F13-BD171C867405" target="_blank"><span class="italic">Oracle数据库安全指南”</span></a> 。
                           </p>
                        </li>
                        <li>
                           <p><span class="bold">复制</span> （在包含分布式数据库系统的多个数据库中复制和维护数据库对象（如表）的过程）</p>
                           <p>有关复制的信息，请参阅Oracle GoldenGate文档。</p>
                        </li>
                        <li>
                           <p><span class="bold">消息队列</span> （基于Web的业务应用程序如何相互通信）</p>
                           <p>有关Oracle数据库高级队列（AQ）的介绍性信息，请参阅“ <a href="../adque/aq-introduction.html#ADQUE0100" target="_blank"><span class="italic">Oracle数据库高级队列用户指南”</span></a> 。
                           </p>
                        </li>
                        <li>
                           <p><span class="bold">保持记录变更的历史</span></p>
                           <p>有关Workspace Manager的介绍性信息，请参阅<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/tdddg&amp;id=ADWSM010" target="_blank"><span class="italic">Oracle Database Workspace Manager Developer's Guide</span></a> 。
                           </p>
                        </li>
                     </ul>
                     <p>在<a href="building-effective-applications.html#GUID-681449ED-4B87-4434-9D57-1642BE5F6134__BACGDEFE">例8-4中</a> ，两个并发事务使存储在表中的消息出列（即，每个事务查找并锁定表的下一个未处理行）。该示例不是简单地调用DBMS_AQ.DEQUEUE过程（在<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/tdddg&amp;id=ARPLS098" target="_blank"><span class="italic">Oracle数据库PL / SQL包和类型参考中描述</span></a> ），而是在表上创建基于函数的索引，然后在每个事务中使用该函数来检索行并显示消息。
                     </p>
                     <p><a href="building-effective-applications.html#GUID-681449ED-4B87-4434-9D57-1642BE5F6134__BACGDEFE">例8-4中</a>的代码实现了类似于DBMS_AQ.DEQUEUE调用的功能，但功能较少。使用现有功能（在本例中为基于函数的索引）节省的开发时间可能很长。
                     </p>
                     <div class="example" id="GUID-681449ED-4B87-4434-9D57-1642BE5F6134__BACGDEFE">
                        <p class="titleinexample">例8-4并发出列事务</p>
                        <p>创建表格：</p><pre class="oac_no_warn" dir="ltr">DROP TABLE t; CREATE TABLE t（id NUMBER PRIMARY KEY，processed_flag VARCHAR2（1），payload VARCHAR2（20））;</pre><p><span class="bold">在表上创建索引：</span></p><pre class="oac_no_warn" dir="ltr">CREATE INDEX t_idx ON t（DECODE（processed_flag，'N'，'N'））;</pre><p>填充表格：</p><pre class="oac_no_warn" dir="ltr">INSERT INTO t SELECT r，MODE（r，2）= 0时的情况那么'N'ELSE'Y'END，'payload'|| r FROM（选择级别来自双级连接&lt;= 5）;</pre><p>显示表：</p><pre class="oac_no_warn" dir="ltr">SELECT * FROM t;</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">ID P PAYLOAD ----------  -  -------------------- 1 Y payload 1 2 N payload 2 3 Y payload 3 4 N payload 4 5 Y有效载荷5 5行选择。
</pre><p><span class="bold">第一笔交易：</span></p><pre class="oac_no_warn" dir="ltr">DECLARE l_rec t％ROWTYPE; CURSOR c IS SELECT * FROM t WHERE DECODE（processed_flag，'N'，'N'）='N'FOR UPDATE SKIP LOCKED; BEGIN OPEN c; FETCH c INTO l_rec; IF（c％FOUND）那么DBMS_OUTPUT.PUT_LINE（'得到行'|| l_rec.id ||'，'|| l_rec.payload）;万一;关闭c;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">得到第2行，有效载荷2</pre><p><span class="bold">并发交易：</span></p><pre class="oac_no_warn" dir="ltr">DECLARE <span class="bold">PRAGMA AUTONOMOUS_TRANSACTION;</span> l_rec t％ROWTYPE; CURSOR c IS SELECT * FROM t WHERE DECODE（processed_flag，'N'，'N'）='N'FOR UPDATE SKIP LOCKED; BEGIN OPEN c; FETCH c INTO l_rec; IF（c％FOUND）那么DBMS_OUTPUT.PUT_LINE（'得到行'|| l_rec.id ||'，'|| l_rec.payload）;万一;关闭c;承诺;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">得到第4行，有效载荷4</pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-681449ED-4B87-4434-9D57-1642BE5F6134__GUID-496A3D86-1787-4C06-A1B8-D9BC4B7F0E46">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="../newft/index.html" target="_blank"><span class="italic">Oracle数据库新增功能指南</span></a> （每个版本）</p>
                           </li>
                           <li>
                              <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/tdddg&amp;id=CNCPT" target="_blank"><span class="italic">Oracle数据库概念</span></a> （每个版本）</p>
                           </li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="building-effective-applications.html#GUID-1E354949-D957-4C58-8670-92E11B928CD1" title="使用以下推荐的编程实践。">推荐的编程实践</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="TDDDG151"></a><div class="props_rev_3"><a id="GUID-15E13CE8-9E37-40DE-B259-89E82C92FA03" name="GUID-15E13CE8-9E37-40DE-B259-89E82C92FA03"></a><h4 id="TDDDG-GUID-15E13CE8-9E37-40DE-B259-89E82C92FA03" class="sect4"><span class="enumeration_section">8.2.4</span>使用版本视图覆盖数据库表</h4>
                  <div>
                     <p>如果您的应用程序使用数据库表，则使用版本视图覆盖每个表，以便您可以使用基于版本的重新定义（EBR）在应用程序使用时升级其数据库组件，从而最大限度地减少或消除停机时间。</p>
                     <p>有关基于版本的重新定义的信息，请参阅“ <a href="../adfns/editions.html#ADFNS020" target="_blank"><span class="italic">Oracle数据库开发指南”</span></a> 。
                     </p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="building-effective-applications.html#GUID-1E354949-D957-4C58-8670-92E11B928CD1" title="使用以下推荐的编程实践。">推荐的编程实践</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div><a id="TDDDG152"></a><div class="props_rev_3"><a id="GUID-32FBC335-6B08-4B50-B039-06BB9F500908" name="GUID-32FBC335-6B08-4B50-B039-06BB9F500908"></a><h3 id="TDDDG-GUID-32FBC335-6B08-4B50-B039-06BB9F500908" class="sect3"><span class="enumeration_section">8.3</span>推荐的安全实践</h3>
               <div>
                  <p>在为组成应用程序的模式对象授予权限时，请使用<strong class="term">最小权限原则</strong> 。
                  </p>
                  <p>也就是说，应该为用户和中间层提供执行其操作所需的最少权限，以减少无意或恶意未授权活动的危险。</p>
               </div>
               <div>
                  <div class="infoboxnotealso" id="GUID-32FBC335-6B08-4B50-B039-06BB9F500908__GUID-98743123-C530-4DE0-9862-B41663CDEBE1">
                     <p class="notep1">也可以看看：</p>
                     <p><span class="q">“ <a href="building-effective-applications.html#GUID-5F486510-7FF2-4418-8D88-13B18F2E2606" title="正确使用的绑定变量可让您开发高效，可伸缩的应用程序。">使用绑定变量提高可伸缩性</a> ”</span>有关使用绑定变量而不是字符串文字的信息，这是使代码无法受到SQL注入攻击的最有效方法</p>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="building-effective-applications.html#GUID-F6EB9789-00D7-472F-A36C-F55C143307BC" title="有效的应用程序是可扩展的，并使用推荐的编程和安">构建有效的应用程序</a></p>
                     </div>
                  </div>
               </div>
               
            </div>
         </div>
      </article>
   </body>
</html>