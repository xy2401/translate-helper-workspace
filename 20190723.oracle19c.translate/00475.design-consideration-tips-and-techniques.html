<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <title>设计考虑技巧和技巧</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Object-Relational Developer&#39;s Guide "></meta>
      <meta property="og:description" content=""></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Object-Relational Developer&#39;s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="object-relational-developers-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-11T02:05:10-08:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="1996, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96436-01"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="parallel-queries-with-oracle-objects.html" title="Previous" type="text/html"></link>
      <link rel="next" href="glossary.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Object-Relational Developer&#39;s Guide"></meta>
    <meta name="dcterms.isVersionOf" content="ADOBJ"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="parallel-queries-with-oracle-objects.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="glossary.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">对象关系开发人员指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="design-considerations-for-oracle-objects.html" property="item" typeof="WebPage"><span property="name">Oracle Objects的设计注意事项</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">设计考虑技巧和技巧</li>
            </ol>
            <a id="GUID-4DBA36C1-2766-49E8-8975-CA4D7376A969" name="GUID-4DBA36C1-2766-49E8-8975-CA4D7376A969"></a><a id="ADOBJ7487"></a>
            
            <h2 id="ADOBJ-GUID-4DBA36C1-2766-49E8-8975-CA4D7376A969" class="sect2"><span class="enumeration_section">9.13</span>设计考虑提示和技巧</h2>
         </header>
         <div class="ind">
            <div>
               <p>有关使用Oracle对象类型的各个方面的各种提示。</p>
               <p>话题：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="design-consideration-tips-and-techniques.html#GUID-C4B5DD32-9FA2-425F-8983-C556353E1693">是进化类型还是创建子类型</a></p>
                  </li>
                  <li>
                     <p><a href="design-consideration-tips-and-techniques.html#GUID-B3509AEC-B97F-4115-AD40-4C4C6D9FE40F">ANYDATA如何与用户定义的类型不同</a></p>
                  </li>
                  <li>
                     <p><a href="design-consideration-tips-and-techniques.html#GUID-BA43C8D8-97AC-4EBA-9511-D4A21469F979">多态视图：对象视图层次结构的替代方法</a></p>
                  </li>
                  <li>
                     <p><a href="design-consideration-tips-and-techniques.html#GUID-8F972C30-6642-4773-87FB-91E6FBA9F609">SQLJ对象类型</a></p>
                  </li>
                  <li>
                     <p><a href="design-consideration-tips-and-techniques.html#GUID-429AA7D1-7FB8-47B5-ABE8-A9CAEAAE89B4">杂项设计技巧</a></p>
                  </li>
               </ul>
            </div><a id="ADOBJ7489"></a><a id="ADOBJ7490"></a><a id="ADOBJ7488"></a><div class="props_rev_3"><a id="GUID-C4B5DD32-9FA2-425F-8983-C556353E1693" name="GUID-C4B5DD32-9FA2-425F-8983-C556353E1693"></a><h3 id="ADOBJ-GUID-C4B5DD32-9FA2-425F-8983-C556353E1693" class="sect3"><span class="enumeration_section">9.13.1</span>是否进化类型或创建子类型</h3>
               <div>
                  <p>随着应用程序经历其生命周期，通常会出现问题<a id="d36969e140" class="indexterm-anchor"></a><a id="d36969e144" class="indexterm-anchor"></a>更改现有对象类型或创建专用子类型以满足新要求。答案取决于新要求的性质及其在整个应用程序语义中的上下文。这是两个例子：</p>
                  <div class="section">
                     <p class="subhead2" id="GUID-C4B5DD32-9FA2-425F-8983-C556353E1693__GUID-D24D3AEF-248F-4551-8B44-69B57692384C">更改广泛使用的基本类型</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p>假设我们有一个带有<code class="codeph">Street</code> ， <code class="codeph">State</code>和<code class="codeph">ZIP</code>属性的对象类型<code class="codeph">address</code> ：</p><pre class="oac_no_warn" dir="ltr">CREATE TYPE地址AS OBJECT（Street VARCHAR2（80），State VARCHAR2（20），ZIP VARCHAR2（10））; /</pre><p>我们后来发现我们需要通过添加<code class="codeph">Country</code>属性来扩展<code class="codeph">address</code>类型以支持国际地址。创建<code class="codeph">address</code>子类型或改进<code class="codeph">address</code>类型本身更好吗？
                     </p>
                     <p>对于在整个应用程序中广泛使用的通用基类型，最好使用类型演化来实现更改。</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-C4B5DD32-9FA2-425F-8983-C556353E1693__GUID-D3231A62-6F34-4888-8B47-C67C5209C5AB">添加专业化</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p>假设图形类型的现有类型层次结构（例如，曲线，圆形，正方形，文本）需要容纳另外的变化，即贝塞尔曲线。为了支持这种不反映基类型缺点的新专业化，我们应该使用继承并在<code class="codeph">Curve</code>类型下创建一个新的子类型<code class="codeph">BezierCurve</code> 。
                     </p>
                     <p>总而言之，所需更改的语义决定了我们是否应该使用类型演化或继承。对于更通用且影响基本类型的更改，请使用类型evolution。要进行更专业的更改，请使用继承实现更改。</p>
                  </div>
                  <!-- class="section" -->
               </div>
            </div><a id="ADOBJ7491"></a><div class="props_rev_3"><a id="GUID-B3509AEC-B97F-4115-AD40-4C4C6D9FE40F" name="GUID-B3509AEC-B97F-4115-AD40-4C4C6D9FE40F"></a><h3 id="ADOBJ-GUID-B3509AEC-B97F-4115-AD40-4C4C6D9FE40F" class="sect3"><span class="enumeration_section">9.13.2</span> ANYDATA与用户定义类型的不同之处</h3>
               <div>
                  <p><code class="codeph">ANYDATA</code>是Oracle提供的类型，可以保存任何Oracle数据类型的实例，无论是内置的还是用户定义的。<code class="codeph">ANYDATA</code>是一种自描述类型，支持类似反射的API，可用于确定实例的形状。
                  </p>
                  <p>虽然继承，通过可替代性特征和<code class="codeph">ANYDATA</code>提供了在占位符中存储任何一组可能实例的多态性， <code class="codeph">ANYDATA</code>两种模型赋予了两种截然不同的形式。
                  </p>
                  <p>在继承模型中， <a id="d36969e262" class="indexterm-anchor"></a>多态的可能实例集必须构成单个类型层次结构的一部分。变量可能只包含其定义类型或其子类型的实例。您可以访问超类型的属性并调用超类型中定义的方法（并且可能被子类型覆盖）。您还可以使用IS OF和TREAT运算符测试实例的特定类型。
                  </p>
                  <p>但是， <code class="codeph">ANYDATA</code>变量可以存储异构实例。您无法访问存储在<code class="codeph">ANYDATA</code>变量中的实际实例的属性或调用方法（除非您提取实例）。您可以使用<code class="codeph">ANYDATA</code>方法来发现和提取实例的类型。当函数/过程不关心参数的特定类型时， <code class="codeph">ANYDATA</code>是一种非常有用的参数传递机制。
                  </p>
                  <p>继承提供更好的建模，强类型，专业化等。当您只想拥有任何可能不具有任何共同点的可能实例中的一个时，请使用<code class="codeph">ANYDATA</code> 。
                  </p>
               </div>
            </div><a id="ADOBJ7492"></a><div class="props_rev_3"><a id="GUID-BA43C8D8-97AC-4EBA-9511-D4A21469F979" name="GUID-BA43C8D8-97AC-4EBA-9511-D4A21469F979"></a><h3 id="ADOBJ-GUID-BA43C8D8-97AC-4EBA-9511-D4A21469F979" class="sect3"><span class="enumeration_section">9.13.3</span>多态视图：对象视图层次结构的替代方法</h3>
               <div>
                  <p><a href="applying-an-object-model-to-relational-data.html#GUID-5D527C3A-6B6F-4C8E-A3F5-93340737F8B0" title="您可以编写面向对象的应用程序，而无需更改关系数据的基础结构。">将对象模型应用于关系数据</a>描述了如何构建一个<a id="d36969e341" class="indexterm-anchor"></a><a id="d36969e345" class="indexterm-anchor"></a><a id="d36969e347" class="indexterm-anchor"></a>从一组对象视图查看层次结构，每个对象视图包含单个类型的对象。这样的视图层次结构使得对层次结构内的视图的查询能够查看查询视图或其子视图所包含的多态对象集。
                  </p>
                  <p>作为支持此类多态查询的替代方法，您可以基于返回多态对象集的查询来定义对象视图。当您想要在已存在的一组表或视图上定义视图时，此方法特别有用。</p>
                  <p>例如， <code class="codeph">Person_t</code>的对象视图可以在返回<code class="codeph">Person_t</code>实例的查询上定义，包括<code class="codeph">Employee_t</code>实例。以下语句基于从<code class="codeph">persons</code>表中选择人员和从<code class="codeph">employees</code>表中选择员工的查询来创建视图。
                  </p><pre class="pre codeblock"><code>创建视图Persons_view of Person_t AS SELECT Person_t（...）来自人员UNION ALL SELECT TREAT（Employee_t（...）AS Person_t）来自员工;</code></pre><p>为此视图定义的<code class="codeph">INSTEAD OF</code>触发器可以使用<code class="codeph">VALUE</code>函数来访问当前对象，并根据对象的最具体类型采取适当的操作。
                  </p>
                  <p>多态视图和对象视图层次结构具有以下重要差异：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><span class="bold">可寻址性</span> ：在视图层次结构中，每个子视图都可以在查询和DML语句中独立引用。因此，特定类型的每组对象都具有逻辑名称。但是，多态视图是单个视图，因此必须使用谓词来获取特定类型的对象集。
                        </p>
                     </li>
                     <li>
                        <p><span class="bold">Evolution</span> ：如果添加了新的子类型，则可以将子视图添加到视图层次结构中，而无需更改现有视图定义。使用多态视图时，必须通过添加另一个<code class="codeph">UNION</code>分支来修改单个视图定义。
                        </p>
                     </li>
                     <li>
                        <p><span class="bold">DML语句</span> ：在视图层次结构中，每个子视图可以是固有可更新的，也可以有自己的<code class="codeph">INSTEAD OF</code>触发器。使用多态视图，只能为视图上的给定操作定义一个<code class="codeph">INSTEAD OF</code>触发器。
                        </p>
                     </li>
                  </ul>
               </div>
            </div><a id="ADOBJ7493"></a><div class="props_rev_3"><a id="GUID-8F972C30-6642-4773-87FB-91E6FBA9F609" name="GUID-8F972C30-6642-4773-87FB-91E6FBA9F609"></a><h3 id="ADOBJ-GUID-8F972C30-6642-4773-87FB-91E6FBA9F609" class="sect3"><span class="enumeration_section">9.13.4</span> SQLJ对象类型</h3>
               <div>
                  <p>本节讨论SQLJ对象类型。</p>
                  <p>话题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="design-consideration-tips-and-techniques.html#GUID-CB1B4D5F-2CA8-46B5-8380-55637F1D3CB7">SQLJ对象类型的预期用途</a></p>
                     </li>
                     <li>
                        <p><a href="design-consideration-tips-and-techniques.html#GUID-FBA2205F-012E-46F2-B9E9-789E7B809368">创建SQLJ对象类型时执行的操作</a></p>
                     </li>
                     <li>
                        <p><a href="design-consideration-tips-and-techniques.html#GUID-3B333D83-D570-47B1-8A19-1C883F3B4B14">SQLJ对象类型的使用</a></p>
                     </li>
                     <li>
                        <p><a href="design-consideration-tips-and-techniques.html#GUID-C8208FDE-0B58-4925-9C57-CFE45B739D08">自定义对象类型的使用</a></p>
                     </li>
                     <li>
                        <p><a href="design-consideration-tips-and-techniques.html#GUID-99AFE923-D5F7-4858-A71C-DA2A373672AF">SQLJ和自定义对象类型之间的差异通过JDBC</a></p>
                     </li>
                  </ul>
               </div><a id="ADOBJ7494"></a><div class="props_rev_3"><a id="GUID-CB1B4D5F-2CA8-46B5-8380-55637F1D3CB7" name="GUID-CB1B4D5F-2CA8-46B5-8380-55637F1D3CB7"></a><h4 id="ADOBJ-GUID-CB1B4D5F-2CA8-46B5-8380-55637F1D3CB7" class="sect4"><span class="enumeration_section">9.13.4.1</span> SQLJ对象类型的预期用法</h4>
                  <div>
                     <p>根据<span class="italic">信息</span> <span class="italic">技术</span> <span class="italic">-</span> <span class="italic">SQLJ</span> <span class="italic">-</span> <span class="italic">第</span> <span class="italic">2</span> <span class="italic">部分</span>文件（SQLJ标准），一个SQLJ对象类型是专为Java的数据库的对象类型。一个<a id="d36969e560" class="indexterm-anchor"></a> SQLJ对象类型映射到Java类。通过扩展SQL <code class="codeph">CREATE TYPE</code>命令（DDL语句）注册映射后，Java应用程序可以通过Oracle JDBC驱动程序直接在数据库中插入或选择Java对象。这使用户可以通过SQL方法调度在客户端，JDBC和服务器中部署相同的类。
                     </p>
                  </div>
               </div><a id="ADOBJ7495"></a><div class="props_rev_3"><a id="GUID-FBA2205F-012E-46F2-B9E9-789E7B809368" name="GUID-FBA2205F-012E-46F2-B9E9-789E7B809368"></a><h4 id="ADOBJ-GUID-FBA2205F-012E-46F2-B9E9-789E7B809368" class="sect4"><span class="enumeration_section">9.13.4.2</span>创建SQLJ对象类型时执行的操作</h4>
                  <div>
                     <p>扩展的SQL <code class="codeph">CREATE TYPE</code>命令：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>使用属性，函数和Java类的外部名称填充数据库目录。此外，还保持Java类与其对应的SQLJ对象类型之间的依赖关系。</p>
                        </li>
                        <li>
                           <p>验证Java类的存在并验证它是否实现了与<code class="codeph">USING</code>子句的值相对应的接口。
                           </p>
                        </li>
                        <li>
                           <p>验证是否存在Java字段（在<code class="codeph">EXTERNAL NAME</code>子句中指定）以及这些字段是否与相应的SQL属性兼容。
                           </p>
                        </li>
                        <li>
                           <p>生成内部类以支持构造函数，外部变量名称以及返回<code class="codeph">self</code>外部函数。
                           </p>
                        </li>
                     </ul>
                  </div>
               </div><a id="ADOBJ7496"></a><div class="props_rev_3"><a id="GUID-3B333D83-D570-47B1-8A19-1C883F3B4B14" name="GUID-3B333D83-D570-47B1-8A19-1C883F3B4B14"></a><h4 id="ADOBJ-GUID-3B333D83-D570-47B1-8A19-1C883F3B4B14" class="sect4"><span class="enumeration_section">9.13.4.3</span> SQLJ对象类型的使用</h4>
                  <div>
                     <p>SQLJ对象类型是SQL对象类型的特例，其中所有方法都在Java类中实现。</p>
                     <p>Java类及其对应的SQL类型之间的映射由SQLJ对象类型规范管理。也就是说，SQLJ对象类型规范不能具有相应的类型主体规范。</p>
                     <p>此外，SQLJ对象类型中的继承规则指定Java类层次结构与其对应的SQLJ对象类型层次结构之间的合法映射。这些规则确保SQLJ类型层次结构包含有效的映射。也就是说，SQLJ对象类型的超类型或子类型必须是另一种SQLJ对象类型。</p>
                  </div>
               </div><a id="ADOBJ7497"></a><div class="props_rev_3"><a id="GUID-C8208FDE-0B58-4925-9C57-CFE45B739D08" name="GUID-C8208FDE-0B58-4925-9C57-CFE45B739D08"></a><h4 id="ADOBJ-GUID-C8208FDE-0B58-4925-9C57-CFE45B739D08" class="sect4"><span class="enumeration_section">9.13.4.4</span>自定义对象类型的使用</h4>
                  <div>
                     <p>自定义对象类型是用于访问SQL对象类型的Java接口。SQL对象类型可以包括以诸如PLSQL，Java和C之类的语言实现的方法。在给定SQL对象类型中以Java实现的方法可以属于不同的不相关类。也就是说，SQL对象类型不映射到特定的Java类。</p>
                     <p>为了使客户端能够访问这些对象，可以使用Oracle JVM Web服务调用实用程序生成相应的Java类。此外，用户必须使用相应方法的代码来扩充生成的类。或者，用户可以创建与SQL对象类型对应的类。</p>
                     <p>在运行时，JDBC用户必须在映射中注册SQL Type名称与其对应的Java类之间的对应关系。</p>
                     <div class="infoboxnotealso" id="GUID-C8208FDE-0B58-4925-9C57-CFE45B739D08__GUID-857E64BC-F158-4B72-B3E0-72514A338F67">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="../jjdev/database-as-web-service-consumer.html#JJDEV-GUID-9B020D6B-71C6-4E93-8A3B-D04D27B0A0F8" target="_blank"><span><cite>Oracle数据库Java开发人员指南</cite></span></a></p>
                     </div>
                  </div>
               </div><a id="ADOBJ7499"></a><a id="ADOBJ7498"></a><div class="props_rev_3"><a id="GUID-99AFE923-D5F7-4858-A71C-DA2A373672AF" name="GUID-99AFE923-D5F7-4858-A71C-DA2A373672AF"></a><h4 id="ADOBJ-GUID-99AFE923-D5F7-4858-A71C-DA2A373672AF" class="sect4"><span class="enumeration_section">9.13.4.5</span>通过JDBC在SQLJ和自定义对象类型之间的差异</h4>
                  <div>
                     <p>下表总结了SQLJ对象类型和自定义对象类型之间的差异。</p>
                     <div class="tblformalwide" id="GUID-99AFE923-D5F7-4858-A71C-DA2A373672AF__GUID-05C93FB8-6E03-4DBB-ACA5-B078AFF56BCD">
                        <p class="titleintable">表9-1 SQLJ和自定义对象类型之间的差异</p>
                        <table cellpadding="4" cellspacing="0" class="FormalWide" title="SQLJ和自定义对象类型之间的差异" width="100%" border="1" summary="Differences between SQLJ and custom object types" frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="16%" id="d36969e823">特征</th>
                                 <th align="left" valign="bottom" width="43%" id="d36969e826">SQLJ对象类型行为</th>
                                 <th align="left" valign="bottom" width="41%" id="d36969e829">自定义对象类型行为</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="16%" id="d36969e834" headers="d36969e823 ">
                                    <p>的TypeCodes</p>
                                 </td>
                                 <td align="left" valign="top" width="43%" headers="d36969e834 d36969e826 ">
                                    <p>使用<code class="codeph">OracleTypes.JAVA_STRUCT</code>类型代码将SQLJ对象类型注册为SQL <code class="codeph">OUT</code>参数。<code class="codeph">OracleTypes.JAVA_STRUCT</code>类型代码也用于实现<code class="codeph">ORAData</code>或<code class="codeph">SQLData</code>接口的类的<code class="codeph">_SQL_TYPECODE</code>字段中。
                                    </p>
                                 </td>
                                 <td align="left" valign="top" width="41%" headers="d36969e834 d36969e829 ">
                                    <p>使用<code class="codeph">OracleTypes.STRUCT</code>类型代码将自定义对象类型注册为SQL <code class="codeph">OUT</code>参数。<code class="codeph">OracleTypes.STRUCT</code>类型代码也用于实现<code class="codeph">ORAData</code>或<code class="codeph">SQLData</code>接口的类的<code class="codeph">_SQL_TYPECODE</code>字段中。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="16%" id="d36969e882" headers="d36969e823 ">
                                    <p>创建</p>
                                 </td>
                                 <td align="left" valign="top" width="43%" headers="d36969e882 d36969e826 ">
                                    <p>首先创建一个实现<code class="codeph">SQLData</code>或<code class="codeph">ORAData</code>和<code class="codeph">ORADataFactory</code>接口的Java类，然后将Java类加载到数据库中。接下来，为SQLJ对象类型发出扩展SQL <code class="codeph">CREATE TYPE</code>命令。
                                    </p>
                                 </td>
                                 <td align="left" valign="top" width="41%" headers="d36969e882 d36969e829 ">
                                    <p>为自定义对象类型发出扩展SQL <code class="codeph">CREATE TYPE</code>命令，然后使用Oracle JVM Web服务调用实用程序创建<code class="codeph">SQLData</code>或<code class="codeph">ORAData</code> Java包装器类，或手动执行此操作。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="16%" id="d36969e913" headers="d36969e823 ">
                                    <p>方法支持</p>
                                 </td>
                                 <td align="left" valign="top" width="43%" headers="d36969e913 d36969e826 ">
                                    <p>支持外部名称，构造函数调用以及具有副作用的成员函数调用。</p>
                                 </td>
                                 <td align="left" valign="top" width="41%" headers="d36969e913 d36969e829 ">
                                    <p>没有用于将类型方法实现为Java方法的默认类。某些方法也可以在SQL中实现。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="16%" id="d36969e923" headers="d36969e823 ">
                                    <p>类型映射</p>
                                 </td>
                                 <td align="left" valign="top" width="43%" headers="d36969e923 d36969e826 ">
                                    <p>类型映射由扩展SQL <code class="codeph">CREATE TYPE</code>命令自动完成。但是，SQLJ对象类型必须在客户端上具有定义的Java类。
                                    </p>
                                 </td>
                                 <td align="left" valign="top" width="41%" headers="d36969e923 d36969e829 ">
                                    <p>在类型映射中注册SQL和Java之间的对应关系。否则，该类型实现为<code class="codeph">oracle.sql.STRUCT</code> 。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="16%" id="d36969e939" headers="d36969e823 ">
                                    <p>遗产</p>
                                 </td>
                                 <td align="left" valign="top" width="43%" headers="d36969e939 d36969e826 ">
                                    <p>有将SQL层次结构映射到Java类层次结构的规则。有关这些规则的完整说明，请参见<a href="../sqlrf/Introduction-to-Oracle-SQL.html#SQLRF001" target="_blank"><span class="italic">Oracle数据库SQL语言参考</span></a> 。
                                    </p>
                                 </td>
                                 <td align="left" valign="top" width="41%" headers="d36969e939 d36969e829 ">
                                    <p>没有映射规则。</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                  </div>
               </div>
            </div><a id="ADOBJ7500"></a><div class="props_rev_3"><a id="GUID-429AA7D1-7FB8-47B5-ABE8-A9CAEAAE89B4" name="GUID-429AA7D1-7FB8-47B5-ABE8-A9CAEAAE89B4"></a><h3 id="ADOBJ-GUID-429AA7D1-7FB8-47B5-ABE8-A9CAEAAE89B4" class="sect3"><span class="enumeration_section">9.13.5</span>杂项设计技巧</h3>
               <div>
                  <p>您应该了解使用Oracle对象进行设计的各种技巧。</p>
               </div><a id="ADOBJ7501"></a><div class="props_rev_3"><a id="GUID-0996A08B-05B1-4736-ABF9-F1C008771F89" name="GUID-0996A08B-05B1-4736-ABF9-F1C008771F89"></a><h4 id="ADOBJ-GUID-0996A08B-05B1-4736-ABF9-F1C008771F89" class="sect4"><span class="enumeration_section">9.13.5.1</span>列可替代性和层次结构中的属性数</h4>
                  <div>
                     <p>如果列或表的类型为<code class="codeph">T</code> ，甲骨文增加了一个隐藏的列类型的每个属性<code class="codeph">T</code> ，并且如果列或表是可取代的，对于每一个亚型的每个属性<code class="codeph">T</code> ，存储属性数据。还添加了隐藏的<code class="codeph">typeid</code>列，以跟踪行中对象实例的类型。
                     </p>
                     <p>表中的列数限制为1,000。当总属性数接近1,000时，类型层次结构使您在层次结构中使用类型的可替换列时可能会遇到此限制。为避免此类问题，请考虑以下选项之一来处理具有大量总属性的层次结构：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>使用视图</p>
                        </li>
                        <li>
                           <p>使用<code class="codeph">REF</code></p>
                        </li>
                        <li>
                           <p>分解层次结构</p>
                        </li>
                     </ul>
                  </div>
               </div><a id="ADOBJ7502"></a><div class="props_rev_3"><a id="GUID-0016E25F-6272-4862-BE85-B49E519CF067" name="GUID-0016E25F-6272-4862-BE85-B49E519CF067"></a><h4 id="ADOBJ-GUID-0016E25F-6272-4862-BE85-B49E519CF067" class="sect4"><span class="enumeration_section">9.13.5.2</span>类型<span class="enumeration_section">间的</span>循环依赖性</h4>
                  <div>
                     <p>避免在类型之间创建循环依赖关系。换句话说，不要创建类型为<code class="codeph">T</code>的方法返回类型<code class="codeph">T1</code> ，类型<code class="codeph">T1</code>具有返回类型<code class="codeph">T</code> 。</p>
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>