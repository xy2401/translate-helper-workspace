<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <title>高级设计考虑因素</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Database SecureFiles and Large Objects Developer&#39;s Guide"></meta>
      <meta property="og:description" content=""></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Database SecureFiles and Large Objects Developer&#39;s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="securefiles-and-large-objects-developers-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-02-12T02:58:18-08:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="1996, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96333-01"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="LOB-storage-with-applications.html" title="Previous" type="text/html"></link>
      <link rel="next" href="performance-guidelines.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="SecureFiles and Large Objects Developer&#39;s Guide"></meta>
    <meta name="dcterms.isVersionOf" content="ADLOB"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="LOB-storage-with-applications.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="performance-guidelines.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">Database SecureFiles和Large Objects Developer's Guide</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="application-design-with-LOBs.html" property="item" typeof="WebPage"><span property="name">LOB的应用程序设计</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">高级设计考虑因素</li>
            </ol>
            <a id="GUID-1153755A-C4F4-4462-B592-6EE520F1C6A7" name="GUID-1153755A-C4F4-4462-B592-6EE520F1C6A7"></a><a id="ADLOB45318"></a>
            
            <h2 id="ADLOB-GUID-1153755A-C4F4-4462-B592-6EE520F1C6A7" class="sect2"><span class="enumeration_chapter">14</span>高级设计注意事项</h2>
         </header>
         <div class="ind">
            <div>
               <p>更高级的应用程序开发问题有设计考虑因素。</p>
               <p>Topicss：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="advanced-design-considerations.html#GUID-B161D891-886D-4D53-89F0-BB42BD22C102">使用OPEN和CLOSE接口打开持久LOB</a></p>
                  </li>
                  <li>
                     <p><a href="advanced-design-considerations.html#GUID-B1E476A2-F3FE-4D13-BC2B-FFB809698ED3">Read-Consistent Locators</a></p>
                  </li>
                  <li>
                     <p><a href="advanced-design-considerations.html#GUID-4DDA92CE-8C94-4DD1-9BA3-C6FC5ED7CAE0">LOB定位器和事务边界</a></p>
                  </li>
                  <li>
                     <p><a href="advanced-design-considerations.html#GUID-4AA63439-3BCD-41A8-98D0-40923BFE0309">对象缓存中的LOB</a></p>
                  </li>
                  <li>
                     <p><a href="advanced-design-considerations.html#GUID-FD6659DC-8792-4D7C-AC07-9EABEA02DF91">Terabyte-Size LOB支持</a></p>
                  </li>
                  <li>
                     <p><a href="advanced-design-considerations.html#GUID-B8E82069-4847-4116-9DA1-BFE6F99288C2">创建技嘉LOB的指南</a></p>
                  </li>
               </ul>
            </div><a id="ADLOB1002"></a><div class="props_rev_3"><a id="GUID-B161D891-886D-4D53-89F0-BB42BD22C102" name="GUID-B161D891-886D-4D53-89F0-BB42BD22C102"></a><h3 id="ADLOB-GUID-B161D891-886D-4D53-89F0-BB42BD22C102" class="sect3">使用OPEN和CLOSE接口打开持久LOB</h3>
               <div>
                  <div class="section">
                     <p><code class="codeph">OPEN</code>和<code class="codeph">CLOSE</code>接口使您可以显式打开持久LOB实例。
                     </p>
                     <p>使用<code class="codeph">OPEN</code>接口打开LOB实例时，实例将保持打开状态，直到使用<code class="codeph">CLOSE</code>接口显式关闭LOB。<code class="codeph">ISOPEN</code>接口使您可以确定持久性LOB是否已打开。
                     </p>
                     <p>请注意，LOB的打开状态与LOB实例相关联，而不是与LOB定位器相关联。定位器不保存任何指示它指向的LOB实例是否打开的信息。</p>
                     <div class="infoboxnotealso" id="GUID-B161D891-886D-4D53-89F0-BB42BD22C102__GUID-7D365222-2E5E-407D-A4AC-74958528C67B">
                        <p class="notep1">也可以看看：</p>
                        <p><span class="q">“ <a href="working-with-LOBs.html#GUID-20013E7E-EAAC-40C5-B190-20A759DBFF11" title="LOB API包括使您能够显式打开和关闭LOB实例的操作。">LOB打开和关闭操作0。</a> ”</span> 。
                        </p>
                     </div>
                     <p>话题：</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="advanced-design-considerations.html#GUID-156DDAB9-8B9A-461B-9194-A91987198ECF">明确打开LOB的索引性能优势</a></p>
                        </li>
                        <li>
                           <p><a href="advanced-design-considerations.html#GUID-16CB7CF0-C7E9-4D91-88E6-DD2C9FD49783">关闭显式打开的LOB实例</a></p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
               </div><a id="ADLOB45330"></a><div class="props_rev_3"><a id="GUID-156DDAB9-8B9A-461B-9194-A91987198ECF" name="GUID-156DDAB9-8B9A-461B-9194-A91987198ECF"></a><h4 id="ADLOB-GUID-156DDAB9-8B9A-461B-9194-A91987198ECF" class="sect4">明确打开LOB的索引性能优势</h4>
                  <div>
                     <p>显式打开LOB实例可以使索引列中的持久LOB的性能受益。</p>
                     <p>如果未显式打开LOB实例，则对LOB的每次修改都会隐式打开和关闭LOB实例。每次关闭LOB时都会触发域索引上的任何触发器。请注意，在这种情况下，只要对LOB实例进行任何修改，LOB上的任何域索引都会更新;域索引始终有效，可以随时使用。</p>
                     <p>显式打开LOB实例时，在显式关闭LOB之前，不会触发索引触发器。使用此技术可以通过消除不需要的索引事件来提高索引列的性能，直到您显式关闭LOB。请注意，在您明确关闭LOB之前，LOB列上的任何索引都无效。</p>
                  </div>
               </div><a id="ADLOB45331"></a><div class="props_rev_3"><a id="GUID-16CB7CF0-C7E9-4D91-88E6-DD2C9FD49783" name="GUID-16CB7CF0-C7E9-4D91-88E6-DD2C9FD49783"></a><h4 id="ADLOB-GUID-16CB7CF0-C7E9-4D91-88E6-DD2C9FD49783" class="sect4">关闭显式打开的LOB实例</h4>
                  <div>
                     <div class="section">
                        <p>如果显式打开LOB实例，则必须在提交事务之前关闭LOB。</p>
                        <p>在打开的LOB实例上提交事务会导致错误。发生此错误时，将隐式关闭LOB实例，保存对LOB实例的任何修改，并提交事务，但不更新LOB列上的任何索引。在这种情况下，您必须在LOB列上重建索引。</p>
                        <p>如果随后回滚事务，则LOB实例将回滚到其先前状态，但LOB实例不再显式打开。</p>
                        <p>您必须关闭显式打开的任何LOB实例：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p>在启动事务的DML语句之间，包括<code class="codeph">SELECT</code> ...<code class="codeph">FOR</code> <code class="codeph">UPDATE</code>和<code class="codeph">COMMIT</code> 
                              </p>
                           </li>
                           <li>
                              <p>在自治事务块内</p>
                           </li>
                           <li>
                              <p>在会话结束之前（当没有涉及交易时）</p>
                              <p>如果未显式关闭LOB实例，则会在会话结束时隐式关闭它，并且不会触发索引触发器。</p>
                           </li>
                        </ul>
                        <p>跟踪您明确打开的LOB的打开或关闭状态。以下操作会导致错误：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>显式打开之前已明确打开的LOB实例。</p>
                           </li>
                           <li>
                              <p>显式关闭之前已明确关闭的LOB实例。</p>
                           </li>
                        </ul>
                        <p>无论是使用相同的定位器还是使用不同的定位器访问LOB实例，都会发生这种情况。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="ADLOB45332"></a><div class="props_rev_3"><a id="GUID-B1E476A2-F3FE-4D13-BC2B-FFB809698ED3" name="GUID-B1E476A2-F3FE-4D13-BC2B-FFB809698ED3"></a><h3 id="ADLOB-GUID-B1E476A2-F3FE-4D13-BC2B-FFB809698ED3" class="sect3">Read-Consistent Locators</h3>
               <div>
                  <p>Oracle数据库为LOB提供与所有其他数据库读取和标量数量更新相同的读取一致性机制。</p>
                  <p>读取一致性对LOB定位器有一些特殊的应用，您必须了解它们。以下部分讨论了读一致性，并包含了应该相互关联的示例。</p>
                  <div class="infoboxnotealso" id="GUID-B1E476A2-F3FE-4D13-BC2B-FFB809698ED3__NOTE-134-DFDE2884">
                     <p class="notep1">也可以看看：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>有关读一致性的一般信息，请参阅<a href="../cncpt/data-concurrency-and-consistency.html#CNCPT221" target="_blank"><span><cite>Oracle数据库</cite></span></a>概</p>
                        </li>
                        <li>
                           <p><a href="working-with-LOBs.html#GUID-D71F0CBE-0717-41A2-BCD4-71E1DDF895D1" title="许多Oracle LOB示例使用Oracle Database Sample Schema PM的print_media表。">LOB示例表：PM Schema print_media表</a></p>
                        </li>
                     </ul>
                  </div>
                  <p>话题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="advanced-design-considerations.html#GUID-34EC32F1-51A9-4E72-ADDC-AA5B3D5E4BBC">选定的定位器成为一致的定位器</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-design-considerations.html#GUID-0320FCED-13FE-4F6F-A68B-8A275F224780">更新LOB和读一致性的示例</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-design-considerations.html#GUID-9E8A72FB-D1A7-4151-B184-BB1FEC850BBD">通过更新的定位器更新LOB的示例</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-design-considerations.html#GUID-A67D2857-7F83-4BCC-BF43-A0BA9C5EF9A0">使用SQL DML和DBMS_LOB更新LOB的示例</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-design-considerations.html#GUID-58DED834-DFEB-4ED2-B24C-D1C0634F6A39">使用一个定位器更新相同LOB值的示例</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-design-considerations.html#GUID-348E9FD8-2C50-4172-81B0-8BCC0D23144D">使用PL / SQL（DBMS_LOB）绑定变量更新LOB的示例</a></p>
                     </li>
                  </ul>
               </div><a id="ADLOB45333"></a><div class="props_rev_3"><a id="GUID-34EC32F1-51A9-4E72-ADDC-AA5B3D5E4BBC" name="GUID-34EC32F1-51A9-4E72-ADDC-AA5B3D5E4BBC"></a><h4 id="ADLOB-GUID-34EC32F1-51A9-4E72-ADDC-AA5B3D5E4BBC" class="sect4">选定的定位器成为一致的定位器</h4>
                  <div>
                     <p><a id="d80928e567" class="indexterm-anchor"></a><a id="d80928e571" class="indexterm-anchor"></a><a id="d80928e575" class="indexterm-anchor"></a><a id="d80928e579" class="indexterm-anchor"></a><a id="d80928e583" class="indexterm-anchor"></a><a id="d80928e587" class="indexterm-anchor"></a>无论是否存在<code class="codeph">FOR</code> <code class="codeph">UPDATE</code>子句，所选定位器都将成为<span class="italic">读取一致定位器，</span>并且在LOB值为<a id="d80928e602" class="indexterm-anchor"></a><a id="d80928e606" class="indexterm-anchor"></a>通过该定位器更新。
                     </p>
                     <p>读取一致定位器包含<code class="codeph">SELECT</code>操作的时间点的快照环境。
                     </p>
                     <p>这有一些复杂的含义。假设您已通过<code class="codeph">SELECT</code>操作创建了读一致定位器（ <code class="codeph">L1</code> ）。在通过<code class="codeph">L1</code>读取持久性LOB的值时，请注意以下事项：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>该LOB被读取作为时间点的<code class="codeph">SELECT</code> ，即使语句<code class="codeph">SELECT</code>语句包含<code class="codeph">FOR</code> <code class="codeph">UPDATE</code> 。</p>
                        </li>
                        <li>
                           <p>如果通过同一事务中的不同定位符（ <code class="codeph">L2</code> ）更新LOB值，则<code class="codeph">L1</code>不会看到<code class="codeph">L2</code>更新。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">L1</code>没有看到通过另一个事务对LOB进行的提交更新。
                           </p>
                        </li>
                        <li>
                           <p>如果<a id="d80928e663" class="indexterm-anchor"></a><a id="d80928e665" class="indexterm-anchor"></a>读取一致定位器<code class="codeph">L1</code>被复制到另一个定位器<code class="codeph">L2</code> （例如，通过两个定位器变量的PL / SQL分配<code class="codeph">L2:= L1</code> ），然后<code class="codeph">L2</code>与<code class="codeph">L1</code>一起成为读取一致定位器，并且任何读取的数据都被读取为<code class="codeph">SELECT</code>的<code class="codeph">L1</code>时间点。
                           </p>
                        </li>
                     </ul>
                     <p>你可以使用它的存在<a id="d80928e694" class="indexterm-anchor"></a>多个定位器，用于访问LOB值的不同转换。但是，在执行此操作时，您必须跟踪不同定位器访问的不同值。
                     </p>
                  </div>
               </div><a id="ADLOB45334"></a><div class="props_rev_3"><a id="GUID-0320FCED-13FE-4F6F-A68B-8A275F224780" name="GUID-0320FCED-13FE-4F6F-A68B-8A275F224780"></a><h4 id="ADLOB-GUID-0320FCED-13FE-4F6F-A68B-8A275F224780" class="sect4">更新LOB和读一致性的示例</h4>
                  <div>
                     <p>无论何时发生<code class="codeph">SELECT</code>读取一致定位器都提供相同的LOB值。
                     </p>
                     <p>以下示例演示了简单示例中读取一致性和更新之间的关系。使用<code class="codeph">print_media</code>中描述表<span class="q">“ <a href="working-with-LOBs.html#GUID-D71F0CBE-0717-41A2-BCD4-71E1DDF895D1" title="许多Oracle LOB示例使用Oracle Database Sample Schema PM的print_media表。">表对于LOB实施例：PM模式print_media表</a> ”</span>和PL / SQL，三个<code class="codeph">CLOB</code> ：实例作为潜在的定位器创建<code class="codeph">clob_selected</code> ， <code class="codeph">clob_update</code> ，和<code class="codeph">clob_copied</code> 。
                     </p>
                     <p>从时间<code class="codeph">t1</code>到<code class="codeph">t6</code> ，观察代码中的这些进度：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>在第一个<code class="codeph">SELECT</code> <code class="codeph">INTO</code> （在<code class="codeph">t1</code> ）时， <code class="codeph">ad_sourcetext</code>的值<span class="italic"> </span>与定位符<code class="codeph">clob_selected</code>相关联<span class="italic">。</span> 
                           </p>
                        </li>
                        <li>
                           <p>在第二个操作（在<code class="codeph">t2</code> ）， <code class="codeph">ad_sourcetext</code>的值<span class="italic"> </span>与定位器<code class="codeph">clob_updated</code>相关联<span class="italic">。</span> 因为<code class="codeph">ad_sourcetext</code>的值没有变化<span class="italic"> </span>在<code class="codeph">t1</code>和<code class="codeph">t2</code>之间， <code class="codeph">clob_selected</code>和<code class="codeph">clob_updated</code>都是读取一致的定位器，它们实际上具有相同的值，即使它们反映了在不同时刻拍摄的快照。
                           </p>
                        </li>
                        <li>
                           <p>第三个操作（在<code class="codeph">t3</code> ）将<code class="codeph">clob_copied</code>的值<code class="codeph">clob_selected</code>到<code class="codeph">clob_copied</code> 。此时，所有三个定位器都看到相同的值。该示例使用一系列<code class="codeph">DBMS_LOB</code>演示了这一点。 <code class="codeph">READ()</code>调用。
                           </p>
                        </li>
                        <li>
                           <p>在时间<code class="codeph">t4</code> ，程序使用<code class="codeph">DBMS_LOB</code> 。 <code class="codeph">WRITE()</code>改变<code class="codeph">clob_updated</code>的值，以及<code class="codeph">DBMS_LOB</code> 。 <code class="codeph">READ()</code>显示一个新值。
                           </p>
                        </li>
                        <li>
                           <p>但是，一个<code class="codeph">DBMS_LOB</code> 。通过<code class="codeph">clob_selected</code> （在<code class="codeph">t5</code> ）读取值的<code class="codeph">READ()</code>表明它是一个读取一致的定位器，继续引用与其<code class="codeph">SELECT</code>时间相同的值。</p>
                        </li>
                        <li>
                           <p>同样， <code class="codeph">DBMS_LOB</code> 。通过<code class="codeph">clob_copied</code> （在<code class="codeph">t6</code> ）读取值的<code class="codeph">READ()</code>表明它是一个读取一致的定位器，继续引用与<code class="codeph">clob_selected</code>相同的值。
                           </p>
                        </li>
                     </ul>
                     <div class="example" id="GUID-0320FCED-13FE-4F6F-A68B-8A275F224780__GUID-8E9FDC39-B5CE-4D31-8770-A7471CC2113E">
                        <p class="titleinexample">例14-1</p><pre class="oac_no_warn" dir="ltr">INSERT INTO PRINT_MEDIA VALUES（2056,20020，EMPTY_BLOB（），'abcd'，EMPTY_CLOB（），EMPTY_CLOB（），NULL，NULL，NULL，NULL）;承诺; DECLARE num_var INTEGER; clob_selected CLOB; clob_updated CLOB; clob_copied CLOB; read_amount INTEGER; read_offset INTEGER; write_amount INTEGER; write_offset INTEGER; buffer VARCHAR2（20）; BEGIN  - 在时间t1：SELECT ad_sourcetext INTO clob_selected FROM Print_media WHERE ad_id = 20020; - 在时间t2：SELECT ad_sourcetext INTO clob_updated FROM Print_media WHERE ad_id = 20020 FOR UPDATE; - 在时间t3：clob_copied：= clob_selected; - 赋值后，clob_copied和-clob_selected都具有与时间点相同的快照 -  SELECT到clob_selected  - 从clob_selected读取而clob_copied确实 - 返回相同的LOB值。 clob_updated也看到了相同的LOB值：read_amount：= 10; read_offset：= 1; dbms_lob.read（clob_selected，read_amount，read_offset，buffer）; dbms_output.put_line（'clob_selected value：'|| buffer）; - 产生输出'abcd'read_amount：= 10; dbms_lob.read（clob_copied，read_amount，read_offset，buffer）; dbms_output.put_line（'clob_copied value：'|| buffer）; - 产生输出'abcd'read_amount：= 10; dbms_lob.read（clob_updated，read_amount，read_offset，buffer）; dbms_output.put_line（'clob_updated value：'|| buffer）; - 产生输出'abcd' - 在时间t4：write_amount：= 3; write_offset：= 5; buffer：='efg'; dbms_lob.write（clob_updated，write_amount，write_offset，buffer）; read_amount：= 10; dbms_lob.read（clob_updated，read_amount，read_offset，buffer）; dbms_output.put_line（'clob_updated value：'|| buffer）; - 产生输出'abcdefg' - 在时间t5：read_amount：= 10; dbms_lob.read（clob_selected，read_amount，read_offset，buffer）; dbms_output.put_line（'clob_selected value：'|| buffer）; - 产生输出'abcd' - 在时间t6：read_amount：= 10; dbms_lob.read（clob_copied，read_amount，read_offset，buffer）; dbms_output.put_line（'clob_copied value：'|| buffer）; - 产生输出'abcd'END; /</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="ADLOB45335"></a><div class="props_rev_3"><a id="GUID-9E8A72FB-D1A7-4151-B184-BB1FEC850BBD" name="GUID-9E8A72FB-D1A7-4151-B184-BB1FEC850BBD"></a><h4 id="ADLOB-GUID-9E8A72FB-D1A7-4151-B184-BB1FEC850BBD" class="sect4">通过更新的定位器更新LOB的示例</h4>
                  <div>
                     <p> <a id="d80928e1017" class="indexterm-anchor"></a>通过LOB定位器（ <code class="codeph">L1</code> ）更新持久性LOB的值时， <code class="codeph">L1</code>将更新为包含当前快照环境。
                     </p>
                     <p>此快照是在通过定位器<code class="codeph">L1</code>对LOB值完成操作之后的时间。然后将<code class="codeph">L1</code>称为更新的定位器。此操作使您可以<span class="italic"> </span>在下一次读取同一个定位器<code class="codeph">L1</code> ，看到你自己对LOB值的更改。
                     </p>
                     <div class="infoboxnote" id="GUID-9E8A72FB-D1A7-4151-B184-BB1FEC850BBD__GUID-752D9A48-DEAE-43FE-89E3-C7A3E91C0D5A">
                        <p class="notep1">注意：</p>
                        <p>如果定位器仅用于读取LOB值，则<span class="italic">不会</span>更新定位器中的快照环境。只有在使用PL / SQL <code class="codeph">DBMS_LOB</code>包或OCI LOB API通过定位器修改LOB值时，才会更新它。</p>
                     </div>
                     <p>只有当您的事务是读取提交事务并且在提交另一个事务之后使用L1更新LOB值时，L1才会看到由不同事务所做的任何已提交更新。</p>
                     <div class="infoboxnote" id="GUID-9E8A72FB-D1A7-4151-B184-BB1FEC850BBD__GUID-F5B165F6-9804-478E-B238-8A09441E318D">
                        <p class="notep1">注意：</p>
                        <p>更新持久性LOB值时，始终会对最新的LOB值进行修改。</p>
                     </div>
                     <p>通过任何可用方法（如OCI LOB API或PL / SQL <code class="codeph">DBMS_LOB</code>包）更新持久性LOB的值，更新LOB值<span class="italic">，然后重新选择</span>引用新LOB值的定位器。
                     </p>
                     <div class="infoboxnote" id="GUID-9E8A72FB-D1A7-4151-B184-BB1FEC850BBD__GUID-8AF165C7-9268-4D1A-B1ED-A4D2A3D4BBA3">
                        <p class="notep1">注意：</p>
                        <p>一旦您通过任何方式选择了LOB定位器，您就可以从定位器读取但不能写入它。</p>
                        <p>请注意，通过SQL更新LOB值只是一个<code class="codeph">UPDATE</code>语句。您可以重新选择LOB定位器或在<code class="codeph">UPDATE</code>语句中使用<code class="codeph">RETURNING</code>子句，以便定位器可以查看<code class="codeph">UPDATE</code>语句所做的更改。除非您重新选择LOB定位器或使用<code class="codeph">RETURNING</code>子句，否则在不是这种情况时您可能会认为正在读取最新值。因此，您应该避免将SQL DML与<code class="codeph">OCI</code>和<code class="codeph">DBMS_LOB</code>混合使用<a id="d80928e1091" class="indexterm-anchor"></a>分段操作。
                        </p>
                     </div>
                     <div class="infoboxnotealso" id="GUID-9E8A72FB-D1A7-4151-B184-BB1FEC850BBD__GUID-673A1EC2-9B4A-4212-805C-A07C62B163A7">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="../lnpls/overview.html#LNPLS-GUID-2FBCFBBE-6B42-4DB8-83F3-55B63B75B1EB" target="_blank"><span><cite>Oracle数据库PL / SQL语言参考</cite></span></a></p>
                     </div>
                  </div>
               </div><a id="ADLOB45336"></a><div class="props_rev_3"><a id="GUID-A67D2857-7F83-4BCC-BF43-A0BA9C5EF9A0" name="GUID-A67D2857-7F83-4BCC-BF43-A0BA9C5EF9A0"></a><h4 id="ADLOB-GUID-A67D2857-7F83-4BCC-BF43-A0BA9C5EF9A0" class="sect4">使用SQL DML和DBMS_LOB更新LOB的示例</h4>
                  <div>
                     <p>使用以下示例中的<code class="codeph">Print_media</code>表，将<code class="codeph">CLOB</code>定位器创建为<code class="codeph">clob_selected</code> 。请注意示例中的以下进度，从时间<code class="codeph">t1</code>到<code class="codeph">t3</code> ：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>在第一个<code class="codeph">SELECT</code> <code class="codeph">INTO</code> （在<code class="codeph">t1</code> ）时， <code class="codeph">ad_sourcetext</code>的值与定位符<code class="codeph">clob_selected</code>相关联。
                           </p>
                        </li>
                        <li>
                           <p>在第二个操作中（在<code class="codeph">t2</code> ），通过<code class="codeph">SQL</code> <code class="codeph">UPDATE</code>语句修改<code class="codeph">ad_sourcetext</code>的值，而不影响<code class="codeph">clob_selected</code>定位器。定位器仍然看到原始<code class="codeph">SELECT</code>时间点的LOB值。换句话说，定位器看不到使用SQL <code class="codeph">UPDATE</code>语句进行的<code class="codeph">UPDATE</code> 。后续<code class="codeph">DBMS_LOB</code>说明了这一点。 <code class="codeph">READ()</code>调用。
                           </p>
                        </li>
                        <li>
                           <p>第三个操作（在<code class="codeph">t3</code> ）重新选择LOB值到定位符<code class="codeph">clob_selected</code> 。因此，使用最新的快照环境更新定位器，该环境允许定位器查看先前SQL <code class="codeph">UPDATE</code>语句所做的更改。因此，在下一个<code class="codeph">DBMS_LOB</code> 。 <code class="codeph">READ()</code> ，返回错误，因为LOB值为空，即它不包含任何数据。
                           </p>
                        </li>
                     </ul><pre class="oac_no_warn" dir="ltr">INSERT INTO Print_media VALUES（3247,20010，EMPTY_BLOB（），'abcd'，EMPTY_CLOB（），EMPTY_CLOB（），NULL，NULL，NULL，NULL）;承诺; DECLARE num_var INTEGER; clob_selected CLOB; read_amount INTEGER; read_offset INTEGER; buffer VARCHAR2（20）; BEGIN  - 在时间t1：SELECT ad_sourcetext INTO clob_selected FROM Print_media WHERE ad_id = 20010; read_amount：= 10; read_offset：= 1; dbms_lob.read（clob_selected，read_amount，read_offset，buffer）; dbms_output.put_line（'clob_selected value：'|| buffer）; - 产生输出'abcd' - 在时间t2：UPDATE Print_media SET ad_sourcetext = empty_clob（）WHERE ad_id = 20010; - 尽管最新的LOB值现在为空，但是clob_selected仍然看到LOB值为SELECT read_amount的时间点：= 10; dbms_lob.read（clob_selected，read_amount，read_offset，buffer）; dbms_output.put_line（'clob_selected value：'|| buffer）; - 产生输出'abcd' - 在时间t3：SELECT ad_sourcetext INTO clob_selected FROM Print_media WHERE ad_id = 20010; -  SELECT允许clob_selected看到最新的 -  LOB值read_amount：= 10; dbms_lob.read（clob_selected，read_amount，read_offset，buffer）; - 错误：ORA-01403：未找到数据END; /</pre></div>
               </div><a id="ADLOB45337"></a><div class="props_rev_3"><a id="GUID-58DED834-DFEB-4ED2-B24C-D1C0634F6A39" name="GUID-58DED834-DFEB-4ED2-B24C-D1C0634F6A39"></a><h4 id="ADLOB-GUID-58DED834-DFEB-4ED2-B24C-D1C0634F6A39" class="sect4">使用一个定位器更新相同LOB值的示例</h4>
                  <div>
                     <div class="infoboxnote" id="GUID-58DED834-DFEB-4ED2-B24C-D1C0634F6A39__GUID-D926ECC0-DEF7-49B0-B23E-E4022CE5EACF">
                        <p class="notep1">注意：</p>
                        <p>避免<a id="d80928e1337" class="indexterm-anchor"></a>使用不同的定位器更新相同的LOB。如果仅使用一个定位器来更新给定的LOB值，则可以避免许多陷阱。
                        </p>
                     </div>
                     <p>在以下示例中，使用表<code class="codeph">Print_media</code> ，将两个<code class="codeph">CLOB</code>创建为潜在定位器：clob_updated和clob_copied。
                     </p>
                     <p>在时间t1到t5，请注意示例中的这些进度：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>在第一个<code class="codeph">SELECT</code> <code class="codeph">INTO</code> （在<code class="codeph">t1</code> ）时， <code class="codeph">ad_sourcetext</code>的值与定位符<code class="codeph">clob_updated</code>相关联。
                           </p>
                        </li>
                        <li>
                           <p>第二个操作（在时间<code class="codeph">t2</code> ）将<code class="codeph">clob_copied</code>的值<code class="codeph">clob_updated</code>到<code class="codeph">clob_copied</code> 。此时，两个定位器都看到相同的值。该示例使用一系列<code class="codeph">DBMS_LOB</code>演示了这一点。 <code class="codeph">READ()</code>调用。
                           </p>
                        </li>
                        <li>
                           <p>在时间<code class="codeph">t3</code> ，程序使用<code class="codeph">DBMS_LOB</code> 。 <code class="codeph">WRITE()</code>改变<code class="codeph">clob_updated</code>的值， <code class="codeph">DBMS_LOB.READ()</code>显示一个新值。
                           </p>
                        </li>
                        <li>
                           <p>但是，一个<code class="codeph">DBMS_LOB</code> 。通过<code class="codeph">clob_copied</code> （在时间<code class="codeph">t4</code> ）的值的<code class="codeph">READ()</code>显示它仍然看到从<code class="codeph">clob_updated</code> （在<code class="codeph">t2</code> ）分配的时间点的LOB的值。
                           </p>
                        </li>
                        <li>
                           <p>它不是直到<code class="codeph">clob_updated</code>被分配给<code class="codeph">clob_copied</code> （ <code class="codeph">t5</code> ），该<code class="codeph">clob_copied</code>看到所作出的修改<code class="codeph">clob_updated</code> 。
                           </p>
                        </li>
                     </ul><pre class="oac_no_warn" dir="ltr">INSERT INTO PRINT_MEDIA VALUES（2049,20030，EMPTY_BLOB（），'abcd'，EMPTY_CLOB（），EMPTY_CLOB（），NULL，NULL，NULL，NULL）;承诺; DECLARE num_var INTEGER; clob_updated CLOB; clob_copied CLOB; read_amount INTEGER; read_offset INTEGER; write_amount INTEGER; write_offset INTEGER; buffer VARCHAR2（20）; BEGIN  - 在时间t1：SELECT ad_sourcetext INTO clob_updated FROM PRINT_MEDIA WHERE ad_id = 20030 FOR UPDATE; - 在时间t2：clob_copied：= clob_updated; - 在赋值后，clob_copied和clob_updated看到相同的 -  LOB值read_amount：= 10; read_offset：= 1; dbms_lob.read（clob_updated，read_amount，read_offset，buffer）; dbms_output.put_line（'clob_updated value：'|| buffer）; - 产生输出'abcd'read_amount：= 10; dbms_lob.read（clob_copied，read_amount，read_offset，buffer）; dbms_output.put_line（'clob_copied value：'|| buffer）; - 产生输出'abcd' - 在时间t3：write_amount：= 3; write_offset：= 5; buffer：='efg'; dbms_lob.write（clob_updated，write_amount，write_offset，buffer）; read_amount：= 10; dbms_lob.read（clob_updated，read_amount，read_offset，buffer）; dbms_output.put_line（'clob_updated value：'|| buffer）; - 产生输出'abcdefg' - 在时间t4：read_amount：= 10; dbms_lob.read（clob_copied，read_amount，read_offset，buffer）; dbms_output.put_line（'clob_copied value：'|| buffer）; - 产生输出'abcd' - 在时间t5：clob_copied：= clob_updated; read_amount：= 10; dbms_lob.read（clob_copied，read_amount，read_offset，buffer）; dbms_output.put_line（'clob_copied value：'|| buffer）; - 产生输出'abcdefg'END; /</pre></div>
               </div><a id="ADLOB45338"></a><div class="props_rev_3"><a id="GUID-348E9FD8-2C50-4172-81B0-8BCC0D23144D" name="GUID-348E9FD8-2C50-4172-81B0-8BCC0D23144D"></a><h4 id="ADLOB-GUID-348E9FD8-2C50-4172-81B0-8BCC0D23144D" class="sect4">使用PL / SQL（DBMS_LOB）绑定变量更新LOB的示例</h4>
                  <div>
                     <p>当LOB定位器被用作源来更新另一个持久LOB（如在SQL <code class="codeph">INSERT</code>或<code class="codeph">UPDATE</code>语句时， <code class="codeph">DBMS_LOB</code> 。 <code class="codeph">COPY</code>例程，等等），在源LOB定位器快照环境确定用于所述LOB值作为来源。
                     </p>
                     <p>如果源定位器（例如<code class="codeph">L1</code> ）是a <a id="d80928e1551" class="indexterm-anchor"></a><a id="d80928e1553" class="indexterm-anchor"></a>读取一致定位器，然后使用截至<code class="codeph">L1</code>的<code class="codeph">SELECT</code>时的LOB值。如果源定位符（例如<code class="codeph">L2</code> ）是更新的定位符，则使用在操作时与<code class="codeph">L2</code>快照环境相关联的LOB值。
                     </p>
                     <p>在以下示例中，将创建三个<code class="codeph">CLOB</code>作为潜在定位器： <code class="codeph">clob_selected</code> ，clob_updated和clob_copied。
                     </p>
                     <p>在时间<code class="codeph">t1</code>到<code class="codeph">t5</code>请注意示例中的这些进度：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>在第一个<code class="codeph">SELECT</code> <code class="codeph">INTO</code> （在<code class="codeph">t1</code> ）时， <code class="codeph">ad_sourcetext</code>的值与定位符<code class="codeph">clob_updated</code>相关联。
                           </p>
                        </li>
                        <li>
                           <p>第二个操作（在<code class="codeph">t2</code> ）将<code class="codeph">clob_copied</code>的值<code class="codeph">clob_updated</code>到<code class="codeph">clob_copied</code> 。此时，两个定位器都看到相同的值。
                           </p>
                        </li>
                        <li>
                           <p>然后（在<code class="codeph">t3</code> ），程序使用<code class="codeph">DBMS_LOB</code> 。 <code class="codeph">WRITE()</code>改变<code class="codeph">clob_updated</code>的值<span class="italic">，</span>以及<code class="codeph">DBMS_LOB</code> 。 <code class="codeph">READ()</code>显示一个新值。
                           </p>
                        </li>
                        <li>
                           <p>但是，一个<code class="codeph">DBMS_LOB</code> 。 <code class="codeph">READ()</code>的价值通过<code class="codeph">clob_copied</code> （在<code class="codeph">t4</code> ）显示， <code class="codeph">clob_copied</code>没有看到所作出的改变<code class="codeph">clob_updated</code> 。
                           </p>
                        </li>
                        <li>
                           <p>因此（在<code class="codeph">t5</code> ），当<code class="codeph">clob_copied</code>被用作源的值<code class="codeph">INSERT</code>语句中，与相关联的值<code class="codeph">clob_copied</code> （例如，没有通过由新变化<code class="codeph">clob_updated</code> ）插入。随后的<code class="codeph">DBMS_LOB</code>演示了这一点。刚刚插入的值的<code class="codeph">READ()</code> 。
                           </p>
                        </li>
                     </ul><pre class="oac_no_warn" dir="ltr">INSERT INTO PRINT_MEDIA VALUES（2056,20020，EMPTY_BLOB（），'abcd'，EMPTY_CLOB（），EMPTY_CLOB（），NULL，NULL，NULL，NULL）;承诺; DECLARE num_var INTEGER; clob_selected CLOB; clob_updated CLOB; clob_copied CLOB; read_amount INTEGER; read_offset INTEGER; write_amount INTEGER; write_offset INTEGER; buffer VARCHAR2（20）; BEGIN  - 在时间t1：SELECT ad_sourcetext INTO clob_updated FROM PRINT_MEDIA WHERE ad_id = 20020 FOR UPDATE; read_amount：= 10; read_offset：= 1; dbms_lob.read（clob_updated，read_amount，read_offset，buffer）; dbms_output.put_line（'clob_updated value：'|| buffer）; - 产生输出'abcd' - 在时间t2：clob_copied：= clob_updated; - 在时间t3：write_amount：= 3; write_offset：= 5; buffer：='efg'; dbms_lob.write（clob_updated，write_amount，write_offset，buffer）; read_amount：= 10; dbms_lob.read（clob_updated，read_amount，read_offset，buffer）; dbms_output.put_line（'clob_updated value：'|| buffer）; - 产生输出'abcdefg' - 注意clob_copied看不到之前写的 -  clob_updated  - 在时间t4：read_amount：= 10; dbms_lob.read（clob_copied，read_amount，read_offset，buffer）; dbms_output.put_line（'clob_copied value：'|| buffer）; - 生成输出'abcd' - 在时间t5： - 插入使用clob_copied视图的LOB值 - 不包括clob_updated更改INSERT INTO PRINT_MEDIA VALUES（2056,20042，EMPTY_BLOB（），clob_copied，EMPTY_CLOB（ ），EMPTY_CLOB（），NULL，NULL，NULL，NULL）返回ad_sourcetext INTO clob_selected; read_amount：= 10; dbms_lob.read（clob_selected，read_amount，read_offset，buffer）; dbms_output.put_line（'clob_selected value：'|| buffer）; - 产生输出'abcd'END; /</pre></div>
               </div>
            </div><a id="ADLOB45339"></a><div class="props_rev_3"><a id="GUID-4DDA92CE-8C94-4DD1-9BA3-C6FC5ED7CAE0" name="GUID-4DDA92CE-8C94-4DD1-9BA3-C6FC5ED7CAE0"></a><h3 id="ADLOB-GUID-4DDA92CE-8C94-4DD1-9BA3-C6FC5ED7CAE0" class="sect3">LOB定位器和事务边界</h3>
               <div>
                  <p>LOB定位器可用于事务和事务ID。</p>
                  <div class="infoboxnotealso" id="GUID-4DDA92CE-8C94-4DD1-9BA3-C6FC5ED7CAE0__LOBLOCATORSANDBFILELOCATORSFORMOREI-DFDE82BC">
                     <p class="notep1">也可以看看：</p>
                     <p><a href="working-with-LOBs.html#GUID-747411EC-7E86-4756-A8DC-CE19923BF8A6" title="There are differences between the semantics of locators for the LOB types BLOB, CLOB, and NCLOB, and the semantics of locators for the BFILE type:">LOB定位器和BFILE定位器</a>有关LOB定位<a href="working-with-LOBs.html#GUID-747411EC-7E86-4756-A8DC-CE19923BF8A6" title="LOB类型BLOB，CLOB和NCLOB的定位符的语义与BFILE类型的定位符的语义之间存在差异：">器</a>的更多信息</p>
                  </div>
                  <p>话题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="advanced-design-considerations.html#GUID-C4E6C558-239B-474C-B587-31D8452EBAB1">关于LOB定位器和事务边界</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-design-considerations.html#GUID-F4B23AD1-2E5F-49ED-ABBE-10E6B109BE3E">使用定位器对LOB进行读写操作</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-design-considerations.html#GUID-1A6259F3-2F83-4AD5-B79F-0B0130D3608F">选择事务边界之外的定位器</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-design-considerations.html#GUID-5E2C762D-F4B4-4D03-AE92-0940671C21E3">选择事务边界内的定位器</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-design-considerations.html#GUID-0FFBCC15-1C19-4B48-A570-F6BF197BB2B8">LOB定位器无法跨越事务</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-design-considerations.html#GUID-F973C33A-EA4D-4B1B-A7EA-C258BE6B44A8">不跨越事务的定位器示例</a></p>
                     </li>
                  </ul>
               </div>
               <div class="props_rev_3"><a id="GUID-C4E6C558-239B-474C-B587-31D8452EBAB1" name="GUID-C4E6C558-239B-474C-B587-31D8452EBAB1"></a><h4 id="ADLOB-GUID-C4E6C558-239B-474C-B587-31D8452EBAB1" class="sect4">关于LOB定位器和事务边界</h4>
                  <div>
                     <p>请注意以下有关LOB定位器和事务的信息：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>定位器包含<a id="d80928e1886" class="indexterm-anchor"></a>交易ID时：</p>
                           <p>您开始事务，然后选择定位器：如果您开始事务并随后选择定位器，则定位器包含事务ID。请注意，您可以隐式地在事务中而不显式地开始一个事务。例如， <code class="codeph">SELECT</code> ...<code class="codeph">FOR</code> <code class="codeph">UPDATE</code>隐式开始一个事务。在这种情况下，定位器包含事务ID。</p>
                        </li>
                        <li>
                           <p>定位器不包含事务ID时......</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>您在交易之外，然后选择定位器： <span class="bold"> </span>相反，如果在事务外部选择定位器，则定位器不包含事务ID。</p>
                              </li>
                              <li>
                                 <p>在DML语句执行之前选择时：在第一个DML语句执行之前，不会分配事务ID。因此，在此类DML语句之前选择的定位器不包含事务ID。</p>
                              </li>
                           </ul>
                        </li>
                     </ul>
                  </div>
               </div><a id="ADLOB45340"></a><div class="props_rev_3"><a id="GUID-F4B23AD1-2E5F-49ED-ABBE-10E6B109BE3E" name="GUID-F4B23AD1-2E5F-49ED-ABBE-10E6B109BE3E"></a><h4 id="ADLOB-GUID-F4B23AD1-2E5F-49ED-ABBE-10E6B109BE3E" class="sect4">使用定位器对LOB进行读写操作</h4>
                  <div>
                     <p>无论定位器是否包含事务ID，您始终可以使用定位器读取LOB数据。</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>无法使用定位器编写：</p>
                           <p>如果定位器包含事务ID，则无法写入该特定事务之外的LOB。</p>
                        </li>
                        <li>
                           <p>可以使用定位器写：</p>
                           <p>如果定位器<span class="italic">不</span>包含事务ID，则可以在显式或隐式开始事务后写入LOB。
                           </p>
                        </li>
                        <li>
                           <p>使用可序列化的定位器无法读取或写入<a id="d80928e2004" class="indexterm-anchor"></a>交易方式：</p>
                           <p>如果定位器包含旧事务的事务ID，并且当前事务是可序列化的，则无法使用该定位器进行读取或写入。</p>
                        </li>
                        <li>
                           <p>可以读取，不使用不可序列化的定位器写入<a id="d80928e2014" class="indexterm-anchor"></a>交易方式：</p>
                           <p>如果事务是不可序列化的，那么您可以读取，但不能在该事务之外写入。</p>
                        </li>
                     </ul>
                     <p>示例<a href="advanced-design-considerations.html#GUID-1A6259F3-2F83-4AD5-B79F-0B0130D3608F">选择事务边界之外的定位器</a> ， <a href="advanced-design-considerations.html#GUID-5E2C762D-F4B4-4D03-AE92-0940671C21E3">选择</a> <a href="advanced-design-considerations.html#GUID-1A6259F3-2F83-4AD5-B79F-0B0130D3608F">事务边界</a> <a href="advanced-design-considerations.html#GUID-5E2C762D-F4B4-4D03-AE92-0940671C21E3">内的定位器</a> ， <a href="advanced-design-considerations.html#GUID-0FFBCC15-1C19-4B48-A570-F6BF197BB2B8">LOB定位器不能跨越事务</a> ，并且<a href="advanced-design-considerations.html#GUID-0FFBCC15-1C19-4B48-A570-F6BF197BB2B8">不跨越事务</a> <a href="advanced-design-considerations.html#GUID-F973C33A-EA4D-4B1B-A7EA-C258BE6B44A8">的定位器示例</a>显示定位器与<span class="italic">非可序列化</span>事务之间的关系</p>
                  </div>
               </div><a id="ADLOB45342"></a><a id="ADLOB45343"></a><a id="ADLOB45341"></a><div class="props_rev_3"><a id="GUID-1A6259F3-2F83-4AD5-B79F-0B0130D3608F" name="GUID-1A6259F3-2F83-4AD5-B79F-0B0130D3608F"></a><h4 id="ADLOB-GUID-1A6259F3-2F83-4AD5-B79F-0B0130D3608F" class="sect4">选择事务边界之外的定位器</h4>
                  <div>
                     <div class="section">
                        <p>两个场景描述了在事务外部选择定位器时在非可序列化事务中使用定位器的技术。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-1A6259F3-2F83-4AD5-B79F-0B0130D3608F__GUID-FD707175-9BA1-43D7-9D2B-33C70E3C3545">第一种情景：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ol>
                           <li>
                              <p>选择没有当前事务的定位器。此时，定位器不包含事务ID。</p>
                           </li>
                           <li>
                              <p>开始交易。</p>
                           </li>
                           <li>
                              <p>使用定位器从LOB读取数据。</p>
                           </li>
                           <li>
                              <p>提交或回滚事务。</p>
                           </li>
                           <li>
                              <p>使用定位器从LOB读取数据。</p>
                           </li>
                           <li>
                              <p>开始交易。定位器不包含事务ID。</p>
                           </li>
                           <li>
                              <p>使用定位器将数据写入LOB。此操作有效，因为定位器在写入之前不包含事务ID。在此调用之后，定位器包含事务ID。</p>
                           </li>
                        </ol>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-1A6259F3-2F83-4AD5-B79F-0B0130D3608F__GUID-EE9BE963-90B1-4842-BECE-3A0A49FD4795">第二种情景：</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li><span>选择没有当前事务的定位器。此时，定位器不包含事务ID。</span></li>
                        <li><span>开始交易。定位器不包含事务ID。</span></li>
                        <li><span>使用定位器从LOB读取数据。定位器不包含事务ID。</span></li>
                        <li><span>使用定位器将数据写入LOB。此操作有效，因为定位器在写入之前不包含事务ID。在此调用之后，定位器包含事务ID。您可以继续读取或写入LOB。</span></li>
                        <li><span>提交或回滚事务。定位器继续包含事务ID。</span></li>
                        <li><span>使用定位器从LOB读取数据。这是一个有效的操作。</span></li>
                        <li><span>开始交易。定位器包含先前的事务ID。</span></li>
                        <li><span>使用定位器将数据写入LOB。此写入操作失败，因为定位器不包含与当前事务匹配的事务标识。</span></li>
                     </ol>
                  </div>
               </div><a id="ADLOB45345"></a><a id="ADLOB45346"></a><a id="ADLOB45344"></a><div class="props_rev_3"><a id="GUID-5E2C762D-F4B4-4D03-AE92-0940671C21E3" name="GUID-5E2C762D-F4B4-4D03-AE92-0940671C21E3"></a><h4 id="ADLOB-GUID-5E2C762D-F4B4-4D03-AE92-0940671C21E3" class="sect4">选择事务边界内的定位器</h4>
                  <div>
                     <div class="section">
                        <p>两个场景描述了在事务中选择定位器时在非可序列化事务中使用定位器的技术。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-5E2C762D-F4B4-4D03-AE92-0940671C21E3__GUID-833000E1-F340-44E0-8F6F-A67735BF0C64">第一种情景：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ol>
                           <li>
                              <p>选择事务中的定位器。此时，定位器包含事务ID。</p>
                           </li>
                           <li>
                              <p>开始交易。定位器包含先前的事务ID。</p>
                           </li>
                           <li>
                              <p>使用定位器从LOB读取数据。即使定位器中的事务ID与当前事务不匹配，此操作也是有效的。</p>
                              <div class="infoboxnotealso" id="GUID-5E2C762D-F4B4-4D03-AE92-0940671C21E3__GUID-5ACAA208-E7F4-4FD7-9161-54BD3A6311CD">
                                 <p class="notep1">也可以看看：</p>
                                 <p>有关使用定位器读取LOB数据的更多信息，请<span class="q"><a href="advanced-design-considerations.html#GUID-B1E476A2-F3FE-4D13-BC2B-FFB809698ED3">参阅</a> “ <a href="advanced-design-considerations.html#GUID-B1E476A2-F3FE-4D13-BC2B-FFB809698ED3">Read-Consistent Locators</a> ”</span> 。
                                 </p>
                              </div>
                           </li>
                           <li>
                              <p>使用定位器将数据写入LOB。此操作失败，因为定位器中的事务ID与当前事务不匹配。</p>
                           </li>
                        </ol>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-5E2C762D-F4B4-4D03-AE92-0940671C21E3__GUID-708E4337-5B2F-4334-BABC-3A48EBA058CD">第二种情景：</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li><span>开始交易。</span></li>
                        <li><span>选择定位器。定位器包含事务ID，因为它是在事务中选择的。</span></li>
                        <li><span>使用定位器读取或写入LOB。这些操作有效。</span></li>
                        <li><span>提交或回滚事务。定位器继续包含事务ID。</span></li>
                        <li><span>使用定位器从LOB读取数据。即使在定位器中存在事务ID并且事务先前已提交或回滚，此操作也是有效的。</span></li>
                        <li><span>使用定位器将数据写入LOB。此操作失败，因为定位器中的事务标识用于先前已提交或回滚的事务。</span></li>
                     </ol>
                  </div>
               </div><a id="ADLOB45347"></a><div class="props_rev_3"><a id="GUID-0FFBCC15-1C19-4B48-A570-F6BF197BB2B8" name="GUID-0FFBCC15-1C19-4B48-A570-F6BF197BB2B8"></a><h4 id="ADLOB-GUID-0FFBCC15-1C19-4B48-A570-F6BF197BB2B8" class="sect4">LOB定位器无法跨越事务</h4>
                  <div>
                     <p><a id="d80928e2362" class="indexterm-anchor"></a><a id="d80928e2366" class="indexterm-anchor"></a>使用<code class="codeph">DBMS_LOB</code> ，OCI或SQL <code class="codeph">INSERT</code>或<code class="codeph">UPDATE</code>语句通过LOB定位器修改持久性LOB值会更改定位器<a id="d80928e2380" class="indexterm-anchor"></a><a id="d80928e2382" class="indexterm-anchor"></a>读取一致定位器到更新的定位器。
                     </p>
                     <p><code class="codeph">INSERT</code>或<code class="codeph">UPDATE</code>语句自动启动事务并锁定行。一旦发生这种情况，就不能在当前事务之外使用定位器来修改LOB值。换句话说，用于写入数据的LOB定位器不能跨越事务。但是，除非您处于可序列化的事务中，否则定位器可用于读取LOB值。
                     </p>
                     <div class="infoboxnotealso" id="GUID-0FFBCC15-1C19-4B48-A570-F6BF197BB2B8__GUID-1B2250EF-98F1-40FF-BA86-94D58FEA560F">
                        <p class="notep1">也可以看看：</p>
                        <p><span class="q">“ <a href="advanced-design-considerations.html#GUID-4DDA92CE-8C94-4DD1-9BA3-C6FC5ED7CAE0">LOB定位器和事务边界</a> ”</span> ，有关LOB和事务边界之间关系的更多信息。
                        </p>
                     </div>
                     <p>在<a href="advanced-design-considerations.html#GUID-F973C33A-EA4D-4B1B-A7EA-C258BE6B44A8">没有跨越事务的定位器示例中</a> ，创建了一个<code class="codeph">CLOB</code>定位器： <code class="codeph">clob_updated</code></p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>在第一个<code class="codeph">SELECT</code> <code class="codeph">INTO</code> （在t1）时， <code class="codeph">ad_sourcetext</code>的值与定位符<code class="codeph">clob_updated</code>相关联。
                           </p>
                        </li>
                        <li>
                           <p>第二个操作（在t2）使用<code class="codeph">DBMS_LOB</code> 。 <code class="codeph">WRITE</code>函数用于更改<code class="codeph">clob_updated</code>的值，以及<code class="codeph">DBMS_LOB</code> 。 <code class="codeph">READ</code>显示一个新值。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">commit</code>语句（在t3）结束当前事务。
                           </p>
                        </li>
                        <li>
                           <p>因此（在t4），后续的<code class="codeph">DBMS_LOB</code> 。 <code class="codeph">WRITE</code>操作失败，因为<code class="codeph">clob_updated</code>定位器引用了另一个（已提交的）事务。返回的错误表明了这一点。在进一步的<code class="codeph">DBMS_LOB</code> （和OCI）修改操作中使用它之前，必须重新选择LOB定位器。
                           </p>
                        </li>
                     </ul>
                  </div>
               </div><a id="ADLOB45348"></a><div class="props_rev_3"><a id="GUID-F973C33A-EA4D-4B1B-A7EA-C258BE6B44A8" name="GUID-F973C33A-EA4D-4B1B-A7EA-C258BE6B44A8"></a><h4 id="ADLOB-GUID-F973C33A-EA4D-4B1B-A7EA-C258BE6B44A8" class="sect4">不跨越事务的定位器示例</h4>
                  <div>
                     <p>该示例使用<code class="codeph">print_media</code>中描述表<span class="q">“ <a href="working-with-LOBs.html#GUID-D71F0CBE-0717-41A2-BCD4-71E1DDF895D1" title="许多Oracle LOB示例使用Oracle Database Sample Schema PM的print_media表。">表对于LOB实施例：PM模式print_media表</a> ”</span></p><pre class="oac_no_warn" dir="ltr">INSERT INTO PRINT_MEDIA VALUES（2056,20010，EMPTY_BLOB（），'abcd'，EMPTY_CLOB（），EMPTY_CLOB（），NULL，NULL，NULL，NULL）;承诺; DECLARE num_var INTEGER; clob_updated CLOB; read_amount INTEGER; read_offset INTEGER; write_amount INTEGER; write_offset INTEGER; buffer VARCHAR2（20）; BEGIN  - 在时间t1：SELECT ad_sourcetext INTO clob_updated FROM PRINT_MEDIA WHERE ad_id = 20010 FOR UPDATE; read_amount：= 10; read_offset：= 1; dbms_lob.read（clob_updated，read_amount，read_offset，buffer）; dbms_output.put_line（'clob_updated value：'|| buffer）; - 这会产生输出'abcd' - 在时间t2：write_amount：= 3; write_offset：= 5; buffer：='efg'; dbms_lob.write（clob_updated，write_amount，write_offset，buffer）; read_amount：= 10; dbms_lob.read（clob_updated，read_amount，read_offset，buffer）; dbms_output.put_line（'clob_updated value：'|| buffer）; - 这会产生输出'abcdefg' - 在时间t3：COMMIT; - 在时间t4：dbms_lob.write（clob_updated，write_amount，write_offset，buffer）; - 错误：ORA-22990：LOB定位器无法跨越事务END; /</pre></div>
               </div>
            </div><a id="ADLOB45349"></a><div class="sect2"><a id="GUID-4AA63439-3BCD-41A8-98D0-40923BFE0309" name="GUID-4AA63439-3BCD-41A8-98D0-40923BFE0309"></a><h3 id="ADLOB-GUID-4AA63439-3BCD-41A8-98D0-40923BFE0309" class="sect3">对象缓存中的LOB</h3>
               <div>
                  <p>在具有LOB定位器属性的对象高速缓存中将一个对象复制到另一个对象时，仅复制LOB定位器。</p>
                  <p>这意味着这两个不同对象中的LOB属性包含完全相同的定位符，该定位符引用<span class="italic">一个相同的</span> LOB <span class="italic">值</span> 。仅当刷新目标对象时，才会生成LOB值的单独物理副本，该副本与源LOB值不同。
                  </p>
                  <div class="infoboxnotealso" id="GUID-4AA63439-3BCD-41A8-98D0-40923BFE0309__GUID-157C222F-614E-43AE-A1D2-BB6C241C3E2F">
                     <p class="notep1">也可以看看：</p>
                     <p><span class="q">“ <a href="advanced-design-considerations.html#GUID-0320FCED-13FE-4F6F-A68B-8A275F224780">更新LOB和读一致性的示例</a> ”，</span>用于描述每个对象在通过其中一个定位器执行写入时看到的LOB值的版本。
                     </p>
                  </div>
                  <p>因此，如果要修改作为副本目标的LOB，则<span class="italic"><span class="bold">必须刷新目标对象，刷新目标对象，然后</span></span>通过locator属性写入LOB。
                  </p>
                  <p>考虑内部和外部LOB属性的这些对象缓存问题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>持久性LOB属性：在对象缓存中创建对象，将LOB属性设置为空。<a id="d80928e2668" class="indexterm-anchor"></a><a id="d80928e2672" class="indexterm-anchor"></a><a id="d80928e2676" class="indexterm-anchor"></a></p>
                        <p>在包含持久LOB属性的对象缓存中创建对象时，LOB属性将隐式设置为空。您不能使用此空LOB定位器将数据写入LOB。您必须先刷新对象，然后在表中插入一行并创建一个空LOB  - 即一个长度为0的LOB。在对象缓存中刷新对象（使用<code class="codeph">OCI_PIN_LATEST</code> ）后，将真实的LOB定位器读入属性，然后可以调用OCI LOB API将数据写入LOB。</p>
                     </li>
                     <li>
                        <p>外部LOB（ <code class="codeph">BFILE</code> ）属性：在对象缓存中创建对象，将<code class="codeph">BFILE</code>属性设置为<code class="codeph">NULL</code> 。</p>
                        <p>使用外部LOB（ <code class="codeph">BFILE)</code>属性创建对象时， <code class="codeph">BFILE</code>设置为<code class="codeph">NULL</code> 。在从<code class="codeph">BFILE</code>读取之前，必须使用有效的目录对象名称和文件名进行更新。</p>
                     </li>
                  </ul>
               </div>
            </div><a id="ADLOB102"></a><div class="props_rev_3"><a id="GUID-FD6659DC-8792-4D7C-AC07-9EABEA02DF91" name="GUID-FD6659DC-8792-4D7C-AC07-9EABEA02DF91"></a><h3 id="ADLOB-GUID-FD6659DC-8792-4D7C-AC07-9EABEA02DF91" class="sect3">Terabyte-Size LOB支持</h3>
               <div>
                  <p><a id="d80928e2774" class="indexterm-anchor"></a><a id="d80928e2778" class="indexterm-anchor"></a><a id="d80928e2782" class="indexterm-anchor"></a>太字节大小的LOB是最大为8到128太字节的LOB，具体取决于数据库块大小。
                  </p>
                  <p>话题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="advanced-design-considerations.html#GUID-74618664-CE35-48FB-85C6-E03CD2063BD1">关于Terabyte-Size LOB支持</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-design-considerations.html#GUID-A84520F4-05EF-48F3-B2A4-9CC001192B23">TB级大小LOB的最大存储限制</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-design-considerations.html#GUID-0A6B471E-85EC-429C-AA20-29944A96939E">在TB中使用TB级大小的LOB</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-design-considerations.html#GUID-1DEA56D9-5CBD-4211-88DB-87B4329B02F6">在TBMS_LOB包中使用TB级大小的LOB</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-design-considerations.html#GUID-A40086A3-2F4D-4153-B4DE-7C02C7CE08A8">使用太字节大小的LOB和OCI</a></p>
                     </li>
                  </ul>
               </div>
               <div class="props_rev_3"><a id="GUID-74618664-CE35-48FB-85C6-E03CD2063BD1" name="GUID-74618664-CE35-48FB-85C6-E03CD2063BD1"></a><h4 id="ADLOB-GUID-74618664-CE35-48FB-85C6-E03CD2063BD1" class="sect4">关于Terabyte-Size LOB支持</h4>
                  <div>
                     <p>以下API支持TB级大小的LOB：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>Java使用JDBC（Java数据库连接）</p>
                        </li>
                        <li>
                           <p>使用DBMS_LOB包的PL / SQL</p>
                        </li>
                        <li>
                           <p>C使用OCI（Oracle调用接口）</p>
                        </li>
                     </ul>
                     <p>在以下编程环境中，您无法创建和使用大小超过4千兆字节“太字节大小LOB”的LOB实例：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>COBOL使用Pro * COBOL预编译器</p>
                        </li>
                        <li>
                           <p>使用Pro * C / C ++预编译器的C或C ++</p>
                        </li>
                     </ul>
                     <div class="infoboxnote" id="GUID-74618664-CE35-48FB-85C6-E03CD2063BD1__GUID-11FE0E82-93ED-4571-B971-850B5123866D">
                        <p class="notep1">注意：</p>
                        <p>在任何编程环境中，Oracle数据库都不支持大于2 ^ 64-1字节的<code class="codeph">BFILE</code> （OCI中的<code class="codeph">UB8MAXVAL</code> ）。操作系统强加的任何其他文件大小限制也适用于<code class="codeph">BFILE</code> 。
                        </p>
                     </div>
                  </div>
               </div><a id="ADLOB45350"></a><div class="props_rev_3"><a id="GUID-A84520F4-05EF-48F3-B2A4-9CC001192B23" name="GUID-A84520F4-05EF-48F3-B2A4-9CC001192B23"></a><h4 id="ADLOB-GUID-A84520F4-05EF-48F3-B2A4-9CC001192B23" class="sect4">TB级大小LOB的最大存储限制</h4>
                  <div>
                     <p>在支持的环境中，您可以创建和操作最大为数据库配置的最大存储大小限制的LOB。</p>
                     <p>Oracle数据库允许您创建块大小与数据库块大小不同的表空间，并且LOB的最大大小取决于表空间块的大小。<code class="codeph">CHUNK</code>是LOB存储的参数，其值由存储LOB的表空间的块大小控制。
                     </p>
                     <div class="infoboxnote" id="GUID-A84520F4-05EF-48F3-B2A4-9CC001192B23__GUID-69693601-CFB9-42B9-B1B0-6F8CFD131081">
                        <p class="notep1">注意：</p>
                        <p><code class="codeph">CHUNK</code>参数不适用于SecureFiles。它仅用于BasicFiles LOB。
                        </p>
                     </div>
                     <p>创建LOB列时，可以为<code class="codeph">CHUNK</code>指定一个值，该值是为LOB操作分配的字节数。该值必须是表空间块大小的倍数，或Oracle数据库向上舍入到下一个倍数。（如果表空间块大小与数据库块大小相同，则<code class="codeph">CHUNK</code>也是数据库块大小的倍数。）
                     </p>
                     <p>配置的最大允许存储限制取决于表空间块大小设置，并计算为（4千兆字节 -  1）乘以从<a id="d80928e2994" class="indexterm-anchor"></a> <code class="codeph">DBMS_LOB.GETCHUNKSIZE</code>或<a id="d80928e2999" class="indexterm-anchor"></a> <code class="codeph">OCILobGetChunkSize()</code> 。由于内部存储开销，此值（ <code class="codeph">BLOB</code>的字节数或<code class="codeph">CLOB</code>的字符数）实际上小于<code class="codeph">CHUNK</code>参数的大小。表空间块大小的当前允许范围为2K到32K，存储限制范围为8TB到128TB。
                     </p>
                     <p>例如，假设您的数据库块大小为32K字节，并且您创建了一个非标准块大小为8K的表空间。进一步假设您创建一个具有LOB列的表，并指定CHUNK大小为16K（这是8K表空间块大小的倍数）。然后，此列中LOB的最大大小为（4千兆字节-1）* 16K。</p>
                     <div class="infoboxnotealso" id="GUID-A84520F4-05EF-48F3-B2A4-9CC001192B23__GUID-EA64EA3E-77FC-4BEC-A5C2-5946839B3D61">
                        <p class="notep1">也可以看看：</p>
                        <p> </p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p> 有关数据库安装的初始化参数设置的详细信息，请参见<a href="../admin/creating-and-configuring-an-oracle-database.html#ADMIN11099" target="_blank"><span class="italic">“Oracle数据库管理员指南”</span></a></p>
                           </li>
                           <li>
                              <p><span class="q">“ <a href="LOB-storage-with-applications.html#GUID-A3D50A10-E688-4DB3-A3EB-07AC7D0019A6">CHUNK</a> ”</span></p>
                           </li>
                        </ul>
                     </div>
                     <p>此存储限制适用于支持TB级LOB的环境中的所有LOB类型。但是，请注意<code class="codeph">CLOB</code>和<code class="codeph">NCLOB</code>类型的大小以字符为单位，而<code class="codeph">BLOB</code>类型的大小以字节为单位。
                     </p>
                  </div>
               </div><a id="ADLOB45351"></a><div class="props_rev_3"><a id="GUID-0A6B471E-85EC-429C-AA20-29944A96939E" name="GUID-0A6B471E-85EC-429C-AA20-29944A96939E"></a><h4 id="ADLOB-GUID-0A6B471E-85EC-429C-AA20-29944A96939E" class="sect4">在TB中使用TB级大小的LOB</h4>
                  <div>
                     <p>您可以使用Oracle JDBC类中包含的LOB API来访问TB级LOB。</p>
                     <div class="infoboxnotealso" id="GUID-0A6B471E-85EC-429C-AA20-29944A96939E__GUID-1CD9F739-D2C0-4054-A23A-F66CED511B1C">
                        <p class="notep1">也可以看看：</p>
                        <p><span class="q">“ <a href="overview-of-supplied-LOB-APIs.html#GUID-02CAA51A-FD04-4A40-8227-0B9108FAED8E">使用Java（JDBC）处理LOB</a> ”</span></p>
                     </div>
                  </div>
               </div><a id="ADLOB45352"></a><div class="props_rev_3"><a id="GUID-1DEA56D9-5CBD-4211-88DB-87B4329B02F6" name="GUID-1DEA56D9-5CBD-4211-88DB-87B4329B02F6"></a><h4 id="ADLOB-GUID-1DEA56D9-5CBD-4211-88DB-87B4329B02F6" class="sect4">在TBMS_LOB包中使用TB级大小的LOB</h4>
                  <div>
                     <p>您可以使用DBMS_LOB PL / SQL包中的所有API访问TB级的LOB。</p>
                     <p>使用<code class="codeph">DBMS_LOB.GETCHUNKSIZE</code>获取用于读取和写入LOB的值。由于内部存储开销，存储在块中的字节数实际上小于<code class="codeph">CHUNK</code>参数的大小。该<a id="d80928e3188" class="indexterm-anchor"></a> <code class="codeph">DBMS_LOB.GET_STORAGE_LIMIT</code>函数返回数据库配置的存储限制。这是LOB的最大允许大小。<code class="codeph">BLOB</code>的大小以字节为单位，而<code class="codeph">CLOB</code>和<code class="codeph">NCLOB</code>的大小以字符为单位。
                     </p>
                     <div class="infoboxnotealso" id="GUID-1DEA56D9-5CBD-4211-88DB-87B4329B02F6__GUID-D169ED0A-8BE4-4AEB-81BF-AB23BA553589">
                        <p class="notep1">也可以看看：</p>
                        <p>有关数据库安装的初始化参数设置的详细信息，请参阅<a href="../arpls/DBMS_LOB.html#ARPLS601" target="_blank"><span><cite>Oracle Database PL / SQL包和类型参考</cite></span></a> 。
                        </p>
                     </div>
                  </div>
               </div><a id="ADLOB45353"></a><div class="props_rev_3"><a id="GUID-A40086A3-2F4D-4153-B4DE-7C02C7CE08A8" name="GUID-A40086A3-2F4D-4153-B4DE-7C02C7CE08A8"></a><h4 id="ADLOB-GUID-A40086A3-2F4D-4153-B4DE-7C02C7CE08A8" class="sect4">使用太字节大小的LOB和OCI</h4>
                  <div>
                     <p>Oracle Call Interface API为所有大小的LOB提供了一组函数。</p>
                     <p><code class="codeph">OCILobGetChunkSize()</code>返回<code class="codeph">BLOB</code>的字节值，或<code class="codeph">CLOB</code>的字符，用于读写LOB。对于变宽字符集，该值是适合的Unicode字符数。由于内部存储开销，存储在块中的字节数实际上小于<code class="codeph">CHUNK</code>参数的大小。函数<code class="codeph">OCILobGetStorageLimit()</code>返回当前数据库安装中内部LOB的最大允许大小（以字节为单位）。如果使用流模式，读取整个LOB，则不需要获取块大小。
                     </p>
                     <div class="infoboxnotealso" id="GUID-A40086A3-2F4D-4153-B4DE-7C02C7CE08A8__GUID-6793BAA5-DB0F-4BE7-911D-6F0C6418CBC2">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="../lnoci/lobs-and-bfile-operations.html#LNOCI-GUID-EC49588A-0534-4E43-8CB1-3D0FAE205BAB" target="_blank"><span><cite>“Oracle调用接口程序员指南”</cite></span></a> ，了解有关支持LOB的OCI函数的详细信息</p>
                     </div>
                  </div>
               </div>
            </div><a id="ADLOB45354"></a><div class="props_rev_3"><a id="GUID-B8E82069-4847-4116-9DA1-BFE6F99288C2" name="GUID-B8E82069-4847-4116-9DA1-BFE6F99288C2"></a><h3 id="ADLOB-GUID-B8E82069-4847-4116-9DA1-BFE6F99288C2" class="sect3">创建技嘉LOB的指南</h3>
               <div>
                  <div class="section">
                     <p>要在受支持的环境中创建千兆字节LOB，请使用以下准则来利用表空间中的所有可用空间来进行LOB存储：</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <ul style="list-style-type:disc">
                        <li>
                           <p>单数据文件大小限制：</p>
                           <p>每个操作系统的单个数据文件的大小都有限制。例如，Solaris 2.5仅允许最多2千兆字节的操作系统文件。因此，当LOB增长大于运行Oracle数据库的操作系统的最大允许文件大小时，请向表空间添加更多数据文件。</p>
                        </li>
                        <li>
                           <p>将PCT INCREASE参数设置为零：</p>
                           <p>LOB存储子句中的<code class="codeph">PCTINCREASE</code>参数指定新扩展区大小的增长百分比。当LOB在表空间中逐个填充时，会在该过程中创建许多新的扩展区。如果扩展区大小每次默认值增加50％，则扩展区变得无法管理，最终会浪费表空间中的空间。因此， <code class="codeph">PCTINCREASE</code>参数应设置为零或小值。
                           </p>
                        </li>
                        <li>
                           <p>将MAXEXTENTS设置为合适的值或UNLIMITED：</p>
                           <p><code class="codeph">MAXEXTENTS</code>参数限制LOB列允许的范围数。随着LOB大小的增加，会逐渐创建大量扩展区。因此，应将参数设置为足以容纳列的所有LOB的值。或者，您可以将其设置为<code class="codeph">UNLIMITED</code> 。</p>
                        </li>
                        <li>
                           <p>使用大范围大小：</p>
                           <p>对于创建的每个新范围，Oracle都会为标头和范围的其他元数据生成撤消信息。如果扩展区的数量很大，则回滚段可能会饱和。要解决此问题，请选择较大的扩展区大小，例如100兆字节，以减少扩展区创建的频率，或者更频繁地提交事务以重用回滚段中的空间。</p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
               </div><a id="ADLOB45355"></a><div class="sect3"><a id="GUID-D32C170D-F7A9-4338-B7C9-7384BC757166" name="GUID-D32C170D-F7A9-4338-B7C9-7384BC757166"></a><h4 id="ADLOB-GUID-D32C170D-F7A9-4338-B7C9-7384BC757166" class="sect4">创建表空间和表来存储技嘉LOB</h4>
                  <div>
                     <p>以下示例说明如何创建表空间和表以存储千兆字节LOB。</p><pre class="oac_no_warn" dir="ltr">CREATE TABLESPACE lobtbs1 DATAFILE'/your/own/data/directory/lobtbs_1.dat'SIZE 2000M REUSE ONLINE NOLOGGING DEFAULT STORAGE（MAXEXTENTS UNLIMITED）; ALTER TABLESPACE lobtbs1添加数据文件'/your/own/data/directory/lobtbs_2.dat'SIZE 2000M REUSE; CREATE TABLE print_media_backup（product_id NUMBER（6），ad_id NUMBER（6），ad_composite BLOB，ad_sourcetext CLOB，ad_finaltext CLOB，ad_fltextn NCLOB，ad_textdocs_ntab textdoc_tab，ad_photo BLOB，ad_graphic BLOB，ad_header adheader_typ）NESTED TABLE ad_textdocs_ntab STORE AS textdocs_nestedtab5 LOB（ad_sourcetext）商店（TABLESPACE lobtbs1 CHUNK 32768 PCTVERSION 0 NOCACHE NOLOGGING STORAGE（INMTIAL 100M NEXT 100M MAXEXTENTS UNLIMITED PCTINCREASE 0））;</pre><p>请注意以下关于此示例：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>此示例中的storage子句在<code class="codeph">CREATE TABLESPACE</code>语句中指定。
                           </p>
                        </li>
                        <li>
                           <p>您可以在<code class="codeph">CREATE TABLE</code>语句中指定storage子句作为替代。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">CREATE TEMPORARY TABLESPACE</code>语句中不允许使用storage子句。
                           </p>
                        </li>
                        <li>
                           <p>对于千兆字节LOB，建议将<code class="codeph">PCTINCREASE</code>参数设置为0。对于小尺寸或中等尺寸的凸起，建议使用默认的<code class="codeph">PCTINCREASE</code>值50，因为它减少了范围分配的数量。
                           </p>
                        </li>
                     </ul>
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>