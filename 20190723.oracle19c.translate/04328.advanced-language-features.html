<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <title>高级语言功能</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="SQLJ Developer&#39;s Guide "></meta>
      <meta property="og:description" content=""></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="SQLJ Developer&#39;s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="sqlj-developers-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-11T08:20:03-08:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="1999, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96458-01"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="objects-collections-and-OPAQUE-types.html" title="Previous" type="text/html"></link>
      <link rel="next" href="translator-command-line-and-options.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="SQLJ Developer&#39;s Guide"></meta>
    <meta name="dcterms.isVersionOf" content="JSQLJ"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="objects-collections-and-OPAQUE-types.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="translator-command-line-and-options.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">SQLJ开发人员指南</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">高级语言功能</li>
            </ol>
            <a id="GUID-FE22E864-65F8-44E7-AB2B-12AE158E4A58" name="GUID-FE22E864-65F8-44E7-AB2B-12AE158E4A58"></a><a id="JSQLJ494"></a>
            
            <h2 id="JSQLJ-GUID-FE22E864-65F8-44E7-AB2B-12AE158E4A58" class="sect2"><span class="enumeration_chapter">8</span>高级语言功能</h2>
         </header>
         <div class="ind">
            <div>
               <p>本章讨论用于编写应用程序的高级SQLJ语言功能。有关更多基本主题，请参阅<a href="basic-language-features.html#GUID-D93359BA-4F29-49C2-8AAE-23F8BBCE8BE5">基本语言功能</a> 。
               </p>
               <p>讨论了以下主题：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="advanced-language-features.html#GUID-DE7D99A8-ED65-4DEA-B274-3BC09EE0056A">连接上下文</a></p>
                  </li>
                  <li>
                     <p><a href="advanced-language-features.html#GUID-BC1805F7-AECB-4D97-B74C-1E0D71BDE603">执行上下文</a></p>
                  </li>
                  <li>
                     <p><a href="advanced-language-features.html#GUID-C7787089-2507-43D1-91A3-FEC222903639">SQLJ中的多线程</a></p>
                  </li>
                  <li>
                     <p><a href="advanced-language-features.html#GUID-9723BCED-0FA3-4AD9-B6C0-62B85B53C4EF">迭代器类实现和高级功能</a></p>
                  </li>
                  <li>
                     <p><a href="advanced-language-features.html#GUID-3B7EEA7A-5E45-4455-8255-2A5C1334DAD8">高级交易控制</a></p>
                  </li>
                  <li>
                     <p><a href="advanced-language-features.html#GUID-8AF6CBB6-D6B3-44AB-99D5-5ADF6495E568">SQLJ和JDBC互操作性</a></p>
                  </li>
                  <li>
                     <p><a href="advanced-language-features.html#GUID-1A237022-5F1E-4C29-87D3-8E913F59C3FA">支持动态SQL</a></p>
                  </li>
                  <li>
                     <p><a href="advanced-language-features.html#GUID-EB24FCD6-B42D-47FB-98B8-1D4285407E69">使用存储的轮廓</a></p>
                  </li>
                  <li>
                     <p><a href="advanced-language-features.html#GUID-8465DD7E-5943-4BBD-911D-F1318A55552E">使用计划基准</a></p>
                  </li>
               </ul>
            </div><a id="JSQLJ495"></a><div class="props_rev_3"><a id="GUID-DE7D99A8-ED65-4DEA-B274-3BC09EE0056A" name="GUID-DE7D99A8-ED65-4DEA-B274-3BC09EE0056A"></a><h3 id="JSQLJ-GUID-DE7D99A8-ED65-4DEA-B274-3BC09EE0056A" class="sect3">连接上下文</h3>
               <div>
                  <p>SQLJ支持连接上下文的概念，允许强类型连接与不同的SQL实体集一起使用。您可以将连接上下文视为与一组特定的SQL实体相关联，例如表，视图和存储过程。SQLJ允许您声明其他连接上下文类，以便您可以将每个类用于使用特定SQL实体集的连接。单个连接上下文类的不同实例不需要使用相同的物理实体或连接到同一模式，但至少会使用具有相同名称和数据类型的实体集。</p>
                  <div class="infoboxnotealso" id="GUID-DE7D99A8-ED65-4DEA-B274-3BC09EE0056A__GUID-DB141E7F-B6CE-45BE-A3A8-E67EBED8F73F">
                     <p class="notep1">也可以看看：</p>
                     <p><span class="q">“ <a href="key-programming-considerations.html#GUID-02A50813-2D4D-4DC1-AD1A-014AF1EDC03D">连接注意事项</a> ”，</span>用于概述连接基础知识，重点介绍仅使用一组SQL实体和单个连接上下文类的情况。
                     </p>
                  </div>
                  <p>本节包括以下主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="advanced-language-features.html#GUID-7756F849-1D32-4AEC-9D2E-C14F344F0E8E">连接上下文概念</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-language-features.html#GUID-DFA587F9-6F2D-4C60-875F-2A69790EEA43">连接上下文物流</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-language-features.html#GUID-2A967E4C-6ED2-4C69-830D-D89CE7F319FC">声明和使用连接上下文类</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-language-features.html#GUID-C4145BED-8A73-4F6C-9CEC-1FA90DBF515F">多连接上下文的示例</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-language-features.html#GUID-50ACAE7A-118A-4D0B-B18B-03813798054C">连接上下文类的实现和功能</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-language-features.html#GUID-DBE080FD-E5E1-476B-8B7F-199D44C259BC">在连接上下文声明中使用IMPLEMENTS子句</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-language-features.html#GUID-186FBFAC-DA4B-4BA4-9B21-CBBFE8EB67F1">语义 - 检查连接上下文使用情况</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-language-features.html#GUID-BBB6A8DE-EEF3-454B-BF98-C12E32A81314">标准数据源支持</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-language-features.html#GUID-861032F9-E30B-4765-9BD6-12CCF54D2D75">SQLJ特定的数据源</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-language-features.html#GUID-51755815-E5DB-41A3-8427-8969A0B90404">用于JavaServer Pages的SQLJ特定连接JavaBeans</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-language-features.html#GUID-02D73030-0352-4669-9152-0A331260FBC8">SQLJ支持全局事务</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-language-features.html#GUID-A5EAE0BC-4FE0-4D3B-992A-E423667DC3D1">连接到PDB</a></p>
                     </li>
                  </ul>
               </div><a id="JSQLJ496"></a><div class="props_rev_3"><a id="GUID-7756F849-1D32-4AEC-9D2E-C14F344F0E8E" name="GUID-7756F849-1D32-4AEC-9D2E-C14F344F0E8E"></a><h4 id="JSQLJ-GUID-7756F849-1D32-4AEC-9D2E-C14F344F0E8E" class="sect4">连接上下文概念</h4>
                  <div>
                     <p>如果您的应用程序使用不同的SQL实体集，那么您通常需要声明并使用一个或多个其他连接上下文类，如<span class="q">“ <a href="basic-language-features.html#GUID-74A36C5C-B63E-4489-A464-47387ABCB24E">SQLJ声明概述</a> ”中所述</span> 。每个连接上下文类都可以用于一组特定的相互关联的SQL实体，这意味着您使用特定连接上下文类定义的所有连接将使用表，视图，存储过程等，它们具有相同的名称并使用相同的数据类型。
                     </p>
                     <p>一组SQL实体的示例是人力资源（HR）部门使用的一组表和存储过程。也许他们使用<code class="codeph">EMPLOYEES</code>和<code class="codeph">DEPARTMENTS</code>表以及<code class="codeph">CHANGE_DEPT</code>和<code class="codeph">UPDATE_HEALTH_PLAN</code>存储过程。另一组SQL实体可能是工资单部门使用的一组表和过程，可能包括<code class="codeph">EMPS</code>表（另一个员工表，但不同于HR使用的表）和<code class="codeph">GIVE_RAISE</code>和<code class="codeph">CHANGE_WITHHOLDING</code>存储过程。
                     </p>
                     <p>将连接上下文类定制为SQL实体集的优势在于它允许的在线语义检查程度。联机检查验证在SQLJ语句中出现的使用给定连接上下文类的所有SQL实体是否与在转换期间使用的示例模式中找到的SQL实体匹配。示例模式是SQLJ连接到的数据库帐户，用于联机检查使用特定连接上下文类的所有SQLJ语句。您可以通过SQLJ命令行<code class="codeph">-user</code> ， <code class="codeph">-password</code>和<code class="codeph">-url</code>选项向转换程序提供示例模式。示例模式可能与您的应用程序在运行时使用的帐户相同或不同。
                     </p>
                     <div class="infoboxnotealso" id="GUID-7756F849-1D32-4AEC-9D2E-C14F344F0E8E__GUID-454DAED1-AA45-4861-BBA6-40BBAB5D2E1E">
                        <p class="notep1">也可以看看：</p>
                        <p><span class="q">“ <a href="translator-command-line-and-options.html#GUID-E001FA35-824A-47A1-8973-AA5771B0DFE5">连接选项</a> ”</span></p>
                     </div>
                     <p>如果您的SQLJ语句使用广泛且可能不相关的SQL实体组，但您对这些语句仅使用单个连接上下文类，则您提供的示例模式必须非常通用。它必须包含所有语句中使用的所有表，视图和存储过程。或者，如果使用给定连接上下文类的所有SQLJ语句都使用紧密的，可能相互关联的SQL实体集，那么您可以提供更具体的示例模式，以实现更彻底和有意义的语义检查。</p>
                     <div class="infoboxnote" id="GUID-7756F849-1D32-4AEC-9D2E-C14F344F0E8E__GUID-850E839F-E7A1-4A92-A386-72D1C4DEB012">
                        <p class="notep1">注意：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>请注意，连接上下文类声明未定义要与声明的连接上下文类一起使用的一组SQL实体，并且允许对使用不同且不相关的实体集的连接使用相同的连接上下文类。您如何使用连接上下文类由您自行决定。限制可以与特定连接上下文类一起使用的SQL实体的所有限制是示例模式中可用的实体集（如果在转换期间使用在线语义检查），以及在运行时连接到的模式中可用的实体集时间，使用连接上下文类的实例。</p>
                           </li>
                           <li>
                              <p>如果在应用程序中使用了合格的SQL名称，例如<code class="codeph">HR.EMPLOYEES</code> ，它指定了实体所在的模式，那么示例模式（如果使用在线检查）和运行时模式必须具有完全访问资源的权限。合格的名字。
                              </p>
                           </li>
                           <li>
                              <p>即使连接到不同供应商的数据库，也可以使用单个连接上下文类，只要连接的每个模式都具有可由相同名称访问且使用兼容数据类型的实体。</p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="JSQLJ497"></a><div class="props_rev_3"><a id="GUID-DFA587F9-6F2D-4C60-875F-2A69790EEA43" name="GUID-DFA587F9-6F2D-4C60-875F-2A69790EEA43"></a><h4 id="JSQLJ-GUID-DFA587F9-6F2D-4C60-875F-2A69790EEA43" class="sect4">连接上下文物流</h4>
                  <div>
                     <p>声明连接上下文类会导致SQLJ转换器在转换器生成的代码中为您定义类。除了您声明的任何连接上下文类之外，始终存在默认的连接上下文类：</p><pre class="oac_no_warn" dir="ltr">sqlj.runtime.ref。的DefaultContext</pre><p>构造连接上下文实例时，请指定特定的模式以及将在其中执行SQL操作的特定会话和事务。您通常通过将用户名，密码和数据库URL指定为连接上下文类的构造函数的输入来实现此目的。连接上下文实例管理会话期间执行的一组SQL操作。</p>
                     <p>在每个SQLJ语句中，您可以指定要使用的连接上下文实例。以下示例显示了连接上下文类<code class="codeph">MyContext</code>基本声明和用法，以连接到两个不同的模式。对于典型用法，假设这些模式包含一组具有通用名称和数据类型的SQL实体。
                     </p><pre class="oac_no_warn" dir="ltr">#sql context MyContext; ...MyContext mctx1 = new MyContext（“jdbc：oracle：thin：@localhost：5221 / myservice”，“HR”，“hr”，false）; MyContext mctx2 = new MyContext（“jdbc：oracle：thin @ localhost：5221 / myservice”，“brian”，“mypasswd”，false）;</pre><p>请注意，连接上下文类构造函数指定了一个布尔自动提交参数。此外，请注意您可以使用不同的连接上下文实例连接到同一模式。在前面的示例中，如果需要， <code class="codeph">mctx1</code>和<code class="codeph">mctx2</code>都可以指定<code class="codeph">HR/hr</code> 。但是，在运行时，在提交更改之前，一个连接上下文实例不会看到对另一个连接上下文实例所做的更改。唯一的例外是，如果两个连接上下文实例都是从相同的底层Java数据库连接（JDBC）连接实例创建的。任何连接上下文类的构造函数之一都将JDBC连接实例作为输入。
                     </p>
                  </div>
               </div><a id="JSQLJ499"></a><a id="JSQLJ500"></a><a id="JSQLJ501"></a><a id="JSQLJ502"></a><a id="JSQLJ498"></a><div class="props_rev_3"><a id="GUID-2A967E4C-6ED2-4C69-830D-D89CE7F319FC" name="GUID-2A967E4C-6ED2-4C69-830D-D89CE7F319FC"></a><h4 id="JSQLJ-GUID-2A967E4C-6ED2-4C69-830D-D89CE7F319FC" class="sect4">声明和使用连接上下文类</h4>
                  <div>
                     <div class="section">
                        <p>本节给出了如何声明连接上下文类，然后使用类的实例定义数据库连接的详细示例。</p>
                        <p>连接上下文类具有用于打开与数据库模式的连接的构造函数，该数据库模式采用以下任何输入参数集（与<code class="codeph">DefaultContext</code>类一样）：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p>URL（ <code class="codeph">String</code> ），用户名（ <code class="codeph">String</code> ），密码（ <code class="codeph">String</code> ），自动提交（ <code class="codeph">boolean</code> ）</p>
                           </li>
                           <li>
                              <p>URL（ <code class="codeph">String</code> ）， <code class="codeph">java.util.Properties</code>对象，自动提交（ <code class="codeph">boolean</code> ）</p>
                           </li>
                           <li>
                              <p>URL（完全指定连接并包括用户名和密码的<code class="codeph">String</code> ），自动提交设置（ <code class="codeph">boolean</code> ）</p>
                           </li>
                           <li>
                              <p>JDBC连接对象（ <code class="codeph">Connection</code> ）</p>
                           </li>
                           <li>
                              <p>SQLJ连接上下文对象</p>
                           </li>
                        </ul>
                        <div class="infoboxnote" id="GUID-2A967E4C-6ED2-4C69-830D-D89CE7F319FC__GUID-15ABC42D-4E25-464D-800C-9F100FE76266">
                           <p class="notep1">注意：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>使用带有JDBC连接对象的构造函数时，请不要使用空JDBC连接初始化连接上下文实例。</p>
                              </li>
                              <li>
                                 <p>自动提交设置确定是否自动提交SQL操作。有关更多信息，请参阅<span class="q">“ <a href="key-programming-considerations.html#GUID-6F37BE89-6EA0-4B27-884A-C0D4E8746E97">基本事务控制</a> ”</span> 。
                                 </p>
                              </li>
                              <li>
                                 <p>如果使用<code class="codeph">with</code>子句的数据源声明连接上下文类，则它将包含一组不同的构造函数。有关更多信息，请参阅<span class="q">“ <a href="advanced-language-features.html#GUID-BBB6A8DE-EEF3-454B-BF98-C12E32A81314">标准数据源支持</a> ”</span> 。
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-2A967E4C-6ED2-4C69-830D-D89CE7F319FC__GUID-9C64BCC6-2469-490E-A093-E712C71AFF12">声明连接上下文类</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>以下声明创建连接上下文类：</p><pre class="oac_no_warn" dir="ltr">#sql context OrderEntryCtx &lt; <span class="italic">implements_clause</span> &gt; &lt; <span class="italic">with_clause</span> &gt;;</pre><p>这导致SQLJ转换器生成一个实现<code class="codeph">sqlj.runtime.的类<code class="codeph">sqlj.runtime.ConnectionContext</code>接口并扩展了一些基类，可能是一个抽象类，它也实现了<code class="codeph">ConnectionContext</code>接口。此基类将是您正在使用的特定SQLJ实现的一个功能。<code class="codeph">implements</code>子句和<code class="codeph">with</code>子句是可选的，分别指定要实现的附加接口和定义和初始化的变量。
                        </p>
                        <div class="infoboxnotealso" id="GUID-2A967E4C-6ED2-4C69-830D-D89CE7F319FC__GUID-0EE8E5FC-FE61-43DA-A250-89AB61910F3C">
                           <p class="notep1">也可以看看：</p>
                           <p><span class="q">“ <a href="basic-language-features.html#GUID-1843167B-56CD-49CB-811B-4ACC5DF38035">宣言实施条款</a> ”</span>和<span class="q">“ <a href="basic-language-features.html#GUID-5E97C2F0-7249-48FD-A75B-AB5A465147C7">声明条款</a> ”</span></p>
                        </div>
                        <p>以下是SQLJ转换器生成的示例（省略了方法实现）：</p><pre class="oac_no_warn" dir="ltr">class OrderEntryCtx实现了sqlj.runtime。ConnectionContext扩展...{public OrderEntryCtx（String url，Properties info，boolean autocommit）抛出SQLException {...}public OrderEntryCtx（String url，boolean autocommit）抛出SQLException {...}public OrderEntryCtx（String url，String user，String password，boolean autocommit）抛出SQLException {...}public OrderEntryCtx（Connection conn）抛出SQLException {...}public OrderEntryCtx（ConnectionContext other）抛出SQLException {...}public static OrderEntryCtx getDefaultContext（）{...}public static void setDefaultContext（OrderEntryCtx ctx）{...}}</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-2A967E4C-6ED2-4C69-830D-D89CE7F319FC__GUID-275BCAF5-E37F-42D2-95B4-6824C333E5FE">创建连接上下文实例</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>继续前面的示例，使用以下语法实例化<code class="codeph">OrderEntryCtx</code>类：</p><pre class="oac_no_warn" dir="ltr">OrderEntryCtx myOrderConn = new OrderEntryCtx（ <span class="italic">url</span> ， <span class="italic">username</span> ， <span class="italic">password，autocommit</span> ）;</pre><p>例如：</p><pre class="oac_no_warn" dir="ltr">OrderEntryCtx myOrderConn = new OrderEntryCtx（“jdbc：oracle：thin：@localhost：5221 / myservice”，“HR”，“hr”，true）;</pre><p>这与实例化<code class="codeph">DefaultContext</code>类的方式相同。所有连接上下文类（包括<code class="codeph">DefaultContext</code> ）都具有相同的构造函数签名。
                        </p>
                        <div class="infoboxnote" id="GUID-2A967E4C-6ED2-4C69-830D-D89CE7F319FC__GUID-E735C636-A11E-4235-B0DB-D689A9461D16">
                           <p class="notep1">注意：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>您通常必须在构建连接上下文实例之前注册JDBC驱动程序。请参阅<span class="q">“ <a href="key-programming-considerations.html#GUID-EDC7B103-DC71-490F-BF36-9FD95B155425">运行时选择和注册</a> ”</span> 。
                                 </p>
                              </li>
                              <li>
                                 <p>如果使用<code class="codeph">with</code>子句的数据源声明连接上下文类，则它将包含一组不同的构造函数。有关更多信息，请参阅<span class="q">“ <a href="advanced-language-features.html#GUID-BBB6A8DE-EEF3-454B-BF98-C12E32A81314">标准数据源支持</a> ”</span> 。
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-2A967E4C-6ED2-4C69-830D-D89CE7F319FC__GUID-EFBB9C99-D952-4ACC-ACBB-E66C2378C9DC">为SQLJ子句指定连接上下文实例</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>回想一下，基本的SQLJ语句语法如下：</p><pre class="oac_no_warn" dir="ltr">#sql &lt;[&lt; <span class="italic">conn</span> &gt; <span class="italic">&lt;，&gt; &lt;exec</span> &gt;]&gt; { <span class="italic">SQL operation</span> };</pre><p>在<code class="codeph">#sql</code>标记后面的方括号内指定连接上下文实例。例如，在以下SQLJ语句中，连接上下文实例是上一个示例中的<code class="codeph">myOrderConn</code> ：</p><pre class="oac_no_warn" dir="ltr">#sql [myOrderConn] {UPDATE TAB2 SET COL1 =：w WHERE：v &lt;COL2};</pre><p>通过这种方式，您可以指定<code class="codeph">DefaultContext</code>类或任何声明的连接上下文类的实例。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-2A967E4C-6ED2-4C69-830D-D89CE7F319FC__GUID-80F22B68-1771-4D63-962C-F88CE0E7F896">关闭连接上下文实例</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>建议您在完成后关闭所有连接上下文实例。每个连接上下文类都包含一个<code class="codeph">close()</code>方法，如<span class="q">“ <a href="key-programming-considerations.html#GUID-B255B6E1-449E-4FE1-ACFE-6FCD2AFCFBDC">关闭连接</a> ”中</span>的<code class="codeph">DefaultContext</code>类所述。
                        </p>
                        <p>在关闭与另一个连接实例共享底层连接的连接上下文实例时，您可能希望保持底层连接处于打开状态。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ503"></a><div class="props_rev_3"><a id="GUID-C4145BED-8A73-4F6C-9CEC-1FA90DBF515F" name="GUID-C4145BED-8A73-4F6C-9CEC-1FA90DBF515F"></a><h4 id="JSQLJ-GUID-C4145BED-8A73-4F6C-9CEC-1FA90DBF515F" class="sect4">多连接上下文的示例</h4>
                  <div>
                     <p>以下是使用多个连接上下文的SQLJ应用程序的示例。它隐式地为一组SQL实体使用<code class="codeph">DefaultContext</code>类的实例，并为另一组SQL实体使用声明的<code class="codeph">DeptContext</code>连接上下文类的实例。
                     </p>
                     <p>此示例使用静态<code class="codeph">Oracle.connect()</code>方法建立默认连接，然后使用静态<code class="codeph">Oracle.getConnection()</code>方法将另一个<code class="codeph">DefaultContext</code>实例传递给<code class="codeph">DeptContext</code>构造函数， <code class="codeph">DeptContext</code>构造其他连接。如前所述，这只是构建SQLJ连接上下文实例的几种方法之一。
                     </p><pre class="oac_no_warn" dir="ltr">import java.sql。的SQLException; import oracle.sqlj.runtime。甲骨文; //为获取部门声明一个新的上下文类#sql context DeptContext; #sql iterator Employees（String ename，int deptno）; class MultiSchemaDemo {public static void main（String [] args）throws SQLException {//设置在connect.properties文件中指定的URL，用户和密码的默认连接.Oracle.connect（MultiSchemaDemo.class，“connect。属性“）; //使用//第二个连接创建查询部门信息的上下文DeptContext deptCtx = new DeptContext（Oracle.getConnection（MultiSchemaDemo.class，“connect.properties”））; new MultiSchemaDemo（）。printEmployees（deptCtx）; deptCtx.close（）; } //在从//不同连接访问的两个表的deptno字段上执行连接。void printEmployees（DeptContext deptCtx）抛出SQLException {//从默认上下文Employees emps获取员工; #sql emps = {SELECT first_name，department_id FROM employees}; //为每个员工，使用dept表连接上下文获取部门名称while（emps.next（））{String dname; int deptno = emps.deptno（）; #sql [deptCtx] {SELECT dname INTO：dname FROM departments WHERE department_id =：deptno}; System.out.println（“employee：”+ emps.ename（）+“，department：”+ dname）; } emps.close（）; }}</pre></div>
               </div><a id="JSQLJ505"></a><a id="JSQLJ506"></a><a id="JSQLJ504"></a><div class="props_rev_3"><a id="GUID-50ACAE7A-118A-4D0B-B18B-03813798054C" name="GUID-50ACAE7A-118A-4D0B-B18B-03813798054C"></a><h4 id="JSQLJ-GUID-50ACAE7A-118A-4D0B-B18B-03813798054C" class="sect4">连接上下文类的实现和功能</h4>
                  <div>
                     <p>本节讨论SQLJ如何实现连接上下文类，包括<code class="codeph">DefaultContext</code>类，以及它们包含哪些值得注意的方法。如前所述， <code class="codeph">DefaultContext</code>类和所有生成的连接上下文类都实现了<code class="codeph">ConnectionContext</code>接口。
                     </p>
                     <div class="infoboxnote" id="GUID-50ACAE7A-118A-4D0B-B18B-03813798054C__GUID-8FB01559-8F2A-4BAD-987A-680D26ADFFA5">
                        <p class="notep1">注意：</p>
                        <p>SQLJ规范中不允许扩展连接上下文类，Oracle SQLJ实现不支持。</p>
                     </div>
                     <div class="section">
                        <p class="subhead3" id="GUID-50ACAE7A-118A-4D0B-B18B-03813798054C__GUID-A5EA131A-0CC0-4ABD-A62C-E9B8641BF263">ConnectionContext接口</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>每个连接上下文类都实现<code class="codeph">sqlj.runtime.ConnectionContext</code>接口。
                        </p>
                        <p><a id="d36232e718" class="indexterm-anchor"></a><a id="d36232e722" class="indexterm-anchor"></a><a id="d36232e726" class="indexterm-anchor"></a><a id="d36232e730" class="indexterm-anchor"></a>此接口指定的基本方法包括以下内容：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">close(boolean CLOSE_CONNECTION/KEEP_CONNECTION)</code> ：释放用于维护此连接的所有资源，并关闭所有打开的连接配置文件。它可能会关闭底层JDBC连接，具体取决于是否指定了<code class="codeph">CLOSE_CONNECTION</code>或<code class="codeph">KEEP_CONNECTION</code> 。这些是<code class="codeph">ConnectionContext</code>接口的静态布尔常量。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">getConnection()</code> ：返回此连接上下文实例的基础JDBC连接对象。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">getExecutionContext()</code> ：返回此连接上下文实例的默认<code class="codeph">ExecutionContext</code>实例。
                              </p>
                              <div class="infoboxnotealso" id="GUID-50ACAE7A-118A-4D0B-B18B-03813798054C__GUID-90D1763B-32BA-49FF-AEE1-44A42096A270">
                                 <p class="notep1">也可以看看：</p>
                                 <p><span class="q">“ <a href="advanced-language-features.html#GUID-BC1805F7-AECB-4D97-B74C-1E0D71BDE603">执行上下文</a> ”</span></p>
                              </div>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-50ACAE7A-118A-4D0B-B18B-03813798054C__GUID-79031DD9-BCA2-49BB-94FF-F57E986DFF3B">附加连接上下文类方法</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>除了在<code class="codeph">ConnectionContext</code>接口中指定和定义的方法之外，每个连接上下文类还定义以下方法：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><span class="italic"><code class="codeph">YourCtxClass</code></span> <code class="codeph">getDefaultContext()</code> ：这是一个静态方法，它返回给定连接上下文类的默认连接上下文实例。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">setDefaultContext(</code> <span class="italic"><code class="codeph">YourCtxClass</code></span> <code class="codeph"> </code> <span class="italic"><code class="codeph">connctxinstance</code></span> <code class="codeph">)</code> ：这是一个静态方法，它将给定的连接上下文实例定义为其类的默认连接上下文实例。
                              </p>
                           </li>
                        </ul>
                        <p>虽然您只能使用<code class="codeph">DefaultContext</code>类的实例作为默认连接，但使用<code class="codeph">setDefaultContext()</code>方法将声明的连接上下文类的实例指定为该类的默认上下文可能仍然有用。然后，您可以使用特定类的<code class="codeph">getDefaultContext()</code>方法方便地检索它。例如，这将使您能够为SQLJ可执行语句指定连接上下文实例，如下所示：</p><pre class="oac_no_warn" dir="ltr">#sql context MyContext; ...MyContext myctx1 = new MyContext（ <span class="italic">url，user，password，autocommit</span> ）; ...MyContext.setDefaultContext（myctx1）; ...#sql [MyContext.getDefaultContext（）] { <span class="italic">SQL operations</span> }; ...
</pre><p>此外，每个连接上下文类都定义了控制SQLJ语句高速缓存的方法。以下是静态方法：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">setDefaultStmtCacheSize（INT）</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">int getDefaultStmtCacheSize（）</code></p>
                           </li>
                        </ul>
                        <p>以下是实例方法：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">setStmtCacheSize（INT）</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">int getStmtCacheSize（）</code></p>
                           </li>
                        </ul>
                        <p>默认情况下，启用语句缓存。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ507"></a><div class="props_rev_3"><a id="GUID-DBE080FD-E5E1-476B-8B7F-199D44C259BC" name="GUID-DBE080FD-E5E1-476B-8B7F-199D44C259BC"></a><h4 id="JSQLJ-GUID-DBE080FD-E5E1-476B-8B7F-199D44C259BC" class="sect4">在连接上下文声明中使用IMPLEMENTS子句</h4>
                  <div>
                     <p>在某些情况下，在连接上下文声明中实现接口很有用。例如，您可能希望定义一个仅公开连接上下文类的功能子集的接口。更具体地说，您可能需要具有<code class="codeph">getConnection()</code>功能但没有连接上下文类的其他功能的类。
                     </p>
                     <p>例如，您可以创建一个名为<code class="codeph">HasConnection</code>的接口，该接口指定<code class="codeph">getConnection()</code>方法，但不指定在连接上下文类中找到的其他方法。然后，您可以声明连接上下文类，但只通过将连接上下文实例分配给<code class="codeph">HasConnection</code>类型的变量而不是具有所声明的连接上下文类的类型的变量来公开<code class="codeph">getConnection()</code>功能。
                     </p>
                     <p>假设<code class="codeph">HasConnection</code>在<code class="codeph">mypackage</code>包中，声明如下：</p><pre class="oac_no_warn" dir="ltr">#sql public context MyContext实现mypackage。HasConnection;</pre><p>然后，您可以按如下方式实例化连接实例：</p><pre class="oac_no_warn" dir="ltr">HasConnection myConn = new MyContext（ <span class="italic">url</span> ， <span class="italic">username</span> ， <span class="italic">password，autocommit</span> ）;</pre><p>例如：</p><pre class="oac_no_warn" dir="ltr">HasConnection myConn = new MyContext（“jdbc：oracle：thin：@localhost：5221 / myservice”，“HR”，“hr”，true）;</pre></div>
               </div><a id="JSQLJ508"></a><div class="props_rev_3"><a id="GUID-186FBFAC-DA4B-4BA4-9B21-CBBFE8EB67F1" name="GUID-186FBFAC-DA4B-4BA4-9B21-CBBFE8EB67F1"></a><h4 id="JSQLJ-GUID-186FBFAC-DA4B-4BA4-9B21-CBBFE8EB67F1" class="sect4">语义 - 检查连接上下文使用情况</h4>
                  <div>
                     <div class="section">
                        <p>SQLJ的一个重要特性是强类型连接，每个连接上下文类通常用于特定的一组相互关联的SQL实体上的操作。这并不意味着单个类的所有连接实例都使用相同的物理实体。相反，它们使用具有相同属性的实体，例如与表和视图关联的名称和特权，其行的数据类型以及存储过程的名称和定义。这种强类型允许SQLJ语义检查在转换期间验证您正在使用SQL操作，与数据库连接有关。</p>
                        <p>要在转换期间使用联机语义检查，请为每个连接上下文类提供一个示例模式，其中包括一组适当的SQL实体。这些示例模式称为示例模式。通过SQLJ <code class="codeph">-user</code> ， <code class="codeph">-password</code>和<code class="codeph">-url</code>选项的适当组合提供示例模式。以下是两个示例，一个用于<code class="codeph">DefaultContext</code>类，另一个用于声明的连接上下文类，其中用户，密码和URL都通过<code class="codeph">-user</code>选项指定：</p><pre class="oac_no_warn" dir="ltr">-user = HR / hr @jdbc：oracle：oci：@ -user @ MyContext = HR / hr @jdbc：oracle：oci：@</pre><p>在语义检查期间，转换程序连接到特定连接上下文类的指定示例模式，并完成以下操作：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>它检查代码中的每个SQLJ语句，该语句指定连接上下文类的实例并检查其SQL操作，例如您访问的表以及您使用的存储过程。</p>
                           </li>
                           <li>
                              <p>它验证SQL操作中的实体是否与示例模式中存在的实体集匹配。</p>
                           </li>
                        </ul>
                        <p>您有责任选择以适当方式表示运行时模式的示例模式。例如，它必须具有表，视图，存储函数和存储过程，其名称和数据类型与SQL操作中使用的名称和数据类型相匹配，并且具有适当的权限。</p>
                        <p>如果在转换期间没有适当的示例模式可用于某个连接上下文类，则不必为该特定连接上下文类指定SQLJ转换器选项。在这种情况下，仅在可能的范围内语义检查指定该连接上下文类的连接对象的SQLJ语句。</p>
                        <div class="infoboxnote" id="GUID-186FBFAC-DA4B-4BA4-9B21-CBBFE8EB67F1__GUID-DEBBFCFC-1622-42D2-9EAD-34BEF758E92E">
                           <p class="notep1">注意：</p>
                           <p>请记住，您在转换程序选项设置中指定的示例模式未指定要在运行时使用的模式。示例模式仅为转换程序提供了一组SQL实体，以与您在SQLJ可执行语句中使用的实体进行比较。</p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ510"></a><a id="JSQLJ511"></a><a id="JSQLJ512"></a><a id="JSQLJ513"></a><a id="JSQLJ509"></a><div class="props_rev_3"><a id="GUID-BBB6A8DE-EEF3-454B-BF98-C12E32A81314" name="GUID-BBB6A8DE-EEF3-454B-BF98-C12E32A81314"></a><h4 id="JSQLJ-GUID-BBB6A8DE-EEF3-454B-BF98-C12E32A81314" class="sect4">标准数据源支持</h4>
                  <div>
                     <p>JDBC 2.0扩展应用程序编程接口（API）指定使用数据源和Java命名和目录接口（JNDI）作为获取JDBC连接的<code class="codeph">DriverManager</code>机制的可移植替代方法。它允许通过JNDI名称查找建立数据库连接。在程序运行时通过<code class="codeph">javax.sql.将此名称绑定到特定的数据库和模式<code class="codeph">javax.sql.DataSource</code>对象，通常通过图形用户界面（GUI）JavaBeans部署工具安装。只需通过重新绑定目录服务中的名称，即可将名称绑定到不同的物理连接，而无需更改任何源代码。
                     </p>
                     <p>SQLJ使用相同的机制以灵活和可移植的方式创建连接上下文实例。数据源也可以使用JDBC 2.0扩展API定义的连接池或分布式事务服务来实现。</p>
                     <div class="infoboxnotealso" id="GUID-BBB6A8DE-EEF3-454B-BF98-C12E32A81314__GUID-62C40DAA-B075-4215-86F3-02672587D93F">
                        <p class="notep1">也可以看看：</p>
                        <p><span class="italic"><a href="../jjdbc/data-sources-and-URLs.html#JJDBC-GUID-44572C63-10D2-478A-BB2E-ACF6674C59CC" target="_blank"><span><cite>Oracle数据库JDBC开发人员指南</cite></span></a></span></p>
                     </div>
                     <div class="section">
                        <p class="subhead3" id="GUID-BBB6A8DE-EEF3-454B-BF98-C12E32A81314__GUID-45B351FF-937F-415D-88F7-17BE5417A606">将连接上下文与数据源相关联</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>在SQLJ中，将连接上下文类与逻辑模式相关联是很自然的，就像数据源名称作为JDBC连接的符号名称一样。通过将数据源名称添加到连接上下文声明来组合这两个概念。例如：</p><pre class="oac_no_warn" dir="ltr">#sql context EmpCtx with（dataSource =“jdbc / EmpDB”）;</pre><p>使用<code class="codeph">dataSource</code>属性声明的任何连接上下文类都提供其他构造函数。要继续<code class="codeph">EmpCtx</code>示例，请提供以下构造函数：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">EmpCtx()</code> ：查找<code class="codeph">jdbc/EmpDB</code>的数据源，然后调用数据源上的<code class="codeph">getConnection()</code>方法以获取连接。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">EmpCtx(String user, String password)</code> ：查找<code class="codeph">jdbc/EmpDB</code>的数据源，并调用数据源上的<code class="codeph">getConnection(user,password)</code>方法以获取连接。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">EmpCtx(ConnectionContext ctx)</code> ：委托<code class="codeph">ctx</code>获取连接。
                              </p>
                           </li>
                        </ul>
                        <p>使用<code class="codeph">dataSource</code>属性声明的任何连接上下文类也省略了许多基于<code class="codeph">DriverManager</code>的构造函数。继续<code class="codeph">EmpCtx</code>示例，省略以下构造函数：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">EmpCtx（连接conn）</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">EmpCtx（String url，String user，String password，boolean autoCommit）</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">EmpCtx（String url，boolean autoCommit）</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">EmpCtx（String url，java.util。属性信息，布尔autoCommit）</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">EmpCtx（String url，boolean autoCommit）</code></p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-BBB6A8DE-EEF3-454B-BF98-C12E32A81314__GUID-7461EAE5-2788-4993-85CB-B77133B74C55">数据源连接的自动提交模式</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>与基于<code class="codeph">DriverManager</code>的构建器不同，基于数据源的构造函数不包含显式的自动提交参数。它们始终使用数据源定义的自动提交模式。
                        </p>
                        <p>根据部署方案，数据源配置为具有默认自动提交模式。例如，服务器和中间层中的数据源通常具有自动提交功能。客户端上的人可以使用它。但是，也可以使用特定的自动提交设置配置数据源。这允许为特定应用程序和部署方案配置数据源。将此与可能仅指定单个数据库/驱动程序配置的JDBC URL进行对比。</p>
                        <p>程序可以使用作为其连接上下文实例基础的JDBC连接来验证并可能覆盖当前的自动提交设置。</p>
                        <div class="infoboxnote" id="GUID-BBB6A8DE-EEF3-454B-BF98-C12E32A81314__GUID-5862CCBB-C2EB-4542-A78D-CD1092B83AF0">
                           <p class="notep1">注意：</p>
                           <p>请注意以下与您建立的连接的自动提交状态相关的要点：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>如果您使用<code class="codeph">Oracle</code>类，则除非您明确打开它，否则自动提交将关闭。
                                 </p>
                              </li>
                              <li>
                                 <p>如果将<code class="codeph">DefaultContext</code>或连接上下文类与<code class="codeph">DriverManager</code> style构造函数一起使用，则必须始终明确指定自动提交设置。
                                 </p>
                              </li>
                              <li>
                                 <p>如果使用数据源机制，则自动提交设置将从基础数据源继承。在大多数环境中，数据源对象源自JDBC，并且启用了自动提交选项。为避免意外行为，请始终检查自动提交设置。</p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-BBB6A8DE-EEF3-454B-BF98-C12E32A81314__GUID-C5C42120-10E9-478E-BC61-B6D70DF871A7">将数据源与默认上下文相关联</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>如果SQLJ程序访问默认连接上下文，并且尚未设置默认上下文，则SQLJ运行时将使用SQLJ默认数据源来建立其连接。SQLJ缺省数据源绑定到JNDI名称<code class="codeph">jdbc/defaultDataSource</code> 。
                        </p>
                        <p>此机制提供了一种可移植方法，用于为默认SQLJ连接上下文定义和安装默认JDBC连接。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-BBB6A8DE-EEF3-454B-BF98-C12E32A81314__GUID-4F4371B0-BF40-452F-91D8-0E31D9965AEF">数据源支持要求</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>要使程序使用数据源，必须在Java环境中提供<code class="codeph">javax.sql.*</code>和<code class="codeph">javax.naming.*</code>包以及<code class="codeph">InitialContext</code>提供程序。后者需要获取JNDI上下文，其中SQLJ运行时可以查找数据源对象。
                        </p>
                        <p>Oracle提供的所有SQLJ运行时库都支持数据源。但是，如果使用<code class="codeph">runtime12ee</code>库，则必须在类路径中使用<code class="codeph">javax.sql.*</code>和<code class="codeph">javax.naming.*</code>才能加载运行时。相比之下，其他运行时库使用反射来检索<code class="codeph">DataSource</code>对象。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ515"></a><a id="JSQLJ516"></a><a id="JSQLJ517"></a><a id="JSQLJ514"></a><div class="props_rev_3"><a id="GUID-861032F9-E30B-4765-9BD6-12CCF54D2D75" name="GUID-861032F9-E30B-4765-9BD6-12CCF54D2D75"></a><h4 id="JSQLJ-GUID-861032F9-E30B-4765-9BD6-12CCF54D2D75" class="sect4">SQLJ特定的数据源</h4>
                  <div>
                     <div class="section">
                        <p>Oracle SQLJ实现在<code class="codeph">runtime12ee</code>库中提供特定于SQLJ的数据源支持。目前，SQLJ特定的数据源可用于客户端或中间层应用程序，但不能用于服务器内部。
                        </p>
                        <p>SQLJ特定的数据源使用返回SQLJ连接上下文实例的方法扩展JDBC数据源功能。这使得SQLJ开发人员能够像JDBC开发人员管理连接一样管理连接上下文。通常，每个特定于SQLJ的数据源接口或类都基于相应的标准JDBC数据源接口或Oracle数据源类。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-861032F9-E30B-4765-9BD6-12CCF54D2D75__GUID-FBCC4E11-8F48-4663-BF27-A5B6D69973CE">SQLJ数据源接口</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p><code class="codeph">sqlj.runtime.ConnectionContextFactory</code>接口充当SQLJ数据源功能的基础接口。它由一组更专业的Oracle数据源接口实现，这些接口增加了对连接池，连接缓存或分布式事务等功能的支持。
                        </p>
                        <p><code class="codeph">ConnectionContextFactory</code>接口指定以下方法来返回SQLJ连接上下文实例：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">DefaultContext getDefaultContext（）</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">DefaultContext getDefaultContext（boolean autoCommit）</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">DefaultContext getDefaultContext（String user，String password）</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">DefaultContext getDefaultContext（String user，String password，boolean autoCommit）</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">ConnectionContext getContext（Class aContextClass）</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">ConnectionContext getContext（Class aContextClass，boolean autoCommit）</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">ConnectionContext getContext（类aContextClass，String user，String password）</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">ConnectionContext getContext（类aContextClass，String user，String password，boolean autoCommit）</code></p>
                           </li>
                        </ul>
                        <p><code class="codeph">getDefaultContext</code>方法返回<code class="codeph">sqlj.runtime.ref.SQLJ默认上下文的DefaultContext</code>实例。<code class="codeph">getContext()</code>方法返回<code class="codeph">sqlj.runtime.ConnectionContext</code>实例。具体来说，它返回在方法调用中指定的用户声明的连接上下文类的实例。
                        </p>
                        <p>对于<code class="codeph">getDefaultContext()</code>和<code class="codeph">getContext()</code> ，有一些签名使您能够为连接上下文实例的基础JDBC连接指定连接参数：自动提交设置，用户和密码设置或全部三个。如果未指定用户和密码，则从生成连接的基础数据源获取它们。如果未指定自动提交设置，则默认值为<code class="codeph">false</code>除非为基础数据源显式设置为<code class="codeph">true</code> 。
                        </p>
                        <p>实现<code class="codeph">ConnectionContextFactory</code>每个Oracle数据源接口还实现标准JDBC数据源接口，以指定适当功能的方法，例如基本数据源，连接池数据源或分布式事务（XA）数据源。Oracle已经实现了<code class="codeph">SqljDataSource</code> ， <code class="codeph">SqljConnectionPoolDataSource</code>和<code class="codeph">SqljXADataSource</code>接口，它们位于<code class="codeph">sqlj.runtime</code>包中，并指定如下：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">接口SqljDataSource扩展了javax.sql。DataSource，ConnectionContextFactory {}</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">接口SqljDataSource扩展了javax.sql。ConnectionPoolDataSource，ConnectionContextFactory {}</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">接口SqljXADataSource扩展了javax.sql。XADataSource，ConnectionContextFactory {}</code></p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-861032F9-E30B-4765-9BD6-12CCF54D2D75__GUID-DF84B27E-A754-4FF1-B008-886DC399D0A4">SQLJ数据源类</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>Oracle为以下JDBC数据源的类特定SQLJ-同行： <code class="codeph">OracleDataSource</code> ， <code class="codeph">OracleConnectionPoolDataSource</code> ， <code class="codeph">OracleXADataSource</code> ， <code class="codeph">OracleConnectionCacheImpl</code> ， <code class="codeph">OracleXAConnectionCacheImpl</code> ，和<code class="codeph">OracleOCIConnectionPool</code> 。
                        </p>
                        <div class="infoboxnotealso" id="GUID-861032F9-E30B-4765-9BD6-12CCF54D2D75__GUID-BE239C0B-0DAB-41BC-9970-D90C51D2D799">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="../jjdbc/JDBC-support-Oracle-FAN.html#JJDBC-GUID-069265AF-BBEE-4682-9906-98D8429BFC1C" target="_blank"><span class="italic">Oracle数据库JDBC开发人员指南</span></a></p>
                        </div>
                        <p>Oracle SQLJ特定的数据源类位于两个包中： <code class="codeph">oracle.sqlj.runtime</code>和<code class="codeph">oracle.sqlj.runtime.client</code> 。
                        </p>
                        <p><code class="codeph">oracle.sqlj.runtime</code>包中包含以下内容：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">class OracleSqljDataSource扩展了oracle.jdbc.pool。OracleDataSource实现了ConnectionContextFactory</code></p>
                           </li>
                        </ul>
                        <div class="infoboxnote" id="GUID-861032F9-E30B-4765-9BD6-12CCF54D2D75__GUID-4B2EC029-EBF1-4BDD-8E4F-2C1FE1C1720B">
                           <p class="notep1">注意：</p>
                           <p><code class="codeph">OracleSqljDataSource</code>类实现<code class="codeph">java.io.Serializable</code>界面。因此，它是可序列化的，可用于集群环境，例如Oracle9 <span class="italic">i</span> Application Server Containers for J2EE（OC4J）。
                           </p>
                        </div>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">class OracleSqljConnectionPoolDataSource扩展了oracle.jdbc.pool。OracleConnectionPoolDataSource实现ConnectionContextFactory</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">抽象类OracleSqljXADataSource扩展了oracle.jdbc.xa。OracleXADataSource实现了ConnectionContextFactory</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">class OracleSqljConnectionCacheImpl扩展了oracle.jdbc.pool。OracleConnectonCacheImpl实现了ConnectionContextFactory</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">class OracleSqljXAConnectionCacheImpl扩展了oracle.jdbc.pool。OracleXAConnectonCacheImpl实现了ConnectionContextFactory</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">class OracleSqljOCIConnectionPool扩展了oracle.jdbc.pool。OracleOCIConnectionPool实现ConnectionContextFactory</code></p>
                           </li>
                        </ul>
                        <div class="infoboxnote" id="GUID-861032F9-E30B-4765-9BD6-12CCF54D2D75__GUID-CCD4E6F2-3D03-476F-BCB0-81B53D52BFE4">
                           <p class="notep1">注意：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>如果您使用的是<code class="codeph">OracleSqljConnectionCacheImpl</code> ，则需要将其替换为<code class="codeph">OracleSqljDataSource</code> 。
                                 </p>
                              </li>
                              <li>
                                 <p>如果您使用的是<code class="codeph">OracleSqljXAConnectionCacheImpl</code> ，则需要将其替换为<code class="codeph">OracleSqljXADataSource</code> 。
                                 </p>
                              </li>
                           </ul>
                        </div>
                        <p><code class="codeph">oracle.sqlj.runtime.client</code>包中包含以下内容：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">class OracleSqljXADataSource扩展了oracle.jdbc.xa.client。OracleXADataSource实现了ConnectionContextFactory</code></p>
                           </li>
                        </ul>
                        <p>您可以使用这些类代替它们扩展的相应JDBC类。它们包括<code class="codeph">getDefaultContext()</code>和<code class="codeph">getContext()</code>方法。当您调用这些方法时，会执行以下步骤：</p>
                        <ol>
                           <li>
                              <p>从当前数据源获取新的逻辑JDBC连接。</p>
                           </li>
                           <li>
                              <p>从逻辑连接创建连接上下文实例并返回。</p>
                           </li>
                        </ol>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-861032F9-E30B-4765-9BD6-12CCF54D2D75__GUID-5AFFB2E6-73DA-41CA-9DD6-B8512976A7B2">示例：使用SQLJ数据源</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>在中间层环境中使用时，SQLJ特定的数据源（如JDBC数据源）将绑定到JNDI位置。您可以显式执行绑定，如以下示例所示：</p><pre class="oac_no_warn" dir="ltr">//初始化数据源SqljXADataSource sqljDS = new OracleSqljXADataSource（）; sqljDS.setUser（ “HR”）; sqljDS.setPassword（ “HR”）; sqljDS.setServerName（ “MYSERVER”）; sqljDS.setDatabaseName（ “ORCL”）; sqljDS.setDataSourceName（ “JDBC / OracleSqljXADS”）; //将数据源绑定到JNDI上下文ctx = new InitialContext（）;起来ctx.bind（ “JDBC / OracleSqljXADS”）;</pre><p>在中间层OC4J环境中，另一种方法是实例化数据源并通过<code class="codeph">j2ee/home/config/data-sources.xml</code>文件中的设置将它们绑定到JNDI。例如，该文件中的以下<code class="codeph">&lt;data-source&gt;</code>元素创建<code class="codeph">OracleSqljXADataSource</code>实例并将其绑定到JNDI位置<code class="codeph">jdbc/OracleSqljXADS</code> ：</p><pre class="oac_no_warn" dir="ltr">&lt;data-source class =“oracle.sqlj.runtime。OracleSqljXADataSource“name =”jdbc / OracleSqljXADS“location =”jdbc / OracleSqljXADS“xa-location =”jdbc / OracleSqljXADS / xa“username =”HR“password =”hr“url =”jdbc：oracle：thin：@myhost：5221 / myservice“/&gt;</pre><p>可以查找绑定到JNDI位置的SQLJ特定数据源，并将其用于创建连接上下文实例。以下代码段使用前面<code class="codeph">&lt;data-source&gt;</code>元素中的信息分别创建连接上下文实例， <code class="codeph">DefaultContext</code>实例和用户声明的<code class="codeph">MyCtx</code>类的实例：</p><pre class="oac_no_warn" dir="ltr">sqlj.runtime。sqljDataSource sqljDS; InitialContext initCtx = new InitialContext（）; sqljDS =（sqlj.runtime。SqljDataSource）initCtx.lookup（ “JDBC / OracleSqljXADS”）; // getDefaultContext DefaultContext ctx = sqljDS.getDefaultContext（）; // getContext / *声明MyCtx连接上下文类。您可以选择使用“with”子句来指定通过基础数据源不可用的任何所需连接参数。* / #sql public static context MyCtx; MyCtx ctx =（MyCtx）sqljDS.getContext（MyCtx.class）;</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ519"></a><a id="JSQLJ520"></a><a id="JSQLJ521"></a><a id="JSQLJ518"></a><div class="props_rev_3"><a id="GUID-51755815-E5DB-41A3-8427-8969A0B90404" name="GUID-51755815-E5DB-41A3-8427-8969A0B90404"></a><h4 id="JSQLJ-GUID-51755815-E5DB-41A3-8427-8969A0B90404" class="sect4">用于JavaServer Pages的SQLJ特定连接JavaBeans</h4>
                  <div>
                     <p>Oracle已经在Java Server Pages（JSP）页面中为数据库连接实现了一组JavaBeans。</p>
                     <p>Oracle SQLJ实现在<code class="codeph">runtime12ee</code>库中提供了以下JavaBeans的扩展，以便在SQLJ JSP页面中使用：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">oracle.sqlj.runtime。SqljConnBean</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">oracle.sqlj.runtime。SqljConnCacheBean</code></p>
                        </li>
                     </ul>
                     <p><code class="codeph">ConnBean</code>和<code class="codeph">ConnCacheBean</code>包含返回JDBC连接对象的方法。<code class="codeph">SqljConnBean</code>和<code class="codeph">SqljConnCacheBean</code>扩展此功能以支持名为<code class="codeph">ContextClass</code>类型为<code class="codeph">String</code>的bean属性并返回SQLJ连接上下文实例。
                     </p>
                     <div class="infoboxnote" id="GUID-51755815-E5DB-41A3-8427-8969A0B90404__GUID-BBB8AFC1-7E8B-428F-A5B4-F0E888C9035B">
                        <p class="notep1">注意：</p>
                        <p><code class="codeph">SqljConnBean</code>类实现<code class="codeph">java.io.Serializable</code>界面。因此它是可序列化的，可以在集群环境中使用，例如OC4J。</p>
                     </div>
                     <p><code class="codeph">SqljConnBean</code>和<code class="codeph">SqljConnCacheBean</code>提供以下方法：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">void setContextClass（String contextClassName）</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">String getContextClass（）</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">DefaultContext getDefaultContext（）</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">ConnectionContext getContext（）</code></p>
                        </li>
                     </ul>
                     <p>如果您不使用<code class="codeph">DefaultContext</code> ， <code class="codeph">ContextClass</code>属性指定用户声明的连接上下文类的名称。您可以通过<code class="codeph">setContextClass()</code>方法设置此属性。
                     </p>
                     <p>要检索连接上下文实例，请根据需要使用<code class="codeph">getDefaultContext()</code>或<code class="codeph">getContext()</code> 。前者返回<code class="codeph">sqlj.runtime.ref.DefaultContext</code>实例，后者返回<code class="codeph">sqlj.runtime.ConnectionContext</code>实例，具体而言，是<code class="codeph">ContextClass</code>属性中指定的类的实例（默认情况下为<code class="codeph">DefaultContext</code> ）。
                     </p>
                     <p>但是，请注意，在<code class="codeph">SqljConnBean</code>和<code class="codeph">SqljConnCacheBean</code>之间， <code class="codeph">getDefaultContext()</code>和<code class="codeph">getContext()</code>方法的实现方式不同。
                     </p>
                     <div class="section">
                        <p class="subhead3" id="GUID-51755815-E5DB-41A3-8427-8969A0B90404__GUID-11696AA5-2A6E-4787-9A24-534E6ED5503A">SqljConnBean的行为（简单连接）</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p><code class="codeph">SqljConnBean</code>实例在任何给定时间只能包装一个逻辑JDBC连接和一个SQLJ连接上下文实例。
                        </p>
                        <p>第一个<code class="codeph">getDefaultContext()</code>或<code class="codeph">getContext()</code>方法调用将基于底层JDBC连接创建并返回连接上下文实例。此连接上下文实例也将存储在<code class="codeph">SqljConnBean</code>实例中。
                        </p>
                        <p>一旦创建并存储了连接上下文实例，后续<code class="codeph">getDefaultContext()</code>或<code class="codeph">getContext()</code>调用的行为将取决于存储的连接上下文的类型，对于<code class="codeph">getContext()</code> ，取决于<code class="codeph">ContextClass</code>属性中指定的连接上下文类型， 如下：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>对于后续的<code class="codeph">getDefaultContext()</code>调用：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>如果存储的连接上下文实例是<code class="codeph">DefaultContext</code>实例：该方法将继续返回该实例。
                                    </p>
                                 </li>
                                 <li>
                                    <p>如果存储的连接上下文实例<span class="italic">不是</span> <code class="codeph">DefaultContext</code>实例：该方法将关闭存储的连接上下文实例并重用底层JDBC连接以创建新连接上下文并将其作为<code class="codeph">DefaultContext</code>实例返回（无论先前的连接上下文类型如何）。这将成为存储在<code class="codeph">SqljConnBean</code>实例中的新连接上下文实例。
                                    </p>
                                 </li>
                              </ul>
                           </li>
                           <li>
                              <p>对于后续的<code class="codeph">getContext()</code>调用：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>如果存储的连接上下文实例与<code class="codeph">ContextClass</code>属性指定的类型相同：该方法将继续返回该实例。
                                    </p>
                                 </li>
                                 <li>
                                    <p>如果存储的连接上下文实例是同样的类型由指定的<span class="italic">不</span> <code class="codeph">ContextClass</code> ：该方法将关闭存储的连接上下文实例和重用底层的JDBC连接，以创建并返回一个新的连接上下文实例，什么是在指定的一个实例<code class="codeph">ContextClass</code> 。这将成为存储在<code class="codeph">SqljConnBean</code>实例中的新连接上下文实例。
                                    </p>
                                 </li>
                              </ul>
                           </li>
                        </ul>
                        <div class="infoboxnote" id="GUID-51755815-E5DB-41A3-8427-8969A0B90404__GUID-77F1FD48-462D-42E6-95BA-F79F499B96DA">
                           <p class="notep1">注意：</p>
                           <p>当<code class="codeph">SqljConnBean</code>关闭连接上下文实例时，它使用<code class="codeph">KEEP_CONNECTION</code>设置执行此操作，保持底层JDBC连接不变。
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-51755815-E5DB-41A3-8427-8969A0B90404__GUID-6948CC15-2E02-4A7E-89FD-520AE7BEEAC5">SqljConnCacheBean的行为（连接缓存）</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>与<code class="codeph">SqljConnBean</code>不同， <code class="codeph">SqljConnCacheBean</code> JavaBean在每次调用<code class="codeph">getDefaultContext()</code>或<code class="codeph">getContext()</code> ，基于新的逻辑JDBC连接创建并返回一个新的连接上下文实例。连接上下文类型将是<code class="codeph">getDefaultContext()</code>调用的<code class="codeph">DefaultContext</code>或<code class="codeph">getContext()</code>调用的<code class="codeph">ContextClass</code>属性中指定的类型。
                        </p>
                        <p><code class="codeph">SqljConnCacheBean</code>不存储它创建的连接上下文实例。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-51755815-E5DB-41A3-8427-8969A0B90404__GUID-0EC57B36-69AF-4EE6-9684-2CA57AA6A3C2">示例：使用SqljConnCacheBean的SQLJ JSP页面</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>以下程序<code class="codeph">SQLJSelectInto.sqljsp</code>演示了<code class="codeph">SqljConnCacheBean</code>及其<code class="codeph">ContextClass</code> bean属性及其<code class="codeph">getContext()</code>方法的用法：</p><pre class="oac_no_warn" dir="ltr">&lt;％@ page language =“sqlj”import =“java.sql。*，oracle.sqlj.runtime。SqljConnCacheBean“％&gt; &lt;jsp：useBean id =”cbean“class =”oracle.sqlj.runtime。SqljConnCacheBean“scope =”session“&gt; &lt;jsp：setProperty name =”cbean“property =”User“value =”HR“/&gt; &lt;jsp：setProperty name =”cbean“property =”Password“value =”hr“/&gt; &lt;jsp：setProperty name =“cbean”property =“URL”value =“jdbc：oracle：thin：@ myhost：5221 / myservice”/&gt; &lt;jsp：setProperty name =“cbean”property =“ContextClass”value =“sqlj .runtime.ref。DefaultContext“/&gt; &lt;/ jsp：useBean&gt; &lt;HTML&gt; &lt;HEAD&gt; &lt;TITLE&gt; SQLJSelectInto JSP &lt;/ TITLE&gt; &lt;/ HEAD&gt; &lt;BODY BGCOLOR = white&gt; &lt;％String empno = request.getParameter（”employee_id“）;如果（empno！= null）{％&gt; &lt;H3&gt;员工＃&lt;％= empno％&gt;详细信息：&lt;/ H3&gt; &lt;％String ename = null; double sal = 0.0; String hireDate = null; StringBuffer sb = new StringBuffer（）; sqlj.runtime.ref。DefaultContext ctx = null; try {//使连接ctx =（sqlj.runtime.ref。DefaultContext）cbean.getContext（）; } catch（SQLException e）{} try {#sql [ctx] {SELECT first_name，salary，TO_CHAR（hire_date，'DD-MON-YYYY'）INTO：ename，：sal，：hireDate FROM HR.employees WHERE UPPER（employee_id ）= UPPER（：empno）}; sb.append（ “&lt;BLOCKQUOTE&gt; &lt;BIG&gt; &lt;B&gt; &lt;PRE&gt; \ n”）; sb.append（“姓名：”+ ename +“\ n”）; sb.append（“薪水：”+ sal +“\ n”）; sb.append（“雇用日期：”+ hireDate）; sb.append（ “&lt;/ PRE&gt; &lt;/ B&gt; &lt;/ BIG&gt; &lt;/ BLOCKQUOTE&gt;”）; } catch（java.sql。SQLException e）{sb.append（“&lt;P&gt; SQL错误：&lt;PRE&gt;”+ e +“&lt;/ PRE&gt; &lt;/ P&gt; \ n”）; }终于{if（ctx！= null）ctx.close（）; }％&gt; &lt;H3&gt; &lt;％= sb.toString（）％&gt; &lt;/ H3&gt; &lt;％}％&gt; &lt;B&gt;输入员工编号：&lt;/ B&gt; &lt;FORM METHOD = get&gt; &lt;INPUT TYPE =“text” NAME =“empno”SIZE = 10&gt; &lt;INPUT TYPE =“submit”VALUE =“Ask Oracle”）; &lt;/ FORM&gt; &lt;/ BODY&gt; &lt;/ HTML&gt;</pre><div class="infoboxnote" id="GUID-51755815-E5DB-41A3-8427-8969A0B90404__GUID-68B47675-DB96-4AC7-A297-D8D616E8B2F6">
                           <p class="notep1">注意：</p>
                           <p>此示例使用<code class="codeph">ContextClass</code>属性进行说明。但是，请注意<code class="codeph">DefaultContext</code>是默认值，如果要使用<code class="codeph">DefaultContext</code> ，那么如果使用<code class="codeph">getDefaultContext()</code>而不是<code class="codeph">getContext()</code> ，则<code class="codeph">ContextClass</code>的值无关紧要。
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ523"></a><a id="JSQLJ524"></a><a id="JSQLJ525"></a><a id="JSQLJ526"></a><a id="JSQLJ527"></a><a id="JSQLJ528"></a><a id="JSQLJ529"></a><a id="JSQLJ530"></a><a id="JSQLJ531"></a><a id="JSQLJ532"></a><a id="JSQLJ533"></a><a id="JSQLJ522"></a><div class="props_rev_3"><a id="GUID-02D73030-0352-4669-9152-0A331260FBC8" name="GUID-02D73030-0352-4669-9152-0A331260FBC8"></a><h4 id="JSQLJ-GUID-02D73030-0352-4669-9152-0A331260FBC8" class="sect4">SQLJ支持全局事务</h4>
                  <div>
                     <p>分布式事务（有时称为全局事务）是一组必须以协调方式管理的两个或多个相关事务。构成分布式事务的事务可能位于同一数据库中，但更常见的是位于不同的数据库中，并且通常位于不同的位置。分布式事务的每个单独事务称为事务分支。</p>
                     <p>X / Open分布式事务处理（DTP）体系结构定义了一种标准体系结构，该体系结构允许属于同一资源管理器或不同资源管理器的多个但相关的事务作为单个单元工作。它协调应用程序（AP）和资源管理器（RM）之间的工作到全局事务。提交或回滚所有事务。</p>
                     <p>Oracle XA库是一个外部接口，它使Oracle服务器以外的事务管理器能够协调全局事务。XA库使用支持分布式事务中的非Oracle资源管理器。这在多个数据库和资源之间的事务中特别有用。Oracle XA库的实现符合X / Open分布式事务处理（DTP）软件架构的XA接口规范。Oracle XA库作为Oracle数据库企业版的一部分安装。</p>
                     <div class="infoboxnote" id="GUID-02D73030-0352-4669-9152-0A331260FBC8__GUID-6F94CB5F-4EAE-4585-98C4-04D4D35BBA76">
                        <p class="notep1">注意：</p>
                        <p></p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>JDBC提供了几个类和接口来支持XA。 OracleXADataSource实现了<code class="codeph">XADataSource</code>接口。OracleXADatasource是XA连接的工厂。有关更多信息，请参阅<span class="italic">Oracle Database JDBC Developer's Guide</span> 。
                              </p>
                           </li>
                           <li>
                              <p>本文档明确指出了SQLJ支持在XA应用程序中形成连接上下文的方法。为了形成连接上下文，SQLJ使用从OracleXADataSource形成的JDBC连接。</p>
                           </li>
                        </ul>
                     </div>
                     <div class="figure" id="GUID-02D73030-0352-4669-9152-0A331260FBC8__GUID-4936CC72-C051-486F-BA48-6A46F19D4DE5">
                        <p class="titleinfigure">图8-1全局事务</p><img src="img/connection_context.gif" alt="下面是图8-1的描述" title="下面是图8-1的描述" longdesc="img_text/connection_context.html"><br><a href="img_text/connection_context.html">“图8-1全局交易”的描述</a></div>
                     <!-- class="figure" -->
                     <p>以下是分布式事务处理（DTP）模型的示例：</p>
                     <p><span class="bold">事务管理器</span>是驻留在Oracle数据库之外的外部中间层组件。它提供了一个API，用于指定事务的边界并管理提交和恢复。TM实现了两阶段提交引擎，以在分布式RM之间提供<span class="italic">全有或全无</span>语义。</p>
                     <p><span class="bold">资源管理器</span>控制共享的可恢复资源，该资源可在失败后返回到一致状态。例如，Oracle是资源管理器。
                     </p>
                     <p><code class="codeph">javax.sql.XADataSource</code>接口概述了XA数据源的标准功能。XA数据源是XA连接的工厂。Oracle JDBC通过OracleXADatasource类实现<code class="codeph">XADataSource</code>接口。OracleXADatasource类的<code class="codeph">getConnection( )</code>方法返回与底层数据源的XA连接。在SQLJ中，可以通过<code class="codeph">DefaultContext</code>类或<code class="codeph">ConnectionContext</code>类获取与数据库的<code class="codeph">ConnectionContext</code> 。对于使用不同SQL实体的多个连接，使用连接上下文声明来定义其他连接上下文类是有利的。
                     </p>
                     <p>代码片段显示了如何首先创建<code class="codeph">XADatasource</code> ，然后通过以下步骤从数据源创建JDBC连接：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>启动XA Resource1</p>
                        </li>
                        <li>
                           <p>启动XA Resource2</p>
                        </li>
                        <li>
                           <p>使用第一个Connection对象执行DML操作</p>
                        </li>
                        <li>
                           <p>结束XA资源1</p>
                        </li>
                        <li>
                           <p>结束XA资源2</p>
                        </li>
                        <li>
                           <p>准备资源1</p>
                        </li>
                        <li>
                           <p>准备资源2</p>
                        </li>
                        <li>
                           <p>承诺1</p>
                        </li>
                        <li>
                           <p>承诺2</p>
                        </li>
                     </ul>
                     <div class="infoboxnote" id="GUID-02D73030-0352-4669-9152-0A331260FBC8__GUID-22BF6171-EBE0-4D1B-912A-13B51C1CB927">
                        <p class="notep1">注意：</p>
                        <p>以下不是一个完整的示例，仅包含用于创建和使用<code class="codeph">XADatasource</code>相关代码。
                        </p>
                     </div>
                     <div class="section">
                        <p class="subhead3" id="GUID-02D73030-0352-4669-9152-0A331260FBC8__GUID-AD1B6EA7-CA83-4E58-9002-098477294E99">示例：创建XADatasource并使用它来创建JDBC连接</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section"><pre class="oac_no_warn" dir="ltr">import javax.sql。*; import javax.transaction。*; import javax.transaction.xa。*; ...import oracle.jdbc.driver。*; import oracle.jdbc.xa。OracleXid; import oracle.jdbc.xa。OracleXAException; import oracle.jdbc.xa.client。*; ............ #sql context MyContext; #sql iterator Iterator2（String job_id，String job_title）; #sql iterator Iterator3（String region_id，String region_name）; ............类XA3mod {public static void main（String args []）抛出SQLException {try { <span class="bold">/ *创建一个XADataSource实例* /</span> OracleXADataSource oxds = new OracleXADataSource（）; oxds.setURL（URL）; oxds.setUser（ “HR”）; oxds.setPassword（ “HR”）; <span class="bold">/ *获取与底层数据源* /</span> javax.sql <span class="bold">的XA连接</span> 。XAConnection pc1 = oxds.getXAConnection（）; <span class="bold">/ *使用相同的数据源* /</span> javax.sql。XAConnection pc2 = oxds.getXAConnection（）; <span class="bold">/ *获取物理连接* /</span> java.sql。连接conn1 = pc1.getConnection（）; java.sql中。连接conn2 = pc2.getConnection（）; <span class="bold">/ *应用程序可以通过多个数据库连接访问数据。每个数据库连接都</span> <span class="bold">作为事务资源与事务管理器一起 登记</span> <span class="bold">。事务管理器</span> <span class="bold">为参与全局事务的每个连接</span> 获取XAResource</span> <span class="bold">* /</span> XAResource oxar1 = pc1.getXAResource（）; XAResource oxar2 = pc2.getXAResource（）; <span class="bold">/ *使用相同的全局ID创建Xids。Xid接口是X / Open事务</span> <span class="bold">标识符XID结构</span> 的Java映射</span> <span class="bold">* /</span> Xid xid1 = createXid（1）; Xid xid2 = createXid（2）; <span class="bold">/ *启动资源。这将代表xid1和xid2中指定的事务分支开始工作。</span>
<span class="bold">事务管理器使用start方法将全局事务与资源相关联，</span> <span class="bold">并使用end方法将事务与资源* /</span> oxar1.start（xid1，XAResource） <span class="bold">取消关联</span> 。TMNOFLAGS）; oxar2.start（xid2，XAResource。TMNOFLAGS）; <span class="bold">/ *使用conn1 * /</span> DoSomeWork（conn1） <span class="bold">执行某些操作</span> ; <span class="bold">/ *结束两个分支* /</span> xar1.end（xid1，XAResource。TMSUCCESS）; xar2.end（xid2，XAResource。TMSUCCESS）; <span class="bold">/ *准备RM。 Oracle XA库接口遵循两阶段提交协议。准备事务</span> <span class="bold">是此协议的第一步。两个阶段提交协议在术语表部分中详细说明。* /</span> int prp1 = oxar1.prepare（xid1）; int prp2 = oxar2.prepare（xid2）; boolean do_commit = true;如果（！（（PRP1 == XA资源。XA_OK）||（PRP-== XA资源。XA_RDONLY）））do_commit = false;如果（！（（prp2 == XA资源。XA_OK）||（prp2 == XA资源。XA_RDONLY）））do_commit = false; <span class="bold">/ *仅在所有事务完成且没有和错误时才对所有事务发出提交。即使</span> <span class="bold">单个事务失败 也会回滚</span> <span class="bold">。* /</span> if（prp1 == XAResource。XA_OK）if（do_commit）oxar1.commit（xid1，false）; else oxar1.rollback（xid1）; if（prp2 == XAResource。XA_OK）if（do_commit）oxar2.commit（xid2，false）; else oxar2.rollback（xid2）; <span class="bold">/ * close connections * /</span> conn1.close（）; conn1 = null; conn2.close（）; conn2 = null; pc1.close（）; pc1 = null; pc2.close（）; pc2 = null; } catch（XAException xae）{if（xae instanceof OracleXAException）{System.out.println（“XA Error is”+（（OracleXAException）xae）.getXAError（））; System.out.println（“SQL Error is”+（（OracleXAException）xae）.getOracleError（））; } //}结束类</pre><p>以下示例说明了可以接受从OracleXADatasource获取的JDBC连接的不同SQLJ方法。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-02D73030-0352-4669-9152-0A331260FBC8__GUID-524405F0-0621-4214-B5DB-DE6B5CBADD3F">将Oracle.connect（）方法与从XA数据源获得的JDBC连接一起使用：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section"><pre class="oac_no_warn" dir="ltr">private static void DoSomeWork（java.sql。连接conn）抛出SQLException {String chr =“XA_CERT”; Oracle.connect（conn）;在#sql {insert into xa_test values（1，：chr）};尝试{Iterator3 iter = null; #sql iter = {SELECT id，name FROM xa_test}; while（iter.next（））{System.out.print（iter.id（））; System.out.print（“”）;的System.out.println（iter.name（））; catch（Exception e）{System.out.println（e）; e.printStackTrace（）; }}</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-02D73030-0352-4669-9152-0A331260FBC8__GUID-0DB882A5-6A0F-4A8D-9286-F5D165CAFE96">将Oracle.getConnection（）方法与从XA数据源获取的JDBC连接一起使用</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section"><pre class="oac_no_warn" dir="ltr">private static void DoSomeWork（java.sql。连接conn）抛出SQLException {String chr =“XA_CERT”; DefaultContext ctx = Oracle.getConnection（conn）; #sql [ctx] {insert into xa_test values（1，：chr）};尝试{Iterator3 iter = null; #sql [ctx] iter = {SELECT id，name FROM xa_test}; while（iter.next（））{System.out.print（iter.id（））; System.out.print（“”）;的System.out.println（iter.name（））; catch（Exception e）{System.out.println（e）; e.printStackTrace（）; }}</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-02D73030-0352-4669-9152-0A331260FBC8__GUID-6EA7A070-B3A7-4894-AAF6-17AE6A6FB145">使用带有从XA数据源获取的JDBC连接的DefaultContext构造函数</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section"><pre class="oac_no_warn" dir="ltr">private static void DoSomeWork（java.sql。连接conn）抛出SQLException {String chr =“XA_CERT”; DefaultContext ctx = new DefaultContext（conn）#sql [ctx] {insert into xa_test values（1，：chr）};尝试{Iterator3 iter = null; #sql [ctx] iter = {SELECT id，name FROM xa_test}; while（iter.next（））{System.out.print（iter.id（））; System.out.print（“”）;的System.out.println（iter.name（））; catch（Exception e）{System.out.println（e）; e.printStackTrace（）; }}</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-02D73030-0352-4669-9152-0A331260FBC8__GUID-4A823490-533C-4DD0-A6C7-7043C6FC6613">通过将ConnectionContext传递给它来使用DefaultContext构造函数。ConnectionContext是通过从XA数据源获得的JDBC连接创建的</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section"><pre class="oac_no_warn" dir="ltr">private static void DoSomeWork（java.sql。连接conn）抛出SQLException {String chr =“XA_CERT”; MyContext myctx1 = new MyContext（conn）; DefaultContext ctx = new DefaultContext（myctx1）; #sql [ctx] {insert into xa_test values（1，：chr）};尝试{Iterator3 iter = null; #sql [ctx] iter = {SELECT id，name FROM xa_test}; while（iter.next（））{System.out.print（iter.id（））; System.out.print（“”）;的System.out.println（iter.name（））; catch（Exception e）{System.out.println（e）; e.printStackTrace（）; }}</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-02D73030-0352-4669-9152-0A331260FBC8__GUID-D22FF91A-5A8E-4DF0-B51A-208A071785D6">通过将ConnectionContext传递给它来使用Oracle.connect（）方法。ConnectionContext是通过从XA数据源获得的JDBC连接创建的</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section"><pre class="oac_no_warn" dir="ltr">private static void DoSomeWork（java.sql。连接conn）抛出SQLException {String chr =“XA_CERT”; MyContext myctx1 = new MyContext（conn）; Oracle.connect（myctx1）; #sql {insert into xa_test values（1，：chr）};尝试{Iterator3 iter = null; #sql iter = {SELECT id，name FROM xa_test}; while（iter.next（））{System.out.print（iter.id（））; System.out.print（“”）;的System.out.println（iter.name（））; catch（Exception e）{System.out.println（e）; e.printStackTrace（）; }}</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-02D73030-0352-4669-9152-0A331260FBC8__GUID-E359B839-82E7-4149-AA67-7674A32A7BD8">使用Oracle。通过将ConnectionContext传递给它的getConnection（）方法。ConnectionContext是通过从XA数据源获得的JDBC连接创建的</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section"><pre class="oac_no_warn" dir="ltr">private static void DoSomeWork（java.sql。连接conn）抛出SQLException {String chr =“XA_CERT”; MyContext myctx1 = new MyContext（conn）; DefaultContext ctx = Oracle.getConnection（myctx1）; #sql [ctx] {insert into xa_test values（1，：chr）};尝试{Iterator3 iter = null; #sql [ctx] iter = {SELECT id，name FROM xa_test}; while（iter.next（））{System.out.print（iter.id（））; System.out.print（“”）;的System.out.println（iter.name（））; catch（Exception e）{System.out.println（e）; e.printStackTrace（）; }}</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-02D73030-0352-4669-9152-0A331260FBC8__GUID-ADD052F5-4E6D-49B1-BEF1-D2B94E181F38">DefaultContext类的setDefaultContext（）方法也可用于设置通过从XA数据源获取的JDBC连接创建的上下文</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section"><pre class="oac_no_warn" dir="ltr">DefaultContext.setDefaultContext（CTX）;</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-02D73030-0352-4669-9152-0A331260FBC8__GUID-F81953E4-84FF-449C-990F-4F693BFEDA6A">通过传递从XA数据源获取的JDBC连接来使用ConnectionContext构造函数</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section"><pre class="oac_no_warn" dir="ltr">private static void DoSomeWork（java.sql。连接conn）抛出SQLException {String chr =“XA_CERT”; MyContext myctx1 = new MyContext（conn）; #sql [myctx1] {insert into xa_test values（1，：chr）};尝试{Iterator3 iter = null; #sql [myctx1] iter = {SELECT id，name FROM xa_test}; while（iter.next（））{System.out.print（iter.id（））; System.out.print（“”）;的System.out.println（iter.name（））; catch（Exception e）{System.out.println（e）; e.printStackTrace（）; }}</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-02D73030-0352-4669-9152-0A331260FBC8__GUID-C6A2124A-6071-4F4C-8506-25D241AFFEC0">通过将ConnectionContext传递给它来使用ConnectionContext构造函数。ConnectionContext是通过从XA数据源获得的JDBC连接创建的</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section"><pre class="oac_no_warn" dir="ltr">private static void DoSomeWork（java.sql。连接conn）抛出SQLException {String chr =“XA_CERT”; MyContext myctx = new MyContext（conn）; MyContext myctx1 = new MyContext（myctx）; #sql [myctx1] {insert into xa_test values（1，：chr）};尝试{Iterator3 iter = null; #sql [myctx1] iter = {SELECT id，name FROM xa_test}; while（iter.next（））{System.out.print（iter.id（））; System.out.print（“”）;的System.out.println（iter.name（））; catch（Exception e）{System.out.println（e）; e.printStackTrace（）; }}</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ922"></a><div class="props_rev_3"><a id="GUID-A5EAE0BC-4FE0-4D3B-992A-E423667DC3D1" name="GUID-A5EAE0BC-4FE0-4D3B-992A-E423667DC3D1"></a><h4 id="JSQLJ-GUID-A5EAE0BC-4FE0-4D3B-992A-E423667DC3D1" class="sect4">连接到PDB</h4>
                  <div>
                     <p>可插拔数据库（PDB）使Oracle数据库能够包含一个可移植的模式，模式对象和非复制对象集合，这些对象在Oracle客户端中显示为单独的数据库。多租户容器数据库（CDB）是包含一个或多个PDB的Oracle数据库。SQLJ应用程序可以使用服务连接到PDB，其<code class="codeph">PLUGGABLE DATABASE</code>属性设置为相关的PDB。</p>
                     <div class="infoboxnotealso" id="GUID-A5EAE0BC-4FE0-4D3B-992A-E423667DC3D1__GUID-152F090B-86CA-48D0-A4B3-2018A72959AD">
                        <p class="notep1">也可以看看：</p>
                        <p>有关配置连接到各种可插拔数据库的服务的详细信息<a href="../bradv/glossary.html#BRADV-GUID-D4239448-A344-41EF-9566-0B7716FEAE72" target="_blank"><span><cite>，请参见“Oracle数据库备份和恢复用户指南”</cite></span></a></p>
                     </div>
                  </div>
               </div>
            </div><a id="JSQLJ534"></a><div class="props_rev_3"><a id="GUID-BC1805F7-AECB-4D97-B74C-1E0D71BDE603" name="GUID-BC1805F7-AECB-4D97-B74C-1E0D71BDE603"></a><h3 id="JSQLJ-GUID-BC1805F7-AECB-4D97-B74C-1E0D71BDE603" class="sect3">执行上下文</h3>
               <div>
                  <p>执行上下文是<code class="codeph">sqlj.runtime.一个实例<code class="codeph">sqlj.runtime.ExecutionContext</code>类，并提供ExecutionContext</code> SQL操作的上下文。执行上下文实例与SQLJ应用程序中的每个SQL操作隐式或显式关联。
                  </p>
                  <p><code class="codeph">ExecutionContext</code>类包含以下功能的方法：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>执行控制操作修改后续SQL操作的语义。</p>
                     </li>
                     <li>
                        <p>执行状态操作描述最近SQL操作的结果。</p>
                     </li>
                     <li>
                        <p>执行取消操作终止当前正在执行的SQL操作。</p>
                     </li>
                     <li>
                        <p>更新批处理操作可启用和禁用更新批处理，设置批处理限制以及获取更新计数。</p>
                     </li>
                     <li>
                        <p>Savepoint操作设置保存点，回滚到保存点并释放保存点。</p>
                     </li>
                     <li>
                        <p>闭包操作关闭执行上下文实例以避免资源泄漏。</p>
                     </li>
                  </ul>
                  <div class="infoboxnote" id="GUID-BC1805F7-AECB-4D97-B74C-1E0D71BDE603__GUID-F1679FA2-F9E5-4B7A-8B4A-CB82FCE4706B">
                     <p class="notep1">注意：</p>
                     <p>只有一个执行上下文类，与连接上下文类不同，您可以根据需要声明其他类。每个执行上下文都是<code class="codeph">ExecutionContext</code>类的实例。因此，虽然术语连接上下文通常是指您声明的类，但术语执行上下文始终引用<code class="codeph">ExecutionContext</code>类的实例。本文档指定连接上下文类，连接上下文实例和执行上下文实例以避免混淆。
                     </p>
                  </div>
                  <p>本节包括以下主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="advanced-language-features.html#GUID-4C5420FC-6F0B-4297-A1C5-60316BB449DF">执行上下文与连接上下文的关系</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-language-features.html#GUID-AC767320-7338-42AD-90B5-5359E764110A">创建和指定执行上下文实例</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-language-features.html#GUID-E45F36C2-8D2C-4D58-9809-615C98E0DA90">执行上下文同步</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-language-features.html#GUID-8E1ED9B1-104E-40DD-9A04-EBEC2A36D5AA">执行上下文方法</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-language-features.html#GUID-5D46378D-44D5-478B-AD6D-EF67C7E27E30">执行上下文与多线程的关系</a></p>
                     </li>
                  </ul>
               </div><a id="JSQLJ535"></a><div class="props_rev_3"><a id="GUID-4C5420FC-6F0B-4297-A1C5-60316BB449DF" name="GUID-4C5420FC-6F0B-4297-A1C5-60316BB449DF"></a><h4 id="JSQLJ-GUID-4C5420FC-6F0B-4297-A1C5-60316BB449DF" class="sect4">执行上下文与连接上下文的关系</h4>
                  <div>
                     <p>每个连接上下文实例都隐式具有自己的默认执行上下文实例，您可以使用连接上下文实例的<code class="codeph">getExecutionContext()</code>方法检索该实例。
                     </p>
                     <p>除以下情况外，单个执行上下文实例对于连接上下文实例就足够了：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>您正在使用具有单个连接上下文实例的多个线程。</p>
                           <p>使用多线程时，每个线程必须有自己的执行上下文实例。</p>
                        </li>
                        <li>
                           <p>您希望对使用相同连接上下文实例的不同SQLJ语句使用不同的SQL执行控制操作。</p>
                        </li>
                        <li>
                           <p>您希望从使用相同连接上下文实例的多个SQL操作中保留不同的SQL状态信息集。</p>
                           <p>当您执行使用相同执行上下文实例的连续SQL操作时，每个操作的状态信息将覆盖上一操作的状态信息。</p>
                        </li>
                     </ul>
                     <p>虽然执行上下文实例可能看起来与连接上下文实例相关联（假设每个连接上下文实例都有一个默认的执行上下文实例，并且您可以为特定的SQLJ语句一起指定连接上下文实例和执行上下文实例），独立运作。您可以在使用相同连接上下文实例的语句中使用不同的执行上下文实例，反之亦然。</p>
                     <p>例如，如果使用多线程，则将多个执行上下文实例与单个连接上下文实例一起使用是很有用的，每个线程都有一个单独的执行上下文实例。如果您的程序是单线程的，并且您希望将同一组SQL控件参数应用于所有连接上下文实例，则可以将多个连接上下文实例与单个显式执行上下文实例一起使用。</p>
                     <div class="infoboxnotealso" id="GUID-4C5420FC-6F0B-4297-A1C5-60316BB449DF__GUID-779E4D2C-B45F-4DF6-8AD2-0DB0C6C6A331">
                        <p class="notep1">也可以看看：</p>
                        <p><span class="q">“ <a href="advanced-language-features.html#GUID-8E1ED9B1-104E-40DD-9A04-EBEC2A36D5AA">执行上下文方法</a> ”</span></p>
                     </div>
                     <p>要将不同的执行上下文实例与单个连接上下文实例一起使用，必须创建<code class="codeph">ExecutionContext</code>类的其他实例，并使用SQLJ语句适当地指定它们。
                     </p>
                  </div>
               </div><a id="JSQLJ536"></a><div class="props_rev_3"><a id="GUID-AC767320-7338-42AD-90B5-5359E764110A" name="GUID-AC767320-7338-42AD-90B5-5359E764110A"></a><h4 id="JSQLJ-GUID-AC767320-7338-42AD-90B5-5359E764110A" class="sect4">创建和指定执行上下文实例</h4>
                  <div>
                     <div class="section">
                        <p>要使用给定连接上下文实例的缺省值以外的执行上下文实例，必须构造另一个执行上下文实例。<code class="codeph">ExectionContext</code>构造函数没有输入参数。例如：</p><pre class="oac_no_warn" dir="ltr">ExecutionContext myExecCtx = new ExecutionContext（）;</pre><p>然后，您可以指定此执行上下文实例以用于任何特定的SQLJ语句，就像指定连接上下文实例一样。一般语法如下：</p><pre class="oac_no_warn" dir="ltr">#sql [&lt; <span class="italic">conn_context</span> &gt; &lt;，&gt; &lt; <span class="italic">exec_context</span> &gt;] { <span class="italic">SQL operation</span> };</pre><p>例如，如果您还声明并实例化连接上下文类<code class="codeph">MyConnCtxClass</code> ，并创建一个实例<code class="codeph">myConnCtx</code> ，那么您可以使用以下语句：</p><pre class="oac_no_warn" dir="ltr">#sql [myConnCtx，myExecCtx] {DELETE FROM employees WHERE salary&gt; 30000};</pre><p>随后，您可以将不同的执行上下文实例与<code class="codeph">myConnCtx</code>一起<code class="codeph">myConnCtx</code>或将不同的连接上下文实例与<code class="codeph">myExecCtx</code>一起<code class="codeph">myExecCtx</code> 。
                        </p>
                        <p>您可以选择在使用默认连接上下文实例时指定执行上下文实例，如下所示：</p><pre class="oac_no_warn" dir="ltr">#sql [myExecCtx] {DELETE FROM employees WHERE salary&gt; 30000};</pre><div class="infoboxnote" id="GUID-AC767320-7338-42AD-90B5-5359E764110A__GUID-FA8C0995-AE92-4AA4-B6A1-20BF546A0D1B">
                           <p class="notep1">注意：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>如果指定没有执行上下文实例的连接上下文实例，则使用该连接上下文实例的默认执行上下文实例。</p>
                              </li>
                              <li>
                                 <p>如果指定没有连接上下文实例的执行上下文实例，则执行上下文实例将与应用程序的默认连接上下文实例一起使用。</p>
                              </li>
                              <li>
                                 <p>如果未指定连接上下文实例且没有指定执行上下文实例，则SQLJ将使用默认连接及其默认执行上下文实例。</p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ537"></a><div class="props_rev_3"><a id="GUID-E45F36C2-8D2C-4D58-9809-615C98E0DA90" name="GUID-E45F36C2-8D2C-4D58-9809-615C98E0DA90"></a><h4 id="JSQLJ-GUID-E45F36C2-8D2C-4D58-9809-615C98E0DA90" class="sect4">执行上下文同步</h4>
                  <div>
                     <p><code class="codeph">ExecutionContext</code>方法都是<code class="codeph">synchronized</code>方法。因此，对于ISO标准代码生成，只要语句尝试使用已在使用的执行上下文实例，第二个语句将被阻塞，直到第一个语句完成。
                     </p>
                     <p>在客户端应用程序中，这通常涉及多线程情况。尝试使用当前由另一个线程使用的执行上下文实例的线程将被阻止。要避免此类阻塞，必须为您使用的每个线程指定单独的执行上下文实例。</p>
                     <div class="infoboxnotealso" id="GUID-E45F36C2-8D2C-4D58-9809-615C98E0DA90__GUID-35B675A1-C35F-4028-9B81-17457C18AB04">
                        <p class="notep1">也可以看看：</p>
                        <p><span class="q">“ <a href="advanced-language-features.html#GUID-C7787089-2507-43D1-91A3-FEC222903639">SQLJ中的多线程</a> ”</span></p>
                     </div>
                     <p>前面的讨论不适用于默认的Oracle特定代码生成。出于性能原因，SQLJ不会针对特定于Oracle的生成代码<code class="codeph">ExecutionContext</code>针对<code class="codeph">ExecutionContext</code>实例的其他同步。因此，您有责任确保多个线程不会使用相同的执行上下文实例。如果多个线程使用相同的执行上下文，那么您的应用程序将遇到错误，例如错误的结果或<code class="codeph">NullPointer</code>异常，而不是阻塞。
                     </p>
                     <p>讨论的另一个例外是递归，只在服务器中遇到。如果这种情况是由递归调用产生的，则允许同一线程中的多个SQLJ语句同时使用相同的执行上下文实例。例如，SQLJ存储过程或函数调用另一个SQLJ存储过程或函数。如果两者都使用默认执行上下文实例（通常情况下），则第二个过程中的SQLJ语句将使用此执行上下文，而第一个过程中的SQLJ调用语句也仍在使用它。这是允许的。</p>
                  </div>
               </div><a id="JSQLJ538"></a><div class="props_rev_3"><a id="GUID-8E1ED9B1-104E-40DD-9A04-EBEC2A36D5AA" name="GUID-8E1ED9B1-104E-40DD-9A04-EBEC2A36D5AA"></a><h4 id="JSQLJ-GUID-8E1ED9B1-104E-40DD-9A04-EBEC2A36D5AA" class="sect4">执行上下文方法</h4>
                  <div>
                     <p>以下部分列出了<code class="codeph">ExecutionContext</code>类的公共方法并提供了一个示例：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="advanced-language-features.html#GUID-51FD7FFA-AD3F-4792-9D01-38C0BB411630">现状方法</a></p>
                        </li>
                        <li>
                           <p><a href="advanced-language-features.html#GUID-1A95460D-2A8C-4B26-AD89-EA588B2F638E">控制方法</a></p>
                        </li>
                        <li>
                           <p><a href="advanced-language-features.html#GUID-8291E777-D86C-4504-B1EE-CC68ECAB03D2">取消方法</a></p>
                        </li>
                        <li>
                           <p><a href="advanced-language-features.html#GUID-FA3E1F82-191B-4ACA-BC1C-4E4A5E279EE1">更新批处理方法</a></p>
                        </li>
                        <li>
                           <p><a href="advanced-language-features.html#GUID-8A773E63-0B14-4F39-ADE6-38B8C476B123">保存点方法</a></p>
                        </li>
                        <li>
                           <p><a href="advanced-language-features.html#GUID-B77D7CC7-7DC8-4C5F-827E-969875CA02CF">关闭方法</a></p>
                        </li>
                        <li>
                           <p><a href="advanced-language-features.html#GUID-AD6833B1-11DB-4B42-95A4-D06390430364">示例：使用ExecutionContext方法</a></p>
                        </li>
                     </ul>
                  </div><a id="JSQLJ539"></a><div class="props_rev_3"><a id="GUID-51FD7FFA-AD3F-4792-9D01-38C0BB411630" name="GUID-51FD7FFA-AD3F-4792-9D01-38C0BB411630"></a><h5 id="JSQLJ-GUID-51FD7FFA-AD3F-4792-9D01-38C0BB411630" class="sect5">现状方法</h5>
                     <div>
                        <p>使用执行上下文实例的以下方法获取有关使用该实例完成的最新SQL操作的状态信息：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">SQLWarning getWarnings()</code> ：返回一个<code class="codeph">java.sql.SQLWarning</code>对象，包含使用此执行上下文实例完成的最新SQL操作报告的第一个警告。警告在链中返回。使用<code class="codeph">getWarnings()</code>执行上下文实例的方式来获得的第一个警告，然后使用<code class="codeph">getNextWarning()</code>每个方法<code class="codeph">SQLWarning</code>对象，以获取下一个警告。该链包含执行SQL操作期间生成的所有警告。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">int getUpdateCount()</code> ：除非启用更新批处理，否则返回一个<code class="codeph">int</code>值，指定使用此执行上下文实例完成的上一个SQL操作更新的行数。如果最后一个SQL操作不是数据操作语言（DML）语句，则返回零（ <code class="codeph">0</code> ）。如果最后一个SQL操作生成迭代器或结果集，则返回<code class="codeph">QUERY_COUNT</code>常量。如果最后一个SQL操作在完成执行之前终止，或者如果尚未使用此执行上下文实例尝试操作，则返回<code class="codeph">EXCEPTION_COUNT</code>常量。
                              </p>
                              <p>对于启用批处理的应用程序， <code class="codeph">getUpdateCount()</code>返回的值将是几个与批处理相关的常量值之一： <code class="codeph">NEW_BATCH_COUNT</code> ， <code class="codeph">ADD_BATCH_COUNT</code>或<code class="codeph">EXEC_BATCH_COUNT</code> 。</p>
                              <div class="infoboxnotealso" id="GUID-51FD7FFA-AD3F-4792-9D01-38C0BB411630__GUID-EAAEA405-1D75-4153-963B-24BF56E05FF0">
                                 <p class="notep1">也可以看看：</p>
                                 <p><span class="q">“ <a href="performance-and-debugging.html#GUID-E764E87E-1320-4DBE-B59E-7B03150BF803__I1006039">执行上下文更新计数</a> ”</span></p>
                              </div>
                           </li>
                        </ul>
                     </div>
                  </div><a id="JSQLJ540"></a><div class="props_rev_3"><a id="GUID-1A95460D-2A8C-4B26-AD89-EA588B2F638E" name="GUID-1A95460D-2A8C-4B26-AD89-EA588B2F638E"></a><h5 id="JSQLJ-GUID-1A95460D-2A8C-4B26-AD89-EA588B2F638E" class="sect5">控制方法</h5>
                     <div>
                        <p>使用执行上下文实例的以下方法来控制使用该实例执行的未来SQL操作的操作（尚未启动的操作）：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">int getMaxFieldSize()</code> ：返回一个<code class="codeph">int</code>值，指定随后使用此执行上下文实例从SQL操作返回的最大数据量（以字节为单位）。这仅适用于<code class="codeph">BINARY</code> ， <code class="codeph">VARBINARY</code> ， <code class="codeph">LONGVARBINARY</code> ， <code class="codeph">CHAR</code> ， <code class="codeph">VARCHAR</code>或<code class="codeph">LONGVARCHAR</code>类型的列。
                              </p>
                              <p>默认情况下，此参数设置为<code class="codeph">0</code> ，表示没有大小限制。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">setMaxFieldSize(int)</code> ：将<code class="codeph">int</code>值作为输入来修改最大字段大小。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">int getMaxRows()</code> ：返回一个<code class="codeph">int</code>值，指定使用此执行上下文实例创建的任何SQLJ迭代器或JDBC结果集可包含的最大行数。如果超出限制，则会以静默方式删除多余的行，而不会显示任何错误报告或警告。
                              </p>
                              <p>默认情况下，此参数设置为<code class="codeph">0</code> ，表示没有行限制。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">setMaxRows(int)</code> ：将<code class="codeph">int</code>值作为输入来修改最大行值。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">int getQueryTimeout()</code> ：返回一个<code class="codeph">int</code>值，指定使用此执行上下文实例的任何SQL操作的超时间隔（以秒为单位）。如果SQL操作超出此限制，则抛出SQL异常。
                              </p>
                              <p>默认情况下，此参数设置为<code class="codeph">0</code> ，表示没有查询超时限制。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">setQueryTimeout(int)</code> ：将<code class="codeph">int</code>值作为输入来修改查询超时限制。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">int getFetchSize()</code> ：获取从此<code class="codeph">ExecutionContext</code>对象生成的迭代器对象的当前提取大小的行数。如果此<code class="codeph">ExecutionContext</code>对象未通过调用<code class="codeph">setFetchSize()</code>设置获取大小，则返回的值为<code class="codeph">0</code> 。如果此<code class="codeph">ExecutionContext</code>对象通过调用方法<code class="codeph">setFetchSize()</code>设置了非负提取大小，则返回值是<code class="codeph">setFetchSize()</code>上指定的提取大小。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">setFetchSize(int)</code> ：为SQLJ运行时提供一个提示，指示在需要更多行时应该提取的行数。指定的行数仅影响使用此<code class="codeph">ExecutionContext</code>对象创建的迭代器对象。指定零意味着将依赖于实现的默认值用于提取大小。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">int getFetchDirection()</code> ：获取从此<code class="codeph">ExecutionContext</code>对象生成的可滚动迭代器对象的获取数据的默认方向。如果此<code class="codeph">ExecutionContext</code>对象未通过调用方法<code class="codeph">setFetchDirection()</code>设置获取方向，则返回值为<code class="codeph">FETCH_FORWARD</code> 。</p>
                           </li>
                           <li>
                              <p><code class="codeph">setFetchDirection(int)</code> ：为SQLJ运行时提供有关处理可滚动迭代器对象行的方向的提示。该提示仅适用于使用此<code class="codeph">ExecutionContext</code>对象创建的可滚动迭代器对象。默认值为：</p><pre class="oac_no_warn" dir="ltr">sqlj.runtime。ResultSetIterator。FETCH_FORWARD。</pre><p>如果给定方向不是<code class="codeph">FETCH_FORWARD</code> ， <code class="codeph">FETCH_REVERSE</code>或<code class="codeph">FETCH_UNKNOWN</code> （ <code class="codeph">int</code>常量）之一，则此方法抛出<code class="codeph">SQLException</code> 。
                              </p>
                           </li>
                        </ul>
                     </div>
                  </div><a id="JSQLJ541"></a><div class="props_rev_3"><a id="GUID-8291E777-D86C-4504-B1EE-CC68ECAB03D2" name="GUID-8291E777-D86C-4504-B1EE-CC68ECAB03D2"></a><h5 id="JSQLJ-GUID-8291E777-D86C-4504-B1EE-CC68ECAB03D2" class="sect5">取消方法</h5>
                     <div>
                        <p>如果启用了更新批处理，请使用以下方法取消多线程环境中的SQL操作或取消挂起的语句批处理：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">cancel()</code> ：在多线程环境中，在一个线程中使用此方法取消当前在另一个线程中执行的SQL操作。它使用此执行上下文实例取消已启动但未完成的最新操作。如果当前没有使用此执行上下文实例执行语句，则此方法无效。
                              </p>
                              <p>在启用批处理的环境中，使用此选项取消挂起的语句批处理。清空批次，批处理中的所有语句都不会执行。取消批处理后，遇到的下一个batchable语句将添加到新批处理中。</p>
                              <div class="infoboxnotealso" id="GUID-8291E777-D86C-4504-B1EE-CC68ECAB03D2__GUID-7E5D4522-B34A-419B-8D31-C75324DFC8F9">
                                 <p class="notep1">也可以看看：</p>
                                 <p><span class="q">“ <a href="performance-and-debugging.html#GUID-E764E87E-1320-4DBE-B59E-7B03150BF803__I1006005">取消批次</a> ”</span></p>
                              </div>
                           </li>
                        </ul>
                     </div>
                  </div><a id="JSQLJ542"></a><div class="props_rev_3"><a id="GUID-FA3E1F82-191B-4ACA-BC1C-4E4A5E279EE1" name="GUID-FA3E1F82-191B-4ACA-BC1C-4E4A5E279EE1"></a><h5 id="JSQLJ-GUID-FA3E1F82-191B-4ACA-BC1C-4E4A5E279EE1" class="sect5">更新批处理方法</h5>
                     <div>
                        <p>如果希望应用程序使用该性能增强功能，请使用以下方法控制更新批处理：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">int[] executeBatch()</code> ：执行pending语句批处理，返回<code class="codeph">int</code> update count数组。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">int getBatchLimit()</code> ：返回一个指示当前批量限制的<code class="codeph">int</code>值。如果存在批处理限制，则一旦包含该数量的语句，就会隐式执行挂起的批处理。
                              </p>
                              <p>默认情况下，批次限制设置为<code class="codeph">ExecutionContext</code>静态常量值<code class="codeph">UNLIMITED_BATCH</code> ，这意味着没有批次限制。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">int[] getBatchUpdateCounts()</code> ：返回上次执行的批处理的<code class="codeph">int</code>更新计数数组。在隐式执行批处理的情况下，此方法很有用。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">boolean isBatching()</code> ：返回一个布尔值，指示是否启用更新批处理。
                              </p>
                              <p>这不表示当前是否存在挂起的批处理，但您可以使用<code class="codeph">getUpdateCount()</code>方法查看是否已新创建，添加或执行批处理。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">setBatching(boolean)</code> ：使用布尔值来启用更新批处理。
                              </p>
                              <p>默认情况下禁用更新批处理。</p>
                           </li>
                           <li>
                              <p><code class="codeph">setBatchLimit(int)</code> ：将正的非零<code class="codeph">int</code>值作为输入来设置当前批次限制。您可以分配的两个特殊值是<code class="codeph">UNLIMITED_BATCH</code> ，这意味着没有限制，而<code class="codeph">AUTO_BATCH</code>可以让SQLJ运行时动态地确定批量限制。
                              </p>
                           </li>
                        </ul>
                        <div class="infoboxnotealso" id="GUID-FA3E1F82-191B-4ACA-BC1C-4E4A5E279EE1__GUID-84077021-7B2D-4BC9-AF56-6D4B724C677B">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="../jjdbc/performance-extensions.html#JJDBC-GUID-8B920135-D97D-4F33-8FF5-5774E802C520" target="_blank"><span><cite>Oracle数据库JDBC开发人员指南</cite></span></a></p>
                        </div>
                     </div>
                  </div><a id="JSQLJ543"></a><div class="props_rev_3"><a id="GUID-8A773E63-0B14-4F39-ADE6-38B8C476B123" name="GUID-8A773E63-0B14-4F39-ADE6-38B8C476B123"></a><h5 id="JSQLJ-GUID-8A773E63-0B14-4F39-ADE6-38B8C476B123" class="sect5">保存点方法</h5>
                     <div>
                        <p>Oracle SQLJ实现支持JDBC 3.0保存点。保存点存储在<code class="codeph">ExecutionContext</code>实例中，并且存在以下公共方法以支持SQLJ保存点语句：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">Object oracleSetSavepoint（ConnectionContextImpl，String）</code></p>
                              <p>注册保存点并将保存点作为<code class="codeph">Object</code>实例返回。此方法将连接上下文作为<code class="codeph">sqlj.runtime.ref.的实例<code class="codeph">sqlj.runtime.ref.ConnectionContextImpl</code>类和指定保存点名称的字符串。
                              </p>
                              <p>Oracle SQLJ实现将保存点实例化为<code class="codeph">oracle.jdbc.的实例<code class="codeph">oracle.jdbc.OracleSavepoint</code>类，它扩展了<code class="codeph">java.sql.Savepoint</code>界面。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">void oracleRollbackToSavepoint（ConnectionContextImpl，Object）</code></p>
                              <p>回滚更改为指定的保存点。此方法将连接上下文作为<code class="codeph">ConnectionContextImpl</code>的实例，将保存点作为<code class="codeph">Object</code>实例。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">void oracleReleaseSavepoint（ConnectionContextImpl，Object）</code></p>
                              <p>释放指定的保存点。此方法将连接上下文作为<code class="codeph">ConnectionContextImpl</code>的实例，将保存点作为<code class="codeph">Object</code>实例。
                              </p>
                           </li>
                        </ul>
                        <p>您通常会使用SQLJ保存点语句而不是直接使用这些方法。</p>
                     </div>
                  </div><a id="JSQLJ544"></a><div class="props_rev_3"><a id="GUID-B77D7CC7-7DC8-4C5F-827E-969875CA02CF" name="GUID-B77D7CC7-7DC8-4C5F-827E-969875CA02CF"></a><h5 id="JSQLJ-GUID-B77D7CC7-7DC8-4C5F-827E-969875CA02CF" class="sect5">关闭方法</h5>
                     <div>
                        <p>Oracle SQLJ实现通过<code class="codeph">ExecutionContext</code>类的<code class="codeph">close()</code>方法提供扩展功能：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">close()</code> ：为避免资源泄漏，如果满足以下条件，请使用此方法：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>您正在使用特定于Oracle的代码生成。</p>
                                 </li>
                                 <li>
                                    <p>您显式创建并使用了<code class="codeph">ExecutionContext</code>实例，而不是使用通过连接上下文实例提供的默认实例。
                                    </p>
                                 </li>
                                 <li>
                                    <p>您<span class="italic">没有</span>使用<code class="codeph">ExecutionContext</code>实例显式发出SQLJ回滚或提交语句：</p><pre class="oac_no_warn" dir="ltr">#sql [ec] {COMMIT}; #sql [ec] {ROLLBACK};</pre></li>
                                 <li>
                                    <p>您<span class="italic">没有</span>在<code class="codeph">ExecutionContext</code>实例上调用<code class="codeph">executeBatch()</code> 。
                                    </p>
                                 </li>
                              </ul>
                              <p>在这种情况下，可以在<code class="codeph">ExecutionContext</code>实例上打开一个batchable语句，并且随着时间的推移，您可能会耗尽数据库游标。要避免这种情况，请使用<code class="codeph">close()</code>方法，如以下示例所示：</p><pre class="oac_no_warn" dir="ltr">执行上下文ec = new ExecutionContext（）; ...尝试{...#sql [ec] { <span class="italic">SQL operation</span> }; ...} finally {ec.close（）; }</pre></li>
                        </ul>
                        <div class="infoboxnote" id="GUID-B77D7CC7-7DC8-4C5F-827E-969875CA02CF__GUID-C5ED67C3-64F8-486F-B69A-9E9AE4802A45">
                           <p class="notep1">注意：</p>
                           <p>当执行上下文实例与连接上下文实例相关联而不是显式声明时，关闭连接上下文实例（无论是否关闭底层JDBC连接）都将自动关闭执行上下文实例上剩余的任何语句。</p>
                        </div>
                     </div>
                  </div><a id="JSQLJ545"></a><div class="props_rev_3"><a id="GUID-AD6833B1-11DB-4B42-95A4-D06390430364" name="GUID-AD6833B1-11DB-4B42-95A4-D06390430364"></a><h5 id="JSQLJ-GUID-AD6833B1-11DB-4B42-95A4-D06390430364" class="sect5">示例：使用ExecutionContext方法</h5>
                     <div>
                        <p>以下代码演示了一些<code class="codeph">ExecutionContext</code>方法的用法：</p><pre class="oac_no_warn" dir="ltr">ExecutionContext execCtx = DefaultContext.getDefaultContext（）。getExecutionContext（）; //等待3秒钟才能完成execCtx.setQueryTimeout（3）; //使用默认连接上下文的执行上下文删除#sql {DELETE FROM employees WHERE salary&gt; 10000}; System.out.println（“删除”+ execCtx.getUpdateCount（）+“employees”）;</pre></div>
                  </div>
               </div><a id="JSQLJ546"></a><div class="props_rev_3"><a id="GUID-5D46378D-44D5-478B-AD6D-EF67C7E27E30" name="GUID-5D46378D-44D5-478B-AD6D-EF67C7E27E30"></a><h4 id="JSQLJ-GUID-5D46378D-44D5-478B-AD6D-EF67C7E27E30" class="sect4">执行上下文与多线程的关系</h4>
                  <div>
                     <p>不要将多个线程与单个执行上下文一起使用。如果这样做，并且两个SQLJ语句尝试同时使用相同的执行上下文，则第二个语句将被阻塞，直到第一个语句完成。此外，来自第一操作的状态信息可能在被检索之前被覆盖。</p>
                     <p>因此，如果您使用具有单个连接上下文实例的多个线程，则应执行以下步骤：</p>
                     <ol>
                        <li>
                           <p>实例化一个唯一的执行上下文实例，以便与每个线程一起使用。</p>
                        </li>
                        <li>
                           <p>使用<code class="codeph">#sql</code>语句指定执行上下文，以便每个线程使用自己的执行上下文。
                           </p>
                        </li>
                     </ol>
                     <p>如果要对每个线程使用不同的连接上下文实例，则不需要实例化和执行上下文实例的规范，因为每个连接上下文实例都隐式地具有其自己的默认执行上下文实例。</p>
                     <div class="infoboxnote" id="GUID-5D46378D-44D5-478B-AD6D-EF67C7E27E30__GUID-B11DFDF4-A508-498F-A304-988B725AF5C9">
                        <p class="notep1">注意：</p>
                        <p>出于性能原因，SQLJ不会针对特定于Oracle的生成代码<code class="codeph">ExecutionContext</code>针对<code class="codeph">ExecutionContext</code>实例的其他同步。因此，您有责任确保多个线程不会使用相同的执行上下文实例。如果多个线程使用相同的执行上下文，那么您的应用程序将遇到错误，例如错误的结果或<code class="codeph">NullPointer</code>异常，而不是阻塞。
                        </p>
                     </div>
                  </div>
               </div>
            </div><a id="JSQLJ548"></a><a id="JSQLJ547"></a><div class="props_rev_3"><a id="GUID-C7787089-2507-43D1-91A3-FEC222903639" name="GUID-C7787089-2507-43D1-91A3-FEC222903639"></a><h3 id="JSQLJ-GUID-C7787089-2507-43D1-91A3-FEC222903639" class="sect3">SQLJ中的多线程</h3>
               <div>
                  <p>本节讨论SQLJ对多线程的支持和要求以及多线程和执行上下文实例之间的关系。</p>
                  <p>您可以在编写多线程应用程序时使用SQLJ。但是，在SQLJ应用程序中使用多线程会受到JDBC驱动程序或专有数据库访问工具的限制。这包括任何同步限制。</p>
                  <p>您需要为每个线程使用不同的执行上下文实例。您可以通过以下两种方式之一完成此任务：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>为SQLJ语句指定连接上下文实例，以便为每个线程使用不同的连接上下文实例。每个连接上下文实例都自动拥有自己的默认执行上下文实例</p>
                     </li>
                     <li>
                        <p>如果您使用具有多个线程的相同连接上下文实例，则声明其他执行上下文实例并为SQLJ语句指定执行上下文实例，以便为每个线程使用不同的执行上下文实例。</p>
                     </li>
                  </ul>
                  <div class="infoboxnotealso" id="GUID-C7787089-2507-43D1-91A3-FEC222903639__GUID-0204D45A-35C7-4BF7-944E-D20B1C201E92">
                     <p class="notep1">也可以看看：</p>
                     <p><span class="q">“ <a href="basic-language-features.html#GUID-9F93C716-2C14-4AD0-B68F-EAC2CEDCDA60">指定连接上下文实例和执行上下文实例</a> ”</span></p>
                  </div>
                  <p>如果您使用的是其中一个Oracle JDBC驱动程序，则只要指定了不同的执行上下文实例并且没有直接对您可见的同步要求，则多个线程可以根据需要使用相同的连接上下文实例。但请注意，数据访问是顺序的。在任何给定时间只有一个线程正在访问数据。同步是指通过线程执行的SQL操作的各个阶段的控制流。例如，每个语句都可以绑定输入参数，然后执行，然后绑定输出参数。对于某些JDBC驱动程序，必须特别注意不要将这些阶段混合在一起。</p>
                  <p>对于ISO标准代码生成，如果线程尝试执行使用另一个操作正在使用的执行上下文的SQL操作，则该线程将被阻塞，直到当前操作完成。如果在线程之间共享执行上下文，那么一个线程执行的SQL操作的结果将在另一个线程中可见。如果两个线程都在执行SQL操作，则可能会出现争用情况。在第一个线程处理原始结果之前，在另一个线程中执行的结果可能会覆盖在一个线程中执行的结果。这就是不允许多个线程共享执行上下文实例的原因。</p>
                  <div class="infoboxnote" id="GUID-C7787089-2507-43D1-91A3-FEC222903639__GUID-B1836AE6-7A38-4939-9226-C69610E9AD77">
                     <p class="notep1">注意：</p>
                     <p>如果使用默认的Oracle特定代码生成，则前一段不适用。出于性能原因，SQLJ不会针对特定于Oracle的生成代码<code class="codeph">ExecutionContext</code>针对<code class="codeph">ExecutionContext</code>实例的其他同步。因此，您有责任确保多个线程不会使用相同的执行上下文实例。如果多个线程使用相同的执行上下文，那么您的应用程序将遇到错误，例如错误的结果或<code class="codeph">NullPointer</code>异常，而不是阻塞。
                     </p>
                  </div>
                  <div class="section">
                     <p class="subhead2" id="GUID-C7787089-2507-43D1-91A3-FEC222903639__GUID-FBC8E8A9-75DA-4324-A811-CF1DBFC4DEF8">多线程：MultiThreadDemo.sqlj</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p>以下是使用多线程的SQLJ应用程序的示例。在关闭连接之前执行<code class="codeph">ROLLBACK</code>操作，因此数据不会永久更改。
                     </p><pre class="oac_no_warn" dir="ltr">import java.sql。的SQLException; import java.util。随机; import sqlj.runtime。执行上下文; import oracle.sqlj.runtime。甲骨文; / ** MultiThreadDemo的每个实例都是一个线程，它在运行时为所有员工提供一些安装。主程序创建两个这样的实例，并在两个线程完成后计算净加注。** / class MultiThreadDemo扩展Thread {double raise; static Random randomizer = new Random（）; public static void main（String args []）{try {//设置在connect.properties文件中指定的URL，用户和密码的默认连接Oracle.connect（MultiThreadDemo.class，“connect.properties”） ; double avgStart = calcAvgSal（）; MultiThreadDemo t1 = new MultiThreadDemo（250.50）; MultiThreadDemo t2 = new MultiThreadDemo（150.50）; t1.start（）; t2.start（）; t1.join（）; t2.join（）; double avgEnd = calcAvgSal（）; System.out.println（“平均工资变化：”+（avgEnd  -  avgStart））; } catch（Exception e）{System.err.println（“运行示例时出错：”+ e）;尝试{#sql {ROLLBACK}; Oracle.close（）; } catch（SQLException e）{}} static double calcAvgSal（）抛出SQLException {double avg; #sql {SELECT AVG（薪水）INTO：avg FROM employees};返回平均MultiThreadDemo（double raise）{this.raise = raise; } public void run（）{//由于所有线程都使用相同的默认连接//上下文，因此每次运行都使用显式执行上下文实例来避免执行期间的冲突try {delay（）; ExecutionContext execCtx = new ExecutionContext（）; #sql [execCtx] {UPDATE EMPLOYEES SET salary = salary +：raise}; int updateCount = execCtx.getUpdateCount（）; System.out.println（“gave raise of”+ raise +“to”+ updateCount +“employees”）; } catch（SQLException e）{System.err.println（“错误更新员工：”+ e）; }} // delay用于将一些随机性引入执行顺序private void delay（）{try {sleep（（long）Math.abs（randomizer.nextInt（）/ 10000000））; } catch（InterruptedException e）{}}}</pre></div>
                  <!-- class="section" -->
               </div>
            </div><a id="JSQLJ549"></a><div class="sect2"><a id="GUID-9723BCED-0FA3-4AD9-B6C0-62B85B53C4EF" name="GUID-9723BCED-0FA3-4AD9-B6C0-62B85B53C4EF"></a><h3 id="JSQLJ-GUID-9723BCED-0FA3-4AD9-B6C0-62B85B53C4EF" class="sect3">迭代器类实现和高级功能</h3>
               <div>
                  <p>本节讨论如何实现迭代器类以及除基本方法之外还有哪些其他功能。涵盖以下主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="advanced-language-features.html#GUID-76C47911-9FAF-4F69-BDB0-6935ECF91997">迭代器类的实现和功能</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-language-features.html#GUID-6504E582-745D-4419-AE90-97CB95181C4C">使用迭代器声明中的IMPLEMENTS子句</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-language-features.html#GUID-C914EB64-E51C-465E-84D7-6ECCF4D782C1">支持扩展迭代器类</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-language-features.html#GUID-8A659A48-2847-4CC2-97B1-39116D628C9F">结果集迭代器</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-language-features.html#GUID-398B03B4-138D-41E6-A34B-B4911ACF7A18">可滚动迭代器</a></p>
                     </li>
                  </ul>
               </div><a id="JSQLJ550"></a><div class="props_rev_3"><a id="GUID-76C47911-9FAF-4F69-BDB0-6935ECF91997" name="GUID-76C47911-9FAF-4F69-BDB0-6935ECF91997"></a><h4 id="JSQLJ-GUID-76C47911-9FAF-4F69-BDB0-6935ECF91997" class="sect4">迭代器类的实现和功能</h4>
                  <div>
                     <p>您声明的任何命名迭代器类都将由SQLJ转换器生成，以实现<code class="codeph">sqlj.runtime.NamedIterator</code>接口。实现<code class="codeph">NamedIterator</code>接口的类具有按名称而不是按位置将迭代器列映射到数据库列的功能。
                     </p>
                     <p>您声明的任何位置迭代器类都将由SQLJ转换器生成，以实现<code class="codeph">sqlj.runtime.PositionedIterator</code>接口。实现<code class="codeph">PositionedIterator</code>接口的类具有按位置而不是按名称将迭代器列映射到数据库列的功能。
                     </p>
                     <p><code class="codeph">NamedIterator</code>接口和<code class="codeph">PositionedIterator</code>接口，以及所有生成的SQLJ迭代器类，都实现或扩展<code class="codeph">sqlj.runtime.ResultSetIterator</code>接口。
                     </p>
                     <p><code class="codeph">ResultSetIterator</code>接口为所有SQLJ迭代器指定以下方法：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">close()</code> ：关闭迭代器。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">ResultSet getResultSet()</code> ：从迭代器中提取底层JDBC结果集。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">boolean isClosed()</code> ：确定迭代器是否已关闭。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">boolean next()</code> ：移动到迭代器的下一行，如果有一个有效的下一行要返回，则返回<code class="codeph">true</code> 。
                           </p>
                        </li>
                     </ul>
                     <p><code class="codeph">PositionedIterator</code>接口为位置迭代器添加以下方法规范：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">boolean endFetch()</code> ：确定是否已到达位置迭代器的最后一行。
                           </p>
                        </li>
                     </ul>
                     <p>使用<code class="codeph">next()</code>方法推进命名迭代器和访问器方法的行以检索数据。命名迭代器类的SQLJ生成为每个迭代器列定义一个访问器方法，其中每个方法名称与相应的列名称相同。例如，如果声明<code class="codeph">name</code>列，则将生成<code class="codeph">name()</code>方法。
                     </p>
                     <p>使用<code class="codeph">FETCH INTO</code>语句和<code class="codeph">endFetch()</code>方法来推进位置迭代器的行并检索数据。<code class="codeph">FETCH INTO</code>语句隐式调用<code class="codeph">next()</code>方法。除非使用特殊的<code class="codeph">FETCH CURRENT</code>语法，否则不要在位置迭代器中显式使用<code class="codeph">next()</code>方法。<code class="codeph">FETCH INTO</code>语句还隐式调用根据迭代器列号命名的访问器方法。位置迭代器类的SQLJ生成为每个迭代器列定义一个访问器方法，其中每个方法名称对应于列位置。
                     </p>
                     <div class="infoboxnotealso" id="GUID-76C47911-9FAF-4F69-BDB0-6935ECF91997__GUID-3A08E78D-78BA-427F-945C-BBF3B6629557">
                        <p class="notep1">也可以看看：</p>
                        <p>\</p>
                     </div>
                     <p>完成后，使用<code class="codeph">close()</code>方法关闭任何迭代器。<code class="codeph">getResultSet()</code>方法是SQLJ-JDBC互操作性的核心。
                     </p>
                     <div class="infoboxnotealso" id="GUID-76C47911-9FAF-4F69-BDB0-6935ECF91997__GUID-DD33DB29-C265-44A8-ADE2-890A7DC83230">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="../jjdbc/resultset.html#JJDBC-GUID-41D05006-5470-4C1C-ACA0-A4B487B4D1C0" target="_blank"><span><cite>Oracle数据库JDBC开发人员指南</cite></span></a></p>
                     </div>
                     <div class="infoboxnote" id="GUID-76C47911-9FAF-4F69-BDB0-6935ECF91997__GUID-601C228E-D514-4C36-A064-080104C15AF7">
                        <p class="notep1">注意：</p>
                        <p>或者，您可以将<code class="codeph">ResultSetIterator</code>实例或<code class="codeph">ScrollableResultSetIterator</code>实例直接用作弱类型迭代器。（ <code class="codeph">ScrollableResultSetIterator</code>扩展了<code class="codeph">ResultSetIterator</code> 。）如果您只对将其转换为JDBC结果集并且不需要命名或位置迭代器功能感兴趣，这很方便。您也可以通过SQLJ <code class="codeph">FETCH CURRENT</code>语法访问它。
                        </p>
                     </div>
                  </div>
               </div><a id="JSQLJ551"></a><div class="props_rev_3"><a id="GUID-6504E582-745D-4419-AE90-97CB95181C4C" name="GUID-6504E582-745D-4419-AE90-97CB95181C4C"></a><h4 id="JSQLJ-GUID-6504E582-745D-4419-AE90-97CB95181C4C" class="sect4">使用迭代器声明中的IMPLEMENTS子句</h4>
                  <div>
                     <div class="section">
                        <p>在某些情况下，在迭代器声明中实现接口会很有用。例如，您可能有一个迭代器类，您希望限制对一个或多个列的访问。由SQLJ生成的命名迭代器类为迭代器中的每个列都有一个访问器方法。如果要限制对某些列的访问，可以创建仅包含访问器方法子集的接口，然后将接口类型的实例公开给用户，而不是公开迭代器类类型的实例。</p>
                        <p>例如，假设您正在创建员工数据的命名迭代器，其中包含<code class="codeph">ENAME</code> （员工姓名）， <code class="codeph">EMPNO</code> （员工编号）和<code class="codeph">SAL</code> （薪水）列。完成如下：</p><pre class="oac_no_warn" dir="ltr">#sql iterator EmpIter（String ename，int empno，float sal）;</pre><p>这将生成一个带有<code class="codeph">ename()</code> ， <code class="codeph">empno()</code>和<code class="codeph">sal()</code>访问器方法的类<code class="codeph">EmpIter</code> 。
                        </p>
                        <p>但是，假设您要阻止访问<code class="codeph">SAL</code>列。您可以创建一个具有<code class="codeph">ename()</code>和<code class="codeph">empno()</code>方法的<code class="codeph">EmpIterIntfc</code>接口，但不能创建<code class="codeph">sal()</code>方法。然后你可以使用以下迭代器声明而不是前面的声明（假设<code class="codeph">EmpIterIntfc</code>在<code class="codeph">mypackage</code>包中）：</p><pre class="oac_no_warn" dir="ltr">#sql iterator EmpIter实现mypackage。EmpIterIntfc（String emame，int empno，float sal）;</pre><p>然后，如果您对应用程序进行编码，以便用户只能通过<code class="codeph">EmpIterIntfc</code>实例访问数据，那么他们将无法访问<code class="codeph">SAL</code>列。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ552"></a><div class="props_rev_3"><a id="GUID-C914EB64-E51C-465E-84D7-6ECCF4D782C1" name="GUID-C914EB64-E51C-465E-84D7-6ECCF4D782C1"></a><h4 id="JSQLJ-GUID-C914EB64-E51C-465E-84D7-6ECCF4D782C1" class="sect4">支持扩展迭代器类</h4>
                  <div>
                     <div class="section">
                        <p>SQLJ支持扩展迭代器类的能力。此功能在允许您向查询和查询结果添加功能方面非常有用。</p>
                        <p>迭代器子类的一个关键要求是必须提供一个带有<code class="codeph">sqlj.runtime.实例的公共构造<code class="codeph">sqlj.runtime.RTResultSet</code>作为输入。SQLJ运行时将调用此构造函数将查询结果分配给子类的实例。除此之外，您还可以根据自己的选择提供功能。
                        </p>
                        <p>您可以继续使用原始迭代器类（子类的超类）的功能。例如，您可以通过调用<code class="codeph">super.next()</code>方法来提前查询结果。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ553"></a><div class="props_rev_3"><a id="GUID-8A659A48-2847-4CC2-97B1-39116D628C9F" name="GUID-8A659A48-2847-4CC2-97B1-39116D628C9F"></a><h4 id="JSQLJ-GUID-8A659A48-2847-4CC2-97B1-39116D628C9F" class="sect4">结果集迭代器</h4>
                  <div>
                     <p>您可能遇到不需要SQLJ迭代器的强类型功能的情况。</p>
                     <p>对于这种情况，您可以直接使用<code class="codeph">sqlj.runtime.实例<code class="codeph">sqlj.runtime.ResultSetIterator</code>类型用于接收查询数据，因此您不需要声明命名或位置迭代器类。或者，您可以使用<code class="codeph">sqlj.runtime.ScrollableResultSetIterator</code>类型，它扩展了<code class="codeph">ResultSetIterator</code> 。这使您可以使用SQLJ可滚动迭代器功能。在使用结果集迭代器而不是强类型迭代器时，您正在交易SQLJ <code class="codeph">SELECT</code>操作的强类型检查，以方便不必声明迭代器类。
                     </p>
                     <p><code class="codeph">ResultSetIterator</code>接口是所有命名和位置迭代器类的基础，并指定<code class="codeph">getResultSet()</code>和<code class="codeph">close()</code>方法。如果要使用SQLJ处理结果集迭代器实例，请使用<code class="codeph">ScrollableResultSetIterator</code>实例和<code class="codeph">FETCH CURRENT</code>语法。
                     </p>
                     <p>如果要使用JDBC处理结果集迭代器实例，可以使用其<code class="codeph">getResultSet()</code>方法，然后处理检索的基础结果集。如果通过其底层结果集处理结果集迭代器，则应在完成后关闭结果集迭代器而不是结果集。关闭结果集迭代器也将关闭结果集，但关闭结果集将不会关闭结果集迭代器。
                     </p>
                     <div class="infoboxnote" id="GUID-8A659A48-2847-4CC2-97B1-39116D628C9F__GUID-21A3B7E6-E59E-49DC-B0EF-65023D4CE482">
                        <p class="notep1">注意：</p>
                        <p>Oracle SQLJ实现支持结果集迭代器，用作主机表达式并表示<code class="codeph">FETCH</code>语句中的游标。在Oracle9 <span class="italic">i</span>数据库之前不支持此功能。
                        </p>
                     </div>
                  </div>
               </div><a id="JSQLJ555"></a><a id="JSQLJ556"></a><a id="JSQLJ557"></a><a id="JSQLJ558"></a><a id="JSQLJ559"></a><a id="JSQLJ560"></a><a id="JSQLJ561"></a><a id="JSQLJ554"></a><div class="props_rev_3"><a id="GUID-398B03B4-138D-41E6-A34B-B4911ACF7A18" name="GUID-398B03B4-138D-41E6-A34B-B4911ACF7A18"></a><h4 id="JSQLJ-GUID-398B03B4-138D-41E6-A34B-B4911ACF7A18" class="sect4">可滚动迭代器</h4>
                  <div>
                     <p>SQLJ的ISO标准支持可滚动迭代器，其功能在JDBC 2.0规范之后用于可滚动JDBC结果集。Oracle SQLJ实现支持此功能。</p>
                     <div class="infoboxnotealso" id="GUID-398B03B4-138D-41E6-A34B-B4911ACF7A18__GUID-5410F46A-3E0C-4996-B41F-796BDFA16C1C">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="../jjdbc/resultset.html#JJDBC-GUID-F29ED77D-7BD2-4044-94F2-F53A0739701F" target="_blank"><span class="italic">Oracle数据库JDBC开发人员指南</span></a></p>
                     </div>
                     <div class="section" id="GUID-398B03B4-138D-41E6-A34B-B4911ACF7A18__I1006761">
                        <p class="subhead3" id="GUID-398B03B4-138D-41E6-A34B-B4911ACF7A18__GUID-AD609C89-825F-480A-9A28-4CD88F918EC4">声明可滚动迭代器</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>要将迭代器表征为可滚动，请将以下子句添加到迭代器声明：</p><pre class="oac_no_warn" dir="ltr">实现sqlj.runtime。滚动</pre><p>这指示SQLJ转换器生成实现<code class="codeph">Scrollable</code>接口的迭代器。以下是声明命名的可滚动迭代器的示例：</p><pre class="oac_no_warn" dir="ltr">#sql public static MyScrIter实现了sqlj.runtime。Scrollable（String ename，int empno）;</pre><p>SQLJ转换器为<code class="codeph">MyScrIter</code>类生成的代码将自动支持<code class="codeph">Scrollable</code>接口的所有方法。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-398B03B4-138D-41E6-A34B-B4911ACF7A18__I1006775">
                        <p class="subhead3" id="GUID-398B03B4-138D-41E6-A34B-B4911ACF7A18__GUID-06C2FB02-8C6F-44AF-A7D0-2ABB2A1429ED">可滚动迭代器灵敏度</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>您可以声明可滚动迭代器（如可滚动结果集），以便对基础数据的更改具有敏感性。默认情况下，Oracle SQLJ实现中的可滚动迭代器的<code class="codeph">sensitivity</code>设置为<code class="codeph">INSENSITIVE</code> ，这意味着它们不会检测基础数据中的任何此类更改。但是，您可以使用<code class="codeph">with</code>子句来更改此设置。以下示例展开了前面的示例以指定灵敏度：</p><pre class="oac_no_warn" dir="ltr">#sql public static MyScrIter实现了sqlj.runtime。可滚动的（sensitivity = SENSITIVE）（String ename，int empno）;</pre><div class="infoboxnote" id="GUID-398B03B4-138D-41E6-A34B-B4911ACF7A18__GUID-0387B448-20D7-4643-B5C0-8E29960AD331">
                           <p class="notep1">注意：</p>
                           <p><code class="codeph">implements</code>子句必须在<code class="codeph">with</code>子句之前。
                           </p>
                        </div>
                        <p>SQLJ标准还允许设置<code class="codeph">ASENSITIVE</code> ，这意味着接受数据库的默认<code class="codeph">sensitivity</code> 。但是，在Oracle中，如果将<code class="codeph">sensitivity</code>设置为<code class="codeph">ASENSITIVE</code> ，则会导致使用默认设置<code class="codeph">INSENSITIVE</code> 。
                        </p>
                        <p>鉴于前面的声明， <code class="codeph">MyScrIter</code>实例将对数据更改敏感，受制于获取大小窗口等因素。
                        </p>
                        <div class="infoboxnotealso" id="GUID-398B03B4-138D-41E6-A34B-B4911ACF7A18__GUID-822F6292-D459-4028-9597-F3957411AFA6">
                           <p class="notep1">也可以看看：</p>
                           <p>有关可滚动结果集的信息，请参见<a href="../jjdbc/resultset.html#JJDBC-GUID-16116A5C-1A33-4F65-B9DD-1BDCE925343B" target="_blank"><span class="italic">“Oracle数据库JDBC开发人员指南”</span></a></p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-398B03B4-138D-41E6-A34B-B4911ACF7A18__I1006795">
                        <p class="subhead3" id="GUID-398B03B4-138D-41E6-A34B-B4911ACF7A18__GUID-B32E1907-1580-4FC8-8C0D-1027440A2D09">可滚动界面</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>本节介绍了<code class="codeph">sqlj.runtime.一些关键方法<code class="codeph">sqlj.runtime.Scrollable</code>界面。
                        </p>
                        <p>您可以提供有关可滚动迭代器的获取方向的提示。在可滚动迭代器和执行上下文中定义了以下方法。使用<code class="codeph">ExecutionContext</code>实例提供在创建可滚动迭代器时使用的默认方向。
                        </p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">setFetchDirection(int)</code> ：为SQLJ运行时提供有关处理行的方向的提示。方向应该是<code class="codeph">sqlj.runtime.ResultSetIterator。FETCH_FORWARD</code> ， <code class="codeph">FETCH_REVERSE</code>或<code class="codeph">FETCH_UNKNOWN</code> 。</p>
                              <p>如果未在<code class="codeph">ExecutionContext</code>上指定方向的值，则<code class="codeph">FETCH_FORWARD</code>将用作默认值。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">int getFetchDirection()</code> ：获取获取数据行的当前方向（上一点中描述的整数常量之一）。
                              </p>
                           </li>
                        </ul>
                        <p>还有一些可滚动的迭代器方法，它们将返回有关底层结果集中迭代器对象的当前位置的信息。只要迭代器底层的结果集不包含任何行，所有这些方法都将返回<code class="codeph">false</code> ：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">boolean isBeforeFirst()</code> ：指示迭代器对象是否在结果集中的第一行之前。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">boolean isFirst()</code> ：指示迭代器对象是否在结果集的第一行。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">boolean isLast()</code> ：指示迭代器对象是否在结果集的最后一行。请注意，调用<code class="codeph">isLast()</code>方法可能很昂贵，因为JDBC驱动程序可能必须提前一行来确定当前行是否是结果集中的最后一行。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">boolean isAfterLast()</code> ：指示迭代器对象是否在结果集的最后一行之后。
                              </p>
                           </li>
                        </ul>
                        <div class="infoboxnote" id="GUID-398B03B4-138D-41E6-A34B-B4911ACF7A18__GUID-56CDDC95-CBCD-4A7B-853E-BEA81DEC4DDD">
                           <p class="notep1">注意：</p>
                           <p>还可以使用在<code class="codeph">Scrollable</code>界面中定义的其他导航方法。
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-398B03B4-138D-41E6-A34B-B4911ACF7A18__I1006816">
                        <p class="subhead3" id="GUID-398B03B4-138D-41E6-A34B-B4911ACF7A18__GUID-52384EFC-4A97-4B52-A495-6B562DA00979">可滚动命名的迭代器</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>命名迭代器使用在<code class="codeph">Scrollable</code>接口中定义的导航方法来遍历结果集的行。如本手册前面所述，不可滚动的迭代器只有以下导航方法：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">boolean next()</code> ：将迭代器对象移动到结果集中的下一行。
                              </p>
                           </li>
                        </ul>
                        <div class="infoboxnotealso" id="GUID-398B03B4-138D-41E6-A34B-B4911ACF7A18__GUID-2B265A7D-0D2A-4C96-BB06-40CD192BAC89">
                           <p class="notep1">也可以看看：</p>
                           <p><span class="q">“ <a href="basic-language-features.html#GUID-FF318201-3A54-450E-AC86-616665E03DE2">使用命名迭代器</a> ”</span></p>
                        </div>
                        <p>其他导航方法可用于可滚动的命名迭代器。这些方法的功能与<code class="codeph">next()</code>方法类似。因为他们试图将迭代器放在结果集的实际行上。如果迭代器最终在有效行上，则返回<code class="codeph">true</code>否则返回<code class="codeph">false</code> 。此外，如果尝试将迭代器对象放在结果集中的第一行之前或最后一行之后，则会将迭代器对象分别保留在“前一个”或“后一个”位置。
                        </p>
                        <p>支持以下方法：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">boolean previous()</code> ：将迭代器对象移动到结果集中的上一行。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">boolean first()</code> ：将迭代器对象移动到结果集中的第一行。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">boolean last()</code> ：将迭代器对象移动到结果集中的最后一行。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">boolean absolute(int)</code> ：将迭代器对象移动到结果集中的给定行号。第一行是第1行，第二行是第2行，依此类推。如果给定的行号为负数，则迭代器对象将移动到相对于结果集末尾的行位置。例如，调用<code class="codeph">absolute(-1)</code>将迭代器对象放在最后一行上， <code class="codeph">absolute(-2)</code>表示倒数第二行，依此类推。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">boolean relative(int)</code> ：将迭代器对象移动一个相对的行数，从当前位置开始为正数或负数。调用<code class="codeph">relative(0)</code>是有效的，但不会更改迭代器位置。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">void beforeFirst()</code> ：在第一行之前将迭代器对象移动到结果集的前面。如果结果集不包含任何行，则无效。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">void afterLast()</code> ：将迭代器对象移动到最后一行之后的结果集的末尾。如果结果集不包含任何行，则无效。
                              </p>
                           </li>
                        </ul>
                        <div class="infoboxnote" id="GUID-398B03B4-138D-41E6-A34B-B4911ACF7A18__GUID-DE0ED949-46F2-4A00-9A23-9FB96C09F3EF">
                           <p class="notep1">注意：</p>
                           <p><code class="codeph">beforeFirst()</code>和<code class="codeph">afterLast()</code>方法返回<code class="codeph">void</code> ，因为它们从不将迭代器对象放在结果集的实际行上。
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-398B03B4-138D-41E6-A34B-B4911ACF7A18__GUID-F790EA73-4BE5-4A91-B6DF-CF1CA7DC7290">可滚动位置迭代器</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>前面已经在<span class="q">“ <a href="basic-language-features.html#GUID-C99760AC-46A2-446C-8CA6-D032FC4C303D">使用位置迭代器</a> ”中</span>描述了位置迭代器的一般<code class="codeph">FETCH</code>语法。例如：</p><pre class="oac_no_warn" dir="ltr">#sql {FETCH：iter INTO：x，：y，：z};</pre><p>这实际上是以下语法的缩写版本：</p><pre class="oac_no_warn" dir="ltr">#sql {FETCH NEXT FROM：iter INTO：x，：y，：z};</pre><p>这表明了交替移动到结果集中的前一行，第一行或最后一行的模式。不幸的是，JDBC 2.0在运动方法建模之后使用了<code class="codeph">previous()</code> 。在SQL之后构图的<code class="codeph">FETCH</code>语法使用<code class="codeph">PRIOR</code> 。如果您忘记了这种不一致，Oracle Database 12 <span class="italic">c</span>第1版（12.1）SQLJ转换程序也将接受<code class="codeph">FETCH PREVIOUS</code> 。</p>
                        <p>语法是：</p><pre class="oac_no_warn" dir="ltr">#sql {FETCH PRIOR FROM：iter INTO：x，：y，：z}; #sql {FETCH FIRST FROM：iter INTO：x，：y，：z}; #sql {FETCH LAST FROM：iter INTO：x，：y，：z};</pre><p>还有一种语法可以传递绝对或相对移动的数值，移动到特定（绝对）行，或从当前位置向前或向后移动。语法是：</p><pre class="oac_no_warn" dir="ltr">#sql {FETCH ABSOLUTE：n FROM：iter INTO：x，：y，：z}; #sql {FETCH RELATIVE：n FROM：iter INTO：x，：y，：z};</pre><div class="infoboxnote" id="GUID-398B03B4-138D-41E6-A34B-B4911ACF7A18__GUID-9D6D40D6-1CB2-48AE-A040-585FA3394A29">
                           <p class="notep1">注意：</p>
                           <p>在所有前面的情况中，只要<code class="codeph">FETCH</code>无法移动到有效行并检索值，迭代器<code class="codeph">endFetch()</code>方法就会返回<code class="codeph">true</code> 。
                           </p>
                        </div>
                        <p>请注意， <span class="italic">必须</span>使用主机表达式指定移动。您不能简单地使用常量作为数值。因此，而不是以下：</p><pre class="oac_no_warn" dir="ltr">#sql {FETCH RELATIVE 0 FROM：iter INTO：x，：y，：z};</pre><p>您必须写下以下内容：</p><pre class="oac_no_warn" dir="ltr">#sql {FETCH RELATIVE：（0）FROM：iter INTO：x，：y，：z};</pre><p>顺便说一下，这个命令使迭代器的位置保持不变。如果迭代器位于有效行上，则该命令只会填充变量。</p>
                        <div class="infoboxnote" id="GUID-398B03B4-138D-41E6-A34B-B4911ACF7A18__GUID-212957F3-D936-4441-9F85-882AEC922151">
                           <p class="notep1">注意：</p>
                           <p>或者，您可以通过导航方法和<code class="codeph">FETCH CURRENT</code>语法的组合来浏览可滚动的位置迭代器。
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-398B03B4-138D-41E6-A34B-B4911ACF7A18__I1006889">
                        <p class="subhead3" id="GUID-398B03B4-138D-41E6-A34B-B4911ACF7A18__GUID-F5C4C5CB-384E-4025-8D18-1B74AC09CBE3">FETCH CURRENT语法：从JDBC结果集到SQLJ迭代器</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>考虑一种情况，即您希望在SQLJ中重写现有的JDBC程序，并尽可能少地进行修改。</p>
                        <p>JDBC结果集将仅使用移动方法，例如<code class="codeph">next()</code> ， <code class="codeph">previous()</code> ， <code class="codeph">absolute()</code>等。您可以通过命名迭代器立即在SQLJ中对此进行建模。但是，这也意味着SQL结果集的所有列都必须具有正确的名称。实际上，结果集的许多列（如果不是全部的话）都需要引入别名。如果查询文本保持不变，这是不可接受的。
                        </p>
                        <p>为避免更改查询源，替代方法是为结果集定义位置迭代器类型。但是，这种方法强制改变程序的控制流逻辑。请考虑以下JDBC代码示例：</p><pre class="oac_no_warn" dir="ltr">ResultSet rs = ... //执行...查询...; while（rs.next（））{x：= rs.get <span class="italic">Xxx</span> （1）; y：= rs.get <span class="italic">Xxx</span> （2）; ...... <span class="italic">过程</span> ......}</pre><p>这将以下几行转换为SQLJ：</p><pre class="oac_no_warn" dir="ltr">MyIter iter; #sql iter = {...查询...}; while（true）{#sql {FETCH：iter INTO：x，：y}; if（iter.endFetch（））中断; ...处理...}</pre><p>在考虑可滚动迭代器上的任意移动时，对程序逻辑的转换将变得更加困难。因为位置迭代器实现了命名迭代器的所有移动命令，所以可以利用它并使用<code class="codeph">RELATIVE :(0)</code>来填充迭代器中的变量：</p><pre class="oac_no_warn" dir="ltr">MyIter iter; #sql iter = {...查询...}; while（iter.next（））{#sql {FETCH RELATIVE：（0）FROM：iter INTO：x，：y}; ...处理...}</pre><p>现在，您可以保留原始查询和原始程序逻辑。不幸的是，这种方法仍有一个缺点。<code class="codeph">MyIter</code>迭代器类型必须实现<code class="codeph">Scrollable</code>接口，即使实际上不需要此属性。为解决此问题，Oracle SQLJ实现支持以下语法扩展：</p><pre class="oac_no_warn" dir="ltr">#sql {FETCH CURRENT FROM：iter INTO：x，：y，：z};</pre><p>鉴于此语法，您可以在SQLJ中重写JDBC示例以用于可滚动和不可滚动的迭代器：</p><pre class="oac_no_warn" dir="ltr">AnyIterator ai; #sql ai = {...查询...}; while（ai.next（））{＃sql {FETCH CURRENT FROM：ai INTO：x，：y}; ...... <span class="italic">过程</span> ......}</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-398B03B4-138D-41E6-A34B-B4911ACF7A18__GUID-3412CA95-37F0-4F1B-A061-97CE49C663D7">可滚动结果集迭代器</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>对于弱类型结果集迭代器，Oracle SQLJ实现中的支持包括一个可滚动的结果集迭代器类型：</p><pre class="oac_no_warn" dir="ltr">package sqlj.runtime;公共接口ScrollableResultSetIterator扩展ResultSetIterator实现Scrollable {}</pre><p>因为这种类型扩展了<code class="codeph">sqlj.runtime.ResultSetIterator</code> ，它支持<span class="q">“ <a href="advanced-language-features.html#GUID-8A659A48-2847-4CC2-97B1-39116D628C9F">结果集迭代器</a> ”中</span>描述的方法。
                        </p>
                        <p>因为它还实现了<code class="codeph">sqlj.runtime.Scrollable</code>接口，它支持<span class="q">“ <a href="advanced-language-features.html#GUID-398B03B4-138D-41E6-A34B-B4911ACF7A18">Scrollable Iterators</a> ”</span>和<span class="q">“ <a href="advanced-language-features.html#GUID-398B03B4-138D-41E6-A34B-B4911ACF7A18">Scrollable Iterators</a> ”中</span>描述的方法。
                        </p>
                        <p>此外，可滚动结果集迭代器支持<span class="q">“可<a href="advanced-language-features.html#GUID-398B03B4-138D-41E6-A34B-B4911ACF7A18">滚动迭代器</a> ”中</span>描述的<code class="codeph">FETCH CURRENT</code>语法。
                        </p>
                        <p>请考虑以下JDBC代码：</p><pre class="oac_no_warn" dir="ltr">Statement st = conn.createStatement（“SELECT first_name，employee_id FROM employees”）; ResultSet rs = st.executeQuery（）; while（rs.next（））{x = rs.getString（1）; y = rs.getInt（2）; } rs.close（）;</pre><p>您可以在编写等效代码时使用SQLJ结果集迭代器，如下所示：</p><pre class="oac_no_warn" dir="ltr">sqlj.runtime。ResultSetIterator rsi; #sql rsi = {SELECT first_name，employee_id FROM employees}; while（rsi.next（））{＃sql {FETCH CURRENT FROM：rsi INTO：x，：y}; } rsi.close（）;</pre><p>要利用可滚动功能，您还可以编写以下代码：</p><pre class="oac_no_warn" dir="ltr">sqlj.runtime。ScrollableResultSetIterator srsi; #sql srsi = {SELECT first_name，employee_id FROM employees}; srsi.afterLast（）; while（srsi.previous（））{#sql {FETCH CURRENT FROM：srsi INTO：x，：y}; } srsi.close（）;</pre></div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="JSQLJ562"></a><div class="sect2"><a id="GUID-3B7EEA7A-5E45-4455-8255-2A5C1334DAD8" name="GUID-3B7EEA7A-5E45-4455-8255-2A5C1334DAD8"></a><h3 id="JSQLJ-GUID-3B7EEA7A-5E45-4455-8255-2A5C1334DAD8" class="sect3">高级交易控制</h3>
               <div>
                  <p>SQLJ支持SQL <code class="codeph">SET TRANSACTION</code>语句来指定任何给定事务的访问模式和隔离级别。标准SQLJ支持<code class="codeph">READ ONLY</code>和<code class="codeph">READ WRITE</code>访问模式设置，但Oracle JDBC实现不支持<code class="codeph">READ ONLY</code> 。但是，您可以将权限设置为具有相同的效果。隔离级别支持的设置为<code class="codeph">SERIALIZABLE</code> ， <code class="codeph">READ COMMITTED</code> ， <code class="codeph">READ UNCOMMITTED</code>和<code class="codeph">REPEATABLE READ</code> 。但是，Oracle SQL实现不支持<code class="codeph">READ UNCOMMITTED</code>或<code class="codeph">REPEATABLE READ</code> 。</p>
                  <p><code class="codeph">READ WRITE</code>是标准SQL和Oracle SQL实现中的默认访问模式。<code class="codeph">READ COMMITTED</code>是Oracle SQL实现中的默认隔离级别。<code class="codeph">SERIALIZABLE</code>是标准SQL中的默认值。</p>
                  <p>以下部分提供了详细信息：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="advanced-language-features.html#GUID-EE04BE5C-95AD-4919-A890-15AF1D223A7B">SET TRANSACTION语法</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-language-features.html#GUID-930E9F53-1611-4999-8A17-73CDD7E6E649">访问模式设置</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-language-features.html#GUID-A912E09C-A148-4E60-BEE1-6E70A71B7F4B">隔离级别设置</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-language-features.html#GUID-958C951B-678A-417B-959F-354975386F77">使用JDBC连接类方法</a></p>
                     </li>
                  </ul>
                  <div class="infoboxnotealso" id="GUID-3B7EEA7A-5E45-4455-8255-2A5C1334DAD8__GUID-D211C78E-E1B7-4B27-8042-9EBB18B6DD95">
                     <p class="notep1">也可以看看：</p>
                     <p><span class="q">“ <a href="key-programming-considerations.html#GUID-6F37BE89-6EA0-4B27-884A-C0D4E8746E97">基本交易控制</a> ”</span></p>
                  </div>
               </div><a id="JSQLJ563"></a><div class="sect3"><a id="GUID-EE04BE5C-95AD-4919-A890-15AF1D223A7B" name="GUID-EE04BE5C-95AD-4919-A890-15AF1D223A7B"></a><h4 id="JSQLJ-GUID-EE04BE5C-95AD-4919-A890-15AF1D223A7B" class="sect4">SET TRANSACTION语法</h4>
                  <div>
                     <p>SQLJ <code class="codeph">SET TRANSACTION</code>语句具有以下语法：</p><pre class="oac_no_warn" dir="ltr">#sql {SET TRANSACTION &lt; <span class="italic">access_mode</span> &gt;，&lt;ISOLATION LEVEL <span class="italic">isolation_level</span> &gt;};</pre><p>如果未指定连接上下文实例，则该语句将应用于默认连接。如果使用<code class="codeph">SET TRANSACTION</code> ，则它必须是事务中的第一个语句，位于任何DML语句之前。换句话说，自从您连接到数据库或最近的<code class="codeph">COMMIT</code>或<code class="codeph">ROLLBACK</code>以来的第一个语句。</p>
                     <p>在标准SQLJ中，您设置的任何访问模式或隔离级别将在事务中保持有效，直到您在后续事务开始时显式重置它。在标准SQLJ <code class="codeph">SET TRANSACTION</code>语句中，您可以选择首先指定隔离级别，或仅指定访问模式或仅指定隔离级别。以下是一些例子：</p><pre class="oac_no_warn" dir="ltr">#sql {SET TRANSACTION READ WRITE}; #sql {SET TRANSACTION ISOLATION LEVEL SERIALIZABLE}; #sql {SET TRANSACTION READ WRITE，ISOLATION LEVEL SERIALIZABLE}; #sql {SET TRANSACTION ISOLATION LEVEL READ COMMITTED，READ WRITE};</pre><p>您还可以为<code class="codeph">SET TRANSACTION</code>语句指定特定的连接上下文实例，而不是将其应用于默认连接：</p><pre class="oac_no_warn" dir="ltr">#sql [myCtxt] {SET TRANSACTION ISOLATION LEVEL SERIALIZABLE};</pre><p>请注意，在SQLJ中，可以在单个<code class="codeph">SET TRANSACTION</code>语句中设置访问模式和隔离级别。在其他Oracle SQL工具中并非如此，例如服务器管理器或SQL * Plus，其中单个语句可以设置一个或另一个，但不能同时设置两者。
                     </p>
                  </div>
               </div><a id="JSQLJ564"></a><div class="sect3"><a id="GUID-930E9F53-1611-4999-8A17-73CDD7E6E649" name="GUID-930E9F53-1611-4999-8A17-73CDD7E6E649"></a><h4 id="JSQLJ-GUID-930E9F53-1611-4999-8A17-73CDD7E6E649" class="sect4">访问模式设置</h4>
                  <div>
                     <p><a id="d36232e4526" class="indexterm-anchor"></a><a id="d36232e4528" class="indexterm-anchor"></a>支持的<code class="codeph">READ WRITE</code>和<code class="codeph">READ ONLY</code>访问模式设置具有以下功能：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">READ WRITE</code> （默认值）：在<code class="codeph">READ WRITE</code>事务中，不允许更新数据库。<code class="codeph">SELECT</code> ， <code class="codeph">INSERT</code> ， <code class="codeph">UPDATE</code>和<code class="codeph">DELETE</code>都是合法的。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">READ ONLY</code> （也由Oracle JDBC实现支持）：在<code class="codeph">READ ONLY</code>事务中，不允许更新数据库。<code class="codeph">SELECT</code>是合法的，但<code class="codeph">INSERT</code> ， <code class="codeph">UPDATE</code> ， <code class="codeph">DELETE</code>和<code class="codeph">SELECT FOR UPDATE</code>不是。
                           </p>
                        </li>
                     </ul>
                  </div>
               </div><a id="JSQLJ565"></a><div class="sect3"><a id="GUID-A912E09C-A148-4E60-BEE1-6E70A71B7F4B" name="GUID-A912E09C-A148-4E60-BEE1-6E70A71B7F4B"></a><h4 id="JSQLJ-GUID-A912E09C-A148-4E60-BEE1-6E70A71B7F4B" class="sect4">隔离级别设置</h4>
                  <div>
                     <p><a id="d36232e4614" class="indexterm-anchor"></a><a id="d36232e4616" class="indexterm-anchor"></a><a id="d36232e4618" class="indexterm-anchor"></a><a id="d36232e4620" class="indexterm-anchor"></a><a id="d36232e4622" class="indexterm-anchor"></a><a id="d36232e4624" class="indexterm-anchor"></a><a id="d36232e4626" class="indexterm-anchor"></a> <code class="codeph">READ COMMITTED</code> ， <code class="codeph">SERIALIZABLE</code> ， <code class="codeph">READ UNCOMMITTED</code>和<code class="codeph">REPEATABLE READ</code>隔离级别设置（如果支持）具有以下功能：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">READ UNCOMMITTED</code> ：允许读取脏读，不可重复读取和幻像读取。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">READ COMMITTED</code> （默认值）：防止脏读，并允许不可重复的读取和幻像读取。如果事务包含需要由其他事务持有行锁的DML语句，则任何语句都将阻塞，直到其所需的行锁被另一个事务释放。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">REPEATABLE READ</code> ：防止脏读和不可重复读，并允许幻读。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">SERIALIZABLE</code> ：可以防止脏读，不可重复读和幻像读。事务中的任何DML语句都无法更新可能在事务开始后提交更改的任何资源。这样的DML语句将失败。
                           </p>
                        </li>
                     </ul>
                     <p>当事务B访问由事务A更新的行时发生脏读，但事务A稍后回滚更新。结果，事务B看到从未实际提交到数据库的数据。</p>
                     <p>当事务A检索行时，事务B随后更新该行，而事务A稍后再次检索同一行，则发生不可重复的读取。事务A检索同一行两次但看到不同的数据。</p>
                     <p>当事务A检索满足给定条件的一组行时发生虚拟读取，事务B随后插入或更新行，使得该行现在满足事务A中的条件，并且事务A稍后重复条件检索。事务A现在看到一个额外的行。这一行被称为幻像。</p>
                     <p>您可以想到四个隔离级别设置正在进行中：</p><pre class="oac_no_warn" dir="ltr">SERIALIZABLE&gt; REPEATABLE READ&gt; READ COMMITTED&gt; READ UNCOMMITTED</pre><p>如果您无法使用所需的设置，例如，如果使用Oracle Database 12 <span class="italic">c</span>第1版（12.1），则<code class="codeph">REPEATABLE READ</code>或<code class="codeph">READ UNCOMMITTED</code> ，请使用更大的设置（左侧更远）以确保至少具有隔离级别你要。
                     </p>
                     <div class="infoboxnotealso" id="GUID-A912E09C-A148-4E60-BEE1-6E70A71B7F4B__GUID-F09CEDE1-E9AD-4218-B93F-BF82303A5C50">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="../adfns/sql-processing-for-application-developers.html#ADFNS-GUID-6F888B25-FB84-456F-BF6E-675C955D3E52" target="_blank"><span class="italic">Oracle数据库开发指南</span></a></p>
                     </div>
                  </div>
               </div><a id="JSQLJ566"></a><div class="sect3"><a id="GUID-958C951B-678A-417B-959F-354975386F77" name="GUID-958C951B-678A-417B-959F-354975386F77"></a><h4 id="JSQLJ-GUID-958C951B-678A-417B-959F-354975386F77" class="sect4">使用JDBC连接类方法</h4>
                  <div>
                     <p>您可以使用连接上下文实例的基础JDBC连接实例的方法，选择性地访问和设置事务的访问模式和隔离级别。但是，使用这些JDBC方法的SQLJ代码不可移植。</p>
                     <p>以下是访问模式和隔离级别设置的<code class="codeph">Connection</code>类方法：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">abstract int getTransactionIsolation()</code> ：将当前事务隔离级别作为以下常量值之一返回：</p>
                           <p><code class="codeph">TRANSACTION_NONE TRANSACTION_READ_COMMITTED TRANSACTION_SERIALIZABLE TRANSACTION_READ_UNCOMMITTED TRANSACTION_REPEATABLE_READ</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">abstract void setTransactionIsolation(int)</code> ：设置事务隔离级别，将前一个常量值作为输入。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">abstract boolean isReadOnly()</code> ：如果事务是<code class="codeph">READ ONLY</code>则返回<code class="codeph">true</code> 。如果事务是<code class="codeph">READ WRITE</code>则返回<code class="codeph">false</code> 。</p>
                        </li>
                        <li>
                           <p><code class="codeph">abstract void setReadOnly(boolean)</code> ：如果输入<code class="codeph">true</code>则将事务访问模式设置为<code class="codeph">READ ONLY</code> 。如果输入<code class="codeph">false</code>则将访问模式设置为<code class="codeph">READ WRITE</code> 。
                           </p>
                        </li>
                     </ul>
                  </div>
               </div>
            </div><a id="JSQLJ567"></a><div class="sect2"><a id="GUID-8AF6CBB6-D6B3-44AB-99D5-5ADF6495E568" name="GUID-8AF6CBB6-D6B3-44AB-99D5-5ADF6495E568"></a><h3 id="JSQLJ-GUID-8AF6CBB6-D6B3-44AB-99D5-5ADF6495E568" class="sect3">SQLJ和JDBC互操作性</h3>
               <div>
                  <p>SQLJ <a id="d36232e4812" class="indexterm-anchor"></a>语句通常用于静态SQL操作。Oracle Database 12 <span class="italic">c</span>第1版（12.1）也有扩展以支持动态SQL，但另一种方法是在SQLJ应用程序中使用JDBC代码进行动态操作，这样可以更加轻松。可能还有其他情况，在SQLJ应用程序中使用JDBC代码可能有用甚至是必需的。因此，SQLJ使您可以同时使用SQLJ和JDBC语句，并提供SQLJ和JDBC构造之间的互操作性。
                  </p>
                  <p>SQLJ和JDBC之间的两种交互特别有用：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>在SQLJ连接上下文和JDBC连接之间</p>
                     </li>
                     <li>
                        <p>在SQLJ迭代器和JDBC结果集之间</p>
                     </li>
                  </ul>
                  <div class="infoboxnotealso" id="GUID-8AF6CBB6-D6B3-44AB-99D5-5ADF6495E568__GUID-356C7DBE-59E2-4EC2-B61B-96AD0F8D2541">
                     <p class="notep1">也可以看看：</p>
                     <p><a href="../jjdbc/JDBC-getting-started.html#JJDBC-GUID-A7809785-56AF-4BD1-A04D-E69CA03489C5" target="_blank"><span class="italic">Oracle数据库JDBC开发人员指南</span></a></p>
                  </div>
                  <p>本节包括以下主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="advanced-language-features.html#GUID-340AFCEF-E421-46F9-B136-DF9CC3723310">SQLJ连接上下文和JDBC连接互操作性</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-language-features.html#GUID-76329A99-A510-4BEB-8271-46F689A10D2D">SQLJ迭代器和JDBC结果集互操作性</a></p>
                     </li>
                  </ul>
               </div><a id="JSQLJ569"></a><a id="JSQLJ570"></a><a id="JSQLJ571"></a><a id="JSQLJ572"></a><a id="JSQLJ573"></a><a id="JSQLJ568"></a><div class="sect3"><a id="GUID-340AFCEF-E421-46F9-B136-DF9CC3723310" name="GUID-340AFCEF-E421-46F9-B136-DF9CC3723310"></a><h4 id="JSQLJ-GUID-340AFCEF-E421-46F9-B136-DF9CC3723310" class="sect4">SQLJ连接上下文和JDBC连接互操作性</h4>
                  <div>
                     <p>SQLJ使您可以在SQLJ连接上下文实例和JDBC连接实例之间转换任意方向。</p>
                     <div class="infoboxnote" id="GUID-340AFCEF-E421-46F9-B136-DF9CC3723310__GUID-C7EA4813-99D9-44F6-9E84-BCF476DEF3DF">
                        <p class="notep1">注意：</p>
                        <p>在SQLJ连接上下文和JDBC连接之间进行转换时，请记住这两个对象共享相同的底层物理连接。</p>
                     </div>
                     <div class="section">
                        <p class="subhead3" id="GUID-340AFCEF-E421-46F9-B136-DF9CC3723310__GUID-6F49BC14-F807-4C69-ABC1-6B5166E7E703">从连接上下文转换为JDBC连接</p>
                     </div>
                     <!-- class="section" -->
                     <p>如果要通过在SQLJ中建立的数据库连接执行JDBC操作（例如，如果应用程序调用返回JDBC连接对象的库例程），则必须将SQLJ连接上下文实例转换为JDBC连接实例。</p>
                     <p>SQLJ应用程序中的任何连接上下文实例，无论是<code class="codeph">sqlj.runtime.ref.的实例<code class="codeph">sqlj.runtime.ref.DefaultContext</code>类或声明的连接上下文类，包含底层JDBC连接实例和返回该JDBC连接实例的<code class="codeph">getConnection()</code>方法。如果要使用JDBC操作，请使用JDBC连接实例创建JDBC语句对象。
                     </p>
                     <p>以下是如何使用<code class="codeph">getConnection()</code>方法的示例。
                     </p><pre class="oac_no_warn" dir="ltr">import java.sql。*; ...DefaultContext ctx = new DefaultContext（“jdbc：oracle：thin：@localhost：5221 / myservice”，“HR”，“hr”，true）; ...（ <span class="italic">通过SQLJ</span> ctx <span class="italic">连接上下文实例的</span> <span class="italic">SQLJ操作</span> ）...Connection conn = ctx.getConnection（）; ...（ <span class="italic">通过JDBC</span> conn <span class="italic">连接实例进行</span> <span class="italic">JDBC操作</span> ）...
</pre><p>连接上下文实例可以是<code class="codeph">DefaultContext</code>类的实例，也可以是您声明的任何连接上下文类的实例。
                     </p>
                     <p>要检索默认SQLJ连接的基础JDBC连接，可以直接从<code class="codeph">DefaultContext.getDefaultContext()</code>调用使用<code class="codeph">getConnection()</code> ，其中<code class="codeph">getDefaultContext()</code>返回之前初始化为默认连接且<code class="codeph">getConnection()</code>返回的<code class="codeph">DefaultContext</code>实例它的底层JDBC连接实例。在这种情况下，因为您不必显式使用<code class="codeph">DefaultContext</code>实例，所以您也可以使用<code class="codeph">Oracle.connect()</code>方法。此方法隐式创建实例并使其成为默认连接。
                     </p>
                     <div class="infoboxnotealso" id="GUID-340AFCEF-E421-46F9-B136-DF9CC3723310__GUID-543EEB1A-EBAB-40DA-B9B1-6E237D090FB1">
                        <p class="notep1">也可以看看：</p>
                        <p><span class="q">“ <a href="key-programming-considerations.html#GUID-02A50813-2D4D-4DC1-AD1A-014AF1EDC03D">连接注意事项</a> ”</span>和<span class="q">“ <a href="key-programming-considerations.html#GUID-5838209F-A715-4935-AD3F-7EFDD5CE4BF3">有关Oracle类的更多信息</a> ”</span></p>
                     </div>
                     <p>以下是一个例子：</p><pre class="oac_no_warn" dir="ltr">import java.sql。*; ...Connection conn = Oracle.connect（“jdbc：oracle：thin：@localhost：5221 / myservice”，“HR”，“hr”）。getConnection（）; ...（ <span class="italic">通过JDBC</span> conn <span class="italic">连接实例进行</span> <span class="italic">JDBC操作</span> ）...
</pre><div class="section" id="GUID-340AFCEF-E421-46F9-B136-DF9CC3723310__CBBEJJFD">
                        <p class="subhead3" id="GUID-340AFCEF-E421-46F9-B136-DF9CC3723310__GUID-6BA0A471-2625-42FE-9838-ADEB3BE564E5">示例：动态SQL的JDBC和SQLJ连接互操作性</p>
                     </div>
                     <!-- class="section" -->
                     <p>以下是一个示例方法，该方法使用默认SQLJ连接上下文实例的基础JDBC连接实例在JDBC中执行动态SQL操作。使用JDBC <code class="codeph">java.sql.执行动态操作<code class="codeph">java.sql.Connection</code> ， <code class="codeph">java.sql.PreparedStatement</code>和<code class="codeph">java.sql.ResultSet</code>对象。或者，您可以使用Oracle SQLJ扩展进行动态SQL操作。
                     </p>
                     <div class="infoboxnotealso" id="GUID-340AFCEF-E421-46F9-B136-DF9CC3723310__GUID-2C001A50-71A4-4395-A25D-DCA3932E5609">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="../jjdbc/overview-of-JDBC.html#JJDBC-GUID-78462728-C5D3-4999-BDB9-7E676F772674" target="_blank"><span class="italic">Oracle数据库JDBC开发人员指南</span></a>和<span class="q">“ <a href="advanced-language-features.html#GUID-1A237022-5F1E-4C29-87D3-8E913F59C3FA">动态SQL支持</a> ”</span></p>
                     </div><pre class="oac_no_warn" dir="ltr">import java.sql。*; public static void projectsDue（boolean dueThisMonth）throws SQLException {//从先前初始化的SQLJ DefaultContext获取JDBC连接。Connection conn = DefaultContext.getDefaultContext（）。getConnection（）; String query =“SELECT name，start_date + duration”+“FROM projects WHERE start_date + duration&gt; = sysdate”; if（dueThisMonth）query + =“AND to_char（start_date + duration，'fmMonth'）”+“= to_char（sysdate，'fmMonth'）”; PreparedStatement pstmt = conn.prepareStatement（query）; ResultSet rs = pstmt.executeQuery（）; while（rs.next（））{System.out.println（“Project：”+ rs.getString（1）+“Deadline：”+ rs.getDate（2））; } rs.close（）; pstmt.close（）; }</pre><div class="section">
                        <p class="subhead3" id="GUID-340AFCEF-E421-46F9-B136-DF9CC3723310__GUID-B95F78ED-4E0C-4C68-BAFF-AC1CA873AB93">从JDBC连接转换为连接上下文</p>
                     </div>
                     <!-- class="section" -->
                     <p>如果您将连接作为JDBC <code class="codeph">Connection</code>实例启动，但稍后想将其用作SQLJ连接上下文实例（例如，如果要在上下文表达式中使用它来指定用于SQLJ可执行语句的连接），则可以将JDBC连接实例转换为SQLJ连接上下文实例。
                     </p>
                     <p><code class="codeph">DefaultContext</code>类和所有声明的连接上下文类都有一个构造函数，它将JDBC连接实例作为输入并构造一个SQLJ连接上下文实例。
                     </p>
                     <p>例如，假设您实例化并定义了JDBC连接实例<code class="codeph">conn</code>并希望对声明的SQLJ连接上下文类<code class="codeph">MyContext</code>的实例使用相同的连接。你可以这样做：</p><pre class="oac_no_warn" dir="ltr">...#sql context MyContext; ...MyContext myctx = new MyContext（conn）; ...
</pre><div class="section">
                        <p class="subhead3" id="GUID-340AFCEF-E421-46F9-B136-DF9CC3723310__GUID-906475FA-FFBD-40CA-8CDD-997E014D92D1">关于共享连接</p>
                     </div>
                     <!-- class="section" -->
                     <p>SQLJ连接上下文实例和关联的JDBC连接实例共享相同的底层物理连接。结果，以下情况属实：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>从SQLJ连接上下文实例（使用连接上下文<code class="codeph">getConnection()</code>方法）获取JDBC连接实例时， <code class="codeph">Connection</code>实例将继承连接上下文实例的状态。除其他外， <code class="codeph">Connection</code>实例将保留连接上下文实例的自动提交设置。
                           </p>
                        </li>
                        <li>
                           <p>当您从JDBC连接实例构造SQLJ连接上下文实例时（使用以连接实例作为输入的连接上下文构造函数），连接上下文实例将继承<code class="codeph">Connection</code>实例的状态。除此之外，连接上下文实例将保留<code class="codeph">Connection</code>实例的自动提交设置。默认情况下，JDBC连接实例的自动提交设置为<code class="codeph">true</code> ，但您可以通过<code class="codeph">Connection</code>实例的<code class="codeph">setAutoCommit()</code>方法更改此设置。
                           </p>
                        </li>
                        <li>
                           <p>给定SQLJ连接上下文实例和关联的JDBC连接实例，对在一个实例中更改会话状态的方法的调用也将影响另一个实例，因为它实际上是正在更改的基础共享会话。</p>
                        </li>
                        <li>
                           <p>因为只有一个底层物理连接，所以还有一组基础事务。一个连接实例中的<code class="codeph">COMMIT</code>或<code class="codeph">ROLLBACK</code>操作将影响共享相同底层连接的任何其他连接实例。
                           </p>
                        </li>
                     </ul>
                     <div class="infoboxnote" id="GUID-340AFCEF-E421-46F9-B136-DF9CC3723310__GUID-FDA46A98-91B3-4F15-8F28-8DD66E5D3A77">
                        <p class="notep1">注意：</p>
                        <p>也可以从同一个JDBC连接实例创建多个SQLJ连接上下文实例，从而共享相同的底层物理连接。例如，如果要在程序模块之间共享同一组事务，这可能很有用。前面的注释也适用于这种情况。</p>
                     </div>
                     <div class="section" id="GUID-340AFCEF-E421-46F9-B136-DF9CC3723310__I1007208">
                        <p class="subhead3" id="GUID-340AFCEF-E421-46F9-B136-DF9CC3723310__GUID-BC14DD55-2F26-4502-BD33-353E272807AA">关闭共享连接</p>
                     </div>
                     <!-- class="section" -->
                     <p>从SQLJ连接上下文实例（使用<code class="codeph">getConnection()</code>方法）获取JDBC连接实例或从JDBC连接实例（使用连接上下文构造函数）创建SQLJ连接上下文实例时，必须仅关闭连接上下文实例。默认情况下，调用连接上下文实例的<code class="codeph">close()</code>方法会关闭关联的JDBC连接实例和基础物理连接，从而释放与连接关联的所有资源。
                     </p>
                     <p>如果要关闭SQLJ连接上下文实例<span class="italic">而不</span>关闭关联的JDBC连接实例（例如，如果在其他地方使用<code class="codeph">Connection</code>实例，直接或通过另一个连接上下文实例），则可以指定布尔常量<code class="codeph">KEEP_CONNECTION</code>为<code class="codeph">close()</code>方法，如下（假设连接上下文实例<code class="codeph">ctx</code> ）：</p><pre class="oac_no_warn" dir="ltr">ctx.close（ConnectionContext。KEEP_CONN ECTION）;</pre><p>如果未指定<code class="codeph">KEEP_CONNECTION</code> ，则默认情况下关闭关联的JDBC连接实例。您也可以明确指定：</p><pre class="oac_no_warn" dir="ltr">ctx.close（ConnectionContext。CLOSE_CONN ECTION）;</pre><p><code class="codeph">KEEP_CONNECTION</code>和<code class="codeph">CLOSE_CONNECTION</code>是<code class="codeph">CLOSE_CONNECTION</code>的静态常量<code class="codeph">sqlj.runtime.ConnectionContext</code>接口。
                     </p>
                     <p>如果仅关闭JDBC连接实例，则<span class="italic">不会</span>关闭关联的SQLJ连接上下文实例。底层物理连接将被关闭，但连接上下文实例的资源在垃圾收集之前不会被释放。
                     </p>
                     <div class="infoboxnote" id="GUID-340AFCEF-E421-46F9-B136-DF9CC3723310__GUID-37A03D05-F24B-4E4F-9622-146FD8830B12">
                        <p class="notep1">注意：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>如果多个连接上下文实例共享相同的基础JDBC连接，则在关闭除最后剩余的打开连接上下文实例之外的所有实例时使用<code class="codeph">KEEP_CONNECTION</code> 。
                              </p>
                           </li>
                           <li>
                              <p>如果您尝试关闭其基础JDBC连接已关闭的连接上下文实例，或者您已尝试在已关闭时关闭基础连接，则将发出错误消息。如果遇到这种情况，请验证JDBC连接是否未被JDBC代码独立关闭，并且对使用基础连接的SQLJ连接上下文实例的所有前面的<code class="codeph">close()</code>调用都使用<code class="codeph">KEEP_CONNECTION</code>参数。
                              </p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="JSQLJ575"></a><a id="JSQLJ576"></a><a id="JSQLJ577"></a><a id="JSQLJ574"></a><div class="sect3"><a id="GUID-76329A99-A510-4BEB-8271-46F689A10D2D" name="GUID-76329A99-A510-4BEB-8271-46F689A10D2D"></a><h4 id="JSQLJ-GUID-76329A99-A510-4BEB-8271-46F689A10D2D" class="sect4">SQLJ迭代器和JDBC结果集互操作性</h4>
                  <div>
                     <p>SQLJ使您可以在SQLJ迭代器和JDBC结果集之间转换任意方向。对于在SQLJ语句中选择数据但不关心强类型迭代器功能的情况，SQLJ还支持弱类型迭代器，您可以将其转换为JDBC结果集。</p>
                     <div class="section" id="GUID-76329A99-A510-4BEB-8271-46F689A10D2D__I1007234">
                        <p class="subhead3" id="GUID-76329A99-A510-4BEB-8271-46F689A10D2D__GUID-9ADE2497-94E9-4128-89BE-136360C00247">从结果集转换为命名或位置迭代器</p>
                     </div>
                     <!-- class="section" -->
                     <p>在许多情况下，您可能会发现自己在操纵JDBC结果集。例如，另一个包可能在JDBC中实现，并且仅通过结果集提供对数据的访问，或者可能需要<code class="codeph">ResultSetMetaData</code>信息，因为它是针对任何类型的结果集一般编写的例程。或者您的SQLJ应用程序可能会调用返回JDBC结果集的存储过程。
                     </p>
                     <p>如果动态结果集具有已知结构，则通常希望将其作为迭代器进行操作以使用迭代器提供的强类型范例。</p>
                     <p>在SQLJ中，您可以通过转换现有的JDBC结果集对象来填充命名或位置迭代器对象。这可以被认为是将结果集转换为迭代器，语法反映如下：</p><pre class="oac_no_warn" dir="ltr">#sql iter = {CAST：rs};</pre><p>这会将结果集对象<code class="codeph">rs</code>绑定到SQLJ可执行语句中，转换结果集，并使用结果集数据填充迭代器<code class="codeph">iter</code> 。
                     </p>
                     <p>以下是一个例子。假设<code class="codeph">myEmpQuery()</code>是一个名为<code class="codeph">RSClass</code>的类中的静态Java函数，其预定义查询返回JDBC结果集对象：</p><pre class="oac_no_warn" dir="ltr">import java.sql。*; ...#sql public iterator MyIterator（String ename，float sal）; ...ResultSet rs; MyIterator iter; ...rs = RSClass.myEmpQuery（）; #sql iter = {CAST：rs}; ...（ <span class="italic">处理迭代器</span> ）...iter.close（）; ...
</pre><p>这个例子可能使用了位置迭代器而不是命名迭代器。功能相同。</p>
                     <p>将JDBC结果集转换为SQLJ迭代器并处理数据时，以下规则适用：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>要转换为位置迭代器，结果集和迭代器必须具有相同的列数，并且类型必须正确映射。</p>
                        </li>
                        <li>
                           <p>要转换为命名迭代器，结果集必须至少具有与迭代器一样多的列，并且迭代器的所有列必须与名称和类型匹配。如果结果集和迭代器的列数不同，那么除非使用<code class="codeph">-warn=nostrict</code>选项设置，否则SQLJ转换器将生成警告。
                           </p>
                        </li>
                        <li>
                           <p>要转换的结果集必须实现<code class="codeph">java.sql.ResultSet</code>接口。类<code class="codeph">oracle.jdbc.与任何标准结果集类一样， OracleResultSet</code>实现此接口。
                           </p>
                        </li>
                        <li>
                           <p>接收强制转换的迭代器必须是声明为<code class="codeph">public</code>的迭代器类的实例。
                           </p>
                        </li>
                        <li>
                           <p>在转换之前或之后，请勿访问结果集中的数据。仅从迭代器访问数据。</p>
                        </li>
                        <li>
                           <p>完成后，关闭迭代器，而不是结果集。关闭迭代器也会关闭结果集，但关闭结果集不会关闭迭代器。与JDBC互操作时，请始终关闭SQLJ实体。</p>
                        </li>
                     </ul>
                     <div class="section" id="GUID-76329A99-A510-4BEB-8271-46F689A10D2D__I1007269">
                        <p class="subhead3" id="GUID-76329A99-A510-4BEB-8271-46F689A10D2D__GUID-5B8EBAAE-6780-476E-8EBA-72D73AD82CAA">从命名或位置迭代器转换为结果集</p>
                     </div>
                     <!-- class="section" -->
                     <p>您可能还会遇到要使用SQLJ定义查询但最终需要结果集的情况。</p>
                     <div class="infoboxnote" id="GUID-76329A99-A510-4BEB-8271-46F689A10D2D__GUID-2EA53CA9-3F18-4481-9153-9116A6A7388D">
                        <p class="notep1">注意：</p>
                        <p>SQLJ提供了更自然和简洁的语法，但您可能希望对结果进行动态处理，或者您可能希望使用将结果集作为输入的现有Java方法。</p>
                     </div>
                     <p>因此，您可以将迭代器转换为结果集，使用<code class="codeph">getResultSet()</code>方法生成每个SQLJ迭代器类（无论是命名还是位置<code class="codeph">getResultSet()</code> 。此方法可用于返回迭代器对象的基础JDBC结果集对象。
                     </p>
                     <p>以下是显示<code class="codeph">getResultSet()</code>方法的使用示例：</p><pre class="oac_no_warn" dir="ltr">import java.sql。*; #sql public iterator MyIterator（String ename，float sal）; ...MyIterator iter; ...#sql iter = {SELECT * FROM employees}; ResultSet rs = iter.getResultSet（）; ...（ <span class="italic">处理结果集</span> ）......iter.close（）; ...
</pre><p>将SQLJ迭代器转换为JDBC结果集并处理数据时，以下规则适用。</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>将迭代器数据写入结果集时，只应通过结果集访问数据。在转换之前或之后，不要尝试直接访问迭代器。</p>
                        </li>
                        <li>
                           <p>完成后，关闭原始迭代器，而不是结果集。关闭迭代器也将关闭结果集，但关闭结果集将不会关闭迭代器。与JDBC互操作时，请始终关闭SQLJ实体。</p>
                        </li>
                     </ul>
                     <div class="section" id="GUID-76329A99-A510-4BEB-8271-46F689A10D2D__I1007295">
                        <p class="subhead3" id="GUID-76329A99-A510-4BEB-8271-46F689A10D2D__GUID-02C4C7D6-A513-4E5F-98C5-1865D91991B4">使用和转换弱类型迭代器（ResultSetIterator）</p>
                     </div>
                     <!-- class="section" -->
                     <p>您可能遇到类似于<span class="q">“ <a href="advanced-language-features.html#GUID-76329A99-A510-4BEB-8271-46F689A10D2D">SQLJ迭代器和JDBC结果集互操作性</a> ”中</span>讨论的情况，但您不需要迭代器的强类型功能。在这种情况下，您应该能够为查询使用SQLJ语法，然后从结果集动态处理数据。对于这种情况，您可以直接使用<code class="codeph">sqlj.runtime.ResultSetIterator</code>类型用于接收查询数据。
                     </p>
                     <p>在使用SQLJ语句和<code class="codeph">ResultSetIterator</code>功能而不是使用JDBC语句和标准结果集功能时，您可以自己使用SQLJ的更简洁的<code class="codeph">SELECT</code>语法。</p>
                     <p>以下是如何使用和转换弱类型结果集迭代器的示例：</p><pre class="oac_no_warn" dir="ltr">import sqlj.runtime。*; import java.sql。*; ...ResultSetIterator rsiter; ...#sql rsiter = {SELECT * FROM table}; ResultSet rs = rsiter.getResultSet（）; ...（ <span class="italic">处理结果集</span> ）......rsiter.close（）; ...
</pre><div class="infoboxnote" id="GUID-76329A99-A510-4BEB-8271-46F689A10D2D__GUID-A8C67155-0CAB-4D3E-AF4E-A63B1F5B7222">
                        <p class="notep1">注意：</p>
                        <p>Oracle SQLJ实现允许使用<code class="codeph">next()</code>方法和<code class="codeph">FETCH CURRENT</code>语法在结果集迭代器中导航。此外，对于可滚动的结果集迭代器，还支持其他导航方法。
                        </p>
                     </div>
                  </div>
               </div>
            </div><a id="JSQLJ578"></a><div class="sect2"><a id="GUID-1A237022-5F1E-4C29-87D3-8E913F59C3FA" name="GUID-1A237022-5F1E-4C29-87D3-8E913F59C3FA"></a><h3 id="JSQLJ-GUID-1A237022-5F1E-4C29-87D3-8E913F59C3FA" class="sect3">支持动态SQL</h3>
               <div>
                  <p>Oracle SQLJ实现包括支持动态SQL的扩展，未预定义且可以实时更改的操作。嵌入在SQLJ语句中的动态SQL表达式称为元绑定表达式。</p>
                  <div class="infoboxnote" id="GUID-1A237022-5F1E-4C29-87D3-8E913F59C3FA__GUID-EE4FE99B-3E77-4261-BA34-FE7D1BC2EAFD">
                     <p class="notep1">注意：</p>
                     <p>对于Oracle Database 12 <span class="italic">c</span>第1版（12.1）中的动态SQL，使用JDBC代码仍然是一个选项，如果需要考虑代码可移植性，则可能更可取，但SQLJ对动态SQL的支持允许将SQLJ用作单个简化的API以进行数据访问。
                     </p>
                  </div>
                  <p>本节包括以下主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="advanced-language-features.html#GUID-76572A3E-02EE-41E4-98AD-9937A46C050D">元绑定表达式</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-language-features.html#GUID-46D0B10D-7CE1-4DB9-80E7-ECCBF476DF67">SQLJ动态SQL示例</a></p>
                     </li>
                  </ul>
               </div><a id="JSQLJ580"></a><a id="JSQLJ581"></a><a id="JSQLJ582"></a><a id="JSQLJ583"></a><a id="JSQLJ584"></a><a id="JSQLJ585"></a><a id="JSQLJ579"></a><div class="sect3"><a id="GUID-76572A3E-02EE-41E4-98AD-9937A46C050D" name="GUID-76572A3E-02EE-41E4-98AD-9937A46C050D"></a><h4 id="JSQLJ-GUID-76572A3E-02EE-41E4-98AD-9937A46C050D" class="sect4">元绑定表达式</h4>
                  <div>
                     <p>元绑定表达式用于SQLJ语句中的动态SQL，否则将出现静态SQL子句。元绑定表达式包含<code class="codeph">String</code>类型的Java标识符或在运行时解释的字符串值Java表达式。此外，为了使SQLJ可以执行在线语义检查，元绑定表达式可以选择包括用于在转换期间进行检查的静态SQL替换代码。
                     </p>
                     <div class="section">
                        <p class="subhead3" id="GUID-76572A3E-02EE-41E4-98AD-9937A46C050D__GUID-3D48A66D-8AC0-46A2-B3E6-FB3DB510FC0C">Meta Bind表达式：一般用法和限制</p>
                     </div>
                     <!-- class="section" -->
                     <p>您可以使用元绑定表达式代替以下任何一种：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>表名</p>
                        </li>
                        <li>
                           <p><code class="codeph">SELECT</code>语句中的列名（没有列别名，如果指定）</p>
                        </li>
                        <li>
                           <p>全部或部分<code class="codeph">WHERE</code>子句条件</p>
                        </li>
                        <li>
                           <p>数据定义语言（DDL）或DML语句中的角色，架构，目录或包名称</p>
                        </li>
                        <li>
                           <p>SQL文字值或SQL表达式</p>
                        </li>
                     </ul>
                     <p>请注意以下对元绑定表达式的限制，强制执行以确保SQLJ转换程序可以正确地确定SQL操作的性质，并且可以对SQLJ语句进行整体语法分析：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>元绑定表达式不能是SQLJ语句中SQL操作的第一个非注释。</p>
                        </li>
                        <li>
                           <p>元绑定表达式不能包含SQLJ <code class="codeph">SELECT INTO</code>语句的<code class="codeph">INTO</code>标记，也不能扩展为<code class="codeph">SELECT INTO</code>语句的<code class="codeph">INTO</code> -list。
                           </p>
                        </li>
                        <li>
                           <p>元绑定表达式不能出现在以下任何类型的SQL / SQLJ指令或子句中： <code class="codeph">CALL</code> ， <code class="codeph">VALUES</code> ， <code class="codeph">PSM SET</code> ， <code class="codeph">COMMIT</code> ， <code class="codeph">ROLLBACK</code> ， <code class="codeph">FETCH INTO</code>或<code class="codeph">CAST</code> 。</p>
                        </li>
                     </ul>
                     <div class="section">
                        <p class="subhead3" id="GUID-76572A3E-02EE-41E4-98AD-9937A46C050D__GUID-5C7F34D1-2067-44AF-9A4B-8BDB30BD1D95">元绑定表达式：语法和行为</p>
                     </div>
                     <!-- class="section" -->
                     <p>以下是元绑定表达式的一般语法：</p><pre class="oac_no_warn" dir="ltr">：{ <span class="italic">Java_bind_expression</span> }</pre><p>要么：</p><pre class="oac_no_warn" dir="ltr">：{ <span class="italic">Java_bind_expression</span> :: <span class="italic">SQL_replacement_code</span> }</pre><p>请注意，空格是可选的。在SQLJ语句的SQL指令中可以有多个元绑定表达式。</p>
                     <div class="section">
                        <p class="subhead3" id="GUID-76572A3E-02EE-41E4-98AD-9937A46C050D__GUID-602E808A-0E37-492B-86AA-520FF8F8EFCF">Java绑定表达式</p>
                     </div>
                     <!-- class="section" -->
                     <p>Java绑定表达式可以是以下任一种：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">String</code>类型的Java标识符</p>
                        </li>
                        <li>
                           <p>评估为字符串的Java表达式</p>
                        </li>
                     </ul>
                     <p>元绑定表达式中的Java绑定表达式受标准Java lexing规则的约束，其语法类似于SQLJ主机表达式。但是，与主机表达式不同，元绑定表达式中的Java绑定表达式不包含在括号内。这是因为，如果存在SQL替换代码，则<code class="codeph">::</code> token充当Java绑定表达式和SQL代码之间的分隔符。如果没有SQL替换代码，则结束括号（}）充当终止符。无论哪种情况，都没有歧义。
                     </p>
                     <div class="infoboxnote" id="GUID-76572A3E-02EE-41E4-98AD-9937A46C050D__GUID-16384EC8-3939-4A39-9266-1073E780D00B">
                        <p class="notep1">注意：</p>
                        <p>不可能有任何模式说明符， <code class="codeph">IN</code> ， <code class="codeph">OUT</code> ，或<code class="codeph">INOUT</code> ，一个Java bind表达式内或之间<code class="codeph">:</code>和<code class="codeph">{</code>元绑定表达的。
                        </p>
                     </div>
                     <div class="section">
                        <p class="subhead3" id="GUID-76572A3E-02EE-41E4-98AD-9937A46C050D__GUID-C6B84308-0B23-4D91-952B-BB083E2D43B7">SQL替换代码</p>
                     </div>
                     <!-- class="section" -->
                     <p>SQL替换代码子句由零个或多个SQL标记的序列组成，具有以下要求和限制：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>它受SQL lexing规则的约束。</p>
                        </li>
                        <li>
                           <p>大括号（{}）必须出现在匹配对中（除了那些属于SQL注释，常量或标识符的那些）。</p>
                        </li>
                        <li>
                           <p>SQL指令中不能有SQLJ主机表达式或嵌套的元绑定表达式。</p>
                        </li>
                     </ul>
                     <div class="infoboxnote" id="GUID-76572A3E-02EE-41E4-98AD-9937A46C050D__GUID-1BA1FB81-45D8-4B88-A555-BD5A0DC564EA">
                        <p class="notep1">注意：</p>
                        <p>SQL替换代码允许为空。</p>
                     </div>
                     <div class="section">
                        <p class="subhead3" id="GUID-76572A3E-02EE-41E4-98AD-9937A46C050D__GUID-C05AEAE7-A241-4C81-B27A-239072972DCD">翻译时间行为</p>
                     </div>
                     <!-- class="section" -->
                     <p>每当元绑定表达式中存在SQL替换代码（即使只是空字符串）时，元绑定表达式在转换期间由SQL代码替换。SQL替换代码的目的是使SQLJ转换器能够执行在线语义检查。</p>
                     <p>如果SQLJ语句中的任何元绑定表达式没有SQL替换代码子句，则SQLJ转换程序无法对语句执行联机语义检查。它只在语法上检查。</p>
                     <div class="section">
                        <p class="subhead3" id="GUID-76572A3E-02EE-41E4-98AD-9937A46C050D__GUID-00BAC44C-F683-4AD2-9592-D511911C7998">运行时行为</p>
                     </div>
                     <!-- class="section" -->
                     <p>在运行时，每个元绑定表达式都由其Java绑定表达式的评估替换。如果Java绑定表达式的计算结果为<code class="codeph">null</code> ，则整个动态SQL语句将变为未定义。
                     </p>
                  </div>
               </div><a id="JSQLJ587"></a><a id="JSQLJ588"></a><a id="JSQLJ589"></a><a id="JSQLJ590"></a><a id="JSQLJ591"></a><a id="JSQLJ586"></a><div class="sect3"><a id="GUID-46D0B10D-7CE1-4DB9-80E7-ECCBF476DF67" name="GUID-46D0B10D-7CE1-4DB9-80E7-ECCBF476DF67"></a><h4 id="JSQLJ-GUID-46D0B10D-7CE1-4DB9-80E7-ECCBF476DF67" class="sect4">SQLJ动态SQL示例</h4>
                  <div>
                     <p>本节提供SQLJ代码中动态SQL用法的示例。</p>
                     <div class="section">
                        <p class="subhead3" id="GUID-46D0B10D-7CE1-4DB9-80E7-ECCBF476DF67__GUID-1785F89C-FE40-4B19-A516-3C5D0DD84405">例1</p>
                     </div>
                     <!-- class="section" --><pre class="oac_no_warn" dir="ltr">...int x = 10; int y = x + 10; int z = y + 10; String table =“new_Emp”; #sql {INSERT INTO：{table :: emp} VALUES（：x，：y，：z）}; ...
</pre><p>在转换期间，SQL操作变为：</p><pre class="oac_no_warn" dir="ltr">插入进入价值观（10,20,30）;</pre><p>SQLJ可以对具有<code class="codeph">emp</code>表的模式执行在线语义检查。也许<code class="codeph">new_Emp</code>仅存在于运行时模式中，并且在应用程序执行之前不会创建。
                     </p>
                     <p>在运行时，SQL操作变为：</p><pre class="oac_no_warn" dir="ltr">插入new_Emp VALUES（10,20,30）;</pre><div class="section">
                        <p class="subhead3" id="GUID-46D0B10D-7CE1-4DB9-80E7-ECCBF476DF67__GUID-CA666E24-C321-458C-A527-01E006EB9DBF">例2</p>
                     </div>
                     <!-- class="section" --><pre class="oac_no_warn" dir="ltr">...String table =“new_Emp”; String query =“ename LIKE'S％'AND sal&gt; 1000”; #sql myIter = {SELECT * FROM：{table :: emp2} WHERE：{query :: ename ='HR'}}; ...
</pre><p>在转换期间，SQL操作变为：</p><pre class="oac_no_warn" dir="ltr">SELECT * FROM emp2 WHERE ename ='HR';</pre><p>SQLJ可以对具有<code class="codeph">emp2</code>表的模式执行在线语义检查。
                     </p>
                     <p>在运行时，SQL操作变为：</p><pre class="oac_no_warn" dir="ltr">SELECT * FROM new_Emp WHERE ename LIKE'S％'AND sal&gt; 1000;</pre><div class="section" id="GUID-46D0B10D-7CE1-4DB9-80E7-ECCBF476DF67__I1007458">
                        <p class="subhead3" id="GUID-46D0B10D-7CE1-4DB9-80E7-ECCBF476DF67__GUID-DAD3CD99-51CE-4D0F-AC43-8836D151FA8F">例3</p>
                     </div>
                     <!-- class="section" --><pre class="oac_no_warn" dir="ltr">...double raise = 1.12; String col =“comm”; String whereQuery =“WHERE”+ col +“IS not null”; for（int i = 0; i &lt;5; i ++）{#sql {UPDATE：{“emp”+ i :: emp} SET：{col :: sal} =：{col :: sal} *：raise：{ whereQuery ::}}; } ...
</pre><p>在转换期间，SQL操作变为：</p><pre class="oac_no_warn" dir="ltr">UPDATE emp SET sal = sal * 1.12;</pre><p>SQLJ可以对具有<code class="codeph">emp</code>表的模式执行在线语义检查。转换期间没有<code class="codeph">WHERE</code>子句，因为SQL替换代码为空。
                     </p>
                     <p>在运行时，SQL操作执行五次，变为：</p><pre class="oac_no_warn" dir="ltr">UPDATE emp0 SET comm = comm * 1.12 WHERE comm IS not null; UPDATE emp1 SET comm = comm * 1.12 WHERE comm IS not null; UPDATE emp2 SET comm = comm * 1.12 WHERE comm IS not null; UPDATE emp3 SET comm = comm * 1.12 WHERE comm IS not null; UPDATE emp4 SET comm = comm * 1.12 WHERE comm IS not null;</pre><div class="section" id="GUID-46D0B10D-7CE1-4DB9-80E7-ECCBF476DF67__I1007483">
                        <p class="subhead3" id="GUID-46D0B10D-7CE1-4DB9-80E7-ECCBF476DF67__GUID-FB0CA7C0-F8DB-4E2D-A952-DEE6EFBA34E9">例4</p>
                     </div>
                     <!-- class="section" --><pre class="oac_no_warn" dir="ltr">...double raise = 1.12; String col =“comm”; String whereQuery =“WHERE”+ col +“IS not null”; for（int i = 0; i &lt;10; i ++）{#sql {UPDATE：{“emp”+ i} SET：{col :: sal} =：{col :: sal} *：raise：{whereQuery :: }}; } ...
</pre><p>实施例3和实施例4的运行时行为是相同的。但是，在转换期间会出现差异，其中SQLJ无法对示例4执行联机语义检查，因为第一个元绑定表达式没有SQL替换代码<code class="codeph">:{"emp"+i}</code> 。
                     </p>
                     <div class="section" id="GUID-46D0B10D-7CE1-4DB9-80E7-ECCBF476DF67__I1007507">
                        <p class="subhead3" id="GUID-46D0B10D-7CE1-4DB9-80E7-ECCBF476DF67__GUID-0656E79B-6203-4FBD-B843-20D1439590D3">示例5：来自Result Set Iterator的带有FETCH的动态SQL</p>
                     </div>
                     <!-- class="section" -->
                     <p>此示例是使用SQLJ语句而不是JDBC语句重新编写<span class="q">“ <a href="advanced-language-features.html#GUID-340AFCEF-E421-46F9-B136-DF9CC3723310__CBBEJJFD">示例：动态SQL的JDBC和SQLJ连接互操作性</a> ”</span> 。此示例还使用结果集迭代器中的<code class="codeph">FETCH CURRENT</code>功能。
                     </p><pre class="oac_no_warn" dir="ltr">import java.sql。*; public static void projectsDue（boolean dueThisMonth）抛出SQLException {ResultSetIterator rsi; String andClause =（dueThisMonth）？“AND to_char（start_date + duration，'fmMonth'）”+“= to_char（sysdate，'fmMonth'）”：“”; #sql rsi = {SELECT name，start_date + duration FROM projects WHERE start_date + duration&gt; = sysdate：{andClause ::}}; while（rsi.next（））{String name = null; java.sql中。日期截止日期= null; #sql {FETCH CURRENT FROM：rsi INTO：name，：deadline}; System.out.println（“项目：”+名称+“截止日期：”+截止日期）; } rsi.close（）; }</pre></div>
               </div>
            </div><a id="JSQLJ594"></a><a id="JSQLJ595"></a><a id="JSQLJ596"></a><a id="JSQLJ597"></a><a id="JSQLJ598"></a><a id="JSQLJ599"></a><a id="JSQLJ600"></a><a id="JSQLJ601"></a><a id="JSQLJ592"></a><div class="sect2"><a id="GUID-EB24FCD6-B42D-47FB-98B8-1D4285407E69" name="GUID-EB24FCD6-B42D-47FB-98B8-1D4285407E69"></a><h3 id="JSQLJ-GUID-EB24FCD6-B42D-47FB-98B8-1D4285407E69" class="sect3">使用存储的轮廓</h3>
               <div>
                  <div class="infoboxnote" id="GUID-EB24FCD6-B42D-47FB-98B8-1D4285407E69__GUID-25DE8CAA-1FD3-46FD-B291-F39DF71E9C62">
                     <p class="notep1">注意：</p>
                     <p>从Oracle Database 12 <span class="italic">c</span>第2版（12.2）开始，不推荐使用此功能，并将其替换为SQL计划管理（SPM）。Oracle建议您利用新功能，该功能功能更强大，性能更佳。有关SPM的更多信息，请参阅<span class="q">“ <a href="advanced-language-features.html#GUID-8465DD7E-5943-4BBD-911D-F1318A55552E">使用计划基准</a> ”</span> 。
                     </p>
                  </div>
                  <p>如果由于环境的变化而导致应用程序中的任何性能更改的风险，那么您可以使用Oracle的大纲功能。大纲实现为一组与SQL语句关联的优化程序提示。如果为语句启用了大纲，Oracle会自动考虑存储的提示并尝试根据这些提示生成执行计划。您可以将大纲分组到类别中，即，它们是默认的还是由客户端指定的，并控制Oracle用于简化大纲管理和部署的大纲类别。如果已将<code class="codeph">USE_STORED_OUTLINES</code>设置为类别名称或为<code class="codeph">TRUE.</code>则在执行各个语句期间将使用轮廓中的提示<code class="codeph">TRUE.</code></p>
                  <div class="infoboxnotealso" id="GUID-EB24FCD6-B42D-47FB-98B8-1D4285407E69__GUID-4BF405CD-1EA7-4F65-A023-2DACD6B20466">
                     <p class="notep1">也可以看看：</p>
                     <p>有关轮廓的更多信息，请<a href="../sqlrf/CREATE-OUTLINE.html#SQLRF-GUID-7CC033AF-DB19-4616-87D9-8173939FD627" target="_blank"><span><cite>参见Oracle数据库SQL语言参考</cite></span></a> 。
                     </p>
                  </div>
                  <p>将新大纲选项设置为<code class="codeph">true</code>或类别名称翻译文件时，则：</p>
                  <ol>
                     <li>
                        <p>创建一个单独的SQL文件，其中包含输入SQLJ文件中存在的所有SQL语句的<code class="codeph">CREATE OUTLINE</code>语句。
                        </p>
                     </li>
                     <li>
                        <p>生成包含SQL语句，大纲名称，大纲SQL语句，大纲类别和状态信息的日志文件。</p>
                     </li>
                     <li>
                        <p>如果指定<code class="codeph">-runoutline option</code> ，则生成的SQL文件将在成功转换输入文件的末尾运行。
                        </p>
                     </li>
                  </ol>
                  <p>可用于创建轮廓的SQL语句包括：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>选择</p>
                     </li>
                     <li>
                        <p>删除</p>
                     </li>
                     <li>
                        <p>UPDATE</p>
                     </li>
                     <li>
                        <p>插入 ...选择</p>
                     </li>
                     <li>
                        <p>创建表...选择</p>
                     </li>
                  </ul>
                  <p>您在创建轮廓时有以下限制：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>您无法在MERGE语句上创建轮廓。</p>
                     </li>
                     <li>
                        <p>您无法在多表INSERT语句上创建轮廓。</p>
                     </li>
                     <li>
                        <p>大纲中的SQL语句不能包含远程对象上的任何DML操作。</p>
                     </li>
                  </ul>
                  <div class="section">
                     <p class="subhead2" id="GUID-EB24FCD6-B42D-47FB-98B8-1D4285407E69__GUID-3126F6DE-D7B7-41BA-8E3C-C7192753FD9F">生成轮廓的选项</p>
                  </div>
                  <!-- class="section" -->
                  <div class="infoboxnote" id="GUID-EB24FCD6-B42D-47FB-98B8-1D4285407E69__GUID-EC1A2812-F955-46F2-BBC2-6C4DCE45C1D5">
                     <p class="notep1">注意：</p>
                     <p>大纲选项<span class="italic">仅</span>在进行在线检查时有效。
                     </p>
                  </div>
                  <p>考虑SQLJ程序<code class="codeph">abc.sqlj</code>包含以下代码片段：</p><pre class="oac_no_warn" dir="ltr">{#sql iter = {SELECT * FROM employees WHERE employee_id =：var;} #sql iter1 = {SELECT * FROM departments}; }</pre><p>将SQLJ程序编译为：</p><pre class="oac_no_warn" dir="ltr">％sqlj -url = jdbc：oracle：oci8：@ -user = HR -outline = abccat abc.sqlj密码： <span class="italic">密码</span>
</pre><p>上面的SQLJ代码片段生成的SQL文件<code class="codeph">abc_sqlj.sql</code>如下所示：</p><pre class="oac_no_warn" dir="ltr">创建或替换大纲abccat_abc_sqlj_0001 FOR CATEGORY abccat ON SELECT * FROM employees WHERE employee_id =：B1 / * abccat_abc_sqlj_0001 * /;创建或替换大纲abccat_abc_sqlj_0002 FOR CATEGORY abccat ON SELECT * FROM departments / * abccat_abc_sqlj_0002 * /;</pre><div class="infoboxnote" id="GUID-EB24FCD6-B42D-47FB-98B8-1D4285407E69__GUID-E64C2682-3CFE-4412-B4F6-ED7432598AF3">
                     <p class="notep1">注意：</p>
                     <p>给出前缀时，文件名不包含在大纲名称或注释中。在本节中，您将看到使用和不使用前缀的示例。有关前缀的更多信息，请参阅<span class="q">“ <a href="advanced-language-features.html#GUID-EB24FCD6-B42D-47FB-98B8-1D4285407E69__CHDFFGHI">sqlj.outlineprefix</a> ”</span> 。
                     </p>
                  </div>
                  <p>选项<code class="codeph">-outline</code>在成功转换结束时生成两个文件：SQL文件和LOG文件。生成的SQL文件名具有以下格式：</p><pre class="oac_no_warn" dir="ltr">&lt;文件名&gt; _ &lt;文件类型&gt; .SQL</pre><p>例如，生成的文件<code class="codeph">abc.sqlj</code> <code class="codeph">abc_sqlj.sql.</code> SQL文件为<code class="codeph">abc_sqlj.sql.</code></p>
                  <p>用作大纲名称和注释的唯一标识符的格式为：</p><pre class="oac_no_warn" dir="ltr">&lt;categoryname&gt; _ &lt;filename&gt; _ &lt;filetype&gt; _ &lt;序列号&gt;</pre><p>其中，序列号是一个四位数的序列号，范围从0001到9999。如果SQLJ程序包含超过9999个SQL语句，则会出现“ <code class="codeph">Max sequence number exceeded for outlines</code> ”错误。例如，为<code class="codeph">abc.sqlj</code>生成的唯一标识符的格式为<code class="codeph">abccat_abc_sqlj_0001</code> ，其中， <code class="codeph">abccat</code>是类别的名称。
                  </p>
                  <div class="infoboxnote" id="GUID-EB24FCD6-B42D-47FB-98B8-1D4285407E69__GUID-B65FAFBB-EDD2-4350-A6E4-5F4D88C848D8">
                     <p class="notep1">注意：</p>
                     <p>对运行时使用的生成的java或类文件中的SQL添加相同的注释。</p>
                  </div>
                  <p>如果将outline设置为<code class="codeph">true</code> ，则默认类别将用于存储轮廓：</p><pre class="oac_no_warn" dir="ltr">％sqlj -user = HR -url = jdbc：oracle：oci8：@ -outline = true abc.sqlj密码： <span class="italic">密码</span>
</pre><p>在这种情况下，生成的SQL文件<code class="codeph">abc_sqlj.sql</code>如下所示：</p><pre class="oac_no_warn" dir="ltr">创建或替换大纲default_abc_sqlj_0001 ON SELECT * FROM employees WHERE employee_id =：B1 / * default_abc_sqlj_0001 * /;创建或替换大纲default_abc_sqlj_0002 ON SELECT * FROM departments / * default_abc_sqlj_0002 * /;</pre><p>您可以使用以下命令将大纲名称设置为特定前缀：</p><pre class="oac_no_warn" dir="ltr">％sqlj -user = HR -url = jdbc：oracle：oci8：@ -outline = abccat -outlineprefix = pref1 abc.sqlj密码： <span class="italic">密码</span>
</pre><p>在这种情况下，生成的SQL文件<code class="codeph">abc_sqlj.sql</code>如下所示：</p><pre class="oac_no_warn" dir="ltr">创建或替换大纲pref1_0001 FOR CATEGORY abccat ON SELECT * FROM employees WHERE employee_id =：B1 / * pref1_0001 * /';创建或替换大纲pref1_0002 FOR CATEGORY abccat ON SELECT * FROM departments / * pref1_0002 * /';</pre><div class="infoboxnote" id="GUID-EB24FCD6-B42D-47FB-98B8-1D4285407E69__GUID-0E0733F0-D929-41AD-B516-FF928333FF94">
                     <p class="notep1">注意：</p>
                     <p>如果设置<code class="codeph">-outlineprefix</code>选项，则只能将一个SQLJ文件传递给转换程序。
                     </p>
                  </div>
                  <div class="infoboxnote" id="GUID-EB24FCD6-B42D-47FB-98B8-1D4285407E69__GUID-66117AC5-9F9F-4DD5-8F61-748050535433">
                     <p class="notep1">注意：</p>
                     <p>要使用<code class="codeph">outlineprefix</code>选项翻译多个文件，您可以执行以下操作：</p><pre class="oac_no_warn" dir="ltr">％sqlj -outline = abccat -outlineprefix = pref1，pref2，pref3 abc.sqlj def.sqlj fgh.sqlj</pre></div>
                  <p>目前，大纲名称长度的上限是30个字节。因此，如果生成的大纲名称超过30个字节，则SQLJ错误“ <code class="codeph">Outline name exceeds maximum limit.抛出Use -outlineprefix option</code> 。在这种情况下，如果要使用<code class="codeph">-outline</code>选项，则需要调用<code class="codeph">-outlineprefix</code>选项，如上例所示。如果希望数据库服务器生成大纲名称而不是SQLJ生成的大纲名称，则可以将<code class="codeph">-outlineprefix</code>选项设置为<code class="codeph">none.</code> 例如：</p><pre class="oac_no_warn" dir="ltr">％sqlj -user = HR -url = jdbc：oracle：oci8：@ -outline = abccat -outlineprefix = none abc.sqlj密码： <span class="italic">密码</span>
</pre><p>在这种情况下，生成的SQL文件<code class="codeph">abc_sqlj.sql</code>如下所示：</p><pre class="oac_no_warn" dir="ltr">创建或替换类别的大纲abccat ON SELECT * FROM employees WHERE employee_id =：B1 / * abccat_abc_sqlj_0001 * /';创建或替换类别abccat ON SELECT * FROM departments / * abccat_abc_sqlj_0002 * /';</pre><p>如果要使用<code class="codeph">-outlineprefix</code>选项转换多个文件，则可以使用以下命令：</p><pre class="oac_no_warn" dir="ltr">％sqlj -user = HR -url = jdbc：oracle：oci8：@ -outline = abccat -outlineprefix = pref1，pref2 abc.sqlj def.sqlj密码： <span class="italic">密码</span>
</pre><p>如果SQLJ文件是程序包的一部分而您尚未指定<code class="codeph">-outlineprefix</code>选项，则程序包名称将附加到大纲名称并添加到注释中。例如，如果<code class="codeph">abc.sqlj</code>是<code class="codeph">xyz.def.fgh</code>包的一部分， <code class="codeph">xyz.def.fgh</code>命令<code class="codeph">%sqlj -url=jdbc:oracle:oci8:@ -user=HR/</code>生成SQL文件<code class="codeph">abc_sqlj.sql</code> <code class="codeph">%sqlj -url=jdbc:oracle:oci8:@ -user=HR/</code> <span class="italic"><code class="codeph">password</code></span> <code class="codeph">-outline=abccat abc.sqlj</code>如下所示：</p><pre class="oac_no_warn" dir="ltr">创建或替换大纲abccat_xyz $ def $ fgh $ abc_sqlj_0001 FOR CATEGORY abccat ON SELECT * FROM employees WHERE employee_id =：B1 / * abccat_xyz $ def $ fgh $ abc_sqlj_0001 * /;创建或替换大纲abccat_xyz $ def $ fgh $ abc_sqlj_0002 FOR CATEGORY abccat ON SELECT * FROM departments / * abccat_xyz $ def $ fgh $ abc_sqlj_0002 * /;</pre><p>如果希望在成功转换结束时由转换程序执行生成的SQL文件，则可以将<code class="codeph">runoutline</code>选项设置为<code class="codeph">true</code> 。默认情况下为<code class="codeph">false.</code> 例如：</p><pre class="oac_no_warn" dir="ltr">％sqlj -user = HR -url = jdbc：oracle：oci8：@ -outline = default -runoutline = true abc.sqlj密码： <span class="italic">密码</span>
</pre><p>现在，如果要检索导出的大纲名称或修改SQL代码的计划，则可以手动或使用工具从<code class="codeph">OL$</code>表中检索相同的大小名称。您可以使用SQL查询中的注释来搜索相应的SQL语句以标识大纲名称，因为注释唯一地标识了SQL语句。
                  </p>
                  <p><a href="advanced-language-features.html#GUID-EB24FCD6-B42D-47FB-98B8-1D4285407E69__CBBEEECI" title="表格显示生成轮廓的选项和值">表8-1</a>显示了可以传递给转换程序以生成轮廓的所有选项和值。
                  </p>
                  <div class="tblformal" id="GUID-EB24FCD6-B42D-47FB-98B8-1D4285407E69__CBBEEECI">
                     <p class="titleintable">表8-1显示生成轮廓的选项和值的表</p>
                     <table cellpadding="4" cellspacing="0" class="Formal" title="表格显示生成轮廓的选项和值" width="100%" border="1" summary="Table showing options and values for generating outlines" frame="hsides" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="50%" id="d36232e6098">选项名称</th>
                              <th align="left" valign="bottom" width="50%" id="d36232e6101">期权价值</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="50%" id="d36232e6106" headers="d36232e6098 ">
                                 <p><code class="codeph">-大纲</code></p>
                              </td>
                              <td align="left" valign="top" width="50%" headers="d36232e6106 d36232e6101 ">
                                 <p><code class="codeph">true</code> &lt;类别名称&gt;</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="50%" id="d36232e6116" headers="d36232e6098 ">
                                 <p><code class="codeph">-outlineprefix</code></p>
                              </td>
                              <td align="left" valign="top" width="50%" headers="d36232e6116 d36232e6101 ">
                                 <p><code class="codeph">none</code> &lt;前缀名称&gt; | <code class="codeph">none</code> &lt;前缀名称1，前缀名称2，...&gt;</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="50%" id="d36232e6129" headers="d36232e6098 ">
                                 <p><code class="codeph">-runoutline</code></p>
                              </td>
                              <td align="left" valign="top" width="50%" headers="d36232e6129 d36232e6101 ">
                                 <p><code class="codeph">true</code> | <code class="codeph">false</code></p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
                  <div class="infoboxnotealso" id="GUID-EB24FCD6-B42D-47FB-98B8-1D4285407E69__GUID-E9D5A9E3-85AD-4256-925B-5EBEDAEDEEF5">
                     <p class="notep1">也可以看看：</p>
                     <p>有关轮廓的更多信息，请<a href="../refrn/DBA_OUTLINES.html#REFRN-GUID-D311BC8E-FB08-4990-8DED-C6AB221088F2" target="_blank"><span><cite>参见Oracle数据库参考</cite></span></a>
                     </p>
                  </div>
                  <div class="section">
                     <p class="subhead2" id="GUID-EB24FCD6-B42D-47FB-98B8-1D4285407E69__GUID-92B9F11C-2046-40EB-AC52-6339AA7953C9">生成的LOG文件名</p>
                  </div>
                  <!-- class="section" -->
                  <p>生成的文件名的格式为：</p><pre class="oac_no_warn" dir="ltr">&lt;文件名&gt; _ &lt;文件类型&gt; .log中</pre><p>例如，在翻译<code class="codeph">abc.sqlj</code> ，生成的日志文件是<code class="codeph">abc_sqlj.log.</code></p>
                  <div class="section">
                     <p class="subhead2" id="GUID-EB24FCD6-B42D-47FB-98B8-1D4285407E69__GUID-F942FC80-8EB1-42CB-B941-85CFC2042A2B">生成的LOG文件格式</p>
                  </div>
                  <!-- class="section" -->
                  <p>假设您有以下代码段：</p><pre class="oac_no_warn" dir="ltr">#sql iter = {SELECT * FROM employees WHERE employee_id =：var}; #sql iter1 = {SELECT * FROM departments};</pre><p>前面的代码段生成的日志文件如下：</p><pre class="oac_no_warn" dir="ltr">CATERGORY abccat源SQL_1 SELECT * FROM employees WHERE employee_id =：B1 OUTLINE NAME abccat_abc_sqlj_0001 OUTLINE SQL_1 CREATE OR REPLACE OUTLINE abccat_abc_sqlj_0001 FOR CATEGORY abccat ON SELECT * FROM employees WHERE employee_id =：B1 / * abccat_abc_sqlj_0001 * / STATUS success Source SQL_2 SELECT * FROM departments OUTLINE名称abccat_abc_sqlj_0002概述SQL_2创建或替换大纲abccat_abc_sqlj_2 FOR abccat ON SELECT * FROM departments / * abccat_abc_sqlj_2 * / STATUS失败</pre><p>在前面生成的日志文件格式示例中：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>类别表示要生成的大纲的类别</p>
                     </li>
                     <li>
                        <p>Source表示要为其生成大纲的SQL语句</p>
                     </li>
                     <li>
                        <p>大纲名称是要生成的大纲的名称</p>
                     </li>
                     <li>
                        <p>Status是用作源的SQL语句的执行状态。如果执行成功，则状态为<code class="codeph">success.</code> 否则，它会<code class="codeph">fail.</code></p>
                     </li>
                  </ul>
                  <div class="section">
                     <p class="subhead2" id="GUID-EB24FCD6-B42D-47FB-98B8-1D4285407E69__GUID-8E8DAD66-15EF-4C6E-8DB4-357084867674">配置文件</p>
                  </div>
                  <!-- class="section" -->
                  <p>您可以在配置文件中设置不同的命令行选项，如下所示：</p>
                  <div class="section">
                     <p class="subhead2" id="GUID-EB24FCD6-B42D-47FB-98B8-1D4285407E69__GUID-3C5B9EE1-C1EE-430E-B330-5209851A6DD0">sqlj.outline</p>
                  </div>
                  <!-- class="section" -->
                  <ul style="list-style-type:disc">
                     <li>
                        <p>参数名称： <code class="codeph">outline</code></p>
                     </li>
                     <li>
                        <p>参数类型：字符串</p>
                     </li>
                     <li>
                        <p>允许值：{true | category_name}</p>
                     </li>
                     <li>
                        <p>默认值：true</p>
                     </li>
                     <li>
                        <p>描述：表示需要为SQL语句生成大纲SQL文件，它应该位于：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>如果值是默认值，则为DEFAULT类别，即<code class="codeph">true</code></p>
                           </li>
                           <li>
                              <p>提到<span class="italic">category_name时</span>的类别名称</p>
                           </li>
                        </ul>
                        <p>如果未使用此选项，则不会生成大纲SQL文件。</p>
                     </li>
                     <li>
                        <p>对其他参数的依赖性：打开此选项时，应填写在线检查</p>
                     </li>
                  </ul>
                  <div class="section">
                     <p class="subhead2" id="GUID-EB24FCD6-B42D-47FB-98B8-1D4285407E69__GUID-44394535-9071-482A-955C-711DADF86DDF">sqlj.runoutline</p>
                  </div>
                  <!-- class="section" -->
                  <ul style="list-style-type:disc">
                     <li>
                        <p>参数名称： <code class="codeph">runoutline</code></p>
                     </li>
                     <li>
                        <p>参数类型：布尔值</p>
                     </li>
                     <li>
                        <p>允许值：{true | false}</p>
                     </li>
                     <li>
                        <p>默认值：false</p>
                     </li>
                     <li>
                        <p>描述：如果<code class="codeph">runoutline=true</code>那么生成的SQL文件应该在成功转换结束时由翻译者执行。
                        </p>
                     </li>
                     <li>
                        <p>对其他参数的依赖性：打开此选项时，在线检查应该已满，并且应设置outline选项。</p>
                     </li>
                  </ul>
                  <div class="section" id="GUID-EB24FCD6-B42D-47FB-98B8-1D4285407E69__CHDFFGHI">
                     <p class="subhead2" id="GUID-EB24FCD6-B42D-47FB-98B8-1D4285407E69__GUID-BAC61B19-BF5F-4575-8C34-5A46D18A40AE">sqlj.outlineprefix</p>
                  </div>
                  <!-- class="section" -->
                  <ul style="list-style-type:disc">
                     <li>
                        <p>参数名称： <code class="codeph">outlineprefix</code></p>
                     </li>
                     <li>
                        <p>参数类型：字符串</p>
                     </li>
                     <li>
                        <p>允许值：{前缀名称}，无</p>
                     </li>
                     <li>
                        <p>描述：如果设置了此选项，则生成的SQL中的大纲名称将设置为<code class="codeph">&lt;prefix&gt;_&lt;seqno&gt;</code> 。如果在属性文件中将此选项设置为除<code class="codeph">none</code>之外的任何值，则只能将一个SQLJ文件传递给转换程序。如果该选项设置为<code class="codeph">none</code> ，则在服务器中执行<code class="codeph">create outline</code>语句时，系统会生成大纲名称。此外，当<code class="codeph">–outlineprefix</code>设置为none时，您可以将多个文件传递给转换<code class="codeph">–outlineprefix</code> 。
                        </p>
                     </li>
                     <li>
                        <p>对其他参数的依赖性：打开此选项时，在线检查应该已满，并且应设置outline选项。</p>
                     </li>
                  </ul>
               </div>
            </div><a id="JSQLJ889"></a><div class="sect2"><a id="GUID-8465DD7E-5943-4BBD-911D-F1318A55552E" name="GUID-8465DD7E-5943-4BBD-911D-F1318A55552E"></a><h3 id="JSQLJ-GUID-8465DD7E-5943-4BBD-911D-F1318A55552E" class="sect3">使用计划基准</h3>
               <div>
                  <p>从Oracle Database 12 <span class="italic">c</span>第2版（12.2）开始，SQLJ支持使用Oracle数据库SQL计划管理（SPM）创建计划基准。您可以在翻译SQLJ文件时生成计划基准。在<code class="codeph">.sql</code>文件中生成用于创建计划基线的必要SQL语句。您可以在部署SQLJ应用程序之前查看，调整和修复计划基准。
                  </p>
                  <div class="infoboxnotealso" id="GUID-8465DD7E-5943-4BBD-911D-F1318A55552E__GUID-A69CE7F9-38E9-49AE-8288-35D6F465AF5A">
                     <p class="notep1">也可以看看：</p>
                     <p>有关计划基准的详细信息，请<a href="../tgsql/glossary.html#TGSQL-GUID-0C3F70B2-94F7-4ABF-B433-0F8E2925EE22" target="_blank"><span><cite>参见“Oracle数据库SQL调优指南”</cite></span></a></p>
                  </div>
                  <p>本节包含以下主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="advanced-language-features.html#GUID-D13CDA62-3ABF-482F-8D16-BE85CADF3FEB">生成计划基准</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-language-features.html#GUID-FFD5DDB4-DB81-42DE-A5EA-BF7B727FEEF5">命令行和属性文件选项</a></p>
                     </li>
                  </ul>
               </div><a id="JSQLJ891"></a><a id="JSQLJ890"></a><div class="sect3"><a id="GUID-D13CDA62-3ABF-482F-8D16-BE85CADF3FEB" name="GUID-D13CDA62-3ABF-482F-8D16-BE85CADF3FEB"></a><h4 id="JSQLJ-GUID-D13CDA62-3ABF-482F-8D16-BE85CADF3FEB" class="sect4">生成计划基准</h4>
                  <div>
                     <p>您可以为SPM支持的所有SQL语句生成计划基准。生成的日志文件报告不支持的语句（如果有）。</p>
                     <div class="section">
                        <p class="subhead3" id="GUID-D13CDA62-3ABF-482F-8D16-BE85CADF3FEB__GUID-31BF86BF-8375-48FC-A30E-3BAD1DBBA3C5">参数</p>
                     </div>
                     <!-- class="section" -->
                     <p>指定计划基线选项时，SQLJ会生成SQL文件，并调用<code class="codeph">dbms_spm_internal.create_sql_plan_baseline</code>过程。此过程具有以下参数：</p>
                     <div class="tblformal" id="GUID-D13CDA62-3ABF-482F-8D16-BE85CADF3FEB__GUID-D7DF942E-3319-4254-9441-4A7645BCB194">
                        <table cellpadding="4" cellspacing="0" class="Formal" title="" width="100%" border="1" summary="This table describes the parameters of create_sql_plan procedure" frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="29%" id="d36232e6404">参数</th>
                                 <th align="left" valign="bottom" width="71%" id="d36232e6407">描述</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d36232e6412" headers="d36232e6404 ">
                                    <p><code class="codeph">SQL_TEXT</code></p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d36232e6412 d36232e6407 ">
                                    <p>指定需要为其创建计划基准的SQL文本。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d36232e6420" headers="d36232e6404 ">
                                    <p><code class="codeph">PARSING_SCHEMA</code></p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d36232e6420 d36232e6407 ">
                                    <p>指定用于对传递的SQL文本进行语义检查的模式。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d36232e6428" headers="d36232e6404 ">
                                    <p><code class="codeph">PLAN_NAME</code></p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d36232e6428 d36232e6407 ">
                                    <p>指定计划基准的名称。此参数是可选的。如果未指定此参数，则默认计划名称为<code class="codeph">default.</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d36232e6438" headers="d36232e6404 ">
                                    <p><code class="codeph">启用</code></p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d36232e6438 d36232e6407 ">
                                    <p>指定是否启用计划。默认值为<code class="codeph">yes</code> 。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d36232e6449" headers="d36232e6404 ">
                                    <p><code class="codeph">固定</code></p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d36232e6449 d36232e6407 ">
                                    <p>指定计划是否为固定计划。默认值为<code class="codeph">no</code> 。
                                    </p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <div class="infoboxnote" id="GUID-D13CDA62-3ABF-482F-8D16-BE85CADF3FEB__GUID-C7C8F261-D814-49D2-AEDB-6FD4D47BEEC0">
                        <p class="notep1">注意：</p>
                        <p></p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>要生成并执行计划基线的SQL语句，你必须有<code class="codeph">Execute</code>上的特权<code class="codeph">DBMS_SPM_INTERNAL</code>包和<code class="codeph">Administer</code> <code class="codeph">SQL</code> <code class="codeph">Management</code> <code class="codeph">Object</code>的权限。
                              </p>
                           </li>
                           <li>
                              <p>计划基线选项仅在进行在线语义检查时才有效。如果使用脱机语义检查指定这些选项，则会忽略这些选项并抛出警告，通知选项应仅用于联机语义检查。</p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="JSQLJ892"></a><div class="sect3"><a id="GUID-FFD5DDB4-DB81-42DE-A5EA-BF7B727FEEF5" name="GUID-FFD5DDB4-DB81-42DE-A5EA-BF7B727FEEF5"></a><h4 id="JSQLJ-GUID-FFD5DDB4-DB81-42DE-A5EA-BF7B727FEEF5" class="sect4">命令行和属性文件选项</h4>
                  <div>
                     <p>使用以下命令行选项生成计划基准SQL语句：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="advanced-language-features.html#GUID-F32EE95C-7DE8-478A-B575-F9FE182B9B07">plan_baseline</a></p>
                        </li>
                        <li>
                           <p><a href="advanced-language-features.html#GUID-E210E14E-B525-4EFD-A500-BF519E95C725">plan_prefix</a></p>
                        </li>
                        <li>
                           <p><a href="advanced-language-features.html#GUID-30E179ED-C131-4617-8F31-93D98ACC0948">plan_run</a></p>
                        </li>
                        <li>
                           <p><a href="advanced-language-features.html#GUID-9310CCF4-130E-4D5F-87CA-A67E0F680EB3">plan_fixed</a></p>
                        </li>
                        <li>
                           <p><a href="advanced-language-features.html#GUID-798C741D-7485-4A8B-BFBD-E325EB1377E1">plan_enabled</a></p>
                        </li>
                     </ul>
                     <div class="infoboxnote" id="GUID-FFD5DDB4-DB81-42DE-A5EA-BF7B727FEEF5__GUID-BB1D20D0-F185-49D8-90E2-5D0CD1B836AA">
                        <p class="notep1">注意：</p>
                        <p>生成的文件指定运行文件的相应用户。例如，生成的文件中的以下语句指定<code class="codeph">HR</code>可以运行该文件：</p><pre class="oac_no_warn" dir="ltr">var ORA_SPM_PARSE_SCHEMA varchar2（30）; exec：ORA_SPM_PARSE_SCHEMA：='HR';</pre></div>
                  </div><a id="JSQLJ894"></a><a id="JSQLJ895"></a><a id="JSQLJ896"></a><a id="JSQLJ893"></a><div class="sect4"><a id="GUID-F32EE95C-7DE8-478A-B575-F9FE182B9B07" name="GUID-F32EE95C-7DE8-478A-B575-F9FE182B9B07"></a><h5 id="JSQLJ-GUID-F32EE95C-7DE8-478A-B575-F9FE182B9B07" class="sect5">plan_baseline</h5>
                     <div>
                        <p>使用<code class="codeph">plan_baseline</code>选项指定是否应为SQL文件中的所有SQL语句生成基准计划。如果将此选项设置为<code class="codeph">true</code> ，则将<code class="codeph">default</code>用作基准名称。使用轮廓时，基线名称等同于类别名称。在运行SQL文件时，您为此选项提供的值将用作模块名称。
                        </p>
                        <p>SQL文件的名称使用序列号进行转换，该组合用于唯一标识SQL文件中的每个SQL语句。此组合也用作计划的名称。序列号可以在0到9999之间变化。计划名称的格式如下：</p><pre class="oac_no_warn" dir="ltr">&lt;文件名&gt; _ &lt;文件类型&gt; _ &lt;sequence_no&gt;</pre><div class="section">
                           <p class="subhead3" id="GUID-F32EE95C-7DE8-478A-B575-F9FE182B9B07__GUID-0A3F2DCE-288F-4C59-A1CA-35AA7249B8DA">句法</p>
                        </div>
                        <!-- class="section" -->
                        <p>在命令行中， <code class="codeph">plan_baseline</code>选项指定如下：</p><pre class="oac_no_warn" dir="ltr">-plan_baseline = &lt;true / false / module_name&gt;</pre><p>在属性文件中， <code class="codeph">plan_baseline</code>选项指定如下：</p><pre class="oac_no_warn" dir="ltr">sqlj.plan_baseline = &lt;真/假/ MODULE_NAME&gt;</pre><div class="section">
                           <p class="subhead3" id="GUID-F32EE95C-7DE8-478A-B575-F9FE182B9B07__GUID-A186AC8B-D1F5-43D0-8634-ADB5C6BD19B6">默认值</p>
                        </div>
                        <!-- class="section" -->
                        <p><code class="codeph">plan_baseline</code>选项的默认值为<code class="codeph">false</code> ，在这种情况下，不会生成计划基线。如果为此选项指定值<code class="codeph">true</code> ，则模块名称为<code class="codeph">default.</code></p>
                        <div class="section">
                           <p class="subhead3" id="GUID-F32EE95C-7DE8-478A-B575-F9FE182B9B07__GUID-053EB3F7-8E7D-4B20-A3EB-A9101885A3BA">例</p>
                        </div>
                        <!-- class="section" --><pre class="oac_no_warn" dir="ltr">sqlj test.sqlj -plan_baseline = true -user = HR / hr</pre><p>如果<code class="codeph">test.sqlj</code>是名为<code class="codeph">mypackage</code>的包的一部分，并且只包含以下两个SQL语句：</p><pre class="oac_no_warn" dir="ltr">从员工中选择first_name;从员工中选择employee_id;</pre><p>然后，生成的SQL文件的内容是：</p><pre class="oac_no_warn" dir="ltr">var ORA_SPM_PARSE_SCHEMA varchar2（30）; exec：ORA_SPM_PARSE_SCHEMA：='HR'; begin dbms_application_info.set_module（'default'，''）;结束; BEGIN BEGIN d：= SYS.DBMS_SPM.DROP_SQL_PLAN_BASELINE（PLAN_NAME =&gt;'mypackage_test_sqlj_0000'）;除非其他人之外的例外情况;结束; c：= SYS.DBMS_SPM_INTERNAL.CREATE_SQL_PLAN_BASELINE（'从employees选择first_name / * mypackage_test_sqlj_0000 * /'，：ORA_SPM_PARSE_SCHEMA，'mypackage_test_sqlj_0000'，'no'，'no'）;结束 ; / BEGIN BEGIN d：= SYS.DBMS_SPM.DROP_SQL_PLAN_BASELINE（PLAN_NAME =&gt;'mypackage_test_sqlj_0001'）;除非其他人之外的例外情况;结束; c：= SYS.DBMS_SPM_INTERNAL.CREATE_SQL_PLAN_BASELINE（'从employees / * mypackage_test_sqlj_0001 * /'中选择employee_id，：ORA_SPM_PARSE_SCHEMA，'mypackage_test_sqlj_0001'，'no'，'no'）;结束 ; /</pre><p>如果<code class="codeph">test.sqlj</code>仅包含以下两个SQL语句：</p><pre class="oac_no_warn" dir="ltr">从员工中选择first_name;从员工中选择employee_id;</pre><p>并且您提供SPM计划名称如下：</p><pre class="oac_no_warn" dir="ltr">sqlj -plan_name = mybaseline -user = HR / hr test.sqlj</pre><p>然后，生成的SQL文件的内容是：</p><pre class="oac_no_warn" dir="ltr">var ORA_SPM_PARSE_SCHEMA varchar2（30）; exec：ORA_SPM_PARSE_SCHEMA：='HR'; begin dbms_application_info.set_module（'mybaseline，''）;结束; BEGIN BEGIN d：= SYS.DBMS_SPM.DROP_SQL_PLAN_BASELINE（PLAN_NAME =&gt;'mypackage_test_sqlj_0000'）;除非其他人之外的例外情况;结束; c：= SYS.DBMS_SPM_INTERNAL.CREATE_SQL_PLAN_BASELINE（'从employees选择first_name / * mypackage_test_sqlj_0000 * /'，：ORA_SPM_PARSE_SCHEMA，'mypackage_test_sqlj_0000'，'no'，'no'）;结束 ; / BEGIN BEGIN d：= SYS.DBMS_SPM.DROP_SQL_PLAN_BASELINE（PLAN_NAME =&gt;'mypackage_test_sqlj_0001'）;除非其他人之外的例外情况;结束; c：= SYS.DBMS_SPM_INTERNAL.CREATE_SQL_PLAN_BASELINE（'从employees / * mypackage_test_sqlj_0001 * /'中选择employee_id，：ORA_SPM_PARSE_SCHEMA，'mypackage_test_sqlj_0001'，'no'，'no'）;结束 ; /</pre></div>
                  </div><a id="JSQLJ898"></a><a id="JSQLJ899"></a><a id="JSQLJ900"></a><a id="JSQLJ897"></a><div class="sect4"><a id="GUID-E210E14E-B525-4EFD-A500-BF519E95C725" name="GUID-E210E14E-B525-4EFD-A500-BF519E95C725"></a><h5 id="JSQLJ-GUID-E210E14E-B525-4EFD-A500-BF519E95C725" class="sect5">plan_prefix</h5>
                     <div>
                        <p>使用<code class="codeph">plan_prefix</code>选项指定计划的名称。这对应于<code class="codeph">create_sql_plan_baseline</code>过程的<code class="codeph">PLAN_NAME</code>参数。如果不使用此选项，则会自动生成计划名称。
                        </p>
                        <div class="section">
                           <p class="subhead3" id="GUID-E210E14E-B525-4EFD-A500-BF519E95C725__GUID-FBADDB9A-EC15-41DB-9F2A-D4E50B805D03">句法</p>
                        </div>
                        <!-- class="section" -->
                        <p>在命令行中， <code class="codeph">plan_prefix</code>选项指定如下：</p><pre class="oac_no_warn" dir="ltr">-plan_prefix = &lt;名称&gt;</pre><p>在属性文件中， <code class="codeph">plan_prefix</code>选项指定如下：</p><pre class="oac_no_warn" dir="ltr">sqlj.plan_prefix = &lt;名称&gt;</pre><div class="section">
                           <p class="subhead3" id="GUID-E210E14E-B525-4EFD-A500-BF519E95C725__GUID-9CAB3874-3526-4A2E-8BEE-EC6FA61C9500">默认值</p>
                        </div>
                        <!-- class="section" -->
                        <p><code class="codeph">plan_prefix</code>选项的值为<code class="codeph">none</code> 。如果为此选项指定任何其他值，则计划名称的格式将变为以下内容：</p><pre class="oac_no_warn" dir="ltr">&lt;名称&gt; _ &lt;sequence_no&gt;</pre><div class="section">
                           <p class="subhead3" id="GUID-E210E14E-B525-4EFD-A500-BF519E95C725__GUID-74371BFF-089E-442D-A6F6-F1BD93D775FD">例</p>
                        </div>
                        <!-- class="section" -->
                        <p><code class="codeph">sqlj test.sqlj -plan_baseline = mybaseline true -user = HR / hr -plan_prefix = myprefix</code></p>
                        <p>假设， <code class="codeph">test.sqlj</code>只包含以下两个SQL语句：</p><pre class="oac_no_warn" dir="ltr">从员工中选择first_name;从员工中选择employee_id;</pre><p>然后，生成的SQL文件的内容是：</p><pre class="oac_no_warn" dir="ltr">var ORA_SPM_PARSE_SCHEMA varchar2（30）; exec：ORA_SPM_PARSE_SCHEMA：='HR'; begin dbms_application_info.set_module（'default'，''）;结束; BEGIN BEGIN d：= SYS.DBMS_SPM.DROP_SQL_PLAN_BASELINE（PLAN_NAME =&gt;'myprefix_0000'）;除非其他人之外的例外情况;结束; c：= SYS.DBMS_SPM_INTERNAL.CREATE_SQL_PLAN_BASELINE（'从employees / * myprefix_0000 * /'中选择first_name，：ORA_SPM_PARSE_SCHEMA，'myprefix_0000'，'no'，'no'）;结束 ; / BEGIN BEGIN d：= SYS.DBMS_SPM.DROP_SQL_PLAN_BASELINE（PLAN_NAME =&gt;'myprefix_0001'）;除非其他人之外的例外情况;结束; c：= SYS.DBMS_SPM_INTERNAL.CREATE_SQL_PLAN_BASELINE（'从employees / * myprefix_0001 * /'中选择employee_id，：ORA_SPM_PARSE_SCHEMA，'myprefix_0001'，'no'，'no'）;结束 ;</pre></div>
                  </div><a id="JSQLJ902"></a><a id="JSQLJ903"></a><a id="JSQLJ901"></a><div class="sect4"><a id="GUID-30E179ED-C131-4617-8F31-93D98ACC0948" name="GUID-30E179ED-C131-4617-8F31-93D98ACC0948"></a><h5 id="JSQLJ-GUID-30E179ED-C131-4617-8F31-93D98ACC0948" class="sect5">plan_run</h5>
                     <div>
                        <p>使用<code class="codeph">plan_run</code>选项指定是否希望SQLJ在转换结束时执行生成的SQL文件。
                        </p>
                        <div class="infoboxnote" id="GUID-30E179ED-C131-4617-8F31-93D98ACC0948__GUID-C04CF5D7-8B7D-4ACC-A545-F6EF0BA72842">
                           <p class="notep1">注意：</p>
                           <p>您<span class="italic">必须</span>具有以下权限才能执行生成的SQL文件：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>对<code class="codeph">DBMS_SPM_INTERNAL</code>包执行权限</p>
                              </li>
                              <li>
                                 <p>管理SQL管理对象权限</p>
                              </li>
                           </ul>
                        </div>
                        <div class="section">
                           <p class="subhead3" id="GUID-30E179ED-C131-4617-8F31-93D98ACC0948__GUID-9A82EADD-7626-429F-AB73-C0E7388EC320">句法</p>
                        </div>
                        <!-- class="section" -->
                        <p>在命令行中， <code class="codeph">plan_run</code>选项指定如下：</p><pre class="oac_no_warn" dir="ltr">-plan_run = &lt;是|否&gt;</pre><p>在属性文件中， <code class="codeph">plan_run</code>选项指定如下：</p><pre class="oac_no_warn" dir="ltr">sqlj.plan_run = &lt;是|否&gt;</pre><div class="section">
                           <p class="subhead3" id="GUID-30E179ED-C131-4617-8F31-93D98ACC0948__GUID-8C55A852-A37C-42F1-B9E8-9BC59A966AB7">默认值</p>
                        </div>
                        <!-- class="section" -->
                        <p><code class="codeph">plan_run</code>选项的默认值为<code class="codeph">yes</code> 。
                        </p>
                     </div>
                  </div><a id="JSQLJ905"></a><a id="JSQLJ906"></a><a id="JSQLJ904"></a><div class="sect4"><a id="GUID-9310CCF4-130E-4D5F-87CA-A67E0F680EB3" name="GUID-9310CCF4-130E-4D5F-87CA-A67E0F680EB3"></a><h5 id="JSQLJ-GUID-9310CCF4-130E-4D5F-87CA-A67E0F680EB3" class="sect5">plan_fixed</h5>
                     <div>
                        <p>使用<code class="codeph">plan_fixed</code>选项指定是否应修复生成的基线。
                        </p>
                        <div class="section">
                           <p class="subhead3" id="GUID-9310CCF4-130E-4D5F-87CA-A67E0F680EB3__GUID-C42D6644-6592-44AE-8C0D-2583A8BB73C8">句法</p>
                        </div>
                        <!-- class="section" -->
                        <p>在命令行中， <code class="codeph">plan_fixed</code>选项指定如下：</p><pre class="oac_no_warn" dir="ltr">-plan_fixed = &lt;yes | no&gt;</pre><p>在属性文件中， <code class="codeph">plan_fixed</code>选项指定如下：</p><pre class="oac_no_warn" dir="ltr">sqlj.plan_fixed = &lt;是|否&gt;</pre><div class="section">
                           <p class="subhead3" id="GUID-9310CCF4-130E-4D5F-87CA-A67E0F680EB3__GUID-DE5C9626-4A60-4E46-A64F-5CA6DD261263">默认值</p>
                        </div>
                        <!-- class="section" -->
                        <p>此选项的默认值为<code class="codeph">yes</code> 。
                        </p>
                     </div>
                  </div><a id="JSQLJ908"></a><a id="JSQLJ909"></a><a id="JSQLJ907"></a><div class="sect4"><a id="GUID-798C741D-7485-4A8B-BFBD-E325EB1377E1" name="GUID-798C741D-7485-4A8B-BFBD-E325EB1377E1"></a><h5 id="JSQLJ-GUID-798C741D-7485-4A8B-BFBD-E325EB1377E1" class="sect5">plan_enabled</h5>
                     <div>
                        <p>使用<code class="codeph">plan_enabled</code>选项指定是否应启用生成的基线。
                        </p>
                        <div class="section">
                           <p class="subhead3" id="GUID-798C741D-7485-4A8B-BFBD-E325EB1377E1__GUID-B1EE9C0E-03CB-48C8-AE9A-98DF4F674EF6">句法</p>
                        </div>
                        <!-- class="section" -->
                        <p>在命令行中， <code class="codeph">plan_enabled</code>选项指定如下：</p><pre class="oac_no_warn" dir="ltr">-plan_enabled = &lt;yes | no&gt;</pre><p>在属性文件中， <code class="codeph">plan_enabled</code>选项指定如下：</p><pre class="oac_no_warn" dir="ltr">sqlj.plan_enabled = &lt;是|否&gt;</pre><div class="section">
                           <p class="subhead3" id="GUID-798C741D-7485-4A8B-BFBD-E325EB1377E1__GUID-85B68844-4D2A-4519-B36D-6658FFC9CA83">默认值</p>
                        </div>
                        <!-- class="section" -->
                        <p>此选项的默认值为<code class="codeph">yes</code> 。
                        </p>
                     </div>
                  </div>
               </div><a id="JSQLJ910"></a><div class="sect3"><a id="GUID-DA93F6D3-1EF7-4CE3-9363-E0563F467A70" name="GUID-DA93F6D3-1EF7-4CE3-9363-E0563F467A70"></a><h4 id="JSQLJ-GUID-DA93F6D3-1EF7-4CE3-9363-E0563F467A70" class="sect4">生成的SQL文件</h4>
                  <div>
                     <p>在使用<a href="advanced-language-features.html#GUID-FFD5DDB4-DB81-42DE-A5EA-BF7B727FEEF5">命令行和属性文件选项中</a>描述的选项预编译SQLJ文件的末尾，将生成一个SQL文件。此SQL文件包含用于为SQLJ文件中的每个SQL语句创建SPM计划的SQL语句。
                     </p>
                     <p>本节包含以下主题：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="advanced-language-features.html#GUID-A798AD26-3AB6-4FED-ADB0-5C56811B19E4">生成的SQL文件名</a></p>
                        </li>
                        <li>
                           <p><a href="advanced-language-features.html#GUID-F318DEE5-41A4-430A-B0E4-D17650E6F192">生成的SQL文件格式</a></p>
                        </li>
                     </ul>
                  </div><a id="JSQLJ911"></a><div class="sect4"><a id="GUID-A798AD26-3AB6-4FED-ADB0-5C56811B19E4" name="GUID-A798AD26-3AB6-4FED-ADB0-5C56811B19E4"></a><h5 id="JSQLJ-GUID-A798AD26-3AB6-4FED-ADB0-5C56811B19E4" class="sect5">生成的SQL文件名</h5>
                     <div>
                        <p>生成的SQL文件的名称采用以下格式：</p><pre class="oac_no_warn" dir="ltr">&lt;文件名&gt; _ &lt;文件类型&gt; _bln.sql</pre><p>对于SQLJ，文件类型始终为<code class="codeph">.sqlj</code> 。因此，SQL文件的名称始终采用以下格式：</p><pre class="oac_no_warn" dir="ltr">&lt;文件名&gt; _sqlj_bln.sql</pre></div>
                  </div><a id="JSQLJ912"></a><div class="sect4"><a id="GUID-F318DEE5-41A4-430A-B0E4-D17650E6F192" name="GUID-F318DEE5-41A4-430A-B0E4-D17650E6F192"></a><h5 id="JSQLJ-GUID-F318DEE5-41A4-430A-B0E4-D17650E6F192" class="sect5">生成的SQL文件格式</h5>
                     <div>
                        <p>假设， <code class="codeph">test.sqlj</code>文件是包<code class="codeph">mypackage</code>的一部分，它包含以下SQL语句：</p><pre class="oac_no_warn" dir="ltr">#sql {select * from employees}; #sql {select manager_id from employees};</pre><p>如果使用以下命令预编译该文件：</p><pre class="oac_no_warn" dir="ltr">sqlj test.sqlj -plan_baseline = mybaseline -plan_prefix = myprefix -userid = HR / hr</pre><p>然后生成的SQL文件<code class="codeph">mypackage_test_sqlj_bln.sql</code>的内容是：</p><pre class="oac_no_warn" dir="ltr">var ORA_SPM_PARSE_SCHEMA varchar2（30）; exec：ORA_SPM_PARSE_SCHEMA：='HR'; begin dbms_application_info.set_module（'default'，''）;结束; BEGIN BEGIN d：= SYS.DBMS_SPM.DROP_SQL_PLAN_BASELINE（PLAN_NAME =&gt;'myprefix_0000'）;除非其他人之外的例外情况;结束; c：= SYS.DBMS_SPM_INTERNAL.CREATE_SQL_PLAN_BASELINE（'从employees / * myprefix_0000 * /'中选择first_name，：ORA_SPM_PARSE_SCHEMA，'myprefix_0000'，'no'，'no'）;结束 ; / BEGIN BEGIN d：= SYS.DBMS_SPM.DROP_SQL_PLAN_BASELINE（PLAN_NAME =&gt;'myprefix_0001'）;除非其他人之外的例外情况;结束; c：= SYS.DBMS_SPM_INTERNAL.CREATE_SQL_PLAN_BASELINE（'从employees / * myprefix_0001 * /'中选择employee_id，：ORA_SPM_PARSE_SCHEMA，'myprefix_0001'，'no'，'no'）;结束 ;</pre><div class="infoboxnote" id="GUID-F318DEE5-41A4-430A-B0E4-D17650E6F192__GUID-12F46793-B563-4528-A9DE-10A1DFC182B1">
                           <p class="notep1">注意：</p>
                           <p></p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>序列号0000和0001用于唯一标识每个SQL语句的计划名称。</p>
                              </li>
                              <li>
                                 <p>如果使用<code class="codeph">plan_prefix</code>选项指定<code class="codeph">none</code>以外的值，则使用前缀值而不是使用<code class="codeph">–plan_baseline</code>选项指定的值。
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </div>
                  </div>
               </div><a id="JSQLJ913"></a><div class="sect3"><a id="GUID-62420BB6-38D6-43CB-82FB-753742261137" name="GUID-62420BB6-38D6-43CB-82FB-753742261137"></a><h4 id="JSQLJ-GUID-62420BB6-38D6-43CB-82FB-753742261137" class="sect4">生成的日志文件</h4>
                  <div>
                     <p>在预编译结束时，将生成一个SQL文件。本节介绍日志文件的以下详细信息：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="advanced-language-features.html#GUID-FA1C4957-E930-4959-B510-0FF3498A750D">生成的日志文件名</a></p>
                        </li>
                        <li>
                           <p><a href="advanced-language-features.html#GUID-2DBEC927-2B64-4DC5-B0FF-992A8A8462CE">生成的日志文件格式</a></p>
                        </li>
                     </ul>
                  </div><a id="JSQLJ914"></a><div class="sect4"><a id="GUID-FA1C4957-E930-4959-B510-0FF3498A750D" name="GUID-FA1C4957-E930-4959-B510-0FF3498A750D"></a><h5 id="JSQLJ-GUID-FA1C4957-E930-4959-B510-0FF3498A750D" class="sect5">生成的日志文件名</h5>
                     <div>
                        <p>生成的日志文件的名称采用以下格式：</p><pre class="oac_no_warn" dir="ltr">&lt;文件名&gt; _ &lt;文件类型&gt; _bln.log</pre><p>对于SQLJ，文件类型始终为<code class="codeph">.sqlj</code> 。因此，SQL文件的名称始终采用以下格式：</p><pre class="oac_no_warn" dir="ltr">&lt;文件名&gt; _sqlj_bln.log</pre></div>
                  </div><a id="JSQLJ915"></a><div class="sect4"><a id="GUID-2DBEC927-2B64-4DC5-B0FF-992A8A8462CE" name="GUID-2DBEC927-2B64-4DC5-B0FF-992A8A8462CE"></a><h5 id="JSQLJ-GUID-2DBEC927-2B64-4DC5-B0FF-992A8A8462CE" class="sect5">生成的日志文件格式</h5>
                     <div>
                        <p>假设， <code class="codeph">test.sqlj</code>文件是包<code class="codeph">mypackage</code>的一部分，它包含以下SQL语句：</p><pre class="oac_no_warn" dir="ltr">#sql {select * from employees}; #sql {select manager_id from employees};</pre><p>如果使用以下命令预编译该文件：</p><pre class="oac_no_warn" dir="ltr">sqlj test.sqlj -plan_baseline = true userid = HR / hr</pre><p>然后生成的日志文件的内容是：</p><pre class="oac_no_warn" dir="ltr">MODULE默认SOURCE SQL_0 select * from employees;计划名称mypackage_test_sqlj_0000状态成功/ ****************************************** // ****************************************** / MODULE默认SOURCE SQL_1从中选择manager_id员工计划名称mypackage_test_sqlj_0001状态成功/ ****************************************** /</pre><p>如果使用以下命令预编译该文件：</p><pre class="oac_no_warn" dir="ltr">sqlj test.sqlj -plan_baseline = true userid = HR / hr -plan_prefix = myprefix</pre><p>然后生成的日志文件的内容是：</p><pre class="oac_no_warn" dir="ltr">MODULE默认SOURCE SQL_0 select * from employees;计划名称myprefix_0000状态成功/ ****************************************** // ****************************************** / MODULE默认SOURCE SQL_1从中选择manager_id员工计划名称myprefix_0001状态成功/ ****************************************** /</pre></div>
                  </div>
               </div><a id="JSQLJ916"></a><div class="sect3"><a id="GUID-364929C9-9E57-4301-9EEE-3A53F5B3122E" name="GUID-364929C9-9E57-4301-9EEE-3A53F5B3122E"></a><h4 id="JSQLJ-GUID-364929C9-9E57-4301-9EEE-3A53F5B3122E" class="sect4">生成的Java文件</h4>
                  <div>
                     <p>在预编译结束时，将生成Java文件。</p>
                     <p>假设， <code class="codeph">test.sqlj</code>文件是包<code class="codeph">mypackage</code>的一部分，它包含以下SQL语句：</p><pre class="oac_no_warn" dir="ltr">#sql {select * from employees};</pre><p>如果使用以下命令预编译该文件：</p><pre class="oac_no_warn" dir="ltr">sqlj test.sqlj -plan_baseline = mybaseline -plan_prefix = myprefix -userid = HR / hr</pre><p>然后生成的Java文件的标识符附加到SQL语句，如下所示：</p><pre class="oac_no_warn" dir="ltr">尝试{String theSqlTS =“从employees / * mybaseline_test_sqlj_0001 * /中选择first_name; __sJT_st = __sJT_ec.prepareOracleStatement（__ sJT_cc，“0Select”，theSqlTS）; //执行查询iter = new Iter（new sqlj.runtime.ref。OraRTResultSet（__ sJT_ec.oracleExecuteQuery（），__ sJT_st， “0Select”，NULL））; } finally {__sJT_ec.oracleCloseQuery（）; }</pre></div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>