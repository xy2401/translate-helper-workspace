<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html xml:lang="en-us" lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <title>Performance Extensions</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="JDBC Developer's Guide">
      <meta property="og:description" content>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="JDBC Developer's Guide">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="jdbc-developers-guide.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2019-02-13T13:20:37-08:00">
      <meta name="dcterms.title" content="JDBC Developer's Guide">
      <meta name="dcterms.dateCopyrighted" content="1999, 2019">
      <meta name="dcterms.category" content="database">
      <meta name="dcterms.identifier" content="E96471-02">
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19">
      
      <link rel="prev" href="statement-and-resultset-caching.html" title="Previous" type="text/html">
      <link rel="next" href="high-speed-ingestion-of-data-streams.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.isVersionOf" content="JJDBC">
    <meta name="dcterms.release" content="Release 19">
  </head>
   <body>
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="statement-and-resultset-caching.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>Previous</a>
         <a href="high-speed-ingestion-of-data-streams.html" class="pull-right">Next<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a>
         <span class="fa fa-exclamation-triangle" aria-hidden="true"></span> JavaScript must be enabled to correctly display this content
        
      </div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">JDBC Developer's Guide</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="performance-and-scalability.html" property="item" typeof="WebPage"><span property="name"> Performance and Scalability</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem"> Performance Extensions </li>
            </ol>
            <a id="GUID-FEECA64F-44F4-453F-B8A8-AFBF6D29ABA4" name="GUID-FEECA64F-44F4-453F-B8A8-AFBF6D29ABA4"></a><a id="JJDBC28752"></a>
            
            <h2 id="JJDBC-GUID-FEECA64F-44F4-453F-B8A8-AFBF6D29ABA4" class="sect2"><span class="enumeration_chapter">21 </span> Performance Extensions 
            </h2>
         </header>
         <div class="ind">
            <div>
               <p><a id="d67478e21" class="indexterm-anchor"></a><a id="d67478e25" class="indexterm-anchor"></a>This chapter describes the Oracle performance extensions to the Java Database Connectivity (JDBC) standard.
               </p>
               <p>This chapter covers the following topics:</p>
               <ul style="list-style-type: disc;">
                  <li>
                     <p><a href="performance-extensions.html#GUID-8B920135-D97D-4F33-8FF5-5774E802C520">Update Batching</a></p>
                  </li>
                  <li>
                     <p><a href="performance-extensions.html#GUID-96A38C6D-A288-4E0B-9F03-E711C146632B">Additional Oracle Performance Extensions</a></p>
                  </li>
               </ul>
               <div class="infoboxnote" id="GUID-FEECA64F-44F4-453F-B8A8-AFBF6D29ABA4__GUID-8841910F-7FE9-44A6-89DE-F42183CFD28C">
                  <p class="notep1">Note:</p>
                  <p>Oracle update batching was deprecated in Oracle Database 12<span class="italic">c</span> Release 1 (12.1). Starting in Oracle Database 12<span class="italic">c</span> Release 2 (12.2), Oracle update batching is a no operation code (no-op). This means that if you implement Oracle update batching in your application, using the Oracle Database 12<span class="italic">c</span> Release 2 (12.2) JDBC driver, then the specified batch size is not set and results in a batch size of 1. With this batch setting, your application processes one row at a time. Oracle strongly recommends that you use the standard JDBC batching if you are using the Oracle Database 12<span class="italic">c</span> Release 2 (12.2) JDBC driver.
                  </p>
               </div>
            </div><a id="JJDBC28753"></a><div class="props_rev_3"><a id="GUID-8B920135-D97D-4F33-8FF5-5774E802C520" name="GUID-8B920135-D97D-4F33-8FF5-5774E802C520"></a><h3 id="JJDBC-GUID-8B920135-D97D-4F33-8FF5-5774E802C520" class="sect3"><span class="enumeration_section">21.1 </span>Update Batching
               </h3>
               <div>
                  <p>This section covers the following topics:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="performance-extensions.html#GUID-0DED2C61-397C-48D3-AE68-A085D2E29E1A">Overview of Update Batching</a></p>
                     </li>
                     <li>
                        <p><a href="performance-extensions.html#GUID-24D35E13-A9C0-43F3-8F8B-870AD1BF5339">Standard Update Batching</a></p>
                     </li>
                     <li>
                        <p><a href="performance-extensions.html#GUID-6BAAB99B-8F5D-43A4-9445-4CC90E26F211">Premature Batch Flush</a></p>
                     </li>
                  </ul>
               </div>
               <div class="props_rev_3"><a id="GUID-0DED2C61-397C-48D3-AE68-A085D2E29E1A" name="GUID-0DED2C61-397C-48D3-AE68-A085D2E29E1A"></a><h4 id="JJDBC-GUID-0DED2C61-397C-48D3-AE68-A085D2E29E1A" class="sect4"><span class="enumeration_section">21.1.1 </span>Overview of Update Batching
                  </h4>
                  <div>
                     <p>You can reduce the number of round-trips to the database, thereby improving application performance, by grouping multiple <code class="codeph">UPDATE</code>, <code class="codeph">DELETE</code>, or <code class="codeph">INSERT</code> statements into a single batch and having the whole batch sent to the database and processed in one trip. This is referred to as 'update batching'. This is especially useful with prepared statements, when you are repeating the same statement with different bind variables.
                     </p>
                     <div class="infoboxnote" id="GUID-0DED2C61-397C-48D3-AE68-A085D2E29E1A__GUID-20F2AAD9-E0E0-46A4-AE4F-782FB4425A5C">
                        <p class="notep1">Note:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>The JDBC 2.0 specification refers to 'update batching' as 'batch updates'.</p>
                           </li>
                           <li>
                              <p>To adhere to the JDBC 2.0 standard, Oracle implementation of standard update batching supports callable statements without <code class="codeph">OUT</code> parameters, generic statements, and prepared statements. You can migrate standard update batching into an Oracle JDBC application without difficulty. However, the Oracle implementation of standard update batching does not implement true batching for generic statements and callable statements and you will see performance improvement for only <code class="codeph">PreparedStatement</code> objects.
                              </p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="JJDBC28767"></a><div class="props_rev_3"><a id="GUID-24D35E13-A9C0-43F3-8F8B-870AD1BF5339" name="GUID-24D35E13-A9C0-43F3-8F8B-870AD1BF5339"></a><h4 id="JJDBC-GUID-24D35E13-A9C0-43F3-8F8B-870AD1BF5339" class="sect4"><span class="enumeration_section">21.1.2 </span>Standard Update Batching
                  </h4>
                  <div>
                     <p>JDBC standard update batching depends on explicitly adding statements to the batch using an <code class="codeph">addBatch</code> method and explicitly processing the batch using an <code class="codeph">executeBatch</code> method.
                     </p>
                     <div class="infoboxnote" id="GUID-24D35E13-A9C0-43F3-8F8B-870AD1BF5339__GUID-DDF20CF5-42D0-43C1-AAA5-F332B2270550">
                        <p class="notep1">Note:</p>
                        <p>Disable auto-commit mode when you use update batching. In case an error occurs while you are processing a batch, this provides you the option of committing or rolling back the operations that ran successfully prior to the error.</p>
                     </div>
                  </div><a id="JJDBC28768"></a><div class="props_rev_3"><a id="GUID-0D1B2185-4395-416A-9D64-0221ED02D166" name="GUID-0D1B2185-4395-416A-9D64-0221ED02D166"></a><h5 id="JJDBC-GUID-0D1B2185-4395-416A-9D64-0221ED02D166" class="sect5"><span class="enumeration_section">21.1.2.1 </span>Limitations in the Oracle Implementation of Standard Batching
                     </h5>
                     <div>
                        <div class="section">
                           <p>This section discusses the limitations and implementation details regarding the Oracle implementation of standard update batching.</p>
                           <p>In Oracle JDBC applications, update batching is intended for use with prepared statements that are being processed repeatedly with different sets of bind values. </p>
                           <p>The Oracle implementation of standard update batching does not implement true batching for generic statements and callable statements. Even though Oracle JDBC supports the use of standard batching for <code class="codeph">Statement</code> and <code class="codeph">CallableStatement</code> objects, you are unlikely to see performance improvement.
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="JJDBC28769"></a><div class="props_rev_3"><a id="GUID-8848824F-F505-4EAE-A2F6-DEDB1945E45F" name="GUID-8848824F-F505-4EAE-A2F6-DEDB1945E45F"></a><h5 id="JJDBC-GUID-8848824F-F505-4EAE-A2F6-DEDB1945E45F" class="sect5"><span class="enumeration_section">21.1.2.2 </span>About Adding Operations to the Batch
                     </h5>
                     <div>
                        <p>When any statement object is first created, its statement batch is empty. Use the standard <code class="codeph">addBatch</code> method to add an operation to the statement batch. This method is specified in the standard <code class="codeph">java.sql.Statement</code>, <code class="codeph">PreparedStatement</code>, and <code class="codeph">CallableStatement</code> interfaces, which are implemented by the <code class="codeph">oracle.jdbc.OracleStatement</code>, <code class="codeph">OraclePreparedStatement</code>, and <code class="codeph">OracleCallableStatement</code> interfaces, respectively.
                        </p>
                        <p>For a <code class="codeph">Statement</code> object, the <code class="codeph">addBatch</code> method takes a Java <code class="codeph">String</code> with a SQL operation as input. For example:
                        </p><pre class="oac_no_warn" dir="ltr">...
Statement stmt = conn.createStatement();

stmt.addBatch("INSERT INTO emp VALUES(1000, 'Joe Jones')");
stmt.addBatch("INSERT INTO dept VALUES(260, 'Sales')");
stmt.addBatch("INSERT INTO emp_dept VALUES(1000, 260)");
...
</pre><p>At this point, three operations are in the batch.</p>
                        <p>For prepared statements, update batching is used to batch multiple runs of the same statement with different sets of bind parameters. For a <code class="codeph">PreparedStatement</code> or <code class="codeph">OraclePreparedStatement</code> object, the <code class="codeph">addBatch</code> method takes no input. It simply adds the operation to the batch using the bind parameters last set by the appropriate <code class="codeph">set</code><span class="italic"><code class="codeph">XXX</code></span> methods. This is also true for <code class="codeph">CallableStatement</code> or <code class="codeph">OracleCallableStatement</code> objects, but remember that in the Oracle implementation of standard update batching, you will probably see no performance improvement in batching callable statements.
                        </p>
                        <p>For example:</p><pre class="oac_no_warn" dir="ltr">...
PreparedStatement pstmt = 
          conn.prepareStatement("INSERT INTO employees VALUES(?, ?)");

pstmt.setInt(1, 2000);
pstmt.setString(2, "Milo Mumford");
pstmt.addBatch();

pstmt.setInt(1, 3000);
pstmt.setString(2, "Sulu Simpson");
pstmt.addBatch();
...
</pre><p>At this point, two operations are in the batch.</p>
                        <p>Because a batch is associated with a single prepared statement object, you can batch only repeated runs of a single prepared statement, as in this example.</p>
                     </div>
                  </div><a id="JJDBC28770"></a><div class="props_rev_3"><a id="GUID-EB4B2280-70DF-4433-8B4A-59DD3108DB41" name="GUID-EB4B2280-70DF-4433-8B4A-59DD3108DB41"></a><h5 id="JJDBC-GUID-EB4B2280-70DF-4433-8B4A-59DD3108DB41" class="sect5"><span class="enumeration_section">21.1.2.3 </span>About Processing the Batch
                     </h5>
                     <div>
                        <p>To process the current batch of operations, use the <code class="codeph">executeBatch</code> method of the statement object. This method is specified in the standard <code class="codeph">Statement</code> interface, which is extended by the standard <code class="codeph">PreparedStatement</code> and <code class="codeph">CallableStatement</code> interfaces.
                        </p>
                        <div class="infoboxnote" id="GUID-EB4B2280-70DF-4433-8B4A-59DD3108DB41__GUID-82911FAB-1BF5-47BE-90ED-5B1C2A9FD334">
                           <p class="notep1">Note:</p>
                           <p>If you add too many operations to a batch by calling the <code class="codeph">addBatch</code> method several times and create a very large batch (for example, with more than or equal to 100,000 rows), then while calling the <code class="codeph">executeBatch</code> method on the whole batch, you may face severe performance problems in terms of memory. To avoid this issue, the JDBC driver transparently breaks up the large batches into smaller internal batches and makes a roundtrip to the server for each internal batch. This makes your application slightly slower because of each round-trip overhead, but optimizes memory significantly. However, if each bound row is very large in size (for example, more than about 1MB each or so), then this process can impact the overall performance negatively because in such a case, the performance gained in terms of memory will be less than the performance lost in terms of time.
                           </p>
                        </div>
                        <p>Following is an example that repeats the prepared statement <code class="codeph">addBatch</code> calls shown previously and then processes the batch:
                        </p><pre class="oac_no_warn" dir="ltr">...
PreparedStatement pstmt = 
          conn.prepareStatement("INSERT INTO employees VALUES(?, ?)");

pstmt.setInt(1, 2000);
pstmt.setString(2, "Milo Mumford");
pstmt.addBatch();

pstmt.setInt(1, 3000);
pstmt.setString(2, "Sulu Simpson");
pstmt.addBatch();

int[] updateCounts = pstmt.executeBatch();
...
</pre></div>
                  </div><a id="JJDBC29182"></a><div class="props_rev_3"><a id="GUID-20BF8463-A574-48CB-AD56-18CF8DEF603D" name="GUID-20BF8463-A574-48CB-AD56-18CF8DEF603D"></a><h5 id="JJDBC-GUID-20BF8463-A574-48CB-AD56-18CF8DEF603D" class="sect5"><span class="enumeration_section">21.1.2.4 </span>Row Count per Iteration for Array DMLs
                     </h5>
                     <div>
                        <div class="section">
                           <p>Starting from Oracle Database 12<span class="italic">c </span>Release 1 (12.1), the <code class="codeph">executeBatch</code> method has been improved so that it returns an int array of size that is the same as the number of records in the batch and each item in the return array is the number of database table rows affected by the corresponding record of the batch. For example, if the batch size is 5, then the <code class="codeph">executeBatch</code> method returns an array of size 5. In case of an error in between execution of the batch, the <code class="codeph">executeBatch</code> method cannot return a value, instead it throws a <code class="codeph">BatchUpdateException</code>. In this case, the exception itself carries an int array of size <code class="codeph">n</code> as its data, where <code class="codeph">n</code> is the number of successful record executions. For example, if the batch is of size 5 and the error occurs at the 4th record, then the <code class="codeph">BatchUpdateException</code> has an array of size 3 (3 records executed successfully) and each item in the array represents how many rows were affected by each of  them.
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="JJDBC28771"></a><div class="props_rev_3"><a id="GUID-B3FC184E-8F92-4B33-8213-29CA69ABF86C" name="GUID-B3FC184E-8F92-4B33-8213-29CA69ABF86C"></a><h5 id="JJDBC-GUID-B3FC184E-8F92-4B33-8213-29CA69ABF86C" class="sect5"><span class="enumeration_section">21.1.2.5 </span>About Committing the Changes in the Oracle Implementation of Standard Batching
                     </h5>
                     <div>
                        <p>After you process the batch, you must still commit the changes, presuming auto-commit is disabled as recommended. </p>
                        <p>Calling <code class="codeph">commit</code>, commits nonbatched operations and batched operations for statement batches that have been processed, but for the Oracle implementation of standard batching, has no effect on pending statement batches that have <span class="italic">not</span> been processed.
                        </p>
                     </div>
                  </div><a id="JJDBC28772"></a><div class="props_rev_3"><a id="GUID-61B19DD7-9681-4C02-B7CF-48B115F41F1B" name="GUID-61B19DD7-9681-4C02-B7CF-48B115F41F1B"></a><h5 id="JJDBC-GUID-61B19DD7-9681-4C02-B7CF-48B115F41F1B" class="sect5"><span class="enumeration_section">21.1.2.6 </span>About Clearing the Batch
                     </h5>
                     <div>
                        <p>To clear the current batch of operations instead of processing it, use the <code class="codeph">clearBatch</code> method of the statement object. This method is specified in the standard <code class="codeph">Statement</code> interface, which is extended by the standard <code class="codeph">PreparedStatement</code> and <code class="codeph">CallableStatement</code> interfaces.
                        </p>
                        <p>Keep the following things in mind:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>When a batch is processed, operations are performed in the order in which they were batched.</p>
                           </li>
                           <li>
                              <p>After calling <code class="codeph">addBatch</code>, you must call either <code class="codeph">executeBatch</code> or <code class="codeph">clearBatch</code> before a call to <code class="codeph">executeUpdate</code>, otherwise there will be a SQL exception.
                              </p>
                           </li>
                           <li>
                              <p>A <code class="codeph">clearBatch</code> or <code class="codeph">executeBatch</code> call resets the statement batch to empty. 
                              </p>
                           </li>
                           <li>
                              <p>The statement batch is not reset to empty if the connection receives a <code class="codeph">ROLLBACK</code> request. You must explicitly call <code class="codeph">clearBatch</code> to reset it.
                              </p>
                           </li>
                           <li>
                              <p>Invoking <code class="codeph">clearBatch</code> method after a rollback works for all releases.
                              </p>
                           </li>
                           <li>
                              <p>An <code class="codeph">executeBatch</code> call closes the current result set of the statement object, if one exists.
                              </p>
                           </li>
                           <li>
                              <p>Nothing is returned by the <code class="codeph">clearBatch</code> method.
                              </p>
                           </li>
                        </ul>
                        <p>Following is an example that repeats the prepared statement <code class="codeph">addBatch</code> calls shown previously but then clears the batch under certain circumstances:
                        </p><pre class="oac_no_warn" dir="ltr">...
PreparedStatement pstmt = 
          conn.prepareStatement("INSERT INTO employees VALUES(?, ?)");

pstmt.setInt(1, 2000);
pstmt.setString(2, "Milo Mumford");
pstmt.addBatch();

pstmt.setInt(1, 3000);
pstmt.setString(2, "Sulu Simpson");
pstmt.addBatch();

if (...<span class="italic">condition</span>...)
{
   int[] updateCounts = pstmt.executeBatch();
   ...
}
else
{
   pstmt.clearBatch();
   ...
}
</pre></div>
                  </div><a id="JJDBC28774"></a><a id="JJDBC28773"></a><div class="props_rev_3"><a id="GUID-E399D995-77F0-48A2-8659-3FD3363D6474" name="GUID-E399D995-77F0-48A2-8659-3FD3363D6474"></a><h5 id="JJDBC-GUID-E399D995-77F0-48A2-8659-3FD3363D6474" class="sect5"><span class="enumeration_section">21.1.2.7 </span>Update Counts in the Oracle Implementation of Standard Batching
                     </h5>
                     <div>
                        <p>If a statement batch is processed successfully, then the integer array, or update counts array, returned by the statement <code class="codeph">executeBatch</code> call will always have one element for each operation in the batch. In the Oracle implementation of standard update batching, the values of the array elements are as follows:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>For a prepared statement batch, the array contains the actual update counts indicating the number of rows affected by each operation.</p>
                           </li>
                           <li>
                              <p>For a generic statement batch, the array contains the actual update counts indicating the number of rows affected by each operation. The actual update counts can be provided only in the case of generic statements in the Oracle implementation of standard batching.</p>
                           </li>
                           <li>
                              <p>For a callable statement batch, the array contains the actual update counts indicating the number of rows affected by each operation.</p>
                           </li>
                        </ul>
                        <p>In your code, upon successful processing of a batch, you should be prepared to handle either <code class="codeph">-2</code>, <code class="codeph">1</code>, or true update counts in the array elements. For a successful batch processing, the array contains either all <code class="codeph">-2</code>, <code class="codeph">1</code>, or all positive integers.
                        </p>
                        <p><a href="performance-extensions.html#GUID-E399D995-77F0-48A2-8659-3FD3363D6474__CHDCBHEC">Example 21-1</a> illustrates the use of standard update batching.
                        </p>
                        <div class="example" id="GUID-E399D995-77F0-48A2-8659-3FD3363D6474__CHDCBHEC">
                           <p class="titleinexample">Example 21-1 Standard Update Batching</p>
                           <p>This example combines the sample fragments in the previous sections, accomplishing the following steps:</p>
                           <ol>
                              <li>
                                 <p>Disabling auto-commit mode, which you should always perform when using update batching</p>
                              </li>
                              <li>
                                 <p>Creating a prepared statement object</p>
                              </li>
                              <li>
                                 <p>Adding operations to the batch associated with the prepared statement object</p>
                              </li>
                              <li>
                                 <p>Processing the batch</p>
                              </li>
                              <li>
                                 <p>Committing the operations from the batch</p>
                              </li>
                           </ol><pre class="oac_no_warn" dir="ltr">conn.setAutoCommit(false);

PreparedStatement pstmt = 
          conn.prepareStatement("INSERT INTO employees VALUES(?, ?)");

pstmt.setInt(1, 2000);
pstmt.setString(2, "Milo Mumford");
pstmt.addBatch();

pstmt.setInt(1, 3000);
pstmt.setString(2, "Sulu Simpson");
pstmt.addBatch();

int[] updateCounts = pstmt.executeBatch();

conn.commit();

pstmt.close();
...
</pre><p>You can process the update counts array to determine if the batch processed successfully.</p>
                        </div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="JJDBC28775"></a><div class="props_rev_3"><a id="GUID-BF1E09C3-44A7-4CE9-A28A-BB01D5E335A9" name="GUID-BF1E09C3-44A7-4CE9-A28A-BB01D5E335A9"></a><h5 id="JJDBC-GUID-BF1E09C3-44A7-4CE9-A28A-BB01D5E335A9" class="sect5"><span class="enumeration_section">21.1.2.8 </span>Error Handling in the Oracle Implementation of Standard Batching
                     </h5>
                     <div>
                        <p>If any one of the batched operations fails to complete successfully or attempts to return a result set during an <code class="codeph">executeBatch</code> call, then the processing stops and a <code class="codeph">java.sql.BatchUpdateException</code> is generated.
                        </p>
                        <p>After a batch exception, the update counts array can be retrieved using the <code class="codeph">getUpdateCounts</code> method of the <code class="codeph">BatchUpdateException</code> object. This returns an <code class="codeph">int</code> array of update counts, just as the <code class="codeph">executeBatch</code> method does. In the Oracle implementation of standard update batching, contents of the update counts array are as follows, after a batch is processed:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>For a pr<a id="d67478e724" class="indexterm-anchor"></a><a id="d67478e728" class="indexterm-anchor"></a>epared statement batch, in case of an error in between execution of the batch, the <code class="codeph">executeBatch</code> method cannot return a value, instead it throws a <code class="codeph">BatchUpdateException</code>. In this case, the exception itself carries an int array of size <code class="codeph">n</code> as its data, where <code class="codeph">n</code> is the number of successful record executions. For example, if the batch is of size 5 and the error occurs at the 4th record, then the <code class="codeph">BatchUpdateException</code> has an array of size 3 (3 records executed successfully) and each item in the array represents how many rows were affected by each of them.
                              </p>
                           </li>
                           <li>
                              <p>For a generic statement batch or callable statement batch, the update counts array is only a partial array containing the actual update counts up to the point of the error. The actual update counts can be provided because Oracle JDBC cannot use true batching for generic and callable statements in the Oracle implementation of standard update batching.</p>
                              <p>For example, if there were 20 operations in the batch, the first 13 succeeded, and the 14th generated an exception, then the update counts array will have 13 elements, containing actual update counts of the successful operations.</p>
                              <p>You can either commit or roll back the successful operations in this situation, as you prefer.</p>
                           </li>
                        </ul>
                        <p>In your code, upon failed processing of a batch, you should be prepared to handle either <code class="codeph">-3</code> or true update counts in the array elements when an exception occurs. For a failed batch processing, you will have either a full array of <code class="codeph">-3</code> or a partial array of positive integers.
                        </p>
                     </div>
                  </div><a id="JJDBC28776"></a><div class="props_rev_3"><a id="GUID-244F4126-6AF6-4751-8F16-163A3336F29F" name="GUID-244F4126-6AF6-4751-8F16-163A3336F29F"></a><h5 id="JJDBC-GUID-244F4126-6AF6-4751-8F16-163A3336F29F" class="sect5"><span class="enumeration_section">21.1.2.9 </span>About Intermixing Batched Statements and Nonbatched Statements
                     </h5>
                     <div>
                        <p>You cannot call <code class="codeph">executeUpdate</code> for regular, nonbatched processing of an operation if the statement object has a pending batch of operations.
                        </p>
                        <p>However, you can intermix batched operations and nonbatched operations in a single statement object if you process nonbatched operations either prior to adding any operations to the statement batch or after processing the batch. Essentially, you can call <code class="codeph">executeUpdate</code> for a statement object only when its update batch is empty. If the batch is non-empty, then an exception will be generated.
                        </p>
                        <p>For example, it is valid to have a sequence, such as the following:</p><pre class="oac_no_warn" dir="ltr">...
PreparedStatement pstmt = 
          conn.prepareStatement("INSERT INTO employees VALUES(?, ?)");

pstmt.setInt(1, 2000);
pstmt.setString(2, "Milo Mumford");

int scount = pstmt.executeUpdate();   // OK; no operations in pstmt batch

pstmt.setInt(1, 3000);
pstmt.setString(2, "Sulu Simpson");
pstmt.addBatch();                    // Now start a batch

pstmt.setInt(1, 4000);
pstmt.setString(2, "Stan Leland");
pstmt.addBatch();

int[] bcounts = pstmt.executeBatch();

pstmt.setInt(1, 5000);
pstmt.setString(2, "Amy Feiner");

int scount = pstmt.executeUpdate();   // OK; pstmt batch was executed
...
</pre><p>Intermixing nonbatched operations on one statement object and batched operations on another statement object within your code is permissible. Different statement objects are independent of each other with regard to update batching operations. A <code class="codeph">COMMIT</code> request will affect all nonbatched operations and all successful operations in processed batches, but will not affect any pending batches.
                        </p>
                     </div>
                  </div>
               </div><a id="JJDBC28778"></a><a id="JJDBC28777"></a><div class="props_rev_3"><a id="GUID-6BAAB99B-8F5D-43A4-9445-4CC90E26F211" name="GUID-6BAAB99B-8F5D-43A4-9445-4CC90E26F211"></a><h4 id="JJDBC-GUID-6BAAB99B-8F5D-43A4-9445-4CC90E26F211" class="sect4"><span class="enumeration_section">21.1.3 </span>Premature Batch Flush
                  </h4>
                  <div>
                     <p>Premature batch flush happens due to a change in cached metadata. Cached metadata can be changed due to various reasons, such as the following:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>The initial bind was null and the following bind is not null.</p>
                        </li>
                        <li>
                           <p>A scalar type is initially bound as string and then bound as scalar type or the reverse.</p>
                        </li>
                     </ul>
                     <p>The premature batch flush count is summed to the return value of the next <code class="codeph">executeUpdate</code> or <code class="codeph">sendBatch</code> method. 
                     </p>
                     <p>The old functionality lost all these batch flush values which can be obtained now. To switch back to the old functionality, you can set the <code class="codeph">AccumulateBatchResult</code> property to <code class="codeph">false</code>, as follows: 
                     </p><pre class="oac_no_warn" dir="ltr">java.util.Properties info = new java.util.Properties(); 
info.setProperty("user", "HR"); 
info.setProperty("passwd", "hr"); 
// other properties 
... 

// property: batch flush type 
info.setProperty("AccumulateBatchResult", "false");

OracleDataSource ods = new OracleDataSource();
ods.setConnectionProperties(info);
ods.setURL("jdbc:oracle:oci:@"");
Connection conn = ods.getConnection(); 
</pre><div class="infoboxnote" id="GUID-6BAAB99B-8F5D-43A4-9445-4CC90E26F211__GUID-C7B0463E-C89A-42AA-A3EE-CB2E9BF3761E">
                        <p class="notep1">Note:</p>
                        <p>The <code class="codeph">AccumulateBatchResult</code> property is set to <code class="codeph">true</code> by default.
                        </p>
                     </div>
                     <p><a href="performance-extensions.html#GUID-6BAAB99B-8F5D-43A4-9445-4CC90E26F211__CHDIJICJ">Example 21-2</a> illustrates premature batch flushing.
                     </p>
                     <div class="example" id="GUID-6BAAB99B-8F5D-43A4-9445-4CC90E26F211__CHDIJICJ">
                        <p class="titleinexample">Example 21-2 Premature Batch Flushing</p><pre class="oac_no_warn" dir="ltr">((OraclePreparedStatement)pstmt).setExecuteBatch (2); 

pstmt.setNull(1, OracleTypes.NUMBER); 
pstmt.setString(2, "test11"); 
int count = pstmt.executeUpdate(); // returns 0 

/* 
* Premature batch flush happens here. 
*/ 
pstmt.setInt(1, 22);
pstmt.setString(2, "test22"); 
int count = pstmt.executeUpdate(); // returns 0 

pstmt.setInt(1, 33);
pstmt.setString(2, "test33");
/* 
*  returns 3 with the new batching scheme where as, 
*  returns 2 with the old batching scheme. 
*/ 
int count = pstmt.executeUpdate();
</pre></div>
                     <!-- class="example" -->
                  </div>
               </div>
            </div><a id="JJDBC28779"></a><div class="props_rev_3"><a id="GUID-96A38C6D-A288-4E0B-9F03-E711C146632B" name="GUID-96A38C6D-A288-4E0B-9F03-E711C146632B"></a><h3 id="JJDBC-GUID-96A38C6D-A288-4E0B-9F03-E711C146632B" class="sect3"><span class="enumeration_section">21.2 </span>Additional Oracle Performance Extensions
               </h3>
               <div>
                  <div class="section">
                     <p>In addition to update batching, Oracle JDBC drivers support the following extensions that improve performance by reducing round-trips to the database:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a id="d67478e908" class="indexterm-anchor"></a>Prefetching rows
                           </p>
                           <p>This reduces round-trips to the database by fetching multiple rows of data each time data is fetched. The extra data is stored in client-side buffers for later access by the client. The number of rows to prefetch can be set as desired.</p>
                        </li>
                        <li>
                           <p>Specifying <a id="d67478e916" class="indexterm-anchor"></a>column types
                           </p>
                           <p>This avoids an inefficiency in the standard JDBC protocol for performing and returning the results of queries.</p>
                        </li>
                        <li>
                           <p>Suppressing database metadata <code class="codeph">TABLE_REMARKS</code> columns
                           </p>
                           <p>This avoids an expensive outer join operation.</p>
                        </li>
                     </ul>
                     <p>Oracle provides several extensions to connection properties objects to support these performance extensions. These extensions enable you to set the <code class="codeph">remarksReporting</code> flag and default values for row prefetching and update batching.
                     </p>
                     <p>This section covers the following topics:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="performance-extensions.html#GUID-5E60A90D-3924-4228-948D-4A9219201D18">About Prefetching LOB Data</a></p>
                        </li>
                        <li>
                           <p><a href="performance-extensions.html#GUID-8A39C0E0-AC61-4066-9932-30C4581B1D3A">Oracle Row-Prefetching Limitations</a></p>
                        </li>
                        <li>
                           <p><a href="performance-extensions.html#GUID-4E1011BD-7E2A-45D6-BD21-0BF36DC35421">About Defining Column Types</a></p>
                        </li>
                        <li>
                           <p><a href="performance-extensions.html#GUID-15865071-39F2-430F-9EDA-EB34D0B2D560">About Reporting DatabaseMetaData TABLE_REMARKS</a></p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
               </div><a id="JJDBC28780"></a><a id="JJDBC23210"></a><div class="props_rev_3"><a id="GUID-5E60A90D-3924-4228-948D-4A9219201D18" name="GUID-5E60A90D-3924-4228-948D-4A9219201D18"></a><h4 id="JJDBC-GUID-5E60A90D-3924-4228-948D-4A9219201D18" class="sect4"><span class="enumeration_section">21.2.1 </span>About Prefetching LOB Data
                  </h4>
                  <div>
                     <p>For the JDBC drivers prior to Oracle Database 11<span class="italic">g</span> Release 2 JDBC drivers, if you want to retrieve <code class="codeph">LOB</code> data in one round trip, then you have to fetch the data as <code class="codeph">VARCHAR2</code> type, that is, you have to use <code class="codeph">OracleTypes.VARCHAR</code> or <code class="codeph">OracleTypes.LONGVARCHAR</code> with the JDBC <code class="codeph">defineColumnType</code> method. The limitation of this approach is that when <code class="codeph">LOB</code> data is fetched as <code class="codeph">CHAR</code> type, the locator cannot be fetched along with the data. So, if the application wants to get the <code class="codeph">LOB</code> data at a later point of time, or if the application wants to perform other <code class="codeph">LOB</code> operations, then one more round trip is required to get the <code class="codeph">LOB</code> locator, as <code class="codeph">LOB</code> locator is not available to the application.
                     </p>
                     <div class="infoboxnote" id="GUID-5E60A90D-3924-4228-948D-4A9219201D18__GUID-53AA4ADF-D855-4CE9-A14E-709BD57D128B">
                        <p class="notep1">Note:</p>
                        <p>Array operations on <code class="codeph">LOB</code> locators are not supported in the JDBC APIs.
                        </p>
                     </div>
                     <p>Starting from Oracle Database 11<span class="italic">g</span> Release 2 JDBC drivers, the number of round trips is reduced by prefetching frequently used metadata, such as the <code class="codeph">LOB</code> length and the chunk size as well as the beginning of the <code class="codeph">LOB</code> data along with the locator during regular fetch operations. For small <code class="codeph">LOB</code>s, the data may be totally prefetched in one single round trip, that is, the <code class="codeph">select</code> parse, execution, and fetch occurs in one round trip, and performance is improved greatly. For large <code class="codeph">LOB</code>s that are larger than 5 times the prefetch size, the performance improvement is not very significant as only the round trip for retrieving the chunk size is not needed.
                     </p>
                     <div class="section">
                        <p class="subhead3" id="GUID-5E60A90D-3924-4228-948D-4A9219201D18__GUID-9328BD10-BDDF-4E39-8EA9-824C582B3ECF">defaultLobPrefetchSize Connection Property</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>Starting from Oracle Database 11<span class="italic">g</span> Release 2, there is a new connection property <code class="codeph">oracle.jdbc.defaultLobPrefetchSize</code> that can be used to set the default <code class="codeph">LOB</code> prefetch size for the connection. This connection property is defined as the following constant: <code class="codeph">OracleConnection.CONNECTION_PROPERTY_DEFAULT_LOB_PREFETCH_SIZE</code>. The value of this property is used as the default <code class="codeph">LOB</code> prefetch size for the current connection. The default value of this connection property is 4000. If you want to change the default value at the statement level, then use the <code class="codeph">setLobPrefetchSize</code> method defined in <code class="codeph">oracle.jdbc.OracleStatement</code> interface. You can change the default value to:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>-1 to disable <code class="codeph">LOB</code> prefetch for the current connection
                              </p>
                           </li>
                           <li>
                              <p>0 to enable <code class="codeph">LOB</code> prefetch for metadata only
                              </p>
                           </li>
                           <li>
                              <p>Any value greater than 0 to specify the number of bytes for <code class="codeph">BLOB</code>s and the number of characters for <code class="codeph">CLOB</code>s to be prefetched along with the locator during fetch operations
                              </p>
                           </li>
                        </ul>
                        <p>Use <code class="codeph">getLobPrefetchSize</code> method defined in <code class="codeph">oracle.jdbc.OracleStatement</code> interface to retrieve the <code class="codeph">LOB</code> prefetch size.
                        </p>
                        <p>You can also set the value of <code class="codeph">LOB</code> prefetch size at the column level by using the <code class="codeph">defineColumnType</code> method. The column-level value overrides any value that is set at the connection or statement level.
                        </p>
                        <div class="infoboxnote" id="GUID-5E60A90D-3924-4228-948D-4A9219201D18__GUID-D80CD4D2-BC11-4E0E-B1F5-47BAFC11F878">
                           <p class="notep1">Note:</p>
                           <p>If <code class="codeph">LOB</code> prefetch is not disabled at the connection level or statement level, it cannot be disabled at the column level.
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JJDBC28781"></a><div class="props_rev_3"><a id="GUID-8A39C0E0-AC61-4066-9932-30C4581B1D3A" name="GUID-8A39C0E0-AC61-4066-9932-30C4581B1D3A"></a><h4 id="JJDBC-GUID-8A39C0E0-AC61-4066-9932-30C4581B1D3A" class="sect4"><span class="enumeration_section">21.2.2 </span>Oracle Row-Prefetching Limitations
                  </h4>
                  <div>
                     <div class="section">
                        <p>There is no maximum prefetch setting. <a id="d67478e1149" class="indexterm-anchor"></a>The default value is 10. Larger or smaller values may be appropriate depending on the number of rows and columns expected from the query. You can set the default connection row-prefetch value using a <code class="codeph">Properties</code> object.
                        </p>
                        <p>When a statement object is created, it receives the default row-prefetch setting from the associated connection. Subsequent changes to the default connection row-prefetch setting will have no effect on the statement row-prefetch setting.</p>
                        <p>If a column of a result set is of data type <code class="codeph">LONG</code>, <code class="codeph">LONG</code> <code class="codeph">RAW</code> or <code class="codeph">LOB</code>s returned through the data interface, that is, the streaming types, then JDBC changes the statement row-prefetch setting to 1, even if you never actually read a value of either of these types.
                        </p>
                        <p>Setting the prefetch size can affect the performance of an application. Increasing the prefetch size will reduce the number of round-trips required to get all the data, but will increase memory usage. This will depend on the number and size of the columns in the query and the number of rows expected to be returned. It will also depend on the memory and CPU loading of the JDBC client machine. The optimum for a standalone client application will be different from a heavily loaded application server. The speed and latency of the network connection should also be considered.</p>
                        <div class="infoboxnote" id="GUID-8A39C0E0-AC61-4066-9932-30C4581B1D3A__GUID-E6B031D3-8840-4C0D-833B-68B42A9C7F44">
                           <p class="notep1">Note:</p>
                           <p>Starting from Oracle Database 11<span class="italic">g</span> Release 1, the Thin driver can fetch the first <code class="codeph">prefetch_size</code> number of rows from the server in the very first round-trip. This saves one round-trip in SELECT statements.
                           </p>
                        </div>
                        <p>If you are migrating an application from earlier releases of Oracle JDBC drivers to 10<span class="italic">g</span> Release 1 (10.1) or later releases of Oracle JDBC drivers, then you should revisit the optimizations that you had done earlier, because the memory usage and performance characteristics may have changed substantially.
                        </p>
                        <p>A common situation that you may encounter is, say, you have a query that selects a unique key. The query will return only zero or one row. Setting the prefetch size to 1 will decrease memory and CPU usage and cannot increase round-trips. However, you must be careful to avoid the error of requesting an extra fetch by writing <code class="codeph">while(rs.next())</code> instead of <code class="codeph">if(rs.next())</code>.
                        </p>
                        <p>If you are using the JDBC Thin driver, then use the <code class="codeph">useFetchSizeWithLongColumn</code> connection property, because it will perform <code class="codeph">PARSE</code>, <code class="codeph">EXECUTE</code>, and <code class="codeph">FETCH</code> in a single round-trip.
                        </p>
                        <p>Tuning of the prefetch size should be done along with tuning of memory management in your JVM under realistic loads of the actual application.</p>
                        <div class="infoboxnote" id="GUID-8A39C0E0-AC61-4066-9932-30C4581B1D3A__GUID-597CB868-DC87-46B5-B746-D57969973796">
                           <p class="notep1">Note:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>Do not mix the JDBC 2.0 fetch size application programming interface (API) and the Oracle row-prefetching API in your application. You can use one or the other, but not both.</p>
                              </li>
                              <li>
                                 <p>Be aware that setting the Oracle fetch size value can affect not only queries, but also explicitly refetching rows in a result set through the result set <code class="codeph">refreshRow</code> method, which is relevant for scroll-sensitive/read-only, scroll-sensitive/updatable, and scroll-insensitive/updatable result sets, and the window size of a scroll-sensitive result set, affecting how often automatic refetches are performed. However, the Oracle fetch size value will be overridden by any setting of the fetch size.
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JJDBC28783"></a><a id="JJDBC28784"></a><a id="JJDBC28782"></a><div class="props_rev_3"><a id="GUID-4E1011BD-7E2A-45D6-BD21-0BF36DC35421" name="GUID-4E1011BD-7E2A-45D6-BD21-0BF36DC35421"></a><h4 id="JJDBC-GUID-4E1011BD-7E2A-45D6-BD21-0BF36DC35421" class="sect4"><span class="enumeration_section">21.2.3 </span>About Defining Column Types
                  </h4>
                  <div>
                     <div class="section">
                        <div class="infoboxnote" id="GUID-4E1011BD-7E2A-45D6-BD21-0BF36DC35421__GUID-CEA3A0C3-A05B-4348-B4CA-D91BDD0A62A8">
                           <p class="notep1">Note:</p>
                           <p>Starting from Oracle Database 12<span class="italic">c </span>Release 1 (12.1), the <code class="codeph">defineColumnType</code> method is deprecated.
                           </p>
                        </div>
                        <p>The implementation of <code class="codeph">defineColumnType</code> changed significantly since Oracle Database 10<span class="italic">g</span>. Previously, <code class="codeph">defineColumnType</code> was used both as a performance optimization and to force data type conversion. In previous releases, all of the drivers benefited from calls to <code class="codeph">defineColumnType</code>. Starting from Oracle Database 10<span class="italic">g</span>, the JDBC Thin driver no longer needs the information provided. The JDBC Thin driver achieves maximum performance without calls to <code class="codeph">defineColumnType</code>. The JDBC Oracle Call Interface (OCI) and server-side internal drivers still get better performance when the application uses <code class="codeph">defineColumnType</code>.
                        </p>
                        <p>If your code is used with both the JDBC Thin and OCI drivers, you can disable the <code class="codeph">defineColumnType</code> method when using the Thin driver by setting the connection property <code class="codeph">disableDefineColumnType</code> to <code class="codeph">true</code>. Doing this makes <code class="codeph">defineColumnType</code> have no effect. Do not set this connection property to <code class="codeph">true</code> when using the JDBC OCI or server-side internal drivers.
                        </p>
                        <p>You can also use <code class="codeph">defineColumnType</code> to control how much memory the client-side allocates or to limit the size of variable-length data.
                        </p>
                        <p><a id="d67478e1306" class="indexterm-anchor"></a><a id="d67478e1310" class="indexterm-anchor"></a>Follow these general steps to define column types for a query:
                        </p>
                        <ol>
                           <li>
                              <p>If necessary, cast your statement object to <code class="codeph">OracleStatement</code>, <code class="codeph">OraclePreparedStatement</code>, or <code class="codeph">OracleCallableStatement</code>, as applicable.
                              </p>
                           </li>
                           <li>
                              <p>If necessary, use the <code class="codeph">clearDefines</code> method of your <code class="codeph">Statement</code> object to clear any previous column definitions for this <code class="codeph">Statement</code> object.
                              </p>
                           </li>
                           <li>
                              <p>On each column, call the <code class="codeph">defineColumnType</code> method of your <code class="codeph">Statement</code> object, passing it these parameters:
                              </p>
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p>Column index (integer)</p>
                                 </li>
                                 <li>
                                    <p>Type code (integer)</p>
                                    <p>Use the <code class="codeph">static</code> constants of the <code class="codeph">java.sql.Types</code> class or <code class="codeph">oracle.jdbc.OracleTypes</code> class, such as <code class="codeph">Types.INTEGER</code>, <code class="codeph">Types.FLOAT</code>, <code class="codeph">Types.VARCHAR</code>, <code class="codeph">OracleTypes.VARCHAR</code>, and <code class="codeph">OracleTypes.ROWID</code>. Type codes for standard types are identical in these two classes.
                                    </p>
                                 </li>
                                 <li>
                                    <p>Type name (string) </p>
                                    <p>For structured objects, object references, and arrays, you must also specify the type name. For example, <code class="codeph">Employee</code>, <code class="codeph">EmployeeRef</code>, or <code class="codeph">EmployeeArray</code>.
                                    </p>
                                 </li>
                                 <li>
                                    <p>Maximum field size (integer)</p>
                                    <p>Optionally specify a maximum data length for this column.</p>
                                    <p>You cannot specify a maximum field size parameter if you are defining the column type for a structured object, object reference, or array. If you try to include this parameter, it will be ignored.</p>
                                 </li>
                                 <li>
                                    <p>Form of use (short)</p>
                                    <p>Optionally specify a form of use for the column. This can be <code class="codeph">OraclePreparedStatement.FORM_CHAR</code> to use the database character set or <code class="codeph">OraclePreparedStatement.FORM_NCHAR</code> to use the national character set. If this parameter is omitted, the default is <code class="codeph">FORM_CHAR</code>.
                                    </p>
                                 </li>
                              </ul>
                              <p>For example, assuming <code class="codeph">stmt</code> is an Oracle statement, use:
                              </p><pre class="oac_no_warn" dir="ltr">stmt.defineColumnType(<span class="italic">column_index</span>, <span class="italic">typeCode</span>);
</pre><p>If the column is <code class="codeph">VARCHAR</code> or equivalent and you know the length limit:
                              </p><pre class="oac_no_warn" dir="ltr">stmt.defineColumnType(<span class="italic">column_index</span>, <span class="italic">typeCode</span>, <span class="italic">max_size</span>);
</pre><p>For an <code class="codeph">NVARCHAR</code> column where the original maximum length is desired and conversion to the database character set is requested:
                              </p><pre class="oac_no_warn" dir="ltr">stmt.defineColumnType(<span class="italic">column_index</span>, <span class="italic">typeCode</span>, 0,
   OraclePreparedStatement.FORM_CHAR );
</pre><p>For structured object, object reference, and array columns:</p><pre class="oac_no_warn" dir="ltr">stmt.defineColumnType(<span class="italic">column_index</span>, <span class="italic">typeCode</span>, <span class="italic">typeName</span>);
</pre><p>Set a maximum field size if you do not want to receive the full default length of the data. Calling the <code class="codeph">setMaxFieldSize</code> method of the standard JDBC <code class="codeph">Statement</code> class sets a restriction on the amount of data returned. Specifically, the size of the data returned will be the minimum of the following: 
                              </p>
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p>The maximum field size set in <code class="codeph">defineColumnType</code></p>
                                 </li>
                                 <li>
                                    <p>The maximum field size set in <code class="codeph">setMaxFieldSize</code></p>
                                 </li>
                                 <li>
                                    <p>The natural maximum size of the data type</p>
                                 </li>
                              </ul>
                           </li>
                        </ol>
                        <p>After you complete these steps, use the <code class="codeph">executeQuery</code> method of the statement to perform the query.
                        </p>
                        <div class="infoboxnote" id="GUID-4E1011BD-7E2A-45D6-BD21-0BF36DC35421__GUID-8F484BA8-81A1-485E-8C4F-0DEDCC321726">
                           <p class="notep1">Note:</p>
                           <p>It is no longer necessary to specify a data type for each column of the expected result set.</p>
                        </div>
                        <p>The following example illustrates the use of this feature. It assumes you have imported the <code class="codeph">oracle.jdbc.*</code> interfaces.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-4E1011BD-7E2A-45D6-BD21-0BF36DC35421__CHDJDDEA">
                        <p class="titleinexample">Example 21-3 Defining Column Types</p><pre class="oac_no_warn" dir="ltr">OracleDataSource ods = new OracleDataSource();
ods.setURL("jdbc:oracle:thin:@localhost:5221:orcl");
ods.setUser("HR");
ods.setPassword("hr");
Connection conn = ods.getConnection();

Statement stmt = conn.createStatement();
// Allocate only 2 chars for this column (truncation will happen)
((OracleStatement)stmt).defineColumnType(1, Types.VARCHAR, 2);
ResultSet rset = stmt.executeQuery("select ename from emp");
while(rset.next() )
  System.out.println(rset.getString(1));
stmt.close();
</pre></div>
                     <!-- class="example" -->
                     <div class="section">
                        <p>As this example shows, you must cast the <code class="codeph">Statement</code> object, <code class="codeph">stmt</code>, to <code class="codeph">OracleStatement</code> in the invocation of the <code class="codeph">defineColumnType</code> method. The <code class="codeph">createStatement</code> method of the connection returns an object of type <code class="codeph">java.sql.Statement</code>, which does not have the <code class="codeph">defineColumnType</code> and <code class="codeph">clearDefines</code> methods. These methods are provided only in the <code class="codeph">OracleStatement</code> implementation.
                        </p>
                        <p>The define-extensions use JDBC types to specify the desired types. The allowed define types for columns depend on the internal Oracle type of the column.</p>
                        <p>All columns can be defined to their natural JDBC types. In most cases, they can be defined to the <code class="codeph">Types.CHAR</code> or <code class="codeph">Types.VARCHAR</code> type code.
                        </p>
                        <p>The following table lists the valid column definition arguments that you can use in the <code class="codeph">defineColumnType</code> method.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="tblformal" id="GUID-4E1011BD-7E2A-45D6-BD21-0BF36DC35421__G1060844">
                        <p class="titleintable">Table 21-1 Valid Column Type Specifications </p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="Valid Column Type Specifications " summary="table" width="100%" frame="hsides" border="1" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="34%" id="d67478e1570">If the column has Oracle  SQL type:</th>
                                 <th align="left" valign="bottom" width="66%" id="d67478e1575">You can use defineColumnType  to define it as:</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="34%" id="d67478e1582" headers="d67478e1570 ">
                                    <p><code class="codeph">NUMBER</code>, <code class="codeph">VARNUM</code></p>
                                 </td>
                                 <td align="left" valign="top" width="66%" headers="d67478e1582 d67478e1575 ">
                                    <p><code class="codeph">BIGINT</code>, <code class="codeph">TINYINT</code>, <code class="codeph">SMALLINT</code>, <code class="codeph">INTEGER</code>, <code class="codeph">FLOAT</code>, <code class="codeph">REAL</code>, <code class="codeph">DOUBLE</code>, <code class="codeph">NUMERIC</code>, <code class="codeph">DECIMAL</code>, <code class="codeph">CHAR</code>, <code class="codeph">VARCHAR</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="34%" id="d67478e1625" headers="d67478e1570 ">
                                    <p><code class="codeph">CHAR</code>, <code class="codeph">VARCHAR2</code></p>
                                 </td>
                                 <td align="left" valign="top" width="66%" headers="d67478e1625 d67478e1575 ">
                                    <p><code class="codeph">CHAR</code>, <code class="codeph">VARCHAR</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="34%" id="d67478e1640" headers="d67478e1570 ">
                                    <p><code class="codeph">LONG</code></p>
                                 </td>
                                 <td align="left" valign="top" width="66%" headers="d67478e1640 d67478e1575 ">
                                    <p><code class="codeph">CHAR</code>, <code class="codeph">VARCHAR</code>, <code class="codeph">LONGVARCHAR</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="34%" id="d67478e1655" headers="d67478e1570 ">
                                    <p><code class="codeph">LONGRAW</code></p>
                                 </td>
                                 <td align="left" valign="top" width="66%" headers="d67478e1655 d67478e1575 ">
                                    <p><code class="codeph">LONGVARBINARY</code>, <code class="codeph">VARBINARY</code>, <code class="codeph">BINARY</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="34%" id="d67478e1670" headers="d67478e1570 ">
                                    <p><code class="codeph">RAW</code></p>
                                 </td>
                                 <td align="left" valign="top" width="66%" headers="d67478e1670 d67478e1575 ">
                                    <p><code class="codeph">VARBINARY</code>, <code class="codeph">BINARY</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="34%" id="d67478e1682" headers="d67478e1570 ">
                                    <p><code class="codeph">DATE</code></p>
                                 </td>
                                 <td align="left" valign="top" width="66%" headers="d67478e1682 d67478e1575 ">
                                    <p><code class="codeph">DATE</code>, <code class="codeph">TIME</code>, <code class="codeph">TIMESTAMP</code>, <code class="codeph">CHAR</code>, <code class="codeph">VARCHAR</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="34%" id="d67478e1703" headers="d67478e1570 ">
                                    <p><code class="codeph">ROWID</code></p>
                                 </td>
                                 <td align="left" valign="top" width="66%" headers="d67478e1703 d67478e1575 ">
                                    <p><code class="codeph">ROWID</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="34%" id="d67478e1712" headers="d67478e1570 ">
                                    <p><code class="codeph">BLOB</code></p>
                                 </td>
                                 <td align="left" valign="top" width="66%" headers="d67478e1712 d67478e1575 ">
                                    <p><code class="codeph">VARBINARY</code>, <code class="codeph">BINARY</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="34%" id="d67478e1724" headers="d67478e1570 ">
                                    <p><code class="codeph">CLOB</code></p>
                                 </td>
                                 <td align="left" valign="top" width="66%" headers="d67478e1724 d67478e1575 ">
                                    <p><code class="codeph">LONG</code>, <code class="codeph">CHAR</code>, <code class="codeph">VARCHAR</code></p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <div class="section">
                        <p>It is always valid to use <code class="codeph">defineColumnType</code> with the original data type of the column.
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JJDBC28787"></a><a id="JJDBC28788"></a><a id="JJDBC28786"></a><a id="JJDBC28785"></a><div class="props_rev_3"><a id="GUID-15865071-39F2-430F-9EDA-EB34D0B2D560" name="GUID-15865071-39F2-430F-9EDA-EB34D0B2D560"></a><h4 id="JJDBC-GUID-15865071-39F2-430F-9EDA-EB34D0B2D560" class="sect4"><span class="enumeration_section">21.2.4 </span>About Reporting DatabaseMetaData TABLE_REMARKS
                  </h4>
                  <div>
                     <p>The <code class="codeph">getColumns</code>, <code class="codeph">getProcedureColumns</code>, <code class="codeph">getProcedures</code>, and <code class="codeph">getTables</code> methods of the database metadata classes are slow if they must report <code class="codeph">TABLE_REMARKS</code> columns, because this necessitates an expensive outer join. For this reason, the JDBC driver does <span class="italic">not</span> report <code class="codeph">TABLE_REMARKS</code> columns by default.
                     </p>
                     <p>You can enable <code class="codeph">TABLE_REMARKS</code> reporting by passing a <code class="codeph">true</code> argument to the <code class="codeph">setRemarksReporting</code> method of an <code class="codeph">OracleConnection</code> object. 
                     </p>
                     <p>Equivalently, instead of calling <code class="codeph">setRemarksReporting</code>, you can set the <code class="codeph">remarksReporting</code> Java property if you use a Java <code class="codeph">Properties</code> object in establishing the connection.
                     </p>
                     <p>If you are using a standard <code class="codeph">java.sql.Connection</code> object, you must cast it to <code class="codeph">OracleConnection</code> to use <code class="codeph">setRemarksReporting</code>.
                     </p>
                     <p>The following code snippet illustrates how to enable <code class="codeph">TABLE_REMARKS</code> reporting:
                     </p><pre class="oac_no_warn" dir="ltr">((oracle.jdbc.OracleConnection)conn ).setRemarksReporting(true);
</pre><p>Here, <code class="codeph">conn</code> is the name of your standard <code class="codeph">Connection</code> object, the following statement enables <code class="codeph">TABLE_REMARKS</code> reporting:
                     </p>
                     <div class="section">
                        <p class="subhead3" id="GUID-15865071-39F2-430F-9EDA-EB34D0B2D560__GUID-96D4A629-8ECA-4D9A-AF13-93D796323E3A">Considerations for getColumns</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>By default, the <code class="codeph">getColumns</code> method does not retrieve information about the columns if a synonym is specified. To enable the retrieval of information if a synonym is specified, you must call the <code class="codeph">setIncludeSynonyms</code> method on the connection as follows:
                        </p><pre class="oac_no_warn" dir="ltr">((oracle.jdbc.OracleConnection)conn ).setIncludeSynonyms(true)
</pre><p>This will cause all subsequent <code class="codeph">getColumns</code> method calls on the connection to include synonyms. This is similar to <code class="codeph">setRemarksReporting</code>. Alternatively, you can set the <code class="codeph">includeSynonyms</code> connection property. This is similar to the <code class="codeph">remarksReporting</code> connection property.
                        </p>
                        <p>However, bear in mind that if <code class="codeph">includeSynonyms</code> is <code class="codeph">true</code>, then the name of the object returned in the <code class="codeph">table_name</code> column will be the synonym name, if a synonym exists. This is true even if you pass the table name to <code class="codeph">getColumns</code>.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-15865071-39F2-430F-9EDA-EB34D0B2D560__GUID-2D1B3889-695F-4CEE-AD18-C7691C332AAA">Considerations for getProcedures and getProcedureColumns Methods</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>According to JDBC versions 1.1 and 1.2, the methods <code class="codeph">getProcedures</code> and <code class="codeph">getProcedureColumns</code> treat the <code class="codeph">catalog</code>, <code class="codeph">schemaPattern</code>, <code class="codeph">columnNamePattern</code>, and <code class="codeph">procedureNamePattern</code> parameters in the same way. In the Oracle definition of these methods, the parameters are treated differently:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><code class="codeph">catalog</code></p>
                              <p>Oracle does not have multiple catalogs, but it does have packages. Consequently, the <code class="codeph">catalog</code> parameter is treated as the package name. This applies both on input, which is the <code class="codeph">catalog</code> parameter, and the output, which is the <code class="codeph">catalog</code> column in the returned <code class="codeph">ResultSet</code>. On input, the construct <code class="codeph">"</code> <code class="codeph">"</code>, which is an empty string, retrieves procedures and arguments without a package, that is, standalone objects. A <code class="codeph">null</code> value means to drop from the selection criteria, that is, return information about both standalone and packaged objects. That is, it has the same effect as passing in the percent sign (<code class="codeph">%</code>). Otherwise, the <code class="codeph">catalog</code> parameter should be a package name pattern, with SQL wild cards, if desired.
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">schemaPattern</code></p>
                              <p>All objects within Oracle database must have a schema, so it does not make sense to return information for those objects without one. Thus, the construct <code class="codeph">"</code> <code class="codeph">"</code>, which is an empty string, is interpreted on input to mean the objects in the current schema, that is, the one to which you are currently connected. To be consistent with the behavior of the <code class="codeph">catalog</code> parameter, <code class="codeph">null</code> is interpreted to drop the schema from the selection criteria. That is, it has the same effect as passing in <code class="codeph">%</code>. It can also be used as a pattern with SQL wild cards.
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">procedureNamePattern</code> and <code class="codeph">columnNamePattern</code></p>
                              <p>The empty string (" ") does not make sense for either parameter, because all procedures and arguments must have names. Thus, the construct <code class="codeph">"</code> <code class="codeph">"</code> will raise an exception. To be consistent with the behavior of other parameters, <code class="codeph">null</code> has the same effect as passing in percent sign (<code class="codeph">%</code>). 
                              </p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>