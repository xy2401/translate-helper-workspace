<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <title>性能扩展</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="JDBC Developer&#39;s Guide"></meta>
      <meta property="og:description" content=""></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="JDBC Developer&#39;s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="jdbc-developers-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-02-13T13:20:37-08:00"></meta>
      <meta name="dcterms.title" content="JDBC Developer&#39;s Guide"></meta>
      <meta name="dcterms.dateCopyrighted" content="1999, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96471-02"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="statement-and-resultset-caching.html" title="Previous" type="text/html"></link>
      <link rel="next" href="high-speed-ingestion-of-data-streams.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.isVersionOf" content="JJDBC"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="statement-and-resultset-caching.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="high-speed-ingestion-of-data-streams.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">JDBC开发人员指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="performance-and-scalability.html" property="item" typeof="WebPage"><span property="name">性能和可伸缩性</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">性能扩展</li>
            </ol>
            <a id="GUID-FEECA64F-44F4-453F-B8A8-AFBF6D29ABA4" name="GUID-FEECA64F-44F4-453F-B8A8-AFBF6D29ABA4"></a><a id="JJDBC28752"></a>
            
            <h2 id="JJDBC-GUID-FEECA64F-44F4-453F-B8A8-AFBF6D29ABA4" class="sect2"><span class="enumeration_chapter">21</span>性能扩展</h2>
         </header>
         <div class="ind">
            <div>
               <p><a id="d67478e21" class="indexterm-anchor"></a><a id="d67478e25" class="indexterm-anchor"></a>本章介绍Java数据库连接（JDBC）标准的Oracle性能扩展。
               </p>
               <p>本章包含以下主题：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="performance-extensions.html#GUID-8B920135-D97D-4F33-8FF5-5774E802C520">更新批处理</a></p>
                  </li>
                  <li>
                     <p><a href="performance-extensions.html#GUID-96A38C6D-A288-4E0B-9F03-E711C146632B">其他Oracle Performance Extensions</a></p>
                  </li>
               </ul>
               <div class="infoboxnote" id="GUID-FEECA64F-44F4-453F-B8A8-AFBF6D29ABA4__GUID-8841910F-7FE9-44A6-89DE-F42183CFD28C">
                  <p class="notep1">注意：</p>
                  <p>Oracle Database 12 <span class="italic">c</span>第1版（12.1）中不推荐使用Oracle更新批处理。从Oracle Database 12 <span class="italic">c</span>第2版（12.2）开始，Oracle更新批处理是一个无操作代码（no-op）。这意味着，如果使用Oracle Database <span class="italic">12c</span>第2版（12.2）JDBC驱动程序在应用程序中实施Oracle更新批处理，则不会设置指定的批处理大小，并导致批处理大小为1。使用此批处理设置，您的应用程序一次处理一行。如果您使用的是Oracle Database 12 <span class="italic">c</span>第2版（12.2）JDBC驱动程序，Oracle强烈建议您使用标准JDBC批处理。
                  </p>
               </div>
            </div><a id="JJDBC28753"></a><div class="props_rev_3"><a id="GUID-8B920135-D97D-4F33-8FF5-5774E802C520" name="GUID-8B920135-D97D-4F33-8FF5-5774E802C520"></a><h3 id="JJDBC-GUID-8B920135-D97D-4F33-8FF5-5774E802C520" class="sect3"><span class="enumeration_section">21.1</span>更新批处理</h3>
               <div>
                  <p>本节包括以下主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="performance-extensions.html#GUID-0DED2C61-397C-48D3-AE68-A085D2E29E1A">更新批处理概述</a></p>
                     </li>
                     <li>
                        <p><a href="performance-extensions.html#GUID-24D35E13-A9C0-43F3-8F8B-870AD1BF5339">标准更新批处理</a></p>
                     </li>
                     <li>
                        <p><a href="performance-extensions.html#GUID-6BAAB99B-8F5D-43A4-9445-4CC90E26F211">过早批量冲洗</a></p>
                     </li>
                  </ul>
               </div>
               <div class="props_rev_3"><a id="GUID-0DED2C61-397C-48D3-AE68-A085D2E29E1A" name="GUID-0DED2C61-397C-48D3-AE68-A085D2E29E1A"></a><h4 id="JJDBC-GUID-0DED2C61-397C-48D3-AE68-A085D2E29E1A" class="sect4"><span class="enumeration_section">21.1.1</span>更新批处理概述</h4>
                  <div>
                     <p>通过将多个<code class="codeph">UPDATE</code> ， <code class="codeph">DELETE</code>或<code class="codeph">INSERT</code>语句分组到一个批处理中，并将整个批处理发送到数据库并在一次行程中处理，您可以减少到数据库的往返次数，从而提高应用程序性能。这被称为“更新批处理”。当您使用不同的绑定变量重复相同的语句时，这对预准备语句特别有用。
                     </p>
                     <div class="infoboxnote" id="GUID-0DED2C61-397C-48D3-AE68-A085D2E29E1A__GUID-20F2AAD9-E0E0-46A4-AE4F-782FB4425A5C">
                        <p class="notep1">注意：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>JDBC 2.0规范将“更新批处理”称为“批量更新”。</p>
                           </li>
                           <li>
                              <p>为了遵守JDBC 2.0标准，标准更新批处理的Oracle实现支持不带<code class="codeph">OUT</code>参数，泛型语句和预准备语句的可调用语句。您可以毫不费力地将标准更新批处理迁移到Oracle JDBC应用程序中。但是，标准更新批处理的Oracle实现不会为通用语句和可调用语句实现真正的批处理，您将看到仅对<code class="codeph">PreparedStatement</code>对象的性能改进。
                              </p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="JJDBC28767"></a><div class="props_rev_3"><a id="GUID-24D35E13-A9C0-43F3-8F8B-870AD1BF5339" name="GUID-24D35E13-A9C0-43F3-8F8B-870AD1BF5339"></a><h4 id="JJDBC-GUID-24D35E13-A9C0-43F3-8F8B-870AD1BF5339" class="sect4"><span class="enumeration_section">21.1.2</span>标准更新批处理</h4>
                  <div>
                     <p>JDBC标准更新批处理依赖于使用<code class="codeph">addBatch</code>方法向批处理显式添加语句，并使用<code class="codeph">executeBatch</code>方法显式处理批处理。
                     </p>
                     <div class="infoboxnote" id="GUID-24D35E13-A9C0-43F3-8F8B-870AD1BF5339__GUID-DDF20CF5-42D0-43C1-AAA5-F332B2270550">
                        <p class="notep1">注意：</p>
                        <p>使用更新批处理时禁用自动提交模式。如果在处理批处理时发生错误，则可以选择提交或回滚在错误之前成功运行的操作。</p>
                     </div>
                  </div><a id="JJDBC28768"></a><div class="props_rev_3"><a id="GUID-0D1B2185-4395-416A-9D64-0221ED02D166" name="GUID-0D1B2185-4395-416A-9D64-0221ED02D166"></a><h5 id="JJDBC-GUID-0D1B2185-4395-416A-9D64-0221ED02D166" class="sect5"><span class="enumeration_section">21.1.2.1</span> Oracle标准批处理实现的局限性</h5>
                     <div>
                        <div class="section">
                           <p>本节讨论有关Oracle标准更新批处理实现的限制和实现细节。</p>
                           <p>在Oracle JDBC应用程序中，更新批处理旨在与使用不同绑定值集重复处理的预准备语句一起使用。</p>
                           <p>标准更新批处理的Oracle实现不会为通用语句和可调用语句实现真正的批处理。尽管Oracle JDBC支持对<code class="codeph">Statement</code>和<code class="codeph">CallableStatement</code>对象使用标准批处理，但您不太可能看到性能提升。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="JJDBC28769"></a><div class="props_rev_3"><a id="GUID-8848824F-F505-4EAE-A2F6-DEDB1945E45F" name="GUID-8848824F-F505-4EAE-A2F6-DEDB1945E45F"></a><h5 id="JJDBC-GUID-8848824F-F505-4EAE-A2F6-DEDB1945E45F" class="sect5"><span class="enumeration_section">21.1.2.2</span>关于向批处理添加操作</h5>
                     <div>
                        <p>首次创建任何语句对象时，其语句批处理为空。使用标准的<code class="codeph">addBatch</code>方法将操作添加到语句批处理中。此方法在标准<code class="codeph">java.sql.指定<code class="codeph">java.sql.Statement</code> ， <code class="codeph">PreparedStatement</code>和<code class="codeph">CallableStatement</code>接口，由<code class="codeph">oracle.jdbc.实现<code class="codeph">oracle.jdbc.OracleStatement</code> ， <code class="codeph">OraclePreparedStatement</code>和<code class="codeph">OracleCallableStatement</code>接口，分别。
                        </p>
                        <p>对于<code class="codeph">Statement</code>对象， <code class="codeph">addBatch</code>方法将带有SQL操作的Java <code class="codeph">String</code>作为输入。例如：</p><pre class="oac_no_warn" dir="ltr">...语句stmt = conn.createStatement（）; stmt.addBatch（“INSERT INTO emp VALUES（1000，'Joe Jones'）”）; stmt.addBatch（“INSERT INTO dept VALUES（260，'Sales'）”）; stmt.addBatch（“INSERT INTO emp_dept VALUES（1000,260）”）; ...
</pre><p>此时，批处理中有三个操作。</p>
                        <p>对于预准备语句，更新批处理用于批处理具有不同绑定参数集的同一语句的多次运行。对于<code class="codeph">PreparedStatement</code>或<code class="codeph">OraclePreparedStatement</code>对象， <code class="codeph">addBatch</code>方法不接受任何输入。它只是使用最后由相应的<code class="codeph">set</code> <span class="italic"><code class="codeph">XXX</code></span>方法设置的绑定参数将操作添加到批处理中。对于<code class="codeph">CallableStatement</code>或<code class="codeph">OracleCallableStatement</code>对象也是如此，但请记住，在标准更新批处理的Oracle实现中，您可能会看到在批处理可调用语句时没有性能改进。
                        </p>
                        <p>例如：</p><pre class="oac_no_warn" dir="ltr">...PreparedStatement pstmt = conn.prepareStatement（“INSERT INTO employees VALUES（？，？）“）; pstmt.setInt（1,2000）; pstmt.setString（2，”Milo Mumford“）; pstmt.addBatch（）; pstmt.setInt（1,3000）; pstmt.setString（2，”Sulu Simpson“） ; pstmt.addBatch（）; ...
</pre><p>此时，批处理中有两个操作。</p>
                        <p>由于批处理与单个预准备语句对象关联，因此您只能批量运行单个预准备语句，如本例所示。</p>
                     </div>
                  </div><a id="JJDBC28770"></a><div class="props_rev_3"><a id="GUID-EB4B2280-70DF-4433-8B4A-59DD3108DB41" name="GUID-EB4B2280-70DF-4433-8B4A-59DD3108DB41"></a><h5 id="JJDBC-GUID-EB4B2280-70DF-4433-8B4A-59DD3108DB41" class="sect5"><span class="enumeration_section">21.1.2.3</span>关于处理批处理</h5>
                     <div>
                        <p>要处理当前批处理操作，请使用语句对象的<code class="codeph">executeBatch</code>方法。此方法在标准<code class="codeph">Statement</code>接口中指定，该接口由标准<code class="codeph">PreparedStatement</code>和<code class="codeph">CallableStatement</code>接口扩展。
                        </p>
                        <div class="infoboxnote" id="GUID-EB4B2280-70DF-4433-8B4A-59DD3108DB41__GUID-82911FAB-1BF5-47BE-90ED-5B1C2A9FD334">
                           <p class="notep1">注意：</p>
                           <p>如果通过多次调用<code class="codeph">addBatch</code>方法向批处理添加太多操作并创建一个非常大的批处理（例如，大于或等于100,000行），那么在整个批处理中调用<code class="codeph">executeBatch</code>方法时，您可能会遇到内存方面的严重性能问题。为避免此问题，JDBC驱动程序透明地将大批量分解为较小的内部批处理，并为每个内部批处理向服务器进行往返。这会使您的应用程序因每次往返开销而稍微变慢，但会显着优化内存。但是，如果每个绑定行的大小非常大（例如，每个大约超过1MB），那么此过程会对整体性能产生负面影响，因为在这种情况下，在内存方面获得的性能将低于表现在时间上的损失。
                           </p>
                        </div>
                        <p>以下示例重复先前显示的<code class="codeph">addBatch</code>准备语句<code class="codeph">addBatch</code>调用，然后处理批处理：</p><pre class="oac_no_warn" dir="ltr">...PreparedStatement pstmt = conn.prepareStatement（“INSERT INTO employees VALUES（？，？）“）; pstmt.setInt（1,2000）; pstmt.setString（2，”Milo Mumford“）; pstmt.addBatch（）; pstmt.setInt（1,3000）; pstmt.setString（2，”Sulu Simpson“） ; pstmt.addBatch（）; int [] updateCounts = pstmt.executeBatch（）; ...
</pre></div>
                  </div><a id="JJDBC29182"></a><div class="props_rev_3"><a id="GUID-20BF8463-A574-48CB-AD56-18CF8DEF603D" name="GUID-20BF8463-A574-48CB-AD56-18CF8DEF603D"></a><h5 id="JJDBC-GUID-20BF8463-A574-48CB-AD56-18CF8DEF603D" class="sect5"><span class="enumeration_section">21.1.2.4</span>数组DML的每次迭代行数</h5>
                     <div>
                        <div class="section">
                           <p>从Oracle Database 12 <span class="italic">c</span>第1版（12.1）开始， <code class="codeph">executeBatch</code>方法已得到改进，因此它返回的int数组大小与批处理中的记录数相同，并且返回数组中的每个项都是数据库表行受批处理的相应记录影响。例如，如果批处理大小为5，则<code class="codeph">executeBatch</code>方法返回大小为5的数组。如果批处理执行之间出错，则<code class="codeph">executeBatch</code>方法不能返回值，而是抛出<code class="codeph">BatchUpdateException</code> 。在这种情况下，异常本身携带一个大小为<code class="codeph">n</code>的int数组作为其数据，其中<code class="codeph">n</code>是成功记录执行的次数。例如，如果批处理的大小为5且错误发生在第4条记录中，则<code class="codeph">BatchUpdateException</code>具有大小为3的数组（成功执行3条记录），并且数组中的每个项目表示每个项目受影响的行数。 。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="JJDBC28771"></a><div class="props_rev_3"><a id="GUID-B3FC184E-8F92-4B33-8213-29CA69ABF86C" name="GUID-B3FC184E-8F92-4B33-8213-29CA69ABF86C"></a><h5 id="JJDBC-GUID-B3FC184E-8F92-4B33-8213-29CA69ABF86C" class="sect5"><span class="enumeration_section">21.1.2.5</span>关于提交Oracle标准批处理实现的更改</h5>
                     <div>
                        <p>处理批处理后，您仍必须提交更改，假设已按建议禁用自动提交。</p>
                        <p>调用<code class="codeph">commit</code> ，提交nonbatched操作和已处理的语句批处理批处理操作，但对于Oracle实施标准配料，对未决还<span class="italic">没有</span>被处理语句批处理没有影响。
                        </p>
                     </div>
                  </div><a id="JJDBC28772"></a><div class="props_rev_3"><a id="GUID-61B19DD7-9681-4C02-B7CF-48B115F41F1B" name="GUID-61B19DD7-9681-4C02-B7CF-48B115F41F1B"></a><h5 id="JJDBC-GUID-61B19DD7-9681-4C02-B7CF-48B115F41F1B" class="sect5"><span class="enumeration_section">21.1.2.6</span>关于清除批次</h5>
                     <div>
                        <p>要清除当前批处理操作而不是处理它，请使用语句对象的<code class="codeph">clearBatch</code>方法。此方法在标准<code class="codeph">Statement</code>接口中指定，该接口由标准<code class="codeph">PreparedStatement</code>和<code class="codeph">CallableStatement</code>接口扩展。
                        </p>
                        <p>请记住以下事项：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>处理批处理时，将按批处理顺序执行操作。</p>
                           </li>
                           <li>
                              <p>调用<code class="codeph">addBatch</code> ，必须在调用<code class="codeph">executeUpdate</code>之前调用<code class="codeph">executeBatch</code>或<code class="codeph">clearBatch</code> ，否则会出现SQL异常。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">clearBatch</code>或<code class="codeph">executeBatch</code>调用将语句批处理重置为空。
                              </p>
                           </li>
                           <li>
                              <p>如果连接收到<code class="codeph">ROLLBACK</code>请求，则语句批处理不会重置为空。您必须显式调用<code class="codeph">clearBatch</code>才能重置它。
                              </p>
                           </li>
                           <li>
                              <p>回滚后调用<code class="codeph">clearBatch</code>方法适用于所有版本。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">executeBatch</code>调用将关闭语句对象的当前结果集（如果存在）。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">clearBatch</code>方法没有返回任何内容。
                              </p>
                           </li>
                        </ul>
                        <p>以下示例重复先前显示的<code class="codeph">addBatch</code>准备语句<code class="codeph">addBatch</code>调用，但在某些情况下清除批处理：</p><pre class="oac_no_warn" dir="ltr">...PreparedStatement pstmt = conn.prepareStatement（“INSERT INTO employees VALUES（？，？）“）; pstmt.setInt（1,2000）; pstmt.setString（2，”Milo Mumford“）; pstmt.addBatch（）; pstmt.setInt（1,3000）; pstmt.setString（2，”Sulu Simpson“） ; pstmt.addBatch（）; if（... <span class="italic">condition</span> ...）{int [] updateCounts = pstmt.executeBatch（）; ...} else {pstmt.clearBatch（）; ...}</pre></div>
                  </div><a id="JJDBC28774"></a><a id="JJDBC28773"></a><div class="props_rev_3"><a id="GUID-E399D995-77F0-48A2-8659-3FD3363D6474" name="GUID-E399D995-77F0-48A2-8659-3FD3363D6474"></a><h5 id="JJDBC-GUID-E399D995-77F0-48A2-8659-3FD3363D6474" class="sect5"><span class="enumeration_section">21.1.2.7</span> Oracle标准批处理实现中的更新计数</h5>
                     <div>
                        <p>如果成功处理语句批处理，则语句<code class="codeph">executeBatch</code>调用返回的整数数组或更新计数数组将始终为批处理中的每个操作都有一个元素。在标准更新批处理的Oracle实现中，数组元素的值如下：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>对于预准备语句批处理，该数组包含实际更新计数，指示每个操作影响的行数。</p>
                           </li>
                           <li>
                              <p>对于通用语句批处理，该数组包含实际更新计数，指示每个操作影响的行数。只有在标准批处理的Oracle实现中的通用语句的情况下才能提供实际的更新计数。</p>
                           </li>
                           <li>
                              <p>对于可调用语句批处理，该数组包含实际更新计数，指示每个操作影响的行数。</p>
                           </li>
                        </ul>
                        <p>在你的代码，在一个批处理的成功处理，你应该准备处理任何<code class="codeph">-2</code> ， <code class="codeph">1</code>数组元素，或真正的更新计数。对于一个成功的批量处理，该数组包含要么全部<code class="codeph">-2</code> ， <code class="codeph">1</code> ，或所有正整数。
                        </p>
                        <p><a href="performance-extensions.html#GUID-E399D995-77F0-48A2-8659-3FD3363D6474__CHDCBHEC">例21-1</a>说明了标准更新批处理的使用。
                        </p>
                        <div class="example" id="GUID-E399D995-77F0-48A2-8659-3FD3363D6474__CHDCBHEC">
                           <p class="titleinexample">例21-1标准更新批处理</p>
                           <p>此示例组合了前面部分中的示例片段，完成以下步骤：</p>
                           <ol>
                              <li>
                                 <p>禁用自动提交模式，使用更新批处理时应始终执行该模式</p>
                              </li>
                              <li>
                                 <p>创建预准备的语句对象</p>
                              </li>
                              <li>
                                 <p>将操作添加到与准备好的语句对象关联的批处理中</p>
                              </li>
                              <li>
                                 <p>处理批次</p>
                              </li>
                              <li>
                                 <p>从批处理中提交操作</p>
                              </li>
                           </ol><pre class="oac_no_warn" dir="ltr">conn.setAutoCommit（假）; PreparedStatement pstmt = conn.prepareStatement（“INSERT INTO employees VALUES（？，？）“）; pstmt.setInt（1,2000）; pstmt.setString（2，”Milo Mumford“）; pstmt.addBatch（）; pstmt.setInt（1,3000）; pstmt.setString（2，”Sulu Simpson“） ; pstmt.addBatch（）; int [] updateCounts = pstmt.executeBatch（）; conn.commit（）; pstmt.close（）; ...
</pre><p>您可以处理更新计数数组以确定批处理是否成功处理。</p>
                        </div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="JJDBC28775"></a><div class="props_rev_3"><a id="GUID-BF1E09C3-44A7-4CE9-A28A-BB01D5E335A9" name="GUID-BF1E09C3-44A7-4CE9-A28A-BB01D5E335A9"></a><h5 id="JJDBC-GUID-BF1E09C3-44A7-4CE9-A28A-BB01D5E335A9" class="sect5"><span class="enumeration_section">21.1.2.8</span> Oracle标准批处理实现中的错误处理</h5>
                     <div>
                        <p>如果任何一个批处理操作未能成功完成或尝试在<code class="codeph">executeBatch</code>调用期间返回结果集，则处理将停止并运行<code class="codeph">java.sql.生成BatchUpdateException</code> 。
                        </p>
                        <p>在批处理异常之后，可以使用<code class="codeph">BatchUpdateException</code>对象的<code class="codeph">getUpdateCounts</code>方法检索更新计数数组。这将返回一个<code class="codeph">int</code>数组的更新计数，就像<code class="codeph">executeBatch</code>方法一样。在标准更新批处理的Oracle实现中，处理批处理后，更新计数数组的内容如下：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>对于pr epared语句批处理，如果批处理执行之间出错，则<code class="codeph">executeBatch</code>方法不能返回值，而是抛出<code class="codeph">BatchUpdateException</code> 。在这种情况下，异常本身携带一个大小为<code class="codeph">n</code>的int数组作为其数据，其中<code class="codeph">n</code>是成功记录执行的次数。例如，如果批处理的大小为5且错误发生在第4条记录中，则<code class="codeph">BatchUpdateException</code>具有大小为3的数组（成功执行3条记录），并且数组中的每个项目表示每个项目受影响的行数。 。
                              </p>
                           </li>
                           <li>
                              <p>对于通用语句批处理或可调用语句批处理，更新计数数组只是一个包含直到错误点的实际更新计数的部分数组。可以提供实际的更新计数，因为Oracle JDBC无法在标准更新批处理的Oracle实现中对泛型和可调用语句使用真正的批处理。</p>
                              <p>例如，如果批处理中有20个操作，前13个成功，第14个生成异常，则更新计数数组将包含13个元素，包含成功操作的实际更新计数。</p>
                              <p>您可以根据需要在这种情况下提交或回滚成功的操作。</p>
                           </li>
                        </ul>
                        <p>在您的代码中，在处理批处理失败时，您应该准备好在发生异常时处理数组元素中的<code class="codeph">-3</code>或真实更新计数。对于失败的批处理，您将具有<code class="codeph">-3</code>的完整数组或正整数的部分数组。
                        </p>
                     </div>
                  </div><a id="JJDBC28776"></a><div class="props_rev_3"><a id="GUID-244F4126-6AF6-4751-8F16-163A3336F29F" name="GUID-244F4126-6AF6-4751-8F16-163A3336F29F"></a><h5 id="JJDBC-GUID-244F4126-6AF6-4751-8F16-163A3336F29F" class="sect5"><span class="enumeration_section">21.1.2.9</span>关于混合批量报表和非加密语句</h5>
                     <div>
                        <p>如果语句对象具有挂起的一批操作，则无法调用<code class="codeph">executeUpdate</code>进行常规的非操作处理操作。
                        </p>
                        <p>但是，如果在向语句批添加任何操作之前或处理批处理之后处理非分页操作，则可以在单个语句对象中混合批处理操作和非分页操作。实际上，只有当更新批处理为空时，才能为语句对象调用<code class="codeph">executeUpdate</code> 。如果批处理非空，则会生成异常。
                        </p>
                        <p>例如，有一个序列是有效的，如下所示：</p><pre class="oac_no_warn" dir="ltr">...PreparedStatement pstmt = conn.prepareStatement（“INSERT INTO employees VALUES（？，？）“）; pstmt.setInt（1,2000）; pstmt.setString（2，”Milo Mumford“）; int scount = pstmt.executeUpdate（）; // OK; pstmt批处理中没有操作pstmt.setInt（1,3000） ; pstmt.setString（2，“Sulu Simpson”）; pstmt.addBatch（）; //现在启动批处理pstmt.setInt（1,4000）; pstmt.setString（2，“Stan Leland”）; pstmt.addBatch（ ）; int [] bcounts = pstmt.executeBatch（）; pstmt.setInt（1,5000）; pstmt.setString（2，“Amy Feiner”）; int scount = pstmt.executeUpdate（）; // OK; pstmt batch was执行...
</pre><p>允许在一个语句对象上混合非压缩操作和在代码中的另一个语句对象上混合操作。关于更新批处理操作，不同的语句对象彼此独立。<code class="codeph">COMMIT</code>请求将影响已处理批次中的所有非分页操作和所有成功操作，但不会影响任何挂起的批处理。
                        </p>
                     </div>
                  </div>
               </div><a id="JJDBC28778"></a><a id="JJDBC28777"></a><div class="props_rev_3"><a id="GUID-6BAAB99B-8F5D-43A4-9445-4CC90E26F211" name="GUID-6BAAB99B-8F5D-43A4-9445-4CC90E26F211"></a><h4 id="JJDBC-GUID-6BAAB99B-8F5D-43A4-9445-4CC90E26F211" class="sect4"><span class="enumeration_section">21.1.3</span>过早批量冲洗</h4>
                  <div>
                     <p>由于缓存的元数据发生更改，会发生过早的批量刷新。由于各种原因，可以更改缓存的元数据，例如：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>初始绑定为null，以下绑定不为null。</p>
                        </li>
                        <li>
                           <p>标量类型最初绑定为字符串，然后绑定为标量类型或反向绑定。</p>
                        </li>
                     </ul>
                     <p>过早批量刷新计数总计为下一个<code class="codeph">executeUpdate</code>或<code class="codeph">sendBatch</code>方法的返回值。
                     </p>
                     <p>旧功能丢失了现在可以获得的所有这些批量刷新值。要切换回旧功能，可以将<code class="codeph">AccumulateBatchResult</code>属性设置为<code class="codeph">false</code> ，如下所示：</p><pre class="oac_no_warn" dir="ltr">java.util中。属性info = new java.util。属性（）; info.setProperty（“user”，“HR”）; info.setProperty（“passwd”，“hr”）; //其他属性......// property：batch flush type info.setProperty（“AccumulateBatchResult”，“false”）; OracleDataSource ods = new OracleDataSource（）; ods.setConnectionProperties（INFO）; ods.setURL（“jdbc：oracle：oci：@”“）;连接conn = ods.getConnection（）;</pre><div class="infoboxnote" id="GUID-6BAAB99B-8F5D-43A4-9445-4CC90E26F211__GUID-C7B0463E-C89A-42AA-A3EE-CB2E9BF3761E">
                        <p class="notep1">注意：</p>
                        <p>默认情况下， <code class="codeph">AccumulateBatchResult</code>属性设置为<code class="codeph">true</code> 。
                        </p>
                     </div>
                     <p><a href="performance-extensions.html#GUID-6BAAB99B-8F5D-43A4-9445-4CC90E26F211__CHDIJICJ">实施例21-2</a>说明了过早的批次冲洗。
                     </p>
                     <div class="example" id="GUID-6BAAB99B-8F5D-43A4-9445-4CC90E26F211__CHDIJICJ">
                        <p class="titleinexample">实施例21-2过早分批冲洗</p><pre class="oac_no_warn" dir="ltr">（（OraclePreparedStatement）pstmt）.setExecuteBatch（2）; pstmt.setNull（1，OracleTypes。数）; pstmt.setString（2，“test11”）; int count = pstmt.executeUpdate（）; //返回0 / * *此处发生过早批量刷新。* / pstmt.setInt（1,22）; pstmt.setString（2，“test22”）; int count = pstmt.executeUpdate（）; //返回0 pstmt.setInt（1,33）; pstmt.setString（2，“test33”）; / * *使用新的批处理方案返回3，其中as，*使用旧的批处理方案返回2。* / int count = pstmt.executeUpdate（）;</pre></div>
                     <!-- class="example" -->
                  </div>
               </div>
            </div><a id="JJDBC28779"></a><div class="props_rev_3"><a id="GUID-96A38C6D-A288-4E0B-9F03-E711C146632B" name="GUID-96A38C6D-A288-4E0B-9F03-E711C146632B"></a><h3 id="JJDBC-GUID-96A38C6D-A288-4E0B-9F03-E711C146632B" class="sect3"><span class="enumeration_section">21.2</span>其他Oracle性能扩展</h3>
               <div>
                  <div class="section">
                     <p>除了更新批处理之外，Oracle JDBC驱动程序还支持以下扩展，通过减少到数据库的往返来提高性能：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a id="d67478e908" class="indexterm-anchor"></a>预取行</p>
                           <p>通过每次获取数据时获取多行数据，这减少了到数据库的往返。额外数据存储在客户端缓冲区中，供客户端稍后访问。可以根据需要设置预取的行数。</p>
                        </li>
                        <li>
                           <p>指定<a id="d67478e916" class="indexterm-anchor"></a>列类型</p>
                           <p>这避免了标准JDBC协议在执行和返回查询结果方面的低效率。</p>
                        </li>
                        <li>
                           <p>抑制数据库元数据<code class="codeph">TABLE_REMARKS</code>列</p>
                           <p>这避免了昂贵的外连接操作。</p>
                        </li>
                     </ul>
                     <p>Oracle为连接属性对象提供了几种扩展，以支持这些性能扩展。这些扩展使您可以设置<code class="codeph">remarksReporting</code>标志以及行预取和更新批处理的默认值。
                     </p>
                     <p>本节包括以下主题：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="performance-extensions.html#GUID-5E60A90D-3924-4228-948D-4A9219201D18">关于预取LOB数据</a></p>
                        </li>
                        <li>
                           <p><a href="performance-extensions.html#GUID-8A39C0E0-AC61-4066-9932-30C4581B1D3A">Oracle Row-Prefetching限制</a></p>
                        </li>
                        <li>
                           <p><a href="performance-extensions.html#GUID-4E1011BD-7E2A-45D6-BD21-0BF36DC35421">关于定义列类型</a></p>
                        </li>
                        <li>
                           <p><a href="performance-extensions.html#GUID-15865071-39F2-430F-9EDA-EB34D0B2D560">关于报告DatabaseMetaData TABLE_REMARKS</a></p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
               </div><a id="JJDBC28780"></a><a id="JJDBC23210"></a><div class="props_rev_3"><a id="GUID-5E60A90D-3924-4228-948D-4A9219201D18" name="GUID-5E60A90D-3924-4228-948D-4A9219201D18"></a><h4 id="JJDBC-GUID-5E60A90D-3924-4228-948D-4A9219201D18" class="sect4"><span class="enumeration_section">21.2.1</span>关于预取LOB数据</h4>
                  <div>
                     <p>对于Oracle Database <span class="italic">11g</span>第2版JDBC驱动程序之前的JDBC驱动程序，如果要在一次往返中检索<code class="codeph">LOB</code>数据，则必须以<code class="codeph">VARCHAR2</code>类型获取数据，即必须使用<code class="codeph">OracleTypes.VARCHAR</code>或<code class="codeph">OracleTypes.使用JDBC <code class="codeph">defineColumnType</code>方法的LONGVARCHAR</code> 。这种方法的局限性在于，当<code class="codeph">LOB</code>数据被提取为<code class="codeph">CHAR</code>类型时，无法与数据一起提取定位器。因此，如果应用程序想要在稍后的时间点获取<code class="codeph">LOB</code>数据，或者应用程序想要执行其他<code class="codeph">LOB</code>操作，则需要再往返一次以获取<code class="codeph">LOB</code>定位器，因为<code class="codeph">LOB</code>定位器不可用于应用。
                     </p>
                     <div class="infoboxnote" id="GUID-5E60A90D-3924-4228-948D-4A9219201D18__GUID-53AA4ADF-D855-4CE9-A14E-709BD57D128B">
                        <p class="notep1">注意：</p>
                        <p>JDBC API不支持<code class="codeph">LOB</code>定位器上的数组操作。</p>
                     </div>
                     <p>从Oracle Database <span class="italic">11g</span>第2版JDBC驱动程序开始，通过预取经常使用的元数据（例如<code class="codeph">LOB</code>长度和块大小）以及常规获取操作期间<code class="codeph">LOB</code>数据的开头以及定位器，可以减少往返次数。 。对于小<code class="codeph">LOB</code> ，数据可以在一次往返中完全预取，即，在一次往返中发生<code class="codeph">select</code>解析，执行和提取，并且性能得到极大改善。对于大于预取大小的5倍的大型<code class="codeph">LOB</code> ，性能改进不是很显着，因为不需要用于检索块大小的往返行程。
                     </p>
                     <div class="section">
                        <p class="subhead3" id="GUID-5E60A90D-3924-4228-948D-4A9219201D18__GUID-9328BD10-BDDF-4E39-8EA9-824C582B3ECF">defaultLobPrefetchSize连接属性</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>从Oracle Database <span class="italic">11g</span>第2版开始，有一个新的连接属性<code class="codeph">oracle.jdbc.defaultLobPrefetchSize</code> ，可用于设置连接的默认<code class="codeph">LOB</code>预取大小。此连接属性定义为以下常量： <code class="codeph">OracleConnection.CONNECTION_PROPERTY_DEFAULT_LOB_PREFETCH_SIZE</code> 。此属性的值用作当前连接的默认<code class="codeph">LOB</code>预取大小。此连接属性的默认值为4000。如果要在语句级别更改默认值，请使用<code class="codeph">oracle.jdbc.定义的<code class="codeph">setLobPrefetchSize</code>方法<code class="codeph">oracle.jdbc.OracleStatement</code>接口。您可以将默认值更改为：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>-1禁用当前连接的<code class="codeph">LOB</code>预取</p>
                           </li>
                           <li>
                              <p>0仅为元数据启用<code class="codeph">LOB</code>预取</p>
                           </li>
                           <li>
                              <p>任何大于0的值，用于指定<code class="codeph">BLOB</code>的字节数以及在获取操作期间与定位器一起预取的<code class="codeph">CLOB</code>的字符数</p>
                           </li>
                        </ul>
                        <p>使用<code class="codeph">oracle.jdbc.定义的<code class="codeph">getLobPrefetchSize</code>方法<code class="codeph">oracle.jdbc.OracleStatement</code>接口用于检索<code class="codeph">LOB</code>预取大小。
                        </p>
                        <p>您还可以使用<code class="codeph">defineColumnType</code>方法在列级别设置<code class="codeph">LOB</code>预取大小的值。列级别值将覆盖在连接或语句级别设置的任何值。
                        </p>
                        <div class="infoboxnote" id="GUID-5E60A90D-3924-4228-948D-4A9219201D18__GUID-D80CD4D2-BC11-4E0E-B1F5-47BAFC11F878">
                           <p class="notep1">注意：</p>
                           <p>如果未在连接级别或语句级别禁用<code class="codeph">LOB</code>预取，则不能在列级别禁用它。
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JJDBC28781"></a><div class="props_rev_3"><a id="GUID-8A39C0E0-AC61-4066-9932-30C4581B1D3A" name="GUID-8A39C0E0-AC61-4066-9932-30C4581B1D3A"></a><h4 id="JJDBC-GUID-8A39C0E0-AC61-4066-9932-30C4581B1D3A" class="sect4"><span class="enumeration_section">21.2.2</span> Oracle行预取限制</h4>
                  <div>
                     <div class="section">
                        <p>没有最大预取设置。<a id="d67478e1149" class="indexterm-anchor"></a>默认值为10。根据查询所需的行数和列数，可能更大或更小的值。您可以使用<code class="codeph">Properties</code>对象设置默认连接行预取值。
                        </p>
                        <p>创建语句对象时，它将从关联的连接接收默认的行预取设置。对默认连接行预取设置的后续更改将不会对语句行预取设置产生任何影响。</p>
                        <p>如果结果集的列的数据类型为<code class="codeph">LONG</code> ， <code class="codeph">LONG</code> <code class="codeph">RAW</code>或<code class="codeph">LOB</code>通过数据接口返回，即流类型，则JDBC会将语句行预取设置更改为1，即使您实际上从未读过这两种类型的价值。
                        </p>
                        <p>设置预取大小可能会影响应用程序的性能。增加预取大小将减少获取所有数据所需的往返次数，但会增加内存使用量。这取决于查询中列的数量和大小以及预期返回的行数。它还取决于JDBC客户端计算机的内存和CPU负载。独立客户端应用程序的最佳选择将与负载很重的应用程序服务器不同。还应考虑网络连接的速度和延迟。</p>
                        <div class="infoboxnote" id="GUID-8A39C0E0-AC61-4066-9932-30C4581B1D3A__GUID-E6B031D3-8840-4C0D-833B-68B42A9C7F44">
                           <p class="notep1">注意：</p>
                           <p>从Oracle Database <span class="italic">11g</span>第1版开始，Thin驱动程序可以在第一次往返中从服务器获取第一个<code class="codeph">prefetch_size</code>行数。这样可以在SELECT语句中保存一次往返。
                           </p>
                        </div>
                        <p>如果要将应用程序从早期版本的Oracle JDBC驱动程序迁移到<span class="italic">10g</span>第1版（10.1）或更高版本的Oracle JDBC驱动程序，那么您应该重新审视之前已完成的优化，因为内存使用和性能特征可能具有变化很大。
                        </p>
                        <p>您可能遇到的一种常见情况是，您有一个选择唯一键的查询。查询将仅返回零行或一行。将预取大小设置为1将降低内存和CPU使用率，并且不能增加往返次数。但是，您必须小心避免通过写入<code class="codeph">while(rs.next())</code>而不是<code class="codeph">if(rs.next())</code>来请求额外提取的错误。
                        </p>
                        <p>如果您使用的是JDBC Thin驱动程序，则使用<code class="codeph">useFetchSizeWithLongColumn</code>连接属性，因为它将在一次往返中执行<code class="codeph">PARSE</code> ， <code class="codeph">EXECUTE</code>和<code class="codeph">FETCH</code> 。
                        </p>
                        <p>调整预取大小应该与在实际应用程序的实际负载下调整JVM中的内存管理一起完成。</p>
                        <div class="infoboxnote" id="GUID-8A39C0E0-AC61-4066-9932-30C4581B1D3A__GUID-597CB868-DC87-46B5-B746-D57969973796">
                           <p class="notep1">注意：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>不要在应用程序中混用JDBC 2.0提取大小应用程序编程接口（API）和Oracle行预取API。您可以使用其中一个，但不能同时使用两个。</p>
                              </li>
                              <li>
                                 <p>请注意，设置Oracle提取大小值不仅会影响查询，还会通过结果集<code class="codeph">refreshRow</code>方法显式地重新生成结果集中的行，这与滚动敏感/只读，滚动敏感/可更新和滚动不敏感/可更新的结果集，以及滚动敏感结果集的窗口大小，影响自动重新获取的执行频率。但是，Oracle提取大小值将被提取大小的任何设置覆盖。
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JJDBC28783"></a><a id="JJDBC28784"></a><a id="JJDBC28782"></a><div class="props_rev_3"><a id="GUID-4E1011BD-7E2A-45D6-BD21-0BF36DC35421" name="GUID-4E1011BD-7E2A-45D6-BD21-0BF36DC35421"></a><h4 id="JJDBC-GUID-4E1011BD-7E2A-45D6-BD21-0BF36DC35421" class="sect4"><span class="enumeration_section">21.2.3</span>关于定义列类型</h4>
                  <div>
                     <div class="section">
                        <div class="infoboxnote" id="GUID-4E1011BD-7E2A-45D6-BD21-0BF36DC35421__GUID-CEA3A0C3-A05B-4348-B4CA-D91BDD0A62A8">
                           <p class="notep1">注意：</p>
                           <p>从Oracle Database 12 <span class="italic">c</span>第1版（12.1）开始，不推荐使用<code class="codeph">defineColumnType</code>方法。
                           </p>
                        </div>
                        <p>自Oracle Database <span class="italic">10g</span>以来， <code class="codeph">defineColumnType</code>的实现发生了重大变化。以前， <code class="codeph">defineColumnType</code>既用作性能优化又用于强制数据类型转换。在以前的版本中，所有驱动程序都受益于对<code class="codeph">defineColumnType</code>调用。从Oracle数据库<span class="italic">10g开始</span> ，JDBC Thin驱动程序不再需要提供的信息。JDBC Thin驱动程序无需调用<code class="codeph">defineColumnType</code>即可实现最高性能。当应用程序使用<code class="codeph">defineColumnType</code>时，JDBC Oracle调用接口（OCI）和服务器端内部驱动程序仍可获得更好的性能。
                        </p>
                        <p>如果您的代码与JDBC Thin和OCI驱动程序一起使用，则可以在使用Thin驱动程序时通过将connection属性<code class="codeph">disableDefineColumnType</code>设置为<code class="codeph">true</code>来禁用<code class="codeph">defineColumnType</code>方法。这样做会使<code class="codeph">defineColumnType</code>无效。使用JDBC OCI或服务器端内部驱动程序时，请勿将此连接属性设置为<code class="codeph">true</code> 。
                        </p>
                        <p>您还可以使用<code class="codeph">defineColumnType</code>来控制客户端分配的内存量或限制可变长度数据的大小。
                        </p>
                        <p><a id="d67478e1306" class="indexterm-anchor"></a><a id="d67478e1310" class="indexterm-anchor"></a>请按照以下常规步骤为查询定义列类型：</p>
                        <ol>
                           <li>
                              <p>如果有必要，投你的Statement对象<code class="codeph">OracleStatement</code> ， <code class="codeph">OraclePreparedStatement</code> ，或<code class="codeph">OracleCallableStatement</code> （如适用）。
                              </p>
                           </li>
                           <li>
                              <p>如有必要，请使用<code class="codeph">Statement</code>对象的<code class="codeph">clearDefines</code>方法清除此<code class="codeph">Statement</code>对象的所有<code class="codeph">clearDefines</code>定义。
                              </p>
                           </li>
                           <li>
                              <p>在每一列上，调用<code class="codeph">Statement</code>对象的<code class="codeph">defineColumnType</code>方法，并将这些参数传递给它：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>列索引（整数）</p>
                                 </li>
                                 <li>
                                    <p>类型代码（整数）</p>
                                    <p>使用<code class="codeph">java.sql.的<code class="codeph">static</code>常量<code class="codeph">java.sql.Types</code>类或<code class="codeph">oracle.jdbc.OracleTypes</code>类，例如<code class="codeph">Types.INTEGER</code> ， <code class="codeph">Types.FLOAT</code> ， <code class="codeph">Types.VARCHAR</code> ， <code class="codeph">OracleTypes.VARCHAR</code>和<code class="codeph">OracleTypes.ROWID</code> 。标准类型的类型代码在这两个类中是相同的。
                                    </p>
                                 </li>
                                 <li>
                                    <p>输入名称（字符串）</p>
                                    <p>对于结构化对象，对象引用和数组，还必须指定类型名称。例如， <code class="codeph">Employee</code> ， <code class="codeph">EmployeeRef</code>或<code class="codeph">EmployeeArray</code> 。
                                    </p>
                                 </li>
                                 <li>
                                    <p>最大字段大小（整数）</p>
                                    <p>（可选）为此列指定最大数据长度。</p>
                                    <p>如果要为结构化对象，对象引用或数组定义列类型，则不能指定最大字段大小参数。如果您尝试包含此参数，则会将其忽略。</p>
                                 </li>
                                 <li>
                                    <p>使用形式（短）</p>
                                    <p>（可选）指定列的使用形式。这可以是<code class="codeph">OraclePreparedStatement.FORM_CHAR</code>使用数据库字符集或<code class="codeph">OraclePreparedStatement.FORM_NCHAR</code>使用国家字符集。如果省略此参数，则默认为<code class="codeph">FORM_CHAR</code> 。</p>
                                 </li>
                              </ul>
                              <p>例如，假设<code class="codeph">stmt</code>是Oracle语句，请使用：</p><pre class="oac_no_warn" dir="ltr">stmt.defineColumnType（ <span class="italic">column_index</span> ， <span class="italic">typeCode</span> ）;</pre><p>如果列是<code class="codeph">VARCHAR</code>或等效的，并且您知道长度限制：</p><pre class="oac_no_warn" dir="ltr">stmt.defineColumnType（ <span class="italic">column_index</span> ， <span class="italic">typeCode</span> ， <span class="italic">max_size</span> ）;</pre><p>对于需要原始最大长度并请求转换为数据库字符集的<code class="codeph">NVARCHAR</code>列：</p><pre class="oac_no_warn" dir="ltr">stmt.defineColumnType（ <span class="italic">column_index</span> ， <span class="italic">typeCode</span> ，0，OraclePreparedStatement。FORM_CHAR）;</pre><p>对于结构化对象，对象引用和数组列：</p><pre class="oac_no_warn" dir="ltr">stmt.defineColumnType（ <span class="italic">column_index</span> ， <span class="italic">typeCode</span> ， <span class="italic">typeName</span> ）;</pre><p>如果您不想接收数据的完整默认长度，请设置最大字段大小。调用标准JDBC <code class="codeph">Statement</code>类的<code class="codeph">setMaxFieldSize</code>方法会对返回的数据量设置限制。具体而言，返回的数据大小将是以下最小值：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p><code class="codeph">defineColumnType</code>设置的最大字段大小</p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">setMaxFieldSize</code>设置的最大字段大小</p>
                                 </li>
                                 <li>
                                    <p>数据类型的自然最大大小</p>
                                 </li>
                              </ul>
                           </li>
                        </ol>
                        <p>完成这些步骤后，使用该语句的<code class="codeph">executeQuery</code>方法执行查询。
                        </p>
                        <div class="infoboxnote" id="GUID-4E1011BD-7E2A-45D6-BD21-0BF36DC35421__GUID-8F484BA8-81A1-485E-8C4F-0DEDCC321726">
                           <p class="notep1">注意：</p>
                           <p>不再需要为预期结果集的每列指定数据类型。</p>
                        </div>
                        <p>以下示例说明了此功能的用法。它假定您已导入<code class="codeph">oracle.jdbc.*</code>接口。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-4E1011BD-7E2A-45D6-BD21-0BF36DC35421__CHDJDDEA">
                        <p class="titleinexample">例21-3定义列类型</p><pre class="oac_no_warn" dir="ltr">OracleDataSource ods = new OracleDataSource（）; ods.setURL（ “JDBC：预言：瘦：@localhost：5221：ORCL”）; ods.setUser（ “HR”）; ods.setPassword（ “HR”）; Connection conn = ods.getConnection（）;语句stmt = conn.createStatement（）; //为此列仅分配2个字符（将发生截断）（（OracleStatement）stmt）.defineColumnType（1，Types。VARCHAR，2）; ResultSet rset = stmt.executeQuery（“从emp中选择ename”）; while（rset.next（））System.out.println（rset.getString（1））; stmt.close（）;</pre></div>
                     <!-- class="example" -->
                     <div class="section">
                        <p>如此示例所示，您必须在调用<code class="codeph">defineColumnType</code>方法时将<code class="codeph">Statement</code>对象<code class="codeph">stmt</code> <code class="codeph">defineColumnType</code>为<code class="codeph">OracleStatement</code> 。连接的<code class="codeph">createStatement</code>方法返回<code class="codeph">java.sql.类型的对象<code class="codeph">java.sql.Statement</code> ，没有<code class="codeph">defineColumnType</code>和<code class="codeph">clearDefines</code>方法。这些方法仅在<code class="codeph">OracleStatement</code>实现中提供。
                        </p>
                        <p>define-extensions使用JDBC类型来指定所需的类型。列的允许定义类型取决于列的内部Oracle类型。</p>
                        <p>可以将所有列定义为其自然JDBC类型。在大多数情况下，可以将它们定义为<code class="codeph">Types.CHAR</code>或<code class="codeph">Types.VARCHAR</code>类型代码。
                        </p>
                        <p>下表列出了可在<code class="codeph">defineColumnType</code>方法中使用的有效列定义参数。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="tblformal" id="GUID-4E1011BD-7E2A-45D6-BD21-0BF36DC35421__G1060844">
                        <p class="titleintable">表21-1有效列类型规范</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="有效列类型规范" width="100%" border="1" summary="table" frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="34%" id="d67478e1570">如果列具有Oracle SQL类型：</th>
                                 <th align="left" valign="bottom" width="66%" id="d67478e1575">您可以使用defineColumnType将其定义为：</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="34%" id="d67478e1582" headers="d67478e1570 ">
                                    <p><code class="codeph">NUMBER</code> ， <code class="codeph">VARNUM</code></p>
                                 </td>
                                 <td align="left" valign="top" width="66%" headers="d67478e1582 d67478e1575 ">
                                    <p><code class="codeph">BIGINT</code> ， <code class="codeph">TINYINT</code> ， <code class="codeph">SMALLINT</code> ， <code class="codeph">INTEGER</code> ， <code class="codeph">FLOAT</code> ， <code class="codeph">REAL</code> ， <code class="codeph">DOUBLE</code> ， <code class="codeph">NUMERIC</code> ， <code class="codeph">DECIMAL</code> ， <code class="codeph">CHAR</code> ， <code class="codeph">VARCHAR</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="34%" id="d67478e1625" headers="d67478e1570 ">
                                    <p><code class="codeph">CHAR</code> ， <code class="codeph">VARCHAR2</code></p>
                                 </td>
                                 <td align="left" valign="top" width="66%" headers="d67478e1625 d67478e1575 ">
                                    <p><code class="codeph">CHAR</code> ， <code class="codeph">VARCHAR</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="34%" id="d67478e1640" headers="d67478e1570 ">
                                    <p><code class="codeph">长</code></p>
                                 </td>
                                 <td align="left" valign="top" width="66%" headers="d67478e1640 d67478e1575 ">
                                    <p><code class="codeph">CHAR</code> ， <code class="codeph">VARCHAR</code> ， <code class="codeph">LONGVARCHAR</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="34%" id="d67478e1655" headers="d67478e1570 ">
                                    <p><code class="codeph">LONGRAW</code></p>
                                 </td>
                                 <td align="left" valign="top" width="66%" headers="d67478e1655 d67478e1575 ">
                                    <p><code class="codeph">LONGVARBINARY</code> ， <code class="codeph">VARBINARY</code> ， <code class="codeph">BINARY</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="34%" id="d67478e1670" headers="d67478e1570 ">
                                    <p><code class="codeph">生的</code></p>
                                 </td>
                                 <td align="left" valign="top" width="66%" headers="d67478e1670 d67478e1575 ">
                                    <p><code class="codeph">VARBINARY</code> ， <code class="codeph">BINARY</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="34%" id="d67478e1682" headers="d67478e1570 ">
                                    <p><code class="codeph">日期</code></p>
                                 </td>
                                 <td align="left" valign="top" width="66%" headers="d67478e1682 d67478e1575 ">
                                    <p><code class="codeph">DATE</code> ， <code class="codeph">TIME</code> ， <code class="codeph">TIMESTAMP</code> ， <code class="codeph">CHAR</code> ， <code class="codeph">VARCHAR</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="34%" id="d67478e1703" headers="d67478e1570 ">
                                    <p><code class="codeph">ROWID</code></p>
                                 </td>
                                 <td align="left" valign="top" width="66%" headers="d67478e1703 d67478e1575 ">
                                    <p><code class="codeph">ROWID</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="34%" id="d67478e1712" headers="d67478e1570 ">
                                    <p><code class="codeph">BLOB</code></p>
                                 </td>
                                 <td align="left" valign="top" width="66%" headers="d67478e1712 d67478e1575 ">
                                    <p><code class="codeph">VARBINARY</code> ， <code class="codeph">BINARY</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="34%" id="d67478e1724" headers="d67478e1570 ">
                                    <p><code class="codeph">CLOB</code></p>
                                 </td>
                                 <td align="left" valign="top" width="66%" headers="d67478e1724 d67478e1575 ">
                                    <p><code class="codeph">LONG</code> ， <code class="codeph">CHAR</code> ， <code class="codeph">VARCHAR</code></p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <div class="section">
                        <p>将<code class="codeph">defineColumnType</code>与列的原始数据类型一起使用始终有效。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JJDBC28787"></a><a id="JJDBC28788"></a><a id="JJDBC28786"></a><a id="JJDBC28785"></a><div class="props_rev_3"><a id="GUID-15865071-39F2-430F-9EDA-EB34D0B2D560" name="GUID-15865071-39F2-430F-9EDA-EB34D0B2D560"></a><h4 id="JJDBC-GUID-15865071-39F2-430F-9EDA-EB34D0B2D560" class="sect4"><span class="enumeration_section">21.2.4</span>关于报告DatabaseMetaData TABLE_REMARKS</h4>
                  <div>
                     <p>如果必须报告<code class="codeph">TABLE_REMARKS</code>列，则数据库元数据类的<code class="codeph">getColumns</code> ， <code class="codeph">getProcedureColumns</code> ， <code class="codeph">getProcedures</code>和<code class="codeph">getTables</code>方法很慢，因为这需要昂贵的外连接。因此，JDBC驱动程序默认情况下<span class="italic">不</span>报告<code class="codeph">TABLE_REMARKS</code>列。
                     </p>
                     <p>您可以通过将<code class="codeph">true</code>参数传递给<code class="codeph">OracleConnection</code>对象的<code class="codeph">setRemarksReporting</code>方法来启用<code class="codeph">TABLE_REMARKS</code>报告。
                     </p>
                     <p>同样，如果在建立连接时使用Java <code class="codeph">Properties</code>对象，则可以设置<code class="codeph">remarksReporting</code> Java属性，而不是调用<code class="codeph">setRemarksReporting</code> 。
                     </p>
                     <p>如果您使用的是标准<code class="codeph">java.sql.Connection</code>对象，必须将其<code class="codeph">setRemarksReporting</code>为<code class="codeph">OracleConnection</code>才能使用<code class="codeph">setRemarksReporting</code> 。
                     </p>
                     <p>以下代码段说明了如何启用<code class="codeph">TABLE_REMARKS</code>报告：</p><pre class="oac_no_warn" dir="ltr">（（oracle.jdbc。OracleConnection）conn）。setRemarksReporting（true）;</pre><p>这里， <code class="codeph">conn</code>是标准<code class="codeph">Connection</code>对象的名称，以下语句启用<code class="codeph">TABLE_REMARKS</code>报告：</p>
                     <div class="section">
                        <p class="subhead3" id="GUID-15865071-39F2-430F-9EDA-EB34D0B2D560__GUID-96D4A629-8ECA-4D9A-AF13-93D796323E3A">getColumns的注意事项</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>默认情况下，如果指定了同义词，则<code class="codeph">getColumns</code>方法不会检索有关列的信息。要在指定同义词时启用信息检索，必须在连接上调用<code class="codeph">setIncludeSynonyms</code>方法，如下所示：</p><pre class="oac_no_warn" dir="ltr">（（oracle.jdbc。OracleConnection）conn）.setIncludeSynonyms（true）</pre><p>这将导致连接上的所有后续<code class="codeph">getColumns</code>方法调用都包含同义词。这与<code class="codeph">setRemarksReporting</code>类似。或者，您可以设置<code class="codeph">includeSynonyms</code>连接属性。这类似于<code class="codeph">remarksReporting</code>连接属性。
                        </p>
                        <p>但是，请记住，如果<code class="codeph">includeSynonyms</code>为<code class="codeph">true</code> ，则<code class="codeph">table_name</code>列中返回的对象的名称将是同义词名称（如果存在同义词）。即使将表名传递给<code class="codeph">getColumns</code>也是如此。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-15865071-39F2-430F-9EDA-EB34D0B2D560__GUID-2D1B3889-695F-4CEE-AD18-C7691C332AAA">getProcedures和getProcedureColumns方法的注意事项</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>根据JDBC版本1.1和1.2，方法<code class="codeph">getProcedures</code>和<code class="codeph">getProcedureColumns</code>以相同的方式处理<code class="codeph">catalog</code> ， <code class="codeph">schemaPattern</code> ， <code class="codeph">columnNamePattern</code>和<code class="codeph">procedureNamePattern</code>参数。在这些方法的Oracle定义中，参数的处理方式不同：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">目录</code></p>
                              <p>Oracle没有多个目录，但它确实有包。因此， <code class="codeph">catalog</code>参数被视为包名称。这适用于输入（作为<code class="codeph">catalog</code>参数）和输出（它是返回的<code class="codeph">ResultSet</code>的<code class="codeph">catalog</code>列）。在输入时，构造<code class="codeph">"</code> <code class="codeph">"</code>是一个空字符串，它在没有包的情况下检索过程和参数，即独立对象。<code class="codeph">null</code>值意味着从选择标准中删除，即返回有关独立对象和打包对象的信息。也就是说，它与传递百分号（ <code class="codeph">%</code> ）具有相同的效果。否则，如果需要， <code class="codeph">catalog</code>参数应该是包名称模式，带有SQL通配符。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">schemaPattern</code></p>
                              <p>Oracle数据库中的所有对象都必须具有模式，因此在没有模式的情况下返回这些对象的信息是没有意义的。因此，构造<code class="codeph">"</code> <code class="codeph">"</code> （它是一个空字符串）在输入上被解释为表示当前模式中的对象，即您当前连接的对象。为了与<code class="codeph">catalog</code>参数的行为保持一致， <code class="codeph">null</code>被解释为从选择条件中删除模式。也就是说，它与传入<code class="codeph">%</code>具有相同的效果。它也可以用作SQL通配符的模式。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">procedureNamePattern</code>和<code class="codeph">columnNamePattern</code></p>
                              <p>空字符串（“”）对任一参数都没有意义，因为所有过程和参数都必须具有名称。因此，构造<code class="codeph">"</code> <code class="codeph">"</code>将引发异常。为了与其他参数的行为保持一致， <code class="codeph">null</code>与传入百分号（ <code class="codeph">%</code> ）具有相同的效果。
                              </p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>