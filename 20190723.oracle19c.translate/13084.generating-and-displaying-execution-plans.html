<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <meta name="abstract" content="Knowledge of how to explain a statement and display its plan is essential to SQL tuning."></meta>
      <meta name="description" content="Knowledge of how to explain a statement and display its plan is essential to SQL tuning."></meta>
      <title>解释和显示执行计划</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="SQL Tuning Guide"></meta>
      <meta property="og:description" content="Knowledge of how to explain a statement and display its plan is essential to SQL tuning."></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="SQL Tuning Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="sql-tuning-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-31T14:57:08-08:00"></meta>
      <meta name="dcterms.title" content="SQL Tuning Guide"></meta>
      <meta name="dcterms.dateCopyrighted" content="2013, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96095-03"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="query-execution-plans.html" title="Previous" type="text/html"></link>
      <link rel="next" href="optimizer-ref.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.isVersionOf" content="TGSQL"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="query-execution-plans.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="optimizer-ref.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">SQL调优指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="query-execution-plans.html" property="item" typeof="WebPage"><span property="name">查询执行计划</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">解释和显示执行计划</li>
            </ol>
            <a id="GUID-60E30B1C-342B-4D71-B154-C26623D6A3B1" name="GUID-60E30B1C-342B-4D71-B154-C26623D6A3B1"></a><a id="TGSQL271"></a>
            
            <h2 id="TGSQL-GUID-60E30B1C-342B-4D71-B154-C26623D6A3B1" class="sect2"><span class="enumeration_chapter">6</span>解释和显示执行计划</h2>
         </header>
         <div class="ind">
            <div>
               <p>了解如何解释语句并显示其计划对于SQL调优至关重要。</p>
               <p>本章包含以下主题：</p>
            </div>
            <div>
               <ul class="ullinks">
                  <li class="ulchildlink"><a href="generating-and-displaying-execution-plans.html#GUID-EB015E00-82E3-4BEA-A8A4-4F7225F548D6">执行计划简介</a><br><strong class="term">执行计划</strong>是数据库为运行SQL语句而执行的操作序列。
                  </li>
                  <li class="ulchildlink"><a href="generating-and-displaying-execution-plans.html#GUID-BE9E3808-81AF-4868-B8B2-656E3940B892">使用EXPLAIN PLAN语句生成计划输出</a><br><code class="codeph">EXPLAIN PLAN</code>语句使您可以检查优化程序为SQL语句选择的执行计划。
                  </li>
                  <li class="ulchildlink"><a href="generating-and-displaying-execution-plans.html#GUID-725CADF8-3803-416F-96EB-BF942F742663">显示执行计划</a><br>显示执行计划的最简单方法是使用<code class="codeph">DBMS_XPLAN</code>显示功能或<code class="codeph">V$</code>视图。
                  </li>
                  <li class="ulchildlink"><a href="generating-and-displaying-execution-plans.html#GUID-0023D232-5695-4BA8-89C5-88672B7647E2">比较执行计划</a><br>计划比较工具采用参考计划和任意测试计划列表，并突出显示它们之间的差异。计划比较是合乎逻辑的而不是逐行的。
                  </li>
               </ul>
               <div class="familylinks">
                  <div class="parentlink">
                     <p><strong>父主题：</strong> <a href="query-execution-plans.html#GUID-BE44BB45-C061-4F3A-8F18-4AAC5F74C68A" title="如果查询的性能欠佳，则执行计划是了解问题和提供解决方案的关键工具。">查询执行计划</a></p>
                  </div>
               </div>
            </div>
            <a id="TGSQL272"></a><div class="props_rev_3"><a id="GUID-EB015E00-82E3-4BEA-A8A4-4F7225F548D6" name="GUID-EB015E00-82E3-4BEA-A8A4-4F7225F548D6"></a><h3 id="TGSQL-GUID-EB015E00-82E3-4BEA-A8A4-4F7225F548D6" class="sect3"><span class="enumeration_section">6.1</span>执行计划简介</h3>
               <div>
                  <p><strong class="term">执行计划</strong>是数据库为运行SQL语句而执行的操作序列。
                  </p>
                  <p>本节包含以下主题：</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="generating-and-displaying-execution-plans.html#GUID-E348705A-6FA5-4869-BD13-2806DACBF4ED">执行计划的内容</a><br>仅执行计划操作无法区分经过良好调整的语句和执行次优的语句。
                     </li>
                     <li class="ulchildlink"><a href="generating-and-displaying-execution-plans.html#GUID-30C0114A-084A-45C8-B6A7-C4D91B6A35AE">为什么执行计划会发生变化</a><br>随着基础优化器输入的变化，执行计划可以并且确实会发生变化。
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="generating-and-displaying-execution-plans.html#GUID-60E30B1C-342B-4D71-B154-C26623D6A3B1" title="了解如何解释语句并显示其计划对于SQL调优至关重要。">解释和显示执行计划</a></p>
                     </div>
                  </div>
               </div>
               <a id="TGSQL94698"></a><div class="props_rev_3"><a id="GUID-E348705A-6FA5-4869-BD13-2806DACBF4ED" name="GUID-E348705A-6FA5-4869-BD13-2806DACBF4ED"></a><h4 id="TGSQL-GUID-E348705A-6FA5-4869-BD13-2806DACBF4ED" class="sect4"><span class="enumeration_section">6.1.1</span>执行计划的内容</h4>
                  <div>
                     <p>仅执行计划操作无法区分经过良好调整的语句和执行次优的语句。</p>
                     <div class="section">
                        <p>该计划包括一系列步骤。每个步骤都要从数据库中物理地检索数据行，或者为发出语句的用户准备它们。以下计划显示了<code class="codeph">employees</code>和<code class="codeph">departments</code>表的连接：</p><pre class="pre codeblock"><code>SQL_ID g9xaqjktdhbcd，子编号0 ------------------------------------- SELECT employee_id，last_name，first_name，来自员工e的department_name，部门d WHERE e.department_id = d.department_id和last_name like'T％'ORDER BY last_name计划哈希值：1219589317 -------------------- -------------------------------------------------- ---------------------- | Id |操作|名称|行|字节|成本（％CPU）|时间| -------------------------------------------------- ------------------------------------------ | 0 |选择声明| | | | 5（100）| | | 1 | NESTED LOOPS | | 5 | 190 | 5（0）| 00:00:01 | | 2 |按INDEX ROWID表的访问权限|员工| 5 | 110 | 2（0）| 00:00:01 | | * 3 | INDEX RANGE SCAN | EMP_NAME_IX | 5 | | 1（0）| 00:00:01 | | * 4 |表访问完全|部门| 1 | 16 | 1（0）| 00:00:01 | -------------------------------------------------- ------------------------------------------谓词信息（由操作ID标识） ：------------------------------------------------- -  3  - 访问权限（“LAST_NAME”LIKE'T％'）过滤器（“LAST_NAME”LIKE'T％'）4  - 过滤器（“E”。“DEPARTMENT_ID”=“D”。“DEPARTMENT_ID”）</code></pre><p><a href="glossary.html#GUID-8C474809-DFD4-4EA6-90FE-A17882D07E58"><span class="xrefglossterm">行源树</span></a>是执行计划的核心。该树显示以下信息：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>语句引用的表的<a href="glossary.html#GUID-4AF1D36D-F72C-4049-925A-BA2C169A0500"><span class="xrefglossterm">连接顺序</span></a></p>
                              <p>在上面的计划中， <code class="codeph">employees</code>是外行源， <code class="codeph">departments</code>是内行源。
                              </p>
                           </li>
                           <li>
                              <p>语句中提到的每个表的<a href="glossary.html#GUID-22DF198C-4310-4307-BF29-DCE765725BD4"><span class="xrefglossterm">访问路径</span></a></p>
                              <p>在上一个计划中，优化程序选择使用索引扫描访问<code class="codeph">employees</code>使用完整扫描访问<code class="codeph">departments</code> 。
                              </p>
                           </li>
                           <li>
                              <p>对语句中的连接操作影响的表的<a href="glossary.html#GUID-C4F1E78D-0262-4517-9DE6-8D835DCEC709"><span class="xrefglossterm">连接方法</span></a></p>
                              <p>在前面的计划中，优化器选择嵌套循环连接。</p>
                           </li>
                           <li>
                              <p>过滤，排序或聚合等数据操作</p>
                              <p>在上面的计划中，优化器会过滤以<code class="codeph">T</code>开头并在<code class="codeph">department_id</code>匹配的姓氏。
                              </p>
                           </li>
                        </ul>
                        <p>除了行源树之外，计划表还包含有关以下内容的信息：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>优化，例如每个操作的成本和基数</p>
                           </li>
                           <li>
                              <p>分区，例如访问的分区集</p>
                           </li>
                           <li>
                              <p>并行执行，例如连接输入的分配方法</p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="generating-and-displaying-execution-plans.html#GUID-EB015E00-82E3-4BEA-A8A4-4F7225F548D6" title="执行计划是数据库为运行SQL语句而执行的操作序列。">执行计划简介</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="TGSQL94693"></a><div class="props_rev_3"><a id="GUID-30C0114A-084A-45C8-B6A7-C4D91B6A35AE" name="GUID-30C0114A-084A-45C8-B6A7-C4D91B6A35AE"></a><h4 id="TGSQL-GUID-30C0114A-084A-45C8-B6A7-C4D91B6A35AE" class="sect4"><span class="enumeration_section">6.1.2</span>为什么执行计划会发生变化</h4>
                  <div>
                     <p>随着基础优化器输入的变化，执行计划可以并且确实会发生变化。</p>
                     <div class="infoboxnote" id="GUID-30C0114A-084A-45C8-B6A7-C4D91B6A35AE__GUID-6040AF75-3CD3-4B80-8F25-8A9BBE385F10">
                        <p class="notep1">注意：</p>
                        <p>为避免执行计划更改可能导致的SQL性能回归，请考虑使用SQL计划管理。</p>
                     </div>
                     <p>本节包含以下主题：</p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="generating-and-displaying-execution-plans.html#GUID-94D7E339-9310-4482-A1BC-26F74D2BED89">不同的架构</a><br>由于各种原因，架构可能不同。
                        </li>
                        <li class="ulchildlink"><a href="generating-and-displaying-execution-plans.html#GUID-4A42068F-93FA-4E04-9574-1E96423C8EBC">不同的成本</a><br>即使模式相同，优化程序也可以在成本不同时选择不同的执行计划。
                        </li>
                     </ul>
                     <div class="infoboxnotealso" id="GUID-30C0114A-084A-45C8-B6A7-C4D91B6A35AE__GUID-877FCF73-4E3C-4FF0-A09D-CF1522BDF86B">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><span class="q">“ <a href="overview-of-sql-plan-management.html#GUID-F1C45056-F998-43E5-B362-83F88DA49E58" title="SQL计划管理是一种预防机制，使优化程序能够自动管理执行计划，确保数据库仅使用已知或已验证的计划。">SQL计划管理概述</a> ”</span></p>
                           </li>
                           <li>
                              <p><a href="../arpls/DBMS_SPM.html#ARPLS150" target="_blank"><span><cite>Oracle Database PL / SQL包和类型参考，</cite></span></a>以了解<code class="codeph">DBMS_SPM</code>包</p>
                           </li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="generating-and-displaying-execution-plans.html#GUID-EB015E00-82E3-4BEA-A8A4-4F7225F548D6" title="执行计划是数据库为运行SQL语句而执行的操作序列。">执行计划简介</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="TGSQL94694"></a><div class="props_rev_3"><a id="GUID-94D7E339-9310-4482-A1BC-26F74D2BED89" name="GUID-94D7E339-9310-4482-A1BC-26F74D2BED89"></a><h5 id="TGSQL-GUID-94D7E339-9310-4482-A1BC-26F74D2BED89" class="sect5"><span class="enumeration_section">6.1.2.1</span>不同的模式</h5>
                     <div>
                        <p>由于各种原因，架构可能不同。</p>
                        <p>主要原因包括以下内容：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>执行和解释计划发生在不同的数据库上。</p>
                           </li>
                           <li>
                              <p>解释该语句的用户与运行该语句的用户不同。两个用户可能指向同一数据库中的不同对象，从而导致执行计划不同。</p>
                           </li>
                           <li>
                              <p>两个操作之间的架构更改（通常是索引更改）。</p>
                           </li>
                        </ul>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="generating-and-displaying-execution-plans.html#GUID-30C0114A-084A-45C8-B6A7-C4D91B6A35AE" title="随着基础优化器输入的变化，执行计划可以并且确实会发生变化。">执行计划更改的原因</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TGSQL94695"></a><div class="props_rev_3"><a id="GUID-4A42068F-93FA-4E04-9574-1E96423C8EBC" name="GUID-4A42068F-93FA-4E04-9574-1E96423C8EBC"></a><h5 id="TGSQL-GUID-4A42068F-93FA-4E04-9574-1E96423C8EBC" class="sect5"><span class="enumeration_section">6.1.2.2</span>不同的费用</h5>
                     <div>
                        <p>即使模式相同，优化程序也可以在成本不同时选择不同的执行计划。</p>
                        <p>影响成本的一些因素包括：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>数据量和统计数据</p>
                           </li>
                           <li>
                              <p>绑定变量类型和值</p>
                           </li>
                           <li>
                              <p>初始化参数在全局或会话级别设置</p>
                           </li>
                        </ul>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="generating-and-displaying-execution-plans.html#GUID-30C0114A-084A-45C8-B6A7-C4D91B6A35AE" title="随着基础优化器输入的变化，执行计划可以并且确实会发生变化。">执行计划更改的原因</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div>
            </div><a id="TGSQL273"></a><div class="props_rev_3"><a id="GUID-BE9E3808-81AF-4868-B8B2-656E3940B892" name="GUID-BE9E3808-81AF-4868-B8B2-656E3940B892"></a><h3 id="TGSQL-GUID-BE9E3808-81AF-4868-B8B2-656E3940B892" class="sect3"><span class="enumeration_section">6.2</span>使用EXPLAIN PLAN语句生成计划输出</h3>
               <div>
                  <p><code class="codeph">EXPLAIN PLAN</code>语句使您可以检查优化程序为SQL语句选择的执行计划。
                  </p>
                  <p>本节包含以下主题：</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="generating-and-displaying-execution-plans.html#GUID-23BE135E-3C29-4A55-93E8-17163F6C4801">关于EXPLAIN PLAN声明</a><br><code class="codeph">EXPLAIN PLAN</code>语句显示优化程序为<code class="codeph">SELECT</code> ， <code class="codeph">UPDATE</code> ， <code class="codeph">INSERT</code>和<code class="codeph">DELETE</code>语句选择的执行计划。
                     </li>
                     <li class="ulchildlink"><a href="generating-and-displaying-execution-plans.html#GUID-E4ED3145-8ABD-4F40-B044-9AEFBD89409C">解释SQL语句：基本步骤</a><br>使用<code class="codeph">EXPLAIN PLAN</code>在<code class="codeph">PLAN_TABLE</code>存储SQL语句的计划。</li>
                     <li class="ulchildlink"><a href="generating-and-displaying-execution-plans.html#GUID-102A6D99-3193-4628-BC35-74501F46D13A">在EXPLAIN PLAN中指定语句ID：示例</a><br>使用多个语句，您可以指定语句标识符并使用它来标识您的特定执行计划。
                     </li>
                     <li class="ulchildlink"><a href="generating-and-displaying-execution-plans.html#GUID-A377E279-4983-4750-917D-17C48ED3D1DB">为EXPLAIN PLAN输出指定不同的位置：示例</a><br><code class="codeph">EXPLAIN PLAN</code>的<code class="codeph">INTO</code>子句指定了一个用于存储输出的不同表。
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="generating-and-displaying-execution-plans.html#GUID-60E30B1C-342B-4D71-B154-C26623D6A3B1" title="了解如何解释语句并显示其计划对于SQL调优至关重要。">解释和显示执行计划</a></p>
                     </div>
                  </div>
               </div>
               <a id="TGSQL95114"></a><div class="props_rev_3"><a id="GUID-23BE135E-3C29-4A55-93E8-17163F6C4801" name="GUID-23BE135E-3C29-4A55-93E8-17163F6C4801"></a><h4 id="TGSQL-GUID-23BE135E-3C29-4A55-93E8-17163F6C4801" class="sect4"><span class="enumeration_section">6.2.1</span>关于EXPLAIN PLAN声明</h4>
                  <div>
                     <p><code class="codeph">EXPLAIN PLAN</code>语句显示优化程序为<code class="codeph">SELECT</code> ， <code class="codeph">UPDATE</code> ， <code class="codeph">INSERT</code>和<code class="codeph">DELETE</code>语句选择的执行计划。
                     </p>
                     <p><code class="codeph">EXPLAIN PLAN</code>输出显示了在解释语句时数据库如何运行SQL语句。由于执行环境和解释计划环境的差异，所解释的计划可能与语句执行期间使用的实际计划不同。
                     </p>
                     <p>发出<code class="codeph">EXPLAIN PLAN</code>语句时，优化程序会选择执行计划，然后将描述执行计划的每个步骤的行插入到指定的计划表中。您还可以将<code class="codeph">EXPLAIN PLAN</code>语句作为SQL跟踪工具的一部分发出。
                     </p>
                     <p><code class="codeph">EXPLAIN PLAN</code>语句是DML语句而不是DDL语句。因此，Oracle数据库不会隐式提交<code class="codeph">EXPLAIN PLAN</code>语句所做的更改。
                     </p>
                     <p>本节包含以下主题：</p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="generating-and-displaying-execution-plans.html#GUID-948FF9B7-F728-46C3-98B4-AC3EFD362E65">关于PLAN_TABLE</a><br><code class="codeph">PLAN_TABLE</code>是<code class="codeph">EXPLAIN PLAN</code>语句插入描述执行计划的行的默认样本输出表。
                        </li>
                        <li class="ulchildlink"><a href="generating-and-displaying-execution-plans.html#GUID-E2463C7B-F71A-4F06-85D3-1AF3D4D71CE8">解释计划限制</a><br>对于执行日期绑定变量的隐式类型转换的语句，Oracle数据库不支持<code class="codeph">EXPLAIN PLAN</code> 。
                        </li>
                     </ul>
                     <div class="infoboxnotealso" id="GUID-23BE135E-3C29-4A55-93E8-17163F6C4801__GUID-4C0770EA-67D2-40EA-8725-5346A73BCF7A">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p> <span class="q">“ <a href="sql-processing.html#GUID-E052E274-586D-4D76-960F-B831140F7B94" title="行源生成器是从优化器接收最佳执行计划并生成可由数据库的其余部分使用的迭代执行计划的软件。">SQL行源生成</a> ”</span></p>
                           </li>
                           <li>
                              <p><a href="../sqlrf/EXPLAIN-PLAN.html#SQLRF01601" target="_blank"><span><cite>Oracle Database SQL语言参考</cite></span></a> ，了解<code class="codeph">EXPLAIN PLAN</code>语句</p>
                           </li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="generating-and-displaying-execution-plans.html#GUID-BE9E3808-81AF-4868-B8B2-656E3940B892" title="EXPLAIN PLAN语句使您可以检查优化程序为SQL语句选择的执行计划。">使用EXPLAIN PLAN语句生成计划输出</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="TGSQL94701"></a><div class="props_rev_3"><a id="GUID-948FF9B7-F728-46C3-98B4-AC3EFD362E65" name="GUID-948FF9B7-F728-46C3-98B4-AC3EFD362E65"></a><h5 id="TGSQL-GUID-948FF9B7-F728-46C3-98B4-AC3EFD362E65" class="sect5"><span class="enumeration_section">6.2.1.1</span>关于PLAN_TABLE</h5>
                     <div>
                        <p><code class="codeph">PLAN_TABLE</code>是<code class="codeph">EXPLAIN PLAN</code>语句插入描述执行计划的行的默认样本输出表。
                        </p>
                        <div class="section">
                           <p>Oracle数据库自动在<code class="codeph">SYS</code>模式中创建全局临时表<code class="codeph">PLAN_TABLE$</code> ，并创建<code class="codeph">PLAN_TABLE</code>作为同义词。<code class="codeph">PLAN_TABLE</code>所有必要权限都授予<code class="codeph">PUBLIC</code> 。因此，每个会话在其临时表空间中都有自己的<code class="codeph">PLAN_TABLE</code>私有副本。
                           </p>
                           <p>您可以使用SQL脚本<code class="codeph">catplan.sql</code>手动创建全局临时表和<code class="codeph">PLAN_TABLE</code>同义词。此脚本的名称和位置取决于您的操作系统。在UNIX和Linux上，该脚本位于<code class="codeph">$ORACLE_HOME/rdbms/admin</code>目录中。例如，启动SQL * Plus会话，使用<code class="codeph">SYSDBA</code>权限连接，并按如下方式运行脚本：</p><pre class="pre codeblock"><code>@ $ ORACLE_HOME / RDBMS /管理/ catplan.sql</code></pre><p>可以在分发介质上的SQL脚本中使用示例输出表<code class="codeph">PLAN_TABLE</code>的定义。您的输出表必须与此表具有相同的列名称和数据类型。该脚本的通用名称是<code class="codeph">utlxplan.sql</code> 。确切的名称和位置取决于您的操作系统。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-948FF9B7-F728-46C3-98B4-AC3EFD362E65__GUID-EE83465E-9679-4EC0-A1E0-AB640F548B09">
                           <p class="notep1">也可以看看：</p>
                           <p>有关<code class="codeph">EXPLAIN PLAN</code>语法的完整说明，请<a href="../sqlrf/EXPLAIN-PLAN.html#SQLRF01601" target="_blank"><span><cite>参见Oracle数据库SQL语言参考</cite></span></a> 。
                           </p>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="generating-and-displaying-execution-plans.html#GUID-23BE135E-3C29-4A55-93E8-17163F6C4801" title="EXPLAIN PLAN语句显示优化程序为SELECT，UPDATE，INSERT和DELETE语句选择的执行计划。">关于EXPLAIN PLAN语句</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TGSQL94700"></a><div class="props_rev_3"><a id="GUID-E2463C7B-F71A-4F06-85D3-1AF3D4D71CE8" name="GUID-E2463C7B-F71A-4F06-85D3-1AF3D4D71CE8"></a><h5 id="TGSQL-GUID-E2463C7B-F71A-4F06-85D3-1AF3D4D71CE8" class="sect5"><span class="enumeration_section">6.2.1.2解释</span>计划限制</h5>
                     <div>
                        <p>对于执行日期绑定变量的隐式类型转换的语句，Oracle数据库不支持<code class="codeph">EXPLAIN PLAN</code> 。
                        </p>
                        <div class="section">
                           <p>通常使用绑定变量， <code class="codeph">EXPLAIN PLAN</code>输出可能不代表实际的执行计划。
                           </p>
                           <p>从SQL语句的文本来看， <code class="codeph">TKPROF</code>无法确定绑定变量的类型。它假定类型为<code class="codeph">VARCHAR</code> ，否则给出错误消息。您可以通过在SQL语句中放入适当的类型转换来避免此限制。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-E2463C7B-F71A-4F06-85D3-1AF3D4D71CE8__GUID-4B4164F5-E704-4BB2-84A2-A846D3A9FE43">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><span class="q">“ <a href="performing-application-tracing.html#GUID-440D3AD4-B302-408E-8627-FE8032DD09F9" title="本章介绍了端到端应用程序跟踪的内容，以及如何生成和读取跟踪文件。">执行应用程序跟踪</a> ”</span></p>
                              </li>
                              <li>
                                 <p><span class="q">“ <a href="performing-application-tracing.html#GUID-2D5E244C-1852-40F0-B222-3DBA59380A56" title="如果您不知道在运行时绑定的值，则可能会陷入参数陷阱。">避免争论陷阱的指导原则</a> ”</span></p>
                              </li>
                              <li>
                                 <p><a href="../sqlrf/Data-Types.html#SQLRF-GUID-A3C0D836-BADB-44E5-A5D4-265BA5968483" target="_blank"><span><cite>Oracle数据库SQL语言参考，</cite></span></a>以了解有关SQL数据类型的更多信息</p>
                              </li>
                           </ul>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="generating-and-displaying-execution-plans.html#GUID-23BE135E-3C29-4A55-93E8-17163F6C4801" title="EXPLAIN PLAN语句显示优化程序为SELECT，UPDATE，INSERT和DELETE语句选择的执行计划。">关于EXPLAIN PLAN语句</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div>
               <div class="props_rev_3"><a id="GUID-E4ED3145-8ABD-4F40-B044-9AEFBD89409C" name="GUID-E4ED3145-8ABD-4F40-B044-9AEFBD89409C"></a><h4 id="TGSQL-GUID-E4ED3145-8ABD-4F40-B044-9AEFBD89409C" class="sect4"><span class="enumeration_section">6.2.2</span>解释SQL语句：基本步骤</h4>
                  <div>
                     <p>使用<code class="codeph">EXPLAIN PLAN</code>在<code class="codeph">PLAN_TABLE</code>存储SQL语句的计划。</p>
                     <div class="section">
                        <p class="subhead3" id="GUID-E4ED3145-8ABD-4F40-B044-9AEFBD89409C__GUID-EA194E3F-7937-4E81-922A-74670325E653">先决条件</p>
                        <p>此任务假定您的架构中存在名为<code class="codeph">PLAN_TABLE</code>的示例输出表。如果此表不存在，则运行SQL脚本<code class="codeph">catplan.sql</code> 。
                        </p>
                        <p>要执行<code class="codeph">EXPLAIN PLAN</code> ，您必须具有以下权限：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>您必须具有将行插入到指定用于保存执行计划的现有输出表所需的特权</p>
                           </li>
                           <li>
                              <p>您还必须具有执行要为其确定执行计划的SQL语句所需的特权。如果SQL语句访问视图，则您必须具有访问视图所基于的任何表和视图的权限。如果视图基于另一个基于表的视图，则您必须具有访问其他视图及其基础表的权限。</p>
                           </li>
                        </ul>
                        <p>要检查<code class="codeph">EXPLAIN PLAN</code>语句生成的执行计划，您必须具有查询输出表所需的权限。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-E4ED3145-8ABD-4F40-B044-9AEFBD89409C__GUID-47181F89-96CE-4223-9E2A-68B57EFE1B2D">解释声明：</p>
                        <ol>
                           <li>
                              <p>启动SQL * Plus或SQL Developer，并以具有必需权限的用户身份登录数据库。</p>
                           </li>
                           <li>
                              <p>在SQL语句之前包含<code class="codeph">EXPLAIN PLAN FOR</code>子句。
                              </p>
                              <p>以下示例说明了<code class="codeph">employees</code>表的查询计划：</p><pre class="pre codeblock"><code>EXPLAIN PLAN FOR SELECT e.last_name，d.department_name，e.salary FROM employees e，departments d WHERE salary &lt;3000 AND e.department_id = d.department_id ORDER BY salary DESC;</code></pre></li>
                           <li>
                              <p>发出<code class="codeph">EXPLAIN PLAN</code>语句后，使用Oracle数据库提供的脚本或包显示最新的计划表输出。
                              </p>
                              <p>以下示例使用<code class="codeph">DBMS_XPLAN.DISPLAY</code>函数：</p><pre class="pre codeblock"><code>SELECT * FROM TABLE（DBMS_XPLAN.DISPLAY（format =&gt;'ALL'））;</code></pre></li>
                           <li>
                              <p>查看计划输出。</p>
                              <p>例如，以下计划显示了散列连接：</p><pre class="pre codeblock"><code>SQL&gt; SELECT * FROM TABLE（DBMS_XPLAN.DISPLAY（format =&gt;'ALL'））;计划哈希值：3556827125 --------------------------------------------- -------------------------------------- | Id |操作|名称|行|字节|成本（％CPU）|时间| -------------------------------------------------- --------------------------------- | 0 |选择声明| | 4 | 124 | 5（20）| 00:00:01 | | 1 |排序顺序| | 4 | 124 | 5（20）| 00:00:01 | | * 2 | HASH JOIN | | 4 | 124 | 4（0）| 00:00:01 | | * 3 |表访问完全|员工| 4 | 60 | 2（0）| 00:00:01 | | 4 |表访问完全|部门| 27 | 432 | 2（0）| 00:00:01 | -------------------------------------------------- ---------------------------------查询块名称/对象别名（由操作ID标识）：---- -------------------------------------------------- ------- 1  -  SEL $ 1 3  -  SEL $ 1 / E @ SEL $ 1 4  -  SEL $ 1 / D @ SEL $ 1谓词信息（由操作ID识别）：------------ --------------------------------------- 2  -  access（“E”。“DEPARTMENT_ID” =“D”。“DEPARTMENT_ID”）3  - 过滤器（“SALARY”&lt;3000）列投影信息（由操作ID标识）：--------------------- -------------------------------------- 1  - （＃keys = 1）INTERNAL_FUNCTION（“E “。”SALARY“）[22]，”E“。”LAST_NAME“[VARCHAR2,25]，”D“。”DEPARTMENT_NAME“[VARCHAR2,30] 2  - （＃keys = 1）”E“。”LAST_NAME“ [VARCHAR2,25]，“SALARY”[NUMBER，22]，“D”。“DEPARTMENT_NAME”[VARCHAR2,30]，“D”。“DEPARTMENT_NAME”[VARCHAR2,30] 3  - “E”。“LAST_NAME”[ VARCHAR2,25]，“SALARY”[NUMBER，22]，“E”。“DEPARTMENT_ID”[NUMBER，22] 4  - “D”。“DEPARTMENT_ID”[NUMBER，22]，“D”。“DEPARTMENT_NAME”[VARCHAR2 ，30]注意-----  - 这是一个适应器计划</code></pre><p><code class="codeph">EXPLAIN PLAN</code>输出中的执行顺序以最右边缩进的行开始。下一步是该行的父级。如果两条线平均缩进，则通常首先执行顶行。
                              </p>
                              <div class="infoboxnote" id="GUID-E4ED3145-8ABD-4F40-B044-9AEFBD89409C__GUID-66B035BC-615D-4E4A-802F-5CB013E2503A">
                                 <p class="notep1">注意：</p>
                                 <p>本章中<code class="codeph">EXPLAIN PLAN</code>输出中的步骤可能与您的数据库不同。优化器可以根据数据库配置选择不同的执行计划。
                                 </p>
                              </div>
                           </li>
                        </ol>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-E4ED3145-8ABD-4F40-B044-9AEFBD89409C__GUID-B00A245A-AB43-499D-9F45-BFDB36DF6CAB">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><span class="q">“ <a href="generating-and-displaying-execution-plans.html#GUID-948FF9B7-F728-46C3-98B4-AC3EFD362E65" title="PLAN_TABLE是EXPLAIN PLAN语句插入描述执行计划的行的默认样本输出表。">关于PLAN_TABLE</a> ”</span></p>
                           </li>
                           <li>
                              <p><span class="q">“ <a href="generating-and-displaying-execution-plans.html#GUID-5E88AD7F-D5FF-4003-B721-9126352CE414" title="要显示计划表输出，可以使用SQL脚本或DBMS_XPLAN包。">关于PLAN_TABLE输出的显示</a> ”</span></p>
                           </li>
                           <li>
                              <p>有关<code class="codeph">EXPLAIN PLAN</code>的语法和语义的<a href="../sqlrf/EXPLAIN-PLAN.html#SQLRF-GUID-FD540872-4ED3-4936-96A2-362539931BA0" target="_blank"><span><cite>Oracle数据库SQL语言参考</cite></span></a></p>
                           </li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="generating-and-displaying-execution-plans.html#GUID-BE9E3808-81AF-4868-B8B2-656E3940B892" title="EXPLAIN PLAN语句使您可以检查优化程序为SQL语句选择的执行计划。">使用EXPLAIN PLAN语句生成计划输出</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="TGSQL94703"></a><a id="TGSQL94702"></a><div class="props_rev_3"><a id="GUID-102A6D99-3193-4628-BC35-74501F46D13A" name="GUID-102A6D99-3193-4628-BC35-74501F46D13A"></a><h4 id="TGSQL-GUID-102A6D99-3193-4628-BC35-74501F46D13A" class="sect4"><span class="enumeration_section">6.2.3</span>在EXPLAIN PLAN中指定语句ID：示例</h4>
                  <div>
                     <p>使用多个语句，您可以指定语句标识符并使用它来标识您的特定执行计划。</p>
                     <div class="section">
                        <p>在使用<code class="codeph">SET STATEMENT ID</code>之前，请删除该语句ID的所有现有行。在以下示例中，将<code class="codeph">st1</code>指定为语句标识符。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-102A6D99-3193-4628-BC35-74501F46D13A__CACCJJCJ">
                        <p class="titleinexample">示例6-1将EXPLAIN PLAN与STATEMENT ID子句一起使用</p><pre class="pre codeblock"><code>EXPLAIN PLAN SET STATEMENT_ID ='st1'FOR SELECT last_name FROM employees;</code></pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="generating-and-displaying-execution-plans.html#GUID-BE9E3808-81AF-4868-B8B2-656E3940B892" title="EXPLAIN PLAN语句使您可以检查优化程序为SQL语句选择的执行计划。">使用EXPLAIN PLAN语句生成计划输出</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="TGSQL94705"></a><a id="TGSQL94704"></a><div class="props_rev_3"><a id="GUID-A377E279-4983-4750-917D-17C48ED3D1DB" name="GUID-A377E279-4983-4750-917D-17C48ED3D1DB"></a><h4 id="TGSQL-GUID-A377E279-4983-4750-917D-17C48ED3D1DB" class="sect4"><span class="enumeration_section">6.2.4</span>为EXPLAIN PLAN输出指定不同的位置：示例</h4>
                  <div>
                     <p><code class="codeph">EXPLAIN PLAN</code>的<code class="codeph">INTO</code>子句指定了一个用于存储输出的不同表。
                     </p>
                     <div class="section">
                        <p>如果您不想使用名称<code class="codeph">PLAN_TABLE</code> ，请在运行<code class="codeph">catplan.sql</code>脚本后创建新的同义词。例如：</p><pre class="pre codeblock"><code>为plan_table $创建或替换PUBLIC SYNONYM my_plan_table</code></pre><p>以下语句将输出定向到<code class="codeph">my_plan_table</code> ：</p><pre class="pre codeblock"><code>EXPLAIN PLAN INTO my_plan_table FOR SELECT last_name FROM employees;</code></pre><p>您可以在使用<code class="codeph">INTO</code>子句时指定语句ID，如以下语句中所示：</p><pre class="pre codeblock"><code>EXPLAIN PLAN SET STATEMENT_ID ='st1'INTO my_plan_table FOR SELECT last_name FROM employees;</code></pre></div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-A377E279-4983-4750-917D-17C48ED3D1DB__GUID-6FF1242C-8932-4D90-A755-4047E8E67509">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><span class="q">“ <a href="optimizer-ref.html#GUID-5AE1939F-F654-42FF-B0C5-706507CD12A2" title="PLAN_TABLE由EXPLAIN PLAN语句填充。">PLAN_TABLE列</a> ”</span>用于描述<code class="codeph">PLAN_TABLE</code>中的列</p>
                           </li>
                           <li>
                              <p><a href="../sqlrf/CREATE-SYNONYM.html#SQLRF-GUID-A806C82F-1171-478E-A910-F9C6C42739B2" target="_blank"><span><cite>Oracle Database SQL语言参考</cite></span></a>了解<code class="codeph">CREATE SYNONYM</code></p>
                           </li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="generating-and-displaying-execution-plans.html#GUID-BE9E3808-81AF-4868-B8B2-656E3940B892" title="EXPLAIN PLAN语句使您可以检查优化程序为SQL语句选择的执行计划。">使用EXPLAIN PLAN语句生成计划输出</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div>
            <div class="sect2"><a id="GUID-725CADF8-3803-416F-96EB-BF942F742663" name="GUID-725CADF8-3803-416F-96EB-BF942F742663"></a><h3 id="TGSQL-GUID-725CADF8-3803-416F-96EB-BF942F742663" class="sect3"><span class="enumeration_section">6.3</span>显示执行计划</h3>
               <div>
                  <p>显示执行计划的最简单方法是使用<code class="codeph">DBMS_XPLAN</code>显示功能或<code class="codeph">V$</code>视图。
                  </p>
                  <p>本节包含以下主题：</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="generating-and-displaying-execution-plans.html#GUID-5E88AD7F-D5FF-4003-B721-9126352CE414">关于PLAN_TABLE输出的显示</a><br>要显示计划表输出，可以使用SQL脚本或<code class="codeph">DBMS_XPLAN</code>包。
                     </li>
                     <li class="ulchildlink"><a href="generating-and-displaying-execution-plans.html#GUID-1FA56307-047B-42BB-AF17-3B05F1814559">显示执行计划：基本步骤</a><br><code class="codeph">DBMS_XPLAN.DISPLAY</code>函数是显示已解释计划的简单方法。
                     </li>
                     <li class="ulchildlink"><a href="generating-and-displaying-execution-plans.html#GUID-83F88700-3902-4D19-8182-AF2B92AEA7EB">显示自适应查询计划：教程</a><br><strong class="term">自适应优化器</strong>是<strong class="term">优化器</strong>的一项功能，使其能够根据运行时统计信息调整计划。所有自适应机制都可以执行与默认计划不同的语句的最终计划。
                     </li>
                     <li class="ulchildlink"><a href="generating-and-displaying-execution-plans.html#GUID-90411427-FDD7-4196-A52A-84D153CE37C1">显示执行计划：示例</a><br>这些示例显示了显示执行计划的不同方式。
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="generating-and-displaying-execution-plans.html#GUID-60E30B1C-342B-4D71-B154-C26623D6A3B1" title="了解如何解释语句并显示其计划对于SQL调优至关重要。">解释和显示执行计划</a></p>
                     </div>
                  </div>
               </div>
               <a id="TGSQL94706"></a><div class="props_rev_3"><a id="GUID-5E88AD7F-D5FF-4003-B721-9126352CE414" name="GUID-5E88AD7F-D5FF-4003-B721-9126352CE414"></a><h4 id="TGSQL-GUID-5E88AD7F-D5FF-4003-B721-9126352CE414" class="sect4"><span class="enumeration_section">6.3.1</span>关于PLAN_TABLE输出的显示</h4>
                  <div>
                     <p>要显示计划表输出，可以使用SQL脚本或<code class="codeph">DBMS_XPLAN</code>包。
                     </p>
                     <div class="section">
                        <p>解释完计划后，使用Oracle Database提供的以下SQL脚本或PL / SQL包显示最新的计划表输出：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">DBMS_XPLAN.DISPLAY</code>表函数</p>
                              <p>此函数接受用于显示计划表输出的选项。您可以指定：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>如果您使用的表与<code class="codeph">PLAN_TABLE</code>不同，则为计划表名称</p>
                                 </li>
                                 <li>
                                    <p>如果已使用<code class="codeph">EXPLAIN PLAN</code>设置语句ID，则为语句ID</p>
                                 </li>
                                 <li>
                                    <p>确定详细程度的格式选项： <code class="codeph">BASIC</code> ， <code class="codeph">SERIAL</code> ， <code class="codeph">TYPICAL</code>和<code class="codeph">ALL</code></p>
                                 </li>
                              </ul>
                              <p>使用<code class="codeph">DBMS_XPLAN</code>显示<code class="codeph">PLAN_TABLE</code>输出的示例<code class="codeph">DBMS_XPLAN</code> ：</p><pre class="pre codeblock"><code>从TABLE中选择PLAN_TABLE_OUTPUT（DBMS_XPLAN.DISPLAY（））;从TABLE中选择PLAN_TABLE_OUTPUT（DBMS_XPLAN.DISPLAY（'MY_PLAN_TABLE'，'st1'，'TYPICAL'））;</code></pre></li>
                           <li>
                              <p><code class="codeph">utlxpls.sql</code> 
                              </p>
                              <p>此脚本显示用于串行处理的计划表输出</p>
                           </li>
                           <li>
                              <p><code class="codeph">utlxplp.sql</code></p>
                              <p>此脚本显示计划表输出，包括并行执行列。</p>
                           </li>
                        </ul>
                        <p>本节包含以下主题：</p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="generating-and-displaying-execution-plans.html#GUID-2C3C060E-1E16-4075-BA08-37148F0BFDFA">DBMS_XPLAN显示功能</a><br>您可以使用<code class="codeph">DBMS_XPLAN</code>显示功能来显示计划。
                        </li>
                        <li class="ulchildlink"><a href="generating-and-displaying-execution-plans.html#GUID-955B4D41-EB27-44FE-A9E2-8C42835B652D">与计划相关的视图</a><br>您可以通过查询动态性能和数据字典视图来获取有关执行计划的信息。
                        </li>
                     </ul>
                     <div class="infoboxnotealso" id="GUID-5E88AD7F-D5FF-4003-B721-9126352CE414__GUID-2FD03CE5-2A08-49CF-A2A1-F0726D52A496">
                        <p class="notep1">也可以看看：</p>
                        <p>有关<code class="codeph">DBMS_XPLAN</code>包的更多信息，请<code class="codeph">DBMS_XPLAN</code> <a href="../arpls/DBMS_XPLAN.html#ARPLS378" target="_blank"><span><cite>Oracle Database PL / SQL包和类型参考</cite></span></a></p>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="generating-and-displaying-execution-plans.html#GUID-725CADF8-3803-416F-96EB-BF942F742663" title="显示执行计划的最简单方法是使用DBMS_XPLAN显示功能或V $视图。">显示执行计划</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="TGSQL291"></a><a id="TGSQL290"></a><div class="props_rev_3"><a id="GUID-2C3C060E-1E16-4075-BA08-37148F0BFDFA" name="GUID-2C3C060E-1E16-4075-BA08-37148F0BFDFA"></a><h5 id="TGSQL-GUID-2C3C060E-1E16-4075-BA08-37148F0BFDFA" class="sect5"><span class="enumeration_section">6.3.1.1</span> DBMS_XPLAN显示功能</h5>
                     <div>
                        <p>您可以使用<code class="codeph">DBMS_XPLAN</code>显示功能来显示计划。
                        </p>
                        <div class="section">
                           <p>显示功能接受显示计划表输出的选项。您可以指定：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>如果您使用的表与<code class="codeph">PLAN_TABLE</code>不同，则为计划表名称</p>
                              </li>
                              <li>
                                 <p>如果已使用<code class="codeph">EXPLAIN PLAN</code>设置语句ID，则为语句ID</p>
                              </li>
                              <li>
                                 <p>确定详细程度的格式选项： <code class="codeph">BASIC</code> ， <code class="codeph">SERIAL</code> ， <code class="codeph">TYPICAL</code> ， <code class="codeph">ALL</code> ，在某些情况下是<code class="codeph">ADAPTIVE</code></p>
                              </li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                        <div class="tblformal" id="GUID-2C3C060E-1E16-4075-BA08-37148F0BFDFA__CEGCBHGJ">
                           <p class="titleintable">表6-1 DBMS_XPLAN显示功能</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="DBMS_XPLAN显示功能" width="100%" border="1" summary="This 2 column table describes DBMS_XPLAN program units. Column 1 lists the functions. Column 2 provides more information about the functions. " frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="25%" id="d21079e2755">显示功能</th>
                                    <th align="left" valign="bottom" width="75%" id="d21079e2758">笔记</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="25%" id="d21079e2763" headers="d21079e2755 ">
                                       <p><code class="codeph">显示</code></p>
                                    </td>
                                    <td align="left" valign="top" width="75%" headers="d21079e2763 d21079e2758 ">
                                       <p><span>此表函数显示计划表的内容。</span></p>
                                       <p>此外，只要此表的列的名称与计划表的列相同（或者如果包含统计信息， <code class="codeph">V$SQL_PLAN_STATISTICS_ALL</code> ），您可以使用此表函数显示存储在表中的任何计划（有或没有统计信息） ）。您可以在指定的表上应用谓词以选择要显示的计划的行。
                                       </p>
                                       <p><code class="codeph">format</code>参数控制计划的级别。它接受值<code class="codeph">BASIC</code> ， <code class="codeph">TYPICAL</code> ， <code class="codeph">SERIAL</code>和<code class="codeph">ALL</code> 。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="25%" id="d21079e2794" headers="d21079e2755 ">
                                       <p><code class="codeph">DISPLAY_AWR</code></p>
                                    </td>
                                    <td align="left" valign="top" width="75%" headers="d21079e2794 d21079e2758 ">
                                       <p><span>该表函数显示存储在AWR中的执行计划的内容。</span></p>
                                       <p><code class="codeph">format</code>参数控制计划的级别。它接受值<code class="codeph">BASIC</code> ， <code class="codeph">TYPICAL</code> ， <code class="codeph">SERIAL</code>和<code class="codeph">ALL</code> 。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="25%" id="d21079e2820" headers="d21079e2755 ">
                                       <p><code class="codeph">DISPLAY_CURSOR</code></p>
                                    </td>
                                    <td align="left" valign="top" width="75%" headers="d21079e2820 d21079e2758 ">
                                       <p><span>此表函数显示加载到游标缓存中的任何游标的说明计划。除了解释计划，各种计划统计（如。可以报告I / O，内存和计时（基于<code class="codeph">V$SQL_PLAN_STATISTICS_ALL VIEWS</code> ）。</span></p>
                                       <p><span><code class="codeph">format</code>参数控制计划的级别。它接受值<code class="codeph">BASIC</code> ， <code class="codeph">TYPICAL</code> ， <code class="codeph">SERIAL</code> ， <code class="codeph">ALL</code>和<code class="codeph">ADAPTIVE</code> 。</span>指定<code class="codeph">ADAPTIVE</code> ，输出包括：</p>
                                       <ul style="list-style-type:disc">
                                          <li>
                                             <p>最终的计划。如果执行尚未完成，则输出显示当前计划。本节还包括有关影响计划的运行时优化的说明。</p>
                                          </li>
                                          <li>
                                             <p>推荐计划。在报告模式下，输出包括将根据执行统计信息选择的计划。</p>
                                          </li>
                                          <li>
                                             <p>动态计划。输出汇总了计划中与优化程序选择的默认计划不同的部分。</p>
                                          </li>
                                          <li>
                                             <p>重新优化。输出显示由于重新优化而在后续执行时选择的计划。</p>
                                          </li>
                                       </ul>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="25%" id="d21079e2871" headers="d21079e2755 ">
                                       <p><code class="codeph">DISPLAY_PLAN</code></p>
                                    </td>
                                    <td align="left" valign="top" width="75%" headers="d21079e2871 d21079e2758 "><span>此表函数以<code class="codeph">CLOB</code>输出类型以各种格式显示计划表的内容。</span><p><span><code class="codeph">format</code>参数控制计划的级别。它接受值<code class="codeph">BASIC</code> ， <code class="codeph">TYPICAL</code> ， <code class="codeph">SERIAL</code> ， <code class="codeph">ALL</code>和<code class="codeph">ADAPTIVE</code> 。</span>指定<code class="codeph">ADAPTIVE</code> ，输出包括默认计划。对于每个动态子计划，计划显示可以替换的原始行源列表以及将替换它们的行源。
                                       </p>
                                       <p>如果<code class="codeph">format</code>参数指定轮廓显示，则该函数显示动态子计划中每个选项的提示。如果计划不是自适应查询计划，则该功能将显示默认计划。如果未指定<code class="codeph">ADAPTIVE</code> ，则计划将按原样显示，但在“注释”部分中显示其他注释，以显示任何动态的行源。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="25%" id="d21079e2916" headers="d21079e2755 ">
                                       <p><code class="codeph">DISPLAY_SQL_PLAN_BASELINE</code></p>
                                    </td>
                                    <td align="left" valign="top" width="75%" headers="d21079e2916 d21079e2758 ">
                                       <p><span>此表函数显示SQL计划基准的指定SQL句柄的一个或多个执行计划。</span></p>
                                       <p>此功能使用存储在计划基准中的计划信息来解释和显示计划。所述<code class="codeph">plan_id</code>存储在SQL管理基础可能不匹配<code class="codeph">plan_id</code>生成的计划。存储的<code class="codeph">plan_id</code>与生成的<code class="codeph">plan_id</code>之间的不匹配意味着它是不可重现的计划。这样的计划被认为是无效的，并且在SQL编译期间被优化器绕过。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="25%" id="d21079e2939" headers="d21079e2755 ">
                                       <p><code class="codeph">DISPLAY_SQLSET</code></p>
                                    </td>
                                    <td align="left" valign="top" width="75%" headers="d21079e2939 d21079e2758 ">
                                       <p><span>此表函数显示存储在SQL调优集中的给定语句的执行计划。</span></p>
                                       <p><code class="codeph">format</code>参数控制计划的级别。它接受值<code class="codeph">BASIC</code> ， <code class="codeph">TYPICAL</code> ， <code class="codeph">SERIAL</code>和<code class="codeph">ALL</code> 。</p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <div class="section"></div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-2C3C060E-1E16-4075-BA08-37148F0BFDFA__GUID-C6E97A92-5673-43E0-A386-FD30DB280405">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="../arpls/DBMS_SQLTUNE.html#ARPLS68408" target="_blank"><span><cite>Oracle Database PL / SQL包和类型参考，</cite></span></a>以了解有关<code class="codeph">DBMS_XPLAN</code>显示功能的更多信息</p>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="generating-and-displaying-execution-plans.html#GUID-5E88AD7F-D5FF-4003-B721-9126352CE414" title="要显示计划表输出，可以使用SQL脚本或DBMS_XPLAN包。">关于PLAN_TABLE输出的显示</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TGSQL285"></a><a id="TGSQL284"></a><div class="props_rev_3"><a id="GUID-955B4D41-EB27-44FE-A9E2-8C42835B652D" name="GUID-955B4D41-EB27-44FE-A9E2-8C42835B652D"></a><h5 id="TGSQL-GUID-955B4D41-EB27-44FE-A9E2-8C42835B652D" class="sect5"><span class="enumeration_section">6.3.1.2与</span>计划相关的视图</h5>
                     <div>
                        <p>您可以通过查询动态性能和数据字典视图来获取有关执行计划的信息。</p>
                        <div class="section">
                           <div class="tblformal" id="GUID-955B4D41-EB27-44FE-A9E2-8C42835B652D__CEGJADJA">
                              <p class="titleintable">表6-2执行计划视图</p>
                              <table cellpadding="4" cellspacing="0" class="Formal" title="执行计划视图" width="100%" border="1" summary="This 2 column table describes execution plan views. Column 1 is the view. Column 2 describes that view. " frame="hsides" rules="rows">
                                 <thead>
                                    <tr align="left" valign="top">
                                       <th align="left" valign="bottom" width="41%" id="d21079e3118">视图</th>
                                       <th align="left" valign="bottom" width="59%" id="d21079e3121">描述</th>
                                    </tr>
                                 </thead>
                                 <tbody>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="41%" id="d21079e3126" headers="d21079e3118 ">
                                          <p><code class="codeph">V $ SQL</code></p>
                                       </td>
                                       <td align="left" valign="top" width="59%" headers="d21079e3126 d21079e3121 ">
                                          <p>列出游标的统计信息，并为输入的原始SQL文本的每个子项包含一行。</p>
                                          <p>从<span>Oracle Database 19c开始</span> ， <code class="codeph">V$SQL.QUARANTINED</code>指示资源管理器是否已终止语句，因为该语句消耗了太多资源。Oracle数据库记录并标记隔离的计划，并阻止执行使用这些计划的语句。<code class="codeph">AVOIDED_EXECUTIONS</code>列指示由于隔离语句而尝试但阻止的执行次数。
                                          </p>
                                       </td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="41%" id="d21079e3145" headers="d21079e3118 ">
                                          <p><code class="codeph">V $ SQL_SHARED_CURSOR</code></p>
                                       </td>
                                       <td align="left" valign="top" width="59%" headers="d21079e3145 d21079e3121 ">
                                          <p>解释为什么不与现有子游标共享特定子游标的原因。每列标识无法共享游标的特定原因。</p>
                                          <p><code class="codeph">USE_FEEDBACK_STATS</code>列显示子游标是否因重新优化而无法匹配。
                                          </p>
                                       </td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="41%" id="d21079e3158" headers="d21079e3118 ">
                                          <p><code class="codeph">V $ SQL_PLAN</code></p>
                                       </td>
                                       <td align="left" valign="top" width="59%" headers="d21079e3158 d21079e3121 ">
                                          <p>包含存储在共享SQL区域中的每个语句的计划。</p>
                                          <p>视图定义类似于<code class="codeph">PLAN_TABLE</code> 。该视图包含所有最终计划中出现的所有行的超集。<code class="codeph">PLAN_LINE_ID</code>是连续编号的，但对于单个最终计划，ID可能不是连续的。
                                          </p>
                                          <p>作为<code class="codeph">EXPLAIN PLAN</code>的替代方法，您可以通过查询<code class="codeph">V$SQL_PLAN</code>来显示计划。 <code class="codeph">V$SQL_PLAN</code>优于<code class="codeph">EXPLAIN PLAN</code>的优点是您不需要知道用于执行特定语句的编译环境。对于<code class="codeph">EXPLAIN PLAN</code> ，您需要设置一个相同的环境以在执行语句时获得相同的计划。
                                          </p>
                                       </td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="41%" id="d21079e3191" headers="d21079e3118 ">
                                          <p><code class="codeph">V $ SQL_PLAN_STATISTICS</code></p>
                                       </td>
                                       <td align="left" valign="top" width="59%" headers="d21079e3191 d21079e3121 ">
                                          <p>提供计划中每个操作的实际执行统计信息，例如输出行数和已用时间。除输出行数外，所有统计信息都是累积的。例如，连接操作的统计信息还包括其两个输入的统计信息。<code class="codeph">V$SQL_PLAN_STATISTICS</code>中的统计信息可用于已使用设置为<code class="codeph">ALL</code>的<code class="codeph">STATISTICS_LEVEL</code>初始化参数编译的游标。</p>
                                       </td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="41%" id="d21079e3208" headers="d21079e3118 ">
                                          <p><code class="codeph">V $ SQL_PLAN_STATISTICS_ALL</code></p>
                                       </td>
                                       <td align="left" valign="top" width="59%" headers="d21079e3208 d21079e3121 ">
                                          <p>包含使用SQL内存（排序或散列连接）的行源的内存使用情况统计信息。此视图将<code class="codeph">V$SQL_PLAN</code>信息与<code class="codeph">V$SQL_PLAN_STATISTICS</code>和<code class="codeph">V$SQL_WORKAREA</code>执行统计信息连接<code class="codeph">V$SQL_WORKAREA</code> 。</p>
                                          <p><code class="codeph">V$SQL_PLAN_STATISTICS_ALL</code>可以对优化程序为行数和已用时间提供的估计值进行并排比较。该视图结合了每个游标的<code class="codeph">V$SQL_PLAN</code>和<code class="codeph">V$SQL_PLAN_STATISTICS</code>信息。
                                          </p>
                                       </td>
                                    </tr>
                                 </tbody>
                              </table>
                           </div>
                           <!-- class="inftblhruleinformal" -->
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-955B4D41-EB27-44FE-A9E2-8C42835B652D__GUID-5DA25729-85FE-4E7C-8A5B-6FBF826F8A85">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><span class="q">“ <a href="optimizer-ref.html#GUID-5AE1939F-F654-42FF-B0C5-706507CD12A2" title="PLAN_TABLE由EXPLAIN PLAN语句填充。">PLAN_TABLE列</a> ”</span></p>
                              </li>
                              <li>
                                 <p><span class="q">“ <a href="monitoring-database-operations.html#GUID-C941CE9D-97E1-42F8-91ED-4949B2B710BF" title="本章介绍如何监视SQL和PL / SQL。">监视数据库操作</a> ”</span>以获取有关<code class="codeph">V$SQL_PLAN_MONITOR</code>视图的信息</p>
                              </li>
                              <li>
                                 <p>有关<code class="codeph">V$SQL_PLAN</code>视图的更多信息，请<a href="../refrn/V-SQL_PLAN.html#REFRN-GUID-87561B21-721C-42EB-8E3D-28251C9BC50C" target="_blank"><span><cite>参见Oracle数据库参考</cite></span></a></p>
                              </li>
                              <li>
                                 <p>有关<code class="codeph">STATISTICS_LEVEL</code>初始化参数的信息，请<a href="../refrn/STATISTICS_LEVEL.html#REFRN-GUID-16B23F95-8644-407A-A6C8-E85CADFA61FF" target="_blank"><span><cite>参见Oracle数据库参考</cite></span></a></p>
                              </li>
                           </ul>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="generating-and-displaying-execution-plans.html#GUID-5E88AD7F-D5FF-4003-B721-9126352CE414" title="要显示计划表输出，可以使用SQL脚本或DBMS_XPLAN包。">关于PLAN_TABLE输出的显示</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="TGSQL94710"></a><a id="TGSQL94711"></a><a id="TGSQL94712"></a><a id="TGSQL277"></a><div class="props_rev_3"><a id="GUID-1FA56307-047B-42BB-AF17-3B05F1814559" name="GUID-1FA56307-047B-42BB-AF17-3B05F1814559"></a><h4 id="TGSQL-GUID-1FA56307-047B-42BB-AF17-3B05F1814559" class="sect4"><span class="enumeration_section">6.3.2</span>显示执行计划：基本步骤</h4>
                  <div>
                     <p><code class="codeph">DBMS_XPLAN.DISPLAY</code>函数是显示已解释计划的简单方法。
                     </p>
                     <div class="section">
                        <p>默认情况下， <code class="codeph">DISPLAY</code>函数使用<code class="codeph">TYPICAL</code>的格式设置。在这种情况下，计划是计划中最相关的信息：操作ID，名称和选项，行，字节和优化器成本。仅在适用时显示修剪，并行和谓词信息。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-1FA56307-047B-42BB-AF17-3B05F1814559__GUID-9783646C-282C-4335-AE7D-DE214B14CABC">要显示执行计划：</p>
                        <ol>
                           <li>
                              <p>启动SQL * Plus或SQL Developer并登录到解释该计划的会话。</p>
                           </li>
                           <li>
                              <p>解释一个计划。</p>
                           </li>
                           <li>
                              <p>使用<code class="codeph">DBMS_XPLAN.DISPLAY</code>查询<code class="codeph">PLAN_TABLE</code> 。</p>
                              <p>按如下方式指定查询：</p><pre class="pre codeblock"><code>从TABLE中选择PLAN_TABLE_OUTPUT（DBMS_XPLAN.DISPLAY）;</code></pre><p>或者，使用<code class="codeph">statement_id</code>参数指定语句ID：</p><pre class="pre codeblock"><code>从TABLE中选择PLAN_TABLE_OUTPUT（DBMS_XPLAN.DISPLAY（statement_id =&gt;' <span class="italic">statement_id</span> ））;</code></pre></li>
                        </ol>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-1FA56307-047B-42BB-AF17-3B05F1814559__CEGCJACH">
                        <p class="titleinexample">示例6-2语句ID ex_plan1的EXPLAIN PLAN</p>
                        <p>此示例说明了使用语句ID <code class="codeph">ex_plan1</code>的<code class="codeph">employees</code>查询，然后查询<code class="codeph">PLAN_TABLE</code> ：</p><pre class="pre codeblock"><code>EXPLAIN PLAN SET statement_id ='ex_plan1'FOR SELECT phone_number FROM employees WHERE phone_number LIKE'650％';从TABLE中选择PLAN_TABLE_OUTPUT（DBMS_XPLAN.DISPLAY（statement_id =&gt;'ex_plan1'））;</code></pre><p>示例输出显示如下：</p><pre class="pre codeblock"><code>计划哈希值：1445457117 --------------------------------------------- ---------------------------------- | Id |操作|名称|行|字节|成本（％CPU）|时间| -------------------------------------------------- ----------------------------- | 0 |选择声明| | 1 | 15 | 2（0）| 00:00:01 | | * 1 |表访问完全|员工| 1 | 15 | 2（0）| 00:00:01 | -------------------------------------------------- -----------------------------谓词信息（由操作ID标识）：------------ --------------------------------------- 1  - 过滤器（“PHONE_NUMBER”LIKE'650％ “）</code></pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-1FA56307-047B-42BB-AF17-3B05F1814559__GUID-2E0342FE-ABA2-48D0-9E12-20AD0A8A7CE4">
                        <p class="titleinexample">示例6-3语句ID ex_plan2的EXPLAIN PLAN</p>
                        <p>此示例说明了使用语句ID <code class="codeph">ex_plan2</code>的<code class="codeph">employees</code>查询，然后使用<code class="codeph">BASIC</code>格式显示计划：</p><pre class="pre codeblock"><code>EXPLAIN PLAN SET statement_id ='ex_plan2'FOR SELECT last_name FROM employees WHERE last_name LIKE'Pe％';从TABLE中选择PLAN_TABLE_OUTPUT（DBMS_XPLAN.DISPLAY（NULL，'ex_plan2'，'BASIC'））;</code></pre><p>示例输出显示如下：</p><pre class="pre codeblock"><code>---------------------------------------- | Id |操作|名称| ---------------------------------------- | 0 |选择声明| | | 1 | INDEX RANGE SCAN | EMP_NAME_IX | ----------------------------------------</code></pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-1FA56307-047B-42BB-AF17-3B05F1814559__GUID-64C544C6-F43E-4AD8-A1C2-AE0837615EF9">
                        <p class="notep1">也可以看看：</p>
                        <p>有关<code class="codeph">DBMS_XPLAN</code>包的更多信息，请<code class="codeph">DBMS_XPLAN</code> <a href="../arpls/DBMS_XPLAN.html#GUID-BAD480AA-351A-48FE-A8E7-F0D8EF643EBF" target="_blank"><span><cite>Oracle Database PL / SQL包和类型参考</cite></span></a></p>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="generating-and-displaying-execution-plans.html#GUID-725CADF8-3803-416F-96EB-BF942F742663" title="显示执行计划的最简单方法是使用DBMS_XPLAN显示功能或V $视图。">显示执行计划</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="TGSQL94855"></a><a id="TGSQL94856"></a><a id="TGSQL94857"></a><a id="TGSQL94854"></a><div class="props_rev_3"><a id="GUID-83F88700-3902-4D19-8182-AF2B92AEA7EB" name="GUID-83F88700-3902-4D19-8182-AF2B92AEA7EB"></a><h4 id="TGSQL-GUID-83F88700-3902-4D19-8182-AF2B92AEA7EB" class="sect4"><span class="enumeration_section">6.3.3</span>显示自适应查询计划：教程</h4>
                  <div>
                     <p><strong class="term">自适应优化器</strong>是<strong class="term">优化器</strong>的一项功能，使其能够根据运行时统计信息调整计划。所有自适应机制都可以执行与默认计划不同的语句的最终计划。
                     </p>
                     <div class="section">
                        <p><a href="glossary.html#GUID-5E4FD63A-4143-48FF-B8ED-9D953B8A6D40"><span class="xrefglossterm">自适应查询计划</span></a> <span class="italic">在</span>当前语句执行<span class="italic">期间</span>选择子<a href="glossary.html#GUID-5E4FD63A-4143-48FF-B8ED-9D953B8A6D40"><span class="xrefglossterm">计划</span></a> 。相反， <a href="glossary.html#GUID-70FBCF66-F29E-4ADE-BEA8-F328917A2986"><span class="xrefglossterm">自动重新优化</span></a>仅在当前语句执行<span class="italic">后</span>发生的执行中更改计划。
                        </p>
                        <p>您可以根据计划的<code class="codeph">Notes</code>部分中的<code class="codeph">Notes</code>确定数据库是否对SQL语句使用自适应查询优化。评论表明行源是动态的，还是自动重新优化是否适应了计划。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-83F88700-3902-4D19-8182-AF2B92AEA7EB__GUID-0E629273-B74D-4E09-BB79-C79169436C8B">假设</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>本教程假设以下内容：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">STATISTICS_LEVEL</code>初始化参数设置为<code class="codeph">ALL</code> 。</p>
                           </li>
                           <li>
                              <p>数据库使用默认设置进行自适应执行。</p>
                           </li>
                           <li>
                              <p>作为用户<code class="codeph">oe</code> ，您希望发出以下单独的查询：</p><pre class="pre codeblock"><code>SELECT o.order_id，v.product_name FROM orders o，（SELECT order_id，product_name FROM order_items o，product_information p WHERE p.product_id = o.product_id AND list_price &lt;50 AND min_price &lt;40）v WHERE o.order_id = v.order_id SELECT product_name FROM order_items o，product_information p WHERE o.unit_price = 15 AND quantity&gt; 1 AND p.product_id = o.product_id</code></pre></li>
                           <li>
                              <p>在执行每个查询之前，您需要查询<code class="codeph">DBMS_XPLAN.DISPLAY_PLAN</code>以查看默认计划，即优化程序在应用其自适应机制之前选择的计划。
                              </p>
                           </li>
                           <li>
                              <p>执行每个查询后，您需要查询<code class="codeph">DBMS_XPLAN.DISPLAY_CURSOR</code>以查看最终计划和自适应查询计划。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">SYS</code>授予<code class="codeph">oe</code>以下特权：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p><code class="codeph">授予V_ $ SESSION到oe的选择权</code></p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">GRANT SELECT ON V_ $ SQL to oe</code></p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">GRANT SELECT on V_ $ SQL_PLAN to oe</code></p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">GRANT SELECT on V_ $ SQL_PLAN_STATISTICS_ALL to oe</code></p>
                                 </li>
                              </ul>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-83F88700-3902-4D19-8182-AF2B92AEA7EB__GUID-736704A9-2856-46B9-B799-BC30AEB87469">要查看自适应优化的结果：</p>
                        <ol>
                           <li>
                              <p>启动SQL * Plus，然后以用户<code class="codeph">oe</code>身份连接到数据库。
                              </p>
                           </li>
                           <li id="GUID-83F88700-3902-4D19-8182-AF2B92AEA7EB__CEGEDCCC">
                              <p>查询<code class="codeph">orders</code> 。
                              </p>
                              <p>例如，使用以下语句：</p><pre class="pre codeblock"><code>SELECT o.order_id，v.product_name FROM orders o，（SELECT order_id，product_name FROM order_items o，product_information p WHERE p.product_id = o.product_id AND list_price &lt;50 AND min_price &lt;40）v WHERE o.order_id = v.order_id;</code></pre></li>
                           <li id="GUID-83F88700-3902-4D19-8182-AF2B92AEA7EB__CEGCEJFA">
                              <p>在光标中查看计划。</p>
                              <p>例如，运行以下命令：</p><pre class="pre codeblock"><code>SET LINESIZE 165 SET PAGESIZE 0 SELECT * FROM TABLE（DBMS_XPLAN.DISPLAY_CURSOR（FORMAT =&gt;'+ ALLSTATS'））;</code></pre><p>以下示例输出已重新格式化以适合页面。在此计划中，优化程序选择嵌套循环连接。原始优化程序估计值显示在<code class="codeph">E-Rows</code>列中，而执行期间收集的实际统计数据显示在<code class="codeph">A-Rows</code>列中。在<code class="codeph">MERGE JOIN</code>操作中，估计行数和实际行数之间的差异很大。
                              </p><pre class="pre codeblock"><code>-------------------------------------------------- ------------------------------------------ | Id |操作|名称|开始<span class="bold">| E-Rows | A-Rows |</span> A-时间|浅黄色| OMEM | 1Mem | O / 1 / M | -------------------------------------------------- ------------------------------------------ | 0 |选择声明| | 1 | | 269 | 00：00：00.09 | 1338 | | | | | 1 | <span class="bold">NESTED LOOPS</span> | | 1 | 1 | 269 | 00：00：00.09 | 1338 | | | | | 2 | MERGE加入笛卡尔| | 1 | 4 | 9135 | 00：00：00.03 | 33 | | | | | * 3 |表访问已满| PRODUCT_INFORMAT | 1 | 1 | 87 | 00：00：00.01 | 32 | | | | | 4 | BUFFER SORT | | 87 | 105 | 9135 | 00：00：00.01 | 1 | 4096 | 4096 | 1/0/0 | | 5 | INDEX全扫描| ORDER_PK | 1 | 105 | 105 | 00：00：00.01 | 1 | | | | | * 6 | INDEX UNIQUE SCAN | ORDER_ITEMS_UK | 9135 | 1 | 269 | 00：00：00.03 | 1305 | | | | -------------------------------------------------- ------------------------------------------谓词信息（由操作ID标识） ：------------------------------------------------- -  3  -  filter（（“MIN_PRICE”&lt;40 AND“LIST_PRICE”&lt;50））6  - 访问（“O”。“ORDER_ID”=“ORDER_ID”和“P”。“PRODUCT_ID”=“O”。“PRODUCT_ID “）</code></pre></li>
                           <li>
                              <p>运行您在步骤2中运行的<code class="codeph">orders</code>的相同查询。
                              </p>
                           </li>
                           <li>
                              <p>使用在步骤3中运行的相同<code class="codeph">SELECT</code>语句查看游标中的执行计划。
                              </p>
                              <p>以下示例显示优化程序使用散列连接选择了不同的计划。Note部分显示优化程序使用统计信息反馈来调整第二次执行查询的成本估算，从而说明自动重新优化。</p><pre class="pre codeblock"><code>-------------------------------------------------- ------------------------------------------ | Id |操作|名称|开始|电子行| A行| A-Time | Buff |读取| OMem | 1Mem | O / 1 / M | -------------------------------------------------- ------------------------------------------ | 0 |选择声明| | 1 | | 269 | 00：00：00.02 | 60 | 1 | | | | | 1 | NESTED LOOPS | | 1 | 269 | 269 | 00：00：00.02 | 60 | 1 | | | | | * 2 | <span class="bold">HASH JOIN</span> | | 1 | 313 | 269 | 00：00：00.02 | 39 | 1 | 1000K | 1000K | 1/0/0 | | * 3 |表访问已满| PRODUCT_INFORMA | 1 | 87 | 87 | 00：00：00.01 | 15 | 0 | | | | | 4 | INDEX FAST FULL SCAN | ORDER_ITEMS_UK | 1 | 665 | 665 | 00：00：00.01 | 24 | 1 | | | | | * 5 | INDEX UNIQUE SCAN | ORDER_PK | 269 | 1 | 269 | 00：00：00.01 | 21 | 0 | | | | -------------------------------------------------- ------------------------------------------谓词信息（由操作ID标识） ：------------------------------------------------- -  2  - 访问（“P”。“PRODUCT_ID”=“O”。“PRODUCT_ID”）3  - 过滤器（（“MIN_PRICE”&lt;40 AND“LIST_PRICE”&lt;50））5  - 访问（“O”。“ORDER_ID “=”ORDER_ID“）注意-----  - <span class="bold">用于此语句的统计信息反馈</span>
</code></pre></li>
                           <li>
                              <p>查询<code class="codeph">V$SQL</code>以验证性能改进。
                              </p>
                              <p>以下查询显示了两个语句的性能（包括示例输出）。</p><pre class="pre codeblock"><code>SELECT CHILD_NUMBER，CPU_TIME，ELAPSED_TIME，BUFFER_GETS FROM V $ SQL WHERE SQL_ID ='gm2npz344xqn8'; CHILD_NUMBER CPU_TIME ELAPSED_TIME BUFFER_GETS ------------ ---------- ------------ ----------- 0 92006 131485 1831 1 12000 24156 60</code></pre><p>执行的第二个语句，即子号<code class="codeph">1</code> ，使用统计反馈。CPU时间，经过时间和缓冲区获取都显着降低。
                              </p>
                           </li>
                           <li>
                              <p>解释<code class="codeph">order_items</code>查询的计划。
                              </p>
                              <p>例如，使用以下语句：</p><pre class="pre codeblock"><code>EXPLAIN PLAN FOR SELECT product_name FROM order_items o，product_information p WHERE o.unit_price = 15 AND quantity&gt; 1 AND p.product_id = o.product_id</code></pre></li>
                           <li>
                              <p>在计划表中查看计划。</p>
                              <p>例如，运行以下语句：</p><pre class="pre codeblock"><code>SELECT * FROM TABLE（DBMS_XPLAN.DISPLAY）;</code></pre><p>示例输出显示如下：</p><pre class="pre codeblock"><code>-------------------------------------------------- ----------------------------- | Id |操作|名称|行|字节|成本（％CPU）|时间| -------------------------------------------------- ----------------------------- | 0 |选择声明| | 4 | 128 | 7（0）| 00:00:01 | | 1 | NESTED LOOPS | | | | | | | 2 | NESTED LOOPS | | 4 | 128 | 7（0）| 00:00:01 | | * 3 | TABLE ACCESS FULL | ORDER_ITEMS | 4 | 48 | 3（0）| 00:00:01 | | * 4 | INDEX UNIQUE SCAN | PRODUCT_INFORMATION_PK | 1 | | 0（0）| 00:00：01 | | 5 |按行索引表访问权限| PRODUCT_INFORMATION | 1 | 20 | 1（0）| 00:00:01 | -------------------------------------------------- -----------------------------谓词信息（由操作ID标识）：------------ --------------------------------------- 3  -  filter（“O”。“UNIT_PRICE” = 15 AND“QUANTITY”&gt; 1）4  - 访问（“P”。“PRODUCT_ID”=“O”。“PRODUCT_ID”）</code></pre><p>在此计划中，优化程序选择嵌套循环连接。</p>
                           </li>
                           <li>
                              <p>运行您之前解释过的查询。</p>
                              <p>例如，使用以下语句：</p><pre class="pre codeblock"><code>SELECT product_name FROM order_items o，product_information p WHERE o.unit_price = 15 AND quantity&gt; 1 AND p.product_id = o.product_id</code></pre></li>
                           <li>
                              <p>在光标中查看计划。</p>
                              <p>例如，运行以下命令：</p><pre class="pre codeblock"><code>SET LINESIZE 165 SET PAGESIZE 0 SELECT * FROM TABLE（DBMS_XPLAN.DISPLAY（FORMAT =&gt;'+ ADAPTIVE'））;</code></pre><p>样本输出如下所示。根据运行时收集的统计信息（步骤4），优化器选择散列连接而不是嵌套循环连接。破折号（ <code class="codeph">-</code> ）表示优化程序考虑但最终不会选择的嵌套循环计划中的步骤。该开关说明了自适应查询计划功能。
                              </p><pre class="pre codeblock"><code>-------------------------------------------------- ----------------------------- | Id |操作|名称|行|字节|成本（％CPU）|时间| -------------------------------------------------- ----------------------------- | 0 |选择声明| | 4 | 128 | 7（0）| 00：00：01 | | * 1 | HASH JOIN | | 4 | 128 | 7（0）| 00：00：01 | |  -  2 | NESTED LOOPS | | | | | | |  -  3 | NESTED LOOPS | | | 128 | 7（0）| 00：00：01 | |  -  4 | <span class="bold">统计收集者</span> | | | | | | | * 5 |表访问完全| ORDER_ITEMS | 4 | 48 | 3（0）| 00：00：01 | |  -  * 6 | INDEX UNIQUE SCAN | PRODUCT_INFORMATI_PK | 1 | | 0（0）| 00：00：01 | |  -  7 |按INDEX ROWID表的访问权限| PRODUCT_INFORMATION | 1 | 20 | 1（0）| 00：00：01 | | 8 |表访问完全| PRODUCT_INFORMATION | 1 | 20 | 1（0）| 00：00：01 | -------------------------------------------------- -----------------------------谓词信息（由操作ID标识）：------------ --------------------------------------- 1  -  access（“P”。“PRODUCT_ID” =“O”。“PRODUCT_ID”）5  - 过滤器（“O”。“UNIT_PRICE”= 15 AND“QUANTITY”&gt; 1）6  - 访问（“P”。“PRODUCT_ID”=“O”。“PRODUCT_ID”）注意-----  - <span class="bold">这是一个自适应计划（标有' - '的行不活动）</span></code></pre></li>
                        </ol>
                     </div>
                     <!-- class="section" -->
                     <div class="section"></div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-83F88700-3902-4D19-8182-AF2B92AEA7EB__GUID-83F902F5-DC23-45B7-B771-7207B505F555">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><span class="q">“ <a href="query-optimizer-concepts.html#GUID-5A1EB094-1A9E-4B69-9BE5-39BDA2B3253C" title="自适应查询计划使优化器能够在执行期间为语句做出计划决策。">自适应查询计划</a> ”</span></p>
                           </li>
                           <li>
                              <p><span class="q">“ <a href="generating-and-displaying-execution-plans.html#GUID-2C3C060E-1E16-4075-BA08-37148F0BFDFA__CEGCBHGJ" title="该2列表描述了DBMS_XPLAN程序单元。第1列列出了这些功能。第2列提供了有关这些功能的更多信息。">表6-1</a> ”</span></p>
                           </li>
                           <li>
                              <p><span class="q">“ <a href="influencing-the-optimizer.html#GUID-DAFB7D07-E8B3-4219-A09D-214BD943AFF9" title="在Oracle数据库中，自适应查询优化是优化程序根据运行时收集的统计信息调整执行计划的过程。">控制自适应优化</a> ”</span></p>
                           </li>
                           <li>
                              <p><a href="../refrn/STATISTICS_LEVEL.html#REFRN10214" target="_blank"><span class="italic">Oracle Database Reference</span></a>了解<code class="codeph">STATISTICS_LEVEL</code>初始化参数</p>
                           </li>
                           <li>
                              <p><a href="../arpls/DBMS_SQLTUNE.html#ARPLS68408" target="_blank"><span class="italic">Oracle Database PL / SQL包和类型参考</span></a>以了解有关<code class="codeph">DBMS_XPLAN</code>更多信息</p>
                           </li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="generating-and-displaying-execution-plans.html#GUID-725CADF8-3803-416F-96EB-BF942F742663" title="显示执行计划的最简单方法是使用DBMS_XPLAN显示功能或V $视图。">显示执行计划</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="sect3"><a id="GUID-90411427-FDD7-4196-A52A-84D153CE37C1" name="GUID-90411427-FDD7-4196-A52A-84D153CE37C1"></a><h4 id="TGSQL-GUID-90411427-FDD7-4196-A52A-84D153CE37C1" class="sect4"><span class="enumeration_section">6.3.4</span>显示执行计划：示例</h4>
                  <div>
                     <p>这些示例显示了显示执行计划的不同方式。</p>
                     <p>本节包含以下主题：</p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="generating-and-displaying-execution-plans.html#GUID-51E46694-0C6B-4FDA-8C2F-0D7D7536D5F8">自定义PLAN_TABLE输出</a><br>如果已指定语句标识符，则可以编写自己的脚本来查询<code class="codeph">PLAN_TABLE</code> 。</li>
                        <li class="ulchildlink"><a href="generating-and-displaying-execution-plans.html#GUID-22F3C307-95C3-47EE-A3FD-545F614947CB">显示并行执行计划：示例</a><br>并行查询的计划与串行查询的计划有很大不同。
                        </li>
                        <li class="ulchildlink"><a href="generating-and-displaying-execution-plans.html#GUID-CE8BCA2D-47B5-4FBD-95A9-5096A5734063">显示位图索引计划：示例</a><br>使用位图索引的索引行源显示在<code class="codeph">EXPLAIN PLAN</code>输出中，并带有指示索引类型的单词<code class="codeph">BITMAP</code> 。
                        </li>
                        <li class="ulchildlink"><a href="generating-and-displaying-execution-plans.html#GUID-FE0B82DA-1A06-4145-B03D-A1C39DB1F88F">显示结果缓存计划：示例</a><br>当您的查询包含<code class="codeph">result_cache</code>提示时， <code class="codeph">ResultCache</code>运算符将插入执行计划中。
                        </li>
                        <li class="ulchildlink"><a href="generating-and-displaying-execution-plans.html#GUID-37DF6780-3279-47CE-93E6-BE922F1451EF">显示分区对象的计划：示例</a><br>使用<code class="codeph">EXPLAIN PLAN</code>确定Oracle数据库如何访问特定查询的分区对象。
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="generating-and-displaying-execution-plans.html#GUID-725CADF8-3803-416F-96EB-BF942F742663" title="显示执行计划的最简单方法是使用DBMS_XPLAN显示功能或V $视图。">显示执行计划</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="TGSQL94709"></a><div class="props_rev_3"><a id="GUID-51E46694-0C6B-4FDA-8C2F-0D7D7536D5F8" name="GUID-51E46694-0C6B-4FDA-8C2F-0D7D7536D5F8"></a><h5 id="TGSQL-GUID-51E46694-0C6B-4FDA-8C2F-0D7D7536D5F8" class="sect5"><span class="enumeration_section">6.3.4.1</span>自定义PLAN_TABLE输出</h5>
                     <div>
                        <p>如果已指定语句标识符，则可以编写自己的脚本来查询<code class="codeph">PLAN_TABLE</code> 。</p>
                        <div class="section">
                           <p>例如：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>从ID = 0开始并给出<code class="codeph">STATEMENT_ID</code> 。</p>
                              </li>
                              <li>
                                 <p>使用<code class="codeph">CONNECT BY</code>子句将树从父级传递到子级，连接键为<code class="codeph">STATEMENT_ID = PRIOR STATMENT_ID</code>和<code class="codeph">PARENT_ID = PRIOR ID</code> 。</p>
                              </li>
                              <li>
                                 <p>使用伪列<code class="codeph">LEVEL</code> （与<code class="codeph">CONNECT BY</code>关联）缩进子项。
                                 </p><pre class="pre codeblock"><code>SELECT基数“Rows”，lpad（''，level-1）|| operation ||' '||选项||' '|| object_name“计划”FROM PLAN_TABLE CONNECT BY先前的id = parent_id AND previous statement_id = statement_id START WITH id = 0 AND statement_id ='st1'ORDER BY id;行计划------- ---------------------------------------- SELECT声明表访问全体员工</code></pre><p>“ <code class="codeph">Rows</code>列中的<code class="codeph">NULL</code>表示优化程序没有关于表的任何统计信息。分析表格显示以下内容：</p><pre class="pre codeblock"><code>行计划------- ---------------------------------------- 16957选择声明16957表访问全体员工</code></pre><p>您也可以选择<code class="codeph">COST</code> 。这对于比较执行计划或理解优化程序为何选择一个执行计划而非另一个执行计划非常有用。
                                 </p>
                                 <div class="infoboxnote" id="GUID-51E46694-0C6B-4FDA-8C2F-0D7D7536D5F8__GUID-42DE2A10-328A-49B3-9B35-B8DA225B6B7C">
                                    <p class="notep1">注意：</p>
                                    <p>这些简化示例对递归SQL无效。</p>
                                 </div>
                              </li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="generating-and-displaying-execution-plans.html#GUID-90411427-FDD7-4196-A52A-84D153CE37C1" title="这些示例显示了显示执行计划的不同方式。">显示执行计划：示例</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TGSQL94713"></a><div class="props_rev_3"><a id="GUID-22F3C307-95C3-47EE-A3FD-545F614947CB" name="GUID-22F3C307-95C3-47EE-A3FD-545F614947CB"></a><h5 id="TGSQL-GUID-22F3C307-95C3-47EE-A3FD-545F614947CB" class="sect5"><span class="enumeration_section">6.3.4.2</span>显示并行执行计划：示例</h5>
                     <div>
                        <p>并行查询的计划与串行查询的计划有很大不同。</p>
                        <p>本节包含以下主题：</p>
                     </div>
                     <div>
                        <ul class="ullinks">
                           <li class="ulchildlink"><a href="generating-and-displaying-execution-plans.html#GUID-029E861E-50C7-4E64-BE47-5B34F6ADA86A">关于EXPLAIN PLAN和并行查询</a><br>通过选择驱动表，调整并行查询非常类似于非并行查询调优练习。但是，管理选择的规则是不同的。
                           </li>
                           <li class="ulchildlink"><a href="generating-and-displaying-execution-plans.html#GUID-ED34B100-C281-4100-9F4B-38C40B4A4ECE">使用EXPLAIN PLAN查看并行查询：示例</a><br>将<code class="codeph">EXPLAIN PLAN</code>与并行查询一起使用时，数据库将编译并执行一个并行计划。此计划源自串行计划，通过在QC计划中分配特定于并行支持的行源。
                           </li>
                        </ul>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="generating-and-displaying-execution-plans.html#GUID-90411427-FDD7-4196-A52A-84D153CE37C1" title="这些示例显示了显示执行计划的不同方式。">显示执行计划：示例</a></p>
                           </div>
                        </div>
                     </div>
                     <a id="TGSQL94714"></a><div class="props_rev_3"><a id="GUID-029E861E-50C7-4E64-BE47-5B34F6ADA86A" name="GUID-029E861E-50C7-4E64-BE47-5B34F6ADA86A"></a><h6 id="TGSQL-GUID-029E861E-50C7-4E64-BE47-5B34F6ADA86A" class="sect6"><span class="enumeration_section">6.3.4.2.1</span>关于EXPLAIN PLAN和并行查询</h6>
                        <div>
                           <p>通过选择驱动表，调整并行查询非常类似于非并行查询调优练习。但是，管理选择的规则是不同的。</p>
                           <p>在串行情况下，最佳驱动表在应用限制条件后产生最少的行数。数据库使用非唯一索引将少量行连接到较大的表。</p>
                           <p>例如，考虑一个由<code class="codeph">customer</code> ， <code class="codeph">account</code>和<code class="codeph">transaction</code>组成的表层次结构。
                           </p>
                           <div class="figure" id="GUID-029E861E-50C7-4E64-BE47-5B34F6ADA86A__GUID-F83F6CF6-70FD-4DDB-98D5-72870DEF5E70">
                              <p class="titleinfigure">图6-1表层次结构</p><img src="img/pfgrf211.gif" alt="下面是图6-1的描述" title="下面是图6-1的描述" longdesc="img_text/pfgrf211.html"><br><a href="img_text/pfgrf211.html">“图6-1表层次结构”的描述</a></div>
                           <!-- class="figure" -->
                           <p>在此示例中， <code class="codeph">customer</code>是最小的表，而<code class="codeph">transaction</code>是最大的表。典型的OLTP查询检索有关特定客户帐户的交易信息。查询从<code class="codeph">customer</code>表驱动。目标是最小化逻辑I / O，这通常可以最小化其他关键资源，包括物理I / O和CPU时间。
                           </p>
                           <p>对于并行查询，驱动表通常是<span class="italic">最大的</span>表。在这种情况下使用并行查询效率不高，因为只访问每个表中的几行。但是，如果有必要确定上个月有某种类型交易的所有客户呢？从<code class="codeph">transaction</code>表驱动会更有效，因为<code class="codeph">customer</code>表上不存在限制条件。数据库会将<code class="codeph">transaction</code>表中的行连接到<code class="codeph">account</code>表，然后最终将结果集连接到<code class="codeph">customer</code>表。在这种情况下， <code class="codeph">account</code>和<code class="codeph">customer</code>表上使用的可能是高度选择性的主键或唯一索引，而不是第一个查询中使用的非唯一索引。由于<code class="codeph">transaction</code>表很大且列不是选择性的，因此从<code class="codeph">transaction</code>表中使用并行查询驱动将是有益的。
                           </p>
                           <p>并行操作包括以下内容：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">PARALLEL_TO_PARALLEL</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">PARALLEL_TO_SERIAL</code></p>
                                 <p><code class="codeph">PARALLEL_TO_SERIAL</code>操作始终是查询协调器使用并行操作中的行时发生的步骤。此查询中未发生的另一种操作是<code class="codeph">SERIAL</code>操作。如果发生这些类型的操作，则考虑将它们作为并行操作来提高性能，因为它们也是潜在的瓶颈。
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">PARALLEL_FROM_SERIAL</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">PARALLEL_TO_PARALLEL</code></p>
                                 <p>如果每个步骤中的工作负载相对等效，则<code class="codeph">PARALLEL_TO_PARALLEL</code>操作通常会产生最佳性能。
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">PARALLEL_COMBINED_WITH_CHILD</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">PARALLEL_COMBINED_WITH_PARENT</code></p>
                                 <p>当数据库与父步骤同时执行步骤时，会发生<code class="codeph">PARALLEL_COMBINED_WITH_PARENT</code>操作。
                                 </p>
                              </li>
                           </ul>
                           <p>如果并行步骤产生许多行，则QC可能无法像生成行一样快地消耗行。没有什么可以改善这种情况。</p>
                        </div>
                        <div>
                           <div class="infoboxnotealso" id="GUID-029E861E-50C7-4E64-BE47-5B34F6ADA86A__GUID-E0692402-F90F-4625-BD94-9841DBEE007F">
                              <p class="notep1">也可以看看：</p>
                              <p><span class="q">“ <a href="optimizer-ref.html#GUID-5AE1939F-F654-42FF-B0C5-706507CD12A2" title="PLAN_TABLE由EXPLAIN PLAN语句填充。">PLAN_TABLE列</a> ”中</span>的<code class="codeph">OTHER_TAG</code>列</p>
                           </div>
                           <div class="familylinks">
                              <div class="parentlink">
                                 <p><strong>父主题：</strong> <a href="generating-and-displaying-execution-plans.html#GUID-22F3C307-95C3-47EE-A3FD-545F614947CB" title="并行查询的计划与串行查询的计划有很大不同。">显示并行执行计划：示例</a></p>
                              </div>
                           </div>
                        </div>
                        
                     </div><a id="TGSQL94716"></a><a id="TGSQL94715"></a><div class="props_rev_3"><a id="GUID-ED34B100-C281-4100-9F4B-38C40B4A4ECE" name="GUID-ED34B100-C281-4100-9F4B-38C40B4A4ECE"></a><h6 id="TGSQL-GUID-ED34B100-C281-4100-9F4B-38C40B4A4ECE" class="sect6"><span class="enumeration_section">6.3.4.2.2</span>使用EXPLAIN PLAN查看并行查询：示例</h6>
                        <div>
                           <p>将<code class="codeph">EXPLAIN PLAN</code>与并行查询一起使用时，数据库将编译并执行一个并行计划。此计划源自串行计划，通过在QC计划中分配特定于并行支持的行源。
                           </p>
                           <div class="section">
                              <p>两个并行执行服务器集PQ模型所需的表队列行源（ <code class="codeph">PX</code> <code class="codeph">Send</code>和<code class="codeph">PX</code> <code class="codeph">Receive</code> ），粒度迭代器和缓冲区排序直接插入到并行计划中。该计划与并行执行时所有并行执行服务器的计划相同，或者在串行执行时与QC相同。
                              </p>
                           </div>
                           <!-- class="section" -->
                           <div class="example" id="GUID-ED34B100-C281-4100-9F4B-38C40B4A4ECE__CEGIFEAJ">
                              <p class="titleinexample">例6-4并行查询解释计划</p>
                              <p>以下简单示例说明了并行查询的<code class="codeph">EXPLAIN</code> <code class="codeph">PLAN</code> ：</p><pre class="pre codeblock"><code>CREATE TABLE emp2 AS SELECT * FROM employees; ALTER TABLE emp2 PARALLEL 2;用于SELECT SUM（薪水）的EXPLAIN PLAN FROM emp2 GROUP BY department_id;从TABLE中选择PLAN_TABLE_OUTPUT（DBMS_XPLAN.DISPLAY（））; -------------------------------------------------- ---------------------------------------------- | Id |操作|名称|行|字节数|成本％CPU | TQ | IN-OUT | PQ Distrib | -------------------------------------------------- ---------------------------------------------- | 0 |选择声明| | 107 | 2782 | 3（34）| | | | | 1 | PX COORDINATOR | | | | | | | | | 2 | PX SEND QC（RANDOM）| ：TQ10001 | 107 | 2782 | 3（34）| Q1,01 | P-&gt; S | QC（兰德）| | 3 | HASH GROUP BY | | 107 | 2782 | 3（34）| Q1,01 | PCWP | | | 4 | PX RECEIVE | | 107 | 2782 | 3（34）| Q1,01 | PCWP | | | 5 | PX SEND HASH | ：TQ10000 | 107 | 2782 | 3（34）| Q1,00 | P-&gt; P |哈希| | 6 | HASH GROUP BY | | 107 | 2782 | 3（34）| Q1,00 | PCWP | | | 7 | PX BLOCK ITERATOR | | 107 | 2782 | 2（0）| Q1,00 | PCWP | | | 8 |表访问完全| EMP2 | 107 | 2782 | 2（0）| Q1,00 | PCWP | | -------------------------------------------------- ----------------------------------------------</code></pre><p>一组并行执行服务器并行扫描<code class="codeph">EMP2</code> ，而第二组执行<code class="codeph">GROUP</code> <code class="codeph">BY</code>操作的聚合。<code class="codeph">PX</code> <code class="codeph">BLOCK</code> <code class="codeph">ITERATOR</code>行源表示将表<code class="codeph">EMP2</code>拆分成多个部分，以划分并行执行服务器之间的扫描工作负载。<code class="codeph">PX SEND</code>和<code class="codeph">PX RECEIVE</code>行源表示连接两组并行执行服务器的管道，当行从并行扫描向上流动，通过<code class="codeph">HASH</code>表队列重新分区，然后在顶部集合上读取和聚合。<code class="codeph">PX SEND QC</code>行源表示以随机（RAND）顺序发送到QC的聚合值。<code class="codeph">PX COORDINATOR</code>行源代表QC或查询协调器，它控制和计划在计划树中出现在它下面的并行计划。
                              </p>
                           </div>
                           <!-- class="example" -->
                        </div>
                        <div>
                           <div class="familylinks">
                              <div class="parentlink">
                                 <p><strong>父主题：</strong> <a href="generating-and-displaying-execution-plans.html#GUID-22F3C307-95C3-47EE-A3FD-545F614947CB" title="并行查询的计划与串行查询的计划有很大不同。">显示并行执行计划：示例</a></p>
                              </div>
                           </div>
                        </div>
                        
                     </div>
                  </div><a id="TGSQL94718"></a><a id="TGSQL94717"></a><div class="props_rev_3"><a id="GUID-CE8BCA2D-47B5-4FBD-95A9-5096A5734063" name="GUID-CE8BCA2D-47B5-4FBD-95A9-5096A5734063"></a><h5 id="TGSQL-GUID-CE8BCA2D-47B5-4FBD-95A9-5096A5734063" class="sect5"><span class="enumeration_section">6.3.4.3</span>显示位图索引计划：示例</h5>
                     <div>
                        <p>使用位图索引的索引行源显示在<code class="codeph">EXPLAIN PLAN</code>输出中，并带有指示索引类型的单词<code class="codeph">BITMAP</code> 。
                        </p>
                        <div class="example" id="GUID-CE8BCA2D-47B5-4FBD-95A9-5096A5734063__CEGFDIHJ">
                           <p class="titleinexample">示例6-5带位图索引的EXPLAIN计划</p>
                           <p>在该示例中，谓词<code class="codeph">c1=2</code>产生可以进行减法的位图。从该位图中，减去位图中<code class="codeph">c2=6</code>的位。此外，减去位图中<code class="codeph">c2 IS NULL</code>的位，解释了为什么计划中有两个<code class="codeph">MINUS</code>行源。除非列具有<code class="codeph">NOT NULL</code>约束，否则<code class="codeph">NULL</code>减法对于语义正确性是必需的。<code class="codeph">TO ROWIDS</code>选项生成表访问所需的rowid。
                           </p>
                           <div class="infoboxnote" id="GUID-CE8BCA2D-47B5-4FBD-95A9-5096A5734063__GUID-50D3D7DD-EAFA-44D6-8508-2CEA4C0874B8">
                              <p class="notep1">注意：</p>
                              <p>使用位图连接索引的查询指示位图连接索引访问路径。位图连接索引的操作与位图索引相同。</p>
                           </div><pre class="pre codeblock"><code>用于SELECT * FROM t WHERE c1 = 2和c2 &lt;&gt; 6或c3在10和20之间;选择语句表访问T由INDEX ROWID BITMAP转换为ROWID BITMAP或BITMAP减少BITMAP减去BITMAP索引C1_IND单值BITMAP索引C2_IND单值BITMAP索引C2_IND单值BITMAP MERGE BITMAP索引C3_IND RANGE SCAN</code></pre></div>
                        <!-- class="example" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="generating-and-displaying-execution-plans.html#GUID-90411427-FDD7-4196-A52A-84D153CE37C1" title="这些示例显示了显示执行计划的不同方式。">显示执行计划：示例</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TGSQL94719"></a><div class="props_rev_3"><a id="GUID-FE0B82DA-1A06-4145-B03D-A1C39DB1F88F" name="GUID-FE0B82DA-1A06-4145-B03D-A1C39DB1F88F"></a><h5 id="TGSQL-GUID-FE0B82DA-1A06-4145-B03D-A1C39DB1F88F" class="sect5"><span class="enumeration_section">6.3.4.4</span>显示结果缓存计划：示例</h5>
                     <div>
                        <p>当您的查询包含<code class="codeph">result_cache</code>提示时， <code class="codeph">ResultCache</code>运算符将插入执行计划中。
                        </p>
                        <div class="section">
                           <p>例如，请考虑以下查询：</p><pre class="pre codeblock"><code>SELECT / * + result_cache * / deptno，avg（sal）FROM emp GROUP BY deptno;</code></pre><p>要查看此查询的<code class="codeph">EXPLAIN PLAN</code> ，请使用以下命令：</p><pre class="pre codeblock"><code>EXPLAIN PLAN FOR SELECT / * + result_cache * / deptno，avg（sal）FROM emp GROUP BY deptno;从TABLE中选择PLAN_TABLE_OUTPUT（DBMS_XPLAN.DISPLAY（））;</code></pre><p>此查询的<code class="codeph">EXPLAIN PLAN</code>输出应类似于以下内容：</p><pre class="pre codeblock"><code>-------------------------------------------------- ------------------------------ | Id |操作|名称|行|字节|成本（％CPU）|时间| -------------------------------------------------- ------------------------------ | 0 |选择声明| | 11 | 77 | 4（25）| 00：00：01 | | 1 | RESULT CACHE | b06ppfz9pxzstbttpbqyqnfbmy | | | | | | 2 | HASH GROUP BY | | 11 | 77 | 4（25）| 00：00：01 | | 3 |表访问完全| EMP | 107 | 749 | 3（0）| 00：00：01 | -------------------------------------------------- ------------------------------</code></pre><p>在此<code class="codeph">EXPLAIN PLAN</code> ， <code class="codeph">ResultCache</code>运算符由其<code class="codeph">CacheId</code>标识，该标识为<code class="codeph">b06ppfz9pxzstbttpbqyqnfbmy</code> 。您现在可以使用此<code class="codeph">CacheId</code>在<code class="codeph">V$RESULT_CACHE_OBJECTS</code>视图上运行查询。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="generating-and-displaying-execution-plans.html#GUID-90411427-FDD7-4196-A52A-84D153CE37C1" title="这些示例显示了显示执行计划的不同方式。">显示执行计划：示例</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TGSQL94720"></a><div class="props_rev_3"><a id="GUID-37DF6780-3279-47CE-93E6-BE922F1451EF" name="GUID-37DF6780-3279-47CE-93E6-BE922F1451EF"></a><h5 id="TGSQL-GUID-37DF6780-3279-47CE-93E6-BE922F1451EF" class="sect5"><span class="enumeration_section">6.3.4.5</span>显示分区对象的计划：示例</h5>
                     <div>
                        <p>使用<code class="codeph">EXPLAIN PLAN</code>确定Oracle数据库如何访问特定查询的分区对象。
                        </p>
                        <p>修剪后访问的<code class="codeph">PARTITION START</code>显示在<code class="codeph">PARTITION START</code>和<code class="codeph">PARTITION STOP</code>列中。范围分区的行源名称是<code class="codeph">PARTITION RANGE</code> 。对于散列分区，行源名称为<code class="codeph">PARTITION HASH</code> 。</p>
                        <p>如果其中一个连接表的计划表的<code class="codeph">DISTRIBUTION</code>列包含<code class="codeph">PARTITION(KEY)</code>则使用部分分区连接实现连接。如果其中一个连接表在其连接列上分区并且表是并行化的，则可以进行部分分区连接。
                        </p>
                        <p>如果分区行源出现在<code class="codeph">EXPLAIN PLAN</code>输出中的连接行源之前，则使用完全分区连接实现连接。只有当两个连接表在各自的连接列上均分时，才可能使用完全分区连接。下面是几种分区的执行计划示例。
                        </p>
                        <p>本节包含以下主题：</p>
                     </div>
                     <div>
                        <ul class="ullinks">
                           <li class="ulchildlink"><a href="generating-and-displaying-execution-plans.html#GUID-CFF5285C-DC64-4687-A3D3-B76C28DF8C01">使用EXPLAIN PLAN显示范围和哈希分区：示例</a><br>此示例说明了使用<code class="codeph">emp_range</code>表进行修剪，该表按<code class="codeph">hire_date</code>上的范围分区。
                           </li>
                           <li class="ulchildlink"><a href="generating-and-displaying-execution-plans.html#GUID-60AB9A81-49C2-4033-A692-A9766A065A60">使用复合分区对象修剪信息：示例</a><br>为了说明Oracle数据库如何显示复合分区对象的修剪信息，请考虑表<code class="codeph">emp_comp</code> 。它在<code class="codeph">hiredate</code>上进行范围分区，在<code class="codeph">deptno</code>上使用hash进行子分区。
                           </li>
                           <li class="ulchildlink"><a href="generating-and-displaying-execution-plans.html#GUID-2D33B318-5E73-4D68-BCAE-FCB905B8490A">部分分区 - 明智联接的示例</a><br>在这些示例中， <code class="codeph">PQ_DISTRIBUTE</code>提示显式强制部分分区连接，因为查询优化器可能已根据此查询中的成本选择了不同的计划。
                           </li>
                           <li class="ulchildlink"><a href="generating-and-displaying-execution-plans.html#GUID-C2D553C9-FDCF-4C0F-9CF8-112A7B5C7E5A">完全分区 - 明智加入的示例</a><br>在此示例中， <code class="codeph">emp_comp</code>和<code class="codeph">dept_hash</code>在其哈希分区列上连接，从而可以使用完全分区连接。
                           </li>
                           <li class="ulchildlink"><a href="generating-and-displaying-execution-plans.html#GUID-B1401051-FDEF-483A-B769-0C28143FBD8F">INLIST ITERATOR和EXPLAIN PLAN的例子</a><br>如果索引实现<code class="codeph">IN</code> -list谓词，则<code class="codeph">INLIST ITERATOR</code>操作将出现在<code class="codeph">EXPLAIN PLAN</code>输出中。
                           </li>
                           <li class="ulchildlink"><a href="generating-and-displaying-execution-plans.html#GUID-E200BFF9-2C2D-411A-8134-4AEF177E2F1A">域索引和EXPLAIN PLAN的示例</a><br>您可以使用<code class="codeph">EXPLAIN PLAN</code>来获取域索引的用户定义的CPU和I / O开销。
                           </li>
                        </ul>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="generating-and-displaying-execution-plans.html#GUID-90411427-FDD7-4196-A52A-84D153CE37C1" title="这些示例显示了显示执行计划的不同方式。">显示执行计划：示例</a></p>
                           </div>
                        </div>
                     </div>
                     <a id="TGSQL94721"></a><div class="props_rev_3"><a id="GUID-CFF5285C-DC64-4687-A3D3-B76C28DF8C01" name="GUID-CFF5285C-DC64-4687-A3D3-B76C28DF8C01"></a><h6 id="TGSQL-GUID-CFF5285C-DC64-4687-A3D3-B76C28DF8C01" class="sect6"><span class="enumeration_section">6.3.4.5.1</span>使用EXPLAIN PLAN显示范围和散列分区：示例</h6>
                        <div>
                           <p>此示例说明了使用<code class="codeph">emp_range</code>表进行修剪，该表按<code class="codeph">hire_date</code>上的范围分区。
                           </p>
                           <div class="section">
                              <p>假设存在Oracle数据库示例模式中的表<code class="codeph">employees</code>和<code class="codeph">departments</code> 。
                              </p><pre class="pre codeblock"><code>CREATE TABLE emp_range PARTITION BY RANGE（hire_date）（PARTITION emp_p1值不到（截至（'1-JAN-1992'，'DD-MON-YYYY'）），分区emp_p2值不到（1994年1月1日） '，'DD-MON-YYYY'）），分区emp_p3值不到（截止日期（'1-JAN-1996'，'DD-MON-YYYY'）），分区emp_p4值小于（1月1日） -1998'，'DD-MON-YYYY'）），PARTITION emp_p5值不到（截止日期为（'1-JAN-2001'，'DD-MON-YYYY'）））AS SELECT * FROM employees;</code></pre><p>对于第一个示例，请考虑以下语句：</p><pre class="pre codeblock"><code>用于SELECT * FROM emp_range的EXPLAIN PLAN;</code></pre><p>Oracle数据库显示类似于以下内容的内容：</p><pre class="pre codeblock"><code>-------------------------------------------------- ------------------ | Id |操作|名称|行|字节|成本| Pstart时| PSTOP | -------------------------------------------------- ------------------ | 0 |选择声明| | 105 | 13965 | 2 | | | | 1 | PARTITION RANGE ALL | | 105 | 13965 | 2 | 1 | 5 | | 2 |表访问完全| EMP_RANGE | 105 | 13965 | 2 | 1 | 5 | -------------------------------------------------- ------------------</code></pre><p>数据库在表访问行源的顶部创建分区行源。它遍历要访问的分区集。在此示例中，分区迭代器覆盖所有分区（选项<code class="codeph">ALL</code> ），因为谓词不用于修剪。<code class="codeph">PLAN_TABLE</code>的<code class="codeph">PARTITION_START</code>和<code class="codeph">PARTITION_STOP</code>列显示从1到5的所有分区的访问权限。
                              </p>
                              <p>对于下一个示例，请考虑以下语句：</p><pre class="pre codeblock"><code>SELECT * FROM emp_range的EXPLAIN PLAN WHERE hire_date&gt; = TO_DATE（'1-JAN-1996'，'DD-MON-YYYY'）; -------------------------------------------------- --------------------- | Id |操作|名称|行|字节|成本| Pstart | Pstop | -------------------------------------------------- --------------------- | 0 |选择声明| | 3 | 399 | 2 | | | | 1 |分区范围ITERATOR | | 3 | 399 | 2 | 4 | 5 | | * 2 |表访问已满| EMP_RANGE | 3 | 399 | 2 | 4 | 5 | -------------------------------------------------- ---------------------</code></pre><p>在前面的示例中，分区行源从分区4迭代到5，因为数据库使用<code class="codeph">hire_date</code>上的谓词修剪其他分区。
                              </p>
                              <p>最后，请考虑以下声明：</p><pre class="pre codeblock"><code>用于SELECT * FROM emp_range的EXPLAIN PLAN WHERE hire_date &lt;TO_DATE（'1-JAN-1992'，'DD-MON-YYYY'）; -------------------------------------------------- --------------------- | Id |操作|名称|行|字节|成本| Pstart | Pstop | -------------------------------------------------- --------------------- | 0 |选择声明| | 1 | 133 | 2 | | | | 1 | PARTITION RANGE SINGLE | | 1 | 133 | 2 | 1 | 1 | | * 2 |表访问完全| EMP_RANGE | 1 | 133 | 2 | 1 | 1 | -------------------------------------------------- ---------------------</code></pre><p>在前面的示例中，只有分区1在编译时被访问并且已知;因此，不需要分区行源。</p>
                              <div class="infoboxnote" id="GUID-CFF5285C-DC64-4687-A3D3-B76C28DF8C01__GUID-201DA968-4EF0-471D-85AC-28E3E1667F3C">
                                 <p class="notep1">注意：</p>
                                 <p>Oracle数据库显示与散列分区对象相同的信息，但分区行源名称为<code class="codeph">PARTITION HASH</code>而不是<code class="codeph">PARTITION RANGE</code> 。此外，使用散列分区，只能使用相等或<code class="codeph">IN</code> -list谓词进行修剪。
                                 </p>
                              </div>
                           </div>
                           <!-- class="section" -->
                        </div>
                        <div>
                           <div class="familylinks">
                              <div class="parentlink">
                                 <p><strong>父主题：</strong> <a href="generating-and-displaying-execution-plans.html#GUID-37DF6780-3279-47CE-93E6-BE922F1451EF" title="使用EXPLAIN PLAN确定Oracle数据库如何访问特定查询的分区对象。">显示分区对象的计划：示例</a></p>
                              </div>
                           </div>
                        </div>
                        
                     </div><a id="TGSQL94723"></a><div class="props_rev_3"><a id="GUID-60AB9A81-49C2-4033-A692-A9766A065A60" name="GUID-60AB9A81-49C2-4033-A692-A9766A065A60"></a><h6 id="TGSQL-GUID-60AB9A81-49C2-4033-A692-A9766A065A60" class="sect6"><span class="enumeration_section">6.3.4.5.2</span>使用复合分区对象修剪信息：示例</h6>
                        <div>
                           <p>为了说明Oracle数据库如何显示复合分区对象的修剪信息，请考虑表<code class="codeph">emp_comp</code> 。它在<code class="codeph">hiredate</code>上进行范围分区，在<code class="codeph">deptno</code>上使用hash进行子分区。
                           </p>
                           <div class="section"><pre class="pre codeblock"><code>CREATE TABLE emp_comp PARTITION BY RANGE（hire_date）HASH（department_id）SUBPARTITIONS 3的分区（分区emp_p1值不到（截至（'1-JAN-1992'，'DD-MON-YYYY'）），分区emp_p2值小于（ TO_DATE（'1-JAN-1994'，'DD-MON-YYYY'）），PARTITION emp_p3值不到（截至（'1-JAN-1996'，'DD-MON-YYYY'）），分区emp_p4值少（截止日期（'1-JAN-1998'，'DD-MON-YYYY'）），分区emp_p5值不到（截止日期为（'1-JAN-2001'，'DD-MON-YYYY'））） *来自员工;</code></pre><p>对于第一个示例，请考虑以下语句：</p><pre class="pre codeblock"><code>SELECT * FROM emp_comp的EXPLAIN PLAN; -------------------------------------------------- --------------------- | Id |操作|名称|行|字节|成本| Pstart | Pstop | -------------------------------------------------- --------------------- | 0 |选择声明| | 10120 | 1314K | 78 | | | | 1 | PARTITION RANGE ALL | | 10120 | 1314K | 78 | 1 | 5 | | 2 | PARTITION HASH ALL | | 10120 | 1314K | 78 | 1 | 3 | | 3 |表访问完全| EMP_COMP | 10120 | 1314K | 78 | 1 | 15 | -------------------------------------------------- ---------------------</code></pre><p>此示例显示Oracle数据库访问复合对象的所有分区的所有子分区时的计划。为此，数据库使用两个分区行源：用于迭代分区的范围分区行源，以及用于迭代每个访问分区的子分区的散列分区行源。</p>
                              <p>在以下示例中，范围分区行源从分区1迭代到5，因为数据库不执行修剪。在每个分区内，散列分区行源迭代当前分区的子分区1到3。结果，表访问行源访问子分区1到15。换句话说，数据库访问复合对象的所有子分区。</p><pre class="pre codeblock"><code>SELECT * FROM emp_comp WHERE hire_date = TO_DATE（'15-FEB-1998'，'DD-MON-YYYY'）的EXPLAIN PLAN; -------------------------------------------------- --------------------- | Id |操作|名称|行|字节|成本| Pstart | Pstop | -------------------------------------------------- --------------------- | 0 |选择声明| | 20 | 2660 | 17 | | | | 1 | PARTITION RANGE SINGLE | | 20 | 2660 | 17 | 5 | 5 | | 2 | PARTITION HASH ALL | | 20 | 2660 | 17 | 1 | 3 | | * 3 |表访问完全| EMP_COMP | 20 | 2660 | 17 | 13 | 15 | -------------------------------------------------- ---------------------</code></pre><p>在前面的示例中，仅访问最后一个分区（分区5）。此分区在编译时是已知的，因此数据库不需要在计划中显示它。散列分区行源显示对该分区内所有子分区的访问;也就是说，子分区1到3，它转换为<code class="codeph">emp_comp</code>表的子分区13到15。
                              </p>
                              <p>现在考虑以下声明：</p><pre class="pre codeblock"><code>SELECT * FROM emp_comp的EXPLAIN PLAN WHERE department_id = 20; -------------------------------------------------- ---------------------- | Id |操作|名称|行|字节|成本| Pstart | Pstop | -------------------------------------------------- ---------------------- | 0 |选择声明| | 101 | 13433 | 78 | | | | 1 | PARTITION RANGE ALL | | 101 | 13433 | 78 | 1 | 5 | | 2 | PARASHTION HASH SINGLE | | 101 | 13433 | 78 | 3 | 3 | | * 3 |表访问完全| EMP_COMP | 101 | 13433 | 78 | | | -------------------------------------------------- ----------------------</code></pre><p>在前面的示例中，谓词<code class="codeph">deptno=20</code>允许对每个分区内的散列维度进行修剪。因此，Oracle数据库只需要访问单个子分区。此子分区的编号在编译时是已知的，因此不需要散列分区行源。
                              </p>
                              <p>最后，请考虑以下声明：</p><pre class="pre codeblock"><code>VARIABLE dno NUMBER; EXPLAIN PLAN FOR SELECT * FROM emp_comp WHERE department_id =：dno; -------------------------------------------------- --------------------- | ID |操作|名称|行|字节|成本| Pstart | Pstop | -------------------------------------------------- --------------------- | 0 |选择声明| | 101 | 13433 | 78 | | | | 1 | PARTITION RANGE ALL | | 101 | 13433 | 78 | 1 | 5 | | 2 | PARASHTION HASH SINGLE | | 101 | 13433 | 78 | KEY | KEY | | * 3 |表访问完全| EMP_COMP | 101 | 13433 | 78 | | | -------------------------------------------------- ---------------------</code></pre><p>最后两个示例是相同的，除了<code class="codeph">department_id</code> =： <code class="codeph">dno</code>替换<code class="codeph">deptno=20</code> 。在最后一种情况下，子分区编号在编译时是未知的，并且分配了散列分区行源。对于此行源，该选项为<code class="codeph">SINGLE</code> ，因为Oracle数据库仅访问每个分区中的一个子分区。在步骤2中， <code class="codeph">PARTITION</code> _ <code class="codeph">START</code>和<code class="codeph">PARTITION</code> _ <code class="codeph">STOP</code>都设置为<code class="codeph">KEY</code> 。此值表示Oracle数据库确定运行时的子分区数。
                              </p>
                           </div>
                           <!-- class="section" -->
                        </div>
                        <div>
                           <div class="familylinks">
                              <div class="parentlink">
                                 <p><strong>父主题：</strong> <a href="generating-and-displaying-execution-plans.html#GUID-37DF6780-3279-47CE-93E6-BE922F1451EF" title="使用EXPLAIN PLAN确定Oracle数据库如何访问特定查询的分区对象。">显示分区对象的计划：示例</a></p>
                              </div>
                           </div>
                        </div>
                        
                     </div><a id="TGSQL94725"></a><a id="TGSQL94726"></a><a id="TGSQL94724"></a><div class="props_rev_3"><a id="GUID-2D33B318-5E73-4D68-BCAE-FCB905B8490A" name="GUID-2D33B318-5E73-4D68-BCAE-FCB905B8490A"></a><h6 id="TGSQL-GUID-2D33B318-5E73-4D68-BCAE-FCB905B8490A" class="sect6"><span class="enumeration_section">6.3.4.5.3</span>部分分区 - 明智连接的例子</h6>
                        <div>
                           <p>在这些示例中， <code class="codeph">PQ_DISTRIBUTE</code>提示显式强制部分分区连接，因为查询优化器可能已根据此查询中的成本选择了不同的计划。
                           </p>
                           <div class="example" id="GUID-2D33B318-5E73-4D68-BCAE-FCB905B8490A__CEGBBAEA">
                              <p class="titleinexample">例6-6部分分区 - 明智加入范围分区</p>在以下示例中，数据库在分区列<code class="codeph">department_id</code>上加入<code class="codeph">emp_range_did</code>并将其并行化。数据库可以使用部分分区连接，因为<code class="codeph">dept2</code>表未分区。Oracle数据库在连接之前动态分区<code class="codeph">dept2</code>表。<pre class="pre codeblock"><code>CREATE TABLE dept2 AS SELECT * FROM departments; ALTER TABLE dept2 PARALLEL 2; CREATE TABLE emp_range_did PARTITION BY RANGE（department_id）（PARTITION emp_p1值小于（150），PARTITION emp_p5值小于（MAXVALUE））AS SELECT * FROM employees; ALTER TABLE emp_range_did PARALLEL 2;用于SELECT / * + PQ_DISTRIBUTE（d NONE PARTITION）的EXPLAIN PLAN ORDERED * / e.last_name，d.department_name FROM emp_range_did e，dept2 d WHERE e.department_id = d.department_id; -------------------------------------------------- ---------------------------------------------- | Id |操作|名称|行|字节|成本| Pstart | Pstop | TQ | IN-OUT | PQ Distrib | -------------------------------------------------- ---------------------------------------------- | 0 |选择声明| | 284 | 16188 | 6 | | | | | | | 1 | PX COORDINATOR | | | | | | | | | | | 2 | PX SEND QC（RANDOM）|：TQ10001 | 284 | 16188 | 6 | | | Q1,01 | P-&gt; S | QC（兰德）| | * 3 | HASH JOIN | | 284 | 16188 | 6 | | | Q1,01 | PCWP | | | 4 | PX PARTITION RANGE ALL | | 284 | 7668 | 2 | 1 | 2 | Q1,01 | PCWC | | | 5 |表访问已满| EMP_RANGE_DID | 284 | 7668 | 2 | 1 | 2 | Q1,01 | PCWP | | | 6 | BUFFER SORT | | | | | | | Q1,01 | PCWC | | | 7 | PX RECEIVE | | 21 | 630 | 2 | | | Q1,01 | PCWP | | | 8 | PX SEND PARTITION（KEY）|：TQ10000 | 21 | 630 | 2 | | | | S-&gt; P | PART（KEY）| | 9 |表访问完全| DEPT2 | 21 | 630 | 2 | | | | | | -------------------------------------------------- ----------------------------------------------</code></pre><p>执行计划显示表<code class="codeph">dept2</code>被串行扫描，并且具有相同分区列值<code class="codeph">emp_range_did (department_id)</code>所有行通过<code class="codeph">PART (KEY)</code>或分区键，表队列发送到执行部分分区的同一并行执行服务器 - 加入。
                              </p>
                           </div>
                           <!-- class="example" -->
                           <div class="example" id="GUID-2D33B318-5E73-4D68-BCAE-FCB905B8490A__CEGFCDHA">
                              <p class="titleinexample">示例6-7使用复合分区的部分分区 - 明智联接</p>
                              <p>在以下示例中， <code class="codeph">emp_comp</code>在分区列上连接并并行化，从而允许使用部分分区连接，因为<code class="codeph">dept2</code>未分区。数据库在连接之前动态分区<code class="codeph">dept2</code> 。
                              </p><pre class="pre codeblock"><code>ALTER TABLE emp_comp PARALLEL 2;用于SELECT / * + PQ_DISTRIBUTE（d NONE PARTITION）的EXPLAIN PLAN ORDERED * / e.last_name，d.department_name FROM emp_comp e，dept2 d WHERE e.department_id = d.department_id;从TABLE中选择PLAN_TABLE_OUTPUT（DBMS_XPLAN.DISPLAY（））; -------------------------------------------------- ---------------------------------------------- | ID |操作|名称|行|字节|成本| Pstart | Pstop | TQ | IN-OUT | PQ Distrib | -------------------------------------------------- ---------------------------------------------- | 0 |选择声明| | 445 | 17800 | 5 | | | | | | | 1 | PX COORDINATOR | | | | | | | | | | | 2 | PX SEND QC（RANDOM）|：TQ10001 | 445 | 17800 | 5 | | | Q1,01 | P-&gt; S | QC（兰德）| | * 3 | HASH JOIN | | 445 | 17800 | 5 | | | Q1,01 | PCWP | | | 4 | PX PARTITION RANGE ALL | | 107 | 1070 | 3 | 1 | 5 | Q1,01 | PCWC | | | 5 | PX PARTITION HASH ALL | | 107 | 1070 | 3 | 1 | 3 | Q1,01 | PCWC | | | 6 |表访问已满| EMP_COMP | 107 | 1070 | 3 | 1 | 15 | Q1,01 | PCWP | | | 7 | PX RECEIVE | | 21 | 630 | 1 | | | Q1,01 | PCWP | | | 8 | PX SEND PARTITION（KEY）|：TQ10000 | 21 | 630 | 1 | | | Q1,00 | P-&gt; P | PART（KEY）| | 9 | PX BLOCK ITERATOR | | 21 | 630 | 1 | | | Q1,00 | PCWC | | | 10 |表访问完全| DEPT2 | 21 | 630 | 1 | | | Q1,00 | PCWP | | -------------------------------------------------- ----------------------------------------------</code></pre><p>该计划显示优化程序从两列之一中选择部分分区连接。<code class="codeph">PX SEND</code>节点类型为<code class="codeph">PARTITION (KEY)</code> ， <code class="codeph">PQ Distrib</code>列包含文本<code class="codeph">PART (KEY)</code>或分区键。这意味着基于连接列<code class="codeph">department_id</code>对表<code class="codeph">dept2</code>进行重新分区，以将其发送到执行<code class="codeph">EMP_COMP</code>扫描和连接的并行执行服务器。
                              </p>
                           </div>
                           <!-- class="example" -->
                        </div>
                        <div>
                           <div class="familylinks">
                              <div class="parentlink">
                                 <p><strong>父主题：</strong> <a href="generating-and-displaying-execution-plans.html#GUID-37DF6780-3279-47CE-93E6-BE922F1451EF" title="使用EXPLAIN PLAN确定Oracle数据库如何访问特定查询的分区对象。">显示分区对象的计划：示例</a></p>
                              </div>
                           </div>
                        </div>
                        
                     </div><a id="TGSQL94728"></a><a id="TGSQL94727"></a><div class="props_rev_3"><a id="GUID-C2D553C9-FDCF-4C0F-9CF8-112A7B5C7E5A" name="GUID-C2D553C9-FDCF-4C0F-9CF8-112A7B5C7E5A"></a><h6 id="TGSQL-GUID-C2D553C9-FDCF-4C0F-9CF8-112A7B5C7E5A" class="sect6"><span class="enumeration_section">6.3.4.5.4</span>完全分区 - 明智连接的示例</h6>
                        <div>
                           <p>在此示例中， <code class="codeph">emp_comp</code>和<code class="codeph">dept_hash</code>在其哈希分区列上连接，从而可以使用完全分区连接。
                           </p>
                           <div class="section">
                              <p><code class="codeph">PARTITION HASH</code>行源显示在计划表输出中的连接行源的顶部。
                              </p><pre class="pre codeblock"><code>CREATE TABLE dept_hash PARTITION BY HASH（department_id）PARTITIONS 3 PARALLEL 2 AS SELECT * FROM departments;用于SELECT / * + PQ_DISTRIBUTE（e NONE NONE）的EXPLAIN PLAN ORDERED * / e.last_name，d.department_name FROM emp_comp e，dept_hash d WHERE e.department_id = d.department_id; -------------------------------------------------- ---------------------------------------------- | Id |操作|名称|行|字节|成本| Pstart | Pstop | TQ | IN-OUT | PQ Distrib | -------------------------------------------------- ---------------------------------------------- | 0 |选择声明| | 106 | 2544 | 8 | | | | | | | 1 | PX COORDINATOR | | | | | | | | | | | 2 | PX SEND QC（RANDOM）| ：TQ10000 | 106 | 2544 | 8 | | | Q1,00 | P-&gt; S | QC（兰德）| | 3 | PX PARTITION HASH ALL | | 106 | 2544 | 8 | 1 | 3 | Q1,00 | PCWC | | | * 4 | HASH JOIN | | 106 | 2544 | 8 | | | Q1,00 | PCWP | | | 5 | PX PARTITION RANGE ALL | | 107 | 1070 | 3 | 1 | 5 | Q1,00 | PCWC | | | 6 |表访问完全| EMP_COMP | 107 | 1070 | 3 | 1 | 15 | Q1,00 | PCWP | | | 7 |表访问完全| DEPT_HASH | 27 | 378 | 4 | 1 | 3 | Q1,00 | PCWP | | -------------------------------------------------- ----------------------------------------------</code></pre><p><code class="codeph">PX PARTITION HASH</code>行源显示在计划表输出中的连接行源的顶部，而<code class="codeph">PX PARTITION RANGE</code>行源显示在<code class="codeph">emp_comp</code>的扫描上。每个并行执行服务器执行<code class="codeph">emp_comp</code>的整个散列分区与<code class="codeph">emp_comp</code>的整个分区的<code class="codeph">dept_hash</code> 。
                              </p>
                           </div>
                           <!-- class="section" -->
                        </div>
                        <div>
                           <div class="familylinks">
                              <div class="parentlink">
                                 <p><strong>父主题：</strong> <a href="generating-and-displaying-execution-plans.html#GUID-37DF6780-3279-47CE-93E6-BE922F1451EF" title="使用EXPLAIN PLAN确定Oracle数据库如何访问特定查询的分区对象。">显示分区对象的计划：示例</a></p>
                              </div>
                           </div>
                        </div>
                        
                     </div><a id="TGSQL94729"></a><div class="props_rev_3"><a id="GUID-B1401051-FDEF-483A-B769-0C28143FBD8F" name="GUID-B1401051-FDEF-483A-B769-0C28143FBD8F"></a><h6 id="TGSQL-GUID-B1401051-FDEF-483A-B769-0C28143FBD8F" class="sect6"><span class="enumeration_section">6.3.4.5.5</span> INLIST ITERATOR和EXPLAIN PLAN的例子</h6>
                        <div>
                           <p>如果索引实现<code class="codeph">IN</code> -list谓词，则<code class="codeph">INLIST ITERATOR</code>操作将出现在<code class="codeph">EXPLAIN PLAN</code>输出中。
                           </p>
                           <div class="section">
                              <p>请考虑以下声明：</p><pre class="pre codeblock"><code>SELECT * FROM emp WHERE empno IN（7876,7900,7902）;</code></pre><p><code class="codeph">EXPLAIN PLAN</code>输出显示如下：</p><pre class="pre codeblock"><code>操作选项OBJECT_NAME ---------------- --------------- -------------- SELECT STATEMENT通过ROWID EMP INDEX RANGE SCAN EMP_EMPNO进行INLIST ITERATOR表访问</code></pre><p><code class="codeph">INLIST ITERATOR</code>操作迭代<code class="codeph">IN</code> list谓词中每个值的计划中的下一个操作。以下部分描述了分区表和索引的三种可能类型的<code class="codeph">IN</code> -list列。
                              </p>
                              <p>本节包含以下主题：</p>
                           </div>
                           <!-- class="section" -->
                        </div>
                        <div>
                           <ul class="ullinks">
                              <li class="ulchildlink"><a href="generating-and-displaying-execution-plans.html#GUID-4B04B5D8-9948-40A4-A769-632AB1770749">当IN列表列是索引列时：示例</a><br>如果<code class="codeph">IN</code> -list列<code class="codeph">empno</code>是索引列而不是分区列，则<code class="codeph">IN</code> -list运算符出现在表操作之前但在计划中的分区操作之后。
                              </li>
                              <li class="ulchildlink"><a href="generating-and-displaying-execution-plans.html#GUID-C5AEB7F0-CAEE-49D2-A363-DED45A7C7D7C">当IN列表列是索引和分区列时：示例</a><br>如果<code class="codeph">empno</code>是索引和分区列，则计划在分区操作之前包含<code class="codeph">INLIST ITERATOR</code>操作。
                              </li>
                              <li class="ulchildlink"><a href="generating-and-displaying-execution-plans.html#GUID-9CBA5FC7-33C5-4CAF-963F-02BDF5918B70">当IN列表列是分区列时：示例</a><br>如果<code class="codeph">empno</code>是分区列且不存在索引，则不分配<code class="codeph">INLIST ITERATOR</code>操作。
                              </li>
                           </ul>
                           <div class="familylinks">
                              <div class="parentlink">
                                 <p><strong>父主题：</strong> <a href="generating-and-displaying-execution-plans.html#GUID-37DF6780-3279-47CE-93E6-BE922F1451EF" title="使用EXPLAIN PLAN确定Oracle数据库如何访问特定查询的分区对象。">显示分区对象的计划：示例</a></p>
                              </div>
                           </div>
                        </div>
                        <a id="TGSQL94730"></a><div class="props_rev_3"><a id="GUID-4B04B5D8-9948-40A4-A769-632AB1770749" name="GUID-4B04B5D8-9948-40A4-A769-632AB1770749"></a><h6 id="TGSQL-GUID-4B04B5D8-9948-40A4-A769-632AB1770749" class="sect6"><span class="enumeration_section">6.3.4.5.5.1</span>当IN-List列是索引列时：示例</h6>
                           <div>
                              <p>如果<code class="codeph">IN</code> -list列<code class="codeph">empno</code>是索引列而不是分区列，则<code class="codeph">IN</code> -list运算符出现在表操作之前但在计划中的分区操作之后。
                              </p>
                              <div class="section"><pre class="pre codeblock"><code>操作选项OBJECT_NAME PARTIT_START PARTITION_STOP ---------------- ------------ ----------- ------ ------ -------------- SELECT语句分区范围所有键（INLIST）键（INLIST）INLIST ITERATOR表访问本地索引ROWID EMP KEY（INLIST）键（INLIST） INDEX RANGE SCAN EMP_EMPNO KEY（INLIST）KEY（INLIST）</code></pre><p>分区开始和停止键的<code class="codeph">KEY(INLIST)</code>指定指定<code class="codeph">IN</code> -list谓词出现在索引的开始和停止键上。
                                 </p>
                              </div>
                              <!-- class="section" -->
                           </div>
                           <div>
                              <div class="familylinks">
                                 <div class="parentlink">
                                    <p><strong>父主题：</strong> <a href="generating-and-displaying-execution-plans.html#GUID-B1401051-FDEF-483A-B769-0C28143FBD8F" title="如果索引实现IN列表谓词，则INCLIST ITERATOR操作将出现在EXPLAIN PLAN输出中。">INLIST ITERATOR和EXPLAIN PLAN的示例</a></p>
                                 </div>
                              </div>
                           </div>
                           
                        </div><a id="TGSQL94731"></a><div class="props_rev_3"><a id="GUID-C5AEB7F0-CAEE-49D2-A363-DED45A7C7D7C" name="GUID-C5AEB7F0-CAEE-49D2-A363-DED45A7C7D7C"></a><h6 id="TGSQL-GUID-C5AEB7F0-CAEE-49D2-A363-DED45A7C7D7C" class="sect6"><span class="enumeration_section">6.3.4.5.5.2</span>当IN-List列是索引和分区列时：示例</h6>
                           <div>
                              <p>如果<code class="codeph">empno</code>是索引和分区列，则计划在分区操作之前包含<code class="codeph">INLIST ITERATOR</code>操作。
                              </p>
                              <div class="section"><pre class="pre codeblock"><code>操作选项OBJECT_NAME PARTITION_START PARTITION_STOP ---------------- ------------ ----------- ------ --------- -------------- SELECT STATEMENT INLIST ITERATOR PARTITION RANGE ITERATOR KEY（INLIST）KEY（INLIST）表按本地索引ROWID EMP KEY（INLIST）键访问（INLIST）INDEX RANGE SCAN EMP_EMPNO KEY（INLIST）KEY（INLIST）</code></pre></div>
                              <!-- class="section" -->
                           </div>
                           <div>
                              <div class="familylinks">
                                 <div class="parentlink">
                                    <p><strong>父主题：</strong> <a href="generating-and-displaying-execution-plans.html#GUID-B1401051-FDEF-483A-B769-0C28143FBD8F" title="如果索引实现IN列表谓词，则INCLIST ITERATOR操作将出现在EXPLAIN PLAN输出中。">INLIST ITERATOR和EXPLAIN PLAN的示例</a></p>
                                 </div>
                              </div>
                           </div>
                           
                        </div><a id="TGSQL94732"></a><div class="props_rev_3"><a id="GUID-9CBA5FC7-33C5-4CAF-963F-02BDF5918B70" name="GUID-9CBA5FC7-33C5-4CAF-963F-02BDF5918B70"></a><h6 id="TGSQL-GUID-9CBA5FC7-33C5-4CAF-963F-02BDF5918B70" class="sect6"><span class="enumeration_section">6.3.4.5.5.3</span>当IN-List列是分区列时：示例</h6>
                           <div>
                              <p>如果<code class="codeph">empno</code>是分区列且不存在索引，则不分配<code class="codeph">INLIST ITERATOR</code>操作。
                              </p>
                              <div class="section"><pre class="pre codeblock"><code>操作选项OBJECT_NAME PARTITION_START PARTITION_STOP ---------------- ------------ ----------- ------ --------- -------------- SELECT STATEMENT PARTITION RANGE INLIST KEY（INLIST）KEY（INLIST）TABLE ACCESS FULL EMP KEY（INLIST）KEY（INLIST）</code></pre><p>如果<code class="codeph">emp_empno</code>是位图索引，则计划如下：</p><pre class="pre codeblock"><code>操作选项OBJECT_NAME ---------------- --------------- -------------- SELECT STATEMENT INLIST ITERATOR通过INDEX ROWID EMP BITMAP转换访问ROWIDS BITMAP索引单一值EMP_EMPNO</code></pre></div>
                              <!-- class="section" -->
                           </div>
                           <div>
                              <div class="familylinks">
                                 <div class="parentlink">
                                    <p><strong>父主题：</strong> <a href="generating-and-displaying-execution-plans.html#GUID-B1401051-FDEF-483A-B769-0C28143FBD8F" title="如果索引实现IN列表谓词，则INCLIST ITERATOR操作将出现在EXPLAIN PLAN输出中。">INLIST ITERATOR和EXPLAIN PLAN的示例</a></p>
                                 </div>
                              </div>
                           </div>
                           
                        </div>
                     </div><a id="TGSQL94733"></a><div class="props_rev_3"><a id="GUID-E200BFF9-2C2D-411A-8134-4AEF177E2F1A" name="GUID-E200BFF9-2C2D-411A-8134-4AEF177E2F1A"></a><h6 id="TGSQL-GUID-E200BFF9-2C2D-411A-8134-4AEF177E2F1A" class="sect6"><span class="enumeration_section">6.3.4.5.6</span>域索引和EXPLAIN PLAN的示例</h6>
                        <div>
                           <p>您可以使用<code class="codeph">EXPLAIN PLAN</code>来获取域索引的用户定义的CPU和I / O开销。
                           </p>
                           <div class="section">
                              <p><code class="codeph">EXPLAIN PLAN</code>在<code class="codeph">PLAN_TABLE</code>的<code class="codeph">OTHER</code>列中显示域索引统计信息。例如，假设table <code class="codeph">emp</code>在<code class="codeph">resume</code>列上具有用户定义的运算符<code class="codeph">CONTAINS</code> ，域索引为<code class="codeph">emp_resume</code> ，而<code class="codeph">emp_resume</code>的索引类型支持运算符<code class="codeph">CONTAINS</code> 。您解释以下查询的计划：</p><pre class="pre codeblock"><code>SELECT * FROM emp WHERE CONTAINS（resume，'Oracle'）= 1</code></pre><p>数据库可以显示以下计划：</p><pre class="pre codeblock"><code>操作选项OBJECT_NAME OTHER ----------------- ----------- ------------ ------ ---------- SELECT语句表访问由ROWID EMP DOMAIN索引EMP_RESUME CPU：300，I / O：4</code></pre></div>
                           <!-- class="section" -->
                        </div>
                        <div>
                           <div class="familylinks">
                              <div class="parentlink">
                                 <p><strong>父主题：</strong> <a href="generating-and-displaying-execution-plans.html#GUID-37DF6780-3279-47CE-93E6-BE922F1451EF" title="使用EXPLAIN PLAN确定Oracle数据库如何访问特定查询的分区对象。">显示分区对象的计划：示例</a></p>
                              </div>
                           </div>
                        </div>
                        
                     </div>
                  </div>
               </div>
            </div>
            <div class="sect2"><a id="GUID-0023D232-5695-4BA8-89C5-88672B7647E2" name="GUID-0023D232-5695-4BA8-89C5-88672B7647E2"></a><h3 id="TGSQL-GUID-0023D232-5695-4BA8-89C5-88672B7647E2" class="sect3"><span class="enumeration_section">6.4</span>比较执行计划</h3>
               <div>
                  <p>计划比较工具采用参考计划和任意测试计划列表，并突出显示它们之间的差异。计划比较是合乎逻辑的而不是逐行的。</p>
                  <p>本节包含以下主题：</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="generating-and-displaying-execution-plans.html#GUID-932E5852-46C8-47F8-8FD4-1B3C3936CA1D">计划比较的目的</a><br>计划比较报告确定了差异的来源，这有助于用户对计划重现性问题进行分类。
                     </li>
                     <li class="ulchildlink"><a href="generating-and-displaying-execution-plans.html#GUID-74056529-E2A2-42CB-9230-4924C046260E">计划比较的用户界面</a><br>您可以使用<code class="codeph">DBMS_XPLAN.COMPARE_PLANS</code>以文本，XML或HTML格式生成报告。
                     </li>
                     <li class="ulchildlink"><a href="generating-and-displaying-execution-plans.html#GUID-60FF7945-DFA3-4E97-89D0-B4F11543C680">比较执行计划：教程</a><br>要比较计划，请使用<code class="codeph">DBMS_XPLAN.COMPARE_PLANS</code>函数。
                     </li>
                     <li class="ulchildlink"><a href="generating-and-displaying-execution-plans.html#GUID-7909832F-F81B-40CC-AB8A-7F52CA84F104">比较执行计划：示例</a><br>这些示例演示了如何为<code class="codeph">sh</code>模式中的表的查询生成比较计划报告。
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="generating-and-displaying-execution-plans.html#GUID-60E30B1C-342B-4D71-B154-C26623D6A3B1" title="了解如何解释语句并显示其计划对于SQL调优至关重要。">解释和显示执行计划</a></p>
                     </div>
                  </div>
               </div>
               
               <div class="sect3"><a id="GUID-932E5852-46C8-47F8-8FD4-1B3C3936CA1D" name="GUID-932E5852-46C8-47F8-8FD4-1B3C3936CA1D"></a><h4 id="TGSQL-GUID-932E5852-46C8-47F8-8FD4-1B3C3936CA1D" class="sect4"><span class="enumeration_section">6.4.1</span>计划比较的目的</h4>
                  <div>
                     <p>计划比较报告确定了差异的来源，这有助于用户对计划重现性问题进行分类。</p>
                     <p>计划比较报告在以下方案中特别有用：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>您希望将性能正在回归的查询的当前计划与AWR中捕获的旧计划进行比较。</p>
                        </li>
                        <li>
                           <p>SQL计划基准无法重现原始计划，您希望确定新计划与预期计划之间的差异。</p>
                        </li>
                        <li>
                           <p>您想确定添加提示，更改参数或创建索引将如何影响计划。</p>
                        </li>
                        <li>
                           <p>您希望确定基于SQL配置文件或SQL性能分析器生成的计划与原始计划的不同之处。</p>
                        </li>
                     </ul>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="generating-and-displaying-execution-plans.html#GUID-0023D232-5695-4BA8-89C5-88672B7647E2" title="计划比较工具采用参考计划和任意测试计划列表，并突出显示它们之间的差异。计划比较是合乎逻辑的而不是逐行的。">比较执行计划</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="sect3"><a id="GUID-74056529-E2A2-42CB-9230-4924C046260E" name="GUID-74056529-E2A2-42CB-9230-4924C046260E"></a><h4 id="TGSQL-GUID-74056529-E2A2-42CB-9230-4924C046260E" class="sect4"><span class="enumeration_section">6.4.2</span>计划比较的用户界面</h4>
                  <div>
                     <p>您可以使用<code class="codeph">DBMS_XPLAN.COMPARE_PLANS</code>以文本，XML或HTML格式生成报告。
                     </p>
                     <div class="section">
                        <p class="subhead3" id="GUID-74056529-E2A2-42CB-9230-4924C046260E__GUID-C2784720-8E14-402C-8920-C5856342E9FD">比较计划报告格式</p>
                        <p>报告以摘要开头。“ <code class="codeph">COMPARE PLANS REPORT</code>部分包括运行报告的用户和比较的计划数等信息，如以下示例所示：</p><pre class="pre codeblock"><code>比较计划报告----------------------------------------------- --------------------------当前用户：SH计划总数：2发现数量：1 --------- -------------------------------------------------- --------------</code></pre><p>报告的“ <code class="codeph">COMPARISON DETAILS</code>部分包含以下信息：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>计划信息</p>
                              <p>该信息包括计划编号，计划源，计划属性（根据源不同），解析架构和SQL文本。</p>
                           </li>
                           <li>
                              <p>计划</p>
                              <p>此部分显示计划行，包括谓词和注释。</p>
                           </li>
                           <li>
                              <p>比较结果</p>
                              <p>本节总结了比较结果，突出显示了逻辑差异，例如连接顺序，连接方法，访问路径和并行分发方法。调查结果从第<code class="codeph">1</code>开始。对于与特定查询块相关的发现，文本以块的名称开头。对于与特定对象别名相关的发现，文本以查询块的名称和对象别名开头。下列</p><pre class="pre codeblock"><code>比较结果（1）：----------------------------- 1。查询块SEL $ 1，别名PRODUCTS @ SEL $ 1：某些列（OPERATION，OPTIONS，OBJECT_NAME）在引用计划（id：2）和当前计划（id：2）之间不匹配。</code></pre></li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-74056529-E2A2-42CB-9230-4924C046260E__GUID-52888641-6CFC-4327-A387-39F18B4812B7">DBMS_XPLAN.PLAN_OBJECT_LIST表类型</p>
                        <p><code class="codeph">plan_object_list</code>类型允许将通用对象列表作为<code class="codeph">DBMS_XPLAN.COMPARE_PLANS</code>函数的输入。语法如下：</p><pre class="pre codeblock"><code>TYPE plan_object_list IS TABLE OF generic_plan_object;</code></pre><p>通用对象从所有计划源中抽象出计划的共同属性。每个计划源都是<code class="codeph">plan_object_list</code>超类的子类。下表总结了不同的计划来源。请注意，当可选参数为null时，它可以对应于多个对象。例如，如果没有为<code class="codeph">cursor_cache_object</code>指定子编号，则它将匹配具有指定SQL ID的所有游标缓存语句。</p>
                        <div class="tblformal" id="GUID-74056529-E2A2-42CB-9230-4924C046260E__GUID-DDFDDD63-3854-49FF-BCB7-82B41CC66B3E">
                           <p class="titleintable">表6-3 PLAN_OBJECT_LIST的计划来源</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="计划PLAN_OBJECT_LIST的来源" border="1" summary="This table describe the plan sources for the plan_object_list object." frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="20%" id="d21079e7423">计划来源</th>
                                    <th align="left" valign="bottom" width="20%" id="d21079e7425">规格</th>
                                    <th align="left" valign="bottom" width="20%" id="d21079e7427">描述</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d21079e7431" headers="d21079e7423 ">
                                       <p>计划表</p>
                                    </td>
                                    <td align="left" valign="top" width="20%" headers="d21079e7431 d21079e7425 "><pre class="pre codeblock"><code>plan_table_object（owner，plan_table_name，statement_id，plan_id）</code></pre></td>
                                    <td align="left" valign="top" width="20%" headers="d21079e7431 d21079e7427 ">
                                       <p>参数如下：</p>
                                       <ul style="list-style-type:disc">
                                          <li>
                                             <p><code class="codeph">owner</code> - 计划表的所有者</p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">plan_table_name</code> - 计划表的名称</p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">statement_id</code> - <code class="codeph">statement_id</code> ID（可选）</p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">plan_id</code> - 计划的ID（可选）</p>
                                          </li>
                                       </ul>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d21079e7462" headers="d21079e7423 ">
                                       <p>游标缓存</p>
                                    </td>
                                    <td align="left" valign="top" width="20%" headers="d21079e7462 d21079e7425 "><pre class="pre codeblock"><code>cursor_cache_object（sql_id，child_number）</code></pre></td>
                                    <td align="left" valign="top" width="20%" headers="d21079e7462 d21079e7427 ">
                                       <p>参数如下：</p>
                                       <ul style="list-style-type:disc">
                                          <li>
                                             <p><code class="codeph">sql_id</code> - 计划的SQL ID</p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">child_number</code> - 游标缓存中计划的子编号（可选）</p>
                                          </li>
                                       </ul>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d21079e7483" headers="d21079e7423 ">
                                       <p>AWR</p>
                                    </td>
                                    <td align="left" valign="top" width="20%" headers="d21079e7483 d21079e7425 "><pre class="pre codeblock"><code>awr_object（sql_id，dbid，con_dbid，plan_hash_value）</code></pre></td>
                                    <td align="left" valign="top" width="20%" headers="d21079e7483 d21079e7427 ">
                                       <p>参数如下：</p>
                                       <ul style="list-style-type:disc">
                                          <li>
                                             <p><code class="codeph">sql_id</code> - 计划的SQL ID</p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">dbid</code> - 数据库ID（可选）</p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">con_dbid</code> -  CDB ID（可选）</p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">plan_hash_value</code> - 计划的哈希值（可选）</p>
                                          </li>
                                       </ul>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d21079e7514" headers="d21079e7423 ">
                                       <p>SQL调优集</p>
                                    </td>
                                    <td align="left" valign="top" width="20%" headers="d21079e7514 d21079e7425 "><pre class="pre codeblock"><code>sqlset_object（sqlset_owner，sqlset_name，sql_id，plan_hash_value）</code></pre></td>
                                    <td align="left" valign="top" width="20%" headers="d21079e7514 d21079e7427 ">
                                       <p>参数如下：</p>
                                       <ul style="list-style-type:disc">
                                          <li>
                                             <p><code class="codeph">sqlset_owner</code> -  SQL调优集的所有者</p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">sqlset_name</code> -  SQL调优集的名称</p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">sql_id</code> - 计划的SQL ID</p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">plan_hash_value</code> - 计划的哈希值（可选）</p>
                                          </li>
                                       </ul>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d21079e7545" headers="d21079e7423 ">
                                       <p>SQL计划管理</p>
                                    </td>
                                    <td align="left" valign="top" width="20%" headers="d21079e7545 d21079e7425 "><pre class="pre codeblock"><code>spm_object（sql_handle，plan_name）</code></pre></td>
                                    <td align="left" valign="top" width="20%" headers="d21079e7545 d21079e7427 ">
                                       <p>参数如下：</p>
                                       <ul style="list-style-type:disc">
                                          <li>
                                             <p><code class="codeph">sql_handle</code> - 受SQL计划管理保护的计划的SQL句柄</p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">plan_name</code> -  SQL计划基准的名称（可选）</p>
                                          </li>
                                       </ul>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d21079e7566" headers="d21079e7423 ">
                                       <p>SQL配置文件</p>
                                    </td>
                                    <td align="left" valign="top" width="20%" headers="d21079e7566 d21079e7425 "><pre class="pre codeblock"><code>sql_profile_object（profile_name）</code></pre></td>
                                    <td align="left" valign="top" width="20%" headers="d21079e7566 d21079e7427 ">
                                       <p><code class="codeph">profile_name</code>参数指定SQL配置文件的名称。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d21079e7579" headers="d21079e7423 ">
                                       <p>顾问</p>
                                    </td>
                                    <td align="left" valign="top" width="20%" headers="d21079e7579 d21079e7425 "><pre class="pre codeblock"><code>advisor_object（task_name，execution_name，sql_id，plan_id）</code></pre></td>
                                    <td align="left" valign="top" width="20%" headers="d21079e7579 d21079e7427 ">
                                       <p>参数如下：</p>
                                       <ul style="list-style-type:disc">
                                          <li>
                                             <p><code class="codeph">task_name</code> - 顾问程序任务的名称</p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">execution_name</code> - 任务执行的名称</p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">sql_id</code> - 计划的SQL ID</p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">plan_id</code> - 顾问计划ID（可选）</p>
                                          </li>
                                       </ul>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-74056529-E2A2-42CB-9230-4924C046260E__GUID-2AA07398-CF24-491D-8717-F75BE6FDA123">DBMS_XPLAN.COMPARE_PLANS函数</p>
                        <p>比较计划工具的界面是以下功能：</p><pre class="pre codeblock"><code>DBMS_XPLAN.COMPARE_PLANS（reference_plan IN generic_plan_object，compare_plan_list IN plan_object_list，type IN VARCHAR2：='TEXT'，level IN VARCHAR2：='TYPICAL'，section IN VARCHAR2：='ALL'）RETURN CLOB;</code></pre><p>下表描述了指定要比较的计划的参数。</p>
                        <div class="tblformal" id="GUID-74056529-E2A2-42CB-9230-4924C046260E__GUID-E1B34511-BF4D-45E1-9A7C-0A71890A26A4">
                           <p class="titleintable">表6-4 COMPARE_PLANS功能的参数</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="COMPARE_PLANS函数的参数" border="1" summary="This table lists the parameters for COMPARE_PLANS." frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="20%" id="d21079e7628">参数</th>
                                    <th align="left" valign="bottom" width="20%" id="d21079e7630">描述</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d21079e7634" headers="d21079e7628 ">
                                       <p><code class="codeph">reference_plan</code></p>
                                    </td>
                                    <td align="left" valign="top" width="20%" headers="d21079e7634 d21079e7630 ">
                                       <p>指定<code class="codeph">generic_plan_object</code>类型的单个计划。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d21079e7645" headers="d21079e7628 ">
                                       <p><code class="codeph">compare_plan_list</code></p>
                                    </td>
                                    <td align="left" valign="top" width="20%" headers="d21079e7645 d21079e7630 ">
                                       <p>指定计划对象的列表。对象可能对应于一个或多个计划。</p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-74056529-E2A2-42CB-9230-4924C046260E__GUID-676346CB-54BC-489F-832A-BDE46855C50C">
                        <p class="titleinexample">例6-8比较儿童游标的计划</p>
                        <p>此示例将SQL ID <code class="codeph">8mkxm7ur07za0</code>的子游标编号2的计划与相同SQL ID的子游标编号4的计划进行比较。</p><pre class="pre codeblock"><code>VAR v_report CLOB; BEGIN：v_report：= DBMS_XPLAN.COMPARE_PLANS（reference_plan =&gt; CURSOR_CACHE_OBJECT（'8mkxm7ur07za0'，2），compare_plan_list =&gt; PLAN_OBJECT_LIST（CURSOR_CACHE_OBJECT（'8mkxm7ur07za0'，4）））;结束; / PRINT v_report</code></pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-74056529-E2A2-42CB-9230-4924C046260E__GUID-06C743A0-781A-44F1-B474-BEE3B6BC4368">
                        <p class="titleinexample">示例6-9将计划与子游标与SQL计划基准计划进行比较</p>
                        <p>此示例将SQL ID <code class="codeph">8mkxm7ur07za0</code>的子游标编号2的计划与SQL计划基准中的计划进行比较。基线查询的SQL句柄为<code class="codeph">SQL_024d0f7d21351f5d</code> ，计划名称为<code class="codeph">SQL_PLAN_sdfjkd</code> 。
                        </p><pre class="pre codeblock"><code>VAR v_report CLOB; BEGIN：v_report：= DBMS_XPLAN.COMPARE_PLANS（ -  reference_plan =&gt; CURSOR_CACHE_OBJECT（'8mkxm7ur07za0'，2），compare_plan_list =&gt; PLAN_OBJECT_LIST（SPM_OBJECT（'SQL_024d0f7d21351f5d'，'SQL_PLAN_sdfjkd'）））;结束;打印v_report</code></pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-74056529-E2A2-42CB-9230-4924C046260E__GUID-A6FF9164-BAB4-4EA7-BCDB-B422A96DDD57">
                        <p class="titleinexample">示例6-10将计划与多个来源的计划进行比较</p>
                        <p>此示例仅打印摘要部分。该程序将SQL ID <code class="codeph">8mkxm7ur07za0</code>的子游标号2的计划与以下列表中的每个计划进行比较：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>共享SQL区域中为SQL ID <code class="codeph">8mkxm7ur07za0</code>生成的所有计划</p>
                           </li>
                           <li>
                              <p>在SQL调优集<code class="codeph">SH. SQLT_WORKLOAD</code>生成的所有计划<code class="codeph">SH. SQLT_WORKLOAD</code>的SQL ID <code class="codeph">6vfqvav0rgyad</code></p>
                           </li>
                           <li>
                              <p>AWR中为数据库ID 5和SQL ID <code class="codeph">6vfqvav0rgyad</code>捕获的所有计划</p>
                           </li>
                           <li>
                              <p>具有名称<code class="codeph">SQL_PLAN_sdfjkd</code>句柄<code class="codeph">SQL_024d0f7d21351f5d</code>的查询的计划基准</p>
                           </li>
                           <li>
                              <p>存储在计划<code class="codeph">sh.plan_table</code>鉴定<code class="codeph">plan_id=38</code></p>
                           </li>
                           <li>
                              <p>由SQL配置文件名称<code class="codeph">pe3r3ejsfd</code>标识的计划</p>
                           </li>
                           <li>
                              <p>存储在SQL顾问程序中的所有计划由任务名称<code class="codeph">TASK_1228</code> ，执行名称<code class="codeph">EXEC_1928</code>和SQL ID <code class="codeph">8mkxm7ur07za0</code>标识</p>
                           </li>
                        </ul><pre class="pre codeblock"><code>VAR v_report CLOB BEGIN：v_report：= DBMS_XPLAN.COMPARE_PLANS（reference_plan =&gt; CURSOR_CACHE_OBJECT（'8mkxm7ur07za0'，2），compare_plan_list =&gt; plan_object_list（cursor_cache_object（'8mkxm7ur07za0'），sqlset_object（'SH'，'SQLT_WORKLOAD'，'6vfqvav0rgyad'） ，awr_object（'6vfqvav0rgyad'，5），spm_object（'SQL_024d0f7d21351f5d'，'SQL_PLAN_sdfjkd'），plan_table_object（'SH'，'plan_table'，38），sql_profile_object（'pe3r3ejsfd'），advisor_object（'TASK_1228'，'EXEC_1928' ，'8mkxm7ur07za0'）），type =&gt;'XML'，level =&gt;'ALL'，section =&gt;'SUMMARY'）;结束; / PRINT v_report</code></pre><div class="infoboxnote" id="GUID-74056529-E2A2-42CB-9230-4924C046260E__GUID-5F15DF37-5070-448A-914F-85CCCC51EB34">
                           <p class="notep1">注意：</p>
                           <p>有关<code class="codeph">DBMS_XPLAN</code>包的更多信息，请<code class="codeph">DBMS_XPLAN</code> <a href="../arpls/DBMS_XPLAN.html#GUID-BAD480AA-351A-48FE-A8E7-F0D8EF643EBF" target="_blank"><span><cite>Oracle Database PL / SQL包和类型参考</cite></span></a></p>
                        </div>
                     </div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="generating-and-displaying-execution-plans.html#GUID-0023D232-5695-4BA8-89C5-88672B7647E2" title="计划比较工具采用参考计划和任意测试计划列表，并突出显示它们之间的差异。计划比较是合乎逻辑的而不是逐行的。">比较执行计划</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="sect3"><a id="GUID-60FF7945-DFA3-4E97-89D0-B4F11543C680" name="GUID-60FF7945-DFA3-4E97-89D0-B4F11543C680"></a><h4 id="TGSQL-GUID-60FF7945-DFA3-4E97-89D0-B4F11543C680" class="sect4"><span class="enumeration_section">6.4.3</span>比较执行计划：教程</h4>
                  <div>
                     <p>要比较计划，请使用<code class="codeph">DBMS_XPLAN.COMPARE_PLANS</code>函数。
                     </p>
                     <div class="section">在本教程中，您将比较两个不同的查询。比较计划报告显示优化程序能够在一个查询中使用联接消除转换，但不能在另一个查询中使用联接消除转换。</div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-60FF7945-DFA3-4E97-89D0-B4F11543C680__GUID-610FD272-CC16-47EC-983E-F26F6809F0C1">假设</p>
                        <p>本教程假定用户<code class="codeph">sh</code>发出以下查询：</p><pre class="pre codeblock"><code>从产品p中选择count（*），其中p.prod_id = s.prod_id和p.prod_min_price&gt; 200;从产品p中选择count（*），其中p.prod_id = s.prod_id和s.quantity_sold = 43;</code></pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-60FF7945-DFA3-4E97-89D0-B4F11543C680__GUID-CF764952-1820-4CEC-939E-C2766009DFB4">要比较执行计划：</p>
                        <ol>
                           <li>
                              <p>启动SQL * Plus，并使用管理权限登录数据库。</p>
                           </li>
                           <li>
                              <p>查询<code class="codeph">V$SQL</code>以确定两个查询的SQL ID。
                              </p>
                              <p>以下查询查询包含字符串<code class="codeph">products</code>查询的<code class="codeph">V$SQL</code> ：</p><pre class="pre codeblock"><code>SET LINESIZE 120 COL SQL_ID FORMAT a20 COL SQL_TEXT FORMAT a60 SELECT SQL_ID，SQL_TEXT FROM V $ SQL WHERE SQL_TEXT LIKE'％products％'AND SQL_TEXT NOT LIKE'％SQL_TEXT％'ORDER BY SQL_ID; SQL_ID SQL_TEXT -------------------- ---------------------------- -------------------------------- 0hxmvnfkasg6q从产品p中选择计数（*），其中p.prod_id = s .prod_id和s.quantity_sold = 43 10dqxjph6bwum从产品p中选择计数（*），其中p.prod_id = s.prod_id和p.prod_min_price&gt; 200</code></pre></li>
                           <li>
                              <p>以<code class="codeph">sh</code>用户登录数据库。
                              </p>
                           </li>
                           <li>
                              <p>执行<code class="codeph">DBMS_XPLAN.COMPARE_PLANS</code>函数，指定在上一步中获取的SQL ID。
                              </p>
                              <p>例如，执行以下程序：</p><pre class="pre codeblock"><code>VARIABLE v_rep CLOB BEGIN：v_rep：= DBMS_XPLAN.COMPARE_PLANS（reference_plan =&gt; cursor_cache_object（'0hxmvnfkasg6q'，NULL），compare_plan_list =&gt; plan_object_list（cursor_cache_object（'10dqxjph6bwum'，NULL）），type =&gt;'TEXT'，level =&gt;' TYPICAL'，section =&gt;'ALL'）;结束; /</code></pre></li>
                           <li>
                              <p>打印报告。</p>
                              <p>例如，运行以下查询：</p><pre class="pre codeblock"><code>SET PAGESIZE 50000 SET LONG 100000 SET LINESIZE 210 COLUMN报告FORMAT a200 SELECT：v_rep REPORT FROM DUAL;</code></pre><p>以下示例报告的“ <code class="codeph">Comparison Results</code>部分显示只有第一个查询使用了连接消除转换：</p><pre class="pre codeblock"><code>REPORT ------------------------------------------------- --------------------------------------------比较计划报告--- -------------------------------------------------- ----------------------------------------当前用户：SH计划总数：2调查结果：1 --------------------------------------------- ------------------------------------------------比较详情-------------------------------------------------- -------------------------------------------计划编号：1（参考计划）找到计划：是计划源：游标缓存SQL ID：0hxmvnfkasg6q子编号：0计划数据库版本：19.0.0.0解析架构：“SH”SQL文本：从产品p中选择计数（*），其中p.prod_id = s.prod_id和s.quantity_sold = 43计划-----------------------------计划哈希价值：3519235612 ------ -------------------------------------------------- ----------------- | Id |操作|名称|行|字节|成本|时间| -------------------------------------------------- ----------------------- | 0 |选择声明| | | | 469 | | | 1 | SORT AGGREGATE | | 1 | 3 | | | | 2 | PARTITION RANGE ALL | | 1 | 3 | 469 | 00:00:01 | | * 3 |表访问完全|销售| 1 | 3 | 469 | 00:00:01 | -------------------------------------------------- -----------------------谓词信息（由操作ID标识）：------------------ ------------------------ * 3  - 过滤器（“S”。“QUANTITY_SOLD”= 43）----------- -------------------------------------------------- --------------------------------计划编号：2计划发现：是计划来源：游标缓存SQL ID：10dqxjph6bwum Child编号：0计划数据库版本：19.0.0.0解析架构：“SH”SQL文本：从产品p中选择count（*），其中p.prod_id = s.prod_id和p.prod_min_price&gt; 200计划----- ------------------------计划哈希价值：3037679890 --------------------- -------------------------------------------------- --------------------------- | Id |操作|名称|行|字节|成本|时间| -------------------------------------------------- ------------------------------------------------ | 0 |选择声明| | | | 34 | | | 1 | SORT AGGREGATE | | 1 | 13 | | | | * 2 | HASH JOIN | | 781685 | 10161905 | 34 | 00:00:01 | | * 3 |表访问完全|产品| 61 | 549 | 2 | 00:00:01 | | 4 | PARTITION RANGE ALL | | 918843 | 3675372 | 29 | 00:00:01 | | 5 | BITMAP转换为ROWIDS | | 918843 | 3675372 | 29 | 00:00:01 | | 6 | BITMAP INDEX FAST FULL SCAN | SALES_PROD_BIX | | | | | -------------------------------------------------- ------------------------------------------------谓词信息（由操作ID标识）：------------------------------------------ * 2  - 访问（“P”。“PROD_ID”=“S”。“PROD_ID”）* 3  - 过滤器（“P”。“PROD_MIN_PRICE”&gt; 200）注意-----  - 这是一个自适应计划<span class="bold">比较结果（ 1）：----------------------------- 1。查询块SEL $ 1：仅在参考计划中发生了从QUERY BLOCK中删除的转换JOIN（结果查询块：SEL $ A43D1678）。
</span></code></pre></li>
                        </ol>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-60FF7945-DFA3-4E97-89D0-B4F11543C680__GUID-C9ACC884-2673-4915-B4AC-29BFAD34B79F">
                        <p class="notep1">也可以看看：</p>
                        <p>有关<code class="codeph">DBMS_XPLAN</code>包的更多信息，请<code class="codeph">DBMS_XPLAN</code> <a href="../arpls/DBMS_XPLAN.html#GUID-BAD480AA-351A-48FE-A8E7-F0D8EF643EBF" target="_blank"><span><cite>Oracle Database PL / SQL包和类型参考</cite></span></a></p>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="generating-and-displaying-execution-plans.html#GUID-0023D232-5695-4BA8-89C5-88672B7647E2" title="计划比较工具采用参考计划和任意测试计划列表，并突出显示它们之间的差异。计划比较是合乎逻辑的而不是逐行的。">比较执行计划</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="sect3"><a id="GUID-7909832F-F81B-40CC-AB8A-7F52CA84F104" name="GUID-7909832F-F81B-40CC-AB8A-7F52CA84F104"></a><h4 id="TGSQL-GUID-7909832F-F81B-40CC-AB8A-7F52CA84F104" class="sect4"><span class="enumeration_section">6.4.4</span>比较执行计划：示例</h4>
                  <div>
                     <p>这些示例演示了如何为<code class="codeph">sh</code>模式中的表的查询生成比较计划报告。
                     </p>
                     <div class="example" id="GUID-7909832F-F81B-40CC-AB8A-7F52CA84F104__GUID-7FBF8FC9-94DC-473A-B911-CE5A46FD71D4">
                        <p class="titleinexample">示例6-11将解释的计划与游标中的计划进行比较</p>
                        <p>此示例说明了在<code class="codeph">sh</code>模式中查询表的计划，然后执行查询：</p><pre class="pre codeblock"><code>EXPLAIN PLAN SET STATEMENT_ID ='TEST'用于选择c.cust_city，SUM（s.quantity_sold）FROM customers c，sales s，products p WHERE c.cust_id = s.cust_id AND p.prod_id = s.prod_id AND prod_min_price&gt; 100 GROUP通过c.cust_city; SELECT c.cust_city，SUM（s.quantity_sold）FROM customers c，sales s，products p WHERE c.cust_id = s.cust_id AND p.prod_id = s.prod_id AND prod_min_price&gt; 100 GROUP BY c.cust_city;</code></pre><p>假设执行的查询的SQL ID是<code class="codeph">9mp7z6qq83k5y</code> 。以下PL / SQL程序将<code class="codeph">PLAN_TABLE</code>的计划与共享SQL区域中的计划进行比较：</p><pre class="pre codeblock"><code>BEGIN：v_rep：= DBMS_XPLAN.COMPARE_PLANS（reference_plan =&gt; plan_table_object（'SH'，'PLAN_TABLE'，'TEST'，NULL），compare_plan_list =&gt; plan_object_list（cursor_cache_object（'9mp7z6qq83k5y'）），type =&gt;'TEXT'，level &gt;'TYPICAL'，section =&gt;'ALL'）;结束; / PRINT v_rep</code></pre><p>以下示例报告显示计划相同：</p><pre class="pre codeblock"><code>比较计划报告----------------------------------------------- --------------------------当前用户：SH计划总数：2发现数量：1 --------- -------------------------------------------------- --------------比较细节---------------------------------- ---------------------------------------计划编号：1（参考计划）计划发现：是计划来源：计划表计划表所有者：SH计划表名称：PLAN_TABLE语句ID：测试计划ID：52计划数据库版本：19.0.0.0解析架构：“SH”SQL文本：无SQL文本计划------ -----------------------计划哈希价值：3473931970 ---------- -------------------------------------------------- -  | ID |操作|名称|行|字节|成本|时间| -------------------------------------------------- ------------------------ | 0 |选择声明| | 620 | 22320 | 1213 | 00:00:01 | | 1 | HASH GROUP BY | | 620 | 22320 | 1213 | 00:00:01 | | * 2 | HASH JOIN | | 160348 | 5772528 | 1209 | 00:00:01 | | 3 |表访问完整|客户| 55500 | 832500 | 414 | 00:00:01 | | * 4 | HASH JOIN | | 160348 | 3367308 | 472 | 00:00:01 | | * 5 |表访问完整|产品| 13 | 117 | 2 | 00:00:01 | | 6 | PARTITION RANGE ALL | | 918843 | 11026116 | 467 | 00:00:01 | | 7 | TABLE ACCESS FULL | SALES | 918843 | 11026116 | 467 | 00:00:01 | -------------------------------------------------- ------------------------谓词信息（由操作ID标识）：----------------- ------------------------- * 2  - 访问（“C”。“CUST_ID”=“S”。“CUST_ID”）* 4  - 访问（“P”。“PROD_ID”=“S”。“PROD_ID”）* 5  - 过滤器（“PROD_MIN_PRICE”&gt; 100）注意-----  - 这是一个自适应计划---------- -------------------------------------------------- --------------------计划编号：2计划发现：是计划来源：游标缓存SQL ID：9mp7z6qq83k5y子编号：0计划数据库版本：19.0.0.0解析架构：“SH”SQL文本：选择c.cust_city，sum（s.quantity_sold）来自客户c，sales s，产品p其中c.cust_id = s.cust_id和p.prod_id = s.prod_id和prod_min_price&gt; 100 group by c .cust_city Plan ----------------------------- Plan Hash Value：3473931970 ------------- -------------------------------------------------- ------------- | Id |操作|名称|行|字节|成本|时间| -------------------------------------------------- -------------------------- | 0 |选择声明| | | | 1213 | | | 1 | HASH GROUP BY | | 620 | 22320 | 1213 | 00:00:01 | | * 2 | HASH JOIN | | 160348 | 5772528 | 1209 | 00:00:01 | | 3 |表访问完整|客户| 55500 | 832500 | 414 | 00:00:01 | | * 4 | HASH JOIN | | 160348 | 3367308 | 472 | 00:00:01 | | * 5 |表访问完整|产品| 13 | 117 | 2 | 00:00:01 | | 6 | PARTITION RANGE ALL | | 918843 | 11026116 | 467 | 00:00:01 | | 7 | TABLE ACCESS FULL | SALES | 918843 | 11026116 | 467 | 00:00:01 | -------------------------------------------------- --------------------------谓词信息（由操作ID标识）：--------------- --------------------------- * 2  -  access（“C”。“CUST_ID”=“S”。“CUST_ID”）* 4 - 访问（“P”。“PROD_ID”=“S”。“PROD_ID”）* 5  - 过滤器（“PROD_MIN_PRICE”&gt; 100）注意事项-----  - 这是一个自适应计划<span class="bold">比较结果（1）： - --------------------------- 1。计划是一样的。</span></code></pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-7909832F-F81B-40CC-AB8A-7F52CA84F104__GUID-C7596A42-1556-4578-942B-26EF24F8C190">
                        <p class="titleinexample">示例6-12比较基准和SQL调整集中的计划</p>
                        <p>假设您要比较以下查询的计划，这些计划仅在子查询中包含的<code class="codeph">NO_MERGE</code>提示方面有所不同：</p><pre class="pre codeblock"><code>SELECT c.cust_city，SUM（s.quantity_sold）FROM customers c，sales s，（SELECT prod_id FROM products WHERE prod_min_price&gt; 100）p WHERE c.cust_id = s.cust_id AND p.prod_id = s.prod_id GROUP BY c.cust_city ; SELECT c.cust_city，SUM（s.quantity_sold）FROM customers c，sales s，（SELECT / * + NO_MERGE * / prod_id FROM products WHERE prod_min_price&gt; 100）WHERE c.cust_id = s.cust_id AND p.prod_id = s.prod_id GROUP BY c.cust_city;</code></pre><p>使用SQL句柄<code class="codeph">SQL_c522f5888cc4613e</code>在SQL计划管理基线中捕获第一个查询的计划。第二个查询的计划存储在名为<code class="codeph">MYSTS1</code>的SQL调优集中，其SQL ID为<code class="codeph">d07p7qmrm13nc</code> 。您运行以下PL / SQL程序来比较计划：</p><pre class="pre codeblock"><code>VAR v_rep CLOB BEGIN v_rep：= DBMS_XPLAN.COMPARE_PLANS（reference_plan =&gt; spm_object（'SQL_c522f5888cc4613e'），compare_plan_list =&gt; plan_object_list（sqlset_object（'SH'，'MYSTS1'，'d07p7qmrm13nc'，null）），type =&gt;'TEXT' ，level =&gt;'TYPICAL'，section =&gt;'ALL'）;结束; / PRINT v_rep</code></pre><p>以下输出显示唯一的参考计划（对应于没有提示的查询）使用了视图合并：</p><pre class="pre codeblock"><code>-------------------------------------------------- -------------------------------------------比较计划报告---- -------------------------------------------------- ---------------------------------------当前用户：SH总计划数：2个发现：1 ---------------------------------------------- -----------------------------------------------比较详情 - -------------------------------------------------- ------------------------------------------计划编号：1（参考计划）发现计划：是计划源：SQL计划基准SQL句柄：SQL_c522f5888cc4613e计划名称：SQL_PLAN_ca8rpj26c8s9y7c2279c4计划数据库版本：19.0.0.0解析架构：“SH”SQL文本：选择c.cust_city，sum（s.quantity_sold）来自客户c，销售s，（从prod_min_price&gt; 100的产品中选择prod_id）p其中c.cust_id = s.cust_id和p.prod id = s.prod_id group by c.cust_city Plan -------------- ---------------计划哈希值：2082634180 ------------------------------ - ----------------------------------------------- | Id |操作|名称|行|字节|成本|时间| -------------------------------------------------- ---------------------------- | 0 |选择声明| | | | 22 | | | 1 | HASH GROUP BY | | 300 | 11400 | 22 | 00:00:01 | | 2 | HASH JOIN | | 718 | 27284 | 21 | 00:00:01 | | 3 |表访问完全|客户| 630 | 9450 | 5 | 00:00:01 | | 4 | HASH JOIN | | 718 | 16514 | 15 | 00:00:01 | | 5 |表访问完全|产品| 573 | 5730 | 9 | 00:00:01 | | 6 | PARTITION RANGE ALL | | 960 | 12480 | 5 | 00:00:01 | | 7 |表访问完全|销售| 960 | 12480 | 5 | 00:00:01 | -------------------------------------------------- ---------------------------- ---------------------- -------------------------------------------------- ------计划编号：2计划找到：是计划源：SQL调优集SQL调优集所有者：SH SQL调优集名称：MYSTS1 SQL ID：d07p7qmrm13nc计划哈希值：655891922计划数据库版本：19.0.0.0解析架构：“SH”SQL文本：选择c.cust_city，sum（s.quantity_sold）来自客户c，sales s，（选择/ * + NO_MERGE * / prod_id来自产品，其中prod_min_price&gt; 100）p其中c.cust_id = s.cust_id和c.prod_id = s.prod_id group by c.cust_city Plan ----------------------------- Plan Hash Value：655891922  - -------------------------------------------------- -------------------------- | Id |操作|名称|行|字节|成本|时间| -------------------------------------------------- ---------------------------- | 0 |选择声明| | | | 23 | | | 1 | HASH GROUP BY | | 300 | 9900 | 23 | 00:00:01 | | 2 | HASH JOIN | | 718 | 23694 | 21 | 00:00:01 | | 3 | HASH JOIN | | 718 | 12924 | 15 | 00:00:01 | | 4 |查看| | 573 | 2865 | 9 | 00:00:01 | | 5 |表访问完全|产品| 573 | 5730 | 9 | 00:00:01 | | 6 | PARTITION RANGE ALL | | 960 | 12480 | 5 | 00:00:01 | | 7 |表访问完全|销售| 960 | 12480 | 5 | 00:00:01 | | 8 |表访问完全|客户| 630 | 9450 | 5 | 00:00:01 | -------------------------------------------------- ---------------------------- Notes -----  - 这是一个自适应计划<span class="bold">比较结果（1）：---- ------------------------- 1。查询块SEL $ 1：转换视图MERGE仅在参考计划中发生（结果查询块：SEL $ F5BB74E1）。
</span></code></pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-7909832F-F81B-40CC-AB8A-7F52CA84F104__GUID-1AE8839D-6DEF-4BB3-B3DA-5E8A842CCBAA">
                        <p class="titleinexample">示例6-13比较添加索引之前和之后的计划</p>
                        <p>在此示例中，您将测试索引对查询计划的影响：</p><pre class="pre codeblock"><code>EXPLAIN PLAN SET STATEMENT_ID ='TST1'FOR SELECT COUNT（*）FROM products WHERE prod_min_price&gt; 100; CREATE INDEX newprodidx ON产品（prod_min_price）; EXPLAIN PLAN SET STATEMENT_ID ='TST2'FOR SELECT COUNT（*）FROM products WHERE prod_min_price&gt; 100;</code></pre><p>您执行以下PL / SQL程序以生成报告：</p><pre class="pre codeblock"><code>VAR v_rep CLOB BEGIN：v_rep：= DBMS_XPLAN.COMPARE_PLANS（reference_plan =&gt; plan_table_object（'SH'，'PLAN_TABLE'，'TST1'，NULL），compare_plan_list =&gt; plan_object_list（plan_table_object（'SH'，'PLAN_TABLE'，'TST2'） ，NULL）），TYPE =&gt;'TEXT'，level =&gt;'TYPICAL'，section =&gt;'ALL'）;结束; / PRINT v_rep</code></pre><p>以下报告表明两个计划中的操作不同：</p><pre class="pre codeblock"><code>比较计划报告----------------------------------------------- ---------------------------当前用户：SH计划总数：2发现数量：1 -------- -------------------------------------------------- ----------------比较详情-------------------------------- ------------------------------------------计划编号：1（参考计划）发现计划：是计划来源：计划表计划表所有者：SH计划表名称：PLAN_TABLE语句ID：TST1计划ID：56计划数据库版本：19.0.0.0解析架构：“SH”SQL文本：无SQL文本计划--- --------------------------计划哈希值：3421487369 ------------------- -------------------------------------------------- ----- | Id |操作|名称|行|字节|成本|时间| -------------------------------------------------- ------------------------ | 0 |选择声明| | 1 | 5 | 2 | 00:00:01 | | 1 | SORT AGGREGATE | | 1 | 5 | | | | * 2 |表访问完全|产品| 13 | 65 | 2 | 00:00:01 | -------------------------------------------------- ------------------------谓词信息（由操作ID标识）：----------------- ------------------------- * 2  - 过滤器（“PROD_MIN_PRICE”&gt; 100）-------------- -------------------------------------------------- ----------计划编号：2计划找到：是计划来源：计划表计划表所有者：SH计划表名称：PLAN_TABLE语句ID：TST2计划ID：57计划数据库版本：19.0.0.0解析架构：“SH”SQL文本：无SQL文本计划-----------------------------计划哈希值：2694011010 ----- -------------------------------------------------- -------------------- | Id |操作|名称|行|字节|成本|时间| -------------------------------------------------- ------------------------- | 0 |选择声明| | 1 | 5 | 1 | 00:00:01 | | 1 | SORT AGGREGATE | | 1 | 5 | | | | * 2 | INDEX RANGE SCAN | NEWPRODIDX | 13 | 65 | 1 | 00:00:01 | -------------------------------------------------- -------------------------谓词信息（由操作ID标识）：---------------- -------------------------- * 2  - 访问（“PROD_MIN_PRICE”&gt; 100） <span class="bold">比较结果（1）：------- ---------------------- 1。查询块SEL $ 1，别名PRODUCTS @ SEL $ 1：某些列（OPERATION，OPTIONS，OBJECT_NAME）在引用计划（id：2）和当前计划（id：2）之间不匹配。
</span></code></pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-7909832F-F81B-40CC-AB8A-7F52CA84F104__GUID-1E8F7CDB-90EC-4631-B131-DC3D7166E164">
                        <p class="titleinexample">示例6-14将计划与可见和不可见索引进行比较</p>
                        <p>在此示例中，应用程序执行以下查询：</p><pre class="pre codeblock"><code>从产品p中选择count（*），其中p.prod_id = s.prod_id和p.prod_status ='obsolete';</code></pre><p>此查询的计划使用两个索引： <code class="codeph">sales_prod_bix</code>和<code class="codeph">products_prod_status_bix</code> 。数据库生成四个计划，使用两个索引的所有可见和不可见组合。假设SQL计划管理在查询的基线中接受以下计划：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">sales_prod_bix</code>可见， <code class="codeph">products_prod_status_bix</code>可见</p>
                           </li>
                           <li>
                              <p><code class="codeph">sales_prod_bix</code>可见， <code class="codeph">products_prod_status_bix</code>不可见</p>
                           </li>
                           <li>
                              <p><code class="codeph">sales_prod_bix</code>不可见， <code class="codeph">products_prod_status_bix</code>可见</p>
                           </li>
                        </ul>
                        <p>您使两个索引都不可见，然后再次执行查询。优化程序无法使用不可见索引生成新计划。三个基线计划都依赖于至少一个可见的索引，无法重现。因此，优化程序使用新计划并将其添加到查询的SQL计划基准中。要将共享SQL区域中的当前计划（参考计划）与基准中的所有四个计划进行比较，请执行以下PL / SQL代码：</p><pre class="pre codeblock"><code>VAR v_rep CLOB BEGIN：v_rep：= DBMS_XPLAN.COMPARE_PLANS（reference_plan =&gt; cursor_cache_object（'45ns3tzutg0ds'），compare_plan_list =&gt; plan_object_list（spm_object（'SQL_aec814b0d452da8a'）），TYPE =&gt;'TEXT'，level =&gt;'TYPICAL'，section &gt;'全'）;结束; / PRINT v_rep</code></pre><p>以下报告比较了所有五个计划：</p><pre class="pre codeblock"><code>-------------------------------------------------- ---------------------------比较计划报告-------------------- -------------------------------------------------- -------当前用户：SH计划总数：5发现数量：19 ---------------------------- -------------------------------------------------比较细节  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  - - ----------------------------计划编号：1（参考计划）计划发现：是计划来源：游标缓存SQL ID：45ns3tzutg0ds Child编号：0计划数据库版本：19.0.0.0解析架构：“SH”SQL文本：从产品p中选择计数（*），销售s其中p.prod_id = s.prod_id和p.prod_status ='过时'计划--- --------------------------计划哈希值：1136711713 ------------------- -------------------------------------------------- --------- | Id |操作|名称|行|字节|成本|时间| -------------------------------------------------- ---------------------------- | 0 |选择声明| | | | 15 | | | 1 | SORT AGGREGATE | | 1 | 30 | | | | * 2 | HASH JOIN | | 320 | 9600 | 15 | 00:00:01 | | 3 |加入过滤器创建| ：BF0000 | 255 | 6375 | 9 | 00:00:01 | | * 4 |表访问完全|产品| 255 | 6375 | 9 | 00:00:01 | | 5 |加入过滤器使用| ：BF0000 | 960 | 4800 | 5 | 00:00:01 | | 6 | PARTITION RANGE ALL | | 960 | 4800 | 5 | 00:00:01 | | * 7 |表访问完全|销售| 960 | 4800 | 5 | 00:00:01 | -------------------------------------------------- ----------------------------谓词信息（由操作ID标识）：------------- ----------------------------- * 2  -  access（“P”。“PROD_ID”=“S”。“PROD_ID”） * 4  - 过滤器（“P”。“PROD_STATUS”='过时'）* 7  - 过滤器（SYS_OP_BLOOM_FILTER（：BF0000，“S”。“PROD_ID”））注意-----  -  baseline_repro_fail = yes ---- -------------------------------------------------- ---------------------------------------计划编号：2找到的计划：是计划来源： SQL计划基准SQL句柄：SQL_aec814b0d452da8a计划名称：SQL_PLAN_axk0nq3a55qna6e039463计划数据库版本：19.0.0.0解析架构：“SH”SQL文本：从产品p，sales s中选择count（*），其中p.prod_id = s.prod_id和p.prod_status ='过时'计划-----------------------------计划哈希价值：1845728355 ----------- -------------------------------------------------- ------------------------------------ | Id |操作|名称|行|字节|成本|时间| -------------------------------------------------- ----------------------------------------------- | 0 |选择声明| | 1 | 30 | 11 | 00:00：01 | | 1 | SORT AGGREGATE | | 1 | 30 | | | | * 2 | HASH JOIN | | 320 | 9600 | 11 | 00:00：01 | | 3 |加入过滤器创建| ：BF0000 | 255 | 6375 | 5 | 00:00:01 | | * 4 |查看| index $ _join $ _001 | 255 | 6375 | 5 | 00:00:01 | | * 5 | HASH JOIN | | | | | | | 6 | BITMAP转换为ROWIDS | | 255 | 6375 | 1 | 00:00：01 | | * 7 | BITMAP INDEX单一价值| PRODUCTS_PROD_STATUS_BIX | | | | | | 8 | INDEX FAST FULL SCAN | PRODUCTS_PK | 255 | 6375 | 4 | 00:00:01 | | 9 |加入过滤器使用| ：BF0000 | 960 | 4800 | 5 | 00:00:01 | | 10 | PARTITION RANGE ALL | | 960 | 4800 | 5 | 00:00:01 | | * 11 |表访问完全|销售| 960 | 4800 | 5 | 00:00:01 | -------------------------------------------------- -----------------------------------------------谓词信息（由操作ID识别：------------------------------------------ * 2 - 访问（“P”。“PROD_ID”=“S”。“PROD_ID”）* 4  - 过滤器（“P”。“PROD_STATUS”='过时'）* 5  - 访问（ROWID = ROWID）* 7  - 访问（ “P”。“PROD_STATUS”='过时'）* 11  - 过滤器（SYS_OP_BLOOM_FILTER（：BF0000，“S”。“PROD_ID”）） <span class="bold">比较结果（4）：------------- ---------------- 1。查询块SEL $ 1，别名P @ SEL $ 1：当前计划中缺少参考计划中的某些行（id：4）。2。查询块SEL $ 1，别名S @ SEL $ 1：参考计划（id：5）和当前计划（id：9）之间的某些列（ID）不匹配。3。查询块SEL $ 1，别名S @ SEL $ 1：某些列（ID，PARENT_ID，PARTITION_ID）在引用计划（id：6）和当前计划（id：10）之间不匹配。4。查询块SEL $ 1，别名S @ SEL $ 1：参考计划（id：7）和当前计划（id：11）之间的某些列（ID，PARENT_ID，PARTITION_ID）不匹配。</span>-------------------------------------------------- -------------------------------------------计划编号：3计划发现：是计划源：SQL计划基准SQL句柄：SQL_aec814b0d452da8a计划名称：SQL_PLAN_axk0nq3a55qna43c0d821计划数据库版本：19.0.0.0解析架构：“SH”SQL文本：从产品p中选择计数（*），其中p.prod_id = s.prod_id和p.prod_status ='过时'计划-----------------------------计划哈希价值：1136711713 ------- -------------------------------------------------- --------------------- | Id |操作|名称|行|字节|成本|时间| -------------------------------------------------- ---------------------------- | 0 |选择声明| | 1 | 30 | 15 | 00:00:01 | | 1 | SORT AGGREGATE | | 1 | 30 | | | | * 2 | HASH JOIN | | 320 | 9600 | 15 | 00:00:01 | | 3 |加入过滤器创建| ：BF0000 | 255 | 6375 | 9 | 00:00:01 | | * 4 |表访问完全|产品| 255 | 6375 | 9 | 00:00:01 | | 5 |加入过滤器使用| ：BF0000 | 960 | 4800 | 5 | 00:00:01 | | 6 | PARTITION RANGE ALL | | 960 | 4800 | 5 | 00:00:01 | | * 7 |表访问完全|销售| 960 | 4800 | 5 | 00:00:01 | -------------------------------------------------- ----------------------------谓词信息（由操作ID标识）：------------- ----------------------------- * 2  -  access（“P”。“PROD_ID”=“S”。“PROD_ID”） * 4  - 过滤器（“P”。“PROD_STATUS”='过时'）* 7  - 过滤器（SYS_OP_BLOOM_FILTER（：BF0000，“S”。“PROD_ID”））比较结果（1）：-------- --------------------- 1。计划是一样的。-------------------------------------------------- ----------------------------计划编号：4计划发现：是计划来源：SQL计划基准SQL句柄：SQL_aec814b0d452da8a计划名称：SQL_PLAN_axk0nq3a55qna1b7aea6c计划数据库版本：19.0.0.0解析架构：“SH”SQL文本：从产品p中选择count（*），其中p.prod_id = s.prod_id和p.prod_status ='过时'计划------ -----------------------计划哈希值：461040236 ---------- -------------------------------------------------- ------------- | Id |操作|名称|行|字节|成本|时间| -------------------------------------------------- ------- --------------------------- | 0 |选择声明| | 1 | 30 | 10 | 00:00:01 | | 1 | SORT AGGREGATE | | 1 | 30 | | | | 2 | NESTED LOOPS | | 320 | 9600 | 10 | 00:00:01 | | * 3 |表访问完全|产品| 255 | 6375 | 9 | 00:00:01 | | 4 | PARTITION RANGE ALL | | 1 | 5 | 10 | 00:00:01 | | 5 | BITMAP CONVERSION COUNT | | 1 | 5 | 10 | 00:00:01 | | * 6 | BITMAP INDEX单一价值| SALES_PROD_BIX | | | | | -------------------------------------------------- -----------------------------------谓词信息（由操作ID标识）：------ ------------------------------------ * 3  -  filter（“P”。“PROD_STATUS”='过时'）* 6  - 访问（“P”。“PROD_ID”=“S”。“PROD_ID”） <span class="bold">比较结果（7）：-------------------- --------- 1。查询块SEL $ 1，别名P @ SEL $ 1：当前计划中缺少参考计划中的某些行（id：3）。2。查询块SEL $ 1，别名S @ SEL $ 1：当前计划中缺少参考计划中的某些行（id：5）。3。查询块SEL $ 1，别名S @ SEL $ 1：当前计划中缺少参考计划中的某些行（id：7）。4。查询块SEL $ 1，别名S @ SEL $ 1：参考计划中缺少当前计划中的某些行（id：5,6）。5。查询块SEL $ 1，别名P @ SEL $ 1：参考计划（id：2）和当前计划（id：2）之间的某些列（OPERATION）不匹配。6。查询块SEL $ 1，别名P @ SEL $ 1：某些列（ID，PARENT_ID，DEPTH）在引用计划（id：4）和当前计划（id：3）之间不匹配。7。查询块SEL $ 1，别名S @ SEL $ 1：参考计划（id：6）和当前计划（id：4）之间的某些列（ID，PARENT_ID，DEPTH，POSITION，PARTITION_ID）不匹配。</span>-------------------------------------------------- -------------------------------------------计划编号：5计划发现：是计划源：SQL计划基准SQL句柄：SQL_aec814b0d452da8a计划名称：SQL_PLAN_axk0nq3a55qna0628afbd计划数据库版本：19.0.0.0解析架构：“SH”SQL文本：从产品p中选择计数（*），其中p.prod_id = s.prod_id和p.prod_status ='过时'计划-----------------------------计划哈希价值：103329725 ------- -------------------------------------------------- ---------------------------------- | Id |操作|名称|行|字节|成本|时间| -------------------------------------------------- ----------------------------------------- | 0 |选择声明| | | | 5 | | | 1 | SORT AGGREGATE | | 1 | 30 | | | | 2 | NESTED LOOPS | | 320 | 9600 | 5 | 00:00:01 | | 3 |查看| index $ _join $ _001 | 255 | 6375 | 5 | 00:00:01 | | 4 | HASH JOIN | | | | | | | 5 | BITMAP转换为ROWIDS | | 255 | 6375 | 1 | 00:00：01 | | 6 | BITMAP INDEX单一价值| PRODUCTS_PROD_STATUS_BIX | | | | | | 7 | INDEX FAST FULL SCAN | PRODUCTS_PK | 255 | 6375 | 4 | 00:00:01 | | 8 | PARTITION RANGE ALL | | 1 | 5 | 5 | 00:00:01 | | 9 | BITMAP转换为ROWIDS | | 1 | 5 | 5 | 00:00:01 | | 10 | BITMAP INDEX单一价值| SALES_PROD_BIX | | | | | -------------------------------------------------- ----------------------------------------- <span class="bold">比较结果（7）：--- -------------------------- 1。查询块SEL $ 1，别名P @ SEL $ 1：当前计划中缺少参考计划中的某些行（id：3）。2。查询块SEL $ 1，别名P @ SEL $ 1：当前计划中缺少参考计划中的某些行（id：4）。3。查询块SEL $ 1，别名S @ SEL $ 1：当前计划中缺少参考计划中的某些行（id：5）。4。查询块SEL $ 1，别名S @ SEL $ 1：当前计划中缺少参考计划中的某些行（id：7）。5。查询块SEL $ 1，别名S @ SEL $ 1：参考计划中缺少当前计划中的某些行（id：9,10）。6。查询块SEL $ 1，别名P @ SEL $ 1：参考计划（id：2）和当前计划（id：2）之间的某些列（OPERATION）不匹配。7。查询块SEL $ 1，别名S @ SEL $ 1：某些列（ID，PARENT_ID，DEPTH，POSITION，PARTITION_ID）在引用计划（id：6）和当前计划（id：8）之间不匹配。</span>
</code></pre><p>上述报告显示以下内容：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>计划1是共享SQL区域的参考计划。该计划不使用既不可见的索引，也不会重现基准计划。</p>
                           </li>
                           <li>
                              <p>计划2位于基线中，并假设<code class="codeph">sales_prod_bix</code>不可见且<code class="codeph">products_prod_status_bix</code>可见。
                              </p>
                           </li>
                           <li>
                              <p>计划3在基线中，并假设两个索引都是不可见的。计划1和计划3是相同的。</p>
                           </li>
                           <li>
                              <p>计划4位于基线中，并假设<code class="codeph">sales_prod_bix</code>可见且<code class="codeph">products_prod_status_bix</code>不可见。
                              </p>
                           </li>
                           <li>
                              <p>计划5在基线中并假设两个索引都是可见的。</p>
                           </li>
                        </ul>
                        <p>比较报告显示，计划1无法从该基准重现计划。原因是游标（计划1）中的计划已添加到基准中，因为在执行时没有可用的基准计划，因此数据库执行了语句的软解析并生成了无索引计划。如果当前光标无效，并且如果要再次执行查询，则比较报告将显示光标计划确实重现了基线计划。</p>
                        <div class="infoboxnotealso" id="GUID-7909832F-F81B-40CC-AB8A-7F52CA84F104__GUID-3BD49B43-E45E-4F7A-B668-B8FC769DDB40">
                           <p class="notep1">也可以看看：</p>
                           <p>有关<code class="codeph">DBMS_XPLAN</code>包的更多信息，请<code class="codeph">DBMS_XPLAN</code> <a href="../arpls/DBMS_XPLAN.html#GUID-BAD480AA-351A-48FE-A8E7-F0D8EF643EBF" target="_blank"><span><cite>Oracle Database PL / SQL包和类型参考</cite></span></a></p>
                        </div>
                     </div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-7909832F-F81B-40CC-AB8A-7F52CA84F104__GUID-01DC5163-893A-4DCD-B112-676A010E2F45">
                        <p class="titleinexample">示例6-15比较无法重现的基线</p>
                        <p>一个用例是将基于成本的计划与SQL计划基准进行比较。在此示例中，您将创建一个唯一索引。数据库捕获使用此索引的计划基准。然后，您可以使索引不可见并再次执行查询。基线计划无法重现，因为索引不可见，迫使优化程序选择不同的计划。基准计划与基于成本的计划之间的比较计划报告显示了两个计划之间访问路径的差异。</p>
                        <ol>
                           <li>
                              <p>以<code class="codeph">hr</code>用户登录数据库，然后创建计划表：</p><pre class="pre codeblock"><code>CREATE TABLE PLAN_TABLE（STATEMENT_ID VARCHAR2（30），PLAN_ID NUMBER，TIMESTAMP DATE，REMARKS VARCHAR2（4000），OPERATION VARCHAR2（30），OPTIONS VARCHAR2（255），OBJECT_NODE VARCHAR2（128），OBJECT_OWNER VARCHAR2（30），OBJECT_NAME VARCHAR2（30） ），OBJECT_ALIAS VARCHAR2（65），OBJECT_INSTANCE NUMBER（38），OBJECT_TYPE VARCHAR2（30），OPTIMIZER VARCHAR2（255），SEARCH_COLUMNS NUMBER，ID NUMBER（38），PARENT_ID NUMBER（38），DEPTH NUMBER（38），POSITION NUMBER（ 38），COST NUMBER（38），CARDINALITY NUMBER（38），BYTES NUMBER（38），OTHER_TAG VARCHAR2（255），PARTITION_START VARCHAR2（255），PARTITION_STOP VARCHAR2（255），PARTITION_ID NUMBER（38），OTHER LONG，DISTRIBUTION VARCHAR2 （30），CPU_COST NUMBER（38），IO_COST NUMBER（38），TEMP_SPACE NUMBER（38），ACCESS_PREDICATES VARCHAR2（4000），FILTER_PREDICATES VARCHAR2（4000），PROJECTION VARCHAR2（4000），TIME NUMBER（38），QBLOCK_NAME VARCHAR2（30） ），OTHER_XML CLOB）;</code></pre></li>
                           <li>
                              <p>执行以下DDL语句，这些语句在<code class="codeph">staff.employee_id</code>列上创建名为<code class="codeph">staff</code>的表和索引：</p><pre class="pre codeblock"><code>CREATE TABLE员工AS（SELECT * FROM员工）; CREATE UNIQUE INDEX staff_employee_id ON staff（employee_id）;</code></pre></li>
                           <li>
                              <p>执行以下语句以在SQL计划管理的保护下放置<code class="codeph">staff</code>查询，然后使索引不可见：</p><pre class="pre codeblock"><code>ALTER SESSION SET optimizer_capture_sql_plan_baselines = TRUE; SELECT COUNT（*）FROM staff WHERE employee_id = 20; - 第二次执行查询以创建基线SELECT COUNT（*）FROM staff WHERE employee_id = 20; ALTER SESSION SET optimizer_capture_sql_plan_baselines = FALSE; ALTER INDEX staff_employee_id不可见;</code></pre></li>
                           <li>
                              <p>解释计划，然后查询计划表（包括样本输出）：</p><pre class="pre codeblock"><code>EXPLAIN PLAN SET STATEMENT_ID ='STAFF'用于SELECT COUNT（*）FROM staff WHERE employee_id = 20; SELECT * FROM TABLE（DBMS_XPLAN.DISPLAY（FORMAT =&gt;'TYPICAL'））; PLAN_TABLE_OUTPUT ------------------------------------------------- -------------------------------计划哈希值：1778552452 -------------- -------------------------------------------------- ------------ | Id |操作|名称|行|字节|成本（％CPU）|时间| -------------------------------------------------- -------------------------- | 0 |选择声明| | 1 | 4 | 2（0）| 00:00:01 | | 1 | SORT AGGREGATE | | 1 | 4 | | | | * 2 | <span class="bold">表访问完全</span> |工作人员| 1 | 4 | 2（0）| 00:00:01 | -------------------------------------------------- --------------------------谓词信息（由操作ID标识）：PLAN_TABLE_OUTPUT -------------- -------------------------------------------------- ---------------- 2  -  filter（“EMPLOYEE_ID”= 20） <span class="bold">注意-----  - 使用的动态统计：动态采样（level = 2） - 无法使用SQL计划此声明的基线</span></code></pre><p>如前面的输出所示，优化器选择全表扫描，因为索引是不可见的。由于SQL计划基准使用索引，因此优化程序无法重现计划。</p>
                           </li>
                           <li>
                              <p>在单独的会话中，以<code class="codeph">SYS</code>身份登录并查询SQL计划基准的句柄和计划名称（包括样本输出）：</p><pre class="pre codeblock"><code>SET LINESIZE 120 COL SQL_HANDLE FORMAT a25 COL PLAN_NAME FORMAT a35 SELECT DISTINCT SQL_HANDLE，PLAN_NAME，接受DBA_SQL_PLAN_BASELINES，其中PARSING_SCHEMA_NAME ='HR'; SQL_HANDLE PLAN_NAME ACC ------------------------- ---------------------- ------------- --- SQL_3fa3b23c5ba1bf60 SQL_PLAN_3z8xk7jdu3gv0b7aa092a是</code></pre></li>
                           <li>
                              <p>比较计划，指定从上一步获得的SQL句柄和计划基线名称：</p><pre class="pre codeblock"><code>VAR v_report CLOB BEGIN：v_report：= DBMS_XPLAN.COMPARE_PLANS（reference_plan =&gt; plan_table_object（'HR'，'PLAN_TABLE'，'STAFF'），compare_plan_list =&gt; plan_object_list（SPM_OBJECT（'SQL_3fa3b23c5ba1bf60'，'SQL_PLAN_3z8xk7jdu3gv0b7aa092a'）），type =&gt; 'TEXT'，level =&gt;'ALL'，section =&gt;'ALL'）;结束; /</code></pre></li>
                           <li>
                              <p>查询比较计划报告（包括样本输出）：</p><pre class="pre codeblock"><code>SET LONG 1000000 SET PAGESIZE 50000 SET LINESIZE 200 SELECT：v_report rep FROM DUAL; REP ------------------------------------------------- -------------------------------比较计划报告---------------- -------------------------------------------------- --------------当前用户：SYS计划总数：2发现数量：1 --------------------- -------------------------------------------------- ---------比较详情--------------------------------------- -----------------------------------------计划编号：1（参考计划）计划找到：是计划来源：计划表计划表所有者：HR计划表名称：PLAN_TABLE语句ID：STAFF计划ID：72计划数据库版本：19.0.0.0解析架构：“HR”SQL文本：无SQL文本计划---- ------------------------- Plan Hash Value：1766070819 -------------------- ------------------------------------------------ | Id |操作|名称|行|字节|成本|时间| -------------------------------------------------- ------------------ | 0 |选择声明| | 1 | 13 | 2 | 00:00:01 | | 1 | SORT AGGREGATE | | 1 | 13 | | | | * 2 |表访问完全|工作人员| 1 | 13 | 2 | 00:00:01 | -------------------------------------------------- ------------------谓词信息（由操作ID标识）：----------------------- ------------------- * 2  -  filter（“EMPLOYEE_ID”= 20）注释-----  - 用于此语句的动态采样（level = 2） -  baseline_repro_fail =是------------------------------------------------ --------------------计划编号：2计划发现：是计划来源：SQL计划基准SQL句柄：SQL_3fa3b23c5ba1bf60计划名称：SQL_PLAN_3z8xk7jdu3gv0b7aa092a计划数据库版本：19.0.0.0解析架构：“HR”SQL文本：SELECT COUNT（*）FROM staff WHERE employee_id = 20 Plan ----------------------------- Plan Hash Value：3081373994 ---------------------------------------------- ---------------------------------- | Id |操作|名称|行|字节|成本|时间| -------------------------------------------------- ------------------------------ | 0 |选择声明| | 1 | 13 | 0 | 00:00:01 | | 1 | SORT AGGREGATE | | 1 | 13 | | | | * 2 | INDEX UNIQUE SCAN | STAFF_EMPLOYEE_ID | 1 | 13 | 0 | 00:00:01 | -------------------------------------------------- ------------------------------谓词信息（由操作ID标识）：----------- ------------------------------- * 2  -  access（“EMPLOYEE_ID”= 20） <span class="bold">比较结果（1）： - --------------------------- 1。查询块SEL $ 1，别名“STAFF”@“SEL $ 1”：参考计划（id：2）和当前计划（id：2）之间的某些列（OPERATION，OPTIONS，OBJECT_NAME）不匹配</span> ----- -------------------------------------------------- ---------------------</code></pre></li>
                        </ol>
                     </div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="generating-and-displaying-execution-plans.html#GUID-0023D232-5695-4BA8-89C5-88672B7647E2" title="计划比较工具采用参考计划和任意测试计划列表，并突出显示它们之间的差异。计划比较是合乎逻辑的而不是逐行的。">比较执行计划</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div>
         </div>
      </article>
   </body>
</html>