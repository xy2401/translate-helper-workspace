<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html xml:lang="en-us" lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta name="abstract" content="Knowledge of how to explain a statement and display its plan is essential to SQL tuning.">
      <meta name="description" content="Knowledge of how to explain a statement and display its plan is essential to SQL tuning.">
      <title>Explaining and Displaying Execution Plans</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="SQL Tuning Guide">
      <meta property="og:description" content="Knowledge of how to explain a statement and display its plan is essential to SQL tuning.">
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="SQL Tuning Guide">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="sql-tuning-guide.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2019-01-31T14:57:08-08:00">
      <meta name="dcterms.title" content="SQL Tuning Guide">
      <meta name="dcterms.dateCopyrighted" content="2013, 2019">
      <meta name="dcterms.category" content="database">
      <meta name="dcterms.identifier" content="E96095-03">
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19">
      
      <link rel="prev" href="query-execution-plans.html" title="Previous" type="text/html">
      <link rel="next" href="optimizer-ref.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.isVersionOf" content="TGSQL">
    <meta name="dcterms.release" content="Release 19">
  </head>
   <body>
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="query-execution-plans.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>Previous</a>
         <a href="optimizer-ref.html" class="pull-right">Next<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a>
         <span class="fa fa-exclamation-triangle" aria-hidden="true"></span> JavaScript must be enabled to correctly display this content
        
      </div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">SQL Tuning Guide</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="query-execution-plans.html" property="item" typeof="WebPage"><span property="name">Query Execution Plans</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">Explaining and Displaying Execution Plans</li>
            </ol>
            <a id="GUID-60E30B1C-342B-4D71-B154-C26623D6A3B1" name="GUID-60E30B1C-342B-4D71-B154-C26623D6A3B1"></a><a id="TGSQL271"></a>
            
            <h2 id="TGSQL-GUID-60E30B1C-342B-4D71-B154-C26623D6A3B1" class="sect2"><span class="enumeration_chapter">6 </span>Explaining and Displaying Execution Plans
            </h2>
         </header>
         <div class="ind">
            <div>
               <p>Knowledge of how to explain a statement and display its plan is essential to SQL tuning.</p>
               <p>This chapter contains the following topics:</p>
            </div>
            <div>
               <ul class="ullinks">
                  <li class="ulchildlink"><a href="generating-and-displaying-execution-plans.html#GUID-EB015E00-82E3-4BEA-A8A4-4F7225F548D6">Introduction to Execution Plans</a><br>An <strong class="term">execution plan</strong> is the sequence of operations that the database performs to run a SQL statement.
                  </li>
                  <li class="ulchildlink"><a href="generating-and-displaying-execution-plans.html#GUID-BE9E3808-81AF-4868-B8B2-656E3940B892">Generating Plan Output Using the EXPLAIN PLAN Statement</a><br>The <code class="codeph">EXPLAIN PLAN</code> statement enables you to examine the execution plan that the optimizer chose for a SQL statement.
                  </li>
                  <li class="ulchildlink"><a href="generating-and-displaying-execution-plans.html#GUID-725CADF8-3803-416F-96EB-BF942F742663">Displaying Execution Plans</a><br>The easiest way to display execution plans is to use <code class="codeph">DBMS_XPLAN</code> display functions or <code class="codeph">V$</code> views.
                  </li>
                  <li class="ulchildlink"><a href="generating-and-displaying-execution-plans.html#GUID-0023D232-5695-4BA8-89C5-88672B7647E2">Comparing Execution Plans</a><br>The plan comparison tool takes a reference plan and an arbitrary list of test plans and highlights the differences between them. The plan comparison is logical rather than line by line.
                  </li>
               </ul>
               <div class="familylinks">
                  <div class="parentlink">
                     <p><strong>Parent topic:</strong> <a href="query-execution-plans.html#GUID-BE44BB45-C061-4F3A-8F18-4AAC5F74C68A" title="If a query has suboptimal performance, the execution plan is the key tool for understanding the problem and supplying a solution.">Query Execution Plans</a></p>
                  </div>
               </div>
            </div>
            <a id="TGSQL272"></a><div class="props_rev_3"><a id="GUID-EB015E00-82E3-4BEA-A8A4-4F7225F548D6" name="GUID-EB015E00-82E3-4BEA-A8A4-4F7225F548D6"></a><h3 id="TGSQL-GUID-EB015E00-82E3-4BEA-A8A4-4F7225F548D6" class="sect3"><span class="enumeration_section">6.1 </span>Introduction to Execution Plans
               </h3>
               <div>
                  <p>An <strong class="term">execution plan</strong> is the sequence of operations that the database performs to run a SQL statement.
                  </p>
                  <p>This section contains the following topics:</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="generating-and-displaying-execution-plans.html#GUID-E348705A-6FA5-4869-BD13-2806DACBF4ED">Contents of an Execution Plan</a><br>The execution plan operation alone cannot differentiate between well-tuned statements and those that perform suboptimally.
                     </li>
                     <li class="ulchildlink"><a href="generating-and-displaying-execution-plans.html#GUID-30C0114A-084A-45C8-B6A7-C4D91B6A35AE">Why Execution Plans Change</a><br>Execution plans can and do change as the underlying optimizer inputs change.
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="generating-and-displaying-execution-plans.html#GUID-60E30B1C-342B-4D71-B154-C26623D6A3B1" title="Knowledge of how to explain a statement and display its plan is essential to SQL tuning.">Explaining and Displaying Execution Plans</a></p>
                     </div>
                  </div>
               </div>
               <a id="TGSQL94698"></a><div class="props_rev_3"><a id="GUID-E348705A-6FA5-4869-BD13-2806DACBF4ED" name="GUID-E348705A-6FA5-4869-BD13-2806DACBF4ED"></a><h4 id="TGSQL-GUID-E348705A-6FA5-4869-BD13-2806DACBF4ED" class="sect4"><span class="enumeration_section">6.1.1 </span>Contents of an Execution Plan
                  </h4>
                  <div>
                     <p>The execution plan operation alone cannot differentiate between well-tuned statements and those that perform suboptimally.</p>
                     <div class="section">
                        <p>The plan consists of a series of steps. Every step either retrieves rows of data physically from the database or prepares them for the user issuing the statement. The following plan shows a join of the <code class="codeph">employees</code> and <code class="codeph">departments</code> tables:
                        </p><pre class="pre codeblock"><code>SQL_ID  g9xaqjktdhbcd, child number 0
-------------------------------------
SELECT employee_id, last_name, first_name, department_name from
employees e, departments d WHERE e.department_id = d.department_id and
last_name like 'T%' ORDER BY last_name

Plan hash value: 1219589317

--------------------------------------------------------------------------------------------
| Id  | Operation                    | Name        | Rows  | Bytes | Cost (%CPU)| Time     |
--------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT             |             |       |       |     5 (100)|          |
|   1 |  NESTED LOOPS                |             |     5 |   190 |     5   (0)| 00:00:01 |
|   2 |   TABLE ACCESS BY INDEX ROWID| EMPLOYEES   |     5 |   110 |     2   (0)| 00:00:01 |
|*  3 |    INDEX RANGE SCAN          | EMP_NAME_IX |     5 |       |     1   (0)| 00:00:01 |
|*  4 |   TABLE ACCESS FULL          | DEPARTMENTS |     1 |    16 |     1   (0)| 00:00:01 |
--------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   3 - access("LAST_NAME" LIKE 'T%')
       filter("LAST_NAME" LIKE 'T%')
   4 - filter("E"."DEPARTMENT_ID"="D"."DEPARTMENT_ID")
</code></pre><p>The <a href="glossary.html#GUID-8C474809-DFD4-4EA6-90FE-A17882D07E58"><span class="xrefglossterm">row source tree</span></a> is the core of the execution plan. The tree shows the following information:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>The <a href="glossary.html#GUID-4AF1D36D-F72C-4049-925A-BA2C169A0500"><span class="xrefglossterm">join order</span></a> of the tables referenced by the statement
                              </p>
                              <p>In the preceding plan, <code class="codeph">employees</code> is the outer row source and <code class="codeph">departments</code> is the inner row source.
                              </p>
                           </li>
                           <li>
                              <p>An <a href="glossary.html#GUID-22DF198C-4310-4307-BF29-DCE765725BD4"><span class="xrefglossterm">access path</span></a> for each table mentioned in the statement
                              </p>
                              <p>In the preceding plan, the optimizer chooses to access <code class="codeph">employees</code> using an index scan and <code class="codeph">departments</code> using a full scan.
                              </p>
                           </li>
                           <li>
                              <p>A <a href="glossary.html#GUID-C4F1E78D-0262-4517-9DE6-8D835DCEC709"><span class="xrefglossterm">join method</span></a> for tables affected by join operations in the statement
                              </p>
                              <p>In the preceding plan, the optimizer chooses a nested loops join.</p>
                           </li>
                           <li>
                              <p>Data operations like filter, sort, or aggregation</p>
                              <p>In the preceding plan, the optimizer filters on last names that begin with <code class="codeph">T</code> and matches on <code class="codeph">department_id</code>.
                              </p>
                           </li>
                        </ul>
                        <p>In addition to the row source tree, the plan table contains information about the following:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Optimization, such as the cost and cardinality of each operation</p>
                           </li>
                           <li>
                              <p>Partitioning, such as the set of accessed partitions</p>
                           </li>
                           <li>
                              <p>Parallel execution, such as the distribution method of join inputs</p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="generating-and-displaying-execution-plans.html#GUID-EB015E00-82E3-4BEA-A8A4-4F7225F548D6" title="An execution plan is the sequence of operations that the database performs to run a SQL statement.">Introduction to Execution Plans</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="TGSQL94693"></a><div class="props_rev_3"><a id="GUID-30C0114A-084A-45C8-B6A7-C4D91B6A35AE" name="GUID-30C0114A-084A-45C8-B6A7-C4D91B6A35AE"></a><h4 id="TGSQL-GUID-30C0114A-084A-45C8-B6A7-C4D91B6A35AE" class="sect4"><span class="enumeration_section">6.1.2 </span>Why Execution Plans Change
                  </h4>
                  <div>
                     <p>Execution plans can and do change as the underlying optimizer inputs change.</p>
                     <div class="infoboxnote" id="GUID-30C0114A-084A-45C8-B6A7-C4D91B6A35AE__GUID-6040AF75-3CD3-4B80-8F25-8A9BBE385F10">
                        <p class="notep1">Note:</p>
                        <p>To avoid possible SQL performance regression that may result from execution plan changes, consider using SQL plan management.</p>
                     </div>
                     <p>This section contains the following topics:</p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="generating-and-displaying-execution-plans.html#GUID-94D7E339-9310-4482-A1BC-26F74D2BED89">Different Schemas</a><br>Schemas can differ for various reasons.
                        </li>
                        <li class="ulchildlink"><a href="generating-and-displaying-execution-plans.html#GUID-4A42068F-93FA-4E04-9574-1E96423C8EBC">Different Costs</a><br>Even if the schemas are the same, the optimizer can choose different execution plans when the costs are different. 
                        </li>
                     </ul>
                     <div class="infoboxnotealso" id="GUID-30C0114A-084A-45C8-B6A7-C4D91B6A35AE__GUID-877FCF73-4E3C-4FF0-A09D-CF1522BDF86B">
                        <p class="notep1">See Also:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><span class="q">"<a href="overview-of-sql-plan-management.html#GUID-F1C45056-F998-43E5-B362-83F88DA49E58" title="SQL plan management is a preventative mechanism that enables the optimizer to automatically manage execution plans, ensuring that the database uses only known or verified plans.">Overview of SQL Plan Management</a>"</span></p>
                           </li>
                           <li>
                              <p><a href="../arpls/DBMS_SPM.html#ARPLS150" target="_blank"><span><cite>Oracle Database PL/SQL Packages and Types Reference</cite></span></a> to learn about the <code class="codeph">DBMS_SPM</code> package
                              </p>
                           </li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="generating-and-displaying-execution-plans.html#GUID-EB015E00-82E3-4BEA-A8A4-4F7225F548D6" title="An execution plan is the sequence of operations that the database performs to run a SQL statement.">Introduction to Execution Plans</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="TGSQL94694"></a><div class="props_rev_3"><a id="GUID-94D7E339-9310-4482-A1BC-26F74D2BED89" name="GUID-94D7E339-9310-4482-A1BC-26F74D2BED89"></a><h5 id="TGSQL-GUID-94D7E339-9310-4482-A1BC-26F74D2BED89" class="sect5"><span class="enumeration_section">6.1.2.1 </span>Different Schemas 
                     </h5>
                     <div>
                        <p>Schemas can differ for various reasons.</p>
                        <p>Principal reasons include the following:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>The execution and explain plan occur on different databases.</p>
                           </li>
                           <li>
                              <p>The user explaining the statement is different from the user running the statement. Two users might be pointing to different objects in the same database, resulting in different execution plans.</p>
                           </li>
                           <li>
                              <p>Schema changes (often changes in indexes) between the two operations.</p>
                           </li>
                        </ul>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="generating-and-displaying-execution-plans.html#GUID-30C0114A-084A-45C8-B6A7-C4D91B6A35AE" title="Execution plans can and do change as the underlying optimizer inputs change.">Why Execution Plans Change</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TGSQL94695"></a><div class="props_rev_3"><a id="GUID-4A42068F-93FA-4E04-9574-1E96423C8EBC" name="GUID-4A42068F-93FA-4E04-9574-1E96423C8EBC"></a><h5 id="TGSQL-GUID-4A42068F-93FA-4E04-9574-1E96423C8EBC" class="sect5"><span class="enumeration_section">6.1.2.2 </span>Different Costs
                     </h5>
                     <div>
                        <p>Even if the schemas are the same, the optimizer can choose different execution plans when the costs are different. </p>
                        <p>Some factors that affect the costs include the following:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Data volume and statistics</p>
                           </li>
                           <li>
                              <p>Bind variable types and values</p>
                           </li>
                           <li>
                              <p>Initialization parameters set globally or at session level</p>
                           </li>
                        </ul>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="generating-and-displaying-execution-plans.html#GUID-30C0114A-084A-45C8-B6A7-C4D91B6A35AE" title="Execution plans can and do change as the underlying optimizer inputs change.">Why Execution Plans Change</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div>
            </div><a id="TGSQL273"></a><div class="props_rev_3"><a id="GUID-BE9E3808-81AF-4868-B8B2-656E3940B892" name="GUID-BE9E3808-81AF-4868-B8B2-656E3940B892"></a><h3 id="TGSQL-GUID-BE9E3808-81AF-4868-B8B2-656E3940B892" class="sect3"><span class="enumeration_section">6.2 </span>Generating Plan Output Using the EXPLAIN PLAN Statement
               </h3>
               <div>
                  <p>The <code class="codeph">EXPLAIN PLAN</code> statement enables you to examine the execution plan that the optimizer chose for a SQL statement.
                  </p>
                  <p>This section contains the following topics:</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="generating-and-displaying-execution-plans.html#GUID-23BE135E-3C29-4A55-93E8-17163F6C4801">About the EXPLAIN PLAN Statement</a><br>The <code class="codeph">EXPLAIN PLAN</code> statement displays execution plans that the optimizer chooses for <code class="codeph">SELECT</code>, <code class="codeph">UPDATE</code>, <code class="codeph">INSERT</code>, and <code class="codeph">DELETE</code> statements.
                     </li>
                     <li class="ulchildlink"><a href="generating-and-displaying-execution-plans.html#GUID-E4ED3145-8ABD-4F40-B044-9AEFBD89409C">Explaining a SQL Statement: Basic Steps</a><br>Use <code class="codeph">EXPLAIN PLAN</code> to store the plan for a SQL statement in <code class="codeph">PLAN_TABLE</code>.
                     </li>
                     <li class="ulchildlink"><a href="generating-and-displaying-execution-plans.html#GUID-102A6D99-3193-4628-BC35-74501F46D13A">Specifying a Statement ID in EXPLAIN PLAN: Example</a><br>With multiple statements, you can specify a statement identifier and use that to identify your specific execution plan.
                     </li>
                     <li class="ulchildlink"><a href="generating-and-displaying-execution-plans.html#GUID-A377E279-4983-4750-917D-17C48ED3D1DB">Specifying a Different Location for EXPLAIN PLAN Output: Example</a><br>The <code class="codeph">INTO</code> clause of <code class="codeph">EXPLAIN PLAN</code> specifies a different table in which to store the output.
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="generating-and-displaying-execution-plans.html#GUID-60E30B1C-342B-4D71-B154-C26623D6A3B1" title="Knowledge of how to explain a statement and display its plan is essential to SQL tuning.">Explaining and Displaying Execution Plans</a></p>
                     </div>
                  </div>
               </div>
               <a id="TGSQL95114"></a><div class="props_rev_3"><a id="GUID-23BE135E-3C29-4A55-93E8-17163F6C4801" name="GUID-23BE135E-3C29-4A55-93E8-17163F6C4801"></a><h4 id="TGSQL-GUID-23BE135E-3C29-4A55-93E8-17163F6C4801" class="sect4"><span class="enumeration_section">6.2.1 </span>About the EXPLAIN PLAN Statement
                  </h4>
                  <div>
                     <p>The <code class="codeph">EXPLAIN PLAN</code> statement displays execution plans that the optimizer chooses for <code class="codeph">SELECT</code>, <code class="codeph">UPDATE</code>, <code class="codeph">INSERT</code>, and <code class="codeph">DELETE</code> statements.
                     </p>
                     <p><code class="codeph">EXPLAIN PLAN</code> output shows how the database would have run the SQL statement when the statement was explained. Because of differences in the execution environment and explain plan environment, the explained plan can differ from the actual plan used during statement execution.
                     </p>
                     <p>When the <code class="codeph">EXPLAIN PLAN</code> statement is issued, the optimizer chooses an execution plan and then inserts a row describing each step of the execution plan into a specified plan table. You can also issue the <code class="codeph">EXPLAIN PLAN</code> statement as part of the SQL trace facility.
                     </p>
                     <p>The <code class="codeph">EXPLAIN PLAN</code> statement is a DML statement rather than a DDL statement. Therefore, Oracle Database does not implicitly commit the changes made by an <code class="codeph">EXPLAIN PLAN</code> statement.
                     </p>
                     <p>This section contains the following topics:</p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="generating-and-displaying-execution-plans.html#GUID-948FF9B7-F728-46C3-98B4-AC3EFD362E65">About PLAN_TABLE</a><br><code class="codeph">PLAN_TABLE</code> is the default sample output table into which the <code class="codeph">EXPLAIN PLAN</code> statement inserts rows describing execution plans.
                        </li>
                        <li class="ulchildlink"><a href="generating-and-displaying-execution-plans.html#GUID-E2463C7B-F71A-4F06-85D3-1AF3D4D71CE8">EXPLAIN PLAN Restrictions</a><br>Oracle Database does not support <code class="codeph">EXPLAIN PLAN</code> for statements performing implicit type conversion of date bind variables. 
                        </li>
                     </ul>
                     <div class="infoboxnotealso" id="GUID-23BE135E-3C29-4A55-93E8-17163F6C4801__GUID-4C0770EA-67D2-40EA-8725-5346A73BCF7A">
                        <p class="notep1">See Also:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p> <span class="q">"<a href="sql-processing.html#GUID-E052E274-586D-4D76-960F-B831140F7B94" title="The row source generator is software that receives the optimal execution plan from the optimizer and produces an iterative execution plan that is usable by the rest of the database.">SQL Row Source Generation</a>"</span></p>
                           </li>
                           <li>
                              <p><a href="../sqlrf/EXPLAIN-PLAN.html#SQLRF01601" target="_blank"><span><cite>Oracle Database SQL Language Reference</cite></span></a> to learn about the <code class="codeph">EXPLAIN PLAN</code> statement
                              </p>
                           </li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="generating-and-displaying-execution-plans.html#GUID-BE9E3808-81AF-4868-B8B2-656E3940B892" title="The EXPLAIN PLAN statement enables you to examine the execution plan that the optimizer chose for a SQL statement.">Generating Plan Output Using the EXPLAIN PLAN Statement</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="TGSQL94701"></a><div class="props_rev_3"><a id="GUID-948FF9B7-F728-46C3-98B4-AC3EFD362E65" name="GUID-948FF9B7-F728-46C3-98B4-AC3EFD362E65"></a><h5 id="TGSQL-GUID-948FF9B7-F728-46C3-98B4-AC3EFD362E65" class="sect5"><span class="enumeration_section">6.2.1.1 </span>About PLAN_TABLE
                     </h5>
                     <div>
                        <p><code class="codeph">PLAN_TABLE</code> is the default sample output table into which the <code class="codeph">EXPLAIN PLAN</code> statement inserts rows describing execution plans.
                        </p>
                        <div class="section">
                           <p>Oracle Database automatically creates a global temporary table <code class="codeph">PLAN_TABLE$</code> in the <code class="codeph">SYS</code> schema, and creates <code class="codeph">PLAN_TABLE</code> as a synonym. All necessary privileges to <code class="codeph">PLAN_TABLE</code> are granted to <code class="codeph">PUBLIC</code>. Consequently, every session gets its own private copy of <code class="codeph">PLAN_TABLE</code> in its temporary tablespace.
                           </p>
                           <p>You can use the SQL script <code class="codeph">catplan.sql</code> to manually create the global temporary table and the <code class="codeph">PLAN_TABLE</code> synonym. The name and location of this script depends on your operating system. On UNIX and Linux, the script is located in the <code class="codeph">$ORACLE_HOME/rdbms/admin</code> directory. For example, start a SQL*Plus session, connect with <code class="codeph">SYSDBA</code> privileges, and run the script as follows:
                           </p><pre class="pre codeblock"><code>@$ORACLE_HOME/rdbms/admin/catplan.sql
</code></pre><p>The definition of a sample output table <code class="codeph">PLAN_TABLE</code> is available in a SQL script on your distribution media. Your output table must have the same column names and data types as this table. The common name of this script is <code class="codeph">utlxplan.sql</code>. The exact name and location depend on your operating system.
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-948FF9B7-F728-46C3-98B4-AC3EFD362E65__GUID-EE83465E-9679-4EC0-A1E0-AB640F548B09">
                           <p class="notep1">See Also:</p>
                           <p><a href="../sqlrf/EXPLAIN-PLAN.html#SQLRF01601" target="_blank"><span><cite>Oracle Database SQL Language Reference</cite></span></a> for a complete description of <code class="codeph">EXPLAIN PLAN</code> syntax.
                           </p>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="generating-and-displaying-execution-plans.html#GUID-23BE135E-3C29-4A55-93E8-17163F6C4801" title="The EXPLAIN PLAN statement displays execution plans that the optimizer chooses for SELECT, UPDATE, INSERT, and DELETE statements.">About the EXPLAIN PLAN Statement</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TGSQL94700"></a><div class="props_rev_3"><a id="GUID-E2463C7B-F71A-4F06-85D3-1AF3D4D71CE8" name="GUID-E2463C7B-F71A-4F06-85D3-1AF3D4D71CE8"></a><h5 id="TGSQL-GUID-E2463C7B-F71A-4F06-85D3-1AF3D4D71CE8" class="sect5"><span class="enumeration_section">6.2.1.2 </span>EXPLAIN PLAN Restrictions
                     </h5>
                     <div>
                        <p>Oracle Database does not support <code class="codeph">EXPLAIN PLAN</code> for statements performing implicit type conversion of date bind variables. 
                        </p>
                        <div class="section">
                           <p>With bind variables in general, the <code class="codeph">EXPLAIN PLAN</code> output might not represent the real execution plan. 
                           </p>
                           <p>From the text of a SQL statement, <code class="codeph">TKPROF</code> cannot determine the types of the bind variables. It assumes that the type is <code class="codeph">VARCHAR</code>, and gives an error message otherwise. You can avoid this limitation by putting appropriate type conversions in the SQL statement.
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-E2463C7B-F71A-4F06-85D3-1AF3D4D71CE8__GUID-4B4164F5-E704-4BB2-84A2-A846D3A9FE43">
                           <p class="notep1">See Also:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><span class="q">"<a href="performing-application-tracing.html#GUID-440D3AD4-B302-408E-8627-FE8032DD09F9" title="This chapter explains what end-to-end application tracing is, and how to generate and read trace files.">Performing Application Tracing</a>"</span></p>
                              </li>
                              <li>
                                 <p><span class="q">"<a href="performing-application-tracing.html#GUID-2D5E244C-1852-40F0-B222-3DBA59380A56" title="If you are not aware of the values being bound at run time, then it is possible to fall into the argument trap.">Guideline for Avoiding the Argument Trap</a>"</span></p>
                              </li>
                              <li>
                                 <p><a href="../sqlrf/Data-Types.html#SQLRF-GUID-A3C0D836-BADB-44E5-A5D4-265BA5968483" target="_blank"><span><cite>Oracle Database SQL Language Reference</cite></span></a> to learn more about SQL data types
                                 </p>
                              </li>
                           </ul>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="generating-and-displaying-execution-plans.html#GUID-23BE135E-3C29-4A55-93E8-17163F6C4801" title="The EXPLAIN PLAN statement displays execution plans that the optimizer chooses for SELECT, UPDATE, INSERT, and DELETE statements.">About the EXPLAIN PLAN Statement</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div>
               <div class="props_rev_3"><a id="GUID-E4ED3145-8ABD-4F40-B044-9AEFBD89409C" name="GUID-E4ED3145-8ABD-4F40-B044-9AEFBD89409C"></a><h4 id="TGSQL-GUID-E4ED3145-8ABD-4F40-B044-9AEFBD89409C" class="sect4"><span class="enumeration_section">6.2.2 </span>Explaining a SQL Statement: Basic Steps
                  </h4>
                  <div>
                     <p>Use <code class="codeph">EXPLAIN PLAN</code> to store the plan for a SQL statement in <code class="codeph">PLAN_TABLE</code>.
                     </p>
                     <div class="section">
                        <p class="subhead3" id="GUID-E4ED3145-8ABD-4F40-B044-9AEFBD89409C__GUID-EA194E3F-7937-4E81-922A-74670325E653">Prerequisites</p>
                        <p>This task assumes that a sample output table named <code class="codeph">PLAN_TABLE</code> exists in your schema. If this table does not exist, then run the SQL script <code class="codeph">catplan.sql</code>.
                        </p>
                        <p>To execute <code class="codeph">EXPLAIN PLAN</code>, you must have the following privileges:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>You must have the privileges necessary to insert rows into an existing output table that you specify to hold the execution plan</p>
                           </li>
                           <li>
                              <p>You must also have the privileges necessary to execute the SQL statement for which you are determining the execution plan. If the SQL statement accesses a view, then you must have privileges to access any tables and views on which the view is based. If the view is based on another view that is based on a table, then you must have privileges to access both the other view and its underlying table.</p>
                           </li>
                        </ul>
                        <p>To examine the execution plan produced by an <code class="codeph">EXPLAIN PLAN</code> statement, you must have the privileges necessary to query the output table.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-E4ED3145-8ABD-4F40-B044-9AEFBD89409C__GUID-47181F89-96CE-4223-9E2A-68B57EFE1B2D">To explain a statement:</p>
                        <ol>
                           <li>
                              <p>Start SQL*Plus or SQL Developer, and log in to the database as a user with the requisite permissions.</p>
                           </li>
                           <li>
                              <p>Include the <code class="codeph">EXPLAIN PLAN FOR</code> clause immediately before the SQL statement.
                              </p>
                              <p>The following example explains the plan for a query of the <code class="codeph">employees</code> table:
                              </p><pre class="pre codeblock"><code>EXPLAIN PLAN FOR
  SELECT e.last_name, d.department_name, e.salary
  FROM   employees e, departments d
  WHERE  salary &lt; 3000
  AND    e.department_id = d.department_id
  ORDER BY salary DESC;</code></pre></li>
                           <li>
                              <p>After issuing the <code class="codeph">EXPLAIN PLAN</code> statement, use a script or package provided by Oracle Database to display the most recent plan table output. 
                              </p>
                              <p>The following example uses the <code class="codeph">DBMS_XPLAN.DISPLAY</code> function:
                              </p><pre class="pre codeblock"><code>SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY(format =&gt; 'ALL'));</code></pre></li>
                           <li>
                              <p>Review the plan output.</p>
                              <p>For example, the following plan shows a hash join:</p><pre class="pre codeblock"><code>SQL&gt; SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY(format =&gt; 'ALL'));
Plan hash value: 3556827125

-----------------------------------------------------------------------------------
| Id  | Operation           | Name        | Rows  | Bytes | Cost (%CPU)| Time     |
-----------------------------------------------------------------------------------
|   0 | SELECT STATEMENT    |             |     4 |   124 |     5  (20)| 00:00:01 |
|   1 |  SORT ORDER BY      |             |     4 |   124 |     5  (20)| 00:00:01 |
|*  2 |   HASH JOIN         |             |     4 |   124 |     4   (0)| 00:00:01 |
|*  3 |    TABLE ACCESS FULL| EMPLOYEES   |     4 |    60 |     2   (0)| 00:00:01 |
|   4 |    TABLE ACCESS FULL| DEPARTMENTS |    27 |   432 |     2   (0)| 00:00:01 |
-----------------------------------------------------------------------------------

Query Block Name / Object Alias (identified by operation id):
-------------------------------------------------------------

   1 - SEL$1
   3 - SEL$1 / E@SEL$1
   4 - SEL$1 / D@SEL$1

Predicate Information (identified by operation id):
---------------------------------------------------

   2 - access("E"."DEPARTMENT_ID"="D"."DEPARTMENT_ID")
   3 - filter("SALARY"&lt;3000)

Column Projection Information (identified by operation id):
-----------------------------------------------------------

   1 - (#keys=1) INTERNAL_FUNCTION("E"."SALARY")[22],
       "E"."LAST_NAME"[VARCHAR2,25], "D"."DEPARTMENT_NAME"[VARCHAR2,30]
   2 - (#keys=1) "E"."LAST_NAME"[VARCHAR2,25], "SALARY"[NUMBER,22],
       "D"."DEPARTMENT_NAME"[VARCHAR2,30], "D"."DEPARTMENT_NAME"[VARCHAR2,30]
   3 - "E"."LAST_NAME"[VARCHAR2,25], "SALARY"[NUMBER,22],
       "E"."DEPARTMENT_ID"[NUMBER,22]
   4 - "D"."DEPARTMENT_ID"[NUMBER,22], "D"."DEPARTMENT_NAME"[VARCHAR2,30]

Note
-----
   - this is an adaptive plan
</code></pre><p>The execution order in <code class="codeph">EXPLAIN PLAN</code> output begins with the line that is the furthest indented to the right. The next step is the parent of that line. If two lines are indented equally, then the top line is normally executed first.
                              </p>
                              <div class="infoboxnote" id="GUID-E4ED3145-8ABD-4F40-B044-9AEFBD89409C__GUID-66B035BC-615D-4E4A-802F-5CB013E2503A">
                                 <p class="notep1">Note:</p>
                                 <p>The steps in the <code class="codeph">EXPLAIN PLAN</code> output in this chapter may be different on your database. The optimizer may choose different execution plans, depending on database configurations.
                                 </p>
                              </div>
                           </li>
                        </ol>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-E4ED3145-8ABD-4F40-B044-9AEFBD89409C__GUID-B00A245A-AB43-499D-9F45-BFDB36DF6CAB">
                        <p class="notep1">See Also:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><span class="q">"<a href="generating-and-displaying-execution-plans.html#GUID-948FF9B7-F728-46C3-98B4-AC3EFD362E65" title="PLAN_TABLE is the default sample output table into which the EXPLAIN PLAN statement inserts rows describing execution plans.">About PLAN_TABLE</a>"</span></p>
                           </li>
                           <li>
                              <p><span class="q">"<a href="generating-and-displaying-execution-plans.html#GUID-5E88AD7F-D5FF-4003-B721-9126352CE414" title="To display the plan table output, you can use either SQL scripts or the DBMS_XPLAN package.">About the Display of PLAN_TABLE Output</a>"</span></p>
                           </li>
                           <li>
                              <p><a href="../sqlrf/EXPLAIN-PLAN.html#SQLRF-GUID-FD540872-4ED3-4936-96A2-362539931BA0" target="_blank"><span><cite>Oracle Database SQL Language Reference</cite></span></a> for the syntax and semantics of <code class="codeph">EXPLAIN PLAN</code></p>
                           </li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="generating-and-displaying-execution-plans.html#GUID-BE9E3808-81AF-4868-B8B2-656E3940B892" title="The EXPLAIN PLAN statement enables you to examine the execution plan that the optimizer chose for a SQL statement.">Generating Plan Output Using the EXPLAIN PLAN Statement</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="TGSQL94703"></a><a id="TGSQL94702"></a><div class="props_rev_3"><a id="GUID-102A6D99-3193-4628-BC35-74501F46D13A" name="GUID-102A6D99-3193-4628-BC35-74501F46D13A"></a><h4 id="TGSQL-GUID-102A6D99-3193-4628-BC35-74501F46D13A" class="sect4"><span class="enumeration_section">6.2.3 </span>Specifying a Statement ID in EXPLAIN PLAN: Example
                  </h4>
                  <div>
                     <p>With multiple statements, you can specify a statement identifier and use that to identify your specific execution plan.</p>
                     <div class="section">
                        <p>Before using <code class="codeph">SET STATEMENT ID</code>, remove any existing rows for that statement ID. In the following example, <code class="codeph">st1</code> is specified as the statement identifier.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-102A6D99-3193-4628-BC35-74501F46D13A__CACCJJCJ">
                        <p class="titleinexample">Example 6-1 Using EXPLAIN PLAN with the STATEMENT ID Clause</p><pre class="pre codeblock"><code>EXPLAIN PLAN
  SET STATEMENT_ID = 'st1' FOR
  SELECT last_name FROM employees;</code></pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="generating-and-displaying-execution-plans.html#GUID-BE9E3808-81AF-4868-B8B2-656E3940B892" title="The EXPLAIN PLAN statement enables you to examine the execution plan that the optimizer chose for a SQL statement.">Generating Plan Output Using the EXPLAIN PLAN Statement</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="TGSQL94705"></a><a id="TGSQL94704"></a><div class="props_rev_3"><a id="GUID-A377E279-4983-4750-917D-17C48ED3D1DB" name="GUID-A377E279-4983-4750-917D-17C48ED3D1DB"></a><h4 id="TGSQL-GUID-A377E279-4983-4750-917D-17C48ED3D1DB" class="sect4"><span class="enumeration_section">6.2.4 </span>Specifying a Different Location for EXPLAIN PLAN Output: Example
                  </h4>
                  <div>
                     <p>The <code class="codeph">INTO</code> clause of <code class="codeph">EXPLAIN PLAN</code> specifies a different table in which to store the output.
                     </p>
                     <div class="section">
                        <p>If you do not want to use the name <code class="codeph">PLAN_TABLE</code>, create a new synonym after running the <code class="codeph">catplan.sql</code> script. For example:
                        </p><pre class="pre codeblock"><code>CREATE OR REPLACE PUBLIC SYNONYM my_plan_table for plan_table$</code></pre><p>The following statement directs output to <code class="codeph">my_plan_table</code>:
                        </p><pre class="pre codeblock"><code>EXPLAIN PLAN
  INTO my_plan_table FOR
  SELECT last_name FROM employees;
</code></pre><p>You can specify a statement ID when using the <code class="codeph">INTO</code> clause, as in the following statement:
                        </p><pre class="pre codeblock"><code>EXPLAIN PLAN
   SET STATEMENT_ID = 'st1'
   INTO my_plan_table FOR
   SELECT last_name FROM employees;</code></pre></div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-A377E279-4983-4750-917D-17C48ED3D1DB__GUID-6FF1242C-8932-4D90-A755-4047E8E67509">
                        <p class="notep1">See Also:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><span class="q">"<a href="optimizer-ref.html#GUID-5AE1939F-F654-42FF-B0C5-706507CD12A2" title="PLAN_TABLE is populated by the EXPLAIN PLAN statement.">PLAN_TABLE Columns</a>"</span> for a description of the columns in <code class="codeph">PLAN_TABLE</code></p>
                           </li>
                           <li>
                              <p><a href="../sqlrf/CREATE-SYNONYM.html#SQLRF-GUID-A806C82F-1171-478E-A910-F9C6C42739B2" target="_blank"><span><cite>Oracle Database SQL Language Reference</cite></span></a> to learn about <code class="codeph">CREATE SYNONYM</code></p>
                           </li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="generating-and-displaying-execution-plans.html#GUID-BE9E3808-81AF-4868-B8B2-656E3940B892" title="The EXPLAIN PLAN statement enables you to examine the execution plan that the optimizer chose for a SQL statement.">Generating Plan Output Using the EXPLAIN PLAN Statement</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div>
            <div class="sect2"><a id="GUID-725CADF8-3803-416F-96EB-BF942F742663" name="GUID-725CADF8-3803-416F-96EB-BF942F742663"></a><h3 id="TGSQL-GUID-725CADF8-3803-416F-96EB-BF942F742663" class="sect3"><span class="enumeration_section">6.3 </span>Displaying Execution Plans
               </h3>
               <div>
                  <p>The easiest way to display execution plans is to use <code class="codeph">DBMS_XPLAN</code> display functions or <code class="codeph">V$</code> views.
                  </p>
                  <p>This section contains the following topics:</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="generating-and-displaying-execution-plans.html#GUID-5E88AD7F-D5FF-4003-B721-9126352CE414">About the Display of PLAN_TABLE Output</a><br>To display the plan table output, you can use either SQL scripts or the <code class="codeph">DBMS_XPLAN</code> package.
                     </li>
                     <li class="ulchildlink"><a href="generating-and-displaying-execution-plans.html#GUID-1FA56307-047B-42BB-AF17-3B05F1814559">Displaying Execution Plans: Basic Steps</a><br>The <code class="codeph">DBMS_XPLAN.DISPLAY</code> function is a simple way to display an explained plan.
                     </li>
                     <li class="ulchildlink"><a href="generating-and-displaying-execution-plans.html#GUID-83F88700-3902-4D19-8182-AF2B92AEA7EB">Displaying Adaptive Query Plans: Tutorial</a><br>The <strong class="term">adaptive optimizer</strong> is a feature of the optimizer that enables it to adapt plans based on run-time statistics. All adaptive mechanisms can execute a final plan for a statement that differs from the default plan.
                     </li>
                     <li class="ulchildlink"><a href="generating-and-displaying-execution-plans.html#GUID-90411427-FDD7-4196-A52A-84D153CE37C1">Display Execution Plans: Examples</a><br>These examples show different ways of displaying execution plans.
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="generating-and-displaying-execution-plans.html#GUID-60E30B1C-342B-4D71-B154-C26623D6A3B1" title="Knowledge of how to explain a statement and display its plan is essential to SQL tuning.">Explaining and Displaying Execution Plans</a></p>
                     </div>
                  </div>
               </div>
               <a id="TGSQL94706"></a><div class="props_rev_3"><a id="GUID-5E88AD7F-D5FF-4003-B721-9126352CE414" name="GUID-5E88AD7F-D5FF-4003-B721-9126352CE414"></a><h4 id="TGSQL-GUID-5E88AD7F-D5FF-4003-B721-9126352CE414" class="sect4"><span class="enumeration_section">6.3.1 </span>About the Display of PLAN_TABLE Output
                  </h4>
                  <div>
                     <p>To display the plan table output, you can use either SQL scripts or the <code class="codeph">DBMS_XPLAN</code> package.
                     </p>
                     <div class="section">
                        <p>After you have explained the plan, use the following SQL scripts or PL/SQL package provided by Oracle Database to display the most recent plan table output:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><code class="codeph">DBMS_XPLAN.DISPLAY</code> table function 
                              </p>
                              <p>This function accepts options for displaying the plan table output. You can specify:</p>
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p>A plan table name if you are using a table different than <code class="codeph">PLAN_TABLE</code></p>
                                 </li>
                                 <li>
                                    <p>A statement ID if you have set a statement ID with the <code class="codeph">EXPLAIN PLAN</code></p>
                                 </li>
                                 <li>
                                    <p>A format option that determines the level of detail: <code class="codeph">BASIC</code>, <code class="codeph">SERIAL</code>, <code class="codeph">TYPICAL</code>, and <code class="codeph">ALL</code></p>
                                 </li>
                              </ul>
                              <p>Examples of using <code class="codeph">DBMS_XPLAN</code> to display <code class="codeph">PLAN_TABLE</code> output are:
                              </p><pre class="pre codeblock"><code>SELECT PLAN_TABLE_OUTPUT FROM TABLE(DBMS_XPLAN.DISPLAY());

SELECT PLAN_TABLE_OUTPUT 
  FROM TABLE(DBMS_XPLAN.DISPLAY('MY_PLAN_TABLE', 'st1','TYPICAL'));</code></pre></li>
                           <li>
                              <p><code class="codeph">utlxpls.sql</code> 
                              </p>
                              <p>This script displays the plan table output for serial processing</p>
                           </li>
                           <li>
                              <p><code class="codeph">utlxplp.sql</code></p>
                              <p>This script displays the plan table output including parallel execution columns.</p>
                           </li>
                        </ul>
                        <p>This section contains the following topics:</p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="generating-and-displaying-execution-plans.html#GUID-2C3C060E-1E16-4075-BA08-37148F0BFDFA">DBMS_XPLAN Display Functions</a><br>You can use the <code class="codeph">DBMS_XPLAN</code> display functions to show plans.
                        </li>
                        <li class="ulchildlink"><a href="generating-and-displaying-execution-plans.html#GUID-955B4D41-EB27-44FE-A9E2-8C42835B652D">Plan-Related Views</a><br>You can obtain information about execution plans by querying dynamic performance and data dictionary views.
                        </li>
                     </ul>
                     <div class="infoboxnotealso" id="GUID-5E88AD7F-D5FF-4003-B721-9126352CE414__GUID-2FD03CE5-2A08-49CF-A2A1-F0726D52A496">
                        <p class="notep1">See Also:</p>
                        <p><a href="../arpls/DBMS_XPLAN.html#ARPLS378" target="_blank"><span><cite>Oracle Database PL/SQL Packages and Types Reference</cite></span></a> for more information about the <code class="codeph">DBMS_XPLAN</code> package
                        </p>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="generating-and-displaying-execution-plans.html#GUID-725CADF8-3803-416F-96EB-BF942F742663" title="The easiest way to display execution plans is to use DBMS_XPLAN display functions or V$ views.">Displaying Execution Plans</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="TGSQL291"></a><a id="TGSQL290"></a><div class="props_rev_3"><a id="GUID-2C3C060E-1E16-4075-BA08-37148F0BFDFA" name="GUID-2C3C060E-1E16-4075-BA08-37148F0BFDFA"></a><h5 id="TGSQL-GUID-2C3C060E-1E16-4075-BA08-37148F0BFDFA" class="sect5"><span class="enumeration_section">6.3.1.1 </span>DBMS_XPLAN Display Functions
                     </h5>
                     <div>
                        <p>You can use the <code class="codeph">DBMS_XPLAN</code> display functions to show plans.
                        </p>
                        <div class="section">
                           <p>The display functions accept options for displaying the plan table output. You can specify:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>A plan table name if you are using a table different from <code class="codeph">PLAN_TABLE</code></p>
                              </li>
                              <li>
                                 <p>A statement ID if you have set a statement ID with the <code class="codeph">EXPLAIN PLAN</code></p>
                              </li>
                              <li>
                                 <p>A format option that determines the level of detail: <code class="codeph">BASIC</code>, <code class="codeph">SERIAL</code>, <code class="codeph">TYPICAL</code>, <code class="codeph">ALL</code>, and in some cases <code class="codeph">ADAPTIVE</code></p>
                              </li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                        <div class="tblformal" id="GUID-2C3C060E-1E16-4075-BA08-37148F0BFDFA__CEGCBHGJ">
                           <p class="titleintable">Table 6-1 DBMS_XPLAN Display Functions</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="DBMS_XPLAN Display Functions" summary="This 2 column table describes DBMS_XPLAN program units. Column 1 lists the functions. Column 2 provides more information about the functions. " width="100%" frame="hsides" border="1" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="25%" id="d21079e2755">Display Functions</th>
                                    <th align="left" valign="bottom" width="75%" id="d21079e2758">Notes</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="25%" id="d21079e2763" headers="d21079e2755 ">
                                       <p><code class="codeph">DISPLAY</code></p>
                                    </td>
                                    <td align="left" valign="top" width="75%" headers="d21079e2763 d21079e2758 ">
                                       <p><span>This table function displays the contents of the plan table.</span></p>
                                       <p>In addition, you can use this table function to display any plan (with or without statistics) stored in a table as long as the columns of this table are named the same as columns of the plan table (or <code class="codeph">V$SQL_PLAN_STATISTICS_ALL</code> if statistics are included). You can apply a predicate on the specified table to select rows of the plan to display.
                                       </p>
                                       <p>The <code class="codeph">format</code> parameter controls the level of the plan. It accepts the values <code class="codeph">BASIC</code>, <code class="codeph">TYPICAL</code>, <code class="codeph">SERIAL</code>, and <code class="codeph">ALL</code>.
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="25%" id="d21079e2794" headers="d21079e2755 ">
                                       <p><code class="codeph">DISPLAY_AWR</code></p>
                                    </td>
                                    <td align="left" valign="top" width="75%" headers="d21079e2794 d21079e2758 ">
                                       <p><span>This table function displays the contents of an execution plan stored in AWR.</span></p>
                                       <p>The <code class="codeph">format</code> parameter controls the level of the plan. It accepts the values <code class="codeph">BASIC</code>, <code class="codeph">TYPICAL</code>, <code class="codeph">SERIAL</code>, and <code class="codeph">ALL</code>.
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="25%" id="d21079e2820" headers="d21079e2755 ">
                                       <p><code class="codeph">DISPLAY_CURSOR</code></p>
                                    </td>
                                    <td align="left" valign="top" width="75%" headers="d21079e2820 d21079e2758 ">
                                       <p><span>This table function displays the explain plan of any cursor loaded in the cursor cache. In addition to the explain plan, various plan statistics (such as. I/O, memory and timing) can be reported (based on the <code class="codeph">V$SQL_PLAN_STATISTICS_ALL VIEWS</code>).</span></p>
                                       <p><span>The <code class="codeph">format</code> parameter controls the level of the plan. It accepts the values <code class="codeph">BASIC</code>, <code class="codeph">TYPICAL</code>, <code class="codeph">SERIAL</code>, <code class="codeph">ALL</code>, and <code class="codeph">ADAPTIVE</code>.</span> When you specify <code class="codeph">ADAPTIVE</code>, the output includes: 
                                       </p>
                                       <ul style="list-style-type: disc;">
                                          <li>
                                             <p>The final plan. If the execution has not completed, then the output shows the current plan. This section also includes notes about run-time optimizations that affect the plan.</p>
                                          </li>
                                          <li>
                                             <p>Recommended plan. In reporting mode, the output includes the plan that would be chosen based on execution statistics.</p>
                                          </li>
                                          <li>
                                             <p>Dynamic plan. The output summarizes the portions of the plan that differ from the default plan chosen by the optimizer.</p>
                                          </li>
                                          <li>
                                             <p>Reoptimization. The output displays the plan that would be chosen on a subsequent execution because of reoptimization.</p>
                                          </li>
                                       </ul>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="25%" id="d21079e2871" headers="d21079e2755 ">
                                       <p><code class="codeph">DISPLAY_PLAN</code></p>
                                    </td>
                                    <td align="left" valign="top" width="75%" headers="d21079e2871 d21079e2758 "><span>This table function displays the contents of the plan table in a variety of formats with <code class="codeph">CLOB</code> output type.</span><p><span>The <code class="codeph">format</code> parameter controls the level of the plan. It accepts the values <code class="codeph">BASIC</code>, <code class="codeph">TYPICAL</code>, <code class="codeph">SERIAL</code>, <code class="codeph">ALL</code>, and <code class="codeph">ADAPTIVE</code>.</span> When you specify <code class="codeph">ADAPTIVE</code>, the output includes the default plan. For each dynamic subplan, the plan shows a list of the row sources from the original that may be replaced, and the row sources that would replace them. 
                                       </p>
                                       <p>If the <code class="codeph">format</code> argument specifies the outline display, then the function displays the hints for each option in the dynamic subplan. If the plan is not an adaptive query plan, then the function displays the default plan. When you do not specify <code class="codeph">ADAPTIVE</code>, the plan is shown as-is, but with additional comments in the Note section that show any row sources that are dynamic.
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="25%" id="d21079e2916" headers="d21079e2755 ">
                                       <p><code class="codeph">DISPLAY_SQL_PLAN_BASELINE</code></p>
                                    </td>
                                    <td align="left" valign="top" width="75%" headers="d21079e2916 d21079e2758 ">
                                       <p><span>This table function displays one or more execution plans for the specified SQL handle of a SQL plan baseline.</span></p>
                                       <p>This function uses plan information stored in the plan baseline to explain and display the plans. The <code class="codeph">plan_id</code> stored in the SQL management base may not match the <code class="codeph">plan_id</code> of the generated plan. A mismatch between the stored <code class="codeph">plan_id</code> and generated <code class="codeph">plan_id</code> means that it is a non-reproducible plan. Such a plan is deemed invalid and is bypassed by the optimizer during SQL compilation.
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="25%" id="d21079e2939" headers="d21079e2755 ">
                                       <p><code class="codeph">DISPLAY_SQLSET</code></p>
                                    </td>
                                    <td align="left" valign="top" width="75%" headers="d21079e2939 d21079e2758 ">
                                       <p><span>This table function displays the execution plan of a given statement stored in a SQL tuning set.</span></p>
                                       <p>The <code class="codeph">format</code> parameter controls the level of the plan. It accepts the values <code class="codeph">BASIC</code>, <code class="codeph">TYPICAL</code>, <code class="codeph">SERIAL</code>, and <code class="codeph">ALL</code>.
                                       </p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <div class="section"></div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-2C3C060E-1E16-4075-BA08-37148F0BFDFA__GUID-C6E97A92-5673-43E0-A386-FD30DB280405">
                           <p class="notep1">See Also:</p>
                           <p><a href="../arpls/DBMS_SQLTUNE.html#ARPLS68408" target="_blank"><span><cite>Oracle Database PL/SQL Packages and Types Reference</cite></span></a> to learn more about <code class="codeph">DBMS_XPLAN</code> display functions
                           </p>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="generating-and-displaying-execution-plans.html#GUID-5E88AD7F-D5FF-4003-B721-9126352CE414" title="To display the plan table output, you can use either SQL scripts or the DBMS_XPLAN package.">About the Display of PLAN_TABLE Output</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TGSQL285"></a><a id="TGSQL284"></a><div class="props_rev_3"><a id="GUID-955B4D41-EB27-44FE-A9E2-8C42835B652D" name="GUID-955B4D41-EB27-44FE-A9E2-8C42835B652D"></a><h5 id="TGSQL-GUID-955B4D41-EB27-44FE-A9E2-8C42835B652D" class="sect5"><span class="enumeration_section">6.3.1.2 </span>Plan-Related Views
                     </h5>
                     <div>
                        <p>You can obtain information about execution plans by querying dynamic performance and data dictionary views.</p>
                        <div class="section">
                           <div class="tblformal" id="GUID-955B4D41-EB27-44FE-A9E2-8C42835B652D__CEGJADJA">
                              <p class="titleintable">Table 6-2 Execution Plan Views</p>
                              <table cellpadding="4" cellspacing="0" class="Formal" title="Execution Plan Views" summary="This 2 column table describes execution plan views. Column 1 is the view. Column 2 describes that view. " width="100%" frame="hsides" border="1" rules="rows">
                                 <thead>
                                    <tr align="left" valign="top">
                                       <th align="left" valign="bottom" width="41%" id="d21079e3118">View</th>
                                       <th align="left" valign="bottom" width="59%" id="d21079e3121">Description</th>
                                    </tr>
                                 </thead>
                                 <tbody>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="41%" id="d21079e3126" headers="d21079e3118 ">
                                          <p><code class="codeph">V$SQL</code></p>
                                       </td>
                                       <td align="left" valign="top" width="59%" headers="d21079e3126 d21079e3121 ">
                                          <p>Lists statistics for cursors and contains one row for each child of the original SQL text entered.</p>
                                          <p>Starting in <span>Oracle Database 19c</span>, <code class="codeph">V$SQL.QUARANTINED</code> indicates whether a statement has been terminated by the Resource Manager because the statement consumed too many resources. Oracle Database records and marks the quarantined plans and prevents the execution of statements using these plans from executing. The <code class="codeph">AVOIDED_EXECUTIONS</code> column indicates the number of executions attempted but prevented because of the quarantined statement.
                                          </p>
                                       </td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="41%" id="d21079e3145" headers="d21079e3118 ">
                                          <p><code class="codeph">V$SQL_SHARED_CURSOR</code></p>
                                       </td>
                                       <td align="left" valign="top" width="59%" headers="d21079e3145 d21079e3121 ">
                                          <p>Explains why a particular child cursor is not shared with existing child cursors. Each column identifies a specific reason why the cursor cannot be shared.</p>
                                          <p>The <code class="codeph">USE_FEEDBACK_STATS</code> column shows whether a child cursor fails to match because of reoptimization.
                                          </p>
                                       </td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="41%" id="d21079e3158" headers="d21079e3118 ">
                                          <p><code class="codeph">V$SQL_PLAN</code></p>
                                       </td>
                                       <td align="left" valign="top" width="59%" headers="d21079e3158 d21079e3121 ">
                                          <p>Contains the plan for every statement stored in the shared SQL area. </p>
                                          <p>The view definition is similar to <code class="codeph">PLAN_TABLE</code>. The view includes a superset of all rows appearing in all final plans. <code class="codeph">PLAN_LINE_ID</code> is consecutively numbered, but for a single final plan, the IDs may not be consecutive. 
                                          </p>
                                          <p>As an alternative to <code class="codeph">EXPLAIN PLAN</code>, you can display the plan by querying <code class="codeph">V$SQL_PLAN</code>. The advantage of <code class="codeph">V$SQL_PLAN</code> over <code class="codeph">EXPLAIN PLAN</code> is that you do not need to know the compilation environment that was used to execute a particular statement. For <code class="codeph">EXPLAIN PLAN</code>, you would need to set up an identical environment to get the same plan when executing the statement.
                                          </p>
                                       </td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="41%" id="d21079e3191" headers="d21079e3118 ">
                                          <p><code class="codeph">V$SQL_PLAN_STATISTICS</code></p>
                                       </td>
                                       <td align="left" valign="top" width="59%" headers="d21079e3191 d21079e3121 ">
                                          <p>Provides the actual execution statistics for every operation in the plan, such as the number of output rows and elapsed time. All statistics, except the number of output rows, are cumulative. For example, the statistics for a join operation also includes the statistics for its two inputs. The statistics in <code class="codeph">V$SQL_PLAN_STATISTICS</code> are available for cursors that have been compiled with the <code class="codeph">STATISTICS_LEVEL</code> initialization parameter set to <code class="codeph">ALL</code>.
                                          </p>
                                       </td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="41%" id="d21079e3208" headers="d21079e3118 ">
                                          <p><code class="codeph">V$SQL_PLAN_STATISTICS_ALL</code></p>
                                       </td>
                                       <td align="left" valign="top" width="59%" headers="d21079e3208 d21079e3121 ">
                                          <p>Contains memory usage statistics for row sources that use SQL memory (sort or hash join). This view concatenates information in <code class="codeph">V$SQL_PLAN</code> with execution statistics from <code class="codeph">V$SQL_PLAN_STATISTICS</code> and <code class="codeph">V$SQL_WORKAREA</code>.
                                          </p>
                                          <p><code class="codeph">V$SQL_PLAN_STATISTICS_ALL</code> enables side-by-side comparisons of the estimates that the optimizer provides for the number of rows and elapsed time. This view combines both <code class="codeph">V$SQL_PLAN</code> and <code class="codeph">V$SQL_PLAN_STATISTICS</code> information for every cursor.
                                          </p>
                                       </td>
                                    </tr>
                                 </tbody>
                              </table>
                           </div>
                           <!-- class="inftblhruleinformal" -->
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-955B4D41-EB27-44FE-A9E2-8C42835B652D__GUID-5DA25729-85FE-4E7C-8A5B-6FBF826F8A85">
                           <p class="notep1">See Also:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><span class="q">"<a href="optimizer-ref.html#GUID-5AE1939F-F654-42FF-B0C5-706507CD12A2" title="PLAN_TABLE is populated by the EXPLAIN PLAN statement.">PLAN_TABLE Columns</a>"</span></p>
                              </li>
                              <li>
                                 <p><span class="q">"<a href="monitoring-database-operations.html#GUID-C941CE9D-97E1-42F8-91ED-4949B2B710BF" title="This chapter describes how to monitor SQL and PL/SQL.">Monitoring Database Operations</a>"</span> for information about the <code class="codeph">V$SQL_PLAN_MONITOR</code> view
                                 </p>
                              </li>
                              <li>
                                 <p><a href="../refrn/V-SQL_PLAN.html#REFRN-GUID-87561B21-721C-42EB-8E3D-28251C9BC50C" target="_blank"><span><cite>Oracle Database Reference</cite></span></a> for more information about <code class="codeph">V$SQL_PLAN</code> views
                                 </p>
                              </li>
                              <li>
                                 <p><a href="../refrn/STATISTICS_LEVEL.html#REFRN-GUID-16B23F95-8644-407A-A6C8-E85CADFA61FF" target="_blank"><span><cite>Oracle Database Reference</cite></span></a> for information about the <code class="codeph">STATISTICS_LEVEL</code> initialization parameter
                                 </p>
                              </li>
                           </ul>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="generating-and-displaying-execution-plans.html#GUID-5E88AD7F-D5FF-4003-B721-9126352CE414" title="To display the plan table output, you can use either SQL scripts or the DBMS_XPLAN package.">About the Display of PLAN_TABLE Output</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="TGSQL94710"></a><a id="TGSQL94711"></a><a id="TGSQL94712"></a><a id="TGSQL277"></a><div class="props_rev_3"><a id="GUID-1FA56307-047B-42BB-AF17-3B05F1814559" name="GUID-1FA56307-047B-42BB-AF17-3B05F1814559"></a><h4 id="TGSQL-GUID-1FA56307-047B-42BB-AF17-3B05F1814559" class="sect4"><span class="enumeration_section">6.3.2 </span>Displaying Execution Plans: Basic Steps
                  </h4>
                  <div>
                     <p>The <code class="codeph">DBMS_XPLAN.DISPLAY</code> function is a simple way to display an explained plan.
                     </p>
                     <div class="section">
                        <p>By default, the <code class="codeph">DISPLAY</code> function uses the format setting of <code class="codeph">TYPICAL</code>. In this case, the plan the most relevant information in the plan: operation id, name and option, rows, bytes and optimizer cost. Pruning, parallel and predicate information are only displayed when applicable.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-1FA56307-047B-42BB-AF17-3B05F1814559__GUID-9783646C-282C-4335-AE7D-DE214B14CABC">To display an execution plan:</p>
                        <ol>
                           <li>
                              <p>Start SQL*Plus or SQL Developer and log in to the session in which you explained the plan.</p>
                           </li>
                           <li>
                              <p>Explain a plan.</p>
                           </li>
                           <li>
                              <p>Query <code class="codeph">PLAN_TABLE</code> using <code class="codeph">DBMS_XPLAN.DISPLAY</code>.
                              </p>
                              <p>Specify the query as follows:</p><pre class="pre codeblock"><code>SELECT PLAN_TABLE_OUTPUT FROM TABLE(DBMS_XPLAN.DISPLAY);
</code></pre><p>Alternatively, specify the statement ID using the <code class="codeph">statement_id</code> parameter:
                              </p><pre class="pre codeblock"><code>SELECT PLAN_TABLE_OUTPUT FROM TABLE(DBMS_XPLAN.DISPLAY(statement_id =&gt; '<span class="italic">statement_id</span>));
</code></pre></li>
                        </ol>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-1FA56307-047B-42BB-AF17-3B05F1814559__CEGCJACH">
                        <p class="titleinexample">Example 6-2 EXPLAIN PLAN for Statement ID ex_plan1</p>
                        <p>This example explains a query of <code class="codeph">employees</code> that uses the statement ID <code class="codeph">ex_plan1</code>, and then queries <code class="codeph">PLAN_TABLE</code>:
                        </p><pre class="pre codeblock"><code>EXPLAIN PLAN 
  SET statement_id = 'ex_plan1' FOR
  SELECT phone_number 
  FROM   employees
  WHERE  phone_number LIKE '650%';

SELECT PLAN_TABLE_OUTPUT 
  FROM TABLE(DBMS_XPLAN.DISPLAY(statement_id =&gt; 'ex_plan1'));
</code></pre><p>Sample output appears below:</p><pre class="pre codeblock"><code>Plan hash value: 1445457117

-------------------------------------------------------------------------------
| Id  | Operation         | Name      | Rows  | Bytes | Cost (%CPU)| Time     |
-------------------------------------------------------------------------------
|   0 | SELECT STATEMENT  |           |     1 |    15 |     2   (0)| 00:00:01 |
|*  1 |  TABLE ACCESS FULL| EMPLOYEES |     1 |    15 |     2   (0)| 00:00:01 |
-------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   1 - filter("PHONE_NUMBER" LIKE '650%')</code></pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-1FA56307-047B-42BB-AF17-3B05F1814559__GUID-2E0342FE-ABA2-48D0-9E12-20AD0A8A7CE4">
                        <p class="titleinexample">Example 6-3 EXPLAIN PLAN for Statement ID ex_plan2</p>
                        <p>This example explains a query of <code class="codeph">employees</code> that uses the statement ID <code class="codeph">ex_plan2</code>, and then displays the plan using the <code class="codeph">BASIC</code> format:
                        </p><pre class="pre codeblock"><code>EXPLAIN PLAN 
  SET statement_id = 'ex_plan2' FOR
  SELECT last_name 
  FROM   employees
  WHERE  last_name LIKE 'Pe%';

SELECT PLAN_TABLE_OUTPUT 
  FROM TABLE(DBMS_XPLAN.DISPLAY(NULL, 'ex_plan2','BASIC'));
</code></pre><p>Sample output appears below:</p><pre class="pre codeblock"><code>----------------------------------------
| Id  | Operation        | Name        |
----------------------------------------
|   0 | SELECT STATEMENT |             |
|   1 |  INDEX RANGE SCAN| EMP_NAME_IX |
----------------------------------------</code></pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-1FA56307-047B-42BB-AF17-3B05F1814559__GUID-64C544C6-F43E-4AD8-A1C2-AE0837615EF9">
                        <p class="notep1">See Also:</p>
                        <p><a href="../arpls/DBMS_XPLAN.html#GUID-BAD480AA-351A-48FE-A8E7-F0D8EF643EBF" target="_blank"><span><cite>Oracle Database PL/SQL Packages and Types Reference</cite></span></a> for more information about the <code class="codeph">DBMS_XPLAN</code> package
                        </p>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="generating-and-displaying-execution-plans.html#GUID-725CADF8-3803-416F-96EB-BF942F742663" title="The easiest way to display execution plans is to use DBMS_XPLAN display functions or V$ views.">Displaying Execution Plans</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="TGSQL94855"></a><a id="TGSQL94856"></a><a id="TGSQL94857"></a><a id="TGSQL94854"></a><div class="props_rev_3"><a id="GUID-83F88700-3902-4D19-8182-AF2B92AEA7EB" name="GUID-83F88700-3902-4D19-8182-AF2B92AEA7EB"></a><h4 id="TGSQL-GUID-83F88700-3902-4D19-8182-AF2B92AEA7EB" class="sect4"><span class="enumeration_section">6.3.3 </span>Displaying Adaptive Query Plans: Tutorial
                  </h4>
                  <div>
                     <p>The <strong class="term">adaptive optimizer</strong> is a feature of the optimizer that enables it to adapt plans based on run-time statistics. All adaptive mechanisms can execute a final plan for a statement that differs from the default plan.
                     </p>
                     <div class="section">
                        <p>An <a href="glossary.html#GUID-5E4FD63A-4143-48FF-B8ED-9D953B8A6D40"><span class="xrefglossterm">adaptive query plan</span></a> chooses among subplans <span class="italic">during</span> the current statement execution. In contrast, <a href="glossary.html#GUID-70FBCF66-F29E-4ADE-BEA8-F328917A2986"><span class="xrefglossterm">automatic reoptimization</span></a> changes a plan only on executions that occur <span class="italic">after</span> the current statement execution.
                        </p>
                        <p>You can determine whether the database used adaptive query optimization for a SQL statement based on the comments in the <code class="codeph">Notes</code> section of plan. The comments indicate whether row sources are dynamic, or whether automatic reoptimization adapted a plan.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-83F88700-3902-4D19-8182-AF2B92AEA7EB__GUID-0E629273-B74D-4E09-BB79-C79169436C8B">Assumptions</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>This tutorial assumes the following:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>The <code class="codeph">STATISTICS_LEVEL</code> initialization parameter is set to <code class="codeph">ALL</code>.
                              </p>
                           </li>
                           <li>
                              <p>The database uses the default settings for adaptive execution.</p>
                           </li>
                           <li>
                              <p>As user <code class="codeph">oe</code>, you want to issue the following separate queries:
                              </p><pre class="pre codeblock"><code>SELECT o.order_id, v.product_name
FROM   orders o,
       (  SELECT order_id, product_name
          FROM   order_items o, product_information p
          WHERE  p.product_id = o.product_id
          AND    list_price &lt; 50
          AND    min_price &lt; 40  ) v
WHERE  o.order_id = v.order_id

SELECT product_name
FROM   order_items o, product_information p  
WHERE  o.unit_price = 15 
AND    quantity &gt; 1
AND    p.product_id = o.product_id
</code></pre></li>
                           <li>
                              <p>Before executing each query, you want to query <code class="codeph">DBMS_XPLAN.DISPLAY_PLAN</code> to see the default plan, that is, the plan that the optimizer chose before applying its adaptive mechanism.
                              </p>
                           </li>
                           <li>
                              <p>After executing each query, you want to query <code class="codeph">DBMS_XPLAN.DISPLAY_CURSOR</code> to see the final plan and adaptive query plan.
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">SYS</code> has granted <code class="codeph">oe</code> the following privileges:
                              </p>
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p><code class="codeph">GRANT SELECT ON V_$SESSION TO oe</code></p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">GRANT SELECT ON V_$SQL TO oe</code></p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">GRANT SELECT ON V_$SQL_PLAN TO oe</code></p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">GRANT SELECT ON V_$SQL_PLAN_STATISTICS_ALL TO oe</code></p>
                                 </li>
                              </ul>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-83F88700-3902-4D19-8182-AF2B92AEA7EB__GUID-736704A9-2856-46B9-B799-BC30AEB87469">To see the results of adaptive optimization:</p>
                        <ol>
                           <li>
                              <p>Start SQL*Plus, and then connect to the database as user <code class="codeph">oe</code>.
                              </p>
                           </li>
                           <li id="GUID-83F88700-3902-4D19-8182-AF2B92AEA7EB__CEGEDCCC">
                              <p>Query <code class="codeph">orders</code>.
                              </p>
                              <p>For example, use the following statement:</p><pre class="pre codeblock"><code>SELECT o.order_id, v.product_name
FROM   orders o,
       (  SELECT order_id, product_name
          FROM   order_items o, product_information p
          WHERE  p.product_id = o.product_id
          AND    list_price &lt; 50
          AND    min_price &lt; 40  ) v
WHERE  o.order_id = v.order_id;
</code></pre></li>
                           <li id="GUID-83F88700-3902-4D19-8182-AF2B92AEA7EB__CEGCEJFA">
                              <p>View the plan in the cursor.</p>
                              <p>For example, run the following commands:</p><pre class="pre codeblock"><code>SET LINESIZE 165
SET PAGESIZE 0
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(FORMAT=&gt;'+ALLSTATS'));
</code></pre><p>The following sample output has been reformatted to fit on the page. In this plan, the optimizer chooses a nested loops join. The original optimizer estimates are shown in the <code class="codeph">E-Rows</code> column, whereas the actual statistics gathered during execution are shown in the <code class="codeph">A-Rows</code> column. In the <code class="codeph">MERGE JOIN</code> operation, the difference between the estimated and actual number of rows is significant.
                              </p><pre class="pre codeblock"><code>--------------------------------------------------------------------------------------------
|Id| Operation             | Name          |Start<span class="bold">|E-Rows|A-Rows|</span>A-Time|Buff|OMem|1Mem|O/1/M|
--------------------------------------------------------------------------------------------
| 0| SELECT STATEMENT      |                |   1|   | 269|00:00:00.09|1338|    |    |     |
| 1|  <span class="bold">NESTED LOOPS</span>         |                |   1|  1| 269|00:00:00.09|1338|    |    |     |
| 2|   MERGE JOIN CARTESIAN|                |   1|  4|9135|00:00:00.03|  33|    |    |     |
|*3|    TABLE ACCESS FULL  |PRODUCT_INFORMAT|   1|  1|  87|00:00:00.01|  32|    |    |     |
| 4|    BUFFER SORT        |                |  87|105|9135|00:00:00.01|   1|4096|4096|1/0/0|
| 5|     INDEX FULL SCAN   | ORDER_PK       |   1|105| 105|00:00:00.01|   1|    |    |     |
|*6|   INDEX UNIQUE SCAN   | ORDER_ITEMS_UK |9135|  1| 269|00:00:00.03|1305|    |    |     |
--------------------------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
 
   3 - filter(("MIN_PRICE"&lt;40 AND "LIST_PRICE"&lt;50))
   6 - access("O"."ORDER_ID"="ORDER_ID" AND "P"."PRODUCT_ID"="O"."PRODUCT_ID")
</code></pre></li>
                           <li>
                              <p>Run the same query of <code class="codeph">orders</code> that you ran in Step 2.
                              </p>
                           </li>
                           <li>
                              <p>View the execution plan in the cursor by using the same <code class="codeph">SELECT</code> statement that you ran in Step 3.
                              </p>
                              <p>The following example shows that the optimizer has chosen a different plan, using a hash join. The Note section shows that the optimizer used statistics feedback to adjust its cost estimates for the second execution of the query, thus illustrating automatic reoptimization.</p><pre class="pre codeblock"><code>--------------------------------------------------------------------------------------------
|Id| Operation              |Name    |Start|E-Rows|A-Rows|A-Time|Buff|Reads|OMem|1Mem|O/1/M|
--------------------------------------------------------------------------------------------
| 0| SELECT STATEMENT       |               | 1 |   |269|00:00:00.02|60|1|     |     |     |
| 1|  NESTED LOOPS          |               | 1 |269|269|00:00:00.02|60|1|     |     |     |
|*2|   <span class="bold">HASH JOIN</span>            |               | 1 |313|269|00:00:00.02|39|1|1000K|1000K|1/0/0|
|*3|    TABLE ACCESS FULL   |PRODUCT_INFORMA| 1 | 87| 87|00:00:00.01|15|0|     |     |     |
| 4|    INDEX FAST FULL SCAN|ORDER_ITEMS_UK | 1 |665|665|00:00:00.01|24|1|     |     |     |
|*5|   INDEX UNIQUE SCAN    |ORDER_PK       |269|  1|269|00:00:00.01|21|0|     |     |     |
--------------------------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
 
   2 - access("P"."PRODUCT_ID"="O"."PRODUCT_ID")
   3 - filter(("MIN_PRICE"&lt;40 AND "LIST_PRICE"&lt;50))
   5 - access("O"."ORDER_ID"="ORDER_ID")
 
Note
-----
   - <span class="bold">statistics feedback used for this statement</span>
</code></pre></li>
                           <li>
                              <p>Query <code class="codeph">V$SQL</code> to verify the performance improvement.
                              </p>
                              <p>The following query shows the performance of the two statements (sample output included). </p><pre class="pre codeblock"><code>SELECT CHILD_NUMBER, CPU_TIME, ELAPSED_TIME, BUFFER_GETS
FROM   V$SQL
WHERE  SQL_ID = 'gm2npz344xqn8';
 
CHILD_NUMBER   CPU_TIME ELAPSED_TIME BUFFER_GETS
------------ ---------- ------------ -----------
           0      92006       131485        1831
           1      12000        24156          60
</code></pre><p>The second statement executed, which is child number <code class="codeph">1</code>, used statistics feedback. CPU time, elapsed time, and buffer gets are all significantly lower.
                              </p>
                           </li>
                           <li>
                              <p>Explain the plan for the query of <code class="codeph">order_items</code>.
                              </p>
                              <p>For example, use the following statement:</p><pre class="pre codeblock"><code>EXPLAIN PLAN FOR
  SELECT product_name 
  FROM   order_items o, product_information p  
  WHERE  o.unit_price = 15
  AND    quantity &gt; 1  
  AND    p.product_id = o.product_id
</code></pre></li>
                           <li>
                              <p>View the plan in the plan table.</p>
                              <p>For example, run the following statement:</p><pre class="pre codeblock"><code>SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
</code></pre><p>Sample output appears below:</p><pre class="pre codeblock"><code>-------------------------------------------------------------------------------
|Id| Operation                 | Name             |Rows|Bytes|Cost (%CPU)|Time|
-------------------------------------------------------------------------------
| 0| SELECT STATEMENT             |                      |4|128|7 (0)|00:00:01|
| 1|  NESTED LOOPS                |                      | |   |     |        |
| 2|   NESTED LOOPS               |                      |4|128|7 (0)|00:00:01|
|*3|    TABLE ACCESS FULL         |ORDER_ITEMS           |4|48 |3 (0)|00:00:01|
|*4|    INDEX UNIQUE SCAN         |PRODUCT_INFORMATION_PK|1|   |0 (0)|00:00:01|
| 5|   TABLE ACCESS BY INDEX ROWID|PRODUCT_INFORMATION   |1|20 |1 (0)|00:00:01|
-------------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
 
   3 - filter("O"."UNIT_PRICE"=15 AND "QUANTITY"&gt;1)
   4 - access("P"."PRODUCT_ID"="O"."PRODUCT_ID")
</code></pre><p>In this plan, the optimizer chooses a nested loops join.</p>
                           </li>
                           <li>
                              <p>Run the query that you previously explained.</p>
                              <p>For example, use the following statement:</p><pre class="pre codeblock"><code>SELECT product_name 
FROM   order_items o, product_information p  
WHERE  o.unit_price = 15
AND    quantity &gt; 1  
AND    p.product_id = o.product_id
</code></pre></li>
                           <li>
                              <p>View the plan in the cursor.</p>
                              <p>For example, run the following commands:</p><pre class="pre codeblock"><code>SET LINESIZE 165
SET PAGESIZE 0
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY(FORMAT=&gt;'+ADAPTIVE'));
</code></pre><p>Sample output appears below. Based on statistics collected at run time (Step 4), the optimizer chose a hash join rather than the nested loops join. The dashes (<code class="codeph">-</code>) indicate the steps in the nested loops plan that the optimizer considered but do not ultimately choose. The switch illustrates the adaptive query plan feature.
                              </p><pre class="pre codeblock"><code>-------------------------------------------------------------------------------
|Id | Operation                     | Name     |Rows|Bytes|Cost(%CPU)|Time    |
-------------------------------------------------------------------------------
|  0| SELECT STATEMENT              |                     |4|128|7(0)|00:00:01|
| *1|  HASH JOIN                    |                     |4|128|7(0)|00:00:01|
|- 2|   NESTED LOOPS                |                     | |   |    |        |
|- 3|    NESTED LOOPS               |                     | |128|7(0)|00:00:01|
|- 4|     <span class="bold">STATISTICS COLLECTOR</span>      |                     | |   |    |        |
| *5|      TABLE ACCESS FULL        | ORDER_ITEMS         |4| 48|3(0)|00:00:01|
|-*6|     INDEX UNIQUE SCAN         | PRODUCT_INFORMATI_PK|1|   |0(0)|00:00:01|
|- 7|    TABLE ACCESS BY INDEX ROWID| PRODUCT_INFORMATION |1| 20|1(0)|00:00:01|
|  8|   TABLE ACCESS FULL           | PRODUCT_INFORMATION |1| 20|1(0)|00:00:01|
-------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------
   1 - access("P"."PRODUCT_ID"="O"."PRODUCT_ID")
   5 - filter("O"."UNIT_PRICE"=15 AND "QUANTITY"&gt;1)
   6 - access("P"."PRODUCT_ID"="O"."PRODUCT_ID")

Note
-----
   - <span class="bold">this is an adaptive plan (rows marked '-' are inactive)</span></code></pre></li>
                        </ol>
                     </div>
                     <!-- class="section" -->
                     <div class="section"></div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-83F88700-3902-4D19-8182-AF2B92AEA7EB__GUID-83F902F5-DC23-45B7-B771-7207B505F555">
                        <p class="notep1">See Also:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><span class="q">"<a href="query-optimizer-concepts.html#GUID-5A1EB094-1A9E-4B69-9BE5-39BDA2B3253C" title="An adaptive query plan enables the optimizer to make a plan decision for a statement during execution.">Adaptive Query Plans</a>"</span></p>
                           </li>
                           <li>
                              <p><span class="q">"<a href="generating-and-displaying-execution-plans.html#GUID-2C3C060E-1E16-4075-BA08-37148F0BFDFA__CEGCBHGJ" title="This 2 column table describes DBMS_XPLAN program units. Column 1 lists the functions. Column 2 provides more information about the functions.">Table 6-1</a>"</span></p>
                           </li>
                           <li>
                              <p><span class="q">"<a href="influencing-the-optimizer.html#GUID-DAFB7D07-E8B3-4219-A09D-214BD943AFF9" title="In Oracle Database, adaptive query optimization is the process by which the optimizer adapts an execution plan based on statistics collected at run time.">Controlling Adaptive Optimization</a>"</span></p>
                           </li>
                           <li>
                              <p><a href="../refrn/STATISTICS_LEVEL.html#REFRN10214" target="_blank"><span class="italic">Oracle Database Reference</span></a> to learn about the <code class="codeph">STATISTICS_LEVEL</code> initialization parameter
                              </p>
                           </li>
                           <li>
                              <p><a href="../arpls/DBMS_SQLTUNE.html#ARPLS68408" target="_blank"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> to learn more about <code class="codeph">DBMS_XPLAN</code></p>
                           </li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="generating-and-displaying-execution-plans.html#GUID-725CADF8-3803-416F-96EB-BF942F742663" title="The easiest way to display execution plans is to use DBMS_XPLAN display functions or V$ views.">Displaying Execution Plans</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="sect3"><a id="GUID-90411427-FDD7-4196-A52A-84D153CE37C1" name="GUID-90411427-FDD7-4196-A52A-84D153CE37C1"></a><h4 id="TGSQL-GUID-90411427-FDD7-4196-A52A-84D153CE37C1" class="sect4"><span class="enumeration_section">6.3.4 </span>Display Execution Plans: Examples
                  </h4>
                  <div>
                     <p>These examples show different ways of displaying execution plans.</p>
                     <p>This section contains the following topics:</p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="generating-and-displaying-execution-plans.html#GUID-51E46694-0C6B-4FDA-8C2F-0D7D7536D5F8">Customizing PLAN_TABLE Output</a><br>If you have specified a statement identifier, then you can write your own script to query the <code class="codeph">PLAN_TABLE</code>. 
                        </li>
                        <li class="ulchildlink"><a href="generating-and-displaying-execution-plans.html#GUID-22F3C307-95C3-47EE-A3FD-545F614947CB">Displaying Parallel Execution Plans: Example</a><br>Plans for parallel queries differ in important ways from plans for serial queries.
                        </li>
                        <li class="ulchildlink"><a href="generating-and-displaying-execution-plans.html#GUID-CE8BCA2D-47B5-4FBD-95A9-5096A5734063">Displaying Bitmap Index Plans: Example</a><br>Index row sources using bitmap indexes appear in the <code class="codeph">EXPLAIN PLAN</code> output with the word <code class="codeph">BITMAP</code> indicating the type of the index.
                        </li>
                        <li class="ulchildlink"><a href="generating-and-displaying-execution-plans.html#GUID-FE0B82DA-1A06-4145-B03D-A1C39DB1F88F">Displaying Result Cache Plans: Example</a><br>When your query contains the <code class="codeph">result_cache</code> hint, the <code class="codeph">ResultCache</code> operator is inserted into the execution plan. 
                        </li>
                        <li class="ulchildlink"><a href="generating-and-displaying-execution-plans.html#GUID-37DF6780-3279-47CE-93E6-BE922F1451EF">Displaying Plans for Partitioned Objects: Example</a><br>Use <code class="codeph">EXPLAIN PLAN</code> to determine how Oracle Database accesses partitioned objects for specific queries. 
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="generating-and-displaying-execution-plans.html#GUID-725CADF8-3803-416F-96EB-BF942F742663" title="The easiest way to display execution plans is to use DBMS_XPLAN display functions or V$ views.">Displaying Execution Plans</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="TGSQL94709"></a><div class="props_rev_3"><a id="GUID-51E46694-0C6B-4FDA-8C2F-0D7D7536D5F8" name="GUID-51E46694-0C6B-4FDA-8C2F-0D7D7536D5F8"></a><h5 id="TGSQL-GUID-51E46694-0C6B-4FDA-8C2F-0D7D7536D5F8" class="sect5"><span class="enumeration_section">6.3.4.1 </span>Customizing PLAN_TABLE Output
                     </h5>
                     <div>
                        <p>If you have specified a statement identifier, then you can write your own script to query the <code class="codeph">PLAN_TABLE</code>. 
                        </p>
                        <div class="section">
                           <p>For example:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>Start with ID = 0 and given <code class="codeph">STATEMENT_ID</code>.
                                 </p>
                              </li>
                              <li>
                                 <p>Use the <code class="codeph">CONNECT BY</code> clause to walk the tree from parent to child, the join keys being <code class="codeph">STATEMENT_ID = PRIOR STATMENT_ID</code> and <code class="codeph">PARENT_ID = PRIOR ID</code>.
                                 </p>
                              </li>
                              <li>
                                 <p>Use the pseudo-column <code class="codeph">LEVEL</code> (associated with <code class="codeph">CONNECT BY</code>) to indent the children.
                                 </p><pre class="pre codeblock"><code>SELECT cardinality "Rows",
   lpad(' ',level-1)||operation||' '||options||' '||object_name "Plan"
  FROM PLAN_TABLE
CONNECT BY prior id = parent_id
        AND prior statement_id = statement_id
  START WITH id = 0
        AND statement_id = 'st1'
  ORDER BY id;

   Rows Plan
------- ----------------------------------------
        SELECT STATEMENT
         TABLE ACCESS FULL EMPLOYEES
</code></pre><p>The <code class="codeph">NULL</code> in the <code class="codeph">Rows</code> column indicates that the optimizer does not have any statistics on the table. Analyzing the table shows the following:
                                 </p><pre class="pre codeblock"><code>   Rows Plan
------- ----------------------------------------
  16957 SELECT STATEMENT
  16957  TABLE ACCESS FULL EMPLOYEES
</code></pre><p>You can also select the <code class="codeph">COST</code>. This is useful for comparing execution plans or for understanding why the optimizer chooses one execution plan over another.
                                 </p>
                                 <div class="infoboxnote" id="GUID-51E46694-0C6B-4FDA-8C2F-0D7D7536D5F8__GUID-42DE2A10-328A-49B3-9B35-B8DA225B6B7C">
                                    <p class="notep1">Note:</p>
                                    <p>These simplified examples are not valid for recursive&nbsp;SQL. </p>
                                 </div>
                              </li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="generating-and-displaying-execution-plans.html#GUID-90411427-FDD7-4196-A52A-84D153CE37C1" title="These examples show different ways of displaying execution plans.">Display Execution Plans: Examples</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TGSQL94713"></a><div class="props_rev_3"><a id="GUID-22F3C307-95C3-47EE-A3FD-545F614947CB" name="GUID-22F3C307-95C3-47EE-A3FD-545F614947CB"></a><h5 id="TGSQL-GUID-22F3C307-95C3-47EE-A3FD-545F614947CB" class="sect5"><span class="enumeration_section">6.3.4.2 </span>Displaying Parallel Execution Plans: Example
                     </h5>
                     <div>
                        <p>Plans for parallel queries differ in important ways from plans for serial queries.</p>
                        <p>This section contains the following topics:</p>
                     </div>
                     <div>
                        <ul class="ullinks">
                           <li class="ulchildlink"><a href="generating-and-displaying-execution-plans.html#GUID-029E861E-50C7-4E64-BE47-5B34F6ADA86A">About EXPLAIN PLAN and Parallel Queries</a><br>Tuning a parallel query begins much like a non-parallel query tuning exercise by choosing the driving table. However, the rules governing the choice are different. 
                           </li>
                           <li class="ulchildlink"><a href="generating-and-displaying-execution-plans.html#GUID-ED34B100-C281-4100-9F4B-38C40B4A4ECE">Viewing Parallel Queries with EXPLAIN PLAN: Example</a><br>When using <code class="codeph">EXPLAIN PLAN</code> with parallel queries, the database compiles and executes one parallel plan. This plan is derived from the serial plan by allocating row sources specific to the parallel support in the QC plan. 
                           </li>
                        </ul>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="generating-and-displaying-execution-plans.html#GUID-90411427-FDD7-4196-A52A-84D153CE37C1" title="These examples show different ways of displaying execution plans.">Display Execution Plans: Examples</a></p>
                           </div>
                        </div>
                     </div>
                     <a id="TGSQL94714"></a><div class="props_rev_3"><a id="GUID-029E861E-50C7-4E64-BE47-5B34F6ADA86A" name="GUID-029E861E-50C7-4E64-BE47-5B34F6ADA86A"></a><h6 id="TGSQL-GUID-029E861E-50C7-4E64-BE47-5B34F6ADA86A" class="sect6"><span class="enumeration_section">6.3.4.2.1 </span>About EXPLAIN PLAN and Parallel Queries
                        </h6>
                        <div>
                           <p>Tuning a parallel query begins much like a non-parallel query tuning exercise by choosing the driving table. However, the rules governing the choice are different. </p>
                           <p>In the serial case, the best driving table produces the fewest numbers of rows after applying limiting conditions. The database joins a small number of rows to larger tables using non-unique indexes.</p>
                           <p>For example, consider a table hierarchy consisting of <code class="codeph">customer</code>, <code class="codeph">account</code>, and <code class="codeph">transaction</code>.
                           </p>
                           <div class="figure" id="GUID-029E861E-50C7-4E64-BE47-5B34F6ADA86A__GUID-F83F6CF6-70FD-4DDB-98D5-72870DEF5E70">
                              <p class="titleinfigure">Figure 6-1 A Table Hierarchy</p><img src="img/pfgrf211.gif" alt="Description of Figure 6-1 follows" title="Description of Figure 6-1 follows" longdesc="img_text/pfgrf211.html"><br><a href="img_text/pfgrf211.html">Description of "Figure 6-1 A Table Hierarchy"</a></div>
                           <!-- class="figure" -->
                           <p>In this example, <code class="codeph">customer</code> is the smallest table, whereas <code class="codeph">transaction</code> is the largest table. A typical OLTP query retrieves transaction information about a specific customer account. The query drives from the <code class="codeph">customer</code> table. The goal is to minimize logical I/O, which typically minimizes other critical resources including physical I/O and CPU time.
                           </p>
                           <p>For parallel queries, the driving table is usually the <span class="italic">largest</span> table. It would not be efficient to use parallel query in this case because only a few rows from each table are accessed. However, what if it were necessary to identify all customers who had transactions of a certain type last month? It would be more efficient to drive from the <code class="codeph">transaction</code> table because no limiting conditions exist on the <code class="codeph">customer</code> table. The database would join rows from the <code class="codeph">transaction</code> table to the <code class="codeph">account</code> table, and then finally join the result set to the <code class="codeph">customer</code> table. In this case, the used on the <code class="codeph">account</code> and <code class="codeph">customer</code> table are probably highly selective primary key or unique indexes rather than the non-unique indexes used in the first query. Because the <code class="codeph">transaction</code> table is large and the column is not selective, it would be beneficial to use parallel query driving from the <code class="codeph">transaction</code> table.
                           </p>
                           <p>Parallel operations include the following: </p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><code class="codeph">PARALLEL_TO_PARALLEL </code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">PARALLEL_TO_SERIAL </code></p>
                                 <p>A <code class="codeph">PARALLEL_TO_SERIAL</code> operation is always the step that occurs when the query coordinator consumes rows from a parallel operation. Another type of operation that does not occur in this query is a <code class="codeph">SERIAL</code> operation. If these types of operations occur, then consider making them parallel operations to improve performance because they too are potential bottlenecks.
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">PARALLEL_FROM_SERIAL </code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">PARALLEL_TO_PARALLEL </code></p>
                                 <p>If the workloads in each step are relatively equivalent, then the <code class="codeph">PARALLEL_TO_PARALLEL</code> operations generally produce the best performance. 
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">PARALLEL_COMBINED_WITH_CHILD </code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">PARALLEL_COMBINED_WITH_PARENT </code></p>
                                 <p>A <code class="codeph">PARALLEL_COMBINED_WITH_PARENT</code> operation occurs when the database performs the step simultaneously with the parent step. 
                                 </p>
                              </li>
                           </ul>
                           <p>If a parallel step produces many rows, then the QC may not be able to consume the rows as fast as they are produced. Little can be done to improve this situation.</p>
                        </div>
                        <div>
                           <div class="infoboxnotealso" id="GUID-029E861E-50C7-4E64-BE47-5B34F6ADA86A__GUID-E0692402-F90F-4625-BD94-9841DBEE007F">
                              <p class="notep1">See Also:</p>
                              <p>The <code class="codeph">OTHER_TAG</code> column in <span class="q">"<a href="optimizer-ref.html#GUID-5AE1939F-F654-42FF-B0C5-706507CD12A2" title="PLAN_TABLE is populated by the EXPLAIN PLAN statement.">PLAN_TABLE Columns</a>"</span></p>
                           </div>
                           <div class="familylinks">
                              <div class="parentlink">
                                 <p><strong>Parent topic:</strong> <a href="generating-and-displaying-execution-plans.html#GUID-22F3C307-95C3-47EE-A3FD-545F614947CB" title="Plans for parallel queries differ in important ways from plans for serial queries.">Displaying Parallel Execution Plans: Example</a></p>
                              </div>
                           </div>
                        </div>
                        
                     </div><a id="TGSQL94716"></a><a id="TGSQL94715"></a><div class="props_rev_3"><a id="GUID-ED34B100-C281-4100-9F4B-38C40B4A4ECE" name="GUID-ED34B100-C281-4100-9F4B-38C40B4A4ECE"></a><h6 id="TGSQL-GUID-ED34B100-C281-4100-9F4B-38C40B4A4ECE" class="sect6"><span class="enumeration_section">6.3.4.2.2 </span>Viewing Parallel Queries with EXPLAIN PLAN: Example
                        </h6>
                        <div>
                           <p>When using <code class="codeph">EXPLAIN PLAN</code> with parallel queries, the database compiles and executes one parallel plan. This plan is derived from the serial plan by allocating row sources specific to the parallel support in the QC plan. 
                           </p>
                           <div class="section">
                              <p>The table queue row sources (<code class="codeph">PX</code> <code class="codeph">Send</code> and <code class="codeph">PX</code> <code class="codeph">Receive</code>), the granule iterator, and buffer sorts, required by the two parallel execution server set PQ model, are directly inserted into the parallel plan. This plan is the same plan for all parallel execution servers when executed in parallel or for the QC when executed serially.
                              </p>
                           </div>
                           <!-- class="section" -->
                           <div class="example" id="GUID-ED34B100-C281-4100-9F4B-38C40B4A4ECE__CEGIFEAJ">
                              <p class="titleinexample">Example 6-4 Parallel Query Explain Plan</p>
                              <p>The following simple example illustrates an <code class="codeph">EXPLAIN</code> <code class="codeph">PLAN</code> for a parallel query:
                              </p><pre class="pre codeblock"><code>CREATE TABLE emp2 AS SELECT * FROM employees;

ALTER TABLE emp2 PARALLEL 2;

EXPLAIN PLAN FOR
  SELECT SUM(salary) 
  FROM   emp2 
  GROUP BY department_id;

SELECT PLAN_TABLE_OUTPUT FROM TABLE(DBMS_XPLAN.DISPLAY());

------------------------------------------------------------------------------------------------
| Id  | Operation              | Name     | Rows| Bytes |Cost %CPU|    TQ  |IN-OUT| PQ Distrib |
------------------------------------------------------------------------------------------------
| 0 | SELECT STATEMENT         |          | 107 |  2782 |  3 (34) |        |      |            |
| 1 |  PX COORDINATOR          |          |     |       |         |        |      |            |
| 2 |   PX SEND QC (RANDOM)    | :TQ10001 | 107 |  2782 |  3 (34) |  Q1,01 | P-&gt;S | QC (RAND)  |
| 3 |    HASH GROUP BY         |          | 107 |  2782 |  3 (34) |  Q1,01 | PCWP |            |
| 4 |     PX RECEIVE           |          | 107 |  2782 |  3 (34) |  Q1,01 | PCWP |            |
| 5 |      PX SEND HASH        | :TQ10000 | 107 |  2782 |  3 (34) |  Q1,00 | P-&gt;P | HASH       |
| 6 |       HASH GROUP BY      |          | 107 |  2782 |  3 (34) |  Q1,00 | PCWP |            |
| 7 |        PX BLOCK ITERATOR |          | 107 |  2782 |  2 (0)  |  Q1,00 | PCWP |            |
| 8 |         TABLE ACCESS FULL| EMP2     | 107 |  2782 |  2 (0)  |  Q1,00 | PCWP |            |
------------------------------------------------------------------------------------------------
</code></pre><p>One set of parallel execution servers scans <code class="codeph">EMP2</code> in parallel, while the second set performs the aggregation for the <code class="codeph">GROUP</code> <code class="codeph">BY</code> operation. The <code class="codeph">PX</code> <code class="codeph">BLOCK</code> <code class="codeph">ITERATOR</code> row source represents the splitting up of the table <code class="codeph">EMP2</code> into pieces to divide the scan workload between the parallel execution servers. The <code class="codeph">PX SEND</code> and <code class="codeph">PX RECEIVE</code> row sources represent the pipe that connects the two sets of parallel execution servers as rows flow up from the parallel scan, get repartitioned through the <code class="codeph">HASH</code> table queue, and then read by and aggregated on the top set. The <code class="codeph">PX SEND QC</code> row source represents the aggregated values being sent to the QC in random (RAND) order. The <code class="codeph">PX COORDINATOR</code> row source represents the QC or Query Coordinator which controls and schedules the parallel plan appearing below it in the plan tree.
                              </p>
                           </div>
                           <!-- class="example" -->
                        </div>
                        <div>
                           <div class="familylinks">
                              <div class="parentlink">
                                 <p><strong>Parent topic:</strong> <a href="generating-and-displaying-execution-plans.html#GUID-22F3C307-95C3-47EE-A3FD-545F614947CB" title="Plans for parallel queries differ in important ways from plans for serial queries.">Displaying Parallel Execution Plans: Example</a></p>
                              </div>
                           </div>
                        </div>
                        
                     </div>
                  </div><a id="TGSQL94718"></a><a id="TGSQL94717"></a><div class="props_rev_3"><a id="GUID-CE8BCA2D-47B5-4FBD-95A9-5096A5734063" name="GUID-CE8BCA2D-47B5-4FBD-95A9-5096A5734063"></a><h5 id="TGSQL-GUID-CE8BCA2D-47B5-4FBD-95A9-5096A5734063" class="sect5"><span class="enumeration_section">6.3.4.3 </span>Displaying Bitmap Index Plans: Example
                     </h5>
                     <div>
                        <p>Index row sources using bitmap indexes appear in the <code class="codeph">EXPLAIN PLAN</code> output with the word <code class="codeph">BITMAP</code> indicating the type of the index.
                        </p>
                        <div class="example" id="GUID-CE8BCA2D-47B5-4FBD-95A9-5096A5734063__CEGFDIHJ">
                           <p class="titleinexample">Example 6-5 EXPLAIN PLAN with Bitmap Indexes</p>
                           <p>In this example, the predicate <code class="codeph">c1=2</code> yields a bitmap from which a subtraction can take place. From this bitmap, the bits in the bitmap for <code class="codeph">c2=6</code> are subtracted. Also, the bits in the bitmap for <code class="codeph">c2 IS NULL</code> are subtracted, explaining why there are two <code class="codeph">MINUS</code> row sources in the plan. The <code class="codeph">NULL</code> subtraction is necessary for semantic correctness unless the column has a <code class="codeph">NOT NULL</code> constraint. The <code class="codeph">TO ROWIDS</code> option generates the rowids necessary for the table access.
                           </p>
                           <div class="infoboxnote" id="GUID-CE8BCA2D-47B5-4FBD-95A9-5096A5734063__GUID-50D3D7DD-EAFA-44D6-8508-2CEA4C0874B8">
                              <p class="notep1">Note:</p>
                              <p>Queries using bitmap join index indicate the bitmap join index access path. The operation for bitmap join index is the same as bitmap index. </p>
                           </div><pre class="pre codeblock"><code>EXPLAIN PLAN FOR  SELECT * 
  FROM   t
  WHERE  c1 = 2 
  AND    c2 &lt;&gt; 6 
  OR     c3 BETWEEN 10 AND 20;

SELECT STATEMENT
   TABLE ACCESS T BY INDEX ROWID
      BITMAP CONVERSION TO ROWID
         BITMAP OR
            BITMAP MINUS
               BITMAP MINUS
                  BITMAP INDEX C1_IND SINGLE VALUE
                  BITMAP INDEX C2_IND SINGLE VALUE
               BITMAP INDEX C2_IND SINGLE VALUE
            BITMAP MERGE
               BITMAP INDEX C3_IND RANGE SCAN
</code></pre></div>
                        <!-- class="example" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="generating-and-displaying-execution-plans.html#GUID-90411427-FDD7-4196-A52A-84D153CE37C1" title="These examples show different ways of displaying execution plans.">Display Execution Plans: Examples</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TGSQL94719"></a><div class="props_rev_3"><a id="GUID-FE0B82DA-1A06-4145-B03D-A1C39DB1F88F" name="GUID-FE0B82DA-1A06-4145-B03D-A1C39DB1F88F"></a><h5 id="TGSQL-GUID-FE0B82DA-1A06-4145-B03D-A1C39DB1F88F" class="sect5"><span class="enumeration_section">6.3.4.4 </span>Displaying Result Cache Plans: Example
                     </h5>
                     <div>
                        <p>When your query contains the <code class="codeph">result_cache</code> hint, the <code class="codeph">ResultCache</code> operator is inserted into the execution plan. 
                        </p>
                        <div class="section">
                           <p>For example, consider the following query:</p><pre class="pre codeblock"><code>SELECT /*+ result_cache */ deptno, avg(sal) 
FROM   emp 
GROUP BY deptno;
</code></pre><p>To view the <code class="codeph">EXPLAIN PLAN</code> for this query, use the following command:
                           </p><pre class="pre codeblock"><code>EXPLAIN PLAN FOR 
  SELECT /*+ result_cache */ deptno, avg(sal) 
  FROM emp 
  GROUP BY deptno;

SELECT PLAN_TABLE_OUTPUT FROM TABLE (DBMS_XPLAN.DISPLAY());
</code></pre><p>The <code class="codeph">EXPLAIN PLAN</code> output for this query should look similar to the following:
                           </p><pre class="pre codeblock"><code>--------------------------------------------------------------------------------
|Id| Operation          | Name                     |Rows|Bytes|Cost(%CPU)|Time |
--------------------------------------------------------------------------------
|0| SELECT STATEMENT    |                          | 11 | 77 | 4 (25)| 00:00:01|
|1|  RESULT CACHE       |b06ppfz9pxzstbttpbqyqnfbmy|    |    |       |         |
|2|   HASH GROUP BY     |                          | 11 | 77 | 4 (25)| 00:00:01|
|3|    TABLE ACCESS FULL| EMP                      |107 | 749| 3 (0) | 00:00:01|
--------------------------------------------------------------------------------
</code></pre><p>In this <code class="codeph">EXPLAIN PLAN</code>, the <code class="codeph">ResultCache</code> operator is identified by its <code class="codeph">CacheId</code>, which is <code class="codeph">b06ppfz9pxzstbttpbqyqnfbmy</code>. You can now run a query on the <code class="codeph">V$RESULT_CACHE_OBJECTS</code> view by using this <code class="codeph">CacheId</code>.
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="generating-and-displaying-execution-plans.html#GUID-90411427-FDD7-4196-A52A-84D153CE37C1" title="These examples show different ways of displaying execution plans.">Display Execution Plans: Examples</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TGSQL94720"></a><div class="props_rev_3"><a id="GUID-37DF6780-3279-47CE-93E6-BE922F1451EF" name="GUID-37DF6780-3279-47CE-93E6-BE922F1451EF"></a><h5 id="TGSQL-GUID-37DF6780-3279-47CE-93E6-BE922F1451EF" class="sect5"><span class="enumeration_section">6.3.4.5 </span>Displaying Plans for Partitioned Objects: Example
                     </h5>
                     <div>
                        <p>Use <code class="codeph">EXPLAIN PLAN</code> to determine how Oracle Database accesses partitioned objects for specific queries. 
                        </p>
                        <p>Partitions accessed after pruning are shown in the <code class="codeph">PARTITION START</code> and <code class="codeph">PARTITION STOP</code> columns. The row source name for the range partition is <code class="codeph">PARTITION RANGE</code>. For hash partitions, the row source name is <code class="codeph">PARTITION HASH</code>. 
                        </p>
                        <p>A join is implemented using partial partition-wise join if the <code class="codeph">DISTRIBUTION</code> column of the plan table of one of the joined tables contains <code class="codeph">PARTITION(KEY)</code>. Partial partition-wise join is possible if one of the joined tables is partitioned on its join column and the table is parallelized.
                        </p>
                        <p>A join is implemented using full partition-wise join if the partition row source appears before the join row source in the <code class="codeph">EXPLAIN PLAN</code> output. Full partition-wise joins are possible only if both joined tables are equipartitioned on their respective join columns. Examples of execution plans for several types of partitioning follow.
                        </p>
                        <p>This section contains the following topics:</p>
                     </div>
                     <div>
                        <ul class="ullinks">
                           <li class="ulchildlink"><a href="generating-and-displaying-execution-plans.html#GUID-CFF5285C-DC64-4687-A3D3-B76C28DF8C01">Displaying Range and Hash Partitioning with EXPLAIN PLAN: Examples</a><br>This example illustrates pruning by using the <code class="codeph">emp_range</code> table, which partitioned by range on <code class="codeph">hire_date</code>.
                           </li>
                           <li class="ulchildlink"><a href="generating-and-displaying-execution-plans.html#GUID-60AB9A81-49C2-4033-A692-A9766A065A60">Pruning Information with Composite Partitioned Objects: Examples</a><br>To illustrate how Oracle Database displays pruning information for composite partitioned objects, consider the table <code class="codeph">emp_comp</code>. It is range-partitioned on <code class="codeph">hiredate</code> and subpartitioned by hash on <code class="codeph">deptno</code>. 
                           </li>
                           <li class="ulchildlink"><a href="generating-and-displaying-execution-plans.html#GUID-2D33B318-5E73-4D68-BCAE-FCB905B8490A">Examples of Partial Partition-Wise Joins</a><br>In these examples, the <code class="codeph">PQ_DISTRIBUTE</code> hint explicitly forces a partial partition-wise join because the query optimizer could have chosen a different plan based on cost in this query.
                           </li>
                           <li class="ulchildlink"><a href="generating-and-displaying-execution-plans.html#GUID-C2D553C9-FDCF-4C0F-9CF8-112A7B5C7E5A">Example of Full Partition-Wise Join</a><br>In this example, <code class="codeph">emp_comp</code> and <code class="codeph">dept_hash</code> are joined on their hash partitioning columns, enabling use of a full partition-wise join. 
                           </li>
                           <li class="ulchildlink"><a href="generating-and-displaying-execution-plans.html#GUID-B1401051-FDEF-483A-B769-0C28143FBD8F">Examples of INLIST ITERATOR and EXPLAIN PLAN</a><br>An <code class="codeph">INLIST ITERATOR</code> operation appears in the <code class="codeph">EXPLAIN PLAN</code> output if an index implements an <code class="codeph">IN</code>-list predicate. 
                           </li>
                           <li class="ulchildlink"><a href="generating-and-displaying-execution-plans.html#GUID-E200BFF9-2C2D-411A-8134-4AEF177E2F1A">Example of Domain Indexes and EXPLAIN PLAN</a><br>You can use <code class="codeph">EXPLAIN PLAN</code> to derive user-defined CPU and I/O costs for domain indexes.
                           </li>
                        </ul>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="generating-and-displaying-execution-plans.html#GUID-90411427-FDD7-4196-A52A-84D153CE37C1" title="These examples show different ways of displaying execution plans.">Display Execution Plans: Examples</a></p>
                           </div>
                        </div>
                     </div>
                     <a id="TGSQL94721"></a><div class="props_rev_3"><a id="GUID-CFF5285C-DC64-4687-A3D3-B76C28DF8C01" name="GUID-CFF5285C-DC64-4687-A3D3-B76C28DF8C01"></a><h6 id="TGSQL-GUID-CFF5285C-DC64-4687-A3D3-B76C28DF8C01" class="sect6"><span class="enumeration_section">6.3.4.5.1 </span>Displaying Range and Hash Partitioning with EXPLAIN PLAN: Examples
                        </h6>
                        <div>
                           <p>This example illustrates pruning by using the <code class="codeph">emp_range</code> table, which partitioned by range on <code class="codeph">hire_date</code>.
                           </p>
                           <div class="section">
                              <p>Assume that the tables <code class="codeph">employees</code> and <code class="codeph">departments</code> from the Oracle Database sample schema exist.
                              </p><pre class="pre codeblock"><code>CREATE TABLE emp_range 
PARTITION BY RANGE(hire_date) 
( 
  PARTITION emp_p1 VALUES LESS THAN (TO_DATE('1-JAN-1992','DD-MON-YYYY')),
  PARTITION emp_p2 VALUES LESS THAN (TO_DATE('1-JAN-1994','DD-MON-YYYY')),
  PARTITION emp_p3 VALUES LESS THAN (TO_DATE('1-JAN-1996','DD-MON-YYYY')),
  PARTITION emp_p4 VALUES LESS THAN (TO_DATE('1-JAN-1998','DD-MON-YYYY')),
  PARTITION emp_p5 VALUES LESS THAN (TO_DATE('1-JAN-2001','DD-MON-YYYY')) 
) 
AS SELECT * FROM employees; 
</code></pre><p>For the first example, consider the following statement:</p><pre class="pre codeblock"><code>EXPLAIN PLAN FOR 
  SELECT * FROM emp_range; 
</code></pre><p>Oracle Database displays something similar to the following: </p><pre class="pre codeblock"><code>--------------------------------------------------------------------
|Id| Operation           | Name      |Rows| Bytes|Cost|Pstart|Pstop|
--------------------------------------------------------------------
| 0| SELECT STATEMENT    |           |  105| 13965 | 2 |   |       |
| 1|  PARTITION RANGE ALL|           |  105| 13965 | 2 | 1 |     5 |
| 2|   TABLE ACCESS FULL | EMP_RANGE |  105| 13965 | 2 | 1 |     5 |
--------------------------------------------------------------------
</code></pre><p>The database creates a partition row source on top of the table access row source. It iterates over the set of partitions to be accessed. In this example, the partition iterator covers all partitions (option <code class="codeph">ALL</code>), because a predicate was not used for pruning. The <code class="codeph">PARTITION_START</code> and <code class="codeph">PARTITION_STOP</code> columns of the <code class="codeph">PLAN_TABLE</code> show access to all partitions from 1 to 5.
                              </p>
                              <p>For the next example, consider the following statement:</p><pre class="pre codeblock"><code>EXPLAIN PLAN FOR 
  SELECT * 
  FROM   emp_range 
  WHERE  hire_date &gt;= TO_DATE('1-JAN-1996','DD-MON-YYYY');

-----------------------------------------------------------------------
| Id | Operation                | Name   |Rows|Bytes|Cost|Pstart|Pstop|
-----------------------------------------------------------------------
|  0 | SELECT STATEMENT         |         | 3 | 399 |   2 |     |     |
|  1 |  PARTITION RANGE ITERATOR|         | 3 | 399 |   2 |   4 |   5 |
| *2 |   TABLE ACCESS FULL      |EMP_RANGE| 3 | 399 |   2 |   4 |   5 |
-----------------------------------------------------------------------
</code></pre><p>In the previous example, the partition row source iterates from partition 4 to 5 because the database prunes the other partitions using a predicate on <code class="codeph">hire_date</code>. 
                              </p>
                              <p>Finally, consider the following statement:</p><pre class="pre codeblock"><code>EXPLAIN PLAN FOR 
  SELECT *
  FROM   emp_range
  WHERE  hire_date &lt; TO_DATE('1-JAN-1992','DD-MON-YYYY'); 

-----------------------------------------------------------------------
| Id  | Operation            | Name      |Rows|Bytes|Cost|Pstart|Pstop|
-----------------------------------------------------------------------
|   0 | SELECT STATEMENT       |           |    1 |   133 | 2 |   |   |
|   1 |  PARTITION RANGE SINGLE|           |    1 |   133 | 2 | 1 | 1 |
|*  2 |   TABLE ACCESS FULL    | EMP_RANGE |    1 |   133 | 2 | 1 | 1 |
-----------------------------------------------------------------------
</code></pre><p>In the previous example, only partition 1 is accessed and known at compile time; thus, there is no need for a partition row source. </p>
                              <div class="infoboxnote" id="GUID-CFF5285C-DC64-4687-A3D3-B76C28DF8C01__GUID-201DA968-4EF0-471D-85AC-28E3E1667F3C">
                                 <p class="notep1">Note:</p>
                                 <p>Oracle Database displays the same information for hash partitioned objects, except the partition row source name is <code class="codeph">PARTITION HASH</code> instead of <code class="codeph">PARTITION RANGE</code>. Also, with hash partitioning, pruning is only possible using equality or <code class="codeph">IN</code>-list predicates. 
                                 </p>
                              </div>
                           </div>
                           <!-- class="section" -->
                        </div>
                        <div>
                           <div class="familylinks">
                              <div class="parentlink">
                                 <p><strong>Parent topic:</strong> <a href="generating-and-displaying-execution-plans.html#GUID-37DF6780-3279-47CE-93E6-BE922F1451EF" title="Use EXPLAIN PLAN to determine how Oracle Database accesses partitioned objects for specific queries.">Displaying Plans for Partitioned Objects: Example</a></p>
                              </div>
                           </div>
                        </div>
                        
                     </div><a id="TGSQL94723"></a><div class="props_rev_3"><a id="GUID-60AB9A81-49C2-4033-A692-A9766A065A60" name="GUID-60AB9A81-49C2-4033-A692-A9766A065A60"></a><h6 id="TGSQL-GUID-60AB9A81-49C2-4033-A692-A9766A065A60" class="sect6"><span class="enumeration_section">6.3.4.5.2 </span>Pruning Information with Composite Partitioned Objects: Examples
                        </h6>
                        <div>
                           <p>To illustrate how Oracle Database displays pruning information for composite partitioned objects, consider the table <code class="codeph">emp_comp</code>. It is range-partitioned on <code class="codeph">hiredate</code> and subpartitioned by hash on <code class="codeph">deptno</code>. 
                           </p>
                           <div class="section"><pre class="pre codeblock"><code>CREATE TABLE emp_comp PARTITION BY RANGE(hire_date) 
      SUBPARTITION BY HASH(department_id) SUBPARTITIONS 3 
( 
PARTITION emp_p1 VALUES LESS THAN (TO_DATE('1-JAN-1992','DD-MON-YYYY')),
PARTITION emp_p2 VALUES LESS THAN (TO_DATE('1-JAN-1994','DD-MON-YYYY')),
PARTITION emp_p3 VALUES LESS THAN (TO_DATE('1-JAN-1996','DD-MON-YYYY')),
PARTITION emp_p4 VALUES LESS THAN (TO_DATE('1-JAN-1998','DD-MON-YYYY')),
PARTITION emp_p5 VALUES LESS THAN (TO_DATE('1-JAN-2001','DD-MON-YYYY')) 
) 
AS SELECT * FROM employees; 
</code></pre><p>For the first example, consider the following statement:</p><pre class="pre codeblock"><code>EXPLAIN PLAN FOR 
  SELECT * FROM emp_comp; 

-----------------------------------------------------------------------
|Id| Operation           | Name     | Rows  | Bytes |Cost|Pstart|Pstop|
-----------------------------------------------------------------------
| 0| SELECT STATEMENT    |          | 10120 |  1314K| 78 |    |       |
| 1|  PARTITION RANGE ALL|          | 10120 |  1314K| 78 |  1 |     5 |
| 2|   PARTITION HASH ALL|          | 10120 |  1314K| 78 |  1 |     3 |
| 3|    TABLE ACCESS FULL| EMP_COMP | 10120 |  1314K| 78 |  1 |    15 |
-----------------------------------------------------------------------
</code></pre><p>This example shows the plan when Oracle Database accesses all subpartitions of all partitions of a composite object. The database uses two partition row sources for this purpose: a range partition row source to iterate over the partitions, and a hash partition row source to iterate over the subpartitions of each accessed partition. </p>
                              <p>In the following example, the range partition row source iterates from partition 1 to 5, because the database performs no pruning. Within each partition, the hash partition row source iterates over subpartitions 1 to 3 of the current partition. As a result, the table access row source accesses subpartitions 1 to 15. In other words, the database accesses all subpartitions of the composite object.</p><pre class="pre codeblock"><code>EXPLAIN PLAN FOR 
  SELECT * 
  FROM   emp_comp 
  WHERE  hire_date = TO_DATE('15-FEB-1998', 'DD-MON-YYYY'); 

-----------------------------------------------------------------------
| Id | Operation              | Name    |Rows|Bytes |Cost|Pstart|Pstop|
-----------------------------------------------------------------------
|  0 | SELECT STATEMENT       |          | 20 | 2660 | 17 |     |     |
|  1 |  PARTITION RANGE SINGLE|          | 20 | 2660 | 17 |   5 |   5 |
|  2 |   PARTITION HASH ALL   |          | 20 | 2660 | 17 |   1 |   3 |
|* 3 |    TABLE ACCESS FULL   | EMP_COMP | 20 | 2660 | 17 |  13 |  15 |
-----------------------------------------------------------------------
</code></pre><p>In the previous example, only the last partition, partition 5, is accessed. This partition is known at compile time, so the database does not need to show it in the plan. The hash partition row source shows accessing of all subpartitions within that partition; that is, subpartitions 1 to 3, which translates into subpartitions 13 to 15 of the <code class="codeph">emp_comp</code> table. 
                              </p>
                              <p>Now consider the following statement:</p><pre class="pre codeblock"><code>EXPLAIN PLAN FOR 
  SELECT * 
  FROM   emp_comp 
  WHERE  department_id = 20; 

------------------------------------------------------------------------
| Id | Operation              |Name    |Rows | Bytes |Cost|Pstart|Pstop|
------------------------------------------------------------------------
|  0 | SELECT STATEMENT       |          | 101 | 13433 | 78 |    |     |
|  1 |  PARTITION RANGE ALL   |          | 101 | 13433 | 78 |  1 |   5 |
|  2 |   PARTITION HASH SINGLE|          | 101 | 13433 | 78 |  3 |   3 |
|* 3 |    TABLE ACCESS FULL   | EMP_COMP | 101 | 13433 | 78 |    |     |
------------------------------------------------------------------------
</code></pre><p>In the previous example, the predicate <code class="codeph">deptno=20</code> enables pruning on the hash dimension within each partition. Therefore, Oracle Database only needs to access a single subpartition. The number of this subpartition is known at compile time, so the hash partition row source is not needed. 
                              </p>
                              <p>Finally, consider the following statement:</p><pre class="pre codeblock"><code>VARIABLE dno NUMBER; 
EXPLAIN PLAN FOR 
  SELECT * 
  FROM   emp_comp 
  WHERE  department_id = :dno; 

-----------------------------------------------------------------------
| Id| Operation              | Name    |Rows| Bytes |Cost|Pstart|Pstop|
-----------------------------------------------------------------------
| 0 | SELECT STATEMENT       |          | 101| 13433 | 78 |     |     |
| 1 |  PARTITION RANGE ALL   |          | 101| 13433 | 78 |   1 |   5 |
| 2 |   PARTITION HASH SINGLE|          | 101| 13433 | 78 | KEY | KEY |
|*3 |    TABLE ACCESS FULL   | EMP_COMP | 101| 13433 | 78 |     |     |
-----------------------------------------------------------------------
</code></pre><p>The last two examples are the same, except that <code class="codeph">department_id</code> = :<code class="codeph">dno</code> replaces <code class="codeph">deptno=20</code>. In this last case, the subpartition number is unknown at compile time, and a hash partition row source is allocated. The option is <code class="codeph">SINGLE</code> for this row source because Oracle Database accesses only one subpartition within each partition. In Step 2, both <code class="codeph">PARTITION</code>_<code class="codeph">START</code> and <code class="codeph">PARTITION</code>_<code class="codeph">STOP</code> are set to <code class="codeph">KEY</code>. This value means that Oracle Database determines the number of subpartitions at run time. 
                              </p>
                           </div>
                           <!-- class="section" -->
                        </div>
                        <div>
                           <div class="familylinks">
                              <div class="parentlink">
                                 <p><strong>Parent topic:</strong> <a href="generating-and-displaying-execution-plans.html#GUID-37DF6780-3279-47CE-93E6-BE922F1451EF" title="Use EXPLAIN PLAN to determine how Oracle Database accesses partitioned objects for specific queries.">Displaying Plans for Partitioned Objects: Example</a></p>
                              </div>
                           </div>
                        </div>
                        
                     </div><a id="TGSQL94725"></a><a id="TGSQL94726"></a><a id="TGSQL94724"></a><div class="props_rev_3"><a id="GUID-2D33B318-5E73-4D68-BCAE-FCB905B8490A" name="GUID-2D33B318-5E73-4D68-BCAE-FCB905B8490A"></a><h6 id="TGSQL-GUID-2D33B318-5E73-4D68-BCAE-FCB905B8490A" class="sect6"><span class="enumeration_section">6.3.4.5.3 </span>Examples of Partial Partition-Wise Joins
                        </h6>
                        <div>
                           <p>In these examples, the <code class="codeph">PQ_DISTRIBUTE</code> hint explicitly forces a partial partition-wise join because the query optimizer could have chosen a different plan based on cost in this query.
                           </p>
                           <div class="example" id="GUID-2D33B318-5E73-4D68-BCAE-FCB905B8490A__CEGBBAEA">
                              <p class="titleinexample">Example 6-6 Partial Partition-Wise Join with Range Partition</p>In the following example, the database joins <code class="codeph">emp_range_did</code> on the partitioning column <code class="codeph">department_id</code> and parallelizes it. The database can use a partial partition-wise join because the <code class="codeph">dept2</code> table is not partitioned. Oracle Database dynamically partitions the <code class="codeph">dept2</code> table before the join.<pre class="pre codeblock"><code>CREATE TABLE dept2 AS SELECT * FROM departments;
ALTER TABLE dept2 PARALLEL 2;

CREATE TABLE emp_range_did PARTITION BY RANGE(department_id)
   (PARTITION emp_p1 VALUES LESS THAN (150),
    PARTITION emp_p5 VALUES LESS THAN (MAXVALUE) )
  AS SELECT * FROM employees;

ALTER TABLE emp_range_did PARALLEL 2;

EXPLAIN PLAN FOR 
  SELECT /*+ PQ_DISTRIBUTE(d NONE PARTITION) ORDERED */ e.last_name, 
         d.department_name 
  FROM   emp_range_did e, dept2 d 
  WHERE  e.department_id = d.department_id;

------------------------------------------------------------------------------------------------
|Id| Operation                    |Name        |Row|Byte|Cost|Pstart|Pstop|TQ|IN-OUT|PQ Distrib|
------------------------------------------------------------------------------------------------
| 0| SELECT STATEMENT             |             |284 |16188|6 |   |   |       |     |          | 
| 1|  PX COORDINATOR              |             |    |     |  |   |   |       |     |          |
| 2|   PX SEND QC (RANDOM)        |:TQ10001     |284 |16188|6 |   |   | Q1,01 |P-&gt;S |QC (RAND) |
|*3|    HASH JOIN                 |             |284 |16188|6 |   |   | Q1,01 |PCWP |          |
| 4|     PX PARTITION RANGE ALL   |             |284 |7668 |2 | 1 | 2 | Q1,01 |PCWC |          |
| 5|      TABLE ACCESS FULL       |EMP_RANGE_DID|284 |7668 |2 | 1 | 2 | Q1,01 |PCWP |          |
| 6|     BUFFER SORT              |             |    |     |  |   |   | Q1,01 |PCWC |          |
| 7|      PX RECEIVE              |             | 21 | 630 |2 |   |   | Q1,01 |PCWP |          |
| 8|       PX SEND PARTITION (KEY)|:TQ10000     | 21 | 630 |2 |   |   |       |S-&gt;P |PART (KEY)|
| 9|        TABLE ACCESS FULL     |DEPT2        | 21 | 630 |2 |   |   |       |     |          |
------------------------------------------------------------------------------------------------
</code></pre><p>The execution plan shows that the table <code class="codeph">dept2</code> is scanned serially and all rows with the same partitioning column value of <code class="codeph">emp_range_did (department_id)</code> are sent through a <code class="codeph">PART (KEY)</code>, or partition key, table queue to the same parallel execution server doing the partial partition-wise join. 
                              </p>
                           </div>
                           <!-- class="example" -->
                           <div class="example" id="GUID-2D33B318-5E73-4D68-BCAE-FCB905B8490A__CEGFCDHA">
                              <p class="titleinexample">Example 6-7 Partial Partition-Wise Join with Composite Partition</p>
                              <p>In the following example, <code class="codeph">emp_comp</code> is joined on the partitioning column and is parallelized, enabling use of a partial partition-wise join because <code class="codeph">dept2</code> is not partitioned. The database dynamically partitions <code class="codeph">dept2</code> before the join.
                              </p><pre class="pre codeblock"><code>ALTER TABLE emp_comp PARALLEL 2; 

EXPLAIN PLAN FOR 
  SELECT /*+ PQ_DISTRIBUTE(d NONE PARTITION) ORDERED */ e.last_name, 
         d.department_name 
  FROM   emp_comp e, dept2 d 
  WHERE  e.department_id = d.department_id;

SELECT PLAN_TABLE_OUTPUT FROM TABLE(DBMS_XPLAN.DISPLAY());

------------------------------------------------------------------------------------------------
| Id| Operation                   | Name  |Rows |Bytes |Cost|Pstart|Pstop|TQ |IN-OUT|PQ Distrib|
------------------------------------------------------------------------------------------------
| 0 | SELECT STATEMENT            |        | 445 | 17800 | 5 |   |   |       |      |          |
| 1 |  PX COORDINATOR             |        |     |       |   |   |   |       |      |          |
| 2 |   PX SEND QC (RANDOM)       |:TQ10001| 445 | 17800 | 5 |   |   | Q1,01 | P-&gt;S | QC (RAND)|
|*3 |    HASH JOIN                |        | 445 | 17800 | 5 |   |   | Q1,01 | PCWP |          |
| 4 |     PX PARTITION RANGE ALL  |        | 107 |  1070 | 3 | 1 | 5 | Q1,01 | PCWC |          |
| 5 |      PX PARTITION HASH ALL  |        | 107 |  1070 | 3 | 1 | 3 | Q1,01 | PCWC |          |
| 6 |       TABLE ACCESS FULL     |EMP_COMP| 107 |  1070 | 3 | 1 | 15| Q1,01 | PCWP |          |
| 7 |     PX RECEIVE              |        |  21 |   630 | 1 |   |   | Q1,01 | PCWP |          |
| 8 |      PX SEND PARTITION (KEY)|:TQ10000|  21 |   630 | 1 |   |   | Q1,00 | P-&gt;P |PART (KEY)|
| 9 |       PX BLOCK ITERATOR     |        |  21 |   630 | 1 |   |   | Q1,00 | PCWC |          |
|10 |        TABLE ACCESS FULL    |DEPT2   |  21 |   630 | 1 |   |   | Q1,00 | PCWP |          |
------------------------------------------------------------------------------------------------
</code></pre><p>The plan shows that the optimizer selects partial partition-wise join from one of two columns. The <code class="codeph">PX SEND</code> node type is <code class="codeph">PARTITION (KEY)</code> and the <code class="codeph">PQ Distrib</code> column contains the text <code class="codeph">PART (KEY)</code>, or partition key. This implies that the table <code class="codeph">dept2</code> is re-partitioned based on the join column <code class="codeph">department_id</code> to be sent to the parallel execution servers executing the scan of <code class="codeph">EMP_COMP</code> and the join.
                              </p>
                           </div>
                           <!-- class="example" -->
                        </div>
                        <div>
                           <div class="familylinks">
                              <div class="parentlink">
                                 <p><strong>Parent topic:</strong> <a href="generating-and-displaying-execution-plans.html#GUID-37DF6780-3279-47CE-93E6-BE922F1451EF" title="Use EXPLAIN PLAN to determine how Oracle Database accesses partitioned objects for specific queries.">Displaying Plans for Partitioned Objects: Example</a></p>
                              </div>
                           </div>
                        </div>
                        
                     </div><a id="TGSQL94728"></a><a id="TGSQL94727"></a><div class="props_rev_3"><a id="GUID-C2D553C9-FDCF-4C0F-9CF8-112A7B5C7E5A" name="GUID-C2D553C9-FDCF-4C0F-9CF8-112A7B5C7E5A"></a><h6 id="TGSQL-GUID-C2D553C9-FDCF-4C0F-9CF8-112A7B5C7E5A" class="sect6"><span class="enumeration_section">6.3.4.5.4 </span>Example of Full Partition-Wise Join
                        </h6>
                        <div>
                           <p>In this example, <code class="codeph">emp_comp</code> and <code class="codeph">dept_hash</code> are joined on their hash partitioning columns, enabling use of a full partition-wise join. 
                           </p>
                           <div class="section">
                              <p>The <code class="codeph">PARTITION HASH</code> row source appears on top of the join row source in the plan table output. 
                              </p><pre class="pre codeblock"><code>CREATE TABLE dept_hash
   PARTITION BY HASH(department_id)
   PARTITIONS 3
   PARALLEL 2
   AS SELECT * FROM departments;

EXPLAIN PLAN FOR 
  SELECT /*+ PQ_DISTRIBUTE(e NONE NONE) ORDERED */ e.last_name,
         d.department_name
  FROM   emp_comp e, dept_hash d
  WHERE  e.department_id = d.department_id;

------------------------------------------------------------------------------------------------
|Id| Operation                  | Name      |Rows|Bytes|Cost|Pstart|Pstop|TQ |IN-OUT|PQ Distrib|
------------------------------------------------------------------------------------------------
| 0| SELECT STATEMENT           |           | 106 | 2544 | 8 |   |    |       |      |         |
| 1|  PX COORDINATOR            |           |     |      |   |   |    |       |      |         |
| 2|   PX SEND QC (RANDOM)      | :TQ10000  | 106 | 2544 | 8 |   |    | Q1,00 | P-&gt;S |QC (RAND)|
| 3|    PX PARTITION HASH ALL   |           | 106 | 2544 | 8 | 1 |  3 | Q1,00 | PCWC |         |
|*4|     HASH JOIN              |           | 106 | 2544 | 8 |   |    | Q1,00 | PCWP |         |
| 5|      PX PARTITION RANGE ALL|           | 107 | 1070 | 3 | 1 |  5 | Q1,00 | PCWC |         |
| 6|       TABLE ACCESS FULL    | EMP_COMP  | 107 | 1070 | 3 | 1 | 15 | Q1,00 | PCWP |         |
| 7|      TABLE ACCESS FULL     | DEPT_HASH |  27 |  378 | 4 | 1 |  3 | Q1,00 | PCWP |         |
------------------------------------------------------------------------------------------------</code></pre><p>The <code class="codeph">PX PARTITION HASH</code> row source appears on top of the join row source in the plan table output while the <code class="codeph">PX PARTITION RANGE</code> row source appears over the scan of <code class="codeph">emp_comp</code>. Each parallel execution server performs the join of an entire hash partition of <code class="codeph">emp_comp</code> with an entire partition of <code class="codeph">dept_hash</code>.
                              </p>
                           </div>
                           <!-- class="section" -->
                        </div>
                        <div>
                           <div class="familylinks">
                              <div class="parentlink">
                                 <p><strong>Parent topic:</strong> <a href="generating-and-displaying-execution-plans.html#GUID-37DF6780-3279-47CE-93E6-BE922F1451EF" title="Use EXPLAIN PLAN to determine how Oracle Database accesses partitioned objects for specific queries.">Displaying Plans for Partitioned Objects: Example</a></p>
                              </div>
                           </div>
                        </div>
                        
                     </div><a id="TGSQL94729"></a><div class="props_rev_3"><a id="GUID-B1401051-FDEF-483A-B769-0C28143FBD8F" name="GUID-B1401051-FDEF-483A-B769-0C28143FBD8F"></a><h6 id="TGSQL-GUID-B1401051-FDEF-483A-B769-0C28143FBD8F" class="sect6"><span class="enumeration_section">6.3.4.5.5 </span>Examples of INLIST ITERATOR and EXPLAIN PLAN
                        </h6>
                        <div>
                           <p>An <code class="codeph">INLIST ITERATOR</code> operation appears in the <code class="codeph">EXPLAIN PLAN</code> output if an index implements an <code class="codeph">IN</code>-list predicate. 
                           </p>
                           <div class="section">
                              <p>Consider the following statement:</p><pre class="pre codeblock"><code>SELECT * FROM emp WHERE empno IN (7876, 7900, 7902);
</code></pre><p>The <code class="codeph">EXPLAIN PLAN</code> output appears as follows:
                              </p><pre class="pre codeblock"><code>OPERATION          OPTIONS           OBJECT_NAME
----------------   ---------------   -------------- 
SELECT STATEMENT
INLIST ITERATOR
TABLE ACCESS       BY ROWID          EMP
INDEX              RANGE SCAN        EMP_EMPNO
</code></pre><p>The <code class="codeph">INLIST ITERATOR</code> operation iterates over the next operation in the plan for each value in the <code class="codeph">IN</code>-list predicate. The following sections describe the three possible types of <code class="codeph">IN</code>-list columns for partitioned tables and indexes.
                              </p>
                              <p>This section contains the following topics:</p>
                           </div>
                           <!-- class="section" -->
                        </div>
                        <div>
                           <ul class="ullinks">
                              <li class="ulchildlink"><a href="generating-and-displaying-execution-plans.html#GUID-4B04B5D8-9948-40A4-A769-632AB1770749">When the IN-List Column is an Index Column: Example</a><br>If the <code class="codeph">IN</code>-list column <code class="codeph">empno</code> is an index column but not a partition column, then the <code class="codeph">IN</code>-list operator appears before the table operation but after the partition operation in the plan.
                              </li>
                              <li class="ulchildlink"><a href="generating-and-displaying-execution-plans.html#GUID-C5AEB7F0-CAEE-49D2-A363-DED45A7C7D7C">When the IN-List Column is an Index and a Partition Column: Example</a><br>If <code class="codeph">empno</code> is an indexed and a partition column, then the plan contains an <code class="codeph">INLIST ITERATOR</code> operation before the partition operation.
                              </li>
                              <li class="ulchildlink"><a href="generating-and-displaying-execution-plans.html#GUID-9CBA5FC7-33C5-4CAF-963F-02BDF5918B70">When the IN-List Column is a Partition Column: Example</a><br>If <code class="codeph">empno</code> is a partition column and no indexes exist, then no <code class="codeph">INLIST ITERATOR</code> operation is allocated.
                              </li>
                           </ul>
                           <div class="familylinks">
                              <div class="parentlink">
                                 <p><strong>Parent topic:</strong> <a href="generating-and-displaying-execution-plans.html#GUID-37DF6780-3279-47CE-93E6-BE922F1451EF" title="Use EXPLAIN PLAN to determine how Oracle Database accesses partitioned objects for specific queries.">Displaying Plans for Partitioned Objects: Example</a></p>
                              </div>
                           </div>
                        </div>
                        <a id="TGSQL94730"></a><div class="props_rev_3"><a id="GUID-4B04B5D8-9948-40A4-A769-632AB1770749" name="GUID-4B04B5D8-9948-40A4-A769-632AB1770749"></a><h6 id="TGSQL-GUID-4B04B5D8-9948-40A4-A769-632AB1770749" class="sect6"><span class="enumeration_section">6.3.4.5.5.1 </span>When the IN-List Column is an Index Column: Example
                           </h6>
                           <div>
                              <p>If the <code class="codeph">IN</code>-list column <code class="codeph">empno</code> is an index column but not a partition column, then the <code class="codeph">IN</code>-list operator appears before the table operation but after the partition operation in the plan.
                              </p>
                              <div class="section"><pre class="pre codeblock"><code>OPERATION        OPTIONS              OBJECT_NAME PARTIT_START PARTITION_STOP
---------------- ------------         ----------- ------------ -------------- 
SELECT STATEMENT 
PARTITION RANGE  ALL                               KEY(INLIST)     KEY(INLIST)
INLIST ITERATOR
TABLE ACCESS     BY LOCAL INDEX ROWID EMP          KEY(INLIST)     KEY(INLIST)
INDEX            RANGE SCAN           EMP_EMPNO    KEY(INLIST)     KEY(INLIST)
</code></pre><p>The <code class="codeph">KEY(INLIST)</code> designation for the partition start and stop keys specifies that an <code class="codeph">IN</code>-list predicate appears on the index start and stop keys.
                                 </p>
                              </div>
                              <!-- class="section" -->
                           </div>
                           <div>
                              <div class="familylinks">
                                 <div class="parentlink">
                                    <p><strong>Parent topic:</strong> <a href="generating-and-displaying-execution-plans.html#GUID-B1401051-FDEF-483A-B769-0C28143FBD8F" title="An INLIST ITERATOR operation appears in the EXPLAIN PLAN output if an index implements an IN-list predicate.">Examples of INLIST ITERATOR and EXPLAIN PLAN</a></p>
                                 </div>
                              </div>
                           </div>
                           
                        </div><a id="TGSQL94731"></a><div class="props_rev_3"><a id="GUID-C5AEB7F0-CAEE-49D2-A363-DED45A7C7D7C" name="GUID-C5AEB7F0-CAEE-49D2-A363-DED45A7C7D7C"></a><h6 id="TGSQL-GUID-C5AEB7F0-CAEE-49D2-A363-DED45A7C7D7C" class="sect6"><span class="enumeration_section">6.3.4.5.5.2 </span>When the IN-List Column is an Index and a Partition Column: Example
                           </h6>
                           <div>
                              <p>If <code class="codeph">empno</code> is an indexed and a partition column, then the plan contains an <code class="codeph">INLIST ITERATOR</code> operation before the partition operation.
                              </p>
                              <div class="section"><pre class="pre codeblock"><code>OPERATION        OPTIONS              OBJECT_NAME PARTITION_START PARTITION_STOP
---------------- ------------         ----------- --------------- --------------
SELECT STATEMENT
INLIST ITERATOR
PARTITION RANGE  ITERATOR                         KEY(INLIST)     KEY(INLIST)
TABLE ACCESS     BY LOCAL INDEX ROWID EMP         KEY(INLIST)     KEY(INLIST)
INDEX            RANGE SCAN           EMP_EMPNO   KEY(INLIST)     KEY(INLIST)</code></pre></div>
                              <!-- class="section" -->
                           </div>
                           <div>
                              <div class="familylinks">
                                 <div class="parentlink">
                                    <p><strong>Parent topic:</strong> <a href="generating-and-displaying-execution-plans.html#GUID-B1401051-FDEF-483A-B769-0C28143FBD8F" title="An INLIST ITERATOR operation appears in the EXPLAIN PLAN output if an index implements an IN-list predicate.">Examples of INLIST ITERATOR and EXPLAIN PLAN</a></p>
                                 </div>
                              </div>
                           </div>
                           
                        </div><a id="TGSQL94732"></a><div class="props_rev_3"><a id="GUID-9CBA5FC7-33C5-4CAF-963F-02BDF5918B70" name="GUID-9CBA5FC7-33C5-4CAF-963F-02BDF5918B70"></a><h6 id="TGSQL-GUID-9CBA5FC7-33C5-4CAF-963F-02BDF5918B70" class="sect6"><span class="enumeration_section">6.3.4.5.5.3 </span>When the IN-List Column is a Partition Column: Example
                           </h6>
                           <div>
                              <p>If <code class="codeph">empno</code> is a partition column and no indexes exist, then no <code class="codeph">INLIST ITERATOR</code> operation is allocated.
                              </p>
                              <div class="section"><pre class="pre codeblock"><code>OPERATION         OPTIONS        OBJECT_NAME   PARTITION_START   PARTITION_STOP
----------------  ------------   -----------   ---------------   --------------
SELECT STATEMENT
PARTITION RANGE   INLIST                       KEY(INLIST)       KEY(INLIST)
TABLE ACCESS      FULL           EMP           KEY(INLIST)       KEY(INLIST)
</code></pre><p>If <code class="codeph">emp_empno</code> is a bitmap index, then the plan is as follows:
                                 </p><pre class="pre codeblock"><code>OPERATION          OPTIONS           OBJECT_NAME
----------------   ---------------   -------------- 
SELECT STATEMENT
INLIST ITERATOR
TABLE ACCESS       BY INDEX ROWID    EMP
BITMAP CONVERSION  TO ROWIDS
BITMAP INDEX       SINGLE VALUE      EMP_EMPNO</code></pre></div>
                              <!-- class="section" -->
                           </div>
                           <div>
                              <div class="familylinks">
                                 <div class="parentlink">
                                    <p><strong>Parent topic:</strong> <a href="generating-and-displaying-execution-plans.html#GUID-B1401051-FDEF-483A-B769-0C28143FBD8F" title="An INLIST ITERATOR operation appears in the EXPLAIN PLAN output if an index implements an IN-list predicate.">Examples of INLIST ITERATOR and EXPLAIN PLAN</a></p>
                                 </div>
                              </div>
                           </div>
                           
                        </div>
                     </div><a id="TGSQL94733"></a><div class="props_rev_3"><a id="GUID-E200BFF9-2C2D-411A-8134-4AEF177E2F1A" name="GUID-E200BFF9-2C2D-411A-8134-4AEF177E2F1A"></a><h6 id="TGSQL-GUID-E200BFF9-2C2D-411A-8134-4AEF177E2F1A" class="sect6"><span class="enumeration_section">6.3.4.5.6 </span>Example of Domain Indexes and EXPLAIN PLAN
                        </h6>
                        <div>
                           <p>You can use <code class="codeph">EXPLAIN PLAN</code> to derive user-defined CPU and I/O costs for domain indexes.
                           </p>
                           <div class="section">
                              <p><code class="codeph">EXPLAIN PLAN</code> displays domain index statistics in the <code class="codeph">OTHER</code> column of <code class="codeph">PLAN_TABLE</code>. For example, assume table <code class="codeph">emp</code> has user-defined operator <code class="codeph">CONTAINS</code> with a domain index <code class="codeph">emp_resume</code> on the <code class="codeph">resume</code> column, and the index type of <code class="codeph">emp_resume</code> supports the operator <code class="codeph">CONTAINS</code>. You explain the plan for the following query:
                              </p><pre class="pre codeblock"><code>SELECT * FROM emp WHERE CONTAINS(resume, 'Oracle') = 1 
</code></pre><p>The database could display the following plan:</p><pre class="pre codeblock"><code>OPERATION            OPTIONS      OBJECT_NAME     OTHER 
-----------------    -----------  ------------    ----------------
SELECT STATEMENT 
TABLE ACCESS         BY ROWID     EMP
DOMAIN INDEX                      EMP_RESUME      CPU: 300, I/O: 4</code></pre></div>
                           <!-- class="section" -->
                        </div>
                        <div>
                           <div class="familylinks">
                              <div class="parentlink">
                                 <p><strong>Parent topic:</strong> <a href="generating-and-displaying-execution-plans.html#GUID-37DF6780-3279-47CE-93E6-BE922F1451EF" title="Use EXPLAIN PLAN to determine how Oracle Database accesses partitioned objects for specific queries.">Displaying Plans for Partitioned Objects: Example</a></p>
                              </div>
                           </div>
                        </div>
                        
                     </div>
                  </div>
               </div>
            </div>
            <div class="sect2"><a id="GUID-0023D232-5695-4BA8-89C5-88672B7647E2" name="GUID-0023D232-5695-4BA8-89C5-88672B7647E2"></a><h3 id="TGSQL-GUID-0023D232-5695-4BA8-89C5-88672B7647E2" class="sect3"><span class="enumeration_section">6.4 </span>Comparing Execution Plans
               </h3>
               <div>
                  <p>The plan comparison tool takes a reference plan and an arbitrary list of test plans and highlights the differences between them. The plan comparison is logical rather than line by line.</p>
                  <p>This section contains the following topics:</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="generating-and-displaying-execution-plans.html#GUID-932E5852-46C8-47F8-8FD4-1B3C3936CA1D">Purpose of Plan Comparison</a><br>The plan comparison report identifies the source of differences, which helps users triage plan reproducibility issues.
                     </li>
                     <li class="ulchildlink"><a href="generating-and-displaying-execution-plans.html#GUID-74056529-E2A2-42CB-9230-4924C046260E">User Interface for Plan Comparison</a><br>You can use <code class="codeph">DBMS_XPLAN.COMPARE_PLANS</code> to generate a report in text, XML, or HTML format.
                     </li>
                     <li class="ulchildlink"><a href="generating-and-displaying-execution-plans.html#GUID-60FF7945-DFA3-4E97-89D0-B4F11543C680">Comparing Execution Plans: Tutorial</a><br>To compare plans, use the <code class="codeph">DBMS_XPLAN.COMPARE_PLANS</code> function.
                     </li>
                     <li class="ulchildlink"><a href="generating-and-displaying-execution-plans.html#GUID-7909832F-F81B-40CC-AB8A-7F52CA84F104">Comparing Execution Plans: Examples</a><br>These examples demonstrate how to generate compare plans reports for queries of tables in the <code class="codeph">sh</code> schema.
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="generating-and-displaying-execution-plans.html#GUID-60E30B1C-342B-4D71-B154-C26623D6A3B1" title="Knowledge of how to explain a statement and display its plan is essential to SQL tuning.">Explaining and Displaying Execution Plans</a></p>
                     </div>
                  </div>
               </div>
               
               <div class="sect3"><a id="GUID-932E5852-46C8-47F8-8FD4-1B3C3936CA1D" name="GUID-932E5852-46C8-47F8-8FD4-1B3C3936CA1D"></a><h4 id="TGSQL-GUID-932E5852-46C8-47F8-8FD4-1B3C3936CA1D" class="sect4"><span class="enumeration_section">6.4.1 </span>Purpose of Plan Comparison
                  </h4>
                  <div>
                     <p>The plan comparison report identifies the source of differences, which helps users triage plan reproducibility issues.</p>
                     <p>The plan comparison report is particularly useful in the following scenarios:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>You want to compare the current plan of a query whose performance is regressing with an old plan captured in AWR.</p>
                        </li>
                        <li>
                           <p>A SQL plan baseline fails to reproduce the originally intended plan, and you want to determine the difference between the new plan and the intended plan.</p>
                        </li>
                        <li>
                           <p>You want to determine how adding a hint, changing a parameter, or creating an index will affect a plan.</p>
                        </li>
                        <li>
                           <p>You want to determine how a plan generated based on a SQL profile or by SQL Performance Analyzer differs from the original plan.</p>
                        </li>
                     </ul>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="generating-and-displaying-execution-plans.html#GUID-0023D232-5695-4BA8-89C5-88672B7647E2" title="The plan comparison tool takes a reference plan and an arbitrary list of test plans and highlights the differences between them. The plan comparison is logical rather than line by line.">Comparing Execution Plans</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="sect3"><a id="GUID-74056529-E2A2-42CB-9230-4924C046260E" name="GUID-74056529-E2A2-42CB-9230-4924C046260E"></a><h4 id="TGSQL-GUID-74056529-E2A2-42CB-9230-4924C046260E" class="sect4"><span class="enumeration_section">6.4.2 </span>User Interface for Plan Comparison
                  </h4>
                  <div>
                     <p>You can use <code class="codeph">DBMS_XPLAN.COMPARE_PLANS</code> to generate a report in text, XML, or HTML format.
                     </p>
                     <div class="section">
                        <p class="subhead3" id="GUID-74056529-E2A2-42CB-9230-4924C046260E__GUID-C2784720-8E14-402C-8920-C5856342E9FD">Compare Plans Report Format</p>
                        <p>The report begins with a summary. The <code class="codeph">COMPARE PLANS REPORT</code> section includes information such as the user who ran the report and the number of plans compared, as shown in the following example:
                        </p><pre class="pre codeblock"><code>COMPARE PLANS REPORT
-------------------------------------------------------------------------
  Current user           : SH
  Total number of plans  : 2
  Number of findings     : 1
-------------------------------------------------------------------------</code></pre><p>The <code class="codeph">COMPARISON DETAILS</code> section of the report contains the following information:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Plan information</p>
                              <p>The information includes the plan number, the plan source, plan attributes (which differ depending on the source), parsing schema, and SQL text.</p>
                           </li>
                           <li>
                              <p>Plans</p>
                              <p>This section displays the plan rows, including the predicates and notes.</p>
                           </li>
                           <li>
                              <p>Comparison results</p>
                              <p>This section summarizes the comparison findings, highlighting logical differences such as join order, join methods, access paths, and parallel distribution method. The findings start at number <code class="codeph">1</code>. For findings that relate to a particular query block, the text starts with the name of the block. For findings that relate to a particular object alias, the text starts with the name of the query block and the object alias. The following 
                              </p><pre class="pre codeblock"><code>Comparison Results (1):
-----------------------------
 1. Query block SEL$1, Alias PRODUCTS@SEL$1: Some columns (OPERATION, OPTIONS,
    OBJECT_NAME) do not match between the reference plan (id: 2) and the
    current plan (id: 2).</code></pre></li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-74056529-E2A2-42CB-9230-4924C046260E__GUID-52888641-6CFC-4327-A387-39F18B4812B7">DBMS_XPLAN.PLAN_OBJECT_LIST Table Type</p>
                        <p>The <code class="codeph">plan_object_list</code> type allows for a list of generic objects as input to the <code class="codeph">DBMS_XPLAN.COMPARE_PLANS</code> function. The syntax is as follows:
                        </p><pre class="pre codeblock"><code>TYPE plan_object_list IS TABLE OF generic_plan_object;</code></pre><p>The generic object abstracts the common attributes of plans from all plan sources. Every plan source is a subclass of the <code class="codeph">plan_object_list</code> superclass. The following table summarizes the different plan sources. Note that when an optional parameter is null, it can correspond to multiple objects. For example, if you do not specify a child number for <code class="codeph">cursor_cache_object</code>, then it matches all cursor cache statements with the specified SQL ID.
                        </p>
                        <div class="tblformal" id="GUID-74056529-E2A2-42CB-9230-4924C046260E__GUID-DDFDDD63-3854-49FF-BCB7-82B41CC66B3E">
                           <p class="titleintable">Table 6-3 Plan Sources for PLAN_OBJECT_LIST</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="Plan Sources for PLAN_OBJECT_LIST" summary="This table describe the plan sources for the plan_object_list object." frame="hsides" border="1" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="20%" id="d21079e7423">Plan Source</th>
                                    <th align="left" valign="bottom" width="20%" id="d21079e7425">Specification</th>
                                    <th align="left" valign="bottom" width="20%" id="d21079e7427">Description</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d21079e7431" headers="d21079e7423 ">
                                       <p>Plan table</p>
                                    </td>
                                    <td align="left" valign="top" width="20%" headers="d21079e7431 d21079e7425 "><pre class="pre codeblock"><code>plan_table_object(owner, plan_table_name, statement_id, plan_id)</code></pre></td>
                                    <td align="left" valign="top" width="20%" headers="d21079e7431 d21079e7427 ">
                                       <p>The parameters are as follows:</p>
                                       <ul style="list-style-type: disc;">
                                          <li>
                                             <p><code class="codeph">owner</code>The owner of the plan table
                                             </p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">plan_table_name</code>The name of the plan table
                                             </p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">statement_id</code>The ID of the statement (optional)
                                             </p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">plan_id</code>The ID of the plan (optional)
                                             </p>
                                          </li>
                                       </ul>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d21079e7462" headers="d21079e7423 ">
                                       <p>Cursor cache</p>
                                    </td>
                                    <td align="left" valign="top" width="20%" headers="d21079e7462 d21079e7425 "><pre class="pre codeblock"><code>cursor_cache_object(sql_id, child_number)</code></pre></td>
                                    <td align="left" valign="top" width="20%" headers="d21079e7462 d21079e7427 ">
                                       <p>The parameters are as follows:</p>
                                       <ul style="list-style-type: disc;">
                                          <li>
                                             <p><code class="codeph">sql_id</code>The SQL ID of the plan
                                             </p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">child_number</code>The child number of the plan in the cursor cache (optional)
                                             </p>
                                          </li>
                                       </ul>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d21079e7483" headers="d21079e7423 ">
                                       <p>AWR</p>
                                    </td>
                                    <td align="left" valign="top" width="20%" headers="d21079e7483 d21079e7425 "><pre class="pre codeblock"><code>awr_object(sql_id, dbid, con_dbid, plan_hash_value)</code></pre></td>
                                    <td align="left" valign="top" width="20%" headers="d21079e7483 d21079e7427 ">
                                       <p>The parameters are as follows:</p>
                                       <ul style="list-style-type: disc;">
                                          <li>
                                             <p><code class="codeph">sql_id</code>The SQL ID of the plan
                                             </p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">dbid</code>The database ID (optional)
                                             </p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">con_dbid</code>The CDB ID (optional)
                                             </p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">plan_hash_value</code>The hash value of the plan (optional)
                                             </p>
                                          </li>
                                       </ul>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d21079e7514" headers="d21079e7423 ">
                                       <p>SQL tuning set</p>
                                    </td>
                                    <td align="left" valign="top" width="20%" headers="d21079e7514 d21079e7425 "><pre class="pre codeblock"><code>sqlset_object (sqlset_owner, sqlset_name, sql_id, plan_hash_value)</code></pre></td>
                                    <td align="left" valign="top" width="20%" headers="d21079e7514 d21079e7427 ">
                                       <p>The parameters are as follows:</p>
                                       <ul style="list-style-type: disc;">
                                          <li>
                                             <p><code class="codeph">sqlset_owner</code>The owner of the SQL tuning set
                                             </p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">sqlset_name</code>The name of the SQL tuning set
                                             </p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">sql_id</code>The SQL ID of the plan
                                             </p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">plan_hash_value</code>The hash value of the plan (optional)
                                             </p>
                                          </li>
                                       </ul>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d21079e7545" headers="d21079e7423 ">
                                       <p>SQL plan management</p>
                                    </td>
                                    <td align="left" valign="top" width="20%" headers="d21079e7545 d21079e7425 "><pre class="pre codeblock"><code>spm_object (sql_handle, plan_name)</code></pre></td>
                                    <td align="left" valign="top" width="20%" headers="d21079e7545 d21079e7427 ">
                                       <p>The parameters are as follows:</p>
                                       <ul style="list-style-type: disc;">
                                          <li>
                                             <p><code class="codeph">sql_handle</code>The SQL handle of plans protected by SQL plan management
                                             </p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">plan_name</code>The name of the SQL plan baseline (optional)
                                             </p>
                                          </li>
                                       </ul>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d21079e7566" headers="d21079e7423 ">
                                       <p>SQL profile</p>
                                    </td>
                                    <td align="left" valign="top" width="20%" headers="d21079e7566 d21079e7425 "><pre class="pre codeblock"><code>sql_profile_object (profile_name)</code></pre></td>
                                    <td align="left" valign="top" width="20%" headers="d21079e7566 d21079e7427 ">
                                       <p>The <code class="codeph">profile_name</code> parameter specifies the name of the SQL profile.
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d21079e7579" headers="d21079e7423 ">
                                       <p>Advisor</p>
                                    </td>
                                    <td align="left" valign="top" width="20%" headers="d21079e7579 d21079e7425 "><pre class="pre codeblock"><code>advisor_object (task_name, execution_name, sql_id, plan_id)</code></pre></td>
                                    <td align="left" valign="top" width="20%" headers="d21079e7579 d21079e7427 ">
                                       <p>The parameters are as follows:</p>
                                       <ul style="list-style-type: disc;">
                                          <li>
                                             <p><code class="codeph">task_name</code>The name of the advisor task
                                             </p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">execution_name</code>The name of the task execution
                                             </p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">sql_id</code>The SQL ID of the plan
                                             </p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">plan_id</code>The advisor plan ID (optional)
                                             </p>
                                          </li>
                                       </ul>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-74056529-E2A2-42CB-9230-4924C046260E__GUID-2AA07398-CF24-491D-8717-F75BE6FDA123">DBMS_XPLAN.COMPARE_PLANS Function</p>
                        <p>The interface for the compare plan tools is the following function:</p><pre class="pre codeblock"><code>DBMS_XPLAN.COMPARE_PLANS(
    reference_plan        IN generic_plan_object,
    compare_plan_list     IN plan_object_list,
    type                  IN VARCHAR2 := 'TEXT',
    level                 IN VARCHAR2 := 'TYPICAL',
    section               IN VARCHAR2 := 'ALL')
RETURN CLOB;
</code></pre><p>The following table describes the parameters that specify that plans to be compared.</p>
                        <div class="tblformal" id="GUID-74056529-E2A2-42CB-9230-4924C046260E__GUID-E1B34511-BF4D-45E1-9A7C-0A71890A26A4">
                           <p class="titleintable">Table 6-4 Parameters for the COMPARE_PLANS Function</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="Parameters for the COMPARE_PLANS Function" summary="This table lists the parameters for COMPARE_PLANS." frame="hsides" border="1" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="20%" id="d21079e7628">Parameter</th>
                                    <th align="left" valign="bottom" width="20%" id="d21079e7630">Description</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d21079e7634" headers="d21079e7628 ">
                                       <p><code class="codeph">reference_plan</code></p>
                                    </td>
                                    <td align="left" valign="top" width="20%" headers="d21079e7634 d21079e7630 ">
                                       <p>Specifies a single plan of type <code class="codeph">generic_plan_object</code>.
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d21079e7645" headers="d21079e7628 ">
                                       <p><code class="codeph">compare_plan_list</code></p>
                                    </td>
                                    <td align="left" valign="top" width="20%" headers="d21079e7645 d21079e7630 ">
                                       <p>Specifies a list of plan objects. An object might correspond to one or more plans.</p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-74056529-E2A2-42CB-9230-4924C046260E__GUID-676346CB-54BC-489F-832A-BDE46855C50C">
                        <p class="titleinexample">Example 6-8 Comparing Plans from Child Cursors</p>
                        <p>This example compares the plan of child cursor number 2 for the SQL ID <code class="codeph">8mkxm7ur07za0</code> with the plan for child cursor number 4 for the same SQL ID.
                        </p><pre class="pre codeblock"><code>VAR v_report CLOB;

BEGIN
  :v_report := DBMS_XPLAN.COMPARE_PLANS(
    reference_plan    =&gt; CURSOR_CACHE_OBJECT('8mkxm7ur07za0', 2),
    compare_plan_list =&gt; PLAN_OBJECT_LIST(CURSOR_CACHE_OBJECT('8mkxm7ur07za0', 4)));
END;
/

PRINT v_report</code></pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-74056529-E2A2-42CB-9230-4924C046260E__GUID-06C743A0-781A-44F1-B474-BEE3B6BC4368">
                        <p class="titleinexample">Example 6-9 Comparing Plan from Child Cursor with Plan from SQL Plan Baseline</p>
                        <p>This example compares the plan of child cursor number 2 for the SQL ID <code class="codeph">8mkxm7ur07za0</code> with the plan from the SQL plan baseline. The baseline query has a SQL handle of <code class="codeph">SQL_024d0f7d21351f5d</code> and a plan name of <code class="codeph">SQL_PLAN_sdfjkd</code>.
                        </p><pre class="pre codeblock"><code>VAR v_report CLOB;
BEGIN
  :v_report := DBMS_XPLAN.COMPARE_PLANS( -
    reference_plan    =&gt; CURSOR_CACHE_OBJECT('8mkxm7ur07za0', 2),
    compare_plan_list =&gt; PLAN_OBJECT_LIST(SPM_OBJECT('SQL_024d0f7d21351f5d', 'SQL_PLAN_sdfjkd')));
END;

PRINT v_report</code></pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-74056529-E2A2-42CB-9230-4924C046260E__GUID-A6FF9164-BAB4-4EA7-BCDB-B422A96DDD57">
                        <p class="titleinexample">Example 6-10 Comparing a Plan with Plans from Multiple Sources</p>
                        <p>This example prints the summary section only. The program compares the plan of child cursor number 2 for the SQL ID <code class="codeph">8mkxm7ur07za0</code> with every plan in the following list:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>All plans in the shared SQL area that are generated for the SQL ID <code class="codeph">8mkxm7ur07za0</code></p>
                           </li>
                           <li>
                              <p>All plans generated in the SQL tuning set <code class="codeph">SH. SQLT_WORKLOAD</code> for the SQL ID <code class="codeph">6vfqvav0rgyad</code></p>
                           </li>
                           <li>
                              <p>All plans in AWR that are captured for database ID 5 and SQL ID <code class="codeph">6vfqvav0rgyad</code></p>
                           </li>
                           <li>
                              <p>The plan baseline for the query with handle <code class="codeph">SQL_024d0f7d21351f5d</code> with name <code class="codeph">SQL_PLAN_sdfjkd</code></p>
                           </li>
                           <li>
                              <p>The plan stored in <code class="codeph">sh.plan_table</code> identified by <code class="codeph">plan_id=38</code></p>
                           </li>
                           <li>
                              <p>The plan identified by the SQL profile name <code class="codeph">pe3r3ejsfd</code></p>
                           </li>
                           <li>
                              <p>All plans stored in SQL advisor identified by task name <code class="codeph">TASK_1228</code>, execution name <code class="codeph">EXEC_1928</code>, and SQL ID <code class="codeph">8mkxm7ur07za0</code></p>
                           </li>
                        </ul><pre class="pre codeblock"><code>VAR v_report CLOB
BEGIN
  :v_report := DBMS_XPLAN.COMPARE_PLANS(
    reference_plan    =&gt; CURSOR_CACHE_OBJECT('8mkxm7ur07za0', 2),
    compare_plan_list =&gt; plan_object_list(
         cursor_cache_object('8mkxm7ur07za0'),
         sqlset_object('SH', 'SQLT_WORKLOAD', '6vfqvav0rgyad'),
         awr_object('6vfqvav0rgyad', 5),
         spm_object('SQL_024d0f7d21351f5d', 'SQL_PLAN_sdfjkd'),
         plan_table_object('SH', 'plan_table', 38),
         sql_profile_object('pe3r3ejsfd'), 
         advisor_object('TASK_1228', 'EXEC_1928', '8mkxm7ur07za0')),
    type              =&gt; 'XML', 
    level             =&gt; 'ALL',
    section =&gt; 'SUMMARY');
END;
/

PRINT v_report</code></pre><div class="infoboxnote" id="GUID-74056529-E2A2-42CB-9230-4924C046260E__GUID-5F15DF37-5070-448A-914F-85CCCC51EB34">
                           <p class="notep1">Note:</p>
                           <p><a href="../arpls/DBMS_XPLAN.html#GUID-BAD480AA-351A-48FE-A8E7-F0D8EF643EBF" target="_blank"><span><cite>Oracle Database PL/SQL Packages and Types Reference</cite></span></a> for more information about the <code class="codeph">DBMS_XPLAN</code> package
                           </p>
                        </div>
                     </div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="generating-and-displaying-execution-plans.html#GUID-0023D232-5695-4BA8-89C5-88672B7647E2" title="The plan comparison tool takes a reference plan and an arbitrary list of test plans and highlights the differences between them. The plan comparison is logical rather than line by line.">Comparing Execution Plans</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="sect3"><a id="GUID-60FF7945-DFA3-4E97-89D0-B4F11543C680" name="GUID-60FF7945-DFA3-4E97-89D0-B4F11543C680"></a><h4 id="TGSQL-GUID-60FF7945-DFA3-4E97-89D0-B4F11543C680" class="sect4"><span class="enumeration_section">6.4.3 </span>Comparing Execution Plans: Tutorial
                  </h4>
                  <div>
                     <p>To compare plans, use the <code class="codeph">DBMS_XPLAN.COMPARE_PLANS</code> function.
                     </p>
                     <div class="section">In this tutorial, you compare two distinct queries. The compare plans report shows that the optimizer was able to use a join elimination transformation in one query but not the other.</div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-60FF7945-DFA3-4E97-89D0-B4F11543C680__GUID-610FD272-CC16-47EC-983E-F26F6809F0C1">Assumptions</p>
                        <p>This tutorial assumes that user <code class="codeph">sh</code> issued the following queries:
                        </p><pre class="pre codeblock"><code>select count(*) 
from   products p, sales s 
where  p.prod_id = s.prod_id 
and    p.prod_min_price &gt; 200;

select count(*) 
from   products p, sales s 
where  p.prod_id = s.prod_id 
and    s.quantity_sold = 43;</code></pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-60FF7945-DFA3-4E97-89D0-B4F11543C680__GUID-CF764952-1820-4CEC-939E-C2766009DFB4">To compare execution plans:</p>
                        <ol>
                           <li>
                              <p>Start SQL*Plus, and log in to the database with administrative privileges.</p>
                           </li>
                           <li>
                              <p>Query <code class="codeph">V$SQL</code> to determine the SQL IDs of the two queries.
                              </p>
                              <p>The following query queries <code class="codeph">V$SQL</code> for queries that contain the string <code class="codeph">products</code>:
                              </p><pre class="pre codeblock"><code>SET LINESIZE 120
COL SQL_ID FORMAT a20
COL SQL_TEXT FORMAT a60

SELECT SQL_ID, SQL_TEXT
FROM   V$SQL
WHERE  SQL_TEXT LIKE '%products%'
AND    SQL_TEXT NOT LIKE '%SQL_TEXT%'
ORDER BY SQL_ID;

SQL_ID               SQL_TEXT
-------------------- ------------------------------------------------------------
0hxmvnfkasg6q        select count(*) from   products p, sales s where  p.prod_id
                     = s.prod_id and    s.quantity_sold = 43

10dqxjph6bwum        select count(*) from   products p, sales s where  p.prod_id
                     = s.prod_id and    p.prod_min_price &gt; 200</code></pre></li>
                           <li>
                              <p>Log in to the database as user <code class="codeph">sh</code>.
                              </p>
                           </li>
                           <li>
                              <p>Execute the <code class="codeph">DBMS_XPLAN.COMPARE_PLANS</code> function, specifying the SQL IDs obtained in the previous step.
                              </p>
                              <p>For example, execute the following program:</p><pre class="pre codeblock"><code>VARIABLE v_rep CLOB

BEGIN
  :v_rep := DBMS_XPLAN.COMPARE_PLANS( 
    reference_plan    =&gt; cursor_cache_object('0hxmvnfkasg6q', NULL),
    compare_plan_list =&gt; plan_object_list(cursor_cache_object('10dqxjph6bwum', NULL)),
    type              =&gt; 'TEXT',
    level             =&gt; 'TYPICAL', 
    section           =&gt; 'ALL');
END;
/</code></pre></li>
                           <li>
                              <p>Print the report.</p>
                              <p>For example, run the following query:</p><pre class="pre codeblock"><code>SET PAGESIZE 50000
SET LONG 100000
SET LINESIZE 210
COLUMN report FORMAT a200

SELECT :v_rep REPORT FROM DUAL;</code></pre><p>The <code class="codeph">Comparison Results</code> section of the following sample report shows that only the first query used a join elimination transformation:
                              </p><pre class="pre codeblock"><code>REPORT
---------------------------------------------------------------------------------------------

COMPARE PLANS REPORT
---------------------------------------------------------------------------------------------
  Current user           : SH
  Total number of plans  : 2
  Number of findings     : 1
---------------------------------------------------------------------------------------------

COMPARISON DETAILS
---------------------------------------------------------------------------------------------
 Plan Number            : 1 (Reference Plan)
 Plan Found             : Yes
 Plan Source            : Cursor Cache
 SQL ID                 : 0hxmvnfkasg6q
 Child Number           : 0
 Plan Database Version  : 19.0.0.0
 Parsing Schema         : "SH"
 SQL Text               : select count(*) from products p, sales s where
                        p.prod_id = s.prod_id and s.quantity_sold = 43

Plan
-----------------------------

 Plan Hash Value  : 3519235612

-------------------------------------------------------------------------
| Id  | Operation              | Name  | Rows | Bytes | Cost | Time     |
-------------------------------------------------------------------------
|   0 | SELECT STATEMENT       |       |      |       |  469 |          |
|   1 |   SORT AGGREGATE       |       |    1 |     3 |      |          |
|   2 |    PARTITION RANGE ALL |       |    1 |     3 |  469 | 00:00:01 |
| * 3 |     TABLE ACCESS FULL  | SALES |    1 |     3 |  469 | 00:00:01 |
-------------------------------------------------------------------------

Predicate Information (identified by operation id):
------------------------------------------
* 3 - filter("S"."QUANTITY_SOLD"=43)

---------------------------------------------------------------------------------------------
 Plan Number            : 2
 Plan Found             : Yes
 Plan Source            : Cursor Cache
 SQL ID                 : 10dqxjph6bwum
 Child Number           : 0
 Plan Database Version  : 19.0.0.0
 Parsing Schema         : "SH"
 SQL Text               : select count(*) from products p, sales s where
                        p.prod_id = s.prod_id and p.prod_min_price &gt; 200

Plan
-----------------------------

 Plan Hash Value  : 3037679890

--------------------------------------------------------------------------------------------------
| Id  | Operation                         | Name           | Rows   | Bytes    | Cost | Time     |
--------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT                  |                |        |          |   34 |          |
|   1 |   SORT AGGREGATE                  |                |      1 |       13 |      |          |
| * 2 |    HASH JOIN                      |                | 781685 | 10161905 |   34 | 00:00:01 |
| * 3 |     TABLE ACCESS FULL             | PRODUCTS       |     61 |      549 |    2 | 00:00:01 |
|   4 |     PARTITION RANGE ALL           |                | 918843 |  3675372 |   29 | 00:00:01 |
|   5 |      BITMAP CONVERSION TO ROWIDS  |                | 918843 |  3675372 |   29 | 00:00:01 |
|   6 |       BITMAP INDEX FAST FULL SCAN | SALES_PROD_BIX |        |          |      |          |
--------------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
------------------------------------------
* 2 - access("P"."PROD_ID"="S"."PROD_ID")
* 3 - filter("P"."PROD_MIN_PRICE"&gt;200)


Notes
-----
- This is an adaptive plan


<span class="bold">Comparison Results (1):
-----------------------------
 1. Query block SEL$1: Transformation JOIN REMOVED FROM QUERY BLOCK occurred
    only in the reference plan (result query block: SEL$A43D1678).
</span></code></pre></li>
                        </ol>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-60FF7945-DFA3-4E97-89D0-B4F11543C680__GUID-C9ACC884-2673-4915-B4AC-29BFAD34B79F">
                        <p class="notep1">See Also:</p>
                        <p><a href="../arpls/DBMS_XPLAN.html#GUID-BAD480AA-351A-48FE-A8E7-F0D8EF643EBF" target="_blank"><span><cite>Oracle Database PL/SQL Packages and Types Reference</cite></span></a> for more information about the <code class="codeph">DBMS_XPLAN</code> package
                        </p>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="generating-and-displaying-execution-plans.html#GUID-0023D232-5695-4BA8-89C5-88672B7647E2" title="The plan comparison tool takes a reference plan and an arbitrary list of test plans and highlights the differences between them. The plan comparison is logical rather than line by line.">Comparing Execution Plans</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="sect3"><a id="GUID-7909832F-F81B-40CC-AB8A-7F52CA84F104" name="GUID-7909832F-F81B-40CC-AB8A-7F52CA84F104"></a><h4 id="TGSQL-GUID-7909832F-F81B-40CC-AB8A-7F52CA84F104" class="sect4"><span class="enumeration_section">6.4.4 </span>Comparing Execution Plans: Examples
                  </h4>
                  <div>
                     <p>These examples demonstrate how to generate compare plans reports for queries of tables in the <code class="codeph">sh</code> schema.
                     </p>
                     <div class="example" id="GUID-7909832F-F81B-40CC-AB8A-7F52CA84F104__GUID-7FBF8FC9-94DC-473A-B911-CE5A46FD71D4">
                        <p class="titleinexample">Example 6-11 Comparing an Explained Plan with a Plan in a Cursor</p>
                        <p>This example explains a plan for a query of tables in the <code class="codeph">sh</code> schema, and then executes the query:
                        </p><pre class="pre codeblock"><code>EXPLAIN PLAN 
  SET STATEMENT_ID='TEST' FOR
  SELECT c.cust_city, SUM(s.quantity_sold)
  FROM   customers c, sales s, products p
  WHERE  c.cust_id=s.cust_id
  AND    p.prod_id=s.prod_id
  AND    prod_min_price&gt;100
  GROUP BY c.cust_city;

SELECT c.cust_city, SUM(s.quantity_sold)
FROM   customers c, sales s, products p
WHERE  c.cust_id=s.cust_id
AND    p.prod_id=s.prod_id
AND    prod_min_price&gt;100
GROUP BY c.cust_city;</code></pre><p>Assume that the SQL ID of the executed query is <code class="codeph">9mp7z6qq83k5y</code>. The following PL/SQL program compares the plan in <code class="codeph">PLAN_TABLE</code> and the plan in the shared SQL area:
                        </p><pre class="pre codeblock"><code>BEGIN
  :v_rep := DBMS_XPLAN.COMPARE_PLANS(
    reference_plan    =&gt; plan_table_object('SH', 'PLAN_TABLE', 'TEST', NULL),
    compare_plan_list =&gt; plan_object_list(cursor_cache_object('9mp7z6qq83k5y')),
    type              =&gt; 'TEXT', 
    level             =&gt; 'TYPICAL',
    section           =&gt; 'ALL');
END;
/

PRINT v_rep
</code></pre><p>The following sample report shows that the plans are the same:</p><pre class="pre codeblock"><code>COMPARE PLANS REPORT
-------------------------------------------------------------------------
  Current user           : SH
  Total number of plans  : 2
  Number of findings     : 1
-------------------------------------------------------------------------

COMPARISON DETAILS
-------------------------------------------------------------------------
 Plan Number            : 1 (Reference Plan)
 Plan Found             : Yes
 Plan Source            : Plan Table
 Plan Table Owner       : SH
 Plan Table Name        : PLAN_TABLE
 Statement ID           : TEST
 Plan ID                : 52
 Plan Database Version  : 19.0.0.0
 Parsing Schema         : "SH"
 SQL Text               : No SQL Text

Plan
-----------------------------
 Plan Hash Value  : 3473931970

--------------------------------------------------------------------------
| Id| Operation                | Name    | Rows | Bytes  |Cost| Time     |
--------------------------------------------------------------------------
|  0| SELECT STATEMENT         |         |   620|   22320|1213| 00:00:01 |
|  1|   HASH GROUP BY          |         |   620|   22320|1213| 00:00:01 |
|* 2|    HASH JOIN             |         |160348| 5772528|1209| 00:00:01 |
|  3|     TABLE ACCESS FULL    |CUSTOMERS| 55500|  832500| 414| 00:00:01 |
|* 4|     HASH JOIN            |         |160348| 3367308| 472| 00:00:01 |
|* 5|      TABLE ACCESS FULL   |PRODUCTS |    13|     117|   2| 00:00:01 |
|  6|      PARTITION RANGE ALL |         |918843|11026116| 467| 00:00:01 |
|  7|       TABLE ACCESS FULL  |SALES    |918843|11026116| 467| 00:00:01 |
--------------------------------------------------------------------------

Predicate Information (identified by operation id):
------------------------------------------
* 2 - access("C"."CUST_ID"="S"."CUST_ID")
* 4 - access("P"."PROD_ID"="S"."PROD_ID")
* 5 - filter("PROD_MIN_PRICE"&gt;100)

Notes
-----
- This is an adaptive plan

--------------------------------------------------------------------------------
 Plan Number            : 2
 Plan Found             : Yes
 Plan Source            : Cursor Cache
 SQL ID                 : 9mp7z6qq83k5y
 Child Number           : 0
 Plan Database Version  : 19.0.0.0
 Parsing Schema         : "SH"
 SQL Text               : select c.cust_city, sum(s.quantity_sold) from
                        customers c, sales s, products p where
                        c.cust_id=s.cust_id and p.prod_id=s.prod_id and
                        prod_min_price&gt;100 group by c.cust_city

Plan
-----------------------------
 Plan Hash Value  : 3473931970

----------------------------------------------------------------------------
| Id  | Operation              | Name     | Rows | Bytes  | Cost| Time     |
----------------------------------------------------------------------------
|  0| SELECT STATEMENT         |          |      |        |1213 |          |
|  1|   HASH GROUP BY          |          |   620|   22320|1213 | 00:00:01 |
|* 2|    HASH JOIN             |          |160348| 5772528|1209 | 00:00:01 |
|  3|     TABLE ACCESS FULL    |CUSTOMERS | 55500|  832500| 414 | 00:00:01 |
|* 4|     HASH JOIN            |          |160348| 3367308| 472 | 00:00:01 |
|* 5|      TABLE ACCESS FULL   |PRODUCTS  |    13|     117|   2 | 00:00:01 |
|  6|      PARTITION RANGE ALL |          |918843|11026116| 467 | 00:00:01 |
|  7|       TABLE ACCESS FULL  |SALES     |918843|11026116| 467 | 00:00:01 |
----------------------------------------------------------------------------

Predicate Information (identified by operation id):
------------------------------------------
* 2 - access("C"."CUST_ID"="S"."CUST_ID")
* 4 - access("P"."PROD_ID"="S"."PROD_ID")
* 5 - filter("PROD_MIN_PRICE"&gt;100)

Notes
-----
- This is an adaptive plan

<span class="bold">Comparison Results (1):
-----------------------------
 1. The plans are the same.</span></code></pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-7909832F-F81B-40CC-AB8A-7F52CA84F104__GUID-C7596A42-1556-4578-942B-26EF24F8C190">
                        <p class="titleinexample">Example 6-12 Comparing Plans in a Baseline and SQL Tuning Set</p>
                        <p>Assume that you want to compare the plans for the following queries, which differ only in the <code class="codeph">NO_MERGE</code> hint contained in the subquery:
                        </p><pre class="pre codeblock"><code>SELECT c.cust_city, SUM(s.quantity_sold)
FROM   customers c, sales s, 
       (SELECT prod_id FROM products WHERE prod_min_price&gt;100) p
WHERE  c.cust_id=s.cust_id
AND    p.prod_id=s.prod_id
GROUP BY c.cust_city;

SELECT c.cust_city, SUM(s.quantity_sold)
FROM   customers c, sales s, 
       (SELECT /*+ NO_MERGE */ prod_id FROM products WHERE prod_min_price&gt;100) 
WHERE  c.cust_id=s.cust_id
AND    p.prod_id=s.prod_id
GROUP BY c.cust_city;</code></pre><p>The plan for the first query is captured in a SQL plan management baseline with SQL handle <code class="codeph">SQL_c522f5888cc4613e</code>. The plan for the second query is stored in a SQL tuning set named <code class="codeph">MYSTS1</code> and has a SQL ID of <code class="codeph">d07p7qmrm13nc</code>. You run the following PL/SQL program to compare the plans:
                        </p><pre class="pre codeblock"><code>VAR v_rep CLOB

BEGIN 
  v_rep := DBMS_XPLAN.COMPARE_PLANS(
   reference_plan    =&gt; spm_object('SQL_c522f5888cc4613e'),
   compare_plan_list =&gt; plan_object_list(sqlset_object('SH', 'MYSTS1', 'd07p7qmrm13nc', null)),
   type              =&gt; 'TEXT',
   level             =&gt; 'TYPICAL',
   section           =&gt; 'ALL');
END;
/

PRINT v_rep
</code></pre><p>The following output shows that the only the reference plan, which corresponds to the query without the hint, used a view merge:</p><pre class="pre codeblock"><code>--------------------------------------------------------------------------------------------- 
COMPARE PLANS REPORT
---------------------------------------------------------------------------------------------
Current user       : SH 
Total number of plans : 2 
Number of findings     : 1
---------------------------------------------------------------------------------------------

COMPARISON DETAILS
---------------------------------------------------------------------------------------------
Plan Number            : 1 (Reference Plan)
Plan Found             : Yes
Plan Source            : SQL Plan Baseline
SQL Handle             : SQL_c522f5888cc4613e
Plan Name              : SQL_PLAN_ca8rpj26c8s9y7c2279c4 
Plan Database Version  : 19.0.0.0
Parsing Schema         : "SH"
SQL Text               : select c.cust_city, sum(s.quantity_sold) from customers c, sales s, (select 
                       prod_id from products where prod_min_price&gt;100) p where c.cust_id=s.cust_id and p.prod
                       id=s.prod_id group by c.cust_city

Plan
-----------------------------

Plan Hash Value  : 2082634180
------------------------------------------------------------------------------
| Id | Operation                | Name      | Rows | Bytes | Cost | Time     |
------------------------------------------------------------------------------
|  0 | SELECT STATEMENT         |           |      |       |   22 |          |
|  1 |   HASH GROUP BY          |           |  300 | 11400 |   22 | 00:00:01 |
|  2 |    HASH JOIN             |           |  718 | 27284 |   21 | 00:00:01 |
|  3 |     TABLE ACCESS FULL    | CUSTOMERS |  630 |  9450 |    5 | 00:00:01 |
|  4 |     HASH JOIN            |           |  718 | 16514 |   15 | 00:00:01 |
|  5 |      TABLE ACCESS FULL   | PRODUCTS  |  573 |  5730 |    9 | 00:00:01 |
|  6 |      PARTITION RANGE ALL |           |  960 | 12480 |    5 | 00:00:01 |
|  7 |       TABLE ACCESS FULL  | SALES     |  960 | 12480 |    5 | 00:00:01 |
------------------------------------------------------------------------------

------------------------------------------------------------------------------
Plan Number            : 2
Plan Found             : Yes
Plan Source            : SQL Tuning Set 
SQL Tuning Set Owner   : SH
SQL Tuning Set Name    : MYSTS1
SQL ID                 : d07p7qmrm13nc
Plan Hash Value        : 655891922 
Plan Database Version  : 19.0.0.0 
Parsing Schema         : "SH"
SQL Text               : select c.cust_city, sum(s.quantity_sold) from customers c, sales s, (select 
                       /*+ NO_MERGE */ prod_id from products where prod_min_price&gt;100) p where
                       c.cust_id=s.cust_id and p.prod_id=s.prod_id group by c.cust_city

Plan
-----------------------------

Plan Hash Value  : 655891922
------------------------------------------------------------------------------
| Id | Operation                | Name      | Rows | Bytes | Cost | Time     |
------------------------------------------------------------------------------
|  0 | SELECT STATEMENT         |           |      |       |   23 |          |
|  1 |   HASH GROUP BY          |           |  300 |  9900 |   23 | 00:00:01 |
|  2 |    HASH JOIN             |           |  718 | 23694 |   21 | 00:00:01 |
|  3 |     HASH JOIN            |           |  718 | 12924 |   15 | 00:00:01 |
|  4 |      VIEW                |           |  573 |  2865 |    9 | 00:00:01 |
|  5 |       TABLE ACCESS FULL  | PRODUCTS  |  573 |  5730 |    9 | 00:00:01 |
|  6 |      PARTITION RANGE ALL |           |  960 | 12480 |    5 | 00:00:01 |
|  7 |       TABLE ACCESS FULL  | SALES     |  960 | 12480 |    5 | 00:00:01 |
|  8 |     TABLE ACCESS FULL    | CUSTOMERS |  630 |  9450 |    5 | 00:00:01 |
------------------------------------------------------------------------------

Notes
-----
- This is an adaptive plan

<span class="bold">Comparison Results (1):
-----------------------------
1. Query block SEL$1: Transformation VIEW MERGE occurred only in the reference
plan (result query block: SEL$F5BB74E1).
</span></code></pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-7909832F-F81B-40CC-AB8A-7F52CA84F104__GUID-1AE8839D-6DEF-4BB3-B3DA-5E8A842CCBAA">
                        <p class="titleinexample">Example 6-13 Comparing Plans Before and After Adding an Index</p>
                        <p>In this example, you test the effect of an index on a query plan:</p><pre class="pre codeblock"><code>EXPLAIN PLAN 
  SET STATEMENT_ID='TST1' FOR 
  SELECT COUNT(*) FROM products WHERE prod_min_price&gt;100;

CREATE INDEX newprodidx ON products(prod_min_price); 

EXPLAIN PLAN 
  SET STATEMENT_ID='TST2' FOR 
  SELECT COUNT(*) FROM products WHERE prod_min_price&gt;100;</code></pre><p>You execute the following PL/SQL program to generate the report:</p><pre class="pre codeblock"><code>VAR v_rep CLOB

BEGIN
  :v_rep := DBMS_XPLAN.COMPARE_PLANS(
    reference_plan    =&gt; plan_table_object('SH', 'PLAN_TABLE', 'TST1', NULL),
    compare_plan_list =&gt; plan_object_list(plan_table_object('SH', 'PLAN_TABLE', 'TST2', NULL)),
    TYPE              =&gt; 'TEXT', 
    level             =&gt; 'TYPICAL', 
    section           =&gt; 'ALL');
END;
/

PRINT v_rep
</code></pre><p>The following report indicates that the operations in the two plans are different:</p><pre class="pre codeblock"><code>COMPARE PLANS REPORT
--------------------------------------------------------------------------
  Current user           : SH
  Total number of plans  : 2
  Number of findings     : 1
--------------------------------------------------------------------------

COMPARISON DETAILS
--------------------------------------------------------------------------
 Plan Number            : 1 (Reference Plan)
 Plan Found             : Yes
 Plan Source            : Plan Table
 Plan Table Owner       : SH
 Plan Table Name        : PLAN_TABLE
 Statement ID           : TST1
 Plan ID                : 56
 Plan Database Version  : 19.0.0.0
 Parsing Schema         : "SH"
 SQL Text               : No SQL Text

Plan
-----------------------------
 Plan Hash Value  : 3421487369

--------------------------------------------------------------------------
| Id  | Operation            | Name     | Rows | Bytes | Cost | Time     |
--------------------------------------------------------------------------
|   0 | SELECT STATEMENT     |          |    1 |     5 |    2 | 00:00:01 |
|   1 |   SORT AGGREGATE     |          |    1 |     5 |      |          |
| * 2 |    TABLE ACCESS FULL | PRODUCTS |   13 |    65 |    2 | 00:00:01 |
--------------------------------------------------------------------------

Predicate Information (identified by operation id):
------------------------------------------
* 2 - filter("PROD_MIN_PRICE"&gt;100)

--------------------------------------------------------------------------
 Plan Number            : 2
 Plan Found             : Yes
 Plan Source            : Plan Table
 Plan Table Owner       : SH
 Plan Table Name        : PLAN_TABLE
 Statement ID           : TST2
 Plan ID                : 57
 Plan Database Version  : 19.0.0.0
 Parsing Schema         : "SH"
 SQL Text               : No SQL Text

Plan
-----------------------------
 Plan Hash Value  : 2694011010

---------------------------------------------------------------------------
| Id  | Operation           | Name       | Rows | Bytes | Cost | Time     |
---------------------------------------------------------------------------
|   0 | SELECT STATEMENT    |            |    1 |     5 |    1 | 00:00:01 |
|   1 |   SORT AGGREGATE    |            |    1 |     5 |      |          |
| * 2 |    INDEX RANGE SCAN | NEWPRODIDX |   13 |    65 |    1 | 00:00:01 |
---------------------------------------------------------------------------

Predicate Information (identified by operation id):
------------------------------------------
* 2 - access("PROD_MIN_PRICE"&gt;100)

<span class="bold">Comparison Results (1):
-----------------------------
 1. Query block SEL$1, Alias PRODUCTS@SEL$1: Some columns (OPERATION, OPTIONS,
    OBJECT_NAME) do not match between the reference plan (id: 2) and the
    current plan (id: 2).
</span></code></pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-7909832F-F81B-40CC-AB8A-7F52CA84F104__GUID-1E8F7CDB-90EC-4631-B131-DC3D7166E164">
                        <p class="titleinexample">Example 6-14 Comparing Plans with Visible and Invisible Indexes</p>
                        <p>In this example, an application executes the following query:</p><pre class="pre codeblock"><code>select count(*)
  from products p, sales s 
 where p.prod_id = s.prod_id
   and p.prod_status = 'obsolete';
</code></pre><p>The plan for this query uses two indexes: <code class="codeph">sales_prod_bix</code> and <code class="codeph">products_prod_status_bix</code>. The database generates four plans, using all combinations of visible and invisible for both indexes. Assume that SQL plan management accepts the following plans in the baseline for the query:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><code class="codeph">sales_prod_bix</code> visible and <code class="codeph">products_prod_status_bix</code> visible
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">sales_prod_bix</code> visible and <code class="codeph">products_prod_status_bix</code> invisible
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">sales_prod_bix</code> invisible and <code class="codeph">products_prod_status_bix</code> visible
                              </p>
                           </li>
                        </ul>
                        <p>You make both indexes invisible, and then execute the query again. The optimizer, unable to use the invisible indexes, generates a new plan. The three baseline plans, all of which rely on at least one index being visible, fail to reproduce. Therefore, the optimizer uses the new plan and adds it to the SQL plan baseline for the query. To compare the plan currently in the shared SQL area, which is the reference plan, with all four plans in the baseline, you execute the following PL/SQL code:</p><pre class="pre codeblock"><code>VAR v_rep CLOB

BEGIN
  :v_rep := DBMS_XPLAN.COMPARE_PLANS(
    reference_plan    =&gt; cursor_cache_object('45ns3tzutg0ds'),
    compare_plan_list =&gt; plan_object_list(spm_object('SQL_aec814b0d452da8a')),
    TYPE              =&gt; 'TEXT',
    level             =&gt; 'TYPICAL',
    section           =&gt; 'ALL');
END;
/

PRINT v_rep</code></pre><p>The following report compares all five plans:</p><pre class="pre codeblock"><code>-----------------------------------------------------------------------------
COMPARE PLANS REPORT
-----------------------------------------------------------------------------
Current user       : SH
Total number of plans : 5
Number of findings     : 19
-----------------------------------------------------------------------------

COMPARISON DETAILS
-----------------------------------------------------------------------------
Plan Number            : 1 (Reference Plan)
Plan Found             : Yes
Plan Source            : Cursor Cache
SQL ID                 : 45ns3tzutg0ds
Child Number           : 0
Plan Database Version  : 19.0.0.0 
Parsing Schema         : "SH"
SQL Text               : select count(*) from products p, sales s where p.prod_id = s.prod_id and 
                       p.prod_status = 'obsolete'

Plan
-----------------------------

Plan Hash Value  : 1136711713
------------------------------------------------------------------------------
| Id  | Operation                | Name     | Rows | Bytes | Cost | Time     |
------------------------------------------------------------------------------
|   0 | SELECT STATEMENT         |          |      |       |   15 |          |
|   1 |   SORT AGGREGATE         |          |    1 |    30 |      |          |
| * 2 |    HASH JOIN             |          |  320 |  9600 |   15 | 00:00:01 |
|   3 |     JOIN FILTER CREATE   | :BF0000  |  255 |  6375 |    9 | 00:00:01 |
| * 4 |      TABLE ACCESS FULL   | PRODUCTS |  255 |  6375 |    9 | 00:00:01 |
|   5 |     JOIN FILTER USE      | :BF0000  |  960 |  4800 |    5 | 00:00:01 |
|   6 |      PARTITION RANGE ALL |          |  960 |  4800 |    5 | 00:00:01 |
| * 7 |       TABLE ACCESS FULL  | SALES    |  960 |  4800 |    5 | 00:00:01 |
------------------------------------------------------------------------------
Predicate Information (identified by operation id):
------------------------------------------
* 2 - access("P"."PROD_ID"="S"."PROD_ID")
* 4 - filter("P"."PROD_STATUS"='obsolete')
* 7 - filter(SYS_OP_BLOOM_FILTER(:BF0000,"S"."PROD_ID"))

Notes
-----
- baseline_repro_fail = yes

---------------------------------------------------------------------------------------------
Plan Number            : 2
Plan Found             : Yes
Plan Source            : SQL Plan Baseline
SQL Handle             : SQL_aec814b0d452da8a
Plan Name              : SQL_PLAN_axk0nq3a55qna6e039463 
Plan Database Version  : 19.0.0.0
Parsing Schema         : "SH"
SQL Text               : select count(*) from products p, sales s where p.prod_id = s.prod_id and 
                       p.prod_status = 'obsolete'

Plan
-----------------------------

Plan Hash Value  : 1845728355
-------------------------------------------------------------------------------------------------
| Id | Operation                          | Name                     |Rows| Bytes | Cost | Time |
-------------------------------------------------------------------------------------------------
|   0| SELECT STATEMENT                   |                          |  1 |   30 | 11 |00:00:01 |
|   1|   SORT AGGREGATE                   |                          |  1 |   30 |    |         |
| * 2|    HASH JOIN                       |                          |320 | 9600 | 11 |00:00:01 |
|   3|     JOIN FILTER CREATE             | :BF0000                  |255 | 6375 |  5 |00:00:01 |
| * 4|      VIEW                          | index$_join$_001         |255 | 6375 |  5 |00:00:01 |
| * 5|       HASH JOIN                    |                          |    |      |    |         |
|   6|        BITMAP CONVERSION TO ROWIDS |                          |255 | 6375 |  1 |00:00:01 |
| * 7|         BITMAP INDEX SINGLE VALUE  | PRODUCTS_PROD_STATUS_BIX |    |      |    |         |
|   8|        INDEX FAST FULL SCAN        | PRODUCTS_PK              |255 | 6375 |  4 |00:00:01 |
|   9|     JOIN FILTER USE                | :BF0000                  |960 | 4800 |  5 |00:00:01 |
|  10|      PARTITION RANGE ALL           |                          |960 | 4800 |  5 |00:00:01 |
|* 11|       TABLE ACCESS FULL            | SALES                    |960 | 4800 |  5 |00:00:01 |
-------------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
------------------------------------------
* 2 - access("P"."PROD_ID"="S"."PROD_ID")
* 4 - filter("P"."PROD_STATUS"='obsolete')
* 5 - access(ROWID=ROWID)
* 7 - access("P"."PROD_STATUS"='obsolete')
* 11 - filter(SYS_OP_BLOOM_FILTER(:BF0000,"S"."PROD_ID"))

<span class="bold">Comparison Results (4):
-----------------------------
1. Query block SEL$1, Alias P@SEL$1: Some lines (id: 4) in the reference plan are missing in the 
current plan.
2. Query block SEL$1, Alias S@SEL$1: Some columns (ID) do not match between the reference plan (id: 
5) and the current plan (id: 9).
3. Query block SEL$1, Alias S@SEL$1: Some columns (ID, PARENT_ID, PARTITION_ID) do not match 
between the reference plan (id: 6) and the current plan (id: 10).
4. Query block SEL$1, Alias S@SEL$1: Some columns (ID, PARENT_ID, PARTITION_ID) do not match 
between the reference plan (id: 7) and the current plan (id: 11).</span>

---------------------------------------------------------------------------------------------
Plan Number            : 3
Plan Found             : Yes
Plan Source            : SQL Plan Baseline
SQL Handle             : SQL_aec814b0d452da8a
Plan Name              : SQL_PLAN_axk0nq3a55qna43c0d821 
Plan Database Version  : 19.0.0.0
Parsing Schema         : "SH"
SQL Text               : select count(*) from products p, sales s where p.prod_id = s.prod_id and 
                       p.prod_status = 'obsolete'

Plan
-----------------------------
Plan Hash Value  : 1136711713

------------------------------------------------------------------------------
| Id  | Operation                | Name     | Rows | Bytes | Cost | Time     |
------------------------------------------------------------------------------
|   0 | SELECT STATEMENT         |          |    1 |    30 |   15 | 00:00:01 |
|   1 |   SORT AGGREGATE         |          |    1 |    30 |      |          |
| * 2 |    HASH JOIN             |          |  320 |  9600 |   15 | 00:00:01 |
|   3 |     JOIN FILTER CREATE   | :BF0000  |  255 |  6375 |    9 | 00:00:01 |
| * 4 |      TABLE ACCESS FULL   | PRODUCTS |  255 |  6375 |    9 | 00:00:01 |
|   5 |     JOIN FILTER USE      | :BF0000  |  960 |  4800 |    5 | 00:00:01 |
|   6 |      PARTITION RANGE ALL |          |  960 |  4800 |    5 | 00:00:01 |
| * 7 |       TABLE ACCESS FULL  | SALES    |  960 |  4800 |    5 | 00:00:01 |
------------------------------------------------------------------------------

Predicate Information (identified by operation id):
------------------------------------------
* 2 - access("P"."PROD_ID"="S"."PROD_ID")
* 4 - filter("P"."PROD_STATUS"='obsolete')
* 7 - filter(SYS_OP_BLOOM_FILTER(:BF0000,"S"."PROD_ID"))

Comparison Results (1):
-----------------------------
1. The plans are the same.

------------------------------------------------------------------------------
Plan Number            : 4
Plan Found             : Yes
Plan Source            : SQL Plan Baseline
SQL Handle             : SQL_aec814b0d452da8a
Plan Name              : SQL_PLAN_axk0nq3a55qna1b7aea6c 
Plan Database Version  : 19.0.0.0
Parsing Schema         : "SH"
SQL Text               : select count(*) from products p, sales s where p.prod_id = s.prod_id and 
                       p.prod_status = 'obsolete'

Plan
-----------------------------

Plan Hash Value  : 461040236
-------------------------------------------------------------------------------------
| Id | Operation                       | Name           |Rows|Bytes | Cost | Time   |
--------------------------------------------------------- ---------------------------
|  0 | SELECT STATEMENT                |                |  1 |   30 | 10 | 00:00:01 |
|  1 |   SORT AGGREGATE                |                |  1 |   30 |    |          |
|  2 |    NESTED LOOPS                 |                |320 | 9600 | 10 | 00:00:01 |
|* 3 |     TABLE ACCESS FULL           | PRODUCTS       |255 | 6375 |  9 | 00:00:01 |
|  4 |     PARTITION RANGE ALL         |                |  1 |    5 | 10 | 00:00:01 |
|  5 |      BITMAP CONVERSION COUNT    |                |  1 |    5 | 10 | 00:00:01 |
|* 6 |       BITMAP INDEX SINGLE VALUE | SALES_PROD_BIX |    |      |    |          |
-------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
------------------------------------------
* 3 - filter("P"."PROD_STATUS"='obsolete')
* 6 - access("P"."PROD_ID"="S"."PROD_ID")

<span class="bold">Comparison Results (7):
-----------------------------
1. Query block SEL$1, Alias P@SEL$1: Some lines (id: 3) in the reference plan are missing in the 
current plan.
2. Query block SEL$1, Alias S@SEL$1: Some lines (id: 5) in the reference plan are missing in the 
current plan.
3. Query block SEL$1, Alias S@SEL$1: Some lines (id: 7) in the reference plan are missing in the 
current plan.
4. Query block SEL$1, Alias S@SEL$1: Some lines (id: 5,6) in the current plan are missing in the 
reference plan.
5. Query block SEL$1, Alias P@SEL$1: Some columns (OPERATION) do not match between the reference 
plan (id: 2) and the current plan (id: 2).
6. Query block SEL$1, Alias P@SEL$1: Some columns (ID, PARENT_ID, DEPTH) do not match between the 
reference plan (id: 4) and the current plan (id: 3).
7. Query block SEL$1, Alias S@SEL$1: Some columns (ID, PARENT_ID, DEPTH, POSITION, PARTITION_ID) do 
not match between the reference plan (id: 6) and the current plan (id: 4).</span>

---------------------------------------------------------------------------------------------
Plan Number            : 5
Plan Found             : Yes
Plan Source            : SQL Plan Baseline
SQL Handle             : SQL_aec814b0d452da8a
Plan Name              : SQL_PLAN_axk0nq3a55qna0628afbd 
Plan Database Version  : 19.0.0.0
Parsing Schema         : "SH"
SQL Text               : select count(*) from products p, sales s where p.prod_id = s.prod_id and 
                       p.prod_status = 'obsolete'

Plan
-----------------------------

Plan Hash Value  : 103329725
-------------------------------------------------------------------------------------------
|Id| Operation                         | Name                     | Rows|Bytes|Cost|Time  |
-------------------------------------------------------------------------------------------
| 0| SELECT STATEMENT                  |                          |    |     | 5 |        |
| 1|   SORT AGGREGATE                  |                          |  1 |  30 |   |        |
| 2|    NESTED LOOPS                   |                          |320 |9600 | 5 |00:00:01|
| 3|     VIEW                          | index$_join$_001         |255 |6375 | 5 |00:00:01|
| 4|      HASH JOIN                    |                          |    |     |   |        |
| 5|       BITMAP CONVERSION TO ROWIDS |                          |255 |6375 | 1 |00:00:01|
| 6|        BITMAP INDEX SINGLE VALUE  | PRODUCTS_PROD_STATUS_BIX |    |     |   |        |
| 7|       INDEX FAST FULL SCAN        | PRODUCTS_PK              |255 |6375 | 4 |00:00:01|
| 8|     PARTITION RANGE ALL           |                          |  1 |   5 | 5 |00:00:01|
| 9|      BITMAP CONVERSION TO ROWIDS  |                          |  1 |   5 | 5 |00:00:01|
|10|       BITMAP INDEX SINGLE VALUE   | SALES_PROD_BIX           |    |     |   |        |
-------------------------------------------------------------------------------------------

<span class="bold">Comparison Results (7):
-----------------------------
1. Query block SEL$1, Alias P@SEL$1: Some lines (id: 3) in the reference plan are missing in the 
current plan.
2. Query block SEL$1, Alias P@SEL$1: Some lines (id: 4) in the reference plan are missing in the 
current plan.
3. Query block SEL$1, Alias S@SEL$1: Some lines (id: 5) in the reference plan are missing in the 
current plan.
4. Query block SEL$1, Alias S@SEL$1: Some lines (id: 7) in the reference plan are missing in the 
current plan.
5. Query block SEL$1, Alias S@SEL$1: Some lines (id: 9,10) in the current plan are missing in the 
reference plan.
6. Query block SEL$1, Alias P@SEL$1: Some columns (OPERATION) do not match between the reference 
plan (id: 2) and the current plan (id: 2).
7. Query block SEL$1, Alias S@SEL$1: Some columns (ID, PARENT_ID, DEPTH, POSITION, PARTITION_ID) do 
not match between the reference plan (id: 6) and the current plan (id: 8).</span>
</code></pre><p>The preceding report shows the following:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Plan 1 is the reference plan from the shared SQL area. The plan does not use the indexes, which are both invisible, and does not reproduce a baseline plan.</p>
                           </li>
                           <li>
                              <p>Plan 2 is in the baseline and assumes <code class="codeph">sales_prod_bix</code> is invisible and <code class="codeph">products_prod_status_bix</code> is visible.
                              </p>
                           </li>
                           <li>
                              <p>Plan 3 is in the baseline and assumes both indexes are invisible. Plan 1 and Plan 3 are the same.</p>
                           </li>
                           <li>
                              <p>Plan 4 is in the baseline and assumes <code class="codeph">sales_prod_bix</code> is visible and <code class="codeph">products_prod_status_bix</code> is invisible.
                              </p>
                           </li>
                           <li>
                              <p>Plan 5 is in the baseline and assumes that both indexes are visible.</p>
                           </li>
                        </ul>
                        <p>The comparison report shows that Plan 1 could not reproduce a plan from that baseline. The reason is that the plan in the cursor (Plan 1) was added to the baseline because no baseline plan was available at the time of execution, so the database performed a soft parse of the statement and generated the no-index plan. If the current cursor were to be invalidated, and if the query were to be executed again, then a comparison report would show that the cursor plan did reproduce a baseline plan.</p>
                        <div class="infoboxnotealso" id="GUID-7909832F-F81B-40CC-AB8A-7F52CA84F104__GUID-3BD49B43-E45E-4F7A-B668-B8FC769DDB40">
                           <p class="notep1">See Also:</p>
                           <p><a href="../arpls/DBMS_XPLAN.html#GUID-BAD480AA-351A-48FE-A8E7-F0D8EF643EBF" target="_blank"><span><cite>Oracle Database PL/SQL Packages and Types Reference</cite></span></a> for more information about the <code class="codeph">DBMS_XPLAN</code> package
                           </p>
                        </div>
                     </div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-7909832F-F81B-40CC-AB8A-7F52CA84F104__GUID-01DC5163-893A-4DCD-B112-676A010E2F45">
                        <p class="titleinexample">Example 6-15 Comparing a Baseline That Fails to Reproduce</p>
                        <p>One use case is to compare a cost-based plan with a SQL plan baseline. In this example, you create a unique index. The database captures a plan baseline that uses this index. You then make the index invisible and execute the query again. The baseline plan fails to reproduce because the index is not visible, forcing the optimizer to choose a different plan. A compare plans report between the baseline plan and the cost-based plan shows the difference in the access path between the two plans.</p>
                        <ol>
                           <li>
                              <p>Log in to the database as user <code class="codeph">hr</code>, and then create a plan table:
                              </p><pre class="pre codeblock"><code>CREATE TABLE PLAN_TABLE (
 STATEMENT_ID                VARCHAR2(30),
 PLAN_ID                     NUMBER,
 TIMESTAMP                   DATE,
 REMARKS                     VARCHAR2(4000),
 OPERATION                   VARCHAR2(30),
 OPTIONS                     VARCHAR2(255),
 OBJECT_NODE                 VARCHAR2(128),
 OBJECT_OWNER                VARCHAR2(30),
 OBJECT_NAME                 VARCHAR2(30),
 OBJECT_ALIAS                VARCHAR2(65),
 OBJECT_INSTANCE             NUMBER(38),
 OBJECT_TYPE                 VARCHAR2(30),
 OPTIMIZER                   VARCHAR2(255),
 SEARCH_COLUMNS              NUMBER,
 ID                          NUMBER(38),
 PARENT_ID                   NUMBER(38),
 DEPTH                       NUMBER(38),
 POSITION                    NUMBER(38),
 COST                        NUMBER(38),
 CARDINALITY                 NUMBER(38),
 BYTES                       NUMBER(38),
 OTHER_TAG                   VARCHAR2(255),
 PARTITION_START             VARCHAR2(255),
 PARTITION_STOP              VARCHAR2(255),
 PARTITION_ID                NUMBER(38),
 OTHER                       LONG,
 DISTRIBUTION                VARCHAR2(30),
 CPU_COST                    NUMBER(38),
 IO_COST                     NUMBER(38),
 TEMP_SPACE                  NUMBER(38),
 ACCESS_PREDICATES           VARCHAR2(4000),
 FILTER_PREDICATES           VARCHAR2(4000),
 PROJECTION                  VARCHAR2(4000),
 TIME                        NUMBER(38),
 QBLOCK_NAME                 VARCHAR2(30),
 OTHER_XML                   CLOB);
</code></pre></li>
                           <li>
                              <p>Execute the following DDL statements, which create a table named <code class="codeph">staff</code> and an index on the <code class="codeph">staff.employee_id</code> column:
                              </p><pre class="pre codeblock"><code>CREATE TABLE staff AS (SELECT * FROM employees);
CREATE UNIQUE INDEX staff_employee_id ON staff (employee_id);
</code></pre></li>
                           <li>
                              <p>Execute the following statements to place a query of <code class="codeph">staff</code> under the protection of SQL Plan Management, and then make the index invisible:
                              </p><pre class="pre codeblock"><code>ALTER SESSION SET optimizer_capture_sql_plan_baselines = TRUE;
SELECT COUNT(*) FROM staff WHERE employee_id = 20;
-- execute query a second time to create a baseline
SELECT COUNT(*) FROM staff WHERE employee_id = 20;
ALTER SESSION SET optimizer_capture_sql_plan_baselines = FALSE;
ALTER INDEX staff_employee_id INVISIBLE;
</code></pre></li>
                           <li>
                              <p>Explain the plan, and then query the plan table (sample output included):</p><pre class="pre codeblock"><code>EXPLAIN PLAN SET STATEMENT_ID='STAFF' FOR SELECT COUNT(*) FROM staff WHERE employee_id = 20;
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY(FORMAT=&gt;'TYPICAL'));

PLAN_TABLE_OUTPUT
--------------------------------------------------------------------------------
Plan hash value: 1778552452

----------------------------------------------------------------------------
| Id  | Operation          | Name  | Rows  | Bytes | Cost (%CPU)| Time     |
----------------------------------------------------------------------------
|   0 | SELECT STATEMENT   |       |     1 |     4 |     2   (0)| 00:00:01 |
|   1 |  SORT AGGREGATE    |       |     1 |     4 |            |          |
|*  2 |   <span class="bold">TABLE ACCESS FULL</span>| STAFF |     1 |     4 |     2   (0)| 00:00:01 |
----------------------------------------------------------------------------

Predicate Information (identified by operation id):

PLAN_TABLE_OUTPUT
--------------------------------------------------------------------------------

   2 - filter("EMPLOYEE_ID"=20)

<span class="bold">Note
-----
   - dynamic statistics used: dynamic sampling (level=2)
   - Failed to use SQL plan baseline for this statement</span></code></pre><p>As the preceding output shows, the optimizer chooses a full table scan because the index is invisible. Because the SQL plan baseline uses an index, the optimizer cannot reproduce the plan.</p>
                           </li>
                           <li>
                              <p>In a separate session, log in as <code class="codeph">SYS</code> and query the handle and plan name of the SQL plan baseline (sample output included):
                              </p><pre class="pre codeblock"><code>SET LINESIZE 120
COL SQL_HANDLE FORMAT a25
COL PLAN_NAME FORMAT a35

SELECT DISTINCT SQL_HANDLE,PLAN_NAME,ACCEPTED 
FROM   DBA_SQL_PLAN_BASELINES 
WHERE  PARSING_SCHEMA_NAME = 'HR';

SQL_HANDLE                PLAN_NAME                           ACC
------------------------- ----------------------------------- ---
SQL_3fa3b23c5ba1bf60      SQL_PLAN_3z8xk7jdu3gv0b7aa092a      YES</code></pre></li>
                           <li>
                              <p>Compare the plans, specifying the SQL handle and plan baseline name obtained from the previous step:</p><pre class="pre codeblock"><code>VAR v_report CLOB

BEGIN
 :v_report := DBMS_XPLAN.COMPARE_PLANS(
   reference_plan    =&gt; plan_table_object('HR', 'PLAN_TABLE', 'STAFF'),
   compare_plan_list =&gt; plan_object_list (SPM_OBJECT('SQL_3fa3b23c5ba1bf60','SQL_PLAN_3z8xk7jdu3gv0b7aa092a')),
   type              =&gt; 'TEXT',
   level             =&gt; 'ALL',
   section           =&gt; 'ALL');
END;
/</code></pre></li>
                           <li>
                              <p>Query the compare plans report (sample output included):</p><pre class="pre codeblock"><code>SET LONG 1000000
SET PAGESIZE 50000
SET LINESIZE 200
SELECT :v_report rep FROM DUAL;

REP
--------------------------------------------------------------------------------

COMPARE PLANS REPORT
--------------------------------------------------------------------------------
  Current user           : SYS
  Total number of plans  : 2
  Number of findings     : 1
--------------------------------------------------------------------------------

COMPARISON DETAILS
--------------------------------------------------------------------------------
 Plan Number            : 1 (Reference Plan)
 Plan Found             : Yes
 Plan Source            : Plan Table
 Plan Table Owner       : HR
 Plan Table Name        : PLAN_TABLE
 Statement ID           : STAFF
 Plan ID                : 72
 Plan Database Version  : 19.0.0.0
 Parsing Schema         : "HR"
 SQL Text               : No SQL Text

Plan
-----------------------------
 Plan Hash Value  : 1766070819

--------------------------------------------------------------------
| Id | Operation            | Name  |Rows| Bytes | Cost | Time     |
--------------------------------------------------------------------
|   0| SELECT STATEMENT     |       |  1 |    13 |    2 | 00:00:01 |
|   1|   SORT AGGREGATE     |       |  1 |    13 |      |          |
| * 2|    TABLE ACCESS FULL | STAFF |  1 |    13 |    2 | 00:00:01 |
--------------------------------------------------------------------

Predicate Information (identified by operation id):
------------------------------------------
* 2 - filter("EMPLOYEE_ID"=20)

Notes
-----
- Dynamic sampling used for this statement ( level = 2 )
- baseline_repro_fail = yes

--------------------------------------------------------------------
 Plan Number            : 2
 Plan Found             : Yes
 Plan Source            : SQL Plan Baseline
 SQL Handle             : SQL_3fa3b23c5ba1bf60
 Plan Name              : SQL_PLAN_3z8xk7jdu3gv0b7aa092a
 Plan Database Version  : 19.0.0.0
 Parsing Schema         : "HR"
 SQL Text               : SELECT COUNT(*) FROM staff WHERE employee_id = 20

Plan
-----------------------------

 Plan Hash Value  : 3081373994

--------------------------------------------------------------------------------
| Id | Operation            | Name              |Rows| Bytes | Cost | Time     |
--------------------------------------------------------------------------------
|   0| SELECT STATEMENT     |                   |  1 |    13 |    0 | 00:00:01 |
|   1|   SORT AGGREGATE     |                   |  1 |    13 |      |          |
| * 2|    INDEX UNIQUE SCAN | STAFF_EMPLOYEE_ID |  1 |    13 |    0 | 00:00:01 |
--------------------------------------------------------------------------------

Predicate Information (identified by operation id):
------------------------------------------
* 2 - access("EMPLOYEE_ID"=20)

<span class="bold">Comparison Results (1):
-----------------------------
 1. Query block SEL$1, Alias "STAFF"@"SEL$1": Some columns (OPERATION, OPTIONS,
    OBJECT_NAME) do not match between the reference plan (id: 2) and the
    current plan (id: 2)
</span>----------------------------------------------------------------------------</code></pre></li>
                        </ol>
                     </div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="generating-and-displaying-execution-plans.html#GUID-0023D232-5695-4BA8-89C5-88672B7647E2" title="The plan comparison tool takes a reference plan and an arbitrary list of test plans and highlights the differences between them. The plan comparison is logical rather than line by line.">Comparing Execution Plans</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div>
         </div>
      </article>
   </body>
</html>