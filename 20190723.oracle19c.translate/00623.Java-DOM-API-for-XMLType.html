<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <meta name="abstract" content="The Java DOM API for XMLType lets you operate on XMLType instances using a DOM. You can use it to manipulate XML data in Java, including fetching it through Java Database Connectivity (JDBC)."></meta>
      <meta name="description" content="The Java DOM API for XMLType lets you operate on XMLType instances using a DOM. You can use it to manipulate XML data in Java, including fetching it through Java Database Connectivity (JDBC)."></meta>
      <title>用于XMLType的Java DOM API</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Developer&#39;s Guide "></meta>
      <meta property="og:description" content="The Java DOM API for XMLType lets you operate on XMLType instances using a DOM. You can use it to manipulate XML data in Java, including fetching it through Java Database Connectivity (JDBC)."></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Developer&#39;s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="xml-db-developers-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-03-30T12:32:42-07:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="2002, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96222-03"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="PLSQL-package-DBMS_XMLSTORE.html" title="Previous" type="text/html"></link>
      <link rel="next" href="C-API-for-XMLType.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="XML DB Developer&#39;s Guide"></meta>
    <meta name="dcterms.isVersionOf" content="ADXDB"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="PLSQL-package-DBMS_XMLSTORE.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="C-API-for-XMLType.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">开发人员指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="XMLType-APIs.html" property="item" typeof="WebPage"><span property="name">XMLType API</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">用于XMLType的Java DOM API</li>
            </ol>
            <a id="GUID-4C510052-8A31-4917-8567-0E2825927C54" name="GUID-4C510052-8A31-4917-8567-0E2825927C54"></a><a id="ADXDB1300"></a>
            
            <h2 id="ADXDB-GUID-4C510052-8A31-4917-8567-0E2825927C54" class="sect2"><span class="enumeration_chapter">13</span>用于XMLType的Java DOM API</h2>
         </header>
         <div class="ind"><script type="text/javascript">window.name='Java-DOM-API-for-XMLType'</script><script type="text/javascript">
    function footdisplay(footnum,footnote) {
    var msg = window.open('about:blank', 'NewWindow' + footnum,
        'directories=no,height=100,location=no,menubar=no,resizable=yes,' +
        'scrollbars=yes,status=no,toolbar=no,width=598');
    msg.document.open('text/html');
    msg.document.write('<!DOCTYPE html ');
    msg.document.write('PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" ');
    msg.document.write('"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">'); 
    msg.document.write('<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us" dir="ltr"><head><title>');
   
    msg.document.write('Footnote&nbsp; ' + footnum);
    msg.document.write('<\/title><meta http-equiv="Content-Type" ');
    msg.document.write('content="text/html; charset=utf-8" />');
    msg.document.write('<meta http-equiv="Content-Script-Type" ');
    msg.document.write('content="text/javascript" />');
    msg.document.write('<style type="text/css"> <![CDATA[ ');
    msg.document.write('h1 {text-align: center; font-size: 14pt;}');
    msg.document.write('fieldset {border: none;}');
    msg.document.write('form {text-align: center;}');
    msg.document.write(' ]]u003e </style>');
    msg.document.write('<\/head><body><div id="footnote"><h1>Footnote&nbsp; ' + footnum + '<\/h1><p>');
    msg.document.write(footnote);
    msg.document.write('<\/p><form action="" method="post"><fieldset>');
    msg.document.write('<input type="button" value="OK" ');
    msg.document.write('onclick="window.close();" />');
    msg.document.write('<\/fieldset><\/form><\/div><\/body><\/html>');
    msg.document.close();
    setTimeout(function() {
        var height = msg.document.getElementById('footnote').offsetHeight;
        msg.resizeTo(598, height + 100);
    }
    , 100);
    msg.focus();
}
            </script><noscript>
               <p>此页面上的脚本内容仅用于导航目的，不会以任何方式更改内容。</p>
            </noscript>
            <div>
               <p><code class="codeph">XMLType</code>的Java DOM API允许您使用DOM操作<code class="codeph">XMLType</code>实例。您可以使用它来操作Java中的XML数据，包括通过Java数据库连接（JDBC）获取它。
               </p>
               <div class="section"></div>
               <!-- class="section" -->
            </div>
            <div>
               <ul class="ullinks">
                  <li class="ulchildlink"><a href="Java-DOM-API-for-XMLType.html#GUID-353F087D-90D2-4337-B346-342E002FED36">XMLType的Java DOM API概述</a><br>Oracle XML DB支持<code class="codeph">XMLType</code>的Java文档对象模型（DOM）应用程序接口（API）。对于基于XML模式和非基于模式的文档，这是客户端和服务器的通用API。
                  </li>
                  <li class="ulchildlink"><a href="Java-DOM-API-for-XMLType.html#GUID-225EFCBA-435C-4461-A3A1-54FC14AFF530">使用JDBC访问XMLType数据</a><br>Java数据库连接（JDBC）是一种基于SQL的方法，用于Java应用程序访问Oracle数据库中的任何数据，包括Oracle XML DB中的XML文档。</li>
                  <li class="ulchildlink"><a href="Java-DOM-API-for-XMLType.html#GUID-2F228754-D548-44F2-8C09-7DFAB1793799">使用JDBC操作XML数据库文档</a><br>您可以使用Java数据库连接（JDBC）与Oracle XML DB更新，插入和删除存储在数据库中的<code class="codeph">XMLType</code>数据。</li>
                  <li class="ulchildlink"><a href="Java-DOM-API-for-XMLType.html#GUID-B41ECF30-93FD-43D2-9F12-649890E68C52">使用JDBC将大型XML文档加载到数据库中</a><br>要使用Java Database Connectivity（JDBC）将大型XML文档加载到数据库中，请使用Java <code class="codeph">CLOB</code>对象来保存文档，并使用Java方法<code class="codeph">insertXML()</code>来执行插入。
                  </li>
                  <li class="ulchildlink"><a href="Java-DOM-API-for-XMLType.html#GUID-AB51C56E-03E8-4B86-8D99-7C59E35F3DAF">具有粗连接的Java DOM API的MS Windows Java安全管理器权限</a><br>如果在MS Windows上使用Java安全管理器（类<code class="codeph">SecurityManager</code> ）为应用程序实现安全策略，则必须向安全策略文件添加某些权限，以便使用具有粗连接的<code class="codeph">XMLType</code> API for <code class="codeph">XMLType</code> 。
                  </li>
                  <li class="ulchildlink"><a href="Java-DOM-API-for-XMLType.html#GUID-7C93723D-5D83-4444-BD06-216BECAE4983">创建基于XML模式的文档</a><br>要创建基于XML模式的文档， <code class="codeph">XMLType</code> Java DOM API使用扩展来指定要使用的XML模式URL。它还验证正在创建的DOM是否符合指定的XML模式，即在适当的文档下插入适当的子项。
                  </li>
                  <li class="ulchildlink"><a href="Java-DOM-API-for-XMLType.html#GUID-71138EC1-A710-4557-91C0-7CEBE4BD90B5">Java中的XMLType实例表示（JDBC或SQLJ）</a><br><code class="codeph">XMLType</code>实例由Java表示为<code class="codeph">oracle.xdb.XMLType</code> 。使用JDBC或SQLJ客户端获取<code class="codeph">XMLType</code>实例时，它会自动显示为提供的<code class="codeph">XMLType</code>类的对象。
                  </li>
                  <li class="ulchildlink"><a href="Java-DOM-API-for-XMLType.html#GUID-6144192C-114A-4120-B117-D7FB6B871CDE">XMLType的Java DOM API类</a><br>Oracle XML DB支持W3C DOM Level 2 Recommendation。它还提供特定于Oracle的扩展，以便于您的应用程序与Oracle XML Developer的Java Kit连接。<code class="codeph">XMLType</code>的Java DOM API提供了实现W3C DOM接口的类。
                  </li>
                  <li class="ulchildlink"><a href="Java-DOM-API-for-XMLType.html#GUID-F5F719CF-F383-4677-A655-6329C1E462FA">使用Java DOM API for XMLType</a><br>从<code class="codeph">XMLType</code>表或列中检索数据，并从中获取Java <code class="codeph">XMLDocument</code>实例。使用XML DOM API for <code class="codeph">XMLType</code>数据的DOM树元素。
                  </li>
                  <li class="ulchildlink"><a href="Java-DOM-API-for-XMLType.html#GUID-292AD380-743C-4E36-BDD1-039A279006C0">使用Java进行大型XML节点处理</a><br>Oracle XML DB提供了抽象流和流操作方法，可用于处理大于64 K字节的XML节点。使用Java类<code class="codeph">XMLNode</code>和<code class="codeph">XMLAttr</code>以及thick或kprb连接来操作大型节点。
                  </li>
                  <li class="ulchildlink"><a href="Java-DOM-API-for-XMLType.html#GUID-1234728D-0732-4DC6-82EF-9D372702061F">将Java DOM API和JDBC与二进制XML一起使用</a><br>您可以使用Java DOM API进行XML和Java数据库连接（JDBC）来读取或写入从Oracle XML DB编码为二进制XML的XML数据。这样做涉及通常的读写程序。
                  </li>
               </ul>
               <div class="relinfo">
                  <p><strong>相关话题</strong></p>
                  <ul>
                     <li><a href="query-and-update-XML.html#GUID-8F3B9C09-6877-4E43-A6E7-873BF0E74DAB" title="XQuery API for Java（XQJ），也称为JSR-225，为Java程序使用XQuery访问XML数据提供了行业标准方法。它允许您根据XML数据源评估XQuery表达式，并将结果作为XML数据处理。">使用XQuery与XQJ访问数据库数据</a></li>
                  </ul>
               </div>
               <div class="familylinks">
                  <div class="parentlink">
                     <p><strong>父主题：</strong> <a href="XMLType-APIs.html#GUID-6209297F-DBE4-4F31-85F1-4083BF5BDE01" title="您可以使用Oracle XML DB XMLType PL / SQL，Java，C API和Oracle Data Provider for .NET（ODP.NET）来访问和操作XML数据。">XMLType API</a></p>
                  </div>
               </div>
            </div>
            <a id="ADXDB4931"></a><div class="props_rev_3"><a id="GUID-353F087D-90D2-4337-B346-342E002FED36" name="GUID-353F087D-90D2-4337-B346-342E002FED36"></a><h3 id="ADXDB-GUID-353F087D-90D2-4337-B346-342E002FED36" class="sect3"><span class="enumeration_section">13.1</span> XMLType的Java DOM API概述</h3>
               <div>
                  <p>Oracle XML DB支持<code class="codeph">XMLType</code>的Java文档对象模型（DOM）应用程序接口（API）。对于基于XML模式和非基于模式的文档，这是客户端和服务器的通用API。
                  </p>
                  <p>DOM是动态内存中XML文档的基于树的对象表示，它允许以编程方式访问其元素和属性。DOM对象和接口是W3C推荐的一部分。如<a href="PLSQL-APIs-for-XMLType.html#GUID-2D5B2D47-9CFF-49D0-9BD8-114BBE48A289" title="有几个PL / SQL包为XMLType提供API。">针对XMLType的PL / SQL API中</a>所讨论的，Oracle XML DB DOM API符合W3C DOM Level 1.0和Level 2.0 Core Recommendation。
                  </p>
                  <p><code class="codeph">XMLType</code>的Java DOM API处理存储在Oracle XML DB中的所有格式良好的XML文档。它提供了XML文档的统一视图，无论是基于XML模式还是基于非模式，以及基础<code class="codeph">XMLType</code>存储模型。Java DOM API适用于客户端和服务器。
                  </p>
                  <p><code class="codeph">XMLType</code>的Java DOM API可用于从以不同字符集编码的数据构造<code class="codeph">XMLType</code>实例。
                  </p>
                  <p>您可以使用Java DOM API for <code class="codeph">XMLType</code>从Java应用程序访问存储在Oracle XML DB Repository中的XML文档。命名符合W3C DOM Recommendation规定的DOM的Java绑定。存储库可以包含基于XML模式和非基于模式的文档。
                  </p>
                  <p>要使用JDBC访问<code class="codeph">XMLType</code>数据，请使用类<code class="codeph">oracle.xdb.XMLType</code> 。
                  </p>
                  <p><code class="codeph">XMLType</code>的Java DOM API是使用Java包<code class="codeph">oracle.xml.parser.v2</code> 。
                  </p>
               </div>
               <div>
                  <div class="infoboxnotealso" id="GUID-353F087D-90D2-4337-B346-342E002FED36__GUID-7FDBC05D-9534-4E94-9AE2-CD0DE91D2B10">
                     <p class="notep1">也可以看看：</p>
                     <p><a href="../jaxml/index.html" target="_blank"><span><cite>Oracle数据库XML Java API参考</cite></span></a></p>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="Java-DOM-API-for-XMLType.html#GUID-4C510052-8A31-4917-8567-0E2825927C54" title="XMLType的Java DOM API允许您使用DOM操作XMLType实例。您可以使用它来操作Java中的XML数据，包括通过Java数据库连接（JDBC）获取它。">XMLType的Java DOM API</a></p>
                     </div>
                  </div>
               </div>
               
            </div><a id="ADXDB4933"></a><div class="props_rev_3"><a id="GUID-225EFCBA-435C-4461-A3A1-54FC14AFF530" name="GUID-225EFCBA-435C-4461-A3A1-54FC14AFF530"></a><h3 id="ADXDB-GUID-225EFCBA-435C-4461-A3A1-54FC14AFF530" class="sect3"><span class="enumeration_section">13.2</span>使用JDBC访问XMLType数据</h3>
               <div>
                  <p>Java数据库连接（JDBC）是一种基于SQL的方法，用于Java应用程序访问Oracle数据库中的任何数据，包括Oracle XML DB中的XML文档。</p>
                  <p>您使用Java类<code class="codeph">oracle.xdb.XMLType</code>或Java接口<code class="codeph">java.sql.SQLXML</code>用于创建XML数据。
                  </p>
                  <p>XML数据的JDBC 4.0标准数据类型是<code class="codeph">java.sql.SQLXML</code> 。方法<code class="codeph">getObject()</code>返回<code class="codeph">oracle.xdb.类型的对象<code class="codeph">oracle.xdb.XMLType</code> 。从Oracle Database 11g第2版（11.2.0.3）开始，oracle.xdb <code class="codeph">oracle.xdb.XMLType</code>实现接口<code class="codeph">java.sql.SQLXML</code> 。</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="Java-DOM-API-for-XMLType.html#GUID-01FFCF6C-0197-417E-B1E6-6CF2FF770179">使用JDBC访问Oracle XML DB中的XML文档</a><br>JDBC用户可以查询<code class="codeph">XMLType</code>表以获取JDBC <code class="codeph">XMLType</code>接口，该接口支持SQL数据类型<code class="codeph">XMLType</code>支持的所有SQL / XML函数。<code class="codeph">XMLType</code>接口的Java（JDBC）API可以实现DOM文档接口。
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="Java-DOM-API-for-XMLType.html#GUID-4C510052-8A31-4917-8567-0E2825927C54" title="XMLType的Java DOM API允许您使用DOM操作XMLType实例。您可以使用它来操作Java中的XML数据，包括通过Java数据库连接（JDBC）获取它。">XMLType的Java DOM API</a></p>
                     </div>
                  </div>
               </div>
               <a id="ADXDB4935"></a><a id="ADXDB5887"></a><a id="ADXDB4937"></a><a id="ADXDB4938"></a><a id="ADXDB4934"></a><div class="props_rev_3"><a id="GUID-01FFCF6C-0197-417E-B1E6-6CF2FF770179" name="GUID-01FFCF6C-0197-417E-B1E6-6CF2FF770179"></a><h4 id="ADXDB-GUID-01FFCF6C-0197-417E-B1E6-6CF2FF770179" class="sect4"><span class="enumeration_section">13.2.1</span>使用JDBC访问Oracle XML DB中的XML文档</h4>
                  <div>
                     <p>JDBC用户可以查询<code class="codeph">XMLType</code>表以获取JDBC <code class="codeph">XMLType</code>接口，该接口支持SQL数据类型<code class="codeph">XMLType</code>支持的所有SQL / XML函数。<code class="codeph">XMLType</code>接口的Java（JDBC）API可以实现DOM文档接口。
                     </p>
                     <div class="section">
                        <p><a href="Java-DOM-API-for-XMLType.html#GUID-01FFCF6C-0197-417E-B1E6-6CF2FF770179__CHDHEGED">例13-1</a>说明了如何使用JDBC查询<code class="codeph">XMLType</code>表。
                        </p>
                        <p>您可以使用JDBC以下列任何方式选择<code class="codeph">XMLType</code>数据：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p>在SQL中使用SQL / XML函数<code class="codeph">XMLSerialize</code> ，并以<code class="codeph">oracle.jdbc.获取结果<code class="codeph">oracle.jdbc.OracleClob</code>或<code class="codeph">java.lang.Java中的String</code>实例。<a href="Java-DOM-API-for-XMLType.html#GUID-01FFCF6C-0197-417E-B1E6-6CF2FF770179__CHDGIDFE">例13-2中</a>的Java代码段说明了这一点。
                              </p>
                           </li>
                           <li>
                              <p>在<code class="codeph">ResultSet</code>调用方法<code class="codeph">getSQLXML()</code>以获取整个<code class="codeph">SQLXML</code>实例。此方法的返回值是<code class="codeph">java.sql.类型<code class="codeph">java.sql.SQLXML</code> 。然后，您可以在接口<code class="codeph">SQLXML</code>使用Java方法来访问数据。<a href="Java-DOM-API-for-XMLType.html#GUID-01FFCF6C-0197-417E-B1E6-6CF2FF770179__CHDJJHCE">例13-3</a>显示了如何执行此操作。
                              </p>
                           </li>
                        </ul>
                        <p><a href="Java-DOM-API-for-XMLType.html#GUID-01FFCF6C-0197-417E-B1E6-6CF2FF770179__CHDJJHCE">例13-3</a>显示了使用方法<code class="codeph">getObject()</code>直接从<code class="codeph">ResultSet</code>获取<code class="codeph">XMLType</code>实例。
                        </p>
                        <p><a href="Java-DOM-API-for-XMLType.html#GUID-01FFCF6C-0197-417E-B1E6-6CF2FF770179__CHDGFDCD">例13-4</a>显示了如何将<code class="codeph">XMLType</code>类型的输出参数绑定到SQL语句。输出参数注册为具有数据类型<code class="codeph">XMLType</code> 。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-01FFCF6C-0197-417E-B1E6-6CF2FF770179__CHDHEGED">
                        <p class="titleinexample">示例13-1使用JDBC查询XMLType表</p><pre class="pre codeblock"><code>PreparedStatement statement = connection.prepareStatement（“SELECT e.poDoc FROM po_xml_tab e”）; ResultSet resultSet = statement.executeQuery（）; while（resultSet.next（））{//获取结果作为SQLXML数据。//使用它来获取DomSource实例。SQLXML sqlXml = resultSet。 <span class="bold">getSQLXML</span> （1）; DomSource source = sqlXml。 <span class="bold">getSource</span> （DOMSource.class）; //从DomSource实例获取文档作为DOM节点。文件文件=（文件）来源。 <span class="bold">getNode</span> （）; //使用文档对象...}</code></pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-01FFCF6C-0197-417E-B1E6-6CF2FF770179__CHDGIDFE">
                        <p class="titleinexample">示例13-2使用getString（）和getCLOB（）选择XMLType数据</p><pre class="pre codeblock"><code>PreparedStatement statement = connection.prepareStatement（“SELECT <span class="bold">XMLSerialize</span> （DOCUMENT e.poDoc <span class="bold">AS CLOB</span> ）poDoc，”+“ <span class="bold">XMLSerialize</span> （DOCUMENT e.poDoc <span class="bold">AS VARCHAR2（2000）</span> ）poString”+“FROM po_xml_tab e”）; ResultSet resultSet = statement.executeQuery（）; while（resultSet.next（））{//第一个结果是OracleClob实例<span class="bold">OracleClob</span> clob = resultSet。 <span class="bold">getClob</span> （1））; //第二个结果是String实例String poString = resultSet。 <span class="bold">getString</span> （2）; //使用clob和poString ......}</code></pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-01FFCF6C-0197-417E-B1E6-6CF2FF770179__CHDJJHCE">
                        <p class="titleinexample">示例13-3使用getSQLXML（）返回XMLType数据</p><pre class="pre codeblock"><code>PreparedStatement statement = connection.prepareStatement（“SELECT e.poDoc FROM po_xml_tab e”）; ResultSet resultSet = statement.executeQuery（）; while（resultSet.next（））{//获取SQLXML SQLXML sqlXml = resultSet。 <span class="bold">getSQLXML</span> （1）; //将SQLXML转换为xmlString实例String xmlString = sqlXml。 <span class="bold">getString</span> （）; //使用xmlString实例...}</code></pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-01FFCF6C-0197-417E-B1E6-6CF2FF770179__CHDGFDCD">
                        <p class="titleinexample">示例13-4使用输出参数返回XMLType数据</p><pre class="pre codeblock"><code>public void doCall（String [] args）throws Exception {// CREATE OR REPLACE FUNCTION getPurchaseOrder（reference VARCHAR2）// RETURN XMLTYPE // AS // xml XMLTYPE; // BEGIN // SELECT OBJECT_VALUE INTO xml // FROM purchaseorder // WHERE XMLCast（XMLQuery（'$ p / PurchaseOrder / Reference'// PASSING OBJECT_VALUE AS“p”RETURNING CONTENT）// AS VARCHAR2（30））// =参考; // RETURN xml; // 结束;字符串SQLTEXT =“{？= call getPurchaseOrder（'BLAKE-2002100912333601PDT'）}“; super.doSomething（args）; createConnection（）; try {System.out.println（”SQL：=“+ SQLTEXT）; CallableStatement sqlStatement = getConnection（）。prepareCall（ SQLTEXT）;的SQLStatement <span class="bold">的registerOutParameter（1，java.sql</span>中。类型。SQLXML）; sqlStatement.execute（）; SQLXML sqlXml = sqlStatement。 <span class="bold">getSQLXML</span> （1）;的System.out.println（SQLXML <span class="bold">的getString（））;</span> } catch（SQLException异常）{if（sqlStatement！= null）{sqlStatement.close（）;抛出异常; }}}</code></pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="Java-DOM-API-for-XMLType.html#GUID-225EFCBA-435C-4461-A3A1-54FC14AFF530" title="Java数据库连接（JDBC）是一种基于SQL的方法，用于Java应用程序访问Oracle数据库中的任何数据，包括Oracle XML DB中的XML文档。">使用JDBC访问XMLType数据</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div><a id="ADXDB5889"></a><a id="ADXDB5890"></a><a id="ADXDB4941"></a><a id="ADXDB4942"></a><a id="ADXDB5891"></a><a id="ADXDB5892"></a><a id="ADXDB4939"></a><div class="props_rev_3"><a id="GUID-2F228754-D548-44F2-8C09-7DFAB1793799" name="GUID-2F228754-D548-44F2-8C09-7DFAB1793799"></a><h3 id="ADXDB-GUID-2F228754-D548-44F2-8C09-7DFAB1793799" class="sect3"><span class="enumeration_section">13.3</span>使用JDBC操作XML数据库文档</h3>
               <div>
                  <p>您可以使用Java数据库连接（JDBC）与Oracle XML DB更新，插入和删除存储在数据库中的<code class="codeph">XMLType</code>数据。</p>
                  <div class="section">
                     <div class="infoboxnote" id="GUID-2F228754-D548-44F2-8C09-7DFAB1793799__GUID-6BBA39E0-1407-4055-A108-5DBEB6E92930">
                        <p class="notep1">注意：</p>
                        <p><code class="codeph">XMLType</code>方法<code class="codeph">transform()</code>仅适用于OCI驱动程序。
                        </p>
                        <p>不是所有的<code class="codeph">oracle.xdb.瘦JDBC驱动程序支持XMLType</code>函数。如果你不使用<code class="codeph">oracle.xdb.XMLType</code>类和OCI驱动程序可能会失去与XML的智能处理相关的性能优势。</p>
                     </div>
                     <p>您可以通过以下任一方式更新，插入或删除<code class="codeph">XMLType</code>数据：</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <ul style="list-style-type:disc">
                        <li>
                           <p>将字符串绑定到<code class="codeph">INSERT</code> ， <code class="codeph">UPDATE</code>或<code class="codeph">DELETE</code>语句，并使用SQL中的<code class="codeph">XMLType</code>构造函数构造XML实例。<a href="Java-DOM-API-for-XMLType.html#GUID-2F228754-D548-44F2-8C09-7DFAB1793799__CHDJFABC">例13-5</a>说明了这一点。
                           </p>
                        </li>
                        <li>
                           <p>在<code class="codeph">PreparedStatement</code>实例中使用<code class="codeph">setSQLXML()</code>来设置整个<code class="codeph">XMLType</code>实例。<a href="Java-DOM-API-for-XMLType.html#GUID-2F228754-D548-44F2-8C09-7DFAB1793799__CHDJBADD">例13-6</a>说明了这一点。
                           </p>
                        </li>
                     </ul>
                     <p>选择<code class="codeph">SQLXML</code>值时，JDBC将该列描述为<code class="codeph">SQLXML</code> 。您可以选择列类型名称并将其与<code class="codeph">SQLXML</code>进行比较，以查看您是否正在处理<code class="codeph">SQLXML</code>实例。<a href="Java-DOM-API-for-XMLType.html#GUID-2F228754-D548-44F2-8C09-7DFAB1793799__I1031938">例13-7</a>说明了这一点。
                     </p>
                     <p><a href="Java-DOM-API-for-XMLType.html#GUID-2F228754-D548-44F2-8C09-7DFAB1793799__I1031963">示例13-8</a>更新存储在<code class="codeph">XMLType</code>列中的元素<code class="codeph">PurchaseOrder</code>内的元素<code class="codeph">discount</code> 。它使用JDBC和<code class="codeph">SQLXML</code> 。它使用XML解析器更新DOM树并将更新的XML值写入<code class="codeph">XMLType</code>列。
                     </p>
                     <p><a href="Java-DOM-API-for-XMLType.html#GUID-2F228754-D548-44F2-8C09-7DFAB1793799__CHDBDGFB">例13-9</a>显示了由<a href="Java-DOM-API-for-XMLType.html#GUID-2F228754-D548-44F2-8C09-7DFAB1793799__I1031963">例13-8</a>产生的更新的采购订单。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-2F228754-D548-44F2-8C09-7DFAB1793799__CHDJFABC">
                     <p class="titleinexample">示例13-5使用SQL构造函数XMLType和Java String更新XMLType列</p><pre class="pre codeblock"><code>PreparedStatement statement = connection.prepareStatement（“UPDATE po_xml_tab SET poDoc = <span class="bold">XMLType</span> （？）“）;字符串poString =”&lt;PO&gt; &lt;PONO&gt; 200 &lt;/ PONO&gt; &lt;PNAME&gt; PO_2 &lt;/ PNAME&gt; &lt;/ PO&gt;“; //绑定字符串statement.setString（1，poString）; statement.execute（ ）;</code></pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-2F228754-D548-44F2-8C09-7DFAB1793799__CHDJBADD">
                     <p class="titleinexample">示例13-6使用SQLXML更新XMLType列</p><pre class="pre codeblock"><code>PreparedStatement statement = connection.prepareStatement（“UPDATE po_xml_tab SET poDoc =？“）;字符串xmlString =”&lt;PO&gt; &lt;PONO&gt; 200 &lt;/ PONO&gt; &lt;PNAME&gt; PO_2 &lt;/ PNAME&gt; &lt;/ PO&gt;“; SQLXML sqlXml = connection.createSQLXML（）; sqlXml.setString（xmlString）; //绑定SQLXML声明<span class="bold">setSQLXML（1，SQLXML）;</span>的Statement.execute（）;</code></pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-2F228754-D548-44F2-8C09-7DFAB1793799__I1031938">
                     <p class="titleinexample">示例13-7使用JDBC检索关于XMLType列的元数据</p><pre class="pre codeblock"><code>PreparedStatement statement = connection.prepareStatement（“SELECT poDoc FROM po_xml_tab”）; ResultSet resultSet = statement.executeQuery（）; //获取resultSet元数据ResultSetMetaData mdata =（ResultSetMetaData）resultSet。 <span class="bold">getMetaData</span> （）; //列类型为SQLXML if（mdata.getColumnType（1）== java.sql。类型。SQLXML）{//它是一个SQLXML实例}</code></pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-2F228754-D548-44F2-8C09-7DFAB1793799__I1031963">
                     <p class="titleinexample">示例13-8使用JDBC更新XMLType列</p><pre class="pre codeblock"><code>public class UpdateXMLType {static String qryStr =“SELECT x.poDoc from po_xml_tab x”+“WHERE XMLCast（XMLQuery（'/ PO / PONO / text（）'”+“PASSING x.poDoc RETURNING CONTENT）”+“AS NUMBER” “+”= 200“; static String updateXML（String xmlTypeStr）{System.out.println（“\ n ===============================”） ;的System.out.println（xmlTypeStr）;的System.out.println（ “===============================”）; String outXML = null; try {DOMParser parser = new DOMParser（）; parser.setValidationMode（假）; parser.setPreserveWhitespace（true）; parser.parse（new StringReader（xmlTypeStr））; System.out.println（“XML字符串格式正确”）; XMLDocument document = parser.getDocument（）; NodeList nl = document.getElementsByTagName（“ <span class="bold">DISCOUNT</span> ”）; for（int i = 0; i &lt;nl.getLength（）; i ++）{XMLElement discount =（XMLElement）nl.item（i）; XMLNode textNode =（XMLNode）discount.getFirstChild（）; textNode.setNodeValue（ “10”）; } StringWriter sw = new StringWriter（）; document.print（new PrintWriter（sw））; outXML = sw.toString（）; //打印修改后的xml System.out.println（“\ n ===============================”）; System.out.println（“Updated PurchaseOrder：”）;的System.out.println（outXML）;的System.out.println（ “===============================”）; } catch（Exception e）{e.printStackTrace（System.out）; } return outXML; public static void main（String args []）throws Exception {try {PreparedStatement statement = connection.createStatement（）; ResultSet resultSet = statement.executeQuery（qryStr）; while（orset.next（））{//从数据库中检索PurchaseOrder xml文件SQLXML sqlXml = resultSet.getSQLXML（1）; //将此PurchaseOrder存储在po_xml_hist表语句中= connection.prepareStatement（“INSERT INTO po_xml_hist VALUES（？）“）; statement.setSQLXML（1，sqlXml）; //绑定SQLXML实例statement.execute（）; //更新”DISCOUNT“元素字符串newXML = updateXML（sqlXml.getString（））; //创建一个新的实例来自更新值的XMLtype SQLXML sqlXml2 = connection.createSQLXML（）; sqlXml2.setString（newXml）; //更新数据库中的PurchaseOrder xml文档语句= connection.prepareStatement（“UPDATE po_xml_tab x SET x.poDoc =？WHERE“+”XMLCast（XMLQuery（'/ PO / PONO / text（）'“+”PASSING value（xmltab）RETURNING CONTENT）“+”AS NUMBER）“+”= 200“）; statement.setSQLXML（1，sqlXml2 ）; //绑定XMLType实例statement.execute（）; connection.commit（）; System.out.println（“PurchaseOrder 200已更新！“）;} //删除PurchaseOrder 1001 statement.execute（”DELETE FROM po_xml x WHERE“+”XMLCast（XMLQuery（'/ PurchaseOrder / PONO / text（）'“+”PASSING value（xmltab）RETURNING CONTENT）“+” AS NUMBER）“+”= 1001“）; System.out.println（”PurchaseOrder 1001已删除！“）;} catch（例外e）{e.printStackTrace（System.out）;}}}</code></pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-2F228754-D548-44F2-8C09-7DFAB1793799__CHDBDGFB">
                     <p class="titleinexample">示例13-9更新的采购订单凭证</p><pre class="pre codeblock"><code>&lt;？xml版本=“1.0”？&gt; &lt;PurchaseOrder&gt; &lt;PONO&gt; 200 &lt;/ PONO&gt; &lt;CUSTOMER&gt; &lt;CUSTNO&gt; 2 &lt;/ CUSTNO&gt; &lt;CUSTNAME&gt; John Nike &lt;/ CUSTNAME&gt; &lt;ADDRESS&gt; &lt;STREET&gt; 323 College Drive &lt;/ STREET&gt; &lt;CITY&gt; Edison &lt; / CITY&gt; &lt;STATE&gt; NJ &lt;/ STATE&gt; &lt;ZIP&gt; 08820 &lt;/ ZIP&gt; &lt;/ ADDRESS&gt; &lt;PHONELIST&gt; &lt;VARCHAR2&gt; 609-555-1212 &lt;/ VARCHAR2&gt; &lt;VARCHAR2&gt; 201-555-1212 &lt;/ VARCHAR2&gt; &lt;/ PHONELIST&gt; &lt;/ CUSTOMER&gt; &lt;ORDERDATE&gt; 20-APR-97 &lt;/ ORDERDATE&gt; &lt;SHIPDATE&gt; 20-MAY-97 12.00.00.000000 AM &lt;/ SHIPDATE&gt; &lt;LINEITEMS&gt; &lt;LINEITEM_TYP LineItemNo =“1”&gt; &lt;ITEM StockNo =“1004”&gt; &lt;PRICE&gt; 6750 &lt;/ PRICE&gt; &lt;TAXRATE&gt; 2 &lt;/ TAXRATE&gt; &lt;/ ITEM&gt; &lt;QUANTITY&gt; 1 &lt;/ QUANTITY&gt; <span class="bold">&lt;DISCOUNT&gt; 10 &lt;/ DISCOUNT&gt;</span> &lt;/ LINEITEM_TYP&gt; &lt;LINEITEM_TYP LineItemNo =“ 2“&gt; &lt;ITEM StockNo =”1011“&gt; &lt;PRICE&gt; 4500.23 &lt;/ PRICE&gt; &lt;TAXRATE&gt; 2 &lt;/ TAXRATE&gt; &lt;/ ITEM&gt; &lt;QUANTITY&gt; 2 &lt;/ QUANTITY&gt; <span class="bold">&lt;DISCOUNT&gt; 10 &lt;/ DISCOUNT&gt;</span> &lt;/ LINEITEM_TYP &gt; &lt;/ LINEITEMS&gt; &lt;SHIPTOADDR&gt; &lt;STREET&gt; 55 Madison Ave &lt;/ STREET&gt; &lt;CITY&gt; Madison &lt;/ CITY&gt; &lt;STATE&gt; WI &lt;/ STATE&gt; &lt;ZIP&gt; 53715 &lt;/ ZIP&gt; &lt;/ SHIPTOADDR&gt; &lt;/ PurchaseOrder&gt;</code></pre></div>
                  <!-- class="example" -->
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="Java-DOM-API-for-XMLType.html#GUID-4C510052-8A31-4917-8567-0E2825927C54" title="XMLType的Java DOM API允许您使用DOM操作XMLType实例。您可以使用它来操作Java中的XML数据，包括通过Java数据库连接（JDBC）获取它。">XMLType的Java DOM API</a></p>
                     </div>
                  </div>
               </div>
               
            </div><a id="ADXDB5893"></a><a id="ADXDB5894"></a><a id="ADXDB4944"></a><div class="props_rev_3"><a id="GUID-B41ECF30-93FD-43D2-9F12-649890E68C52" name="GUID-B41ECF30-93FD-43D2-9F12-649890E68C52"></a><h3 id="ADXDB-GUID-B41ECF30-93FD-43D2-9F12-649890E68C52" class="sect3"><span class="enumeration_section">13.4</span>使用JDBC将大型XML文档加载到数据库中</h3>
               <div>
                  <p>要使用Java Database Connectivity（JDBC）将大型XML文档加载到数据库中，请使用Java <code class="codeph">CLOB</code>对象来保存文档，并使用Java方法<code class="codeph">insertXML()</code>来执行插入。
                  </p>
                  <div class="section">
                     <p>如果使用JDBC中的<code class="codeph">String</code>对象将大型XML文档（通常大于4000个字符）插入<code class="codeph">XMLType</code>表或列，则会发生此运行时错误：</p><pre class="oac_no_warn" dir="ltr">“java.sql中。SQLException：此类型的数据大小大于最大大小“</pre><p>使用Java <code class="codeph">OracleClob</code>对象来保存大型XML文档可以避免此错误。<a href="Java-DOM-API-for-XMLType.html#GUID-B41ECF30-93FD-43D2-9F12-649890E68C52__CHDCHFIG">例13-10</a>显示了使用这种技术的代码。它定义了<code class="codeph">XMLType</code>方法<code class="codeph">insertXML()</code> ，它可用于将大型XML文档插入到表<code class="codeph">poTable</code> <code class="codeph">XMLType</code>列<code class="codeph">purchaseOrder</code>中。可以对<code class="codeph">XMLType</code>表使用相同的方法。
                     </p>
                     <p>方法<code class="codeph">insertXML()</code>使用包含XML文档的<code class="codeph">OracleClob</code>对象。接口<code class="codeph">OracleClob</code>是标准JDBC接口<code class="codeph">java.sql.的子接口<code class="codeph">java.sql.Clob</code> 。方法<code class="codeph">insertXML()</code>将<code class="codeph">OracleClob</code>对象绑定到JDBC <code class="codeph">insertXML()</code>准备语句，该语句将数据插入<code class="codeph">XMLType</code>列。
                     </p>
                     <p>使用<code class="codeph">insertXML()</code>的先决条件如下：</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <ul style="list-style-type:disc">
                        <li>
                           <p>Oracle数据库，版本9.2.0.1或更高版本。</p>
                        </li>
                        <li>
                           <p>目标数据库表。在运行示例之前执行以下SQL：</p>
                           <p><code class="codeph">CREATE TABLE poTable（purchaseOrder XMLType）;</code></p>
                        </li>
                     </ul>
                     <p><code class="codeph">XMLType</code>方法<code class="codeph">insertXML()</code>的形式参数如下：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><span class="italic"><code class="codeph">xmlString</code></span> - 要插入<code class="codeph">XMLType</code>列的XML数据</p>
                        </li>
                        <li>
                           <p><span class="italic"><code class="codeph">connection</code></span> - 数据库连接对象（Oracle连接对象）</p>
                        </li>
                     </ul>
                     <p>Java方法<code class="codeph">insertXML()</code>调用方法<code class="codeph">getCLOB()</code>来创建并返回保存XML数据的<code class="codeph">CLOB</code>对象。<a href="Java-DOM-API-for-XMLType.html#GUID-B41ECF30-93FD-43D2-9F12-649890E68C52__CHDFFDJH">例13-11中</a>定义的方法<code class="codeph">getCLOB()</code>的形式参数如下：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><span class="italic"><code class="codeph">xmlString</code></span> - 要插入<code class="codeph">XMLType</code>列的XML数据</p>
                        </li>
                        <li>
                           <p><span class="italic"><code class="codeph">connection</code></span> - 数据库连接对象（Oracle连接对象）</p>
                        </li>
                     </ul>
                     <div class="infoboxnotealso" id="GUID-B41ECF30-93FD-43D2-9F12-649890E68C52__GUID-853A0A6C-0A7D-41F8-AD92-FF2658A0AE06">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="../adlob/overview-of-supplied-LOB-APIs.html#ADLOB45482" target="_blank"><span><cite>Oracle Database SecureFiles和大对象开发人员指南</cite></span></a></p>
                     </div>
                  </div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-B41ECF30-93FD-43D2-9F12-649890E68C52__CHDCHFIG">
                     <p class="titleinexample">示例13-10使用JDBC插入XMLType列</p><pre class="oac_no_warn" dir="ltr">private void <span class="bold">insertXML</span> （Connection connection，String xmlString）{OracleClob clob = null; try {String query =“INSERT INTO potable（purchaseOrder）VALUES（XMLType（？））“; //获取语句Object PreparedStatement statement = connection.prepareStatement（query）; //从xmlString获取OracleClob实例clob = <span class="bold">getOracleClob</span> （connection，xmlString）; statement.setObject（1，clob）; //执行预准备语句if（statement.executeUpdate（）== 1）{System.out.println（“成功插入采购订单”）;}} catch（Exception exp）{exp.printStackTrace（）;} finally {if（clob！= null）clob.close（）; }}</pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-B41ECF30-93FD-43D2-9F12-649890E68C52__CHDFFDJH">
                     <p class="titleinexample">示例13-11将XML字符串转换为OracleClob实例</p><pre class="oac_no_warn" dir="ltr">private OracleClob <span class="bold">getOracleClob</span> （Connection connection，String xmlString）抛出SQLException {OracleClob clob =（OracleClob）connection.createClob（）; clob.setString（1，xmlString）;回归}</pre></div>
                  <!-- class="example" -->
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="Java-DOM-API-for-XMLType.html#GUID-4C510052-8A31-4917-8567-0E2825927C54" title="XMLType的Java DOM API允许您使用DOM操作XMLType实例。您可以使用它来操作Java中的XML数据，包括通过Java数据库连接（JDBC）获取它。">XMLType的Java DOM API</a></p>
                     </div>
                  </div>
               </div>
               
            </div><a id="ADXDB6347"></a><a id="ADXDB6346"></a><div class="props_rev_3"><a id="GUID-AB51C56E-03E8-4B86-8D99-7C59E35F3DAF" name="GUID-AB51C56E-03E8-4B86-8D99-7C59E35F3DAF"></a><h3 id="ADXDB-GUID-AB51C56E-03E8-4B86-8D99-7C59E35F3DAF" class="sect3"><span class="enumeration_section">13.5</span>具有粗连接的Java DOM API的MS Windows Java安全管理器权限</h3>
               <div>
                  <p>如果在MS Windows上使用Java安全管理器（类<code class="codeph">SecurityManager</code> ）为应用程序实现安全策略，则必须向安全策略文件添加某些权限，以便使用具有粗连接的<code class="codeph">XMLType</code> API for <code class="codeph">XMLType</code> 。
                  </p>
                  <p><a href="Java-DOM-API-for-XMLType.html#GUID-AB51C56E-03E8-4B86-8D99-7C59E35F3DAF__CACBACJG">示例13-12</a>显示了此类策略文件的内容，其中包含与Oracle XML DB相关的jar的工作空间文件夹是<code class="codeph">c:\myworkspace</code> 。（策略文件必须位于同一文件夹中。）
                  </p>
                  <p><a href="Java-DOM-API-for-XMLType.html#GUID-AB51C56E-03E8-4B86-8D99-7C59E35F3DAF__CACBACJG">实施例13-12</a>中使用的库是<code class="codeph">orageneric12</code>和<code class="codeph">oraxml12</code> 。最后两个字符（此处为<code class="codeph">12</code> ）必须与您的主要数据库版本号相对应（因此，对于Oracle Database 13 Release 2，您将使用<code class="codeph">orageneric</code> <span class="bold"><code class="codeph">13</code></span>和<code class="codeph">oraxml</code> <span class="bold"><code class="codeph">13</code></span> ）。
                  </p>
                  <p>创建策略文件后，可以使用以下命令行开关调用程序：</p><pre class="pre codeblock"><code>-Djava.security.manager = default -Djava.security.policy = c：\ myworkspace \ ojdbc.policy</code></pre><div class="example" id="GUID-AB51C56E-03E8-4B86-8D99-7C59E35F3DAF__CACBACJG">
                     <p class="titleinexample">示例13-12 Java DOM API的策略文件授予权限</p><pre class="pre codeblock"><code>grant codeBase“file： <code class="codeph">c:\myworkspace</code> ”{permission java.lang。RuntimePermission“loadLibrary.orageneric12”;权限java.lang。RuntimePermission“loadLibrary.oraxml12”; } grant codeBase“file：c：\ myworkspace \ <span class="bold">xdb6.jar</span> ”{permission java.lang。RuntimePermission“loadLibrary.orageneric12”;权限java.lang。RuntimePermission“loadLibrary.oraxml12”; } grant codeBase“file：c：\ myworkspace \ <span class="bold">ojdbc6.jar</span> ”{permission java.lang。RuntimePermission“loadLibrary.orageneric12”;权限java.lang。RuntimePermission“loadLibrary.oraxml12”; }</code></pre></div>
                  <!-- class="example" -->
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="Java-DOM-API-for-XMLType.html#GUID-4C510052-8A31-4917-8567-0E2825927C54" title="XMLType的Java DOM API允许您使用DOM操作XMLType实例。您可以使用它来操作Java中的XML数据，包括通过Java数据库连接（JDBC）获取它。">XMLType的Java DOM API</a></p>
                     </div>
                  </div>
               </div>
               
            </div><a id="ADXDB4948"></a><a id="ADXDB4947"></a><div class="props_rev_3"><a id="GUID-7C93723D-5D83-4444-BD06-216BECAE4983" name="GUID-7C93723D-5D83-4444-BD06-216BECAE4983"></a><h3 id="ADXDB-GUID-7C93723D-5D83-4444-BD06-216BECAE4983" class="sect3"><span class="enumeration_section">13.6</span>创建基于XML模式的文档</h3>
               <div>
                  <p>要创建基于XML模式的文档， <code class="codeph">XMLType</code> Java DOM API使用扩展来指定要使用的XML模式URL。它还验证正在创建的DOM是否符合指定的XML模式，即在适当的文档下插入适当的子项。
                  </p>
                  <div class="section">
                     <div class="infoboxnote" id="GUID-7C93723D-5D83-4444-BD06-216BECAE4983__GUID-28F18FFC-0830-4BFA-97ED-B50F1CF9957F">
                        <p class="notep1">注意：</p>
                        <p><code class="codeph">XMLType</code>的Java DOM API <span class="italic">不</span>执行类型和约束检查。
                        </p>
                     </div>
                     <p>创建DOM对象后，可以使用Oracle XML DB资源API将其保存到Oracle XML DB存储库。XML文档以适当的格式存储：</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <ul style="list-style-type:disc">
                        <li>
                           <p>作为非基于模式的文档的BLOB实例。</p>
                        </li>
                        <li>
                           <p>以XML模式为基于XML模式的文档指定的格式。</p>
                        </li>
                     </ul>
                     <p><a href="Java-DOM-API-for-XMLType.html#GUID-7C93723D-5D83-4444-BD06-216BECAE4983__CHDGCCEB">示例13-13</a>显示了如何使用Java DOM API for <code class="codeph">XMLType</code>创建DOM对象并以关联的XML模式指定的格式存储它。此处未显示针对XML架构的验证。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-7C93723D-5D83-4444-BD06-216BECAE4983__CHDGCCEB">
                     <p class="titleinexample">示例13-13使用Java DOM API创建DOM对象</p><pre class="pre codeblock"><code>PreparedStatement statement = connection.prepareStatement（“update po_xml_XMLTypetab set poDoc =？“）;字符串xmlString =”&lt;PO&gt; &lt;PONO&gt; 200 &lt;/ PONO&gt; &lt;PNAME&gt; PO_2 &lt;/ PNAME&gt; &lt;/ PO&gt;“; OracleClob clob =（OracleClob）connection.createClob（）; clob.setString（1， xmlString）; SQLXML sqlXml = clob.toSQLXML（）; DOMSource domSource = sqlXml.getSource（DOMSource.class）;文档文档=（文档）domSource.getNode（）;元素rootElem = document.createElement（“PO”）;文档。 insertBefore（document，rootElem，null）; SQLXML sqlXml2 = clob.toSQLXML（）; DOMResult domResult = sqlXml2.setResult（DomResult.class）; domResult.setNode（document）; statement.setSQLXML（1，sqlXml2）; statement.execute（ ）;</code></pre></div>
                  <!-- class="example" -->
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="Java-DOM-API-for-XMLType.html#GUID-4C510052-8A31-4917-8567-0E2825927C54" title="XMLType的Java DOM API允许您使用DOM操作XMLType实例。您可以使用它来操作Java中的XML数据，包括通过Java数据库连接（JDBC）获取它。">XMLType的Java DOM API</a></p>
                     </div>
                  </div>
               </div>
               
            </div><a id="ADXDB4949"></a><div class="props_rev_3"><a id="GUID-71138EC1-A710-4557-91C0-7CEBE4BD90B5" name="GUID-71138EC1-A710-4557-91C0-7CEBE4BD90B5"></a><h3 id="ADXDB-GUID-71138EC1-A710-4557-91C0-7CEBE4BD90B5" class="sect3"><span class="enumeration_section">13.7</span> Java中的XMLType实例表示（JDBC或SQLJ）</h3>
               <div>
                  <p><code class="codeph">XMLType</code>实例由Java表示为<code class="codeph">oracle.xdb.XMLType</code> 。使用JDBC或SQLJ客户端获取<code class="codeph">XMLType</code>实例时，它会自动显示为提供的<code class="codeph">XMLType</code>类的对象。
                  </p>
                  <p>您可以将此类的对象作为值绑定到需要<code class="codeph">XMLType</code>数据操作语言（DML）语句。
                  </p>
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="Java-DOM-API-for-XMLType.html#GUID-4C510052-8A31-4917-8567-0E2825927C54" title="XMLType的Java DOM API允许您使用DOM操作XMLType实例。您可以使用它来操作Java中的XML数据，包括通过Java数据库连接（JDBC）获取它。">XMLType的Java DOM API</a></p>
                     </div>
                  </div>
               </div>
               
            </div><a id="ADXDB4951"></a><a id="ADXDB4950"></a><div class="props_rev_3"><a id="GUID-6144192C-114A-4120-B117-D7FB6B871CDE" name="GUID-6144192C-114A-4120-B117-D7FB6B871CDE"></a><h3 id="ADXDB-GUID-6144192C-114A-4120-B117-D7FB6B871CDE" class="sect3"><span class="enumeration_section">13.8</span> XMLType的Java DOM API类</h3>
               <div>
                  <p>Oracle XML DB支持W3C DOM Level 2 Recommendation。它还提供特定于Oracle的扩展，以便于您的应用程序与Oracle XML Developer的Java Kit连接。<code class="codeph">XMLType</code>的Java DOM API提供了实现W3C DOM接口的类。
                  </p>
                  <p><code class="codeph">XMLDocument</code>是一个表示实例化XML文档的DOM的类。您可以从文档和连接对象中检索<code class="codeph">SQLXML</code>实例，如下所示：</p><pre class="pre codeblock"><code>SQLXML sqlXml = connection.createSQLXML（）; DOMResult domResult = sqlXml.setResult（DOMResult.class）; domResult.setNode（文件）;</code></pre><p><a href="Java-DOM-API-for-XMLType.html#GUID-6144192C-114A-4120-B117-D7FB6B871CDE__CACFFCEG" title="此表描述了XMLType类的Java DOM API。它包括等效W3C类的列表。">表13-1</a>列出了<code class="codeph">XMLType</code>类的Java DOM API以及它们实现的W3C DOM接口。Java DOM API类位于包<code class="codeph">oracle.xml.parser.v2</code> 。
                  </p>
                  <div class="tblformal" id="GUID-6144192C-114A-4120-B117-D7FB6B871CDE__CACFFCEG">
                     <p class="titleintable">表13-1 XMLType的Java DOM API：类</p>
                     <table cellpadding="4" cellspacing="0" class="Formal" title="用于XMLType的Java DOM API：类" width="100%" border="1" summary="This table describes the Java DOM API for XMLType classes. It includes a listing of the equivalent W3C classes." frame="hsides" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="43%" id="d73809e1286">XMLType类的Java DOM API</th>
                              <th align="left" valign="bottom" width="57%" id="d73809e1289">W3C DOM接口推荐类</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="43%" id="d73809e1294" headers="d73809e1286 "><pre class="oac_no_warn" dir="ltr">的XMLDocument</pre></td>
                              <td align="left" valign="top" width="57%" headers="d73809e1294 d73809e1289 "><pre class="oac_no_warn" dir="ltr">org.w3c.dom中。文献</pre></td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="43%" id="d73809e1301" headers="d73809e1286 "><pre class="oac_no_warn" dir="ltr">XMLCDATA</pre></td>
                              <td align="left" valign="top" width="57%" headers="d73809e1301 d73809e1289 "><pre class="oac_no_warn" dir="ltr">org.w3c.dom中。的CDATASection</pre></td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="43%" id="d73809e1308" headers="d73809e1286 "><pre class="oac_no_warn" dir="ltr">XMLCOMMENT</pre></td>
                              <td align="left" valign="top" width="57%" headers="d73809e1308 d73809e1289 "><pre class="oac_no_warn" dir="ltr">org.w3c.dom中。评论</pre></td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="43%" id="d73809e1315" headers="d73809e1286 "><pre class="oac_no_warn" dir="ltr">XMLPI</pre></td>
                              <td align="left" valign="top" width="57%" headers="d73809e1315 d73809e1289 "><pre class="oac_no_warn" dir="ltr">org.w3c.dom中。的ProcessingInstruction</pre></td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="43%" id="d73809e1322" headers="d73809e1286 "><pre class="oac_no_warn" dir="ltr">XMLTEXT</pre></td>
                              <td align="left" valign="top" width="57%" headers="d73809e1322 d73809e1289 "><pre class="oac_no_warn" dir="ltr">org.w3c.dom中。文本</pre></td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="43%" id="d73809e1329" headers="d73809e1286 "><pre class="oac_no_warn" dir="ltr">XMLEntity</pre></td>
                              <td align="left" valign="top" width="57%" headers="d73809e1329 d73809e1289 "><pre class="oac_no_warn" dir="ltr">org.w3c.dom中。实体</pre></td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="43%" id="d73809e1336" headers="d73809e1286 "><pre class="oac_no_warn" dir="ltr">DTD</pre></td>
                              <td align="left" valign="top" width="57%" headers="d73809e1336 d73809e1289 "><pre class="oac_no_warn" dir="ltr">org.w3c.dom中。DocumentType</pre></td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="43%" id="d73809e1343" headers="d73809e1286 "><pre class="oac_no_warn" dir="ltr">XMLNotation</pre></td>
                              <td align="left" valign="top" width="57%" headers="d73809e1343 d73809e1289 "><pre class="oac_no_warn" dir="ltr">org.w3c.dom中。符号</pre></td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="43%" id="d73809e1350" headers="d73809e1286 "><pre class="oac_no_warn" dir="ltr">XMLAttr</pre></td>
                              <td align="left" valign="top" width="57%" headers="d73809e1350 d73809e1289 "><pre class="oac_no_warn" dir="ltr">org.w3c.dom中。属性</pre></td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="43%" id="d73809e1357" headers="d73809e1286 "><pre class="oac_no_warn" dir="ltr">XMLDomImplementation</pre></td>
                              <td align="left" valign="top" width="57%" headers="d73809e1357 d73809e1289 "><pre class="oac_no_warn" dir="ltr">org.w3c.dom中。的DOMImplementation</pre></td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="43%" id="d73809e1364" headers="d73809e1286 "><pre class="oac_no_warn" dir="ltr">的XMLElement</pre></td>
                              <td align="left" valign="top" width="57%" headers="d73809e1364 d73809e1289 "><pre class="oac_no_warn" dir="ltr">org.w3c.dom中。元件</pre></td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="43%" id="d73809e1372" headers="d73809e1286 "><pre class="oac_no_warn" dir="ltr">XMLAttrList</pre></td>
                              <td align="left" valign="top" width="57%" headers="d73809e1372 d73809e1289 "><pre class="oac_no_warn" dir="ltr">org.w3c.dom中。的NamedNodeMap</pre></td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="43%" id="d73809e1379" headers="d73809e1286 "><pre class="oac_no_warn" dir="ltr">的XMLNode</pre></td>
                              <td align="left" valign="top" width="57%" headers="d73809e1379 d73809e1289 "><pre class="oac_no_warn" dir="ltr">org.w3c.dom中。节点</pre></td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
               </div>
               <div>
                  <div class="infoboxnotealso" id="GUID-6144192C-114A-4120-B117-D7FB6B871CDE__GUID-4A9A738F-C544-4D3A-9A32-EA60E66C8C5A">
                     <p class="notep1">也可以看看：</p>
                     <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/adxdb&amp;id=otn_db_xmldb_overview" target="_blank">OTN上的Oracle XML DB</a> for Oracle扩展，用于将应用程序与Oracle XML Developer's Kit for Java连接</p>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="Java-DOM-API-for-XMLType.html#GUID-4C510052-8A31-4917-8567-0E2825927C54" title="XMLType的Java DOM API允许您使用DOM操作XMLType实例。您可以使用它来操作Java中的XML数据，包括通过Java数据库连接（JDBC）获取它。">XMLType的Java DOM API</a></p>
                     </div>
                  </div>
               </div>
               
            </div><a id="ADXDB4954"></a><a id="ADXDB4953"></a><div class="props_rev_3"><a id="GUID-F5F719CF-F383-4677-A655-6329C1E462FA" name="GUID-F5F719CF-F383-4677-A655-6329C1E462FA"></a><h3 id="ADXDB-GUID-F5F719CF-F383-4677-A655-6329C1E462FA" class="sect3"><span class="enumeration_section">13.9</span>为XMLType使用Java DOM API</h3>
               <div>
                  <p>从<code class="codeph">XMLType</code>表或列中检索数据，并从中获取Java <code class="codeph">XMLDocument</code>实例。使用XML DOM API for <code class="codeph">XMLType</code>数据的DOM树元素。
                  </p>
                  <div class="section">
                     <p><code class="codeph">XMLType</code>的Java DOM API允许您在任何级别查找和检索文档中的节点。您可以使用它以编程方式创建XML文档，包括动态（动态）。这些文档是否符合已注册的XML模式。<code class="codeph">XMLType</code>的Java API符合DOM 2.0建议，并且它是名称空间感知的。
                     </p>
                     <p><a href="Java-DOM-API-for-XMLType.html#GUID-F5F719CF-F383-4677-A655-6329C1E462FA__I1031454">图13-1</a>说明了如何将Java DOM API用于<code class="codeph">XMLType</code> 。<a id="fn_1" name="fn_1" href="#fn_1" data="" this="" assumes="" that="" your="" xml="" is="" pre-registered="" with="" an="" schema,="" and="" it="" stored="" in="" xmltype="" column=")" ="" onclick="footdisplay(1, "><sup>脚1</sup></a>这些是步骤：</p>
                     <ol>
                        <li>
                           <p>从表中的<code class="codeph">XMLType</code>表或<code class="codeph">XMLType</code>列中检索XML数据。获取XML数据时，Oracle会创建一个<code class="codeph">Document</code>实例。然后，您可以使用方法<code class="codeph">getNode()</code>来检索<code class="codeph">XMLDocument</code>实例。
                           </p>
                        </li>
                        <li>
                           <p>使用Java DOM API for <code class="codeph">XMLType</code>来操作DOM树的元素。<code class="codeph">XMLType</code>实例保存已修改的数据，但使用JDBC更新发回数据。
                           </p>
                        </li>
                     </ol>
                     <p>应使用相应类中的<code class="codeph">free()</code>方法关闭<code class="codeph">XMLType</code>和<code class="codeph">XMLDocument</code>实例。这释放了所持有的任何底层内存。
                     </p>
                     <div class="figure" id="GUID-F5F719CF-F383-4677-A655-6329C1E462FA__I1031454">
                        <p class="titleinfigure">图13-1为XMLType使用Java DOM API</p><img src="img/adxdb024b.png" width="292" alt="下面是图13-1的描述" title="下面是图13-1的描述" longdesc="img_text/adxdb024b.html"><br><a href="img_text/adxdb024b.html">“图13-1使用Java DOM API for XMLType”的描述</a></div>
                     <!-- class="figure" -->
                  </div>
                  <!-- class="section" -->
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="Java-DOM-API-for-XMLType.html#GUID-4C510052-8A31-4917-8567-0E2825927C54" title="XMLType的Java DOM API允许您使用DOM操作XMLType实例。您可以使用它来操作Java中的XML数据，包括通过Java数据库连接（JDBC）获取它。">XMLType的Java DOM API</a></p>
                     </div>
                  </div>
               </div>
               
            </div><a id="ADXDB1150"></a><div class="props_rev_3"><a id="GUID-292AD380-743C-4E36-BDD1-039A279006C0" name="GUID-292AD380-743C-4E36-BDD1-039A279006C0"></a><h3 id="ADXDB-GUID-292AD380-743C-4E36-BDD1-039A279006C0" class="sect3"><span class="enumeration_section">13.10</span>使用Java进行大型XML节点处理</h3>
               <div>
                  <p>Oracle XML DB提供了抽象流和流操作方法，可用于处理大于64 K字节的XML节点。使用Java类<code class="codeph">XMLNode</code>和<code class="codeph">XMLAttr</code>以及thick或kprb连接来操作大型节点。
                  </p>
                  <div class="infoboxnote" id="GUID-292AD380-743C-4E36-BDD1-039A279006C0__GUID-221D5813-F9B6-44D4-B048-142BF6FF7A49">
                     <p class="notep1">注意：</p>
                     <p>大节点功能仅适用于thick或kprb连接。它不适用于瘦连接。</p>
                  </div>
                  <p>在Oracle Database 11g第1版（11.1）之前，Oracle XML DB处理的每个文本节点或属性值的大小限制为64 K字节。从版本11.1开始，此限制不再适用。</p>
                  <p>前者对节点大小的限制是因为设置和获取节点值的Java方法仅支持<code class="codeph">java.lang.类型的参数<code class="codeph">java.lang.String</code> 。字符串的最大大小取决于Java VM的实现，但它是有限的。在版本11.1之前，Java DOM API用于管理类<code class="codeph">oracle.xdb.dom.包含的节点值<code class="codeph">oracle.xdb.dom.XDBNode.java</code>是这些：</p><pre class="oac_no_warn" dir="ltr">public String getNodeValue（）; public void setNodeValue（String value）;</pre><p>在版本11.1之前，用于管理属性的Java DOM API包含在类<code class="codeph">oracle.xdb.dom.XDBAttribute.java</code> ，是这些：</p><pre class="oac_no_warn" dir="ltr">public String getValue（）; public void setValue（String value）;</pre><p>从Oracle Database 11g第1版（11.1）开始，不推荐使用包<code class="codeph">oracle.xdb.dom</code> 。Java类<code class="codeph">XDBNode</code>和<code class="codeph">XDBAttribute</code>该包中被替换的类<code class="codeph">XMLNode</code>和<code class="codeph">XMLAttr</code>分别，在包<code class="codeph">oracle.xml.parser.v2</code> 。此外，这些DOM API在版本11.1中进行了扩展，以支持任意大小的文本和二进制节点值。
                  </p>
                  <div class="section"></div>
                  <!-- class="section" -->
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="Java-DOM-API-for-XMLType.html#GUID-385EA5A7-6646-4EA6-8443-5BF243C149B4">流扩展到Java DOM</a><br>所有Java <code class="codeph">String</code> ， <code class="codeph">Reader</code>和<code class="codeph">Writer</code>数据都在UCS2中表示，它可能与数据库字符集不同。此外，节点字符数据标记有字符集id，该字符集id在填充节点值时设置。
                     </li>
                  </ul>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="PLSQL-APIs-for-XMLType.html#GUID-27F60B86-33DC-4E4B-B870-DDCBCF7819F6" title="Oracle XML DB提供了抽象流和流操作方法，可用于处理大于64 K字节的XML节点。">使用DBMS_XMLDOM进行大型节点处理</a></li>
                     </ul>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="Java-DOM-API-for-XMLType.html#GUID-4C510052-8A31-4917-8567-0E2825927C54" title="XMLType的Java DOM API允许您使用DOM操作XMLType实例。您可以使用它来操作Java中的XML数据，包括通过Java数据库连接（JDBC）获取它。">XMLType的Java DOM API</a></p>
                     </div>
                  </div>
               </div>
               <a id="ADXDB4955"></a><div class="props_rev_3"><a id="GUID-385EA5A7-6646-4EA6-8443-5BF243C149B4" name="GUID-385EA5A7-6646-4EA6-8443-5BF243C149B4"></a><h4 id="ADXDB-GUID-385EA5A7-6646-4EA6-8443-5BF243C149B4" class="sect4"><span class="enumeration_section">13.10.1</span> Java DOM的流扩展</h4>
                  <div>
                     <p>所有Java <code class="codeph">String</code> ， <code class="codeph">Reader</code>和<code class="codeph">Writer</code>数据都在UCS2中表示，它可能与数据库字符集不同。此外，节点字符数据标记有字符集id，该字符集id在填充节点值时设置。
                     </p>
                     <p><code class="codeph">oracle.xml.parser.v2.的以下方法<code class="codeph">oracle.xml.parser.v2.XMLNode.java</code>可用于访问大小超过64 KB的节点。如果您尝试获取或设置不是叶节点的节点（属性， <code class="codeph">PI</code> ， <code class="codeph">CDATA</code>等），则这些API会抛出异常。此外，请务必使用<code class="codeph">close()</code>实际写入值并释放用于维护状态的资源以便对节点进行流式访问。
                     </p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="Java-DOM-API-for-XMLType.html#GUID-83D45962-6911-4E8D-AA76-7DB19C4B5288">Get-Pull模型</a><br>您可以使用方法<code class="codeph">getNodeValueAsBinaryStream()</code>和<code class="codeph">getNodeValueAsCharacterStream()</code>来使用处于拉模式的解析器来检索DOM节点的值。Oracle XML DB从解析器编写的输入流中读取事件数据。
                        </li>
                        <li class="ulchildlink"><a href="Java-DOM-API-for-XMLType.html#GUID-1A5DF09B-C27C-45EC-B22A-A9D235883AB1">Get-Push模型</a><br>在此模型中，使用处于推送模式的解析器检索DOM节点的值。Oracle XML DB将节点数据写入解析器读取的输出流。
                        </li>
                        <li class="ulchildlink"><a href="Java-DOM-API-for-XMLType.html#GUID-5528C4C8-C076-4B03-AC18-F16BCC3C3DFE">集拉模型</a><br>在此模型中，使用处于拉模式的解析器设置DOM节点的值。Oracle XML DB从解析器编写的输入流中读取事件数据。
                        </li>
                        <li class="ulchildlink"><a href="Java-DOM-API-for-XMLType.html#GUID-EDECA2DC-5808-4549-8F99-0B5092208529">集推模型</a><br>在此模型中，使用处于推送模式的解析器设置DOM节点的值。Oracle XML DB将节点数据写入解析器读取的输出流。
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="Java-DOM-API-for-XMLType.html#GUID-292AD380-743C-4E36-BDD1-039A279006C0" title="Oracle XML DB提供了抽象流和流操作方法，可用于处理大于64 K字节的XML节点。使用Java类XMLNode和XMLAttr以及thick或kprb连接来操作大型节点。">使用Java进行大型XML节点处理</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="ADXDB4956"></a><div class="props_rev_3"><a id="GUID-83D45962-6911-4E8D-AA76-7DB19C4B5288" name="GUID-83D45962-6911-4E8D-AA76-7DB19C4B5288"></a><h5 id="ADXDB-GUID-83D45962-6911-4E8D-AA76-7DB19C4B5288" class="sect5"><span class="enumeration_section">13.10.1.1</span> Get-Pull模型</h5>
                     <div>
                        <p>您可以使用方法<code class="codeph">getNodeValueAsBinaryStream()</code>和<code class="codeph">getNodeValueAsCharacterStream()</code>来使用处于拉模式的解析器来检索DOM节点的值。Oracle XML DB从解析器编写的输入流中读取事件数据。
                        </p>
                        <p>对于二进制输入流：</p><pre class="pre codeblock"><code>public java.io.InputStream getNodeValueAsBinaryStream（）抛出java.io.IOException，DOMException;</code></pre><p>方法<code class="codeph">getNodeValueAsBinaryStream()</code>返回的实例<code class="codeph">java.io.可以使用此类的已定义方法读取的InputStream</code> 。节点的数据类型必须是<code class="codeph">RAW</code>或<code class="codeph">BLOB</code> 。如果不是，则抛出<code class="codeph">IOException</code> 。以下示例片段说明了读取二进制50字节段中节点的值：</p><pre class="pre codeblock"><code>...oracle.xml.parser.v2。XMLNode node = null; ...java.io.InputStream value = node.getNodeValueAsBinaryStream（）; //现在读取InputStream ...byte buffer [] = new byte [50]; int returnValue = 0; while（（returnValue = value.read（buffer））！= -1）{//处理下一个50字节的节点} ...
</code></pre><p>对于字符输入流：</p><pre class="pre codeblock"><code>public java.io.Reader getNodeValueAsCharacterStream（）抛出java.io.IOException，DOMException;</code></pre><p>方法<code class="codeph">getNodeValueAsCharacterStream()</code>返回的实例<code class="codeph">java.io.可以使用此类的已定义方法读取的Reader</code> 。如果节点的数据类型既不是字符也不是<code class="codeph">CLOB</code> ，则首先将节点数据转换为字符。所有节点数据最终都是字符格式，并在必要时转换为<code class="codeph">UCS2</code> 。以下示例片段说明了以50个字符的段读取节点值：</p><pre class="pre codeblock"><code>...oracle.xml.parser.v2。XMLNode node = null; ...java.io.Reader value = node.getNodeValueAsCharacterStream（）; //现在读取InputStream char buffer [] = new char [50]; int returnValue = 0; while（（returnValue = value.read（buffer））！= -1）{//处理节点的下一个50个字符} ...</code></pre></div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="Java-DOM-API-for-XMLType.html#GUID-385EA5A7-6646-4EA6-8443-5BF243C149B4" title="所有Java String，Reader和Writer数据都在UCS2中表示，它可能与数据库字符集不同。此外，节点字符数据标记有字符集id，该字符集id在填充节点值时设置。">流扩展到Java DOM</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="ADXDB4957"></a><div class="props_rev_3"><a id="GUID-1A5DF09B-C27C-45EC-B22A-A9D235883AB1" name="GUID-1A5DF09B-C27C-45EC-B22A-A9D235883AB1"></a><h5 id="ADXDB-GUID-1A5DF09B-C27C-45EC-B22A-A9D235883AB1" class="sect5"><span class="enumeration_section">13.10.1.2</span> Get-Push模型</h5>
                     <div>
                        <p>在此模型中，使用处于推送模式的解析器检索DOM节点的值。Oracle XML DB将节点数据写入解析器读取的输出流。</p>
                        <p>对于二进制输出流：</p><pre class="pre codeblock"><code>public void getNodeValueAsBinaryStream（java.io.OutputStream pushValue）抛出java.io.IOException，DOMException;</code></pre><p><code class="codeph">java.io.的状态。必须打开<code class="codeph">pushValue</code>指定的OutputStream</code> 。节点的数据类型必须是<code class="codeph">RAW</code>或<code class="codeph">BLOB</code> 。如果不是，则抛出<code class="codeph">IOException</code> 。使用<code class="codeph">OutputStream</code> <code class="codeph">write()</code>方法将节点二进制数据写入<code class="codeph">pushValue</code> ，并在节点值完全写入流时调用方法<code class="codeph">close()</code> 。
                        </p>
                        <p>对于字符输出流：</p><pre class="pre codeblock"><code>public void getNodeValueAsCharacterStream（java.io.Writer pushValue）抛出java.io.IOException，DOMException;</code></pre><p><code class="codeph">java.io.的状态。必须打开<code class="codeph">pushValue</code>指定的Writer</code> 。如果节点的数据类型既不是字符也不是<code class="codeph">CLOB</code> ，则数据首先转换为字符。节点数据（始终为字符格式）根据需要转换为<code class="codeph">UCS2</code> ，然后推送到<code class="codeph">java.io.Writer</code> 。
                        </p>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="Java-DOM-API-for-XMLType.html#GUID-385EA5A7-6646-4EA6-8443-5BF243C149B4" title="所有Java String，Reader和Writer数据都在UCS2中表示，它可能与数据库字符集不同。此外，节点字符数据标记有字符集id，该字符集id在填充节点值时设置。">流扩展到Java DOM</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="ADXDB4958"></a><div class="props_rev_3"><a id="GUID-5528C4C8-C076-4B03-AC18-F16BCC3C3DFE" name="GUID-5528C4C8-C076-4B03-AC18-F16BCC3C3DFE"></a><h5 id="ADXDB-GUID-5528C4C8-C076-4B03-AC18-F16BCC3C3DFE" class="sect5"><span class="enumeration_section">13.10.1.3</span>集拉模型</h5>
                     <div>
                        <p>在此模型中，使用处于拉模式的解析器设置DOM节点的值。Oracle XML DB从解析器编写的输入流中读取事件数据。</p>
                        <p>对于二进制输入流：</p><pre class="pre codeblock"><code>public void setNodeValueAsBinaryStream（java.io.InputStream pullValue）抛出java.io.IOException，DOMException;</code></pre><p><code class="codeph">java.io.的状态。由<code class="codeph">pullValue</code>指定的InputStream</code>必须是打开的。节点的数据类型必须是<code class="codeph">RAW</code>或<code class="codeph">BLOB</code> 。如果不是，则抛出<code class="codeph">IOException</code> 。使用<code class="codeph">InputStream</code> <code class="codeph">read()</code>方法<code class="codeph">read()</code> <code class="codeph">pullValue</code>的二进制数据，并替换节点值。
                        </p><pre class="pre codeblock"><code>import java.io.InputStream的; import oracle.xml.parser。*; ...oracle.xml.parser.v2。XMLNode node = null; ...byte [] buffer = new byte [500]; java.io.InputStream istream; //用户定义的输入流node.setNodeValueAsBinaryStream（istream）;</code></pre><p>对于字符输入流：</p><pre class="pre codeblock"><code>public void setNodeValueAsCharacterStream（java.io.Reader pullValue）抛出java.io.IOException，DOMException;</code></pre><p><code class="codeph">java.io.的状态。Reader</code>通过指定<code class="codeph">pullValue</code>必须打开。如果节点的数据类型既不是字符也不是<code class="codeph">CLOB</code> ，则字符数据从<code class="codeph">UCS2</code>转换为节点数据类型。如果节点的数据类型是字符或<code class="codeph">CLOB</code> ，则从<code class="codeph">pullValue</code>读取的字符数据将从<code class="codeph">UCS2</code>转换为节点的字符集。
                        </p>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="Java-DOM-API-for-XMLType.html#GUID-385EA5A7-6646-4EA6-8443-5BF243C149B4" title="所有Java String，Reader和Writer数据都在UCS2中表示，它可能与数据库字符集不同。此外，节点字符数据标记有字符集id，该字符集id在填充节点值时设置。">流扩展到Java DOM</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="ADXDB4959"></a><div class="props_rev_3"><a id="GUID-EDECA2DC-5808-4549-8F99-0B5092208529" name="GUID-EDECA2DC-5808-4549-8F99-0B5092208529"></a><h5 id="ADXDB-GUID-EDECA2DC-5808-4549-8F99-0B5092208529" class="sect5"><span class="enumeration_section">13.10.1.4</span> Set-Push模型</h5>
                     <div>
                        <p>在此模型中，使用处于推送模式的解析器设置DOM节点的值。Oracle XML DB将节点数据写入解析器读取的输出流。</p>
                        <p>对于二进制输出流：</p><pre class="pre codeblock"><code>public java.io.OutputStream setNodeValueAsBinaryStream（）抛出java.io.IOException，DOMException;</code></pre><p>方法<code class="codeph">setNodeValueAsBinaryStream()</code>返回的实例<code class="codeph">java.io.OutputStream</code> ，调用者可以将节点值写入其中。节点的数据类型必须是<code class="codeph">RAW</code>或<code class="codeph">BLOB</code> 。否则，引发<code class="codeph">IOException</code> 。以下示例片段说明了通过写入<code class="codeph">java.io.的实现将节点的值设置为二进制数据。OutputStream</code>由Oracle XML DB或Oracle XML Developer's Kit提供。
                        </p>
                        <p>对于字符输出流：</p><pre class="pre codeblock"><code>public java.io.Writer setNodeValueAsCharacterStream（）抛出java.io.IOException，DOMException;</code></pre><p>方法<code class="codeph">setNodeValueAsCharacterStream()</code>返回的实例<code class="codeph">java.io.调用者可以写入节点值的Writer</code> 。如有必要，首先将写入的字符数据从<code class="codeph">UCS2</code>转换为节点字符集。如果节点的数据类型既不是字符也不是<code class="codeph">CLOB</code> ，则字符数据将转换为节点数据类型。类似地，以下示例片段通过写入<code class="codeph">java.io.的实现来说明将节点的值设置为字符数据。Writer</code>由Oracle XML DB或Oracle XML Developer's Kit提供。
                        </p><pre class="pre codeblock"><code>import java.io.作家; import oracle.xml.parser。*; ...oracle.xml.parser.v2。XMLNode node = null; ...char [] buffer = new char [500]; java.io.Writer writer = node.setNodeValueAsCharacterStream（）; for（int k = 0; k &lt;10; k ++）{byte segment [] = new byte [50]; //将下一个缓冲区子集复制到段writer.write（segment）; } writer.flush（）; writer.close（）;</code></pre><p>Oracle XML DB创建一个<code class="codeph">writer</code>或<code class="codeph">OutputStream</code> ，并将其传递给重复调用方法<code class="codeph">write()</code>的用户，直到<code class="codeph">write()</code>完整的节点值。仅当用户调用方法<code class="codeph">close()</code>时才反映新节点值。
                        </p>
                        <div class="section"></div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-EDECA2DC-5808-4549-8F99-0B5092208529__GUID-D1751450-44F5-4233-AE1C-1E9F13D4AFF0">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><a href="../jaxml/index.html" target="_blank"><span><cite>Oracle数据库XML Java API参考</cite></span></a></p>
                              </li>
                              <li>
                                 <p>有关大型节点的C函数的信息，请参阅<a href="../caxml/package-DOM-API.html#CAXML-GUID-1A4B5DBB-1B8C-4963-AEC4-C5DC0709C325" target="_blank"><span><cite>Oracle Database XML C API参考</cite></span></a></p>
                              </li>
                           </ul>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="Java-DOM-API-for-XMLType.html#GUID-385EA5A7-6646-4EA6-8443-5BF243C149B4" title="所有Java String，Reader和Writer数据都在UCS2中表示，它可能与数据库字符集不同。此外，节点字符数据标记有字符集id，该字符集id在填充节点值时设置。">流扩展到Java DOM</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div>
            </div><a id="ADXDB4961"></a><a id="ADXDB4960"></a><div class="props_rev_3"><a id="GUID-1234728D-0732-4DC6-82EF-9D372702061F" name="GUID-1234728D-0732-4DC6-82EF-9D372702061F"></a><h3 id="ADXDB-GUID-1234728D-0732-4DC6-82EF-9D372702061F" class="sect3"><span class="enumeration_section">13.11</span>将Java DOM API和JDBC与二进制XML一起使用</h3>
               <div>
                  <p>您可以使用Java DOM API进行XML和Java数据库连接（JDBC）来读取或写入从Oracle XML DB编码为二进制XML的XML数据。这样做涉及通常的读写程序。</p>
                  <div class="section">
                     <p>XML数据可以使用数据类型<code class="codeph">XMLType</code>存储在Oracle XML DB中，此抽象数据类型的存储模型之一是二进制XML，这是一种紧凑的XML Schema感知XML数据编码。您可以将二进制XML用作数据库中<code class="codeph">XMLType</code>的存储模型，但您也可以将其用于位于数据库外部的XML数据。客户端处理XML数据可能涉及存储在Oracle XML DB中的数据或驻留在数据库外部的瞬态数据。
                     </p>
                     <p>二进制XML是XML Schema感知的，可以使用各种编码方案，具体取决于您的需求和数据。因此，为了操作二进制XML数据，您必须同时拥有关于相关XML模式和编码的数据和元数据。</p>
                     <p>对于存储在数据库中的<code class="codeph">XMLType</code>数据，此元数据也存储在数据库中。但是，根据数据库和数据的设置方式，元数据可能与应用的数据不在同一服务器上。如果是这种情况，那么，在您从数据库读取或写入二进制XML数据之前，必须执行以下步骤：</p>
                     <ol>
                        <li>
                           <p>为元数据创建上下文实例。</p>
                        </li>
                        <li>
                           <p>将此上下文与用于访问数据库中的二进制XML数据的数据连接相关联。数据连接可以是专用连接或连接池。您在类<code class="codeph">java.sql.使用<code class="codeph">getDedicatedConn()</code>和<code class="codeph">getConnPool()</code>方法<code class="codeph">java.sql.Connection</code>分别获取这两种连接的句柄。
                           </p>
                        </li>
                     </ol>
                     <p>然后，当您的应用程序需要对数据连接上的二进制XML数据进行编码或解码时，它会自动获取所需的元数据。因此，整个行动顺序如下：</p>
                     <ol>
                        <li>
                           <p>在类<code class="codeph">java.sql.创建XML数据连接对象<code class="codeph">java.sql.Connection</code> 。
                           </p>
                        </li>
                        <li>
                           <p>创建一个或多个元数据的上下文中，根据需要，使用方法<code class="codeph">BinXMLMetadataProviderFactory.createDBMetadataProvider()</code>中包<code class="codeph">oracle.xml.binxml</code> 。元数据上下文有时被称为元数据存储库。您可以从专用连接或连接池创建元数据上下文。
                           </p>
                        </li>
                        <li>
                           <p>将元数据上下文与二进制XML数据连接相关联。使用方法<code class="codeph">DBBinXMLMetadataProvider.associateDataConnection()</code>封装<code class="codeph">oracle.xml.binxml</code>做到这一点。
                           </p>
                        </li>
                        <li>
                           <p>（可选）如果XML数据源自数据库之外，请使用方法<code class="codeph">oracle.xdb.XMLType.setFormatPref()</code>指定要以二进制XML格式编码要发送到数据库的XML数据。这适用于DOM文档（类<code class="codeph">oracle.xdb.XMLType</code> ）。如果未指定二进制XML，则数据将作为文本发送到数据库。
                           </p>
                        </li>
                        <li>
                           <p>使用常用的Java方法从数据库读取和写入XML数据。只要需要对二进制XML文档进行编码或解码，就会使用元数据上下文自动获取必要的元数据。</p>
                           <p>使用Java DOM API for XML在客户端级别对XML数据进行操作。</p>
                        </li>
                     </ol>
                     <p><a href="Java-DOM-API-for-XMLType.html#GUID-1234728D-0732-4DC6-82EF-9D372702061F__CHDJJAED">例13-14</a>说明了这一点。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <div class="infoboxnotealso" id="GUID-1234728D-0732-4DC6-82EF-9D372702061F__GUID-BC392FC9-DE8C-47C9-9CDE-B1AE0E385A68">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="../adxdk/using-binary-XML-with-Java.html#ADXDK4440" target="_blank"><span><cite>Oracle XML Developer's Kit程序员指南</cite></span></a></p>
                     </div>
                  </div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-1234728D-0732-4DC6-82EF-9D372702061F__CHDJJAED">
                     <p class="titleinexample">示例13-14将Java DOM API与二进制XML列一起使用</p><pre class="oac_no_warn" dir="ltr">class PrintBinaryXML {public static void printBinXML（）throws SQLException，BinXMLException {//创建数据源以连接到本地数据库OracleDataSource ods = new OracleDataSource（）; ods.setURL（ “JDBC：ORACLE：kprb”）; System.out.println（“启动二进制XML Java示例”）; //创建数据连接Connection connection = ods。 <span class="bold">getConnection</span> （）; //使用连接池创建二进制XML元数据上下文DBBinXMLMetadataProvider repos = <span class="bold">BinXMLMetadataProviderFactory.createDBMetadataProvider</span> （）;回购。 <span class="bold">setConnectionPool</span> （ods）; //将元数据上下文与数据连接存储库关联。 <span class="bold">associateDataConnection</span> （connection）; //将存储在SQLXML列中的XML数据作为二进制XML查询语句= connection.createStatement（）; ResultSet resultSet = statement.executeQuery（“SELECT doc FROM po_binxmltab”）; //获取SQLXML对象while（resultSet.next（））{SQLXML sqlXml = resultSet.getSQLXML（1）; //将SQLXML转换为String String xmlString = sqlXml.getString（）;的System.out.println（的xmlString）; } resultSet.close（）;将statement.close（）; connection.close（）时; System.out.println（“完成的二进制XML Java示例”）; }}</pre></div>
                  <!-- class="example" -->
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="intro-to-XML-DB.html#GUID-B8507F44-B010-4384-94E6-101131DD7D88" title="XMLType是一种抽象数据类型，它提供了不同的存储模型，以最好地适应您的数据及其使用。作为抽象数据类型，您的应用程序和数据库查询可以获得灵活性：所有XMLType操作都可以使用相同的接口。">XMLType存储模型</a></li>
                     </ul>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="Java-DOM-API-for-XMLType.html#GUID-4C510052-8A31-4917-8567-0E2825927C54" title="XMLType的Java DOM API允许您使用DOM操作XMLType实例。您可以使用它来操作Java中的XML数据，包括通过Java数据库连接（JDBC）获取它。">XMLType的Java DOM API</a></p>
                     </div>
                  </div>
               </div>
               
            </div>
            <hr><br><p style="text-decoration:underline">脚注图例</p>脚注1：<p>这假定您的XML数据已预先注册了XML模式，并且它存储在<code class="codeph">XMLType</code>列中。
            </p><br></div>
      </article>
   </body>
</html>