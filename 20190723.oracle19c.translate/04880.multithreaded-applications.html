<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <title>多线程应用程序</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Programmer&#39;s Guide"></meta>
      <meta property="og:description" content=""></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Programmer&#39;s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="cobol-programmers-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-11T02:40:40-08:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="1996, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96466-01"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="Oracle-dynamic-SQL-method-4.html" title="Previous" type="text/html"></link>
      <link rel="next" href="large-objects-LOBs.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Pro*COBOL Programmer&#39;s Guide"></meta>
    <meta name="dcterms.isVersionOf" content="LNPCB"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="Oracle-dynamic-SQL-method-4.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="large-objects-LOBs.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">程序员指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="applications.html" property="item" typeof="WebPage"><span property="name">应用</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">多线程应用程序</li>
            </ol>
            <a id="GUID-9505F099-9344-4F23-BC12-56561C152950" name="GUID-9505F099-9344-4F23-BC12-56561C152950"></a><a id="LNPCB785"></a>
            
            <h2 id="LNPCB-GUID-9505F099-9344-4F23-BC12-56561C152950" class="sect2"><span class="enumeration_chapter">12</span>多线程应用程序</h2>
         </header>
         <div class="ind">
            <div>
               <p>如果您的开发平台不支持线程，则可以忽略本章。</p>
               <p>本章的部分是：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="multithreaded-applications.html#GUID-2DD70727-CFBE-498E-8924-519715BC09E0">线程简介</a></p>
                  </li>
                  <li>
                     <p><a href="multithreaded-applications.html#GUID-94729121-6A2F-4BA7-A2FA-161D58C39F21">Pro * COBOL中的运行时上下文</a></p>
                  </li>
                  <li>
                     <p><a href="multithreaded-applications.html#GUID-28A95A18-F235-4AE0-BE78-A856F8855B07">运行时上下文使用模型</a></p>
                  </li>
                  <li>
                     <p><a href="multithreaded-applications.html#GUID-880C1FE7-0CBD-43FD-BCFD-4FD579FA947D">多线程应用程序的用户界面功能</a></p>
                  </li>
                  <li>
                     <p><a href="multithreaded-applications.html#GUID-3E515B07-BE56-42FE-AC8B-88E2FDFA63BA">多线程示例</a></p>
                  </li>
               </ul>
            </div><a id="LNPCB786"></a><div class="props_rev_3"><a id="GUID-2DD70727-CFBE-498E-8924-519715BC09E0" name="GUID-2DD70727-CFBE-498E-8924-519715BC09E0"></a><h3 id="LNPCB-GUID-2DD70727-CFBE-498E-8924-519715BC09E0" class="sect3"><span class="enumeration_section">12.1</span>线程简介</h3>
               <div>
                  <p>多线程应用程序在共享地址空间中执行多个<span class="italic">线程</span> 。线程是在进程内执行的“轻量级”子进程。它们共享代码和数据段，但有自己的程序计数器，机器寄存器和堆栈。在工作存储中没有thread-local属性声明的变量（与本地存储或线程本地存储相对）对于所有线程都是通用的，并且通常需要互斥机制来管理应用程序中多个线程对这些变量的访问。<span class="italic">互斥锁</span>是确保保持数据完整性的同步机制。
                  </p>
                  <p>有关互斥锁的进一步讨论，请参阅有关多线程的文本。有关多线程应用程序的更多详细信息，请参阅线程函数的文档。</p>
                  <p>Pro * COBOL支持使用以下方法开发多线程Oracle Server应用程序（在支持多线程应用程序的平台上）：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>用于生成线程安全代码的命令行选项。</p>
                     </li>
                     <li>
                        <p>嵌入式SQL语句和指令，支持多线程。</p>
                     </li>
                     <li>
                        <p>线程安全的SQLLIB和其他客户端Oracle库。</p>
                     </li>
                  </ul>
                  <div class="infoboxnote" id="GUID-2DD70727-CFBE-498E-8924-519715BC09E0__GUID-075B690C-51EC-4EE9-9B2C-CFDE9E0C3DCF">
                     <p class="notep1">注意：</p>
                     <p>虽然您的平台可能支持特定的线程包，但请参阅特定于平台的Oracle文档以确定Oracle是否支持它。</p>
                  </div>
                  <p>本章的主题讨论如何使用前面的功能来开发多线程Pro * COBOL应用程序：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>多线程应用程序的运行时上下文。</p>
                     </li>
                     <li>
                        <p>两个使用运行时上下文的模型。</p>
                     </li>
                     <li>
                        <p>多线程应用程序的用户界面功能。</p>
                     </li>
                     <li>
                        <p>使用Pro * COBOL编写多线程应用程序的编程注意事项。</p>
                     </li>
                     <li>
                        <p>示例多线程Pro * COBOL应用程序。</p>
                     </li>
                  </ul>
               </div>
            </div><a id="LNPCB788"></a><a id="LNPCB787"></a><div class="props_rev_3"><a id="GUID-94729121-6A2F-4BA7-A2FA-161D58C39F21" name="GUID-94729121-6A2F-4BA7-A2FA-161D58C39F21"></a><h3 id="LNPCB-GUID-94729121-6A2F-4BA7-A2FA-161D58C39F21" class="sect3"><span class="enumeration_section">12.2</span> Pro * COBOL中的运行时上下文</h3>
               <div>
                  <p>为了松散地耦合线程和连接，在Pro * COBOL中我们引入了<span class="italic">运行时上下文</span>的概念。运行时上下文包括以下资源及其当前状态：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>与一个或多个Oracle服务器的零个或多个连接。</p>
                     </li>
                     <li>
                        <p>用于服务器连接的零个或多个游标。</p>
                     </li>
                     <li>
                        <p>内联选项，例如MODE，HOLD_CURSOR，RELEASE_CURSOR和SELECT_ERROR。</p>
                     </li>
                  </ul>
                  <p>Pro * COBOL不是简单地支持线程和连接之间的松散耦合，而是使您能够将线程与运行时上下文松散耦合。Pro * COBOL使您的应用程序能够定义运行时上下文的句柄，并将该句柄从一个线程传递到另一个线程。</p>
                  <p>例如，交互式应用程序生成一个线程T1，以执行查询并将前10行返回给应用程序。然后T1终止。在获得必要的用户输入之后，产生另一个线程T2（或者使用现有线程），并且T1的运行时上下文被传递给T2，因此它可以通过处理相同的光标来获取接下来的10行。<a href="multithreaded-applications.html#GUID-94729121-6A2F-4BA7-A2FA-161D58C39F21__I1005570">如图12-1</a>所示：</p>
                  <div class="figure" id="GUID-94729121-6A2F-4BA7-A2FA-161D58C39F21__I1005570">
                     <p class="titleinfigure">图12-1松散耦合连接和线程</p><img src="img/pc_81021.gif" alt="下面是图12-1的描述" title="下面是图12-1的描述" longdesc="img_text/pc_81021.html"><br><a href="img_text/pc_81021.html">“图12-1松耦合连接和螺纹”的描述</a></div>
                  <!-- class="figure" -->
               </div>
            </div><a id="LNPCB789"></a><div class="props_rev_3"><a id="GUID-28A95A18-F235-4AE0-BE78-A856F8855B07" name="GUID-28A95A18-F235-4AE0-BE78-A856F8855B07"></a><h3 id="LNPCB-GUID-28A95A18-F235-4AE0-BE78-A856F8855B07" class="sect3"><span class="enumeration_section">12.3</span>运行时上下文使用模型</h3>
               <div>
                  <p>这里显示了在多线程应用程序中使用运行时上下文的两种可能模型：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>多个线程共享单个运行时上下文。</p>
                     </li>
                     <li>
                        <p>多个线程使用单独的运行时上下文。</p>
                     </li>
                  </ul>
                  <p>无论您使用的运行时环境的模型，你<span class="italic">不能</span> <span class="italic">在同一时间</span>共享多个线程之间的运行时环境。如果两个或多个线程同时尝试使用相同的运行时上下文，则会发生运行时错误</p>
               </div><a id="LNPCB791"></a><a id="LNPCB790"></a><div class="props_rev_3"><a id="GUID-7D6CB9D8-0D11-4559-B29E-44930005AEF8" name="GUID-7D6CB9D8-0D11-4559-B29E-44930005AEF8"></a><h4 id="LNPCB-GUID-7D6CB9D8-0D11-4559-B29E-44930005AEF8" class="sect4"><span class="enumeration_section">12.3.1</span>共享单个运行时上下文的多个线程</h4>
                  <div>
                     <p>“线程间的上下文共享”显示了在多线程环境中运行的应用程序。各种线程共享一个运行时上下文来处理一个或多个SQL语句。同样，多个线程不能同时共享运行时上下文。“线程间的上下文共享”中的互斥锁显示了如何防止并发使用。</p>
                     <div class="figure" id="GUID-7D6CB9D8-0D11-4559-B29E-44930005AEF8__I1005537">
                        <p class="titleinfigure">图12-2线程间的上下文共享</p><img src="img/pc_81023.gif" alt="下面是图12-2的描述" title="下面是图12-2的描述" longdesc="img_text/pc_81023.html"><br><a href="img_text/pc_81023.html">“图12-2线程间的上下文共享”的说明</a></div>
                     <!-- class="figure" -->
                  </div>
               </div><a id="LNPCB793"></a><a id="LNPCB792"></a><div class="props_rev_3"><a id="GUID-4A60D990-F23C-47F0-8359-8EA96FD31FF3" name="GUID-4A60D990-F23C-47F0-8359-8EA96FD31FF3"></a><h4 id="LNPCB-GUID-4A60D990-F23C-47F0-8359-8EA96FD31FF3" class="sect4"><span class="enumeration_section">12.3.2</span>多个线程共享多个运行时上下文</h4>
                  <div>
                     <p><a href="multithreaded-applications.html#GUID-4A60D990-F23C-47F0-8359-8EA96FD31FF3__I997998">图12-3</a>显示了使用多个运行时上下文执行多个线程的应用程序。在这种情况下，应用程序不需要互斥锁，因为每个线程都有一个专用的运行时上下文。
                     </p>
                     <div class="figure" id="GUID-4A60D990-F23C-47F0-8359-8EA96FD31FF3__I997998">
                        <p class="titleinfigure">图12-3线程间无上下文共享</p><img src="img/pc_81022.gif" alt="下面是图12-3的描述" title="下面是图12-3的描述" longdesc="img_text/pc_81022.html"><br><a href="img_text/pc_81022.html">“图12-3线程间没有上下文共享”的描述</a></div>
                     <!-- class="figure" -->
                  </div>
               </div>
            </div><a id="LNPCB794"></a><div class="props_rev_3"><a id="GUID-880C1FE7-0CBD-43FD-BCFD-4FD579FA947D" name="GUID-880C1FE7-0CBD-43FD-BCFD-4FD579FA947D"></a><h3 id="LNPCB-GUID-880C1FE7-0CBD-43FD-BCFD-4FD579FA947D" class="sect3"><span class="enumeration_section">12.4</span>多线程应用程序的用户界面功能</h3>
               <div>
                  <p>Pro * COBOL提供以下用户界面功能以支持多线程应用程序：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>主机变量可以在LOCAL-STORAGE和THREAD-LOCAL-STORAGE部分声明。</p>
                     </li>
                     <li>
                        <p>命令行选项THREADS = YES |没有。</p>
                     </li>
                     <li>
                        <p>嵌入式SQL语句和指令。</p>
                     </li>
                     <li>
                        <p>线程安全的SQLLIB公共函数。</p>
                     </li>
                  </ul>
               </div><a id="LNPCB795"></a><div class="props_rev_3"><a id="GUID-B2AB9A7F-1B90-4414-A7BA-DFF7C13DE48A" name="GUID-B2AB9A7F-1B90-4414-A7BA-DFF7C13DE48A"></a><h4 id="LNPCB-GUID-B2AB9A7F-1B90-4414-A7BA-DFF7C13DE48A" class="sect4"><span class="enumeration_section">12.4.1</span>螺纹选项</h4>
                  <div>
                     <p>在命令行中指定THREADS = YES时，Pro * COBOL确保生成的代码是线程安全的，前提是您遵循“多线程编程注意事项”中描述的准则。指定THREADS = YES后，Pro * COBOL将验证所有SQL语句是否在用户定义的运行时上下文范围内执行。如果您的程序不符合此要求，则会返回预编译器错误。</p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="multithreaded-applications.html#GUID-05DFF012-F61F-4EE8-9E07-B3F68D835508">多线程编程注意事项</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div><a id="LNPCB796"></a><div class="props_rev_3"><a id="GUID-9BBF11EA-71B3-49AB-8765-8E0066813CD6" name="GUID-9BBF11EA-71B3-49AB-8765-8E0066813CD6"></a><h4 id="LNPCB-GUID-9BBF11EA-71B3-49AB-8765-8E0066813CD6" class="sect4"><span class="enumeration_section">12.4.2</span>运行时上下文的嵌入式SQL语句和指令</h4>
                  <div>
                     <p>以下嵌入式SQL语句和指令支持运行时上下文和线程的定义和用法：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>EXEC SQL ENABLE THREADS END-EXEC。</p>
                        </li>
                        <li>
                           <p>EXEC SQL语境分配： <span class="italic">context_var</span> END-EXEC。</p>
                        </li>
                        <li>
                           <p>EXEC SQL语境使用{： <span class="italic">context_var</span> | DEFAULT} END-EXEC。</p>
                        </li>
                        <li>
                           <p>EXEC SQL语境免费： <span class="italic">context_var</span> END-EXEC。</p>
                        </li>
                     </ul>
                     <p>对于这些EXEC SQL语句， <span class="italic">context_var</span>是运行时上下文的句柄，必须声明为type <a id="d77950e404" class="indexterm-anchor"></a> SQL-CONTEXT如下：</p><pre class="oac_no_warn" dir="ltr">01 SQL-CONTEXT <span class="italic">context_var</span> END-EXEC。</pre><p>使用DEFAULT意味着默认（全局）运行时上下文将用于所有嵌入式SQL语句，这些语句在词法上遵循，直到另一个CONTEXT USE语句覆盖它。</p>
                     <p>示出了说明上下文语句的各种用途的示例。</p>
                  </div><a id="LNPCB797"></a><div class="props_rev_3"><a id="GUID-D707098F-E3A5-4587-8AFE-905283214A62" name="GUID-D707098F-E3A5-4587-8AFE-905283214A62"></a><h5 id="LNPCB-GUID-D707098F-E3A5-4587-8AFE-905283214A62" class="sect5"><span class="enumeration_section">12.4.2.1</span>不允许使用SQL-CONTEXT的主机表</h5>
                     <div>
                        <p>您不能声明SQL-CONTEXT的主机表。相反，声明一个S9（9）COMP变量的主机表，然后在子程序中将它们重新声明为SQL-CONTEXT后，一次将它们传递给子程序。</p>
                     </div>
                  </div><a id="LNPCB798"></a><div class="props_rev_3"><a id="GUID-D77E0F29-44D0-4E37-BCBD-E99C3A57397F" name="GUID-D77E0F29-44D0-4E37-BCBD-E99C3A57397F"></a><h5 id="LNPCB-GUID-D77E0F29-44D0-4E37-BCBD-E99C3A57397F" class="sect5"><span class="enumeration_section">12.4.2.2</span> <span class="bold">EXEC SQL ENABLE THREADS</span></h5>
                     <div>
                        <div class="section">
                           <p>此可执行SQL语句初始化支持多个线程的进程。这必须是包含多线程应用程序的程序中的第一个可执行SQL语句。在应用程序的所有文件中只能有一个ENABLE THREADS语句，或者出现错误结果。有关更多详细信息，请参阅“ENABLE THREADS（可执行嵌入式SQL扩展）”。</p>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="relinfo">
                           <p><strong>相关话题</strong></p>
                           <ul>
                              <li><a href="embedded-SQL-statements-and-precompiler-directives.html#GUID-CBDF1FDD-24BB-424B-8ED5-F228AB8DC017">ENABLE THREADS（可执行嵌入式SQL扩展）</a></li>
                           </ul>
                        </div>
                     </div>
                     
                  </div><a id="LNPCB799"></a><div class="props_rev_3"><a id="GUID-6575398B-BD03-4879-B520-7967748FD825" name="GUID-6575398B-BD03-4879-B520-7967748FD825"></a><h5 id="LNPCB-GUID-6575398B-BD03-4879-B520-7967748FD825" class="sect5"><span class="enumeration_section">12.4.2.3</span> <span class="bold">EXEC SQL上下文</span> <span class="enumeration_section">分配</span></h5>
                     <div>
                        <div class="section">
                           <p>此可执行SQL语句为指定的运行时上下文分配和初始化内存;必须将运行时上下文变量声明为SQL_CONTEXT类型。有关更多详细信息，请参阅“CONTEXT ALLOCATE（可执行嵌入式SQL扩展）”。</p>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="relinfo">
                           <p><strong>相关话题</strong></p>
                           <ul>
                              <li><a href="embedded-SQL-statements-and-precompiler-directives.html#GUID-E76AF7D6-771A-465D-B039-27B1BF095A0E">CONTEXT ALLOCATE（可执行的嵌入式SQL扩展）</a></li>
                           </ul>
                        </div>
                     </div>
                     
                  </div><a id="LNPCB800"></a><div class="props_rev_3"><a id="GUID-BEDB43AC-FAF0-4FFC-8F1C-73635A883589" name="GUID-BEDB43AC-FAF0-4FFC-8F1C-73635A883589"></a><h5 id="LNPCB-GUID-BEDB43AC-FAF0-4FFC-8F1C-73635A883589" class="sect5"><span class="enumeration_section">12.4.2.4</span> EXEC SQL上下文使用</h5>
                     <div>
                        <div class="section">
                           <p><a id="d77950e573" class="indexterm-anchor"></a><a id="d77950e575" class="indexterm-anchor"></a><a id="d77950e579" class="indexterm-anchor"></a><a id="d77950e581" class="indexterm-anchor"></a><a id="d77950e585" class="indexterm-anchor"></a> EXEC SQL CONTEXT USE指令指示预编译器将指定的运行时上下文用于后续可执行SQL语句。必须使用EXEC SQL CONTEXT ALLOCATE语句预先分配指定的运行时上下文。
                           </p>
                           <p>EXEC SQL CONTEXT USE指令与EXEC SQL WHENEVER指令的工作方式类似，它会影响在给定源文件中位于其后的所有可执行SQL语句，而不考虑标准COBOL范围规则。</p>
                           <p>有关更多详细信息，请参阅“上下文使用（Oracle嵌入式SQL指令）”和“CONTEXT ALLOCATE（可执行嵌入式SQL扩展）”。</p>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="relinfo">
                           <p><strong>相关话题</strong></p>
                           <ul>
                              <li><a href="embedded-SQL-statements-and-precompiler-directives.html#GUID-01F374A6-6CA0-4F3A-8784-869E3102976E">上下文使用（Oracle嵌入式SQL指令）</a></li>
                              <li><a href="embedded-SQL-statements-and-precompiler-directives.html#GUID-E76AF7D6-771A-465D-B039-27B1BF095A0E">CONTEXT ALLOCATE（可执行的嵌入式SQL扩展）</a></li>
                           </ul>
                        </div>
                     </div>
                     
                  </div><a id="LNPCB801"></a><div class="props_rev_3"><a id="GUID-BB29E84F-B3B0-4E53-9F4A-39D7470EFE94" name="GUID-BB29E84F-B3B0-4E53-9F4A-39D7470EFE94"></a><h5 id="LNPCB-GUID-BB29E84F-B3B0-4E53-9F4A-39D7470EFE94" class="sect5"><span class="enumeration_section">12.4.2.5</span> <span class="bold">EXEC SQL语境免费</span></h5>
                     <div>
                        <div class="section">
                           <p>EXEC SQL CONTEXT FREE可执行SQL语句释放与指定运行时上下文关联的内存，并在主程序变量中放置空指针。有关更多详细信息，请参阅“CONTEXT FREE（可执行嵌入式SQL扩展）”。</p>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="relinfo">
                           <p><strong>相关话题</strong></p>
                           <ul>
                              <li><a href="embedded-SQL-statements-and-precompiler-directives.html#GUID-A9BB556B-0E00-4E59-ACDF-06EB96AE615C">CONTEXT FREE（可执行嵌入式SQL扩展）</a></li>
                           </ul>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="LNPCB802"></a><div class="props_rev_3"><a id="GUID-B24992BA-3F10-4184-BB67-A903E7EDF9E5" name="GUID-B24992BA-3F10-4184-BB67-A903E7EDF9E5"></a><h4 id="LNPCB-GUID-B24992BA-3F10-4184-BB67-A903E7EDF9E5" class="sect4"><span class="enumeration_section">12.4.3</span>与Pro * C / C ++程序通信</h4>
                  <div>
                     <p>可以使用链接部分中定义的参数传递运行时上下文。多线程Pro * C / C ++程序可以调用Pro * COBOL子程序，Pro * COBOL程序可以调用用Pro * C / C ++编写的子程序。</p>
                  </div>
               </div><a id="LNPCB803"></a><div class="props_rev_3"><a id="GUID-05DFF012-F61F-4EE8-9E07-B3F68D835508" name="GUID-05DFF012-F61F-4EE8-9E07-B3F68D835508"></a><h4 id="LNPCB-GUID-05DFF012-F61F-4EE8-9E07-B3F68D835508" class="sect4"><span class="enumeration_section">12.4.4</span>多线程编程注意事项</h4>
                  <div>
                     <p>虽然Oracle确保SQLLIB代码是线程安全的，但您有责任确保源代码能够与线程一起正常工作。例如，仔细考虑您使用的变量的范围。</p>
                     <p>此外，多线程需要有关以下内容的设计决策：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>为每个运行时上下文包含一个SQLCA。</p>
                        </li>
                        <li>
                           <p>将SQLDA声明为线程安全的组项，如SQLCA，通常是一个自动变量，每个运行时上下文一个。</p>
                        </li>
                        <li>
                           <p>以线程安全的方式声明主机变量，换句话说，仔细考虑使用静态和全局主机变量。</p>
                        </li>
                        <li>
                           <p>避免在多个线程中同时使用运行时上下文。</p>
                        </li>
                        <li>
                           <p>是否使用默认数据库连接或使用AT子句显式定义它们。</p>
                        </li>
                     </ul>
                     <p>在给定时间，只有一个可执行的嵌入式SQL语句（例如，EXEC SQL UPDATE）在运行时上下文中可能是未完成的。</p>
                     <p>预编译应用程序的现有要求也适用。例如，对给定游标的所有引用必须出现在同一源文件中。</p>
                  </div><a id="LNPCB804"></a><div class="props_rev_3"><a id="GUID-BA6E7019-B55B-466E-97A4-25D284D4CEFF" name="GUID-BA6E7019-B55B-466E-97A4-25D284D4CEFF"></a><h5 id="LNPCB-GUID-BA6E7019-B55B-466E-97A4-25D284D4CEFF" class="sect5"><span class="enumeration_section">12.4.4.1</span>多线程的限制</h5>
                     <div>
                        <div class="section">
                           <p>使用线程时，以下限制有效：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>您不能使用数组类型SQL-CONTEXT数组。</p>
                              </li>
                              <li>
                                 <p>并发线程应该都有自己的SQLCA。</p>
                              </li>
                              <li>
                                 <p>并发线程应该都有自己的上下文区域。</p>
                              </li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="LNPCB805"></a><div class="props_rev_3"><a id="GUID-783A245F-DBEB-48BA-B017-18600EB3B285" name="GUID-783A245F-DBEB-48BA-B017-18600EB3B285"></a><h4 id="LNPCB-GUID-783A245F-DBEB-48BA-B017-18600EB3B285" class="sect4"><span class="enumeration_section">12.4.5</span>多个上下文示例</h4>
                  <div>
                     <p>本节中的代码片段显示了如何使用多个上下文，并演示了上下文使用语句的范围。</p>
                  </div><a id="LNPCB806"></a><div class="props_rev_3"><a id="GUID-957D2164-3D1E-4812-8164-2FF4D0D5D0B6" name="GUID-957D2164-3D1E-4812-8164-2FF4D0D5D0B6"></a><h5 id="LNPCB-GUID-957D2164-3D1E-4812-8164-2FF4D0D5D0B6" class="sect5"><span class="enumeration_section">12.4.5.1</span>例1</h5>
                     <div>
                        <p>在第一个示例中，不需要预编译器选项设置THREADS = YES，因为我们不生成线程：</p><pre class="oac_no_warn" dir="ltr">识别部门。 PROGRAM-ID。主要。 ...*声明一个上下文区域01 CTX1 SQL-CONTEXT。 01 UID1 PIC X（11）值“SCOTT / TIGER”。01 UID2 PIC X（10）值“MARY / LION”程序部分。 ...*分配上下文区域EXEC SQL CONTEXT ALLOCATE：CTX1 END-EXEC。 EXEC SQL语境使用：CTX1 END-EXEC。 *所有语句直到下一个上下文使用将使用CTX1 EXEC SQL CONNECT：UID1 END-EXEC。 EXEC SQL SELECT ....EXEC SQL语境使用DEFAULT END-EXEC。 *前面一行之后的所有语句都将使用默认上下文EXEC SQL CONNECT：UID2 END-EXEC。 EXEC SQL INSERT .........</pre></div>
                  </div><a id="LNPCB807"></a><div class="props_rev_3"><a id="GUID-82384FEE-A2F2-40DF-A9DF-7A2F689541D8" name="GUID-82384FEE-A2F2-40DF-A9DF-7A2F689541D8"></a><h5 id="LNPCB-GUID-82384FEE-A2F2-40DF-A9DF-7A2F689541D8" class="sect5"><span class="enumeration_section">12.4.5.2</span>例2</h5>
                     <div>
                        <p>下一个示例显示了多个上下文。生成的线程使用一个上下文，而主程序使用另一个上下文。启动的线程SUBPRGM1将使用上下文CTX1，它通过LINKAGE SECTION传递给它。此示例还演示了CONTEXT USE语句的范围。</p>
                        <div class="infoboxnote" id="GUID-82384FEE-A2F2-40DF-A9DF-7A2F689541D8__GUID-19C69E99-3889-4881-BB35-800965DC7578">
                           <p class="notep1">注意：</p>
                           <p>您必须使用选项THREADS = YES预编译主程序文件和本节中每个后续示例的主程序。</p>
                        </div><pre class="oac_no_warn" dir="ltr">识别部门。 PROGRAM-ID。主要。 ...*声明两个上下文区域01 CTX1 SQL-CONTEXT。 01 CTX2 SQL-CONTEXT。程序部门。 *启用线程EXEC SQL ENABLE THREADS END-EXEC。 *分配上下文区域EXEC SQL CONTEXT ALLOCATE：CTX1 END-EXEC。 EXEC SQL语境分配：CTX2 END-EXEC。 *在此处使用CTX1包含您的代码以启动线程“SUBPGM1”。EXEC SQL语境使用：CTX2 END-EXEC。 *前面几行之后的所有语句都将使用CTX2 EXEC SQL CONNECT：USERID END-EXEC。 EXEC SQL INSERT ........
</pre><p>线程<code class="codeph">SUBPRGM1</code>在另一个文件中：</p><pre class="oac_no_warn" dir="ltr">PROGRAM-ID。 SUBPRGM1。...01 USERID PIC X（11）值“SCOTT / TIGER”。链接部分。 01 CTX1 SQL-CONTEXT。使用CTX1的程序部门。EXEC SQL语境使用：CTX1 END-EXEC。 EXEC SQL CONNECT：USERID END-EXEC。 EXEC SQL SELECT ......</pre></div>
                  </div><a id="LNPCB808"></a><div class="props_rev_3"><a id="GUID-FA2239A2-CFC4-43B9-AA7C-F97ED3682217" name="GUID-FA2239A2-CFC4-43B9-AA7C-F97ED3682217"></a><h5 id="LNPCB-GUID-FA2239A2-CFC4-43B9-AA7C-F97ED3682217" class="sect5"><span class="enumeration_section">12.4.5.3</span>例3</h5>
                     <div>
                        <p>以下示例使用多个线程。每个线程都有自己的上下文。如果要同时执行线程，则每个线程<span class="italic">必须</span>具有自己的上下文。使用START语句的USING CLAUSE将上下文传递给线程，并在线程子程序的LINKAGE SECTION中声明。
                        </p><pre class="oac_no_warn" dir="ltr">识别部门。 PROGRAM-ID。主要。 ...数据部门。 01 CTX1 SQL-CONTEXT。 01 CTX2 SQL-CONTEXT。程序部门。 ...EXEC SQL ENABLE THREADS END-EXEC。 EXEC SQL语境分配：CTX1 END-EXEC。 EXEC SQL语境分配：CTX2 END-EXEC。 *在此处使用CTX1包含您的代码以启动线程“SUBPGM”。*在此处使用CTX2包含您的代码以启动线程“SUBPGM”。...
</pre><p>线程SUBPGM放在另一个文件中：</p><pre class="oac_no_warn" dir="ltr">PROGRAM-ID。 SUBPGM。 ...数据部门。 ...01 USERID PIC X（11）值“SCOTT / TIGER”。...链接部分。 01 CTX SQL-CONTEXT。使用CTX的程序部门。 EXEC SQL语境使用：CTX END-EXEC。 EXEC SQL CONNECT：USERID END-EXEC。 EXEC SQL SELECT .......</pre></div>
                  </div><a id="LNPCB809"></a><div class="props_rev_3"><a id="GUID-378D62AD-A3C3-4250-B112-84CC6E9B3B18" name="GUID-378D62AD-A3C3-4250-B112-84CC6E9B3B18"></a><h5 id="LNPCB-GUID-378D62AD-A3C3-4250-B112-84CC6E9B3B18" class="sect5"><span class="enumeration_section">12.4.5.4</span>例4</h5>
                     <div>
                        <p>下一个示例基于前面的示例，但是在顶级程序中进行连接并将与上下文的连接传递给线程子程序。</p><pre class="oac_no_warn" dir="ltr">识别部门。 PROGRAM-ID。主要。 ...数据部门。 01 CTX1 SQL-CONTEXT。 01 CTX2 SQL-CONTEXT。 01 USERID PIC X（11）值“SCOTT / TIGER”。ROCEDURE DIVISION。 EXEC SQL ENABLE THREADS END-EXEC。 EXEC SQL语境分配：CTX1 END-EXEC。 EXEC SQL语境分配：CTX2 END-EXEC。 EXEC SQL语境使用：CTX1 END-EXEC。 EXEC SQL CONNECT：USERID END-EXEC。 EXEC SQL语境使用：CTX2 END-EXEC。 EXEC SQL CONNECT：USERID END-EXEC。 *在此处使用CTX1包含您的代码以启动线程“SUBPGM”。*在此处使用CTX2包含您的代码以启动线程“SUBPGM”。...
</pre><p>线程<code class="codeph">SUBPRGM</code>在另一个文件中：</p><pre class="oac_no_warn" dir="ltr">PROGRAM-ID。 SUBPGM。 ...链接部分。 01 CTX SQL-CONTEXT。使用CTX的程序部门。 EXEC SQL语境使用：CTX END-EXEC。 EXEC SQL SELECT .......</pre></div>
                  </div><a id="LNPCB810"></a><div class="props_rev_3"><a id="GUID-BF19B005-C377-4F11-84C7-8F6F07982CE7" name="GUID-BF19B005-C377-4F11-84C7-8F6F07982CE7"></a><h5 id="LNPCB-GUID-BF19B005-C377-4F11-84C7-8F6F07982CE7" class="sect5"><span class="enumeration_section">12.4.5.5</span>例5</h5>
                     <div>
                        <p>以下示例显示了共享上下文的多个线程。请注意，在这种情况下， <span class="italic">必须</span>序列化线程。
                        </p><pre class="oac_no_warn" dir="ltr">识别部门。 PROGRAM-ID。主要。 ...数据部门。 01 CTX1 SQL-CONTEXT。程序部门。 EXEC SQL ENABLE THREADS END-EXEC。 EXEC SQL语境分配：CTX1 END-EXEC。 *在此处使用CTX1包含您的代码以启动thread1“SUBPGM1”。*包括你的代码在这里等待thread1。*在此处使用CTX1包含您的代码以启动thread2“SUBPGM2”。...
</pre><p>这两个线程有两个单独的文件。首先是：</p><pre class="oac_no_warn" dir="ltr">PROGRAM-ID。 SUBPGM1。...数据部门。 ..01 USERID PIC X（11）值“SCOTT / TIGER”。...链接部分。 01 CTX SQL-CONTEXT。使用CTX的程序部门。 EXEC SQL语境使用：CTX END-EXEC。 ...EXEC SQL CONNECT：USERID END-EXEC。</pre><p>另一个文件包含SUBPGM2：</p><pre class="oac_no_warn" dir="ltr">PROGRAM-ID。 SUBPGM2。...数据部门。 ...链接部分。 01 CTX SQL-CONTEXT。使用CTX的程序部门。 EXEC SQL语境使用：CTX END-EXEC。 EXEC SELECT .......</pre></div>
                  </div>
               </div>
            </div><a id="LNPCB811"></a><div class="props_rev_3"><a id="GUID-3E515B07-BE56-42FE-AC8B-88E2FDFA63BA" name="GUID-3E515B07-BE56-42FE-AC8B-88E2FDFA63BA"></a><h3 id="LNPCB-GUID-3E515B07-BE56-42FE-AC8B-88E2FDFA63BA" class="sect3"><span class="enumeration_section">12.5</span>多线程示例</h3>
               <div>
                  <p>此多文件应用程序演示了一种使用SQLLIB运行时上下文区域（SQL-CONTEXT）来支持多个线程的方法。预编译THREADS = YES。</p>
                  <p>主程序orathrd2声明了一个S9（9）COMP变量数组，用于保存sqllib上下文。它可以通过线程进行线程化</p><pre class="oac_no_warn" dir="ltr">EXEC SQL ENABLE THREADS END-EXEC。</pre><p>语句然后调用子程序oracon（在文件<code class="codeph">oracon.pco</code> ）来分配线程。 oracon还为每个分配的上下文建立连接。
                  </p>
                  <p>接下来，ORTHRD2将上下文传递给其中一个线程入口点THREAD-1或THREAD-2。THREAD-1只选择并显示员工的薪水。THREAD-2选择并更新该员工的薪水。由于THREAD-2发出提交，因此在提交后执行SELECT的线程可以看到更新。（但不是与更新同时运行的那些。）请注意，输出因运行而异，因为更新和提交的时间是非决定性的。</p>
                  <p>重要的是要记住，并发线程必须各自拥有自己的上下文。上下文可以传递给后续线程并由后续线程使用，但线程可能不会同时使用相同的上下文。此模型可用于连接池，其中最初创建最大连接数并将其传递给可用的线程，以执行用户的请求。</p>
                  <p>使用了一组S9（9）COMP变量，因为您当前无法声明SQL-CONTEXT数组。</p>
                  <p><span class="bold">注意：</span>此程序专为运行Solaris和MicroFocus ServerExpress编译器的Sun工作站开发，并使用特定于供应商的指令和功能。
                  </p>
                  <p>有关支持多线程的特定COBOL语句，请参阅特定于平台的文档。</p>
                  <p>主程序在文件<code class="codeph">orathrd2.pco</code> ：</p><pre class="oac_no_warn" dir="ltr">$ SET REENTRANT MF IDENTIFICATION DIVISION。 PROGRAM-ID。 ORATHRD2。环境部门。数据部门。工作储存部分。 78 MAX-LOOPS VALUE 10。01 THREAD-ID使用指针。 01 TP-1使用线程指示器最大限度。 01 IDEN-4 PIC 9（4）。01 LOOP-COUNTER PIC 9（2）COMP-X外部。 01 PEMPNO PIC S9（4）COMP外部。 01 ISAL PIC S9（4）COMP VALUE ZERO。 EXEC SQL包含SQLCA END-EXEC。线 - 局部存储部分。 01上下文区域PIC S9（9）COMP OCCURS MAX-LOOPS。程序部门。主要部分。执行初始化操作ORACLE-CONNECTIONS循环计数从1到1循环计数器&gt;最大循环执行循环计数从1到1循环计数器&gt;最大循环执行启动 - 线程结束停止运行。 * ------------------------------------------------- -------------- *检查我们是否在多线程RTS下运行。 * ------------------------------------------------- --------------初始化部分。 CALL“CBL_THREAD_SELF”使用THREAD-ID打开显示“此RTS中没有线程支持”STOP RUN END-CALL如果返回代码= 1008显示“无法在单线程RTS上运行此测试”停止运行结束 - 如果显示“MULTI-线程RTS“*允许线程必须在任何上下文使用之前执行EXEC SQL使线程结束 - 执行。如果SQLCODE NOT = ZERO显示'错误启用ORACLE线程支持'' - 中止：'SQLERRMC停止运行结束 - 如果*为员工编号设置值。因为这是一个*外部变量，其价值的副本对于本应用程序中的其他模块是可见的，将7566移至PEMPNO退出部分。 * ------------------------------------------------- ---------------- *创建线程并开始使用线程1或线程2 * ------------------- ---------------------------------------------- START-THREAD SECTION 。如果LOOP-COUNTER = 2或LOOP-COUNTER = 5启动“THREAD-2”使用TP-1（循环计数器）状态识别的上下文区域（循环计数器）状态为IDEN-4 ON EXPLPTION DISPLAY“THREAD CREATE FAILED” END-START如果IDEN-4 NOT =零显示“线程创建失败返回”IDEN-4结束 - 如果使用TP-1（循环计数器）状态识别的上下文区域（循环计数器）开始“线程-1”是IDEN-4在例外显示“线程创建失败”结束 - 如果IDEN-4不是= ZERO显示“线程创建失败返回”IDEN-4 END-IF END-IF。 START-线程结束。退出部分。 * ------------------------------------------------- ---------------- *分配上下文区域与每个区域建立连接。 * ------------------------------------------------- ---------------- ORACLE-CONNECTIONS部分。使用上下文区域（LOOP-COUNTER）呼叫“ORACON”。ORACLE的连接-END。退出部分。</pre><p>这是文件<code class="codeph">thread-1.pco</code> ：</p><pre class="oac_no_warn" dir="ltr">*这是第1个主题。它选择并显示*员工的数据。已建立连接*的上下文区域通过*链接部分传递给线程。在多文件应用程序中，您*可以通过链接部分传递上下文。*使用THREADS = YES进行预编译。 * $ SET REENTRANT MF IDENTIFICATION DIVISION。 PROGRAM-ID。线程1。环境部门。数据部门。工作储存部分。 01 PEMPNO PIC S9（4）COMP外部。本地存储部分。 01 DEMPNO PIC Z（4）VALUE ZERO。 01 PEMP-NAME1 PIC X（15）变化值空间。 01 PSAL-VALUE1 PIC S9（7）V99 COMP-3 VALUE ZERO。 01 ISAL1 PIC S9（4）COMP VALUE ZERO。 01 DSAL-VALUE PIC +（7）.99 VALUE ZERO。 EXEC SQL包含SQLCA END-EXEC。链接部分。 01 CONTEXT-AREA1 SQL-CONTEXT。 * ------------------------------------------------- -------------- *使用上下文传递，为员工选择和显示*数据。* ------------------------------------------------- --------------使用上下文区域的程序划分。主要部分。执行SQL WHENEVER SQLERROR GOTO SELECT-ERROR END-EXEC EXEC SQL语境使用：CONTEXT-AREA1 END-EXEC EXEC SQL SELECT ENAME，SAL INTO：PEMP-NAME1，：PSAL-VALUE1：ISAL1来自EMP，其中EMPNO =：PEMPNO END-EXEC如果ISAL1 &lt;ZERO移动零到PSAL-VALUE1结束 - 如果移动PEMPNO到DEMPNO将PSAL-VALUE1移动到DSAL值显示“EMP”，DEMPNO，“NAME”，PEMP-NAME1-ARR（1：PEMP-NAME1-LEN ），“当前薪资是”，DSAL-VALUE EXIT PROGRAM。 * ------------------------------------------------- -------------- *从EMP表中选择时出现错误* ----------------------- ---------------------------------------- SELECT-ERROR SECTION。 EXEC SQL WHENEVER SQLERROR CONTINUE END-EXEC DISPLAY“HAC ORACLE ERROR SELECTING EMPNO 7566”DISPLAY“SQLCODE =”，SQLCODE DISPLAY“ERROR TEXT”，SQLERRMC（1：SQLERRML）GOBACK EXIT SECTION。</pre><p>这是文件<code class="codeph">thread-2.pco</code> ：</p><pre class="oac_no_warn" dir="ltr">*这是第2个主题。程序将选择，然后更新，*增量，然后提交工资。它使用先前已建立连接的传入*上下文。*使用THREADS = YES进行预编译。 * $ SET REENTRANT MF IDENTIFICATION DIVISION。 PROGRAM-ID。线程2。环境部门。数据部门。工作储存部分。 01 PEMPNO PIC S9（4）COMP外部。本地存储部分。 01 DEMPNO PIC Z（4）VALUE ZERO。 01 PEMP-NAME2 PIC X（15）变化值空间。 01 PSAL-VALUE2 PIC S9（7）V99 COMP-3值100。01 ISAL2 PIC S9（4）COMP VALUE ZERO。 01 DSAL-VALUE PIC +（7）.99 VALUE ZERO。 EXEC SQL包含SQLCA END-EXEC。链接部分。 01 CONTEXT-AREA2 SQL-CONTEXT。 * ------------------------------------------------- -------------- *使用在上下文区域内通过，首先选择获得初始*价值，增加薪酬，更新和承诺。 * ------------------------------------------------- --------------使用上下文区域的程序划分。主要部分。 EXEC SQL WHENEVER SQLERROR GOTO UPDATE-ERROR END-EXEC EXEC SQL语境使用：CONTEXT-AREA2 END-EXEC EXEC SQL SELECT ENAME，SAL INTO：PEMP-NAME2，：PSAL-VALUE2：ISAL2来自EMP，其中EMPNO =：PEMPNO END-EXEC添加10到PSAL-VALUE2 EXEC SQL更新EMP设置SAL =：PSAL-VALUE2在哪里EMPNO =：PEMPNO END-EXEC将PEMPNO移动到DEMPNO将PSAL-VALUE2移动到DSAL值显示“FOR EMP”，DEMPNO，“NAME”，PEMP -NAME2-ARR（1：PEMP-NAME2-LEN），“更新的薪水是”，DSAL-VALUE *此提交是必需的，否则数据库*将因为更新而阻止同一行EXEC SQL COMMIT WORK END- EXEC EXIT PROGRAM。 * ------------------------------------------------- -------------- *在EMP表中更新SAL时出现错误* --------------------- ------------------------------------------ UPDATE-ERROR SECTION。 EXEC SQL WHENEVER SQLERROR CONTINUE END-EXEC DISPLAY“HAC ORACLE ERROR UPDATING EMPNO 7566”DISPLAY“SQLCODE =”，SQLCODE DISPLAY“ERROR TEXT”，SQLERRMC（1：SQLERRML）GOBACK EXIT SECTION。</pre><p>文件<code class="codeph">oracon.pco</code>如下：</p><pre class="oac_no_warn" dir="ltr">*此程序分配SQLLIB运行时上下文，存储*指向变量的上下文的指针，该变量是从主程序通过链接部分*传入的，并在分配的上下文上建立连接。* *此程序是为Merant MicroFocus COBOL编写的，并使用*特定于供应商的指令和功能。使用THREADS = YES预编译*。 * $ SET REENTRANT MF IDENTIFICATION DIVISION。 PROGRAM-ID。 ORACON。环境部门。数据部门。工作储存部分。 01登录PIC X（40）值空间。 EXEC SQL包含SQLCA END-EXEC。链接部分。 01上下文SQL-CONTEXT。使用上下文的程序划分。主要部分。 * ------------------------------------------------- ---------------- *分配上下文区域与每个区域建立连接。 * ------------------------------------------------- ---------------- ORACLE-CONNECTION SECTION。将“SCOTT / TIGER”移至登录执行SQL语境分配：上下文结束 - 执行如果SQLCODE NOT = ZERO显示'错误分配上下文'' - 中止：'SQLERRMC GOBACK ELSE显示'上下文分配'结束 - 如果执行SQL语境使用：CONTEXT END-EXEC EXEC SQL CONNECT：登录结束-ECEC如果SQLCODE NOT = ZERO'显示'错误连接第二个线到数据库'' -  ABORT TEST：'SQLERRMC GOBACK ELSE显示'连接已建立'END-IF-EXIT SECTION。</pre></div>
            </div>
         </div>
      </article>
   </body>
</html>