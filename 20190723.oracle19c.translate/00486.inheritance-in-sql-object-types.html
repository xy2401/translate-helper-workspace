<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <title>SQL对象类型中的继承</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Object-Relational Developer&#39;s Guide "></meta>
      <meta property="og:description" content=""></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Object-Relational Developer&#39;s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="object-relational-developers-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-11T02:05:10-08:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="1996, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96436-01"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="object-methods.html" title="Previous" type="text/html"></link>
      <link rel="next" href="functions-and-operators-useful-with-objects.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Object-Relational Developer&#39;s Guide"></meta>
    <meta name="dcterms.isVersionOf" content="ADOBJ"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="object-methods.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="functions-and-operators-useful-with-objects.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">对象关系开发人员指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="basic-components-of-oracle-objects.html" property="item" typeof="WebPage"><span property="name">Oracle Objects的基本组件</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">SQL对象类型中的继承</li>
            </ol>
            <a id="GUID-D6D92FB6-7BC4-4EE6-A9EC-BC69C5BA5A56" name="GUID-D6D92FB6-7BC4-4EE6-A9EC-BC69C5BA5A56"></a><a id="ADOBJ00205"></a>
            
            <h2 id="ADOBJ-GUID-D6D92FB6-7BC4-4EE6-A9EC-BC69C5BA5A56" class="sect2"><span class="enumeration_section">2.3</span> SQL对象类型中的继承</h2>
         </header>
         <div class="ind">
            <div>
               <p>SQL对象继承基于形成类型层次结构的对象类型的族树。类型层次结构由父对象类型（称为超类型）和一个或多个子对象类型级别（称为子类型）组成，这些子对象类型派生自父级。</p>
               <p>话题：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="inheritance-in-sql-object-types.html#GUID-7082F4A5-5353-4D41-9894-E33827F57B75">关于SQL对象类型中的继承</a></p>
                  </li>
                  <li>
                     <p><a href="inheritance-in-sql-object-types.html#GUID-C9382BAD-3513-4CFB-9D4D-D3BC5B581AA8" title="亚型可以通过其他亚型的间插水平直接或间接地从超型衍生。">超类型和子类型</a></p>
                  </li>
                  <li>
                     <p><a href="inheritance-in-sql-object-types.html#GUID-E15EC4A3-A894-4DB4-AE8F-0B2B99429B29" title="对象类型可以是可继承的，如果定义了方法，则可以覆盖方法。">FINAL和NOT FINAL继承的类型和方法</a></p>
                  </li>
                  <li>
                     <p><a href="inheritance-in-sql-object-types.html#GUID-132DAF47-6A1D-435E-B9A4-969490385CD0" title="您可以创建包含超类型和子类型实例的表。">子类型创建</a></p>
                  </li>
                  <li>
                     <p><a href="inheritance-in-sql-object-types.html#GUID-1E601CC0-5AA6-4DEE-9241-509F1F45649A" title="创建时，类型和方法可以声明为NOT INSTANTIABLE。">不可行的类型和方法</a></p>
                  </li>
                  <li>
                     <p><a href="inheritance-in-sql-object-types.html#GUID-9A965E24-9922-448F-A887-05A96EBC7B28">重载和重写的方法</a></p>
                  </li>
                  <li>
                     <p><a href="inheritance-in-sql-object-types.html#GUID-C2DF60C8-025E-49E3-ABE4-375C4E36D806" title="动态方法分派是指在运行时将方法调用分派到最近的实现的方式，从当前或指定的类型处理类型层次结构。">动态方法调度</a></p>
                  </li>
                  <li>
                     <p><a href="inheritance-in-sql-object-types.html#GUID-903F72C4-E4CE-4175-9972-EA13450F2DFB">在类型层次结构中键入替换</a></p>
                  </li>
                  <li>
                     <p><a href="inheritance-in-sql-object-types.html#GUID-7AD15180-6B5B-4007-9822-189601A25614" title="您可以替换对象表中的对象类型列和对象类型行。">列和行可替代性</a></p>
                  </li>
                  <li>
                     <p><a href="inheritance-in-sql-object-types.html#GUID-9310EC5A-0ED4-42D6-86F9-01F2D0D609A0" title="如果创建子类型，则任何已具有超类型的可替换列的表也可以存储新的子类型。">存储在可替换列中的新创建的子类型</a></p>
                  </li>
                  <li>
                     <p><a href="inheritance-in-sql-object-types.html#GUID-B8F5B0D0-B61B-4990-8045-2EB6F1C61F47" title="当您使用VALIDATE选项删除子类型时，它会检查子类型的任何可替换列中是否存储子类型的实例。如果没有这样的实例，则DROP操作完成。">创建可替换列后删除子类型</a></p>
                  </li>
                  <li>
                     <p><a href="inheritance-in-sql-object-types.html#GUID-A36A7587-4184-48CA-8EC2-099CB8933754" title="在创建表时，可以关闭列或属性的所有可替换性，包括嵌入的属性和嵌套的集合。">关闭新表中的替代品</a></p>
                  </li>
                  <li>
                     <p><a href="inheritance-in-sql-object-types.html#GUID-C2A190CF-251C-471C-8C77-719D751ACFC2" title="您可以强制使用约束将对象列或属性中允许的子类型范围限制为声明类型的层次结构中的特定子类型。">限制替代性</a></p>
                  </li>
                  <li>
                     <p><a href="inheritance-in-sql-object-types.html#GUID-B3CCBD8C-29C9-4B39-939C-258711505E8D">修改表上的可替代性</a></p>
                  </li>
                  <li>
                     <p><a href="inheritance-in-sql-object-types.html#GUID-570E2FF9-E36F-4E11-9BFE-5F41270D2F7F">修改替代性的限制</a></p>
                  </li>
                  <li>
                     <p><a href="inheritance-in-sql-object-types.html#GUID-7C8C1750-6182-4351-B177-FDD398E55E70" title="在集合类型的表达式的赋值中，源和目标必须具有相同的声明类型。">跨类型的分配</a></p>
                  </li>
               </ul>
            </div>
            <div class="props_rev_3"><a id="GUID-7082F4A5-5353-4D41-9894-E33827F57B75" name="GUID-7082F4A5-5353-4D41-9894-E33827F57B75"></a><h3 id="ADOBJ-GUID-7082F4A5-5353-4D41-9894-E33827F57B75" class="sect3"><span class="enumeration_section">2.3.1</span>关于SQL对象类型中的继承</h3>
               <div>
                  <p>继承是将层次结构中的子类型连接到其超类型的机制。</p>
                  <p>子类型自动继承其父类型的属性和方法。此外，继承链接仍然存在。子类型自动获取对父级中的这些属性或方法所做的任何更改：在超类型中更新的任何属性或方法也会以子类型进行更新。</p>
                  <div class="infoboxnote" id="GUID-7082F4A5-5353-4D41-9894-E33827F57B75__GUID-EFF464D4-30C0-4811-9CA2-960209C9A5B2">
                     <p class="notep1">注意：</p>
                     <p>Oracle仅支持单继承。因此，子类型可以直接从一个超类型派生，而不是多于一个。</p>
                  </div>
                  <p>对于类型层次结构中的对象类型，您可以对诸如客户之类的实体进行建模，还可以在原始类型下定义不同的客户<a href="glossary.html#GUID-D432CD11-A4EC-4DC7-8115-0AB8C08DF036"><span class="xrefglossterm">专用</span></a>子类型。然后，您可以在层次结构上执行操作，并使每种类型以特殊方式实现和执行操作。
                  </p>
               </div>
            </div><a id="ADOBJ7102"></a><a id="ADOBJ7101"></a><div class="props_rev_3"><a id="GUID-C9382BAD-3513-4CFB-9D4D-D3BC5B581AA8" name="GUID-C9382BAD-3513-4CFB-9D4D-D3BC5B581AA8"></a><h3 id="ADOBJ-GUID-C9382BAD-3513-4CFB-9D4D-D3BC5B581AA8" class="sect3"><span class="enumeration_section">2.3.2</span>超类型和子类型</h3>
               <div>
                  <p>亚型可以通过其他亚型的间插水平直接或间接地从超型衍生。</p>
                  <p>超类型可以有多个兄弟子类型，但子类型最多只能有一个直接父超类型（单继承）。</p>
                  <div class="figure" id="GUID-C9382BAD-3513-4CFB-9D4D-D3BC5B581AA8__GUID-DC616615-72CD-4484-A1A4-48105E4EDA64">
                     <p class="titleinfigure">图2-1类型层次结构中的超类型和子类型</p><img src="img/adobj027.gif" width="496" alt="下面描述图2-1" title="下面描述图2-1" longdesc="img_text/adobj027.html"><br><a href="img_text/adobj027.html">“图2-1类型层次结构中的超类型和子类型”的描述</a></div>
                  <!-- class="figure" -->
                  <p>要从超类型派生子类型，请定义超类型的专用变体，该变量将新的属性和方法添加到从父级继承的集合或重新定义（覆盖）继承的方法。例如，从<code class="codeph">person_typ</code>对象类型中，您可以派生特殊类型<code class="codeph">student_typ</code>和<code class="codeph">employee_typ</code> 。这些子类型中的每一个仍然是<code class="codeph">person_typ</code> ，但是是一种特殊的人。子类型与其父类型的区别在于对子类型从其父类型接收的属性或方法所做的一些更改。
                  </p>
                  <p>除非子类型重新定义了继承方法，否则它始终包含父类型中的相同核心属性和方法集，以及它添加的任何属性和方法。如果<code class="codeph">person_typ</code>对象类型具有三个属性<code class="codeph">idno</code> ， <code class="codeph">name</code>和<code class="codeph">phone</code>以及方法<code class="codeph">get_idno()</code> ，那么从<code class="codeph">person_typ</code>派生的任何对象类型将具有这三个相同的属性和方法<code class="codeph">get_idno()</code> 。如果<code class="codeph">person_typ</code>的定义发生变化，那么任何子类型的定义<code class="codeph">person_typ</code>发生变化。
                  </p>
                  <p>使用关键字<code class="codeph">UNDER</code>创建子类型，如下所示：</p>
                  <p><code class="codeph">CREATE</code> <code class="codeph">TYPE</code> <code class="codeph">student_typ</code> <code class="codeph">UNDER</code> <code class="codeph">person_typ</code></p>
                  <p>您可以通过以下方式专门化子类型的属性或方法：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>添加其父类型没有的新属性。</p>
                        <p>例如，您可以通过添加<code class="codeph">major</code>的属性将<code class="codeph">student_typ</code>专门化为一种特殊的<code class="codeph">person_typ</code> 。子类型不能删除或更改从其父级继承的属性的类型;它只能添加新属性。
                        </p>
                     </li>
                     <li>
                        <p>添加父级没有的全新方法。</p>
                     </li>
                     <li>
                        <p>更改子类继承的某些方法的实现，以便子类型的版本执行与父类不同的代码。</p>
                        <p>例如，椭圆对象可能定义方法<code class="codeph">calculate()</code> 。<code class="codeph">ellipse_typ</code> ， <code class="codeph">circle_typ</code>和<code class="codeph">sphere_typ</code>类型可能都以不同的方式实现此方法。
                        </p>
                     </li>
                  </ul>
                  <p>超类型及其子类型之间的继承关系是对象的大部分功能的来源以及它们的复杂性。</p>
                  <p>能够更改超类型中的方法并通过重新编译使更改在下游的所有子类型中生效非常强大。但是，相同的功能意味着您必须考虑是否要允许类型专用或重新定义方法。类似地，对于能够在层次结构中包含任何类型的表或列，功能也很强大，但您必须决定是否在特定情况下允许此类型。此外，您可能需要约束DML语句和查询，以便它们从类型层次结构中仅选择所需的类型范围。</p>
                  <div class="infoboxnotealso" id="GUID-C9382BAD-3513-4CFB-9D4D-D3BC5B581AA8__GUID-3CD8FC51-FC89-4689-82C7-A1A6E41D7DE5">
                     <p class="notep1">也可以看看：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>有关完整示例，请参见<a href="inheritance-in-sql-object-types.html#GUID-A19D6DC9-5490-4EE5-B77C-1F734C86206D__BCFIEIFE">示例2-15</a></p>
                        </li>
                        <li>
                           <p><span class="q">“ <a href="inheritance-in-sql-object-types.html#GUID-9A965E24-9922-448F-A887-05A96EBC7B28">重载和重写方法</a> ”</span></p>
                        </li>
                     </ul>
                  </div>
               </div>
            </div><a id="ADOBJ7103"></a><div class="props_rev_3"><a id="GUID-E15EC4A3-A894-4DB4-AE8F-0B2B99429B29" name="GUID-E15EC4A3-A894-4DB4-AE8F-0B2B99429B29"></a><h3 id="ADOBJ-GUID-E15EC4A3-A894-4DB4-AE8F-0B2B99429B29" class="sect3"><span class="enumeration_section">2.3.3</span> FINAL和NOT FINAL继承的类型和方法</h3>
               <div>
                  <p>对象类型可以是可继承的，如果定义了方法，则可以覆盖方法。</p>
                  <p>对于可继承的对象类型或方法，该定义必须指定它是可继承的。对于类型和方法，使用关键字<code class="codeph">FINAL</code>或<code class="codeph">NOT</code> <code class="codeph">FINAL</code>来确定可继承性。
                  </p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><span class="bold">对象类型：</span>对于可继承的对象类型，从而允许从中派生子类型，对象定义必须指定它。
                        </p>
                        <p><code class="codeph">NOT</code> <code class="codeph">FINAL</code>意味着可以派生子类型。<code class="codeph">FINAL</code> ，（默认）表示不能从中派生任何子类型。
                        </p>
                     </li>
                     <li>
                        <p><span class="bold">方法：</span>定义必须指出是否可以覆盖它。
                        </p>
                        <p><code class="codeph">NOT</code> <code class="codeph">FINAL</code> （默认值）表示可以覆盖该方法。<code class="codeph">FINAL</code>意味着子类型不能通过提供自己的实现来覆盖它。
                        </p>
                     </li>
                  </ul>
                  <div class="infoboxnotealso" id="GUID-E15EC4A3-A894-4DB4-AE8F-0B2B99429B29__GUID-8399A835-B655-4D9A-B91A-78EDB8759C2F">
                     <p class="notep1">也可以看看：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="inheritance-in-sql-object-types.html#GUID-9E016F13-273B-4EC1-A47E-BE8C6F9B8D03__CIHHECAA">例2-13</a></p>
                        </li>
                        <li>
                           <p><a href="inheritance-in-sql-object-types.html#GUID-A5FE7A3B-7C1C-430A-8095-76AE955119C9__CIHIHCHI">例2-12</a></p>
                        </li>
                        <li>
                           <p><a href="inheritance-in-sql-object-types.html#GUID-381EB31A-F88A-478E-9430-E2D88E844A8D">将最终类型更改为NOT FINAL</a></p>
                        </li>
                     </ul>
                  </div>
               </div><a id="ADOBJ7105"></a><div class="props_rev_3"><a id="GUID-A5FE7A3B-7C1C-430A-8095-76AE955119C9" name="GUID-A5FE7A3B-7C1C-430A-8095-76AE955119C9"></a><h4 id="ADOBJ-GUID-A5FE7A3B-7C1C-430A-8095-76AE955119C9" class="sect4"><span class="enumeration_section">2.3.3.1</span>使用FINAL成员函数创建对象类型为NOT FINAL</h4>
                  <div>
                     <div class="section">
                        <p>您可以使用<code class="codeph">FINAL</code>成员函数创建<code class="codeph">NOT FINAL</code>对象类型，如<a href="inheritance-in-sql-object-types.html#GUID-A5FE7A3B-7C1C-430A-8095-76AE955119C9__CIHIHCHI">例2-12所示</a> 。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-A5FE7A3B-7C1C-430A-8095-76AE955119C9__CIHIHCHI">
                        <p class="titleinexample">示例2-12使用FINAL成员函数创建对象类型为NOT FINAL</p><pre class="oac_no_warn" dir="ltr">DROP TYPE person_typ FORCE; - 如果您之前创建了对象CREATE OR REPLACE TYPE person_typ AS OBJECT（idno NUMBER，name VARCHAR2（30），phone VARCHAR2（20）， <span class="bold">FINAL</span> MAP MEMBER FUNCTION get_idno RETURN NUMBER） <span class="bold">NOT FINAL;</span> /</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="ADOBJ7104"></a><div class="props_rev_3"><a id="GUID-9E016F13-273B-4EC1-A47E-BE8C6F9B8D03" name="GUID-9E016F13-273B-4EC1-A47E-BE8C6F9B8D03"></a><h4 id="ADOBJ-GUID-9E016F13-273B-4EC1-A47E-BE8C6F9B8D03" class="sect4"><span class="enumeration_section">2.3.3.2</span>创建NOT FINAL对象类型</h4>
                  <div>
                     <p>您可以将对象类型创建为<code class="codeph">NOT FINAL</code> 。</p>
                     <div class="section">
                        <p><a href="inheritance-in-sql-object-types.html#GUID-9E016F13-273B-4EC1-A47E-BE8C6F9B8D03__CIHHECAA">例2-13将</a> <code class="codeph">person_typ</code>声明为<code class="codeph">NOT FINAL</code>类型，因此可以定义<code class="codeph">person_typ</code>子类型。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-9E016F13-273B-4EC1-A47E-BE8C6F9B8D03__CIHHECAA">
                        <p class="titleinexample">示例2-13创建person_typ对象类型为NOT FINAL</p><pre class="oac_no_warn" dir="ltr">DROP TYPE person_typ FORCE; - 如果您之前创建了对象CREATE OR REPLACE TYPE person_typ AS OBJECT（idno NUMBER，name VARCHAR2（30），phone VARCHAR2（20））NOT FINAL; /</pre></div>
                     <!-- class="example" -->
                  </div>
               </div>
            </div>
            <div class="props_rev_3"><a id="GUID-381EB31A-F88A-478E-9430-E2D88E844A8D" name="GUID-381EB31A-F88A-478E-9430-E2D88E844A8D"></a><h3 id="ADOBJ-GUID-381EB31A-F88A-478E-9430-E2D88E844A8D" class="sect3"><span class="enumeration_section">2.3.4</span>将最终类型更改为NOT FINAL</h3>
               <div>
                  <div class="section">
                     <p>您可以通过使用<code class="codeph">ALTER</code> <code class="codeph">TYPE</code>语句将最终类型更改为非最终类型（反之亦然）来更改继承。
                     </p>
                     <p>例如，以下语句将<code class="codeph">person_typ</code>更改为最终类型：</p><pre class="oac_no_warn" dir="ltr">ALTER TYPE person_typ FINAL;</pre><p>如果目标类型没有子类型，则只能将类型从<code class="codeph">NOT</code> <code class="codeph">FINAL</code>更改为<code class="codeph">FINAL</code> 。
                     </p>
                  </div>
                  <!-- class="section" -->
               </div>
            </div><a id="ADOBJ00214"></a><div class="props_rev_3"><a id="GUID-132DAF47-6A1D-435E-B9A4-969490385CD0" name="GUID-132DAF47-6A1D-435E-B9A4-969490385CD0"></a><h3 id="ADOBJ-GUID-132DAF47-6A1D-435E-B9A4-969490385CD0" class="sect3"><span class="enumeration_section">2.3.5</span>子类型创建</h3>
               <div>
                  <p>您可以使用<code class="codeph">CREATE</code> <code class="codeph">TYPE</code>语句创建子<code class="codeph">TYPE</code> ，该语句使用<code class="codeph">UNDER</code>关键字指定子类型的直接父级。
                  </p>
                  <p>话题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="inheritance-in-sql-object-types.html#GUID-40D90D72-D1BB-4DAC-B7FA-D6CED4FC9395">创建父对象或超类型对象</a></p>
                     </li>
                     <li>
                        <p><a href="inheritance-in-sql-object-types.html#GUID-A19D6DC9-5490-4EE5-B77C-1F734C86206D">创建子类型对象</a></p>
                     </li>
                     <li>
                        <p><a href="inheritance-in-sql-object-types.html#GUID-76F4F2F9-A239-442D-97C3-678FE9330F45">广义调用</a></p>
                     </li>
                     <li>
                        <p><a href="inheritance-in-sql-object-types.html#GUID-6AFC45DD-9B89-484E-BFDF-0E911518A958">创建多个子类型</a></p>
                     </li>
                     <li>
                        <p><a href="inheritance-in-sql-object-types.html#GUID-FC96C63D-4DE4-4C4A-9C7D-A6E945644A0B" title="您可以创建包含超类型和子类型实例的表。">创建包含超类型和子类型对象的表</a></p>
                     </li>
                  </ul>
               </div><a id="ADOBJ7107"></a><a id="ADOBJ7106"></a><div class="props_rev_3"><a id="GUID-40D90D72-D1BB-4DAC-B7FA-D6CED4FC9395" name="GUID-40D90D72-D1BB-4DAC-B7FA-D6CED4FC9395"></a><h4 id="ADOBJ-GUID-40D90D72-D1BB-4DAC-B7FA-D6CED4FC9395" class="sect4"><span class="enumeration_section">2.3.5.1</span>创建父对象或超类型对象</h4>
                  <div>
                     <div class="section">
                        <p>您可以使用<code class="codeph">CREATE TYPE</code>语句创建父对象或超类型对象。
                        </p>
                        <p><a href="inheritance-in-sql-object-types.html#GUID-40D90D72-D1BB-4DAC-B7FA-D6CED4FC9395__BCFCAAFG">示例2-14</a>提供了父类或超类型<code class="codeph">person_typ</code>对象，以演示<a href="inheritance-in-sql-object-types.html#GUID-A19D6DC9-5490-4EE5-B77C-1F734C86206D__BCFIEIFE">示例2-15</a> ， <a href="inheritance-in-sql-object-types.html#GUID-6AFC45DD-9B89-484E-BFDF-0E911518A958__BCFIJGCF">示例2-18</a>和<a href="inheritance-in-sql-object-types.html#GUID-1978E393-6F3C-4383-B381-512E3B8F07B1__BCFDIDIE">示例2-19中的</a>子类型定义。
                        </p>
                        <p>注意<a href="inheritance-in-sql-object-types.html#GUID-40D90D72-D1BB-4DAC-B7FA-D6CED4FC9395__BCFCAAFG">例2-14中</a>的<code class="codeph">show()</code> 。在下面的子类型示例中，使用<code class="codeph">OVERRIDING</code>关键字将父类型的<code class="codeph">show()</code>函数重写为每个子类型的<code class="codeph">OVERRIDING</code> 。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-40D90D72-D1BB-4DAC-B7FA-D6CED4FC9395__BCFCAAFG">
                        <p class="titleinexample">示例2-14创建父类或超类型person_typ对象</p><pre class="oac_no_warn" dir="ltr">DROP TYPE person_typ FORCE; - 如果创建了创建或替换类型person_typ AS OBJECT（idno NUMBER，名称VARCHAR2（30），电话VARCHAR2（20），MAP成员功能get_idno返回号码，成员功能<span class="bold">show</span> RETURN VARCHAR2）NOT FINAL; /创建或替换TYPE BODY person_typ AS MAP会员功能get_idno返回号码是BEGIN RETURN idno;结束; - 可以通过子类型覆盖的功能MEMBER FUNCTION <span class="bold">show</span> RETURN VARCHAR2 IS BEGIN RETURN'Id：'|| TO_CHAR（idno）|| '，名字：'||名称;结束;结束; /</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="ADOBJ7109"></a><a id="ADOBJ7108"></a><div class="props_rev_3"><a id="GUID-A19D6DC9-5490-4EE5-B77C-1F734C86206D" name="GUID-A19D6DC9-5490-4EE5-B77C-1F734C86206D"></a><h4 id="ADOBJ-GUID-A19D6DC9-5490-4EE5-B77C-1F734C86206D" class="sect4"><span class="enumeration_section">2.3.5.2</span>创建子类型对象</h4>
                  <div>
                     <div class="section">
                        <p>子类型继承了超类型的属性和方法。</p>
                        <p>这些是继承的：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p>超类型声明或继承的所有属性。</p>
                           </li>
                           <li>
                              <p>超类型声明或继承的任何方法。</p>
                           </li>
                        </ul>
                        <p><a href="inheritance-in-sql-object-types.html#GUID-A19D6DC9-5490-4EE5-B77C-1F734C86206D__BCFIEIFE">实施例2-15</a>的定义<code class="codeph">student_typ</code>对象的子类型<code class="codeph">person_typ</code> ，其继承所有中声明或由继承属性<code class="codeph">person_typ</code>和任何方法，通过继承或宣布<code class="codeph">person_typ</code> 。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-A19D6DC9-5490-4EE5-B77C-1F734C86206D__BCFIEIFE">
                        <p class="titleinexample">示例2-15使用UNDER子句创建student_typ子类型</p><pre class="oac_no_warn" dir="ltr">- 要求Ex。2-14 CREATE TYPE student_typ <span class="bold">UNDER</span> person_typ（dept_id NUMBER，major VARCHAR2（30）， <span class="bold">OVERRIDING MEMBER FUNCTION show</span> RETURN VARCHAR2）NOT FINAL; / CREATE TYPE BODY student_typ AS OVERRIDING MEMBER FUNCTION show RETURN VARCHAR2 IS BEGIN <span class="bold">RETURN（self AS person_typ）.show</span> || ' - 少校：'||重大的 ;结束;结束; /</pre><p>定义<code class="codeph">student_typ</code>的语句通过添加两个新属性<code class="codeph">dept_id</code>和<code class="codeph">major</code>专门化<code class="codeph">person_typ</code>并覆盖<code class="codeph">show</code>方法。在子类型中声明的新属性必须具有与其任何超类型中声明的任何属性或方法的名称不同的名称，在其类型层次结构中更高。
                        </p>
                     </div>
                     <!-- class="example" -->
                  </div>
               </div><a id="ADOBJ00215"></a><div class="props_rev_3"><a id="GUID-76F4F2F9-A239-442D-97C3-678FE9330F45" name="GUID-76F4F2F9-A239-442D-97C3-678FE9330F45"></a><h4 id="ADOBJ-GUID-76F4F2F9-A239-442D-97C3-678FE9330F45" class="sect4"><span class="enumeration_section">2.3.5.3</span>广义调用</h4>
                  <div>
                     <p>广义调用提供了一种机制来调用超类型或父类型的方法，而不是特定的子类型成员方法。</p>
                     <p> <a href="inheritance-in-sql-object-types.html#GUID-A19D6DC9-5490-4EE5-B77C-1F734C86206D__BCFIEIFE">例2-15</a>使用以下语法演示了这一点：</p><pre class="oac_no_warn" dir="ltr">（自我为person_typ）。显示</pre><p><code class="codeph">student_typ</code> <code class="codeph">show</code>方法首先调用<code class="codeph">person_typ</code> <code class="codeph">show</code>方法来执行常用操作，然后执行自己的特定操作，即将<code class="codeph">'--Major:'</code>附加到<code class="codeph">person_typ</code> <code class="codeph">show</code>方法返回的值。这样，覆盖子类型方法可以在执行自己的特定操作之前调用相应的重写父类型方法来执行常见操作。
                     </p>
                     <p>除了<code class="codeph">AS</code>之后的类型名称应该是表达式求值类型的父类型的类型名称之外，方法与普通成员方法一样被调用。
                     </p>
                  </div>
               </div><a id="ADOBJ7110"></a><div class="props_rev_3"><a id="GUID-15838A1D-E8FC-4B28-9494-CA5BDF77A1B6" name="GUID-15838A1D-E8FC-4B28-9494-CA5BDF77A1B6"></a><h4 id="ADOBJ-GUID-15838A1D-E8FC-4B28-9494-CA5BDF77A1B6" class="sect4"><span class="enumeration_section">2.3.5.4</span>使用广义调用</h4>
                  <div>
                     <div class="section">
                        <p>在<a href="inheritance-in-sql-object-types.html#GUID-15838A1D-E8FC-4B28-9494-CA5BDF77A1B6__CHDFIHIC">例2-16中</a> ，有一个隐式<code class="codeph">SELF</code>参数，就像普通成员方法调用的隐式self参数一样。在这种情况下，它调用<code class="codeph">person_typ</code> <code class="codeph">show</code>方法而不是特定的<code class="codeph">student_typ</code> <code class="codeph">show</code>方法。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-15838A1D-E8FC-4B28-9494-CA5BDF77A1B6__CHDFIHIC">
                        <p class="titleinexample">示例2-16使用广义调用</p><pre class="oac_no_warn" dir="ltr">- 需要Ex。 2-14和2-15 DECLARE myvar student_typ：= student_typ（100，'Sam'，'6505556666'，100，'Math'）;名称VARCHAR2（100）; BEGIN name：= <span class="bold">（myvar AS person_typ）.show</span> ; - 广义调用END; /</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="ADOBJ7111"></a><div class="props_rev_3"><a id="GUID-798441BA-924B-49AB-928D-E151F4D33049" name="GUID-798441BA-924B-49AB-928D-E151F4D33049"></a><h4 id="ADOBJ-GUID-798441BA-924B-49AB-928D-E151F4D33049" class="sect4"><span class="enumeration_section">2.3.5.5</span>使用广义表达式</h4>
                  <div>
                     <div class="section">
                        <p>当使用显式self参数调用方法时，也支持广义表达式，如成员方法调用。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-798441BA-924B-49AB-928D-E151F4D33049__GUID-D9546C8A-65BE-4461-B381-D3690894E45C">
                        <p class="titleinexample">例2-17使用广义表达式</p><pre class="oac_no_warn" dir="ltr">- 需要Ex。 2-14和2-15 DECLARE myvar2 student_typ：= student_typ（101，'Sam'，'6505556666'，100，'Math'）; name2 VARCHAR2（100）; BEGIN name2：= <span class="bold">person_typ.show（（myvar2 AS person_typ））</span> ; - 广义表达式END; /</pre><p>在此示例中使用双括号，因为<code class="codeph">((myvar2</code> <code class="codeph">AS</code> <code class="codeph">person_typ))</code>既是必须解析的表达式，又是<code class="codeph">show</code>函数的参数。
                        </p>
                        <p>注意：无法使用此语法调用构造方法。此外，在此语法中<code class="codeph">AS</code>之后显示的类型名称应该是要为其调用方法的表达式类型的父类型之一。
                        </p>
                        <p>此语法只能用于调用父类型的相应重写成员方法。</p>
                     </div>
                     <!-- class="example" -->
                  </div>
               </div><a id="ADOBJ7113"></a><a id="ADOBJ7112"></a><div class="props_rev_3"><a id="GUID-6AFC45DD-9B89-484E-BFDF-0E911518A958" name="GUID-6AFC45DD-9B89-484E-BFDF-0E911518A958"></a><h4 id="ADOBJ-GUID-6AFC45DD-9B89-484E-BFDF-0E911518A958" class="sect4"><span class="enumeration_section">2.3.5.6</span>创建多个子类型</h4>
                  <div>
                     <div class="section">
                        <p>类型可以有多个子子类型，这些子类型也可以有子类型。</p>
                        <p> 除了在<a href="inheritance-in-sql-object-types.html#GUID-A19D6DC9-5490-4EE5-B77C-1F734C86206D__BCFIEIFE">示例2-15中</a>创建的现有子类型<code class="codeph">student_typ</code>之外， <a href="inheritance-in-sql-object-types.html#GUID-6AFC45DD-9B89-484E-BFDF-0E911518A958__BCFIJGCF">示例2-18</a>还在<code class="codeph">person_typ</code>下创建了另一个子类<code class="codeph">employee_typ</code> 。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-6AFC45DD-9B89-484E-BFDF-0E911518A958__BCFIJGCF">
                        <p class="titleinexample">示例2-18使用UNDER子句创建employee_typ子类型</p><pre class="oac_no_warn" dir="ltr">- 要求Ex。2-14 DROP TYPE employee_typ FORCE; - 如果先前创建了CREATE OR REPLACE TYPE employee_typ UNDER person_typ（emp_id NUMBER，mgr VARCHAR2（30），OVERRIDING MEMBER FUNCTION show RETURN VARCHAR2）; / CREATE OR REPLACE TYPE BODY employee_typ AS OVERRIDING MEMBER FUNCTION show RETURN VARCHAR2 IS BEGIN RETURN（SELF AS person_typ）.show || ' - 员工ID：'|| TO_CHAR（emp_id）|| '，经理：'|| mgr;结束;结束; /</pre><p> </p>
                     </div>
                     <!-- class="example" -->
                  </div>
               </div><a id="ADOBJ7114"></a><div class="props_rev_3"><a id="GUID-1978E393-6F3C-4383-B381-512E3B8F07B1" name="GUID-1978E393-6F3C-4383-B381-512E3B8F07B1"></a><h4 id="ADOBJ-GUID-1978E393-6F3C-4383-B381-512E3B8F07B1" class="sect4"><span class="enumeration_section">2.3.5.7</span>在另一个子类型下创建子类型</h4>
                  <div>
                     <div class="section">
                        <p>子类型可以在另一个子类型下定义。</p>
                        <p>新子类继承其父类型具有声明和继承的所有属性和方法。<a href="inheritance-in-sql-object-types.html#GUID-1978E393-6F3C-4383-B381-512E3B8F07B1__BCFDIDIE">例2-19</a>在<a href="inheritance-in-sql-object-types.html#GUID-A19D6DC9-5490-4EE5-B77C-1F734C86206D__BCFIEIFE">例2-15中</a>创建的<code class="codeph">student_typ</code>下定义了一个新的子类型<code class="codeph">part_time_student_typ</code> 。新子类继承了<code class="codeph">student_typ</code>所有属性和方法，并添加了另一个属性<code class="codeph">number_hours</code> 。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-1978E393-6F3C-4383-B381-512E3B8F07B1__BCFDIDIE">
                        <p class="titleinexample">示例2-19使用UNDER子句创建part_time_student_typ子类型</p><pre class="oac_no_warn" dir="ltr">创建类型part_time_student_typ UNDER student_typ（ <span class="bold">number_hours NUMBER</span> ，OVERRIDING MEMBER FUNCTION show RETURN VARCHAR2）; / CREATE TYPE BODY part_time_student_typ AS OVERRIDING MEMBER FUNCTION show RETURN VARCHAR2 IS BEGIN RETURN（SELF AS person_typ）.show || ' - 少校：'||专业|| '，小时：'|| TO_CHAR（NUMBER_HOURS）;结束;结束; /</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="ADOBJ7116"></a><a id="ADOBJ7115"></a><div class="props_rev_3"><a id="GUID-FC96C63D-4DE4-4C4A-9C7D-A6E945644A0B" name="GUID-FC96C63D-4DE4-4C4A-9C7D-A6E945644A0B"></a><h4 id="ADOBJ-GUID-FC96C63D-4DE4-4C4A-9C7D-A6E945644A0B" class="sect4"><span class="enumeration_section">2.3.5.8</span>创建包含超类型和子类型对象的表</h4>
                  <div>
                     <p>您可以创建包含超类型和子类型实例的表。</p>
                     <div class="section">
                        <p>然后，您可以使用<a href="inheritance-in-sql-object-types.html#GUID-FC96C63D-4DE4-4C4A-9C7D-A6E945644A0B__CHDJGIAG">示例2-20中</a>的<code class="codeph">person_obj_table</code>填充表格。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-FC96C63D-4DE4-4C4A-9C7D-A6E945644A0B__CHDJGIAG">
                        <p class="titleinexample">示例2-20将值插入对象表的可替换行中</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE person_obj_table OF person_typ; INSERT INTO person_obj_table VALUES（person_typ（12，'Bob Jones'，'650-555-0130'））; INSERT INTO person_obj_table VALUES（student_typ（51，'Joe Lane'，'1-650-555-0140'，12，'HISTORY'））; INSERT INTO person_obj_table VALUES（employee_typ（55，'Jane Smith'，'1-650-555-0144'，100，'Jennifer Nelson'））; INSERT INTO person_obj_table VALUES（part_time_student_typ（52，'Kim Patel'，'1-650-555-0135'，14，'PHYSICS'，20））;</pre><p>您可以使用以下内容为表中的超类型和子类型调用<code class="codeph">show()</code>函数：</p><pre class="oac_no_warn" dir="ltr">SELECT p.show（）FROM person_obj_table p;</pre><p>输出类似于：</p><pre class="pre codeblock"><code>Id：12，姓名：Bob Jones Id：51，姓名：Joe Lane  -  Major：HISTORY Id：55，姓名：Jane Smith  - 员工ID：100，经理：Jennifer Nelson Id：52，姓名：Kim Patel  - 专业：物理，课时：20</code></pre><p>请注意， <code class="codeph">show()</code>方法显示的数据取决于对象是超类型还是子类型，以及是否重写了子类型的<code class="codeph">show()</code>方法。例如，Bob Jones是<code class="codeph">person_typ</code> ，即超类型。仅显示他的<code class="codeph">name</code>和<code class="codeph">Id</code> 。对于Joe Lane，一个<code class="codeph">student_typ</code> ，他的<code class="codeph">name</code>和<code class="codeph">Id</code>由超类型的<code class="codeph">show()</code>函数提供，他的<code class="codeph">major</code>由子类型的重写<code class="codeph">show()</code>函数提供。
                        </p>
                     </div>
                     <!-- class="example" -->
                  </div>
               </div>
            </div><a id="ADOBJ7117"></a><div class="props_rev_3"><a id="GUID-1E601CC0-5AA6-4DEE-9241-509F1F45649A" name="GUID-1E601CC0-5AA6-4DEE-9241-509F1F45649A"></a><h3 id="ADOBJ-GUID-1E601CC0-5AA6-4DEE-9241-509F1F45649A" class="sect3"><span class="enumeration_section">2.3.6</span>不可用的类型和方法</h3>
               <div>
                  <p>创建时，类型和方法可以声明为<code class="codeph">NOT</code> <code class="codeph">INSTANTIABLE</code> 。
                  </p>
                  <p><code class="codeph">NOT</code> <code class="codeph">INSTANTIABLE</code>类型和方法：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><code class="codeph">NOT</code> <code class="codeph">INSTANTIABLE</code>类型</p>
                        <p>如果类型不可实例化，则无法实例化该类型的实例。它没有构造函数（默认或用户定义）。您可以将此类型用于仅用作实例化专用子类型的超类型的类型。</p>
                     </li>
                     <li>
                        <p><code class="codeph">NOT</code> <code class="codeph">INSTANTIABLE</code>方法</p>
                        <p>不可实例化的方法用作占位符。它已声明但未在类型中实现。当您希望每个子类型以不同的方式覆盖该方法时，您可以定义一个不可实例化的方法。在这种情况下，在超类型中定义方法没有意义。</p>
                     </li>
                  </ul>
                  <p>您可以使用<code class="codeph">ALTER</code> <code class="codeph">TYPE</code>语句将可实例化类型更改为不可实例化类型，反之亦然。
                  </p>
                  <p>包含不可实例化方法的类型本身必须声明为不可实例化，如<a href="inheritance-in-sql-object-types.html#GUID-AF8D779C-0216-4E32-8BA8-EE9420DCEA4A__CIHJHCJD">例2-21</a>所示。
                  </p>
               </div>
            </div><a id="ADOBJ7118"></a><div class="props_rev_3"><a id="GUID-AF8D779C-0216-4E32-8BA8-EE9420DCEA4A" name="GUID-AF8D779C-0216-4E32-8BA8-EE9420DCEA4A"></a><h3 id="ADOBJ-GUID-AF8D779C-0216-4E32-8BA8-EE9420DCEA4A" class="sect3"><span class="enumeration_section">2.3.7</span>创建非INSTANTIABLE对象类型</h3>
               <div>
                  <div class="section">
                     <p>如果子类型没有为每个继承的非可实例化方法提供实现，则子类型本身（如超类型）必须声明为不可实例化。</p>
                     <p>可以在可实例化的超类型下定义不可实例化的子类型。</p>
                  </div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-AF8D779C-0216-4E32-8BA8-EE9420DCEA4A__CIHJHCJD">
                     <p class="titleinexample">示例2-21创建不可实现的对象类型</p><pre class="oac_no_warn" dir="ltr">DROP TYPE person_typ FORCE; - 如果先前创建了创建或替换类型person_typ AS OBJECT（idno NUMBER，名称VARCHAR2（30），电话VARCHAR2（20），不是不可用的成员函数get_idno返回号码）不可能不是最终的; /</pre></div>
                  <!-- class="example" -->
               </div>
            </div><a id="ADOBJ7119"></a><div class="props_rev_3"><a id="GUID-1DD7BCE1-ED73-4517-8872-ADF4524C20D6" name="GUID-1DD7BCE1-ED73-4517-8872-ADF4524C20D6"></a><h3 id="ADOBJ-GUID-1DD7BCE1-ED73-4517-8872-ADF4524C20D6" class="sect3"><span class="enumeration_section">2.3.8</span>将对象类型更改为INSTANTIABLE</h3>
               <div>
                  <p><code class="codeph">ALTER</code> <code class="codeph">TYPE</code>语句可以使不可实例化的类型可实例化。
                  </p>
                  <div class="section">
                     <p>在<a href="inheritance-in-sql-object-types.html#GUID-1DD7BCE1-ED73-4517-8872-ADF4524C20D6__AlteringAnObjectTypeToINSTANTIABLE-0A1A7584">例2-22中</a> ， <code class="codeph">ALTER</code> <code class="codeph">TYPE</code>语句使<code class="codeph">person_typ</code>实例化。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-1DD7BCE1-ED73-4517-8872-ADF4524C20D6__AlteringAnObjectTypeToINSTANTIABLE-0A1A7584">
                     <p class="titleinexample">示例2-22将对象类型更改为INSTANTIABLE</p><pre class="oac_no_warn" dir="ltr">创建或替换类型person_typ AS OBJECT（idno NUMBER，名称VARCHAR2（30），电话VARCHAR2（20））NOT INSTANTIABLE NOT FINAL; / ALTER TYPE person_typ INSTANTIABLE;</pre><p><span class="bold">更改为不可实例化的类型</span></p>
                     <p>仅当类型没有通过其他类型或子类型直接或间接引用该类型的列，视图，表或实例时，才可以将可实例化类型更改为不可实例化的类型。</p>
                     <p>您不能将非实例化类型声明为<code class="codeph">FINAL</code> 。这实际上是毫无意义的。
                     </p>
                  </div>
                  <!-- class="example" -->
               </div>
            </div><a id="ADOBJ7120"></a><div class="props_rev_3"><a id="GUID-9A965E24-9922-448F-A887-05A96EBC7B28" name="GUID-9A965E24-9922-448F-A887-05A96EBC7B28"></a><h3 id="ADOBJ-GUID-9A965E24-9922-448F-A887-05A96EBC7B28" class="sect3"><span class="enumeration_section">2.3.9</span>重载和重写方法</h3>
               <div>
                  <p>子类型可以重新定义它继承的方法，也可以添加新方法，包括具有相同名称的方法。</p>
                  <p>话题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="inheritance-in-sql-object-types.html#GUID-B3C8D8DF-A55A-4878-865F-26DB6B03EE3A">重载方法</a></p>
                     </li>
                     <li>
                        <p><a href="inheritance-in-sql-object-types.html#GUID-4D442404-4706-46B6-845C-E17767CF6491">覆盖和隐藏方法</a></p>
                     </li>
                     <li>
                        <p><a href="inheritance-in-sql-object-types.html#GUID-C07F7FE1-1515-4942-8142-E73289185D99">对覆盖方法的限制</a></p>
                     </li>
                  </ul>
                  <p>请参阅<span class="q">“ <a href="inheritance-in-sql-object-types.html#GUID-132DAF47-6A1D-435E-B9A4-969490385CD0" title="您可以创建包含超类型和子类型实例的表。">子类型创建</a> ”</span>和<a href="system-defined-and-user-defined-constructors.html#GUID-AACBEBFC-4E97-43D2-BE9B-2142C7DF3BD8__i1011567">示例8-7中的示例</a> 。
                  </p>
               </div><a id="ADOBJ7121"></a><div class="props_rev_3"><a id="GUID-B3C8D8DF-A55A-4878-865F-26DB6B03EE3A" name="GUID-B3C8D8DF-A55A-4878-865F-26DB6B03EE3A"></a><h4 id="ADOBJ-GUID-B3C8D8DF-A55A-4878-865F-26DB6B03EE3A" class="sect4"><span class="enumeration_section">2.3.9.1</span>重载方法</h4>
                  <div>
                     <div class="section">
                        <p>向子类型添加与继承方法具有相同名称的新方法称为重载。</p>
                        <p>具有相同名称但签名不同的方法在存在于同一用户定义类型中时称为重载。</p>
                        <p>方法签名由方法的名称以及方法的形式参数的数量，类型和顺序组成，包括隐式<code class="codeph">self</code>参数。
                        </p>
                        <p>当您想要提供各种方法时，重载非常有用。例如，椭圆对象可能会使用另一个<code class="codeph">calculate()</code>方法重载<code class="codeph">calculate()</code>方法，以便能够计算不同的形状。
                        </p>
                        <p>编译器使用方法签名来确定当类型具有多个重载方法时要调用的方法。</p>
                        <p>在下面的伪代码中，子类型<code class="codeph">circle_typ</code>创建了<code class="codeph">calculate()</code>的重载：</p><pre class="pre codeblock"><code>CREATE TYPE ellipse_typ AS OBJECT（...，MEMBER PROCEDURE计算（x NUMBER，x NUMBER），）NOT FINAL; CREATE TYPE circle_typ UNDER ellipse_typ（...，MEMBER PROCEDURE计算（x NUMBER），...）;</code></pre><p><code class="codeph">circle_typ</code>包含两个版本的<code class="codeph">calculate()</code> 。一个是具有两个<code class="codeph">NUMBER</code>参数的继承版本，另一个是具有一个<code class="codeph">NUMBER</code>参数的新创建的方法。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ADOBJ7122"></a><div class="props_rev_3"><a id="GUID-4D442404-4706-46B6-845C-E17767CF6491" name="GUID-4D442404-4706-46B6-845C-E17767CF6491"></a><h4 id="ADOBJ-GUID-4D442404-4706-46B6-845C-E17767CF6491" class="sect4"><span class="enumeration_section">2.3.9.2</span>覆盖和隐藏方法</h4>
                  <div>
                     <div class="section">
                        <p>在静态方法的情况下，重新定义继承的方法以在子类型中自定义其行为，在成员方法的情况下称为覆盖，或隐藏。</p>
                        <p>与重载不同，您不会使用关键字<code class="codeph">OVERRIDING</code>创建新方法，只需重新定义现有方法。</p>
                        <p>覆盖和隐藏重新定义继承的方法，使其在子类型中执行不同的操作。例如，从<code class="codeph">ellipse_typ</code>超类型派生的子类型<code class="codeph">circle_typ</code>可能会覆盖成员方法<code class="codeph">calculate()</code>以专门用于计算圆的面积。有关重写方法的示例，请参阅<span class="q">“ <a href="inheritance-in-sql-object-types.html#GUID-132DAF47-6A1D-435E-B9A4-969490385CD0" title="您可以创建包含超类型和子类型实例的表。">子类型创建</a> ”</span> 。
                        </p>
                        <p>覆盖和隐藏是类似的，在任何一种情况下，子类型中重新定义的方法的版本都会遮盖相同名称和签名的原始版本，以便每当子类型实例调用方法时执行新版本而不是原始版本。如果子类型本身具有子类型，则这些子类型将继承重新定义的方法而不是原始版本。</p>
                        <p>通过覆盖，系统依赖于成员方法的隐式self参数中包含的类型信息来动态选择要执行的方法的正确版本。通过隐藏，在编译时识别正确的版本，并且不需要动态分派。请参阅<span class="q">“ <a href="inheritance-in-sql-object-types.html#GUID-C2DF60C8-025E-49E3-ABE4-375C4E36D806" title="动态方法分派是指在运行时将方法调用分派到最近的实现的方式，从当前或指定的类型处理类型层次结构。">动态方法调度</a> ”</span> 。
                        </p>
                        <p>要覆盖或隐藏方法，必须保留其签名。方法的重载都具有相同的名称，因此编译器使用子类型方法的签名来标识被取代的超类型中的特定版本。</p>
                        <p>使用<code class="codeph">CREATE</code> <code class="codeph">TYPE</code> <code class="codeph">BODY</code>语句中的<code class="codeph">OVERRIDING</code>关键字指示覆盖。当子类型隐藏静态方法时，不需要这样做。
                        </p>
                        <p>在下面的伪代码中，子类型表示它是重写方法<code class="codeph">calculate()</code> ：</p><pre class="pre codeblock"><code>CREATE TYPE ellipse_typ AS OBJECT（...，MEMBER PROCEDURE calculate（），FINAL MEMBER FUNCTION function_mytype（x NUMBER）...）NOT FINAL;创建类型circle_typ UNDER ellipse_typ（...，OVERRIDING MEMBER PROCEDURE calculate（），...）;</code></pre><p>有关此层次结构的图表，请参<a href="inheritance-in-sql-object-types.html#GUID-C2DF60C8-025E-49E3-ABE4-375C4E36D806__CHDEHFJG">见图2-2</a> 。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ADOBJ7123"></a><div class="props_rev_3"><a id="GUID-C07F7FE1-1515-4942-8142-E73289185D99" name="GUID-C07F7FE1-1515-4942-8142-E73289185D99"></a><h4 id="ADOBJ-GUID-C07F7FE1-1515-4942-8142-E73289185D99" class="sect4"><span class="enumeration_section">2.3.9.3</span>对覆盖方法的限制</h4>
                  <div>
                     <div class="section">
                        <p>覆盖方法有一些限制：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>只能覆盖超类型中未声明为final的方法。</p>
                           </li>
                           <li>
                              <p>Order方法可能只出现在类型层次结构的根类型中：它们可能不会在子类型中重新定义（覆盖）。</p>
                           </li>
                           <li>
                              <p>子类型中的静态方法可能不会重新定义超类型中的成员方法。</p>
                           </li>
                           <li>
                              <p>子类型中的成员方法可能不会重新定义超类型中的静态方法。</p>
                           </li>
                           <li>
                              <p>如果被覆盖的方法为任何参数提供默认值，则覆盖方法必须为相同的参数提供相同的默认值。</p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="ADOBJ7125"></a><a id="ADOBJ7124"></a><div class="props_rev_3"><a id="GUID-C2DF60C8-025E-49E3-ABE4-375C4E36D806" name="GUID-C2DF60C8-025E-49E3-ABE4-375C4E36D806"></a><h3 id="ADOBJ-GUID-C2DF60C8-025E-49E3-ABE4-375C4E36D806" class="sect3"><span class="enumeration_section">2.3.10</span>动态方法调度</h3>
               <div>
                  <p>动态方法分派是指在运行时将方法调用分派到最近的实现的方式，从当前或指定的类型处理类型层次结构。</p>
                  <p>动态方法分派仅在重写成员方法时可用，并且不适用于静态方法。</p>
                  <p>通过方法覆盖，类型层次结构可以定义同一方法的多个实现。在以下类型为<code class="codeph">ellipse_typ</code> ， <code class="codeph">circle_typ</code>和<code class="codeph">sphere_typ</code>层次结构中，每种类型可能以不同方式定义<code class="codeph">calculate()</code>方法。
                  </p>
                  <div class="figure" id="GUID-C2DF60C8-025E-49E3-ABE4-375C4E36D806__CHDEHFJG">
                     <p class="titleinfigure">图2-2类型层次结构</p><img src="img/adobj025.gif" alt="下面是图2-2的描述" title="下面是图2-2的描述" longdesc="img_text/adobj025.html"><br><a href="img_text/adobj025.html">“图2-2类型层次结构”的描述</a></div>
                  <!-- class="figure" -->
                  <p>当调用其中一个方法时，调用它的对象实例的类型决定了要使用的方法的哪个实现。然后将调用分派给该实现以供执行。选择方法实现的这个过程称为虚拟或动态方法分派，因为它是在运行时完成的，而不是在编译时完成的。</p>
                  <p>方法调用处理类型层次结构：从不向下。如果调用调用对象实例的成员方法，则该实例的类型是当前类型，并使用由该类型定义或继承的实现。如果调用调用类型的静态方法，则使用由该指定类型定义或继承的实现。</p>
                  <div class="infoboxnotealso" id="GUID-C2DF60C8-025E-49E3-ABE4-375C4E36D806__GUID-F6DF4744-04B1-49F7-9E2A-A7F58B060103">
                     <p class="notep1">也可以看看：</p>
                     <p>有关如何解析子程序调用的信息，请参阅<a href="../lnpls/plsql-subprograms.html#LNPLS00808" target="_blank"><span><cite>Oracle Database PL / SQL语言参考</cite></span></a> 
                     </p>
                  </div>
               </div>
            </div><a id="ADOBJ7126"></a><div class="props_rev_3"><a id="GUID-903F72C4-E4CE-4175-9972-EA13450F2DFB" name="GUID-903F72C4-E4CE-4175-9972-EA13450F2DFB"></a><h3 id="ADOBJ-GUID-903F72C4-E4CE-4175-9972-EA13450F2DFB" class="sect3"><span class="enumeration_section">2.3.11</span>类型层次结构中的类型替换</h3>
               <div>
                  <p>在类型层次结构中使用类型时，有时需要在最常规级别工作，例如，选择或更新所有人员。但在其他时候，您只需要选择或更新特定的子类型（如学生），或仅选择非学生的子类型。</p>
                  <p>（多态）选择所有人并且不仅返回声明类型为<code class="codeph">person_typ</code>对象而且返回其声明的子类型为<code class="codeph">student_typ</code>或<code class="codeph">employee_typ</code>对象的能力称为可替代性。如果超类型的一个子类型可以在声明类型为超类型的变量或列中替换或替代它，则该超类型是可替代的。
                  </p>
                  <p>通常，类型是可替代的。对象属性，集合元素和<code class="codeph">REF</code>是可替代的。定义为类型<code class="codeph">person_typ</code>的<code class="codeph">REF</code> ，类型或集合的<code class="codeph">person_typ</code>可以将<code class="codeph">REF</code>保存到<code class="codeph">person_typ</code>的实例或实例的实例，或者<code class="codeph">person_typ</code>的任何子类型的<code class="codeph">person_typ</code> 。
                  </p>
                  <p>考虑到子类型毕竟只是一种特殊类型的超类型，这似乎是预期的。但是，形式上，子类型本身就是一种类型：它与其超类型的类型不同。包含所有人员（包括所有学生和所有员工）的栏目实际上包含多种类型的数据。</p>
                  <p>原则上，对象属性，集合元素和<code class="codeph">REF</code>总是可替换的：在类型定义级别没有语法来限制它们对某些子类型的可替代性。但是，对于特定的表和列，您可以关闭或限制存储级别的可替换性。
                  </p>
                  <div class="infoboxnotealso" id="GUID-903F72C4-E4CE-4175-9972-EA13450F2DFB__GUID-57AD4FD9-3045-46F2-8F2A-4501B89EC841">
                     <p class="notep1">也可以看看：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><span class="q">“ <a href="inheritance-in-sql-object-types.html#GUID-A36A7587-4184-48CA-8EC2-099CB8933754" title="在创建表时，可以关闭列或属性的所有可替换性，包括嵌入的属性和嵌套的集合。">关闭新表中的替代品</a> ”</span></p>
                        </li>
                        <li>
                           <p><span class="q">“ <a href="inheritance-in-sql-object-types.html#GUID-C2A190CF-251C-471C-8C77-719D751ACFC2" title="您可以强制使用约束将对象列或属性中允许的子类型范围限制为声明类型的层次结构中的特定子类型。">限制替代性</a> ”</span></p>
                        </li>
                     </ul>
                  </div>
               </div>
            </div><a id="ADOBJ7127"></a><div class="props_rev_3"><a id="GUID-7AD15180-6B5B-4007-9822-189601A25614" name="GUID-7AD15180-6B5B-4007-9822-189601A25614"></a><h3 id="ADOBJ-GUID-7AD15180-6B5B-4007-9822-189601A25614" class="sect3"><span class="enumeration_section">2.3.12</span>列和行可替代性</h3>
               <div>
                  <p>对象表中的对象类型列和对象类型行是可替换的，视图也是可替换的：特定类型的列或行可以包含该类型及其任何子类型的实例。</p>
                  <p>话题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="inheritance-in-sql-object-types.html#GUID-04C3724F-B028-4523-A626-72BF854557FB" title="您可以替换对象表中的对象类型列和对象类型行。">关于列和行可替代性</a></p>
                     </li>
                     <li>
                        <p><a href="inheritance-in-sql-object-types.html#GUID-6AB0B124-522E-4A4C-9853-C5B7AA46BA4C">将OBJECT_VALUE和OBJECT_ID与可替换行一起使用</a></p>
                     </li>
                     <li>
                        <p><a href="inheritance-in-sql-object-types.html#GUID-EEDEEE75-5007-4EC7-90B9-203FEDF050EC">具有超类型属性的子类型</a></p>
                     </li>
                     <li>
                        <p><a href="inheritance-in-sql-object-types.html#GUID-F25CDD42-2140-4074-BE95-87925AAE4CEB">替换REF列和属性</a></p>
                     </li>
                     <li>
                        <p><a href="inheritance-in-sql-object-types.html#GUID-FAB8D45F-A0DB-4839-B67F-6EB765C1E77F">收集元素的替代</a></p>
                     </li>
                  </ul>
               </div><a id="ADOBJ7128"></a><div class="props_rev_3"><a id="GUID-04C3724F-B028-4523-A626-72BF854557FB" name="GUID-04C3724F-B028-4523-A626-72BF854557FB"></a><h4 id="ADOBJ-GUID-04C3724F-B028-4523-A626-72BF854557FB" class="sect4"><span class="enumeration_section">2.3.12.1</span>关于列和行的可替代性</h4>
                  <div>
                     <p>您可以替换对象表中的对象类型列和对象类型行。</p>
                     <p>考虑<code class="codeph">person_typ</code>类型层次结构，例如<a href="inheritance-in-sql-object-types.html#GUID-40D90D72-D1BB-4DAC-B7FA-D6CED4FC9395__BCFCAAFG">示例2-14中</a>介绍的层次结构。您可以创建<code class="codeph">person_typ</code>的对象表，其中包含所有类型的行。为此，在<code class="codeph">INSERT</code>语句的<code class="codeph">VALUES</code>子句中使用该类型的构造函数将给定类型的实例插入到对象表中，如<a href="inheritance-in-sql-object-types.html#GUID-FC96C63D-4DE4-4C4A-9C7D-A6E945644A0B__CHDJGIAG">例2-20</a>所示。
                     </p>
                     <p>类似地， <a href="inheritance-in-sql-object-types.html#GUID-04C3724F-B028-4523-A626-72BF854557FB__BCFIABBI">示例2-23</a>显示<code class="codeph">person_typ</code>类型的可替换列可以在关系表或视图中包含所有三种类型的实例。该示例从该类型层次结构中重新创建person，student和兼职学生对象，并将它们插入到<code class="codeph">person_typ</code>列<code class="codeph">contact</code> 。
                     </p>
                     <div class="example" id="GUID-04C3724F-B028-4523-A626-72BF854557FB__BCFIABBI">
                        <p class="titleinexample">示例2-23将值插入表的可替换列中</p><pre class="oac_no_warn" dir="ltr">DROP TYPE person_typ FORCE; - 如果以前创建过DROP TYPE student_typ FORCE; - 如果先前创建了DROP TYPE part_time_student_typ FORCE; - 如果以前创建过DROP TABLE联系人;如果先前创建了CREATE OR REPLACE TYPE person_typ AS OBJECT（idno NUMBER，名称VARCHAR2（30），电话VARCHAR2（20））NOT FINAL; / CREATE TYPE student_typ UNDER person_typ（dept_id NUMBER，major VARCHAR2（30））NOT FINAL; / CREATE TYPE part_time_student_typ UNDER student_typ（number_hours NUMBER）; / CREATE TABLE联系人（ <span class="bold">联系人person_typ</span> ，contact_date DATE）; <span class="bold">INSERT INTO联系人</span> <span class="bold">VALUES</span> （person_typ（12，'Bob Jones'，'650-555-0130'），'2003年6月24日'）; <span class="bold">INSERT INTO联系人</span> <span class="bold">VALUES</span> （student_typ（51，'Joe Lane'，'1-650-555-0178'，12，'HISTORY'），'2003年6月24日'）; <span class="bold">INSERT INTO联系人</span> <span class="bold">VALUES</span> （part_time_student_typ（52，'Kim Patel'，'1-650-555-0190'，14，'PHYSICS'，20），'2003年6月24日'）;</pre><p>新创建的子类型可以存储在其超类型的任何可替换表和列中，包括在创建子类型之前存在的表和列。</p>
                        <p>通常，您可以使用点表示法访问属性。要访问行或列的声明类型的子类型的属性，可以使用<code class="codeph">TREAT</code>函数。例如：</p><pre class="oac_no_warn" dir="ltr">SELECT TREAT（联系AS student_typ）。主要来自联系人;</pre><p>见<span class="q">“ <a href="functions-and-operators-useful-with-objects.html#GUID-5C6151A6-13C5-42A6-8182-77FC7957C8B5">TREAT</a> ”</span> 。
                        </p>
                     </div>
                     <!-- class="example" -->
                  </div>
               </div><a id="ADOBJ7130"></a><a id="ADOBJ7129"></a><div class="props_rev_3"><a id="GUID-6AB0B124-522E-4A4C-9853-C5B7AA46BA4C" name="GUID-6AB0B124-522E-4A4C-9853-C5B7AA46BA4C"></a><h4 id="ADOBJ-GUID-6AB0B124-522E-4A4C-9853-C5B7AA46BA4C" class="sect4"><span class="enumeration_section">2.3.12.2</span>将OBJECT_VALUE和OBJECT_ID与可替换行一起使用</h4>
                  <div>
                     <div class="section">
                        <p>您可以访问和标识对象标识符（OID）和可替换行的值。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>使用<code class="codeph">OBJECT_VALUE</code>和<code class="codeph">OBJECT_ID</code>伪列允许访问并标识对象表中可替换行的值和对象标识符，如<a href="inheritance-in-sql-object-types.html#GUID-6AB0B124-522E-4A4C-9853-C5B7AA46BA4C__i473472">例2-24</a>所示。
                        </p>
                        <div class="infoboxnotealso" id="GUID-6AB0B124-522E-4A4C-9853-C5B7AA46BA4C__GUID-F5B19AA6-34CB-4F36-B210-1496A132C463">
                           <p class="notep1">也可以看看：</p>
                           <p>有关这些伪列的更多信息</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><a href="../sqlrf/OBJECT_VALUE-Pseudocolumn.html#SQLRF50952" target="_blank"><span class="italic">Oracle数据库SQL语言参考</span></a></p>
                              </li>
                              <li>
                                 <p><a href="../sqlrf/OBJECT_ID-Pseudocolumn.html#SQLRF50951" target="_blank"><span class="italic">Oracle数据库SQL语言参考</span></a></p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-6AB0B124-522E-4A4C-9853-C5B7AA46BA4C__i473472">
                        <p class="titleinexample">示例2-24使用OBJECT_VALUE和OBJECT_ID</p><pre class="oac_no_warn" dir="ltr">DROP TABLE person_obj_table; - 如果先前创建了CREATE TABLE person_obj_table OF person_typ; INSERT INTO person_obj_table VALUES（person_typ（20，'Bob Jones'，'650-555-0130'））; SELECT p。 <span class="bold">object_id</span> ，p。 <span class="bold">object_value</span> FROM person_obj_table p;</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="ADOBJ7132"></a><a id="ADOBJ7133"></a><a id="ADOBJ7131"></a><div class="props_rev_3"><a id="GUID-EEDEEE75-5007-4EC7-90B9-203FEDF050EC" name="GUID-EEDEEE75-5007-4EC7-90B9-203FEDF050EC"></a><h4 id="ADOBJ-GUID-EEDEEE75-5007-4EC7-90B9-203FEDF050EC" class="sect4"><span class="enumeration_section">2.3.12.3</span>具有超类型属性的子类型</h4>
                  <div>
                     <p>子类型可以具有其类型是超类型的类型的属性。例如：</p>
                     <div class="example" id="GUID-EEDEEE75-5007-4EC7-90B9-203FEDF050EC__GUID-3111A702-050A-4538-BBAB-2EC4CBADD6E0">
                        <p class="titleinexample">示例2-25创建具有超类型属性的子类型</p><pre class="oac_no_warn" dir="ltr">- 要求Ex 2-22 CREATE TYPE student_typ UNDER <span class="bold">person_typ</span> （dept_id NUMBER，major VARCHAR2（30），advisor <span class="bold">person_typ</span> ）; /</pre><p>但是，这些类型的列不可替代。类似地，子类型可以具有集合属性，其元素类型是其超类型之一，但是，此类类型的列也不可替代。例如，如果<code class="codeph">student_typ</code>具有嵌套表或person_typ的<code class="codeph">person_typ</code> ，则<code class="codeph">student_typ</code>列将不可替换。
                        </p>
                        <p>但是，您可以定义具有引用超类型的<code class="codeph">REF</code>属性的子类型的可替换列。例如， <a href="inheritance-in-sql-object-types.html#GUID-EEDEEE75-5007-4EC7-90B9-203FEDF050EC__CHDIFHDA">示例2-26</a>中显示的<code class="codeph">composite_category_typ</code>子类型包含<code class="codeph">subcategory_ref_list</code>嵌套表。该表包含<code class="codeph">subcategory_ref_list_typ</code> ，它们是<code class="codeph">category_typ</code> REF。子类型创建如下：</p>
                     </div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-EEDEEE75-5007-4EC7-90B9-203FEDF050EC__CHDIFHDA">
                        <p class="titleinexample">示例2-26定义具有REF属性的子类型的列</p><pre class="oac_no_warn" dir="ltr">- 不执行CREATE TYPE subcategory_ref_list_typ AS TABLE OF REF category_typ; / CREATE TYPE composite_category_typ UNDER category_typ（subcategory_ref_list subcategory_ref_list_typ ...
</pre><p>请参阅<span class="q">“ <a href="inheritance-in-sql-object-types.html#GUID-A36A7587-4184-48CA-8EC2-099CB8933754" title="在创建表时，可以关闭列或属性的所有可替换性，包括嵌入的属性和嵌套的集合。">关闭新表中的可替代性</a> ”</span> 。
                        </p>
                     </div>
                     <!-- class="example" -->
                  </div>
               </div><a id="ADOBJ7134"></a><div class="props_rev_3"><a id="GUID-F25CDD42-2140-4074-BE95-87925AAE4CEB" name="GUID-F25CDD42-2140-4074-BE95-87925AAE4CEB"></a><h4 id="ADOBJ-GUID-F25CDD42-2140-4074-BE95-87925AAE4CEB" class="sect4"><span class="enumeration_section">2.3.12.4</span>替换REF列和属性</h4>
                  <div>
                     <p><code class="codeph">REF</code>列和属性在视图和表中都是可替换的。例如，在视图或表中，声明为<code class="codeph">REF</code> <code class="codeph">person_typ</code>的列可以保存对<code class="codeph">person_typ</code>或其任何子类型的实例的引用。
                     </p>
                  </div>
               </div><a id="ADOBJ7135"></a><div class="props_rev_3"><a id="GUID-FAB8D45F-A0DB-4839-B67F-6EB765C1E77F" name="GUID-FAB8D45F-A0DB-4839-B67F-6EB765C1E77F"></a><h4 id="ADOBJ-GUID-FAB8D45F-A0DB-4839-B67F-6EB765C1E77F" class="sect4"><span class="enumeration_section">2.3.12.5</span>集合元素的替换</h4>
                  <div>
                     <p>集合元素在视图和表中都是可替换的。例如， <code class="codeph">person_typ</code>的嵌套表可以包含<code class="codeph">person_typ</code>或其任何子类型的对象实例。
                     </p>
                  </div>
               </div>
            </div><a id="ADOBJ7137"></a><a id="ADOBJ7136"></a><div class="props_rev_3"><a id="GUID-9310EC5A-0ED4-42D6-86F9-01F2D0D609A0" name="GUID-9310EC5A-0ED4-42D6-86F9-01F2D0D609A0"></a><h3 id="ADOBJ-GUID-9310EC5A-0ED4-42D6-86F9-01F2D0D609A0" class="sect3"><span class="enumeration_section">2.3.13</span>存储在可替换列中的新创建的子类型</h3>
               <div>
                  <p>如果创建子类型，则任何已具有超类型的可替换列的表也可以存储新的子类型。</p>
                  <p>这意味着您创建子类型的选项会受到此类表的影响。如果存在这样的表，则只能创建可替换的子类型，即不违反表限制或约束的子类型。</p>
                  <p>以下示例创建<code class="codeph">person_typ</code> ，然后显示在<code class="codeph">person_typ</code>下创建子类型<code class="codeph">student_typ</code>多次尝试。
                  </p>
                  <div class="example" id="GUID-9310EC5A-0ED4-42D6-86F9-01F2D0D609A0__GUID-B4785754-267B-49B0-90C4-DBAEDC6A67C7">
                     <p class="titleinexample">示例2-27创建可替换列后创建子类型</p><pre class="oac_no_warn" dir="ltr">DROP TYPE person_typ FORCE; DROP TABLE person_obj_table; DROP TYPE student_typ; - 如果创建了对象/表，则执行上面的丢弃创建或替换类型person_typ AS OBJECT（idno NUMBER，名称VARCHAR2（30），电话VARCHAR2（20））NOT FINAL; / CREATE TABLE person_obj_table（ <span class="bold">p person_typ</span> ）;</pre><p>以下语句失败，因为<code class="codeph">student_typ</code>具有超类型属性，而表<code class="codeph">person_obj_table</code>具有超类型的可替换列<code class="codeph">p</code> 。
                     </p><pre class="oac_no_warn" dir="ltr">CREATE TYPE student_typ UNDER person_typ（ - 不正确的CREATE子类型顾问<span class="bold">person_typ</span> ）; /</pre><p>下一次尝试成功。此版本的<code class="codeph">student_typ</code>子类型是可替换的。Oracle数据库自动启用表<code class="codeph">person_obj_table</code>来存储此新类型的实例。
                     </p><pre class="oac_no_warn" dir="ltr">CREATE TYPE student_typ UNDER person_typ（dept_id NUMBER，major VARCHAR2（30））; / INSERT INTO person_obj_table VALUES（student_typ（51，'Joe Lane'，'1-650-555-0178'，12，'HISTORY'））;</pre></div>
                  <!-- class="example" -->
               </div>
            </div><a id="ADOBJ7138"></a><div class="props_rev_3"><a id="GUID-B8F5B0D0-B61B-4990-8045-2EB6F1C61F47" name="GUID-B8F5B0D0-B61B-4990-8045-2EB6F1C61F47"></a><h3 id="ADOBJ-GUID-B8F5B0D0-B61B-4990-8045-2EB6F1C61F47" class="sect3"><span class="enumeration_section">2.3.14</span>创建可替换列后删除子类型</h3>
               <div>
                  <p>当您使用<code class="codeph">VALIDATE</code>选项删除子类型时，它会检查子类型的任何可替换列中是否存储子类型的实例。如果没有这样的实例，则<code class="codeph">DROP</code>操作完成。
                  </p>
                  <div class="section">
                     <p>以下语句失败，因为<code class="codeph">student_typ</code>的实例存储在表<code class="codeph">person_obj_table</code>替换列<code class="codeph">p</code>中：</p><pre class="oac_no_warn" dir="ltr">DROP TYPE student_typ VALIDATE  - 错误：实例仍然存在;</pre><p>要删除该类型，首先删除超类型的可替换列中的任何实例：</p><pre class="oac_no_warn" dir="ltr">- 从表中删除并删除student_typ子类型示例，而不是示例模式</pre><pre class="oac_no_warn" dir="ltr">DELETE FROM person_obj_table WHERE p IS OF（student_typ）; DROP TYPE student_typ VALIDATE;</pre><div class="infoboxnotealso" id="GUID-B8F5B0D0-B61B-4990-8045-2EB6F1C61F47__GUID-DC51D7F6-9375-497A-8511-4BB047CFE3E0">
                        <p class="notep1">也可以看看：</p>
                        <p>有关<code class="codeph">DROP</code>和<code class="codeph">VALIDATE</code>更多信息，请<a href="../lnpls/DROP-TYPE-statement.html#LNPLS99989" target="_blank"><span class="italic">参见Oracle Database PL / SQL语言参考</span></a></p>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div>
            </div><a id="ADOBJ7140"></a><a id="ADOBJ7139"></a><div class="props_rev_3"><a id="GUID-A36A7587-4184-48CA-8EC2-099CB8933754" name="GUID-A36A7587-4184-48CA-8EC2-099CB8933754"></a><h3 id="ADOBJ-GUID-A36A7587-4184-48CA-8EC2-099CB8933754" class="sect3"><span class="enumeration_section">2.3.15</span>关闭新表中的可替代性</h3>
               <div>
                  <p>在创建表时，可以关闭列或属性的所有可替换性，包括嵌入的属性和嵌套的集合。</p>
                  <div class="section">
                     <p>使用条款<code class="codeph">NOT</code> <code class="codeph">SUBSTITUTABLE</code> <code class="codeph">AT</code> <code class="codeph">ALL</code> <code class="codeph">LEVELS</code>当你创建一个表。
                     </p>
                     <p>这将关闭所有列或属性可替代性，包括嵌套到任何级别的嵌入属性和集合。</p>
                     <p>在以下示例中，该子句将关系表的列<code class="codeph">office</code>限制为仅存储<code class="codeph">office_typ</code>实例，并禁止任何子类型实例：</p>
                  </div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-A36A7587-4184-48CA-8EC2-099CB8933754__GUID-65A14C77-415C-4C02-83DA-2538D790EB2A">
                     <p class="titleinexample">示例2-28创建表时关闭可替代性</p><pre class="oac_no_warn" dir="ltr">DROP TYPE location_typ FORCE; - 如果先前已创建，则需要DROP TYPE office_typ FORCE; - 如果先前已创建，则需要创建或替换类型location_typ AS OBJECT（building_no NUMBER，city VARCHAR2（40））; / CREATE TYPE people_typ AS TABLE OF person_typ; / CREATE TYPE office_typ AS OBJECT（office_id VARCHAR（10），location location_typ，occupant person_typ）NOT FINAL; / CREATE TABLE dept_office（dept_no NUMBER， <span class="bold">office office_typ</span> ）COLUMN office不可<span class="bold">替换</span>所有级别;</pre><p>使用对象表，该子句可以作为一个整体应用于表，例如：</p><pre class="oac_no_warn" dir="ltr">DROP TABLE office_tab; - 如果之前创建的CREATE <span class="bold">TABLE</span> office_tab OF office_typ <span class="bold">并非在所有级别可</span>替换;</pre><p>该子句还可以关闭特定列中的可替代性，即对于表的对象类型的特定属性：</p><pre class="oac_no_warn" dir="ltr">DROP TABLE office_tab; - 如果之前创建的CREATE TABLE office_tab OF office_typ <span class="bold">COLUMN</span>占用者在<span class="bold">所有级别都不可</span>替换;</pre><p>您可以使用以下语法指定集合的元素类型不可替换：</p><pre class="oac_no_warn" dir="ltr">DROP TABLE people_tab; - 如果先前已创建，则需要CREATE TABLE people_tab（people_column people_typ）NESTED TABLE people_column在<span class="bold">所有级别的</span>存储中不可替换为people_column_nt;</pre><p>没有关闭<code class="codeph">REF</code>列的可替代性的机制。
                     </p>
                     <p>您可以使用<code class="codeph">NOT</code> <code class="codeph">SUBSTITUTABLE</code> <code class="codeph">AT</code> <code class="codeph">ALL</code> <code class="codeph">LEVELS</code>或<code class="codeph">IS</code> <code class="codeph">OF</code>类型来约束<a href="glossary.html#GUID-A63835BB-D757-44C0-AAFD-94BF0BC41B92"><span class="xrefglossterm">对象列</span></a> ，但不能同时使用它们。
                     </p>
                  </div>
                  <!-- class="example" -->
               </div>
            </div><a id="ADOBJ7142"></a><a id="ADOBJ7141"></a><div class="props_rev_3"><a id="GUID-C2A190CF-251C-471C-8C77-719D751ACFC2" name="GUID-C2A190CF-251C-471C-8C77-719D751ACFC2"></a><h3 id="ADOBJ-GUID-C2A190CF-251C-471C-8C77-719D751ACFC2" class="sect3"><span class="enumeration_section">2.3.16</span>约束替代性</h3>
               <div>
                  <p>您可以强制使用约束将对象列或属性中允许的子类型范围限制为声明类型的层次结构中的特定子类型。</p>
                  <div class="section">
                     <p>使用<code class="codeph">IS</code> <code class="codeph">OF</code> <span class="italic"><code class="codeph">type</code></span>约束执行此操作。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p>以下语句创建一个<code class="codeph">office_typ</code>表，其中占用者仅限于那些雇员：</p>
                  </div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-C2A190CF-251C-471C-8C77-719D751ACFC2__GUID-B0028548-E5DB-4F7A-97C6-3E5E37DF8FC2">
                     <p class="titleinexample">示例2-29创建表时约束可替代性</p><pre class="oac_no_warn" dir="ltr">DROP TABLE office_tab; - 如果先前创建了CREATE TABLE office_tab OF office_typ COLUMN占用者<span class="bold">IS OF</span> （ <span class="bold">仅限</span> employee_typ）;</pre><p>尽管类型<code class="codeph">office_typ</code>允许作者具有<code class="codeph">person_typ</code>类型，但列声明强制约束仅存储<code class="codeph">employee_typ</code>实例。
                     </p>
                     <p>您只能使用<code class="codeph">IS</code> <code class="codeph">OF</code> <span class="italic"><code class="codeph">type</code></span>运算符将行和列对象约束为单个子类型（而不是几个），并且必须使用<code class="codeph">ONLY</code>关键字，如上例所示。
                     </p>
                     <p>您可以使用<code class="codeph">IS</code> <code class="codeph">OF</code> <span class="italic"><code class="codeph">type</code></span>或<code class="codeph">NOT</code> <code class="codeph">SUBSTITUTABLE</code> <code class="codeph">AT</code> <code class="codeph">ALL</code> <code class="codeph">LEVELS</code>约束的<a href="glossary.html#GUID-A63835BB-D757-44C0-AAFD-94BF0BC41B92"><span class="xrefglossterm">对象列</span></a> ，但不能同时使用。
                     </p>
                  </div>
                  <!-- class="example" -->
               </div>
            </div><a id="ADOBJ7144"></a><a id="ADOBJ7143"></a><div class="props_rev_3"><a id="GUID-B3CCBD8C-29C9-4B39-939C-258711505E8D" name="GUID-B3CCBD8C-29C9-4B39-939C-258711505E8D"></a><h3 id="ADOBJ-GUID-B3CCBD8C-29C9-4B39-939C-258711505E8D" class="sect3"><span class="enumeration_section">2.3.17</span>修改表格的可替代性</h3>
               <div>
                  <div class="section">
                     <p>在现有表中，您可以使用<code class="codeph">ALTER</code> <code class="codeph">TABLE</code>语句将对象列从<code class="codeph">SUBSTITUTABLE</code>更改为<code class="codeph">NOT</code> <code class="codeph">SUBSTITUTABLE</code> （或从<code class="codeph">NOT</code> <code class="codeph">SUBSTITUTABLE</code>更改为<code class="codeph">SUBSTITUTABLE</code> ）。
                     </p>
                     <p>为<code class="codeph">ALTER</code> <code class="codeph">TABLE</code>语句中的特定列指定子句[ <code class="codeph">NOT</code> ] <code class="codeph">SUBSTITUTABLE</code> <code class="codeph">AT</code> <code class="codeph">ALL</code> <code class="codeph">LEVELS</code> 。
                     </p>
                     <p>您只能为特定列修改可替代性，而不能修改整个对象表的可替代性。</p>
                     <p>以下语句使列<code class="codeph">office</code>替换：</p>
                  </div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-B3CCBD8C-29C9-4B39-939C-258711505E8D__GUID-CD8A01FA-9B11-4E8F-A2D8-DFD56EE3822C">
                     <p class="titleinexample">例2-30修改表中的可替代性</p><pre class="oac_no_warn" dir="ltr">- 需要Ex。2-28 ALTER TABLE dept_office MODIFY COLUMN办公室可在<span class="bold">所有级别取代</span> ;</pre><p>以下语句使该列不可替代。请注意，它还使用<code class="codeph">FORCE</code>关键字。此关键字会导致删除包含typeid信息或子类型属性数据的任何隐藏列：</p><pre class="oac_no_warn" dir="ltr">- 用FORCE改变表的可替换性</pre><pre class="oac_no_warn" dir="ltr">ALTER TABLE dept_office MODIFY COLUMN办公室不可替换所有级别的<span class="bold">力量</span> ;</pre><pre class="oac_no_warn" dir="ltr">--DROP TABLE dept_office;</pre><p>如果不使用<code class="codeph">FORCE</code>关键字使列不可替换，则该类的列和所有属性必须为<code class="codeph">FINAL</code>否则<code class="codeph">ALTER</code> <code class="codeph">TABLE</code>语句将失败。
                     </p>
                     <p>只有当varray的元素类型本身为final并且没有嵌入类型（在其属性或属性中，等等）不是final时，才能将<code class="codeph">VARRAY</code>列从<code class="codeph">SUBSTITUTABLE</code>修改为<code class="codeph">NOT</code> <code class="codeph">SUBSTITUTABLE</code> 。
                     </p>
                     <div class="infoboxnotealso" id="GUID-B3CCBD8C-29C9-4B39-939C-258711505E8D__GUID-9997CBC8-05B2-44CD-A458-F9D860B5C881">
                        <p class="notep1">也可以看看：</p>
                        <p>有关typeids和子类型属性的隐藏列的详细信息，请参阅<span class="q">“ <a href="storage-of-objects.html#GUID-349CF29A-7F51-4142-9724-90D5F9CDFD6D">可替换列和对象表的</a></span>隐藏列”。
                        </p>
                     </div>
                  </div>
                  <!-- class="example" -->
               </div>
            </div><a id="ADOBJ7145"></a><div class="props_rev_3"><a id="GUID-570E2FF9-E36F-4E11-9BFE-5F41270D2F7F" name="GUID-570E2FF9-E36F-4E11-9BFE-5F41270D2F7F"></a><h3 id="ADOBJ-GUID-570E2FF9-E36F-4E11-9BFE-5F41270D2F7F" class="sect3"><span class="enumeration_section">2.3.18</span>修改替代性的限制</h3>
               <div>
                  <p>您可以使用<code class="codeph">ALTER</code> <code class="codeph">TABLE</code>语句一次<code class="codeph">ALTER</code>一列的可替换性。
                  </p>
                  <p>要更改多列的可替换性，请发出多个语句。</p>
                  <p>在对象表中，如果在创建表时未在表级别显式设置可替代性，则只能修改列的可替换性。</p>
                  <p>例如，以下尝试修改列地址的可替换性成功，因为在<code class="codeph">CREATE</code> <code class="codeph">TABLE</code>语句中未在表级别显式打开或关闭可替换性：</p><pre class="oac_no_warn" dir="ltr">DROP TABLE office_tab; - 如果以前创建了CREATE TABLE office_tab OF office_typ; ALTER TABLE office_tab MODIFY COLUMN占用者不可在所有级别强制替换;</pre><p>但是，在以下示例中，可替换性在表级别显式设置，因此修改列地址设置的尝试将失败：</p><pre class="oac_no_warn" dir="ltr">DROP TABLE office_tab; - 如果之前创建的CREATE TABLE office_tab OF office_typ并非在所有级别可替换; / *以下SQL语句生成错误：* / ALTER TABLE office_tab MODIFY COLUMN占用者可以在所有级别强制执行 - 不正确的ALTER;</pre><p>可替代性已被<code class="codeph">IS</code> <code class="codeph">OF</code> <span class="italic"><code class="codeph">type</code></span>运算符约束的列不能使用[ <code class="codeph">NOT</code> ] <code class="codeph">SUBSTITUTABLE</code> <code class="codeph">AT</code> <code class="codeph">ALL</code> <code class="codeph">LEVELS</code>子句修改其可替代性。
                  </p>
                  <div class="infoboxnotealso" id="GUID-570E2FF9-E36F-4E11-9BFE-5F41270D2F7F__GUID-FF3198FD-93FE-410A-81B0-64CE9B1014D7">
                     <p class="notep1">也可以看看：</p>
                     <p>有关<code class="codeph">IS</code> <code class="codeph">OF</code> <span class="italic"><code class="codeph">type</code></span> ，请参阅<span class="q">“ <a href="inheritance-in-sql-object-types.html#GUID-C2A190CF-251C-471C-8C77-719D751ACFC2" title="您可以强制使用约束将对象列或属性中允许的子类型范围限制为声明类型的层次结构中的特定子类型。">约束可替代性</a> ”</span> 。
                     </p>
                  </div>
               </div>
            </div><a id="ADOBJ7146"></a><div class="props_rev_3"><a id="GUID-7C8C1750-6182-4351-B177-FDD398E55E70" name="GUID-7C8C1750-6182-4351-B177-FDD398E55E70"></a><h3 id="ADOBJ-GUID-7C8C1750-6182-4351-B177-FDD398E55E70" class="sect3"><span class="enumeration_section">2.3.19</span>跨类型的分配</h3>
               <div>
                  <p>本节中描述的赋值规则适用于<code class="codeph">INSERT/UPDATE</code>语句， <code class="codeph">RETURNING</code>子句，函数参数和PL / SQL变量。
                  </p>
                  <p>话题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="inheritance-in-sql-object-types.html#GUID-C4315FAA-7EBD-4238-B84E-9117563F9AF7">典型的对象到对象分配</a></p>
                     </li>
                     <li>
                        <p><a href="inheritance-in-sql-object-types.html#GUID-A151459D-52CE-4F5B-AC97-23BA8755A9E2">扩大分配</a></p>
                     </li>
                     <li>
                        <p><a href="inheritance-in-sql-object-types.html#GUID-F2917628-36BE-4023-A0B8-6D14F01902C9">缩小作业</a></p>
                     </li>
                     <li>
                        <p><a href="inheritance-in-sql-object-types.html#GUID-0E9BA4CE-8562-4A3F-BAB5-0EF6E3DAC49F" title="在集合类型的表达式的赋值中，源和目标必须具有相同的声明类型。">收集作业</a></p>
                     </li>
                  </ul>
               </div><a id="ADOBJ7147"></a><div class="props_rev_3"><a id="GUID-C4315FAA-7EBD-4238-B84E-9117563F9AF7" name="GUID-C4315FAA-7EBD-4238-B84E-9117563F9AF7"></a><h4 id="ADOBJ-GUID-C4315FAA-7EBD-4238-B84E-9117563F9AF7" class="sect4"><span class="enumeration_section">2.3.19.1</span>典型对象到对象分配</h4>
                  <div>
                     <p>可替代性是亚型代表其超类型之一的能力。</p>
                     <p>将超类型替换为子类型，即在另一个方向上的替换，在编译时引发错误。</p>
                     <p>将<code class="codeph">source_typ</code>类型的源分配给<code class="codeph">target_typ</code>类型的目标必须是以下两种模式之一：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>情况1： <code class="codeph">source_typ</code>和<code class="codeph">target_typ</code>是相同的类型</p>
                        </li>
                        <li>
                           <p>情况2： <code class="codeph">source_typ</code>是<code class="codeph">target_typ</code>的子类型（扩展）</p>
                        </li>
                     </ul>
                     <p>案例2说明了扩大。</p>
                  </div>
               </div><a id="ADOBJ7148"></a><div class="props_rev_3"><a id="GUID-A151459D-52CE-4F5B-AC97-23BA8755A9E2" name="GUID-A151459D-52CE-4F5B-AC97-23BA8755A9E2"></a><h4 id="ADOBJ-GUID-A151459D-52CE-4F5B-AC97-23BA8755A9E2" class="sect4"><span class="enumeration_section">2.3.19.2</span>扩大分配</h4>
                  <div>
                     <div class="section">
                        <p>扩展是一种赋值，其中声明的源类型比声明的目标类型更具体。</p>
                        <p>扩展的一个示例是将员工实例分配给人员类型的变量。</p>
                        <p>员工是一个更狭隘，专业化的人，所以如果你不介意忽视任何使这个人成为员工的额外专业化，你就可以把员工放在一个适合一个人的位置。所有员工都是人，所以扩大任务总是有效的。</p>
                        <p>为了说明扩展，假设您有下表：</p><pre class="pre codeblock"><code>表T（pers_col person_typ，emp_col employee_typ，stu_col student_typ）</code></pre><p>以下分配显示扩大。除非<code class="codeph">perscol</code>定义为不可替换，否则分配有效。
                        </p>
                        <p><code class="codeph">UPDATE T set pers_col = emp_col;</code></p>
                        <p>以下是PL / SQL示例，首先要求您创建<code class="codeph">person_typ</code>和<code class="codeph">employee_typ</code> ：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-A151459D-52CE-4F5B-AC97-23BA8755A9E2__GUID-F1AB14F8-1434-4D03-83D5-72AB01DE7ABF">
                        <p class="titleinexample">例2-31 PL / SQL分配</p><pre class="oac_no_warn" dir="ltr">DROP TYPE person_typ FORCE; - 如果先前创建了CREATE TYPE person_typ AS OBJECT（idno NUMBER，名称VARCHAR2（30），电话VARCHAR2（20））NOT FINAL; / DROP TYPE employee_typ FORCE; - 如果先前创建了CREATE TYPE employee_typ UNDER person_typ（emp_id NUMBER，mgr VARCHAR2（30））; /  -  PL / SQL赋值示例DECLARE var1 person_typ; var2 employee_typ; BEGIN var2：= employee_typ（55，'Jane Smith'，'1-650-555-0144'，100，'Jennifer Nelson'）; var1：= var2;结束; /</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="ADOBJ7149"></a><div class="props_rev_3"><a id="GUID-F2917628-36BE-4023-A0B8-6D14F01902C9" name="GUID-F2917628-36BE-4023-A0B8-6D14F01902C9"></a><h4 id="ADOBJ-GUID-F2917628-36BE-4023-A0B8-6D14F01902C9" class="sect4"><span class="enumeration_section">2.3.19.3</span>缩小作业</h4>
                  <div>
                     <div class="section">
                        <p>缩小的任务与扩大相反。</p>
                        <p>缩小任务涉及将更普遍，更不专业的事物（例如人）视为更狭义的事物类型，例如雇员。并非所有人都是雇员，所以这样的特定任务只有在有关人员确实是雇员的情况下才有效。因此，最后，缩小分配仅适用于<span class="q">“ <a href="inheritance-in-sql-object-types.html#GUID-C4315FAA-7EBD-4238-B84E-9117563F9AF7">典型对象到对象分配</a> ”中</span>描述的情况1的情况。
                        </p>
                        <p>要执行缩小赋值，必须使用<code class="codeph">TREAT</code>函数来测试更通用声明类型的源实例实际上是更专用的目标类型的实例，因此可以对其进行操作。<code class="codeph">TREAT</code>函数执行运行时检查以确认此情况，如果源值（相关人员）不是目标类型或其子类型之一，则返回<code class="codeph">NULL</code> 。
                        </p>
                        <p>例如，下面的<code class="codeph">UPDATE</code>语句设置的值<code class="codeph">person_typ</code>列<code class="codeph">perscol</code>成列<code class="codeph">empcol</code>的<code class="codeph">employee_typ</code> 。对于<code class="codeph">perscol</code>每个值，如果该人员也是员工，则分配成功。如果此人不是员工， <code class="codeph">TREAT</code>将返回<code class="codeph">NULL</code> ，并且赋值返回<code class="codeph">NULL</code> 。</p>
                        <p><code class="codeph">UPDATE T set emp_col = TREAT（pers_col AS employee_typ）;</code></p>
                        <p>以下语句尝试在不显式更改源值的声明类型的情况下执行缩小赋值。该语句将返回错误：</p>
                        <p><code class="codeph">UPDATE T set emp_col = pers_col;</code></p>
                        <div class="infoboxnotealso" id="GUID-F2917628-36BE-4023-A0B8-6D14F01902C9__GUID-33CD64A2-7EF3-47B1-AE52-16647D2047A8">
                           <p class="notep1">也可以看看：</p>
                           <p><span class="q">“ <a href="functions-and-operators-useful-with-objects.html#GUID-BC4A9F27-9A34-481C-BEE7-75D5913E4399">使用TREAT缩小作业</a> ”</span></p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ADOBJ7151"></a><a id="ADOBJ7150"></a><div class="props_rev_3"><a id="GUID-0E9BA4CE-8562-4A3F-BAB5-0EF6E3DAC49F" name="GUID-0E9BA4CE-8562-4A3F-BAB5-0EF6E3DAC49F"></a><h4 id="ADOBJ-GUID-0E9BA4CE-8562-4A3F-BAB5-0EF6E3DAC49F" class="sect4"><span class="enumeration_section">2.3.19.4</span>收集分配</h4>
                  <div>
                     <p>在集合类型的表达式的赋值中，源和目标必须具有相同的声明类型。</p>
                     <p>在集合类型的表达式赋值中，不允许扩大或缩小。但是，可以将子类型值分配给超类型集合。例如，在创建新的<code class="codeph">student_typ</code> ，假设我们有以下集合类型：</p>
                     <div class="example" id="GUID-0E9BA4CE-8562-4A3F-BAB5-0EF6E3DAC49F__GUID-28842472-6EC4-47F3-AA1D-C545C93B3E78">
                        <p class="titleinexample">示例2-32创建集合person_set</p><pre class="oac_no_warn" dir="ltr">- 需要2-21 DROP student_typ; - 如果先前创建了CREATE TYPE student_typ UNDER person_typ（dept_id NUMBER，major VARCHAR2（30））NOT FINAL; / CREATE TYPE person_set AS TABLE OF person_typ; / CREATE TYPE student_set AS TABLE OF student_typ; /</pre><p>这些不同集合类型的表达式不能相互分配，但<code class="codeph">student_typ</code>的集合元素可以分配给<code class="codeph">person_set</code>类型的集合：</p><pre class="oac_no_warn" dir="ltr">DECLARE var1 person_set; var2 student_set; elem1 person_typ; <span class="bold">elem2</span> student_typ; BEGIN  -  var1：= var2; / * ILLEGAL  - 不是相同类型的集合* / var1：= <span class="bold">person_set</span> （elem1， <span class="bold">elem2</span> ）; / *法律：元素属于子类型* / END; /</pre></div>
                     <!-- class="example" -->
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>