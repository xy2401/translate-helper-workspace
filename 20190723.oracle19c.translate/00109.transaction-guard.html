<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <title>使用Transaction Guard</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Database Development Guide"></meta>
      <meta property="og:description" content=""></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Database Development Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="database-development-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-31T23:23:15-08:00"></meta>
      <meta name="dcterms.title" content="Database Development Guide"></meta>
      <meta name="dcterms.dateCopyrighted" content="1996, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96334-02"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="editions.html" title="Previous" type="text/html"></link>
      <link rel="next" href="book-index.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.isVersionOf" content="ADFNS"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="editions.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="book-index.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">数据库开发指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="advanced-part.html" property="item" typeof="WebPage"><span property="name">应用程序开发人员的高级主题</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">使用Transaction Guard</li>
            </ol>
            <a id="GUID-6C5880E5-C45F-4858-A069-A28BB25FD1DB" name="GUID-6C5880E5-C45F-4858-A069-A28BB25FD1DB"></a><a id="ADFNS318"></a><a id="ADFNS8000"></a>
            
            <h2 id="ADFNS-GUID-6C5880E5-C45F-4858-A069-A28BB25FD1DB" class="sect2"><span class="enumeration_chapter">28</span>使用Transaction Guard</h2>
         </header>
         <div class="ind">
            <div>
               <p><span class="bold">Transaction Guard</span>为应用程序提供了一个通用工具，用于在计划内和计划外中断时最多执行一次。应用程序使用逻辑事务ID来确定中断后数据库会话中打开的最后一个事务的提交结果。如果没有Transaction Guard，尝试在中断后重播操作的应用程序可能会通过提交重复事务而导致逻辑损坏。Application Continuity使用Transaction Guard进行自动和透明的事务重放。
               </p>
               <p>Transaction Guard提供以下好处：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p>保留返回的结果 - 已提交或未提交，以便可以依赖它</p>
                  </li>
                  <li>
                     <p>确保每个事务的已知提交结果</p>
                  </li>
                  <li>
                     <p>可用于为希望重新提交自身的应用程序提供最多一次的事务执行</p>
                  </li>
                  <li>
                     <p>Application Continuity用于自动和透明的事务重放</p>
                  </li>
               </ul>
               <p>本章假定您熟悉使用Transaction Guard的技术或产品环境的主要相关概念和技术。</p>
               <div class="section">
                  <p class="subhead1" id="GUID-6C5880E5-C45F-4858-A069-A28BB25FD1DB__GUID-40FDFA41-BFC2-40D0-B638-929417A81019">话题：</p>
               </div>
               <!-- class="section" -->
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="transaction-guard.html#GUID-C4CB46C6-EC27-42EA-9CE5-4467079A27E5">Transaction Guard解决的问题</a></p>
                  </li>
                  <li>
                     <p><a href="transaction-guard.html#GUID-2FA3A95E-D3A7-4E39-B6FC-F1F5C0970CFD">Transaction Guard提供的解决方案</a></p>
                  </li>
                  <li>
                     <p><a href="transaction-guard.html#GUID-A8E098A7-580A-4ABD-9C83-84E526A05655">交易警卫概念和范围</a></p>
                  </li>
                  <li>
                     <p><a href="transaction-guard.html#GUID-6868526F-C6BD-4886-A191-7A866673D31A" title="如果您使用的是Oracle RAC或Oracle RAC One，请使用srvctl命令创建和修改服务。如果您使用的是Oracle RAC或Oracle RAC One，请使用srvctl命令创建和修改服务。">Transaction Guard的数据库配置</a></p>
                  </li>
                  <li>
                     <p><a href="transaction-guard.html#GUID-70A0E0F0-1B2D-4CBC-A318-C52FC2099B88">开发使用Transaction Guard的应用程序</a></p>
                  </li>
                  <li>
                     <p><a href="transaction-guard.html#GUID-1FAF5D75-6E7A-4AB8-868C-5A9D4847D6E9">交易保护及其与应用连续性的关系</a></p>
                  </li>
               </ul>
               <div class="infoboxnotealso" id="GUID-6C5880E5-C45F-4858-A069-A28BB25FD1DB__GUID-36FDCB09-5877-4E8F-814C-9093E370802D">
                  <p class="notep1">也可以看看：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="../jjdbc/transaction-guard.html#JJDBC29121" target="_blank"><span class="italic">Oracle数据库JDBC开发人员指南</span></a> ，了解有关将Transaction Guard与Oracle Java数据库连接（JDBC）一起使用的更多信息</p>
                     </li>
                     <li>
                        <p><a href="../lnoci/index.html" target="_blank"><span class="italic">“Oracle调用接口程序员指南”</span></a> ，了解有关将Transaction Guard与OCI一起使用的更多信息</p>
                     </li>
                  </ul>
               </div>
            </div><a id="ADFNS319"></a><div class="props_rev_3"><a id="GUID-C4CB46C6-EC27-42EA-9CE5-4467079A27E5" name="GUID-C4CB46C6-EC27-42EA-9CE5-4467079A27E5"></a><h3 id="ADFNS-GUID-C4CB46C6-EC27-42EA-9CE5-4467079A27E5" class="sect3">交易守卫解决的问题</h3>
               <div>
                  <p>在没有Transaction Guard的应用程序中，在中断后恢复应用程序的一个基本问题是发送回客户端的提交消息不是持久的。如果客户端和服务器之间存在中断，则客户端会看到一条错误消息，指示通信失败。如果提交执行任何提交操作，程序调用已完成并执行所有预期提交和会话状态更改，或者如果调用失败，或者更糟糕的是，仍然运行与客户端断开连接，则此错误不会通知应用程序。</p>
                  <p>如果没有Transaction Guard，在与服务器通信失败后，以保证和可扩展的方式确定上次提交操作的结果是不可能或极其困难的。如果应用程序必须确定是否已提交到数据库，则应用程序必须添加自定义异常代码以查询应用程序中每个可能提交点的结果。鉴于系统可能在任何地方发生故障，这几乎是不切实际的，因为查询必须特定于每个提交。在应用程序构建并投入生产之后，这是完全不切实际的。此外，查询无法给出正确的答案，因为事务可以在执行该查询后立即提交。实际上，在通信失败之后，服务器可能仍在运行提交尚未意识到客户端已断开连接。对于数据库中的PL / SQL或Java，对于程序提交，也没有关于该提交是否已完成或在中途中止的记录。虽然这样的程序可能已经提交，但可能没有为该程序进行后续工作。</p>
                  <p>未能识别上次提交已提交，或将很快提交或尚未完成，可能导致尝试重播的应用程序，从而导致重复的事务提交和其他形式的“逻辑损坏”，因为软件可能会尝试重新发布已经坚持改变。</p>
                  <p>如果没有Transaction Guard，如果已启动事务并且已发出提交，则发送回客户端的提交消息不会持久。客户端不知道事务是否已提交。如果非事务状态不正确或已经提交，则无法有效地重新提交事务。在没有保证提交和完成信息的情况下，重新提交可能导致多次应用事务并且在具有错误状态的会话中。</p>
               </div>
            </div><a id="ADFNS320"></a><div class="props_rev_3"><a id="GUID-2FA3A95E-D3A7-4E39-B6FC-F1F5C0970CFD" name="GUID-2FA3A95E-D3A7-4E39-B6FC-F1F5C0970CFD"></a><h3 id="ADFNS-GUID-2FA3A95E-D3A7-4E39-B6FC-F1F5C0970CFD" class="sect3">交易守卫提供的解决方案</h3>
               <div>
                  <p>从Oracle Database 12 <span class="italic">c</span>第1版（12.1.0.1）开始，Transaction Guard为应用程序提供了新的集成工具，用于自动和透明地实现幂等性，并且可以扩展。其主要特点如下：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>的耐久性<code class="codeph">COMMIT</code>通过保存在提交用于所有支持的事务处理类型对数据库（Oracle数据库<span class="italic">12c的</span>第1版（12.1.0.1）或更高版本）的逻辑事务标识符（LTXID）的结果。这包括使用自动提交，PL / SQL内部，远程事务，单阶段XA事务以及无法使用通用方法识别的标注执行的事务的幂等性。
                        </p>
                     </li>
                     <li>
                        <p>使用LTXID支持最多一次执行语义，这样当LTXID识别出飞行中的该事务的多个副本时，不能复制受逻辑事务标识符保护的数据库事务。</p>
                     </li>
                     <li>
                        <p>阻止提交正在进行的工作以确保无论中断情况如何，受LTXID保护的同一事务的另一次提交都无法提交。</p>
                     </li>
                     <li>
                        <p>确定在LTXID上提交的工作是作为顶级调用（客户端到服务器）的一部分提交的，还是嵌入在服务器的过程（例如PL / SQL）中。嵌入式提交状态表示在提交完成时，执行提交的整个过程尚未完成。除非该过程本身返回到数据库引擎，否则无法保证在提交之外的任何工作都已完成。</p>
                     </li>
                     <li>
                        <p>确定提交解决方案所针对的数据库是在原始提交之前，同步还是在其后面，以及在客户端提交的事务提交顺序中存在间隙时拒绝。如果服务器或客户端在LTXID序列上不同步，则尝试获取结果被视为错误。</p>
                     </li>
                     <li>
                        <p>在LTXID更改时触发的JDBC瘦客户端驱动程序的回调。这可以由更高层应用程序（如WebLogic Server和第三方）使用，以便在需要时保持当前的LTXID可供使用。</p>
                     </li>
                     <li>
                        <p>跨全局不同数据库以及整合到多租户基础架构中的数据库之间的命名空间唯一性。这包括Oracle Real Application Clusters（Oracle RAC）和RAC One，Data Guard和Multitenant数据库。</p>
                     </li>
                     <li>
                        <p>跨全局数据库以及整合到多租户基础架构中的数据库之间的服务名称唯一性。这可确保将连接正确定向到事务信息。</p>
                     </li>
                  </ul>
               </div>
            </div><a id="ADFNS323"></a><a id="ADFNS322"></a><div class="props_rev_3"><a id="GUID-A8E098A7-580A-4ABD-9C83-84E526A05655" name="GUID-A8E098A7-580A-4ABD-9C83-84E526A05655"></a><h3 id="ADFNS-GUID-A8E098A7-580A-4ABD-9C83-84E526A05655" class="sect3">交易警卫概念和范围</h3>
               <div>
                  <p>本节介绍了Transaction Guard的一些关键概念，以及Transaction Guard涵盖和未涵盖的内容。</p>
                  <div class="section">
                     <p class="subhead2" id="GUID-A8E098A7-580A-4ABD-9C83-84E526A05655__GUID-B9D86B39-5809-47AB-941F-EC2DAC78661D">话题：</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="transaction-guard.html#GUID-7A9030F2-FC39-4A72-8CEE-92CDD2FA59AD">逻辑事务标识符（LTXID）</a></p>
                        </li>
                        <li>
                           <p><a href="transaction-guard.html#GUID-1E1094F5-F8B2-49C3-B2C6-CF7AC2A3C9F7">最多执行一次</a></p>
                        </li>
                        <li>
                           <p><a href="transaction-guard.html#GUID-2EA7BC0E-FA8B-43D6-89D5-45AFA040CCC4">交易保护范围</a></p>
                        </li>
                        <li>
                           <p><a href="transaction-guard.html#GUID-25E7E67C-49F6-4C1C-8227-075C2450ED85">交易保护除外</a></p>
                        </li>
                     </ul>
                     <div class="infoboxnotealso" id="GUID-A8E098A7-580A-4ABD-9C83-84E526A05655__GUID-0F04430B-47B8-450E-AFD8-EC64DD735439">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>有关Transaction Guard如何工作的更多信息，请参阅<a href="../cncpt/transactions.html#CNCPT89217" target="_blank"><span class="italic">Oracle数据库概念</span></a></p>
                           </li>
                           <li>
                              <p><a href="../jjdbc/transaction-guard.html#JJDBC29121" target="_blank"><span class="italic">Oracle数据库JDBC开发人员指南</span></a> ，了解有关将Transaction Guard与Oracle Java数据库连接（JDBC）一起使用的更多信息</p>
                           </li>
                        </ul>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div><a id="ADFNS324"></a><div class="props_rev_3"><a id="GUID-7A9030F2-FC39-4A72-8CEE-92CDD2FA59AD" name="GUID-7A9030F2-FC39-4A72-8CEE-92CDD2FA59AD"></a><h4 id="ADFNS-GUID-7A9030F2-FC39-4A72-8CEE-92CDD2FA59AD" class="sect4">逻辑事务标识符（LTXID）</h4>
                  <div>
                     <p>应用程序使用称为<span class="bold">逻辑事务标识符（LTXID）</span>的概念来确定中断后数据库会话中打开的最后一个事务的结果。逻辑事务ID存储在OCI会话句柄和JDBC Thin和ODP.NET驱动程序的连接对象中。逻辑事务ID是最多一次语义的基础。
                     </p>
                     <p>Transaction Guard协议确保：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>每个逻辑事务的执行是唯一的。</p>
                        </li>
                        <li>
                           <p>在支持的提交时检测到重复，以确保对于所有提交点，不得绕过协议。</p>
                        </li>
                        <li>
                           <p>提交事务时，逻辑事务ID将在重试保留期间保持不变（默认值= 24小时，最长值= 30天）。</p>
                        </li>
                        <li>
                           <p>获取结果时，将阻止LTXID，以通过强制执行未提交状态来确保该LTXID的早期版本无法提交。如果已提交或强制使用具有相同LTXID的早期版本，则阻止LTXID将返回相同的结果。</p>
                        </li>
                     </ul>
                     <p>在会话建立时自动分配逻辑会话号。它是一个不透明的结构，应用程序无法读取。对于可伸缩性，每个LTXID都带有一个称为提交编号的运行编号，当为数据库的每次往返提交数据库事务时，该编号会增加。此运行提交编号从零开始。</p>
                  </div>
               </div><a id="ADFNS325"></a><div class="props_rev_3"><a id="GUID-1E1094F5-F8B2-49C3-B2C6-CF7AC2A3C9F7" name="GUID-1E1094F5-F8B2-49C3-B2C6-CF7AC2A3C9F7"></a><h4 id="ADFNS-GUID-1E1094F5-F8B2-49C3-B2C6-CF7AC2A3C9F7" class="sect4">最多执行一次</h4>
                  <div>
                     <p>Transaction Guard使用逻辑事务标识符（LTXID）来避免重复事务。这种确保最多一次执行事务的能力被称为<span class="italic">交易幂等性</span> 。LTXID在提交时保留，并在回滚后重用。在正常运行时期间，LTXID会自动保存在客户端和服务器的会话中，以用于每个数据库事务。在提交时，LTXID作为提交事务的一部分而持久化。
                     </p>
                     <p>最多一次的协议要求数据库在同意重播的保留期内保持LTXID。默认保留期为24小时，但您可能需要更短或更长的时间，可以想象甚至一周或更长时间。保留期越长，最多一次检查在重放时使用旧LTXID阻止旧事务的时间越长。每项服务都提供该设置。当涉及多个数据库时（如使用Data Guard和Active Data Guard的情况），LTXID将通过使用重做复制到涉及的每个数据库。</p>
                     <p>为Oracle JDBC Thin（具有类似的OCI，OCCI和ODP.NET客户端API）提供的<code class="codeph">getLTXID</code> API允许应用程序检索在死会话中使用的逻辑事务标识符。这是确定最后一笔交易的状态所必需的。
                     </p>
                     <p><code class="codeph">DBMS_APP_CONT.GET_LTXID_OUTCOME</code> PL / SQL子程序允许应用程序查找指定逻辑事务标识符的操作结果。调用<code class="codeph">DBMS_APP_CONT.GET_LTXID_OUTCOME</code>可能涉及服务器阻止LTXID提交以便结果已知。如果使用该LTXID的交易正在进行或即将提交，则这是一项要求。使用Transaction Guard的应用程序在发生可恢复的错误后获取LTXID，然后在尝试重放之前调用<code class="codeph">DBMS_APP_CONT.GET_LTXID_OUTCOME</code> 。
                     </p>
                     <div class="infoboxnotealso" id="GUID-1E1094F5-F8B2-49C3-B2C6-CF7AC2A3C9F7__NOTE-125-CBD01D09">
                        <p class="notep1">也可以看看：</p>
                        <p>有关<code class="codeph">DBMS_APP_CONT.GET_LTXID_OUTCOME</code> PL / SQL子程序的更多信息，请<a href="../arpls/DBMS_APP_CONT.html#ARPLS74292" target="_blank"><span class="italic">参见Oracle Database PL / SQL包和类型参考</span></a></p>
                     </div>
                  </div>
               </div><a id="ADFNS326"></a><div class="props_rev_3"><a id="GUID-2EA7BC0E-FA8B-43D6-89D5-45AFA040CCC4" name="GUID-2EA7BC0E-FA8B-43D6-89D5-45AFA040CCC4"></a><h4 id="ADFNS-GUID-2EA7BC0E-FA8B-43D6-89D5-45AFA040CCC4" class="sect4">交易保护范围</h4>
                  <div>
                     <p>您可以在系统中的每个数据库上使用Transaction Guard，包括在单实例数据库，Real Application Clusters，Data Guard和Active Data Guard之间重新启动和故障转移。</p>
                     <p>以下Oracle Database 12c配置支持Transaction Guard：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>单实例Oracle RDBMS</p>
                        </li>
                        <li>
                           <p>真正的应用集群</p>
                        </li>
                        <li>
                           <p>Data Guard</p>
                        </li>
                        <li>
                           <p>Active Data Guard</p>
                        </li>
                        <li>
                           <p>多租户包括拔出/插入和12.2重定位到PDB / CDB，但不包括“with clone”选项</p>
                        </li>
                        <li>
                           <p>用于上述数据库配置的全局数据服务</p>
                        </li>
                     </ul>
                     <p>Transaction Guard支持针对Oracle Database 12c的以下事务类型：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>本地交易</p>
                        </li>
                        <li>
                           <p>数据定义语言（DDL）事务</p>
                        </li>
                        <li>
                           <p>数据控制语言（DCL）事务</p>
                        </li>
                        <li>
                           <p>分布式事务</p>
                        </li>
                        <li>
                           <p>远程交易</p>
                        </li>
                        <li>
                           <p>并行交易</p>
                        </li>
                        <li>
                           <p>成功承诺（自动提交）</p>
                        </li>
                        <li>
                           <p>带有嵌入式提交支持的客户端驱动程序的PL / SQL</p>
                        </li>
                        <li>
                           <p>从Oracle Database 12c第2版（12.2.0.1）开始，使用单阶段优化的XA事务（包括XA提交标志TMONEPHASE和读取优化）</p>
                        </li>
                        <li>
                           <p><code class="codeph">ALTER SESSION SET</code> Container with Service子句，服务使用Transaction Guard</p>
                        </li>
                     </ul>
                     <p>Transaction Guard支持以下客户端驱动程序：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>12 <span class="italic">c</span> JDBC type 4驱动程序</p>
                        </li>
                        <li>
                           <p>12 <span class="italic">c</span> OCI和OCCI客户端驱动程序</p>
                        </li>
                        <li>
                           <p>12 <span class="italic">c</span> Oracle Data Provider for .NET（ODP.NET），非托管驱动程序</p>
                        </li>
                        <li>
                           <p>12 <span class="italic">c</span> ODP.NET，ODAC 12 <span class="italic">c</span>版本4或更高版本中的托管驱动程序</p>
                        </li>
                     </ul>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-71235BCD-DC4B-4466-BE65-8B0B02392666" name="GUID-71235BCD-DC4B-4466-BE65-8B0B02392666"></a><h4 id="ADFNS-GUID-71235BCD-DC4B-4466-BE65-8B0B02392666" class="sect4">具有XA事务的事务处理保护</h4>
                  <div>
                     <p></p>
                     <p>从Oracle Database 12.2发行版开始，Transaction Guard支持XA事务以确定一个阶段事务的结果。Transaction Guard支持在<code class="codeph">commit</code>操作期间使用TMONEPHASE的本地事务和XA事务。当应用程序发出使用<code class="codeph">TMTWOPHASE</code>的XA事务时，事务处理保护会为该事务禁用自身，并自动重新启用以为下一个事务做好准备。这允许Transaction Guard支持以下XA事务：</p>
                     <div class="p">
                        <ol>
                           <li>
                              <p>使用<code class="codeph">autocommit</code>本地事务</p>
                           </li>
                           <li>
                              <p>使用显式<code class="codeph">commit</code>本地事务 
                              </p>
                           </li>
                           <li>
                              <p>使用<code class="codeph">TMONEPHASE</code>标志提交的XA事务</p>
                           </li>
                        </ol>
                     </div>
                     <p>TP监视器和应用程序可以使用Transaction Guard获取这些事务类型的<code class="codeph">commit</code>操作的结果。事务保护为外部管理的<code class="codeph">TMTWOPHASE</code>提交操作禁用自身，并自动为下一个事务重新启用。如果Transaction Guard API与<code class="codeph">TMTWOPHASE</code>事务一起使用， <code class="codeph">TMTWOPHASE</code>在禁用Transaction Guard时返回警告消息。TP监视器拥有<code class="codeph">TMTWOPHASE</code>事务的提交结果。此功能允许TP监视器返回<code class="codeph">TMONEPHASE</code>操作的明确结果。
                     </p>
                  </div>
               </div><a id="ADFNS331"></a><div class="props_rev_3"><a id="GUID-25E7E67C-49F6-4C1C-8227-075C2450ED85" name="GUID-25E7E67C-49F6-4C1C-8227-075C2450ED85"></a><h4 id="ADFNS-GUID-25E7E67C-49F6-4C1C-8227-075C2450ED85" class="sect4">交易保护除外</h4>
                  <div>
                     <p>Transaction Guard故意排除递归事务和自治事务，以便可以重新执行它们。</p>
                     <p>从Oracle Database 12 <span class="italic">c</span> Release 2开始，Transaction Guard也不包括：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>两个XA事务在外部进行管理。使用XA事务时，Transaction Guard维护单阶段XA事务的提交结果，并为外部管理的两阶段事务静默禁用自身，因为此结果由TP监视器拥有。</p>
                        </li>
                        <li>
                           <p>Active Data Guard，具有用于转发事务的读/写数据库链接</p>
                        </li>
                        <li>
                           <p>Golden Gate和Logical Standby用于确定逻辑数据库失败时的结果。Golden Gate和Logical Standby端点可以使用Transaction Guard</p>
                        </li>
                        <li>
                           <p>启用Transaction Guard后无法执行完全数据库导入。使用不带Transaction Guard的管理服务进行完整数据库导入。不排除用户和对象导入。</p>
                        </li>
                        <li>
                           <div class="p">TAF和Application Continuity在内部处理Transaction Guard。不要在以下位置对应用程序中的Transaction Guard进行编码：<ul style="list-style-type:disc">
                                 <li>
                                    <p>来自TAF的失败回归</p>
                                 </li>
                                 <li>
                                    <p>TAF回调TAF或OCI和ODP.NET的应用程序连续性</p>
                                 </li>
                                 <li>
                                    <p>适用于Java的Application Continuity的JDBC初始化回调</p>
                                 </li>
                              </ul>
                           </div>
                        </li>
                     </ul>
                     <p>Transaction Guard排除了由复制技术维护的数据库之间的故障转移：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>复制到金门</p>
                        </li>
                        <li>
                           <p>复制到逻辑备用</p>
                        </li>
                        <li>
                           <p>PDB克隆子句（不包括PDB在线重定位12c第2版及更高版本）</p>
                        </li>
                        <li>
                           <p>所有第三方复制解决方案</p>
                        </li>
                     </ul>
                     <p>如果使用任何复制技术（如Golden Gate，Logical Standby或第三方复制）使用数据库副本，则在此配置中可能不会在主数据库和辅助数据库之间使用Transaction Guard。</p>
                     <p>您可以在参与复制的每个数据库上使用Transaction Guard。在这种情况下，每个数据库必须使用不同的数据库唯一标识符。使用V $ DATABASE获取每个数据库的DBID。</p>
                  </div>
               </div>
            </div><a id="ADFNS334"></a><a id="ADFNS332"></a><div class="props_rev_3"><a id="GUID-6868526F-C6BD-4886-A191-7A866673D31A" name="GUID-6868526F-C6BD-4886-A191-7A866673D31A"></a><h3 id="ADFNS-GUID-6868526F-C6BD-4886-A191-7A866673D31A" class="sect3">Transaction Guard的数据库配置</h3>
               <div>
                  <p>本节包含与配置数据库以使用Transaction Guard相关的信息。</p>
                  <div class="section">
                     <p class="subhead2" id="GUID-6868526F-C6BD-4886-A191-7A866673D31A__GUID-BD749D70-AF7C-4D68-A529-230C822753AC">话题：</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="transaction-guard.html#GUID-7BBE0843-3820-4FFA-8C8F-01E5CAAF4F95">配置清单</a></p>
                        </li>
                        <li>
                           <p><a href="transaction-guard.html#GUID-92B85642-BA82-47A6-BFFF-F73DCCCB9CB5">交易历史表</a></p>
                        </li>
                        <li>
                           <p><a href="transaction-guard.html#GUID-35C1F88A-FDA2-4918-B73E-11F95E0E9BAA" title="如果您使用的是Oracle RAC或Oracle RAC One，请使用srvctl命令创建和修改服务。如果您使用的是Oracle RAC或Oracle RAC One，请使用srvctl命令创建和修改服务。">服务参数</a></p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
               </div><a id="ADFNS335"></a><div class="props_rev_3"><a id="GUID-7BBE0843-3820-4FFA-8C8F-01E5CAAF4F95" name="GUID-7BBE0843-3820-4FFA-8C8F-01E5CAAF4F95"></a><h4 id="ADFNS-GUID-7BBE0843-3820-4FFA-8C8F-01E5CAAF4F95" class="sect4">配置清单</h4>
                  <div>
                     <p>要将Transaction Guard与应用程序一起使用，您必须执行以下操作：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>使用Oracle Database 12 <span class="italic">c</span>第1版（12.1.0.1）或更高版本。
                           </p>
                        </li>
                        <li>
                           <p>使用应用程序服务进行所有数据库工作。如果使用的是Oracle RAC，则使用<code class="codeph">srvctl</code>命令创建服务;如果不使用Oracle RAC，则使用<code class="codeph">DBMS_SERVICE.CREATE_SERVICE</code> PL / SQL子程序创建服务。</p>
                           <p><span class="italic"><span class="bold">不要</span></span>使用默认的数据库服务，因为这些服务是管理的目的，不能被操纵。也就是说，不要使用设置为<span class="italic">db_name</span>或<span class="italic">db_unique_name</span>的服务名称。
                           </p>
                        </li>
                        <li>
                           <p>将<code class="codeph">DBMS_APP_CONT</code>包的权限授予将调用<code class="codeph">GET_LTXID_OUTCOME</code>的数据库用户：</p><pre class="oac_no_warn" dir="ltr">GRANT EXECUTE ON DBMS_APP_CONT TO <span class="italic">&lt;user-name&gt;</span> ;</pre></li>
                        <li>
                           <p>如果将Transaction Guard与DDL语句一起使用，则增加<code class="codeph">DDL_LOCK_TIMEOUT</code> ..
                           </p>
                        </li>
                     </ul>
                     <p>要将Transaction Guard与应用程序一起使用，Oracle建议您执行以下操作：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>找到并定义事务历史记录表以获得最佳性能。</p>
                        </li>
                        <li>
                           <p>如果您使用的是Oracle RAC或Oracle Data Guard，请确保将FAN配置为在出错时快速与中断客户端进行通信。</p>
                        </li>
                        <li>
                           <p>设置以下参数： <code class="codeph">AQ_HA_NOTIFICATIONS = TRUE</code> （如果使用OCI FAN）。
                           </p>
                        </li>
                     </ul>
                     <div class="infoboxnotealso" id="GUID-7BBE0843-3820-4FFA-8C8F-01E5CAAF4F95__NOTE-125-CBD0908D">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>有关<code class="codeph">DDL_LOCK_TIMEOUT</code>更多信息，请<code class="codeph">DDL_LOCK_TIMEOUT</code> <a href="../refrn/DDL_LOCK_TIMEOUT.html#REFRN10267" target="_blank"><span class="italic">Oracle数据库参考</span></a></p>
                           </li>
                           <li>
                              <p><a href="transaction-guard.html#GUID-92B85642-BA82-47A6-BFFF-F73DCCCB9CB5">交易历史表</a></p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="ADFNS337"></a><div class="props_rev_3"><a id="GUID-92B85642-BA82-47A6-BFFF-F73DCCCB9CB5" name="GUID-92B85642-BA82-47A6-BFFF-F73DCCCB9CB5"></a><h4 id="ADFNS-GUID-92B85642-BA82-47A6-BFFF-F73DCCCB9CB5" class="sect4">交易历史表</h4>
                  <div>
                     <p>事务历史表维护逻辑事务标识符（LTXID）到数据库事务的映射。只有具有DBA权限的数据库用户才能访问此表。它由Oracle数据库自动维护，用户不得直接针对事务历史记录表发出DDL或DML语句。</p>
                     <p>在数据库创建和升级时，默认情况下会在SYSAUX表空间中创建事务历史记录表（LTXID_TRANS）。使用最后一个分区的存储添加实例时会添加新分区。但是，如果此表空间的位置不是性能的最佳位置，则DBA可以将分区移动到另一个表空间。例如，以下语句更改事务历史记录表以将其移动到名为<code class="codeph">FastPace</code>的表空间：</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE LTXID_TRANS移动分区LTXID_TRANS_4表空间FastPace存储（初始10G接下来的10G minextents 1 maxextents 121）;</pre><div class="infoboxnotealso" id="GUID-92B85642-BA82-47A6-BFFF-F73DCCCB9CB5__GUID-B5B110DB-C32D-4AAC-BD6B-6715CBB0FFBB">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>有关<code class="codeph">ALTER TABLE</code>语句的信息，请<a href="../sqlrf/ALTER-TABLE.html#SQLRF01001" target="_blank"><span class="italic">参见Oracle数据库SQL语言参考</span></a></p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="ADFNS339"></a><a id="ADFNS340"></a><a id="ADFNS342"></a><a id="ADFNS338"></a><div class="props_rev_3"><a id="GUID-35C1F88A-FDA2-4918-B73E-11F95E0E9BAA" name="GUID-35C1F88A-FDA2-4918-B73E-11F95E0E9BAA"></a><h4 id="ADFNS-GUID-35C1F88A-FDA2-4918-B73E-11F95E0E9BAA" class="sect4">服务参数</h4>
                  <div>
                     <p>配置提交结果和保留的服务。</p>
                     <p>例如：</p><pre class="oac_no_warn" dir="ltr">COMMIT_OUTCOME = TRUE RETENTION_TIMEOUT = <span class="italic">&lt;retention-value&gt;</span>
</pre><p><code class="codeph">COMMIT_OUTCOME</code>确定在执行提交后是否可以访问事务提交结果。此功能使提交的结果持久，并且应用程序使用它来强制执行在中断之前执行的最后一个事务的状态。该功能由Oracle重放驱动程序和WebLogic Server在内部使用，并且可供其他应用程序使用以确定结果。<code class="codeph">COMMIT_OUTCOME</code>可能的值为<code class="codeph">FALSE</code> （默认值）和<code class="codeph">TRUE</code> ，并且值必须为<code class="codeph">TRUE</code>才能使Transaction Guard生效。
                     </p>
                     <p>以下注意事项适用于<code class="codeph">COMMIT_OUTCOME</code> ：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>使用<code class="codeph">DBMS_APP_CONT.GET_LTXID_OUTCOME</code>过程要求<code class="codeph">COMMIT_OUTCOME</code>为<code class="codeph">TRUE</code> 。</p>
                        </li>
                        <li>
                           <p><code class="codeph">COMMIT_OUTCOME</code>对Active Data Guard和只读数据库没有影响。使用带有读/写Active Guard的Transaction Guard与不转发DML的数据库链接相结合。
                           </p>
                        </li>
                        <li>
                           <p>用户定义的数据库服务允许<code class="codeph">COMMIT_OUTCOME</code> 。排除了对数据库服务的使用，因为此服务不会切换到Data Guard，也无法在主数据库的计划中断时启动，停止或禁用。
                           </p>
                        </li>
                     </ul>
                     <p><code class="codeph">RETENTION_TIMEOUT</code>与<code class="codeph">COMMIT_OUTCOME</code>结合使用以设置保留提交结果的时间量。保留超时值以秒为单位指定;默认值为86400（24小时），最大值为2592000（30天）。您可以使用srvctl命令或<code class="codeph">DBMS_SERVICE</code> PL / SQL包指定保留超时值。
                     </p>
                     <div class="infoboxnotealso" id="GUID-35C1F88A-FDA2-4918-B73E-11F95E0E9BAA__GUID-2453CA3E-5AF0-4371-8CDA-AA22ABF264DA">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>有关<a href="../admin/configuring-automatic-restart-of-an-oracle-database.html#ADMIN5013" target="_blank"><code class="codeph">srvctl add service</code></a>和<a href="../admin/configuring-automatic-restart-of-an-oracle-database.html#ADMIN5047" target="_blank"><code class="codeph">srvctl modify service</code></a>命令的信息，请<a href="../admin/configuring-automatic-restart-of-an-oracle-database.html#ADMIN5013" target="_blank"><code class="codeph">srvctl add service</code></a> <span class="italic">“Oracle数据库管理员指南”</span></p>
                           </li>
                           <li>
                              <p>有关<code class="codeph">DBMS_SERVICE</code>包的信息，请<code class="codeph">DBMS_SERVICE</code> <a href="../arpls/DBMS_SERVICE.html#ARPLS092" target="_blank"><span class="italic">Oracle Database PL / SQL包和类型参考</span></a> 。
                              </p>
                           </li>
                           <li>
                              <p>有关<code class="codeph">DBMS_APP_CONT.GET_LTXID_OUTCOME</code>过程的详细信息，请参阅<a href="../arpls/DBMS_APP_CONT.html#ARPLS73456" target="_blank"><span class="italic">Oracle Database PL / SQL包和类型参考</span></a></p>
                           </li>
                        </ul>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-DD955A62-9BBA-4829-97ED-31926D82F057" name="GUID-DD955A62-9BBA-4829-97ED-31926D82F057"></a><h5 id="ADFNS-GUID-DD955A62-9BBA-4829-97ED-31926D82F057" class="sect5">示例：为服务器池添加和修改服务</h5>
                     <div>
                        <p>如果您使用的是Oracle RAC或Oracle RAC One，请使用<code class="codeph">srvctl</code>命令创建和修改服务。
                        </p>
                        <p><a href="transaction-guard.html#GUID-DD955A62-9BBA-4829-97ED-31926D82F057__BABFDBGJ">例28-1</a>显示了<code class="codeph">srvctl</code>的用法。您还可以使用全局数据服务（GDSCTL）。
                        </p>
                        <div class="example" id="GUID-DD955A62-9BBA-4829-97ED-31926D82F057__BABFDBGJ">
                           <p class="titleinexample">示例28-1为服务器池添加和修改服务</p><pre class="oac_no_warn" dir="ltr">srvctl add service -database orcl -service GOLD -poolname ora。Srvpool -commit_outcome TRUE -retention 604800 srvctl修改服务-database orcl -service GOLD -commit_outcome TRUE -retention 604800</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-2E3CBDBF-5F6A-4BCF-947F-A3E3C455AE00" name="GUID-2E3CBDBF-5F6A-4BCF-947F-A3E3C455AE00"></a><h5 id="ADFNS-GUID-2E3CBDBF-5F6A-4BCF-947F-A3E3C455AE00" class="sect5">示例：添加管理员托管服务</h5>
                     <div>
                        <p>如果您使用的是Oracle RAC或Oracle RAC One，请使用<code class="codeph">srvctl</code>命令创建和修改服务。
                        </p>
                        <p><a href="transaction-guard.html#GUID-2E3CBDBF-5F6A-4BCF-947F-A3E3C455AE00__BABECCJJ">例28-2</a>显示了<code class="codeph">srvctl</code>的用法。您还可以使用全球数据服务（GDSCTL）</p>
                        <div class="example" id="GUID-2E3CBDBF-5F6A-4BCF-947F-A3E3C455AE00__BABECCJJ">
                           <p class="titleinexample">示例28-2添加管理员托管服务</p><pre class="oac_no_warn" dir="ltr">srvctl add service -database codedb -service GOLD -preferred serv1 -available serv2 -commit_outcome TRUE -retention 604800</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-8B241409-D9B7-434D-B3DA-6EE9A5B11A0A" name="GUID-8B241409-D9B7-434D-B3DA-6EE9A5B11A0A"></a><h5 id="ADFNS-GUID-8B241409-D9B7-434D-B3DA-6EE9A5B11A0A" class="sect5">示例：修改服务（PL / SQL）</h5>
                     <div>
                        <p>如果您使用的是单实例数据库，请使用<code class="codeph">DBMS_SERVICE.MODIFY_SERVICE</code> PL / SQL过程来修改服务并使用FAN。</p>
                        <p><a href="transaction-guard.html#GUID-8B241409-D9B7-434D-B3DA-6EE9A5B11A0A__BABIGBHI">示例28-3</a>修改了服务（但替换了<code class="codeph">&lt;service-name&gt;</code>的实际服务名称）。
                        </p>
                        <div class="example" id="GUID-8B241409-D9B7-434D-B3DA-6EE9A5B11A0A__BABIGBHI">
                           <p class="titleinexample">示例28-3修改服务（PL / SQL）</p><pre class="pre codeblock"><code>DECLARE params dbms_service.svc_parameter_array; BEGIN params（'COMMIT_OUTCOME'）：='true'; PARAMS（ 'RETENTION_TIMEOUT'）：= 604800; PARAMS（ 'aq_ha_notifications'）：= '真'; dbms_service.modify_service（' <span class="italic">&lt;service-name&gt;</span> '，params）;结束; /</code></pre></div>
                        <!-- class="example" -->
                     </div>
                  </div>
               </div>
            </div><a id="ADFNS351"></a><a id="ADFNS344"></a><div class="props_rev_3"><a id="GUID-70A0E0F0-1B2D-4CBC-A318-C52FC2099B88" name="GUID-70A0E0F0-1B2D-4CBC-A318-C52FC2099B88"></a><h3 id="ADFNS-GUID-70A0E0F0-1B2D-4CBC-A318-C52FC2099B88" class="sect3">开发使用Transaction Guard的应用程序</h3>
               <div>
                  <div class="section">
                     <p>要使用Transaction Guard，请查看<a href="transaction-guard.html#GUID-7BBE0843-3820-4FFA-8C8F-01E5CAAF4F95">配置清单中</a>的要求和建议，并在发生可恢复错误时在错误处理中执行以下步骤：</p>
                     <div class="infoboxnote" id="GUID-70A0E0F0-1B2D-4CBC-A318-C52FC2099B88__GUID-3880AC05-B4A5-4147-8D50-43E8A4ABCD0F">
                        <p class="notep1">注意：</p>如果您使用的是TAF，请跳至<a href="transaction-guard.html#GUID-23BD4194-D13F-41F3-87D0-A8766E15E44D">事务保护和透明应用程序故障转移</a> 。
                     </div>
                  </div>
                  <!-- class="section" -->
                  <ol>
                     <li><span>检查错误是否是导致数据库会话不可用的可恢复错误。</span></li>
                     <li><span>使用客户端驱动程序提供的API（以前失败的会话获取LTXID <code class="codeph">getLTXID</code>为JDBC， <code class="codeph">OCI_ATTR_GET</code>与LTXID的OCI和<code class="codeph">LogicalTransactionId</code>为ODP.NET）。</span></li>
                     <li><span>使用该会话自己的LTXID获取新会话。</span></li>
                     <li><span>使用从API获取的LTXID调用<code class="codeph">DBMS_APP_CONT.GET_LTXID_OUTCOME</code> PL / SQL过程。返回状态告诉驱动程序最后一个事务是<code class="codeph">COMMITTED (TRUE/FALSE)</code>还是<code class="codeph">USER_CALL_COMPLETED (TRUE/FALSE)</code> 。如果客户端和数据库不同步（例如，不是相同的数据库或已还原的数据库），则此PL / SQL函数将返回错误。</span></li>
                     <li><span>应用程序可以将结果返回给用户来决定。应用程序可以重放自己。如果重放本身导致中断，则重放会话的LTXID用于<code class="codeph">DBMS_APP_CONT.GET_LTXID_OUTCOME</code>过程。</span></li>
                  </ol>
               </div><a id="ADFNS376"></a><div class="props_rev_3"><a id="GUID-B63610D4-BC72-42FB-A8AA-23E2B7429249" name="GUID-B63610D4-BC72-42FB-A8AA-23E2B7429249"></a><h4 id="ADFNS-GUID-B63610D4-BC72-42FB-A8AA-23E2B7429249" class="sect4">典型的交易保护用法</h4>
                  <div>
                     <p>以下伪代码显示了Transaction Guard的典型用法：</p><pre class="oac_no_warn" dir="ltr">接收FAN down事件（或可恢复的错误）FAN中止死会话如果可恢复错误（OCI的新OCI_ATTRIBUTE，对于JDBC是可恢复的）使用getLTXID或从您的回调获取来自死会话的最后一个LTXID获取新会话使用最后一个LTXID调用GET_LTXID_OUTCOME获取COMMITTED和USER_CALL_COMPLETED状态如果COMMITTED和USER_CALL_COMPLETED然后返回结果ELSEIF COMMITTED而不是USER_CALL_COMPLETED然后返回结果并发出警告（未返回绑定或行计数等详细信息）ELSEIF NOT COMMITTED清理并重新提交请求，或返回未提交的结果客户端</pre></div>
               </div><a id="ADFNS1031"></a><a id="ADFNS1030"></a><div class="props_rev_3"><a id="GUID-FA7D4C7B-1E43-45F7-B22F-B38B054E739E" name="GUID-FA7D4C7B-1E43-45F7-B22F-B38B054E739E"></a><h4 id="ADFNS-GUID-FA7D4C7B-1E43-45F7-B22F-B38B054E739E" class="sect4">使用LTXID的详细信息</h4>
                  <div>
                     <p>对于重放和返回结果，应用程序或第三方容器需要访问要在服务器上为每个会话提交的下一个LTXID。在可恢复的中断之后，可以使用API（ <code class="codeph">getLTXID</code> JDBC的<code class="codeph">OCI_ATTR_GET</code>和具有LTXID for OCI的OCI_ATTR_GET）从失败的会话获取LTXID。
                     </p>
                     <p>JDBC Thin驱动程序还提供了一个回调，该回调在从数据库接收的每个提交编号更改时执行。如果需要进行故障转移，第三方容器可以使用此回调来保存当前的LTXID以备使用。在每个会话中，当前的LTXID正在使用中，因此回调可以覆盖之前的回调。</p>
                     <p>如果故障转移级联而未完成（即，如果在从一次故障恢复期间发生另一次故障），则应用程序<span class="italic"><span class="bold">必须</span></span>获取然后将当前会话中生效的LTXID传递到<code class="codeph">GET_LTXID_OUTCOME</code> 。</p>
                     <p><a href="transaction-guard.html#GUID-FA7D4C7B-1E43-45F7-B22F-B38B054E739E__BABIABIB" title="LTXID条件或情况，应用程序操作和下一个要使用的LTXID">表28-1</a>显示了需要执行某些与LTXID相关的操作的几个条件或情况，以及每个应用程序操作和下一个LTXID要使用的操作。
                     </p>
                     <div class="tblformal" id="GUID-FA7D4C7B-1E43-45F7-B22F-B38B054E739E__BABIABIB">
                        <p class="titleintable">表28-1 LTXID条件或情况，应用程序操作和下一个要使用的LTXID</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="LTXID条件或情境，应用程序操作和下一个要使用的LTXID" width="100%" border="1" summary="LTXID Conditions or Situations, Application Actions, and Next LTXID to Use" frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="24%" id="d171031e2611">条件或情况</th>
                                 <th align="left" valign="bottom" width="33%" id="d171031e2614">申请行动</th>
                                 <th align="left" valign="bottom" width="42%" id="d171031e2617">下一个要使用的LTXID（容器的LTXID更改回调 - 仅限JDBC瘦）</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="24%" id="d171031e2622" headers="d171031e2611 ">
                                    <p>应用程序收到可恢复的错误并调用<code class="codeph">GET_LTXID_OUTCOME</code>来确定事务状态。
                                    </p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d171031e2622 d171031e2614 ">
                                    <p>应用程序采用新连接（使用自己的LTXID-B 0）并使用上次失败会话（LTXID-A）的LTXID调用<code class="codeph">GET_LTXID_OUTCOME</code> 。
                                    </p>
                                 </td>
                                 <td align="left" valign="top" width="42%" headers="d171031e2622 d171031e2617 ">
                                    <p>新LTXID-B 0</p>
                                    <p>还在注册时使用JDBC回调进行设置</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="24%" id="d171031e2640" headers="d171031e2611 ">
                                    <p>应用程序发现上次会话事务状态为<code class="codeph">COMMITTED</code>和<code class="codeph">USER_CALL_COMPLETED</code> 。</p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d171031e2640 d171031e2614 ">
                                    <p>将提交状态返回给客户端;应用程序可能会继续。</p>
                                 </td>
                                 <td align="left" valign="top" width="42%" headers="d171031e2640 d171031e2617 ">
                                    <p>（不适用）</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="24%" id="d171031e2656" headers="d171031e2611 ">
                                    <p>应用程序发现上次会话事务状态为<code class="codeph">COMMITTED</code>而不是<code class="codeph">USER_CALL_COMPLETED</code> 。</p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d171031e2656 d171031e2614 ">
                                    <p>将已提交状态返回给客户端并退出 - 由于调用中的工作未完成，某些应用程序无法进行。 （例如，未返回out绑定或行计数）。应用程序是否可以继续取决于应用程序。</p>
                                 </td>
                                 <td align="left" valign="top" width="42%" headers="d171031e2656 d171031e2617 ">
                                    <p>（不适用）</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="24%" id="d171031e2672" headers="d171031e2611 ">
                                    <p>应用程序发现上次会话事务状态为“未<code class="codeph">NOT COMMITTED</code> 。</p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d171031e2672 d171031e2614 ">
                                    <p>应用程序将结果返回给用户，或者根据需要进行清理，然后在有效的新会话LTXID-B 0上使用LTXID重新提交。</p>
                                    <p>如果新请求执行任何提交，则服务器返回具有LTXID-B 2并且增加的提交消息。</p>
                                 </td>
                                 <td align="left" valign="top" width="42%" headers="d171031e2672 d171031e2617 ">
                                    <p>新LTXID-B 2 ..ñ</p>
                                    <p>还在注册时使用JDBC回调进行设置</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="24%" id="d171031e2689" headers="d171031e2611 ">
                                    <p>如果应用程序已决定重播，则会收到可恢复的错误。</p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d171031e2689 d171031e2614 ">
                                    <p>应用程序采用新连接（使用LTXID-C 0）并使用LAST会话的LTXID（LTXID-B N）调用<code class="codeph">GET_LTXID_OUTCOME</code> 。
                                    </p>
                                 </td>
                                 <td align="left" valign="top" width="42%" headers="d171031e2689 d171031e2617 ">
                                    <p>新会话中的LTXID-C 0。</p>
                                    <p>还在注册时使用JDBC回调进行设置</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="24%" id="d171031e2704" headers="d171031e2611 ">
                                    <p>如果应用程序已决定重播，则会收到另一个可恢复的错误。</p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d171031e2704 d171031e2614 ">
                                    <p>应用程序采用新连接（使用LTXID-D 0）并使用LAST会话的LTXID（LTXID-C N）再次调用<code class="codeph">GET_LTXID_OUTCOME</code> 。
                                    </p>
                                 </td>
                                 <td align="left" valign="top" width="42%" headers="d171031e2704 d171031e2617 ">
                                    <p>新会话中的LTXID-D 0。</p>
                                    <p>还在注册时使用JDBC回调进行设置</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-23BD4194-D13F-41F3-87D0-A8766E15E44D" name="GUID-23BD4194-D13F-41F3-87D0-A8766E15E44D"></a><h4 id="ADFNS-GUID-23BD4194-D13F-41F3-87D0-A8766E15E44D" class="sect4">事务保护和透明应用程序故障转移</h4>
                  <div>
                     <p></p>
                     <p>使用Transaction Guard启用透明应用程序故障转移（TAF）时，TAF会为开发人员处理错误。使用TAF时不要对Transaction Guard进行编码，因为它已从Oracle Database 12 <span class="italic">c</span> Release 1（12.1.0.1）开始嵌入了Transaction Guard代码。当使用TAF和Transaction Guard时，开发人员可以使用以下TAF错误进行回滚并安全地重新提交，或者返回未提交的错误。
                     </p>
                     <div class="p">
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">ORA-25402</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">ORA-25408</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">ORA-25405</code></p>
                           </li>
                        </ul>
                     </div>
                     <p>当启用TAF时，开发人员不得直接使用<code class="codeph">GET_LTXID_OUTCOME</code>过程，因为TAF已在处理Transaction Guard。
                     </p>
                     <div class="infoboxnote" id="GUID-23BD4194-D13F-41F3-87D0-A8766E15E44D__GUID-C914F069-60B3-4585-9ED7-EEFF685EA608">
                        <p class="notep1">注意：</p>
                        <p>会话失败时不调用TAF（这包括操作系统级别的“kill -9”或<code class="codeph">ALTER SYSTEM KILL</code>会话）。在以下条件下调用TAF：</p>
                        <div class="p">
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">INSTANCE</code>失败</p>
                              </li>
                              <li>
                                 <p><code class="codeph">FAN NODE DOWN</code>活动</p>
                              </li>
                              <li>
                                 <p><code class="codeph">SHUTDOWN</code>交易</p>
                              </li>
                              <li>
                                 <p>断开<code class="codeph">POST_TRANSACTION</code></p>
                              </li>
                           </ul>
                        </div>
                     </div>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-8BA4F2BD-D12F-4CA2-8D58-623810D45B66" name="GUID-8BA4F2BD-D12F-4CA2-8D58-623810D45B66"></a><h4 id="ADFNS-GUID-8BA4F2BD-D12F-4CA2-8D58-623810D45B66" class="sect4">在ODP.NET中使用Transaction Guard</h4>
                  <div>
                     <p>以下规则适用于在ODP.NET中使用Transaction Guard：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>在两个ODP.NET提供程序中升级到XA后，LTXID不可用。</p>
                        </li>
                        <li>
                           <p>从Oracle Database 12c第2版（12.2.0.1）开始，ODP.NET根据应用程序的可用性和处理能力处理应用程序的Transaction Guard。使用ODP.NET时，只有当ODP.NET无法代表应用程序获取提交结果时，LTXID才会暴露给应用程序。例如，在向Data Guard的扩展故障转移期间。</p>
                        </li>
                        <li>
                           <p>开发人员不得在TAF回调或JDBC初始化回调中编写Transaction Guard。交易警卫是为您处理的。</p>
                        </li>
                     </ul>
                  </div>
               </div><a id="ADFNS1086"></a><div class="props_rev_3"><a id="GUID-D6581DF9-A210-46D4-9595-9CA822D2B8FF" name="GUID-D6581DF9-A210-46D4-9595-9CA822D2B8FF"></a><h4 id="ADFNS-GUID-D6581DF9-A210-46D4-9595-9CA822D2B8FF" class="sect4">连接池LTXID用法</h4>
                  <div>
                     <p>连接池为管理LTXID创建了不同的用例，因为连接和会话已预先建立和共享。在最简单的连接池和中间层模型中，每个会话句柄（客户端会话）上都存在LTXID。它在签出时从连接池与应用程序请求相关联，并在签入时与应用程序请求取消关联回池。在签出和签入之间，会话上的LTXID由该应用程序请求独占。签入后，LTXID属于空闲的池化会话。它与下一个检出该连接的应用程序请求相关联。</p>
                     <p>以这种方式使用Transaction Guard：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>可以支持当前HTTP请求的重复检测和故障转移</p>
                        </li>
                        <li>
                           <p>允许取消（实际<code class="codeph">Cancel</code>操作而不是<span class="uicontrol bold">Ctrl-C</span> ）超时请求，以及应用程序可选的重新提交</p>
                        </li>
                     </ul>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-1256CC67-2F1B-4C3F-9E76-C0AB81EECAF6" name="GUID-1256CC67-2F1B-4C3F-9E76-C0AB81EECAF6"></a><h4 id="ADFNS-GUID-1256CC67-2F1B-4C3F-9E76-C0AB81EECAF6" class="sect4">改进了XA单阶段优化的承诺结果</h4>
                  <div>
                     <p></p>
                     <p>从Oracle Database 12 <span class="italic">c</span>第2版（12.2.0.1）开始，Transaction Guard与事务处理监视器（TPM）一起使用，以确定使用单阶段优化（TMONEPLHASE标志）时提交操作的结果。Transaction Guard使用<code class="codeph">GET_LTXID_OUTCOME</code>包来帮助TPM确定与资源管理器的连接是否丢失或是否返回了模糊错误。
                     </p>
                     <p></p>
                     <div class="tblformal" id="GUID-1256CC67-2F1B-4C3F-9E76-C0AB81EECAF6__TRANSACTIONMANAGERCONDITIONSSITUATI-4DB5AA6A">
                        <p class="titleintable">表28-2事务管理器条件/情况和操作</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="事务管理器条件/情况和操作" width="100%" border="1" summary="This table shows various transaction conditions or situations that are addressed by the Transaction Manager." frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" id="d171031e3205">条件或情况</th>
                                 <th align="left" valign="bottom" id="d171031e3208">事务管理器操作</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d171031e3213" headers="d171031e3205 ">
                                    <p>如果事务已回滚，则尚未发出<code class="codeph">Commit</code> 。
                                    </p>
                                 </td>
                                 <td align="left" valign="top" headers="d171031e3213 d171031e3208 ">
                                    <p>事务管理器返回<code class="codeph">rollback</code> 。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d171031e3225" headers="d171031e3205 ">
                                    <p>已发出<code class="codeph">Commit</code> ，如果返回模糊结果。
                                    </p>
                                 </td>
                                 <td align="left" valign="top" headers="d171031e3225 d171031e3208 ">
                                    <p>事务管理器可以使用事务防护（XA）来确定错误可恢复时的结果。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d171031e3234" headers="d171031e3205 ">
                                    <p>如果事务是<code class="codeph">COMMITTED</code> 。</p>
                                 </td>
                                 <td align="left" valign="top" headers="d171031e3234 d171031e3208 ">
                                    <p>事务管理器返回<code class="codeph">COMMITTED</code> 。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d171031e3247" headers="d171031e3205 ">
                                    <p>如果交易<code class="codeph">UNCOMMITTED</code> 。</p>
                                 </td>
                                 <td align="left" valign="top" headers="d171031e3247 d171031e3208 ">
                                    <p>事务管理器借用新连接并重新发出<code class="codeph">COMMIT</code> 。原来<code class="codeph">LTXID</code>通过调用阻塞<code class="codeph">GET_LTXID_OUTCOME</code> 。</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                  </div>
               </div><a id="ADFNS365"></a><div class="props_rev_3"><a id="GUID-0466C5BB-9CC8-43B4-B46A-D51324660B48" name="GUID-0466C5BB-9CC8-43B4-B46A-D51324660B48"></a><h4 id="ADFNS-GUID-0466C5BB-9CC8-43B4-B46A-D51324660B48" class="sect4">交易保护开发的附加要求</h4>
                  <div>
                     <p>Transaction Guard是开发人员在可恢复错误之后使用以提供已知结果的工具。当返回错误指示最后一个会话已死时，必须使用它。</p>
                     <p>在以下情况下， <span class="italic">不得</span>使用Transaction Guard API：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>不要在当前会话中使用<code class="codeph">GET_LTXID_OUTCOME</code> 。它将返回错误。
                           </p>
                        </li>
                        <li>
                           <p>不要对没有收到可恢复错误的会话使用<code class="codeph">GET_LTXID_OUTCOME</code> ，即实时会话。它会阻止该会话提交。
                           </p>
                        </li>
                        <li>
                           <p>不要使用来自其他用户或其他数据库的<code class="codeph">GET_LTXID_OUTCOME</code> 。它将返回错误。
                           </p>
                        </li>
                        <li>
                           <p>请勿获取LTXID并将其保存以供日后使用，而不是立即使用。<code class="codeph">GET_LTXID_OUTCOME</code>的结果仅对上次打开或已完成的事务有效。如果它与同一会话中的早期事务一起使用，则会返回错误。
                           </p>
                        </li>
                        <li>
                           <p>如果应用程序使用TAF，请不要对Transaction Guard进行编码。使用新的TAF错误代码来返回结果。</p>
                           <div class="p">
                              <div class="infoboxnote" id="GUID-0466C5BB-9CC8-43B4-B46A-D51324660B48__GUID-7A2A8BFC-D55A-4ED0-81BF-2B4F12EBC190">
                                 <p class="notep1">注意：</p>此规则不适用于应用程序连续性。
                              </div>
                           </div>
                        </li>
                     </ul>
                     <div class="infoboxnotealso" id="GUID-0466C5BB-9CC8-43B4-B46A-D51324660B48__NOTE-124-CBD14D6A">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="transaction-guard.html#GUID-23BD4194-D13F-41F3-87D0-A8766E15E44D">事务保护和透明应用程序故障转移</a>有关TAF的更多信息</p>
                     </div>
                  </div>
               </div>
            </div><a id="ADFNS1062"></a><div class="props_rev_3"><a id="GUID-1FAF5D75-6E7A-4AB8-868C-5A9D4847D6E9" name="GUID-1FAF5D75-6E7A-4AB8-868C-5A9D4847D6E9"></a><h3 id="ADFNS-GUID-1FAF5D75-6E7A-4AB8-868C-5A9D4847D6E9" class="sect3">交易保护及其与应用连续性的关系</h3>
               <div>
                  <p>Transaction Guard为每个数据库事务提供唯一标识符（LTXID）。此标识符可用于查询事务的提交结果，也可用于确保事务仅应用一次。Transaction Guard由Application Continuity使用并由其自动启用，但也可以单独启用。Transaction Guard可防止应用程序连续性重播的事务被多次应用。如果应用程序已实现应用程序级重放，则需要将应用程序与事务防护集成以提供幂等性。</p>
                  <p>对于不需要编码的解决方案，请将应用程序配置为使用应用程序连续性。为了开发自己的重放，应用程序开发人员使用Transaction Guard进行编码。您可以为Transaction Guard和Application Continuity编写一个应用程序。Application Continuity首先生效，自定义Transaction Guard代码仅在Application Continuity无法重播时生效。它不需要同时使用，但是，如果应用程序同时使用Transaction Guard和Application Continuity，它们是兼容的。如果应用程序希望在Application Continuity之外添加Transaction Guard API，则Transaction Guard可以在禁用重放或不成功时返回提交结果。</p>
                  <div class="infoboxnotealso" id="GUID-1FAF5D75-6E7A-4AB8-868C-5A9D4847D6E9__GUID-6224A83B-0F82-4137-8DB3-545F77DBCD31">
                     <p class="notep1">也可以看看：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="../racad/design-and-deployment-techniques.html#RACAD967" target="_blank"><span class="italic">“Oracle Real Application Clusters管理和部署指南”，</span></a>以获取有关使用Oracle RAC的事务防护和应用程序连续性的信息</p>
                        </li>
                        <li>
                           <p>有关使用JDBC连接数据库的信息，请参见<a href="../jjdbc/introducing-JDBC.html#JJDBC-GUID-864DB502-5E50-4044-8132-33D6AAF8927A" target="_blank"><span class="italic">“Oracle数据库JDBC开发人员指南”</span></a></p>
                        </li>
                        <li>
                           <p><a href="../lnoci/managing-scalable-platforms.html#LNOCI08100" target="_blank"><span class="italic">Oracle Call Interface Programmer's Guide</span></a> ，了解有关使用Oracle Call Interface（OCI）连接数据库的信息</p>
                        </li>
                        <li>
                           <p>有关ODP.Net驱动程序的详细信息，请参阅<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/adfns&amp;id=ODPNT-GUID-635BAE6C-7D0B-4CF2-ADD8-8DB531B9C52E" target="_blank"><span class="italic">适用于Microsoft Windows的Oracle数据提供程序开发人员指南</span></a></p>
                        </li>
                     </ul>
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>