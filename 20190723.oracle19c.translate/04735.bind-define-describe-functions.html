<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <meta name="abstract" content="Lists and describes the bind, define, and describe functions."></meta>
      <meta name="description" content="Lists and describes the bind, define, and describe functions."></meta>
      <title>绑定，定义和描述功能</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Programmer&#39;s Guide"></meta>
      <meta property="og:description" content="Lists and describes the bind, define, and describe functions."></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Programmer&#39;s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="oracle-call-interface-programmers-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-14T08:46:00-08:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="1996, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96204-01"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="handle-and-descriptor-functions.html" title="Previous" type="text/html"></link>
      <link rel="next" href="more-database-access-c-api.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Oracle Call Interface Programmer&#39;s Guide"></meta>
    <meta name="dcterms.isVersionOf" content="LNOCI"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="handle-and-descriptor-functions.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="more-database-access-c-api.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">程序员指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="database-access-c-api.html" property="item" typeof="WebPage"><span property="name">Oracle数据库访问C API</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">绑定，定义和描述功能</li>
            </ol>
            <a id="GUID-1A6A21C8-F2EB-4F4C-9F23-DCE7D433C3A0" name="GUID-1A6A21C8-F2EB-4F4C-9F23-DCE7D433C3A0"></a><a id="LNOCI17138"></a><a id="LNOCI153"></a>
            
            <h2 id="LNOCI-GUID-1A6A21C8-F2EB-4F4C-9F23-DCE7D433C3A0" class="sect2"><span class="enumeration_section">25.4</span>绑定，定义和描述函数</h2>
         </header>
         <div class="ind">
            <div>
               <p>列出并描述绑定，定义和描述函数。</p>
               <div class="section">
                  <p><a href="bind-define-describe-functions.html#GUID-1A6A21C8-F2EB-4F4C-9F23-DCE7D433C3A0__CIHJJHGB" title="该表有2列。第1列是OCI函数名称，第2列描述其目的。">表25-4</a>列出了本节中描述的绑定，定义和描述函数。
                  </p>
               </div>
               <!-- class="section" -->
               <div class="tblformalwide" id="GUID-1A6A21C8-F2EB-4F4C-9F23-DCE7D433C3A0__CIHJJHGB">
                  <p class="titleintable">表25-4绑定，定义和描述函数</p>
                  <table cellpadding="4" cellspacing="0" class="FormalWide" title="绑定，定义和描述功能" width="100%" border="1" summary="This table has 2 columns. Column 1 is the OCI function name and column 2 describes its purpose. " frame="hsides" rules="rows">
                     <thead>
                        <tr align="left" valign="top">
                           <th align="left" valign="bottom" width="60%" id="d190805e209">功能</th>
                           <th align="left" valign="bottom" width="40%" id="d190805e212">目的</th>
                        </tr>
                     </thead>
                     <tbody>
                        <tr align="left" valign="top">
                           <td align="left" valign="top" width="60%" id="d190805e217" headers="d190805e209 ">
                              <p><a href="bind-define-describe-functions.html#GUID-E83BF668-88FC-4F31-A950-3580B79588E0" title="设置静态数组绑定的跳过参数。">OCIBindArrayOfStruct（）</a></p>
                           </td>
                           <td align="left" valign="top" width="40%" headers="d190805e217 d190805e212 ">
                              <p>设置静态数组绑定的跳过参数</p>
                           </td>
                        </tr>
                        <tr align="left" valign="top">
                           <td align="left" valign="top" width="60%" id="d190805e229" headers="d190805e209 ">
                              <p><a href="bind-define-describe-functions.html#GUID-CD63DF78-2178-4727-A896-B9673C4A37F0" title="在SQL语句或PL / SQL块中创建程序变量和占位符之间的关联。">OCIBindByName（）</a></p>
                           </td>
                           <td align="left" valign="top" width="40%" headers="d190805e229 d190805e212 ">
                              <p>按名称绑定</p>
                           </td>
                        </tr>
                        <tr align="left" valign="top">
                           <td align="left" valign="top" width="60%" id="d190805e241" headers="d190805e209 ">
                              <p><a href="bind-define-describe-functions.html#GUID-55C47708-5468-4106-89BE-1AB60861D037" title="在SQL语句或PL / SQL块中创建程序变量和占位符之间的关联。当客户端上的实际长度超过UB2MAXVAL时，在处理数据类型时使用此函数。">OCIBindByName2（）</a></p>
                           </td>
                           <td align="left" valign="top" width="40%" headers="d190805e241 d190805e212 ">
                              <p>按名称绑定。在客户端上返回长度超过<code class="codeph">UB2MAXVAL</code>时使用。
                              </p>
                           </td>
                        </tr>
                        <tr align="left" valign="top">
                           <td align="left" valign="top" width="60%" id="d190805e259" headers="d190805e209 ">
                              <p><a href="bind-define-describe-functions.html#GUID-D28DF5A7-3C75-4E52-82F7-A5D6D5714E69" title="在SQL语句或PL / SQL块中创建程序变量和占位符之间的关联。">OCIBindByPos（）</a></p>
                           </td>
                           <td align="left" valign="top" width="40%" headers="d190805e259 d190805e212 ">
                              <p>按位置绑定</p>
                           </td>
                        </tr>
                        <tr align="left" valign="top">
                           <td align="left" valign="top" width="60%" id="d190805e271" headers="d190805e209 ">
                              <p><a href="bind-define-describe-functions.html#GUID-5C505821-323D-473D-825B-448C8D9A6702" title="在SQL语句或PL / SQL块中创建程序变量和占位符之间的关联。当客户端上的实际长度超过UB2MAXVAL时，在处理数据类型时使用此调用。">OCIBindByPos2（）</a></p>
                           </td>
                           <td align="left" valign="top" width="40%" headers="d190805e271 d190805e212 ">
                              <p>按位置绑定。在客户端上返回长度超过<code class="codeph">UB2MAXVAL</code>时使用。
                              </p>
                           </td>
                        </tr>
                        <tr align="left" valign="top">
                           <td align="left" valign="top" width="60%" id="d190805e289" headers="d190805e209 ">
                              <p><a href="bind-define-describe-functions.html#GUID-030270CB-346A-412E-B3B3-556DD6947BE2" title="注册用户回调以进行动态数据分配。">OCIBindDynamic（）</a></p>
                           </td>
                           <td align="left" valign="top" width="40%" headers="d190805e289 d190805e212 ">
                              <p>使用<code class="codeph">OCI_DATA_AT_EXEC</code>模式绑定后设置其他属性</p>
                           </td>
                        </tr>
                        <tr align="left" valign="top">
                           <td align="left" valign="top" width="60%" id="d190805e304" headers="d190805e209 ">
                              <p><a href="bind-define-describe-functions.html#GUID-384B5D31-165B-4661-A334-8C2B5E475AEF" title="设置命名数据类型（对象）绑定所需的其他属性。">OCIBindObject（）</a></p>
                           </td>
                           <td align="left" valign="top" width="40%" headers="d190805e304 d190805e212 ">
                              <p>为命名数据类型的绑定设置其他属性</p>
                           </td>
                        </tr>
                        <tr align="left" valign="top">
                           <td align="left" valign="top" width="60%" id="d190805e316" headers="d190805e209 ">
                              <p><a href="bind-define-describe-functions.html#GUID-D3F74828-5DA7-48AD-A170-120AD547DEB3" title="指定静态数组定义所需的其他属性，用于结构数组（多行，多列）提取。">OCIDefineArrayOfStruct（）</a></p>
                           </td>
                           <td align="left" valign="top" width="40%" headers="d190805e316 d190805e212 ">
                              <p>为静态数组定义设置其他属性</p>
                           </td>
                        </tr>
                        <tr align="left" valign="top">
                           <td align="left" valign="top" width="60%" id="d190805e328" headers="d190805e209 ">
                              <p><a href="bind-define-describe-functions.html#GUID-CFE5AA54-DEBC-42D3-8A27-AFF1E7815691" title="将选择列表中的项与类型和输出数据缓冲区相关联。">OCIDefineByPos（）</a></p>
                           </td>
                           <td align="left" valign="top" width="40%" headers="d190805e328 d190805e212 ">
                              <p>定义输出变量关联</p>
                           </td>
                        </tr>
                        <tr align="left" valign="top">
                           <td align="left" valign="top" width="60%" id="d190805e340" headers="d190805e209 ">
                              <p><a href="bind-define-describe-functions.html#GUID-74939FB5-919E-4D24-B327-AFB532435061" title="将选择列表中的项与类型和输出数据缓冲区相关联。当客户端上的实际长度超过UB2MAXVAL时，在处理数据类型时使用此调用。">OCIDefineByPos2（）</a></p>
                           </td>
                           <td align="left" valign="top" width="40%" headers="d190805e340 d190805e212 ">
                              <p>定义输出变量关联。在客户端上返回长度超过<code class="codeph">UB2MAXVAL</code>时使用。
                              </p>
                           </td>
                        </tr>
                        <tr align="left" valign="top">
                           <td align="left" valign="top" width="60%" id="d190805e358" headers="d190805e209 ">
                              <p><a href="bind-define-describe-functions.html#GUID-DD404526-9615-4E44-B790-1D17396C82A9" title="如果在OCIDefineByPos（）或OCIDefineByPos2（）中选择了OCI_DYNAMIC_FETCH模式，则设置所需的其他属性。">OCIDefineDynamic（）</a></p>
                           </td>
                           <td align="left" valign="top" width="40%" headers="d190805e358 d190805e212 ">
                              <p>在<code class="codeph">OCI_DYNAMIC_FETCH</code>模式下为define定义其他属性</p>
                           </td>
                        </tr>
                        <tr align="left" valign="top">
                           <td align="left" valign="top" width="60%" id="d190805e383" headers="d190805e209 ">
                              <p><a href="bind-define-describe-functions.html#GUID-F211198D-C88C-493B-A65E-2C2A95E6197B" title="设置命名数据类型或REF定义所需的其他属性。">OCIDefineObject（）</a></p>
                           </td>
                           <td align="left" valign="top" width="40%" headers="d190805e383 d190805e212 ">
                              <p>为命名数据类型的定义设置其他属性</p>
                           </td>
                        </tr>
                        <tr align="left" valign="top">
                           <td align="left" valign="top" width="60%" id="d190805e398" headers="d190805e209 ">
                              <p><a href="bind-define-describe-functions.html#GUID-AE9F73FB-DCC1-401E-8151-A8A89059163A" title="描述现有的模式和子模式对象。">OCIDescribeAny（）</a></p>
                           </td>
                           <td align="left" valign="top" width="40%" headers="d190805e398 d190805e212 ">
                              <p>描述现有的架构对象</p>
                           </td>
                        </tr>
                        <tr align="left" valign="top">
                           <td align="left" valign="top" width="60%" id="d190805e410" headers="d190805e209 ">
                              <p><a href="bind-define-describe-functions.html#GUID-87D50C09-F18D-45BB-A8AF-1E6AFEC6FE2E" title="获取绑定和指示符变量名称。">OCIStmtGetBindInfo（）</a></p>
                           </td>
                           <td align="left" valign="top" width="40%" headers="d190805e410 d190805e212 ">
                              <p>获取绑定和指示符变量名称和句柄</p>
                           </td>
                        </tr>
                     </tbody>
                  </table>
               </div>
               <!-- class="inftblhruleinformal" -->
            </div><a id="LNOCI17139"></a><div class="props_rev_3"><a id="GUID-E83BF668-88FC-4F31-A950-3580B79588E0" name="GUID-E83BF668-88FC-4F31-A950-3580B79588E0"></a><h3 id="LNOCI-GUID-E83BF668-88FC-4F31-A950-3580B79588E0" class="sect3"><span class="enumeration_section">25.4.1</span> OCIBindArrayOfStruct（）</h3>
               <div>
                  <p>设置静态数组绑定的跳过参数。</p>
                  <div class="section">
                     <p class="subhead2" id="GUID-E83BF668-88FC-4F31-A950-3580B79588E0__GUID-7B6E6F64-57B7-4CF7-9820-E103CB67BD74">目的</p>
                     <p>设置静态数组绑定的跳过参数。</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-E83BF668-88FC-4F31-A950-3580B79588E0__GUID-F25AC113-79A2-4362-B480-AA938AB36971">句法</p><pre class="oac_no_warn" dir="ltr">剑OCIBindArrayOfStruct（OCIBind * bindp，OCIError * errhp，ub4 pvskip，ub4 indskip，ub4 alskip，ub4 rcskip）;</pre></div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-E83BF668-88FC-4F31-A950-3580B79588E0__GUID-9D63B646-683F-4394-A283-897ABCEBA661">参数</p>
                     <dl>
                        <dt class="dlterm"><a name="GUID-E83BF668-88FC-4F31-A950-3580B79588E0__GUID-EE87E4F3-C7DF-4121-8777-409A23A9A083"><!-- --></a> <span class="bold">bindp</span> （IN / OUT）</dt>
                        <dd>
                           <p>绑定结构的句柄。</p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-E83BF668-88FC-4F31-A950-3580B79588E0__GUID-2646397B-849F-466A-A67D-29D26DEE3FD7"><!-- --></a> <span class="bold">errhp</span> （IN / OUT）</dt>
                        <dd>
                           <p>一个错误句柄，您可以在出现错误时传递给<code class="codeph">OCIErrorGet()</code>以获取诊断信息。
                           </p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-E83BF668-88FC-4F31-A950-3580B79588E0__GUID-775AF870-1C0E-4E42-9024-9B3581738773"><!-- --></a> <span class="bold">pvskip</span> （IN）</dt>
                        <dd>
                           <p>跳过下一个数据值的参数。</p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-E83BF668-88FC-4F31-A950-3580B79588E0__GUID-2203C9D9-E08C-4965-847A-AE95E7C9E142"><!-- --></a> <span class="bold">indskip</span> （IN）</dt>
                        <dd>
                           <p>跳过下一个指标值或结构的参数。</p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-E83BF668-88FC-4F31-A950-3580B79588E0__GUID-9709B1C2-3550-4908-8AAA-C6EE3F8202B1"><!-- --></a> <span class="bold">alskip</span> （IN）</dt>
                        <dd>
                           <p>跳过下一个实际长度值的参数。</p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-E83BF668-88FC-4F31-A950-3580B79588E0__GUID-BD3A9968-74B5-4061-9062-D1F305163466"><!-- --></a> <span class="bold">rcskip</span> （IN）</dt>
                        <dd>
                           <p>跳过下一个列级返回码值的参数。</p>
                        </dd>
                     </dl>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-E83BF668-88FC-4F31-A950-3580B79588E0__GUID-B89555F3-4C16-4B5A-9897-33F46F6CA034">评论</p>
                     <p>此调用设置静态数组绑定所需的跳过参数。它跟随对<code class="codeph">OCIBindByName()</code>或<code class="codeph">OCIBindByPos()</code>的调用。该初始绑定调用返回的绑定句柄用作<code class="codeph">OCIBindArrayOfStruct()</code>调用的参数。
                     </p>
                  </div>
                  <!-- class="section" -->
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="bind-define-describe-functions.html#GUID-CD63DF78-2178-4727-A896-B9673C4A37F0" title="在SQL语句或PL / SQL块中创建程序变量和占位符之间的关联。">OCIBindByName（）</a></li>
                        <li><a href="bind-define-describe-functions.html#GUID-55C47708-5468-4106-89BE-1AB60861D037" title="在SQL语句或PL / SQL块中创建程序变量和占位符之间的关联。当客户端上的实际长度超过UB2MAXVAL时，在处理数据类型时使用此函数。">OCIBindByName2（）</a></li>
                        <li><a href="bind-define-describe-functions.html#GUID-D28DF5A7-3C75-4E52-82F7-A5D6D5714E69" title="在SQL语句或PL / SQL块中创建程序变量和占位符之间的关联。">OCIBindByPos（）</a></li>
                        <li><a href="bind-define-describe-functions.html#GUID-5C505821-323D-473D-825B-448C8D9A6702" title="在SQL语句或PL / SQL块中创建程序变量和占位符之间的关联。当客户端上的实际长度超过UB2MAXVAL时，在处理数据类型时使用此调用。">OCIBindByPos2（）</a></li>
                     </ul>
                  </div>
                  <div class="infoboxnotealso" id="GUID-E83BF668-88FC-4F31-A950-3580B79588E0__GUID-E3222A47-F696-4141-889E-905E4CB5E19C">
                     <p class="notep1">也可以看看：</p>
                     <p><a href="binding-and-defining-in-oci.html#GUID-094F4767-1BE0-45AE-BA6C-3B114714F87A" title="定义结构数组需要初始调用OCIDefineByPos（）或OCIDefineByPos2（）。">关于在OCI中绑定和定义结构数组</a>以获取有关跳过参数的信息</p>
                  </div>
               </div>
               
            </div><a id="LNOCI17140"></a><div class="props_rev_3"><a id="GUID-CD63DF78-2178-4727-A896-B9673C4A37F0" name="GUID-CD63DF78-2178-4727-A896-B9673C4A37F0"></a><h3 id="LNOCI-GUID-CD63DF78-2178-4727-A896-B9673C4A37F0" class="sect3"><span class="enumeration_section">25.4.2</span> OCIBindByName（）</h3>
               <div>
                  <p>在SQL语句或PL / SQL块中创建程序变量和占位符之间的关联。</p>
                  <div class="section">
                     <p class="subhead2" id="GUID-CD63DF78-2178-4727-A896-B9673C4A37F0__GUID-5D1C6994-C6B9-446F-8BD8-04693A083A4E">目的</p>
                     <p>在SQL语句或PL / SQL块中创建程序变量和占位符之间的关联。</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-CD63DF78-2178-4727-A896-B9673C4A37F0__GUID-2588DDD0-865C-43E2-8C53-7489A276FCE9">句法</p><pre class="oac_no_warn" dir="ltr">剑OCIBindByName（OCIStmt * stmtp，OCIBind ** bindpp，OCIError * errhp，const OraText *占位符，sb4 placeh_len，void * valuep，sb4 value_sz，ub2 dty，void * indp，ub2 * alenp，ub2 * rcodep，ub4 maxarr_len，ub4 * curelep，ub4模式）;</pre></div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-CD63DF78-2178-4727-A896-B9673C4A37F0__GUID-55E1BB5A-427A-4DBF-BEA1-7774D9883375">参数</p>
                     <dl>
                        <dt class="dlterm"><a name="GUID-CD63DF78-2178-4727-A896-B9673C4A37F0__GUID-297ABB53-9B8F-40FB-AEAB-0E4D2B008A0A"><!-- --></a> stmtp（IN / OUT）</dt>
                        <dd>
                           <p>正在处理的SQL或PL / SQL语句的语句句柄。</p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-CD63DF78-2178-4727-A896-B9673C4A37F0__GUID-4C7EA8AC-5A6D-45E2-A2E5-D1B54A24AB11"><!-- --></a> bindpp（IN / OUT）</dt>
                        <dd>
                           <p>一个指针，用于保存由此调用隐式分配的绑定句柄的指针。绑定句柄维护此特定输入值的所有绑定信息。除非<code class="codeph">mode</code>参数具有不同的值，否则调用的默认编码取决于<code class="codeph">stmtp</code>的<code class="codeph">UTF-16</code>设置。取消分配语句句柄时，将隐式释放句柄。在输入时，指针的值必须为<code class="codeph">NULL</code>或有效的绑定句柄。
                           </p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-CD63DF78-2178-4727-A896-B9673C4A37F0__GUID-60E6773F-D59E-4BB4-9899-9C14B21D7FB5"><!-- --></a> errhp（输入/输出）</dt>
                        <dd>
                           <p>一个错误句柄，您可以在出现错误时传递给<code class="codeph">OCIErrorGet()</code>以获取诊断信息。
                           </p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-CD63DF78-2178-4727-A896-B9673C4A37F0__GUID-1B4B40C5-9593-4DF6-82B2-962D3A999EA3"><!-- --></a>占位符（IN）</dt>
                        <dd>
                           <p>由其名称指定的占位符，它映射到与语句句柄关联的语句中的变量。<code class="codeph">placeholder</code>的编码应始终与环境的编码一致。也就是说，如果语句是以<code class="codeph">UTF-16</code>编写的，那么占位符也是如此。作为字符串类型参数，占位符应转换为<code class="codeph">(text *)</code>并以<code class="codeph">NULL</code>结尾。</p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-CD63DF78-2178-4727-A896-B9673C4A37F0__GUID-DF7655EE-CCA2-4364-8647-A9EA2A141EC1"><!-- --></a> placeh_len（IN）</dt>
                        <dd>
                           <p><code class="codeph">placeholder</code>中指定的名称长度，以字节数表示，与编码无关。
                           </p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-CD63DF78-2178-4727-A896-B9673C4A37F0__GUID-352A2A86-18C5-44A9-8DCF-C3D8C25FC893"><!-- --></a> valuep（IN / OUT）</dt>
                        <dd>
                           <p>指向<code class="codeph">dty</code>参数中指定的数据值或数据值数组的指针。如果已调用<code class="codeph">OCIAttrSet()</code>函数将<code class="codeph">OCI_ATTR_CHARSET_ID</code>设置为<code class="codeph">OCI_UTF16ID</code>或不推荐使用的<code class="codeph">OCI_UCS2ID</code> ，则此数据可以是<code class="codeph">UTF-16</code> （以前称为UCS-2）字符串。 <code class="codeph">OCI_UTF16ID</code>是新命名<code class="codeph">OCI_UCS2ID</code> 。</p>
                           <p>此外，正如<code class="codeph">OCIStmtPrepare2()</code>所指出的，字符串类型<code class="codeph">valuep</code>的默认编码是前一次调用<code class="codeph">OCIEnvNlsCreate()</code>的<code class="codeph">charset</code>参数指定的编码，除非您调用<code class="codeph">OCIAttrSet()</code>手动重置字符集。绑定句柄。
                           </p>
                           <div class="infoboxnotealso" id="GUID-CD63DF78-2178-4727-A896-B9673C4A37F0__GUID-2F248D94-7F54-4C7A-91F1-81C56C82C303">
                              <p class="notep1">也可以看看：</p>
                              <p><a href="handle-and-descriptor-attributes.html#GUID-01C53C14-CD15-4A8B-9EFF-86996282F3BD" title="列出并描述绑定句柄属性。">绑定句柄属性</a></p>
                           </div>
                        </dd>
                     </dl>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p>可以指定数据值数组以映射到PL / SQL表或为SQL多行操作提供数据。当提供绑定值数组时，这称为OCI术语中的数组绑定。</p>
                     <p>对于<code class="codeph">SQLT_NTY</code>或<code class="codeph">SQLT_REF</code>绑定，将忽略<code class="codeph">valuep</code>参数。指向OUT缓冲区的指针在由<code class="codeph">OCIBindObject()</code>初始化的<code class="codeph">pgvpp</code>参数中设置。
                     </p>
                     <p>当<code class="codeph">mode</code>设置为<code class="codeph">OCI_IOV</code> ，传递<code class="codeph">OCIIOV</code>结构的基址。
                     </p>
                     <dl>
                        <dt class="dlterm"><a name="GUID-CD63DF78-2178-4727-A896-B9673C4A37F0__GUID-58986A05-48DC-4663-B751-0B1D6A1A5B92"><!-- --></a> value_sz（IN）</dt>
                        <dd>
                           <p>此绑定变量的任何数据值（使用<code class="codeph">valuep</code>传递）的最大大小（以字节为<code class="codeph">valuep</code> ）。此大小始终预计为以字节为单位的大小。在数组绑定的情况下，这是在<code class="codeph">alenp</code>参数中指定实际大小时可能的任何元素的最大大小。
                           </p>
                           <p>对于客户端应用程序未知其大小的描述符，定位符或REF，请使用指向特定类型的指针的大小;例如， <code class="codeph">sizeof</code> （ <code class="codeph">OCILobLocator *</code> ）。
                           </p>
                           <p>即使模式为<code class="codeph">OCI_IOV</code>也是<code class="codeph">OCI_IOV</code> 。</p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-CD63DF78-2178-4727-A896-B9673C4A37F0__GUID-065E847F-0306-442C-A373-3DCA34DD2178"><!-- --></a> dty（IN）</dt>
                        <dd>
                           <p>绑定值的数据类型。仅当应用程序已在对象模式下初始化时，命名数据类型（ <code class="codeph">SQLT_NTY</code> ）和<code class="codeph">REF</code> （ <code class="codeph">SQLT_REF</code> ）才有效。对于命名数据类型或<code class="codeph">REF</code> ，必须使用绑定句柄进行其他调用以设置特定于数据类型的属性。有关记录，集合和布尔值的信息，请参阅注释。对于命名数据类型<code class="codeph">SQLT_CHR</code> ，当实际长度为0时， <code class="codeph">OCIBindByName()</code>修剪尾随空白。指定实际长度以防止修剪尾随空白。
                           </p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-CD63DF78-2178-4727-A896-B9673C4A37F0__GUID-CD860290-1671-4BC7-AD96-E21250AAD1EE"><!-- --></a> indp（IN / OUT）</dt>
                        <dd>
                           <p>指向变量或数组的指针。对于除<code class="codeph">SQLT_NTY</code>之外的所有数据类型，这是指向<code class="codeph">sb2</code>或<code class="codeph">sb2</code>数组的指针。
                           </p>
                           <p>对于<code class="codeph">SQLT_NTY</code> ，忽略此指针，并在随后对<code class="codeph">OCIBindObject()</code>调用中初始化指向结构或指示器结构数组的实际指针。动态绑定将忽略此参数。
                           </p>
                           <div class="infoboxnotealso" id="GUID-CD63DF78-2178-4727-A896-B9673C4A37F0__GUID-30627252-A322-4B7D-BCB4-8E350BA3A24C">
                              <p class="notep1">也可以看看：</p>
                              <p><a href="oci-programming-basics.html#GUID-9966EDF7-37ED-42E5-AE57-67E394245BFA" title="每个绑定和定义OCI调用都有一个参数，它将指示符变量或指示符变量数组与DML语句，PL / SQL语句或查询相关联。">指标变量</a></p>
                           </div>
                        </dd>
                     </dl>
                     <dl>
                        <dt class="dlterm"><a name="GUID-CD63DF78-2178-4727-A896-B9673C4A37F0__GUID-4EA2144A-893D-4B5B-9CC4-5328ACBFC64F"><!-- --></a> alenp（IN / OUT）</dt>
                        <dd>
                           <p>指向数组元素实际长度数组的指针。</p>
                           <p>当使用<code class="codeph">OCIEnvNlsCreate()</code> （推荐的OCI环境句柄创建接口）时， <code class="codeph">alenp</code>长度始终以字节为单位（对于IN绑定）并以字节为单位报告为OUT绑定。对于<code class="codeph">SQLT_VCS</code> （2字节长度前缀）和<code class="codeph">SQLT_LVC</code> （4字节长度前缀）类型中的长度前缀，同样的处理也一致。UCS2或NCHAR案例没有特殊例外。
                           </p>
                           <p>当较旧的OCI环境句柄创建界面被使用（或者<code class="codeph">OCIEnvCreate()</code>或弃用<code class="codeph">OCIEnvInit()</code> <code class="codeph">alenp</code>长度在一般字节。但是，对于IN绑定的字符，预期<code class="codeph">alenp</code>长度，并且仅当字符集为OCI_UC2ID（= OCI_UTF16ID）或在相应的OCIBind句柄上设置<code class="codeph">OCI_ATTR_CHAR_COUNT</code>属性时， <code class="codeph">OCI_ATTR_CHAR_COUNT</code>以OUT绑定的字符报告。对于<code class="codeph">SQLT_VCS</code> （2字节长度前缀）和<code class="codeph">SQLT_LVC</code> （4字节长度前缀）类型中的长度前缀，同样的处理方式也适用。
                           </p>
                           <p>动态绑定将忽略此参数。</p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-CD63DF78-2178-4727-A896-B9673C4A37F0__GUID-EEA37A55-A547-4C9C-BC10-49EB392529D0"><!-- --></a> rcodep（OUT）</dt>
                        <dd>
                           <p>指向列级返回码数组的指针。动态绑定将忽略此参数。</p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-CD63DF78-2178-4727-A896-B9673C4A37F0__GUID-4AD62BAF-5055-481E-A657-A7950D534886"><!-- --></a> maxarr_len（IN）</dt>
                        <dd>
                           <p>最大数组长度参数（用户数组可容纳的最大元素数）。仅用于PL / SQL索引表绑定。</p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-CD63DF78-2178-4727-A896-B9673C4A37F0__GUID-B67547CF-CAA5-40F5-B747-65C33F191DFB"><!-- --></a> curelep（IN / OUT）</dt>
                        <dd>
                           <p>当前数组长度参数（指向执行操作之前或之后数组中元素的实际数量的指针）。仅用于PL / SQL索引表绑定。</p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-CD63DF78-2178-4727-A896-B9673C4A37F0__GUID-0F6B6679-B211-442B-A469-EC4D5F280CB4"><!-- --></a>模式（IN）</dt>
                        <dd>
                           <p>为了保持编码一致性，理论上该参数可以采用<code class="codeph">OCIStmtPrepare2()</code>使用的所有三个可能值。由于绑定变量的编码应始终与包含此变量的语句的编码相同，因此如果指定的编码不是语句的编码，则会引发错误。因此， <code class="codeph">mode</code>的建议设置是<code class="codeph">OCI_DEFAULT</code> ，这使得绑定变量具有与其语句相同的编码。
                           </p>
                           <p>有效模式是：</p>
                        </dd>
                     </dl>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">OCI_DEFAULT</code> - 默认模式。语句处理<code class="codeph">stmtp</code>使用其父环境句柄指定的任何内容。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">OCI_BIND_SOFT</code> - 软绑定模式。此模式可提高呼叫的性能。如果这是第一个绑定或某个输入值（如<code class="codeph">dty</code>或<code class="codeph">value_sz</code> ）从先前绑定更改，则忽略此模式。如果未执行该语句，则返回错误。如果传递的绑定句柄无效，则会导致意外的行为。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">OCI_DATA_AT_EXEC</code> - 选择此模式时， <code class="codeph">value_sz</code>参数定义可在运行时提供的数据的最大大小。应用程序必须随时可以随时和任意次数提供OCI库运行时IN数据缓冲区。运行时数据以下列两种方式之一提供：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>使用用户定义函数的回调，必须在后续调用<code class="codeph">OCIBindDynamic()</code> 。
                                 </p>
                              </li>
                              <li>
                                 <p>使用OCI提供的调用的轮询机制。如果未定义回调，则假定使用此模式。</p>
                                 <div class="infoboxnotealso" id="GUID-CD63DF78-2178-4727-A896-B9673C4A37F0__GUID-0A4C148E-AD65-4E39-978B-0CF6F19CEB06">
                                    <p class="notep1">也可以看看：</p>
                                    <p>有关使用<code class="codeph">OCI_DATA_AT_EXEC</code>模式的更多信息，请<code class="codeph">OCI_DATA_AT_EXEC</code> <a href="binding-and-defining-in-oci.html#GUID-6C5EA0C6-0C1D-4CD5-B47F-1B95B4E9C558" title="您可以使用OCI执行分段插入，更新和数据提取。">OCI中的运行时数据分配和分段操作</a></p>
                                 </div>
                              </li>
                           </ul>
                           <p>当<code class="codeph">mode</code>设置为<code class="codeph">OCI_DATA_AT_EXEC</code> ，不要在main调用中为<code class="codeph">valuep</code> ， <code class="codeph">indp</code> ， <code class="codeph">alenp</code>和<code class="codeph">rcodep</code>提供值。为<code class="codeph">indp</code>和<code class="codeph">alenp</code>传递零（0）。通过使用<code class="codeph">OCIBindDynamic()</code>注册的回调函数提供值。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">OCI_IOV</code> - 绑定不连续的数据地址。<code class="codeph">valuep</code>参数必须是<code class="codeph">OCIIOV *</code>类型。此模式旨在用于分散或聚集绑定，这允许将多个缓冲区绑定或定义到某个位置，例如，一个缓冲区中前10行的列A，一个缓冲区中的后5行，其余25个另一个缓冲区中的行。这样就无需在执行数组执行操作时将所有这些分配并复制到一个大缓冲区中。
                           </p>
                           <div class="infoboxnotealso" id="GUID-CD63DF78-2178-4727-A896-B9673C4A37F0__GUID-42DE3A43-5572-44CA-8DF0-D637E87F4DC4">
                              <p class="notep1">也可以看看：</p>
                              <p><a href="binding-and-defining-in-oci.html#GUID-CC67A87C-A39A-400A-BF95-C32363DCD589" title="您可以指定多个缓冲区以用于单个绑定或定义调用。">关于绑定和定义多个缓冲区</a></p>
                           </div>
                        </li>
                     </ul>
                     <p>当不再需要分配的缓冲区时，它们应该被客户端释放。</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-CD63DF78-2178-4727-A896-B9673C4A37F0__GUID-E335207E-E675-4BB2-A1CB-22DFBFDBFEE8">评论</p>
                     <p>此调用用于执行基本绑定操作。bind在程序变量的地址和SQL语句或PL / SQL块中的占位符之间创建关联。bind调用还指定了绑定的数据类型，还可以指示在运行时提供数据的方法。</p>
                     <p>编码由绑定句柄确定，使用语句句柄中的设置作为默认值，或者您可以通过显式指定<code class="codeph">mode</code>参数来覆盖设置。
                     </p>
                     <p><code class="codeph">OCIBindByName()</code>和<code class="codeph">OCIBimdByName2()</code>也隐式分配<code class="codeph">bindpp</code>参数指示的绑定句柄。如果在<code class="codeph">**bindpp</code>传递非<code class="codeph">NULL</code>指针，则OCI假定这指向先前已通过调用<code class="codeph">OCIHandleAlloc()</code>或<code class="codeph">OCIBindByName()</code>分配的有效句柄。
                     </p>
                     <p>OCI应用程序中的数据可以静态或动态地绑定到占位符。当所有IN绑定数据和OUT绑定缓冲区在执行操作之前很好地定义时，绑定是<span class="italic">静态的</span> 。当IN绑定数据和OUT绑定缓冲区由应用程序在执行时按需提供给客户端库时，绑定是<span class="italic">动态的</span> 。通过将此调用的<code class="codeph">mode</code>参数设置为<code class="codeph">OCI_DATA_AT_EXEC</code>来指示动态绑定。</p>
                     <div class="infoboxnotealso" id="GUID-CD63DF78-2178-4727-A896-B9673C4A37F0__GUID-FE8B2DB4-81C6-4674-B139-28CF1793965E">
                        <p class="notep1">也可以看看：</p>
                        <p>有关动态绑定的更多信息，请参阅<a href="binding-and-defining-in-oci.html#GUID-6C5EA0C6-0C1D-4CD5-B47F-1B95B4E9C558" title="您可以使用OCI执行分段插入，更新和数据提取。">OCI中的运行时数据分配和分段操作</a></p>
                     </div>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p><code class="codeph">OCIBindByName()</code>和<code class="codeph">OCIBindByName2()</code>以及<code class="codeph">OCIBindByPos()</code>和<code class="codeph">OCIBindByPos2()</code>将绑定句柄作为参数，绑定句柄由绑定调用隐式分配。为应用程序绑定的每个占位符分配单独的绑定句柄。
                     </p>
                     <p>可能需要额外的绑定调用来指定绑定某些数据类型或以某些方式处理输入数据时所需的特定属性：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>如果正在使用结构数组，则必须调用<code class="codeph">OCIBindArrayOfStruct()</code>来设置必要的跳过参数。
                           </p>
                        </li>
                        <li>
                           <p>如果在运行时动态提供数据，并且应用程序使用用户定义的回调函数， <code class="codeph">OCIBindDynamic()</code>必须调用<code class="codeph">OCIBindDynamic()</code>来注册回调。
                           </p>
                        </li>
                        <li>
                           <p>如果<code class="codeph">alenp</code>长度大于64 Kilobytes（KB），则使用<code class="codeph">OCIBindDynamic()</code> 。
                           </p>
                        </li>
                        <li>
                           <p>如果绑定了命名数据类型，则必须调用<code class="codeph">OCIBindObject()</code>以指定其他必要信息。
                           </p>
                        </li>
                        <li>
                           <p>如果用一个声明<code class="codeph">RETURNING</code>使用条款，将呼叫<code class="codeph">OCIBindDynamic()</code>必须遵循这一呼吁。
                           </p>
                        </li>
                     </ul>
                     <p>使用IN绑定时，必须在调用<code class="codeph">OCIStmtExecute()</code>之前设置数组的每个元素的值，每个元素的实际长度以及实际的数组长度。
                     </p>
                     <p>使用OUT绑定时，在<code class="codeph">OCIStmtExecute()</code>调用之后， <code class="codeph">OCIStmtExecute()</code>服务器返回数组的每个元素的值，每个元素的实际长度以及实际的数组长度。
                     </p>
                     <dl>
                        <dt class="dlterm"><a name="GUID-CD63DF78-2178-4727-A896-B9673C4A37F0__GUID-FE73BC59-C3F0-4E08-BAE8-811C51F6758D"><!-- --></a>用于记录</dt>
                        <dd>
                           <p>客户端必须使用<code class="codeph">SQLT_NTY</code>绑定包记录类型作为绑定的DTY。在OCI客户端中，对象和记录表示为命名类型（NTY），并且必须使用相同的<code class="codeph">SQLT</code>代码。
                           </p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-CD63DF78-2178-4727-A896-B9673C4A37F0__GUID-521E2449-A797-43D1-8FE4-8074C851E118"><!-- --></a>收藏</dt>
                        <dd>
                           <p>客户端必须使用<code class="codeph">SQLT_NTY</code>绑定所有包集合类型。这是用于绑定所有模式级别集合类型的DTY。
                           </p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-CD63DF78-2178-4727-A896-B9673C4A37F0__GUID-D6EC072A-9F98-427A-B16E-FC0A081E74AF"><!-- --></a>对布尔人来说</dt>
                        <dd>
                           <p>客户端必须使用<code class="codeph">SQLT_BOL</code>绑定布尔类型（ <code class="codeph">OCI_TYPECODE_BOOLEAN</code> ）。</p>
                        </dd>
                     </dl>
                  </div>
                  <!-- class="section" -->
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="bind-define-describe-functions.html#GUID-030270CB-346A-412E-B3B3-556DD6947BE2" title="注册用户回调以进行动态数据分配。">OCIBindDynamic（）</a></li>
                        <li><a href="bind-define-describe-functions.html#GUID-384B5D31-165B-4661-A334-8C2B5E475AEF" title="设置命名数据类型（对象）绑定所需的其他属性。">OCIBindObject（）</a></li>
                        <li><a href="bind-define-describe-functions.html#GUID-E83BF668-88FC-4F31-A950-3580B79588E0" title="设置静态数组绑定的跳过参数。">OCIBindArrayOfStruct（）</a></li>
                        <li><a href="handle-and-descriptor-functions.html#GUID-3741D7BD-7652-4D7A-8813-AC2AEA8D3B03" title="设置句柄或描述符的属性值。">OCIAttrSet（）</a></li>
                        <li><a href="statement-functions.html#GUID-E6C1DC67-D464-4D2A-9F19-737423D31779" title="准备SQL或PL / SQL语句以便执行。">OCIStmtPrepare2（）</a></li>
                        <li><a href="connect-authorize-and-initialize-functions.html#GUID-16BDA1F1-7DAF-41CA-9EE1-C9A4CB467244" title="创建并初始化OCI函数的环境句柄。">OCIEnvCreate（）</a></li>
                        <li><a href="connect-authorize-and-initialize-functions.html#GUID-0B6911A9-4B46-476C-BC5E-B87581666CD9" title="创建并初始化OCI函数的环境句柄。">OCIEnvNlsCreate（）</a></li>
                        <li><a href="deprecated-oci-functions.html#GUID-1AC89920-7DB1-46AC-BBAA-9854DDAD6AB7" title="在Oracle Database 11g第2版（11.2）之前的版本中不推荐使用此功能。">OCIEnvInit（）</a></li>
                        <li><a href="bind-define-describe-functions.html#GUID-55C47708-5468-4106-89BE-1AB60861D037" title="在SQL语句或PL / SQL块中创建程序变量和占位符之间的关联。当客户端上的实际长度超过UB2MAXVAL时，在处理数据类型时使用此函数。">OCIBindByName2（）</a></li>
                        <li><a href="handle-and-descriptor-functions.html#GUID-C5BF55F7-A110-4CB5-9663-5056590F12B5" title="返回指向已分配和初始化句柄的指针。">OCIHandleAlloc（）</a></li>
                        <li><a href="bind-define-describe-functions.html#GUID-5C505821-323D-473D-825B-448C8D9A6702" title="在SQL语句或PL / SQL块中创建程序变量和占位符之间的关联。当客户端上的实际长度超过UB2MAXVAL时，在处理数据类型时使用此调用。">OCIBindByPos2（）</a></li>
                        <li><a href="statement-functions.html#GUID-98B26708-3E02-45C0-8258-5D5544F32BE9" title="将应用程序请求与服务器关联。">OCIStmtExecute（）</a></li>
                        <li><a href="miscellaneous-functions.html#GUID-4B99087C-74F6-498A-8310-D6645172390A" title="返回错误消息和Oracle数据库错误代码。">OCIErrorGet（）</a></li>
                     </ul>
                  </div>
               </div>
               
            </div><a id="LNOCI72805"></a><div class="props_rev_3"><a id="GUID-55C47708-5468-4106-89BE-1AB60861D037" name="GUID-55C47708-5468-4106-89BE-1AB60861D037"></a><h3 id="LNOCI-GUID-55C47708-5468-4106-89BE-1AB60861D037" class="sect3"><span class="enumeration_section">25.4.3</span> OCIBindByName2（）</h3>
               <div>
                  <p>在SQL语句或PL / SQL块中创建程序变量和占位符之间的关联。当客户端上的实际长度超过<code class="codeph">UB2MAXVAL</code>时，在处理数据类型时使用此函数。
                  </p>
                  <div class="section">
                     <p class="subhead2" id="GUID-55C47708-5468-4106-89BE-1AB60861D037__GUID-9EACB294-18E3-42B1-B32A-6C13BA7A4519">目的</p>
                     <p>在SQL语句或PL / SQL块中创建程序变量和占位符之间的关联。当客户端上的实际长度超过<code class="codeph">UB2MAXVAL</code>时，在处理数据类型时使用此调用而不是<code class="codeph">OCIBindByName()</code> 。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-55C47708-5468-4106-89BE-1AB60861D037__GUID-58387447-F6A7-49F5-B76B-3F42D0223266">句法</p><pre class="oac_no_warn" dir="ltr">剑OCIBindByName2（OCIStmt * stmtp，OCIBind ** bindpp，OCIError * errhp，const OraText *占位符，sb4 placeh_len，void * valuep，sb8 value_sz，ub2 dty，void * indp，ub4 * alenp，ub2 * rcodep，ub4 maxarr_len，ub4 * curelep，ub4模式）;</pre></div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-55C47708-5468-4106-89BE-1AB60861D037__GUID-5D79B3AC-79BD-4124-91F6-CC9C75AE8038">参数</p>
                     <dl>
                        <dt class="dlterm"><a name="GUID-55C47708-5468-4106-89BE-1AB60861D037__GUID-5CF95845-465F-4B7F-8EBD-5B8B9398082C"><!-- --></a> stmtp（IN / OUT）</dt>
                        <dd>
                           <p>正在处理的SQL或PL / SQL语句的语句句柄。</p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-55C47708-5468-4106-89BE-1AB60861D037__GUID-673E590E-CE60-430D-8A62-C0C8A8F43F10"><!-- --></a> bindpp（IN / OUT）</dt>
                        <dd>
                           <p>一个指针，用于保存由此调用隐式分配的绑定句柄的指针。绑定句柄维护此特定输入值的所有绑定信息。除非<code class="codeph">mode</code>参数具有不同的值，否则调用的默认编码取决于<code class="codeph">stmtp</code>的<code class="codeph">UTF-16</code>设置。取消分配语句句柄时，将隐式释放句柄。在输入时，指针的值必须为<code class="codeph">NULL</code>或有效的绑定句柄。
                           </p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-55C47708-5468-4106-89BE-1AB60861D037__GUID-CE35650C-0C34-4AC6-AB0B-962159893E5D"><!-- --></a> errhp（输入/输出）</dt>
                        <dd>
                           <p>一个错误句柄，您可以在出现错误时传递给<code class="codeph">OCIErrorGet()</code>以获取诊断信息。
                           </p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-55C47708-5468-4106-89BE-1AB60861D037__GUID-B0385027-F1AB-491D-AFC5-02C32D3567FB"><!-- --></a>占位符（IN）</dt>
                        <dd>
                           <p>由其名称指定的占位符，它映射到与语句句柄关联的语句中的变量。<code class="codeph">placeholder</code>的编码应始终与环境的编码一致。也就是说，如果语句是以<code class="codeph">UTF-16</code>编写的，那么占位符也是如此。作为字符串类型参数，占位符应转换为<code class="codeph">(text *)</code>并以<code class="codeph">NULL</code>结尾。</p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-55C47708-5468-4106-89BE-1AB60861D037__GUID-603FF8F8-9399-46C6-9D42-19CA3307C34E"><!-- --></a> placeh_len（IN）</dt>
                        <dd>
                           <p><code class="codeph">placeholder</code>中指定的名称长度，以字节数表示，与编码无关。
                           </p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-55C47708-5468-4106-89BE-1AB60861D037__GUID-A9D90D32-D4C0-41D5-A1E0-9F1B4366C720"><!-- --></a> valuep（IN / OUT）</dt>
                        <dd>
                           <p>指向<code class="codeph">dty</code>参数中指定的数据值或数据值数组的指针。如果已调用<code class="codeph">OCIAttrSet()</code>函数将<code class="codeph">OCI_ATTR_CHARSET_ID</code>设置为<code class="codeph">OCI_UTF16ID</code>或不推荐使用的<code class="codeph">OCI_UCS2ID</code> ，则此数据可以是<code class="codeph">UTF-16</code> （以前称为UCS-2）字符串。 <code class="codeph">OCI_UTF16ID</code>是新命名<code class="codeph">OCI_UCS2ID</code> 。</p>
                           <p>此外，正如<code class="codeph">OCIStmtPrepare2()</code>所指出的，字符串类型<code class="codeph">valuep</code>的默认编码是前一次调用<code class="codeph">OCIEnvNlsCreate()</code>的<code class="codeph">charset</code>参数指定的编码，除非您调用<code class="codeph">OCIAttrSet()</code>手动重置字符集。绑定句柄。
                           </p>
                           <div class="infoboxnotealso" id="GUID-55C47708-5468-4106-89BE-1AB60861D037__GUID-FDA5EBA2-9F14-4E93-AAFE-2F9C655A7BDD">
                              <p class="notep1">也可以看看：</p>
                              <p><a href="handle-and-descriptor-attributes.html#GUID-01C53C14-CD15-4A8B-9EFF-86996282F3BD" title="列出并描述绑定句柄属性。">绑定句柄属性</a></p>
                           </div>
                        </dd>
                     </dl>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p>可以指定数据值数组以映射到PL / SQL表或为SQL多行操作提供数据。当提供绑定值数组时，这称为OCI术语中的数组绑定。</p>
                     <p>对于<code class="codeph">SQLT_NTY</code>或<code class="codeph">SQLT_REF</code>绑定，将忽略<code class="codeph">valuep</code>参数。指向OUT缓冲区的指针在由<code class="codeph">OCIBindObject()</code>初始化的<code class="codeph">pgvpp</code>参数中设置。
                     </p>
                     <p>当<code class="codeph">mode</code>设置为<code class="codeph">OCI_IOV</code> ，传递<code class="codeph">OCIIOV</code>结构的基址。
                     </p>
                     <dl>
                        <dt class="dlterm"><a name="GUID-55C47708-5468-4106-89BE-1AB60861D037__GUID-E45B7E6D-917B-4E0C-8DFA-84C05ADF7A6D"><!-- --></a> value_sz（IN）</dt>
                        <dd>
                           <p>此绑定变量的任何数据值（使用<code class="codeph">valuep</code>传递）的最大大小（以字节为<code class="codeph">valuep</code> ）。此大小始终预计为以字节为单位的大小。在数组绑定的情况下，这是在<code class="codeph">alenp</code>参数中指定实际大小时可能的任何元素的最大大小。
                           </p>
                           <p>如果<code class="codeph">value_sz</code> &gt; <code class="codeph">SB4MAXVAL</code>的值，将发出<code class="codeph">ORA-24452</code> <code class="codeph">SB4MAXVAL</code>错误，这意味着版本12.1或更高版本中不支持值&gt; <code class="codeph">SB4MAXVAL</code> 。
                           </p>
                           <p>对于客户端应用程序未知其大小的描述符，定位符或REF，请使用指向特定类型的指针的大小;例如， <code class="codeph">sizeof</code> （ <code class="codeph">OCILobLocator *</code> ）。
                           </p>
                           <p>即使模式为<code class="codeph">OCI_IOV</code>也是<code class="codeph">OCI_IOV</code> 。</p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-55C47708-5468-4106-89BE-1AB60861D037__GUID-4C75DB82-036E-4A6A-8825-7B1D80295ED8"><!-- --></a> dty（IN）</dt>
                        <dd>
                           <p>绑定值的数据类型。仅当应用程序已在对象模式下初始化时，命名数据类型（ <code class="codeph">SQLT_NTY</code> ）和<code class="codeph">REF</code> （ <code class="codeph">SQLT_REF</code> ）才有效。对于命名数据类型或<code class="codeph">REF</code> ，必须使用绑定句柄进行其他调用以设置特定于数据类型的属性。有关记录，集合和布尔值的信息，请参阅注释。对于命名数据类型<code class="codeph">SQLT_CHR</code> ，当实际长度为0时， <code class="codeph">OCIBindByName2()</code>修剪尾随空白。指定实际长度以防止修剪尾随空白。
                           </p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-55C47708-5468-4106-89BE-1AB60861D037__GUID-9BB4FBE5-972B-46D6-8CB8-9AD5F02D742D"><!-- --></a> indp（IN / OUT）</dt>
                        <dd>
                           <p>指向变量或数组的指针。对于除<code class="codeph">SQLT_NTY</code>之外的所有数据类型，这是指向<code class="codeph">sb2</code>或<code class="codeph">sb2</code>数组的指针。
                           </p>
                           <p>对于<code class="codeph">SQLT_NTY</code> ，忽略此指针，并在随后对<code class="codeph">OCIBindObject()</code>调用中初始化指向结构或指示器结构数组的实际指针。动态绑定将忽略此参数。
                           </p>
                           <div class="infoboxnotealso" id="GUID-55C47708-5468-4106-89BE-1AB60861D037__GUID-58A7385B-87BC-4BBE-803E-72E0AD0D1883">
                              <p class="notep1">也可以看看：</p>
                              <p><a href="oci-programming-basics.html#GUID-9966EDF7-37ED-42E5-AE57-67E394245BFA" title="每个绑定和定义OCI调用都有一个参数，它将指示符变量或指示符变量数组与DML语句，PL / SQL语句或查询相关联。">指标变量</a></p>
                           </div>
                        </dd>
                     </dl>
                     <dl>
                        <dt class="dlterm"><a name="GUID-55C47708-5468-4106-89BE-1AB60861D037__GUID-2760F669-6DA7-4D9B-B26D-382DCF0F77B0"><!-- --></a> alenp（IN / OUT）</dt>
                        <dd>
                           <p>指向数组元素实际长度数组的指针。</p>
                           <p>当使用<code class="codeph">OCIEnvNlsCreate()</code> （推荐的OCI环境句柄创建接口）时， <code class="codeph">alenp</code>长度始终以字节为单位（对于IN绑定）并以字节为单位报告为OUT绑定。对于<code class="codeph">SQLT_VCS</code> （2字节长度前缀）和<code class="codeph">SQLT_LVC</code> （4字节长度前缀）类型中的长度前缀，同样的处理也一致。UCS2或NCHAR案例没有特殊例外。
                           </p>
                           <p>当较旧的OCI环境句柄创建界面被使用（或者<code class="codeph">OCIEnvCreate()</code>或弃用<code class="codeph">OCIEnvInit()</code> <code class="codeph">alenp</code>长度在一般字节。但是，对于IN绑定的字符，预期<code class="codeph">alenp</code>长度，并且仅当字符集为OCI_UC2ID（= OCI_UTF16ID）或在相应的OCIBind句柄上设置<code class="codeph">OCI_ATTR_CHAR_COUNT</code>属性时， <code class="codeph">OCI_ATTR_CHAR_COUNT</code>以OUT绑定的字符报告。对于<code class="codeph">SQLT_VCS</code> （2字节长度前缀）和<code class="codeph">SQLT_LVC</code> （4字节长度前缀）类型中的长度前缀，同样的处理方式也适用。
                           </p>
                           <p>动态绑定将忽略此参数。</p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-55C47708-5468-4106-89BE-1AB60861D037__GUID-FB0BB649-14F2-4EA5-B2D1-EB4F3CE5A412"><!-- --></a> rcodep（OUT）</dt>
                        <dd>
                           <p>指向列级返回码数组的指针。动态绑定将忽略此参数。</p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-55C47708-5468-4106-89BE-1AB60861D037__GUID-D383E698-EDCC-405E-A94A-BABDC7FB9F5B"><!-- --></a> maxarr_len（IN）</dt>
                        <dd>
                           <p>最大数组长度参数（用户数组可容纳的最大元素数）。仅用于PL / SQL索引表绑定。</p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-55C47708-5468-4106-89BE-1AB60861D037__GUID-F7A9480C-2D65-4FA0-8EED-612223CD839D"><!-- --></a> curelep（IN / OUT）</dt>
                        <dd>
                           <p>当前数组长度参数（指向执行操作之前或之后数组中元素的实际数量的指针）。仅用于PL / SQL索引表绑定。</p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-55C47708-5468-4106-89BE-1AB60861D037__GUID-6E5038AE-1F11-444A-AE00-157437CEEFE0"><!-- --></a>模式（IN）</dt>
                        <dd>
                           <p>为了保持编码一致性，理论上该参数可以采用<code class="codeph">OCIStmtPrepare2()</code>使用的所有三个可能值。由于绑定变量的编码应始终与包含此变量的语句的编码相同，因此如果指定的编码不是语句的编码，则会引发错误。因此， <code class="codeph">mode</code>的建议设置是<code class="codeph">OCI_DEFAULT</code> ，这使得绑定变量具有与其语句相同的编码。
                           </p>
                           <p>有效模式是：</p>
                        </dd>
                     </dl>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">OCI_DEFAULT</code> - 默认模式。语句处理<code class="codeph">stmtp</code>使用其父环境句柄指定的任何内容。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">OCI_BIND_SOFT</code> - 软绑定模式。此模式可提高呼叫的性能。如果这是第一个绑定或某个输入值（如<code class="codeph">dty</code>或<code class="codeph">value_sz</code> ）从先前绑定更改，则忽略此模式。如果未执行该语句，则返回错误。如果传递的绑定句柄无效，则会导致意外的行为。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">OCI_DATA_AT_EXEC</code> - 选择此模式时， <code class="codeph">value_sz</code>参数定义可在运行时提供的数据的最大大小。应用程序必须随时可以随时和任意次数提供OCI库运行时IN数据缓冲区。运行时数据以下列两种方式之一提供：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>使用用户定义函数的回调，必须在后续调用<code class="codeph">OCIBindDynamic()</code> 。
                                 </p>
                              </li>
                              <li>
                                 <p>使用OCI提供的调用的轮询机制。如果未定义回调，则假定使用此模式。</p>
                                 <div class="infoboxnotealso" id="GUID-55C47708-5468-4106-89BE-1AB60861D037__GUID-77369438-1AC7-4250-BE64-4F0EDA594CA3">
                                    <p class="notep1">也可以看看：</p>
                                    <p>有关使用<code class="codeph">OCI_DATA_AT_EXEC</code>模式的更多信息，请<code class="codeph">OCI_DATA_AT_EXEC</code> <a href="binding-and-defining-in-oci.html#GUID-6C5EA0C6-0C1D-4CD5-B47F-1B95B4E9C558" title="您可以使用OCI执行分段插入，更新和数据提取。">OCI中的运行时数据分配和分段操作</a></p>
                                 </div>
                              </li>
                           </ul>
                           <p>当<code class="codeph">mode</code>设置为<code class="codeph">OCI_DATA_AT_EXEC</code> ，不要在main调用中为<code class="codeph">valuep</code> ， <code class="codeph">indp</code> ， <code class="codeph">alenp</code>和<code class="codeph">rcodep</code>提供值。为<code class="codeph">indp</code>和<code class="codeph">alenp</code>传递零（0）。通过使用<code class="codeph">OCIBindDynamic()</code>注册的回调函数提供值。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">OCI_IOV</code> - 绑定不连续的数据地址。<code class="codeph">valuep</code>参数必须是<code class="codeph">OCIIOV *</code>类型。此模式旨在用于分散或聚集绑定，这允许将多个缓冲区绑定或定义到某个位置，例如，一个缓冲区中前10行的列A，一个缓冲区中的后5行，其余25个另一个缓冲区中的行。这样就无需在执行数组执行操作时将所有这些分配并复制到一个大缓冲区中。
                           </p>
                           <div class="infoboxnotealso" id="GUID-55C47708-5468-4106-89BE-1AB60861D037__GUID-D1B33945-7FB2-4B94-8B80-DA9D3D488D17">
                              <p class="notep1">也可以看看：</p>
                              <p><a href="binding-and-defining-in-oci.html#GUID-CC67A87C-A39A-400A-BF95-C32363DCD589" title="您可以指定多个缓冲区以用于单个绑定或定义调用。">关于绑定和定义多个缓冲区</a></p>
                           </div>
                        </li>
                     </ul>
                     <p>当不再需要分配的缓冲区时，它们应该被客户端释放。</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-55C47708-5468-4106-89BE-1AB60861D037__GUID-37E092CA-4F6C-47D1-A75F-E4981F034728">评论</p>
                     <p>此调用用于执行基本绑定操作。bind在程序变量的地址和SQL语句或PL / SQL块中的占位符之间创建关联。bind调用还指定了绑定的数据类型，还可以指示在运行时提供数据的方法。</p>
                     <p>编码由绑定句柄确定，使用语句句柄中的设置作为默认值，或者您可以通过显式指定<code class="codeph">mode</code>参数来覆盖设置。
                     </p>
                     <p><code class="codeph">OCIBindByName2()</code>还隐式分配<code class="codeph">bindpp</code>参数指示的绑定句柄。如果在<code class="codeph">**bindpp</code>传递非<code class="codeph">NULL</code>指针，则OCI假定这指向先前已通过调用<code class="codeph">OCIHandleAlloc()</code>或<code class="codeph">OCIBindByName2()</code>分配的有效句柄。
                     </p>
                     <p>OCI应用程序中的数据可以静态或动态地绑定到占位符。当所有IN绑定数据和OUT绑定缓冲区在执行操作之前很好地定义时，绑定是<span class="italic">静态的</span> 。当IN绑定数据和OUT绑定缓冲区由应用程序在执行时按需提供给客户端库时，绑定是<span class="italic">动态的</span> 。通过将此调用的<code class="codeph">mode</code>参数设置为<code class="codeph">OCI_DATA_AT_EXEC</code>来指示动态绑定。</p>
                     <div class="infoboxnotealso" id="GUID-55C47708-5468-4106-89BE-1AB60861D037__GUID-B9D261EE-FFE7-4A1F-8F0F-B1B664ECD633">
                        <p class="notep1">也可以看看：</p>
                        <p>有关动态绑定的更多信息，请参阅<a href="binding-and-defining-in-oci.html#GUID-6C5EA0C6-0C1D-4CD5-B47F-1B95B4E9C558" title="您可以使用OCI执行分段插入，更新和数据提取。">OCI中的运行时数据分配和分段操作</a></p>
                     </div>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p><code class="codeph">OCIBindByName2()</code>和<code class="codeph">OCIBindByPos2()</code>将绑定句柄作为参数，绑定句柄由绑定调用隐式分配。为应用程序绑定的每个占位符分配单独的绑定句柄。
                     </p>
                     <p>可能需要额外的绑定调用来指定绑定某些数据类型或以某些方式处理输入数据时所需的特定属性：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>如果正在使用结构数组，则必须调用<code class="codeph">OCIBindArrayOfStruct()</code>来设置必要的跳过参数。
                           </p>
                        </li>
                        <li>
                           <p>如果在运行时动态提供数据，并且应用程序使用用户定义的回调函数， <code class="codeph">OCIBindDynamic()</code>必须调用<code class="codeph">OCIBindDynamic()</code>来注册回调。
                           </p>
                        </li>
                        <li>
                           <p>如果<code class="codeph">alenp</code>长度大于64 Kilobytes（KB），则使用<code class="codeph">OCIBindDynamic()</code> 。
                           </p>
                        </li>
                        <li>
                           <p>如果绑定了命名数据类型，则必须调用<code class="codeph">OCIBindObject()</code>以指定其他必要信息。
                           </p>
                        </li>
                        <li>
                           <p>如果用一个声明<code class="codeph">RETURNING</code>使用条款，将呼叫<code class="codeph">OCIBindDynamic()</code>必须遵循这一呼吁。
                           </p>
                        </li>
                     </ul>
                     <p>使用IN绑定时，必须在调用<code class="codeph">OCIStmtExecute()</code>之前设置数组的每个元素的值，每个元素的实际长度以及实际的数组长度。
                     </p>
                     <p>使用OUT绑定时，在<code class="codeph">OCIStmtExecute()</code>调用之后， <code class="codeph">OCIStmtExecute()</code>服务器返回数组的每个元素的值，每个元素的实际长度以及实际的数组长度。
                     </p>
                     <dl>
                        <dt class="dlterm"><a name="GUID-55C47708-5468-4106-89BE-1AB60861D037__GUID-562412EC-A7CE-4B43-89F8-E1123AFB509E"><!-- --></a>用于记录</dt>
                        <dd>
                           <p>客户端必须使用<code class="codeph">SQLT_NTY</code>绑定包记录类型作为绑定的DTY。在OCI客户端中，对象和记录表示为命名类型（NTY），并且必须使用相同的<code class="codeph">SQLT</code>代码。
                           </p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-55C47708-5468-4106-89BE-1AB60861D037__GUID-28A8DB5A-2746-4276-B884-E75922A218ED"><!-- --></a>收藏</dt>
                        <dd>
                           <p>客户端必须使用<code class="codeph">SQLT_NTY</code>绑定所有包集合类型。这是用于绑定所有模式级别集合类型的DTY。
                           </p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-55C47708-5468-4106-89BE-1AB60861D037__GUID-61D960D8-02DD-4DC2-92BA-DFC64B453CAD"><!-- --></a>对于布尔人</dt>
                        <dd>
                           <p>客户端必须使用<code class="codeph">SQLT_BOL</code>绑定布尔类型（ <code class="codeph">OCI_TYPECODE_BOOLEAN</code> ）。</p>
                        </dd>
                     </dl>
                  </div>
                  <!-- class="section" -->
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="bind-define-describe-functions.html#GUID-030270CB-346A-412E-B3B3-556DD6947BE2" title="注册用户回调以进行动态数据分配。">OCIBindDynamic（）</a></li>
                        <li><a href="bind-define-describe-functions.html#GUID-384B5D31-165B-4661-A334-8C2B5E475AEF" title="设置命名数据类型（对象）绑定所需的其他属性。">OCIBindObject（）</a></li>
                        <li><a href="bind-define-describe-functions.html#GUID-E83BF668-88FC-4F31-A950-3580B79588E0" title="设置静态数组绑定的跳过参数。">OCIBindArrayOfStruct（）</a></li>
                        <li><a href="bind-define-describe-functions.html#GUID-CD63DF78-2178-4727-A896-B9673C4A37F0" title="在SQL语句或PL / SQL块中创建程序变量和占位符之间的关联。">OCIBindByName（）</a></li>
                        <li><a href="handle-and-descriptor-functions.html#GUID-3741D7BD-7652-4D7A-8813-AC2AEA8D3B03" title="设置句柄或描述符的属性值。">OCIAttrSet（）</a></li>
                        <li><a href="statement-functions.html#GUID-E6C1DC67-D464-4D2A-9F19-737423D31779" title="准备SQL或PL / SQL语句以便执行。">OCIStmtPrepare2（）</a></li>
                        <li><a href="connect-authorize-and-initialize-functions.html#GUID-16BDA1F1-7DAF-41CA-9EE1-C9A4CB467244" title="创建并初始化OCI函数的环境句柄。">OCIEnvCreate（）</a></li>
                        <li><a href="connect-authorize-and-initialize-functions.html#GUID-0B6911A9-4B46-476C-BC5E-B87581666CD9" title="创建并初始化OCI函数的环境句柄。">OCIEnvNlsCreate（）</a></li>
                        <li><a href="deprecated-oci-functions.html#GUID-1AC89920-7DB1-46AC-BBAA-9854DDAD6AB7" title="在Oracle Database 11g第2版（11.2）之前的版本中不推荐使用此功能。">OCIEnvInit（）</a></li>
                        <li><a href="handle-and-descriptor-functions.html#GUID-C5BF55F7-A110-4CB5-9663-5056590F12B5" title="返回指向已分配和初始化句柄的指针。">OCIHandleAlloc（）</a></li>
                        <li><a href="bind-define-describe-functions.html#GUID-5C505821-323D-473D-825B-448C8D9A6702" title="在SQL语句或PL / SQL块中创建程序变量和占位符之间的关联。当客户端上的实际长度超过UB2MAXVAL时，在处理数据类型时使用此调用。">OCIBindByPos2（）</a></li>
                        <li><a href="statement-functions.html#GUID-98B26708-3E02-45C0-8258-5D5544F32BE9" title="将应用程序请求与服务器关联。">OCIStmtExecute（）</a></li>
                        <li><a href="miscellaneous-functions.html#GUID-4B99087C-74F6-498A-8310-D6645172390A" title="返回错误消息和Oracle数据库错误代码。">OCIErrorGet（）</a></li>
                     </ul>
                  </div>
               </div>
               
            </div><a id="LNOCI17141"></a><div class="props_rev_3"><a id="GUID-D28DF5A7-3C75-4E52-82F7-A5D6D5714E69" name="GUID-D28DF5A7-3C75-4E52-82F7-A5D6D5714E69"></a><h3 id="LNOCI-GUID-D28DF5A7-3C75-4E52-82F7-A5D6D5714E69" class="sect3"><span class="enumeration_section">25.4.4</span> OCIBindByPos（）</h3>
               <div>
                  <p>在SQL语句或PL / SQL块中创建程序变量和占位符之间的关联。</p>
                  <div class="section">
                     <p class="subhead2" id="GUID-D28DF5A7-3C75-4E52-82F7-A5D6D5714E69__GUID-F63D33E9-884C-4C23-836C-FEE5861537CF">目的</p>
                     <p>在SQL语句或PL / SQL块中创建程序变量和占位符之间的关联。</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-D28DF5A7-3C75-4E52-82F7-A5D6D5714E69__GUID-31D3A001-FE3F-4EBF-856D-F3FA9F7E66B2">句法</p><pre class="oac_no_warn" dir="ltr">剑OCIBindByPos（OCIStmt * stmtp，OCIBind ** bindpp，OCIError * errhp，ub4位置，void * valuep，sb4 value_sz，ub2 dty，void * indp，ub2 * alenp，ub2 * rcodep，ub4 maxarr_len，ub4 * curelep，ub4 mode ）;</pre></div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-D28DF5A7-3C75-4E52-82F7-A5D6D5714E69__GUID-A3A1D3FB-2319-4157-8017-6F9C22C63385">参数</p>
                     <dl>
                        <dt class="dlterm"><a name="GUID-D28DF5A7-3C75-4E52-82F7-A5D6D5714E69__GUID-1FF475A7-15DD-48FF-B438-0DE4A3284D47"><!-- --></a> stmtp（IN / OUT）</dt>
                        <dd>
                           <p>正在处理的SQL或PL / SQL语句的语句句柄。</p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-D28DF5A7-3C75-4E52-82F7-A5D6D5714E69__GUID-956231EF-CB55-48B3-956F-F70B6280D258"><!-- --></a> bindpp（IN / OUT）</dt>
                        <dd>
                           <p>此调用隐式分配的绑定句柄的地址。绑定句柄维护此特定输入值的所有绑定信息。取消分配语句句柄时，将隐式释放句柄。在输入时，指针的值必须为<code class="codeph">NULL</code>或有效的绑定句柄。
                           </p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-D28DF5A7-3C75-4E52-82F7-A5D6D5714E69__GUID-B1D4E847-B097-459C-82EA-58419E7A80CF"><!-- --></a> errhp（输入/输出）</dt>
                        <dd>
                           <p>一个错误句柄，您可以在出现错误时传递给<code class="codeph">OCIErrorGet()</code>以获取诊断信息。
                           </p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-D28DF5A7-3C75-4E52-82F7-A5D6D5714E69__GUID-7B05A214-9D76-4E89-9CC7-9A6DE84BEF5E"><!-- --></a>位置（IN）</dt>
                        <dd>
                           <p>如果正在调用<code class="codeph">OCIBindByPos()</code>位置指定占位符属性。职位从1开始。
                           </p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-D28DF5A7-3C75-4E52-82F7-A5D6D5714E69__GUID-9C4E1D6B-440F-4C7B-8ED8-DBDD8EC09ACC"><!-- --></a> valuep（IN / OUT）</dt>
                        <dd>
                           <p>数据值的地址或<code class="codeph">dty</code>参数中指定类型的数据值数组。可以指定数据值数组以映射到PL / SQL表或为SQL多行操作提供数据。当提供绑定值数组时，这称为OCI术语中的数组绑定。
                           </p>
                           <p>对于LOB，缓冲区指针必须是指向<code class="codeph">OCILobLocator</code>类型的LOB定位符的<code class="codeph">OCILobLocator</code> 。给出指针的地址。
                           </p>
                           <p>对于SQLT_NTY或SQLT_REF绑定，将忽略<code class="codeph">valuep</code>参数。指向OUT缓冲区的指针在由<code class="codeph">OCIBindObject()</code>初始化的<code class="codeph">pgvpp</code>参数中设置。
                           </p>
                           <p>如果<code class="codeph">OCI_ATTR_CHARSET_ID</code>属性设置为<code class="codeph">OCI_UTF16ID</code> （替换为了向后兼容而保留的已弃用的<code class="codeph">OCI_UCS2ID</code> ），则假定传递给相应绑定调用并通过相应绑定调用接收的所有数据都采用<code class="codeph">UTF-16</code>编码。
                           </p>
                           <p>当<code class="codeph">mode</code>设置为<code class="codeph">OCI_IOV</code> ，传递<code class="codeph">OCIIOV</code>结构的基址。
                           </p>
                           <div class="infoboxnotealso" id="GUID-D28DF5A7-3C75-4E52-82F7-A5D6D5714E69__GUID-53D145FA-2961-4A62-962B-9486204D48D1">
                              <p class="notep1">也可以看看：</p>
                              <p><a href="handle-and-descriptor-attributes.html#GUID-01C53C14-CD15-4A8B-9EFF-86996282F3BD" title="列出并描述绑定句柄属性。">绑定句柄属性</a></p>
                           </div>
                        </dd>
                        <dt class="dlterm"><a name="GUID-D28DF5A7-3C75-4E52-82F7-A5D6D5714E69__GUID-2B615563-FC6C-431D-850F-CE0283172A04"><!-- --></a> value_sz（IN）</dt>
                        <dd>
                           <p>此绑定变量的任何数据值（使用<code class="codeph">valuep</code>传递）的最大大小（以字节为<code class="codeph">valuep</code> ）。此大小始终预计为以字节为单位的大小。在数组绑定的情况下，这是在<code class="codeph">alenp</code>参数中指定实际大小时可能的任何元素的最大大小。
                           </p>
                           <p>对于客户端应用程序未知其大小的描述符，定位符或<code class="codeph">REF</code> ，请使用指向特定类型的指针的大小;例如， <code class="codeph">sizeof</code> （ <code class="codeph">OCILobLocator *</code> ）。
                           </p>
                           <p>即使模式为<code class="codeph">OCI_IOV</code>也是<code class="codeph">OCI_IOV</code> 。</p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-D28DF5A7-3C75-4E52-82F7-A5D6D5714E69__GUID-C4351357-D826-4766-AB03-ECB2E255C6D3"><!-- --></a> dty（IN）</dt>
                        <dd>
                           <p>绑定值的数据类型。仅当应用程序已在对象模式下初始化时，命名数据类型（SQLT_NTY）和<code class="codeph">REF</code> （SQLT_REF）才有效。对于命名数据类型或<code class="codeph">REF</code> ，必须使用绑定句柄进行其他调用，以设置特定于数据类型的属性。有关记录，集合和布尔值的信息，请参阅注释。对于命名数据类型<code class="codeph">SQLT_CHR</code> ，当实际长度为0时， <code class="codeph">OCIBindByPos()</code>修剪尾随空白。指定实际长度以防止修剪尾随空白。
                           </p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-D28DF5A7-3C75-4E52-82F7-A5D6D5714E69__GUID-08F83FA2-57A4-4623-9E78-228114248200"><!-- --></a> indp（IN / OUT）</dt>
                        <dd>
                           <p>指向变量或数组的指针。对于所有数据类型，这是指向<code class="codeph">sb2</code>或<code class="codeph">sb2</code>值数组的指针。唯一的例外是SQLT_NTY，其中忽略此指针，并且<code class="codeph">OCIBindObject()</code>初始化指向结构或指标结构数组的实际指针。动态绑定将忽略<code class="codeph">indp</code>参数。如果<code class="codeph">valuep</code>是<code class="codeph">OUT</code>参数，则必须将<code class="codeph">indp</code>设置为指向<code class="codeph">OCI_IND_NULL</code> 。</p>
                           <div class="infoboxnotealso" id="GUID-D28DF5A7-3C75-4E52-82F7-A5D6D5714E69__GUID-4D1D69E9-7CD4-49F1-B90C-E1B2D18EC78C">
                              <p class="notep1">也可以看看：</p>
                              <p><a href="oci-programming-basics.html#GUID-9966EDF7-37ED-42E5-AE57-67E394245BFA" title="每个绑定和定义OCI调用都有一个参数，它将指示符变量或指示符变量数组与DML语句，PL / SQL语句或查询相关联。">指标变量</a></p>
                           </div>
                        </dd>
                        <dt class="dlterm"><a name="GUID-D28DF5A7-3C75-4E52-82F7-A5D6D5714E69__GUID-1D253717-4AA1-43B7-81C0-5334F4F6EAA9"><!-- --></a> alenp（IN / OUT）</dt>
                        <dd>
                           <p>指向数组元素实际长度数组的指针。</p>
                           <p>当使用<code class="codeph">OCIEnvNlsCreate()</code> （推荐的OCI环境句柄创建接口）时， <code class="codeph">alenp</code>长度始终以字节为单位（对于IN绑定）并以字节为单位报告为OUT绑定。对于<code class="codeph">SQLT_VCS</code> （2字节长度前缀）和<code class="codeph">SQLT_LVC</code> （4字节长度前缀）类型中的长度前缀，同样的处理也一致。UCS2或NCHAR案例没有特殊例外。
                           </p>
                           <p>当较旧的OCI环境句柄创建界面被使用（或者<code class="codeph">OCIEnvCreate()</code>或弃用<code class="codeph">OCIEnvInit()</code> <code class="codeph">alenp</code>长度在一般字节。但是，对于IN绑定的字符，预期<code class="codeph">alenp</code>长度，并且仅当字符集为OCI_UC2ID（= OCI_UTF16ID）或在相应的OCIBind句柄上设置<code class="codeph">OCI_ATTR_CHAR_COUNT</code>属性时， <code class="codeph">OCI_ATTR_CHAR_COUNT</code>以OUT绑定的字符报告。对于<code class="codeph">SQLT_VCS</code> （2字节长度前缀）和<code class="codeph">SQLT_LVC</code> （4字节长度前缀）类型中的长度前缀，同样的处理方式也适用。
                           </p>
                           <p>动态绑定将忽略此参数。</p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-D28DF5A7-3C75-4E52-82F7-A5D6D5714E69__GUID-30840291-18A1-44CD-AEA9-9536490D22F6"><!-- --></a> rcodep（OUT）</dt>
                        <dd>
                           <p>指向列级返回码数组的指针。动态绑定将忽略此参数。</p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-D28DF5A7-3C75-4E52-82F7-A5D6D5714E69__GUID-FE3210AF-CC37-4047-9652-166B669C4CA4"><!-- --></a> maxarr_len（IN）</dt>
                        <dd>
                           <p>最大数组长度参数（用户数组可容纳的最大可能元素数）。仅用于PL / SQL索引表绑定。</p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-D28DF5A7-3C75-4E52-82F7-A5D6D5714E69__GUID-3E8D3FFB-C72B-4CBB-9464-05E5B2BA9181"><!-- --></a> curelep（IN / OUT）</dt>
                        <dd>
                           <p>当前数组长度参数（指向执行操作之前或之后数组中元素的实际数量的指针）。仅用于PL / SQL索引表绑定。</p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-D28DF5A7-3C75-4E52-82F7-A5D6D5714E69__GUID-17DA7FA0-7BDE-49D9-9AD0-404051D00F4A"><!-- --></a>模式（IN）</dt>
                        <dd>
                           <p>此参数的有效模式为：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">OCI_DEFAULT</code> - 这是默认模式。
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">OCI_BIND_SOFT</code> - 软绑定模式。此模式可提高呼叫的性能。如果这是第一个绑定或某个输入值（如<code class="codeph">dty</code>或<code class="codeph">value_sz</code> ）从先前绑定更改，则忽略此模式。如果未执行该语句，则返回错误。如果传递的绑定句柄无效，则会导致意外的行为。
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">OCI_DATA_AT_EXEC</code> - 选择此模式时， <code class="codeph">value_sz</code>参数定义可在运行时提供的数据的最大大小。应用程序必须随时可以随时和任意次数提供OCI库运行时IN数据缓冲区。运行时数据以下列方式之一提供：</p>
                                 <ul style="list-style-type:disc">
                                    <li>
                                       <p>使用用户定义函数的回调，必须在后续调用<code class="codeph">OCIBindDynamic()</code> 。
                                       </p>
                                    </li>
                                    <li>
                                       <p>使用OCI提供的调用的轮询机制。如果未定义回调，则假定使用此模式。</p>
                                       <div class="infoboxnotealso" id="GUID-D28DF5A7-3C75-4E52-82F7-A5D6D5714E69__GUID-32776579-7DD9-4681-A8A8-51B658E25DB3">
                                          <p class="notep1">也可以看看：</p>
                                          <p>有关使用<code class="codeph">OCI_DATA_AT_EXEC</code>模式的更多信息，请<code class="codeph">OCI_DATA_AT_EXEC</code> <a href="binding-and-defining-in-oci.html#GUID-6C5EA0C6-0C1D-4CD5-B47F-1B95B4E9C558" title="您可以使用OCI执行分段插入，更新和数据提取。">OCI中的运行时数据分配和分段操作</a></p>
                                       </div>
                                       <p>当<code class="codeph">mode</code>设置为<code class="codeph">OCI_DATA_AT_EXEC</code> ，不要在main调用中为<code class="codeph">valuep</code> ， <code class="codeph">indp</code> ， <code class="codeph">alenp</code>和<code class="codeph">rcodep</code>提供值。为<code class="codeph">indp</code>和<code class="codeph">alenp</code>传递零（0）。通过使用<code class="codeph">OCIBindDynamic()</code>注册的回调函数提供值。
                                       </p>
                                    </li>
                                 </ul>
                              </li>
                              <li>
                                 <p><code class="codeph">OCI_IOV</code> - 绑定不连续的数据地址。<code class="codeph">valuep</code>参数必须是<code class="codeph">OCIIOV *</code>类型。此模式旨在用于分散或聚集绑定，这允许将多个缓冲区绑定或定义到某个位置，例如，一个缓冲区中前10行的列A，一个缓冲区中的后5行，其余25个另一个缓冲区中的行。这样就无需在执行数组执行操作时将所有这些分配并复制到一个大缓冲区中。
                                 </p>
                                 <div class="infoboxnotealso" id="GUID-D28DF5A7-3C75-4E52-82F7-A5D6D5714E69__GUID-DA5242EE-3A89-44E1-98D9-64124E5EC7C6">
                                    <p class="notep1">也可以看看：</p>
                                    <p><a href="binding-and-defining-in-oci.html#GUID-CC67A87C-A39A-400A-BF95-C32363DCD589" title="您可以指定多个缓冲区以用于单个绑定或定义调用。">关于绑定和定义多个缓冲区</a></p>
                                 </div>
                              </li>
                           </ul>
                        </dd>
                     </dl>
                     <p>当不再需要分配的缓冲区时，它们应该被客户端释放。</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-D28DF5A7-3C75-4E52-82F7-A5D6D5714E69__GUID-6BA78DEB-1F27-4577-B89C-7F63FF1A7036">评论</p>
                     <p>此调用用于执行基本绑定操作。bind在程序变量的地址和SQL语句或PL / SQL块中的占位符之间创建关联。绑定调用还指定了绑定的数据类型，还可以指示在运行时提供数据的方法。</p>
                     <p>此函数还隐式分配<code class="codeph">bindpp</code>参数指示的绑定句柄。如果在<code class="codeph">**bindpp</code>传递非<code class="codeph">NULL</code>指针，则OCI假定这指向先前已通过调用<code class="codeph">OCIHandleAlloc()</code>或<code class="codeph">OCIBindByPos()</code>分配的有效句柄。
                     </p>
                     <p>OCI应用程序中的数据可以静态或动态地绑定到占位符。当所有IN绑定数据和OUT绑定缓冲区在执行操作之前很好地定义时，绑定是<span class="italic">静态的</span> 。当IN绑定数据和OUT绑定缓冲区由应用程序在执行时按需提供给客户端库时，绑定是<span class="italic">动态的</span> 。通过将此调用的<code class="codeph">mode</code>参数设置为<code class="codeph">OCI_DATA_AT_EXEC</code>来指示动态绑定。</p>
                     <div class="infoboxnotealso" id="GUID-D28DF5A7-3C75-4E52-82F7-A5D6D5714E69__GUID-0D2C1A23-6527-40D9-8B87-4243AF53210B">
                        <p class="notep1">也可以看看：</p>
                        <p>有关动态绑定的更多信息，请参阅<a href="binding-and-defining-in-oci.html#GUID-6C5EA0C6-0C1D-4CD5-B47F-1B95B4E9C558" title="您可以使用OCI执行分段插入，更新和数据提取。">OCI中的运行时数据分配和分段操作</a></p>
                     </div>
                     <p><code class="codeph">OCIBindByName()</code>和<code class="codeph">OCIBindByPos()</code>将绑定句柄作为参数，绑定句柄由绑定调用隐式分配。为应用程序绑定的每个占位符分配单独的绑定句柄。
                     </p>
                     <p>可能需要额外的绑定调用来指定绑定某些数据类型或以某些方式处理输入数据时所需的特定属性：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>如果正在使用结构数组，则必须调用<code class="codeph">OCIBindArrayOfStruct()</code>来设置必要的跳过参数。
                           </p>
                        </li>
                        <li>
                           <p>如果在运行时动态提供数据，并且应用程序使用用户定义的回调函数， <code class="codeph">OCIBindDynamic()</code>必须调用<code class="codeph">OCIBindDynamic()</code>来注册回调。
                           </p>
                        </li>
                        <li>
                           <p>如果<code class="codeph">alenp</code>长度大于64 KB，请使用<code class="codeph">OCIBindDynamic()</code> 。
                           </p>
                        </li>
                        <li>
                           <p>如果绑定了命名数据类型，则必须调用<code class="codeph">OCIBindObject()</code>以指定其他必要信息。
                           </p>
                        </li>
                        <li>
                           <p>如果用一个声明<code class="codeph">RETURNING</code>使用条款，将呼叫<code class="codeph">OCIBindDynamic()</code>必须遵循这一呼吁。
                           </p>
                        </li>
                     </ul>
                     <p>使用IN绑定时，必须在调用<code class="codeph">OCIStmtExecute()</code>之前设置数组的每个元素的值，每个元素的实际长度以及实际的数组长度。
                     </p>
                     <p>使用OUT绑定时，在<code class="codeph">OCIStmtExecute()</code>调用之后， <code class="codeph">OCIStmtExecute()</code>服务器返回数组的每个元素的值，每个元素的实际长度以及实际的数组长度。
                     </p>
                     <dl>
                        <dt class="dlterm"><a name="GUID-D28DF5A7-3C75-4E52-82F7-A5D6D5714E69__GUID-F5441E22-2F57-4348-AD7C-A67B429808BF"><!-- --></a>用于记录</dt>
                        <dd>
                           <p>客户端必须使用<code class="codeph">SQLT_NTY</code>绑定包记录类型作为绑定的DTY。在OCI客户端中，对象和记录表示为命名类型（NTY），并且必须使用相同的<code class="codeph">SQLT</code>代码。
                           </p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-D28DF5A7-3C75-4E52-82F7-A5D6D5714E69__GUID-A0848DB6-884E-4AF2-B9AB-FE66A0EFBB6A"><!-- --></a>收藏</dt>
                        <dd>
                           <p>客户端必须使用<code class="codeph">SQLT_NTY</code>绑定所有包集合类型。这是用于绑定所有模式级别集合类型的DTY。
                           </p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-D28DF5A7-3C75-4E52-82F7-A5D6D5714E69__GUID-B90F3B6C-20B1-4250-9A50-76ED208F0032"><!-- --></a>对于布尔人</dt>
                        <dd>
                           <p>客户端必须使用<code class="codeph">SQLT_BOL</code>绑定布尔类型（ <code class="codeph">OCI_TYPECODE_BOOLEAN</code> ）。</p>
                        </dd>
                     </dl>
                  </div>
                  <!-- class="section" -->
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="bind-define-describe-functions.html#GUID-030270CB-346A-412E-B3B3-556DD6947BE2" title="注册用户回调以进行动态数据分配。">OCIBindDynamic（）</a></li>
                        <li><a href="bind-define-describe-functions.html#GUID-384B5D31-165B-4661-A334-8C2B5E475AEF" title="设置命名数据类型（对象）绑定所需的其他属性。">OCIBindObject（）</a></li>
                        <li><a href="bind-define-describe-functions.html#GUID-E83BF668-88FC-4F31-A950-3580B79588E0" title="设置静态数组绑定的跳过参数。">OCIBindArrayOfStruct（）</a></li>
                        <li><a href="bind-define-describe-functions.html#GUID-5C505821-323D-473D-825B-448C8D9A6702" title="在SQL语句或PL / SQL块中创建程序变量和占位符之间的关联。当客户端上的实际长度超过UB2MAXVAL时，在处理数据类型时使用此调用。">OCIBindByPos2（）</a></li>
                        <li><a href="connect-authorize-and-initialize-functions.html#GUID-16BDA1F1-7DAF-41CA-9EE1-C9A4CB467244" title="创建并初始化OCI函数的环境句柄。">OCIEnvCreate（）</a></li>
                        <li><a href="connect-authorize-and-initialize-functions.html#GUID-0B6911A9-4B46-476C-BC5E-B87581666CD9" title="创建并初始化OCI函数的环境句柄。">OCIEnvNlsCreate（）</a></li>
                        <li><a href="deprecated-oci-functions.html#GUID-1AC89920-7DB1-46AC-BBAA-9854DDAD6AB7" title="在Oracle Database 11g第2版（11.2）之前的版本中不推荐使用此功能。">OCIEnvInit（）</a></li>
                        <li><a href="handle-and-descriptor-functions.html#GUID-C5BF55F7-A110-4CB5-9663-5056590F12B5" title="返回指向已分配和初始化句柄的指针。">OCIHandleAlloc（）</a></li>
                        <li><a href="bind-define-describe-functions.html#GUID-CD63DF78-2178-4727-A896-B9673C4A37F0" title="在SQL语句或PL / SQL块中创建程序变量和占位符之间的关联。">OCIBindByName（）</a></li>
                        <li><a href="statement-functions.html#GUID-98B26708-3E02-45C0-8258-5D5544F32BE9" title="将应用程序请求与服务器关联。">OCIStmtExecute（）</a></li>
                        <li><a href="miscellaneous-functions.html#GUID-4B99087C-74F6-498A-8310-D6645172390A" title="返回错误消息和Oracle数据库错误代码。">OCIErrorGet（）</a></li>
                     </ul>
                  </div>
               </div>
               
            </div><a id="LNOCI72806"></a><div class="props_rev_3"><a id="GUID-5C505821-323D-473D-825B-448C8D9A6702" name="GUID-5C505821-323D-473D-825B-448C8D9A6702"></a><h3 id="LNOCI-GUID-5C505821-323D-473D-825B-448C8D9A6702" class="sect3"><span class="enumeration_section">25.4.5</span> OCIBindByPos2（）</h3>
               <div>
                  <p>在SQL语句或PL / SQL块中创建程序变量和占位符之间的关联。当客户端上的实际长度超过<code class="codeph">UB2MAXVAL</code>时，在处理数据类型时使用此调用。
                  </p>
                  <div class="section">
                     <p class="subhead2" id="GUID-5C505821-323D-473D-825B-448C8D9A6702__GUID-B3609B60-5E3D-4592-8B26-002EFE1C56FF">目的</p>
                     <p>在SQL语句或PL / SQL块中创建程序变量和占位符之间的关联。当客户端上的实际长度超过<code class="codeph">UB2MAXVAL</code>时，在处理数据类型时使用此调用而不是<code class="codeph">OCIBindByPos()</code> 。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-5C505821-323D-473D-825B-448C8D9A6702__GUID-8A2D63E8-6B9B-4505-8A3E-6C0CC5CA5E42">句法</p><pre class="oac_no_warn" dir="ltr">剑OCIBindByPos2（OCIStmt * stmtp，OCIBind ** bindpp，OCIError * errhp，ub4位置，void * valuep，sb8 value_sz，ub2 dty，void * indp，ub4 * alenp，ub2 * rcodep，ub4 maxarr_len，ub4 * curelep，ub4 mode ）;</pre></div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-5C505821-323D-473D-825B-448C8D9A6702__GUID-7C2CE4C6-1C4D-412A-A938-05528459C2CE">参数</p>
                     <dl>
                        <dt class="dlterm"><a name="GUID-5C505821-323D-473D-825B-448C8D9A6702__GUID-DC4584B9-A397-4BA9-A9E2-51C68B7E77A4"><!-- --></a> stmtp（IN / OUT）</dt>
                        <dd>
                           <p>正在处理的SQL或PL / SQL语句的语句句柄。</p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-5C505821-323D-473D-825B-448C8D9A6702__GUID-0697E836-9A3C-4790-BE93-CDCC4DBAA771"><!-- --></a> bindpp（IN / OUT）</dt>
                        <dd>
                           <p>此调用隐式分配的绑定句柄的地址。绑定句柄维护此特定输入值的所有绑定信息。取消分配语句句柄时，将隐式释放句柄。在输入时，指针的值必须为<code class="codeph">NULL</code>或有效的绑定句柄。
                           </p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-5C505821-323D-473D-825B-448C8D9A6702__GUID-A1750565-EDCD-4D25-962A-ACA0FCDDDF1D"><!-- --></a> errhp（输入/输出）</dt>
                        <dd>
                           <p>一个错误句柄，您可以在出现错误时传递给<code class="codeph">OCIErrorGet()</code>以获取诊断信息。
                           </p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-5C505821-323D-473D-825B-448C8D9A6702__GUID-A664013F-A219-404B-BBF3-B95BA4E875E5"><!-- --></a>位置（IN）</dt>
                        <dd>
                           <p>如果正在调用<code class="codeph">OCIBindByPos()</code>位置指定占位符属性。职位从1开始。
                           </p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-5C505821-323D-473D-825B-448C8D9A6702__GUID-9C865EA5-1D69-4724-99B0-8F32EFA86E42"><!-- --></a> valuep（IN / OUT）</dt>
                        <dd>
                           <p>数据值的地址或<code class="codeph">dty</code>参数中指定类型的数据值数组。可以指定数据值数组以映射到PL / SQL表或为SQL多行操作提供数据。当提供绑定值数组时，这称为OCI术语中的数组绑定。
                           </p>
                           <p>对于LOB，缓冲区指针必须是指向<code class="codeph">OCILobLocator</code>类型的LOB定位符的<code class="codeph">OCILobLocator</code> 。给出指针的地址。
                           </p>
                           <p>对于SQLT_NTY或SQLT_REF绑定，将忽略<code class="codeph">valuep</code>参数。指向OUT缓冲区的指针在由<code class="codeph">OCIBindObject()</code>初始化的<code class="codeph">pgvpp</code>参数中设置。
                           </p>
                           <p>如果<code class="codeph">OCI_ATTR_CHARSET_ID</code>属性设置为<code class="codeph">OCI_UTF16ID</code> （替换为了向后兼容而保留的已弃用的<code class="codeph">OCI_UCS2ID</code> ），则假定传递给相应绑定调用并通过相应绑定调用接收的所有数据都采用<code class="codeph">UTF-16</code>编码。
                           </p>
                           <p>当<code class="codeph">mode</code>设置为<code class="codeph">OCI_IOV</code> ，传递<code class="codeph">OCIIOV</code>结构的基址。
                           </p>
                           <div class="infoboxnotealso" id="GUID-5C505821-323D-473D-825B-448C8D9A6702__GUID-7088B17B-CBA2-427B-B985-B2B8E2892A4C">
                              <p class="notep1">也可以看看：</p>
                              <p><a href="handle-and-descriptor-attributes.html#GUID-01C53C14-CD15-4A8B-9EFF-86996282F3BD" title="列出并描述绑定句柄属性。">绑定句柄属性</a></p>
                           </div>
                        </dd>
                        <dt class="dlterm"><a name="GUID-5C505821-323D-473D-825B-448C8D9A6702__GUID-B4BBE6E0-3BD7-4DB1-A5CF-CA9C0803803E"><!-- --></a> value_sz（IN）</dt>
                        <dd>
                           <p>此绑定变量的任何数据值（使用<code class="codeph">valuep</code>传递）的最大大小（以字节为<code class="codeph">valuep</code> ）。此大小始终预计为以字节为单位的大小。在数组绑定的情况下，这是在<code class="codeph">alenp</code>参数中指定实际大小时可能的任何元素的最大大小。
                           </p>
                           <p>如果<code class="codeph">value_sz</code> &gt; <code class="codeph">SB4MAXVAL</code>的值，将发出<code class="codeph">ORA-24452</code> <code class="codeph">SB4MAXVAL</code>错误，这意味着版本12.1或更高版本中不支持值&gt; <code class="codeph">SB4MAXVAL</code> 。
                           </p>
                           <p>对于客户端应用程序未知其大小的描述符，定位符或<code class="codeph">REF</code> ，请使用指向特定类型的指针的大小;例如， <code class="codeph">sizeof</code> （ <code class="codeph">OCILobLocator *</code> ）。
                           </p>
                           <p>即使模式为<code class="codeph">OCI_IOV</code>也是<code class="codeph">OCI_IOV</code> 。</p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-5C505821-323D-473D-825B-448C8D9A6702__GUID-A48593E4-8ADE-4868-AF70-0758E8DEAE84"><!-- --></a> dty（IN）</dt>
                        <dd>
                           <p>绑定值的数据类型。仅当应用程序已在对象模式下初始化时，命名数据类型（SQLT_NTY）和<code class="codeph">REF</code> （SQLT_REF）才有效。对于命名数据类型或<code class="codeph">REF</code> ，必须使用绑定句柄进行其他调用，以设置特定于数据类型的属性。有关记录，集合和布尔值的信息，请参阅注释。对于命名数据类型<code class="codeph">SQLT_CHR</code> ， <code class="codeph">OCIBindByPos2()</code>在实际长度为0时修剪尾随空白。指定实际长度以防止修剪尾随空白。
                           </p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-5C505821-323D-473D-825B-448C8D9A6702__GUID-8EC8CD74-ADDA-45D8-8B82-E3D2BBF52CCB"><!-- --></a> indp（IN / OUT）</dt>
                        <dd>
                           <p>指向变量或数组的指针。对于所有数据类型，这是指向<code class="codeph">sb2</code>或<code class="codeph">sb2</code>值数组的指针。唯一的例外是SQLT_NTY，其中忽略此指针，并且<code class="codeph">OCIBindObject()</code>初始化指向结构或指标结构数组的实际指针。动态绑定将忽略<code class="codeph">indp</code>参数。如果<code class="codeph">valuep</code>是<code class="codeph">OUT</code>参数，则必须将<code class="codeph">indp</code>设置为指向<code class="codeph">OCI_IND_NULL</code> 。</p>
                           <div class="infoboxnotealso" id="GUID-5C505821-323D-473D-825B-448C8D9A6702__GUID-670D44FF-57C0-492C-8141-C1E48373841F">
                              <p class="notep1">也可以看看：</p>
                              <p><a href="oci-programming-basics.html#GUID-9966EDF7-37ED-42E5-AE57-67E394245BFA" title="每个绑定和定义OCI调用都有一个参数，它将指示符变量或指示符变量数组与DML语句，PL / SQL语句或查询相关联。">指标变量</a></p>
                           </div>
                        </dd>
                        <dt class="dlterm"><a name="GUID-5C505821-323D-473D-825B-448C8D9A6702__GUID-C5B90FFE-6BCB-4354-9128-CD6CDBA8CC2B"><!-- --></a> alenp（IN / OUT）</dt>
                        <dd>
                           <p>指向数组元素实际长度数组的指针。</p>
                           <p>当使用<code class="codeph">OCIEnvNlsCreate()</code> （推荐的OCI环境句柄创建接口）时， <code class="codeph">alenp</code>长度始终以字节为单位（对于IN绑定）并以字节为单位报告为OUT绑定。对于<code class="codeph">SQLT_VCS</code> （2字节长度前缀）和<code class="codeph">SQLT_LVC</code> （4字节长度前缀）类型中的长度前缀，同样的处理也一致。UCS2或NCHAR案例没有特殊例外。
                           </p>
                           <p>当较旧的OCI环境句柄创建界面被使用（或者<code class="codeph">OCIEnvCreate()</code>或弃用<code class="codeph">OCIEnvInit()</code> <code class="codeph">alenp</code>长度在一般字节。但是，对于IN绑定的字符，预期<code class="codeph">alenp</code>长度，并且仅当字符集为OCI_UC2ID（= OCI_UTF16ID）或在相应的OCIBind句柄上设置<code class="codeph">OCI_ATTR_CHAR_COUNT</code>属性时， <code class="codeph">OCI_ATTR_CHAR_COUNT</code>以OUT绑定的字符报告。对于<code class="codeph">SQLT_VCS</code> （2字节长度前缀）和<code class="codeph">SQLT_LVC</code> （4字节长度前缀）类型中的长度前缀，同样的处理方式也适用。
                           </p>
                           <p>动态绑定将忽略此参数。</p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-5C505821-323D-473D-825B-448C8D9A6702__GUID-387A723A-B1B1-486B-B40A-C18CB22BB0D1"><!-- --></a> rcodep（OUT）</dt>
                        <dd>
                           <p>指向列级返回码数组的指针。动态绑定将忽略此参数。</p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-5C505821-323D-473D-825B-448C8D9A6702__GUID-65A4EFD5-34AA-4F8D-AA91-05BFDD2C48FA"><!-- --></a> maxarr_len（IN）</dt>
                        <dd>
                           <p>最大数组长度参数（用户数组可容纳的最大可能元素数）。仅用于PL / SQL索引表绑定。</p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-5C505821-323D-473D-825B-448C8D9A6702__GUID-EFF4716A-7F05-4784-8EB9-C258C078887C"><!-- --></a> curelep（IN / OUT）</dt>
                        <dd>
                           <p>当前数组长度参数（指向执行操作之前或之后数组中元素的实际数量的指针）。仅用于PL / SQL索引表绑定。</p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-5C505821-323D-473D-825B-448C8D9A6702__GUID-F8F21BA3-7614-4092-942C-6F7E186815A3"><!-- --></a>模式（IN）</dt>
                        <dd>
                           <p>此参数的有效模式为：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">OCI_DEFAULT</code> - 这是默认模式。
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">OCI_BIND_SOFT</code> - 软绑定模式。此模式可提高呼叫的性能。如果这是第一个绑定或某个输入值（如<code class="codeph">dty</code>或<code class="codeph">value_sz</code> ）从先前绑定更改，则忽略此模式。如果未执行该语句，则返回错误。如果传递的绑定句柄无效，则会导致意外的行为。
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">OCI_DATA_AT_EXEC</code> - 选择此模式时， <code class="codeph">value_sz</code>参数定义可在运行时提供的数据的最大大小。应用程序必须随时可以随时和任意次数提供OCI库运行时IN数据缓冲区。运行时数据以下列方式之一提供：</p>
                                 <ul style="list-style-type:disc">
                                    <li>
                                       <p>使用用户定义函数的回调，必须在后续调用<code class="codeph">OCIBindDynamic()</code> 。
                                       </p>
                                    </li>
                                    <li>
                                       <p>使用OCI提供的调用的轮询机制。如果未定义回调，则假定使用此模式。</p>
                                       <div class="infoboxnotealso" id="GUID-5C505821-323D-473D-825B-448C8D9A6702__GUID-2DAD1730-1192-44FB-9CFE-C34F3D473C15">
                                          <p class="notep1">也可以看看：</p>
                                          <p>有关使用<code class="codeph">OCI_DATA_AT_EXEC</code>模式的更多信息，请<code class="codeph">OCI_DATA_AT_EXEC</code> <a href="binding-and-defining-in-oci.html#GUID-6C5EA0C6-0C1D-4CD5-B47F-1B95B4E9C558" title="您可以使用OCI执行分段插入，更新和数据提取。">OCI中的运行时数据分配和分段操作</a></p>
                                       </div>
                                       <p>当<code class="codeph">mode</code>设置为<code class="codeph">OCI_DATA_AT_EXEC</code> ，不要在main调用中为<code class="codeph">valuep</code> ， <code class="codeph">indp</code> ， <code class="codeph">alenp</code>和<code class="codeph">rcodep</code>提供值。为<code class="codeph">indp</code>和<code class="codeph">alenp</code>传递零（0）。通过使用<code class="codeph">OCIBindDynamic()</code>注册的回调函数提供值。
                                       </p>
                                    </li>
                                 </ul>
                              </li>
                              <li>
                                 <p><code class="codeph">OCI_IOV</code> - 绑定不连续的数据地址。<code class="codeph">valuep</code>参数必须是<code class="codeph">OCIIOV *</code>类型。此模式旨在用于分散或聚集绑定，这允许将多个缓冲区绑定或定义到某个位置，例如，一个缓冲区中前10行的列A，一个缓冲区中的后5行，其余25个另一个缓冲区中的行。这样就无需在执行数组执行操作时将所有这些分配并复制到一个大缓冲区中。
                                 </p>
                                 <div class="infoboxnotealso" id="GUID-5C505821-323D-473D-825B-448C8D9A6702__GUID-35AFF3A9-12BB-4DBA-BE5D-C96ABE5B6A88">
                                    <p class="notep1">也可以看看：</p>
                                    <p><a href="binding-and-defining-in-oci.html#GUID-CC67A87C-A39A-400A-BF95-C32363DCD589" title="您可以指定多个缓冲区以用于单个绑定或定义调用。">关于绑定和定义多个缓冲区</a></p>
                                 </div>
                              </li>
                           </ul>
                        </dd>
                     </dl>
                     <p>当不再需要分配的缓冲区时，它们应该被客户端释放。</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-5C505821-323D-473D-825B-448C8D9A6702__GUID-9E688B8D-B6CB-41B5-BE16-26F6F5EDB232">评论</p>
                     <p>此调用用于执行基本绑定操作。bind在程序变量的地址和SQL语句或PL / SQL块中的占位符之间创建关联。绑定调用还指定了绑定的数据类型，还可以指示在运行时提供数据的方法。</p>
                     <p>此函数还隐式分配<code class="codeph">bindpp</code>参数指示的绑定句柄。如果在<code class="codeph">**bindpp</code>传递非<code class="codeph">NULL</code>指针，则OCI假定这指向先前已通过调用<code class="codeph">OCIHandleAlloc()</code>或<code class="codeph">OCIBindByPos2()</code>分配的有效句柄。
                     </p>
                     <p>OCI应用程序中的数据可以静态或动态地绑定到占位符。当所有IN绑定数据和OUT绑定缓冲区在执行操作之前很好地定义时，绑定是<span class="italic">静态的</span> 。当IN绑定数据和OUT绑定缓冲区由应用程序在执行时按需提供给客户端库时，绑定是<span class="italic">动态的</span> 。通过将此调用的<code class="codeph">mode</code>参数设置为<code class="codeph">OCI_DATA_AT_EXEC</code>来指示动态绑定。</p>
                     <div class="infoboxnotealso" id="GUID-5C505821-323D-473D-825B-448C8D9A6702__GUID-F0003ECB-6B97-42CF-B5A4-9CD43CE85D12">
                        <p class="notep1">也可以看看：</p>
                        <p>有关动态绑定的更多信息，请参阅<a href="binding-and-defining-in-oci.html#GUID-6C5EA0C6-0C1D-4CD5-B47F-1B95B4E9C558" title="您可以使用OCI执行分段插入，更新和数据提取。">OCI中的运行时数据分配和分段操作</a></p>
                     </div>
                     <p><code class="codeph">OCIBindByName2()</code>和<code class="codeph">OCIBindByPos2()</code>将绑定句柄作为参数，绑定句柄由绑定调用隐式分配。为应用程序绑定的每个占位符分配单独的绑定句柄。
                     </p>
                     <p>可能需要额外的绑定调用来指定绑定某些数据类型或以某些方式处理输入数据时所需的特定属性：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>如果正在使用结构数组，则必须调用<code class="codeph">OCIBindArrayOfStruct()</code>来设置必要的跳过参数。
                           </p>
                        </li>
                        <li>
                           <p>如果在运行时动态提供数据，并且应用程序使用用户定义的回调函数， <code class="codeph">OCIBindDynamic()</code>必须调用<code class="codeph">OCIBindDynamic()</code>来注册回调。
                           </p>
                        </li>
                        <li>
                           <p>如果<code class="codeph">alenp</code>长度大于64 KB，请使用<code class="codeph">OCIBindDynamic()</code> 。
                           </p>
                        </li>
                        <li>
                           <p>如果绑定了命名数据类型，则必须调用<code class="codeph">OCIBindObject()</code>以指定其他必要信息。
                           </p>
                        </li>
                        <li>
                           <p>如果用一个声明<code class="codeph">RETURNING</code>使用条款，将呼叫<code class="codeph">OCIBindDynamic()</code>必须遵循这一呼吁。
                           </p>
                        </li>
                     </ul>
                     <p>使用IN绑定时，必须在调用<code class="codeph">OCIStmtExecute()</code>之前设置数组的每个元素的值，每个元素的实际长度以及实际的数组长度。
                     </p>
                     <p>使用OUT绑定时，在<code class="codeph">OCIStmtExecute()</code>调用之后， <code class="codeph">OCIStmtExecute()</code>服务器返回数组的每个元素的值，每个元素的实际长度以及实际的数组长度。
                     </p>
                     <dl>
                        <dt class="dlterm"><a name="GUID-5C505821-323D-473D-825B-448C8D9A6702__GUID-6ABA34DA-F7B1-4DB5-87F3-8483EACFC66E"><!-- --></a>对于唱片</dt>
                        <dd>
                           <p>客户端必须使用<code class="codeph">SQLT_NTY</code>绑定包记录类型作为绑定的DTY。在OCI客户端中，对象和记录表示为命名类型（NTY），并且必须使用相同的<code class="codeph">SQLT</code>代码。
                           </p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-5C505821-323D-473D-825B-448C8D9A6702__GUID-2973CAB8-82E2-4F65-861B-5B88FDB092DD"><!-- --></a>收藏</dt>
                        <dd>
                           <p>客户端必须使用<code class="codeph">SQLT_NTY</code>绑定所有包集合类型。这是用于绑定所有模式级别集合类型的DTY。
                           </p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-5C505821-323D-473D-825B-448C8D9A6702__GUID-B122E293-7FC0-45C5-A784-6F1947EC591E"><!-- --></a>对于布尔人</dt>
                        <dd>
                           <p>客户端必须使用<code class="codeph">SQLT_BOL</code>绑定布尔类型（ <code class="codeph">OCI_TYPECODE_BOOLEAN</code> ）。</p>
                        </dd>
                     </dl>
                  </div>
                  <!-- class="section" -->
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="bind-define-describe-functions.html#GUID-030270CB-346A-412E-B3B3-556DD6947BE2" title="注册用户回调以进行动态数据分配。">OCIBindDynamic（）</a></li>
                        <li><a href="bind-define-describe-functions.html#GUID-384B5D31-165B-4661-A334-8C2B5E475AEF" title="设置命名数据类型（对象）绑定所需的其他属性。">OCIBindObject（）</a></li>
                        <li><a href="bind-define-describe-functions.html#GUID-E83BF668-88FC-4F31-A950-3580B79588E0" title="设置静态数组绑定的跳过参数。">OCIBindArrayOfStruct（）</a></li>
                        <li><a href="bind-define-describe-functions.html#GUID-D28DF5A7-3C75-4E52-82F7-A5D6D5714E69" title="在SQL语句或PL / SQL块中创建程序变量和占位符之间的关联。">OCIBindByPos（）</a></li>
                        <li><a href="connect-authorize-and-initialize-functions.html#GUID-16BDA1F1-7DAF-41CA-9EE1-C9A4CB467244" title="创建并初始化OCI函数的环境句柄。">OCIEnvCreate（）</a></li>
                        <li><a href="connect-authorize-and-initialize-functions.html#GUID-0B6911A9-4B46-476C-BC5E-B87581666CD9" title="创建并初始化OCI函数的环境句柄。">OCIEnvNlsCreate（）</a></li>
                        <li><a href="deprecated-oci-functions.html#GUID-1AC89920-7DB1-46AC-BBAA-9854DDAD6AB7" title="在Oracle Database 11g第2版（11.2）之前的版本中不推荐使用此功能。">OCIEnvInit（）</a></li>
                        <li><a href="handle-and-descriptor-functions.html#GUID-C5BF55F7-A110-4CB5-9663-5056590F12B5" title="返回指向已分配和初始化句柄的指针。">OCIHandleAlloc（）</a></li>
                        <li><a href="bind-define-describe-functions.html#GUID-55C47708-5468-4106-89BE-1AB60861D037" title="在SQL语句或PL / SQL块中创建程序变量和占位符之间的关联。当客户端上的实际长度超过UB2MAXVAL时，在处理数据类型时使用此函数。">OCIBindByName2（）</a></li>
                        <li><a href="statement-functions.html#GUID-98B26708-3E02-45C0-8258-5D5544F32BE9" title="将应用程序请求与服务器关联。">OCIStmtExecute（）</a></li>
                        <li><a href="miscellaneous-functions.html#GUID-4B99087C-74F6-498A-8310-D6645172390A" title="返回错误消息和Oracle数据库错误代码。">OCIErrorGet（）</a></li>
                     </ul>
                  </div>
               </div>
               
            </div><a id="LNOCI17142"></a><div class="props_rev_3"><a id="GUID-030270CB-346A-412E-B3B3-556DD6947BE2" name="GUID-030270CB-346A-412E-B3B3-556DD6947BE2"></a><h3 id="LNOCI-GUID-030270CB-346A-412E-B3B3-556DD6947BE2" class="sect3"><span class="enumeration_section">25.4.6</span> OCIBindDynamic（）</h3>
               <div>
                  <p>注册用户回调以进行动态数据分配。</p>
                  <div class="section">
                     <p class="subhead2" id="GUID-030270CB-346A-412E-B3B3-556DD6947BE2__GUID-9D65CEA0-8837-4350-ABAA-6B89C3704F7E">目的</p>
                     <p>注册用户回调以进行动态数据分配。</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-030270CB-346A-412E-B3B3-556DD6947BE2__GUID-D65F3E50-E98D-46A7-AAEC-E7AE71731744">句法</p><pre class="oac_no_warn" dir="ltr">剑OCIBindDynamic（OCIBind * bindp，OCIError * errhp，void * ictxp，OCICallbackInBind（icbfp）（void * ictxp，OCIBind * bindp，ub4 iter，ub4 index，void ** bufpp，ub4 * alenp，ub1 * piecep，void ** indpp），void * octxp，OCICallbackOutBind（ocbfp）（void * octxp，OCIBind * bindp，ub4 iter，ub4 index，void ** bufpp，ub4 ** alenpp，ub1 * piecep，void ** indpp，ub2 ** rcodepp） ）;</pre></div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-030270CB-346A-412E-B3B3-556DD6947BE2__GUID-97B9D567-01C0-495F-B56C-9519372CC39D">参数</p>
                     <dl>
                        <dt class="dlterm"><a name="GUID-030270CB-346A-412E-B3B3-556DD6947BE2__GUID-115BFEDF-C324-4055-8C8E-39901B2D9C06"><!-- --></a> bindp（IN / OUT）</dt>
                        <dd>
                           <p>通过调用<code class="codeph">OCIBindByName()</code>或<code class="codeph">OCIBindByPos()</code>返回的绑定句柄。
                           </p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-030270CB-346A-412E-B3B3-556DD6947BE2__GUID-63BBF7F4-DE34-49B0-AD9C-84B7BA8921A6"><!-- --></a> errhp（IN / OUT）</dt>
                        <dd>
                           <p>一个错误句柄，您可以在出现错误时传递给<code class="codeph">OCIErrorGet()</code>以获取诊断信息。
                           </p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-030270CB-346A-412E-B3B3-556DD6947BE2__GUID-DE15C00A-BC78-4ECF-957E-F5CF16EB8906"><!-- --></a> ictxp（IN）</dt>
                        <dd>
                           <p>回调函数<code class="codeph">icbfp</code>所需的上下文指针。
                           </p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-030270CB-346A-412E-B3B3-556DD6947BE2__GUID-6DCDCA8E-CBD8-4949-A9B8-493C4E736C4C"><!-- --></a> icbfp（IN）</dt>
                        <dd>
                           <p>回调函数，它在运行时返回指向IN绑定值或片段的指针。回调采用以下参数：</p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-030270CB-346A-412E-B3B3-556DD6947BE2__GUID-1A622DC3-34DA-4976-8E94-5BF6D5EEEDBA"><!-- --></a> ictxp（IN / OUT）</dt>
                        <dd>
                           <p>此回调函数的上下文指针。</p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-030270CB-346A-412E-B3B3-556DD6947BE2__GUID-DAC40372-B400-4E03-B05E-34FC48D4F0B9"><!-- --></a> bindp（IN）</dt>
                        <dd>
                           <p>传入绑定句柄以唯一标识此绑定变量。</p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-030270CB-346A-412E-B3B3-556DD6947BE2__GUID-80AAC6A2-B855-43B1-9D22-02CE84CE3C4A"><!-- --></a> iter（IN）</dt>
                        <dd>
                           <p>基于0的执行迭代值。</p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-030270CB-346A-412E-B3B3-556DD6947BE2__GUID-9B0746CA-7109-49A0-ABED-EC55190FBD55"><!-- --></a>索引（IN）</dt>
                        <dd>
                           <p>PL / SQL中数组绑定的当前数组的索引。对于SQL，它是行索引。该值基于0且不大于绑定调用的<code class="codeph">curelep</code>参数。
                           </p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-030270CB-346A-412E-B3B3-556DD6947BE2__GUID-B4996925-1519-43F8-8C7B-32E079AB6717"><!-- --></a> bufpp（OUT）</dt>
                        <dd>
                           <p>指向缓冲区或存储区的指针。对于描述符， <code class="codeph">*bufpp</code>包含指向描述符的指针。例如，如果您定义以下参数，则将<code class="codeph">*bufpp</code>设置为<code class="codeph">lobp</code> ，而不是<code class="codeph">*lobp</code> 。
                           </p><pre class="oac_no_warn" dir="ltr">OCILobLocator * lobp;</pre><p>对于<code class="codeph">REF</code> ，请传递ref的地址;也就是说，传递<code class="codeph">&amp;my_ref</code>为<code class="codeph">*bufpp</code> 。
                           </p>
                           <p>如果<code class="codeph">OCI_ATTR_CHARSET_ID</code>属性设置为<code class="codeph">OCI_UTF16ID</code> （替换为了向后兼容而保留的已弃用的<code class="codeph">OCI_UCS2ID</code> ），则假定传递给相应绑定调用并通过相应绑定调用接收的所有数据都采用<code class="codeph">UTF-16</code>编码。
                           </p>
                           <div class="infoboxnotealso" id="GUID-030270CB-346A-412E-B3B3-556DD6947BE2__GUID-7AAC3CE7-FD51-47A7-8607-62A3158314D6">
                              <p class="notep1">也可以看看：</p>
                              <p><a href="handle-and-descriptor-attributes.html#GUID-01C53C14-CD15-4A8B-9EFF-86996282F3BD" title="列出并描述绑定句柄属性。">绑定句柄属性</a></p>
                           </div>
                        </dd>
                        <dt class="dlterm"><a name="GUID-030270CB-346A-412E-B3B3-556DD6947BE2__GUID-94DBEEA9-95E5-4045-BD43-2829EB6005EE"><!-- --></a> alenp（OUT）</dt>
                        <dd>
                           <p>指向OCI存储的指针，用于在读取后填充绑定值或块的大小。对于描述符，将指针的大小传递给描述符;例如， <code class="codeph">sizeof(OCILobLocator *)</code> 。
                           </p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-030270CB-346A-412E-B3B3-556DD6947BE2__GUID-B559B5D0-564C-4438-ADB4-C8DFB320D1DE"><!-- --></a> piecep（OUT）</dt>
                        <dd>
                           <p>一段绑定值。这可以是以下值之一： <code class="codeph">OCI_ONE_PIECE</code> ， <code class="codeph">OCI_FIRST_PIECE</code> ， <code class="codeph">OCI_NEXT_PIECE</code>和<code class="codeph">OCI_LAST_PIECE</code> 。对于不支持分段操作的数据类型，必须传递<code class="codeph">OCI_ONE_PIECE</code>或生成错误。
                           </p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-030270CB-346A-412E-B3B3-556DD6947BE2__GUID-04BA76F2-C93C-48D3-A498-8D6985199A1C"><!-- --></a> indpp（OUT）</dt>
                        <dd>
                           <p>包含指标值。这是指向sb2值的指针或指向用于绑定指定数据类型的指示符结构的指针。</p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-030270CB-346A-412E-B3B3-556DD6947BE2__GUID-80217154-8987-43DE-BE4C-24AEB0CAC839"><!-- --></a> octxp（IN）</dt>
                        <dd>
                           <p>回调函数<code class="codeph">ocbfp()</code>所需的上下文指针。
                           </p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-030270CB-346A-412E-B3B3-556DD6947BE2__GUID-25E70A17-7145-4A2F-9E72-C36FAD1706D5"><!-- --></a> ocbfp（IN）</dt>
                        <dd>
                           <p>回调函数，它在运行时返回指向OUT绑定值或块的指针。回调采用以下参数：</p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-030270CB-346A-412E-B3B3-556DD6947BE2__GUID-815A1659-BF83-4A2B-B3BC-EB04A628F1D5"><!-- --></a> octxp（IN / OUT）</dt>
                        <dd>
                           <p>此回调函数的上下文指针。</p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-030270CB-346A-412E-B3B3-556DD6947BE2__GUID-137D168E-0202-49DE-896F-2968A6C02F91"><!-- --></a> bindp（IN）</dt>
                        <dd>
                           <p>传入绑定句柄以唯一标识此绑定变量。</p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-030270CB-346A-412E-B3B3-556DD6947BE2__GUID-2353E203-9B59-4A70-8848-3C93D9E7F8A6"><!-- --></a> iter（IN）</dt>
                        <dd>
                           <p>基于0的执行迭代值。</p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-030270CB-346A-412E-B3B3-556DD6947BE2__GUID-F86EF9B4-B4AD-4225-8E23-B19CFC7610C0"><!-- --></a>索引（IN）</dt>
                        <dd>
                           <p>对于PL / SQL，数组绑定的当前数组的索引。对于SQL，索引是当前迭代中的行号。它基于0，并且不得大于bind调用的<code class="codeph">curelep</code>参数。
                           </p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-030270CB-346A-412E-B3B3-556DD6947BE2__GUID-199710F8-D6A2-4AD7-97A9-892A8A416F63"><!-- --></a> bufpp（OUT）</dt>
                        <dd>
                           <p>指向缓冲区的指针，用于写入绑定值或片段。</p>
                           <p>如果<code class="codeph">OCI_ATTR_CHARSET_ID</code>属性设置为<code class="codeph">OCI_UTF16ID</code> （替换为了向后兼容而保留的已弃用的<code class="codeph">OCI_UCS2ID</code> ），则假定传递给相应绑定调用并通过相应绑定调用接收的所有数据都采用<code class="codeph">UTF-16</code>编码。有关更多信息，请参阅<span class="q">“ <a href="handle-and-descriptor-attributes.html#GUID-01C53C14-CD15-4A8B-9EFF-86996282F3BD" title="列出并描述绑定句柄属性。">绑定句柄属性</a> ”</span> 。
                           </p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-030270CB-346A-412E-B3B3-556DD6947BE2__GUID-AC4EAD10-3E76-482F-B9BD-495FFE6C154F"><!-- --></a> alenpp（IN / OUT）</dt>
                        <dd>
                           <p>指向OCI存储的指针，用于在读取后填充绑定值或块的大小。除了Unicode编码（如果<code class="codeph">OCI_ATTR_CHARSET_ID</code>属性设置为<code class="codeph">OCI_UTF16ID</code> ），它是以字节为单位，当它在代码点中时。
                           </p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-030270CB-346A-412E-B3B3-556DD6947BE2__GUID-29A45C43-28E7-4114-86B6-FFF80CFA46A4"><!-- --></a> piecep（IN / OUT）</dt>
                        <dd>
                           <p>返回从回调（应用程序）到Oracle数据库的片段值，如下所示：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">IN</code> - 值可以是<code class="codeph">OCI_ONE_PIECE</code>或<code class="codeph">OCI_NEXT_PIECE</code> 。</p>
                              </li>
                              <li>
                                 <p><code class="codeph">OUT</code> - 取决于IN值：</p>
                                 <ul style="list-style-type:disc">
                                    <li>
                                       <p>如果IN值为<code class="codeph">OCI_ONE_PIECE</code> ，则OUT值可以是<code class="codeph">OCI_ONE_PIECE</code>或<code class="codeph">OCI_FIRST_PIECE</code> 。</p>
                                    </li>
                                    <li>
                                       <p>如果IN值是<code class="codeph">OCI_NEXT_PIECE</code> ，则OUT值可以是<code class="codeph">OCI_NEXT_PIECE</code>或<code class="codeph">OCI_LAST_PIECE</code> 。</p>
                                    </li>
                                 </ul>
                              </li>
                           </ul>
                        </dd>
                        <dt class="dlterm"><a name="GUID-030270CB-346A-412E-B3B3-556DD6947BE2__GUID-40518F9F-D818-401A-B5C8-813B526BF388"><!-- --></a> indpp（OUT）</dt>
                        <dd>
                           <p>包含指标值。这是指向<code class="codeph">sb2</code>值的指针，或指向用于绑定命名数据类型的指示符结构的指针。
                           </p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-030270CB-346A-412E-B3B3-556DD6947BE2__GUID-5671694F-DEA8-42C9-AD8A-0B16B2DE4059"><!-- --></a> rcodepp（OUT）</dt>
                        <dd>
                           <p>返回指向返回码的指针。</p>
                        </dd>
                     </dl>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-030270CB-346A-412E-B3B3-556DD6947BE2__GUID-29EFFAE2-8583-4390-AD10-8D36F63AC235">评论</p>
                     <p>如果在先前对<code class="codeph">OCIBindByName()</code>或<code class="codeph">OCIBindByPos()</code>调用中指定了<code class="codeph">OCI_DATA_AT_EXEC</code>模式，则此调用用于注册用户定义的回调函数以提供或接收数据。
                     </p>
                     <p>如果调用成功，则回调函数指针必须返回<code class="codeph">OCI_CONTINUE</code> 。除<code class="codeph">OCI_CONTINUE</code>之外的任何返回代码都表示客户端希望立即终止处理。
                     </p>
                     <div class="infoboxnotealso" id="GUID-030270CB-346A-412E-B3B3-556DD6947BE2__GUID-2ED0FBEB-A75C-477D-8085-4143E49351F7">
                        <p class="notep1">也可以看看：</p>
                        <p>有关<code class="codeph">OCI_DATA_AT_EXEC</code>模式的更多信息，请<code class="codeph">OCI_DATA_AT_EXEC</code> <a href="binding-and-defining-in-oci.html#GUID-6C5EA0C6-0C1D-4CD5-B47F-1B95B4E9C558" title="您可以使用OCI执行分段插入，更新和数据提取。">OCI中的运行时数据分配和分段操作</a></p>
                     </div>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p>传递存储区域的地址时，即使应用程序从回调中返回，也要确保存储区域存在。这意味着您不应该在堆栈上分配此类存储。</p>
                     <div class="infoboxnote" id="GUID-030270CB-346A-412E-B3B3-556DD6947BE2__GUID-E2223B77-020A-4337-96B0-FF1585FD4226">
                        <p class="notep1">注意：</p>
                        <p>使用<code class="codeph">OCIEnvNlsCreate()</code>创建环境句柄后，bind和define句柄的实际长度和返回长度始终以字节数表示。
                        </p>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="bind-define-describe-functions.html#GUID-CD63DF78-2178-4727-A896-B9673C4A37F0" title="在SQL语句或PL / SQL块中创建程序变量和占位符之间的关联。">OCIBindByName（）</a></li>
                        <li><a href="bind-define-describe-functions.html#GUID-55C47708-5468-4106-89BE-1AB60861D037" title="在SQL语句或PL / SQL块中创建程序变量和占位符之间的关联。当客户端上的实际长度超过UB2MAXVAL时，在处理数据类型时使用此函数。">OCIBindByName2（）</a></li>
                        <li><a href="bind-define-describe-functions.html#GUID-D28DF5A7-3C75-4E52-82F7-A5D6D5714E69" title="在SQL语句或PL / SQL块中创建程序变量和占位符之间的关联。">OCIBindByPos（）</a></li>
                        <li><a href="bind-define-describe-functions.html#GUID-5C505821-323D-473D-825B-448C8D9A6702" title="在SQL语句或PL / SQL块中创建程序变量和占位符之间的关联。当客户端上的实际长度超过UB2MAXVAL时，在处理数据类型时使用此调用。">OCIBindByPos2（）</a></li>
                        <li><a href="miscellaneous-functions.html#GUID-4B99087C-74F6-498A-8310-D6645172390A" title="返回错误消息和Oracle数据库错误代码。">OCIErrorGet（）</a></li>
                     </ul>
                  </div>
               </div>
               
            </div><a id="LNOCI17143"></a><div class="props_rev_3"><a id="GUID-384B5D31-165B-4661-A334-8C2B5E475AEF" name="GUID-384B5D31-165B-4661-A334-8C2B5E475AEF"></a><h3 id="LNOCI-GUID-384B5D31-165B-4661-A334-8C2B5E475AEF" class="sect3"><span class="enumeration_section">25.4.7</span> OCIBindObject（）</h3>
               <div>
                  <p>设置命名数据类型（对象）绑定所需的其他属性。</p>
                  <div class="section">
                     <p class="subhead2" id="GUID-384B5D31-165B-4661-A334-8C2B5E475AEF__GUID-8A27C5AC-D379-4F2A-96BF-6F95C243F775">目的</p>
                     <p>设置命名数据类型（对象）绑定所需的其他属性。</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-384B5D31-165B-4661-A334-8C2B5E475AEF__GUID-B2119A5F-0DFD-48F4-9CA9-1A25CC1B20AC">句法</p><pre class="oac_no_warn" dir="ltr">sword OCIBindObject（OCIBind * bindp，OCIError * errhp，const OCIType * type，void ** pgvpp，ub4 * pvszsp，void ** indpp，ub4 * indszp，）;</pre></div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-384B5D31-165B-4661-A334-8C2B5E475AEF__GUID-EFAB4A31-91DF-42BD-A290-679C6938D354">参数</p>
                     <dl>
                        <dt class="dlterm"><a name="GUID-384B5D31-165B-4661-A334-8C2B5E475AEF__GUID-106CF460-DD83-46E7-B07A-A42E2D5867DC"><!-- --></a> <span class="bold">bindp</span> （IN / OUT）</dt>
                        <dd>
                           <p>通过调用<code class="codeph">OCIBindByName()</code>或<code class="codeph">OCIBindByName2()</code>或<code class="codeph">OCIBindByPos()</code>或<code class="codeph">OCIBindByPos2()</code>返回的绑定句柄。
                           </p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-384B5D31-165B-4661-A334-8C2B5E475AEF__GUID-06983C40-CE75-43D9-B8E9-9FA7FED97EE5"><!-- --></a> <span class="bold">errhp</span> （输入/输出）</dt>
                        <dd>
                           <p>一个错误句柄，您可以在出现错误时传递给<code class="codeph">OCIErrorGet()</code>以获取诊断信息。
                           </p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-384B5D31-165B-4661-A334-8C2B5E475AEF__GUID-EA80E854-5B59-4CA5-80B5-79E93DF82518"><!-- --></a> <span class="bold">类型</span> （IN）</dt>
                        <dd>
                           <p>指向描述绑定的程序变量类型的TDO。通过调用<code class="codeph">OCITypeByName()</code>检索。SQL中的<code class="codeph">REF</code>可选，但PL / SQL中的<code class="codeph">REF</code>需要。</p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-384B5D31-165B-4661-A334-8C2B5E475AEF__GUID-AFE74B36-CF12-4A35-9CC1-FEAA54AD5C87"><!-- --></a> <span class="bold">pgvpp</span> （IN / OUT）</dt>
                        <dd>
                           <p>程序变量缓冲区的地址。对于数组， <code class="codeph">pgvpp</code>指向一个地址数组。当bind变量也是OUT变量时，在对象缓存中分配OUT命名数据类型值或<code class="codeph">REF</code> ，并返回<code class="codeph">REF</code> 。
                           </p>
                           <p><code class="codeph">pgvpp</code>如果被忽略<code class="codeph">OCI_DATA_AT_EXEC</code>模式。然后在运行时请求指定的数据类型缓冲区。对于静态数组绑定，可以使用<code class="codeph">OCIBindArrayOfStruct()</code>调用指定跳过因子。跳过因子用于计算指向值的下一个指针的地址，指示符结构及其大小。
                           </p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-384B5D31-165B-4661-A334-8C2B5E475AEF__GUID-F76B0A04-C74C-4C9C-A78E-E64478EC08A5"><!-- --></a> <span class="bold">pvszsp</span> （OUT）[可选]</dt>
                        <dd>
                           <p>指向程序变量的大小。输入时不需要指定数据类型的大小。用于阵列， <code class="codeph">pvszsp</code>是阵列<code class="codeph">ub4</code>秒。返回时，对于OUT绑定变量，这指向指定数据类型和接收到的<code class="codeph">REF</code>的大小。 <code class="codeph">pvszsp</code>如果被忽略<code class="codeph">OCI_DATA_AT_EXEC</code>模式。然后在运行时获取缓冲区的大小。
                           </p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-384B5D31-165B-4661-A334-8C2B5E475AEF__GUID-59F266A6-D256-468A-8A52-850BE6AC5259"><!-- --></a> <span class="bold">indpp</span> （IN / OUT）[可选]</dt>
                        <dd>
                           <p>包含并行指示符结构的程序变量缓冲区的地址。对于数组， <code class="codeph">indpp</code>指向一个指针数组。当绑定变量也是OUT绑定变量时，在对象缓存中分配内存，以存储OUT指示符值。在执行操作结束时，当接收到所有OUT值时， <code class="codeph">indpp</code>指向这些新分配的指示符结构的指针。仅对SQLT_NTY绑定所必需。如果设置了<code class="codeph">OCI_DATA_AT_EXEC</code>模式，则忽略<code class="codeph">indpp</code>参数。然后在运行时请求指示符。
                           </p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-384B5D31-165B-4661-A334-8C2B5E475AEF__GUID-CACC9786-E9A0-4F74-ADAB-B1988C152B41"><!-- --></a> <span class="bold">indszp</span> （IN / OUT）</dt>
                        <dd>
                           <p>指向IN指标结构程序变量的大小。对于数组，它是<code class="codeph">sb2</code>的数组。在返回OUT绑定变量时，这指向接收的OUT指示符结构的大小。 <code class="codeph">indszp</code>如果被忽略<code class="codeph">OCI_DATA_AT_EXEC</code>模式。然后在运行时请求指标大小。
                           </p>
                        </dd>
                     </dl>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-384B5D31-165B-4661-A334-8C2B5E475AEF__GUID-5A57D5D3-7A00-407C-9180-C36E7987C3A1">评论</p>
                     <p>此函数设置用于绑定指定数据类型或<code class="codeph">REF</code>其他属性。如果在非对象模式下初始化OCI环境时调用此函数，则会返回错误。
                     </p>
                     <p>此调用将数据类型为<code class="codeph">OCIType</code>的类型描述符对象（TDO）作为参数，用于定义的命名数据类型。可以通过调用<code class="codeph">OCITypeByName()</code>来检索TDO。
                     </p>
                     <p>如果<code class="codeph">OCI_DATA_AT_EXEC</code>在指定模式<code class="codeph">OCIBindByName()</code>或<code class="codeph">OCIBindByName2()</code>或<code class="codeph">OCIBindByPos()</code>或<code class="codeph">OCIBindByPos2()</code>获得或者使用回调指针到IN缓冲器<code class="codeph">icbfp</code>在注册<code class="codeph">OCIBindDynamic()</code>调用或由<code class="codeph">OCIStmtSetPieceInfo()</code>呼叫。
                     </p>
                     <p>缓冲区是为OUT数据动态分配的。通过以下方式返回指向这些缓冲区的指针：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>调用<code class="codeph">ocbfp()</code>注册的<code class="codeph">OCIBindDynamic()</code> 
                           </p>
                        </li>
                        <li>
                           <p>在<code class="codeph">OCIStmtExecute()</code>返回<code class="codeph">OCI_NEED_DATA</code>时调用由<code class="codeph">OCIStmtSetPieceInfo()</code>传入的缓冲区中的缓冲区设置指针</p>
                        </li>
                     </ul>
                     <p>通过使用<code class="codeph">OCIObjectFree()</code>调用，必须在不使用时释放这些客户端库分配的缓冲区的内存。
                     </p>
                  </div>
                  <!-- class="section" -->
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="bind-define-describe-functions.html#GUID-CD63DF78-2178-4727-A896-B9673C4A37F0" title="在SQL语句或PL / SQL块中创建程序变量和占位符之间的关联。">OCIBindByName（）</a></li>
                        <li><a href="bind-define-describe-functions.html#GUID-55C47708-5468-4106-89BE-1AB60861D037" title="在SQL语句或PL / SQL块中创建程序变量和占位符之间的关联。当客户端上的实际长度超过UB2MAXVAL时，在处理数据类型时使用此函数。">OCIBindByName2（）</a></li>
                        <li><a href="bind-define-describe-functions.html#GUID-D28DF5A7-3C75-4E52-82F7-A5D6D5714E69" title="在SQL语句或PL / SQL块中创建程序变量和占位符之间的关联。">OCIBindByPos（）</a></li>
                        <li><a href="bind-define-describe-functions.html#GUID-5C505821-323D-473D-825B-448C8D9A6702" title="在SQL语句或PL / SQL块中创建程序变量和占位符之间的关联。当客户端上的实际长度超过UB2MAXVAL时，在处理数据类型时使用此调用。">OCIBindByPos2（）</a></li>
                        <li><a href="bind-define-describe-functions.html#GUID-E83BF668-88FC-4F31-A950-3580B79588E0" title="设置静态数组绑定的跳过参数。">OCIBindArrayOfStruct（）</a></li>
                        <li><a href="oci-type-information-accessor-functions.html#GUID-3534AABC-E347-4BC7-B220-0CAECDC9ECE7" title="获取现有TDO的最新版本。">OCITypeByName（）</a></li>
                        <li><a href="statement-functions.html#GUID-CDB6F3E3-0FB6-49A7-A8AE-83CD330A359F" title="设置分段操作的片段信息。">OCIStmtSetPieceInfo（）</a></li>
                        <li><a href="statement-functions.html#GUID-98B26708-3E02-45C0-8258-5D5544F32BE9" title="将应用程序请求与服务器关联。">OCIStmtExecute（）</a></li>
                        <li><a href="oci-pin-unpin-and-free-functions.html#GUID-0814B033-C25C-4B4C-8968-4C0B86C2E744" title="释放和取消对象实例。">OCIObjectFree（）</a></li>
                        <li><a href="miscellaneous-functions.html#GUID-4B99087C-74F6-498A-8310-D6645172390A" title="返回错误消息和Oracle数据库错误代码。">OCIErrorGet（）</a></li>
                     </ul>
                  </div>
               </div>
               
            </div><a id="LNOCI17144"></a><div class="props_rev_3"><a id="GUID-D3F74828-5DA7-48AD-A170-120AD547DEB3" name="GUID-D3F74828-5DA7-48AD-A170-120AD547DEB3"></a><h3 id="LNOCI-GUID-D3F74828-5DA7-48AD-A170-120AD547DEB3" class="sect3"><span class="enumeration_section">25.4.8</span> OCIDefineArrayOfStruct（）</h3>
               <div>
                  <p>指定静态数组定义所需的其他属性，用于结构数组（多行，多列）提取。</p>
                  <div class="section">
                     <p class="subhead2" id="GUID-D3F74828-5DA7-48AD-A170-120AD547DEB3__GUID-9855A354-4307-44A9-9E0E-EB9FA5905415">目的</p>
                     <p>指定静态数组定义所需的其他属性，用于结构数组（多行，多列）提取。</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-D3F74828-5DA7-48AD-A170-120AD547DEB3__GUID-034FE14D-E609-42BE-A9C0-21077B845648">句法</p><pre class="oac_no_warn" dir="ltr">剑OCIDefineArrayOfStruct（OCIDefine * defnp，OCIError * errhp，ub4 pvskip，ub4 indskip，ub4 rlskip，ub4 rcskip）;</pre></div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-D3F74828-5DA7-48AD-A170-120AD547DEB3__GUID-67B4D310-9A66-4807-9D8F-DC9058D39EBA">参数</p>
                     <dl>
                        <dt class="dlterm"><a name="GUID-D3F74828-5DA7-48AD-A170-120AD547DEB3__GUID-2F1DDB97-D524-4A12-B2C0-94498EF68EE1"><!-- --></a> <span class="bold">defnp</span> （IN / OUT）</dt>
                        <dd>
                           <p>通过调用<code class="codeph">OCIDefineByPos()</code>或<code class="codeph">OCIDefineByPos2()</code>返回的define结构的句柄。
                           </p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-D3F74828-5DA7-48AD-A170-120AD547DEB3__GUID-FC6B678D-5751-4689-B56D-6A05C19453B1"><!-- --></a> <span class="bold">errhp</span> （IN / OUT）</dt>
                        <dd>
                           <p>一个错误句柄，您可以在出现错误时传递给<code class="codeph">OCIErrorGet()</code>以获取诊断信息。
                           </p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-D3F74828-5DA7-48AD-A170-120AD547DEB3__GUID-BAF9D8B9-765A-496A-B30D-DB98FB9E3590"><!-- --></a> <span class="bold">pvskip</span> （IN）</dt>
                        <dd>
                           <p>跳过下一个数据值的参数。</p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-D3F74828-5DA7-48AD-A170-120AD547DEB3__GUID-6108F5F1-65D2-409B-8092-6D3070D6FD35"><!-- --></a> <span class="bold">indskip</span> （IN）</dt>
                        <dd>
                           <p>跳过下一个指标位置的参数。</p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-D3F74828-5DA7-48AD-A170-120AD547DEB3__GUID-0E8541CE-D0ED-4895-B749-3381AE2DB9FC"><!-- --></a> <span class="bold">rlskip</span> （IN）</dt>
                        <dd>
                           <p>跳过下一个返回长度值的参数。</p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-D3F74828-5DA7-48AD-A170-120AD547DEB3__GUID-96A228B6-F5C1-44A0-B047-9873072E4862"><!-- --></a> <span class="bold">rcskip</span> （IN）</dt>
                        <dd>
                           <p>跳过下一个返回码的参数。</p>
                        </dd>
                     </dl>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-D3F74828-5DA7-48AD-A170-120AD547DEB3__GUID-28CAC45B-7A2C-4BF8-9406-AB05EC415490">评论</p>
                     <p>此调用是在调用<code class="codeph">OCIDefineByPos()</code>或<code class="codeph">OCIDefineByPos2()</code>调用的。如果应用程序绑定涉及对象的结构数组，则必须首先调用<code class="codeph">OCIDefineObject()</code> ，然后调用<code class="codeph">OCIDefineArrayOfStruct()</code> 。
                     </p>
                  </div>
                  <!-- class="section" -->
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="bind-define-describe-functions.html#GUID-CFE5AA54-DEBC-42D3-8A27-AFF1E7815691" title="将选择列表中的项与类型和输出数据缓冲区相关联。">OCIDefineByPos（）</a></li>
                        <li><a href="bind-define-describe-functions.html#GUID-74939FB5-919E-4D24-B327-AFB532435061" title="将选择列表中的项与类型和输出数据缓冲区相关联。当客户端上的实际长度超过UB2MAXVAL时，在处理数据类型时使用此调用。">OCIDefineByPos2（）</a></li>
                        <li><a href="bind-define-describe-functions.html#GUID-F211198D-C88C-493B-A65E-2C2A95E6197B" title="设置命名数据类型或REF定义所需的其他属性。">OCIDefineObject（）</a></li>
                        <li><a href="miscellaneous-functions.html#GUID-4B99087C-74F6-498A-8310-D6645172390A" title="返回错误消息和Oracle数据库错误代码。">OCIErrorGet（）</a></li>
                     </ul>
                  </div>
                  <div class="infoboxnotealso" id="GUID-D3F74828-5DA7-48AD-A170-120AD547DEB3__GUID-B140861B-62A6-4FA9-BB44-A3567D4E9E35">
                     <p class="notep1">也可以看看：</p>
                     <p><a href="binding-and-defining-in-oci.html#GUID-5C52AF81-5D33-4C3F-BC89-0EFE9AC6E90A" title="在跨结构数组拆分列数据时，它不再连续存储在数据库中。">跳过参数</a></p>
                  </div>
               </div>
               
            </div><a id="LNOCI17145"></a><div class="props_rev_3"><a id="GUID-CFE5AA54-DEBC-42D3-8A27-AFF1E7815691" name="GUID-CFE5AA54-DEBC-42D3-8A27-AFF1E7815691"></a><h3 id="LNOCI-GUID-CFE5AA54-DEBC-42D3-8A27-AFF1E7815691" class="sect3"><span class="enumeration_section">25.4.9</span> OCIDefineByPos（）</h3>
               <div>
                  <p>将选择列表中的项与类型和输出数据缓冲区相关联。</p>
                  <div class="section">
                     <p class="subhead2" id="GUID-CFE5AA54-DEBC-42D3-8A27-AFF1E7815691__GUID-9AC7624D-4AE9-4D46-824F-96AB456BFDD6">目的</p>
                     <p>将选择列表中的项与类型和输出数据缓冲区相关联。</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-CFE5AA54-DEBC-42D3-8A27-AFF1E7815691__GUID-ADCD9DAD-5938-4B97-86C4-EFAF408D7480">句法</p><pre class="oac_no_warn" dir="ltr">剑OCIDefineByPos（OCIStmt * stmtp，OCIDefine ** defnpp，OCIError * errhp，ub4 position，void * valuep，sb4 value_sz，ub2 dty，void * indp，ub2 * rlenp，ub2 * rcodep，ub4 mode）;</pre></div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-CFE5AA54-DEBC-42D3-8A27-AFF1E7815691__GUID-73BADB39-5A00-4C6F-84EB-87CA3A1D2127">参数</p>
                     <dl>
                        <dt class="dlterm"><a name="GUID-CFE5AA54-DEBC-42D3-8A27-AFF1E7815691__GUID-DF83FF96-B6C7-4435-9A66-A8113628A77B"><!-- --></a> <span class="bold">stmtp</span> （IN / OUT）</dt>
                        <dd>
                           <p>请求的SQL查询操作的句柄。</p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-CFE5AA54-DEBC-42D3-8A27-AFF1E7815691__GUID-B186ABD9-BF58-486F-A67A-DD63E6B668A6"><!-- --></a> <span class="bold">defnpp</span> （IN / OUT）</dt>
                        <dd>
                           <p>指向定义句柄的指针。如果此参数作为<code class="codeph">NULL</code>传递，则此调用将隐式分配define句柄。对于重定义，可以在此参数中传递非<code class="codeph">NULL</code>句柄。此句柄用于存储此列的定义信息。
                           </p>
                           <div class="infoboxnote" id="GUID-CFE5AA54-DEBC-42D3-8A27-AFF1E7815691__GUID-424B1995-AA7E-46AD-AF5C-05B801C7B769">
                              <p class="notep1">注意：</p>
                              <p>你必须跟踪这个指针。如果对同一列位置进行第二次<code class="codeph">OCIDefineByPos()</code>调用，则无法保证将返回相同的指针。
                              </p>
                           </div>
                        </dd>
                        <dt class="dlterm"><a name="GUID-CFE5AA54-DEBC-42D3-8A27-AFF1E7815691__GUID-1447ACA1-968E-421E-91DA-88C2CC78C9C1"><!-- --></a> <span class="bold">errhp</span> （IN / OUT）</dt>
                        <dd>
                           <p>一个错误句柄，您可以在出现错误时传递给<code class="codeph">OCIErrorGet()</code>以获取诊断信息。
                           </p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-CFE5AA54-DEBC-42D3-8A27-AFF1E7815691__GUID-6E874CAD-F5DD-4736-A5D9-596889893349"><!-- --></a> <span class="bold">位置</span> （IN）</dt>
                        <dd>
                           <p>此值在选择列表中的位置。位置从1开始，从左到右编号。值0选择<code class="codeph">ROWID</code> （表中行的全局唯一标识符）。
                           </p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-CFE5AA54-DEBC-42D3-8A27-AFF1E7815691__GUID-D4317FAC-96C8-4BFC-9845-CF5E2A19964E"><!-- --></a> <span class="bold">valuep</span> （IN / OUT）</dt>
                        <dd>
                           <p>指向缓冲区或<code class="codeph">dty</code>参数中指定类型的缓冲区数组的指针。当在单个提取调用中需要多行的结果时，可以指定多个缓冲区。
                           </p>
                           <p>对于LOB，缓冲区指针必须是指向<code class="codeph">OCILobLocator</code>类型的LOB定位符的<code class="codeph">OCILobLocator</code> 。给出指针的地址。
                           </p>
                           <p>当<code class="codeph">mode</code>设置为<code class="codeph">OCI_IOV</code> ，传递<code class="codeph">OCIIOV</code>结构的基址。
                           </p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-CFE5AA54-DEBC-42D3-8A27-AFF1E7815691__GUID-0882C296-0A63-43BD-A531-30E0B9B6A12D"><!-- --></a> <span class="bold">value_sz</span> （IN）</dt>
                        <dd>
                           <p>每个<code class="codeph">valuep</code>缓冲区的大小（以字节为单位）。如果数据以VARCHAR2格式存储在内部，则可以使用<code class="codeph">OCIAttrSet()</code>指定所需的字符数（如果与缓冲区大小不同<code class="codeph">OCIAttrSet()</code> 。
                           </p>
                           <p>在多字节转换环境中，如果指定的字节数不足以处理所需的字符数，则会生成截断错误。</p>
                           <p>如果<code class="codeph">OCI_ATTR_CHARSET_ID</code>属性设置为<code class="codeph">OCI_UTF16ID</code> （替换为了向后兼容而保留的已弃用的<code class="codeph">OCI_UCS2ID</code> ），则假定传递给相应的define调用并通过相应的define调用接收的所有数据都采用<code class="codeph">UTF-16</code>编码。
                           </p>
                           <p>当<code class="codeph">mode</code>设置为<code class="codeph">OCI_IOV</code> ，传递数据值的大小。
                           </p>
                           <div class="infoboxnotealso" id="GUID-CFE5AA54-DEBC-42D3-8A27-AFF1E7815691__GUID-38447004-A0BA-4000-944A-05202C45CA91">
                              <p class="notep1">也可以看看：</p>
                              <p><a href="handle-and-descriptor-attributes.html#GUID-01C53C14-CD15-4A8B-9EFF-86996282F3BD" title="列出并描述绑定句柄属性。">绑定句柄属性</a></p>
                           </div>
                        </dd>
                     </dl>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <dl>
                        <dt class="dlterm"><a name="GUID-CFE5AA54-DEBC-42D3-8A27-AFF1E7815691__GUID-27238A01-7CC0-4D50-BEDD-C90C8D4C8A84"><!-- --></a> <span class="bold">dty</span> （IN）</dt>
                        <dd>
                           <p>数据类型。仅当在对象模式下初始化环境时，命名数据类型（SQLT_NTY）和<code class="codeph">REF</code> （SQLT_REF）才有效。
                           </p>
                           <p>可以为<code class="codeph">CLOB</code>列指定SQLT_CHR和SQLT_LNG，并且可以为<code class="codeph">BLOB</code>列指定SQLT_BIN和SQLT_LBI。
                           </p>
                           <div class="infoboxnotealso" id="GUID-CFE5AA54-DEBC-42D3-8A27-AFF1E7815691__GUID-EE48D44A-6A2B-4140-AA54-2C8124CA5B1F">
                              <p class="notep1">也可以看看：</p>
                              <p><a href="data-types.html#GUID-027FB2E2-593C-43F1-9184-DFEF7A984A27" title="本章提供OCI应用程序使用的Oracle外部数据类型的参考。">数据类型</a>代码和值列表的数据类型</p>
                           </div>
                        </dd>
                     </dl>
                     <dl>
                        <dt class="dlterm"><a name="GUID-CFE5AA54-DEBC-42D3-8A27-AFF1E7815691__GUID-A6D00ADB-D1C7-4236-9EAC-8A4B000F4A4C"><!-- --></a> <span class="bold">indp（IN）</span></dt>
                        <dd>
                           <p>指向变量或数组的指针。为标量数据类型，指针到<code class="codeph">sb2</code>或阵列<code class="codeph">sb2</code>秒。忽略SQLT_NTY定义。对于SQLT_NTY定义，指向指定数据类型指示符结构的指针或指定数据类型指示符结构的数组由后续<code class="codeph">OCIDefineObject()</code>调用关联。
                           </p>
                           <div class="infoboxnotealso" id="GUID-CFE5AA54-DEBC-42D3-8A27-AFF1E7815691__GUID-1A489604-8373-4A88-8E90-19D9D9504F1D">
                              <p class="notep1">也可以看看：</p>
                              <p><a href="oci-programming-basics.html#GUID-9966EDF7-37ED-42E5-AE57-67E394245BFA" title="每个绑定和定义OCI调用都有一个参数，它将指示符变量或指示符变量数组与DML语句，PL / SQL语句或查询相关联。">指标变量</a></p>
                           </div>
                        </dd>
                     </dl>
                     <dl>
                        <dt class="dlterm"><a name="GUID-CFE5AA54-DEBC-42D3-8A27-AFF1E7815691__GUID-EDB7F313-71C5-49B2-82F1-0ADF227E8D5D"><!-- --></a> <span class="bold">rlenp</span> （IN / OUT）</dt>
                        <dd>
                           <p>指向获取的数据长度数组的指针。</p>
                           <p>当使用<code class="codeph">OCIEnvNlsCreate()</code> （推荐的OCI环境句柄创建接口）时， <code class="codeph">rlenp</code>字节为单位一致地报告<code class="codeph">rlenp</code>长度。对于<code class="codeph">SQLT_VCS</code> （2字节长度前缀）和<code class="codeph">SQLT_LVC</code> （4字节长度前缀）类型中的长度前缀，同样的处理也一致。UCS2或NCHAR案例没有特殊例外。
                           </p>
                           <p>当较旧的OCI环境句柄创建界面被使用（或者<code class="codeph">OCIEnvCreate()</code>或弃用<code class="codeph">OCIEnvInit()</code> <code class="codeph">rlenp</code>长度在一般字节。但是，当字符集为OCI_UC2ID（= OCI_UTF16ID）或在相应的OCIBind句柄上设置<code class="codeph">OCI_ATTR_CHAR_COUNT</code>属性时，以字符报告<code class="codeph">rlenp</code>长度。对于<code class="codeph">SQLT_VCS</code> （2字节长度前缀）和<code class="codeph">SQLT_LVC</code> （4字节长度前缀）类型中的长度前缀，同样的处理方式也适用。
                           </p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-CFE5AA54-DEBC-42D3-8A27-AFF1E7815691__GUID-A4992923-FBFC-434A-8A28-1D6390D32B8B"><!-- --></a> <span class="bold">rcodep</span> （OUT）</dt>
                        <dd>
                           <p>指向列级返回码数组的指针。</p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-CFE5AA54-DEBC-42D3-8A27-AFF1E7815691__GUID-BE25E6BF-70F8-4288-A4AE-BBBF4FD06BFE"><!-- --></a> <span class="bold">模式</span> （IN）</dt>
                        <dd>
                           <p>有效模式是：</p>
                        </dd>
                     </dl>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">OCI_DEFAULT</code> - 这是默认模式。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">OCI_DEFINE_SOFT</code> - 软定义模式。此模式可提高呼叫的性能。如果这是第一个定义，或者某个输入参数（如<code class="codeph">dty</code>或<code class="codeph">value_sz</code> ）从先前的定义更改，则忽略此模式。如果传递了无效的定义句柄，则会导致意外的行为。如果未执行该语句，则返回错误。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">OCI_DYNAMIC_FETCH</code> - 对于在获取时需要动态分配数据的应用程序，必须使用此模式。您可以使用<code class="codeph">OCIDefineDynamic()</code>调用定义回调。<code class="codeph">value_sz</code>参数定义在运行时提供的数据的最大大小。当客户端库需要缓冲区来返回获取的数据时，将调用回调以提供运行时缓冲区，其中返回一个或所有数据。
                           </p>
                           <div class="infoboxnotealso" id="GUID-CFE5AA54-DEBC-42D3-8A27-AFF1E7815691__GUID-5712DA48-B896-440B-8763-DA3BADFF361C">
                              <p class="notep1">也可以看看：</p>
                              <p><a href="performance-topics.html#GUID-03884D82-8E0C-4CAB-84F4-4ED4D8D8674B" title="本节介绍以下主题：">ROWID的隐式提取</a></p>
                           </div>
                        </li>
                        <li>
                           <p><code class="codeph">OCI_IOV</code> - 定义不连续的数据地址。<code class="codeph">valuep</code>参数必须是<code class="codeph">OCIIOV *</code>类型。此模式旨在用于分散或聚集绑定，这允许将多个缓冲区绑定或定义到某个位置，例如，一个缓冲区中前10行的列A，一个缓冲区中的后5行，其余25个另一个缓冲区中的行。这样就无需在执行数组执行操作时将所有这些分配并复制到一个大缓冲区中。
                           </p>
                           <div class="infoboxnotealso" id="GUID-CFE5AA54-DEBC-42D3-8A27-AFF1E7815691__GUID-BC95A368-A6FB-41B1-A891-8914A8B044C1">
                              <p class="notep1">也可以看看：</p>
                              <p><a href="binding-and-defining-in-oci.html#GUID-CC67A87C-A39A-400A-BF95-C32363DCD589" title="您可以指定多个缓冲区以用于单个绑定或定义调用。">关于绑定和定义多个缓冲区</a></p>
                           </div>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-CFE5AA54-DEBC-42D3-8A27-AFF1E7815691__GUID-21AFFC70-859E-4CA4-A6F2-DE2969D5F797">评论</p>
                     <p>此调用定义一个输出缓冲区，用于接收从Oracle数据库检索的数据。定义是<code class="codeph">SELECT</code>语句将数据返回到OCI应用程序时必需的本地步骤。
                     </p>
                     <p>此调用还隐式为select-list项分配define句柄。如果在<code class="codeph">*defnpp</code>传递非<code class="codeph">NULL</code>指针，则OCI假定这指向先前已通过调用<code class="codeph">OCIHandleAlloc()</code>或<code class="codeph">OCIDefineByPos()</code>或<code class="codeph">OCIDefineByPos2()</code>分配的有效句柄。对于将句柄重新定义为不同地址的应用程序来说，这是正确的，这样它就可以为多个提取重用相同的定义句柄。
                     </p>
                     <p>为一次提取定义列的属性是在一次或多次调用中完成的。第一个调用是<code class="codeph">OCIDefineByPos()</code>或<code class="codeph">OCIDefineByPos2()</code> ，它定义了指定fetch所需的最小属性。
                     </p>
                     <p>在调用<code class="codeph">OCIDefineByPos()</code>或<code class="codeph">OCIDefineByPos2()</code>对于某些数据类型或获取模式可能需要额外的定义调用：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>需要调用<code class="codeph">OCIDefineArrayOfStruct()</code>来为多列的数组提取设置跳过参数。
                           </p>
                        </li>
                        <li>
                           <p>需要调用<code class="codeph">OCIDefineObject()</code>来设置命名数据类型（即对象或集合）或<code class="codeph">REF</code>提取的适当属性。在这种情况下， <code class="codeph">OCIDefineByPos()</code>或<code class="codeph">OCIDefineByPos2()</code>的数据缓冲区指针将被忽略。
                           </p>
                        </li>
                        <li>
                           <p>既<code class="codeph">OCIDefineArrayOfStruct()</code>和<code class="codeph">OCIDefineObject()</code>必须后调用<code class="codeph">OCIDefineByPos()</code>或<code class="codeph">OCIDefineByPos2()</code>与名为数据类型的一列来获取多行。
                           </p>
                        </li>
                     </ul>
                     <p>对于LOB定义，缓冲区指针必须是指向<code class="codeph">OCILobLocator</code>类型的LOB定位符的<code class="codeph">OCILobLocator</code> ，由<code class="codeph">OCIDescriptorAlloc()</code>调用分配。始终为LOB列返回LOB定位符，而不是LOB值。然后可以使用提取的定位器上的OCI LOB调用获取LOB值。这种机制适用于所有描述符数据类型。
                     </p>
                     <p>对于NCHAR（固定长度和变化长度），缓冲区指针必须指向足以保存所需NCHAR字符的字节数组。</p>
                     <p>嵌套表列的定义和提取方式与任何其他命名数据类型一样。</p>
                     <p>在定义描述符或定位符数组时，应该传入指向描述符或定位符的指针数组。</p>
                     <p>在为字符列执行数组定义时，应传入一个字符缓冲区数组。</p>
                     <p>如果此调用中的<code class="codeph">mode</code>参数设置为<code class="codeph">OCI_DYNAMIC_FETCH</code> ，则客户端应用程序可以在运行时动态获取数据。可以通过以下两种方式之一提供运行时数据：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>使用用户定义函数的回调，必须在后续调用<code class="codeph">OCIDefineDynamic()</code> 。当客户端库需要缓冲区来返回获取的数据时，将调用回调并且提供的运行时缓冲区将返回一个或所有数据。
                           </p>
                        </li>
                        <li>
                           <p>使用OCI提供的调用的轮询机制。如果未定义回调，则假定使用此模式。在这种情况下，fetch调用返回<code class="codeph">OCI_NEED_DATA</code>错误代码，并使用分段轮询方法来提供数据。
                           </p>
                           <div class="infoboxnotealso" id="GUID-CFE5AA54-DEBC-42D3-8A27-AFF1E7815691__GUID-A4B0FD77-6999-4A06-BC5F-70CCEAC4742A">
                              <p class="notep1">也可以看看：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>有关使用<code class="codeph">OCI_DYNAMIC_FETCH</code>模式的更多信息，请<code class="codeph">OCI_DYNAMIC_FETCH</code> <a href="binding-and-defining-in-oci.html#GUID-6C5EA0C6-0C1D-4CD5-B47F-1B95B4E9C558" title="您可以使用OCI执行分段插入，更新和数据提取。">OCI中的运行时数据分配和分段操作</a></p>
                                 </li>
                                 <li>
                                    <p>有关定义的更多信息，请参阅<a href="binding-and-defining-in-oci.html#GUID-8A09BC68-4C3D-4977-86C9-134F73121E26" title="Query语句将数据从数据库返回给您的应用程序。">在OCI中定义的概述</a></p>
                                 </li>
                                 <li>
                                    <p><a href="performance-topics.html#GUID-03884D82-8E0C-4CAB-84F4-4ED4D8D8674B" title="本节介绍以下主题：">ROWID的隐式提取</a> 
                                    </p>
                                 </li>
                              </ul>
                           </div>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="bind-define-describe-functions.html#GUID-D3F74828-5DA7-48AD-A170-120AD547DEB3" title="指定静态数组定义所需的其他属性，用于结构数组（多行，多列）提取。">OCIDefineArrayOfStruct（）</a></li>
                        <li><a href="bind-define-describe-functions.html#GUID-DD404526-9615-4E44-B790-1D17396C82A9" title="如果在OCIDefineByPos（）或OCIDefineByPos2（）中选择了OCI_DYNAMIC_FETCH模式，则设置所需的其他属性。">OCIDefineDynamic（）</a></li>
                        <li><a href="bind-define-describe-functions.html#GUID-F211198D-C88C-493B-A65E-2C2A95E6197B" title="设置命名数据类型或REF定义所需的其他属性。">OCIDefineObject（）</a></li>
                        <li><a href="bind-define-describe-functions.html#GUID-74939FB5-919E-4D24-B327-AFB532435061" title="将选择列表中的项与类型和输出数据缓冲区相关联。当客户端上的实际长度超过UB2MAXVAL时，在处理数据类型时使用此调用。">OCIDefineByPos2（）</a></li>
                        <li><a href="handle-and-descriptor-functions.html#GUID-3741D7BD-7652-4D7A-8813-AC2AEA8D3B03" title="设置句柄或描述符的属性值。">OCIAttrSet（）</a></li>
                        <li><a href="connect-authorize-and-initialize-functions.html#GUID-16BDA1F1-7DAF-41CA-9EE1-C9A4CB467244" title="创建并初始化OCI函数的环境句柄。">OCIEnvCreate（）</a></li>
                        <li><a href="connect-authorize-and-initialize-functions.html#GUID-0B6911A9-4B46-476C-BC5E-B87581666CD9" title="创建并初始化OCI函数的环境句柄。">OCIEnvNlsCreate（）</a></li>
                        <li><a href="deprecated-oci-functions.html#GUID-1AC89920-7DB1-46AC-BBAA-9854DDAD6AB7" title="在Oracle Database 11g第2版（11.2）之前的版本中不推荐使用此功能。">OCIEnvInit（）</a></li>
                        <li><a href="handle-and-descriptor-functions.html#GUID-C5BF55F7-A110-4CB5-9663-5056590F12B5" title="返回指向已分配和初始化句柄的指针。">OCIHandleAlloc（）</a></li>
                        <li><a href="handle-and-descriptor-functions.html#GUID-E9EF2766-E078-49A7-B1D1-738E4BA4814F" title="分配存储以保存描述符或LOB定位符。">OCIDescriptorAlloc（）</a></li>
                        <li><a href="miscellaneous-functions.html#GUID-4B99087C-74F6-498A-8310-D6645172390A" title="返回错误消息和Oracle数据库错误代码。">OCIErrorGet（）</a></li>
                     </ul>
                  </div>
               </div>
               
            </div><a id="LNOCI72807"></a><div class="props_rev_3"><a id="GUID-74939FB5-919E-4D24-B327-AFB532435061" name="GUID-74939FB5-919E-4D24-B327-AFB532435061"></a><h3 id="LNOCI-GUID-74939FB5-919E-4D24-B327-AFB532435061" class="sect3"><span class="enumeration_section">25.4.10</span> OCIDefineByPos2（）</h3>
               <div>
                  <p>将选择列表中的项与类型和输出数据缓冲区相关联。当客户端上的实际长度超过<code class="codeph">UB2MAXVAL</code>时，在处理数据类型时使用此调用。
                  </p>
                  <div class="section">
                     <p class="subhead2" id="GUID-74939FB5-919E-4D24-B327-AFB532435061__GUID-04D668FA-C5FE-4C9E-BC30-CD4A68A3EF6C">目的</p>
                     <p>将选择列表中的项与类型和输出数据缓冲区相关联。当客户端上的实际长度超过<code class="codeph">UB2MAXVAL</code>时，在处理数据类型时使用此调用而不是<code class="codeph">OCIDefineByPos()</code> 。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-74939FB5-919E-4D24-B327-AFB532435061__GUID-EAC70CDC-52A4-4358-98CD-B770032B0851">句法</p><pre class="oac_no_warn" dir="ltr">剑OCIDefineByPos2（OCIStmt * stmtp，OCIDefine ** defnpp，OCIError * errhp，ub4位置，void * valuep，sb8 value_sz，ub2 dty，void * indp，ub4 * rlenp，ub2 * rcodep，ub4模式）;</pre></div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-74939FB5-919E-4D24-B327-AFB532435061__GUID-F66A6968-85D1-4F95-BC30-C528DF98AFF3">参数</p>
                     <dl>
                        <dt class="dlterm"><a name="GUID-74939FB5-919E-4D24-B327-AFB532435061__GUID-BA0410AC-E3A1-4077-8B70-236549AC9A38"><!-- --></a> <span class="bold">stmtp</span> （IN / OUT）</dt>
                        <dd>
                           <p>请求的SQL查询操作的句柄。</p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-74939FB5-919E-4D24-B327-AFB532435061__GUID-48172B08-11EF-404D-BC94-479865E0003D"><!-- --></a> <span class="bold">defnpp</span> （IN / OUT）</dt>
                        <dd>
                           <p>指向定义句柄的指针。如果此参数作为<code class="codeph">NULL</code>传递，则此调用将隐式分配define句柄。对于重定义，可以在此参数中传递非<code class="codeph">NULL</code>句柄。此句柄用于存储此列的定义信息。
                           </p>
                           <div class="infoboxnote" id="GUID-74939FB5-919E-4D24-B327-AFB532435061__GUID-EDDE6FBD-29ED-4A95-BDBB-339EF4D1BAAD">
                              <p class="notep1">注意：</p>
                              <p>你必须跟踪这个指针。如果对同一列位置进行第二次<code class="codeph">OCIDefineByPos()</code>调用，则无法保证将返回相同的指针。
                              </p>
                           </div>
                        </dd>
                        <dt class="dlterm"><a name="GUID-74939FB5-919E-4D24-B327-AFB532435061__GUID-B066FAD4-4A9A-4DE7-9FC9-0D6216BEFEE8"><!-- --></a> <span class="bold">errhp</span> （IN / OUT）</dt>
                        <dd>
                           <p>一个错误句柄，您可以在出现错误时传递给<code class="codeph">OCIErrorGet()</code>以获取诊断信息。
                           </p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-74939FB5-919E-4D24-B327-AFB532435061__GUID-A0AEE384-8B78-4A4F-9021-0523F4899138"><!-- --></a> <span class="bold">位置</span> （IN）</dt>
                        <dd>
                           <p>此值在选择列表中的位置。位置从1开始，从左到右编号。值0选择<code class="codeph">ROWID</code> （表中行的全局唯一标识符）。
                           </p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-74939FB5-919E-4D24-B327-AFB532435061__GUID-75285C80-67B5-492E-ABAC-EC359A478DC1"><!-- --></a> <span class="bold">valuep</span> （IN / OUT）</dt>
                        <dd>
                           <p>指向缓冲区或<code class="codeph">dty</code>参数中指定类型的缓冲区数组的指针。当在单个提取调用中需要多行的结果时，可以指定多个缓冲区。
                           </p>
                           <p>对于LOB，缓冲区指针必须是指向<code class="codeph">OCILobLocator</code>类型的LOB定位符的<code class="codeph">OCILobLocator</code> 。给出指针的地址。
                           </p>
                           <p>当<code class="codeph">mode</code>设置为<code class="codeph">OCI_IOV</code> ，传递<code class="codeph">OCIIOV</code>结构的基址。
                           </p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-74939FB5-919E-4D24-B327-AFB532435061__GUID-F826F278-E350-44E6-BECD-AA84CDA51E06"><!-- --></a> <span class="bold">value_sz</span> （IN）</dt>
                        <dd>
                           <p>每个<code class="codeph">valuep</code>缓冲区的大小（以字节为单位）。如果数据以<code class="codeph">VARCHAR2</code>格式存储在内部，则可以使用<code class="codeph">OCIAttrSet()</code>将所需的字符数（如果与缓冲区大小（以字节为单位<code class="codeph">OCIAttrSet()</code>指定为附加字节。
                           </p>
                           <p>如果<code class="codeph">value_sz</code> &gt; <code class="codeph">SB4MAXVAL</code>的值，将发出<code class="codeph">ORA-24452</code> <code class="codeph">SB4MAXVAL</code>错误，这意味着版本12.1或更高版本中不支持值&gt; <code class="codeph">SB4MAXVAL</code> 。
                           </p>
                           <p>在多字节转换环境中，如果指定的字节数不足以处理所需的字符数，则会生成截断错误。</p>
                           <p>如果<code class="codeph">OCI_ATTR_CHARSET_ID</code>属性设置为<code class="codeph">OCI_UTF16ID</code> （替换为了向后兼容而保留的已弃用的<code class="codeph">OCI_UCS2ID</code> ），则假定传递给相应的define调用并通过相应的define调用接收的所有数据都采用<code class="codeph">UTF-16</code>编码。
                           </p>
                           <p>当<code class="codeph">mode</code>设置为<code class="codeph">OCI_IOV</code> ，传递数据值的大小。
                           </p>
                           <div class="infoboxnotealso" id="GUID-74939FB5-919E-4D24-B327-AFB532435061__GUID-A0295FFA-5091-4FCD-AC40-8B84D49898FC">
                              <p class="notep1">也可以看看：</p>
                              <p><a href="handle-and-descriptor-attributes.html#GUID-01C53C14-CD15-4A8B-9EFF-86996282F3BD" title="列出并描述绑定句柄属性。">绑定句柄属性</a></p>
                           </div>
                        </dd>
                     </dl>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <dl>
                        <dt class="dlterm"><a name="GUID-74939FB5-919E-4D24-B327-AFB532435061__GUID-C34AECB1-0853-4AB6-A8D6-6EEEA9CCB7A9"><!-- --></a> <span class="bold">dty</span> （IN）</dt>
                        <dd>
                           <p>数据类型。仅当在对象模式下初始化环境时，命名数据类型（SQLT_NTY）和<code class="codeph">REF</code> （SQLT_REF）才有效。
                           </p>
                           <p>可以为<code class="codeph">CLOB</code>列指定SQLT_CHR和SQLT_LNG，并且可以为<code class="codeph">BLOB</code>列指定SQLT_BIN和SQLT_LBI。
                           </p>
                           <div class="infoboxnotealso" id="GUID-74939FB5-919E-4D24-B327-AFB532435061__GUID-37E99E60-C56F-4CC0-A6E3-BDE6E785CFFB">
                              <p class="notep1">也可以看看：</p>
                              <p><a href="data-types.html#GUID-027FB2E2-593C-43F1-9184-DFEF7A984A27" title="本章提供OCI应用程序使用的Oracle外部数据类型的参考。">数据类型</a>代码和值列表的数据类型</p>
                           </div>
                        </dd>
                     </dl>
                     <dl>
                        <dt class="dlterm"><a name="GUID-74939FB5-919E-4D24-B327-AFB532435061__GUID-1822D71C-FF57-4639-B44B-F47DBA3251FF"><!-- --></a> <span class="bold">indp（IN）</span></dt>
                        <dd>
                           <p>指向变量或数组的指针。为标量数据类型，指针到<code class="codeph">sb2</code>或阵列<code class="codeph">sb2</code>秒。忽略SQLT_NTY定义。对于SQLT_NTY定义，指向指定数据类型指示符结构的指针或指定数据类型指示符结构的数组由后续<code class="codeph">OCIDefineObject()</code>调用关联。
                           </p>
                           <div class="infoboxnotealso" id="GUID-74939FB5-919E-4D24-B327-AFB532435061__GUID-DF5F4FDC-6AF3-413D-9A9C-3FC51638056A">
                              <p class="notep1">也可以看看：</p>
                              <p><a href="oci-programming-basics.html#GUID-9966EDF7-37ED-42E5-AE57-67E394245BFA" title="每个绑定和定义OCI调用都有一个参数，它将指示符变量或指示符变量数组与DML语句，PL / SQL语句或查询相关联。">指标变量</a></p>
                           </div>
                        </dd>
                     </dl>
                     <dl>
                        <dt class="dlterm"><a name="GUID-74939FB5-919E-4D24-B327-AFB532435061__GUID-D36FF18D-F2B8-4AC7-9250-B21018540D3E"><!-- --></a> <span class="bold">rlenp</span> （IN / OUT）</dt>
                        <dd>
                           <p>指向获取的数据长度数组的指针。</p>
                           <p>当使用<code class="codeph">OCIEnvNlsCreate()</code> （推荐的OCI环境句柄创建接口）时， <code class="codeph">rlenp</code>字节为单位一致地报告<code class="codeph">rlenp</code>长度。对于<code class="codeph">SQLT_VCS</code> （2字节长度前缀）和<code class="codeph">SQLT_LVC</code> （4字节长度前缀）类型中的长度前缀，同样的处理也一致。UCS2或NCHAR案例没有特殊例外。
                           </p>
                           <p>当较旧的OCI环境句柄创建界面被使用（或者<code class="codeph">OCIEnvCreate()</code>或弃用<code class="codeph">OCIEnvInit()</code> <code class="codeph">rlenp</code>长度在一般字节。但是，当字符集为OCI_UC2ID（= OCI_UTF16ID）或在相应的OCIBind句柄上设置<code class="codeph">OCI_ATTR_CHAR_COUNT</code>属性时，以字符报告<code class="codeph">rlenp</code>长度。对于<code class="codeph">SQLT_VCS</code> （2字节长度前缀）和<code class="codeph">SQLT_LVC</code> （4字节长度前缀）类型中的长度前缀，同样的处理方式也适用。
                           </p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-74939FB5-919E-4D24-B327-AFB532435061__GUID-72FACB6C-AD40-4DE6-B28A-E521D3D3215A"><!-- --></a> <span class="bold">rcodep</span> （OUT）</dt>
                        <dd>
                           <p>指向列级返回码数组的指针。</p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-74939FB5-919E-4D24-B327-AFB532435061__GUID-2E2C1B72-BF55-4DE7-B3D0-7ED191585D73"><!-- --></a> <span class="bold">模式</span> （IN）</dt>
                        <dd>
                           <p>有效模式是：</p>
                        </dd>
                     </dl>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">OCI_DEFAULT</code> - 这是默认模式。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">OCI_DEFINE_SOFT</code> - 软定义模式。此模式可提高呼叫的性能。如果这是第一个定义，或者某个输入参数（如<code class="codeph">dty</code>或<code class="codeph">value_sz</code> ）从先前的定义更改，则忽略此模式。如果传递了无效的定义句柄，则会导致意外的行为。如果未执行该语句，则返回错误。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">OCI_DYNAMIC_FETCH</code> - 对于在获取时需要动态分配数据的应用程序，必须使用此模式。您可以使用<code class="codeph">OCIDefineDynamic()</code>调用定义回调。<code class="codeph">value_sz</code>参数定义在运行时提供的数据的最大大小。当客户端库需要缓冲区来返回获取的数据时，将调用回调以提供运行时缓冲区，其中返回一个或所有数据。
                           </p>
                           <div class="infoboxnotealso" id="GUID-74939FB5-919E-4D24-B327-AFB532435061__GUID-165DB8D9-927D-48BF-B3DB-E896D4AB04E7">
                              <p class="notep1">也可以看看：</p>
                              <p><a href="performance-topics.html#GUID-03884D82-8E0C-4CAB-84F4-4ED4D8D8674B" title="本节介绍以下主题：">ROWID的隐式提取</a></p>
                           </div>
                        </li>
                        <li>
                           <p><code class="codeph">OCI_IOV</code> - 定义不连续的数据地址。<code class="codeph">valuep</code>参数必须是<code class="codeph">OCIIOV *</code>类型。此模式旨在用于分散或聚集绑定，这允许将多个缓冲区绑定或定义到某个位置，例如，一个缓冲区中前10行的列A，一个缓冲区中的后5行，其余25个另一个缓冲区中的行。这样就无需在执行数组执行操作时将所有这些分配并复制到一个大缓冲区中。
                           </p>
                           <div class="infoboxnotealso" id="GUID-74939FB5-919E-4D24-B327-AFB532435061__GUID-20839B1D-6436-4FF7-9089-CBC55FA2893C">
                              <p class="notep1">也可以看看：</p>
                              <p><a href="binding-and-defining-in-oci.html#GUID-CC67A87C-A39A-400A-BF95-C32363DCD589" title="您可以指定多个缓冲区以用于单个绑定或定义调用。">关于绑定和定义多个缓冲区</a></p>
                           </div>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-74939FB5-919E-4D24-B327-AFB532435061__GUID-58CDEBB4-C60F-45D6-AED9-B022ADEFEF18">评论</p>
                     <p>此调用定义一个输出缓冲区，用于接收从Oracle数据库检索的数据。定义是<code class="codeph">SELECT</code>语句将数据返回到OCI应用程序时必需的本地步骤。
                     </p>
                     <p>此调用还隐式为select-list项分配define句柄。如果在<code class="codeph">*defnpp</code>传递非<code class="codeph">NULL</code>指针，则OCI假定这指向先前已通过调用<code class="codeph">OCIHandleAlloc()</code>或<code class="codeph">OCIDefineByPos2()</code>分配的有效句柄。对于将句柄重新定义为不同地址的应用程序来说，这是正确的，这样它就可以为多个提取重用相同的定义句柄。
                     </p>
                     <p>为一次提取定义列的属性是在一次或多次调用中完成的。第一个调用是<code class="codeph">OCIDefineByPos2()</code> ，它定义了指定fetch所需的最小属性。
                     </p>
                     <p>在调用<code class="codeph">OCIDefineByPos2()</code>之后，对于某些数据类型或获取模式，可能需要额外的定义调用：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>需要调用<code class="codeph">OCIDefineArrayOfStruct()</code>来为多列的数组提取设置跳过参数。
                           </p>
                        </li>
                        <li>
                           <p>需要调用<code class="codeph">OCIDefineObject()</code>来设置命名数据类型（即对象或集合）或<code class="codeph">REF</code>提取的适当属性。在这种情况下， <code class="codeph">OCIDefineByPos2()</code>的数据缓冲区指针将被忽略。
                           </p>
                        </li>
                        <li>
                           <p>必须在<code class="codeph">OCIDefineByPos2()</code>之后调用<code class="codeph">OCIDefineArrayOfStruct()</code>和<code class="codeph">OCIDefineObject()</code>以使用一列命名数据类型获取多行。
                           </p>
                        </li>
                     </ul>
                     <p>对于LOB定义，缓冲区指针必须是指向<code class="codeph">OCILobLocator</code>类型的LOB定位符的<code class="codeph">OCILobLocator</code> ，由<code class="codeph">OCIDescriptorAlloc()</code>调用分配。始终为LOB列返回LOB定位符，而不是LOB值。然后可以使用提取的定位器上的OCI LOB调用获取LOB值。这种机制适用于所有描述符数据类型。
                     </p>
                     <p>对于NCHAR（固定长度和变化长度），缓冲区指针必须指向足以保存所需NCHAR字符的字节数组。</p>
                     <p>嵌套表列的定义和提取方式与任何其他命名数据类型一样。</p>
                     <p>在定义描述符或定位符数组时，应该传入指向描述符或定位符的指针数组。</p>
                     <p>在为字符列执行数组定义时，应传入一个字符缓冲区数组。</p>
                     <p>如果此调用中的<code class="codeph">mode</code>参数设置为<code class="codeph">OCI_DYNAMIC_FETCH</code> ，则客户端应用程序可以在运行时动态获取数据。可以通过以下两种方式之一提供运行时数据：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>使用用户定义函数的回调，必须在后续调用<code class="codeph">OCIDefineDynamic()</code> 。当客户端库需要缓冲区来返回获取的数据时，将调用回调并且提供的运行时缓冲区将返回一个或所有数据。
                           </p>
                        </li>
                        <li>
                           <p>使用OCI提供的调用的轮询机制。如果未定义回调，则假定使用此模式。在这种情况下，fetch调用返回<code class="codeph">OCI_NEED_DATA</code>错误代码，并使用分段轮询方法来提供数据。
                           </p>
                           <div class="infoboxnotealso" id="GUID-74939FB5-919E-4D24-B327-AFB532435061__GUID-367DD661-D4AB-47A8-84C2-3FAEC1246F38">
                              <p class="notep1">也可以看看：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>有关使用<code class="codeph">OCI_DYNAMIC_FETCH</code>模式的更多信息，请<code class="codeph">OCI_DYNAMIC_FETCH</code> <a href="binding-and-defining-in-oci.html#GUID-6C5EA0C6-0C1D-4CD5-B47F-1B95B4E9C558" title="您可以使用OCI执行分段插入，更新和数据提取。">OCI中的运行时数据分配和分段操作</a></p>
                                 </li>
                                 <li>
                                    <p>有关定义的更多信息，请参阅<a href="binding-and-defining-in-oci.html#GUID-8A09BC68-4C3D-4977-86C9-134F73121E26" title="Query语句将数据从数据库返回给您的应用程序。">在OCI中定义的概述</a></p>
                                 </li>
                                 <li>
                                    <p><a href="performance-topics.html#GUID-03884D82-8E0C-4CAB-84F4-4ED4D8D8674B" title="本节介绍以下主题：">ROWID的隐式提取</a> 
                                    </p>
                                 </li>
                              </ul>
                           </div>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="bind-define-describe-functions.html#GUID-D3F74828-5DA7-48AD-A170-120AD547DEB3" title="指定静态数组定义所需的其他属性，用于结构数组（多行，多列）提取。">OCIDefineArrayOfStruct（）</a></li>
                        <li><a href="bind-define-describe-functions.html#GUID-DD404526-9615-4E44-B790-1D17396C82A9" title="如果在OCIDefineByPos（）或OCIDefineByPos2（）中选择了OCI_DYNAMIC_FETCH模式，则设置所需的其他属性。">OCIDefineDynamic（）</a></li>
                        <li><a href="bind-define-describe-functions.html#GUID-F211198D-C88C-493B-A65E-2C2A95E6197B" title="设置命名数据类型或REF定义所需的其他属性。">OCIDefineObject（）</a></li>
                        <li><a href="bind-define-describe-functions.html#GUID-CFE5AA54-DEBC-42D3-8A27-AFF1E7815691" title="将选择列表中的项与类型和输出数据缓冲区相关联。">OCIDefineByPos（）</a></li>
                        <li><a href="handle-and-descriptor-functions.html#GUID-3741D7BD-7652-4D7A-8813-AC2AEA8D3B03" title="设置句柄或描述符的属性值。">OCIAttrSet（）</a></li>
                        <li><a href="connect-authorize-and-initialize-functions.html#GUID-0B6911A9-4B46-476C-BC5E-B87581666CD9" title="创建并初始化OCI函数的环境句柄。">OCIEnvNlsCreate（）</a></li>
                        <li><a href="connect-authorize-and-initialize-functions.html#GUID-16BDA1F1-7DAF-41CA-9EE1-C9A4CB467244" title="创建并初始化OCI函数的环境句柄。">OCIEnvCreate（）</a></li>
                        <li><a href="deprecated-oci-functions.html#GUID-1AC89920-7DB1-46AC-BBAA-9854DDAD6AB7" title="在Oracle Database 11g第2版（11.2）之前的版本中不推荐使用此功能。">OCIEnvInit（）</a></li>
                        <li><a href="handle-and-descriptor-functions.html#GUID-C5BF55F7-A110-4CB5-9663-5056590F12B5" title="返回指向已分配和初始化句柄的指针。">OCIHandleAlloc（）</a></li>
                        <li><a href="handle-and-descriptor-functions.html#GUID-E9EF2766-E078-49A7-B1D1-738E4BA4814F" title="分配存储以保存描述符或LOB定位符。">OCIDescriptorAlloc（）</a></li>
                        <li><a href="miscellaneous-functions.html#GUID-4B99087C-74F6-498A-8310-D6645172390A" title="返回错误消息和Oracle数据库错误代码。">OCIErrorGet（）</a></li>
                     </ul>
                  </div>
               </div>
               
            </div><a id="LNOCI17146"></a><div class="props_rev_3"><a id="GUID-DD404526-9615-4E44-B790-1D17396C82A9" name="GUID-DD404526-9615-4E44-B790-1D17396C82A9"></a><h3 id="LNOCI-GUID-DD404526-9615-4E44-B790-1D17396C82A9" class="sect3"><span class="enumeration_section">25.4.11</span> OCIDefineDynamic（）</h3>
               <div>
                  <p>如果在<code class="codeph">OCIDefineByPos()</code>或<code class="codeph">OCIDefineByPos2()</code>选择了<code class="codeph">OCI_DYNAMIC_FETCH</code>模式，则设置所需的其他属性。
                  </p>
                  <div class="section">
                     <p class="subhead2" id="GUID-DD404526-9615-4E44-B790-1D17396C82A9__GUID-9EA43879-161F-4826-A983-B5A49F13B010">目的</p>
                     <p>如果在<code class="codeph">OCIDefineByPos()</code>或<code class="codeph">OCIDefineByPos2()</code>选择了<code class="codeph">OCI_DYNAMIC_FETCH</code>模式，则设置所需的其他属性。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-DD404526-9615-4E44-B790-1D17396C82A9__GUID-66888C01-63C1-4108-B8FA-421634E67BB7">句法</p><pre class="oac_no_warn" dir="ltr">剑OCIDefineDynamic（OCIDefine * defnp，OCIError * errhp，void * octxp，OCICallbackDefine（ocbfp）（void * octxp，OCIDefine * defnp，ub4 iter，void ** bufpp，ub4 ** alenpp，ub1 * piecep，void ** indpp， ub2 ** rcodep）;</pre></div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-DD404526-9615-4E44-B790-1D17396C82A9__GUID-AF787B40-9F78-4BB3-AA70-5CFA8AA708F2">参数</p>
                     <dl>
                        <dt class="dlterm"><a name="GUID-DD404526-9615-4E44-B790-1D17396C82A9__GUID-18A34AFC-AC18-45EA-B2D1-D7347202637F"><!-- --></a> defnp（IN / OUT）</dt>
                        <dd>
                           <p>通过调用<code class="codeph">OCIDefineByPos()</code>返回的定义结构的句柄。
                           </p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-DD404526-9615-4E44-B790-1D17396C82A9__GUID-9E740713-3217-43CE-A4C2-D4FD46C76FC1"><!-- --></a> errhp（IN / OUT）</dt>
                        <dd>
                           <p>一个错误句柄，您可以在出现错误时传递给<code class="codeph">OCIErrorGet()</code>以获取诊断信息。
                           </p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-DD404526-9615-4E44-B790-1D17396C82A9__GUID-C89F7E16-C448-4071-9F19-C399E9AA0E86"><!-- --></a> octxp（IN）</dt>
                        <dd>
                           <p>指向回调函数的上下文。</p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-DD404526-9615-4E44-B790-1D17396C82A9__GUID-6FDA75DE-71B4-48CD-AB96-7A4CD1C718D4"><!-- --></a> ocbfp（IN）</dt>
                        <dd>
                           <p>指向回调函数。这在运行时被调用以获得指向缓冲区的指针，在该缓冲区中将获取所获取的数据或其中的一部分。回调还指定了指标，返回码以及数据块和指标的长度。</p>
                           <div class="infoboxnote" id="GUID-DD404526-9615-4E44-B790-1D17396C82A9__GUID-BFF919D2-CA13-461C-8CAC-11D841C6E27D">
                              <p class="notep1">注意：</p>
                              <p>通常，在OCI函数中， <code class="codeph">IN</code>参数指的是传递给OCI的数据， <code class="codeph">OUT</code>参数指的是从OCI返回的数据。对于回调，这是相反的。<code class="codeph">IN</code>表示数据从OCI进入回调， <code class="codeph">OUT</code>表示数据来自回调并转到OCI。</p>
                           </div>
                           <p>回调参数是：</p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-DD404526-9615-4E44-B790-1D17396C82A9__GUID-AF2014D0-1543-4D68-825B-EF3FF5367DC9"><!-- --></a> octxp（IN / OUT）</dt>
                        <dd>
                           <p>上下文指针作为参数传递给所有回调函数。当客户端库需要缓冲区来返回获取的数据时，将调用回调并且提供的运行时缓冲区将返回一个或所有数据。</p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-DD404526-9615-4E44-B790-1D17396C82A9__GUID-380F4A27-1F0B-4104-8A1B-7DB0F67082AC"><!-- --></a> defnp（IN）</dt>
                        <dd>
                           <p>定义句柄。</p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-DD404526-9615-4E44-B790-1D17396C82A9__GUID-B2A30ED2-6042-42CF-BF58-49A7CFF07115"><!-- --></a> iter（IN）</dt>
                        <dd>
                           <p>指定当前获取的哪一行; 0为主。</p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-DD404526-9615-4E44-B790-1D17396C82A9__GUID-0AAADC1F-3165-403C-BBDA-95618EC9CDA1"><!-- --></a> bufpp（OUT）</dt>
                        <dd>
                           <p>返回指向缓冲区的指针以存储列值;也就是说， <code class="codeph">*bufpp</code>指向列值的某个适当存储。
                           </p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-DD404526-9615-4E44-B790-1D17396C82A9__GUID-03985B26-3172-4F43-AFA8-5189D81AF304"><!-- --></a> alenpp（IN / OUT）</dt>
                        <dd>
                           <p>应用程序使用它来设置<code class="codeph">*bufpp</code>提供的存储大小。将数据提取到缓冲区后， <code class="codeph">alenpp</code>以字节为单位指示数据的实际大小。如果第一次调用中提供的缓冲区长度不足以存储服务器返回的所有数据，则再次调用回调，依此类推。
                           </p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-DD404526-9615-4E44-B790-1D17396C82A9__GUID-A1291E20-6EE7-4915-86CA-73803508D419"><!-- --></a> piecep（IN / OUT）</dt>
                        <dd>
                           <p>返回从回调（应用程序）到OCI的片段值，如下所示：</p>
                           <p><code class="codeph">piecep</code>参数指示要获取的片段是第一个片段， <code class="codeph">OCI_FIRST_PIECE</code> ，后续片段， <code class="codeph">OCI_NEXT_PIECE</code>还是最后一个片段<code class="codeph">OCI_LAST_PIECE</code> 。程序可以在下次调用回调时或在一系列回调结束后处理该块。
                           </p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">IN</code> - 值可以是<code class="codeph">OCI_ONE_PIECE</code> ， <code class="codeph">OCI_FIRST_PIECE</code>或<code class="codeph">OCI_NEXT_PIECE</code> 。</p>
                              </li>
                              <li>
                                 <p><code class="codeph">OUT</code> - 取决于IN值：</p>
                                 <ul style="list-style-type:disc">
                                    <li>
                                       <p>如果<code class="codeph">IN</code>值为<code class="codeph">OCI_ONE_PIECE</code>则<code class="codeph">OUT</code>值可以是<code class="codeph">OCI_ONE_PIECE</code> 。</p>
                                    </li>
                                    <li>
                                       <p>如果<code class="codeph">IN</code>值为<code class="codeph">OCI_FIRST_PIECE</code>则<code class="codeph">OUT</code>值可以是<code class="codeph">OCI_ONE_PIECE</code>或<code class="codeph">OCI_FIRST_PIECE</code> 。</p>
                                    </li>
                                    <li>
                                       <p>如果<code class="codeph">IN</code>值为<code class="codeph">OCI_LAST_PIECE</code>则<code class="codeph">OUT</code>值可以是<code class="codeph">OCI_NEXT_PIECE</code>或<code class="codeph">OCI_NEXT_PIECE</code> 。</p>
                                    </li>
                                 </ul>
                              </li>
                           </ul>
                        </dd>
                        <dt class="dlterm"><a name="GUID-DD404526-9615-4E44-B790-1D17396C82A9__GUID-A713AB42-08F8-4EDC-B67F-097B08FD67D7"><!-- --></a> indpp（IN）</dt>
                        <dd>
                           <p>指标变量指针。</p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-DD404526-9615-4E44-B790-1D17396C82A9__GUID-CB911C46-695E-481C-82C8-E016962D6F74"><!-- --></a> rcodep（IN）</dt>
                        <dd>
                           <p>返回代码变量指针。</p>
                        </dd>
                     </dl>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-DD404526-9615-4E44-B790-1D17396C82A9__GUID-BB10FE45-E80D-4D80-827F-E414E735A359">评论</p>
                     <p>如果在调用<code class="codeph">OCIDefineByPos()</code>或<code class="codeph">OCIDefineByPos2()</code>选择了<code class="codeph">OCI_DYNAMIC_FETCH</code>模式，则此调用用于设置所需的其他属性。如果选择了<code class="codeph">OCI_DYNAMIC_FETCH</code>模式，并且跳过了对<code class="codeph">OCIDefineDynamic()</code>的调用，则应用程序可以使用OCI调用（ <code class="codeph">OCIStmtGetPieceInfo()</code>和<code class="codeph">OCIStmtSetPieceInfo()</code> ）分段获取数据。
                     </p>
                     <div class="infoboxnote" id="GUID-DD404526-9615-4E44-B790-1D17396C82A9__GUID-556BDB63-868C-45DA-BF12-07CF0F29E944">
                        <p class="notep1">注意：</p>
                        <p>使用<code class="codeph">OCIEnvNlsCreate()</code>创建环境句柄后，bind和define句柄的实际长度和返回长度始终以字节数表示。
                        </p>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="bind-define-describe-functions.html#GUID-F211198D-C88C-493B-A65E-2C2A95E6197B" title="设置命名数据类型或REF定义所需的其他属性。">OCIDefineObject（）</a></li>
                        <li><a href="bind-define-describe-functions.html#GUID-030270CB-346A-412E-B3B3-556DD6947BE2" title="注册用户回调以进行动态数据分配。">OCIBindDynamic（）</a></li>
                        <li><a href="bind-define-describe-functions.html#GUID-CFE5AA54-DEBC-42D3-8A27-AFF1E7815691" title="将选择列表中的项与类型和输出数据缓冲区相关联。">OCIDefineByPos（）</a></li>
                        <li><a href="bind-define-describe-functions.html#GUID-74939FB5-919E-4D24-B327-AFB532435061" title="将选择列表中的项与类型和输出数据缓冲区相关联。当客户端上的实际长度超过UB2MAXVAL时，在处理数据类型时使用此调用。">OCIDefineByPos2（）</a></li>
                        <li><a href="statement-functions.html#GUID-3D9B5C7B-E2A1-485D-852C-2434F303EC11" title="返回分段操作的片段信息。">OCIStmtGetPieceInfo（）</a></li>
                        <li><a href="statement-functions.html#GUID-CDB6F3E3-0FB6-49A7-A8AE-83CD330A359F" title="设置分段操作的片段信息。">OCIStmtSetPieceInfo（）</a></li>
                        <li><a href="connect-authorize-and-initialize-functions.html#GUID-0B6911A9-4B46-476C-BC5E-B87581666CD9" title="创建并初始化OCI函数的环境句柄。">OCIEnvNlsCreate（）</a></li>
                     </ul>
                  </div>
                  <div class="infoboxnotealso" id="GUID-DD404526-9615-4E44-B790-1D17396C82A9__GUID-9CE721F8-DD7F-4B1B-B6D6-429B504A2628">
                     <p class="notep1">也可以看看：</p>
                     <p>有关<code class="codeph">OCI_DYNAMIC_FETCH</code>模式的更多信息，请<code class="codeph">OCI_DYNAMIC_FETCH</code> <a href="binding-and-defining-in-oci.html#GUID-6C5EA0C6-0C1D-4CD5-B47F-1B95B4E9C558" title="您可以使用OCI执行分段插入，更新和数据提取。">OCI中的运行时数据分配和分段操作</a></p>
                  </div>
               </div>
               
            </div><a id="LNOCI17147"></a><div class="props_rev_3"><a id="GUID-F211198D-C88C-493B-A65E-2C2A95E6197B" name="GUID-F211198D-C88C-493B-A65E-2C2A95E6197B"></a><h3 id="LNOCI-GUID-F211198D-C88C-493B-A65E-2C2A95E6197B" class="sect3"><span class="enumeration_section">25.4.12</span> OCIDefineObject（）</h3>
               <div>
                  <p>设置命名数据类型或<code class="codeph">REF</code>定义所需的其他属性。
                  </p>
                  <div class="section">
                     <p class="subhead2" id="GUID-F211198D-C88C-493B-A65E-2C2A95E6197B__GUID-850DC2FA-859B-473F-96DA-757F34E8B05E">目的</p>
                     <p>设置命名数据类型或<code class="codeph">REF</code>定义所需的其他属性。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-F211198D-C88C-493B-A65E-2C2A95E6197B__GUID-19F6CCE5-33E2-4C8A-89AC-795B36BEEC4A">句法</p><pre class="oac_no_warn" dir="ltr">剑OCIDefineObject（OCIDefine * defnp，OCIError * errhp，const OCIType * type，void ** pgvpp，ub4 * pvszsp，void ** indpp，ub4 * indszp）;</pre></div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-F211198D-C88C-493B-A65E-2C2A95E6197B__GUID-45D074AA-E022-4EDE-A43D-95BCFBDC6F65">参数</p>
                     <dl>
                        <dt class="dlterm"><a name="GUID-F211198D-C88C-493B-A65E-2C2A95E6197B__GUID-68C225AE-6781-414B-9D8B-208D8E710E30"><!-- --></a> <span class="bold">defnp</span> （IN / OUT）</dt>
                        <dd>
                           <p>先前在对<code class="codeph">OCIDefineByPos()</code>或<code class="codeph">OCIDefineByPos2()</code>的调用中分配的定义句柄。
                           </p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-F211198D-C88C-493B-A65E-2C2A95E6197B__GUID-53359D64-528B-4007-919E-E6771C927DA4"><!-- --></a> <span class="bold">errhp</span> （输入/输出）</dt>
                        <dd>
                           <p>一个错误句柄，您可以在出现错误时传递给<code class="codeph">OCIErrorGet()</code>以获取诊断信息。
                           </p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-F211198D-C88C-493B-A65E-2C2A95E6197B__GUID-C853B2D0-71E2-42C8-8805-16E20436C027"><!-- --></a> <span class="bold">类型</span> （IN）[可选]</dt>
                        <dd>
                           <p>指向描述程序变量类型的类型描述符对象（TDO）。对于<code class="codeph">SQLT_REF</code>类型的变量，此参数是可选的，如果未使用，则可以将其作为<code class="codeph">NULL</code>传递。
                           </p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-F211198D-C88C-493B-A65E-2C2A95E6197B__GUID-94387B09-9449-4C8D-9BE2-14657C6ECD0B"><!-- --></a> <span class="bold">pgvpp</span> （IN / OUT）</dt>
                        <dd>
                           <p>指向程序变量缓冲区的指针。对于数组， <code class="codeph">pgvpp</code>指向一个指针数组。已获取的命名数据类型实例的内存在对象缓存中动态分配。在获取所有值的fetch结束时， <code class="codeph">pgvpp</code>指向指向这些新分配的命名数据类型实例的指针。应用程序必须调用<code class="codeph">OCIObjectFree()</code>以在不再需要它们时释放已命名的数据类型实例。
                           </p>
                           <div class="infoboxnote" id="GUID-F211198D-C88C-493B-A65E-2C2A95E6197B__GUID-3EE40B3C-F181-4779-BE82-1AF18C2F016E">
                              <p class="notep1">注意：</p>
                              <p>如果应用程序想要在缓存中隐式分配缓冲区，则应将<code class="codeph">*pgvpp</code>作为<code class="codeph">NULL</code>传入。</p>
                           </div>
                        </dd>
                        <dt class="dlterm"><a name="GUID-F211198D-C88C-493B-A65E-2C2A95E6197B__GUID-F7CCBF19-4592-4019-84A5-E6CE8B5278A2"><!-- --></a> <span class="bold">pvszsp</span> （IN / OUT）</dt>
                        <dd>
                           <p>指向程序变量的大小。对于数组，它是一个<code class="codeph">ub4</code>数组。
                           </p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-F211198D-C88C-493B-A65E-2C2A95E6197B__GUID-DA45D214-7B6D-4A82-A7C0-16B0E269BDAA"><!-- --></a> <span class="bold">indpp</span> （IN / OUT）</dt>
                        <dd>
                           <p>指向指向包含并行指示器结构的程序变量缓冲区的指针。对于数组，指向指针数组。分配内存以将指示符结构存储在对象缓存中。在接收到所有值时，在获取结束时， <code class="codeph">indpp</code>指向指向这些新分配的指示符结构的指针。
                           </p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-F211198D-C88C-493B-A65E-2C2A95E6197B__GUID-7153DD44-DD62-4670-B7FA-FE01D4FDD4EF"><!-- --></a> <span class="bold">indszp</span> （IN / OUT）</dt>
                        <dd>
                           <p>指向指标结构程序变量的大小。对于数组，它是一个<code class="codeph">ub4</code>的数组。
                           </p>
                        </dd>
                     </dl>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-F211198D-C88C-493B-A65E-2C2A95E6197B__GUID-8CCF1B09-2C46-4564-B490-E712D2EA12CC">评论</p>
                     <p>此函数在调用<code class="codeph">OCIDefineByPos()</code>或<code class="codeph">OCIDefineByPos2()</code>设置初始定义信息。此调用设置命名数据类型定义所需的其他属性。如果在非对象模式下初始化OCI环境时调用此函数，则会返回错误。
                     </p>
                     <p>此调用将数据类型为<code class="codeph">OCIType</code>的类型描述符对象（TDO）作为参数，用于定义的命名数据类型。可以通过调用<code class="codeph">OCIDescribeAny()</code>来检索TDO。
                     </p>
                  </div>
                  <!-- class="section" -->
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="bind-define-describe-functions.html#GUID-CFE5AA54-DEBC-42D3-8A27-AFF1E7815691" title="将选择列表中的项与类型和输出数据缓冲区相关联。">OCIDefineByPos（）</a></li>
                        <li><a href="bind-define-describe-functions.html#GUID-74939FB5-919E-4D24-B327-AFB532435061" title="将选择列表中的项与类型和输出数据缓冲区相关联。当客户端上的实际长度超过UB2MAXVAL时，在处理数据类型时使用此调用。">OCIDefineByPos2（）</a></li>
                        <li><a href="oci-pin-unpin-and-free-functions.html#GUID-0814B033-C25C-4B4C-8968-4C0B86C2E744" title="释放和取消对象实例。">OCIObjectFree（）</a></li>
                        <li><a href="bind-define-describe-functions.html#GUID-AE9F73FB-DCC1-401E-8151-A8A89059163A" title="描述现有的模式和子模式对象。">OCIDescribeAny（）</a></li>
                        <li><a href="connect-authorize-and-initialize-functions.html#GUID-16BDA1F1-7DAF-41CA-9EE1-C9A4CB467244" title="创建并初始化OCI函数的环境句柄。">OCIEnvCreate（）</a></li>
                        <li><a href="connect-authorize-and-initialize-functions.html#GUID-0B6911A9-4B46-476C-BC5E-B87581666CD9" title="创建并初始化OCI函数的环境句柄。">OCIEnvNlsCreate（）</a></li>
                        <li><a href="miscellaneous-functions.html#GUID-4B99087C-74F6-498A-8310-D6645172390A" title="返回错误消息和Oracle数据库错误代码。">OCIErrorGet（）</a></li>
                     </ul>
                  </div>
                  <div class="infoboxnotealso" id="GUID-F211198D-C88C-493B-A65E-2C2A95E6197B__GUID-08E731AD-5EA1-408D-94DC-0681E549C57A">
                     <p class="notep1">也可以看看：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>有关初始化OCI进程环境的更多信息，请<code class="codeph">OCIEnvNlsCreate()</code>和<code class="codeph">OCIEnvCreate()</code></p>
                        </li>
                        <li>
                           <p><a href="binding-and-defining-in-oci.html#GUID-CC67A87C-A39A-400A-BF95-C32363DCD589" title="您可以指定多个缓冲区以用于单个绑定或定义调用。">关于绑定和定义多个缓冲区</a>的示例，以获取使用多个缓冲区的示例</p>
                        </li>
                     </ul>
                  </div>
               </div>
               
            </div><a id="LNOCI17148"></a><div class="props_rev_3"><a id="GUID-AE9F73FB-DCC1-401E-8151-A8A89059163A" name="GUID-AE9F73FB-DCC1-401E-8151-A8A89059163A"></a><h3 id="LNOCI-GUID-AE9F73FB-DCC1-401E-8151-A8A89059163A" class="sect3"><span class="enumeration_section">25.4.13</span> OCIDescribeAny（）</h3>
               <div>
                  <p>描述现有的模式和子模式对象。</p>
                  <div class="section">
                     <p class="subhead2" id="GUID-AE9F73FB-DCC1-401E-8151-A8A89059163A__GUID-D5F4608D-802E-4C2A-AE2F-088C6BE04C73">目的</p>
                     <p>描述现有的模式和子模式对象。</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-AE9F73FB-DCC1-401E-8151-A8A89059163A__GUID-5C41A886-4F08-45A3-B219-D9528E26C0F4">句法</p><pre class="oac_no_warn" dir="ltr">剑OCIDescribeAny（OCISvcCtx * svchp，OCIError * errhp，void * objptr，ub4 objptr_len，ub1 objptr_typ，ub1 info_level，ub1 objtyp，OCIDescribe * dschp）;</pre></div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-AE9F73FB-DCC1-401E-8151-A8A89059163A__GUID-E848914D-3F13-4BA8-8D0C-DA22F9DF58CC">参数</p>
                     <dl>
                        <dt class="dlterm"><a name="GUID-AE9F73FB-DCC1-401E-8151-A8A89059163A__GUID-30AE0FC3-8A36-4BC4-B078-AFFC10870A39"><!-- --></a> svchp（IN）</dt>
                        <dd>
                           <p>服务上下文句柄。</p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-AE9F73FB-DCC1-401E-8151-A8A89059163A__GUID-26DD3888-2B16-43EC-94D3-E7B76A38A16B"><!-- --></a> errhp（输入/输出）</dt>
                        <dd>
                           <p>一个错误句柄，您可以在出现错误时传递给<code class="codeph">OCIErrorGet()</code>以获取诊断信息。
                           </p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-AE9F73FB-DCC1-401E-8151-A8A89059163A__GUID-9D950112-AAF6-4B0C-BE23-47FD07D79AE8"><!-- --></a> objptr（IN）</dt>
                        <dd>
                           <p>这个参数可以是：</p>
                        </dd>
                     </dl>
                     <ol>
                        <li>
                           <p>包含要描述的对象名称的字符串。必须采用前一次调用<code class="codeph">OCIEnvNlsCreate()</code>的<code class="codeph">charset</code>参数指定的编码。
                           </p>
                        </li>
                        <li>
                           <p>指向TDO（对于类型）的<code class="codeph">REF</code>的指针。
                           </p>
                        </li>
                        <li>
                           <p>指向TDO的指针（对于类型）。</p>
                        </li>
                     </ol>
                     <p>通过传递<code class="codeph">objptr_typ</code>的适当值来区分这些情况。此参数必须为非<code class="codeph">NULL</code> 。</p>
                     <p>在案例1中，包含对象名称的字符串应采用格式<code class="codeph">name1[.name2 ...][@linkname]</code> ，例如<code class="codeph">hr.employees.employee_id@mydb</code> 。数据库链接仅允许用于Oracle8 <span class="italic">i</span>或更高版本的数据库。对象名称由以下SQL规则解释：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>如果仅输入<code class="codeph">name1</code>且<code class="codeph">objtyp</code>等于<code class="codeph">OCI_PTYPE_SCHEMA</code> ，则该名称引用指定的模式。Oracle数据库必须是8.1或更高版本。
                           </p>
                        </li>
                        <li>
                           <p>如果仅输入<code class="codeph">name1</code>且<code class="codeph">objtyp</code>等于<code class="codeph">OCI_PTYPE_DATABASE</code> ，则该名称引用指定的数据库。使用<code class="codeph">database_name@db_link_name</code>描述远程数据库时，远程Oracle数据库必须是8.1或更高版本。
                           </p>
                        </li>
                        <li>
                           <p>如果仅输入<code class="codeph">name1</code>且<code class="codeph">objtyp</code>不等于<code class="codeph">OCI_PTYPE_SCHEMA</code>或<code class="codeph">OCI_PTYPE_DATABASE</code> ，则该名称引用当前用户的当前模式中的命名对象（类型表，视图，过程，函数，包，类型，同义词，序列） 。连接到Oracle7 Server时，唯一有效的类型是过程和函数。
                           </p>
                        </li>
                        <li>
                           <p>如果输入<code class="codeph">name1.name2.name3 ...</code> ，则对象名称引用名为<code class="codeph">name1</code>的模式中的模式或子模式对象。例如，在字符串<code class="codeph">hr.employees.department_id</code> ， <code class="codeph">hr</code>是架构的名称， <code class="codeph">employees</code>是架构中表的名称， <code class="codeph">department_id</code>是表中列的名称。
                           </p>
                        </li>
                     </ul>
                     <dl>
                        <dt class="dlterm"><a name="GUID-AE9F73FB-DCC1-401E-8151-A8A89059163A__GUID-86659846-782C-4E58-8969-0DF5D272B598"><!-- --></a> objnm_len（IN）</dt>
                        <dd>
                           <p><code class="codeph">objptr</code>指向的名称字符串的长度。如果传递名称，则必须为非零。如果<code class="codeph">objptr</code>是指向TDO或其<code class="codeph">REF</code>的指针，则可以为零。</p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-AE9F73FB-DCC1-401E-8151-A8A89059163A__GUID-702C7AD1-3F95-424C-9EB2-8C3A8698EDEC"><!-- --></a> objptr_typ（IN）</dt>
                        <dd>
                           <p><code class="codeph">objptr</code>传递的对象类型。有效值为：</p>
                        </dd>
                     </dl>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">OCI_OTYPE_NAME</code> ，如果<code class="codeph">objptr</code>指向架构对象的名称</p>
                        </li>
                        <li>
                           <p><code class="codeph">OCI_OTYPE_REF</code> ，如果<code class="codeph">objptr</code>是指向TDO的<code class="codeph">REF</code>的指针</p>
                        </li>
                        <li>
                           <p><code class="codeph">OCI_OTYPE_PTR</code> ，如果<code class="codeph">objptr</code>是指向TDO的指针</p>
                        </li>
                     </ul>
                     <dl>
                        <dt class="dlterm"><a name="GUID-AE9F73FB-DCC1-401E-8151-A8A89059163A__GUID-919AB7DC-F6AC-45C3-9A32-46EE0C4FE0A0"><!-- --></a> info_level（IN）</dt>
                        <dd>
                           <p>保留用于将来的扩展。传递<code class="codeph">OCI_DEFAULT</code> 。</p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-AE9F73FB-DCC1-401E-8151-A8A89059163A__GUID-7BD4F028-2222-4CC5-93A6-3D23AC7996BF"><!-- --></a> objtyp（IN）</dt>
                        <dd>
                           <p>正在描述的架构对象的类型。有效值为：</p>
                        </dd>
                     </dl>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">OCI_PTYPE_TABLE</code> ，用于表格</p>
                        </li>
                        <li>
                           <p><code class="codeph">OCI_PTYPE_VIEW</code> ，用于视图</p>
                        </li>
                        <li>
                           <p><code class="codeph">OCI_PTYPE_PROC</code> ，用于程序</p>
                        </li>
                        <li>
                           <p><code class="codeph">OCI_PTYPE_FUNC</code> ，用于功能</p>
                        </li>
                        <li>
                           <p><code class="codeph">OCI_PTYPE_PKG</code> ，用于包</p>
                        </li>
                        <li>
                           <p><code class="codeph">OCI_PTYPE_TYPE</code> ，用于类型</p>
                        </li>
                        <li>
                           <p><code class="codeph">OCI_PTYPE_SYN</code> ，用于同义词</p>
                        </li>
                        <li>
                           <p><code class="codeph">OCI_PTYPE_SEQ</code> ，用于序列</p>
                        </li>
                        <li>
                           <p><code class="codeph">OCI_PTYPE_SCHEMA</code> ，用于模式</p>
                        </li>
                        <li>
                           <p><code class="codeph">OCI_PTYPE_DATABASE</code> ，用于数据库</p>
                        </li>
                        <li>
                           <p><code class="codeph">OCI_PTYPE_UNK</code> ，用于未知的模式对象</p>
                        </li>
                     </ul>
                     <dl>
                        <dt class="dlterm"><a name="GUID-AE9F73FB-DCC1-401E-8151-A8A89059163A__GUID-065F34AE-3C06-44C6-8D3B-56B4F109443E"><!-- --></a> dschp（输入/输出）</dt>
                        <dd>
                           <p>描述句柄，在调用后填充有关对象的描述信息。必须是非<code class="codeph">NULL</code> 。</p>
                        </dd>
                     </dl>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-AE9F73FB-DCC1-401E-8151-A8A89059163A__GUID-8B77A471-E44B-49D1-B96A-B4B5733D041F">评论</p>
                     <p>这是描述现有模式对象的通用描述调用：表，视图，同义词，过程，函数，包，序列，类型，模式和数据库。此外， <code class="codeph">OCIDescribeAny()</code>调用描述了包中包含的所有包类型和包类型属性。此调用还描述了子模式对象，例如表中的列。此调用使用可通过<code class="codeph">OCIAttrGet()</code>调用获取的特定于对象的属性填充describe句柄。
                     </p>
                     <p>describe句柄上的<code class="codeph">OCIParamGet()</code>返回指定位置的参数描述符。参数位置以1开头。在参数描述符上调用<code class="codeph">OCIAttrGet()</code>将返回存储过程或函数参数或表列描述符的特定属性。这些后续调用不需要额外的往返服务器，因为<code class="codeph">OCIDescribeAny()</code>在客户端缓存整个模式对象描述。在describe句柄上调用<code class="codeph">OCIAttrGet()</code>也会返回总位数。
                     </p>
                     <p>如果在<code class="codeph">OCI_ATTR_DESC_PUBLIC</code>句柄上设置了<code class="codeph">OCI_ATTR_DESC_PUBLIC</code>属性，则当该对象在当前模式中不存在且仅指定<code class="codeph">name1</code>时，将查找名为的对象作为公共同义词。
                     </p>
                     <p>默认情况下，显式描述（ <code class="codeph">OCIDescribeAny()</code> ）不会列出不可见列。要获取用户定义的不可见列的元数据，必须在调用<code class="codeph">OCIDescribeAny()</code>之前设置describe handle属性<code class="codeph">OCI_ATTR_SHOW_INVISIBLE_COLUMNS</code> 。要知道列是否为不可见类型，可以使用<code class="codeph">OCIAttrGet()</code>获取列属性<code class="codeph">OCI_ATTR_INVISIBLE_COL</code> 。
                     </p>
                     <p>用户可以控制列是否可见的属性。除非在<code class="codeph">SELECT</code>列表中明确指定，否则看不到不可见列。表的任何通用访问（例如<code class="codeph">SELECT * FROM</code> <span class="italic"><code class="codeph">table-name</code></span>语句或<code class="codeph">DESCRIBE</code>语句）都不会显示不可见的列。
                     </p>
                  </div>
                  <!-- class="section" -->
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="handle-and-descriptor-functions.html#GUID-E9EF2766-E078-49A7-B1D1-738E4BA4814F" title="分配存储以保存描述符或LOB定位符。">OCIDescriptorAlloc（）</a></li>
                        <li><a href="handle-and-descriptor-functions.html#GUID-35D2FF91-139B-4A5C-97C8-8BC29866CCA4" title="返回由describe句柄或语句句柄中的position指定的参数的描述符。">OCIParamGet（）</a></li>
                        <li><a href="handle-and-descriptor-functions.html#GUID-FA199A99-4D7A-42C2-BB0A-C20047B95DF9" title="获取句柄属性的值。">OCIAttrGet（）</a></li>
                        <li><a href="miscellaneous-functions.html#GUID-4B99087C-74F6-498A-8310-D6645172390A" title="返回错误消息和Oracle数据库错误代码。">OCIErrorGet（）</a></li>
                     </ul>
                  </div>
                  <div class="infoboxnotealso" id="GUID-AE9F73FB-DCC1-401E-8151-A8A89059163A__GUID-39096BF1-2ED9-4543-920E-79BEF4D88A9F">
                     <p class="notep1">也可以看看：</p>
                     <p><a href="describing-schema-metadata.html#GUID-CED0D15A-D873-43F7-A5B2-51FC0662C250" title="执行模式对象及其子模式对象的显式描述。OCIDescribeAny（）调用限制返回到基本信息的信息，并停止扩展节点（如果它等于另一个描述操作）。执行描述操作时应注意什么。OCI_ATTR_TYPECODE属性返回表示使用CREATE TYPE语句创建新类型时用户提供的类型的类型代码。要描述类型对象，必须在对象模式下初始化OCI进程。可以使用带有OCIStmtExecute（）的隐式描述和带有OCIDescribeAny（）的显式描述来返回列属性OCI_ATTR_PRECISION。类型方法的OCI_ATTR_LIST_ARGUMENTS属性表示方法的第二级参数。本节介绍属于不同参数的属性和句柄。列出并描述表或视图的参数的类型特定属性。列出并描述参数用于过程或函数时的特定于类型的属性。列出并描述参数用于包时的属性。列出并描述参数用于类型时的属性。列出并描述参数用于类型属性时的属性。当参数用于类型的方法时，列出并记录属性。列出并描述参数用于集合类型时的属性。列出并描述参数用于同义词时的属性。列出并描述参数用于序列时的属性。列出并描述参数用于表或视图列时的属性。列出并描述参数用于过程或函数的参数时的属性。当参数用于列，参数和子程序列表或包记录类型的字段时，列出并描述属性。列出并描述参数用于模式类型时的属性。列出并描述参数用于数据库类型时的属性。列出并描述参数用于规则时的属性。列出并描述参数用于规则集时的属性。列出并描述参数用于评估上下文时的属性。列出并描述参数用于表别名时的属性。列出并描述参数用于变量时的属性。列出并描述参数用于名称 - 值对时的属性。查询和列信息支持字符长度语义。如果使用字符长度语义创建数据库列，则隐式描述信息包含字符长度，字节长度和指示如何创建数据库列的标志。表的显式描述有三个属性：OCI_ATTR_DATA_SIZE，OCI_ATTR_CHAR_SIZE和OCI_ATTR_CHAR_USED.Character-length语义取决于服务器或客户端的发布。最好在服务器和客户端都是Oracle9i或更高版本时进行描述。否则，将导致兼容性问题。以下示例演示了如何使用OCIDescribeAny（）来描述不同类型的架构对象。说明使用显式描述来检索表的列数据类型。描述类型方法（也分为函数和过程）所需的步骤与常规PL / SQL函数和过程相同。说明在命名对象类型上使用显式描述。说明在命名集合类型上使用显式描述。显示一个循环，用于在查询执行后检索与查询对应的列名和数据类型。说明使用不可见列属性并检查每列以确定它是否为不可见列。">描述架构元数据</a>以获取有关描述操作的更多信息</p>
                  </div>
               </div>
               
            </div><a id="LNOCI17149"></a><div class="props_rev_3"><a id="GUID-87D50C09-F18D-45BB-A8AF-1E6AFEC6FE2E" name="GUID-87D50C09-F18D-45BB-A8AF-1E6AFEC6FE2E"></a><h3 id="LNOCI-GUID-87D50C09-F18D-45BB-A8AF-1E6AFEC6FE2E" class="sect3"><span class="enumeration_section">25.4.14</span> OCIStmtGetBindInfo（）</h3>
               <div>
                  <p>获取绑定和指示符变量名称。</p>
                  <div class="section">
                     <p class="subhead2" id="GUID-87D50C09-F18D-45BB-A8AF-1E6AFEC6FE2E__GUID-8EC7361E-6D38-44E7-A3D5-7C949A78BE7B">目的</p>
                     <p>获取绑定和指示符变量名称。</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-87D50C09-F18D-45BB-A8AF-1E6AFEC6FE2E__GUID-A8F23380-4BD9-4BFD-9F73-31C94503AAE7">句法</p><pre class="oac_no_warn" dir="ltr">剑OCIStmtGetBindInfo（OCIStmt * stmtp，OCIError * errhp，ub4 size，ub4 startloc，sb4 * found，OraText * bvnp []，ub1 bvnl []，OraText * invp []，ub1 inpl []，ub1 dupl []，OCIBind * hndl []）;</pre></div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-87D50C09-F18D-45BB-A8AF-1E6AFEC6FE2E__GUID-30FFE423-C1BD-4D1A-A85B-DFDC3F44BF78">参数</p>
                     <dl>
                        <dt class="dlterm"><a name="GUID-87D50C09-F18D-45BB-A8AF-1E6AFEC6FE2E__GUID-24FF3D7E-35A5-4E71-817B-DDA964196DDE"><!-- --></a> <span class="bold">stmtp</span> （IN）</dt>
                        <dd>
                           <p>由<code class="codeph">OCIStmtPrepare2()</code>准备的语句句柄。
                           </p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-87D50C09-F18D-45BB-A8AF-1E6AFEC6FE2E__GUID-751B1009-B9AE-4559-9882-5CA37C003E0F"><!-- --></a> <span class="bold">errhp</span> （IN）</dt>
                        <dd>
                           <p>一个错误句柄，您可以在出现错误时传递给<code class="codeph">OCIErrorGet()</code>以获取诊断信息。
                           </p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-87D50C09-F18D-45BB-A8AF-1E6AFEC6FE2E__GUID-991394DA-13EE-43E5-8AF2-0419FB274DBC"><!-- --></a> <span class="bold">尺寸</span> （IN）</dt>
                        <dd>
                           <p>每个数组中的元素数。</p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-87D50C09-F18D-45BB-A8AF-1E6AFEC6FE2E__GUID-C2A6DC34-1B47-4EA1-93AC-A60C23DE40E1"><!-- --></a> <span class="bold">startloc</span> （IN）</dt>
                        <dd>
                           <p>绑定变量的位置，在该位置开始获取绑定信息。</p>
                        </dd>
                        <dt class="dlterm"><span class="bold">找到</span> <a name="GUID-87D50C09-F18D-45BB-A8AF-1E6AFEC6FE2E__GUID-4E8551B0-455B-4750-A8A2-3AB8EFFB4ABD"><!-- --></a> （IN）</dt>
                        <dd>
                           <p>表达式<code class="codeph">abs</code> （ <code class="codeph">found</code> ）给出了语句中绑定变量的总数，与起始位置无关。如果返回的绑定变量数小于提供的大小，则为正值，否则为负数。
                           </p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-87D50C09-F18D-45BB-A8AF-1E6AFEC6FE2E__GUID-B42391E8-F766-41BC-96D7-43E3D5A8FFD1"><!-- --></a> bvnp（OUT）</dt>
                        <dd>
                           <p>用于保存绑定变量名称的指针数组。是在前一次调用<code class="codeph">OCIEnvNlsCreate()</code>的<code class="codeph">charset</code>参数指定的编码中。
                           </p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-87D50C09-F18D-45BB-A8AF-1E6AFEC6FE2E__GUID-68C44662-537E-4D6B-8DAF-7E28EB622E90"><!-- --></a> bvnl（OUT）</dt>
                        <dd>
                           <p>用于保存每个<code class="codeph">bvnp</code>元素长度的数组。长度以字节为单位。
                           </p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-87D50C09-F18D-45BB-A8AF-1E6AFEC6FE2E__GUID-F36C8667-16C9-4E40-80DA-B1DAB1086E83"><!-- --></a> invp（OUT）</dt>
                        <dd>
                           <p>用于保存指示符变量名称的指针数组。必须采用前一次调用<code class="codeph">OCIEnvNlsCreate()</code>的<code class="codeph">charset</code>参数指定的编码。
                           </p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-87D50C09-F18D-45BB-A8AF-1E6AFEC6FE2E__GUID-0CC7DEA3-7029-4541-A253-B56E29F406B2"><!-- --></a> inpl（OUT）</dt>
                        <dd>
                           <p>用于保存每个<code class="codeph">invp</code>元素长度的指针数组。以字节数表示。
                           </p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-87D50C09-F18D-45BB-A8AF-1E6AFEC6FE2E__GUID-04AAECB5-2BA3-4989-90F3-3C64254A325A"><!-- --></a> dupl（OUT）</dt>
                        <dd>
                           <p>元素值为0或1的数组，具体取决于绑定位置是否与另一个绑定位置重复。</p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-87D50C09-F18D-45BB-A8AF-1E6AFEC6FE2E__GUID-63F85BB1-07E4-460A-A540-A986E8A09081"><!-- --></a> hndl（OUT）</dt>
                        <dd>
                           <p>如果已对绑定位置进行绑定，则返回绑定句柄的数组。没有为重复项返回句柄。</p>
                        </dd>
                     </dl>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-87D50C09-F18D-45BB-A8AF-1E6AFEC6FE2E__GUID-B513115D-B1B2-4EF7-9FEC-19F2B9F4CE20">评论</p>
                     <p>在调用语句后，此调用将返回有关绑定变量的信息。这包括绑定名称，指示符名称以及绑定是否是重复绑定。如果有，则此调用还会返回关联的绑定句柄。该调用将<code class="codeph">found</code>参数设置为绑定变量的总数，而不仅仅是不同绑定变量的数量。
                     </p>
                     <p>如果语句没有绑定变量或者在语句中不存在调用中指定的起始绑定位置，则返回<code class="codeph">OCI_NO_DATA</code> 。
                     </p>
                     <p>此函数不包括<code class="codeph">SELECT INTO</code>列表变量，因为它们不被视为绑定。
                     </p>
                     <p>该声明必须在调用之前调用<code class="codeph">OCIStmtPrepare2()</code> 。语句句柄中的编码设置确定是否检索Unicode字符串。
                     </p>
                     <p>此呼叫在本地处理。</p>
                  </div>
                  <!-- class="section" -->
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="statement-functions.html#GUID-E6C1DC67-D464-4D2A-9F19-737423D31779" title="准备SQL或PL / SQL语句以便执行。">OCIStmtPrepare2（）</a></li>
                        <li><a href="connect-authorize-and-initialize-functions.html#GUID-0B6911A9-4B46-476C-BC5E-B87581666CD9" title="创建并初始化OCI函数的环境句柄。">OCIEnvNlsCreate（）</a></li>
                        <li><a href="miscellaneous-functions.html#GUID-4B99087C-74F6-498A-8310-D6645172390A" title="返回错误消息和Oracle数据库错误代码。">OCIErrorGet（）</a></li>
                     </ul>
                  </div>
               </div>
               
            </div>
         </div>
      </article>
   </body>
</html>