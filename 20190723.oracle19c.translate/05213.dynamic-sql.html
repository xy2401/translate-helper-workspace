<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <meta name="abstract" content="Dynamic SQL is a programming methodology for generating and running SQL statements at run time."></meta>
      <meta name="description" content="Dynamic SQL is a programming methodology for generating and running SQL statements at run time."></meta>
      <title>PL / SQL动态SQL</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Database PL/SQL Language Reference "></meta>
      <meta property="og:description" content="Dynamic SQL is a programming methodology for generating and running SQL statements at run time."></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Database PL/SQL Language Reference"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="database-pl-sql-language-reference.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-13T20:26:20-08:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="1996, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96448-02"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="static-sql.html" title="Previous" type="text/html"></link>
      <link rel="next" href="plsql-subprograms.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Database PL/SQL Language Reference"></meta>
    <meta name="dcterms.isVersionOf" content="LNPLS"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="static-sql.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="plsql-subprograms.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">数据库PL / SQL语言参考</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">PL / SQL动态SQL</li>
            </ol>
            <a id="GUID-7E2F596F-9CA3-4DC8-8333-0C117962DB73" name="GUID-7E2F596F-9CA3-4DC8-8333-0C117962DB73"></a><a id="LNPLS513"></a><a id="LNPLS011"></a>
            
            <h2 id="LNPLS-GUID-7E2F596F-9CA3-4DC8-8333-0C117962DB73" class="sect2"><span class="enumeration_chapter">7</span> PL / SQL动态SQL</h2>
         </header>
         <div class="ind">
            <div>
               <p><span class="bold">动态SQL</span>是一种在运行时生成和运行SQL语句的编程方法。
               </p>
               <p>在编写通用查询系统等通用和灵活程序，编写必须运行数据库定义语言（DDL）语句的程序时，或者在编译时不知道SQL语句的全文或数字时，它非常有用或其输入和输出变量的数据类型。</p>
               <p>PL / SQL提供了两种编写动态SQL的方法：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p>本机动态SQL，一种用于构建和运行动态SQL语句的PL / SQL语言（即本机）功能</p>
                  </li>
                  <li>
                     <p><code class="codeph">DBMS_SQL</code>包，用于构建，运行和描述动态SQL语句的API</p>
                  </li>
               </ul>
               <p>本机动态SQL代码比使用<code class="codeph">DBMS_SQL</code>包的等效代码更容易读取和写入，并且运行速度明显更快（特别是当它可以由编译器优化时）。但是，要编写本机动态SQL代码，必须在编译时知道动态SQL语句的输入和输出变量的数量和数据类型。如果在编译时不知道此信息，则必须使用<code class="codeph">DBMS_SQL</code>包。如果希望存储的子程序隐式返回查询结果（而不是通过<code class="codeph">OUT</code> <code class="codeph">REF</code> <code class="codeph">CURSOR</code>参数），则还必须使用<code class="codeph">DBMS_SQL</code>包。
               </p>
               <p>当您需要<code class="codeph">DBMS_SQL</code>包和本机动态SQL时，可以使用<span class="q">“ <a href="dynamic-sql.html#GUID-A194C9FA-221A-466B-9179-6238FEC5143B">DBMS_SQL.TO_REFCURSOR函数</a> ”</span>和<span class="q">“ <a href="dynamic-sql.html#GUID-8DF5B8A3-70F8-4AF5-A747-B1CE6B7D90DF">DBMS_SQL.TO_CURSOR_NUMBER函数</a> ”</span>在它们之间切换。
               </p>
               <div class="section">
                  <p class="subhead1" id="GUID-7E2F596F-9CA3-4DC8-8333-0C117962DB73__GUID-44B456EB-7CB5-4348-AAA6-8A004AE3CF99">话题</p>
               </div>
               <!-- class="section" -->
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="dynamic-sql.html#GUID-DAFD83C8-FA3A-40A6-95E5-3B2F082E1798">何时需要动态SQL</a></p>
                  </li>
                  <li>
                     <p><a href="dynamic-sql.html#GUID-D2613968-6660-4AA2-9057-28E425A3040D" title="本机动态SQL使用EXECUTE IMMEDIATE语句处理大多数动态SQL语句。">本机动态SQL</a></p>
                  </li>
                  <li>
                     <p><a href="dynamic-sql.html#GUID-4E1FD47B-7E1A-42E9-9792-210F13C75A1B" title="DBMS_SQL包定义了一个称为SQL游标号的实体。因为SQL游标号是PL / SQL整数，所以可以将其传递到调用边界并存储它。">DBMS_SQL包</a></p>
                  </li>
                  <li>
                     <p><a href="dynamic-sql.html#GUID-1E31057E-057F-4A53-B1DD-8BC2C337AA2C" title="SQL注入恶意利用在SQL语句中使用客户端提供的数据的应用程序，从而获得对数据库的未授权访问以查看或操纵受限数据。">SQL注入</a></p>
                  </li>
               </ul>
            </div><a id="LNPLS01101"></a><div class="props_rev_3"><a id="GUID-DAFD83C8-FA3A-40A6-95E5-3B2F082E1798" name="GUID-DAFD83C8-FA3A-40A6-95E5-3B2F082E1798"></a><h3 id="LNPLS-GUID-DAFD83C8-FA3A-40A6-95E5-3B2F082E1798" class="sect3"><span class="enumeration_section">7.1</span>何时需要动态SQL</h3>
               <div>
                  <p>在PL / SQL中，您需要运行动态SQL：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>编译时文本未知的SQL</p>
                        <p>例如， <code class="codeph">SELECT</code>语句包含在编译时未知的标识符（例如表名）或<code class="codeph">WHERE</code>子句，其中子条目的数量在编译时是未知的。
                        </p>
                     </li>
                     <li>
                        <p>不支持作为静态SQL的SQL</p>
                        <p>也就是说，任何SQL构造都不包含在<span class="q">“ <a href="static-sql.html#GUID-54ABD9E3-EA4D-4C60-A84A-021925501C0C" title="除非另有说明，否则静态SQL具有与SQL相同的语法。">静态SQL的描述</a> ”中</span> 。
                        </p>
                     </li>
                  </ul>
                  <p>如果您不需要动态SQL，请使用具有以下优点的静态SQL：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>成功编译将验证静态SQL语句是否引用了有效的数据库对象，以及是否具有访问这些对象所需的特权。</p>
                     </li>
                     <li>
                        <p>成功编译会创建架构对象依赖项。</p>
                        <p>有关架构对象依赖关系的信息，请参阅“ <a href="../adfns/schema-object-dependency.html#ADFNS99967" target="_blank"><span class="italic">Oracle数据库开发指南”</span></a> 。
                        </p>
                     </li>
                  </ul>
                  <p>有关在PL / SQL中使用静态SQL语句的信息，请参阅<a href="static-sql.html#GUID-A2E4086F-94DC-4CC7-9E4B-30285BEC3313" title="静态SQL是一种PL / SQL功能，它允许直接在PL / SQL语句中使用SQL语法。">PL / SQL静态SQL</a> 。</p>
               </div>
            </div><a id="LNPLS514"></a><a id="LNPLS01102"></a><div class="props_rev_3"><a id="GUID-D2613968-6660-4AA2-9057-28E425A3040D" name="GUID-D2613968-6660-4AA2-9057-28E425A3040D"></a><h3 id="LNPLS-GUID-D2613968-6660-4AA2-9057-28E425A3040D" class="sect3"><span class="enumeration_section">7.2本</span>机动态SQL</h3>
               <div>
                  <p>本机动态SQL使用<code class="codeph">EXECUTE</code> <code class="codeph">IMMEDIATE</code>语句处理大多数动态SQL语句。
                  </p>
                  <p>如果动态SQL语句是返回多行的<code class="codeph">SELECT</code>语句，则本机动态SQL为您提供以下选择：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>将<code class="codeph">EXECUTE</code> <code class="codeph">IMMEDIATE</code>语句与<code class="codeph">BULK</code> <code class="codeph">COLLECT</code> <code class="codeph">INTO</code>子句一起使用。
                        </p>
                     </li>
                     <li>
                        <p>使用<code class="codeph">OPEN</code> <code class="codeph">FOR</code> ， <code class="codeph">FETCH</code>和<code class="codeph">CLOSE</code>语句。
                        </p>
                     </li>
                  </ul>
                  <p>在本机动态SQL <code class="codeph">INSERT</code> ， <code class="codeph">UPDATE</code> ， <code class="codeph">DELETE</code> ， <code class="codeph">MERGE</code>和单行<code class="codeph">SELECT</code>语句之后，SQL游标属性的工作方式与它们的静态SQL对应项相同。有关SQL游标属性的更多信息，请参阅<span class="q">“ <a href="static-sql.html#GUID-F1FE15F9-5C96-4C4E-B240-B7363D25A8F1" title="游标是指向私有SQL区域的指针，该区域存储有关处理特定SELECT或DML语句的信息。">游标概述</a> ”</span> 。
                  </p>
                  <div class="section">
                     <p class="subhead2" id="GUID-D2613968-6660-4AA2-9057-28E425A3040D__GUID-9C922323-0C53-4EFD-A818-B4BBD2C93A2B">话题</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="dynamic-sql.html#GUID-30ADFC05-8DFB-4C8A-831D-426C2E97F217" title="EXECUTE IMMEDIATE语句是本机动态SQL处理大多数动态SQL语句的方法。">EXECUTE IMMEDIATE声明</a></p>
                        </li>
                        <li>
                           <p><a href="dynamic-sql.html#GUID-BAC52F38-B427-4860-9B6D-336B3AEE6AD2">OPEN FOR，FETCH和CLOSE语句</a></p>
                        </li>
                        <li>
                           <p><a href="dynamic-sql.html#GUID-4E5C6A4F-C1DB-44DD-964E-C683120B448E" title="如果在动态SQL语句中重复占位符名称，请注意占位符与绑定变量关联的方式取决于动态SQL语句的类型。">动态SQL语句中重复的占位符名称</a></p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
               </div><a id="LNPLS626"></a><a id="LNPLS515"></a><a id="LNPLS516"></a><a id="LNPLS517"></a><a id="LNPLS1854"></a><a id="LNPLS1855"></a><a id="LNPLS628"></a><a id="LNPLS01115"></a><div class="props_rev_3"><a id="GUID-30ADFC05-8DFB-4C8A-831D-426C2E97F217" name="GUID-30ADFC05-8DFB-4C8A-831D-426C2E97F217"></a><h4 id="LNPLS-GUID-30ADFC05-8DFB-4C8A-831D-426C2E97F217" class="sect4"><span class="enumeration_section">7.2.1</span> EXECUTE IMMEDIATE语句</h4>
                  <div>
                     <p><code class="codeph">EXECUTE</code> <code class="codeph">IMMEDIATE</code>语句是本机动态SQL处理大多数动态SQL语句的方法。
                     </p>
                     <p>如果动态SQL语句是<span class="bold">自包含的</span> （即，如果它没有绑定变量的占位符，并且它可能返回的唯一结果是错误），那么<code class="codeph">EXECUTE</code> <code class="codeph">IMMEDIATE</code>语句不需要子句。
                     </p>
                     <p>如果动态SQL语句包含绑定变量的占位符，则每个占位符必须在<code class="codeph">EXECUTE</code> <code class="codeph">IMMEDIATE</code>语句的相应子句中具有相应的绑定变量，如下所示：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>如果动态SQL语句是最多可返回一行的<code class="codeph">SELECT</code>语句，则在<code class="codeph">INTO</code>子句中放置绑定变量（定义），在<code class="codeph">USING</code>子句中放入绑定变量。
                           </p>
                        </li>
                        <li>
                           <p>如果动态SQL语句是可以返回多行的<code class="codeph">SELECT</code>语句，则在<code class="codeph">BULK</code> <code class="codeph">COLLECT</code> <code class="codeph">INTO</code>子句中放置绑定变量（定义），在<code class="codeph">USING</code>子句中放入绑定变量。
                           </p>
                        </li>
                        <li>
                           <p>如果动态SQL语句是没有<code class="codeph">RETURNING</code> <code class="codeph">INTO</code>子句的DML语句（ <code class="codeph">SELECT</code>除外），则将所有绑定变量放在<code class="codeph">USING</code>子句中。
                           </p>
                        </li>
                        <li>
                           <p>如果动态SQL语句是带有<code class="codeph">RETURNING</code> <code class="codeph">INTO</code>子句的DML语句，则在<code class="codeph">USING</code>子句中放入绑定变量，在<code class="codeph">RETURNING</code> <code class="codeph">INTO</code>子句中输出out-bind变量。
                           </p>
                        </li>
                        <li>
                           <p>如果动态SQL语句是匿名PL / SQL块或<code class="codeph">CALL</code>语句，请将所有绑定变量放在<code class="codeph">USING</code>子句中。
                           </p>
                           <p>如果动态SQL语句调用子程序，请确保：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>子程序可以在模式级别创建，也可以在包规范中声明和定义。</p>
                              </li>
                              <li>
                                 <p>对应于子程序参数的占位符的每个绑定变量都具有与该子程序参数相同的参数模式以及与子程序参数的数据类型兼容的数据类型。</p>
                              </li>
                              <li>
                                 <p>没有绑定变量是保留字<code class="codeph">NULL</code> 。</p>
                                 <p>要解决此限制，请使用未初始化的变量，以便使用<code class="codeph">NULL</code> ，如<a href="dynamic-sql.html#GUID-30ADFC05-8DFB-4C8A-831D-426C2E97F217__BHCBIICB">例7-7所示</a> 。
                                 </p>
                              </li>
                              <li>
                                 <p>没有绑定变量具有SQL不支持的数据类型（例如由字符串索引的关联数组）。</p>
                                 <p>如果数据类型是集合或记录类型，则必须在包规范中声明它。</p>
                              </li>
                           </ul>
                        </li>
                     </ul>
                     <div class="infoboxnote" id="GUID-30ADFC05-8DFB-4C8A-831D-426C2E97F217__GUID-C61A4D55-E5C8-4939-BD57-9D81EF049CC3">
                        <p class="notep1">注意：</p>
                        <p>可以按任何顺序评估绑定变量。如果程序确定评估顺序，那么在程序执行此操作时，其行为是不确定的。</p>
                     </div>
                     <p>在<a href="dynamic-sql.html#GUID-30ADFC05-8DFB-4C8A-831D-426C2E97F217__CHDECEFD">例7-4</a> ， <a href="dynamic-sql.html#GUID-30ADFC05-8DFB-4C8A-831D-426C2E97F217__CHDFAJCJ">例7-5</a>和<a href="dynamic-sql.html#GUID-30ADFC05-8DFB-4C8A-831D-426C2E97F217__CHDJAAIJ">例7-6中</a> ，动态PL / SQL块是一个匿名PL / SQL块，它调用具有PL / SQL集合类型的形式参数的子程序。集合类型不是SQL数据类型。在每个示例中，集合类型在包规范中声明，子程序在包规范中声明并在包体中定义。
                     </p>
                     <div class="infoboxnotealso" id="GUID-30ADFC05-8DFB-4C8A-831D-426C2E97F217__GUID-DFDCF893-E357-49BA-B39C-5105AEB3E0BB">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>有关在模式级别创建函数的信息，请<span class="q"><a href="CREATE-FUNCTION-statement.html#GUID-B71BC5BD-B87C-4054-AAA5-213E856651F2" title="The CREATE FUNCTION statement creates or replaces a standalone function or a call specification.">参见</a> “ <a href="CREATE-FUNCTION-statement.html#GUID-B71BC5BD-B87C-4054-AAA5-213E856651F2" title="CREATE FUNCTION语句创建或替换独立函数或调用规范。">CREATE FUNCTION语句</a> ”</span></p>
                           </li>
                           <li>
                              <p><span class="q">“ <a href="CREATE-PROCEDURE-statement.html#GUID-5F84DB47-B5BE-4292-848F-756BF365EC54" title="CREATE PROCEDURE语句创建或替换独立过程或调用规范。">CREATE PROCEDURE Statement</a> ”</span>有关在模式级别创建过程的信息</p>
                           </li>
                           <li>
                              <p>有关包的信息，请参阅<span class="q">“ <a href="plsql-packages.html#GUID-C285EC5A-BE50-4192-A88E-48C0778B34E0" title="本章介绍如何将相关的PL / SQL代码和数据捆绑到一个包中，其内容可供许多应用程序使用。">PL / SQL包</a> ”</span></p>
                           </li>
                           <li>
                              <p><span class="q">“ <a href="CREATE-PACKAGE-statement.html#GUID-03A70A54-90FF-4293-B6B8-F0B35E184AC5" title="CREATE PACKAGE语句创建或替换存储包的规范，存储包是数据库中作为一个单元存储的相关过程，函数和其他程序对象的封装集合。">CREATE PACKAGE Statement</a> ”</span>有关在包中声明子程序的信息</p>
                           </li>
                           <li>
                              <p><span class="q">“ <a href="CREATE-PACKAGE-BODY-statement.html#GUID-68526FF2-96A1-4F14-A10B-4DD3E1CD80BE" title="CREATE PACKAGE BODY语句创建或替换存储包的主体，该包是相关过程，存储函数和作为单元存储在数据库中的其他程序对象的封装集合。">CREATE PACKAGE BODY Statement</a> ”</span>有关在包中声明和定义子程序的信息</p>
                           </li>
                           <li>
                              <p><span class="q">“ <a href="CREATE-PACKAGE-statement.html#GUID-03A70A54-90FF-4293-B6B8-F0B35E184AC5" title="CREATE PACKAGE语句创建或替换存储包的规范，存储包是数据库中作为一个单元存储的相关过程，函数和其他程序对象的封装集合。">CREATE PACKAGE语句</a> ”</span> ，以获取有关在包规范中声明类型的更多信息</p>
                           </li>
                           <li>
                              <p><span class="q">“ <a href="EXECUTE-IMMEDIATE-statement.html#GUID-C3245A95-B85B-4280-A01F-12307B108DC8" title="EXECUTE IMMEDIATE语句在单个操作中构建并运行动态SQL语句。">EXECUTE IMMEDIATE语句</a> ”，</span>为的语法细节<code class="codeph">EXECUTE</code> <code class="codeph">IMMEDIATE</code>语句</p>
                           </li>
                           <li>
                              <p>有关集合类型的信息，请参阅<span class="q">“ <a href="plsql-collections-and-records.html#GUID-7115C8B6-62F9-496D-BEC3-F7441DFE148A" title="PL / SQL允许您定义两种复合数据类型：集合和记录。">PL / SQL集合和记录</a> ”</span></p>
                           </li>
                        </ul>
                     </div>
                     <div class="example" id="GUID-30ADFC05-8DFB-4C8A-831D-426C2E97F217__CHDIEFCJ">
                        <p class="titleinexample">示例7-1从动态PL / SQL块调用子程序</p>
                        <p>在此示例中，动态PL / SQL块是一个匿名PL / SQL块，它调用在模式级别创建的子程序。</p><pre class="oac_no_warn" dir="ltr"><span class="bold">- 动态PL / SQL块调用的子程序：</span> CREATE OR REPLACE PROCEDURE create_dept（ <span class="bold">在OUT</span> NUMBER中设置，dname <span class="bold">在</span> VARCHAR2中，mgrid <span class="bold">在</span> NUMBER中，locid <span class="bold">在</span> NUMBER中）AUTHID DEFINER as BEGIN deptid：= departments_seq。NEXTVAL; INSERT INTO部门（department_id，department_name，manager_id，location_id）VALUES（deptid，dname，mgrid，locid）;结束; / DECLARE plsql_block VARCHAR2（500）; new_deptid NUMBER（4）; new_dname VARCHAR2（30）：='广告'; new_mgrid NUMBER（6）：= 200; new_locid NUMBER（4）：= 1700; BEGIN <span class="bold">- 动态PL / SQL块调用子程序：</span> plsql_block：='BEGIN create_dept（：a，：b，：c，：d）;结束;'; <span class="bold">/ *在USING子句中指定绑定变量。</span>
<span class="bold">指定第一个参数的模式。</span>
<span class="bold">默认情况下，其他参数的模式是正确的。* /</span> EXECUTE IMMEDIATE plsql_block使用<span class="bold">输出</span> new_deptid，new_dname，new_mgrid，new_locid;结束; /</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-30ADFC05-8DFB-4C8A-831D-426C2E97F217__CHDFCDFC">
                        <p class="titleinexample">例7-2用BOOLEAN形式参数动态调用子程序</p>
                        <p>在此示例中，动态PL / SQL块是一个匿名PL / SQL块，它调用具有PL / SQL（但不是SQL）数据类型<code class="codeph">BOOLEAN</code>的形式参数的子程序。</p><pre class="oac_no_warn" dir="ltr">创建或替换过程p（x <span class="bold">BOOLEAN</span> ）AUTHID DEFINER，如果x那么DBMS_OUTPUT.PUT_LINE（'x为真'）;万一;结束; / DECLARE dyn_stmt VARCHAR2（200）; <span class="bold">b BOOLEAN</span> ：= TRUE; BEGIN dyn_stmt：='BEGIN <span class="bold">p（：x）</span> ;结束;';执行立即dyn_stmt使用<span class="bold">b</span> ;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">x是真的</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-30ADFC05-8DFB-4C8A-831D-426C2E97F217__CHDFCAGD">
                        <p class="titleinexample">例7-3用RECORD形式参数动态调用子程序</p>
                        <p>在此示例中，动态PL / SQL块是一个匿名PL / SQL块，它调用具有PL / SQL（但不是SQL）数据类型<code class="codeph">RECORD</code>的形式参数的子程序。记录类型在包规范中声明，子程序在包规范中声明并在包体中定义。
                        </p><pre class="oac_no_warn" dir="ltr">创建或替换包装pkg AUTHID DEFINER作为<span class="bold">类型rec IS RECORD（n1 NUMBER，n2 NUMBER）;</span> <span class="bold">程序p（x OUT rec，y NUMBER，z NUMBER）;</span>结束pkg; /创建或替换包装体pkg作为程序p（x OUT rec，y NUMBER，z NUMBER）AS BEGIN x.n1：= y; x.n2：= z;结束p;结束pkg; / DECLARE <span class="bold">r pkg.rec;</span> dyn_str VARCHAR2（3000）; BEGIN dyn_str：='BEGIN pkg.p <span class="bold">（：x，6,8）;</span>结束;';执行立即dyn_str使用<span class="bold">OUT</span> ; DBMS_OUTPUT.PUT_LINE（'r.n1 ='|| r.n1）; DBMS_OUTPUT.PUT_LINE（'r.n2 ='|| r.n2）;结束; /</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-30ADFC05-8DFB-4C8A-831D-426C2E97F217__CHDECEFD">
                        <p class="titleinexample">示例7-4使用Assoc动态调用子程序。数组形式参数</p>
                        <p>在此示例中，动态PL / SQL块是一个匿名PL / SQL块，它调用子程序，该子程序具有由<code class="codeph">PLS_INTEGER</code>索引的PL / SQL集合类型关联数组的形式参数。</p>
                        <div class="infoboxnote" id="GUID-30ADFC05-8DFB-4C8A-831D-426C2E97F217__GUID-4A3E7FB5-07E9-42AF-B3BD-17B834418F49">
                           <p class="notep1">注意：</p>
                           <p>在此上下文中使用的关联数组类型必须由<code class="codeph">PLS_INTEGER</code>索引。</p>
                        </div><pre class="oac_no_warn" dir="ltr">创建或替换包pkg AUTHID DEFINER作为<span class="bold">类型number_names是VARCHAR2的表（5）</span> <span class="bold">INDEX BY PLS_INTEGER;</span> <span class="bold">PROCEDURE print_number_names（x number_names）;</span>结束pkg; /创建或替换包装体程pkg AS PROCEDURE print_number_names（x number_names）是从i开始的。第一.. x。最后的循环DBMS_OUTPUT.PUT_LINE（x（i））;结束循环;结束;结束pkg; / DECLARE <span class="bold">digit_names pkg.number_names;</span> dyn_stmt VARCHAR2（3000）; BEGIN digit_names（0）：='零'; digit_names（1）：='one'; digit_names（2）：='two'; digit_names（3）：='three'; digit_names（4）：='four'; digit_names（5）：='five'; digit_names（6）：='six'; digit_names（7）：='seven'; digit_names（8）：='八'; digit_names（9）：='nine'; dyn_stmt：='BEGIN <span class="bold">pkg.print_number_names（：x）;</span>结束;';执行IMMEDIATE dyn_stmt使用<span class="bold">digit_names</span> ;结束; /</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-30ADFC05-8DFB-4C8A-831D-426C2E97F217__CHDFAJCJ">
                        <p class="titleinexample">示例7-5使用嵌套表格形式参数动态调用子程序</p>
                        <p>在此示例中，动态PL / SQL块是一个匿名PL / SQL块，它调用具有PL / SQL集合类型嵌套表的形式参数的子程序。</p><pre class="oac_no_warn" dir="ltr">创建或替换包装pkg AUTHID DEFINER作为<span class="bold">TYPE名称IS TABLE OF VARCHAR2（10）;</span> <span class="bold">PROCEDURE print_names（x names）;</span>结束pkg; /创建或替换包装体pkg作为程序print_names（x名称）为x IN开始。第一.. x。最后的循环DBMS_OUTPUT.PUT_LINE（x（i））;结束循环;结束;结束pkg; / DECLARE <span class="bold">fruit pkg.names;</span> dyn_stmt VARCHAR2（3000）; BEGIN fruits：= pkg.names（'apple'，'banana'，'cherry'）; dyn_stmt：='BEGIN <span class="bold">pkg.print_names（：x）;</span>结束;';执行即时dyn_stmt使用<span class="bold">水果</span> ;结束; /</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-30ADFC05-8DFB-4C8A-831D-426C2E97F217__CHDJAAIJ">
                        <p class="titleinexample">例7-6用Varray形式参数动态调用子程序</p>
                        <p>在此示例中，动态PL / SQL块是一个匿名PL / SQL块，它调用具有PL / SQL集合类型varray的形式参数的子程序。</p><pre class="oac_no_warn" dir="ltr">创建或替换包装pkg AUTHID DEFINER作为<span class="bold">类型四个IS VARRAY（4）OF VARCHAR2（5）;</span> <span class="bold">程序print_foursome（x四人组）;</span>结束pkg; /创建或替换包装体pkg作为程序print_foursome（x四人组）如果是x，则开始。COUNT = 0那么DBMS_OUTPUT.PUT_LINE（'空'）;我喜欢我的x。第一.. x。最后的循环DBMS_OUTPUT.PUT_LINE（x（i））;结束循环;万一;结束;结束pkg; / DECLARE <span class="bold">指示pkg.foursome;</span> dyn_stmt VARCHAR2（3000）; BEGIN指示：= pkg.foursome（'north'，'south'，'east'，'west'）; dyn_stmt：='BEGIN <span class="bold">pkg.print_foursome（：x）;</span>结束;';执行立即dyn_stmt使用<span class="bold">指示</span> ;结束; /</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-30ADFC05-8DFB-4C8A-831D-426C2E97F217__BHCBIICB">
                        <p class="titleinexample">示例7-7未初始化的变量在USING子句中表示NULL</p>
                        <p>此示例使用未初始化的变量来表示<code class="codeph">USING</code>子句中的保留字<code class="codeph">NULL</code> 。
                        </p><pre class="oac_no_warn" dir="ltr">CREATE TABLE employees_temp AS SELECT * FROM EMPLOYEES; DECLARE a_null CHAR（1）; <span class="bold">- 在运行时自动设置为NULL</span> BEGIN EXECUTE IMMEDIATE'UPDATE employees_temp SET commission_pct = <span class="bold">：</span> <span class="bold">x'USING a_null</span> ;结束; /</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="LNPLS630"></a><a id="LNPLS519"></a><a id="LNPLS629"></a><div class="props_rev_3"><a id="GUID-BAC52F38-B427-4860-9B6D-336B3AEE6AD2" name="GUID-BAC52F38-B427-4860-9B6D-336B3AEE6AD2"></a><h4 id="LNPLS-GUID-BAC52F38-B427-4860-9B6D-336B3AEE6AD2" class="sect4"><span class="enumeration_section">7.2.2</span>打开FOR，FETCH和CLOSE语句</h4>
                  <div>
                     <p>如果动态SQL语句表示返回多行的<code class="codeph">SELECT</code>语句，则可以使用本机动态SQL处理它，如下所示：</p>
                     <ol>
                        <li>
                           <p>使用<code class="codeph">OPEN</code> <code class="codeph">FOR</code>语句将游标变量与动态SQL语句相关联。在<code class="codeph">OPEN</code> <code class="codeph">FOR</code>语句的<code class="codeph">USING</code>子句中，为动态SQL语句中的每个占位符指定一个绑定变量。
                           </p>
                           <p><code class="codeph">USING</code>子句不能包含文字<code class="codeph">NULL</code> 。要解决此限制，请使用未初始化的变量，以便使用<code class="codeph">NULL</code> ，如<a href="dynamic-sql.html#GUID-30ADFC05-8DFB-4C8A-831D-426C2E97F217__BHCBIICB">例7-7所示</a> 。
                           </p>
                        </li>
                        <li>
                           <p>使用<code class="codeph">FETCH</code>语句一次检索一个结果集行，一次检索几个结果集行，或一次检索所有结果集行。
                           </p>
                        </li>
                        <li>
                           <p>使用<code class="codeph">CLOSE</code>语句关闭游标变量。
                           </p>
                        </li>
                     </ol>
                     <p>如果集合符合<span class="q">“ <a href="static-sql.html#GUID-65ADB424-2C2D-49ED-9E98-99A3A68BA248">查询集合</a> ”中</span>的条件，则动态SQL语句可以查询集合。
                     </p>
                     <div class="infoboxnotealso" id="GUID-BAC52F38-B427-4860-9B6D-336B3AEE6AD2__GUID-A4B16287-D713-478E-8E53-B4F5A63D2C08">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>语法详细信息<span class="q">“ <a href="OPEN-FOR-statement.html#GUID-EB7AF439-FDD3-4461-9E3F-B621E8ABFB96" title="OPEN FOR语句将游标变量与查询相关联，分配数据库资源以处理查询，标识结果集，并将光标定位在结果集的第一行之前。">OPEN FOR Statement</a> ”</span></p>
                           </li>
                           <li>
                              <p><span class="q">“ <a href="FETCH-statement.html#GUID-75BC6E63-841A-4103-9B96-8AC97F5C28BB" title="FETCH语句从多行查询的结果集中检索数据行 - 一次一行，一次几行，或一次所有行 - 并将数据存储在变量，记录或集合中。">FETCH语句</a> ”</span>用于语法详细信息</p>
                           </li>
                           <li>
                              <p><span class="q">“ <a href="CLOSE-statement.html#GUID-46E7086C-8C29-4689-A062-0FF059E268FD" title="CLOSE语句关闭一个命名游标，释放其资源以供重用。">CLOSE Statement</a> ”</span>用于语法详细信息</p>
                           </li>
                        </ul>
                     </div>
                     <div class="example" id="GUID-BAC52F38-B427-4860-9B6D-336B3AEE6AD2__BHCFDIAI">
                        <p class="titleinexample">示例7-8具有OPEN FOR，FETCH和CLOSE语句的本机动态SQL</p>
                        <p>此示例列出了作为管理员的所有员工，一次检索一个结果集行。</p><pre class="oac_no_warn" dir="ltr">DECLARE TYPE EmpCurTyp是REF CURSOR; v_emp_cursor EmpCurTyp; emp_record employees％ROWTYPE; v_stmt_str VARCHAR2（200）; v_e_job employees.job％TYPE; BEGIN <span class="bold">- 带占位符的动态SQL语句：</span> v_stmt_str：='SELECT * FROM employees WHERE job_id =：j'; <span class="bold">- 打开游标并在USING子句中指定绑定变量：</span> OPEN v_emp_cursor FOR v_stmt_str使用'MANAGER'; <span class="bold">- 一次从结果集中获取行：</span> LOOP FETCH v_emp_cursor INTO emp_record;退出时v_emp_cursor％NOTFOUND;结束循环; <span class="bold">- 关闭游标：</span> CLOSE v_emp_cursor;结束; /</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-BAC52F38-B427-4860-9B6D-336B3AEE6AD2__CHDDBFJB">
                        <p class="titleinexample">示例7-9使用本机动态SQL查询集合</p>
                        <p>此示例与<a href="static-sql.html#GUID-65ADB424-2C2D-49ED-9E98-99A3A68BA248__BABJDADA">示例6-30</a>类似，只是集合变量<code class="codeph">v1</code>是绑定变量。
                        </p><pre class="oac_no_warn" dir="ltr">创建或替换包装pkg AUTHID DEFINER作为类型rec IS RECORD（f1 NUMBER，f2 VARCHAR2（30））; TYPE mytab IS TABLE OF rec INDEX BY pls_integer;结束; / DECLARE <span class="bold">v1 pkg.mytab; - 记录集合</span> v2 pkg.rec; c1 SYS_REFCURSOR;开始<span class="bold">打开c1 FOR'SELECT * FROM TABLE（：1）'使用v1;</span> FETCH c1 INTO v2;关闭c1; DBMS_OUTPUT.PUT_LINE（'记录中的值为'|| v2.f1 ||'和'|| v2.f2）;结束; /</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="LNPLS520"></a><a id="LNPLS631"></a><div class="props_rev_3"><a id="GUID-4E5C6A4F-C1DB-44DD-964E-C683120B448E" name="GUID-4E5C6A4F-C1DB-44DD-964E-C683120B448E"></a><h4 id="LNPLS-GUID-4E5C6A4F-C1DB-44DD-964E-C683120B448E" class="sect4"><span class="enumeration_section">7.2.3</span>动态SQL语句中重复的占位符名称</h4>
                  <div>
                     <p>如果在动态SQL语句中重复占位符名称，请注意占位符与绑定变量关联的方式取决于动态SQL语句的类型。</p>
                     <div class="section">
                        <p class="subhead3" id="GUID-4E5C6A4F-C1DB-44DD-964E-C683120B448E__GUID-057AA3A3-A1A7-421B-AB14-8FA69A3C3509">话题</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="dynamic-sql.html#GUID-D17344F2-3CA5-4F33-A074-47E059CA91CC" title="如果动态SQL语句不表示匿名PL / SQL块或CALL语句，则重复占位符名称是无关紧要的。">动态SQL语句不是匿名阻止或CALL语句</a></p>
                           </li>
                           <li>
                              <p><a href="dynamic-sql.html#GUID-A31BBD6E-1CB5-47D2-A01B-48DC3BE203C7" title="如果动态SQL语句表示匿名PL / SQL块或CALL语句，则重复占位符名称很重要。">动态SQL语句是匿名块或CALL语句</a></p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div><a id="LNPLS632"></a><div class="props_rev_3"><a id="GUID-D17344F2-3CA5-4F33-A074-47E059CA91CC" name="GUID-D17344F2-3CA5-4F33-A074-47E059CA91CC"></a><h5 id="LNPLS-GUID-D17344F2-3CA5-4F33-A074-47E059CA91CC" class="sect5"><span class="enumeration_section">7.2.3.1</span>动态SQL语句不是匿名块或CALL语句</h5>
                     <div>
                        <p>如果动态SQL语句不表示匿名PL / SQL块或<code class="codeph">CALL</code>语句，则重复占位符名称是无关紧要的。
                        </p>
                        <p>占位符与<code class="codeph">USING</code>子句中的绑定变量按位置关联，而不是按名称关联。
                        </p>
                        <p>例如，在此动态SQL语句中，重复名称： <code class="codeph">x</code>无关紧要：</p><pre class="oac_no_warn" dir="ltr">sql_stmt：='INSERT INTO payroll VALUES（：x，：x，：y，：x）';</pre><p>在相应的<code class="codeph">USING</code>子句中，您必须提供四个绑定变量。它们可以是不同的;例如：</p><pre class="oac_no_warn" dir="ltr">EXECUTE IMMEDIATE sql_stmt使用a，b，c，d;</pre><p>前面的<code class="codeph">EXECUTE</code> <code class="codeph">IMMEDIATE</code>语句运行此SQL语句：</p><pre class="oac_no_warn" dir="ltr">插入工资单值（a，b，c，d）</pre><p>要将相同的绑定变量与每次出现的<code class="codeph">x</code>相关联，您必须重复该绑定变量;例如：</p><pre class="oac_no_warn" dir="ltr">EXECUTE IMMEDIATE sql_stmt使用a，a，b，a;</pre><p>前面的<code class="codeph">EXECUTE</code> <code class="codeph">IMMEDIATE</code>语句运行此SQL语句：</p><pre class="oac_no_warn" dir="ltr">INSERT INTO工资单值（a，a，b，a）</pre></div>
                  </div><a id="LNPLS634"></a><a id="LNPLS633"></a><div class="props_rev_3"><a id="GUID-A31BBD6E-1CB5-47D2-A01B-48DC3BE203C7" name="GUID-A31BBD6E-1CB5-47D2-A01B-48DC3BE203C7"></a><h5 id="LNPLS-GUID-A31BBD6E-1CB5-47D2-A01B-48DC3BE203C7" class="sect5"><span class="enumeration_section">7.2.3.2</span>动态SQL语句是匿名块或CALL语句</h5>
                     <div>
                        <p>如果动态SQL语句表示匿名PL / SQL块或<code class="codeph">CALL</code>语句，则重复占位符名称很重要。
                        </p>
                        <p>每个唯一占位符名称必须在<code class="codeph">USING</code>子句中具有相应的绑定变量。如果重复占位符名称，则无需重复其对应的绑定变量。对该占位符名称的所有引用都对应于<code class="codeph">USING</code>子句中的一个绑定变量。
                        </p>
                        <div class="example" id="GUID-A31BBD6E-1CB5-47D2-A01B-48DC3BE203C7__CHDFHEAG">
                           <p class="titleinexample">示例7-10动态PL / SQL块中重复的占位符名称</p>
                           <p>在此示例中，对第一个唯一占位符名称<code class="codeph">x</code>所有引用都与<code class="codeph">USING</code>子句中的第一个绑定变量<code class="codeph">a</code>相关联，第二个唯一占位符名称： <code class="codeph">y</code>与<code class="codeph">USING</code>的第二个绑定变量相关联。条款， <code class="codeph">b</code> 。
                           </p><pre class="oac_no_warn" dir="ltr">CREATE PROCEDURE calc_stats（w NUMBER，x NUMBER，y NUMBER，z NUMBER）是BEGIN DBMS_OUTPUT.PUT_LINE（w + x + y + z）;结束; / DECLARE一个数字：= 4; b NUMBER：= 7; plsql_block VARCHAR2（100）; BEGIN plsql_block：='BEGIN calc_stats（：x，：x，：y，：x）;结束;'; EXECUTE IMMEDIATE plsql_block使用a，b; <span class="bold">-  calc_stats（a，a，b，a）</span> END; /</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div>
               </div>
            </div><a id="LNPLS2173"></a><a id="LNPLS01108"></a><div class="props_rev_3"><a id="GUID-4E1FD47B-7E1A-42E9-9792-210F13C75A1B" name="GUID-4E1FD47B-7E1A-42E9-9792-210F13C75A1B"></a><h3 id="LNPLS-GUID-4E1FD47B-7E1A-42E9-9792-210F13C75A1B" class="sect3"><span class="enumeration_section">7.3</span> DBMS_SQL包</h3>
               <div>
                  <p>DBMS_SQL包定义了一个称为SQL游标号的实体。因为SQL游标号是PL / SQL整数，所以可以将其传递到调用边界并存储它。</p>
                  <p>如果满足以下任何条件，则必须使用<code class="codeph">DBMS_SQL</code>包来运行动态SQL语句：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>在运行时之前，您不知道<code class="codeph">SELECT</code>列表。
                        </p>
                     </li>
                     <li>
                        <p>直到运行时才知道必须绑定<code class="codeph">SELECT</code>或DML语句中的占位符。
                        </p>
                     </li>
                     <li>
                        <p>您希望存储的子程序隐式返回查询结果（而不是通过<code class="codeph">OUT</code> <code class="codeph">REF</code> <code class="codeph">CURSOR</code>参数），这需要<code class="codeph">DBMS_SQL</code> 。 <code class="codeph">RETURN_RESULT</code>程序。
                        </p>
                     </li>
                  </ul>
                  <p>在这些情况下，您必须使用本机动态SQL而不是<code class="codeph">DBMS_SQL</code>包：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>动态SQL语句将行检索到记录中。</p>
                     </li>
                     <li>
                        <p>在发出动态SQL语句（ <code class="codeph">INSERT</code> ， <code class="codeph">UPDATE</code> ， <code class="codeph">DELETE</code> ， <code class="codeph">MERGE</code>或单行<code class="codeph">SELECT</code>语句）之后，您希望使用SQL游标属性<code class="codeph">%FOUND</code> ， <code class="codeph">%ISOPEN</code> ， <code class="codeph">%NOTFOUND</code>或<code class="codeph">%ROWCOUNT</code> 。
                        </p>
                     </li>
                  </ul>
                  <p>当您需要<code class="codeph">DBMS_SQL</code>包和本机动态SQL时，可以使用<code class="codeph">DBMS_SQL</code>函数在它们之间切换。 <code class="codeph">TO_REFCURSOR</code>和<code class="codeph">DBMS_SQL</code> 。 <code class="codeph">TO_CURSOR_NUMBER</code> 。</p>
                  <div class="section">
                     <p class="subhead2" id="GUID-4E1FD47B-7E1A-42E9-9792-210F13C75A1B__GUID-F9B6E901-8744-4B79-81D0-98D843671A2A">话题</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="dynamic-sql.html#GUID-8CFE5AA9-0BBD-417B-A7EE-6F05AF49001B">DBMS_SQL.RETURN_RESULT过程</a></p>
                        </li>
                        <li>
                           <p><a href="dynamic-sql.html#GUID-1D6A4302-CBA0-47A6-B4A7-80B089DF4E61">DBMS_SQL.GET_NEXT_RESULT过程</a></p>
                        </li>
                        <li>
                           <p><a href="dynamic-sql.html#GUID-A194C9FA-221A-466B-9179-6238FEC5143B">DBMS_SQL.TO_REFCURSOR函数</a></p>
                        </li>
                        <li>
                           <p><a href="dynamic-sql.html#GUID-8DF5B8A3-70F8-4AF5-A747-B1CE6B7D90DF">DBMS_SQL.TO_CURSOR_NUMBER函数</a></p>
                        </li>
                     </ul>
                     <div class="infoboxnote" id="GUID-4E1FD47B-7E1A-42E9-9792-210F13C75A1B__GUID-05B48BB9-8E56-451E-A4DD-8E3A6047E821">
                        <p class="notep1">注意：</p>
                        <p>您可以远程调用<code class="codeph">DBMS_SQL</code>子程序。
                        </p>
                     </div>
                     <div class="infoboxnotealso" id="GUID-4E1FD47B-7E1A-42E9-9792-210F13C75A1B__GUID-9361F58E-E823-4C88-8DA9-00B9EAD77BEA">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><span class="q">“本<a href="dynamic-sql.html#GUID-D2613968-6660-4AA2-9057-28E425A3040D" title="本机动态SQL使用EXECUTE IMMEDIATE语句处理大多数动态SQL语句。">机动态SQL</a> ”，</span>用于获取有关本机动态SQL的信息</p>
                           </li>
                           <li>
                              <p><a href="../arpls/DBMS_SQL.html#ARPLS058" target="_blank"><span class="italic">Oracle Database PL / SQL包和类型参考</span></a>有关<code class="codeph">DBMS_SQL</code>包的更多信息，包括运行具有未知数量的输入或输出变量的动态SQL语句的说明（“方法4”）</p>
                           </li>
                        </ul>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div><a id="LNPLS2175"></a><a id="LNPLS2174"></a><div class="props_rev_3"><a id="GUID-8CFE5AA9-0BBD-417B-A7EE-6F05AF49001B" name="GUID-8CFE5AA9-0BBD-417B-A7EE-6F05AF49001B"></a><h4 id="LNPLS-GUID-8CFE5AA9-0BBD-417B-A7EE-6F05AF49001B" class="sect4"><span class="enumeration_section">7.3.1</span> DBMS_SQL.RETURN_RESULT过程</h4>
                  <div>
                     <p><code class="codeph">DBMS_SQL</code> 。 <code class="codeph">RETURN_RESULT</code>过程允许存储的子程序隐式地将查询结果返回给客户端程序（间接调用子程序）或子程序的直接调用者。在<code class="codeph">DBMS_SQL</code>之后。 <code class="codeph">RETURN_RESULT</code>返回结果，只有收件人才能访问它。
                     </p>
                     <p><code class="codeph">DBMS_SQL</code> 。 <code class="codeph">RETURN_RESULT</code>有两个重载：</p><pre class="oac_no_warn" dir="ltr">程序RETURN_RESULT（rc IN OUT <span class="bold">SYS_REFCURSOR</span> ，to_client in BOOLEAN DEFAULT TRUE）;程序RETURN_RESULT（rc IN OUT <span class="bold">INTEGER</span> ，to_client in BOOLEAN DEFAULT TRUE）;</pre><p><code class="codeph">rc</code>参数是打开游标变量（ <code class="codeph">SYS_REFCURSOR</code> ）或打开游标的游标号（ <code class="codeph">INTEGER</code> ）。要打开游标并获取其游标编号，请调用<code class="codeph">DBMS_SQL</code> 。 <code class="codeph">OPEN_CURSOR</code>函数，在<a href="../arpls/DBMS_SQL.html#ARPLS68275" target="_blank"><span class="italic">Oracle Database PL / SQL包和类型参考中描述</span></a> 。
                     </p>
                     <p>当<code class="codeph">to_client</code>参数为<code class="codeph">TRUE</code> （默认值）时，为<code class="codeph">DBMS_SQL</code> 。 <code class="codeph">RETURN_RESULT</code>过程将查询结果返回给客户端程序（间接调用子程序）;当此参数为<code class="codeph">FALSE</code> ，该过程将查询结果返回给子程序的直接调用者。
                     </p>
                     <div class="infoboxnotealso" id="GUID-8CFE5AA9-0BBD-417B-A7EE-6F05AF49001B__GUID-408BA65C-2409-4206-B3EC-27A403EA4EB7">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>有关<code class="codeph">DBMS_SQL</code>更多信息，请<a href="../arpls/DBMS_SQL.html#ARPLS73893" target="_blank"><span class="italic">参见Oracle Database PL / SQL包和类型参考</span></a> 。 <code class="codeph">RETURN_RESULT</code></p>
                           </li>
                           <li>
                              <p><a href="../lnoci/performance-topics.html#LNOCI73008" target="_blank"><span class="italic">Oracle调用接口程序员指南</span></a> ，了解有关隐式查询结果的C和.NET支持的信息</p>
                           </li>
                           <li>
                              <p><a href="../sqpug/using-scripts-in-SQL-Plus.html#SQPUG200" target="_blank"><span class="italic">SQL * Plus用户指南和参考</span></a>有关SQL * Plus支持隐式查询结果的信息</p>
                           </li>
                        </ul>
                     </div>
                     <div class="example" id="GUID-8CFE5AA9-0BBD-417B-A7EE-6F05AF49001B__CHDFBIBJ">
                        <p class="titleinexample">例7-11 DBMS_SQL.RETURN_RESULT过程</p>
                        <p>在此示例中，过程<code class="codeph">p</code>调用<code class="codeph">DBMS_SQL</code> 。 <code class="codeph">RETURN_RESULT</code>没有可选<code class="codeph">to_client</code>参数（这是<code class="codeph">TRUE</code>默认情况下）。因此， <code class="codeph">DBMS_SQL</code> 。 <code class="codeph">RETURN_RESULT</code>将查询结果返回给子程序客户端（调用<code class="codeph">p</code>的匿名块）。在<code class="codeph">p</code>将结果返回到匿名块之后，只有匿名块才能访问该结果。
                        </p><pre class="oac_no_warn" dir="ltr">创建或替换程序作为c1 SYS_REFCURSOR的AUTHID DEFINER; c2 SYS_REFCURSOR; BEGIN OPEN c1 FOR SELECT first_name，last_name FROM employees WHERE employee_id = 176; <span class="bold">DBMS_SQL.RETURN_RESULT（c1）;</span> <span class="bold"> - 现在p无法访问结果。</span>OPEN c2 FOR SELECT city，state_province FROM locations WHERE country_id ='AU'; <span class="bold">DBMS_SQL.RETURN_RESULT（c2）;</span> <span class="bold"> - 现在p无法访问结果。</span>结束; / BEGIN p;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">ResultSet＃1 FIRST_NAME LAST_NAME -------------------- ------------------------- Jonathon Taylor结果集＃2 CITY STATE_PROVINCE ------------------------------ ------------- ------------悉尼新南威尔士州</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="LNPLS2177"></a><a id="LNPLS2176"></a><div class="props_rev_3"><a id="GUID-1D6A4302-CBA0-47A6-B4A7-80B089DF4E61" name="GUID-1D6A4302-CBA0-47A6-B4A7-80B089DF4E61"></a><h4 id="LNPLS-GUID-1D6A4302-CBA0-47A6-B4A7-80B089DF4E61" class="sect4"><span class="enumeration_section">7.3.2</span> DBMS_SQL.GET_NEXT_RESULT过程</h4>
                  <div>
                     <p><code class="codeph">DBMS_SQL</code> 。 <code class="codeph">GET_NEXT_RESULT</code>过程获取<code class="codeph">DBMS_SQL</code>的下一个结果。 <code class="codeph">RETURN_RESULT</code>过程返回给收件人。这两个过程以相同的顺序返回结果。
                     </p>
                     <p><code class="codeph">DBMS_SQL</code> 。 <code class="codeph">GET_NEXT_RESULT</code>有两个重载：</p><pre class="oac_no_warn" dir="ltr">程序GET_NEXT_RESULT（c IN INTEGER，rc OUT <span class="bold">SYS_REFCURSOR</span> ）;程序GET_NEXT_RESULT（c IN INTEGER，rc OUT <span class="bold">INTEGER</span> ）;</pre><p><code class="codeph">c</code>参数是直接或间接调用使用<code class="codeph">DBMS_SQL</code>的子程序的打开游标的游标号。 <code class="codeph">RETURN_RESULT</code>过程隐式返回查询结果。
                     </p>
                     <p>要打开游标并获取其游标编号，请调用<code class="codeph">DBMS_SQL</code> 。 <code class="codeph">OPEN_CURSOR</code>功能。<code class="codeph">DBMS_SQL</code> 。 <code class="codeph">OPEN_CURSOR</code>有一个可选参数<code class="codeph">treat_as_client_for_results</code> 。当此参数为<code class="codeph">FALSE</code> （默认值）时，打开此游标（调用子程序）的调用者不会被视为从使用<code class="codeph">DBMS_SQL</code>的子程序接收客户端查询结果的客户端。 <code class="codeph">RETURN_RESULT</code>查询结果返回给上层的客户端。当此参数为<code class="codeph">TRUE</code> ，调用者将被视为客户端。有关<code class="codeph">DBMS_SQL</code>更多信息。 <code class="codeph">OPEN_CURSOR</code>函数，请参见<a href="../arpls/DBMS_SQL.html#ARPLS68275" target="_blank"><span class="italic">Oracle Database PL / SQL包和类型参考</span></a> 。
                     </p>
                     <p><code class="codeph">rc</code>参数是游标变量（ <code class="codeph">SYS_REFCURSOR</code> ）或打开游标的游标号（ <code class="codeph">INTEGER</code> ）。
                     </p>
                     <p>在<a href="dynamic-sql.html#GUID-1D6A4302-CBA0-47A6-B4A7-80B089DF4E61__CHDBBIFI">示例7-12中</a> ，过程<code class="codeph">get_employee_info</code>使用<code class="codeph">DBMS_SQL</code> 。 <code class="codeph">RETURN_RESULT</code>将两个查询结果返回给客户端程序，并由匿名块<code class="codeph">&lt;&lt;main&gt;&gt;</code>动态调用。因为<code class="codeph">&lt;&lt;main&gt;&gt;</code>需要接收<code class="codeph">get_employee_info</code>返回的两个查询结果， <code class="codeph">&lt;&lt;main&gt;&gt;</code>打开一个游标以使用<code class="codeph">DBMS_SQL</code>调用<code class="codeph">get_employee_info</code> 。 <code class="codeph">OPEN_CURSOR</code> ，参数<code class="codeph">treat_as_client_for_results</code>设置为<code class="codeph">TRUE</code> 。因此， <code class="codeph">DBMS_SQL</code> 。 <code class="codeph">GET_NEXT_RESULT</code>将其结果返回给<code class="codeph">&lt;&lt;main&gt;&gt;</code> ，它使用光标<code class="codeph">rc</code>来获取它们。
                     </p>
                     <div class="example" id="GUID-1D6A4302-CBA0-47A6-B4A7-80B089DF4E61__CHDBBIFI">
                        <p class="titleinexample">例7-12 DBMS_SQL.GET_NEXT_RESULT过程</p><pre class="oac_no_warn" dir="ltr">创建或替换过程get_employee_info（id IN VARCHAR2）AUTHID DEFINER as rc SYS_REFCURSOR; BEGIN  - 返回员工信息OPEN rc FOR SELECT first_name，last_name，email，phone_number FROM employees WHERE employee_id = id; <span class="bold">DBMS_SQL.RETURN_RESULT（RC）;</span> - 返回员工职位历史OPEN RC FOR SELECT job_title，start_date，end_date FROM job_history jh，jobs j WHERE jh.employee_id = id AND jh.job_id = j.job_id ORDER BY start_date DESC; <span class="bold">DBMS_SQL.RETURN_RESULT（RC）;</span>结束; / <span class="bold">&lt;&lt; main &gt;&gt;</span> DECLARE c INTEGER; rc SYS_REFCURSOR; n NUMBER; first_name VARCHAR2（20）; last_name VARCHAR2（25）;电子邮件VARCHAR2（25）; phone_number VARCHAR2（20）; job_title VARCHAR2（35）; start_date DATE; end_date DATE; BEGIN <span class="bold">c：= DBMS_SQL.OPEN_CURSOR（true）;</span> DBMS_SQL.PARSE（ <span class="bold">c</span> ，' <span class="bold">BEGIN get_employee_info（：id）; END;</span> '，DBMS_SQL.NATIVE）; DBMS_SQL.BIND_VARIABLE（c，'：id'，176）; n：= DBMS_SQL.EXECUTE（c）; - 获取员工信息<span class="bold">dbms_sql.get_next_result（c，rc）;</span> <span class="bold">FETCH rc INTO first_name，last_name，email，phone_number;</span> DBMS_OUTPUT.PUT_LINE（'Employee：'|| first_name ||''|| last_name）; DBMS_OUTPUT.PUT_LINE（'电子邮件：'|| email）; DBMS_OUTPUT.PUT_LINE（'电话：'|| phone_number）; - 获取员工职位历史DBMS_OUTPUT.PUT_LINE（'标题：'）; <span class="bold">DBMS_SQL.GET_NEXT_RESULT（c，rc）;</span> LOOP <span class="bold">FETCH rc INTO job_title，start_date，end_date;</span>退出时rc％NOTFOUND; DBMS_OUTPUT.PUT_LINE（' - '|| job_title ||'（'|| start_date ||' - '|| end_date ||'）'）;结束循环; DBMS_SQL.CLOSE_CURSOR（C）;结束主; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">员工：Jonathon Taylor电子邮件：JTAYLOR电话：011.44.1644.429265标题： - 销售经理（01-JAN-07  -  31-DEC-07） - 销售代表（24-MAR-06-31-DEC-06）PL / SQL程序成功完成。</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="LNPLS635"></a><a id="LNPLS01113"></a><div class="props_rev_3"><a id="GUID-A194C9FA-221A-466B-9179-6238FEC5143B" name="GUID-A194C9FA-221A-466B-9179-6238FEC5143B"></a><h4 id="LNPLS-GUID-A194C9FA-221A-466B-9179-6238FEC5143B" class="sect4"><span class="enumeration_section">7.3.3</span> DBMS_SQL.TO_REFCURSOR函数</h4>
                  <div>
                     <p><code class="codeph">DBMS_SQL</code> 。 <code class="codeph">TO_REFCURSOR</code>函数将SQL游标编号转换为弱游标变量，您可以在本机动态SQL语句中使用该变量。
                     </p>
                     <p>在将SQL游标号传递给<code class="codeph">DBMS_SQL</code> 。 <code class="codeph">TO_REFCURSOR</code>函数，您必须<code class="codeph">OPEN</code> ， <code class="codeph">PARSE</code>和<code class="codeph">EXECUTE</code>它（否则会发生错误）。
                     </p>
                     <p>将SQL游标编号转换为<code class="codeph">REF</code> <code class="codeph">CURSOR</code>变量后， <code class="codeph">DBMS_SQL</code>操作只能将其作为<code class="codeph">REF</code> <code class="codeph">CURSOR</code>变量访问，而不能作为SQL游标编号访问。例如，使用<code class="codeph">DBMS_SQL</code> 。 <code class="codeph">IS_OPEN</code>函数查看转换的SQL游标号是否仍然打开会导致错误。
                     </p>
                     <p><a href="dynamic-sql.html#GUID-A194C9FA-221A-466B-9179-6238FEC5143B__g1777282">例7-13</a>使用<code class="codeph">DBMS_SQL</code> 。 <code class="codeph">TO_REFCURSOR</code>函数用于从<code class="codeph">DBMS_SQL</code>包切换到本机动态SQL。</p>
                     <div class="example" id="GUID-A194C9FA-221A-466B-9179-6238FEC5143B__g1777282">
                        <p class="titleinexample">示例7-13从DBMS_SQL包切换到本机动态SQL</p><pre class="oac_no_warn" dir="ltr">创建或替换类型vc_array IS TABLE OF VARCHAR2（200）; / CREATE OR REPLACE TYPE numlist是数字表; / CREATE OR REPLACE PROCEDURE do_query_1（占位符vc_array，bindvars vc_array，sql_stmt VARCHAR2）AUTHID DEFINER是TYPE类型是否为REF CURSOR; src_cur curtype; curid NUMBER; bindnames vc_array; empnos numlist; depts numlist;返回NUMBER; isopen BOOLEAN; BEGIN <span class="bold">- 打开SQL游标号：</span> curid：= DBMS_SQL.OPEN_CURSOR; <span class="bold">- 解析SQL游标号：</span> DBMS_SQL.PARSE（curid，sql_stmt，DBMS_SQL.NATIVE）; bindnames：=占位符; - 绑定变量：FOR i IN 1 ..绑定名称。COUNT LOOP DBMS_SQL.BIND_VARIABLE（curid，bindnames（i），bindvars（i））;结束循环; <span class="bold">- 运行SQL游标号：</span> ret：= DBMS_SQL.EXECUTE（curid）; <span class="bold">- 从DBMS_SQL切换到本机动态SQL：</span> src_cur：= DBMS_SQL.TO_REFCURSOR（curid）; FETCH src_cur BULK收集进入empnos，depts; <span class="bold">- 这会导致错误，因为curid被转换为REF CURSOR：</span> -  isopen：= DBMS_SQL.IS_OPEN（curid）;关闭src_cur;结束; /</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="LNPLS636"></a><a id="LNPLS00001"></a><div class="props_rev_3"><a id="GUID-8DF5B8A3-70F8-4AF5-A747-B1CE6B7D90DF" name="GUID-8DF5B8A3-70F8-4AF5-A747-B1CE6B7D90DF"></a><h4 id="LNPLS-GUID-8DF5B8A3-70F8-4AF5-A747-B1CE6B7D90DF" class="sect4"><span class="enumeration_section">7.3.4</span> DBMS_SQL.TO_CURSOR_NUMBER函数</h4>
                  <div>
                     <p><code class="codeph">DBMS_SQL</code> 。 <code class="codeph">TO_CURSOR_NUMBER</code>函数将<code class="codeph">REF</code> <code class="codeph">CURSOR</code>变量（强或弱）转换为SQL游标号，您可以将其传递给<code class="codeph">DBMS_SQL</code>子程序。
                     </p>
                     <p>在将<code class="codeph">REF</code> <code class="codeph">CURSOR</code>变量传递给<code class="codeph">DBMS_SQL</code> 。 <code class="codeph">TO_CURSOR_NUMBER</code>函数，您必须<code class="codeph">OPEN</code>它。
                     </p>
                     <p>将<code class="codeph">REF</code> <code class="codeph">CURSOR</code>变量转换为SQL游标数后，本机动态SQL操作无法访问它。
                     </p>
                     <p><a href="dynamic-sql.html#GUID-8DF5B8A3-70F8-4AF5-A747-B1CE6B7D90DF__BHCHJBHJ">例7-14</a>使用<code class="codeph">DBMS_SQL</code> 。 <code class="codeph">TO_CURSOR_NUMBER</code>函数用于从本机动态SQL切换到<code class="codeph">DBMS_SQL</code>包。
                     </p>
                     <div class="example" id="GUID-8DF5B8A3-70F8-4AF5-A747-B1CE6B7D90DF__BHCHJBHJ">
                        <p class="titleinexample">示例7-14从本机动态SQL切换到DBMS_SQL包</p><pre class="oac_no_warn" dir="ltr">创建或替换过程do_query_2（sql_stmt VARCHAR2）AUTHID DEFINER类型为curtype IS REF CURSOR; src_cur curtype; curid NUMBER; desctab DBMS_SQL.DESC_TAB; colcnt NUMBER; namevar VARCHAR2（50）; numvar NUMBER; datevar DATE; empno NUMBER：= 100; BEGIN  -  sql_stmt：= SELECT ...FROM employees WHERE employee_id =：b1'; <span class="bold">- 打开REF CURSOR变量：</span> OPEN src_cur FOR sql_stmt USING empno; <span class="bold">- 从本机动态SQL切换到DBMS_SQL包：</span> curid：= DBMS_SQL.TO_CURSOR_NUMBER（src_cur）; DBMS_SQL.DESCRIBE_COLUMNS（curid，colcnt，desctab）; - 定义列：FOR i IN 1 .. colcnt LOOP IF desctab（i）.col_type = 2 THEN DBMS_SQL.DEFINE_COLUMN（curid，i，numvar）; ELSIF desctab（i）.col_type = 12那么DBMS_SQL.DEFINE_COLUMN（curid，i，datevar）; - 语句ELSE DBMS_SQL.DEFINE_COLUMN（curid，i，namevar，50）;万一;结束循环; - 使用DBMS_SQL包获取行：WHILE DBMS_SQL.FETCH_ROWS（curid）&gt; 0 LOOP FOR i IN 1 .. colcnt LOOP IF（desctab（i）.col_type = 1）那么DBMS_SQL.COLUMN_VALUE（curid，i，namevar）; ELSIF（desctab（i）.col_type = 2）那么DBMS_SQL.COLUMN_VALUE（curid，i，numvar）; ELSIF（desctab（i）.col_type = 12）那么DBMS_SQL.COLUMN_VALUE（curid，i，datevar）; - 陈述END IF;结束循环;结束循环; DBMS_SQL.CLOSE_CURSOR（curid）;结束; /</pre></div>
                     <!-- class="example" -->
                  </div>
               </div>
            </div><a id="LNPLS521"></a><a id="LNPLS637"></a><a id="LNPLS01109"></a><div class="props_rev_3"><a id="GUID-1E31057E-057F-4A53-B1DD-8BC2C337AA2C" name="GUID-1E31057E-057F-4A53-B1DD-8BC2C337AA2C"></a><h3 id="LNPLS-GUID-1E31057E-057F-4A53-B1DD-8BC2C337AA2C" class="sect3"><span class="enumeration_section">7.4</span> SQL注入</h3>
               <div>
                  <p>SQL注入恶意利用在SQL语句中使用客户端提供的数据的应用程序，从而获得对数据库的未授权访问以查看或操纵受限数据。</p>
                  <p>本节介绍PL / SQL中的SQL注入漏洞，并说明如何防范它们。</p>
                  <div class="section">
                     <p class="subhead2" id="GUID-1E31057E-057F-4A53-B1DD-8BC2C337AA2C__GUID-36C59DA9-FB2E-425E-9A86-39F0EB280269">话题</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="dynamic-sql.html#GUID-9353B33A-460A-4D4F-8FFF-FFF06A8C68D5" title="所有SQL注入技术都利用单个漏洞：字符串输入未正确验证并连接到动态SQL语句中。">SQL注入技术</a></p>
                        </li>
                        <li>
                           <p><a href="dynamic-sql.html#GUID-4503110E-DF12-487E-B613-6890CC55B6CD" title="如果在PL / SQL应用程序中使用动态SQL，则必须检查输入文本以确保它完全符合您的预期。">防止SQL注入</a></p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-1E31057E-057F-4A53-B1DD-8BC2C337AA2C__CHDBJCFF">
                     <p class="titleinexample">示例7-15 SQL注入示例的设置</p>
                     <p>要尝试这些示例，请运行这些语句。</p>
                     <div class="infoboxnote" id="GUID-1E31057E-057F-4A53-B1DD-8BC2C337AA2C__GUID-38E9A2F6-64C1-49E1-B4CF-50224D594ECD">
                        <p class="notep1">实时SQL：</p>
                        <p>您可以在<a href="https://livesql.oracle.com/apex/livesql/docs/lnpls/plsql-dynamic-sql/tdlnplsdynamic3.html" target="_blank">SQL注入演示中</a>在Oracle Live SQL上查看和运行此示例</p>
                     </div><pre class="oac_no_warn" dir="ltr">DROP TABLE secret_records; CREATE TABLE secret_records（user_name VARCHAR2（9），service_type VARCHAR2（12），value VARCHAR2（30），date_created DATE）; INSERT INTO secret_records（user_name，service_type，value，date_created）VALUES（'Andy'，'服务员'，'在Cafe Pete'供应晚餐，SYSDATE）; INSERT INTO secret_records（user_name，service_type，value，date_created）VALUES（'Chuck'，'Merger'，'Buy company XYZ'，SYSDATE）;</pre></div>
                  <!-- class="example" -->
               </div><a id="LNPLS522"></a><a id="LNPLS638"></a><div class="props_rev_3"><a id="GUID-9353B33A-460A-4D4F-8FFF-FFF06A8C68D5" name="GUID-9353B33A-460A-4D4F-8FFF-FFF06A8C68D5"></a><h4 id="LNPLS-GUID-9353B33A-460A-4D4F-8FFF-FFF06A8C68D5" class="sect4"><span class="enumeration_section">7.4.1</span> SQL注入技术</h4>
                  <div>
                     <p>所有SQL注入技术都利用单个漏洞：字符串输入未正确验证并连接到动态SQL语句中。</p>
                     <div class="section">
                        <p class="subhead3" id="GUID-9353B33A-460A-4D4F-8FFF-FFF06A8C68D5__GUID-76E36AC5-93EA-43EC-BC1A-A65F13D09B0B">话题</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="dynamic-sql.html#GUID-0ED23CF7-1967-4C06-88CF-B3BB4AE7687F" title="语句修改意味着故意更改动态SQL语句，以便它以应用程序开发人员无意识的方式运行。">声明修改</a></p>
                           </li>
                           <li>
                              <p><a href="dynamic-sql.html#GUID-BA52854E-DAA5-497E-82B0-1686D4ED7C5C" title="语句注入意味着用户将一个或多个SQL语句附加到动态SQL语句。">声明注入</a></p>
                           </li>
                           <li>
                              <p><a href="dynamic-sql.html#GUID-9D45630C-ECBF-409B-91C0-D85CCC3FBD75" title="鲜为人知的SQL注入技术使用NLS会话参数来修改或注入SQL语句。">数据类型转换</a></p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div><a id="LNPLS640"></a><a id="LNPLS639"></a><div class="props_rev_3"><a id="GUID-0ED23CF7-1967-4C06-88CF-B3BB4AE7687F" name="GUID-0ED23CF7-1967-4C06-88CF-B3BB4AE7687F"></a><h5 id="LNPLS-GUID-0ED23CF7-1967-4C06-88CF-B3BB4AE7687F" class="sect5"><span class="enumeration_section">7.4.1.1</span>声明修改</h5>
                     <div>
                        <p><span class="bold">语句修改</span>意味着故意更改动态SQL语句，以便它以应用程序开发人员无意识的方式运行。
                        </p>
                        <p>通常，用户通过更改<code class="codeph">SELECT</code>语句的<code class="codeph">WHERE</code>子句或插入<code class="codeph">UNION</code> <code class="codeph">ALL</code>子句来检索未经授权的数据。此技术的典型示例是通过使<code class="codeph">WHERE</code>子句始终为<code class="codeph">TRUE</code>来绕过密码身份验证。</p>
                        <div class="example" id="GUID-0ED23CF7-1967-4C06-88CF-B3BB4AE7687F__BJEJABIC">
                           <p class="titleinexample">示例7-16易于语句修改的过程</p>
                           <p>此示例创建一个易受语句修改影响的过程，然后使用和不使用语句修改调用该过程。通过语句修改，该过程返回一个所谓的秘密记录。</p>
                           <div class="infoboxnote" id="GUID-0ED23CF7-1967-4C06-88CF-B3BB4AE7687F__GUID-38E9A2F6-64C1-49E1-B4CF-50224D594ECD">
                              <p class="notep1">实时SQL：</p>
                              <p>您可以在<a href="https://livesql.oracle.com/apex/livesql/docs/lnpls/plsql-dynamic-sql/tdlnplsdynamic3.html" target="_blank">SQL注入演示中</a>在Oracle Live SQL上查看和运行此示例</p>
                           </div>
                           <p>创建易受攻击的程</p><pre class="oac_no_warn" dir="ltr">CREATE或REPLACE PROCEDURE get_record（user_name IN VARCHAR2，service_type IN VARCHAR2，rec OUT VARCHAR2）AUTHID DEFINER IS query VARCHAR2（4000）; BEGIN <span class="bold">- 以下SELECT语句易受修改</span> <span class="bold">- 因为它使用连接来构建WHERE子句。</span>query：='SELECT value FROM secret_records WHERE user_name ='''|| user_name || '''AND service_type ='''|| service_type || '' ''; DBMS_OUTPUT.PUT_LINE（'查询：'||查询）; EXECUTE IMMEDIATE查询INTO rec; DBMS_OUTPUT.PUT_LINE（'Rec：'|| rec）;结束; /</pre><p>演示没有SQL注入的过程：</p><pre class="oac_no_warn" dir="ltr">SET SERVEROUTPUT ON; DECLARE record_value VARCHAR2（4000）; BEGIN get_record（'Andy'，'Waiter'，record_value）;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">查询：SELECT值FROM secret_records WHERE user_name ='Andy'AND service_type ='Waiter'Rec：在Cafe Pete享用晚餐</pre><p>声明修改示例：</p><pre class="oac_no_warn" dir="ltr">DECLARE record_value VARCHAR2（4000）; BEGIN get_record（ <span class="bold">'</span> Anybody''OR <span class="bold">service_type =''Merger'' - '，</span> 'Anything'，record_value）;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr"><span class="bold">查询：SELECT值FROM secret_records WHERE user_name ='Anybody'或</span> <span class="bold">service_type ='合并' - 'AND service_type ='任何'</span> <span class="bold">Rec：购买公司XYZ</span> PL / SQL程序已成功完成。</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="LNPLS642"></a><a id="LNPLS641"></a><div class="props_rev_3"><a id="GUID-BA52854E-DAA5-497E-82B0-1686D4ED7C5C" name="GUID-BA52854E-DAA5-497E-82B0-1686D4ED7C5C"></a><h5 id="LNPLS-GUID-BA52854E-DAA5-497E-82B0-1686D4ED7C5C" class="sect5"><span class="enumeration_section">7.4.1.2</span>语句注入</h5>
                     <div>
                        <p><span class="bold">语句注入</span>意味着用户将一个或多个SQL语句附加到动态SQL语句。
                        </p>
                        <p>匿名PL / SQL块容易受到这种技术的攻击。</p>
                        <div class="example" id="GUID-BA52854E-DAA5-497E-82B0-1686D4ED7C5C__BJEHHAFF">
                           <p class="titleinexample">示例7-17易于语句注入的过程</p>
                           <p>此示例创建一个易受语句注入攻击的过程，然后使用和不使用语句注入调用该过程。使用语句注入，该过程将删除<a href="dynamic-sql.html#GUID-0ED23CF7-1967-4C06-88CF-B3BB4AE7687F__BJEJABIC">示例7-16中</a>公开的所谓秘密记录。
                           </p>
                           <div class="infoboxnote" id="GUID-BA52854E-DAA5-497E-82B0-1686D4ED7C5C__GUID-38E9A2F6-64C1-49E1-B4CF-50224D594ECD">
                              <p class="notep1">实时SQL：</p>
                              <p>您可以在<a href="https://livesql.oracle.com/apex/livesql/docs/lnpls/plsql-dynamic-sql/tdlnplsdynamic3.html" target="_blank">SQL注入演示中</a>在Oracle Live SQL上查看和运行此示例</p>
                           </div>
                           <p>创建易受攻击的程</p><pre class="oac_no_warn" dir="ltr">创建或替换过程p（user_name IN VARCHAR2，service_type IN VARCHAR2）AUTHID DEFINER是block1 VARCHAR2（4000）; BEGIN <span class="bold">- 以下块容易受到语句注入的影响</span> <span class="bold">- 因为它是通过连接构建的。</span>block1：='BEGIN DBMS_OUTPUT.PUT_LINE（''user_name：'|| user_name ||'''）;' || 'DBMS_OUTPUT.PUT_LINE（''service_type：'|| service_type ||'''）;结束;'; DBMS_OUTPUT.PUT_LINE（'Block1：'|| block1）; EXECUTE IMMEDIATE block1;结束; /</pre><p>演示没有SQL注入的过程：</p><pre class="oac_no_warn" dir="ltr">SET SERVEROUTPUT ON; BEGIN p（'安迪'，'服务员'）;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">Block1：BEGIN DBMS_OUTPUT.PUT_LINE（'user_name：Andy'）; DBMS_OUTPUT.PUT_LINE（'service_type：Waiter'）;结束; user_name：Andy service_type：服务员</pre><p>SQL * Plus格式化命令：</p><pre class="oac_no_warn" dir="ltr">COLUMN date_created FORMAT A12;</pre><p>查询：</p><pre class="oac_no_warn" dir="ltr"><span class="bold">SELECT * FROM secret_records ORDER BY user_name;</span>
</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">USER_NAME SERVICE_TYPE VALUE DATE_CREATED --------- ------------ ------------------------- ----- ------------ Andy Waiter在Cafe Pete 28-APR-10 Chuck Merger购买公司XYZ 28-APR-10</pre><p>声明修改示例：</p><pre class="oac_no_warn" dir="ltr">BEGIN p（'Anybody'， <span class="bold">'Anything''）;</span> <span class="bold">DELETE FROM secret_records WHERE service_type = INITCAP（''Merger'</span> ）;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">Block1：BEGIN DBMS_OUTPUT.PUT_LINE（'user_name：Anybody'）; DBMS_OUTPUT.PUT_LINE（'service_type：Anything <span class="bold">'）;</span> <span class="bold">DELETE FROM secret_records WHERE service_type = INITCAP（'Merger'</span> ）;结束; user_name：Anybody service_type：已成功完成任何PL / SQL过程。
</pre><p>查询：</p><pre class="oac_no_warn" dir="ltr"><span class="bold">SELECT * FROM secret_records;</span>
</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">USER_NAME SERVICE_TYPE VALUE DATE_CREATED --------- ------------ ------------------------- ----- ------------ Andy Waiter在Cafe Pete 18-MAR-09 <span class="bold">1行选择</span>晚餐<span class="bold">。</span></pre></div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="LNPLS644"></a><a id="LNPLS643"></a><div class="props_rev_3"><a id="GUID-9D45630C-ECBF-409B-91C0-D85CCC3FBD75" name="GUID-9D45630C-ECBF-409B-91C0-D85CCC3FBD75"></a><h5 id="LNPLS-GUID-9D45630C-ECBF-409B-91C0-D85CCC3FBD75" class="sect5"><span class="enumeration_section">7.4.1.3</span>数据类型转换</h5>
                     <div>
                        <p>鲜为人知的SQL注入技术使用NLS会话参数来修改或注入SQL语句。</p>
                        <p>必须将连接到动态SQL语句文本中的日期时间或数值转换为<code class="codeph">VARCHAR2</code>数据类型。转换可以是隐式的（当值是连接运算符的操作数时）或显式的（当值是<code class="codeph">TO_CHAR</code>函数的参数时）。此数据类型转换取决于运行动态SQL语句的数据库会话的NLS设置。日期时间值的转换使用参数<code class="codeph">NLS_DATE_FORMAT</code> ， <code class="codeph">NLS_TIMESTAMP_FORMAT</code>或<code class="codeph">NLS_TIMESTAMP_TZ_FORMAT</code>指定的格式模型，具体取决于特定的日期时间数据类型。数值的转换应用参数<code class="codeph">NLS_NUMERIC_CHARACTERS</code>指定的十进制和组分隔符。</p>
                        <p>一个日期时间格式模型是<code class="codeph">"</code> <span class="italic"><code class="codeph">text</code></span> <code class="codeph">"</code> 。<span class="italic"><code class="codeph">text</code></span>将复制到转换结果中。例如，如果<code class="codeph">NLS_DATE_FORMAT</code>值为<code class="codeph">'"Month:" Month'</code> ，那么在6月， <code class="codeph">TO_CHAR(SYSDATE)</code>将返回<code class="codeph">'Month: June'</code> 。日期时间格式模型可能会被滥用，如<a href="dynamic-sql.html#GUID-9D45630C-ECBF-409B-91C0-D85CCC3FBD75__CHDEIABG">例7-18</a>所示。
                        </p>
                        <div class="example" id="GUID-9D45630C-ECBF-409B-91C0-D85CCC3FBD75__CHDEIABG">
                           <p class="titleinexample">示例7-18通过数据类型转换易受SQL注入的过程</p><pre class="oac_no_warn" dir="ltr">SELECT * FROM secret_records;</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">USER_NAME SERVICE_TYPE VALUE DATE_CREATE --------- ------------ ------------------------- ----- ----------- Andy Waiter在Cafe Pete 28-APR-2010 Chuck Merger购买公司XYZ 28-APR-2010</pre><p>创建易受攻击的程</p><pre class="oac_no_warn" dir="ltr">- 返回不超过一个月的记录CREATE OR REPLACE PROCEDURE get_recent_record（user_name IN VARCHAR2，service_type IN VARCHAR2，rec OUT VARCHAR2）AUTHID DEFINER IS query VARCHAR2（4000）; BEGIN <span class="bold">/ *以下SELECT语句很容易被修改，</span> <span class="bold">因为它使用连接来构建WHERE子句，</span> <span class="bold">并且因为SYSDATE取决于NLS_DATE_FORMAT的值。 * /</span> query：='SELECT value FROM secret_records WHERE user_name ='''|| user_name || '''AND service_type ='''|| service_type || '''和date_created&gt;'''|| <span class="bold">（SYSDATE  -  30）</span> || '' ''; DBMS_OUTPUT.PUT_LINE（'查询：'||查询）; EXECUTE IMMEDIATE查询INTO rec; DBMS_OUTPUT.PUT_LINE（'Rec：'|| rec）;结束; /</pre><p>演示没有SQL注入的过程：</p><pre class="oac_no_warn" dir="ltr">SET SERVEROUTPUT ON; <span class="bold">ALTER SESSION SET NLS_DATE_FORMAT ='DD-MON-YYYY';</span> DECLARE record_value VARCHAR2（4000）; BEGIN get_recent_record（'Andy'，'Waiter'，record_value）;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">查询：SELECT值FROM secret_records WHERE user_name ='Andy'AND service_type ='Waiter'和date_created&gt; '29 -MAR-2010'Rec：在Cafe Pete享用晚餐</pre><p>声明修改示例：</p><pre class="oac_no_warn" dir="ltr"><span class="bold">ALTER SESSION SET NLS_DATE_FORMAT ='“''OR service_type =''Merger”';</span> DECLARE record_value VARCHAR2（4000）; BEGIN get_recent_record（'Anybody'，'Anything'，record_value）;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr"><span class="bold">查询：SELECT值FROM secret_records WHERE user_name ='Anybody'AND</span> <span class="bold">service_type ='Anything'AND_created&gt;''OR service_type ='合并'</span> <span class="bold">Rec：购买公司XYZ</span> PL / SQL程序已成功完成。</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div>
               </div><a id="LNPLS645"></a><div class="props_rev_3"><a id="GUID-4503110E-DF12-487E-B613-6890CC55B6CD" name="GUID-4503110E-DF12-487E-B613-6890CC55B6CD"></a><h4 id="LNPLS-GUID-4503110E-DF12-487E-B613-6890CC55B6CD" class="sect4"><span class="enumeration_section">7.4.2</span>防止SQL注入</h4>
                  <div>
                     <p>如果在PL / SQL应用程序中使用动态SQL，则必须检查输入文本以确保它完全符合您的预期。</p>
                     <p>您可以使用以下技术：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="dynamic-sql.html#GUID-EF9233BB-9570-453D-96EB-E13F43B10596" title="使PL / SQL代码无法受到SQL注入攻击的最有效方法是使用绑定变量。">绑定变量</a></p>
                        </li>
                        <li>
                           <p><a href="dynamic-sql.html#GUID-44F80A6B-99B4-4DB7-8BF8-B17994AD197A" title="始终让您的程序验证用户输入以确保它是预期的。">验证检查</a></p>
                        </li>
                        <li>
                           <p><a href="dynamic-sql.html#GUID-4DB96B62-75BE-424E-B6F7-BB0597FCAA58" title="建议不仅从安全角度使用显式的与语言环境无关的格式模型来构造SQL，还要确保动态SQL语句在任何全球化环境中正确运行。">显式格式模型</a></p>
                        </li>
                     </ul>
                  </div><a id="LNPLS647"></a><a id="LNPLS646"></a><div class="props_rev_3"><a id="GUID-EF9233BB-9570-453D-96EB-E13F43B10596" name="GUID-EF9233BB-9570-453D-96EB-E13F43B10596"></a><h5 id="LNPLS-GUID-EF9233BB-9570-453D-96EB-E13F43B10596" class="sect5"><span class="enumeration_section">7.4.2.1</span>绑定变量</h5>
                     <div>
                        <p>使PL / SQL代码无法受到SQL注入攻击的最有效方法是使用绑定变量。</p>
                        <p>数据库仅使用绑定变量的值，并且不以任何方式解释其内容。（绑定变量也可以提高性能。）</p>
                        <div class="example" id="GUID-EF9233BB-9570-453D-96EB-E13F43B10596__BJEIJEBJ">
                           <p class="titleinexample">例7-19防止SQL注入的绑定变量</p>
                           <p>此示例中的过程不受SQL注入的影响，因为它使用绑定变量构建动态SQL语句（而不是像<a href="dynamic-sql.html#GUID-0ED23CF7-1967-4C06-88CF-B3BB4AE7687F__BJEJABIC">示例7-16</a>中的易受攻击过程那样通过连接）。相同的绑定技术修复了<a href="dynamic-sql.html#GUID-BA52854E-DAA5-497E-82B0-1686D4ED7C5C__BJEHHAFF">例7-17中</a>所示的易受攻击的过程。
                           </p>
                           <p>创建无懈可击的程序：</p><pre class="oac_no_warn" dir="ltr">创建或替换过程get_record_2（user_name IN VARCHAR2，service_type IN VARCHAR2，rec OUT VARCHAR2）AUTHID DEFINER IS query VARCHAR2（4000）; BEGIN query：='SELECT value FROM secret_records WHERE user_name = <span class="bold">：a</span> AND service_type = <span class="bold">：b</span> '; DBMS_OUTPUT.PUT_LINE（'查询：'||查询）; EXECUTE IMMEDIATE query INTO rec <span class="bold">USING user_name，service_type</span> ; DBMS_OUTPUT.PUT_LINE（'Rec：'|| rec）;结束; /</pre><p>演示没有SQL注入的过程：</p><pre class="oac_no_warn" dir="ltr">SET SERVEROUTPUT ON; DECLARE record_value VARCHAR2（4000）; BEGIN get_record_2（'Andy'，'Waiter'，record_value）;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">查询：SELECT值FROM secret_records WHERE user_name = <span class="bold">：a</span> AND service_type = <span class="bold">：b</span> Rec：成功完成Cafe Pete PL / SQL程序的晚餐。
 </pre><p>尝试声明修改：</p><pre class="oac_no_warn" dir="ltr">DECLARE record_value VARCHAR2（4000）; BEGIN get_record_2（'Anybody''OR service_type =''Merger'' - '，'Anything'，record_value）;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">查询：SELECT值FROM secret_records WHERE user_name = <span class="bold">：a</span> AND service_type = <span class="bold">：b</span> <span class="bold">第1行的</span> DECLARE * <span class="bold">ERROR：</span> <span class="bold">ORA-01403：未找到数据</span> <span class="bold">ORA-06512：位于“HR.GET_RECORD_2”，第15行</span> <span class="bold">ORA-06512：第4行</span></pre></div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="LNPLS649"></a><a id="LNPLS648"></a><div class="props_rev_3"><a id="GUID-44F80A6B-99B4-4DB7-8BF8-B17994AD197A" name="GUID-44F80A6B-99B4-4DB7-8BF8-B17994AD197A"></a><h5 id="LNPLS-GUID-44F80A6B-99B4-4DB7-8BF8-B17994AD197A" class="sect5"><span class="enumeration_section">7.4.2.2</span>验证检查</h5>
                     <div>
                        <p>始终让您的程序验证用户输入以确保它是预期的。</p>
                        <p>例如，如果用户正在传递<code class="codeph">DELETE</code>语句的部门号，请通过从<code class="codeph">departments</code>表中选择来检查此部门号的有效性。同样，如果用户输入要删除的表的名称，请通过从静态数据字典视图<code class="codeph">ALL_TABLES</code>进行选择来检查该表是否存在。</p>
                        <div class="infoboxnote" id="GUID-44F80A6B-99B4-4DB7-8BF8-B17994AD197A__GUID-EEBA64CB-B62B-4CE1-9661-F0AB2AC2E021">
                           <p class="notep1">警告：</p>
                           <p>检查用户名及其密码的有效性时，无论哪个项无效，都始终返回相同的错误。否则，收到错误消息“无效密码”但不是“无效用户名”（或反向）的恶意用户可以意识到他或她已正确猜到其中一个。</p>
                        </div>
                        <p>在验证检查代码中， <code class="codeph">DBMS_ASSERT</code>包中的子程序通常很有用。例如，您可以使用<code class="codeph">DBMS_ASSERT</code> 。 <code class="codeph">ENQUOTE_LITERAL</code>函数用于将字符串文字括在引号中，如<a href="dynamic-sql.html#GUID-44F80A6B-99B4-4DB7-8BF8-B17994AD197A__CHDGJEGD">例7-20所示</a> 。这可以防止恶意用户在开始引号和相应的右引号之间注入文本。
                        </p>
                        <div class="infoboxnote" id="GUID-44F80A6B-99B4-4DB7-8BF8-B17994AD197A__GUID-4AD6631A-88F3-4964-9000-7C2FB39EC9B2">
                           <p class="notep1">警告：</p>
                           <p>尽管<code class="codeph">DBMS_ASSERT</code>子程序在验证代码中很有用，但它们并不能替代它。例如，输入字符串可以是一个合格的SQL名称（通过验证<code class="codeph">DBMS_ASSERT</code> 。 <code class="codeph">QUALIFIED_SQL_NAME</code> ），仍然是一个欺诈性的密码。
                           </p>
                        </div>
                        <div class="infoboxnotealso" id="GUID-44F80A6B-99B4-4DB7-8BF8-B17994AD197A__GUID-B11BBB2F-639D-4520-9A31-8F6724B0DA3E">
                           <p class="notep1">也可以看看：</p>
                           <p>有关<code class="codeph">DBMS_ASSERT</code>子程序的信息，请<code class="codeph">DBMS_ASSERT</code> <a href="../arpls/DBMS_ASSERT.html#ARPLS231" target="_blank"><span class="italic">Oracle Database PL / SQL包和类型参考</span></a></p>
                        </div>
                        <div class="example" id="GUID-44F80A6B-99B4-4DB7-8BF8-B17994AD197A__CHDGJEGD">
                           <p class="titleinexample">例7-20验证检查防止SQL注入</p>
                           <p>在此示例中，过程<code class="codeph">raise_emp_salary</code>检查在更新<code class="codeph">employees</code>表之前传递给它的列名的有效性，然后匿名块从动态PL / SQL块和动态SQL语句调用该过程。
                           </p><pre class="oac_no_warn" dir="ltr">CREATE OR REPLACE PROCEDURE raise_emp_salary（column_value NUMBER，emp_column VARCHAR2，amount NUMBER）AUTHID DEFINER IS v_column VARCHAR2（30）; sql_stmt VARCHAR2（200）; BEGIN <span class="bold">- 检查作为输入提供的列名的有效性：</span> SELECT column_name INTO v_column FROM USER_TAB_COLS WHERE TABLE_NAME ='EMPLOYEES'AND COLUMN_NAME = emp_column; sql_stmt：='UPDATE employees SET salary = salary +：1 WHERE'|| <span class="bold">DBMS_ASSERT.ENQUOTE_NAME（v_column，FALSE）</span> || '=：2'; EXECUTE IMMEDIATE sql_stmt USING amount，column_value; <span class="bold">- 如果列名有效：</span> IF SQL％ROWCOUNT&gt; 0那么DBMS_OUTPUT.PUT_LINE（'工资更新为：'|| emp_column ||'='|| column_value）;万一; <span class="bold">- 如果列名</span>无效：EXSEPTION NO_DATA_FOUND那么DBMS_OUTPUT.PUT_LINE（'无效列：'|| emp_column）; END raise_emp_salary; / DECLARE plsql_block VARCHAR2（500）; BEGIN <span class="bold">- 从动态PL / SQL块调用raise_emp_salary：</span> plsql_block：='BEGIN raise_emp_salary（：cvalue，：cname，：amt）;结束;'; EXECUTE IMMEDIATE plsql_block使用110，'DEPARTMENT_ID'，10; <span class="bold">- 从动态SQL语句调用raise_emp_salary：</span> EXECUTE IMMEDIATE'BEGIN raise_emp_salary（：cvalue，：cname，：amt）;结束;'使用112，'EMPLOYEE_ID'，10;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">工资更新时间：DEPARTMENT_ID = 110薪资更新时间：EMPLOYEE_ID = 112</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="LNPLS651"></a><a id="LNPLS650"></a><div class="props_rev_3"><a id="GUID-4DB96B62-75BE-424E-B6F7-BB0597FCAA58" name="GUID-4DB96B62-75BE-424E-B6F7-BB0597FCAA58"></a><h5 id="LNPLS-GUID-4DB96B62-75BE-424E-B6F7-BB0597FCAA58" class="sect5"><span class="enumeration_section">7.4.2.3</span>显式格式模型</h5>
                     <div>
                        <p>建议不仅从安全角度使用显式的与语言环境无关的格式模型来构造SQL，还要确保动态SQL语句在任何全球化环境中正确运行。</p>
                        <p>如果使用连接到SQL或PL / SQL语句文本的日期时间和数值，并且不能将它们作为绑定变量传递，请使用独立于NLS参数值的显式格式模型将它们转换为文本。正在运行的会话。确保转换后的值具有SQL datetime或numeric literals的格式。</p>
                        <div class="example" id="GUID-4DB96B62-75BE-424E-B6F7-BB0597FCAA58__CHDFIIEF">
                           <p class="titleinexample">例7-21防止SQL注入的显式格式模型</p>
                           <p>此过程对SQL注入是无懈可击的，因为它使用<code class="codeph">TO_CHAR</code>函数和与语言环境无关的格式模型显式地将datetime参数值<code class="codeph">SYSDATE</code> <code class="codeph">-</code> <code class="codeph">30</code>转换为<code class="codeph">VARCHAR2</code>值（不是隐式地，如<a href="dynamic-sql.html#GUID-9D45630C-ECBF-409B-91C0-D85CCC3FBD75__CHDEIABG">示例7-18</a>中的易受攻击的过程） ）。
                           </p>
                           <p>创建无懈可击的程序：</p><pre class="oac_no_warn" dir="ltr">- 返回不超过一个月的记录CREATE OR REPLACE PROCEDURE get_recent_record（user_name IN VARCHAR2，service_type IN VARCHAR2，rec OUT VARCHAR2）AUTHID DEFINER IS query VARCHAR2（4000）; BEGIN / *以下SELECT语句易受修改，因为它使用连接来构建WHERE子句。* / query：='SELECT value FROM secret_records WHERE user_name ='''|| user_name || '''AND service_type ='''|| service_type || '''和date_created&gt; DATE'''|| <span class="bold">TO_CHAR（SYSDATE  -  30，'YYYY-MM-DD'</span> ）|| '' ''; DBMS_OUTPUT.PUT_LINE（'查询：'||查询）; EXECUTE IMMEDIATE查询INTO rec; DBMS_OUTPUT.PUT_LINE（'Rec：'|| rec）;结束; /</pre><p>尝试声明修改：</p><pre class="oac_no_warn" dir="ltr"><span class="bold">ALTER SESSION SET NLS_DATE_FORMAT ='“''OR service_type =''Merger”';</span> DECLARE record_value VARCHAR2（4000）; BEGIN get_recent_record（'Anybody'，'Anything'，record_value）;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr"><span class="bold">查询：FROM secret_records SELECT值其中user_name = '任何人' AND</span> <span class="bold">SERVICE_TYPE = '任何' AND DATE_CREATED&gt; DATE '2010-03-29'</span> <span class="bold">DECLARE</span> <span class="bold">*</span> <span class="bold">ERROR位于第1行<span class="bold">：ORA-01403：</span></span> <span class="bold">发现</span> <span class="bold">ORA-06512</span> <span class="bold">无数据</span> <span class="bold">：在“SYS .GET_RECENT_RECORD“，第21行</span> <span class="bold">ORA-06512：第4行</span> </pre></div>
                        <!-- class="example" -->
                     </div>
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>