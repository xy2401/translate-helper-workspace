<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <meta name="abstract" content="This chapter describes binding and defining in OCI."></meta>
      <meta name="description" content="This chapter describes binding and defining in OCI."></meta>
      <title>OCI中的绑定和定义</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Programmer&#39;s Guide"></meta>
      <meta property="og:description" content="This chapter describes binding and defining in OCI."></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Programmer&#39;s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="oracle-call-interface-programmers-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-14T08:46:00-08:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="1996, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96204-01"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="using-sql_statements-in-oci.html" title="Previous" type="text/html"></link>
      <link rel="next" href="describing-schema-metadata.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Oracle Call Interface Programmer&#39;s Guide"></meta>
    <meta name="dcterms.isVersionOf" content="LNOCI"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="using-sql_statements-in-oci.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="describing-schema-metadata.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">程序员指南</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">OCI中的绑定和定义</li>
            </ol>
            <a id="GUID-4C2BD7BB-5768-4E8A-82BF-84FB0030A8C5" name="GUID-4C2BD7BB-5768-4E8A-82BF-84FB0030A8C5"></a><a id="LNOCI050"></a>
            
            <h2 id="LNOCI-GUID-4C2BD7BB-5768-4E8A-82BF-84FB0030A8C5" class="sect2"><span class="enumeration_chapter">7</span> OCI中的绑定和定义</h2>
         </header>
         <div class="ind">
            <div>
               <p>本章介绍OCI中的绑定和定义。</p>
               <p>本章包含以下主题：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="binding-and-defining-in-oci.html#GUID-77A26CEA-1C41-46A2-866C-622F9FEB5482" title="本章扩展了绑定和定义的基本概念，并提供了有关可在OCI应用程序中使用的不同类型的绑定和定义的更多详细信息。">OCI中的绑定概述</a></p>
                  </li>
                  <li>
                     <p><a href="binding-and-defining-in-oci.html#GUID-EE9AD90D-8CFD-4380-9D5E-819555EB3A8E" title="更高级的绑定操作包括多步骤绑定，以及命名数据类型和REF的绑定。">OCI中的高级绑定操作</a></p>
                  </li>
                  <li>
                     <p><a href="binding-and-defining-in-oci.html#GUID-8A09BC68-4C3D-4977-86C9-134F73121E26" title="Query语句将数据从数据库返回给您的应用程序。">在OCI中定义的概述</a></p>
                  </li>
                  <li>
                     <p><a href="binding-and-defining-in-oci.html#GUID-237FC150-290A-42B8-99CB-2C6AFA5B9F9E" title="本节介绍高级定义操作，包括命名数据类型和REF的多步定义和定义。">OCI中的高级定义操作</a></p>
                  </li>
                  <li>
                     <p><a href="binding-and-defining-in-oci.html#GUID-094F4767-1BE0-45AE-BA6C-3B114714F87A" title="定义结构数组需要初始调用OCIDefineByPos（）或OCIDefineByPos2（）。">关于在OCI中绑定和定义结构数组</a></p>
                  </li>
                  <li>
                     <p><a href="binding-and-defining-in-oci.html#GUID-CC67A87C-A39A-400A-BF95-C32363DCD589" title="您可以指定多个缓冲区以用于单个绑定或定义调用。">关于绑定和定义多个缓冲区</a></p>
                  </li>
                  <li>
                     <p><a href="binding-and-defining-in-oci.html#GUID-C0D4318B-0768-4386-AA15-C88AE3A33C76" title="本节概述了使用RETURNING子句正确实现DML语句的规则。">OCI中带有RETURNING子句的DML</a></p>
                  </li>
                  <li>
                     <p><a href="binding-and-defining-in-oci.html#GUID-84576558-1974-4E61-B6E6-795FA67419E3" title="本节讨论涉及客户端和服务器之间的字符转换的问题。">OCI绑定和定义中的字符转换</a></p>
                  </li>
                  <li>
                     <p><a href="binding-and-defining-in-oci.html#GUID-5495CEEB-17D0-4185-8879-3356A21E7888" title="OCI提供绑定和定义PL / SQL REF CURSOR和嵌套表的功能。">OCI中的PL / SQL REF CURSOR和嵌套表</a></p>
                  </li>
                  <li>
                     <p><a href="binding-and-defining-in-oci.html#GUID-9DEC9ACB-BC16-4F4C-8EC6-E43EC47EF9CB" title="从Oracle Database Release 12.1开始，OCI客户端支持本机描述和绑定所有PL / SQL类型的能力。">本地描述和绑定包括包类型的所有PL / SQL类型</a></p>
                  </li>
                  <li>
                     <p><a href="binding-and-defining-in-oci.html#GUID-6C5EA0C6-0C1D-4CD5-B47F-1B95B4E9C558" title="您可以使用OCI执行分段插入，更新和数据提取。">OCI中的运行时数据分配和分段操作</a> 
                     </p>
                  </li>
               </ul>
            </div><a id="LNOCI16360"></a><a id="LNOCI16359"></a><div class="props_rev_3"><a id="GUID-77A26CEA-1C41-46A2-866C-622F9FEB5482" name="GUID-77A26CEA-1C41-46A2-866C-622F9FEB5482"></a><h3 id="LNOCI-GUID-77A26CEA-1C41-46A2-866C-622F9FEB5482" class="sect3"><span class="enumeration_section">7.1</span> OCI中的绑定概述</h3>
               <div>
                  <p>本章扩展了绑定和定义的基本概念，并提供了有关可在OCI应用程序中使用的不同类型的绑定和定义的更多详细信息。</p>
                  <p>此外，本章还讨论了结构数组的使用，以及绑定，定义和字符转换中涉及的其他问题。</p>
                  <p>例如，给定<code class="codeph">INSERT</code>语句：</p><pre class="oac_no_warn" dir="ltr">INSERT INTO emp VALUES（：empno，：ename，：job，：sal，：deptno）</pre><p>然后给出以下变量声明：</p><pre class="oac_no_warn" dir="ltr">text * ename，* job;剑empno，sal，deptno;</pre><p>绑定步骤在占位符名称和程序变量的地址之间建立关联。绑定还指示程序变量的数据类型和长度， <a href="binding-and-defining-in-oci.html#GUID-77A26CEA-1C41-46A2-866C-622F9FEB5482__I423597">如图7-1所示</a> 。
                  </p>
                  <div class="figure" id="GUID-77A26CEA-1C41-46A2-866C-622F9FEB5482__I423597">
                     <p class="titleinfigure">图7-1使用OCIBindByName（）将占位符与程序变量相关联</p><img src="img/lnoci021.gif" alt="下面是图7-1的描述" title="下面是图7-1的描述" longdesc="img_text/lnoci021.html"><br><a href="img_text/lnoci021.html">“图7-1使用OCIBindByName（）将占位符与程序变量关联”</a></div>
                  <!-- class="figure" -->
                  <p>如果仅更改绑定变量的值，则无需重新绑定它以再次执行该语句。因为绑定是通过引用进行的，所以只要变量和句柄的地址保持有效，就可以重新执行引用变量而不重新绑定的语句。</p>
                  <div class="infoboxnote" id="GUID-77A26CEA-1C41-46A2-866C-622F9FEB5482__GUID-D4FD9BAA-0D7B-4218-A41B-5E14B54C8380">
                     <p class="notep1">注意：</p>
                     <p>在接口级别，所有绑定变量至少被视为<code class="codeph">IN</code> ，必须正确初始化。如果变量是纯<code class="codeph">OUT</code>绑定变量，则可以将变量设置为0。您还可以提供<code class="codeph">NULL</code>指示符并将该指示符设置为-1（ <code class="codeph">NULL</code> ）。
                     </p>
                  </div>
                  <p>在Oracle数据库中，已经为命名数据类型， <code class="codeph">REF</code>和LOB实现了数据类型，并且它们可以在SQL语句中绑定为占位符。
                  </p>
                  <div class="infoboxnote" id="GUID-77A26CEA-1C41-46A2-866C-622F9FEB5482__GUID-61FD84CE-5EE2-4311-B2A7-EC63B7E6EF11">
                     <p class="notep1">注意：</p>
                     <p>对于大小未知的不透明数据类型（描述符或定位符），传递描述符或定位器指针的地址。将size参数设置为适当数据结构的大小（ <code class="codeph">sizeof(structure)</code> ）。
                     </p>
                     <div class="p">本节包括以下主题：<ul style="list-style-type:disc">
                           <li>
                              <p><a href="binding-and-defining-in-oci.html#GUID-BC53FC10-66C7-4803-A90D-57647B0A0C91" title="在命名绑定中，语句中的每个占位符都有一个与之关联的名称，而在位置绑定中，占位符由它们在语句中的位置而不是它们的名称引用。">命名的绑定和位置绑定</a></p>
                           </li>
                           <li>
                              <p><a href="binding-and-defining-in-oci.html#GUID-442E47AD-83A8-4959-9A73-DBFB7D3482A6" title="您可以通过各种方式将数据传递到Oracle数据库。">OCI阵列接口</a></p>
                           </li>
                           <li>
                              <p><a href="binding-and-defining-in-oci.html#GUID-6D3F22A5-BA2E-4A22-BBFC-7FDA3B22557D" title="通过将块放在字符串变量中，绑定任何变量，然后执行包含块的语句来处理PL / SQL块，就像使用单个SQL语句一样。">关于在PL / SQL中绑定占位符</a></p>
                           </li>
                           <li>
                              <p><a href="binding-and-defining-in-oci.html#GUID-2C38033A-8B8D-4DC5-AD53-DB5E4B94747A" title="占位符分为几个步骤。">OCI绑定中使用的步骤</a></p>
                           </li>
                           <li>
                              <p><a href="binding-and-defining-in-oci.html#GUID-E7E9BBDF-F958-486F-92BC-286E836F8C3E" title="也许OCI中PL / SQL块最常见的用途是调用存储过程或存储函数。">OCI程序中的PL / SQL块</a></p>
                           </li>
                        </ul>
                     </div>
                  </div>
                  <div class="infoboxnotealso" id="GUID-77A26CEA-1C41-46A2-866C-622F9FEB5482__GUID-1B6CFB3A-75CC-49A7-AE3B-B8A73BFE5889">
                     <p class="notep1">也可以看看：</p>
                     <p><a href="binding-and-defining-in-oci.html#GUID-2C38033A-8B8D-4DC5-AD53-DB5E4B94747A" title="占位符分为几个步骤。">OCI绑定中使用的步骤用于</a>实现此示例的代码</p>
                  </div>
               </div><a id="LNOCI16361"></a><div class="props_rev_3"><a id="GUID-BC53FC10-66C7-4803-A90D-57647B0A0C91" name="GUID-BC53FC10-66C7-4803-A90D-57647B0A0C91"></a><h4 id="LNOCI-GUID-BC53FC10-66C7-4803-A90D-57647B0A0C91" class="sect4"><span class="enumeration_section">7.1.1</span>命名的绑定和位置绑定</h4>
                  <div>
                     <p>在命名绑定中，语句中的每个占位符都有一个与之关联的名称，而在位置绑定中，占位符由它们在语句中的位置而不是它们的名称引用。</p>
                     <p><a href="binding-and-defining-in-oci.html#GUID-77A26CEA-1C41-46A2-866C-622F9FEB5482__I423597">图7-1中</a>的SQL语句是<span class="italic">命名绑定</span>的示例。语句中的每个占位符都有一个与之关联的名称，例如“ename”或“sal”。准备此语句并且占位符与应用程序中的值相关联时，使用<code class="codeph">OCIBindByName()</code>或<code class="codeph">OCIBindByName2()</code>调用以及占位<span class="italic">符</span>参数中传递的<span class="italic">占位符</span>的名称，通过占位符的名称进行<code class="codeph">OCIBindByName2()</code> 。
                     </p>
                     <p>第二种类型的绑定称为<span class="italic">位置绑定</span> 。在位置绑定中，占位符由它们在语句中的位置而不是它们的名称来引用。出于绑定目的，使用<code class="codeph">OCIBindByPos()</code>或<code class="codeph">OCIBindByPos2()</code>调用在输入值和占位符的位置之间建立关联。
                     </p>
                     <p>要使用前面的示例进行位置绑定：</p><pre class="oac_no_warn" dir="ltr">INSERT INTO emp VALUES（：empno，：ename，：job，：sal，：deptno）</pre><p>然后通过调用<code class="codeph">OCIBindByPos()</code>或<code class="codeph">OCIBindByPos2()</code>并在<code class="codeph">position</code>参数中传递占位符的位置编号来绑定五个占位符。例如， <code class="codeph">:empno</code>占位符将通过调用位置为1的<code class="codeph">OCIBindByPos()</code>或<code class="codeph">OCIBindByPos2()</code>来绑定<code class="codeph">:ename</code>位置为2的<code class="codeph">:ename</code> ，依此类推。
                     </p>
                     <p>在重复绑定中，可能只需要一次绑定调用。请考虑以下SQL语句，该语句在数据库中查询佣金和薪水均大于给定金额的员工：</p><pre class="oac_no_warn" dir="ltr">SELECT empno FROM emp WHERE sal&gt;：some_value AND comm&gt;：some_value</pre><p>OCI应用程序可以通过单次调用<code class="codeph">OCIBindByName()</code>或<code class="codeph">OCIBindByName2()</code>来完成此语句的绑定，以按名称绑定<code class="codeph">:some_value</code>占位符。在这种情况下，所有绑定占位符<code class="codeph">:some_value</code>被赋予与<code class="codeph">OCIBindByName()</code>或<code class="codeph">OCIBindByName2()</code>调用所提供的值相同的值。
                     </p>
                     <p>现在考虑添加第6个占位符并重复的情况。例如，在前一个示例中添加<code class="codeph">:ename</code>作为第6个占位符：</p><pre class="oac_no_warn" dir="ltr">INSERT INTO emp VALUES（：empno，：ename，：job，：sal，：deptno，：ename）</pre><p>如果您正在使用<code class="codeph">OCIBindByName()</code>或<code class="codeph">OCIBindByName2()</code>调用，则只需一个绑定调用即可绑定<code class="codeph">:ename</code>占位符的两个匹配项。所有出现的<code class="codeph">:ename</code>语句中的<code class="codeph">:ename</code>将绑定到相同的值。此外，如果添加新的绑定占位符，结果现有绑定占位符的绑定位置发生更改，则无需更改现有绑定调用以更新绑定位置。如果您的程序发展为在语句文本中添加更多绑定变量，则这是使用<code class="codeph">OCIBindByName()</code>或<code class="codeph">OCIBindByName2()</code>调用的明显优势。
                     </p>
                     <p>但是，如果您正在使用<code class="codeph">OCIBindByPos()</code>或<code class="codeph">OCIBindByPos2()</code>调用，则在单独绑定重复绑定参数方面可以提高灵活性（如果需要）。您可以选择分别绑定任何绑定参数的重复出现。参数的任何未绑定的重复出现都会继承第一次出现的具有相同名称的bind参数的值。第一次出现必须明确绑定。
                     </p>
                     <p>在SQL语句的上下文中，位置<span class="italic">n</span>表示第<span class="italic">n</span>个位置的绑定参数。但是，在PL / SQL语句的上下文中， <code class="codeph">OCIBindByPos()</code>或<code class="codeph">OCIBindByPos2()</code>对位置参数有不同的解释：绑定调用中的位置<span class="italic">n</span>表示左侧扫描时语句中第<span class="italic">n</span>个唯一参数名称的绑定对。
                     </p>
                     <p>再次使用前面的示例和相同的SQL语句文本，如果要分别绑定第6个位置，则<code class="codeph">:ename</code>占位符将通过调用位置为6的<code class="codeph">OCIBindByPos()</code>或<code class="codeph">OCIBindByPos2()</code>进行绑定。否则，如果保持未绑定状态，则<code class="codeph">:ename</code>将继承第一次出现的具有相同名称的bind参数的值，在本例中为<code class="codeph">:ename</code> in position 2。
                     </p>
                     <div class="infoboxnotealso" id="GUID-BC53FC10-66C7-4803-A90D-57647B0A0C91__GUID-2DF93E86-63B4-4CA8-AFB3-ABBFF78E7C6E">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="bind-define-describe-functions.html#GUID-CD63DF78-2178-4727-A896-B9673C4A37F0" title="在SQL语句或PL / SQL块中创建程序变量和占位符之间的关联。">OCIBindByName（）</a>或<a href="bind-define-describe-functions.html#GUID-55C47708-5468-4106-89BE-1AB60861D037" title="在SQL语句或PL / SQL块中创建程序变量和占位符之间的关联。当客户端上的实际长度超过UB2MAXVAL时，在处理数据类型时使用此函数。">OCIBindByName2（）</a></p>
                           </li>
                           <li>
                              <p><a href="bind-define-describe-functions.html#GUID-D28DF5A7-3C75-4E52-82F7-A5D6D5714E69" title="在SQL语句或PL / SQL块中创建程序变量和占位符之间的关联。">OCIBindByPos（）</a>或<a href="bind-define-describe-functions.html#GUID-5C505821-323D-473D-825B-448C8D9A6702" title="在SQL语句或PL / SQL块中创建程序变量和占位符之间的关联。当客户端上的实际长度超过UB2MAXVAL时，在处理数据类型时使用此调用。">OCIBindByPos2（）</a></p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="LNOCI16362"></a><div class="props_rev_3"><a id="GUID-442E47AD-83A8-4959-9A73-DBFB7D3482A6" name="GUID-442E47AD-83A8-4959-9A73-DBFB7D3482A6"></a><h4 id="LNOCI-GUID-442E47AD-83A8-4959-9A73-DBFB7D3482A6" class="sect4"><span class="enumeration_section">7.1.2</span> OCI阵列接口</h4>
                  <div>
                     <p>您可以通过各种方式将数据传递到Oracle数据库。</p>
                     <p>您可以使用<code class="codeph">OCIStmtExecute()</code>例程重复执行SQL语句，并在每次迭代时提供不同的输入值。
                     </p>
                     <p>您可以使用Oracle数组接口，并使用单个语句和对<code class="codeph">OCIStmtExecute()</code>的单个调用输入许多值。在这种情况下，将数组绑定到输入占位符，并且可以在<span class="italic">iters</span>参数的控制下同时传递整个数组。
                     </p>
                     <p>在更新或插入大量数据时，阵列接口可显着减少到数据库的往返。这种减少可以在繁忙的客户端/服务器环境中带来可观的性能提升。例如，考虑将10行插入数据库的应用程序。使用单个值调用<code class="codeph">OCIStmtExecute()</code> 10次会导致10次网络往返以插入所有数据。使用输入数组单次调用<code class="codeph">OCIStmtExecute()</code>可能会产生相同的结果，该数组只涉及一次网络往返。
                     </p>
                     <p>从Oracle Database <span class="italic">12c</span>第2版（12.2）开始，对具有传统DML的混合列压缩（HCC）添加了支持，因此在使用OCI的数组插入期间可以使用HCC。 HCC常规数组插入仅支持ASSM表空间上的HCC表。 。
                     </p>
                     <div class="infoboxnote" id="GUID-442E47AD-83A8-4959-9A73-DBFB7D3482A6__GUID-F0528582-3A5B-43A0-846C-3A529DD3330A">
                        <p class="notep1">注意：</p>
                        <p>使用OCI阵列接口执行插入时，将在插入每行时触发数据库中的行触发器。</p>
                        <p>数组DML语句中允许的最大行数为40亿-1（3,999,999,999）。但是，如果使用<code class="codeph">ub8</code>而不是<code class="codeph">ub4</code> ， <code class="codeph">ub4</code>将数组DML语句中允许的最大行数增加到超过40亿行。
                        </p>
                     </div>
                     <div class="infoboxnotealso" id="GUID-442E47AD-83A8-4959-9A73-DBFB7D3482A6__GUID-13175ACB-CEF2-451A-87F5-3578FA9E8C43">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="statement-functions.html#GUID-98B26708-3E02-45C0-8258-5D5544F32BE9" title="将应用程序请求与服务器关联。">OCIStmtExecute（）</a></p>
                           </li>
                           <li>
                              <p>有关如何配置HCC的信息，请参见“ <span class="italic">Oracle数据库管理员指南”</span>中<span class="italic">的“</span> <a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/lnoci&amp;id=ADMIN-GUID-ED833867-4B7F-442E-A70C-9C19DAA8F445" target="_blank">表压缩</a> <span class="italic">”</span></p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="LNOCI16363"></a><div class="props_rev_3"><a id="GUID-6D3F22A5-BA2E-4A22-BBFC-7FDA3B22557D" name="GUID-6D3F22A5-BA2E-4A22-BBFC-7FDA3B22557D"></a><h4 id="LNOCI-GUID-6D3F22A5-BA2E-4A22-BBFC-7FDA3B22557D" class="sect4"><span class="enumeration_section">7.1.3</span>关于PL / SQL中的绑定占位符</h4>
                  <div>
                     <p>通过将块放在字符串变量中，绑定任何变量，然后执行包含块的语句来处理PL / SQL块，就像使用单个SQL语句一样。</p>
                     <p>将PL / SQL块中的占位符绑定到程序变量时，必须使用<code class="codeph">OCIBindByName()</code>或<code class="codeph">OCIBindByName2()</code>或<code class="codeph">OCIBindByPos()</code>或<code class="codeph">OCIBindByPos2()</code>来为标量或数组的主变量执行基本绑定。
                     </p>
                     <p>以下简短的PL / SQL块包含两个占位符，它们表示<code class="codeph">IN</code>给定员工编号和新工资金额时更新员工工资的过程的<code class="codeph">IN</code>参数：</p><pre class="oac_no_warn" dir="ltr">char plsql_statement [] =“BEGIN \ RAISE_SALARY（：emp_number，：new_sal）; \ END;” ;</pre><p>这些占位符可以以与SQL语句中的占位符相同的方式绑定到输入变量。</p>
                     <p>处理PL / SQL语句时，输出变量也通过使用绑定调用与程序变量相关联。</p>
                     <p>例如，考虑以下PL / SQL块：</p><pre class="oac_no_warn" dir="ltr">BEGIN SELECT ename，sal，comm INTO：emp_name，：salary，：commission FROM emp WHERE empno =：emp_number;结束;</pre><p>在此块中，您将使用<code class="codeph">OCIBindByName()</code>或<code class="codeph">OCIBindByName2()</code>来绑定变量来代替<code class="codeph">:emp_name</code> ， <code class="codeph">:salary</code>和<code class="codeph">:commission</code>输出占位符，并代替输入占位符<code class="codeph">:emp_number</code> 。
                     </p>
                     <div class="infoboxnote" id="GUID-6D3F22A5-BA2E-4A22-BBFC-7FDA3B22557D__GUID-33C1B6F2-2ACB-4479-89DA-49F752074914">
                        <p class="notep1">注意：</p>
                        <p>必须通过在绑定调用中将缓冲区长度设置为零来初始化所有缓冲区，甚至是纯<code class="codeph">OUT</code>缓冲区，或者通过将相应的指示符设置为-1来初始化。
                        </p>
                     </div>
                     <div class="infoboxnotealso" id="GUID-6D3F22A5-BA2E-4A22-BBFC-7FDA3B22557D__GUID-636BA551-12C6-47F4-ADA3-A612FFE1D90A">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="bind-define-describe-functions.html#GUID-CD63DF78-2178-4727-A896-B9673C4A37F0" title="在SQL语句或PL / SQL块中创建程序变量和占位符之间的关联。">OCIBindByName（）</a>或<a href="bind-define-describe-functions.html#GUID-55C47708-5468-4106-89BE-1AB60861D037" title="在SQL语句或PL / SQL块中创建程序变量和占位符之间的关联。当客户端上的实际长度超过UB2MAXVAL时，在处理数据类型时使用此函数。">OCIBindByName2（）</a></p>
                           </li>
                           <li>
                              <p><a href="bind-define-describe-functions.html#GUID-D28DF5A7-3C75-4E52-82F7-A5D6D5714E69" title="在SQL语句或PL / SQL块中创建程序变量和占位符之间的关联。">OCIBindByPos（）</a>或<a href="bind-define-describe-functions.html#GUID-5C505821-323D-473D-825B-448C8D9A6702" title="在SQL语句或PL / SQL块中创建程序变量和占位符之间的关联。当客户端上的实际长度超过UB2MAXVAL时，在处理数据类型时使用此调用。">OCIBindByPos2（）</a></p>
                           </li>
                           <li>
                              <p><a href="object-relational-data-types-in-oci.html#GUID-BB043B77-4B3C-4A1C-A4E4-9F225E0DF1BB" title="使用命名数据类型和REF绑定时，请记住以下重要信息。">有关命名数据类型和REF的</a>信息有关绑定PL / SQL占位符的更多信息，请进行绑定</p>
                           </li>
                        </ul>
                        <p></p>
                     </div>
                  </div>
               </div><a id="LNOCI72603"></a><a id="LNOCI16364"></a><div class="props_rev_3"><a id="GUID-2C38033A-8B8D-4DC5-AD53-DB5E4B94747A" name="GUID-2C38033A-8B8D-4DC5-AD53-DB5E4B94747A"></a><h4 id="LNOCI-GUID-2C38033A-8B8D-4DC5-AD53-DB5E4B94747A" class="sect4"><span class="enumeration_section">7.1.4</span> OCI绑定中使用的步骤</h4>
                  <div>
                     <p>占位符分为几个步骤。</p>
                     <p>对于简单的标量或数组绑定，只需要通过使用<code class="codeph">OCIBindByName()</code>或<code class="codeph">OCIBindByName2()</code>或<code class="codeph">OCIBindByPos()</code>或<code class="codeph">OCIBindByPos2()</code>来指定占位符和数据之间的关联。
                     </p>
                     <p>绑定完成后，OCI库会在执行SQL语句时检测输入数据的位置或放置PL / SQL输出数据的位置。程序输入数据在绑定到占位符时不需要在程序变量中，但是在执行语句时数据必须在那里。</p>
                     <p><a href="binding-and-defining-in-oci.html#GUID-2C38033A-8B8D-4DC5-AD53-DB5E4B94747A__CIHEIIBF">例7-1</a>中的以下代码示例显示了SQL语句中每个占位符的句柄分配和绑定。
                     </p>
                     <div class="infoboxnote" id="GUID-2C38033A-8B8D-4DC5-AD53-DB5E4B94747A__GUID-312921F2-6FBA-4303-AC81-03076F5CA262">
                        <p class="notep1">注意：</p>
                        <p><code class="codeph">checkerr()</code>函数评估来自OCI应用程序的返回码。该函数的代码在<code class="codeph">OCIErrorGet()</code>的示例中。
                        </p>
                     </div>
                     <div class="example" id="GUID-2C38033A-8B8D-4DC5-AD53-DB5E4B94747A__CIHEIIBF">
                        <p class="titleinexample">示例7-1处理SQL语句中每个占位符的分配和绑定</p><pre class="oac_no_warn" dir="ltr">.../ * SQL语句，通过调用OCIStmtPrepare2（）* / text * insert =（text *）“INSERT INTO emp（empno，ename，job，sal，deptno）\ VALUES（：empno， ：ename，：job，：sal，：deptno）“; .../ *在SQL语句中绑定占位符，每个绑定句柄一个。* / checkerr（errhp，OCIBindByName（stmthp，＆bnd1p，errhp，（text *）“：ENAME”，strlen（“：ENAME”），（ub1 *）ename，enamelen + 1，SQLT_STR，（void *）0，（ ub2 *）0，（ub2）0，（ub4）0，（ub4 *）0，OCI_DEFAULT））; checkerr（errhp，OCIBindByName（stmthp，＆bnd2p，errhp，（text *）“：JOB”，strlen（“：JOB”），（ub1 *）job，joblen + 1，SQLT_STR，（void *）＆job_ind，（ub2 * ）0，（ub2）0，（ub4）0，（ub4 *）0，OCI_DEFAULT））; checkerr（errhp，OCIBindByName（stmthp，＆bnd3p，errhp，（text *）“：SAL”，strlen（“：SAL”），（ub1 *）＆sal，（sword）sizeof（sal），SQLT_INT，（void *）＆sal_ind ，（ub2 *）0，（ub2）0，（ub4）0，（ub4 *）0，OCI_DEFAULT））; checkerr（errhp，OCIBindByName（stmthp，＆bnd4p，errhp，（text *）“：DEPTNO”，strlen（“：DEPTNO”），（ub1 *）＆deptno，（sword）sizeof（deptno），SQLT_INT，（void *）0 ，（ub2 *）0，（ub2）0，（ub4）0，（ub4 *）0，OCI_DEFAULT））; checkerr（errhp，OCIBindByName（stmthp，＆bnd5p，errhp，（text *）“：EMPNO”，strlen（“：EMPNO”），（ub1 *）＆empno，（sword）sizeof（empno），SQLT_INT，（void *）0 ，（ub2 *）0，（ub2）0，（ub4）0，（ub4 *）0，OCI_DEFAULT））;</pre><div class="infoboxnotealso" id="GUID-2C38033A-8B8D-4DC5-AD53-DB5E4B94747A__GUID-AE744F7A-D67C-4F93-8C46-19866CF28855">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><a href="bind-define-describe-functions.html#GUID-CD63DF78-2178-4727-A896-B9673C4A37F0" title="在SQL语句或PL / SQL块中创建程序变量和占位符之间的关联。">OCIBindByName（）</a>或<a href="bind-define-describe-functions.html#GUID-55C47708-5468-4106-89BE-1AB60861D037" title="在SQL语句或PL / SQL块中创建程序变量和占位符之间的关联。当客户端上的实际长度超过UB2MAXVAL时，在处理数据类型时使用此函数。">OCIBindByName2（）</a></p>
                              </li>
                              <li>
                                 <p><a href="bind-define-describe-functions.html#GUID-D28DF5A7-3C75-4E52-82F7-A5D6D5714E69" title="在SQL语句或PL / SQL块中创建程序变量和占位符之间的关联。">OCIBindByPos（）</a>或<a href="bind-define-describe-functions.html#GUID-5C505821-323D-473D-825B-448C8D9A6702" title="在SQL语句或PL / SQL块中创建程序变量和占位符之间的关联。当客户端上的实际长度超过UB2MAXVAL时，在处理数据类型时使用此调用。">OCIBindByPos2（）</a></p>
                              </li>
                              <li>
                                 <p><a href="miscellaneous-functions.html#GUID-4B99087C-74F6-498A-8310-D6645172390A" title="返回错误消息和Oracle数据库错误代码。">OCIErrorGet（）</a></p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="example" -->
                  </div>
               </div><a id="LNOCI72604"></a><a id="LNOCI16365"></a><div class="props_rev_3"><a id="GUID-E7E9BBDF-F958-486F-92BC-286E836F8C3E" name="GUID-E7E9BBDF-F958-486F-92BC-286E836F8C3E"></a><h4 id="LNOCI-GUID-E7E9BBDF-F958-486F-92BC-286E836F8C3E" class="sect4"><span class="enumeration_section">7.1.5</span> OCI程序中的PL / SQL块</h4>
                  <div>
                     <p>也许OCI中PL / SQL块最常见的用途是调用存储过程或存储函数。</p>
                     <p>假设存在一个名为<code class="codeph">RAISE_SALARY</code>的过程存储在数据库中，并在匿名PL / SQL块中嵌入对该过程的调用，然后处理PL / SQL块。
                     </p>
                     <p>以下程序片段显示如何在OCI应用程序中嵌入存储过程调用。该程序将员工编号和工资增加作为输入传递给名为<code class="codeph">raise_salary</code>的存储过程：</p><pre class="oac_no_warn" dir="ltr">raise_salary（employee_num IN，sal_increase IN，new_salary OUT）;</pre><p>此程序将给定员工的工资提高一定金额。结果的增加工资在存储过程的变量<code class="codeph">new_salary</code> ，程序显示该值。
                     </p>
                     <p>请注意，PL / SQL过程参数<code class="codeph">new_salary</code>虽然是PL / SQL OUT变量，但必须绑定，而不是定义。
                     </p>
                     <p><a href="binding-and-defining-in-oci.html#GUID-E7E9BBDF-F958-486F-92BC-286E836F8C3E__CIHEBECF">例7-2</a>演示了如何执行简单的标量绑定，其中只需要单个绑定调用。在某些情况下，需要额外的绑定调用来定义特定绑定数据类型或执行模式的属性。
                     </p>
                     <div class="example" id="GUID-E7E9BBDF-F958-486F-92BC-286E836F8C3E__CIHEBECF">
                        <p class="titleinexample">示例7-2定义要在OCI中使用的PL / SQL语句</p><pre class="oac_no_warn" dir="ltr">/ *定义要在程序中使用的PL / SQL语句。* / text * give_raise =（text *）“BEGIN \ RAISE_SALARY（：emp_number，：sal_increase，：new_salary）; \ END;”; OCIBind * bnd1p = NULL; / *第一个绑定句柄* / OCIBind * bnd2p = NULL; / *第二个绑定句柄* / OCIBind * bnd3p = NULL; / *第三个绑定句柄* / static void checkerr（）; sb4状态; main（）{sword empno，raise，new_sal; OCISession * usrhp =（OCISession *）NULL; .../ *附加到Oracle数据库，并执行必要的初始化和授权* / .../ *准备语句请求，传递PL / SQL文本块作为要准备的语句* / checkerr（errhp，OCIStmtPrepare2（svchp，＆stmthp，errhp，（text *）give_raise，（ub4）strlen（give_raise），NULL， 0，OCI_NTV_SYNTAX，OCI_DEFAULT））; / *将每个占位符绑定到程序变量* / checkerr（errhp，OCIBindByName（stmthp，＆bnd1p，errhp，（text *）“：emp_number”， -  1，（ub1 *）＆empno，（sword）sizeof（empno） ，SQLT_INT，（void *）0，（ub2 *）0，（ub2）0，（ub4）0，（ub4 *）0，OCI_DEFAULT））; checkerr（errhp，OCIBindByName（stmthp，＆bnd2p，errhp，（text *）“：sal_increase”， -  1，（ub1 *）＆raise，（sword）sizeof（raise），SQLT_INT，（void *）0，（ub2 *） 0，（ub2）0，（ub4）0，（ub4 *）0，OCI_DEFAULT））; / *记住PL / SQL OUT变量是绑定的，未定义* / checkerr（errhp，OCIBindByName（stmthp，＆bnd3p，errhp，（text *）“：new_salary”， -  1，（ub1 *）＆new_sal，（sword）sizeof （new_sal），SQLT_INT，（void *）0，（ub2 *）0，（ub2）0，（ub4）0，（ub4 *）0，OCI_DEFAULT））; / *提示用户输入值* / printf（“输入员工编号：”）; scanf（“％d”，＆empno）; / *刷新输入缓冲区* / myfflush（）; printf（“输入员工的加薪：”）; scanf（“％d”，＆raise）; / *刷新输入缓冲区* / myfflush（）; / *执行PL / SQL块* / checkerr（errhp，OCIStmtExecute（svchp，stmthp，errhp，（ub4）1，（ub4）0，（OCISnapshot *）NULL，（OCISnapshot *）NULL，OCI_DEFAULT））; / *显示新工资，跟随加薪* / printf（“新工资是％d \ n”，new_sal）; OCIStmtRelease（stmthp，errhp，NULL，0，OCI_DEFAULT）; }</pre><div class="infoboxnotealso" id="GUID-E7E9BBDF-F958-486F-92BC-286E836F8C3E__GUID-8584E6E0-C323-45FF-A623-8470BD9E8FB7">
                           <p class="notep1">也可以看看：</p>为什么PL / SQL OUT变量必须绑定且未定义，请参阅<a href="binding-and-defining-in-oci.html#GUID-B5890EB7-4E83-45EE-A38E-C592A46FFB79" title="不要使用define调用为PL / SQL块内的SQL SELECT语句中的select-list项定义输出变量。">关于定义PL / SQL输出变量</a>以及<a href="object-relational-data-types-in-oci.html#GUID-1E2056EF-32BE-4875-9211-C2D4BB535D11" title="在使用命名数据类型和REF定义时，请考虑以下重要信息。它包括有关内存分配和指示符变量用法的指针。">命名数据类型和REF定义的信息以及PL / SQL OUT绑定</a> 。
                        </div>
                     </div>
                     <!-- class="example" -->
                  </div>
               </div>
            </div><a id="LNOCI16367"></a><a id="LNOCI16366"></a><div class="props_rev_3"><a id="GUID-EE9AD90D-8CFD-4380-9D5E-819555EB3A8E" name="GUID-EE9AD90D-8CFD-4380-9D5E-819555EB3A8E"></a><h3 id="LNOCI-GUID-EE9AD90D-8CFD-4380-9D5E-819555EB3A8E" class="sect3"><span class="enumeration_section">7.2</span> OCI中的高级绑定操作</h3>
               <div>
                  <p>更高级的绑定操作包括多步骤绑定，以及命名数据类型和<code class="codeph">REFs</code>绑定。
                  </p>
                  <p><a href="using-sql_statements-in-oci.html#GUID-CB348BD8-9A45-4921-B397-ADFE96B75C70" title="大多数DML语句和一些查询（例如具有WHERE子句的查询）都需要程序将数据作为SQL或PL / SQL语句的一部分传递给Oracle数据库。">关于OCI中的绑定占位符</a>讨论了如何执行基本绑定操作，以通过使用<code class="codeph">OCIBindByName()</code>或<code class="codeph">OCIBindByName2()</code>或<code class="codeph">OCIBindByPos()</code>或<code class="codeph">OCIBindByPos2()</code>在SQL语句中的占位符和程序变量之间创建关联。本节介绍更高级的绑定操作，包括多步绑定，以及命名数据类型和<code class="codeph">REFs</code>绑定。
                  </p>
                  <p>在某些情况下，需要额外的绑定调用来定义某些绑定数据类型或某些执行模式的特定属性。</p>
                  <p>以下部分描述了这些特殊情况， <a href="binding-and-defining-in-oci.html#GUID-EE9AD90D-8CFD-4380-9D5E-819555EB3A8E__CIHJBEEH" title="该表有3列。第1列是绑定类型，第2列是绑定数据类型，第3列是注释。">表7-1</a>总结了有关绑定的信息。<span class="bold"></span></p>
                  <div class="tblformalwide" id="GUID-EE9AD90D-8CFD-4380-9D5E-819555EB3A8E__CIHJBEEH">
                     <p class="titleintable">表7-1绑定类型的信息摘要</p>
                     <table cellpadding="4" cellspacing="0" class="FormalWide" title="绑定类型的信息摘要" width="100%" border="1" summary="This table has 3 columns. Column 1 is the type of bind, column 2 is the bind data type, and column 3 is notes." frame="hsides" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="23%" id="d73793e2272">绑定类型</th>
                              <th align="left" valign="bottom" width="19%" id="d73793e2275">绑定数据类型</th>
                              <th align="left" valign="bottom" width="58%" id="d73793e2278">笔记</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="23%" id="d73793e2283" headers="d73793e2272 ">
                                 <p>纯量</p>
                              </td>
                              <td align="left" valign="top" width="19%" headers="d73793e2283 d73793e2275 ">
                                 <p>任何标量数据类型</p>
                              </td>
                              <td align="left" valign="top" width="58%" headers="d73793e2283 d73793e2278 ">
                                 <p>使用<code class="codeph">OCIBindByName()</code>或<code class="codeph">OCIBindByName2()</code>或<code class="codeph">OCIBindByPos()</code>或<code class="codeph">OCIBindByPos2()</code>绑定单个标量。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="23%" id="d73793e2305" headers="d73793e2272 ">
                                 <p>一系列标量</p>
                              </td>
                              <td align="left" valign="top" width="19%" headers="d73793e2305 d73793e2275 ">
                                 <p>任何标量数据类型</p>
                              </td>
                              <td align="left" valign="top" width="58%" headers="d73793e2305 d73793e2278 ">
                                 <p>使用<code class="codeph">OCIBindByName()</code>或<code class="codeph">OCIBindByName2()</code>或<code class="codeph">OCIBindByPos()</code>或<code class="codeph">OCIBindByPos2()</code>绑定一组标量。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="23%" id="d73793e2327" headers="d73793e2272 ">
                                 <p>命名数据类型</p>
                              </td>
                              <td align="left" valign="top" width="19%" headers="d73793e2327 d73793e2275 ">
                                 <p><code class="codeph">SQLT_NTY</code></p>
                              </td>
                              <td align="left" valign="top" width="58%" headers="d73793e2327 d73793e2278 ">
                                 <p>包括记录和集合</p>
                                 <p>需要两个绑定调用：</p>
                                 <ul style="list-style-type:disc">
                                    <li>
                                       <p><code class="codeph">OCIBindByName()</code>或<code class="codeph">OCIBindByName2()</code>或<code class="codeph">OCIBindByPos()</code>或<code class="codeph">OCIBindByPos2()</code></p>
                                    </li>
                                    <li>
                                       <p><code class="codeph">OCIBindObject（）</code></p>
                                    </li>
                                 </ul>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="23%" id="d73793e2358" headers="d73793e2272 ">
                                 <p>布尔</p>
                              </td>
                              <td align="left" valign="top" width="19%" headers="d73793e2358 d73793e2275 ">
                                 <p><code class="codeph">SQLT_BOL</code></p>
                              </td>
                              <td align="left" valign="top" width="58%" headers="d73793e2358 d73793e2278 ">
                                 <p>使用<code class="codeph">OCIBindByName()</code>或<code class="codeph">OCIBindByName2()</code>或<code class="codeph">OCIBindByPos()</code>或<code class="codeph">OCIBindByPos2()</code>绑定布尔值。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="23%" id="d73793e2381" headers="d73793e2272 ">
                                 <p><code class="codeph">REF</code></p>
                              </td>
                              <td align="left" valign="top" width="19%" headers="d73793e2381 d73793e2275 ">
                                 <p><code class="codeph">SQLT_REF</code></p>
                              </td>
                              <td align="left" valign="top" width="58%" headers="d73793e2381 d73793e2278 ">
                                 <p>需要两个绑定调用：</p>
                                 <ul style="list-style-type:disc">
                                    <li>
                                       <p><code class="codeph">OCIBindByName()</code>或<code class="codeph">OCIBindByName2()</code>或<code class="codeph">OCIBindByPos()</code>或<code class="codeph">OCIBindByPos2()</code></p>
                                    </li>
                                    <li>
                                       <p><code class="codeph">OCIBindObject（）</code></p>
                                    </li>
                                 </ul>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="23%" id="d73793e2411" headers="d73793e2272 ">
                                 <p>高球</p>
                                 <p><code class="codeph">BFILE</code></p>
                              </td>
                              <td align="left" valign="top" width="19%" headers="d73793e2411 d73793e2275 ">
                                 <p><code class="codeph">SQLT_BLOB</code></p>
                                 <p><code class="codeph">SQLT_CLOB</code></p>
                              </td>
                              <td align="left" valign="top" width="58%" headers="d73793e2411 d73793e2278 ">
                                 <p>使用<code class="codeph">OCIDescriptorAlloc()</code>分配LOB定位器，然后使用其中一种LOB数据类型将其地址<code class="codeph">OCILobLocator</code> <code class="codeph">**</code>与<code class="codeph">OCIBindByName()</code>或<code class="codeph">OCIBindByName2()</code>或<code class="codeph">OCIBindByPos()</code>或<code class="codeph">OCIBindByPos2()</code> 。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="23%" id="d73793e2450" headers="d73793e2272 ">
                                 <p>结构数组或静态数组</p>
                              </td>
                              <td align="left" valign="top" width="19%" headers="d73793e2450 d73793e2275 ">
                                 <p>不定</p>
                              </td>
                              <td align="left" valign="top" width="58%" headers="d73793e2450 d73793e2278 ">
                                 <p>需要两个绑定调用：</p>
                                 <ul style="list-style-type:disc">
                                    <li>
                                       <p><code class="codeph">OCIBindByName()</code>或<code class="codeph">OCIBindByName2()</code>或<code class="codeph">OCIBindByPos()</code>或<code class="codeph">OCIBindByPos2()</code></p>
                                    </li>
                                    <li>
                                       <p><code class="codeph">OCIBindArrayOfStruct（）</code></p>
                                    </li>
                                 </ul>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="23%" id="d73793e2478" headers="d73793e2272 ">
                                 <p>分段插入</p>
                              </td>
                              <td align="left" valign="top" width="19%" headers="d73793e2478 d73793e2275 ">
                                 <p>不定</p>
                              </td>
                              <td align="left" valign="top" width="58%" headers="d73793e2478 d73793e2278 ">
                                 <p><code class="codeph">OCIBindByName()</code>或<code class="codeph">OCIBindByName2()</code>或<code class="codeph">OCIBindByPos()</code>或<code class="codeph">OCIBindByPos2()</code> 。应用程序可能还需要调用<code class="codeph">OCIBindDynamic()</code>来注册分段回调。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="23%" id="d73793e2502" headers="d73793e2272 ">
                                 <p><code class="codeph">REF CURSOR</code>变量</p>
                              </td>
                              <td align="left" valign="top" width="19%" headers="d73793e2502 d73793e2275 ">
                                 <p><code class="codeph">SQLT_RSET</code></p>
                              </td>
                              <td align="left" valign="top" width="58%" headers="d73793e2502 d73793e2278 ">
                                 <p>分配语句句柄<code class="codeph">OCIStmt</code> ，然后使用<code class="codeph">SQLT_RSET</code>数据类型绑定其地址<code class="codeph">OCIStmt **</code> 。
                                 </p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
                  <div class="p">本节包括以下主题：<ul style="list-style-type:disc">
                        <li>
                           <p><a href="binding-and-defining-in-oci.html#GUID-B8FD8CD2-95C1-4EA5-A896-7AA3642D01BE" title="有两种绑定LOB的方法：">关于绑定LOB</a></p>
                        </li>
                        <li>
                           <p><a href="binding-and-defining-in-oci.html#GUID-D9A7AC35-9CE8-4B1F-9F4C-B9BE064EAD69" title="如果对OCIBindByName（）或OCIBindByName2（）或OCIBindByPos（）或OCIBindByPos2（）的调用中的mode参数设置为OCI_DATA_AT_EXEC，则如果应用程序使用回调方法在运行时提供数据，则需要额外调用OCIBindDynamic（） 。">关于OCI_DATA_AT_EXEC模式下的绑定</a></p>
                        </li>
                        <li>
                           <p><a href="binding-and-defining-in-oci.html#GUID-983E7E07-7941-4A8E-A046-2F5A6A50C0E1" title="REF CURSOR绑定到绑定数据类型为SQLT_RSET的语句句柄。">关于绑定REF CURSOR变量</a></p>
                        </li>
                     </ul>
                  </div>
                  <div class="infoboxnotealso" id="GUID-EE9AD90D-8CFD-4380-9D5E-819555EB3A8E__GUID-B6FCD5C3-AC75-4639-8077-79D66298D5EA">
                     <p class="notep1">也可以看看：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="object-relational-data-types-in-oci.html#GUID-25B2139A-8F55-4256-88EB-D8F5F706904C" title="对于命名数据类型（对象类型或集合）绑定，在OCIBindByName（）或OCIBindByName2（）或OCIBindByPos（）或OCIBindByPos2（）之后需要进行第二次绑定调用。">命名数据类型绑定</a>有关绑定命名数据类型（对象）的信息</p>
                        </li>
                        <li>
                           <p><a href="object-relational-data-types-in-oci.html#GUID-5A08B855-FB63-4457-866F-DAB035059E49" title="与命名数据类型一样，绑定REF是一个两步过程。">关于绑定REF</a></p>
                        </li>
                        <li>
                           <p><a href="bind-define-describe-functions.html#GUID-CD63DF78-2178-4727-A896-B9673C4A37F0" title="在SQL语句或PL / SQL块中创建程序变量和占位符之间的关联。">OCIBindByName（）</a>或<a href="bind-define-describe-functions.html#GUID-55C47708-5468-4106-89BE-1AB60861D037" title="在SQL语句或PL / SQL块中创建程序变量和占位符之间的关联。当客户端上的实际长度超过UB2MAXVAL时，在处理数据类型时使用此函数。">OCIBindByName2（）</a></p>
                        </li>
                        <li>
                           <p><a href="bind-define-describe-functions.html#GUID-D28DF5A7-3C75-4E52-82F7-A5D6D5714E69" title="在SQL语句或PL / SQL块中创建程序变量和占位符之间的关联。">OCIBindByPos（）</a>或<a href="bind-define-describe-functions.html#GUID-5C505821-323D-473D-825B-448C8D9A6702" title="在SQL语句或PL / SQL块中创建程序变量和占位符之间的关联。当客户端上的实际长度超过UB2MAXVAL时，在处理数据类型时使用此调用。">OCIBindByPos2（）</a></p>
                        </li>
                        <li>
                           <p><a href="bind-define-describe-functions.html#GUID-384B5D31-165B-4661-A334-8C2B5E475AEF" title="设置命名数据类型（对象）绑定所需的其他属性。">OCIBindObject（）</a></p>
                        </li>
                        <li>
                           <p><a href="handle-and-descriptor-functions.html#GUID-E9EF2766-E078-49A7-B1D1-738E4BA4814F" title="分配存储以保存描述符或LOB定位符。">OCIDescriptorAlloc（）</a></p>
                        </li>
                        <li>
                           <p><a href="bind-define-describe-functions.html#GUID-E83BF668-88FC-4F31-A950-3580B79588E0" title="设置静态数组绑定的跳过参数。">OCIBindArrayOfStruct（）</a></p>
                        </li>
                        <li>
                           <p><a href="bind-define-describe-functions.html#GUID-030270CB-346A-412E-B3B3-556DD6947BE2" title="注册用户回调以进行动态数据分配。">OCIBindDynamic（）</a></p>
                        </li>
                     </ul>
                  </div>
               </div><a id="LNOCI16368"></a><div class="props_rev_3"><a id="GUID-B8FD8CD2-95C1-4EA5-A896-7AA3642D01BE" name="GUID-B8FD8CD2-95C1-4EA5-A896-7AA3642D01BE"></a><h4 id="LNOCI-GUID-B8FD8CD2-95C1-4EA5-A896-7AA3642D01BE" class="sect4"><span class="enumeration_section">7.2.1</span>关于绑定LOB</h4>
                  <div>
                     <p>有两种绑定LOB的方法：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>绑定LOB定位符，而不是实际的LOB值。在这种情况下，通过将LOB定位符传递给OCI LOB函数来写入或读取LOB值。</p>
                        </li>
                        <li>
                           <p>直接绑定LOB值，而不使用LOB定位器。</p>
                        </li>
                     </ul>
                     <div class="p">本节包括以下主题：<ul style="list-style-type:disc">
                           <li>
                              <p><a href="binding-and-defining-in-oci.html#GUID-B57CC385-F279-45BA-8CF4-FBF42565C640" title="可以在单个绑定调用中绑定单个定位器或定位器数组。">绑定LOB定位器</a></p>
                           </li>
                           <li>
                              <p><a href="binding-and-defining-in-oci.html#GUID-D757C946-BCDA-4A32-867B-BE951BA9BBF4" title="Oracle数据库允许对任何大小的LOB的INSERT和UPDATE进行非零绑定。">关于绑定LOB数据</a></p>
                           </li>
                        </ul>
                     </div>
                  </div><a id="LNOCI72605"></a><a id="LNOCI72606"></a><a id="LNOCI16369"></a><div class="props_rev_3"><a id="GUID-B57CC385-F279-45BA-8CF4-FBF42565C640" name="GUID-B57CC385-F279-45BA-8CF4-FBF42565C640"></a><h5 id="LNOCI-GUID-B57CC385-F279-45BA-8CF4-FBF42565C640" class="sect5"><span class="enumeration_section">7.2.1.1</span>绑定LOB定位器</h5>
                     <div>
                        <p>可以在单个绑定调用中绑定单个定位器或定位器数组。</p>
                        <p>在每种情况下，应用程序必须传递<span class="italic">LOB定位器</span>的<span class="italic">地址</span>而不是定位器本身。例如，假设应用程序已准备此SQL语句，其中<code class="codeph">one_lob</code>是对应于LOB列的绑定变量：</p><pre class="oac_no_warn" dir="ltr">插入some_table VALUES（：one_lob）</pre><p>然后您的申请作出以下声明：</p><pre class="oac_no_warn" dir="ltr">OCILobLocator * one_lob;</pre><p>然后， <a href="binding-and-defining-in-oci.html#GUID-B57CC385-F279-45BA-8CF4-FBF42565C640__CIHEEHEF">示例7-3中</a>的调用将用于绑定占位符并执行语句：</p>
                        <p>您还可以使用相同的SQL <code class="codeph">INSERT</code>语句插入数组。在这种情况下，应用程序将包含<a href="binding-and-defining-in-oci.html#GUID-B57CC385-F279-45BA-8CF4-FBF42565C640__CIHDCCJD">示例7-4中</a>所示的代码。
                        </p>
                        <p>必须先使用<code class="codeph">OCIDescriptorAlloc()</code>函数分配描述符，然后才能使用它们。在定位器数组中，必须使用<code class="codeph">OCIDescriptorAlloc()</code>初始化每个数组元素。在分配<code class="codeph">BLOB</code> ， <code class="codeph">CLOB</code>和<code class="codeph">NCLOB</code>时，使用<code class="codeph">OCI_DTYPE_LOB</code>作为<code class="codeph">type</code>参数。分配<code class="codeph">BFILE</code>时使用<code class="codeph">OCI_DTYPE_FILE</code> 。
                        </p>
                        <div class="example" id="GUID-B57CC385-F279-45BA-8CF4-FBF42565C640__CIHEEHEF">
                           <p class="titleinexample">示例7-3绑定占位符和执行语句以插入单个定位器</p><pre class="oac_no_warn" dir="ltr">/ *初始化单个定位器* / one_lob = OCIDescriptorAlloc（...OCI_DTYPE_LOB ...）; .../ *传递定位器的地址* / OCIBindByName（...，（void *）＆one_lob，...SQLT_CLOB，...）; OCIStmtExecute（...，1，...）/ * 1是iters参数* /</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-B57CC385-F279-45BA-8CF4-FBF42565C640__CIHDCCJD">
                           <p class="titleinexample">示例7-4绑定占位符和执行语句以插入定位器数组</p><pre class="oac_no_warn" dir="ltr">OCILobLocator * lob_array [10]; ...for（i = 0; i &lt;10，i ++）lob_array [i] = OCIDescriptorAlloc（...OCI_DTYPE_LOB ...）; / *初始化定位器数组* / ...OCIBindByName（...，（void *）lob_array，...）; OCIStmtExecute（...，10，...）; / * 10是iters参数* /</pre></div>
                        <!-- class="example" -->
                        <div class="section">
                           <p>本节包括以下主题： <a href="binding-and-defining-in-oci.html#GUID-B00D7494-01AE-40AD-A6D6-4434EF7710CE" title="绑定LOB定位器有哪些限制。">绑定LOB定位器的限制</a></p>
                           <div class="infoboxnotealso" id="GUID-B57CC385-F279-45BA-8CF4-FBF42565C640__GUID-51B36583-4A3D-4DBE-81E4-B2A9ACC77F86">
                              <p class="notep1">也可以看看：</p><a href="handle-and-descriptor-functions.html#GUID-E9EF2766-E078-49A7-B1D1-738E4BA4814F" title="分配存储以保存描述符或LOB定位符。">OCIDescriptorAlloc（）</a></div>
                        </div>
                        <!-- class="section" -->
                     </div><a id="LNOCI16370"></a><div class="props_rev_3"><a id="GUID-B00D7494-01AE-40AD-A6D6-4434EF7710CE" name="GUID-B00D7494-01AE-40AD-A6D6-4434EF7710CE"></a><h6 id="LNOCI-GUID-B00D7494-01AE-40AD-A6D6-4434EF7710CE" class="sect6"><span class="enumeration_section">7.2.1.1.1</span>绑定LOB定位器的限制</h6>
                        <div>
                           <p>绑定LOB定位器有哪些限制。</p>
                           <p>绑定LOB定位符时，请遵守以下限制：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>不支持分段和回调<code class="codeph">INSERT</code>或<code class="codeph">UPDATE</code>操作。
                                 </p>
                              </li>
                              <li>
                                 <p>使用FILE定位器作为<code class="codeph">INSERT</code>或<code class="codeph">UPDATE</code>语句的绑定变量时，必须首先使用<code class="codeph">OCILobFileSetName()</code>在发出<code class="codeph">INSERT</code>或<code class="codeph">UPDATE</code>语句之前使用目录对象和文件名初始化定位器。
                                 </p>
                              </li>
                           </ul>
                           <div class="infoboxnotealso" id="GUID-B00D7494-01AE-40AD-A6D6-4434EF7710CE__GUID-94F3E17F-2294-4254-BDFA-CC844EE57C74">
                              <p class="notep1">也可以看看：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>有关OCI LOB功能的更多信息，请参阅<a href="lobs-and-bfile-operations.html#GUID-0A094518-F97C-40BE-A336-259AA82BD0A2" title="本章介绍LOB和BFILE操作。">LOB和BFILE操作</a></p>
                                 </li>
                                 <li>
                                    <p><a href="lob-functions.html#GUID-507AC0EF-4CAB-437E-BB94-1FD77EDC1B5C" title="在BFILE定位器中设置目录对象和文件名。">OCILobFileSetName（）</a></p>
                                 </li>
                              </ul>
                              <p></p>
                           </div>
                        </div>
                     </div>
                  </div><a id="LNOCI16371"></a><div class="props_rev_3"><a id="GUID-D757C946-BCDA-4A32-867B-BE951BA9BBF4" name="GUID-D757C946-BCDA-4A32-867B-BE951BA9BBF4"></a><h5 id="LNOCI-GUID-D757C946-BCDA-4A32-867B-BE951BA9BBF4" class="sect5"><span class="enumeration_section">7.2.1.2</span>关于绑定LOB数据</h5>
                     <div>
                        <p>Oracle数据库允许对任何大小的LOB的<code class="codeph">INSERT</code>和<code class="codeph">UPDATE</code>进行非零绑定。</p>
                        <p>因此，您可以使用<code class="codeph">OCIBindByPos()</code>或<code class="codeph">OCIBindByPos2()</code> ， <code class="codeph">OCIBindByName()</code>或<code class="codeph">OCIBindByName2()</code>将数据绑定到LOB列，并且PL / SQL绑定。
                        </p>
                        <p>超过4千字节的数据绑定到LOB列使用临时表空间中的空间。确保您的临时表空间足够大，至少可以保存等于LOB所有绑定长度总和的数据量。如果临时表空间是可扩展的，则在完全使用现有空间后会自动扩展它。使用以下命令创建可扩展的临时表空间：</p><pre class="oac_no_warn" dir="ltr">CREATE TABLESPACE ...AUTOEXTEND ON ...临时......;</pre><div class="p">本节包括以下主题：<ul style="list-style-type:disc">
                              <li>
                                 <p><a href="binding-and-defining-in-oci.html#GUID-96BB84DD-34D1-4280-A6C8-6B1A9E475A26" title="绑定LOB数据有哪些限制。">绑定LOB数据的限制</a></p>
                              </li>
                              <li>
                                 <p><a href="binding-and-defining-in-oci.html#GUID-5741DA96-8C5F-45F3-B161-DAB2E51E142E" title="显示绑定LOB数据的一些示例。">绑定LOB数据的示例</a></p>
                              </li>
                           </ul>
                        </div>
                        <div class="infoboxnotealso" id="GUID-D757C946-BCDA-4A32-867B-BE951BA9BBF4__GUID-9AD823D9-8B7D-4A28-93EC-69830C8AF118">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><a href="bind-define-describe-functions.html#GUID-D28DF5A7-3C75-4E52-82F7-A5D6D5714E69" title="在SQL语句或PL / SQL块中创建程序变量和占位符之间的关联。">OCIBindByPos（）</a>或<a href="bind-define-describe-functions.html#GUID-5C505821-323D-473D-825B-448C8D9A6702" title="在SQL语句或PL / SQL块中创建程序变量和占位符之间的关联。当客户端上的实际长度超过UB2MAXVAL时，在处理数据类型时使用此调用。">OCIBindByPos2（）</a></p>
                              </li>
                              <li>
                                 <p><a href="bind-define-describe-functions.html#GUID-CD63DF78-2178-4727-A896-B9673C4A37F0" title="在SQL语句或PL / SQL块中创建程序变量和占位符之间的关联。">OCIBindByName（）</a>或<a href="bind-define-describe-functions.html#GUID-55C47708-5468-4106-89BE-1AB60861D037" title="在SQL语句或PL / SQL块中创建程序变量和占位符之间的关联。当客户端上的实际长度超过UB2MAXVAL时，在处理数据类型时使用此函数。">OCIBindByName2（）</a></p>
                              </li>
                           </ul>
                        </div>
                     </div><a id="LNOCI16372"></a><div class="props_rev_3"><a id="GUID-96BB84DD-34D1-4280-A6C8-6B1A9E475A26" name="GUID-96BB84DD-34D1-4280-A6C8-6B1A9E475A26"></a><h6 id="LNOCI-GUID-96BB84DD-34D1-4280-A6C8-6B1A9E475A26" class="sect6"><span class="enumeration_section">7.2.1.2.1</span>绑定LOB数据的限制</h6>
                        <div>
                           <p>绑定LOB数据有哪些限制。</p>
                           <p>绑定LOB数据时，请遵守以下限制：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>如果一个表同时具有<code class="codeph">LONG</code>和LOB列，那么对于<code class="codeph">LONG</code>列或LOB列，您可以具有大于4千字节的绑定，但不能在同一语句中具有两个绑定。
                                 </p>
                              </li>
                              <li>
                                 <p>在<code class="codeph">INSERT</code> <code class="codeph">AS</code> <code class="codeph">SELECT</code>操作中，Oracle数据库不允许将任何长度数据绑定到LOB列。
                                 </p>
                              </li>
                              <li>
                                 <p>特殊注意事项适用于既不是LONG也不是LOB的绑定变量的最大大小，而是出现在SQL语句中的任何LOB或LONG绑定变量之后。如果此类绑定变量的最大大小超过4000个字节， <code class="codeph">ORA-24816</code>从Oracle数据库收到<code class="codeph">ORA-24816</code>错误。要避免此错误，必须为字符集转换后服务器端最大大小超过4000字节的任何此类绑定设置<code class="codeph">OCI_ATTR_MAXDATA_SIZE</code>为4000字节。或者，重新排序绑定，以便将这些绑定放在绑定列表中的任何LONG或LOB之前。
                                 </p>
                              </li>
                              <li>
                                 <p>对于大小超过4000字节的数据，Oracle数据库不会进行隐式转换，例如<code class="codeph">HEX</code>到<code class="codeph">RAW</code>或<code class="codeph">RAW</code>到<code class="codeph">HEX</code> 。以下代码示例中的PL / SQL代码说明了这一点：</p>
                                 <p>展示一些无法完成的隐含转换</p><pre class="oac_no_warn" dir="ltr">创建表t（c1 clob，c2 blob）;声明文本varchar（32767）; binbuf raw（32767）;开始文字：= lpad（'a'，12000，'a'）; binbuf：= utl_raw.cast_to_raw（text）; - 以下工作：插入t值（text，binbuf）; - 以下不起作用，因为Oracle dpes不执行隐式 - 十六进制到原始转换。插入t（c2）值（文本）; - 以下不起作用，因为Oracle不执行隐式 - 原始到十六进制转换。插入t（c1）值（binbuf）; - 以下操作无效，因为您无法将 -  utl_raw.cast_to_raw（）运算符与&gt; 4k绑定结合使用。插入t（c2）值（utl_raw.cast_to_raw（text））;结束; /</pre></li>
                              <li>
                                 <p>如果将超过4000个字节的数据绑定到<code class="codeph">BLOB</code>或<code class="codeph">CLOB</code> ，并且数据由SQL运算符进行过滤，则Oracle数据库会将结果的大小限制为最多4000个字节。
                                 </p>
                                 <p>例如：</p><pre class="oac_no_warn" dir="ltr">创建表t（c1 clob，c2 blob）; - 以下命令仅插入4000个字节，因为 -  LPAD的结果限制为插入t（c1）值的4000字节（lpad（'a'，5000，'a'））; - 以下命令仅插入2000个字节，因为 -  LPAD的结果限制为4000个字节，而隐式的十六进制到原始转换 - 将其转换为2000个字节的RAW数据。插入t（c2）值（lpad（'a'，5000，'a'））;</pre></li>
                           </ul>
                           <div class="infoboxnotealso" id="GUID-96BB84DD-34D1-4280-A6C8-6B1A9E475A26__GUID-F183A3E6-11AA-4967-925B-E13702C191AF">
                              <p class="notep1">也可以看看：</p>
                              <p><a href="binding-and-defining-in-oci.html#GUID-AD86F080-F3A4-4D85-A20E-B81A4EF11B40" title="每个绑定句柄都有一个OCI_ATTR_MAXDATA_SIZE属性，该属性指定在字符集转换后在服务器上分配的字节数以容纳客户端绑定数据。">关于使用OCI_ATTR_MAXDATA_SIZE属性</a></p>
                           </div>
                        </div>
                     </div><a id="LNOCI72608"></a><a id="LNOCI72609"></a><a id="LNOCI72610"></a><a id="LNOCI72611"></a><a id="LNOCI72612"></a><a id="LNOCI72613"></a><a id="LNOCI72614"></a><a id="LNOCI72615"></a><a id="LNOCI16373"></a><div class="props_rev_3"><a id="GUID-5741DA96-8C5F-45F3-B161-DAB2E51E142E" name="GUID-5741DA96-8C5F-45F3-B161-DAB2E51E142E"></a><h6 id="LNOCI-GUID-5741DA96-8C5F-45F3-B161-DAB2E51E142E" class="sect6"><span class="enumeration_section">7.2.1.2.2</span>绑定LOB数据的示例</h6>
                        <div>
                           <p>显示绑定LOB数据的一些示例。</p>
                           <p><a href="binding-and-defining-in-oci.html#GUID-5741DA96-8C5F-45F3-B161-DAB2E51E142E__CIHBCIAD">例7-5</a>到<a href="binding-and-defining-in-oci.html#GUID-5741DA96-8C5F-45F3-B161-DAB2E51E142E__CIHGHACA">例7-12</a>中使用了以下SQL语句：</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE foo（INTEGER）; CREATE TYPE lob_typ AS OBJECT（A1 CLOB）; CREATE TABLE lob_long_tab（C1 CLOB，C2 CLOB，CT3 lob_typ，L LONG）;</pre><div class="example" id="GUID-5741DA96-8C5F-45F3-B161-DAB2E51E142E__CIHBCIAD">
                              <p class="titleinexample">例7-5允许：插入C1，C2和L列最多分别为8000,8000和2000字节大小的可变数据值</p><pre class="oac_no_warn" dir="ltr">void insert（）/ * OCI程序中的函数* / {/ *允许以下内容* / ub1 buffer [8000]; text * insert_sql =（text *）“INSERT INTO lob_long_tab（C1，C2，L）\ VALUES（：1，：2，：3）”; OCIStmtPrepare（stmthp，errhp，insert_sql，strlen（（char *）insert_sql），（ub4）OCI_NTV_SYNTAX，（ub4）OCI_DEFAULT）; OCIBindByPos（stmthp，＆bindhp [0]，errhp，1，（void *）buffer，8000，SQLT_LNG，0,0,0,0，（ub4）OCI_DEFAULT）; OCIBindByPos（stmthp，＆bindhp [1]，errhp，2，（void *）buffer，8000，SQLT_LNG，0,0,0,0,0，（ub4）OCI_DEFAULT）; OCIBindByPos（stmthp，＆bindhp [2]，errhp，3，（void *）buffer，2000，SQLT_LNG，0,0,0,0,0，（ub4）OCI_DEFAULT）; OCIStmtExecute（svchp，stmthp，errhp，1,0，（OCISnapshot *）NULL，（OCISnapshot *）NULL，OCI_DEFAULT）; }</pre></div>
                           <!-- class="example" -->
                           <div class="example" id="GUID-5741DA96-8C5F-45F3-B161-DAB2E51E142E__GUID-6EF37483-CC42-49AF-8056-AE7A63520B03">
                              <p class="titleinexample">例7-6允许：分别插入C1和L列，最多分别为2000和8000字节的绑定变量数据值</p><pre class="oac_no_warn" dir="ltr">void insert（）{/ *允许以下内容* / ub1 buffer [8000]; text * insert_sql =（text *）“INSERT INTO lob_long_tab（C1，L）\ VALUES（：1，：2）”; OCIStmtPrepare（stmthp，errhp，insert_sql，strlen（（char *）insert_sql），（ub4）OCI_NTV_SYNTAX，（ub4）OCI_DEFAULT）; OCIBindByPos（stmthp，＆bindhp [0]，errhp，1，（void *）buffer，2000，SQLT_LNG，0,0,0,0,0（ub4）OCI_DEFAULT）; OCIBindByPos（stmthp，＆bindhp [1]，errhp，2，（void *）buffer，8000，SQLT_LNG，0,0,0,0,0，（ub4）OCI_DEFAULT）; OCIStmtExecute（svchp，stmthp，errhp，1,0，（OCISnapshot *）NULL，（OCISnapshot *）NULL，OCI_DEFAULT）; }</pre></div>
                           <!-- class="example" -->
                           <div class="example" id="GUID-5741DA96-8C5F-45F3-B161-DAB2E51E142E__GUID-9AF198E8-37AE-420B-89CF-24548C09DA2F">
                              <p class="titleinexample">示例7-7允许：分别更新C1，C2和L列，最多分别为8000,8000和2000字节的绑定变量数据值</p><pre class="oac_no_warn" dir="ltr">void update（）{/ *以下是允许的，无论它更新多少行* / ub1 buffer [8000]; text * update_sql =（text *）“UPDATE lob_long_tab SET \ C1 =：1，C2 =：2，L =：3”; OCIStmtPrepare（stmthp，errhp，update_sql，strlen（（char *）update_sql），（ub4）OCI_NTV_SYNTAX，（ub4）OCI_DEFAULT）; OCIBindByPos（stmthp，＆bindhp [0]，errhp，1，（void *）buffer，8000，SQLT_LNG，0,0,0,0，（ub4）OCI_DEFAULT）; OCIBindByPos（stmthp，＆bindhp [1]，errhp，2，（void *）buffer，8000，SQLT_LNG，0,0,0,0,0，（ub4）OCI_DEFAULT）; OCIBindByPos（stmthp，＆bindhp [2]，errhp，3，（void *）buffer，2000，SQLT_LNG，0,0,0,0,0，（ub4）OCI_DEFAULT）; OCIStmtExecute（svchp，stmthp，errhp，1,0，（OCISnapshot *）NULL，（OCISnapshot *）NULL，OCI_DEFAULT）; }</pre></div>
                           <!-- class="example" -->
                           <div class="example" id="GUID-5741DA96-8C5F-45F3-B161-DAB2E51E142E__GUID-CEB318B5-9F81-4351-AF6E-5D14CABFC1F0">
                              <p class="titleinexample">示例7-8允许：分别更新C1，C2和L列，最多分别为2000,2000和8000字节的绑定变量数据值</p><pre class="oac_no_warn" dir="ltr">void update（）{/ *以下是允许的，无论它更新多少行* / ub1 buffer [8000]; text * update_sql =（text *）“UPDATE lob_long_tab SET \ C1 =：1，C2 =：2，L =：3”; OCIStmtPrepare（stmthp，errhp，update_sql，strlen（（char *）update_sql），（ub4）OCI_NTV_SYNTAX，（ub4）OCI_DEFAULT）; OCIBindByPos（stmthp，＆bindhp [0]，errhp，1，（void *）buffer，2000，SQLT_LNG，0,0,0,0,0（ub4）OCI_DEFAULT）; OCIBindByPos（stmthp，＆bindhp [1]，errhp，2，（void *）buffer，2000，SQLT_LNG，0,0,0,0,0（ub4）OCI_DEFAULT）; OCIBindByPos（stmthp，＆bindhp [2]，errhp，3，（void *）buffer，8000，SQLT_LNG，0,0,0,0，（ub4）OCI_DEFAULT）; OCIStmtExecute（svchp，stmthp，errhp，1,0，（OCISnapshot *）NULL，（OCISnapshot *）NULL，OCI_DEFAULT）; }</pre></div>
                           <!-- class="example" -->
                           <div class="example" id="GUID-5741DA96-8C5F-45F3-B161-DAB2E51E142E__GUID-853ABC7F-C033-49B2-B488-615E66FB8C25">
                              <p class="titleinexample">示例7-9允许：分段，回调和数组插入或更新操作</p><pre class="oac_no_warn" dir="ltr">void insert（）{/ *分段，回调和数组插入/更新操作类似于*允许的常规插入/更新操作也是允许的* /}</pre></div>
                           <!-- class="example" -->
                           <div class="example" id="GUID-5741DA96-8C5F-45F3-B161-DAB2E51E142E__GUID-DF8C7133-20E7-44C6-8F4A-F2DD81291B45">
                              <p class="titleinexample">示例7-10不允许：使用相同的INSERT语句在LOB和LONG列中插入超过4000个字节</p><pre class="oac_no_warn" dir="ltr">void insert（）{/ *以下是不允许的，因为你不能在LOB和LONG列中插入&gt; 4000字节* * / ub1 buffer [8000]; text * insert_sql =（text *）“INSERT INTO lob_long_tab（C1，L）\ VALUES（：1，：2）”; OCIStmtPrepare（stmthp，errhp，insert_sql，strlen（（char *）insert_sql），（ub4）OCI_NTV_SYNTAX，（ub4）OCI_DEFAULT）; OCIBindByPos（stmthp，＆bindhp [0]，errhp，1，（void *）buffer，8000，SQLT_LNG，0,0,0,0，（ub4）OCI_DEFAULT）; OCIBindByPos（stmthp，＆bindhp [1]，errhp，2，（void *）buffer，8000，SQLT_LNG，0,0,0,0,0，（ub4）OCI_DEFAULT）; OCIStmtExecute（svchp，stmthp，errhp，1,0，（OCISnapshot *）NULL，（OCISnapshot *）NULL，OCI_DEFAULT）; }</pre></div>
                           <!-- class="example" -->
                           <div class="example" id="GUID-5741DA96-8C5F-45F3-B161-DAB2E51E142E__GUID-FC7D7664-AB43-485E-A2C4-A3E1A7CFA69F">
                              <p class="titleinexample">例7-11允许：插入CT3 LOB列，最多2000个字节大小的绑定变量数据值</p><pre class="oac_no_warn" dir="ltr">void insert（）{/ *允许将数据插入LOB属性* / ub1 buffer [8000]; text * insert_sql =（text *）“INSERT INTO lob_long_tab（CT3）\ VALUES（lob_typ（：1））”; OCIStmtPrepare（stmthp，errhp，insert_sql，strlen（（char *）insert_sql），（ub4）OCI_NTV_SYNTAX，（ub4）OCI_DEFAULT）; OCIBindByPos（stmthp，＆bindhp [0]，errhp，1，（void *）buffer，2000，SQLT_LNG，0,0,0,0,0（ub4）OCI_DEFAULT）; OCIStmtExecute（svchp，stmthp，errhp，1,0，（OCISnapshot *）NULL，（OCISnapshot *）NULL，OCI_DEFAULT）; }</pre></div>
                           <!-- class="example" -->
                           <div class="example" id="GUID-5741DA96-8C5F-45F3-B161-DAB2E51E142E__CIHGHACA">
                              <p class="titleinexample">示例7-12不允许：将任何长度数据绑定到作为选择操作的插入中的LOB列</p><pre class="oac_no_warn" dir="ltr">void insert（）{/ *以下是不允许的，因为你不能将* select字符数据插入LOB列* / ub1 buffer [8000]; text * insert_sql =（text *）“INSOO INTO lob_long_tab（C1）SELECT \：1来自FOO”; OCIStmtPrepare（stmthp，errhp，insert_sql，strlen（（char *）insert_sql），（ub4）OCI_NTV_SYNTAX，（ub4）OCI_DEFAULT）; OCIBindByPos（stmthp，＆bindhp [0]，errhp，1，（void *）buffer，8000，SQLT_LNG，0,0,0,0，（ub4）OCI_DEFAULT）; OCIStmtExecute（svchp，stmthp，errhp，1,0，（OCISnapshot *）NULL，（OCISnapshot *）NULL，OCI_DEFAULT）; }</pre></div>
                           <!-- class="example" -->
                        </div>
                     </div>
                  </div>
               </div><a id="LNOCI16382"></a><div class="props_rev_3"><a id="GUID-D9A7AC35-9CE8-4B1F-9F4C-B9BE064EAD69" name="GUID-D9A7AC35-9CE8-4B1F-9F4C-B9BE064EAD69"></a><h4 id="LNOCI-GUID-D9A7AC35-9CE8-4B1F-9F4C-B9BE064EAD69" class="sect4"><span class="enumeration_section">7.2.2</span>关于OCI_DATA_AT_EXEC模式下的绑定</h4>
                  <div>
                     <p>如果对<code class="codeph">OCIBindByName()</code>或<code class="codeph">OCIBindByName2()</code>或<code class="codeph">OCIBindByPos()</code>或<code class="codeph">OCIBindByPos2()</code>的调用中的<code class="codeph">mode</code>参数设置为<code class="codeph">OCI_DATA_AT_EXEC</code> ，则如果应用程序使用回调方法在运行时提供数据，则需要额外调用<code class="codeph">OCIBindDynamic()</code> 。
                     </p>
                     <p>如有必要，对<code class="codeph">OCIBindDynamic()</code>的调用将设置回调例程，以指示所提供的数据或片段。如果选择了<code class="codeph">OCI_DATA_AT_EXEC</code>模式，但使用标准OCI分段轮询方法而不是回调，则<code class="codeph">OCIBindDynamic()</code>调用<code class="codeph">OCIBindDynamic()</code> 。
                     </p>
                     <p>绑定<code class="codeph">RETURN</code>子句变量时，应用程序必须使用<code class="codeph">OCI_DATA_AT_EXEC</code>模式，并且必须提供回调。
                     </p>
                     <div class="infoboxnotealso" id="GUID-D9A7AC35-9CE8-4B1F-9F4C-B9BE064EAD69__GUID-0D780161-95A2-4D1B-AF70-B7347919CA42">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="binding-and-defining-in-oci.html#GUID-6C5EA0C6-0C1D-4CD5-B47F-1B95B4E9C558" title="您可以使用OCI执行分段插入，更新和数据提取。">OCI中的运行时数据分配和分段操作，</a>以获取有关分段操作的更多信息</p>
                           </li>
                           <li>
                              <p><a href="bind-define-describe-functions.html#GUID-CD63DF78-2178-4727-A896-B9673C4A37F0" title="在SQL语句或PL / SQL块中创建程序变量和占位符之间的关联。">OCIBindByName（）</a>或<a href="bind-define-describe-functions.html#GUID-55C47708-5468-4106-89BE-1AB60861D037" title="在SQL语句或PL / SQL块中创建程序变量和占位符之间的关联。当客户端上的实际长度超过UB2MAXVAL时，在处理数据类型时使用此函数。">OCIBindByName2（）</a></p>
                           </li>
                           <li>
                              <p><a href="bind-define-describe-functions.html#GUID-D28DF5A7-3C75-4E52-82F7-A5D6D5714E69" title="在SQL语句或PL / SQL块中创建程序变量和占位符之间的关联。">OCIBindByPos（）</a>或<a href="bind-define-describe-functions.html#GUID-5C505821-323D-473D-825B-448C8D9A6702" title="在SQL语句或PL / SQL块中创建程序变量和占位符之间的关联。当客户端上的实际长度超过UB2MAXVAL时，在处理数据类型时使用此调用。">OCIBindByPos2（）</a></p>
                           </li>
                           <li>
                              <p><a href="bind-define-describe-functions.html#GUID-030270CB-346A-412E-B3B3-556DD6947BE2" title="注册用户回调以进行动态数据分配。">OCIBindDynamic（）</a></p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="LNOCI16383"></a><div class="props_rev_3"><a id="GUID-983E7E07-7941-4A8E-A046-2F5A6A50C0E1" name="GUID-983E7E07-7941-4A8E-A046-2F5A6A50C0E1"></a><h4 id="LNOCI-GUID-983E7E07-7941-4A8E-A046-2F5A6A50C0E1" class="sect4"><span class="enumeration_section">7.2.3</span>关于绑定REF CURSOR变量</h4>
                  <div>
                     <p><code class="codeph">REF CURSOR</code>绑定到绑定数据类型为<code class="codeph">SQLT_RSET</code>的语句句柄。</p>
                     <p></p>
                     <div class="infoboxnotealso" id="GUID-983E7E07-7941-4A8E-A046-2F5A6A50C0E1__GUID-158A0315-671A-4DE3-A059-B58EB9B7E346">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="binding-and-defining-in-oci.html#GUID-5495CEEB-17D0-4185-8879-3356A21E7888" title="OCI提供绑定和定义PL / SQL REF CURSOR和嵌套表的功能。">OCI中的PL / SQL REF CURSOR和嵌套表</a></p>
                     </div>
                  </div>
               </div>
            </div><a id="LNOCI16384"></a><div class="props_rev_3"><a id="GUID-8A09BC68-4C3D-4977-86C9-134F73121E26" name="GUID-8A09BC68-4C3D-4977-86C9-134F73121E26"></a><h3 id="LNOCI-GUID-8A09BC68-4C3D-4977-86C9-134F73121E26" class="sect3"><span class="enumeration_section">7.3</span> OCI定义概述</h3>
               <div>
                  <p>Query语句将数据从数据库返回给您的应用程序。</p>
                  <p>处理查询时，必须为选择列表中的每个项目定义输出变量或输出变量数组，以便检索数据。define步骤创建一个关联，用于确定返回结果的存储位置以及格式。</p>
                  <p>例如，如果您的程序处理以下语句，那么您通常会定义两个输出变量：一个用于接收从<code class="codeph">name</code>列返回的值，另一个用于接收从<code class="codeph">ssn</code>列返回的值：</p><pre class="oac_no_warn" dir="ltr">SELECT name，ssn FROM employees WHERE empno =：empnum</pre><p>如果您只对从<code class="codeph">name</code>列中检索值感兴趣，则不需要为<code class="codeph">ssn</code>定义输出变量。如果正在处理的<code class="codeph">SELECT</code>语句为查询返回的行不止一行，则您定义的输出变量可以是数组而不是标量值。
                  </p>
                  <p>根据应用程序，定义步骤可以在执行操作之前或之后进行。如果在编译时知道select-list项的数据类型，则可以在执行语句之前进行定义。如果您的应用程序正在处理您在运行时输入的动态SQL语句或没有明确定义的选择列表的语句，则应用程序必须执行该语句以检索描述信息。在检索描述信息之后，每个选择列表项的类型信息可用于定义输出变量。</p>
                  <p>OCI在客户端本地处理定义调用。除了指示应存储结果的缓冲区的位置之外，define步骤还确定将数据返回到应用程序时必须进行的数据转换。</p>
                  <div class="infoboxnote" id="GUID-8A09BC68-4C3D-4977-86C9-134F73121E26__GUID-80848218-4F4E-4596-89A3-BBCD2B91F002">
                     <p class="notep1">注意：</p>
                     <p>输出缓冲区必须是2字节对齐的。</p>
                  </div>
                  <p><code class="codeph">OCIDefineByPos()</code>或<code class="codeph">OCIDefineByPos2()</code>调用的<code class="codeph">dty</code>参数指定输出变量的数据类型。当数据被提取到输出变量中时，OCI可以执行各种数据转换。例如，Oracle <code class="codeph">DATE</code>格式的内部数据可以在输出时自动转换为<code class="codeph">String</code>数据类型。
                  </p>
                  <p>本节包括以下主题： <a href="binding-and-defining-in-oci.html#GUID-E965AB3C-003F-45CD-82FA-586BBB4082A4" title="使用位置调用OCIDefineByPos（）或OCIDefineByPos2（）完成基本定义。">OCI定义中使用的步骤</a></p>
                  <div class="infoboxnotealso" id="GUID-8A09BC68-4C3D-4977-86C9-134F73121E26__GUID-2E5C9E8C-C37B-4FBF-9519-2A33A5805DD5">
                     <p class="notep1">也可以看看：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="data-types.html#GUID-027FB2E2-593C-43F1-9184-DFEF7A984A27" title="本章提供OCI应用程序使用的Oracle外部数据类型的参考。">数据类型</a> ，以获取有关数据类型和转换的更多信息</p>
                        </li>
                        <li>
                           <p><a href="using-sql_statements-in-oci.html#GUID-DDB109DD-52EB-4AA8-A69A-34015F8D5D6E" title="如果您的OCI应用程序正在处理查询，您可能需要获取有关选择列表中的项目的更多信息。">关于描述选择列表项</a></p>
                        </li>
                        <li>
                           <p><a href="bind-define-describe-functions.html#GUID-CFE5AA54-DEBC-42D3-8A27-AFF1E7815691" title="将选择列表中的项与类型和输出数据缓冲区相关联。">OCIDefineByPos（）</a>或<a href="bind-define-describe-functions.html#GUID-74939FB5-919E-4D24-B327-AFB532435061" title="将选择列表中的项与类型和输出数据缓冲区相关联。当客户端上的实际长度超过UB2MAXVAL时，在处理数据类型时使用此调用。">OCIDefineByPos2（）</a></p>
                        </li>
                     </ul>
                  </div>
               </div><a id="LNOCI72616"></a><a id="LNOCI16385"></a><div class="props_rev_3"><a id="GUID-E965AB3C-003F-45CD-82FA-586BBB4082A4" name="GUID-E965AB3C-003F-45CD-82FA-586BBB4082A4"></a><h4 id="LNOCI-GUID-E965AB3C-003F-45CD-82FA-586BBB4082A4" class="sect4"><span class="enumeration_section">7.3.1</span> OCI定义中使用的步骤</h4>
                  <div>
                     <p>使用位置调用<code class="codeph">OCIDefineByPos()</code>或<code class="codeph">OCIDefineByPos2()</code>完成基本定义。
                     </p>
                     <p>此步骤在选择列表项和输出变量之间创建关联。某些数据类型或获取模式可能需要额外的定义调用。完成定义步骤后，OCI库将确定将检索到的数据放在何处。您可以再次进行定义调用以重新定义输出变量，而无需重新定义或重新执行SQL语句。</p>
                     <p><a href="binding-and-defining-in-oci.html#GUID-E965AB3C-003F-45CD-82FA-586BBB4082A4__CIHBDHGI">例7-13</a>显示了在执行和描述操作之后定义的标量输出变量。
                     </p>
                     <div class="infoboxnotealso" id="GUID-E965AB3C-003F-45CD-82FA-586BBB4082A4__GUID-ECFDC102-889C-4296-9099-03DDE69292CF">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="using-sql_statements-in-oci.html#GUID-DDB109DD-52EB-4AA8-A69A-34015F8D5D6E" title="如果您的OCI应用程序正在处理查询，您可能需要获取有关选择列表中的项目的更多信息。">关于描述选择列表项</a>以获得描述步骤的说明</p>
                           </li>
                           <li>
                              <p><a href="bind-define-describe-functions.html#GUID-CFE5AA54-DEBC-42D3-8A27-AFF1E7815691" title="将选择列表中的项与类型和输出数据缓冲区相关联。">OCIDefineByPos（）</a>或<a href="bind-define-describe-functions.html#GUID-74939FB5-919E-4D24-B327-AFB532435061" title="将选择列表中的项与类型和输出数据缓冲区相关联。当客户端上的实际长度超过UB2MAXVAL时，在处理数据类型时使用此调用。">OCIDefineByPos2（）</a></p>
                           </li>
                        </ul>
                     </div>
                     <div class="example" id="GUID-E965AB3C-003F-45CD-82FA-586BBB4082A4__CIHBDHGI">
                        <p class="titleinexample">例7-13在执行和描述操作后定义标量输出变量</p><pre class="oac_no_warn" dir="ltr">SELECT department_name FROM departments WHERE department_id =：dept_input / *输入占位符之前已绑定，数据来自* / printf（“输入员工部门：”）下面的用户输入; scanf（“％d”，＆deptno）; / *执行语句。如果OCIStmtExecute（）返回OCI_NO_DATA，意味着没有数据与查询匹配，则部门编号无效。* / if（（status = OCIStmtExecute（svchp，stmthp，errhp，0,0，（OCISnapshot *）0，（OCISnapshot *）0，OCI_DEFAULT））&amp;&amp;（状态！= OCI_NO_DATA））{checkerr（errhp，status）;返回OCI_ERROR; } if（status == OCI_NO_DATA）{printf（“您输入的部门不存在。\ n”）;返回0;接下来的两个语句描述了select-list项，dname，并返回它的长度* / checkerr（errhp，OCIParamGet（（void *）stmthp，（ub4）OCI_HTYPE_STMT，errhp，（void **）＆parmdp，（ub4） ）1））; checkerr（errhp，OCIAttrGet（（void *）parmdp，（ub4）OCI_DTYPE_PARAM，（void *）＆deptlen，（ub4 *）＆sizelen，（ub4）OCI_ATTR_DATA_SIZE，（OCIError *）errhp））; / *使用检索到的dname长度来分配输出缓冲区，然后定义输出变量。如果define调用返回错误，则退出应用程序* / dept =（text *）malloc（（int）deptlen + 1）; if（status = OCIDefineByPos（stmthp，＆defnp，errhp，1，（void *）dept，（sb4）deptlen + 1，SQLT_STR，（void *）0，（ub2 *）0，（ub2 *）0，OCI_DEFAULT）） {checkerr（errhp，status）;返回OCI_ERROR; }</pre></div>
                     <!-- class="example" -->
                  </div>
               </div>
            </div><a id="LNOCI16387"></a><div class="props_rev_3"><a id="GUID-237FC150-290A-42B8-99CB-2C6AFA5B9F9E" name="GUID-237FC150-290A-42B8-99CB-2C6AFA5B9F9E"></a><h3 id="LNOCI-GUID-237FC150-290A-42B8-99CB-2C6AFA5B9F9E" class="sect3"><span class="enumeration_section">7.4</span> OCI中的高级定义操作</h3>
               <div>
                  <p>本节介绍高级定义操作，包括命名数据类型和<code class="codeph">REF</code>的多步定义和定义。
                  </p>
                  <p>在某些情况下，定义步骤需要额外的调用，而不仅仅是调用<code class="codeph">OCIDefineByPos()</code>或<code class="codeph">OCIDefineByPos2()</code> ;例如，定义数组提取， <code class="codeph">OCIDefineArrayOfStruct()</code>或命名数据类型提取， <code class="codeph">OCIDefineObject()</code> 。例如，要使用一列命名数据类型获取多个行，必须为该列调用所有三个调用。要仅获取多行标量列， <code class="codeph">OCIDefineArrayOfStruct()</code>和<code class="codeph">OCIDefineByPos()</code>或<code class="codeph">OCIDefineByPos2()</code>就足够了。
                  </p>
                  <p>Oracle数据库还提供映射对象类型属性的预定义C数据类型。</p>
                  <div class="p">本节包括以下主题：<ul style="list-style-type:disc">
                        <li>
                           <p><a href="binding-and-defining-in-oci.html#GUID-16652266-2A22-43AB-8BA3-9868CCEC9271">关于定义LOB输出变量</a></p>
                        </li>
                        <li>
                           <p><a href="binding-and-defining-in-oci.html#GUID-B5890EB7-4E83-45EE-A38E-C592A46FFB79" title="不要使用define调用为PL / SQL块内的SQL SELECT语句中的select-list项定义输出变量。">关于定义PL / SQL输出变量</a></p>
                        </li>
                        <li>
                           <p><a href="binding-and-defining-in-oci.html#GUID-D667D691-52A2-457F-972C-1E659DFB6901" title="分段提取需要初始调用OCIDefineByPos（）或OCIDefineByPos2（）。">关于定义分段提取</a></p>
                        </li>
                     </ul>
                  </div>
                  <div class="infoboxnotealso" id="GUID-237FC150-290A-42B8-99CB-2C6AFA5B9F9E__GUID-48388339-4EF3-47B1-A7E4-26399617DAD5">
                     <p class="notep1">也可以看看：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="object-relational-data-types-in-oci.html#GUID-C62AEE74-0CC5-4FAB-A91F-997F71C49C2C" title="本章描述了可由OCI数据类型映射和操作函数操作的每种数据类型的用途和结构。">OCI中的对象关系数据类型</a></p>
                        </li>
                        <li>
                           <p><a href="binding-and-defining-in-oci.html#GUID-237FC150-290A-42B8-99CB-2C6AFA5B9F9E" title="本节介绍高级定义操作，包括命名数据类型和REF的多步定义和定义。">OCI中的高级定义操作</a></p>
                        </li>
                        <li>
                           <p><a href="bind-define-describe-functions.html#GUID-CFE5AA54-DEBC-42D3-8A27-AFF1E7815691" title="将选择列表中的项与类型和输出数据缓冲区相关联。">OCIDefineByPos（）</a>或<a href="bind-define-describe-functions.html#GUID-74939FB5-919E-4D24-B327-AFB532435061" title="将选择列表中的项与类型和输出数据缓冲区相关联。当客户端上的实际长度超过UB2MAXVAL时，在处理数据类型时使用此调用。">OCIDefineByPos2（）</a></p>
                        </li>
                        <li>
                           <p><a href="bind-define-describe-functions.html#GUID-D3F74828-5DA7-48AD-A170-120AD547DEB3" title="指定静态数组定义所需的其他属性，用于结构数组（多行，多列）提取。">OCIDefineArrayOfStruct（）</a></p>
                        </li>
                        <li>
                           <p><a href="bind-define-describe-functions.html#GUID-F211198D-C88C-493B-A65E-2C2A95E6197B" title="设置命名数据类型或REF定义所需的其他属性。">OCIDefineObject（）</a></p>
                        </li>
                     </ul>
                  </div>
               </div><a id="LNOCI16388"></a><div class="props_rev_3"><a id="GUID-16652266-2A22-43AB-8BA3-9868CCEC9271" name="GUID-16652266-2A22-43AB-8BA3-9868CCEC9271"></a><h4 id="LNOCI-GUID-16652266-2A22-43AB-8BA3-9868CCEC9271" class="sect4"><span class="enumeration_section">7.4.1</span>关于定义LOB输出变量</h4>
                  <div>
                     <p>有两种定义LOB的方法：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>定义LOB定位器，而不是实际的LOB值。在这种情况下，通过将LOB定位符传递给OCI LOB函数来写入或读取LOB值。</p>
                        </li>
                        <li>
                           <p>直接定义LOB值，而不使用LOB定位器。</p>
                        </li>
                     </ul>
                     <div class="p">本节包括以下主题：<ul style="list-style-type:disc">
                           <li>
                              <p><a href="binding-and-defining-in-oci.html#GUID-BAF35569-CC0C-45E4-BB43-4E33BA85086C">关于定义LOB定位器</a></p>
                           </li>
                           <li>
                              <p><a href="binding-and-defining-in-oci.html#GUID-FE7DB3D8-9310-41ED-8869-B5106E60D29E">关于定义LOB数据</a></p>
                           </li>
                        </ul>
                     </div>
                  </div><a id="LNOCI16389"></a><div class="props_rev_3"><a id="GUID-BAF35569-CC0C-45E4-BB43-4E33BA85086C" name="GUID-BAF35569-CC0C-45E4-BB43-4E33BA85086C"></a><h5 id="LNOCI-GUID-BAF35569-CC0C-45E4-BB43-4E33BA85086C" class="sect5"><span class="enumeration_section">7.4.1.1</span>关于定义LOB定位器</h5>
                     <div>
                        <p>可以在单个定义调用中定义单个定位器或定位器数组。在每种情况下，应用程序必须通过<span class="italic"> </span> LOB定位器的地址，而不是定位器本身的地址。例如，假设应用程序已准备好以下SQL语句：</p><pre class="oac_no_warn" dir="ltr">SELECT lob1 FROM some_table;</pre><p>在此声明， <code class="codeph">lob1</code>是LOB列，和<code class="codeph">one_lob</code>是一个限定可变对应于与以下声明LOB列：</p><pre class="oac_no_warn" dir="ltr">OCILobLocator * one_lob;</pre><p>然后，以下调用将用于绑定占位符并执行语句：</p><pre class="oac_no_warn" dir="ltr">/ *初始化单个定位器* / OCIDescriptorAlloc（...＆one_lob，OCI_DTYPE_LOB ...）; .../ *传递定位器的地址* / OCIBindByName（...，（void *）＆one_lob，...SQLT_CLOB，...）; OCIStmtExecute（...，1，...）; / * 1是iters参数* /</pre><p>您还可以使用相同的SQL <code class="codeph">SELECT</code>语句插入数组。在这种情况下，应用程序将包含以下代码：</p><pre class="oac_no_warn" dir="ltr">OCILobLocator * lob_array [10]; ...for（i = 0; i &lt;10，i ++）OCIDescriptorAlloc（...＆lob_array [i]，OCI_DTYPE_LOB ...）; / *初始化定位器数组* / ...OCIBindByName（...，（void *）lob_array，...）; OCIStmtExecute（...，10，...）; / * 10是iters参数* /</pre><p>请注意，必须先使用<code class="codeph">OCIDescriptorAlloc()</code>函数分配描述符，然后才能使用它们。在定位器数组中，必须使用<code class="codeph">OCIDescriptorAlloc()</code>初始化每个数组元素。在分配<code class="codeph">BLOB</code> ， <code class="codeph">CLOB</code>和<code class="codeph">NCLOB</code>时，使用<code class="codeph">OCI_DTYPE_LOB</code>作为<code class="codeph">type</code>参数。分配<code class="codeph">BFILE</code>时使用<code class="codeph">OCI_DTYPE_FILE</code> 。
                        </p>
                     </div>
                  </div><a id="LNOCI72617"></a><a id="LNOCI72618"></a><a id="LNOCI16390"></a><div class="props_rev_3"><a id="GUID-FE7DB3D8-9310-41ED-8869-B5106E60D29E" name="GUID-FE7DB3D8-9310-41ED-8869-B5106E60D29E"></a><h5 id="LNOCI-GUID-FE7DB3D8-9310-41ED-8869-B5106E60D29E" class="sect5"><span class="enumeration_section">7.4.1.2</span>关于定义LOB数据</h5>
                     <div>
                        <p>Oracle数据库允许任何大小LOB的<code class="codeph">SELECT</code>的非零定义。因此，您可以使用<a href="bind-define-describe-functions.html#GUID-CFE5AA54-DEBC-42D3-8A27-AFF1E7815691" title="将选择列表中的项与类型和输出数据缓冲区相关联。">OCIDefineByPos（）</a>和PL / SQL定义从LOB列中选择最大允许的数据大小。因为一行中可以有多个LOB，所以可以在同一<code class="codeph">SELECT</code>语句中从每个LOB中选择最大数据大小。
                        </p>
                        <p>以下SQL语句是<a href="binding-and-defining-in-oci.html#GUID-FE7DB3D8-9310-41ED-8869-B5106E60D29E__CIHCFDCF">Example 7-14</a>和<a href="binding-and-defining-in-oci.html#GUID-FE7DB3D8-9310-41ED-8869-B5106E60D29E__CIHCGDAE">Example 7-15</a>的基础：</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE lob_tab（C1 CLOB，C2 CLOB）;</pre><div class="example" id="GUID-FE7DB3D8-9310-41ED-8869-B5106E60D29E__CIHCFDCF">
                           <p class="titleinexample">示例7-14执行前定义LOB</p><pre class="oac_no_warn" dir="ltr">void select_define_before_execute（）/ * OCI程序中的函数* / {/ *允许以下内容* / ub1 buffer1 [8000]; ub1 buffer2 [8000]; text * select_sql =（text *）“SELECT c1，c2 FROM lob_tab”; OCIStmtPrepare（stmthp，errhp，select_sql，（ub4）strlen（（char *）select_sql），（ub4）OCI_NTV_SYNTAX，（ub4）OCI_DEFAULT）; OCIDefineByPos（stmthp，＆defhp [0]，errhp，1，（void *）buffer1,8000，SQLT_LNG，（void *）0，（ub2 *）0，（ub2 *）0，（ub4）OCI_DEFAULT）; OCIDefineByPos（stmthp，＆defhp [1]，errhp，2，（void *）buffer2,8000，SQLT_LNG，（void *）0，（ub2 *）0，（ub2 *）0，（ub4）OCI_DEFAULT）; OCIStmtExecute（svchp，stmthp，errhp，1,0，（OCISnapshot *）0，（OCISnapshot *）0，OCI_DEFAULT）; }</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-FE7DB3D8-9310-41ED-8869-B5106E60D29E__CIHCGDAE">
                           <p class="titleinexample">例7-15执行后定义LOB</p><pre class="oac_no_warn" dir="ltr">void select_execute_before_define（）{/ *允许以下内容* / ub1 buffer1 [8000]; ub1 buffer2 [8000]; text * select_sql =（text *）“SELECT c1，c2 FROM lob_tab”; OCIStmtPrepare（stmthp，errhp，select_sql，（ub4）strlen（（char *）select_sql），（ub4）OCI_NTV_SYNTAX，（ub4）OCI_DEFAULT）; OCIStmtExecute（svchp，stmthp，errhp，0,0，（OCISnapshot *）0，（OCISnapshot *）0，OCI_DEFAULT）; OCIDefineByPos（stmthp，＆defhp [0]，errhp，1，（void *）buffer1,8000，SQLT_LNG，（void *）0，（ub2 *）0，（ub2 *）0，（ub4）OCI_DEFAULT）; OCIDefineByPos（stmthp，＆defhp [1]，errhp，2，（void *）buffer2,8000，SQLT_LNG，（void *）0，（ub2 *）0，（ub2 *）0，（ub4）OCI_DEFAULT）; OCIStmtFetch（stmthp，errhp，1，OCI_FETCH_NEXT，OCI_DEFAULT）; }</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div>
               </div><a id="LNOCI16393"></a><div class="props_rev_3"><a id="GUID-B5890EB7-4E83-45EE-A38E-C592A46FFB79" name="GUID-B5890EB7-4E83-45EE-A38E-C592A46FFB79"></a><h4 id="LNOCI-GUID-B5890EB7-4E83-45EE-A38E-C592A46FFB79" class="sect4"><span class="enumeration_section">7.4.2</span>关于定义PL / SQL输出变量</h4>
                  <div>
                     <p>不要使用define调用为PL / SQL块内的SQL <code class="codeph">SELECT</code>语句中的select-list项定义输出变量。
                     </p>
                     <p>请改用OCI绑定调用。</p>
                     <div class="infoboxnotealso" id="GUID-B5890EB7-4E83-45EE-A38E-C592A46FFB79__GUID-C2923694-5664-43C3-BBC5-F2024C27518D">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="object-relational-data-types-in-oci.html#GUID-1E2056EF-32BE-4875-9211-C2D4BB535D11" title="Consider the following important information as you work with named data type and REF defines. It includes pointers about memory allocation and indicator variable usage.">有关命名数据类型和REF定义的信息，以及PL / SQL OUT</a>有关定义PL / SQL输出变量的更多信息，请进行<a href="object-relational-data-types-in-oci.html#GUID-1E2056EF-32BE-4875-9211-C2D4BB535D11" title="在使用命名数据类型和REF定义时，请考虑以下重要信息。它包括有关内存分配和指示符变量用法的指针。">绑定</a></p>
                     </div>
                  </div>
               </div><a id="LNOCI16394"></a><div class="props_rev_3"><a id="GUID-D667D691-52A2-457F-972C-1E659DFB6901" name="GUID-D667D691-52A2-457F-972C-1E659DFB6901"></a><h4 id="LNOCI-GUID-D667D691-52A2-457F-972C-1E659DFB6901" class="sect4"><span class="enumeration_section">7.4.3</span>关于定义分段提取</h4>
                  <div>
                     <p>分段提取需要初始调用<code class="codeph">OCIDefineByPos()</code>或<code class="codeph">OCIDefineByPos2()</code> 。
                     </p>
                     <p>如果应用程序使用回调而不是标准轮询机制，则需要额外调用<code class="codeph">OCIDefineDynamic()</code> 。
                     </p>
                     <div class="infoboxnotealso" id="GUID-D667D691-52A2-457F-972C-1E659DFB6901__GUID-711C77AA-3B44-485A-8CFD-BC4AA59B8F31">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="bind-define-describe-functions.html#GUID-CFE5AA54-DEBC-42D3-8A27-AFF1E7815691" title="将选择列表中的项与类型和输出数据缓冲区相关联。">OCIDefineByPos（）</a>或<a href="bind-define-describe-functions.html#GUID-74939FB5-919E-4D24-B327-AFB532435061" title="将选择列表中的项与类型和输出数据缓冲区相关联。当客户端上的实际长度超过UB2MAXVAL时，在处理数据类型时使用此调用。">OCIDefineByPos2（）</a></p>
                           </li>
                           <li>
                              <p><a href="bind-define-describe-functions.html#GUID-DD404526-9615-4E44-B790-1D17396C82A9" title="如果在OCIDefineByPos（）或OCIDefineByPos2（）中选择了OCI_DYNAMIC_FETCH模式，则设置所需的其他属性。">OCIDefineDynamic（）</a></p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div>
            </div><a id="LNOCI16395"></a><div class="props_rev_3"><a id="GUID-094F4767-1BE0-45AE-BA6C-3B114714F87A" name="GUID-094F4767-1BE0-45AE-BA6C-3B114714F87A"></a><h3 id="LNOCI-GUID-094F4767-1BE0-45AE-BA6C-3B114714F87A" class="sect3"><span class="enumeration_section">7.5</span>关于在OCI中绑定和定义结构数组</h3>
               <div>
                  <p>定义结构数组需要初始调用<code class="codeph">OCIDefineByPos()</code>或<code class="codeph">OCIDefineByPos2()</code> 。
                  </p>
                  <p>需要额外调用<code class="codeph">OCIDefineArrayOfStruct()</code>来设置每个附加参数，包括结构操作数组所需的<code class="codeph">skip</code>参数。
                  </p>
                  <p>使用结构数组可以简化多行，多列操作的处理。您可以创建相关标量数据项的结构，然后将数据库中的值提取到这些结构的数组中，或者从这些结构的数组中将值插入到数据库中。</p>
                  <p>例如，应用程序可能需要从<code class="codeph">NAME</code> ， <code class="codeph">AGE</code>和<code class="codeph">SALARY</code>列中获取多行数据。应用程序可以包含结构的定义，该结构包含单独的字段，用于保存数据库表中一行的<code class="codeph">NAME</code> ， <code class="codeph">AGE</code>和<code class="codeph">SALARY</code>数据。然后，应用程序将数据提取到这些结构的数组中。
                  </p>
                  <p>要使用结构数组执行多行，多列操作，请将操作中涉及的每个列与结构中的字段相关联。此关联是<code class="codeph">OCIDefineArrayOfStruct()</code>和<code class="codeph">OCIBindArrayOfStruct()</code>调用的一部分，用于指定数据的存储位置。
                  </p>
                  <div class="p">本节包括以下主题：<ul style="list-style-type:disc">
                        <li>
                           <p><a href="binding-and-defining-in-oci.html#GUID-5C52AF81-5D33-4C3F-BC89-0EFE9AC6E90A" title="在跨结构数组拆分列数据时，它不再连续存储在数据库中。">跳过参数</a></p>
                        </li>
                        <li>
                           <p><a href="binding-and-defining-in-oci.html#GUID-5BF33AD0-8AA9-4FFC-9721-2643EA24CC38" title="执行涉及结构数组的操作时必须使用哪些调用。">OCI调用与结构数组一起使用</a></p>
                        </li>
                        <li>
                           <p><a href="binding-and-defining-in-oci.html#GUID-5D597ED3-20FB-4092-BA99-6D43D459C34C" title="此外，结构数组的实现支持使用指示符变量和返回码。">结构和指标变量的数组</a></p>
                        </li>
                     </ul>
                  </div>
                  <div class="infoboxnotealso" id="GUID-094F4767-1BE0-45AE-BA6C-3B114714F87A__GUID-26FAB1B8-4E9A-4507-8152-92B5392B8C0D">
                     <p class="notep1">也可以看看：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="bind-define-describe-functions.html#GUID-CFE5AA54-DEBC-42D3-8A27-AFF1E7815691" title="将选择列表中的项与类型和输出数据缓冲区相关联。">OCIDefineByPos（）</a>或<a href="bind-define-describe-functions.html#GUID-74939FB5-919E-4D24-B327-AFB532435061" title="将选择列表中的项与类型和输出数据缓冲区相关联。当客户端上的实际长度超过UB2MAXVAL时，在处理数据类型时使用此调用。">OCIDefineByPos2（）</a></p>
                        </li>
                        <li>
                           <p><a href="bind-define-describe-functions.html#GUID-D3F74828-5DA7-48AD-A170-120AD547DEB3" title="指定静态数组定义所需的其他属性，用于结构数组（多行，多列）提取。">OCIDefineArrayOfStruct（）</a></p>
                        </li>
                        <li>
                           <p><a href="bind-define-describe-functions.html#GUID-E83BF668-88FC-4F31-A950-3580B79588E0" title="设置静态数组绑定的跳过参数。">OCIBindArrayOfStruct（）</a></p>
                        </li>
                     </ul>
                  </div>
               </div><a id="LNOCI16397"></a><a id="LNOCI16396"></a><div class="props_rev_3"><a id="GUID-5C52AF81-5D33-4C3F-BC89-0EFE9AC6E90A" name="GUID-5C52AF81-5D33-4C3F-BC89-0EFE9AC6E90A"></a><h4 id="LNOCI-GUID-5C52AF81-5D33-4C3F-BC89-0EFE9AC6E90A" class="sect4"><span class="enumeration_section">7.5.1</span>跳过参数</h4>
                  <div>
                     <p>在跨结构数组拆分列数据时，它不再连续存储在数据库中。</p>
                     <p>单个结构数组存储数据，好像它由几个标量数组组成。因此，您必须为要绑定或定义的每个字段指定skip参数。此跳过参数是在再次遇到相同字段之前必须在结构数组中跳过的字节数。通常，这相当于一个结构的字节大小。</p>
                     <p><a href="binding-and-defining-in-oci.html#GUID-5C52AF81-5D33-4C3F-BC89-0EFE9AC6E90A__I421954">图7-2</a>显示了如何确定跳过参数。在这种情况下，skip参数是字段<code class="codeph">field1</code> （2字节）， <code class="codeph">field2</code> （4字节）和<code class="codeph">field3</code> （2字节）的大小之和，即8字节。这等于一个结构的大小。
                     </p>
                     <div class="figure" id="GUID-5C52AF81-5D33-4C3F-BC89-0EFE9AC6E90A__I421954">
                        <p class="titleinfigure">图7-2确定跳过参数</p><img src="img/lnoci002.gif" alt="下面是图7-2的描述" title="下面是图7-2的描述" longdesc="img_text/lnoci002.html"><br><a href="img_text/lnoci002.html">“图7-2确定跳过参数”的说明</a></div>
                     <!-- class="figure" -->
                     <p>在某些操作系统上，可能需要将skip参数设置为<code class="codeph">sizeof</code> （ <code class="codeph">one_array_element</code> ）而不是<code class="codeph">sizeof</code> （ <code class="codeph">struct</code> ），因为某些编译器<code class="codeph">one_array_element</code>额外的字节插入到结构中。
                     </p>
                     <p>考虑一个由两个字段组成的C结构数组，一个<code class="codeph">ub4</code>和一个<code class="codeph">ub1</code> ：</p><pre class="oac_no_warn" dir="ltr">struct demo {ub4 field1; ub1 field2; }; struct demo demo_array [MAXSIZE];</pre><p>一些编译器在<code class="codeph">ub1</code>之后插入3个字节的填充，以便开始数组中下一个结构的<code class="codeph">ub4</code>正确对齐。在这种情况下，以下语句可能返回不正确的值：</p><pre class="oac_no_warn" dir="ltr">skip_parameter = sizeof（struct demo）;</pre><p>在某些操作系统上，这会生成一个正确的跳过参数8。在其他系统上， <code class="codeph">skip_parameter</code>由此语句设置为5个字节。在后一种情况下，使用以下语句获取skip参数的正确值：</p><pre class="oac_no_warn" dir="ltr">skip_parameter = sizeof（demo_array [0]）;</pre><p>本节包括以下主题： <a href="binding-and-defining-in-oci.html#GUID-DCC69B07-0EEC-4902-8321-4F402B806B47" title="结构数组是绑定和定义单个变量数组的扩展。">跳过标准数组的参数</a> 。
                     </p>
                  </div><a id="LNOCI16398"></a><div class="props_rev_3"><a id="GUID-DCC69B07-0EEC-4902-8321-4F402B806B47" name="GUID-DCC69B07-0EEC-4902-8321-4F402B806B47"></a><h5 id="LNOCI-GUID-DCC69B07-0EEC-4902-8321-4F402B806B47" class="sect5"><span class="enumeration_section">7.5.1.1</span>标准数组的跳过参数</h5>
                     <div>
                        <p>结构数组是绑定和定义单个变量数组的扩展。</p>
                        <p>指定单变量数组操作时，相关跳过等于所考虑的数组的数据类型的大小。例如，考虑一个声明如下的数组：</p><pre class="oac_no_warn" dir="ltr">text emp_names [4] [20];</pre><p>bind或define操作的skip参数是20。然后，将阵列中的每个数据元素识别为单独的单元，而不是结构的一部分。</p>
                     </div>
                  </div>
               </div><a id="LNOCI16399"></a><div class="props_rev_3"><a id="GUID-5BF33AD0-8AA9-4FFC-9721-2643EA24CC38" name="GUID-5BF33AD0-8AA9-4FFC-9721-2643EA24CC38"></a><h4 id="LNOCI-GUID-5BF33AD0-8AA9-4FFC-9721-2643EA24CC38" class="sect4"><span class="enumeration_section">7.5.2</span> OCI调用与结构数组一起使用</h4>
                  <div>
                     <p>执行涉及结构数组的操作时必须使用哪些调用。</p>
                     <p>执行涉及结构数组的操作时，必须使用两个OCI调用：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>使用<code class="codeph">OCIBindArrayOfStruct()</code>来绑定输入变量的结构数组中的字段</p>
                        </li>
                        <li>
                           <p>使用<code class="codeph">OCIDefineArrayOfStruct()</code>来定义输出变量的结构数组。
                           </p>
                           <div class="infoboxnote" id="GUID-5BF33AD0-8AA9-4FFC-9721-2643EA24CC38__GUID-01F0A823-8B1D-49BA-A275-DB6E021AE907">
                              <p class="notep1">注意：</p>
                              <p>绑定或定义结构数组需要多次调用。对<code class="codeph">OCIBindByName()</code>或<code class="codeph">OCIBindByName2()</code>或<code class="codeph">OCIBindByPos()</code>或<code class="codeph">OCIBindByPos2()</code>的调用必须在对<code class="codeph">OCIBindArrayOfStruct()</code>的调用之前，并且对<code class="codeph">OCIDefineByPos()</code>或<code class="codeph">OCIDefineByPos2()</code>的调用必须在对<code class="codeph">OCIDefineArrayOfStruct()</code>的调用之前。
                              </p>
                           </div>
                        </li>
                     </ul>
                     <div class="infoboxnotealso" id="GUID-5BF33AD0-8AA9-4FFC-9721-2643EA24CC38__GUID-AAFC8A1D-7809-4D09-8311-5EFE26FCC2C6">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="bind-define-describe-functions.html#GUID-E83BF668-88FC-4F31-A950-3580B79588E0" title="设置静态数组绑定的跳过参数。">OCIBindArrayOfStruct（）</a></p>
                           </li>
                           <li>
                              <p><a href="bind-define-describe-functions.html#GUID-D3F74828-5DA7-48AD-A170-120AD547DEB3" title="指定静态数组定义所需的其他属性，用于结构数组（多行，多列）提取。">OCIDefineArrayOfStruct（）</a></p>
                           </li>
                           <li>
                              <p><a href="bind-define-describe-functions.html#GUID-CD63DF78-2178-4727-A896-B9673C4A37F0" title="在SQL语句或PL / SQL块中创建程序变量和占位符之间的关联。">OCIBindByName（）</a>或<a href="bind-define-describe-functions.html#GUID-55C47708-5468-4106-89BE-1AB60861D037" title="在SQL语句或PL / SQL块中创建程序变量和占位符之间的关联。当客户端上的实际长度超过UB2MAXVAL时，在处理数据类型时使用此函数。">OCIBindByName2（）</a></p>
                           </li>
                           <li>
                              <p><a href="bind-define-describe-functions.html#GUID-D28DF5A7-3C75-4E52-82F7-A5D6D5714E69" title="在SQL语句或PL / SQL块中创建程序变量和占位符之间的关联。">OCIBindByPos（）</a>或<a href="bind-define-describe-functions.html#GUID-5C505821-323D-473D-825B-448C8D9A6702" title="在SQL语句或PL / SQL块中创建程序变量和占位符之间的关联。当客户端上的实际长度超过UB2MAXVAL时，在处理数据类型时使用此调用。">OCIBindByPos2（）</a></p>
                           </li>
                           <li>
                              <p><a href="bind-define-describe-functions.html#GUID-CFE5AA54-DEBC-42D3-8A27-AFF1E7815691" title="将选择列表中的项与类型和输出数据缓冲区相关联。">OCIDefineByPos（）</a>或<a href="bind-define-describe-functions.html#GUID-74939FB5-919E-4D24-B327-AFB532435061" title="将选择列表中的项与类型和输出数据缓冲区相关联。当客户端上的实际长度超过UB2MAXVAL时，在处理数据类型时使用此调用。">OCIDefineByPos2（）</a></p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="LNOCI16400"></a><div class="props_rev_3"><a id="GUID-5D597ED3-20FB-4092-BA99-6D43D459C34C" name="GUID-5D597ED3-20FB-4092-BA99-6D43D459C34C"></a><h4 id="LNOCI-GUID-5D597ED3-20FB-4092-BA99-6D43D459C34C" class="sect4"><span class="enumeration_section">7.5.3</span>结构和指标变量阵列</h4>
                  <div>
                     <p>此外，结构数组的实现支持使用指示符变量和返回码。</p>
                     <p>您可以声明列级指示符变量的并行数组，并返回与要提取，插入或更新的信息数组相对应的代码。这些数组可以有自己的跳过参数，这些参数在<code class="codeph">OCIBindArrayOfStruct()</code>或<code class="codeph">OCIDefineArrayOfStruct()</code>调用期间指定。
                     </p>
                     <p>您可以通过多种方式设置程序值和指标变量的结构数组。考虑一个应用程序，它将来自三个数据库列的数据提取到包含三个字段的结构数组中。您可以设置三个字段的相应指标变量结构数组，每个字段都是从数据库中提取的其中一列的列级指示符变量。指标结构中的字段与选择列表项的数量之间的一对一关系不是必需的。</p>
                     <div class="infoboxnotealso" id="GUID-5D597ED3-20FB-4092-BA99-6D43D459C34C__GUID-57EC908F-AE2E-4F40-BCEE-2F0EFAA5BCB9">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="oci-programming-basics.html#GUID-9966EDF7-37ED-42E5-AE57-67E394245BFA" title="每个绑定和定义OCI调用都有一个参数，它将指示符变量或指示符变量数组与DML语句，PL / SQL语句或查询相关联。">指标变量</a></p>
                           </li>
                           <li>
                              <p><a href="bind-define-describe-functions.html#GUID-E83BF668-88FC-4F31-A950-3580B79588E0" title="设置静态数组绑定的跳过参数。">OCIBindArrayOfStruct（）</a></p>
                           </li>
                           <li>
                              <p><a href="bind-define-describe-functions.html#GUID-D3F74828-5DA7-48AD-A170-120AD547DEB3" title="指定静态数组定义所需的其他属性，用于结构数组（多行，多列）提取。">OCIDefineArrayOfStruct（）</a></p>
                           </li>
                        </ul>
                        <p></p>
                     </div>
                  </div>
               </div>
            </div><a id="LNOCI72619"></a><a id="LNOCI05100"></a><div class="props_rev_3"><a id="GUID-CC67A87C-A39A-400A-BF95-C32363DCD589" name="GUID-CC67A87C-A39A-400A-BF95-C32363DCD589"></a><h3 id="LNOCI-GUID-CC67A87C-A39A-400A-BF95-C32363DCD589" class="sect3"><span class="enumeration_section">7.6</span>关于绑定和定义多个缓冲区</h3>
               <div>
                  <p>您可以指定多个缓冲区以用于单个绑定或定义调用。</p>
                  <p>性能得到改善，因为当存储在不同非连续地址的数据未被复制到一个连续位置时，往返次数会减少。因此减少了花费的CPU时间和使用的内存。</p>
                  <p>数据类型<code class="codeph">OCIIOV</code>定义为：</p><pre class="oac_no_warn" dir="ltr">typedef struct OCIIOV {void * bfp; / *指向数据缓冲区的指针* / ub4 bfl; / *缓冲区的大小* /} OCIIOV;</pre><p><code class="codeph">mode</code>参数的值<code class="codeph">OCI_IOV</code>用于<code class="codeph">OCIBindByPos()</code>或<code class="codeph">OCIBindByPos2()</code>和<code class="codeph">OCIBindByName()</code>或<code class="codeph">OCIBindByName2()</code>函数，用于绑定多个缓冲区。如果指定了此<code class="codeph">mode</code>值，则必须在参数<code class="codeph">valuep</code>传递<code class="codeph">OCIIOV</code>的地址。必须在参数<code class="codeph">valuesz</code>传递数据类型的大小。例如：</p><pre class="oac_no_warn" dir="ltr">OCIIOV vecarr [NumBuffers]; .../ *对于位置1的绑定，数据类型为int * / OCIBindByPos（stmthp，bindp，errhp，1，（void *）＆vecarr [0]，sizeof（int），...OCI_IOV）; ...
</pre><p><span>mode参数</span>的值<code class="codeph">OCI_IOV</code> <span>用于</span> <code class="codeph">OCIDefineByPos()</code>或<code class="codeph">OCIDefineByPos2()</code>函数，用于定义多个缓冲区。如果指定了此<code class="codeph">mode</code>值，则在参数<code class="codeph">valuep</code>传递<code class="codeph">OCIIOV</code>的地址。必须在参数<code class="codeph">valuesz</code>传递数据类型的大小。此模式旨在用于分散或聚集绑定，这允许将多个缓冲区绑定或定义到某个位置，例如，一个缓冲区中前10行的列A，一个缓冲区中的后5行，其余25个另一个缓冲区中的行。这样就无需在执行数组执行操作时将所有这些分配并复制到一个大缓冲区中。
                  </p>
                  <p><a href="binding-and-defining-in-oci.html#GUID-CC67A87C-A39A-400A-BF95-C32363DCD589__CIHHIAJF">例7-16</a>说明了结构<code class="codeph">OCIIOV</code>及其<code class="codeph">mode</code>值的使用。
                  </p>
                  <div class="example" id="GUID-CC67A87C-A39A-400A-BF95-C32363DCD589__CIHHIAJF">
                     <p class="titleinexample">示例7-16使用多个绑定和定义缓冲区</p><pre class="oac_no_warn" dir="ltr">/ *以下宏提到*不同缓冲区中数据的最大长度。* / #define LENGTH_DATE 10 #define LENGTH_EMP_NAME 100 / *这两个宏表示每个绑定中的元素数量并定义数组* / #define NUM_BIND 30 #define NUM_DEFINE 45 / *用于插入日期的绑定缓冲区* / char buf_1 [NUM_BIND ] [LENGTH_DATE]，char buf_2 [NUM_BIND * 2] [LENGTH_DATE]，/ *用于插入emp名称的绑定缓冲区* / char buf_3 [NUM_BIND * 3] [LENGTH_EMP_NAME]，/ *定义缓冲区* / char buf_4 [NUM_DEFINE] [LENGTH_EMP_NAME]; char buf_5 [NUM_DEFINE] [LENGTH_EMP_NAME]; / *对应于同一列的缓冲区的数据值大小必须相同，并且该值将在OCIBind或Define调用中传递。上面的buf_4和buf_5具有相同的数据值;也就是说，LENGTH_EMP_NAME虽然两个缓冲区中的元素数量不同。* / OCIBind * bndhp1 =（OCIBind *）0; OCIBind * bndhp2 =（OCIBind *）0; OCIDefine * defhp =（OCIDefine *）0; OCIStmt * stmthp =（OCIStmt *）0; OCIError * errhp =（OCIError *）0; OCIIOV bvec [2]，dvec [2]; / *如何使用带有此功能的指示符和返回代码的示例，显示使用define时的分配。您将指示符，返回码和长度缓冲区的内存分配为NUM_DEFINE * 2个元素的一个块。* / short * indname [NUM_DEFINE * 2]; / *指标* / ub4 * alenname [NUM_DEFINE * 2]; / *返回长度* / ub2 * rcodename [NUM_DEFINE * 2]; / *返回代码* / static text * insertstr =“INSERT INTO EMP（EMP_NAME，JOIN_DATE）VALUES（：1，：2）”; static text * choicestr =“SELECT EMP_NAME FROM EMP”; / *分配环境，错误句柄等，然后初始化环境。* / .../ *使用insert查询准备语句以显示绑定。* / OCIStmtPrepare（stmthp，errhp，insertstr，（ub4）strlen（（char *）insertstr），（ub4）OCI_NTV_SYNTAX，（ub4）OCI_DEFAULT）; / *使用值填充缓冲区。以下代表填充缓冲区的最简单方法。但是，在实际场景中*这些缓冲区可能已由从不同*源接收的数据填充。* / / *将日期存储在日期的绑定缓冲区中。* / strcpy（buf_1 [0]，“21-SEP-02”）; ...strcpy（buf_1 [NUM_BIND  -  1]，“21-OCT-02”）; ...strcpy（buf_2 [0]，“22-OCT-02”）; ...strcpy（buf_2 [2 * NUM_BIND  -  1]，“21-DEC-02”）; ...memset（bvec [0]，0，sizeof（OCIIOV））; memset（bvec [1]，0，sizeof（OCIIOV））; / *在IO Vector结构中设置地址* / bvec [0] .bfp = buf_1 [0]; / *数据的缓冲区地址* / bvec [0] .bfl = NUM_BIND * LENGTH_DATE; / *缓冲区的大小* / / *对于其他结构也是如此。* / bvec [1] .bfp = buf_2 [0]; / *数据的缓冲区地址* / bvec [1] .bfl = NUM_BIND * 2 * LENGTH_DATE; / *缓冲区的大小* / / *使用OCIIOV * / OCIBindByPos（stmthp，＆bindhp2，errhp，2，（void *）＆bvec [0]，sizeof（buf_1 [0]），SQLT_STR，执行日期绑定; void *）inddate，（ub2 *）alendate，（ub2 *）rcodedate，0，（ub4 *）0，OCI_IOV）; / *将员工姓名存储在绑定缓冲区中，3表示名称* / strcpy（buf_3 [0]，“JOHN”）; ...strcpy（buf_3 [NUM_BIND * 3  -  1]，“HARRY”）; / *对员工姓名进行绑定* / OCIBindByPos（stmthp，＆bindhp1，errhp，1，buf_3 [0]，sizeof（buf_3 [0]），SQLT_STR，（void *）indemp，（ub2 *）alenemp，（ub2 * ）rcodeemp，0，（ub4 *）0，OCI_DEFAULT）; OCIStmtExecute（svchp，stmthp，errhp，NUM_BIND * 3,0，（OCISnapshot *）0，（OCISnapshot *）0，OCI_DEFAULT）; .../ *现在描述的语句定义* / / *使用select查询准备语句以显示定义* / OCIStmtPrepare（stmthp，errhp，choicestr，（ub4）strlen（（char *）choicestr），（ub4） OCI_NTV_SYNTAX，（ub4）OCI_DEFAULT）; memset（dvec [0]，0，sizeof（OCIIOV）; memset（dvec [1]，0，sizeof（OCIIOV））; / *设置定义向量* / dvec [0] .bfp = buf_4 [0]; dvec [0] .bfl = NUM_DEFINE * LENGTH_EMP_NAME; dvec [1] .bfp = buf_5 [0]; dvec [1] .bfl = NUM_DEFINE * LENGTH_EMP_NAME; / *传递指标的缓冲区，数据长度和返回代码。请注意，接收数据的缓冲区分为两个位置，每个位置具有NUM_DEFINE个元素。但是，指示缓冲区，实际长度缓冲区和返回码缓冲区包含一个NUM_DEFINE * 2个元素。* / OCIDefineByPos（stmthp，＆defhp，errhp，1，（void *）＆dvec [0]，sizeof（buf_4 [0]），SQLT_STR，（void *）indname，（ub2 *）alenname，（ub2 *）rcodename，OCI_IOV ）; OCIStmtExecute（svchp，stmthp，errhp，NUM_DEFINE * 2,0，（OCISnapshot *）0，（OCISnapshot *）0，OCI_DEFAULT）; ...
</pre><div class="infoboxnotealso" id="GUID-CC67A87C-A39A-400A-BF95-C32363DCD589__GUID-5952030A-4A7A-4831-87A9-08CF7A7838A1">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="bind-define-describe-functions.html#GUID-CD63DF78-2178-4727-A896-B9673C4A37F0" title="在SQL语句或PL / SQL块中创建程序变量和占位符之间的关联。">OCIBindByName（）</a>或<a href="bind-define-describe-functions.html#GUID-55C47708-5468-4106-89BE-1AB60861D037" title="在SQL语句或PL / SQL块中创建程序变量和占位符之间的关联。当客户端上的实际长度超过UB2MAXVAL时，在处理数据类型时使用此函数。">OCIBindByName2（）</a></p>
                           </li>
                           <li>
                              <p><a href="bind-define-describe-functions.html#GUID-D28DF5A7-3C75-4E52-82F7-A5D6D5714E69" title="在SQL语句或PL / SQL块中创建程序变量和占位符之间的关联。">OCIBindByPos（）</a>或<a href="bind-define-describe-functions.html#GUID-5C505821-323D-473D-825B-448C8D9A6702" title="在SQL语句或PL / SQL块中创建程序变量和占位符之间的关联。当客户端上的实际长度超过UB2MAXVAL时，在处理数据类型时使用此调用。">OCIBindByPos2（）</a></p>
                           </li>
                           <li>
                              <p><a href="bind-define-describe-functions.html#GUID-CFE5AA54-DEBC-42D3-8A27-AFF1E7815691" title="将选择列表中的项与类型和输出数据缓冲区相关联。">OCIDefineByPos（）</a>或<a href="bind-define-describe-functions.html#GUID-74939FB5-919E-4D24-B327-AFB532435061" title="将选择列表中的项与类型和输出数据缓冲区相关联。当客户端上的实际长度超过UB2MAXVAL时，在处理数据类型时使用此调用。">OCIDefineByPos2（）</a></p>
                           </li>
                        </ul>
                     </div>
                  </div>
                  <!-- class="example" -->
               </div>
            </div><a id="LNOCI16402"></a><div class="props_rev_3"><a id="GUID-C0D4318B-0768-4386-AA15-C88AE3A33C76" name="GUID-C0D4318B-0768-4386-AA15-C88AE3A33C76"></a><h3 id="LNOCI-GUID-C0D4318B-0768-4386-AA15-C88AE3A33C76" class="sect3"><span class="enumeration_section">7.7</span> OCI中带有RETURNING子句的DML</h3>
               <div>
                  <p>本节概述了使用<code class="codeph">RETURNING</code>子句正确实现DML语句的规则。
                  </p>
                  <p>OCI支持将<code class="codeph">RETURNING</code>子句与SQL <code class="codeph">INSERT</code> ， <code class="codeph">UPDATE</code>和<code class="codeph">DELETE</code>语句一起使用。
                  </p>
                  <div class="p">本节包括以下主题：<ul style="list-style-type:disc">
                        <li>
                           <p><a href="binding-and-defining-in-oci.html#GUID-F170558F-C61D-4B88-8A8C-AC9ED741BE06" title="通过将RETURNING子句与DML语句结合使用，可以将两个SQL语句合并为一个，从而可以保存服务器往返。">关于将DML与RETURNING子句结合使用以组合两个SQL语句</a></p>
                        </li>
                        <li>
                           <p><a href="binding-and-defining-in-oci.html#GUID-415F2F47-03BA-4E3D-B622-A799409DA243" title="由于UPDATE和DELETE语句都可以影响表中的多行，并且DML语句可以在单个OCIStmtExecute（）调用中多次执行，因此在运行时可能无法获知返回的数据量。">关于绑定返回...INTO变量</a></p>
                        </li>
                        <li>
                           <p><a href="binding-and-defining-in-oci.html#GUID-98A7A102-0839-4814-8CC7-2F3A4C662FF9" title="提供给OCIBindDynamic（）的OUT绑定函数必须准备好在出现错误时接收语句的部分结果。">OCI错误处理</a></p>
                        </li>
                        <li>
                           <p><a href="binding-and-defining-in-oci.html#GUID-7B076B46-24FD-4F31-B1B5-A6E3B57F7FEB" title="RETURNING子句还可用于将REF返回到正在数据库中插入或更新的对象。">DML与RETURNING REF ......OCI的INTO条款</a></p>
                        </li>
                        <li>
                           <p><a href="binding-and-defining-in-oci.html#GUID-81F593FB-1C22-41FC-B1E0-EBBD7B182983" title="调用回调函数时，绑定句柄的OCI_ATTR_ROWS_RETURNED属性告诉应用程序在该特定迭代中返回的行数。">关于OCI回调的附加说明</a></p>
                        </li>
                        <li>
                           <p><a href="binding-and-defining-in-oci.html#GUID-FBBE8A75-8EEC-4166-A574-6FEE4AC78FA3" title="OCI为单行DML和数组DML操作提供了附加功能，其中每次迭代返回多行。">用于DML的数组接口在OCI中返回语句</a></p>
                        </li>
                     </ul>
                     <div class="infoboxnotealso" id="GUID-C0D4318B-0768-4386-AA15-C88AE3A33C76__GUID-159CBB0C-6F15-458C-85F8-175CD369485A">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>Oracle安装中包含的数据库演示程序，以获取完整示例。有关其他信息，请参阅<a href="oci-demo-programs.html#GUID-75E18629-0C54-4495-A747-AFB346034F26" title="列出示例程序，其中包含示例代码，用于演示OCI句柄的分配和使用。">OCI演示程序</a> 。
                              </p>
                           </li>
                           <li>
                              <p>有关将<code class="codeph">RETURNING</code>子句与<code class="codeph">INSERT</code> ， <code class="codeph">UPDATE</code>或<code class="codeph">DELETE</code>语句一起使用的更多信息，请<a href="../sqlrf/INSERT.html#SQLRF55083" target="_blank"><span><cite>参见Oracle数据库SQL语言参考</cite></span></a></p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="LNOCI16403"></a><div class="props_rev_3"><a id="GUID-F170558F-C61D-4B88-8A8C-AC9ED741BE06" name="GUID-F170558F-C61D-4B88-8A8C-AC9ED741BE06"></a><h4 id="LNOCI-GUID-F170558F-C61D-4B88-8A8C-AC9ED741BE06" class="sect4"><span class="enumeration_section">7.7.1</span>关于将DML与RETURNING子句结合使用以组合两个SQL语句</h4>
                  <div>
                     <p>通过将<code class="codeph">RETURNING</code>子句与DML语句结合使用，可以将两个SQL语句合并为一个，从而可以保存服务器往返。
                     </p>
                     <p>这是通过向传统的<code class="codeph">UPDATE</code> ， <code class="codeph">INSERT</code>和<code class="codeph">DELETE</code>语句添加一个额外的子句来实现的。extra子句有效地向DML语句添加了一个查询。
                     </p>
                     <p>在OCI中，值作为<code class="codeph">OUT</code>绑定变量返回给应用程序。在以下示例中，绑定变量由前面的冒号“：”表示。这些示例假定存在<code class="codeph">table1</code> ，该表包含列<code class="codeph">col1</code> ， <code class="codeph">col2</code>和<code class="codeph">col3</code> 。
                     </p>
                     <p>以下语句将新值插入到数据库中，然后从数据库中检索受影响行的列值，以便操作插入的行。</p><pre class="oac_no_warn" dir="ltr">INSERT INTO table1 VALUES（：1，：2，：3）RETURNING col1，col2，col3 INTO：out1，：out2，：out3</pre><p>下一个示例更新<code class="codeph">col1</code>的值落在给定范围内的所有列的值，然后返回已修改的受影响的行。
                     </p><pre class="oac_no_warn" dir="ltr">UPDATE table1 SET col1 = col1 +：1，col2 =：2，col3 =：3 WHERE col1&gt; =：low AND col1 &lt;=：high RETURNING col1，col2，col3 INTO：out1，：out2，：out3</pre><p><code class="codeph">DELETE</code>语句删除<code class="codeph">col1</code>值在给定范围内的行，然后从这些行返回数据。
                     </p><pre class="oac_no_warn" dir="ltr">DELETE FROM table1 WHERE col1&gt; =：low AND col2 &lt;=：high RETURNING col1，col2，col3 INTO：out1，：out2，：out3</pre></div>
               </div><a id="LNOCI16404"></a><div class="props_rev_3"><a id="GUID-415F2F47-03BA-4E3D-B622-A799409DA243" name="GUID-415F2F47-03BA-4E3D-B622-A799409DA243"></a><h4 id="LNOCI-GUID-415F2F47-03BA-4E3D-B622-A799409DA243" class="sect4"><span class="enumeration_section">7.7.2</span>关于绑定返回...INTO变量</h4>
                  <div>
                     <p>由于<code class="codeph">UPDATE</code>和<code class="codeph">DELETE</code>语句都可以影响表中的多行，并且DML语句可以在单个<code class="codeph">OCIStmtExecute()</code>调用中多次执行，因此在运行时可能无法<code class="codeph">OCIStmtExecute()</code>返回的数据量。
                     </p>
                     <p>因此，对应于<code class="codeph">RETURNING</code>的变量......<code class="codeph">INTO</code>占位符必须以<code class="codeph">OCI_DATA_AT_EXEC</code>模式绑定。应用程序必须定义自己的动态数据处理回调，而不是使用轮询机制。
                     </p>
                     <p>在使用LOB时，返回子句特别有用。通常，应用程序必须将空LOB定位器插入数据库，然后再次选择它以对其进行操作。通过使用<code class="codeph">RETURNING</code>子句，应用程序可以将这两个步骤组合成一个语句：</p><pre class="oac_no_warn" dir="ltr">INSERT INTO some_table VALUES（：in_locator）RETURNING lob_column INTO：out_locator</pre><p>OCI应用程序将<code class="codeph">RETURNING</code>子句中的占位符实现为纯<code class="codeph">OUT</code>绑定变量。但是， <code class="codeph">RETURNING</code>子句中的所有绑定最初都是<code class="codeph">IN</code> ，必须正确初始化。要提供有效值，可以提供<code class="codeph">NULL</code>指示符并将该指示符设置为-1。<span class="bold"></span></p>
                     <p>在<code class="codeph">RETURNING</code>子句中使用绑定变量时，应用程序必须遵守以下规则：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>绑定<code class="codeph">RETURNING</code>条款占位符<code class="codeph">OCI_DATA_AT_EXEC</code>使用模式<code class="codeph">OCIBindByName()</code>或<code class="codeph">OCIBindByName2()</code>或<code class="codeph">OCIBindByPos()</code>或<code class="codeph">OCIBindByPos2()</code>随后将呼叫<code class="codeph">OCIBindDynamic()</code>为每个占位符。
                           </p>
                        </li>
                        <li>
                           <p>绑定<code class="codeph">RETURNING</code>子句占位符时，提供有效的<code class="codeph">OUT</code>绑定函数作为<code class="codeph">OCIBindDynamic()</code>调用的<code class="codeph">ocbfp</code>参数。此函数必须提供存储以保存返回的数据。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">OCIBindDynamic()</code>调用的<code class="codeph">icbfp</code>参数应该提供一个默认函数，在调用时返回<code class="codeph">NULL</code>值。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">OCIBindDynamic()</code>的<code class="codeph">piecep</code>参数必须设置为<code class="codeph">OCI_ONE_PIECE</code> 。</p>
                        </li>
                     </ul>
                     <p>使用<code class="codeph">RETURNING</code>子句的DML语句中不允许重复绑定，并且DML部分中的绑定变量与语句的<code class="codeph">RETURNING</code>部分之间不允许重复。
                     </p>
                     <div class="infoboxnote" id="GUID-415F2F47-03BA-4E3D-B622-A799409DA243__GUID-1CB9E046-E356-42E3-92B7-FC0C1AA76A82">
                        <p class="notep1">注意：</p>
                        <p>OCI仅支持<code class="codeph">RETURNING</code>子句绑定的回调机制。不支持轮询机制。
                        </p>
                     </div>
                     <div class="infoboxnotealso" id="GUID-415F2F47-03BA-4E3D-B622-A799409DA243__GUID-B34CA9FE-FD9B-492B-BC2E-F92F914B6AC2">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="statement-functions.html#GUID-98B26708-3E02-45C0-8258-5D5544F32BE9" title="将应用程序请求与服务器关联。">OCIStmtExecute（）</a></p>
                           </li>
                           <li>
                              <p><a href="bind-define-describe-functions.html#GUID-CD63DF78-2178-4727-A896-B9673C4A37F0" title="在SQL语句或PL / SQL块中创建程序变量和占位符之间的关联。">OCIBindByName（）</a>或<a href="bind-define-describe-functions.html#GUID-55C47708-5468-4106-89BE-1AB60861D037" title="在SQL语句或PL / SQL块中创建程序变量和占位符之间的关联。当客户端上的实际长度超过UB2MAXVAL时，在处理数据类型时使用此函数。">OCIBindByName2（）</a></p>
                           </li>
                           <li>
                              <p><a href="bind-define-describe-functions.html#GUID-D28DF5A7-3C75-4E52-82F7-A5D6D5714E69" title="在SQL语句或PL / SQL块中创建程序变量和占位符之间的关联。">OCIBindByPos（）</a>或<a href="bind-define-describe-functions.html#GUID-5C505821-323D-473D-825B-448C8D9A6702" title="在SQL语句或PL / SQL块中创建程序变量和占位符之间的关联。当客户端上的实际长度超过UB2MAXVAL时，在处理数据类型时使用此调用。">OCIBindByPos2（）</a></p>
                           </li>
                           <li>
                              <p><a href="bind-define-describe-functions.html#GUID-030270CB-346A-412E-B3B3-556DD6947BE2" title="注册用户回调以进行动态数据分配。">OCIBindDynamic（）</a></p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="LNOCI16405"></a><div class="props_rev_3"><a id="GUID-98A7A102-0839-4814-8CC7-2F3A4C662FF9" name="GUID-98A7A102-0839-4814-8CC7-2F3A4C662FF9"></a><h4 id="LNOCI-GUID-98A7A102-0839-4814-8CC7-2F3A4C662FF9" class="sect4"><span class="enumeration_section">7.7.3</span> OCI错误处理</h4>
                  <div>
                     <p>提供给<code class="codeph">OCIBindDynamic()</code>的<code class="codeph">OUT</code>绑定函数必须准备好在出现错误时接收语句的部分结果。
                     </p>
                     <p>如果应用程序发出了执行10次的DML语句，并且在第五次迭代期间发生错误，则Oracle数据库将返回迭代1到4中的数据。仍然调用回调函数来接收前四次迭代的数据。</p>
                  </div>
               </div><a id="LNOCI16406"></a><div class="props_rev_3"><a id="GUID-7B076B46-24FD-4F31-B1B5-A6E3B57F7FEB" name="GUID-7B076B46-24FD-4F31-B1B5-A6E3B57F7FEB"></a><h4 id="LNOCI-GUID-7B076B46-24FD-4F31-B1B5-A6E3B57F7FEB" class="sect4"><span class="enumeration_section">7.7.4</span> DML与RETURNING REF ......OCI的INTO条款</h4>
                  <div>
                     <p><code class="codeph">RETURNING</code>子句还可用于将<code class="codeph">REF</code>返回到正在数据库中插入或更新的对象。
                     </p><pre class="oac_no_warn" dir="ltr">UPDATE extaddr e SET e.zip ='12345'，e.state ='AZ'WHERE.state ='CA'AND e.zip ='95117'RETURNING REF（e），zip INTO：addref，：zip</pre><p>上述语句更新对象表中对象的多个属性，并在<code class="codeph">RETURNING</code>子句中将<code class="codeph">REF</code>返回给对象（以及标量邮政编码（ZIP））。
                     </p>
                     <p>本节包括以下主题： <a href="binding-and-defining-in-oci.html#GUID-88C58918-C7DF-48F4-8803-763508F072E9" title="在OCI应用程序中绑定REF输出变量需要三个步骤。">绑定输出变量</a> 。
                     </p>
                  </div><a id="LNOCI72620"></a><a id="LNOCI16407"></a><div class="props_rev_3"><a id="GUID-88C58918-C7DF-48F4-8803-763508F072E9" name="GUID-88C58918-C7DF-48F4-8803-763508F072E9"></a><h5 id="LNOCI-GUID-88C58918-C7DF-48F4-8803-763508F072E9" class="sect5"><span class="enumeration_section">7.7.4.1</span>绑定输出变量</h5>
                     <div>
                        <p>在OCI应用程序中绑定<code class="codeph">REF</code>输出变量需要三个步骤。
                        </p>
                        <div class="section">
                           <p><span><a href="binding-and-defining-in-oci.html#GUID-88C58918-C7DF-48F4-8803-763508F072E9__CIHDICFI">例7-17</a></span>中的以下伪代码显示了执行前三个步骤所必需的绑定的函数。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <ol>
                           <li><span>设置初始绑定信息是使用<code class="codeph">OCIBindByName()</code>或<code class="codeph">OCIBindByName2()</code> 。</span></li>
                           <li><span>为<code class="codeph">REF</code>设置其他绑定信息，包括类型描述对象（TDO），使用<code class="codeph">OCIBindObject()</code>设置。</span></li>
                           <li><span>拨打<code class="codeph">OCIBindDynamic()</code> 。</span></li>
                        </ol>
                        <div class="example" id="GUID-88C58918-C7DF-48F4-8803-763508F072E9__CIHDICFI">
                           <p class="titleinexample">例7-17在OCI应用程序中绑定REF输出变量</p><pre class="oac_no_warn" dir="ltr">sword bind_output（stmthp，bndhp，errhp）OCIStmt * stmthp; OCIBind * bndhp []; OCIError * errhp; {ub4 i; / *为BindObject调用获得TDO * / if（OCITypeByName（envhp，errhp，svchp，（CONST text *）0，（ub4）0，（CONST text *）“ADDRESS_OBJECT”，（ub4）strlen（（CONST char *） “ADDRESS_OBJECT”），（CONST text *）0，（ub4）0，OCI_DURATION_SESSION，OCI_TYPEGET_HEADER，＆addrtdo））{return OCI_ERROR; } / *初始绑定调用两个变量* / if（OCIBindByName（stmthp，＆bndhp [2]，errhp，（text *）“：addref”，（sb4）strlen（（char *）“：addref”），（void *）0，（sb4）sizeof（OCIRef *），SQLT_REF，（void *）0，（ub2 *）0，（ub2 *）0，（ub4）0，（ub4 *）0，（ub4）OCI_DATA_AT_EXEC）| | OCIBindByName（stmthp，＆bndhp [3]，errhp，（text *）“：zip”，（sb4）strlen（（char *）“：zip”），（void *）0，（sb4）MAXZIPLEN，SQLT_CHR，（ void *）0，（ub2 *）0，（ub2 *）0，（ub4）0，（ub4 *）0，（ub4）OCI_DATA_AT_EXEC））{return OCI_ERROR; } / *对象绑定REF变量* / if（OCIBindObject（bndhp [2]，errhp，（OCIType *）addrtdo，（void **）＆addrref [0]，（ub4 *）0，（void **）0， （ub4 *）0））{return OCI_ERROR; for（i = 0; i &lt;MAXCOLS; i ++）pos [i] = i; / *动态绑定RETURNING变量* / if（OCIBindDynamic（bndhp [2]，errhp，（void *）＆pos [0]，cbf_no_data，（void *）＆pos [0]，cbf_get_data）|| OCIBindDynamic（bndhp [3 ]，errhp，（void *）＆pos [1]，cbf_no_data，（void *）＆pos [1]，cbf_get_data））{return OCI_ERROR; } return OCI_SUCCESS; }</pre><div class="infoboxnotealso" id="GUID-88C58918-C7DF-48F4-8803-763508F072E9__GUID-8C6B7C8A-FB71-44D2-BDBC-CBF9B5528DE8">
                              <p class="notep1">也可以看看：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p><a href="bind-define-describe-functions.html#GUID-CD63DF78-2178-4727-A896-B9673C4A37F0" title="在SQL语句或PL / SQL块中创建程序变量和占位符之间的关联。">OCIBindByName（）</a>或<a href="bind-define-describe-functions.html#GUID-55C47708-5468-4106-89BE-1AB60861D037" title="在SQL语句或PL / SQL块中创建程序变量和占位符之间的关联。当客户端上的实际长度超过UB2MAXVAL时，在处理数据类型时使用此函数。">OCIBindByName2（）</a></p>
                                 </li>
                                 <li>
                                    <p><a href="bind-define-describe-functions.html#GUID-384B5D31-165B-4661-A334-8C2B5E475AEF" title="设置命名数据类型（对象）绑定所需的其他属性。">OCIBindObject（）</a></p>
                                 </li>
                                 <li>
                                    <p><a href="bind-define-describe-functions.html#GUID-030270CB-346A-412E-B3B3-556DD6947BE2" title="注册用户回调以进行动态数据分配。">OCIBindDynamic（）</a></p>
                                 </li>
                              </ul>
                           </div>
                        </div>
                        <!-- class="example" -->
                     </div>
                  </div>
               </div><a id="LNOCI16408"></a><div class="props_rev_3"><a id="GUID-81F593FB-1C22-41FC-B1E0-EBBD7B182983" name="GUID-81F593FB-1C22-41FC-B1E0-EBBD7B182983"></a><h4 id="LNOCI-GUID-81F593FB-1C22-41FC-B1E0-EBBD7B182983" class="sect4"><span class="enumeration_section">7.7.5</span>关于OCI回调的附加说明</h4>
                  <div>
                     <p>调用回调函数时，绑定句柄的<code class="codeph">OCI_ATTR_ROWS_RETURNED</code>属性告诉应用程序在该特定迭代中返回的行数。
                     </p>
                     <p>在第一次回调迭代期间，您可以为该绑定变量返回的所有行分配空间。在同一次迭代的后续回调期间，将缓冲区指针递增到已分配空间内的正确内存。</p>
                  </div>
               </div><a id="LNOCI16409"></a><div class="props_rev_3"><a id="GUID-FBBE8A75-8EEC-4166-A574-6FEE4AC78FA3" name="GUID-FBBE8A75-8EEC-4166-A574-6FEE4AC78FA3"></a><h4 id="LNOCI-GUID-FBBE8A75-8EEC-4166-A574-6FEE4AC78FA3" class="sect4"><span class="enumeration_section">7.7.6</span> DML的数组接口返回OCI中的语句</h4>
                  <div>
                     <p>OCI为单行DML和数组DML操作提供了附加功能，其中每次迭代返回多行。</p>
                     <p>要利用此功能，必须在绑定调用中指定一个至少与<code class="codeph">OCIStmtExecute()</code>调用指定的迭代计数一样大的OUT缓冲区。这是通过回调提供的绑定缓冲区的补充。
                     </p>
                     <p>如果任何迭代返回多行，则应用程序将收到<code class="codeph">OCI_SUCCESS_WITH_INFO</code>返回码。在这种情况下，DML操作成功。此时，应用程序可以选择回滚事务或忽略警告。
                     </p>
                     <div class="infoboxnotealso" id="GUID-FBBE8A75-8EEC-4166-A574-6FEE4AC78FA3__GUID-363F4C8C-5BD4-43FC-9D23-CD1980B9EC17">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="statement-functions.html#GUID-98B26708-3E02-45C0-8258-5D5544F32BE9" title="将应用程序请求与服务器关联。">OCIStmtExecute（）</a></p>
                     </div>
                  </div>
               </div>
            </div><a id="LNOCI16410"></a><div class="props_rev_3"><a id="GUID-84576558-1974-4E61-B6E6-795FA67419E3" name="GUID-84576558-1974-4E61-B6E6-795FA67419E3"></a><h3 id="LNOCI-GUID-84576558-1974-4E61-B6E6-795FA67419E3" class="sect3"><span class="enumeration_section">7.8</span> OCI绑定和定义中的字符转换</h3>
               <div>
                  <p>本节讨论涉及客户端和服务器之间的字符转换的问题。</p>
                  <p></p>
                  <div class="p">本节包括以下主题：<ul style="list-style-type:disc">
                        <li>
                           <p><a href="binding-and-defining-in-oci.html#GUID-54B9B929-6567-4BB6-86DD-5358CD147608" title="如果将包含字符数据的数据库列定义为CHAR或VARCHAR2或NCHAR或NVARCHAR2列，则涉及该列的绑定或定义必须特别考虑处理字符集规范。">关于选择一个字符集</a></p>
                        </li>
                        <li>
                           <p><a href="binding-and-defining-in-oci.html#GUID-1EC425D9-4DC2-4A94-95E4-13DD7BFE3A28" title="您可以通过OCIEnvNlsCreate（）函数参数charset和ncharset设置客户端字符集。">关于在OCI中设置客户端字符集</a></p>
                        </li>
                        <li>
                           <p><a href="binding-and-defining-in-oci.html#GUID-59162D2A-A07D-4812-B9BE-3A9F23660E22" title="更新或插入操作通过变量绑定完成。">关于OCI中的绑定变量</a></p>
                        </li>
                     </ul>
                  </div>
               </div><a id="LNOCI16411"></a><div class="props_rev_3"><a id="GUID-54B9B929-6567-4BB6-86DD-5358CD147608" name="GUID-54B9B929-6567-4BB6-86DD-5358CD147608"></a><h4 id="LNOCI-GUID-54B9B929-6567-4BB6-86DD-5358CD147608" class="sect4"><span class="enumeration_section">7.8.1</span>关于选择字符集</h4>
                  <div>
                     <p>如果将包含字符数据的数据库列定义为<code class="codeph">CHAR</code>或<code class="codeph">VARCHAR2</code>或<code class="codeph">NCHAR</code>或<code class="codeph">NVARCHAR2</code>列，则涉及该列的绑定或定义必须特别考虑处理字符集规范。
                     </p>
                     <p></p>
                     <p>如果客户端字符集的宽度与服务器字符集不同，并且正确的字符转换，则必须考虑这些因素。在不同字符集之间转换数据期间，数据的大小可以增加或减少最多四倍。确保提供用于保存数据的缓冲区足够大。</p>
                     <p>从Oracle Database 12 <span class="italic">c</span> Release 2（12.2）开始，OCI提供两个服务上下文句柄属性<code class="codeph">OCI_ATTR_MAX_CHARSET_RATIO</code>和<code class="codeph">OCI_ATTR_MAX_NCHARSET_RATIO</code>以分别从服务器到客户端字符集或国家字符集获得最<code class="codeph">OCI_ATTR_MAX_NCHARSET_RATIO</code>扩展比率。使用这些属性可以在转换之前更有效地分配缓冲区的最佳内存，以便在从数据库返回数据时，可以分配足够的空间来保存它。在服务器和客户端之间存在不同字符集或国家字符集的情况下，使用这些属性非常有用。
                     </p>
                     <div class="p">以下代码示例显示如何获取从服务器到客户端字符集的最大字符集扩展比率：<pre class="pre codeblock"><code>size_t cratio; OCIAttrGet（（void *）svchp，（ub4）OCI_HTYPE_SVCCTX，（size_t *）＆cratio，（ub4）0，OCI_ATTR_MAX_CHARSET_RATIO，errhp）; printf（“服务器到客户端字符集的转换率为％d \ n”，cratio）;服务器到客户端字符集的转换率为2</code></pre></div>
                     <div class="p">以下代码示例显示如何获取从服务器到客户端国家字符集的最大字符集扩展比率：<pre class="pre codeblock"><code>size_t cratio; OCIAttrGet（（void *）svchp，（ub4）OCI_HTYPE_SVCCTX，（size_t *）＆cratio，（ub4）0，OCI_ATTR_MAX_NCHARSET_RATIO，errhp）; printf（“从服务器到客户端ncharset的转换率是％d \ n”，cratio）;服务器到客户端ncharset的转换率为1</code></pre></div>
                     <p>在某些情况下，应用程序也可能更容易处理<code class="codeph">CHAR</code>或<code class="codeph">VARCHAR2</code>或<code class="codeph">NCHAR</code>或<code class="codeph">NVARCHAR2</code>数据的字符数，而不是字节数，这是通常的情况。
                     </p>
                     <div class="p">本节包括以下主题：<ul style="list-style-type:disc">
                           <li>
                              <p><a href="binding-and-defining-in-oci.html#GUID-EAF88505-0ADF-4350-85EE-C9307688D75E" title="每个OCI绑定和定义句柄与OCI_ATTR_CHARSET_FORM和OCI_ATTR_CHARSET_ID属性相关联。">字符集表单和ID</a></p>
                           </li>
                           <li>
                              <p><a href="binding-and-defining-in-oci.html#GUID-BB971E75-CF42-4E09-A7B5-661C3A5CF827" title="由于数据库字符集和国家字符集之间的隐式转换，OCI可以支持CHAR和NCHAR之间的交叉绑定和交叉定义。">CHAR和NCHAR之间的隐式转换</a></p>
                           </li>
                        </ul>
                     </div>
                  </div><a id="LNOCI16412"></a><div class="props_rev_3"><a id="GUID-EAF88505-0ADF-4350-85EE-C9307688D75E" name="GUID-EAF88505-0ADF-4350-85EE-C9307688D75E"></a><h5 id="LNOCI-GUID-EAF88505-0ADF-4350-85EE-C9307688D75E" class="sect5"><span class="enumeration_section">7.8.1.1</span>字符集表格和ID</h5>
                     <div>
                        <p>每个OCI绑定和定义句柄与<code class="codeph">OCI_ATTR_CHARSET_FORM</code>和<code class="codeph">OCI_ATTR_CHARSET_ID</code>属性相关联。
                        </p>
                        <p>应用程序可以使用<code class="codeph">OCIAttrSet()</code>调用设置这些属性，以指定绑定或定义缓冲区的字符形式和字符集ID。
                        </p>
                        <p><code class="codeph">csform</code>属性（ <code class="codeph">OCI_ATTR_CHARSET_FORM</code> ）表示用于绑定的客户端缓冲区的字符集，以及用于存储已定义的已提取数据的字符集。它有两个可能的值：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">SQLCS_IMPLICIT</code> - 默认值表示绑定或定义缓冲区的数据库字符集ID和字符缓冲区数据转换为服务器数据库字符集</p>
                           </li>
                           <li>
                              <p><code class="codeph">SQLCS_NCHAR</code> - 表示绑定或定义缓冲区的国家字符集ID和客户机缓冲区数据被转换为服务器国家字符集。
                              </p>
                           </li>
                        </ul>
                        <p>如果未指定字符集ID属性<code class="codeph">OCI_ATTR_CHARSET_ID</code> ，则使用数据库的缺省值或客户端的国家字符集ID，具体取决于<code class="codeph">csform</code>的值。它们分别是<code class="codeph">NLS_LANG</code>和<code class="codeph">NLS_NCHAR</code>环境变量中指定的值。
                        </p>
                        <div class="infoboxnote" id="GUID-EAF88505-0ADF-4350-85EE-C9307688D75E__GUID-113509A2-C911-4EF2-88C9-EFC24F4AFE0C">
                           <p class="notep1">注意：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>无论客户端字符集ID如何，数据都将根据服务器的数据库字符集ID或国家字符集ID进行转换并插入数据库。</p>
                              </li>
                              <li>
                                 <p><code class="codeph">OCI_ATTR_CHARSET_ID</code>绝不能设置为0。
                                 </p>
                              </li>
                              <li>
                                 <p>定义句柄属性<code class="codeph">OCI_ATTR_CHARSET_FORM</code>和<code class="codeph">OCI_ATTR_CHARSET_ID</code>不会影响LOB类型。从服务器获取的LOB定位器保留其原始<code class="codeph">csform</code> 。作为基于这些属性的定义转换的一部分，没有<code class="codeph">CLOB</code> / <code class="codeph">NCLOB</code>转换。
                                 </p>
                              </li>
                           </ul>
                        </div>
                        <div class="infoboxnotealso" id="GUID-EAF88505-0ADF-4350-85EE-C9307688D75E__GUID-40AB4F23-E2A8-46CE-8C3B-B0A3F72B7341">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>有关<code class="codeph">NCHAR</code>数据的详细信息，请<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/lnoci&amp;id=SQLRF50975" target="_blank"><span><cite>参见Oracle数据库SQL语言参考</cite></span></a></p>
                              </li>
                              <li>
                                 <p><a href="handle-and-descriptor-functions.html#GUID-3741D7BD-7652-4D7A-8813-AC2AEA8D3B03" title="设置句柄或描述符的属性值。">OCIAttrSet（）</a></p>
                              </li>
                           </ul>
                        </div>
                     </div>
                  </div><a id="LNOCI16413"></a><div class="props_rev_3"><a id="GUID-BB971E75-CF42-4E09-A7B5-661C3A5CF827" name="GUID-BB971E75-CF42-4E09-A7B5-661C3A5CF827"></a><h5 id="LNOCI-GUID-BB971E75-CF42-4E09-A7B5-661C3A5CF827" class="sect5"><span class="enumeration_section">7.8.1.2</span> CHAR和NCHAR之间的隐式转换</h5>
                     <div>
                        <p>由于数据库字符集和国家字符集之间的隐式转换，OCI可以支持<code class="codeph">CHAR</code>和<code class="codeph">NCHAR</code>之间的交叉绑定和交叉定义。</p>
                        <p>虽然<code class="codeph">OCI_ATTR_CHARSET_FORM</code>属性被设置为<code class="codeph">SQLCS_NCHAR</code> ，OCI使得如果数据被插入到数据到数据库的字符集的转换<code class="codeph">CHAR</code>列。
                        </p>
                     </div>
                  </div>
               </div><a id="LNOCI72621"></a><a id="LNOCI16414"></a><div class="props_rev_3"><a id="GUID-1EC425D9-4DC2-4A94-95E4-13DD7BFE3A28" name="GUID-1EC425D9-4DC2-4A94-95E4-13DD7BFE3A28"></a><h4 id="LNOCI-GUID-1EC425D9-4DC2-4A94-95E4-13DD7BFE3A28" class="sect4"><span class="enumeration_section">7.8.2</span>关于在OCI中设置客户端字符集</h4>
                  <div>
                     <p>您可以通过设置客户端字符集<code class="codeph"></code> <code class="codeph">OCIEnvNlsCreate()</code>函数参数<code class="codeph">charset</code>和<code class="codeph">ncharset</code> 。
                     </p>
                     <p>这两个参数都可以设置为<code class="codeph">OCI_UTF16ID</code> 。 <code class="codeph">charset</code>参数控制元数据和<code class="codeph">CHAR</code>数据的编码。<code class="codeph">ncharset</code>参数控制<code class="codeph">NCHAR</code>数据的编码。功能<code class="codeph"></code> <code class="codeph">OCINlsEnvironmentVariableGet()</code>返回<code class="codeph">NLS_LANG</code>的字符集和<code class="codeph">NLS_NCHAR</code>的国家字符集。</p>
                     <p><a href="binding-and-defining-in-oci.html#GUID-1EC425D9-4DC2-4A94-95E4-13DD7BFE3A28__CIHFABJC">例7-18</a>说明了这些函数的使用（OCI提供了一个名为<code class="codeph">utext</code>的typedef，以便于绑定和定义UTF-16数据）：</p>
                     <div class="infoboxnotealso" id="GUID-1EC425D9-4DC2-4A94-95E4-13DD7BFE3A28__GUID-5AF16ECD-C9D1-4A71-9E49-6AD7D32F47E8">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="connect-authorize-and-initialize-functions.html#GUID-0B6911A9-4B46-476C-BC5E-B87581666CD9" title="创建并初始化OCI函数的环境句柄。">OCIEnvNlsCreate（）</a></p>
                           </li>
                           <li>
                              <p><a href="oci-locale-functions.html#GUID-70CCE086-4BF8-42F9-A6CA-E0B926C4DD11" title="从NLS_LANG返回字符集ID或从NLS_NCHAR返回国家字符集ID。">OCINlsEnvironmentVariableGet（）</a></p>
                           </li>
                        </ul>
                     </div>
                     <div class="example" id="GUID-1EC425D9-4DC2-4A94-95E4-13DD7BFE3A28__CIHFABJC">
                        <p class="titleinexample">示例7-18在OCI中将客户端字符集设置为OCI_UTF16ID</p><pre class="oac_no_warn" dir="ltr">OCIEnv * envhp; ub2 ncsid = 2; / * we8dec * / ub2 hdlcsid，hdlncsid; OraText thename [20]; utext * selstmt = L“SELECT ename FROM emp”; / * UTF16语句* / OCIStmt * stmthp; OCIDefine * defhp; OCIError * errhp; OCIEnvNlsCreate（OCIEnv ** envhp，...，OCI_UTF16ID，ncsid）; ...OCIStmtPrepare（stmthp，...，selstmt，...）; / *准备UTF16语句* / OCIDefineByPos（stmthp，defnp，...，1，thename，sizeof（thename），SQLT_CHR，...）; OCINlsEnvironmentVariableGet（＆hdlcsid，（size_t）0，OCI_NLS_CHARSET_ID，（ub2）0，（size_t *）NULL）; OCIAttrSet（defnp，...，＆hdlcsid，0，OCI_ATTR_CHARSET_ID，errhp）; / *将charset ID更改为NLS_LANG设置* / ...
</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="LNOCI72622"></a><div class="props_rev_3"><a id="GUID-59162D2A-A07D-4812-B9BE-3A9F23660E22" name="GUID-59162D2A-A07D-4812-B9BE-3A9F23660E22"></a><h4 id="LNOCI-GUID-59162D2A-A07D-4812-B9BE-3A9F23660E22" class="sect4"><span class="enumeration_section">7.8.3</span>关于OCI中的绑定变量</h4>
                  <div>
                     <p>更新或插入操作通过变量绑定完成。</p>
                     <p>绑定变量时，请在绑定句柄中指定<code class="codeph">OCI_ATTR_MAXDATA_SIZE</code>属性和<code class="codeph">OCI_ATTR_MAXCHAR_SIZE</code>属性，以指示将数据插入Oracle数据库时使用的字节和字符约束。
                     </p>
                     <p>这些属性定义为：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">OCI_ATTR_MAXDATA_SIZE</code>属性设置服务器端缓冲区中允许的最大字节数。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">OCI_ATTR_MAXCHAR_SIZE</code>属性设置服务器端缓冲区中允许的最大字符数。
                           </p>
                        </li>
                     </ul>
                     <div class="p">本节包括以下附加主题：<ul style="list-style-type:disc">
                           <li>
                              <p><a href="binding-and-defining-in-oci.html#GUID-2A4C92CD-74EF-4990-9786-C50E7E1B1DEA" title="不要为OUT绑定或PL / SQL绑定设置OCI_ATTR_MAXDATA_SIZE。仅为INSERT或UPDATE语句设置OCI_ATTR_MAXDATA_SIZE。">OCI绑定期间的缓冲区扩展</a></p>
                           </li>
                           <li>
                              <p><a href="binding-and-defining-in-oci.html#GUID-FAF088BA-9679-4F37-BF20-835ACFB1A0D4" title="要从列中选择数据到客户端缓冲区，OCI使用已定义的变量。">定义期间的约束检查</a></p>
                           </li>
                           <li>
                              <p><a href="binding-and-defining-in-oci.html#GUID-E1932F9D-9ADB-487F-A566-9C1AE05E66B8" title="OCI中的字符长度语义取决于Oracle数据库版本9.0或更高版本与版本8.1或更早版本。">OCI中字符长度语义的一般兼容性问题</a></p>
                           </li>
                        </ul>
                     </div>
                     <div class="infoboxnotealso" id="GUID-59162D2A-A07D-4812-B9BE-3A9F23660E22__GUID-293739F4-5441-4772-8FFB-B83B63EC6A29">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="binding-and-defining-in-oci.html#GUID-AD86F080-F3A4-4D85-A20E-B81A4EF11B40" title="每个绑定句柄都有一个OCI_ATTR_MAXDATA_SIZE属性，该属性指定在字符集转换后在服务器上分配的字节数以容纳客户端绑定数据。">关于使用OCI_ATTR_MAXDATA_SIZE属性</a>以获取更多信息</p>
                           </li>
                           <li>
                              <p> <a href="binding-and-defining-in-oci.html#GUID-E84660EF-B09B-4CD5-A640-9695DC609B1A" title="OCI_ATTR_MAXCHAR_SIZE使处理能够根据字符数而不是字节数来处理数据。">关于使用OCI_ATTR_MAXCHAR_SIZE属性</a>以获取更多信息</p>
                           </li>
                        </ul>
                     </div>
                  </div><a id="LNOCI16415"></a><div class="props_rev_3"><a id="GUID-AD86F080-F3A4-4D85-A20E-B81A4EF11B40" name="GUID-AD86F080-F3A4-4D85-A20E-B81A4EF11B40"></a><h5 id="LNOCI-GUID-AD86F080-F3A4-4D85-A20E-B81A4EF11B40" class="sect5"><span class="enumeration_section">7.8.3.1</span>关于使用OCI_ATTR_MAXDATA_SIZE属性</h5>
                     <div>
                        <p>每个绑定句柄都有一个<code class="codeph">OCI_ATTR_MAXDATA_SIZE</code>属性，该属性指定在字符集转换后在服务器上分配的字节数以容纳客户端绑定数据。
                        </p>
                        <p>应用程序通常将<code class="codeph">OCI_ATTR_MAXDATA_SIZE</code>设置为列的最大大小或PL / SQL变量的大小，具体取决于它的使用方式。如果<code class="codeph">OCI_ATTR_MAXDATA_SIZE</code>不足以容纳转换后的数据，则Oracle数据库会发出错误，并且操作失败。
                        </p>
                        <p>对于<code class="codeph">IN/INOUT</code>绑定，当设置<code class="codeph">OCI_ATTR_MAXDATA_SIZE</code>属性时，绑定缓冲区必须足够大，以保持字符数乘以字符集的每个字符中的字节。
                        </p>
                        <p>如果<code class="codeph">OCI_ATTR_MAXCHAR_SIZE</code>设置为非零值（例如100），则如果字符集在每个字符中有2个字节，则最小可能的分配大小为200个字节。
                        </p>
                        <p>以下方案演示了<code class="codeph">OCI_ATTR_MAXDATA_SIZE</code>属性的一些用法：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>场景1： <code class="codeph">CHAR</code> （源数据）转换为非<code class="codeph">CHAR</code> （目标列）</p>
                              <p>存在数据的隐式绑定转换。<code class="codeph">OCI_ATTR_MAXDATA_SIZE</code>的建议值是源缓冲区的大小乘以客户端和Oracle数据库字符集之间的最坏情况扩展因子。
                              </p>
                           </li>
                           <li>
                              <p>场景2： <code class="codeph">CHAR</code> （源数据）转换为<code class="codeph">CHAR</code> （目标列）或非<code class="codeph">CHAR</code> （源数据）转换为<code class="codeph">CHAR</code> （目标列）</p>
                              <p><code class="codeph">OCI_ATTR_MAXDATA_SIZE</code>的建议值是列的大小。
                              </p>
                           </li>
                           <li>
                              <p>场景3：CHAR（源数据）转换为PL / SQL变量</p>
                              <p>在这种情况下， <code class="codeph">OCI_ATTR_MAXDATA_SIZE</code>的建议值是PL / SQL变量的大小。
                              </p>
                           </li>
                        </ul>
                     </div>
                  </div><a id="LNOCI16416"></a><div class="props_rev_3"><a id="GUID-E84660EF-B09B-4CD5-A640-9695DC609B1A" name="GUID-E84660EF-B09B-4CD5-A640-9695DC609B1A"></a><h5 id="LNOCI-GUID-E84660EF-B09B-4CD5-A640-9695DC609B1A" class="sect5"><span class="enumeration_section">7.8.3.2</span>关于使用OCI_ATTR_MAXCHAR_SIZE属性</h5>
                     <div>
                        <p><code class="codeph">OCI_ATTR_MAXCHAR_SIZE</code>使处理能够根据字符数而不是字节数来处理数据。
                        </p>
                        <p>对于绑定， <code class="codeph">OCI_ATTR_MAXCHAR_SIZE</code>属性设置Oracle数据库中保留的字符数以存储绑定数据。
                        </p>
                        <p>例如，如果<span>OCI_ATTR_MAXDATA_SIZE</span>设置为100，并且<code class="codeph">OCI_ATTR_MAXCHAR_SIZE</code>设置为0，则转换后Oracle数据库中数据的最大可能大小为100字节。但是，如果<code class="codeph">OCI_ATTR_MAXDATA_SIZE</code>设置为300，并且<code class="codeph">OCI_ATTR_MAXCHAR_SIZE</code>设置为非零值，例如100，则如果字符集具有2个字节/字符，则可能的最大分配大小为200个字节。
                        </p>
                        <p>对于定义， <code class="codeph">OCI_ATTR_MAXCHAR_SIZE</code>属性指定客户端应用程序在返回缓冲区中允许的最大字符数。其派生字节长度会覆盖<code class="codeph">OCIDefineByPos()</code>或<code class="codeph">OCIDefineByPos2()</code>调用中指定的<code class="codeph">maxlength</code>参数。
                        </p>
                        <div class="infoboxnote" id="GUID-E84660EF-B09B-4CD5-A640-9695DC609B1A__GUID-A621EAE4-E909-40CB-B81F-D5E448DBDD1F">
                           <p class="notep1">注意：</p>
                           <p>无论属性<code class="codeph">OCI_ATTR_MAXCHAR_SIZE</code>的值如何，在bind或define调用中指定的缓冲区长度始终以字节为单位。您发送和接收的实际长度值也以字节为单位。
                           </p>
                        </div>
                        <div class="infoboxnotealso" id="GUID-E84660EF-B09B-4CD5-A640-9695DC609B1A__GUID-5F35C65C-CCE1-4F31-A889-D781A94ADC11">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="bind-define-describe-functions.html#GUID-CFE5AA54-DEBC-42D3-8A27-AFF1E7815691" title="将选择列表中的项与类型和输出数据缓冲区相关联。">OCIDefineByPos（）</a>或<a href="bind-define-describe-functions.html#GUID-74939FB5-919E-4D24-B327-AFB532435061" title="将选择列表中的项与类型和输出数据缓冲区相关联。当客户端上的实际长度超过UB2MAXVAL时，在处理数据类型时使用此调用。">OCIDefineByPos2（）</a></p>
                        </div>
                     </div>
                  </div><a id="LNOCI16417"></a><div class="props_rev_3"><a id="GUID-2A4C92CD-74EF-4990-9786-C50E7E1B1DEA" name="GUID-2A4C92CD-74EF-4990-9786-C50E7E1B1DEA"></a><h5 id="LNOCI-GUID-2A4C92CD-74EF-4990-9786-C50E7E1B1DEA" class="sect5"><span class="enumeration_section">7.8.3.3</span> OCI绑定期间的缓冲区扩展</h5>
                     <div>
                        <p>不要为<code class="codeph">OUT</code>绑定或PL / SQL绑定设置<code class="codeph">OCI_ATTR_MAXDATA_SIZE</code> 。仅为<code class="codeph">INSERT</code>或<code class="codeph">UPDATE</code>语句设置<code class="codeph">OCI_ATTR_MAXDATA_SIZE</code> 。
                        </p>
                        <p></p>
                        <p>如果这两个属性都未设置，则OCI使用其最佳估计扩展缓冲区。</p>
                        <div class="p">本节包括以下主题：<ul style="list-style-type:disc">
                              <li>
                                 <p><a href="binding-and-defining-in-oci.html#GUID-FC68A968-3B5F-4991-B676-3B8E3B78E177" title="对于IN绑定，如果使用字符长度语义创建基础列，则最好使用OCI_ATTR_MAXCHAR_SIZE指定约束。">IN绑定</a></p>
                              </li>
                              <li>
                                 <p><a href="binding-and-defining-in-oci.html#GUID-32BB20E2-9229-4399-A60C-F3F88FF0F5DB" title="对于动态SQL，您可以使用显式描述来获取参数句柄中的OCI_ATTR_DATA_SIZE和OCI_ATTR_CHAR_SIZE，作为在绑定句柄中设置OCI_ATTR_MAXDATA_SIZE和OCI_ATTR_MAXCHAR_SIZE属性的指南。">动态SQL</a></p>
                              </li>
                              <li>
                                 <p><a href="binding-and-defining-in-oci.html#GUID-56FF2C8E-8169-4FBE-B989-689B57F19555" title="使用OCI_ATTR_MAXDATA_SIZE可以避免在插入期间由缓冲区扩展导致的意外行为。">插入期间的缓冲区扩展</a></p>
                              </li>
                           </ul>
                        </div>
                     </div><a id="LNOCI16418"></a><div class="props_rev_3"><a id="GUID-FC68A968-3B5F-4991-B676-3B8E3B78E177" name="GUID-FC68A968-3B5F-4991-B676-3B8E3B78E177"></a><h6 id="LNOCI-GUID-FC68A968-3B5F-4991-B676-3B8E3B78E177" class="sect6"><span class="enumeration_section">7.8.3.3.1</span> IN <span class="enumeration_section">Binds</span></h6>
                        <div>
                           <p>对于<code class="codeph">IN</code>绑定，如果使用字符长度语义创建基础列，则最好使用<code class="codeph">OCI_ATTR_MAXCHAR_SIZE</code>指定约束。</p>
                           <p>只要实际缓冲区包含的字符数少于<code class="codeph">OCI_ATTR_MAXCHAR_SIZE</code>指定的字符<code class="codeph">OCI_ATTR_MAXCHAR_SIZE</code> ，就不会在OCI级别违反约束。
                           </p>
                           <p>如果使用字节长度语义创建基础列，则在绑定句柄中使用<code class="codeph">OCI_ATTR_MAXDATA_SIZE</code>指定服务器上的字节约束。如果还指定了<code class="codeph">OCI_ATTR_MAXCHAR_SIZE</code>值，则在服务器端分配接收缓冲区时会施加此约束。
                           </p>
                        </div>
                     </div><a id="LNOCI16419"></a><div class="props_rev_3"><a id="GUID-32BB20E2-9229-4399-A60C-F3F88FF0F5DB" name="GUID-32BB20E2-9229-4399-A60C-F3F88FF0F5DB"></a><h6 id="LNOCI-GUID-32BB20E2-9229-4399-A60C-F3F88FF0F5DB" class="sect6"><span class="enumeration_section">7.8.3.3.2</span>动态SQL</h6>
                        <div>
                           <p>对于动态SQL，您可以使用显式描述来获取参数句柄中的<code class="codeph">OCI_ATTR_DATA_SIZE</code>和<code class="codeph">OCI_ATTR_CHAR_SIZE</code> ，作为在绑定句柄中设置<code class="codeph">OCI_ATTR_MAXDATA_SIZE</code>和<code class="codeph">OCI_ATTR_MAXCHAR_SIZE</code>属性的指南。
                           </p>
                           <p>最好将<code class="codeph">OCI_ATTR_MAXDATA_SIZE</code>和<code class="codeph">OCI_ATTR_MAXCHAR_SIZE</code>指定为不超过实际列宽（以字节或字符为单位）。
                           </p>
                        </div>
                     </div><a id="LNOCI16420"></a><div class="props_rev_3"><a id="GUID-56FF2C8E-8169-4FBE-B989-689B57F19555" name="GUID-56FF2C8E-8169-4FBE-B989-689B57F19555"></a><h6 id="LNOCI-GUID-56FF2C8E-8169-4FBE-B989-689B57F19555" class="sect6"><span class="enumeration_section">7.8.3.3.3</span>插入期间的缓冲区扩展</h6>
                        <div>
                           <p>使用<code class="codeph">OCI_ATTR_MAXDATA_SIZE</code>可以避免在插入期间由缓冲区扩展导致的意外行为。
                           </p>
                           <p>考虑当数据库列具有字符长度语义时会发生什么，并且用户尝试使用<code class="codeph">OCIBindByPos()</code>或<code class="codeph">OCIBindByPos2()</code>或<code class="codeph">OCIBindByName()</code>或<code class="codeph">OCIBindByName2()</code>插入数据，同时仅将<code class="codeph">OCI_ATTR_MAXCHAR_SIZE</code>设置为3000字节。数据库字符集为UTF8，客户端字符集为ASCII。然后，在这种情况下，虽然3000个字符适合客户端大小为3000字节的缓冲区，但在服务器端它可能会扩展到超过4000个字节。除非基础列是<code class="codeph">LONG</code>或LOB类型，否则服务器将返回错误。要避免此问题，请将<code class="codeph">OCI_ATTR_MAXDATA_SIZE</code>指定为4000，以保证Oracle数据库永远不会超过4000个字节。
                           </p>
                           <div class="infoboxnotealso" id="GUID-56FF2C8E-8169-4FBE-B989-689B57F19555__GUID-735C43DD-1F3A-4756-BCCE-1655F545885A">
                              <p class="notep1">也可以看看：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p><a href="bind-define-describe-functions.html#GUID-D28DF5A7-3C75-4E52-82F7-A5D6D5714E69" title="在SQL语句或PL / SQL块中创建程序变量和占位符之间的关联。">OCIBindByPos（）</a>或<a href="bind-define-describe-functions.html#GUID-5C505821-323D-473D-825B-448C8D9A6702" title="在SQL语句或PL / SQL块中创建程序变量和占位符之间的关联。当客户端上的实际长度超过UB2MAXVAL时，在处理数据类型时使用此调用。">OCIBindByPos2（）</a></p>
                                 </li>
                                 <li>
                                    <p><a href="bind-define-describe-functions.html#GUID-CD63DF78-2178-4727-A896-B9673C4A37F0" title="在SQL语句或PL / SQL块中创建程序变量和占位符之间的关联。">OCIBindByName（）</a>或<a href="bind-define-describe-functions.html#GUID-55C47708-5468-4106-89BE-1AB60861D037" title="在SQL语句或PL / SQL块中创建程序变量和占位符之间的关联。当客户端上的实际长度超过UB2MAXVAL时，在处理数据类型时使用此函数。">OCIBindByName2（）</a></p>
                                 </li>
                              </ul>
                           </div>
                        </div>
                     </div>
                  </div><a id="LNOCI16421"></a><div class="props_rev_3"><a id="GUID-FAF088BA-9679-4F37-BF20-835ACFB1A0D4" name="GUID-FAF088BA-9679-4F37-BF20-835ACFB1A0D4"></a><h5 id="LNOCI-GUID-FAF088BA-9679-4F37-BF20-835ACFB1A0D4" class="sect5"><span class="enumeration_section">7.8.3.4</span>定义期间的约束检查</h5>
                     <div>
                        <p>要从列中选择数据到客户端缓冲区，OCI使用已定义的变量。</p>
                        <p>您可以在定义缓冲区上设置<code class="codeph">OCI_ATTR_MAXCHAR_SIZE</code>值，以施加额外的字符长度约束。定义句柄没有<code class="codeph">OCI_ATTR_MAXDATA_SIZE</code>属性，因为以字节为单位的缓冲区大小用作字节长度的限制。<code class="codeph">OCIDefineByPos()</code>或<code class="codeph">OCIDefineByPos2()</code>调用中提供的定义缓冲区大小可用作字节约束。
                        </p>
                        <div class="p">本节包括以下主题：<ul style="list-style-type:disc">
                              <li>
                                 <p><a href="binding-and-defining-in-oci.html#GUID-9E12F114-E52B-4391-AEBF-5FDEE9FBD717" title="在为动态SQL调整缓冲区大小时，请始终在隐式描述中使用OCI_ATTR_DATA_SIZE值，以避免通过截断丢失数据。">动态SQL选择</a></p>
                              </li>
                              <li>
                                 <p><a href="binding-and-defining-in-oci.html#GUID-82E3AA34-D90E-4829-83D2-57D564B23AD9" title="无论数据库的字符长度语义如何，以下返回长度值始终以字节为单位。">返回长度</a></p>
                              </li>
                           </ul>
                        </div>
                        <div class="infoboxnotealso" id="GUID-FAF088BA-9679-4F37-BF20-835ACFB1A0D4__GUID-E96B8E41-1A9C-48B7-8FD3-C1C58C1ACE7C">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="bind-define-describe-functions.html#GUID-CFE5AA54-DEBC-42D3-8A27-AFF1E7815691" title="将选择列表中的项与类型和输出数据缓冲区相关联。">OCIDefineByPos（）</a>或<a href="bind-define-describe-functions.html#GUID-74939FB5-919E-4D24-B327-AFB532435061" title="将选择列表中的项与类型和输出数据缓冲区相关联。当客户端上的实际长度超过UB2MAXVAL时，在处理数据类型时使用此调用。">OCIDefineByPos2（）</a></p>
                        </div>
                     </div><a id="LNOCI16422"></a><div class="props_rev_3"><a id="GUID-9E12F114-E52B-4391-AEBF-5FDEE9FBD717" name="GUID-9E12F114-E52B-4391-AEBF-5FDEE9FBD717"></a><h6 id="LNOCI-GUID-9E12F114-E52B-4391-AEBF-5FDEE9FBD717" class="sect6"><span class="enumeration_section">7.8.3.4.1</span>动态SQL选择</h6>
                        <div>
                           <p>在为动态SQL调整缓冲区大小时，请始终在隐式描述中使用<code class="codeph">OCI_ATTR_DATA_SIZE</code>值，以避免通过截断丢失数据。
                           </p>
                           <p>如果使用通过<code class="codeph">OCI_ATTR_CHAR_USED</code>属性已知的字符长度语义创建数据库列，则可以使用<code class="codeph">OCI_ATTR_MAXCHAR_SIZE</code>值在定义缓冲区上设置其他约束。最大数量的<code class="codeph">OCI_ATTR_MAXCHAR_SIZE</code>字符放在缓冲区中。
                           </p>
                        </div>
                     </div><a id="LNOCI16423"></a><div class="props_rev_3"><a id="GUID-82E3AA34-D90E-4829-83D2-57D564B23AD9" name="GUID-82E3AA34-D90E-4829-83D2-57D564B23AD9"></a><h6 id="LNOCI-GUID-82E3AA34-D90E-4829-83D2-57D564B23AD9" class="sect6"><span class="enumeration_section">7.8.3.4.2</span>返回长度</h6>
                        <div>
                           <p>无论数据库的字符长度语义如何，以下返回长度值始终以字节为单位。</p>
                           <p></p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">alen</code>返回的值，或绑定和定义的实际长度字段</p>
                              </li>
                              <li>
                                 <p>长度中显示的值，以特殊数据类型为前缀，例如<code class="codeph">VARCHAR</code>和<code class="codeph">LONG</code> <code class="codeph">VARCHAR</code></p>
                              </li>
                              <li>
                                 <p>截断情况下指示符变量的值</p>
                              </li>
                           </ul>
                           <p>此规则的唯一例外是<code class="codeph">OCI_UTF16ID</code>字符集ID中的字符串缓冲区;那么返回长度是UTF-16单位。
                           </p>
                           <div class="infoboxnote" id="GUID-82E3AA34-D90E-4829-83D2-57D564B23AD9__GUID-912F8380-D006-42A7-B556-F64CE19063E8">
                              <p class="notep1">注意：</p>
                              <p>bind和define中的缓冲区大小以及<code class="codeph">OCIStmtGetPieceInfo()</code>和<code class="codeph">OCIStmtSetPieceInfo()</code>的块大小以及回调始终以字节为单位。
                              </p>
                           </div>
                           <div class="infoboxnotealso" id="GUID-82E3AA34-D90E-4829-83D2-57D564B23AD9__GUID-968D10B6-3931-4A46-9AFE-D577EE601C18">
                              <p class="notep1">也可以看看：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p><a href="statement-functions.html#GUID-3D9B5C7B-E2A1-485D-852C-2434F303EC11" title="返回分段操作的片段信息。">OCIStmtGetPieceInfo（）</a></p>
                                 </li>
                                 <li>
                                    <p><a href="statement-functions.html#GUID-CDB6F3E3-0FB6-49A7-A8AE-83CD330A359F" title="设置分段操作的片段信息。">OCIStmtSetPieceInfo（）</a></p>
                                 </li>
                              </ul>
                           </div>
                        </div>
                     </div>
                  </div><a id="LNOCI16424"></a><div class="props_rev_3"><a id="GUID-E1932F9D-9ADB-487F-A566-9C1AE05E66B8" name="GUID-E1932F9D-9ADB-487F-A566-9C1AE05E66B8"></a><h5 id="LNOCI-GUID-E1932F9D-9ADB-487F-A566-9C1AE05E66B8" class="sect5"><span class="enumeration_section">7.8.3.5</span> OCI中字符长度语义的一般兼容性问题</h5>
                     <div>
                        <p>OCI中的字符长度语义取决于Oracle数据库版本9.0或更高版本与版本8.1或更早版本。</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>对于与版本8.1或更早版本的Oracle数据库通信的9.0版或更高版本客户端，Oracle数据库不知道<code class="codeph">OCI_ATTR_MAXCHAR_SIZE</code> ，因此忽略此值。如果仅指定此值，则OCI将根据客户端字符集的每个字符的最大字节数派生相应的<code class="codeph">OCI_ATTR_MAXDATA_SIZE</code>值。
                              </p>
                           </li>
                           <li>
                              <p>对于与版本9.0或更高版本的Oracle数据库通信的版本8.1或更早版本的客户端，客户端永远不能指定<code class="codeph">OCI_ATTR_MAXCHAR_SIZE</code>值，因此Oracle数据库认为客户端始终期望字节长度语义。这类似于客户端仅指定<code class="codeph">OCI_ATTR_MAXDATA_SIZE</code> 。</p>
                           </li>
                        </ul>
                        <p>因此，在这两种情况下，Oracle数据库和客户端都可以以适当的方式交换信息。</p>
                        <div class="p">本节包括以下主题：<ul style="list-style-type:disc">
                              <li>
                                 <p><a href="binding-and-defining-in-oci.html#GUID-2E152341-A00A-466E-82FE-1682449E6B53" title="通过指定N个字符创建列时，数据库中的实际分配会考虑最坏的情况。">使用OCI_ATTR_MAXCHAR_SIZE插入和选择的代码示例</a></p>
                              </li>
                              <li>
                                 <p><a href="binding-and-defining-in-oci.html#GUID-D8C1F818-13E4-4695-8A84-CCE70A757076" title="可以设置CHAR或VARCHAR2的绑定和定义中的字符集ID，或者设置为NCHAR或NVARCHAR2变体句柄中的字符集ID，以假定所有数据都以UTF-16（Unicode）编码传递。要指定UTF-16，请设置OCI_ATTR_CHARSET_ID = OCI_UTF16ID。">UTF-16绑定和定义的代码示例</a></p>
                              </li>
                           </ul>
                        </div>
                     </div><a id="LNOCI72623"></a><a id="LNOCI16425"></a><div class="props_rev_3"><a id="GUID-2E152341-A00A-466E-82FE-1682449E6B53" name="GUID-2E152341-A00A-466E-82FE-1682449E6B53"></a><h6 id="LNOCI-GUID-2E152341-A00A-466E-82FE-1682449E6B53" class="sect6"><span class="enumeration_section">7.8.3.5.1</span>使用OCI_ATTR_MAXCHAR_SIZE插入和选择的代码示例</h6>
                        <div>
                           <p>通过指定<code class="codeph">N</code>个字符创建列时，数据库中的实际分配会考虑最坏的情况。
                           </p>
                           <p>这在<a href="binding-and-defining-in-oci.html#GUID-2E152341-A00A-466E-82FE-1682449E6B53__CIHICCAH">例7-19中显示</a> 。分配的实际字节数是<code class="codeph">N</code>的倍数，比如<code class="codeph">M</code>乘以<code class="codeph">N</code>目前， <code class="codeph">M</code>是3，作为UTF-8中为每个字符分配的最大字节数。
                           </p>
                           <p>例如，在<a href="binding-and-defining-in-oci.html#GUID-2E152341-A00A-466E-82FE-1682449E6B53__CIHICCAH">示例7-19中</a> ，在<code class="codeph">EMP</code>表中， <code class="codeph">ENAME</code>列定义为30个字符， <code class="codeph">ADDRESS</code>列定义为80个字符。因此，数据库中的相应字节长度分别为M * 30或3 * 30 = 90，并且M * 80或3 * 80 = 240。
                           </p>
                           <div class="example" id="GUID-2E152341-A00A-466E-82FE-1682449E6B53__CIHICCAH">
                              <p class="titleinexample">示例7-19使用OCI_ATTR_MAXCHAR_SIZE属性插入和选择操作</p><pre class="oac_no_warn" dir="ltr">...utext ename [31]，地址[81]; / * E'&lt;= 30 + 1，D'&lt;= 80 + 1，考虑到空终止* / sb4 ename_max_chars = EC = 20，address_max_chars = ED = 60; / * EC &lt;=（E' -  1），ED &lt;=（D' -  1）* / sb4 ename_max_bytes = EB = 80，address_max_bytes = DB = 200; / * EB &lt;= M * EC，DB &lt;= M * DC * / text * insstmt =（text *）“INSERT INTO EMP（ENAME，ADDRESS）VALUES（：ENAME，\：ADDRESS）”; text * selstmt =（text *）“SELECT ENAME，ADDRESS FROM EMP”; .../ *插入列数据* / OCIStmtPrepare（stmthp1，errhp，insstmt，（ub4）strlen（（char *）insstmt），（ub4）OCI_NTV_SYNTAX，（ub4）OCI_DEFAULT）; OCIBindByName（stmthp1，＆bnd1p，errhp，（text *）“：ENAME”，（sb4）strlen（（char *）“：ENAME”），（void *）ename，sizeof（ename），SQLT_STR，（void *）＆insname_ind ，（ub2 *）alenp，（ub2 *）rcodep，（ub4）maxarr_len，（ub4 *）curelep，OCI_DEFAULT）; / * * / OCIAttrSet（（void *）bnd1p，（ub4）OCI_HTYPE_BIND，（void *）＆ename_max_bytes，（ub4）0，（ub4）OCI_ATTR_MAXDATA_SIZE，errhp）; / *或* / OCIAttrSet（（void *）bnd1p，（ub4）OCI_HTYPE_BIND，（void *）＆ename_max_chars，（ub4）0，（ub4）OCI_ATTR_MAXCHAR_SIZE，errhp）; .../ *检索列数据* / OCIStmtPrepare（stmthp2，errhp，selstmt，strlen（（char *）selstmt），（ub4）OCI_NTV_SYNTAX，（ub4）OCI_DEFAULT）; OCIDefineByPos（stmthp2，＆dfn1p，errhp，（ub4）1，（void *）ename，（sb4）sizeof（ename），SQLT_STR，（void *）＆selname_ind，（ub2 *）alenp，（ub2 *）rcodep，（ub4） OCI_DEFAULT）; / *如果没有调用，则字节语义默认为* / OCIAttrSet（（void *）dfn1p，（ub4）OCI_HTYPE_DEFINE，（void *）＆ename_max_chars，（ub4）0，（ub4）OCI_ATTR_MAXCHAR_SIZE，errhp）; ...
</pre></div>
                           <!-- class="example" -->
                        </div>
                     </div><a id="LNOCI72624"></a><a id="LNOCI16426"></a><div class="props_rev_3"><a id="GUID-D8C1F818-13E4-4695-8A84-CCE70A757076" name="GUID-D8C1F818-13E4-4695-8A84-CCE70A757076"></a><h6 id="LNOCI-GUID-D8C1F818-13E4-4695-8A84-CCE70A757076" class="sect6"><span class="enumeration_section">7.8.3.5.2</span> UTF-16绑定和定义的代码示例</h6>
                        <div>
                           <p>可以设置<code class="codeph">CHAR</code>或<code class="codeph">VARCHAR2</code>绑定和定义中的字符集ID，或者设置为<code class="codeph">NCHAR</code>或<code class="codeph">NVARCHAR2</code>变体句柄中的字符集ID，以假定所有数据都以UTF-16（Unicode）编码传递。要指定UTF-16，请设置<code class="codeph">OCI_ATTR_CHARSET_ID</code> = <code class="codeph">OCI_UTF16ID</code> 。</p>
                           <p>OCI提供了一个名为的typedef <span class="italic"></span> <code class="codeph">utext</code> <span class="italic"> </span>便于绑定和定义UTF-16数据。<code class="codeph">utext</code>的内部表示是一个16位无符号整数<code class="codeph">ub2</code> 。<code class="codeph">wchar_t</code>数据类型的编码方案符合UTF-16的<code class="codeph">utext</code>可以轻松地将<code class="codeph">utext</code>转换为<code class="codeph">wchar_t</code> <code class="codeph"> </code>使用强制运算符的数据类型
                           </p>
                           <p>即使对于UTF-16数据，也假定bind和define调用中的缓冲区大小以字节为单位。用户应使用<code class="codeph">utext</code>数据类型作为输入和输出数据的缓冲区。
                           </p>
                           <p><a href="binding-and-defining-in-oci.html#GUID-D8C1F818-13E4-4695-8A84-CCE70A757076__CIHDCJAF">例7-20</a>显示了伪代码，它说明了绑定并定义了UTF-16数据。
                           </p>
                           <div class="example" id="GUID-D8C1F818-13E4-4695-8A84-CCE70A757076__CIHDCJAF">
                              <p class="titleinexample">例7-20绑定和定义UTF-16数据</p><pre class="oac_no_warn" dir="ltr">...OCIStmt * stmthp1，* stmthp2; OCIDefine * dfn1p，* dfn2p; OCIBind * bnd1p，* bnd2p; text * insstmt =（text *）“INSERT INTO EMP（ENAME，ADDRESS）VALUES（：ename，：address）”; \ text * selname =（text *）“SELECT ENAME，ADDRESS FROM EMP”; utext ename [21]; / *名称 -  UTF-16 * / utext地址[51]; / *地址 -  UTF-16 * / ub2 csid = OCI_UTF16ID; sb4 ename_col_len = 20; sb4 address_col_len = 50; .../ *插入UTF-16数据* / OCIStmtPrepare（stmthp1，errhp，insstmt，（ub4）strlen（（char *）insstmt），（ub4）OCI_NTV_SYNTAX，（ub4）OCI_DEFAULT）; OCIBindByName（stmthp1，＆bnd1p，errhp，（text *）“：ENAME”，（sb4）strlen（（char *）“：ENAME”），（void *）ename，sizeof（ename），SQLT_STR，（void *）＆insname_ind ，（ub2 *）0，（ub2 *）0，（ub4）0，（ub4 *）0，OCI_DEFAULT）; OCIAttrSet（（void *）bnd1p，（ub4）OCI_HTYPE_BIND，（void *）＆csid，（ub4）0，（ub4）OCI_ATTR_CHARSET_ID，errhp）; OCIAttrSet（（void *）bnd1p，（ub4）OCI_HTYPE_BIND，（void *）＆ename_col_len，（ub4）0，（ub4）OCI_ATTR_MAXDATA_SIZE，errhp）; .../ *检索UTF-16数据* / OCIStmtPrepare（stmthp2，errhp，selname，strlen（（char *）selname），（ub4）OCI_NTV_SYNTAX，（ub4）OCI_DEFAULT）; OCIDefineByPos（stmthp2，＆dfn1p，errhp，（ub4）1，（void *）ename，（sb4）sizeof（ename），SQLT_STR，（void *）0，（ub2 *）0，（ub2 *）0，（ub4） OCI_DEFAULT）; OCIAttrSet（（void *）dfn1p，（ub4）OCI_HTYPE_DEFINE，（void *）＆csid，（ub4）0，（ub4）OCI_ATTR_CHARSET_ID，errhp）; ...
</pre><div class="infoboxnotealso" id="GUID-D8C1F818-13E4-4695-8A84-CCE70A757076__GUID-667CCB29-4741-48BE-8E53-FC0EC1D48C83">
                                 <p class="notep1">也可以看看：</p>
                                 <p><a href="handle-and-descriptor-attributes.html#GUID-01C53C14-CD15-4A8B-9EFF-86996282F3BD" title="列出并描述绑定句柄属性。">绑定句柄属性</a></p>
                              </div>
                           </div>
                           <!-- class="example" -->
                        </div>
                     </div>
                  </div>
               </div>
            </div><a id="LNOCI72625"></a><a id="LNOCI72626"></a><a id="LNOCI16427"></a><div class="props_rev_3"><a id="GUID-5495CEEB-17D0-4185-8879-3356A21E7888" name="GUID-5495CEEB-17D0-4185-8879-3356A21E7888"></a><h3 id="LNOCI-GUID-5495CEEB-17D0-4185-8879-3356A21E7888" class="sect3"><span class="enumeration_section">7.9</span> OCI中的PL / SQL REF CURSOR和嵌套表</h3>
               <div>
                  <p>OCI提供绑定和定义PL / SQL <code class="codeph">REF</code> <code class="codeph">CURSOR</code>和嵌套表的功能。
                  </p>
                  <p>应用程序可以使用语句句柄来绑定和定义这些类型的变量。例如，考虑这个PL / SQL块：</p><pre class="oac_no_warn" dir="ltr">static const text * plsql_block =（text *）“begin \ OPEN：cursor1 FOR SELECT employee_id，last_name，job_id，manager_id，\ salary，department_id \ FROM employees WHERE job_id =：job ORDER BY employee_id; \ OPEN：cursor2 FOR SELECT * FROM部门ORDER BY department_id;结束;“;</pre><p>应用程序通过调用<code class="codeph">OCIHandleAlloc()</code>为绑定分配语句句柄，然后将<code class="codeph">:cursor1</code>占位符绑定到语句句柄，如下面的代码所示，其中<code class="codeph">:cursor1</code>绑定到<code class="codeph">stm2p</code> 。
                  </p>
                  <p>在<a href="binding-and-defining-in-oci.html#GUID-5495CEEB-17D0-4185-8879-3356A21E7888__CIHGGCFF">例7-21的</a>代码中， <code class="codeph">stm1p</code>是PL / SQL块的语句句柄，而<code class="codeph">stm2p</code>是绑定为<code class="codeph">REF</code> <code class="codeph">CURSOR</code>的语句句柄，用于以后的数据检索。为<code class="codeph">dty</code>参数传递<code class="codeph">SQLT_RSET</code>的值。
                  </p>
                  <p>作为另一个例子，请考虑以下事项：</p><pre class="oac_no_warn" dir="ltr">static const text * nst_tab =（text *）“SELECT last_name，CURSOR（SELECT department_name，location_id \ FROM departments）FROM employees WHERE last_name ='FORD'”;</pre><p>第二个位置是嵌套表，OCI应用程序可以将其定义为<a href="binding-and-defining-in-oci.html#GUID-5495CEEB-17D0-4185-8879-3356A21E7888__CIHDFFHJ">示例7-22中</a>所示的语句句柄。
                  </p>
                  <p>执行后，当你向<code class="codeph">stm2p</code>取一行时，它就成了一个有效的语句句柄。
                  </p>
                  <div class="infoboxnote" id="GUID-5495CEEB-17D0-4185-8879-3356A21E7888__GUID-14683F15-E832-4F02-8A31-BF6F8D29AA56">
                     <p class="notep1">注意：</p>
                     <p>如果您已检索到多个<code class="codeph">REF</code> <code class="codeph">CURSOR</code> ，则在将它们提取到<code class="codeph">stm2p</code>时必须小心。如果您获取第一个，则可以对其执行提取以检索其数据。但是，在将第二个<code class="codeph">REF</code> <code class="codeph">CURSOR</code>提取到<code class="codeph">stm2p</code> ，您将无法再访问第一个<code class="codeph">REF</code> <code class="codeph">CURSOR</code>的数据。</p>
                     <p>OCI不支持以可滚动模式执行的PL / SQL <code class="codeph">REF</code> <code class="codeph">CURSOR</code> 。
                     </p>
                     <p>OCI不支持可滚动的<code class="codeph">REF</code> <code class="codeph">CURSOR</code>因为您无法回滚到已由<code class="codeph">REF</code> <code class="codeph">CURSOR</code>提取的行。</p>
                  </div>
                  <div class="example" id="GUID-5495CEEB-17D0-4185-8879-3356A21E7888__CIHGGCFF">
                     <p class="titleinexample">例7-21将：cursor1占位符绑定到Statement Handle stm2p作为REF CURSOR</p><pre class="oac_no_warn" dir="ltr">status = OCIStmtPrepare（stm1p，errhp，（text *）plsql_block，strlen（（char *）plsql_block），OCI_NTV_SYNTAX，OCI_DEFAULT）; ...status = OCIBindByName（stm1p，（OCIBind **）＆bnd1p，errhp，（text *）“：cursor1”，（sb4）strlen（（char *）“：cursor1”），（void *）＆stm2p，（sb4）0， SQLT_RSET，（void *）0，（ub2 *）0，（ub2 *）0，（ub4）0，（ub4 *）0，（ub4）OCI_DEFAULT）;</pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-5495CEEB-17D0-4185-8879-3356A21E7888__CIHDFFHJ">
                     <p class="titleinexample">示例7-22将嵌套表（第二个位置）定义为语句句柄</p><pre class="oac_no_warn" dir="ltr">status = OCIStmtPrepare（stm1p，errhp，（text *）nst_tab，strlen（（char *）nst_tab），OCI_NTV_SYNTAX，OCI_DEFAULT）; ...status = OCIDefineByPos（stm1p，（OCIDefine **）＆dfn2p，errhp，（ub4）2，（void *）＆stm2p，（sb4）0，SQLT_RSET，（void *）0，（ub2 *）0，（ub2 *）0 ，（ub4）OCI_DEFAULT）;</pre></div>
                  <!-- class="example" -->
                  <div class="section">
                     <div class="infoboxnotealso" id="GUID-5495CEEB-17D0-4185-8879-3356A21E7888__GUID-7B908F49-350D-4675-BBB7-3D9A403A8B8C">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="handle-and-descriptor-functions.html#GUID-C5BF55F7-A110-4CB5-9663-5056590F12B5" title="返回指向已分配和初始化句柄的指针。">OCIHandleAlloc（）</a></p>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div>
            </div><a id="LNOCI73038"></a><div class="props_rev_3"><a id="GUID-9DEC9ACB-BC16-4F4C-8EC6-E43EC47EF9CB" name="GUID-9DEC9ACB-BC16-4F4C-8EC6-E43EC47EF9CB"></a><h3 id="LNOCI-GUID-9DEC9ACB-BC16-4F4C-8EC6-E43EC47EF9CB" class="sect3"><span class="enumeration_section">7.10</span>本地描述和绑定包括包类型的所有PL / SQL类型</h3>
               <div>
                  <p>从Oracle Database Release 12.1开始，OCI客户端支持本机描述和绑定所有PL / SQL类型的能力。</p>
                  <p>这包括基本标量类型Boolean，以前不支持作为绑定类型。这还包括在PL / SQL包中声明的类型，例如在PL / SQL包规范内声明的命名记录或集合类型（包括嵌套表，varray和索引表）或隐式记录子类型（％rowtype）。对这些功能的本机支持意味着客户端只能使用提供的客户端API来描述和绑定PL / SQL类型。</p>
                  <p><a href="data-types.html#GUID-65066795-6F95-44AE-A454-31CF70A46A1F__G454481" title="该表有2列。第1列是值，第2列是其对应的数据类型。">表5-10</a>列出了这些数据类型的PL / SQL类型代码（Boolean，record，index-by <code class="codeph">BINARY_INTEGER</code>和<code class="codeph">PLS_INTEGER</code>或<code class="codeph">BINARY_INTEGER</code> ）。<a href="data-types.html#GUID-DCC693D9-23D7-4727-9A71-E5FCDABA7136__G454572" title="该表有3列。第1列是Oracle类型系统tymename，第2列是Oracle类型系统类型，第3列是等效的SQLT类型。">表5-11中</a>列出了这些PL / SQL类型代码的等效<code class="codeph">SQLT</code>类型。客户端必须使用相应的<code class="codeph">SQLT</code>类型的指定值作为绑定的DTY来绑定指定的类型。例如，对于记录，客户端必须使用<code class="codeph">SQLT_NTY</code>绑定包记录类型（ <code class="codeph">OCI_TYPECODE_RECORD</code> ）作为绑定的DTY;对于集合，客户端必须使用<code class="codeph">SQLT_NTY</code>绑定所有包集合类型（ <code class="codeph">OCI_TYPECODE_ITABLE</code> ）作为绑定的DTY;对于布尔值，客户端必须使用<code class="codeph">SQLT_BOL</code>绑定布尔类型（ <code class="codeph">OCI_TYPECODE_BOOLEAN</code> ）作为绑定的DTY。绑定API： <code class="codeph">OCIBindByName()</code> ， <code class="codeph">OCIBindByName2()</code> ， <code class="codeph">OCIBindByPos()</code>和<code class="codeph">OCIBindByPos2()</code>支持表示这些PL / SQL类型代码的绑定的DTY中的每个<code class="codeph">SQLT</code>类型值。
                  </p>
                  <div class="infoboxnotealso" id="GUID-9DEC9ACB-BC16-4F4C-8EC6-E43EC47EF9CB__GUID-2985B502-D0CA-4ACA-8CF7-29E3CD677E00">
                     <p class="notep1">也可以看看：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="bind-define-describe-functions.html#GUID-CD63DF78-2178-4727-A896-B9673C4A37F0" title="在SQL语句或PL / SQL块中创建程序变量和占位符之间的关联。">OCIBindByName（）</a>或<a href="bind-define-describe-functions.html#GUID-55C47708-5468-4106-89BE-1AB60861D037" title="在SQL语句或PL / SQL块中创建程序变量和占位符之间的关联。当客户端上的实际长度超过UB2MAXVAL时，在处理数据类型时使用此函数。">OCIBindByName2（）</a></p>
                        </li>
                        <li>
                           <p><a href="bind-define-describe-functions.html#GUID-D28DF5A7-3C75-4E52-82F7-A5D6D5714E69" title="在SQL语句或PL / SQL块中创建程序变量和占位符之间的关联。">OCIBindByPos（）</a>或<a href="bind-define-describe-functions.html#GUID-5C505821-323D-473D-825B-448C8D9A6702" title="在SQL语句或PL / SQL块中创建程序变量和占位符之间的关联。当客户端上的实际长度超过UB2MAXVAL时，在处理数据类型时使用此调用。">OCIBindByPos2（）</a></p>
                        </li>
                     </ul>
                  </div>
               </div>
            </div><a id="LNOCI059"></a><div class="props_rev_3"><a id="GUID-6C5EA0C6-0C1D-4CD5-B47F-1B95B4E9C558" name="GUID-6C5EA0C6-0C1D-4CD5-B47F-1B95B4E9C558"></a><h3 id="LNOCI-GUID-6C5EA0C6-0C1D-4CD5-B47F-1B95B4E9C558" class="sect3"><span class="enumeration_section">7.11</span> OCI中的运行时数据分配和分段操作</h3>
               <div>
                  <p>您可以使用OCI执行分段插入，更新和数据提取。</p>
                  <p>您还可以使用OCI在数组插入或更新的情况下动态提供数据，而不是提供绑定值的静态数组。您可以将一个非常大的列插入或检索为一系列较小的块，从而最大限度地减少客户端内存需求。</p>
                  <p>各个部件的尺寸由应用程序在运行时确定，并且可以是均匀的或不均匀的。</p>
                  <p>当对极大的字符串或二进制数据块执行操作时，OCI的分段功能特别有用，涉及存储<code class="codeph">CLOB</code> ， <code class="codeph">BLOB</code> ， <code class="codeph">LONG</code> ， <code class="codeph">RAW</code>或<code class="codeph">LONG</code> <code class="codeph">RAW</code>数据的数据库列的操作。
                  </p>
                  <p>当最终的<code class="codeph">OCIStmtFetch2()</code>调用返回值OCI_SUCCESS时，分段提取完成。</p>
                  <p>在分段提取和插入中，了解操作成功完成所需的调用顺序非常重要。对于分段插入，必须调用<code class="codeph">OCIStmtExecute()</code>一次，而不是要插入的块数（如果不使用回调）。这是因为第一次<code class="codeph">OCIStmtExecute()</code> ，它返回一个值，指示需要插入的第一个部分。因此，如果要插入<span class="italic">n个</span>片段，则必须调用<code class="codeph">OCIStmtExecute()</code>总共<span class="italic">n + 1</span>次。
                  </p>
                  <p>类似地，在执行分段提取时，必须调用<code class="codeph">OCIStmtFetch2()</code>一次，而不是要提取的数量。
                  </p>
                  <div class="p">本节包括以下主题：<ul style="list-style-type:disc">
                        <li>
                           <p><a href="binding-and-defining-in-oci.html#GUID-DF7EC112-B81D-4B69-885D-5C5A59FB08D7" title="只能处理一些数据类型。">分段操作的有效数据类型</a></p>
                        </li>
                        <li>
                           <p><a href="binding-and-defining-in-oci.html#GUID-0A316448-D51E-4BC6-B7DB-747D596D4783" title="有什么方法可以执行分段操作。">分段操作的类型</a></p>
                        </li>
                        <li>
                           <p><a href="binding-and-defining-in-oci.html#GUID-0C9C1F54-E65C-442F-9BD6-67D14124EBF5" title="在对OCIBindByPos（）或OCIBindByPos2（）或OCIBindByName（）或OCIBindByName2（）的调用中指定OCI_DATA_AT_EXEC模式时，value_sz参数定义可在运行时提供的数据的总大小。">关于在运行时提供INSERT或UPDATE数据</a></p>
                        </li>
                        <li>
                           <p><a href="binding-and-defining-in-oci.html#GUID-A18B68AC-7731-4826-9EFC-3C750C19B759" title="OCI应用程序可以使用PL / SQL对IN，OUT和IN / OUT绑定变量执行分段操作，其方法类似于前面概述的方法。">使用PL / SQL进行分段操作</a></p>
                        </li>
                        <li>
                           <p><a href="binding-and-defining-in-oci.html#GUID-9603C427-3A19-4607-A62E-0AD06621CC17" title="可以使用OCI将IN / OUT绑定到PL / SQL匿名块中，从而传递PL / SQL索引表。">PL / SQL索引表绑定支持</a></p>
                        </li>
                        <li>
                           <p><a href="binding-and-defining-in-oci.html#GUID-25BBA0D1-689D-40FD-86E1-A10D02A3E4BB" title="当调用OCIDefineByPos（）或OCIDefineByPos2（）并将mode参数设置为OCI_DYNAMIC_FETCH时，应用程序可以在获取时指定有关数据缓冲区的信息。">关于在运行时提供FETCH信息</a></p>
                        </li>
                        <li>
                           <p><a href="binding-and-defining-in-oci.html#GUID-9E60B14E-920F-42E6-904D-36BAF20FDA3D" title="对LOB进行分段绑定和定义的方法有哪些。">分段绑定和定义LOB</a></p>
                        </li>
                     </ul>
                  </div>
                  <div class="infoboxnotealso" id="GUID-6C5EA0C6-0C1D-4CD5-B47F-1B95B4E9C558__GUID-F9DBFA97-221D-484F-B2EE-8157E43B3622">
                     <p class="notep1">也可以看看：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="statement-functions.html#GUID-DF585B90-58BA-45FC-B7CE-6F7F987C03B9" title="从（可滚动）结果集中获取一行。">OCIStmtFetch2（）</a></p>
                        </li>
                        <li>
                           <p><a href="statement-functions.html#GUID-98B26708-3E02-45C0-8258-5D5544F32BE9" title="将应用程序请求与服务器关联。">OCIStmtExecute（）</a></p>
                        </li>
                     </ul>
                  </div>
               </div><a id="LNOCI16428"></a><div class="props_rev_3"><a id="GUID-DF7EC112-B81D-4B69-885D-5C5A59FB08D7" name="GUID-DF7EC112-B81D-4B69-885D-5C5A59FB08D7"></a><h4 id="LNOCI-GUID-DF7EC112-B81D-4B69-885D-5C5A59FB08D7" class="sect4"><span class="enumeration_section">7.11.1</span>分段操作的有效数据类型</h4>
                  <div>
                     <p>只能处理一些数据类型。</p>
                     <p>OCI应用程序可以执行以下所有数据类型的分段提取，插入或更新：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">VARCHAR2</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">串</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">长</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">LONG</code> <code class="codeph">RAW</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">生的</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">CLOB</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">BLOB</code></p>
                        </li>
                     </ul>
                     <p>将此功能用于所有数据类型的另一种方法是动态提供数据插入或更新的数据。对于不支持分段操作的数据类型，回调应始终为回调的<code class="codeph">piecep</code>参数指定<code class="codeph">OCI_ONE_PIECE</code> 。
                     </p>
                  </div>
               </div><a id="LNOCI16429"></a><div class="props_rev_3"><a id="GUID-0A316448-D51E-4BC6-B7DB-747D596D4783" name="GUID-0A316448-D51E-4BC6-B7DB-747D596D4783"></a><h4 id="LNOCI-GUID-0A316448-D51E-4BC6-B7DB-747D596D4783" class="sect4"><span class="enumeration_section">7.11.2</span>分段操作的类型</h4>
                  <div>
                     <p>有什么方法可以执行分段操作。</p>
                     <p>您可以通过两种方式执行分段操作：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>使用OCI库中提供的调用在轮询范例下执行分段操作。</p>
                        </li>
                        <li>
                           <p>使用用户定义的回调函数来提供必要的信息和数据块。</p>
                        </li>
                     </ul>
                     <p>当您将<code class="codeph">OCIBindByPos()</code>或<code class="codeph">OCIBindByPos2()</code>或<code class="codeph">OCIBindByName()</code>或<code class="codeph">OCIBindByName2()</code>调用的<code class="codeph">mode</code>参数设置为<code class="codeph">OCI_DATA_AT_EXEC</code> ，它指示OCI应用程序在运行时动态地为<code class="codeph">INSERT</code>或<code class="codeph">UPDATE</code>操作提供数据。
                     </p>
                     <p>类似地，当您将<code class="codeph">OCIDefineByPos()</code>或<code class="codeph">OCIDefineByPos2()</code>调用的<code class="codeph">mode</code>参数设置为<code class="codeph">OCI_DYNAMIC_FETCH</code> ，它指示应用程序动态提供用于在获取时接收数据的分配空间。
                     </p>
                     <p>在每种情况下，您都可以通过以下两种方式之一为<code class="codeph">INSERT</code> ， <code class="codeph">UPDATE</code>或<code class="codeph">FETCH</code>操作提供运行时信息：通过回调函数或使用分段操作。如果需要回调，则需要额外的绑定或定义调用来注册回调。
                     </p>
                     <p>以下部分提供有关运行时数据分配和插入，更新和提取的分段操作的特定信息。</p>
                     <div class="infoboxnote" id="GUID-0A316448-D51E-4BC6-B7DB-747D596D4783__GUID-7E8A166F-2100-4EE4-A8CC-90C892CA29D2">
                        <p class="notep1">注意：</p>
                        <p>分段操作对SQL和PL / SQL块也有效。</p>
                     </div>
                     <div class="infoboxnotealso" id="GUID-0A316448-D51E-4BC6-B7DB-747D596D4783__GUID-7845E41E-28ED-48D3-BA3D-5389B7641364">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="bind-define-describe-functions.html#GUID-D28DF5A7-3C75-4E52-82F7-A5D6D5714E69" title="在SQL语句或PL / SQL块中创建程序变量和占位符之间的关联。">OCIBindByPos（）</a>或<a href="bind-define-describe-functions.html#GUID-5C505821-323D-473D-825B-448C8D9A6702" title="在SQL语句或PL / SQL块中创建程序变量和占位符之间的关联。当客户端上的实际长度超过UB2MAXVAL时，在处理数据类型时使用此调用。">OCIBindByPos2（）</a></p>
                           </li>
                           <li>
                              <p><a href="bind-define-describe-functions.html#GUID-CD63DF78-2178-4727-A896-B9673C4A37F0" title="在SQL语句或PL / SQL块中创建程序变量和占位符之间的关联。">OCIBindByName（）</a>或<a href="bind-define-describe-functions.html#GUID-55C47708-5468-4106-89BE-1AB60861D037" title="在SQL语句或PL / SQL块中创建程序变量和占位符之间的关联。当客户端上的实际长度超过UB2MAXVAL时，在处理数据类型时使用此函数。">OCIBindByName2（）</a></p>
                           </li>
                           <li>
                              <p><a href="bind-define-describe-functions.html#GUID-CFE5AA54-DEBC-42D3-8A27-AFF1E7815691" title="将选择列表中的项与类型和输出数据缓冲区相关联。">OCIDefineByPos（）</a>或<a href="bind-define-describe-functions.html#GUID-74939FB5-919E-4D24-B327-AFB532435061" title="将选择列表中的项与类型和输出数据缓冲区相关联。当客户端上的实际长度超过UB2MAXVAL时，在处理数据类型时使用此调用。">OCIDefineByPos2（）</a></p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="LNOCI16430"></a><div class="props_rev_3"><a id="GUID-0C9C1F54-E65C-442F-9BD6-67D14124EBF5" name="GUID-0C9C1F54-E65C-442F-9BD6-67D14124EBF5"></a><h4 id="LNOCI-GUID-0C9C1F54-E65C-442F-9BD6-67D14124EBF5" class="sect4"><span class="enumeration_section">7.11.3</span>关于在运行时提供INSERT或UPDATE数据</h4>
                  <div>
                     <p>在对<code class="codeph">OCIBindByPos()</code>或<code class="codeph">OCIBindByPos2()</code>或<code class="codeph">OCIBindByName()</code>或<code class="codeph">OCIBindByName2()</code>的调用中指定<code class="codeph">OCI_DATA_AT_EXEC</code>模式时， <code class="codeph">value_sz</code>参数定义可在运行时提供的数据的总大小。
                     </p>
                     <p>应用程序必须准备好向OCI库提供运行时<code class="codeph">IN</code>数据缓冲按需完成操作所需的次数。当不再需要分配的缓冲区时，客户端必须释放它们。
                     </p>
                     <p>运行时数据以两种方式之一提供：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>您可以使用<code class="codeph">OCIBindDynamic()</code>函数定义回调，该函数在运行时调用时返回一段数据或全部数据。
                           </p>
                        </li>
                        <li>
                           <p>如果未定义回调，则调用<code class="codeph">OCIStmtExecute()</code>以处理SQL语句将返回<code class="codeph">OCI_NEED_DATA</code>错误代码。然后，客户端应用程序使用<code class="codeph">OCIStmtSetPieceInfo()</code>调用提供<code class="codeph">IN/OUT</code>数据缓冲区或片段，该调用指定正在使用哪个绑定和片段。
                           </p>
                        </li>
                     </ul>
                     <p>本节包括以下主题： <a href="binding-and-defining-in-oci.html#GUID-7673D7A7-C691-451B-8DDE-D21437BFA751" title="初始化OCI环境并建立数据库连接和会话后，分段插入将以调用SQL或PL / SQL语句以及绑定输入值开始。">执行分段插入或更新</a> 。
                     </p>
                     <div class="infoboxnotealso" id="GUID-0C9C1F54-E65C-442F-9BD6-67D14124EBF5__GUID-DA1593BC-F35F-41AD-BDF9-CF8EB6947293">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="bind-define-describe-functions.html#GUID-D28DF5A7-3C75-4E52-82F7-A5D6D5714E69" title="在SQL语句或PL / SQL块中创建程序变量和占位符之间的关联。">OCIBindByPos（）</a>或<a href="bind-define-describe-functions.html#GUID-5C505821-323D-473D-825B-448C8D9A6702" title="在SQL语句或PL / SQL块中创建程序变量和占位符之间的关联。当客户端上的实际长度超过UB2MAXVAL时，在处理数据类型时使用此调用。">OCIBindByPos2（）</a></p>
                           </li>
                           <li>
                              <p><a href="bind-define-describe-functions.html#GUID-CD63DF78-2178-4727-A896-B9673C4A37F0" title="在SQL语句或PL / SQL块中创建程序变量和占位符之间的关联。">OCIBindByName（）</a>或<a href="bind-define-describe-functions.html#GUID-55C47708-5468-4106-89BE-1AB60861D037" title="在SQL语句或PL / SQL块中创建程序变量和占位符之间的关联。当客户端上的实际长度超过UB2MAXVAL时，在处理数据类型时使用此函数。">OCIBindByName2（）</a></p>
                           </li>
                           <li>
                              <p><a href="bind-define-describe-functions.html#GUID-030270CB-346A-412E-B3B3-556DD6947BE2" title="注册用户回调以进行动态数据分配。">OCIBindDynamic（）</a></p>
                           </li>
                           <li>
                              <p><a href="statement-functions.html#GUID-98B26708-3E02-45C0-8258-5D5544F32BE9" title="将应用程序请求与服务器关联。">OCIStmtExecute（）</a></p>
                           </li>
                           <li>
                              <p><a href="statement-functions.html#GUID-CDB6F3E3-0FB6-49A7-A8AE-83CD330A359F" title="设置分段操作的片段信息。">OCIStmtSetPieceInfo（）</a></p>
                           </li>
                        </ul>
                     </div>
                  </div><a id="LNOCI16432"></a><a id="LNOCI16431"></a><div class="props_rev_3"><a id="GUID-7673D7A7-C691-451B-8DDE-D21437BFA751" name="GUID-7673D7A7-C691-451B-8DDE-D21437BFA751"></a><h5 id="LNOCI-GUID-7673D7A7-C691-451B-8DDE-D21437BFA751" class="sect5"><span class="enumeration_section">7.11.3.1</span>执行分段插入或更新</h5>
                     <div>
                        <p>初始化OCI环境并建立数据库连接和会话后，分段插入将以调用SQL或PL / SQL语句以及绑定输入值开始。</p>
                        <div class="section">
                           <p>使用标准OCI调用而不是用户定义的回调的分段操作不需要调用<code class="codeph">OCIBindDynamic()</code> 。
                           </p>
                           <div class="infoboxnote" id="GUID-7673D7A7-C691-451B-8DDE-D21437BFA751__GUID-FB5C166F-ECC1-4CB4-A05F-3E2BB26A3C32">
                              <p class="notep1">注意：</p>
                              <p>不属于分段操作的其他绑定变量可能需要额外的绑定调用，具体取决于其数据类型。</p>
                           </div>
                           <p>在语句准备和绑定之后，应用程序执行一系列对<code class="codeph">OCIStmtExecute()</code> ， <code class="codeph">OCIStmtGetPieceInfo()</code>和<code class="codeph">OCIStmtSetPieceInfo()</code>的调用，以完成分段操作。每次调用<code class="codeph">OCIStmtExecute()</code>返回一个值，该值确定接下来应执行的操作。通常，应用程序检索一个值，指示必须插入下一个片段，使用该片段填充缓冲区，然后执行插入。插入最后一块后，操作完成。
                           </p>
                           <p>请记住，插入缓冲区可以是任意大小，并在运行时提供。另外，每个插入件不需要具有相同的尺寸。要插入的每个部分的大小由每个<code class="codeph">OCIStmtSetPieceInfo()</code>调用建立。
                           </p>
                           <div class="infoboxnote" id="GUID-7673D7A7-C691-451B-8DDE-D21437BFA751__GUID-82F9AB65-3A54-427A-A9EC-4BBB425083C2">
                              <p class="notep1">注意：</p>
                              <p>如果对于所有插入使用相同的块大小，并且插入的数据的大小不能被块大小整除，则最终插入的块预计会更小。您必须通过在最终的<code class="codeph">OCIStmtSetPieceInfo()</code>调用中指示较小的大小来解释此问题。
                              </p>
                           </div>
                           <p>该过程<a href="binding-and-defining-in-oci.html#GUID-7673D7A7-C691-451B-8DDE-D21437BFA751__I440828">如图7-3</a>所示，并在<a href="binding-and-defining-in-oci.html#GUID-7673D7A7-C691-451B-8DDE-D21437BFA751__I440828">图</a>中的步骤中进行了扩展。
                           </p>
                           <div class="figure" id="GUID-7673D7A7-C691-451B-8DDE-D21437BFA751__I440828">
                              <p class="titleinfigure">图7-3执行分段插入</p><img src="img/lnoci025.png" alt="下面是图7-3的描述" title="下面是图7-3的描述" longdesc="img_text/lnoci025.html"><br><a href="img_text/lnoci025.html">“图7-3执行分段插入”的说明</a></div>
                           <!-- class="figure" -->
                        </div>
                        <!-- class="section" -->
                        <ol>
                           <li class="stepexpand"><span>初始化OCI环境，分配必要的句柄，连接到服务器，授权用户，并使用<code class="codeph">OCIStmtPrepare2()</code>准备语句请求。</span></li>
                           <li class="stepexpand"><span>使用<code class="codeph">OCIBindByName()</code>或<code class="codeph">OCIBindByName2()</code>或<code class="codeph">OCIBindByPos()</code>或<code class="codeph">OCIBindByPos2()</code>绑定占位符。您无需指定所用部件的实际大小，但必须提供可在运行时提供的数据的总大小。</span></li>
                           <li class="stepexpand"><span>第一次调用<code class="codeph">OCIStmtExecute()</code> 。此处未插入任何数据，并且<code class="codeph">OCI_NEED_DATA</code>错误代码将返回给应用程序。如果返回任何其他值，则表示发生了错误。</span></li>
                           <li class="stepexpand"><span>调用<code class="codeph">OCIStmtGetPieceInfo()</code>以检索有关必须插入的部分的信息。<code class="codeph">OCIStmtGetPieceInfo()</code>的参数包括指向值的指针，该值指示所需的块是第一块， <code class="codeph">OCI_FIRST_PIECE</code>还是后续块<code class="codeph">OCI_NEXT_PIECE</code> 。</span></li>
                           <li class="stepexpand"><span>应用程序使用要插入的数据填充缓冲区，并使用以下参数调用<code class="codeph">OCIStmtSetPieceInfo()</code> ：</span><div>
                                 <ul style="list-style-type:disc">
                                    <li>
                                       <p>指向这件作品的指针</p>
                                    </li>
                                    <li>
                                       <p>指向作品长度的指针</p>
                                    </li>
                                    <li>
                                       <p>一个值，指示这是第一块（ <code class="codeph">OCI_FIRST_PIECE</code> ），中间块（ <code class="codeph">OCI_NEXT_PIECE</code> ）还是最后一块（ <code class="codeph">OCI_LAST_PIECE</code> ）</p>
                                    </li>
                                 </ul>
                              </div>
                           </li>
                           <li class="stepexpand"><span>再次调用<code class="codeph">OCIStmtExecute()</code> 。如果<code class="codeph">OCI_LAST_PIECE</code>在第5步，并表示<code class="codeph">OCIStmtExecute()</code>返回<code class="codeph">OCI_SUCCESS</code> ，所有片成功插入。如果<code class="codeph">OCIStmtExecute()</code>返回<code class="codeph">OCI_NEED_DATA</code> ，请返回步骤3以进行下一次插入。如果<code class="codeph">OCIStmtExecute()</code>返回任何其他值，则发生错误。</span></li>
                        </ol>
                        <div class="section">
                           <p>成功插入最终作品后，分段操作完成。这由最终<code class="codeph">OCIStmtExecute()</code>调用的<code class="codeph">OCI_SUCCESS</code>返回值指示。
                           </p>
                           <p>分段更新以类似方式执行。在分段更新操作中，插入缓冲区填充有正在更新的数据，并<code class="codeph">OCIStmtExecute()</code>来执行更新。
                           </p>
                           <div class="infoboxnotealso" id="GUID-7673D7A7-C691-451B-8DDE-D21437BFA751__GUID-D40FD163-2463-402E-AD53-13C7FA0104F3">
                              <p class="notep1">也可以看看：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p><a href="oci-programming-basics.html#GUID-83F4D3B1-56A7-4EEE-A905-BB84D399713D" title="OCI呼吁完成民意调查。">OCI中的轮询模式操作</a></p>
                                 </li>
                                 <li>
                                    <p><a href="bind-define-describe-functions.html#GUID-030270CB-346A-412E-B3B3-556DD6947BE2" title="注册用户回调以进行动态数据分配。">OCIBindDynamic（）</a></p>
                                 </li>
                                 <li>
                                    <p><a href="statement-functions.html#GUID-98B26708-3E02-45C0-8258-5D5544F32BE9" title="将应用程序请求与服务器关联。">OCIStmtExecute（）</a></p>
                                 </li>
                                 <li>
                                    <p><a href="statement-functions.html#GUID-3D9B5C7B-E2A1-485D-852C-2434F303EC11" title="返回分段操作的片段信息。">OCIStmtGetPieceInfo（）</a></p>
                                 </li>
                                 <li>
                                    <p><a href="statement-functions.html#GUID-CDB6F3E3-0FB6-49A7-A8AE-83CD330A359F" title="设置分段操作的片段信息。">OCIStmtSetPieceInfo（）</a></p>
                                 </li>
                                 <li>
                                    <p><a href="statement-functions.html#GUID-E6C1DC67-D464-4D2A-9F19-737423D31779" title="准备SQL或PL / SQL语句以便执行。">OCIStmtPrepare2（）</a></p>
                                 </li>
                                 <li>
                                    <p><a href="bind-define-describe-functions.html#GUID-CD63DF78-2178-4727-A896-B9673C4A37F0" title="在SQL语句或PL / SQL块中创建程序变量和占位符之间的关联。">OCIBindByName（）</a>或<a href="bind-define-describe-functions.html#GUID-55C47708-5468-4106-89BE-1AB60861D037" title="在SQL语句或PL / SQL块中创建程序变量和占位符之间的关联。当客户端上的实际长度超过UB2MAXVAL时，在处理数据类型时使用此函数。">OCIBindByName2（）</a></p>
                                 </li>
                                 <li>
                                    <p><a href="bind-define-describe-functions.html#GUID-D28DF5A7-3C75-4E52-82F7-A5D6D5714E69" title="在SQL语句或PL / SQL块中创建程序变量和占位符之间的关联。">OCIBindByPos（）</a>或<a href="bind-define-describe-functions.html#GUID-5C505821-323D-473D-825B-448C8D9A6702" title="在SQL语句或PL / SQL块中创建程序变量和占位符之间的关联。当客户端上的实际长度超过UB2MAXVAL时，在处理数据类型时使用此调用。">OCIBindByPos2（）</a></p>
                                 </li>
                              </ul>
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="LNOCI16433"></a><div class="props_rev_3"><a id="GUID-A18B68AC-7731-4826-9EFC-3C750C19B759" name="GUID-A18B68AC-7731-4826-9EFC-3C750C19B759"></a><h4 id="LNOCI-GUID-A18B68AC-7731-4826-9EFC-3C750C19B759" class="sect4"><span class="enumeration_section">7.11.4</span> PL / SQL的分段操作</h4>
                  <div>
                     <p>OCI应用程序可以使用类似于前面概述的方法，使用PL / SQL对<code class="codeph">IN</code> ， <code class="codeph">OUT</code>和<code class="codeph">IN/OUT</code>绑定变量执行分段操作。
                     </p>
                     <p>请记住，PL / SQL语句中的所有占位符都是绑定的，而不是定义的。对<code class="codeph">OCIBindDynamic()</code>的调用为<code class="codeph">OUT</code>或<code class="codeph">IN/OUT</code>参数指定了适当的回调。
                     </p>
                     <div class="infoboxnotealso" id="GUID-A18B68AC-7731-4826-9EFC-3C750C19B759__GUID-3F5314E5-8AE4-4B05-AB22-1A91B501250C">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="bind-define-describe-functions.html#GUID-030270CB-346A-412E-B3B3-556DD6947BE2" title="注册用户回调以进行动态数据分配。">OCIBindDynamic（）</a></p>
                     </div>
                  </div>
               </div><a id="LNOCI72627"></a><div class="props_rev_3"><a id="GUID-9603C427-3A19-4607-A62E-0AD06621CC17" name="GUID-9603C427-3A19-4607-A62E-0AD06621CC17"></a><h4 id="LNOCI-GUID-9603C427-3A19-4607-A62E-0AD06621CC17" class="sect4"><span class="enumeration_section">7.11.5</span> PL / SQL索引表绑定支持</h4>
                  <div>
                     <p>可以使用OCI将<code class="codeph">IN/OUT</code>绑定到PL / SQL匿名块中，从而传递PL / SQL索引表。</p>
                     <p>绑定PL / SQL索引表的过程与为SQL语句执行数组绑定非常相似。OCI程序必须使用<code class="codeph">OCIBindByName()</code>或<code class="codeph">OCIBindByName2()</code>或<code class="codeph">OCIBindByPos()</code>或<code class="codeph">OCIBindByPos2()</code>将数组的位置与数组的其他元数据绑定。将C数组绑定到PL / SQL索引表绑定变量的过程必须在绑定调用期间提供以下信息：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">void *valuep (IN/OUT)</code> - 指向位置的指针，该位置指定客户端内存中数组的开头</p>
                        </li>
                        <li>
                           <p><code class="codeph">ub2 dty (IN)</code> - 客户端上表示的数组元素的数据类型</p>
                        </li>
                        <li>
                           <p><code class="codeph">sb4 value_sz (IN)</code> - 客户端上表示的数组的每个元素的最大大小（以字节为单位）</p>
                        </li>
                        <li>
                           <p><code class="codeph">ub4 maxarr_len (IN)</code> - 数组在其生命周期中应保留的数据类型的最大元素数</p>
                           <p>如果预先分配整个数组以进行静态绑定，则数组的大小必须足以包含<code class="codeph">maxarr_len</code>个元素，每个元素的大小为<code class="codeph">value_sz</code> 。此信息还用于约束PL / SQL所看到的索引表。 PL / SQL无法查找超出此指定限制的索引表（读取或写入）。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">ub4 *curelep (IN/OUT)</code> - 指向当前有效的数组中元素数量（从数组的开头<code class="codeph">ub4 *curelep (IN/OUT)</code>的指针。
                           </p>
                           <p>这应该小于或等于最大数组长度。请注意，此信息还用于约束PL / SQL所看到的索引表。对于<code class="codeph">IN</code>绑定，PL / SQL无法从索引表中读取超出此指定限制的值。对于<code class="codeph">OUT</code>绑定，PL / SQL可以写入超出此限制的索引表，但不会超出<code class="codeph">maxarr_len</code>限制。
                           </p>
                        </li>
                     </ul>
                     <p>对于<code class="codeph">IN</code>索引表绑定，在执行<code class="codeph">OCIStmtExecute()</code>之前，用户必须为该执行设置当前数组长度（ <code class="codeph">*curelep</code> ）。此外，用户还必须设置适用于阵列的每个元素的实际长度和指示符。
                     </p>
                     <p>对于<code class="codeph">OUT</code>绑定，OCI必须返回当前数组长度（ <code class="codeph">*curelep</code> ）以及适用于数组中每个元素的实际长度，指示符和返回码。
                     </p>
                     <p>为了获得最佳性能，请使用最大数组长度分配数组，然后根据实际来回传递的元素数来改变执行之间的当前数组长度。这种方法不需要为每次执行重复分配和重新分配阵列，从而有助于整体应用程序性能。</p>
                     <p>也可以使用OCI分段调用来绑定PL / SQL索引表。这种方法不需要预先预先分配整个阵列。<code class="codeph">OCIStmtSetPieceInfo()</code>和<code class="codeph">OCIStmtGetPieceInfo()</code>调用可用于分段传递单个元素。
                     </p>
                     <p>本节包括以下主题： <a href="binding-and-defining-in-oci.html#GUID-07228A70-6E2C-442D-A563-E246EF5B4926" title="PL / SQL索引表OCI绑定接口有哪些限制。">PL / SQL索引表绑定接口的限制</a> 。
                     </p>
                     <div class="infoboxnotealso" id="GUID-9603C427-3A19-4607-A62E-0AD06621CC17__GUID-4BCD4485-C039-4ED5-A2EE-84D44B172A9E">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="bind-define-describe-functions.html#GUID-CD63DF78-2178-4727-A896-B9673C4A37F0" title="在SQL语句或PL / SQL块中创建程序变量和占位符之间的关联。">OCIBindByName（）</a>或<a href="bind-define-describe-functions.html#GUID-55C47708-5468-4106-89BE-1AB60861D037" title="在SQL语句或PL / SQL块中创建程序变量和占位符之间的关联。当客户端上的实际长度超过UB2MAXVAL时，在处理数据类型时使用此函数。">OCIBindByName2（）</a></p>
                           </li>
                           <li>
                              <p><a href="bind-define-describe-functions.html#GUID-D28DF5A7-3C75-4E52-82F7-A5D6D5714E69" title="在SQL语句或PL / SQL块中创建程序变量和占位符之间的关联。">OCIBindByPos（）</a>或<a href="bind-define-describe-functions.html#GUID-5C505821-323D-473D-825B-448C8D9A6702" title="在SQL语句或PL / SQL块中创建程序变量和占位符之间的关联。当客户端上的实际长度超过UB2MAXVAL时，在处理数据类型时使用此调用。">OCIBindByPos2（）</a></p>
                           </li>
                           <li>
                              <p><a href="statement-functions.html#GUID-98B26708-3E02-45C0-8258-5D5544F32BE9" title="将应用程序请求与服务器关联。">OCIStmtExecute（）</a></p>
                           </li>
                           <li>
                              <p><a href="statement-functions.html#GUID-CDB6F3E3-0FB6-49A7-A8AE-83CD330A359F" title="设置分段操作的片段信息。">OCIStmtSetPieceInfo（）</a></p>
                           </li>
                           <li>
                              <p><a href="statement-functions.html#GUID-3D9B5C7B-E2A1-485D-852C-2434F303EC11" title="返回分段操作的片段信息。">OCIStmtGetPieceInfo（）</a></p>
                           </li>
                        </ul>
                     </div>
                  </div><a id="LNOCI72628"></a><div class="props_rev_3"><a id="GUID-07228A70-6E2C-442D-A563-E246EF5B4926" name="GUID-07228A70-6E2C-442D-A563-E246EF5B4926"></a><h5 id="LNOCI-GUID-07228A70-6E2C-442D-A563-E246EF5B4926" class="sect5"><span class="enumeration_section">7.11.5.1</span> PL / SQL索引表绑定接口的限制</h5>
                     <div>
                        <p>PL / SQL索引表OCI绑定接口有哪些限制。</p>
                        <p>PL / SQL索引表OCI绑定接口不支持绑定：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>ADT或<code class="codeph">REF</code>阵列</p>
                           </li>
                           <li>
                              <p>描述符类型的数组，例如LOB描述符，ROWID描述符，日期时间或区间描述符</p>
                           </li>
                           <li>
                              <p>PLSQL记录类型的数组</p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="LNOCI16434"></a><div class="props_rev_3"><a id="GUID-25BBA0D1-689D-40FD-86E1-A10D02A3E4BB" name="GUID-25BBA0D1-689D-40FD-86E1-A10D02A3E4BB"></a><h4 id="LNOCI-GUID-25BBA0D1-689D-40FD-86E1-A10D02A3E4BB" class="sect4"><span class="enumeration_section">7.11.6</span>关于在运行时提供FETCH信息</h4>
                  <div>
                     <p>当调用<code class="codeph">OCIDefineByPos()</code>或<code class="codeph">OCIDefineByPos2()</code>并将<code class="codeph">mode</code>参数设置为<code class="codeph">OCI_DYNAMIC_FETCH</code> ，应用程序可以在获取时指定有关数据缓冲区的信息。
                     </p>
                     <p>您可能还需要调用<code class="codeph">OCIDefineDynamic()</code>来设置一个回调函数，该函数被调用以获取有关数据缓冲区的信息。
                     </p>
                     <p>运行时数据以两种方式之一提供：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>您可以使用<code class="codeph">OCIDefineDynamic()</code>函数定义回调。<code class="codeph">value_sz</code>参数定义运行时提供的数据的最大大小。当客户端库需要缓冲区来返回获取的数据时，将调用回调以提供运行时缓冲区，其中返回一段数据或全部数据。
                           </p>
                        </li>
                        <li>
                           <p>如果未定义回调，则返回<code class="codeph">OCI_NEED_DATA</code>错误代码，然后客户端应用程序可以使用<code class="codeph">OCIStmtSetPieceInfo()</code>提供<code class="codeph">OUT</code>数据缓冲区或块。<code class="codeph">OCIStmtGetPieceInfo()</code>调用提供有关涉及哪个定义和哪个部分的信息。
                           </p>
                        </li>
                     </ul>
                     <p>本节包括以下主题： <a href="binding-and-defining-in-oci.html#GUID-2597C98A-5CB3-4FD9-ADB2-67A247AC9E11" title="获取缓冲区可以是任意大小。另外，每个取出的片不需要具有相同的尺寸。">执行分段提取</a></p>
                     <div class="infoboxnotealso" id="GUID-25BBA0D1-689D-40FD-86E1-A10D02A3E4BB__GUID-8350770A-C27B-427F-92AB-8283FA10697F">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="bind-define-describe-functions.html#GUID-CFE5AA54-DEBC-42D3-8A27-AFF1E7815691" title="将选择列表中的项与类型和输出数据缓冲区相关联。">OCIDefineByPos（）</a>或<a href="bind-define-describe-functions.html#GUID-74939FB5-919E-4D24-B327-AFB532435061" title="将选择列表中的项与类型和输出数据缓冲区相关联。当客户端上的实际长度超过UB2MAXVAL时，在处理数据类型时使用此调用。">OCIDefineByPos2（）</a></p>
                           </li>
                           <li>
                              <p><a href="bind-define-describe-functions.html#GUID-DD404526-9615-4E44-B790-1D17396C82A9" title="如果在OCIDefineByPos（）或OCIDefineByPos2（）中选择了OCI_DYNAMIC_FETCH模式，则设置所需的其他属性。">OCIDefineDynamic（）</a></p>
                           </li>
                           <li>
                              <p><a href="statement-functions.html#GUID-CDB6F3E3-0FB6-49A7-A8AE-83CD330A359F" title="设置分段操作的片段信息。">OCIStmtSetPieceInfo（）</a></p>
                           </li>
                           <li>
                              <p><a href="statement-functions.html#GUID-3D9B5C7B-E2A1-485D-852C-2434F303EC11" title="返回分段操作的片段信息。">OCIStmtGetPieceInfo（）</a></p>
                           </li>
                        </ul>
                     </div>
                  </div><a id="LNOCI16436"></a><a id="LNOCI16435"></a><div class="props_rev_3"><a id="GUID-2597C98A-5CB3-4FD9-ADB2-67A247AC9E11" name="GUID-2597C98A-5CB3-4FD9-ADB2-67A247AC9E11"></a><h5 id="LNOCI-GUID-2597C98A-5CB3-4FD9-ADB2-67A247AC9E11" class="sect5"><span class="enumeration_section">7.11.6.1</span>执行分段提取</h5>
                     <div>
                        <p>获取缓冲区可以是任意大小。另外，每个取出的片不需要具有相同的尺寸。</p>
                        <div class="section">
                           <p>唯一的要求是最终提取的大小必须与最后剩余部分的大小完全相同。每个要获取的片段的大小由每个<code class="codeph">OCIStmtSetPieceInfo()</code>调用建立。该过程<a href="binding-and-defining-in-oci.html#GUID-2597C98A-5CB3-4FD9-ADB2-67A247AC9E11__I430634">如图7-4</a>所示，并在<a href="binding-and-defining-in-oci.html#GUID-2597C98A-5CB3-4FD9-ADB2-67A247AC9E11__I430634">图</a>中的步骤中进行了解释。
                           </p>
                           <div class="figure" id="GUID-2597C98A-5CB3-4FD9-ADB2-67A247AC9E11__I430634">
                              <p class="titleinfigure">图7-4执行分段提取</p><img src="img/lnoci026.png" alt="下面是图7-4的描述" title="下面是图7-4的描述" longdesc="img_text/lnoci026.html"><br><a href="img_text/lnoci026.html">“图7-4执行分段提取”的描述</a></div>
                           <!-- class="figure" -->
                        </div>
                        <!-- class="section" -->
                        <ol>
                           <li><span>初始化OCI环境，分配必要的句柄，连接到数据库，授权用户，准备语句，并使用<code class="codeph">OCIStmtExecute()</code>执行语句。</span></li>
                           <li><span>使用<code class="codeph">OCIDefineByPos()</code>或<code class="codeph">OCIDefineByPos2()</code>定义输出变量， <code class="codeph">mode</code>设置为<code class="codeph">OCI_DYNAMIC_FETCH</code> 。此时，您不需要指定所使用部分的实际大小，但必须提供在运行时获取的数据的总大小。</span></li>
                           <li><span>第一次调用<code class="codeph">OCIStmtFetch2()</code> 。未检索到任何数据，并将<code class="codeph">OCI_NEED_DATA</code>错误代码返回给应用程序。如果返回任何其他值，则发生错误。</span></li>
                           <li><span>调用<code class="codeph">OCIStmtGetPieceInfo()</code>以获取有关要获取的片段的信息。<code class="codeph">piecep</code>参数指示它是第一块（ <code class="codeph">OCI_FIRST_PIECE</code> ），后续块（ <code class="codeph">OCI_NEXT_PIECE</code> ）还是最后一块（ <code class="codeph">OCI_LAST_PIECE</code> ）。</span></li>
                           <li><span>调用<code class="codeph">OCIStmtSetPieceInfo()</code>以指定获取缓冲区。</span></li>
                           <li><span>再次调用<code class="codeph">OCIStmtFetch2()</code>以检索实际的部分。如果<code class="codeph">OCIStmtFetch2()</code>返回<code class="codeph">OCI_SUCCESS</code> ，则已成功获取所有部分。如果<code class="codeph">OCIStmtFetch2()</code>返回<code class="codeph">OCI_NEED_DATA</code> ，则返回步骤4以处理下一个部分。如果返回任何其他值，则发生错误。</span></li>
                        </ol>
                        <div class="section">
                           <div class="infoboxnotealso" id="GUID-2597C98A-5CB3-4FD9-ADB2-67A247AC9E11__GUID-CD4065E8-7451-40E5-85B5-C9379FE8D467">
                              <p class="notep1">也可以看看：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p><a href="oci-programming-basics.html#GUID-83F4D3B1-56A7-4EEE-A905-BB84D399713D" title="OCI呼吁完成民意调查。">OCI中的轮询模式操作</a></p>
                                 </li>
                                 <li>
                                    <p><a href="statement-functions.html#GUID-CDB6F3E3-0FB6-49A7-A8AE-83CD330A359F" title="设置分段操作的片段信息。">OCIStmtSetPieceInfo（）</a></p>
                                 </li>
                                 <li>
                                    <p><a href="statement-functions.html#GUID-98B26708-3E02-45C0-8258-5D5544F32BE9" title="将应用程序请求与服务器关联。">OCIStmtExecute（）</a></p>
                                 </li>
                                 <li>
                                    <p><a href="bind-define-describe-functions.html#GUID-CFE5AA54-DEBC-42D3-8A27-AFF1E7815691" title="将选择列表中的项与类型和输出数据缓冲区相关联。">OCIDefineByPos（）</a>或<a href="bind-define-describe-functions.html#GUID-74939FB5-919E-4D24-B327-AFB532435061" title="将选择列表中的项与类型和输出数据缓冲区相关联。当客户端上的实际长度超过UB2MAXVAL时，在处理数据类型时使用此调用。">OCIDefineByPos2（）</a></p>
                                 </li>
                                 <li>
                                    <p><a href="statement-functions.html#GUID-3D9B5C7B-E2A1-485D-852C-2434F303EC11" title="返回分段操作的片段信息。">OCIStmtGetPieceInfo（）</a></p>
                                 </li>
                                 <li>
                                    <p><a href="statement-functions.html#GUID-DF585B90-58BA-45FC-B7CE-6F7F987C03B9" title="从（可滚动）结果集中获取一行。">OCIStmtFetch2（）</a></p>
                                 </li>
                              </ul>
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="LNOCI16437"></a><div class="props_rev_3"><a id="GUID-9E60B14E-920F-42E6-904D-36BAF20FDA3D" name="GUID-9E60B14E-920F-42E6-904D-36BAF20FDA3D"></a><h4 id="LNOCI-GUID-9E60B14E-920F-42E6-904D-36BAF20FDA3D" class="sect4"><span class="enumeration_section">7.11.7</span>分段绑定和定义LOB</h4>
                  <div>
                     <p>对LOB进行分段绑定和定义的方法有哪些。</p>
                     <p>那里有两个：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><span>使用数据接口</span></p>
                           <p>您可以使用<code class="codeph">SQLT_CHR</code> （ <code class="codeph">VARCHAR2</code> ）或<code class="codeph">SQLT_LNG</code> （ <code class="codeph">LONG</code> ）作为以下函数的输入数据类型来绑定或定义<code class="codeph">CLOB</code>列的字符数据。您还可以使用<code class="codeph">SQLT_LBI</code> （ <code class="codeph">LONG</code> <code class="codeph">RAW</code> ）和<code class="codeph">SQLT_BIN</code> （ <code class="codeph">RAW</code> ）作为这些函数的输入数据类型来绑定或定义<code class="codeph">BLOB</code>列的原始数据：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">OCIDefineByPos()</code>或<code class="codeph">OCIDefineByPos2()</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">OCIBindByName()</code>或<code class="codeph">OCIBindByName2()</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">OCIBindByPos()</code>或<code class="codeph">OCIBindByPos2()</code></p>
                              </li>
                           </ul>
                           <p>在这种情况下， <code class="codeph">CLOB</code>和<code class="codeph">BLOB</code>列支持稍后描述的所有分段操作。
                           </p>
                        </li>
                        <li>
                           <p><span>使用LOB定位器</span></p>
                           <p>您可以使用<code class="codeph">SQLT_CLOB</code> （ <code class="codeph">CLOB</code> ）或<code class="codeph">SQLT_BLOB</code> （ <code class="codeph">BLOB</code> ）作为以下函数的输入数据类型，为<code class="codeph">CLOB</code>和<code class="codeph">BLOB</code>列绑定或定义LOB定位器。
                           </p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">OCIDefineByPos()</code>或<code class="codeph">OCIDefineByPos2()</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">OCIBindByName()</code>或<code class="codeph">OCIBindByName2()</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">OCIBindByPos()</code>或<code class="codeph">OCIBindByPos2()</code></p>
                              </li>
                           </ul>
                           <p>然后，您必须调用OCILob *函数来读取和操作数据。<code class="codeph">OCILobRead2()</code>和<code class="codeph">OCILobWrite2()</code>支持分段和回调模式。
                           </p>
                        </li>
                     </ul>
                     <div class="infoboxnotealso" id="GUID-9E60B14E-920F-42E6-904D-36BAF20FDA3D__GUID-1451BE6F-0520-4504-B0A3-FA04A2307091">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="bind-define-describe-functions.html#GUID-CFE5AA54-DEBC-42D3-8A27-AFF1E7815691" title="将选择列表中的项与类型和输出数据缓冲区相关联。">OCIDefineByPos（）</a>或<a href="bind-define-describe-functions.html#GUID-74939FB5-919E-4D24-B327-AFB532435061" title="将选择列表中的项与类型和输出数据缓冲区相关联。当客户端上的实际长度超过UB2MAXVAL时，在处理数据类型时使用此调用。">OCIDefineByPos2（）</a></p>
                           </li>
                           <li>
                              <p><a href="bind-define-describe-functions.html#GUID-CD63DF78-2178-4727-A896-B9673C4A37F0" title="在SQL语句或PL / SQL块中创建程序变量和占位符之间的关联。">OCIBindByName（）</a>或<a href="bind-define-describe-functions.html#GUID-55C47708-5468-4106-89BE-1AB60861D037" title="在SQL语句或PL / SQL块中创建程序变量和占位符之间的关联。当客户端上的实际长度超过UB2MAXVAL时，在处理数据类型时使用此函数。">OCIBindByName2（）</a></p>
                           </li>
                           <li>
                              <p><a href="bind-define-describe-functions.html#GUID-D28DF5A7-3C75-4E52-82F7-A5D6D5714E69" title="在SQL语句或PL / SQL块中创建程序变量和占位符之间的关联。">OCIBindByPos（）</a>或<a href="bind-define-describe-functions.html#GUID-5C505821-323D-473D-825B-448C8D9A6702" title="在SQL语句或PL / SQL块中创建程序变量和占位符之间的关联。当客户端上的实际长度超过UB2MAXVAL时，在处理数据类型时使用此调用。">OCIBindByPos2（）</a></p>
                           </li>
                           <li>
                              <p><a href="binding-and-defining-in-oci.html#GUID-D757C946-BCDA-4A32-867B-BE951BA9BBF4" title="Oracle数据库允许对任何大小的LOB的INSERT和UPDATE进行非零绑定。">关于绑定LOB数据</a>以及<code class="codeph">INSERT</code>和<code class="codeph">UPDATE statements</code>示例</p>
                           </li>
                           <li>
                              <p><a href="binding-and-defining-in-oci.html#GUID-FE7DB3D8-9310-41ED-8869-B5106E60D29E">关于定义LOB数据</a>以了解<code class="codeph">SELECT</code>语句的用法和示例</p>
                           </li>
                           <li>
                              <p><a href="lob-functions.html#GUID-6AC6E6DA-236B-4BF9-942F-9FCC4178FEDA" title="将调用所指定的LOB或BFILE的一部分读入缓冲区。此函数必须用于大小超过4 GB的LOB。">OCILobRead2（）</a></p>
                           </li>
                           <li>
                              <p><a href="lob-functions.html#GUID-77F056CA-9EEE-4550-8A8E-0155DF994DBE" title="将缓冲区写入LOB。此函数必须用于大小超过4 GB的LOB。">OCILobWrite2（）</a></p>
                           </li>
                           <li>
                              <p><a href="lobs-and-bfile-operations.html#GUID-FFFD9E4C-03CE-469C-AA47-DFD73C0C9C69" title="OCI supports read and write callback functions.">LOB读取和写入回调，</a>以获取有关使用<code class="codeph">OCILobWrite2()</code>和<code class="codeph">OCILobRead2()</code> <a href="lobs-and-bfile-operations.html#GUID-FFFD9E4C-03CE-469C-AA47-DFD73C0C9C69" title="OCI支持读写回调函数。">回调</a>进行流式处理的信息</p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>