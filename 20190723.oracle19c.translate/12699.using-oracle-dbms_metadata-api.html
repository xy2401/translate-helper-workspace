<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <meta name="abstract" content="Using the DBMS_METADATA APIs."></meta>
      <meta name="description" content="Using the DBMS_METADATA APIs."></meta>
      <title>使用元数据API</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Utilities "></meta>
      <meta property="og:description" content="Using the DBMS_METADATA APIs."></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Utilities"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="database-utilities.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-04-23T19:07:17-07:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="2002, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96081-02"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="oracle-logminer-utility.html" title="Previous" type="text/html"></link>
      <link rel="next" href="oracle-original-export-utility.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Database Utilities"></meta>
    <meta name="dcterms.isVersionOf" content="SUTIL"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="oracle-logminer-utility.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="oracle-original-export-utility.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">公用事业</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="other-oracle-utilities.html" property="item" typeof="WebPage"><span property="name">其他公用事业</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">使用元数据API</li>
            </ol>
            <a id="GUID-D9B1300F-B21D-416E-8B9B-C542195EF249" name="GUID-D9B1300F-B21D-416E-8B9B-C542195EF249"></a><a id="SUTIL015"></a>
            
            <h2 id="SUTIL-GUID-D9B1300F-B21D-416E-8B9B-C542195EF249" class="sect2"><span class="enumeration_chapter">23</span>使用元数据API</h2>
         </header>
         <div class="ind">
            <div>
               <p>使用<code class="codeph">DBMS_METADATA</code> API。</p>
               <p><code class="codeph">DBMS_METADATA</code> API使您可以执行以下操作：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p>以XML格式检索对象的元数据</p>
                  </li>
                  <li>
                     <p>以各种方式转换XML，包括将其转换为SQL DDL</p>
                  </li>
                  <li>
                     <p>提交XML以重新创建检索提取的对象</p>
                  </li>
               </ul>
               <p><code class="codeph">DBMS_METADATA_DIFF</code> API允许您比较数据库之间的对象，以识别相同类型的对象中的元数据随时间的变化。
               </p>
            </div>
            <div>
               <ul class="ullinks">
                  <li class="ulchildlink"><a href="using-oracle-dbms_metadata-api.html#GUID-EFF19735-0C94-46CD-B1CB-123FEB390B43">为什么使用DBMS_METADATA API？</a><br><code class="codeph">DBMS_METADATA</code> API使您无需编写和维护自己的元数据提取代码。
                  </li>
                  <li class="ulchildlink"><a href="using-oracle-dbms_metadata-api.html#GUID-FF65F378-97BB-459A-A9C2-E0B105205D3D">DBMS_METADATA API概述</a><br><code class="codeph">DBMS_METADATA</code> API概述。</li>
                  <li class="ulchildlink"><a href="using-oracle-dbms_metadata-api.html#GUID-EE2AA635-EA83-4265-9727-E9C659842CEF">使用DBMS_METADATA API检索对象的元数据</a><br><code class="codeph">DBMS_METADATA</code> API的检索接口允许您指定要检索的对象的类型。
                  </li>
                  <li class="ulchildlink"><a href="using-oracle-dbms_metadata-api.html#GUID-1DA999FD-1AFD-4D8D-A6D0-8EEB84E0D9E4">使用DBMS_METADATA API重新创建检索对象</a><br>获取对象的元数据时，可能希望使用它在不同的数据库或模式中重新创建对象。
                  </li>
                  <li class="ulchildlink"><a href="using-oracle-dbms_metadata-api.html#GUID-85AC0B9A-5C6E-4D2A-A3CA-30F5F7884048">使用DBMS_METADATA API检索不同对象类型的集合</a><br>检索不同对象类型的集合的描述和示例。
                  </li>
                  <li class="ulchildlink"><a href="using-oracle-dbms_metadata-api.html#GUID-E9A778A7-2E9D-4240-8707-A52FF65556FE">使用DBMS_METADATA_DIFF API比较对象元数据</a><br>使用<code class="codeph">DBMS_METADATA</code>和<code class="codeph">DBMS_METADATA_DIFF</code>的检索，比较和提交接口来获取两个表的元数据，比较元数据并生成使一个表像另一个表的<code class="codeph">ALTER</code>语句的描述和示例。
                  </li>
                  <li class="ulchildlink"><a href="using-oracle-dbms_metadata-api.html#GUID-DF431094-5F1D-478D-87E6-04CC774B761F">DBMS_METADATA API的编程接口的性能提示</a><br>描述在使用<code class="codeph">DBMS_METADATA</code> API的编程接口时如何增强性能。</li>
                  <li class="ulchildlink"><a href="using-oracle-dbms_metadata-api.html#GUID-89237236-4729-4E33-842D-D124A3C15B10">示例DBMS_METADATA API的用法</a><br>如何使用<code class="codeph">DBMS_METADATA</code> API的示例。
                  </li>
                  <li class="ulchildlink"><a href="using-oracle-dbms_metadata-api.html#GUID-B19C59EB-A9BC-4D1E-BD8C-135583D403CD">DBMS_METADATA过程摘要</a><br>提供<code class="codeph">DBMS_METADATA</code> API提供的过程的简要说明。</li>
                  <li class="ulchildlink"><a href="using-oracle-dbms_metadata-api.html#GUID-CB5F314F-7412-40F1-B71C-8F6DFB45A4D8">DBMS_METADATA_DIFF过程摘要</a><br>提供<code class="codeph">DBMS_METADATA_DIFF</code> API提供的过程和函数的简要说明。</li>
               </ul>
               <div class="familylinks">
                  <div class="parentlink">
                     <p><strong>父主题：</strong> <a href="other-oracle-utilities.html#GUID-FCEA49BD-D3AF-4337-88F1-3A23545F35A6">其他实用程序</a></p>
                  </div>
               </div>
            </div>
            <a id="SUTIL1622"></a><div class="props_rev_3"><a id="GUID-EFF19735-0C94-46CD-B1CB-123FEB390B43" name="GUID-EFF19735-0C94-46CD-B1CB-123FEB390B43"></a><h3 id="SUTIL-GUID-EFF19735-0C94-46CD-B1CB-123FEB390B43" class="sect3"><span class="enumeration_section">23.1</span>为什么使用DBMS_METADATA API？
               </h3>
               <div>
                  <p><code class="codeph">DBMS_METADATA</code> API使您无需编写和维护自己的元数据提取代码。
                  </p>
                  <p>随着时间的推移，您已经使用了Oracle数据库，您可能已经开发了自己的代码，用于从字典中提取元数据，操作元数据（添加列，更改列数据类型等），然后将元数据转换为DDL，以便您可以在同一个或另一个数据库上重新创建该对象。保持代码更新以支持新的字典功能可能已经证明是具有挑战性的。</p>
                  <p>它为字典元数据的提取，操作和重新创建提供了集中的工具。它支持最新级别的所有字典对象。</p>
                  <p>尽管<code class="codeph">DBMS_METADATA</code> API可以显着减少您编写和维护的自定义代码的数量，但它不会对正常的数据库过程进行任何更改。通过运行<code class="codeph">catproc</code> ， <code class="codeph">DBMS_METADATA</code> API的安装方式与数据字典视图的安装方式相同。 <code class="codeph">sql</code>在数据库安装时运行SQL脚本。安装后，即使在受限模式下，只要实例正常运行，它就可用。
                  </p>
                  <p>更改数据库版本时， <code class="codeph">DBMS_METADATA</code> API不要求您更改任何源代码，因为它在不同的Oracle版本之间向上兼容。一个版本检索的XML文档可以由相同或更高版本的提交界面处理。例如，Oracle9 <span class="italic">i</span>数据库检索的XML文档可以提交给Oracle数据库<span class="italic">10g。</span></p>
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="using-oracle-dbms_metadata-api.html#GUID-D9B1300F-B21D-416E-8B9B-C542195EF249" title="使用DBMS_METADATA API。">使用元数据API</a></p>
                     </div>
                  </div>
               </div>
               
            </div><a id="SUTIL1623"></a><div class="props_rev_3"><a id="GUID-FF65F378-97BB-459A-A9C2-E0B105205D3D" name="GUID-FF65F378-97BB-459A-A9C2-E0B105205D3D"></a><h3 id="SUTIL-GUID-FF65F378-97BB-459A-A9C2-E0B105205D3D" class="sect3"><span class="enumeration_section">23.2</span> DBMS_METADATA API概述</h3>
               <div>
                  <p><code class="codeph">DBMS_METADATA</code> API概述。</p>
                  <p>出于<code class="codeph">DBMS_METADATA</code> API的目的，数据库中的每个实体都被建模为属于对象类型的对象。例如，表<code class="codeph">scott.emp</code>是一个对象，其对象类型是<code class="codeph">TABLE</code> 。获取对象的元数据时，必须指定对象类型。
                  </p>
                  <p>要获取对象类型中的特定对象或对象集，请指定过滤器。为每种对象类型定义不同的过滤器。例如，为<code class="codeph">TABLE</code>对象类型定义的两个过滤器是<code class="codeph">SCHEMA</code>和<code class="codeph">NAME</code> 。例如，它们允许您说您希望其模式为<code class="codeph">scott</code>且名称为<code class="codeph">emp</code> 。
                  </p>
                  <p><code class="codeph">DBMS_METADATA</code> API使用XML（可扩展标记语言）和XSLT（可扩展样式表语言转换）。<code class="codeph">DBMS_METADATA</code> API将对象元数据表示为XML，因为它是一种可以轻松解析和转换的通用格式。<code class="codeph">DBMS_METADATA</code> API使用XSLT将XML文档转换为其他XML文档或SQL DDL。</p>
                  <p>您可以使用<code class="codeph">DBMS_METADATA</code> API指定在获取元数据时（或重新提交元数据时）应用于XML的一个或多个转换（XSLT脚本）。API提供了一些预定义的转换，包括一个名为DDL的转换，它将XML文档转换为SQL创建DDL。</p>
                  <p>然后，您可以使用变换参数指定变换的条件。您还可以指定可选的解析项以访问对象元数据的特定属性。</p>
                  <p>有关所有这些选项及其实现示例的更多详细信息，请参阅以下部分：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="using-oracle-dbms_metadata-api.html#GUID-EE2AA635-EA83-4265-9727-E9C659842CEF" title="DBMS_METADATA API的检索接口允许您指定要检索的对象的类型。">使用DBMS_METADATA API检索对象的元数据</a></p>
                     </li>
                     <li>
                        <p><a href="using-oracle-dbms_metadata-api.html#GUID-1DA999FD-1AFD-4D8D-A6D0-8EEB84E0D9E4" title="获取对象的元数据时，可能希望使用它在不同的数据库或模式中重新创建对象。">使用DBMS_METADATA API重新创建检索对象</a></p>
                     </li>
                     <li>
                        <p><a href="using-oracle-dbms_metadata-api.html#GUID-85AC0B9A-5C6E-4D2A-A3CA-30F5F7884048" title="检索不同对象类型的集合的描述和示例。">使用DBMS_METADATA API检索不同对象类型的集合</a></p>
                     </li>
                  </ul>
                  <div class="section">
                     <p class="subhead2" id="GUID-FF65F378-97BB-459A-A9C2-E0B105205D3D__GUID-28A33334-67A1-4031-8E24-FBB7A8892347">使用视图确定有效的DBMS_METADATA选项</p>
                     <p>您可以使用以下视图来确定每个对象类型转换允许哪些<code class="codeph">DBMS_METADATA</code>转换，每个转换的参数及其解析项。
                     </p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="../refrn/DBMS_METADATA_TRANSFORMS.html#REFRN-GUID-486B1381-AA5B-4F00-B770-3244119D6C05" target="_blank">DBMS_METADATA_TRANSFORMS</a> - 记录与<code class="codeph">DBMS_METADATA</code>包一起使用的所有有效的Oracle提供的转换。
                           </p>
                        </li>
                        <li>
                           <p><a href="../refrn/DBMS_METADATA_TRANSFORM_PARAMS.html#REFRN-GUID-A042CD61-3AF5-4F11-BABB-4743486A3B88" target="_blank">DBMS_METADATA_TRANSFORM_PARAMS</a> - 记录每个转换的有效转换参数。
                           </p>
                        </li>
                        <li>
                           <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sutil&amp;id=REFRN-GUID-2A2D4764-3DB6-4F1E-9D3A-2BF301BC577C" target="_blank">DBMS_METADATA_PARSE_ITEMS</a> - 记录有效的解析项。
                           </p>
                        </li>
                     </ul>
                     <p>例如，假设您想知道<code class="codeph">INDEX</code>对象允许哪些转换。以下查询返回对<code class="codeph">INDEX</code>对象有效的转换，所需的输入类型以及生成的输出类型：</p><pre class="pre codeblock"><code>SQL&gt; SELECT转换，output_type，input_type，description 2 FROM dbms_metadata_transforms 3 WHERE object_type ='INDEX'; TRANSFORM OUTPUT_TYP INPUT_TYPE说明---------- ---------- -------------------- ------ -------------------------------------------------- -------------- ALTERXML ALTER_XML SXML差异doc从SXML生成ALTER_XML差异文档SXMLDDL DDL SXML将SXML转换为DDL MODIFY XML XML根据转换参数修改XML文档SXML SXML XML将XML转换为SXML DDL DDL XML将XML转换为SQL以创建对象ALTERDDL ALTER_DDL ALTER_XML将ALTER_XML转换为ALTER_DDL MODIFYSXML SXML SXML修改SXML文档</code></pre><p>然后，您可能想知道哪些转换参数对DDL转换有效：</p><pre class="pre codeblock"><code>SQL&gt; SELECT param，datatype，default_val，description 2 FROM dbms_metadata_transform_params 3 WHERE object_type ='INDEX'和transform ='DDL'4 ORDER BY param; PARAM DATATYPE DEFAULT_VA说明------------------------- ---------- ----------  - -------------------------------------------------- ------------------- INCLUDE_PARTITIONS TEXT在DDL转换中包含生成的时间间隔和列表分区INDEX_COMPRESSION_CLAUSE TEXT“”用户指定的索引压缩子句的文本PARTITIONING BOOLEAN TRUE在转换中包含分区子句PARTITION_NAME TEXT“”为转换选择的分区名称PCTSPACE NUMBER“”要修改空间分配的百分比SEGMENT_ATTRIBUTES BOOLEAN TRUE在转换中包括段属性子句（物理属性，存储属性，表空间，日志记录）STORAGE BOOLEAN TRUE包含存储子句in transformation SUBPARTITION_NAME TEXT“”为转换选择的子分区名称TABLESPACE BOOLEAN TRUE在转换中包含表空间子句</code></pre><p>您还可以执行以下查询，该查询返回有关<code class="codeph">INDEX</code>对象类型的特定元数据::</p><pre class="pre codeblock"><code>SQL&gt; SELECT parse_item，description 2 FROM dbms_metadata_parse_items 3 WHERE object_type ='INDEX'和convert ='Y'; PARSE_ITEM DESCRIPTION -------------------- ---------------------------- ---------------------------------- OBJECT_TYPE对象类型TABLESPACE对象表空间（分区对象的默认表空间）BASE_OBJECT_SCHEMA Schema of基础对象SCHEMA对象模式，如果有任何名称对象名称BASE_OBJECT_NAME基础对象的名称BASE_OBJECT_TYPE基础对象的对象类型SYSTEM_GENERATED Y =系统生成的对象; N =不是系统生成的</code></pre></div>
                  <!-- class="section" -->
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="using-oracle-dbms_metadata-api.html#GUID-D9B1300F-B21D-416E-8B9B-C542195EF249" title="使用DBMS_METADATA API。">使用元数据API</a></p>
                     </div>
                  </div>
               </div>
               
            </div><a id="SUTIL1624"></a><div class="props_rev_3"><a id="GUID-EE2AA635-EA83-4265-9727-E9C659842CEF" name="GUID-EE2AA635-EA83-4265-9727-E9C659842CEF"></a><h3 id="SUTIL-GUID-EE2AA635-EA83-4265-9727-E9C659842CEF" class="sect3"><span class="enumeration_section">23.3</span>使用DBMS_METADATA API检索对象的元数据</h3>
               <div>
                  <p><code class="codeph">DBMS_METADATA</code> API的检索接口允许您指定要检索的对象的类型。
                  </p>
                  <p>这可以是特定对象类型（例如表，索引或过程），也可以是形成逻辑单元的对象类型的异构集合（例如数据库导出或模式导出）。默认情况下，您获取的元数据将在XML文档中返回。</p>
                  <div class="infoboxnote" id="GUID-EE2AA635-EA83-4265-9727-E9C659842CEF__GUID-C43193A5-98F0-4C5B-A946-C14502066969">
                     <p class="notep1">注意：</p>
                     <p>要访问不在您自己的模式中的对象，您必须具有<code class="codeph">SELECT_CATALOG_ROLE</code>角色。但是，在许多PL / SQL对象（存储过程，函数，定义者权限API）中禁用了角色。因此，如果您正在编写将访问另一个模式中的对象的PL / SQL程序（或者，通常是您需要<code class="codeph">SELECT_CATALOG_ROLE</code>角色的任何对象），那么您必须将代码放在调用者的权限API中。</p>
                  </div>
                  <p>您可以使用编程界面进行休闲浏览，也可以使用它来开发应用程序。如果您只是想对系统元数据进行即席查询，则可以使用浏览界面。如果要将字典元数据作为应用程序的一部分提取，则可以使用编程接口。在这种情况下，可以使用<code class="codeph">DBMS_METADATA</code> API提供的过程代替您当前可能用于执行相同操作的SQL脚本和自定义代码。
                  </p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="using-oracle-dbms_metadata-api.html#GUID-FBCB0C17-4B6A-4BC9-9F01-86015FA0F1C3">用于基本元数据检索的典型步骤</a><br>检索元数据时，使用<code class="codeph">DBMS_METADATA</code> PL / SQL API。</li>
                     <li class="ulchildlink"><a href="using-oracle-dbms_metadata-api.html#GUID-68EB7622-137B-46CC-AE50-75972582092E">检索多个对象</a><br>检索多个对象的描述和示例。
                     </li>
                     <li class="ulchildlink"><a href="using-oracle-dbms_metadata-api.html#GUID-27965831-A88D-4723-8402-F31DC9839B71">在变换上放置条件</a><br>您可以使用变换参数指定要添加的变换的条件。
                     </li>
                     <li class="ulchildlink"><a href="using-oracle-dbms_metadata-api.html#GUID-BB45CA8D-2621-419B-906C-1E811499786A">访问特定元数据属性</a><br>访问特定元数据属性的描述和示例。
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="using-oracle-dbms_metadata-api.html#GUID-D9B1300F-B21D-416E-8B9B-C542195EF249" title="使用DBMS_METADATA API。">使用元数据API</a></p>
                     </div>
                  </div>
               </div>
               
               <div class="props_rev_2"><a id="GUID-FBCB0C17-4B6A-4BC9-9F01-86015FA0F1C3" name="GUID-FBCB0C17-4B6A-4BC9-9F01-86015FA0F1C3"></a><h4 id="SUTIL-GUID-FBCB0C17-4B6A-4BC9-9F01-86015FA0F1C3" class="sect4"><span class="enumeration_section">23.3.1</span>用于基本元数据检索的典型步骤</h4>
                  <div>
                     <p>检索元数据时，使用<code class="codeph">DBMS_METADATA</code> PL / SQL API。</p>
                     <div class="section">
                        <p>以下示例说明了编程和浏览界面。</p>
                        <p><code class="codeph">DBMS_METADATA</code>编程接口示例提供了使用<code class="codeph">DBMS_METADATA</code>编程接口检索一个表的元数据的基本演示。它创建一个<code class="codeph">DBMS_METADATA</code>程序，用于创建名为<code class="codeph">get_table_md</code> 。此函数返回一个表的元数据。
                        </p>
                        <p><code class="codeph">DBMS_METADATA</code>浏览界面示例演示了如何使用浏览界面获取相同的结果。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-FBCB0C17-4B6A-4BC9-9F01-86015FA0F1C3__GUID-99E54742-0197-4C53-A4B0-6D23486B3ED1">
                        <p class="titleinexample">示例23-1使用DBMS_METADATA编程接口检索数据</p>
                        <ol>
                           <li>
                              <p>创建一个<code class="codeph">DBMS_METADATA</code>程序，该程序创建一个名为<code class="codeph">get_table_md</code> ，该函数将在<code class="codeph">hr</code>模式中返回一个表（时间<code class="codeph">timecards</code>的元数据。这样的程序的内容如下。（对于本例，命名程序<code class="codeph">metadata_program</code> 。 <code class="codeph">sql</code> ）。
                              </p><pre class="oac_no_warn" dir="ltr">创建或替换函数get_table_md RETURN CLOB IS  - 定义局部变量。h NUMBER; - 由OPEN号码返回的句柄; -  ADD_TRANSFORM doc CLOB返回的句柄; BEGIN  - 指定对象类型。h：= DBMS_METADATA.OPEN（'TABLE'）; - 使用过滤器指定所需的特定对象。DBMS_METADATA.SET_FILTER（H， 'SCHEMA'， 'HR'）; DBMS_METADATA.SET_FILTER（H， 'NAME'， '考勤卡'）; - 请求将元数据转换为创建DDL。 th：= DBMS_METADATA.ADD_TRANSFORM（h，'DDL'）; - 获取对象。doc：= DBMS_METADATA.FETCH_CLOB（h）; - 释放资源。DBMS_METADATA.CLOSE（H）;返回文档;结束; /</pre></li>
                           <li>
                              <p>以用户<code class="codeph">hr</code>连接。
                              </p>
                           </li>
                           <li>
                              <p>运行该程序以创建<code class="codeph">get_table_md</code>函数：</p>
                              <p><code class="codeph">SQL&gt; @metadata_program</code></p>
                           </li>
                           <li>
                              <p>在select操作中使用新创建的<code class="codeph">get_table_md</code>函数。要生成完整，不间断的输出，请将<code class="codeph">PAGESIZE</code>设置为0，并在执行查询之前将<code class="codeph">LONG</code>设置为某个较大的数字（如图所示）：</p><pre class="oac_no_warn" dir="ltr">SQL&gt; SET PAGESIZE 0 SQL&gt; SET LONG 1000000 SQL&gt; SELECT get_table_md FROM dual;</pre></li>
                           <li>
                              <p>输出显示<code class="codeph">hr</code>模式中时间<code class="codeph">timecards</code>表的元数据，类似于以下内容：</p><pre class="oac_no_warn" dir="ltr">创建表“HR”。“TIMECARDS”（“EMPLOYEE_ID”编号（6,0），“周”编号（2,0），“JOB_ID”VARCHAR2（10），“HOURS_WORKED”编号（4,2），外键（“EMPLOYEE_ID”）参考“HR”。“员工”（“EMPLOYEE_ID”）ENABLE）PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS记录存储（初始65536下一页1048576 MINEXTENTS 1 MAXEXTENTS 2147483645 PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT） TABLESPACE“示例”</pre></li>
                        </ol>
                     </div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-FBCB0C17-4B6A-4BC9-9F01-86015FA0F1C3__GUID-F2DE8330-4777-4AD8-B129-EA25E8E24012">
                        <p class="titleinexample">示例23-2使用DBMS_METADATA浏览界面检索数据</p><pre class="oac_no_warn" dir="ltr">SQL&gt; SET PAGESIZE 0 SQL&gt; SET LONG 1000000 SQL&gt; SELECT DBMS_METADATA.GET_DDL（'TABLE'，'TIMECARDS'，'HR'）FROM dual;</pre><p>此查询的结果与<code class="codeph">DBMS_METADATA</code>编程接口示例中的步骤5中显示的结果相同。
                        </p>
                     </div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="using-oracle-dbms_metadata-api.html#GUID-EE2AA635-EA83-4265-9727-E9C659842CEF" title="DBMS_METADATA API的检索接口允许您指定要检索的对象的类型。">使用DBMS_METADATA API检索对象的元数据</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="SUTIL3620"></a><a id="SUTIL1626"></a><div class="props_rev_3"><a id="GUID-68EB7622-137B-46CC-AE50-75972582092E" name="GUID-68EB7622-137B-46CC-AE50-75972582092E"></a><h4 id="SUTIL-GUID-68EB7622-137B-46CC-AE50-75972582092E" class="sect4"><span class="enumeration_section">23.3.2</span>检索多个对象</h4>
                  <div>
                     <p>检索多个对象的描述和示例。</p>
                     <div class="section">
                        <p>在前面的示例“使用<code class="codeph">DBMS_METADATA</code>编程接口检索数据”中， <code class="codeph">FETCH_CLOB</code>过程仅被调用一次，因为已知只有一个对象。但是，您还可以检索多个对象，例如，模式<code class="codeph">scott</code>所有表。为此，您需要使用以下构造：</p><pre class="oac_no_warn" dir="ltr">LOOP doc：= DBMS_METADATA.FETCH_CLOB（h）; -   - 当没有更多对象要检索时，FETCH_CLOB返回NULL。 - 当doc is NULL时退出;结束循环;</pre><p>以下示例演示了如何使用此构造并检索多个对象。此示例以用户<code class="codeph">scott</code>身份连接。密码是<code class="codeph">tiger</code> 。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-68EB7622-137B-46CC-AE50-75972582092E__I1014062">
                        <p class="titleinexample">示例23-3检索多个对象</p>
                        <ol>
                           <li>
                              <p>创建一个表名为<code class="codeph">my_metadata</code>和程序命名<code class="codeph">get_tables_md</code> ，如下所示。因为不是所有对象都可以返回，所以它们存储在表中并在最后查询。
                              </p><pre class="oac_no_warn" dir="ltr">DROP TABLE my_metadata; CREATE TABLE my_metadata（md clob）;创建或替换程序get_tables_md IS  - 定义局部变量h NUMBER; - '打开'号码返回的句柄; - 'ADD_TRANSFORM'doc CLOB返回的句柄; - 在CLOB BEGIN中返回元数据 - 指定对象类型。h：= DBMS_METADATA.OPEN（'TABLE'）; - 使用过滤器指定架构。DBMS_METADATA.SET_FILTER（H， 'SCHEMA'， 'SCOTT'）; - 请求将元数据转换为创建DDL。 th：= DBMS_METADATA.ADD_TRANSFORM（h，'DDL'）; - 获取对象。LOOP doc：= DBMS_METADATA.FETCH_CLOB（h）; - 当没有更多对象要检索时，FETCH_CLOB返回NULL。当doc为NULL时退出; - 将元数据存储在表格中。INSERT INTO my_metadata（md）VALUES（doc）;承诺;结束循环; - 释放资源。DBMS_METADATA.CLOSE（H）;结束; /</pre></li>
                           <li>
                              <p>执行程序：</p><pre class="oac_no_warn" dir="ltr">执行get_tables_md;</pre></li>
                           <li>
                              <p>查询<code class="codeph">my_metadata</code>表以查看检索到的内容：</p><pre class="oac_no_warn" dir="ltr">SET LONG 9000000 SET PAGES 0 SELECT * FROM my_metadata;</pre></li>
                        </ol>
                     </div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="using-oracle-dbms_metadata-api.html#GUID-EE2AA635-EA83-4265-9727-E9C659842CEF" title="DBMS_METADATA API的检索接口允许您指定要检索的对象的类型。">使用DBMS_METADATA API检索对象的元数据</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="SUTIL3621"></a><a id="SUTIL3622"></a><a id="SUTIL1627"></a><div class="props_rev_3"><a id="GUID-27965831-A88D-4723-8402-F31DC9839B71" name="GUID-27965831-A88D-4723-8402-F31DC9839B71"></a><h4 id="SUTIL-GUID-27965831-A88D-4723-8402-F31DC9839B71" class="sect4"><span class="enumeration_section">23.3.3</span>在变换上放置条件</h4>
                  <div>
                     <p>您可以使用变换参数指定要添加的变换的条件。</p>
                     <div class="section">
                        <p>为此，请使用<code class="codeph">SET_TRANSFORM_PARAM</code>过程。例如，如果已为<code class="codeph">TABLE</code>对象添加了<code class="codeph">DDL</code>转换，则可以指定<code class="codeph">SEGMENT_ATTRIBUTES</code>转换参数，以指示您不希望段属性（物理，存储，日志记录等）出现在DDL中。默认情况下，段属性确实出现在DDL中。</p>
                        <p><a href="using-oracle-dbms_metadata-api.html#GUID-27965831-A88D-4723-8402-F31DC9839B71__I1014066">例23-4</a>显示了<code class="codeph">SET_TRANSFORM_PARAM</code>过程的使用。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-27965831-A88D-4723-8402-F31DC9839B71__I1014066">
                        <p class="titleinexample">例23-4在变换上放置条件</p>
                        <ol>
                           <li>
                              <p>创建一个名为<code class="codeph">get_table_md</code> ，如下所示：</p><pre class="oac_no_warn" dir="ltr">创建或替换函数get_table_md RETURN CLOB IS  - 定义局部变量。h NUMBER; - '打开'号码返回的句柄; - 'ADD_TRANSFORM'doc CLOB返回的句柄; BEGIN  - 指定对象类型。h：= DBMS_METADATA.OPEN（'TABLE'）; - 使用过滤器指定所需的特定对象。DBMS_METADATA.SET_FILTER（H， 'SCHEMA'， 'HR'）; DBMS_METADATA.SET_FILTER（H， 'NAME'， '考勤卡'）; - 请求将元数据转换为创建DDL。 th：= dbms_metadata.add_transform（h，'DDL'）; - 指定不返回段属性。- 请注意，此调用使用TRANSFORM句柄，而不是OPEN句柄。DBMS_METADATA.SET_TRANSFORM_PARAM（日 'SEGMENT_ATTRIBUTES'，假）; - 获取对象。doc：= DBMS_METADATA.FETCH_CLOB（h）; - 释放资源。DBMS_METADATA.CLOSE（H）;返回文档;结束; /</pre></li>
                           <li>
                              <p>执行以下查询：</p><pre class="oac_no_warn" dir="ltr">SQL&gt; SELECT get_table_md FROM dual;</pre><p>输出类似于以下内容：</p><pre class="oac_no_warn" dir="ltr">创建表“HR”。“TIMECARDS”（“EMPLOYEE_ID”编号（6,0），“周”编号（2,0），“JOB_ID”VARCHAR2（10），“HOURS_WORKED”编号（4,2），外键（“EMPLOYEE_ID”）参考“HR”。“EMPLOYEES”（“EMPLOYEE_ID”）ENABLE）</pre></li>
                        </ol>
                        <p>到目前为止所示的示例使用了单个变换，即<code class="codeph">DDL</code>变换。<code class="codeph">DBMS_METADATA</code> API还允许您指定多个转换，第一个的输出是下一个的输入，依此类推。
                        </p>
                        <p>Oracle提供了一个名为<code class="codeph">MODIFY</code>的转换，用于修改XML文档。您可以执行更改架构名称或表空间名称等操作。为此，请使用重映射参数和<code class="codeph">SET_REMAP_PARAM</code>过程。
                        </p>
                        <p><a href="using-oracle-dbms_metadata-api.html#GUID-27965831-A88D-4723-8402-F31DC9839B71__I1014070">例23-5</a>显示了<code class="codeph">SET_REMAP_PARAM</code>过程的示例用法。它首先添加<code class="codeph">MODIFY</code>转换并指定重映射参数以将模式名称从<code class="codeph">hr</code>更改为<code class="codeph">scott</code> 。然后添加<code class="codeph">DDL</code>转换。<code class="codeph">MODIFY</code>转换的输出是一个XML文档，它成为<code class="codeph">DDL</code>转换的输入。最终结果是为时间<code class="codeph">timecards</code>表创建DDL，并将模式<code class="codeph">hr</code>所有实例更改为<code class="codeph">scott</code> 。
                        </p>
                     </div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-27965831-A88D-4723-8402-F31DC9839B71__I1014070">
                        <p class="titleinexample">示例23-5修改XML文档</p>
                        <ol>
                           <li>
                              <p>创建一个名为remap_schema的函数：</p><pre class="oac_no_warn" dir="ltr">CREATE或REPLACE FUNCTION remap_schema RETURN CLOB IS  - 定义局部变量。h NUMBER; - 由OPEN号码返回的句柄; -  ADD_TRANSFORM doc CLOB返回的句柄; BEGIN  - 指定对象类型。h：= DBMS_METADATA.OPEN（'TABLE'）; - 使用过滤器指定所需的特定对象。DBMS_METADATA.SET_FILTER（H， 'SCHEMA'， 'HR'）; DBMS_METADATA.SET_FILTER（H， 'NAME'， '考勤卡'）; - 请求修改架构名称。th：= DBMS_METADATA.ADD_TRANSFORM（h，'MODIFY'）; DBMS_METADATA.SET_REMAP_PARAM（日 'REMAP_SCHEMA'， 'HR'， 'SCOTT'）; - 请求将元数据转换为创建DDL。 th：= DBMS_METADATA.ADD_TRANSFORM（h，'DDL'）; - 指定不返回段属性。DBMS_METADATA.SET_TRANSFORM_PARAM（日 'SEGMENT_ATTRIBUTES'，假）; - 获取对象。doc：= DBMS_METADATA.FETCH_CLOB（h）; - 释放资源。DBMS_METADATA.CLOSE（H）;返回文档;结束; /</pre></li>
                           <li>
                              <p>执行以下查询：</p><pre class="oac_no_warn" dir="ltr">SELECT remap_schema FROM dual;</pre><p>输出类似于以下内容：</p><pre class="oac_no_warn" dir="ltr">创建表“SCOTT”。“TIMECARDS”（“EMPLOYEE_ID”号码（6,0），“周”号（2,0），“JOB_ID”VARCHAR2（10），“HOURS_WORKED”号码（4,2），外键（“EMPLOYEE_ID”）参考“SCOTT”。“EMPLOYEES”（“EMPLOYEE_ID”）ENABLE）</pre><p>如果您熟悉XSLT，则可以添加自己的用户编写的转换来处理XML。</p>
                           </li>
                        </ol>
                     </div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="using-oracle-dbms_metadata-api.html#GUID-EE2AA635-EA83-4265-9727-E9C659842CEF" title="DBMS_METADATA API的检索接口允许您指定要检索的对象的类型。">使用DBMS_METADATA API检索对象的元数据</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="SUTIL3623"></a><a id="SUTIL1628"></a><div class="props_rev_3"><a id="GUID-BB45CA8D-2621-419B-906C-1E811499786A" name="GUID-BB45CA8D-2621-419B-906C-1E811499786A"></a><h4 id="SUTIL-GUID-BB45CA8D-2621-419B-906C-1E811499786A" class="sect4"><span class="enumeration_section">23.3.4</span>访问特定元数据属性</h4>
                  <div>
                     <p>访问特定元数据属性的描述和示例。</p>
                     <div class="section">
                        <p>通常需要访问对象元数据的特定属性，例如，其名称或模式。您可以通过解析返回的元数据来获取此信息，但<code class="codeph">DBMS_METADATA</code> API提供了另一种机制;您可以指定解析项，将从元数据中解析并在单独的数据结构中返回的特定属性。为此，请使用<code class="codeph">SET_PARSE_ITEM</code>过程。
                        </p>
                        <p><a href="using-oracle-dbms_metadata-api.html#GUID-BB45CA8D-2621-419B-906C-1E811499786A__I1014074">示例23-6</a>获取模式中的所有表。对于每个表，使用解析项来获取其名称。然后使用该名称获取表中的所有索引。该示例说明了<code class="codeph">FETCH_DDL</code>函数的使用，该函数返回<code class="codeph">sys</code>元数据。 <code class="codeph">ku$_ddls</code>对象。
                        </p>
                        <p>此示例假定您已连接到包含某些表和索引的架构。它还会创建一个名为<code class="codeph">my_metadata</code>的表。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-BB45CA8D-2621-419B-906C-1E811499786A__I1014074">
                        <p class="titleinexample">示例23-6使用解析项访问特定元数据属性</p>
                        <ol>
                           <li>
                              <p>创建一个表名为<code class="codeph">my_metadata</code>和一个名为程序<code class="codeph">get_tables_and_indexes</code> ，具体如下：</p><pre class="oac_no_warn" dir="ltr">DROP TABLE my_metadata; CREATE TABLE my_metadata（object_type VARCHAR2（30），name VARCHAR2（30），md CLOB）;创建或替换过程get_tables_and_indexes IS  - 定义局部变量。h1号码; -  OPEN为表格h2 NUMBER返回的句柄; -  OPEN为索引th1 NUMBER返回的句柄; -  ADD_TRANSFORM为表格th2 NUMBER返回的句柄; -  ADD_TRANSFORM为索引doc sys.ku $ _ddls返回的句柄; - 在sys.ku $ _ddls中返回元数据， -  sys.ku $ _ddl对象的嵌套表ddl CLOB; - 为对象pi sys.ku $ _parsed_items创建DDL; - 在此对象中返回解析项 - 它包含在sys.ku $ _ddl objname VARCHAR2（30）中; - 解析的对象名称idxddls sys.ku $ _ddls; - 在sys.ku $ _ddls中返回元数据， -  sys.ku $ _ddl对象的嵌套表idxname VARCHAR2（30）; - 解析的索引名称BEGIN  - 此过程有一个外部循环，用于获取表，以及一个内部循环，用于获取索引。- 指定对象类型：TABLE。 h1：= DBMS_METADATA.OPEN（'TABLE'）; - 请求将表名作为解析项返回。DBMS_METADATA.SET_PARSE_ITEM（H1， 'NAME'）; - 请求将元数据转换为创建DDL。 th1：= DBMS_METADATA.ADD_TRANSFORM（h1，'DDL'）; - 指定不返回段属性。DBMS_METADATA.SET_TRANSFORM_PARAM（TH1， 'SEGMENT_ATTRIBUTES'，假）; - 设置外部循环：获取TABLE对象。LOOP doc：= dbms_metadata.fetch_ddl（h1）; - 当没有更多要检索的对象时，FETCH_DDL返回NULL。当doc为NULL时退出; - 循环遍历ku $ _ddls嵌套表的行。我的文件。FIRST..doc。最后的循环ddl：= doc（i）.ddlText; pi：= doc（i）.parsedItems; - 遍历返回的解析项。如果pi不是NULL和pi。COUNT&gt; 0那么j IN pi。FIRST..pi。最后一圈如果pi（j）.item ='NAME'那么objname：= pi（j）.value;万一;结束循环;万一; - 将有关此对象的信息插入到我们的表中。INSERT INTO my_metadata（object_type，name，md）VALUES（'TABLE'，objname，ddl）;承诺;结束循环; - 现在使用解析后的表名称获取索引 -  BASE_OBJECT_NAME过滤器。- 指定对象类型。h2：= DBMS_METADATA.OPEN（'INDEX'）; - 基础对象是在外部循环中检索的表。DBMS_METADATA.SET_FILTER（H2， 'BASE_OBJECT_NAME'，objname表）; - 排除系统生成的索引。DBMS_METADATA.SET_FILTER（H2， 'SYSTEM_GENERATED'，假）; - 请求将索引名称作为解析项返回。DBMS_METADATA.SET_PARSE_ITEM（H 2， 'NAME'）; - 请求将元数据转换为创建DDL。 th2：= DBMS_METADATA.ADD_TRANSFORM（h2，'DDL'）; - 指定不返回段属性。DBMS_METADATA.SET_TRANSFORM_PARAM（TH2， 'SEGMENT_ATTRIBUTES'，假）; LOOP idxddls：= dbms_metadata.fetch_ddl（h2）; - 当没有更多要检索的对象时，FETCH_DDL返回NULL。当idxddls为NULL时退出;我在idxddls。FIRST..idxddls。最后的循环ddl：= idxddls（i）.ddlText; pi：= idxddls（i）.parsedItems; - 遍历返回的解析项。如果pi不是NULL和pi。COUNT&gt; 0那么j IN pi。FIRST..pi。最后一圈如果pi（j）.item ='NAME'那么idxname：= pi（j）.value;万一;结束循环;万一; - 将元数据存储在我们的表中。INSERT INTO my_metadata（object_type，name，md）VALUES（'INDEX'，idxname，ddl）;承诺;结束循环; -  for loop END LOOP; DBMS_METADATA.CLOSE（H2）;结束循环; DBMS_METADATA.CLOSE（H1）;结束; /</pre></li>
                           <li>
                              <p>执行程序：</p><pre class="oac_no_warn" dir="ltr">执行get_tables_and_indexes;</pre></li>
                           <li>
                              <p>执行以下查询以查看检索到的内容：</p><pre class="oac_no_warn" dir="ltr">SET LONG 9000000 SET PAGES 0 SELECT * FROM my_metadata;</pre></li>
                        </ol>
                     </div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="using-oracle-dbms_metadata-api.html#GUID-EE2AA635-EA83-4265-9727-E9C659842CEF" title="DBMS_METADATA API的检索接口允许您指定要检索的对象的类型。">使用DBMS_METADATA API检索对象的元数据</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div><a id="SUTIL3624"></a><a id="SUTIL1629"></a><div class="props_rev_2"><a id="GUID-1DA999FD-1AFD-4D8D-A6D0-8EEB84E0D9E4" name="GUID-1DA999FD-1AFD-4D8D-A6D0-8EEB84E0D9E4"></a><h3 id="SUTIL-GUID-1DA999FD-1AFD-4D8D-A6D0-8EEB84E0D9E4" class="sect3"><span class="enumeration_section">23.4</span>使用DBMS_METADATA API重新创建检索对象</h3>
               <div>
                  <p>获取对象的元数据时，可能希望使用它在不同的数据库或模式中重新创建对象。</p>
                  <div class="section">
                     <p>在获取元数据时，您可能还没有准备好做出重新映射决策。您可能希望将这些决定推迟到以后。为此，您将元数据作为XML获取并将其存储在文件或表中。稍后您可以使用提交界面重新创建对象。</p>
                     <p>提交界面在形式上与检索界面类似。它有一个<code class="codeph">OPENW</code>过程，您可以在其中指定要创建的对象的对象类型。您可以指定变换，变换参数和解析项目。您可以调用<code class="codeph">CONVERT</code>函数将XML转换为DDL，也可以调用<code class="codeph">PUT</code>函数将XML转换为DDL并提交DDL以创建对象。
                     </p>
                     <p><a href="using-oracle-dbms_metadata-api.html#GUID-1DA999FD-1AFD-4D8D-A6D0-8EEB84E0D9E4__I1014078">示例23-7</a>为一个模式中的表获取XML，然后使用submit接口在另一个模式中重新创建表。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-1DA999FD-1AFD-4D8D-A6D0-8EEB84E0D9E4__I1014078">
                     <p class="titleinexample">示例23-7使用提交界面重新创建检索到的对象</p>
                     <ol>
                        <li>
                           <p>以特权用户身份连接：</p><pre class="oac_no_warn" dir="ltr">CONNECT系统输入密码： <span class="italic">密码</span>
</pre></li>
                        <li>
                           <p>创建一个调用者权限包来保存该过程，因为访问另一个模式中的对象需要<code class="codeph">SELECT_CATALOG_ROLE</code>角色。在定义者权限PL / SQL对象（例如过程或函数）中，角色被禁用。
                           </p><pre class="oac_no_warn" dir="ltr">创建或替换包example_pkg AUTHID current_user IS PROCEDURE move_table（VARCHAR2中的table_name，VARCHAR2中的from_schema，VARCHAR2中的to_schema）; END example_pkg; / CREATE或REPLACE PACKAGE BODY example_pkg IS程序move_table（VARCHAR2中的table_name，VARCHAR2中的from_schema，VARCHAR2中的to_schema）IS  - 定义局部变量。h1号码; -  OPEN h2 NUMBER返回的句柄; -  OPENW th1 NUMBER返回的句柄; -  ADD_TRANSFORM为MODIFY th2 NUMBER返回的句柄; -  ADD_TRANSFORM为DDL xml CLOB返回的句柄; -  XML文档错误sys.ku $ _SubmitResults：= sys.ku $ _SubmitResults（）;错误的sys.ku $ _SubmitResult;结果BOOLEAN; BEGIN  - 指定对象类型。h1：= DBMS_METADATA.OPEN（'TABLE'）; - 使用过滤器指定表的名称和架构。DBMS_METADATA.SET_FILTER（H1， 'NAME'，表名）; DBMS_METADATA.SET_FILTER（H1， 'SCHEMA'，from_schema）; - 获取XML。 xml：= DBMS_METADATA.FETCH_CLOB（h1）; IF xml IS NULL，然后是DBMS_OUTPUT.PUT_LINE（'表'|| from_schema ||'。'|| table_name ||'not found'）;返回;万一; - 释放资源。DBMS_METADATA.CLOSE（H1）; - 使用submit接口在另一个模式中重新创建对象。- 使用OPENW（而不是OPEN）指定对象类型。h2：= DBMS_METADATA.OPENW（'TABLE'）; - 首先，添加MODIFY变换。th1：= DBMS_METADATA.ADD_TRANSFORM（h2，'MODIFY'）; - 指定所需的修改：重新映射架构名称。DBMS_METADATA.SET_REMAP_PARAM（TH1， 'REMAP_SCHEMA'，from_schema，to_schema）; - 现在添加DDL转换，以便修改后的XML可以转换为创建DDL。 th2：= DBMS_METADATA.ADD_TRANSFORM（h2，'DDL'）; - 调用PUT重新创建对象。结果：= DBMS_METADATA.PUT（h2，xml，0，errs）; DBMS_METADATA.CLOSE（H2）;如果不是结果那么 - 处理错误信息。因为我错了。FIRST..errs。最后的循环错误：=错误（i）; FOR j IN err.errorLines。FIRST..err.errorLines。最后的循环dbms_output.put_line（err.errorLines（j）.errorText）;结束循环;结束循环;万一;结束; END example_pkg; /</pre></li>
                        <li>
                           <p>现在在模式<code class="codeph">SCOTT</code>创建一个名为<code class="codeph">my_example</code>的表：</p><pre class="oac_no_warn" dir="ltr">CONNECT scott输入密码： - 密码为tiger。DROP TABLE my_example; CREATE TABLE my_example（一个NUMBER，b VARCHAR2（30））; CONNECT系统输入密码： <span class="italic">密码</span> SET LONG 9000000 SET PAGESIZE 0 SET SERVEROUTPUT ON SIZE 100000</pre></li>
                        <li>
                           <p>将<code class="codeph">my_example</code>表复制到<code class="codeph">SYSTEM</code>模式：</p><pre class="oac_no_warn" dir="ltr">DROP TABLE my_example; EXECUTE example_pkg.move_table（'MY_EXAMPLE'，'SCOTT'，'SYSTEM'）;</pre></li>
                        <li>
                           <p>执行以下查询以验证它是否有效：</p><pre class="oac_no_warn" dir="ltr">SELECT DBMS_METADATA.GET_DDL（'TABLE'，'MY_EXAMPLE'）FROM dual;</pre></li>
                     </ol>
                  </div>
                  <!-- class="example" -->
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="using-oracle-dbms_metadata-api.html#GUID-D9B1300F-B21D-416E-8B9B-C542195EF249" title="使用DBMS_METADATA API。">使用元数据API</a></p>
                     </div>
                  </div>
               </div>
               
            </div><a id="SUTIL3625"></a><a id="SUTIL1630"></a><div class="props_rev_3"><a id="GUID-85AC0B9A-5C6E-4D2A-A3CA-30F5F7884048" name="GUID-85AC0B9A-5C6E-4D2A-A3CA-30F5F7884048"></a><h3 id="SUTIL-GUID-85AC0B9A-5C6E-4D2A-A3CA-30F5F7884048" class="sect3"><span class="enumeration_section">23.5</span>使用DBMS_METADATA API检索不同对象类型的集合</h3>
               <div>
                  <p>检索不同对象类型的集合的描述和示例。</p>
                  <p>有时您可能需要检索对象集合，其中对象具有不同类型，但包含逻辑单元。例如，您可能需要检索数据库或模式或表中的所有对象及其所有依赖索引，约束，授权，审计等。为了使这种检索成为可能， <code class="codeph">DBMS_METADATA</code> API提供了几种异构对象类型。异构对象类型是一组有序的对象类型。
                  </p>
                  <p>Oracle提供以下异构对象类型：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><code class="codeph">TABLE_EXPORT</code> - 表及其依赖对象</p>
                     </li>
                     <li>
                        <p><code class="codeph">SCHEMA_EXPORT</code> - 模式及其内容</p>
                     </li>
                     <li>
                        <p><code class="codeph">DATABASE_EXPORT</code> - 数据库中的对象</p>
                     </li>
                  </ul>
                  <p>这些对象类型是为Data Pump Export实用程序开发的，但您可以在自己的应用程序中使用它们。</p>
                  <p>您只能使用这些类型的编程检索接口（ <code class="codeph">OPEN</code> ， <code class="codeph">FETCH</code> ， <code class="codeph">CLOSE</code> ），而不能使用浏览界面或提交界面。
                  </p>
                  <p>您可以为异构对象类型指定过滤器，就像对同类型一样。例如，您可以指定<code class="codeph">SCHEMA</code>和<code class="codeph">NAME</code>进行过滤<code class="codeph">TABLE_EXPORT</code> ，或<code class="codeph">SCHEMA</code>用于过滤<code class="codeph">SCHEMA_EXPORT</code> 。</p>
                  <p><a href="using-oracle-dbms_metadata-api.html#GUID-85AC0B9A-5C6E-4D2A-A3CA-30F5F7884048__I1014082">示例23-8</a>显示了如何检索<code class="codeph">scott</code>模式中的对象类型。以用户<code class="codeph">scott</code>身份连接。密码是<code class="codeph">tiger</code> 。
                  </p>
                  <div class="example" id="GUID-85AC0B9A-5C6E-4D2A-A3CA-30F5F7884048__I1014082">
                     <p class="titleinexample">示例23-8检索异构对象类型</p>
                     <ol>
                        <li>
                           <p>创建一个表来存储检索到的对象：</p><pre class="oac_no_warn" dir="ltr">DROP TABLE my_metadata; CREATE TABLE my_metadata（md CLOB）;创建或替换过程get_schema_md IS  - 定义局部变量。h NUMBER; -  OPEN号码返回的句柄; -  ADD_TRANSFORM doc CLOB返回的句柄; - 在CLOB BEGIN中返回元数据 - 指定对象类型。h：= DBMS_METADATA.OPEN（'SCHEMA_EXPORT'）; - 使用过滤器指定架构。DBMS_METADATA.SET_FILTER（H， 'SCHEMA'， 'SCOTT'）; - 请求将元数据转换为创建DDL。 th：= DBMS_METADATA.ADD_TRANSFORM（h，'DDL'）; - 获取对象。LOOP doc：= DBMS_METADATA.FETCH_CLOB（h）; - 当没有更多对象要检索时，FETCH_CLOB返回NULL。当doc为NULL时退出; - 将元数据存储在表中。INSERT INTO my_metadata（md）VALUES（doc）;承诺;结束循环; - 释放资源。DBMS_METADATA.CLOSE（H）;结束; /</pre></li>
                        <li>
                           <p>执行程序：</p><pre class="oac_no_warn" dir="ltr">执行get_schema_md;</pre></li>
                        <li>
                           <p>执行以下查询以查看检索到的内容：</p><pre class="oac_no_warn" dir="ltr">SET LONG 9000000 SET PAGESIZE 0 SELECT * FROM my_metadata;</pre></li>
                     </ol>
                     <p>在此示例中，按对象类型按顺序返回对象;例如，返回所有表，然后是表上的所有授权，然后是表上的所有索引，依此类推。一般来说，订单是有效的创建订单。因此，如果按照返回的顺序获取对象并使用提交接口在另一个模式或数据库中以相同的顺序重新创建它们，那么通常不会出现错误。（例外通常涉及循环引用;例如，如果包A包含对包B的调用，而包B包含对包A的调用，则其中一个包将需要第二次重新编译。）</p>
                  </div>
                  <!-- class="example" -->
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="using-oracle-dbms_metadata-api.html#GUID-E0EEE23F-EDED-40D2-BAE7-A1F5FF951589">过滤异构对象类型的返回</a><br>过滤异构对象类型返回的描述和示例。
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="using-oracle-dbms_metadata-api.html#GUID-D9B1300F-B21D-416E-8B9B-C542195EF249" title="使用DBMS_METADATA API。">使用元数据API</a></p>
                     </div>
                  </div>
               </div>
               <a id="SUTIL3626"></a><a id="SUTIL1631"></a><div class="props_rev_3"><a id="GUID-E0EEE23F-EDED-40D2-BAE7-A1F5FF951589" name="GUID-E0EEE23F-EDED-40D2-BAE7-A1F5FF951589"></a><h4 id="SUTIL-GUID-E0EEE23F-EDED-40D2-BAE7-A1F5FF951589" class="sect4"><span class="enumeration_section">23.5.1</span>过滤异构对象类型的返回</h4>
                  <div>
                     <p>过滤异构对象类型返回的描述和示例。</p>
                     <div class="section">
                        <p>要更好地控制返回的对象，请使用<code class="codeph">SET_FILTER</code>过程并指定过滤器仅应用于特定成员类型。您可以通过将成员类型的路径名指定为<code class="codeph">SET_FILTER</code>的第四个参数来<code class="codeph">SET_FILTER</code> 。此外，您可以使用<code class="codeph">EXCLUDE_PATH_EXPR</code>过滤器来排除对象类型的所有对象。有关有效路径名的列表，请参见<code class="codeph">TABLE_EXPORT_OBJECTS</code>目录视图。
                        </p>
                        <p><a href="using-oracle-dbms_metadata-api.html#GUID-E0EEE23F-EDED-40D2-BAE7-A1F5FF951589__I1014087">例23-9</a>显示了如何使用<code class="codeph">SET_FILTER</code>指定对返回对象的更精细控制。以用户<code class="codeph">scott</code>身份连接。密码是<code class="codeph">tiger</code> 。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-E0EEE23F-EDED-40D2-BAE7-A1F5FF951589__I1014087">
                        <p class="titleinexample">示例23-9过滤异构对象类型的返回</p>
                        <ol>
                           <li>
                              <p>创建一个表<code class="codeph">my_metadata</code>来存储检索到的对象。并创建一个过程<code class="codeph">get_schema_md2</code> 。
                              </p><pre class="oac_no_warn" dir="ltr">DROP TABLE my_metadata; CREATE TABLE my_metadata（md CLOB）;创建或替换过程get_schema_md2 IS  - 定义局部变量。h NUMBER; - '打开'号码返回的句柄; - 'ADD_TRANSFORM'doc CLOB返回的句柄; - 在CLOB BEGIN中返回元数据 - 指定对象类型。h：= DBMS_METADATA.OPEN（'SCHEMA_EXPORT'）; - 使用过滤器指定架构。DBMS_METADATA.SET_FILTER（H， 'SCHEMA'， 'SCOTT'）; - 使用SET_FILTER的第四个参数指定过滤器 - 适用于特定成员对象类型。DBMS_METADATA.SET_FILTER（H， 'NAME_EXPR'，'！= '' MY_METADATA ''”， 'TABLE'）; - 使用EXCLUDE_PATH_EXPR过滤器排除过程。DBMS_METADATA.SET_FILTER（H， 'EXCLUDE_PATH_EXPR'， '=' '过程' ''）; - 请求将元数据转换为创建DDL。 th：= DBMS_METADATA.ADD_TRANSFORM（h，'DDL'）; - 使用SET_TRANSFORM_PARAM的第四个参数指定一个参数 - 该参数适用于特定的成员对象类型。DBMS_METADATA.SET_TRANSFORM_PARAM（日 'SEGMENT_ATTRIBUTES'，假， 'TABLE'）; - 获取对象。LOOP doc：= dbms_metadata.fetch_clob（h）; - 当没有更多对象要检索时，FETCH_CLOB返回NULL。当doc为NULL时退出; - 将元数据存储在表中。INSERT INTO my_metadata（md）VALUES（doc）;承诺;结束循环; - 释放资源。DBMS_METADATA.CLOSE（H）;结束; /</pre></li>
                           <li>
                              <p>执行程序：</p><pre class="oac_no_warn" dir="ltr">执行get_schema_md2;</pre></li>
                           <li>
                              <p>执行以下查询以查看检索到的内容：</p><pre class="oac_no_warn" dir="ltr">SET LONG 9000000 SET PAGESIZE 0 SELECT * FROM my_metadata;</pre></li>
                        </ol>
                     </div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="using-oracle-dbms_metadata-api.html#GUID-85AC0B9A-5C6E-4D2A-A3CA-30F5F7884048" title="检索不同对象类型的集合的描述和示例。">使用DBMS_METADATA API检索不同对象类型的集合</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div><a id="SUTIL3628"></a><a id="SUTIL3627"></a><div class="props_rev_3"><a id="GUID-E9A778A7-2E9D-4240-8707-A52FF65556FE" name="GUID-E9A778A7-2E9D-4240-8707-A52FF65556FE"></a><h3 id="SUTIL-GUID-E9A778A7-2E9D-4240-8707-A52FF65556FE" class="sect3"><span class="enumeration_section">23.6</span>使用DBMS_METADATA_DIFF API比较对象元数据</h3>
               <div>
                  <p>使用<code class="codeph">DBMS_METADATA</code>和<code class="codeph">DBMS_METADATA_DIFF</code>的检索，比较和提交接口来获取两个表的元数据，比较元数据并生成使一个表像另一个表的<code class="codeph">ALTER</code>语句的描述和示例。
                  </p>
                  <div class="section">
                     <p>为简单起见，在整个示例中使用了函数变体。</p>
                  </div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-E9A778A7-2E9D-4240-8707-A52FF65556FE__GUID-7A7FE9D7-77D8-483F-8B18-37FE39CCE24F">
                     <p class="titleinexample">示例23-10比较对象元数据</p>
                     <ol>
                        <li>
                           <p>创建两个表， <code class="codeph">TAB1</code>和<code class="codeph">TAB2</code> ：</p><pre class="oac_no_warn" dir="ltr">SQL&gt; CREATE TABLE TAB1 2（“EMPNO”NUMBER（4,0），3“ENAME”VARCHAR2（10），4“JOB”VARCHAR2（9），5“DEPTNO”NUMBER（2,0）6）;表创建。SQL&gt; CREATE TABLE TAB2 2（“EMPNO”编号（4,0）PRIMARY KEY ENABLE，3“ENAME”VARCHAR2（20），4“MGR”编号（4,0），5“DEPTNO”编号（2,0） 6）;表创建。
 </pre><p>注意<code class="codeph">TAB1</code>和<code class="codeph">TAB2</code>之间的区别：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>表名不同</p>
                              </li>
                              <li>
                                 <p><code class="codeph">TAB2</code>具有主键约束; <code class="codeph">TAB1</code>没有</p>
                              </li>
                              <li>
                                 <p>每个表中<code class="codeph">ENAME</code>列的长度不同</p>
                              </li>
                              <li>
                                 <p><code class="codeph">TAB1</code>有一个<code class="codeph">JOB</code>列; <code class="codeph">TAB2</code>没有</p>
                              </li>
                              <li>
                                 <p><code class="codeph">TAB2</code>有一个<code class="codeph">MGR</code>列; <code class="codeph">TAB1</code>没有</p>
                              </li>
                           </ul>
                        </li>
                        <li>
                           <p>创建一个函数以SXML格式返回表元数据。以下是使用<code class="codeph">DBMS_METADATA_DIFF</code> API时要记住的有关SXML的一些要点：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>SXML是对象元数据的XML表示。</p>
                              </li>
                              <li>
                                 <p>返回的SXML与<code class="codeph">DBMS_METADATA.GET_XML</code>返回的XML不同，后者复杂且不透明，包含二进制值，特定于实例的值等。
                                 </p>
                              </li>
                              <li>
                                 <p>SXML看起来像是将SQL创建DDL直接转换为XML。标记名称和结构对应于<a href="../sqlrf/SQL-Statements-ADMINISTER-KEY-MANAGEMENT-to-ALTER-JAVA.html#SQLRF008" target="_blank"><span class="italic">Oracle数据库SQL语言参考中的名称</span></a> 。
                                 </p>
                              </li>
                              <li>
                                 <p>SXML旨在支持编辑和比较。</p>
                              </li>
                           </ul>
                           <p>为了简化此示例，使用transform参数来抑制物理属性：</p><pre class="oac_no_warn" dir="ltr">SQL&gt; CREATE OR REPLACE FUNCTION get_table_sxml（name IN VARCHAR2）RETURN CLOB IS 2 open_handle NUMBER; 3 transform_handle NUMBER; 4 doc CLOB; 5 BEGIN 6 open_handle：= DBMS_METADATA.OPEN（'TABLE'）; 7 DBMS_METADATA.SET_FILTER（open_handle，'NAME'，name）; 8  -  9  - 使用'SXML'转换将XML转换为SXML 10  -  11 transform_handle：= DBMS_METADATA.ADD_TRANSFORM（open_handle，'SXML'）; 12  -  13  - 使用此变换参数来抑制物理属性14  -  15 DBMS_METADATA.SET_TRANSFORM_PARAM（transform_handle，'PHYSICAL_PROPERTIES'，16 FALSE）; 17 doc：= DBMS_METADATA.FETCH_CLOB（open_handle）; 18 DBMS_METADATA.CLOSE（open_handle）; 19 RETURN doc; 20结束; 21 /创建功能。
 </pre></li>
                        <li>
                           <p>使用<code class="codeph">get_table_sxml</code>函数获取两个表的表SXML：</p><pre class="oac_no_warn" dir="ltr">SQL&gt; SELECT get_table_sxml（'TAB1'）FROM dual; &lt;TABLE xmlns =“http://xmlns.oracle.com/ku”version =“1.0”&gt; &lt;SCHEMA&gt; SCOTT &lt;/ SCHEMA&gt; &lt;NAME&gt; TAB1 &lt;/ NAME&gt; &lt;RELATIONAL_TABLE&gt; &lt;COL_LIST&gt; &lt;COL_LIST_ITEM&gt; &lt;NAME &gt; EMPNO &lt;/ NAME&gt; &lt;DATATYPE&gt; NUMBER &lt;/ DATATYPE&gt; &lt;PRECISION&gt; 4 &lt;/ PRECISION&gt; &lt;SCALE&gt; 0 &lt;/ SCALE&gt; &lt;/ COL_LIST_ITEM&gt; &lt;COL_LIST_ITEM&gt; &lt;NAME&gt; ENAME &lt;/ NAME&gt; &lt;DATATYPE&gt; VARCHAR2 &lt; / DATATYPE&gt; &lt;LENGTH&gt; 10 &lt;/ LENGTH&gt; &lt;/ COL_LIST_ITEM&gt; &lt;COL_LIST_ITEM&gt; &lt;NAME&gt; JOB &lt;/ NAME&gt; &lt;DATATYPE&gt; VARCHAR2 &lt;/ DATATYPE&gt; &lt;LENGTH&gt; 9 &lt;/ LENGTH&gt; &lt;/ COL_LIST_ITEM&gt; &lt;COL_LIST_ITEM&gt; &lt; NAME&gt; DEPTNO &lt;/ NAME&gt; &lt;DATATYPE&gt; NUMBER &lt;/ DATATYPE&gt; &lt;PRECISION&gt; 2 &lt;/ PRECISION&gt; &lt;SCALE&gt; 0 &lt;/ SCALE&gt; &lt;/ COL_LIST_ITEM&gt; &lt;/ COL_LIST&gt; &lt;/ RELATIONAL_TABLE&gt; &lt;/ TABLE&gt;选择1行。SQL&gt; SELECT get_table_sxml（'TAB2'）FROM dual; &lt;TABLE xmlns =“http://xmlns.oracle.com/ku”version =“1.0”&gt; &lt;SCHEMA&gt; SCOTT &lt;/ SCHEMA&gt; &lt;NAME&gt; TAB2 &lt;/ NAME&gt; &lt;RELATIONAL_TABLE&gt; &lt;COL_LIST&gt; &lt;COL_LIST_ITEM&gt; &lt;NAME &gt; EMPNO &lt;/ NAME&gt; &lt;DATATYPE&gt; NUMBER &lt;/ DATATYPE&gt; &lt;PRECISION&gt; 4 &lt;/ PRECISION&gt; &lt;SCALE&gt; 0 &lt;/ SCALE&gt; &lt;/ COL_LIST_ITEM&gt; &lt;COL_LIST_ITEM&gt; &lt;NAME&gt; ENAME &lt;/ NAME&gt; &lt;DATATYPE&gt; VARCHAR2 &lt; / DATATYPE&gt; &lt;LENGTH&gt; 20 &lt;/ LENGTH&gt; &lt;/ COL_LIST_ITEM&gt; &lt;COL_LIST_ITEM&gt; &lt;NAME&gt; MGR &lt;/ NAME&gt; &lt;DATATYPE&gt; NUMBER &lt;/ DATATYPE&gt; &lt;PRECISION&gt; 4 &lt;/ PRECISION&gt; &lt;SCALE&gt; 0 &lt;/ SCALE&gt; &lt;/ COL_LIST_ITEM&gt; &lt;COL_LIST_ITEM&gt; &lt;NAME&gt; DEPTNO &lt;/ NAME&gt; &lt;DATATYPE&gt; NUMBER &lt;/ DATATYPE&gt; &lt;PRECISION&gt; 2 &lt;/ PRECISION&gt; &lt;SCALE&gt; 0 &lt;/ SCALE&gt; &lt;/ COL_LIST_ITEM&gt; &lt;/ COL_LIST&gt; &lt;PRIMARY_KEY_CONSTRAINT_LIST&gt; &lt;PRIMARY_KEY_CONSTRAINT_LIST_ITEM&gt; &lt;COL_LIST&gt; &lt;COL_LIST_ITEM&gt; &lt;NAME&gt; EMPNO &lt;/ NAME&gt; &lt;/ COL_LIST_ITEM&gt; &lt;/ COL_LIST&gt; &lt;/ PRIMARY_KEY_CONSTRAINT_LIST_ITEM&gt; &lt;/ PRIMARY_KEY_CONSTRAINT_LIST&gt; &lt;/ RELATIONAL_TABLE&gt; &lt;/ TABLE&gt;选择了1行。
 </pre></li>
                        <li>
                           <p>使用<code class="codeph">DBMS_METADATA</code>浏览API比较结果：</p><pre class="oac_no_warn" dir="ltr">SQL&gt; SELECT dbms_metadata.get_sxml（'TABLE'，'TAB1'）FROM dual; SQL&gt; SELECT dbms_metadata.get_sxml（'TABLE'，'TAB2'）FROM dual;</pre></li>
                        <li>
                           <p>使用<code class="codeph">DBMS_METADATA_DIFF</code> API创建函数以比较两个表的元数据。在此函数中， <code class="codeph">get_table_sxml</code>刚刚在步骤2中定义的<code class="codeph">get_table_sxml</code>函数。
                           </p><pre class="oac_no_warn" dir="ltr">SQL&gt; CREATE OR REPLACE FUNCTION compare_table_sxml（name1 IN VARCHAR2，name2 IN VARCHAR2）RETURN CLOB IS 3 doc1 CLOB; 4 doc2 CLOB; 5 diffdoc CLOB; 6 openc_handle NUMBER; 7 BEGIN 8  -  9  - 获取两个表的SXML 10  -  11 doc1：= get_table_sxml（name1）; 12 doc2：= get_table_sxml（name2）; 13  -  14  - 在OPENC调用中指定对象类型15  -  16 openc_handle：= DBMS_METADATA_DIFF.OPENC（'TABLE'）; 17  -  18  - 添加每个文档19  -  20 DBMS_METADATA_DIFF.ADD_DOCUMENT（openc_handle，doc1）; 21 DBMS_METADATA_DIFF.ADD_DOCUMENT（openc_handle，doc2）; 22  -  23  - 获取SXML差异文档24  -  25 diffdoc：= DBMS_METADATA_DIFF.FETCH_CLOB（openc_handle）; 26 DBMS_METADATA_DIFF.CLOSE（openc_handle）; 27 RETURN diffdoc; 28结束; 29 /创建功能。
</pre></li>
                        <li>
                           <p>使用该函数获取两个表的SXML差异文档：</p><pre class="oac_no_warn" dir="ltr">SQL&gt; SELECT compare_table_sxml（'TAB1'，'TAB2'）FROM dual; &lt;TABLE xmlns =“http://xmlns.oracle.com/ku”version =“1.0”&gt; &lt;SCHEMA&gt; SCOTT &lt;/ SCHEMA&gt; &lt;NAME value1 =“TAB1”&gt; TAB2 &lt;/ NAME&gt; &lt;RELATIONAL_TABLE&gt; &lt;COL_LIST&gt; &lt;COL_LIST_ITEM&gt; &lt;NAME&gt; EMPNO &lt;/ NAME&gt; &lt;DATATYPE&gt; NUMBER &lt;/ DATATYPE&gt; &lt;PRECISION&gt; 4 &lt;/ PRECISION&gt; &lt;SCALE&gt; 0 &lt;/ SCALE&gt; &lt;/ COL_LIST_ITEM&gt; &lt;COL_LIST_ITEM&gt; &lt;NAME&gt; ENAME &lt;/ NAME&gt; &lt;DATATYPE&gt; VARCHAR2 &lt;/ DATATYPE&gt; &lt;LENGTH value1 =“10”&gt; 20 &lt;/ LENGTH&gt; &lt;/ COL_LIST_ITEM&gt; &lt;COL_LIST_ITEM src =“1”&gt; &lt;NAME&gt; JOB &lt;/ NAME&gt; &lt;DATATYPE&gt; VARCHAR2 &lt;/ DATATYPE&gt; &lt; LENGTH&gt; 9 &lt;/ LENGTH&gt; &lt;/ COL_LIST_ITEM&gt; &lt;COL_LIST_ITEM&gt; &lt;NAME&gt; DEPTNO &lt;/ NAME&gt; &lt;DATATYPE&gt; NUMBER &lt;/ DATATYPE&gt; &lt;PRECISION&gt; 2 &lt;/ PRECISION&gt; &lt;SCALE&gt; 0 &lt;/ SCALE&gt; &lt;/ COL_LIST_ITEM&gt; &lt;COL_LIST_ITEM src =“2”&gt; &lt;NAME&gt; MGR &lt;/ NAME&gt; &lt;DATATYPE&gt; NUMBER &lt;/ DATATYPE&gt; &lt;PRECISION&gt; 4 &lt;/ PRECISION&gt; &lt;SCALE&gt; 0 &lt;/ SCALE&gt; &lt;/ COL_LIST_ITEM&gt; &lt;/ COL_LIST&gt; &lt;PRIMARY_KEY_CONSTRAINT_LIST src =“2”&gt; &lt;PRIMARY_KEY_CONSTRAINT_LIST_ITEM&gt; &lt;COL_LIST&gt; &lt;COL_LIST_ITEM&gt; &lt;NAME&gt; EMPNO &lt;/ NAME&gt; &lt;/ COL_LIST_ITEM&gt; &lt;/ COL_LIST&gt; &lt;/ PRIMARY_KEY_CONSTRAINT_LIST_ITEM&gt; &lt;/ PRIMARY_KEY_CONSTRAINT_LIST&gt; &lt;/ RELATIONAL_TABLE&gt; &lt;/ TABLE&gt; 1行se lected。
 </pre><p>SXML差异文档显示了两个SXML文档的并集，XML属性<code class="codeph">value1</code>和<code class="codeph">src</code>标识了差异。当一个元素只存在于一个文档中时，它用<code class="codeph">src</code>标记。因此， <code class="codeph">&lt;COL_LIST_ITEM src="1"&gt;</code>表示此元素位于第一个文档（ <code class="codeph">TAB1</code> ）中，但不在第二个文档中。当一个元素出现在两个文档中但具有不同的值时，元素的值是第二个文档中的<code class="codeph">value1</code>在第一个文档中给出它的值。例如， <code class="codeph">&lt;LENGTH value1="10"&gt;20&lt;/LENGTH&gt;</code>表示<code class="codeph">TAB1</code> （第一个文档）中的长度为10， <code class="codeph">TAB2</code>中的长度为20。
                           </p>
                        </li>
                        <li>
                           <p>使用<code class="codeph">DBMS_METADATA_DIFF</code>浏览API比较结果：</p><pre class="oac_no_warn" dir="ltr">SQL&gt; SELECT dbms_metadata_diff.compare_sxml（'TABLE'，'TAB1'，'TAB2'）FROM dual;</pre></li>
                        <li>
                           <p>使用<code class="codeph">DBMS_METADATA.CONVERT</code> API创建函数以生成ALTERXML文档。这是一个XML文档，包含<code class="codeph">ALTER</code>语句，使一个对象像另一个对象。您还可以使用解析项来获取有关各个<code class="codeph">ALTER</code>语句的信息。（此示例使用到目前为止定义的函数。）
                           </p><pre class="oac_no_warn" dir="ltr">SQL&gt; CREATE OR REPLACE FUNCTION get_table_alterxml（name1 IN VARCHAR2，name2 IN VARCHAR2）RETURN CLOB IS 3 diffdoc CLOB; 4 openw_handle NUMBER; 5 transform_handle NUMBER; 6 alterxml CLOB; 7 BEGIN 8  -  9  - 使用刚定义的函数得到差异文件10  -  11 diffdoc：= compare_table_sxml（name1，name2）; 12  -  13  - 在OPENW调用中指定对象类型14  -  15 openw_handle：= DBMS_METADATA.OPENW（'TABLE'）; 16  -  17  - 使用ALTERXML转换生成ALTER_XML文档18  -  19 transform_handle：= DBMS_METADATA.ADD_TRANSFORM（openw_handle，'ALTERXML'）; 20  -  21  - 请求解析项22  -  23 DBMS_METADATA.SET_PARSE_ITEM（openw_handle，'CLAUSE_TYPE'）; 24 DBMS_METADATA.SET_PARSE_ITEM（openw_handle，'NAME'）; 25 DBMS_METADATA.SET_PARSE_ITEM（openw_handle，'COLUMN_ATTRIBUTE'）; 26  -  27  - 创建临时LOB 28  -  29 DBMS_LOB.CREATETEMPORARY（alterxml，TRUE）; 30  -  31  - 调用CONVERT进行转换32  -  33 DBMS_METADATA.CONVERT（openw_handle，diffdoc，alterxml）; 34  -  35  - 关闭上下文并返回结果36  -  37 DBMS_METADATA.CLOSE（openw_handle）; 38 RETURN alterxml; 39结束; 40 /创建功能。
</pre></li>
                        <li>
                           <p>使用该函数获取ALTER_XML文档：</p><pre class="oac_no_warn" dir="ltr">SQL&gt; SELECT get_table_alterxml（'TAB1'，'TAB2'）FROM dual; &lt;ALTER_XML xmlns =“http://xmlns.oracle.com/ku”version =“1.0”&gt; &lt;OBJECT_TYPE&gt; TABLE &lt;/ OBJECT_TYPE&gt; &lt;OBJECT1&gt; &lt;SCHEMA&gt; SCOTT &lt;/ SCHEMA&gt; &lt;NAME&gt; TAB1 &lt;/ NAME&gt; &lt;/ OBJECT1&gt; &lt;OBJECT2&gt; &lt;SCHEMA&gt; SCOTT &lt;/ SCHEMA&gt; &lt;NAME&gt; TAB2 &lt;/ NAME&gt; &lt;/ OBJECT2&gt; &lt;ALTER_LIST&gt; &lt;ALTER_LIST_ITEM&gt; &lt;PARSE_LIST&gt; &lt;PARSE_LIST_ITEM&gt; &lt;ITEM&gt; NAME &lt;/ ITEM&gt; &lt;VALUE&gt; MGR &lt;/ VALUE&gt; &lt;/ PARSE_LIST_ITEM&gt; &lt;PARSE_LIST_ITEM&gt; &lt;ITEM&gt; CLAUSE_TYPE &lt;/ ITEM&gt; &lt;VALUE&gt; ADD_COLUMN &lt;/ VALUE&gt; &lt;/ PARSE_LIST_ITEM&gt; &lt;/ PARSE_LIST&gt; &lt;SQL_LIST&gt; &lt;SQL_LIST_ITEM&gt; &lt;TEXT&gt; ALTER TABLE“SCOTT” 。“TAB1”ADD（“MGR”NUMBER（4,0））&lt;/ TEXT&gt; &lt;/ SQL_LIST_ITEM&gt; &lt;/ SQL_LIST&gt; &lt;/ ALTER_LIST_ITEM&gt; &lt;ALTER_LIST_ITEM&gt; &lt;PARSE_LIST&gt; &lt;PARSE_LIST_ITEM&gt; &lt;ITEM&gt; NAME &lt;/ ITEM&gt; &lt; VALUE&gt; JOB &lt;/ VALUE&gt; &lt;/ PARSE_LIST_ITEM&gt; &lt;PARSE_LIST_ITEM&gt; &lt;ITEM&gt; CLAUSE_TYPE &lt;/ ITEM&gt; &lt;VALUE&gt; DROP_COLUMN &lt;/ VALUE&gt; &lt;/ PARSE_LIST_ITEM&gt; &lt;/ PARSE_LIST&gt; &lt;SQL_LIST&gt; &lt;SQL_LIST_ITEM&gt; &lt;TEXT&gt; ALTER TABLE“ SCOTT“。”TAB1“DROP（”JOB“）&lt;/ TEXT&gt; &lt;/ SQL_LIST_ITEM&gt; &lt;/ SQL_LIST&gt; &lt;/ ALTER_LIST_ITEM&gt; &lt;ALTER_LIST_ITEM&gt; &lt;PARSE_LIST&gt; &lt;PARSE_LIST_ITEM&gt; &lt;ITEM&gt; NAME &lt;/ ITEM&gt; &lt;VALUE&gt; ENAME &lt; / VALUE&gt; &lt;/ PARSE_LIST_ITEM&gt; &lt;PARSE_LIST_ITEM&gt; &lt;ITEM&gt; CLAUSE_TYPE &lt;/ ITEM&gt; &lt;VALUE&gt; MODIFY_COLUMN &lt;/ VALUE&gt; &lt;/ PARSE_LIST_ITEM&gt; &lt;PARSE_LIST_ITEM&gt; &lt;ITEM&gt; COLUMN_ATTRIBUTE &lt;/ ITEM&gt; &lt;VALUE&gt; SIZE_INCREASE &lt;/ VALUE&gt; &lt;/ PARSE_LIST_ITEM&gt; &lt;/ PARSE_LIST&gt; &lt;SQL_LIST&gt; &lt;SQL_LIST_ITEM&gt; &lt;TEXT&gt; ALTER TABLE“SCOTT”。“TAB1”MODIFY（“ENAME”VARCHAR2（20））&lt;/ TEXT&gt; &lt;/ SQL_LIST_ITEM&gt; &lt;/ SQL_LIST&gt; &lt;/ ALTER_LIST_ITEM&gt; &lt;ALTER_LIST_ITEM &gt; &lt;PARSE_LIST&gt; &lt;PARSE_LIST_ITEM&gt; &lt;ITEM&gt; CLAUSE_TYPE &lt;/ ITEM&gt; &lt;VALUE&gt; ADD_CONSTRAINT &lt;/ VALUE&gt; &lt;/ PARSE_LIST_ITEM&gt; &lt;/ PARSE_LIST&gt; &lt;SQL_LIST&gt; &lt;SQL_LIST_ITEM&gt; &lt;TEXT&gt; ALTER TABLE“SCOTT”。“TAB1”ADD PRIMARY KEY（“EMPNO”）ENABLE &lt;/ TEXT&gt; &lt;/ SQL_LIST_ITEM&gt; &lt;/ SQL_LIST&gt; &lt;/ ALTER_LIST_ITEM&gt; &lt;ALTER_LIST_ITEM&gt; &lt;PARSE_LIST&gt; &lt;PARSE_LIST_ITEM&gt; &lt;ITEM&gt; NAME &lt;/ ITEM&gt; &lt;VALUE&gt; TAB1 &lt;/ VALUE&gt; &lt; / PARSE_LIST_ITEM&gt; &lt;PARSE_LIST_ITEM&gt; &lt;ITEM&gt; CLAUSE_TYPE &lt;/ ITEM&gt; &lt;VALUE&gt; RENAME_TABLE &lt;/ VALUE&gt; &lt;/ PARSE_LIST_ITEM&gt; &lt;/ PARSE_LIST&gt; &lt;SQL_LIST&gt; &lt;SQL_LIST_ITEM&gt; &lt;TEXT&gt; ALTER TABLE“SCOTT”。“TAB1”重命名为“TAB2”&lt;/ TEXT&gt; &lt;/ SQL_LIST_ITEM&gt; &lt;/ SQL_LIST&gt; &lt;/ ALTER_LIST_ITEM&gt; &lt;/ AL TER_LIST&gt; &lt;/ ALTER_XML&gt;选择了1行。
 </pre></li>
                        <li>
                           <p>使用<code class="codeph">DBMS_METADATA_DIFF</code>浏览API比较结果：</p><pre class="oac_no_warn" dir="ltr">SQL&gt; SELECT dbms_metadata_diff.compare_alter_xml（'TABLE'，'TAB1'，'TAB2'）FROM dual;</pre></li>
                        <li>
                           <p>ALTER_XML文档包含每个更改的ALTER_LIST。每个ALTER_LIST_ITEM都有一个PARSE_LIST，其中包含作为名称 - 值对的解析项和一个包含特定alter的SQL的SQL_LIST。您可以使用PARSE_LIST中的信息解析此文档并确定要执行哪些SQL语句。 （请注意，例如，在这种情况下，其中一个更改是DROP_COLUMN，您可以选择不执行该操作。）</p>
                        </li>
                        <li>
                           <p>创建最后一个使用<code class="codeph">DBMS_METADATA.CONVERT</code> API和<code class="codeph">ALTER DDL</code>转换的函数将ALTER_XML文档转换为SQL DDL：</p><pre class="oac_no_warn" dir="ltr">SQL&gt; CREATE或REPLACE FUNCTION get_table_alterddl（name1 IN VARCHAR2，name2 IN VARCHAR2）RETURN CLOB IS 3 alterxml CLOB; 4 openw_handle NUMBER; 5 transform_handle NUMBER; 6 alterddl CLOB; 7开始8  -  9  - 使用刚刚定义的函数获取ALTER_XML文档10  -  11 alterxml：= get_table_alterxml（name1，name2）; 12  -  13  - 在OPENW调用中指定对象类型14  -  15 openw_handle：= DBMS_METADATA.OPENW（'TABLE'）; 16  -  17  - 使用ALTERDDL转换将ALTER_XML文档转换为SQL DDL 18  -  19 transform_handle：= DBMS_METADATA.ADD_TRANSFORM（openw_handle，'ALTERDDL'）; 20  -  21  - 使用SQLTERMINATOR转换参数将终结符22附加到每个SQL语句23  -  24 DBMS_METADATA.SET_TRANSFORM_PARAM（transform_handle，'SQLTERMINATOR'，true）; 25  -  26  - 创建临时项目27  -  28 DBMS_LOB.CREATETEMPORARY（alterddl，TRUE）; 29  -  30  - 调用CONVERT进行转换31  -  32 DBMS_METADATA.CONVERT（openw_handle，alterxml，alterddl）; 33  -  34  - 关闭上下文并返回结果35  -  36 DBMS_METADATA.CLOSE（openw_handle）; 37 RETURN alterddl; 38结束; 39 /创建功能。
 </pre></li>
                        <li>
                           <p>使用该函数获取SQL ALTER语句：</p><pre class="oac_no_warn" dir="ltr">SQL&gt; SELECT get_table_alterddl（'TAB1'，'TAB2'）FROM dual; ALTER TABLE“SCOTT”。“TAB1”ADD（“MGR”NUMBER（4,0））/ ALTER TABLE“SCOTT”。“TAB1”DROP（“JOB”）/ ALTER TABLE“SCOTT”。“TAB1”MODIFY（“ ENAME“VARCHAR2（20）”/ ALTER TABLE“SCOTT”。“TAB1”添加主键（“EMPNO”）ENABLE / ALTER TABLE“SCOTT”。“TAB1”重命名为“TAB2”/ 1行选中。
 </pre></li>
                        <li>
                           <p>使用<code class="codeph">DBMS_METADATA_DIFF</code>浏览API比较结果：</p><pre class="oac_no_warn" dir="ltr">SQL&gt; SELECT dbms_metadata_diff.compare_alter（'TABLE'，'TAB1'，'TAB2'）FROM dual; ALTER TABLE“SCOTT”。“TAB1”ADD（“MGR”NUMBER（4,0））ALTER TABLE“SCOTT”。“TAB1”DROP（“JOB”）ALTER TABLE“SCOTT”。“TAB1”MODIFY（“ENAME”） VARCHAR2（20））ALTER TABLE“SCOTT”。“TAB1”添加主键（“EMPNO”）使用索引PCTFREE 10 INITRANS 2存储（初始16384下一页16384 MINEXTENTS 1 MAXEXTENTS 505 PCTINCREASE 50 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT）启用ALTER表“SCOTT”。“TAB1”重命名为“TAB2”选择1行。</pre></li>
                     </ol>
                  </div>
                  <!-- class="example" -->
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="using-oracle-dbms_metadata-api.html#GUID-D9B1300F-B21D-416E-8B9B-C542195EF249" title="使用DBMS_METADATA API。">使用元数据API</a></p>
                     </div>
                  </div>
               </div>
               
            </div><a id="SUTIL1632"></a><div class="props_rev_3"><a id="GUID-DF431094-5F1D-478D-87E6-04CC774B761F" name="GUID-DF431094-5F1D-478D-87E6-04CC774B761F"></a><h3 id="SUTIL-GUID-DF431094-5F1D-478D-87E6-04CC774B761F" class="sect3"><span class="enumeration_section">23.7</span> DBMS_METADATA API的编程接口的性能提示</h3>
               <div>
                  <p>描述在使用<code class="codeph">DBMS_METADATA</code> API的编程接口时如何增强性能。</p>
                  <p>特别：</p>
                  <ol>
                     <li>
                        <p>在获取下一个对象之前获取所有类型的对象。例如，如果要检索模式中所有对象的定义，请首先获取所有表，然后获取所有索引，然后获取所有触发器，依此类推。这将比嵌套<code class="codeph">OPEN</code>上下文快得多;也就是说，获取一个表然后获取其所有索引，授权和触发器，然后获取下一个表及其所有索引，授权和触发器，依此类推。<a href="using-oracle-dbms_metadata-api.html#GUID-89237236-4729-4E33-842D-D124A3C15B10" title="如何使用DBMS_METADATA API的示例。">示例DBMS_METADATA API的使用</a>反映了第二种效率较低的方法，但其目的是演示大多数编程调用，这些调用最好通过此方法显示。
                        </p>
                     </li>
                     <li>
                        <p>使用<code class="codeph">SET_COUNT</code>过程一次检索多个对象。这最大限度地减少了服务器往返次数，并消除了许多冗余函
                        </p>
                     </li>
                     <li>
                        <p>当编写一个PL / SQL包调用<code class="codeph">DBMS_METADATA</code> API，声明LOB变量和包含的LOB（如对象<code class="codeph">SYS</code> 。 <code class="codeph">KU</code> $ <code class="codeph">_DDLS</code>在包的范围，而不是单独的函数内）。这消除了在功能进入和退出时LOB持续时间结构的创建和删除，这是非常昂贵的操作。
                        </p>
                     </li>
                  </ol>
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="using-oracle-dbms_metadata-api.html#GUID-D9B1300F-B21D-416E-8B9B-C542195EF249" title="使用DBMS_METADATA API。">使用元数据API</a></p>
                     </div>
                  </div>
               </div>
               
            </div><a id="SUTIL1633"></a><div class="props_rev_3"><a id="GUID-89237236-4729-4E33-842D-D124A3C15B10" name="GUID-89237236-4729-4E33-842D-D124A3C15B10"></a><h3 id="SUTIL-GUID-89237236-4729-4E33-842D-D124A3C15B10" class="sect3"><span class="enumeration_section">23.8</span> DBMS_METADATA API的示例用法</h3>
               <div>
                  <p>如何使用<code class="codeph">DBMS_METADATA</code> API的示例。
                  </p>
                  <p>提供了一个脚本，通过执行以下操作自动为您运行演示：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>建立模式（ <code class="codeph">MDDEMO</code> ）和一些工资单用户。
                        </p>
                     </li>
                     <li>
                        <p>在架构中创建三个类似工资单的表以及任何关联的索引，触发器和授权。</p>
                     </li>
                     <li>
                        <p>创建一个使用<code class="codeph">DBMS_METADATA</code> API的包<code class="codeph">PAYROLL_DEMO</code> 。 <code class="codeph">PAYROLL_DEMO</code>包中包含一个过程<code class="codeph">GET_PAYROLL_TABLES,</code>它检索<code class="codeph">MDDEMO</code>模式中以<code class="codeph">PAYROLL</code>开头的两个表的DDL。对于每个表，它检索表的关联依赖对象的DDL;索引，授权和触发器。所有DDL都写入名为<code class="codeph">MDDEMO</code>的表中。 <code class="codeph">DDL</code> 。</p>
                     </li>
                  </ul>
                  <p>要执行该示例，请执行以下操作：</p>
                  <ol>
                     <li>
                        <p>以用户<code class="codeph">system</code>身份启动SQL * Plus。系统将提示您输入密码。
                        </p><pre class="oac_no_warn" dir="ltr">sqlplus系统</pre></li>
                     <li>
                        <p>安装演示，该演示位于<code class="codeph">rdbms</code> / <code class="codeph">demo</code>中的<code class="codeph">mddemo.sql</code>文件中：</p><pre class="oac_no_warn" dir="ltr">SQL&gt; @mddemo</pre><p>有关此步骤中发生的情况的说明，请参阅<a href="using-oracle-dbms_metadata-api.html#GUID-7EE1E557-F95C-4C01-946E-5A9B4B6E41E7" title="DBMS_METADATA示例的说明。">DBMS_METADATA示例有何功能？</a> 。
                        </p>
                     </li>
                     <li>
                        <p>以用户<code class="codeph">mddemo</code>连接。系统将提示您输入密码，该密码也是<code class="codeph">mddemo</code> 。
                        </p><pre class="oac_no_warn" dir="ltr">SQL&gt; CONNECT mddemo输入密码：</pre></li>
                     <li>
                        <p>设置以下参数，以便查询输出完整且可读：</p><pre class="oac_no_warn" dir="ltr">SQL&gt; SET PAGESIZE 0 SQL&gt; SET LONG 1000000</pre></li>
                     <li>
                        <p>执行<code class="codeph">GET_PAYROLL_TABLES</code>过程，如下所示：</p><pre class="oac_no_warn" dir="ltr">SQL&gt; CALL payroll_demo.get_payroll_tables（）;</pre></li>
                     <li>
                        <p>执行以下SQL查询：</p><pre class="oac_no_warn" dir="ltr">SQL&gt; SELECT ddl FROM DDL ORDER BY SEQNO;</pre><p>生成的输出是执行<code class="codeph">GET_PAYROLL_TABLES</code>过程的结果。它显示了安装演示时在步骤2中执行的所有DDL。有关实际输出的列表，请参阅<a href="using-oracle-dbms_metadata-api.html#GUID-D807A5A4-4809-4424-AA53-68081627A308" title="从GET_PAYROLL_TABLES过程生成的输出的说明。">从GET_PAYROLL_TABLES过程生成</a>的输出。
                        </p>
                     </li>
                  </ol>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="using-oracle-dbms_metadata-api.html#GUID-7EE1E557-F95C-4C01-946E-5A9B4B6E41E7">DBMS_METADATA示例有什么作用？</a><br><code class="codeph">DBMS_METADATA</code>示例的说明。
                     </li>
                     <li class="ulchildlink"><a href="using-oracle-dbms_metadata-api.html#GUID-D807A5A4-4809-4424-AA53-68081627A308">从GET_PAYROLL_TABLES过程生成的输出</a><br>从<code class="codeph">GET_PAYROLL_TABLES</code>过程生成的输出的说明。
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="using-oracle-dbms_metadata-api.html#GUID-D9B1300F-B21D-416E-8B9B-C542195EF249" title="使用DBMS_METADATA API。">使用元数据API</a></p>
                     </div>
                  </div>
               </div>
               <a id="SUTIL1634"></a><div class="props_rev_3"><a id="GUID-7EE1E557-F95C-4C01-946E-5A9B4B6E41E7" name="GUID-7EE1E557-F95C-4C01-946E-5A9B4B6E41E7"></a><h4 id="SUTIL-GUID-7EE1E557-F95C-4C01-946E-5A9B4B6E41E7" class="sect4"><span class="enumeration_section">23.8.1</span> DBMS_METADATA示例有什么作用？
                  </h4>
                  <div>
                     <p><code class="codeph">DBMS_METADATA</code>示例的说明。
                     </p>
                     <p>运行<code class="codeph">mddemo</code>脚本时，将执行以下步骤。您可以根据自己的情况调整这些步骤。
                     </p>
                     <ol>
                        <li>
                           <p>如果用户存在，则按如下方式删除用户。这将确保您开始使用新数据。如果用户不存在，则会显示相应的消息，不会造成任何损害，并继续执行演示。</p><pre class="oac_no_warn" dir="ltr">CONNECT系统输入密码： <span class="italic">password</span> SQL&gt; DROP USER mddemo CASCADE; SQL&gt; DROP USER mddemo_clerk CASCADE; SQL&gt; DROP USER mddemo_mgr CASCADE;</pre></li>
                        <li>
                           <p>创建用户<code class="codeph">mddemo</code> ，通过鉴定<code class="codeph">mddemo</code> ：</p><pre class="oac_no_warn" dir="ltr">SQL&gt; CREATE USER mddemo由mddemo识别; SQL&gt; GRANT资源，连接，创建会话，1创建表，2创建过程，3创建序列，4创建触发器，5创建视图，6创建同义词，7更改会话，8 TO mddemo;</pre></li>
                        <li>
                           <p>创建用户<code class="codeph">mddemo_clerk</code> ，由<code class="codeph">clerk</code>识别：</p><pre class="oac_no_warn" dir="ltr">创建用户mddemo_clerk IDENTIFIED BY职员;</pre></li>
                        <li>
                           <p>创建由<code class="codeph">mgr</code>标识的用户<code class="codeph">mddemo_mgr</code> ：</p><pre class="oac_no_warn" dir="ltr">创建用户mddemo_mgr由mgr识别;</pre></li>
                        <li>
                           <p>以<code class="codeph">mddemo</code>连接到SQL * Plus（密码也是<code class="codeph">mddemo</code> ）：</p><pre class="oac_no_warn" dir="ltr">CONNECT mddemo输入密码：</pre></li>
                        <li>
                           <p>创建一些工资单类型表：</p><pre class="oac_no_warn" dir="ltr">SQL&gt; CREATE TABLE payroll_emps 2（lastname VARCHAR2（60）NOT NULL，3 firstname VARCHAR2（20）NOT NULL，4 mi VARCHAR2（2），5 suffix VARCHAR2（10），6 dob DATE NOT NULL，7 badge_no NUMBER（6） PRIMARY KEY，8免除VARCHAR（1）NOT NULL，9薪水NUMBER（9,2），10 hourly_rate NUMBER（7,2））11 / SQL&gt; CREATE TABLE payroll_timecards 2（badge_no NUMBER（6）REFERENCES payroll_emps（badge_no）， 3周NUMBER（2），4 job_id NUMBER（5），5 hours_worked NUMBER（4,2））6 /</pre></li>
                        <li>
                           <p>创建一个虚拟表<code class="codeph">audit_trail</code> 。此表用于显示<code class="codeph">GET_PAYROLL_TABLES</code>过程不检索不以<code class="codeph">payroll</code>开头的表。
                           </p><pre class="oac_no_warn" dir="ltr">SQL&gt; CREATE TABLE audit_trail 2（action_time DATE，3 lastname VARCHAR2（60），4 action LONG）5 /</pre></li>
                        <li>
                           <p>在刚刚创建的表上创建一些授权：</p><pre class="oac_no_warn" dir="ltr">SQL&gt; GRANT UPDATE（salary，hourly_rate）ON payroll_emps TO mddemo_clerk; SQL&gt; GRANT ALL ON payroll_emps TO mddemo_mgr WITH GRANT OPTION; SQL&gt; GRANT INSERT，UPDATE ON payroll_timecards TO mddemo_clerk; SQL&gt; GRANT ALL ON payroll_timecards TO mddemo_mgr WITH GRANT OPTION;</pre></li>
                        <li>
                           <p>在刚刚创建的表上创建一些索引：</p><pre class="oac_no_warn" dir="ltr">SQL&gt; CREATE INDEX i_payroll_emps_name ON payroll_emps（lastname）; SQL&gt; CREATE INDEX i_payroll_emps_dob ON payroll_emps（dob）; SQL&gt; CREATE INDEX i_payroll_timecards_badge ON payroll_timecards（badge_no）;</pre></li>
                        <li>
                           <p>在刚刚创建的表上创建一些触发器：</p><pre class="oac_no_warn" dir="ltr">SQL&gt; CREATE OR REPLACE PROCEDURE check_sal（薪水数量）AS BEGIN 2 RETURN; 3结束; 4 /</pre><p>请注意，安全性保持相当宽松，以保持示例简单。</p><pre class="oac_no_warn" dir="ltr">SQL&gt;创建或替换TRIGGER salary_trigger之前插入或更新工资在payroll_emps之前每次行（new.salary&gt; 150000）CALL check_sal（：new.salary）/ SQL&gt;创建或替换TRIGGER hourly_trigger之前更新hourly_rate ON payroll_emps FOR EACH ROW BEGIN：new.hourly_rate：=：old.hourly_rate; END; /</pre></li>
                        <li>
                           <p>设置一个表来保存生成的DDL：</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE ddl（ddl CLOB，seqno NUMBER）;</pre></li>
                        <li>
                           <p>创建<code class="codeph">PAYROLL_DEMO</code>包，其中提供了如何使用<code class="codeph">DBMS_METADATA</code>过程的示例。
                           </p><pre class="oac_no_warn" dir="ltr">SQL&gt; CREATE OR REPLACE PACKAGE payroll_demo AS PROCEDURE get_payroll_tables;结束; /</pre><div class="infoboxnote" id="GUID-7EE1E557-F95C-4C01-946E-5A9B4B6E41E7__GUID-4EC4DCBB-C9E2-42F5-9276-040689EBF59D">
                              <p class="notep1">注意：</p>
                              <p>要查看此示例的整个脚本（包括<code class="codeph">PAYROLL_DEMO</code>包的内容），请参阅位于$ <code class="codeph">ORACLE_HOME/rdbms/demo</code>目录中的文件<code class="codeph">mddemo.sql</code> 。
                              </p>
                           </div>
                        </li>
                     </ol>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="using-oracle-dbms_metadata-api.html#GUID-89237236-4729-4E33-842D-D124A3C15B10" title="如何使用DBMS_METADATA API的示例。">DBMS_METADATA API的示例用法</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="SUTIL1635"></a><div class="props_rev_3"><a id="GUID-D807A5A4-4809-4424-AA53-68081627A308" name="GUID-D807A5A4-4809-4424-AA53-68081627A308"></a><h4 id="SUTIL-GUID-D807A5A4-4809-4424-AA53-68081627A308" class="sect4"><span class="enumeration_section">23.8.2</span>从GET_PAYROLL_TABLES过程生成的输出</h4>
                  <div>
                     <p>从<code class="codeph">GET_PAYROLL_TABLES</code>过程生成的输出的说明。
                     </p>
                     <p>执行<code class="codeph">mddemo.payroll_demo.get_payroll_tables</code>过程后，您可以执行以下查询：</p><pre class="oac_no_warn" dir="ltr">SQL&gt; SELECT ddl FROM ddl ORDER BY seqno;</pre><p>结果如下，它反映了脚本执行的所有DDL，如上一节所述。</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE“MDDEMO”。“PAYROLL_EMPS”（“LASTNAME”VARCHAR2（60）NOT NULL ENABLE，“FIRSTNAME”VARCHAR2（20）NOT NULL ENABLE，“MI”VARCHAR2（2），“SUFFIX”VARCHAR2（10），“DOB “DATE NOT NULL ENABLE，”BADGE_NO“NUMBER（6,0），”EXEMPT“VARCHAR2（1）NOT NULL ENABLE，”SALARY“NUMBER（9,2），”HOURLY_RATE“NUMBER（7,2），PRIMARY KEY（ “BADGE_NO”）ENABLE）;在“MDDEMO”上授予更新（“SALARY”）。“PAYROLL_EMPS”到“MDDEMO_CLERK”;在“MDDEMO”上授予更新（“HOURLY_RATE”）。“PAYROLL_EMPS”到“MDDEMO_CLERK”;授予“MDDEMO”。“PAYROLL_EMPS”到“MDDEMO_MGR”和“授予选项”; GRANT DELETE ON“MDDEMO”。“PAYROLL_EMPS”改为“MDDEMO_MGR”和GRANT OPTION; “MDDEMO”上的GRANT INDEX。“PAYROLL_EMPS”到“MDDEMO_MGR”和GRANT OPTION; GRANT INSERT ON“MDDEMO”。“PAYROLL_EMPS”改为“MDDEMO_MGR”，带有授予选项; GRANT选择“MDDEMO”。“PAYROLL_EMPS”到“MDDEMO_MGR”，带有授予选项;授予“MDDEMO”更新。“PAYROLL_EMPS”到“MDDEMO_MGR”并带有授予选项;对“MDDEMO”授予参考资料。“PAYROLL_EMPS”为“MDDEMO_MGR”，提供授予选项;授予“MDDEMO”上的“COMMED REFRESH”。“PAYROLL_EMPS”为“MDDEMO_MGR”并带有授予选项; “MDDEMO”上的GRANT QUERY REWRITE。“PAYROLL_EMPS”到“MDDEMO_MGR”，带有授予选项;创建索引“MDDEMO”。“I_PAYROLL_EMPS_DOB”ON“MDDEMO”。“PAYROLL_EMPS”（“DOB”）PCTFREE 10 INITRANS 2 MAXTRANS 255存储（初始10240下一个10240 MINEXTENTS 1 MAXEXTENTS 121 PCTINCREASE 50 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT）TABLESPACE“系统“;创建索引“MDDEMO”。“I_PAYROLL_EMPS_NAME”ON“MDDEMO”。“PAYROLL_EMPS”（“LASTNAME”）PCTFREE 10 INITRANS 2 MAXTRANS 255存储（初始10240下一页10240 MINEXTENTS 1 MAXEXTENTS 121 PCTINCREASE 50 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT）TABLESPACE“系统“;在更新每个行的salaryroll_emps上的hourly_rate之前创建或替换TRIGGER hourly_trigger：new.hourly_rate：=：old.hourly_rate; end; / ALTER TRIGGER“MDDEMO”。“HOURLY_TRIGGER”ENABLE;在每行的payroll_emps上插入或更新工资之前创建或替换TRIGGER salary_trigger WHEN（new.salary&gt; 150000）CALL check_sal（：new.salary）/ ALTER TRIGGER“MDDEMO”。“SALARY_TRIGGER”ENABLE;创建表“MDDEMO”。“PAYROLL_TIMECARDS”（“BADGE_NO”编号（6,0），“周”编号（2,0），“JOB_ID”编号（5,0），“HOURS_WORKED”编号（4,2）， FOREIGN KEY（“BADGE_NO”）参考“MDDEMO”。“PAYROLL_EMPS”（“BADGE_NO”）ENABLE）; GRANT INSERT ON“MDDEMO”。“PAYROLL_TIMECARDS”改为“MDDEMO_CLERK”;授予“MDDEMO”更新“PAYROLL_TIMECARDS”至“MDDEMO_CLERK”;授予更改“MDDEMO”。“PAYROLL_TIMECARDS”到“MDDEMO_MGR”并带有授予选项; GRANT DELETE ON“MDDEMO”。“PAYROLL_TIMECARDS”to“MDDEMO_MGR”with GRANT OPTION; “MDDEMO”上的GRANT INDEX。“PAYROLL_TIMECARDS”到“MDDEMO_MGR”和GRANT OPTION; GRANT INSERT ON“MDDEMO”。“PAYROLL_TIMECARDS”to“MDDEMO_MGR”with GRANT OPTION; GRANT选择“MDDEMO”。“PAYROLL_TIMECARDS”到“MDDEMO_MGR”，带有授予选项;授予“MDDEMO”更新。“PAYROLL_TIMECARDS”至“MDDEMO_MGR”并带有授予选项;授予“MDDEMO”的参考资料。“PAYROLL_TIMECARDS”至“MDDEMO_MGR”并提供授予选项;授予“MDDEMO”上的“COMMED REFRESH”。“PAYROLL_TIMECARDS”到“MDDEMO_MGR”并带有授予选项; “MDDEMO”上的GRANT QUERY REWRITE。“PAYROLL_TIMECARDS”到“MDDEMO_MGR”，带有授权选项;创建索引“MDDEMO”。“I_PAYROLL_TIMECARDS_BADGE”打开“MDDEMO”。“PAYROLL_TIMECARDS”（“BADGE_NO”）PCTFREE 10 INITRANS 2 MAXTRANS 255存储（初始10240下一页10240文档1最大值121 PCTINCREASE 50 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT）TABLESPACE“系统“;</pre></div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="using-oracle-dbms_metadata-api.html#GUID-89237236-4729-4E33-842D-D124A3C15B10" title="如何使用DBMS_METADATA API的示例。">DBMS_METADATA API的示例用法</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div><a id="SUTIL3629"></a><a id="SUTIL3630"></a><a id="SUTIL3631"></a><a id="SUTIL1636"></a><div class="props_rev_2"><a id="GUID-B19C59EB-A9BC-4D1E-BD8C-135583D403CD" name="GUID-B19C59EB-A9BC-4D1E-BD8C-135583D403CD"></a><h3 id="SUTIL-GUID-B19C59EB-A9BC-4D1E-BD8C-135583D403CD" class="sect3"><span class="enumeration_section">23.9</span> DBMS_METADATA过程摘要</h3>
               <div>
                  <p>提供<code class="codeph">DBMS_METADATA</code> API提供的过程的简要说明。</p>
                  <div class="section">
                     <p>有关这些过程的详细说明，请参见<a href="../arpls/DBMS_METADATA.html#ARPLS026" target="_blank"><span class="italic">Oracle Database PL / SQL包和类型参考。</span></a></p>
                     <p>下表提供了<code class="codeph">DBMS_METADATA</code>编程接口提供的用于检索多个对象的过程的简要说明。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="tblformalwide" id="GUID-B19C59EB-A9BC-4D1E-BD8C-135583D403CD__G1029894">
                     <p class="titleintable">表23-1用于检索多个对象的DBMS_METADATA过程</p>
                     <table cellpadding="4" cellspacing="0" class="FormalWide" title="DBMS_METADATA用于检索多个对象的过程" width="100%" border="1" summary="DBMS_METADATA procedures used for retrieving multiple objects" frame="hsides" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="41%" id="d145430e2268">PL / SQL过程名称</th>
                              <th align="left" valign="bottom" width="59%" id="d145430e2271">描述</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="41%" id="d145430e2276" headers="d145430e2268 "><pre class="oac_no_warn" dir="ltr">DBMS_METADATA.OPEN（）</pre></td>
                              <td align="left" valign="top" width="59%" headers="d145430e2276 d145430e2271 ">
                                 <p>指定要检索的对象的类型，其元数据的版本以及对象模型。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="41%" id="d145430e2283" headers="d145430e2268 "><pre class="oac_no_warn" dir="ltr">DBMS_METADATA.SET_FILTER（）</pre></td>
                              <td align="left" valign="top" width="59%" headers="d145430e2283 d145430e2271 ">
                                 <p>指定要检索的对象的限制，例如，对象名称或架构。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="41%" id="d145430e2290" headers="d145430e2268 "><pre class="oac_no_warn" dir="ltr">DBMS_METADATA.SET_COUNT（）</pre></td>
                              <td align="left" valign="top" width="59%" headers="d145430e2290 d145430e2271 ">
                                 <p>指定在单个<code class="codeph">FETCH_xxx</code>调用中要检索的最大对象数。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="41%" id="d145430e2300" headers="d145430e2268 "><pre class="oac_no_warn" dir="ltr">DBMS_METADATA.GET_QUERY（）</pre></td>
                              <td align="left" valign="top" width="59%" headers="d145430e2300 d145430e2271 ">
                                 <p>返回<code class="codeph">FETCH_xxx</code>使用的查询的文本。您可以将其用作调试辅助工具。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="41%" id="d145430e2310" headers="d145430e2268 "><pre class="oac_no_warn" dir="ltr">DBMS_METADATA.SET_PARSE_ITEM（）</pre></td>
                              <td align="left" valign="top" width="59%" headers="d145430e2310 d145430e2271 ">
                                 <p>通过指定要解析和返回的对象属性来启用输出解析。您可以查询<code class="codeph">DBMS_METADATA_PARSE_ITEMS</code>以查看所有有效的解析项。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="41%" id="d145430e2320" headers="d145430e2268 "><pre class="oac_no_warn" dir="ltr">DBMS_METADATA.ADD_TRANSFORM（）</pre></td>
                              <td align="left" valign="top" width="59%" headers="d145430e2320 d145430e2271 ">
                                 <p>指定<code class="codeph">FETCH_xxx</code>应用于检索到的对象的XML表示的转换。您可以查询<code class="codeph">DBMS_METADATA_TRANSFORMS</code>视图以查看所有有效的Oracle提供的转换。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="41%" id="d145430e2333" headers="d145430e2268 "><pre class="oac_no_warn" dir="ltr">DBMS_METADATA.SET_TRANSFORM_PARAM（）</pre></td>
                              <td align="left" valign="top" width="59%" headers="d145430e2333 d145430e2271 ">
                                 <p>指定由<code class="codeph">transform_handle.</code>标识的XSLT样式表的参数<code class="codeph">transform_handle.</code> 您可以查询<code class="codeph">DBMS_METADATA_TRANSFORM_PARAMS</code>视图以查看每个转换的所有有效转换参数。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="41%" id="d145430e2346" headers="d145430e2268 "><pre class="oac_no_warn" dir="ltr">DBMS_METADATA.SET_REMAP_PARAM（）</pre></td>
                              <td align="left" valign="top" width="59%" headers="d145430e2346 d145430e2271 ">
                                 <p>指定由<code class="codeph">transform_handle</code>标识的XSLT样式表的参数。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="41%" id="d145430e2356" headers="d145430e2268 "><pre class="oac_no_warn" dir="ltr">DBMS_METADATA.FETCH_xxx（）</pre></td>
                              <td align="left" valign="top" width="59%" headers="d145430e2356 d145430e2271 ">
                                 <p>返回符合<code class="codeph">OPEN</code> ， <code class="codeph">SET_FILTER</code> ， <code class="codeph">SET_COUNT</code> ， <code class="codeph">ADD_TRANSFORM</code>建立标准的对象的元数据。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="41%" id="d145430e2375" headers="d145430e2268 "><pre class="oac_no_warn" dir="ltr">DBMS_METADATA.CLOSE（）</pre></td>
                              <td align="left" valign="top" width="59%" headers="d145430e2375 d145430e2271 ">
                                 <p>使<code class="codeph">OPEN</code>返回的句柄无效并清除关联状态。
                                 </p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
                  <div class="section">
                     <p>下表列出了<code class="codeph">DBMS_METADATA</code>浏览界面提供的过程，并提供了每个过程的简要说明。这些函数返回一个或多个相关或授予对象的元数据。这些过程不支持异构对象类型。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="tblformal" id="GUID-B19C59EB-A9BC-4D1E-BD8C-135583D403CD__G1030147">
                     <p class="titleintable">表23-2用于浏览界面的DBMS_METADATA过程</p>
                     <table cellpadding="4" cellspacing="0" class="Formal" title="DBMS_METADATA用于浏览界面的过程" width="100%" border="1" summary="DBMS_METADATA procedures used for the browsing interface" frame="hsides" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="25%" id="d145430e2400">PL / SQL过程名称</th>
                              <th align="left" valign="bottom" width="75%" id="d145430e2403">描述</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="25%" id="d145430e2408" headers="d145430e2400 "><pre class="oac_no_warn" dir="ltr">DBMS_METADATA.GET_xxx（）</pre></td>
                              <td align="left" valign="top" width="75%" headers="d145430e2408 d145430e2403 ">
                                 <p>提供返回单个对象的元数据的方法。每个<code class="codeph">GET_xxx</code>调用都包含一个<code class="codeph">OPEN</code>过程，一个或两个<code class="codeph">SET_FILTER</code>调用，可选的<code class="codeph">ADD_TRANSFORM</code>过程， <code class="codeph">FETCH_xxx</code>调用和<code class="codeph">CLOSE</code>过程。
                                 </p>
                                 <p><span class="italic"><code class="codeph">object_type</code></span>参数具有与<code class="codeph">OPEN procedure</code>相同的语义。 <span class="italic"><code class="codeph">schema</code></span>和<span class="italic"><code class="codeph">name</code></span>用于过滤。
                                 </p>
                                 <p>如果指定了转换，则继承会话级转换标志。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="25%" id="d145430e2453" headers="d145430e2400 "><pre class="oac_no_warn" dir="ltr">DBMS_METADATA.GET_DEPENDENT_xxx（）</pre></td>
                              <td align="left" valign="top" width="75%" headers="d145430e2453 d145430e2403 ">
                                 <p>返回一个或多个依赖对象的元数据，指定为XML或DDL。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="25%" id="d145430e2460" headers="d145430e2400 "><pre class="oac_no_warn" dir="ltr">DBMS_METADATA.GET_GRANTED_xxx（）</pre></td>
                              <td align="left" valign="top" width="75%" headers="d145430e2460 d145430e2403 ">
                                 <p>返回一个或多个已授予对象的元数据，指定为XML或DDL。</p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
                  <div class="section">
                     <p>下表提供了用于XML提交的<code class="codeph">DBMS_METADATA</code>过程和函数的简要说明。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="tblformal" id="GUID-B19C59EB-A9BC-4D1E-BD8C-135583D403CD__G1030301">
                     <p class="titleintable">表23-3用于提交XML数据的DBMS_METADATA过程和函数</p>
                     <table cellpadding="4" cellspacing="0" class="Formal" title="DBMS_METADATA用于提交XML数据的过程和函数" width="100%" border="1" summary="DBMS_METADATA procedures used for submitting XML data" frame="hsides" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="36%" id="d145430e2482">PL / SQL名称</th>
                              <th align="left" valign="bottom" width="64%" id="d145430e2485">描述</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="36%" id="d145430e2490" headers="d145430e2482 "><pre class="oac_no_warn" dir="ltr">DBMS_METADATA.OPENW（）</pre></td>
                              <td align="left" valign="top" width="64%" headers="d145430e2490 d145430e2485 ">
                                 <p>打开写入上下文。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="36%" id="d145430e2497" headers="d145430e2482 "><pre class="oac_no_warn" dir="ltr">DBMS_METADATA.ADD_TRANSFORM（）</pre></td>
                              <td align="left" valign="top" width="64%" headers="d145430e2497 d145430e2485 ">
                                 <p>指定XML文档的转换</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="36%" id="d145430e2504" headers="d145430e2482 "><pre class="oac_no_warn" dir="ltr">DBMS_METADATA.SET_TRANSFORM_PARAM（）和DBMS_METADATA.SET_REMAP_PARAM（）</pre></td>
                              <td align="left" valign="top" width="64%" headers="d145430e2504 d145430e2485 ">
                                 <p><code class="codeph">SET_TRANSFORM_PARAM</code>指定转换的参数。
                                 </p>
                                 <p><code class="codeph">SET_REMAP_PARAM</code>指定转换的重映射。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="36%" id="d145430e2517" headers="d145430e2482 "><pre class="oac_no_warn" dir="ltr">DBMS_METADATA.SET_PARSE_ITEM（）</pre></td>
                              <td align="left" valign="top" width="64%" headers="d145430e2517 d145430e2485 ">
                                 <p>指定要解析的对象属性。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="36%" id="d145430e2524" headers="d145430e2482 "><pre class="oac_no_warn" dir="ltr">DBMS_METADATA.CONVERT（）</pre></td>
                              <td align="left" valign="top" width="64%" headers="d145430e2524 d145430e2485 ">
                                 <p>将XML文档转换为DDL。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="36%" id="d145430e2531" headers="d145430e2482 "><pre class="oac_no_warn" dir="ltr">DBMS_METADATA.PUT（）</pre></td>
                              <td align="left" valign="top" width="64%" headers="d145430e2531 d145430e2485 ">
                                 <p>将XML文档提交到数据库。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="36%" id="d145430e2538" headers="d145430e2482 "><pre class="oac_no_warn" dir="ltr">DBMS_METADATA.CLOSE（）</pre></td>
                              <td align="left" valign="top" width="64%" headers="d145430e2538 d145430e2485 ">
                                 <p>关闭使用<code class="codeph">OPENW</code>打开的上下文。</p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="using-oracle-dbms_metadata-api.html#GUID-D9B1300F-B21D-416E-8B9B-C542195EF249" title="使用DBMS_METADATA API。">使用元数据API</a></p>
                     </div>
                  </div>
               </div>
               
            </div><a id="SUTIL3633"></a><a id="SUTIL3632"></a><div class="props_rev_3"><a id="GUID-CB5F314F-7412-40F1-B71C-8F6DFB45A4D8" name="GUID-CB5F314F-7412-40F1-B71C-8F6DFB45A4D8"></a><h3 id="SUTIL-GUID-CB5F314F-7412-40F1-B71C-8F6DFB45A4D8" class="sect3"><span class="enumeration_section">23.10</span> DBMS_METADATA_DIFF过程摘要</h3>
               <div>
                  <p>提供<code class="codeph">DBMS_METADATA_DIFF</code> API提供的过程和函数的简要说明。</p>
                  <div class="section">
                     <p>有关这些过程的详细说明，请参见<a href="../arpls/DBMS_METADATA_DIFF.html#ARPLS354" target="_blank"><span class="italic">Oracle Database PL / SQL包和类型参考。</span></a></p>
                  </div>
                  <!-- class="section" -->
                  <div class="tblformalwide" id="GUID-CB5F314F-7412-40F1-B71C-8F6DFB45A4D8__GUID-54F379A6-DC4E-47D1-91FD-788A63A5273C">
                     <p class="titleintable">表23-4 DBMS_METADATA_DIFF过程和函数</p>
                     <table cellpadding="4" cellspacing="0" class="FormalWide" title="DBMS_METADATA_DIFF过程和函数" width="100%" border="1" summary="Summary of DBMS_METADATA_DIFF procedures" frame="hsides" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="41%" id="d145430e2614">PL / SQL过程名称</th>
                              <th align="left" valign="bottom" width="59%" id="d145430e2617">描述</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="41%" id="d145430e2622" headers="d145430e2614 ">
                                 <p><code class="codeph">OPENC</code>功能</p>
                              </td>
                              <td align="left" valign="top" width="59%" headers="d145430e2622 d145430e2617 ">
                                 <p>指定要比较的对象的类型。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="41%" id="d145430e2631" headers="d145430e2614 ">
                                 <p><code class="codeph">ADD_DOCUMENT</code>过程</p>
                              </td>
                              <td align="left" valign="top" width="59%" headers="d145430e2631 d145430e2617 ">
                                 <p>指定要比较的SXML文档。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="41%" id="d145430e2640" headers="d145430e2614 ">
                                 <p><code class="codeph">FETCH_CLOB</code>功能和程序</p>
                              </td>
                              <td align="left" valign="top" width="59%" headers="d145430e2640 d145430e2617 ">
                                 <p>返回一个CLOB，显示<code class="codeph">ADD_DOCUMENT</code>指定的两个文档之间的<code class="codeph">ADD_DOCUMENT</code> 。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="41%" id="d145430e2652" headers="d145430e2614 ">
                                 <p><code class="codeph">CLOSE</code>程序</p>
                              </td>
                              <td align="left" valign="top" width="59%" headers="d145430e2652 d145430e2617 ">
                                 <p>使<code class="codeph">OPENC</code>返回的句柄无效并清除关联状态。
                                 </p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="using-oracle-dbms_metadata-api.html#GUID-D9B1300F-B21D-416E-8B9B-C542195EF249" title="使用DBMS_METADATA API。">使用元数据API</a></p>
                     </div>
                  </div>
               </div>
               
            </div>
         </div>
      </article>
   </body>
</html>