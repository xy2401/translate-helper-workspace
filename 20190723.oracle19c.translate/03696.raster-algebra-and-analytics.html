<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <meta name="abstract" content="This chapter describes the raster algebra language (PL/SQL and algebraic expressions) and related raster operations, including conditional queries, cell value-based updates or edits, mathematical operations, classify, on-the-fly statistical analysis, logical operations, and their applications in cartographic modeling."></meta>
      <meta name="description" content="This chapter describes the raster algebra language (PL/SQL and algebraic expressions) and related raster operations, including conditional queries, cell value-based updates or edits, mathematical operations, classify, on-the-fly statistical analysis, logical operations, and their applications in cartographic modeling."></meta>
      <title>光栅代数和分析</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="GeoRaster Developer&#39;s Guide "></meta>
      <meta property="og:description" content="This chapter describes the raster algebra language (PL/SQL and algebraic expressions) and related raster operations, including conditional queries, cell value-based updates or edits, mathematical operations, classify, on-the-fly statistical analysis, logical operations, and their applications in cartographic modeling."></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="GeoRaster Developer&#39;s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="spatial-and-graph-georaster-developers-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-14T11:48:45-08:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="1999, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E94793-01"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="georaster-data-manipulation.html" title="Previous" type="text/html"></link>
      <link rel="next" href="image-processing-virtual-mosaic.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Spatial and Graph GeoRaster Developer&#39;s Guide"></meta>
    <meta name="dcterms.isVersionOf" content="GEORS"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="georaster-data-manipulation.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="image-processing-virtual-mosaic.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">GeoRaster开发人员指南</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">光栅代数和分析</li>
            </ol>
            <a id="GUID-C75744C9-FA04-4391-96F2-59EF2EA212FF" name="GUID-C75744C9-FA04-4391-96F2-59EF2EA212FF"></a><a id="GEORS1215"></a>
            
            <h2 id="GEORS-GUID-C75744C9-FA04-4391-96F2-59EF2EA212FF" class="sect2"><span class="enumeration_chapter">5</span>光栅代数和分析</h2>
         </header>
         <div class="ind">
            <div>
               <p>本章介绍了栅格代数语言（PL / SQL和代数表达式）和相关的栅格操作，包括条件查询，基于单元格的更新或编辑，数学运算，分类，动态统计分析，逻辑运算及其制图建模中的应用。</p>
               <p>它包含以下主要部分。</p>
            </div>
            <div>
               <ul class="ullinks">
                  <li class="ulchildlink"><a href="raster-algebra-and-analytics.html#GUID-A6F087DC-1E7E-4426-B778-8554A25B3494">光栅代数语言</a><br>栅格代数通常用于栅格数据分析和GIS建模。在GeoRaster中，GeoRaster栅格代数语言支持栅格代数。
                  </li>
                  <li class="ulchildlink"><a href="raster-algebra-and-analytics.html#GUID-FF9C7591-6CCB-41B2-941D-7998F94B8FE9">基于单元格值的条件查询</a><br>使用基于单元格的条件查询，您可以根据指定的条件生成新的GeoRaster对象。
                  </li>
                  <li class="ulchildlink"><a href="raster-algebra-and-analytics.html#GUID-0AEAF37F-6147-4CC7-9573-929B1EF6B44F">基于单元格值的条件更新（编辑）</a><br>您可以根据条件更新栅格单元格值。
                  </li>
                  <li class="ulchildlink"><a href="raster-algebra-and-analytics.html#GUID-C6250398-2364-4FEE-B06E-644B5F1251AB">数学运算</a><br>栅格代数的主要用途是将数学模型应用于来自不同源的栅格图层。
                  </li>
                  <li class="ulchildlink"><a href="raster-algebra-and-analytics.html#GUID-57DE5ACD-7DE9-4871-9DF0-CC685DF5114E">分类操作</a><br>可以在源GeoRaster对象上应用分类（分段）操作以生成新对象。
                  </li>
                  <li class="ulchildlink"><a href="raster-algebra-and-analytics.html#GUID-B1A7F654-E438-48F1-9EB6-55268FA260B1">统计业务</a><br>要对来自一个或多个GeoRaster对象的一个或多个层应用统计操作，可以使用以下类型的操作。
                  </li>
                  <li class="ulchildlink"><a href="raster-algebra-and-analytics.html#GUID-022F5214-9D1E-44B4-8487-967C93CC2954">逻辑运算</a><br>栅格代数的一个主要用途是将逻辑模型应用于来自不同来源的栅格图层;也就是说，您可以在一个或多个GeoRaster对象的一个或多个图层上应用逻辑运算，以生成新的GeoRaster对象。
                  </li>
                  <li class="ulchildlink"><a href="raster-algebra-and-analytics.html#GUID-34B59129-70AC-4E51-BF6D-2E43AA2A813B">栅格数据缩放和偏移</a><br>您可以执行栅格数据缩放和偏移操作。
                  </li>
                  <li class="ulchildlink"><a href="raster-algebra-and-analytics.html#GUID-13B8293B-2AE1-4687-B98A-9463EF42AC27">栅格数据转换</a><br>栅格数据转换将单元格值从一种数据类型映射到另一种数据类型
                  </li>
                  <li class="ulchildlink"><a href="raster-algebra-and-analytics.html#GUID-F2EBC84A-8BB8-484B-9F32-FC88D4E5F166">制图建模</a><br>栅格代数广泛用于制图建模，被认为是GIS系统的重要组成部分。使用PL / SQL和栅格代数表达式和函数，您可以对大量栅格和几乎无限大小的图像进行制图建模。
                  </li>
                  <li class="ulchildlink"><a href="raster-algebra-and-analytics.html#GUID-90AF506E-C29A-464F-95F8-2923E79AFE9B">地形建模与分析</a><br>您可以使用输入GeoRaster对象中的数据来执行地形建模和分析。
                  </li>
               </ul>
            </div>
            <a id="GEORS1216"></a><div class="props_rev_3"><a id="GUID-A6F087DC-1E7E-4426-B778-8554A25B3494" name="GUID-A6F087DC-1E7E-4426-B778-8554A25B3494"></a><h3 id="GEORS-GUID-A6F087DC-1E7E-4426-B778-8554A25B3494" class="sect3"><span class="enumeration_section">5.1</span>栅格代数语言</h3>
               <div>
                  <p>栅格代数通常用于栅格数据分析和GIS建模。在GeoRaster中，GeoRaster栅格代数语言支持栅格代数。</p>
                  <p>GeoRaster栅格代数语言是Oracle PL / SQL语言的扩展。PL / SQL提供变量和常量的声明，一般数学表达式，基本函数，语句和编程功能。GeoRaster为栅格图层操作提供栅格代数表达式语言和一组栅格代数函数。栅格代数表达式语言包括通用算术，转换，逻辑和关系运算符，并允许它们的任意组合。栅格代数函数允许使用表达式并支持基于单元格值的条件查询，数学建模，分类操作以及基于单元格值的更新或对来自一个或多个GeoRaster对象的一个或多个栅格图层进行编辑。</p>
                  <p>PL / SQL语言和GeoRaster代数表达式和函数的这种组合提供了一种易于使用，功能强大的方法，可将栅格分析定义为代数表达式，以便用户可以轻松地在栅格数据上应用代数函数来获得新结果。例如，简单的光栅操作可以使用两个或多个具有相同尺寸大小的栅格图层，通过使用代数运算（加法，减法等）或复杂的栅格操作来生成新的栅格图层，以生成标准化差异植被来自多个卫星图像频段的索引（NDVI）。</p>
                  <p>GeoRaster支持栅格代数本地操作，因此栅格代数操作适用于单个栅格单元或像素。</p>
                  <p>以下是GeoRaster栅格代数表达式语言定义：</p><pre class="oac_no_warn" dir="ltr">&lt;arithmeticExpr&gt; :: = &lt;unaryArithmeticExpr&gt; | &lt;binaryArithmeticExpr&gt; | &lt;functionalArithmeticExpr&gt; | &lt;conditionalExpr&gt; | &lt;castingExpr&gt; | &lt;booleanExpr&gt; | &lt;constantNumber&gt; | &lt;identifier&gt; | （&lt;arithmeticExpr&gt;）&lt;unaryArithmeticExpr&gt; :: =（&lt;unaryArithmeticOp&gt; &lt;arithmeticExpr&gt;）&lt;unaryArithmeticOp&gt; :: = + | -  &lt;binaryArithmeticExpr&gt; :: = &lt;arithmeticExpr&gt; &lt;binaryArithmeticOp&gt; &lt;arithmeticExpr&gt; &lt;binaryArithmeticOp&gt; :: = + | -  | * | / | ％&lt;functionalArithmeticExpr&gt; :: = &lt;statisticsFunction&gt;（）| &lt;numericFunction_with_1_param&gt;（&lt;arithmeticExpr&gt;）| &lt;numericFunction_with_2_param&gt;（&lt;arithmeticExpr&gt;，&lt;arithmeticExpr&gt;）| &lt;numericFunction_with_3_param&gt;（&lt;arithmeticExpr&gt;，&lt;arithmeticExpr&gt;，&lt;arithmeticExpr&gt;）&lt;statisticsFunction&gt; :: = min |最大|意思是中位数| std |少数民族|多数|总和|品种&lt;numericFunction_with_1_param&gt; :: = abs | sqrt | exp | exp2 | exp10 |记录| ln | log2 |罪cos |晒黑| sinh | cosh | tanh | arcsin | arccos | arctan | arcsinh | arccosh | arctanh | ceil |地板| factorial &lt;numericFunction_with_2_param&gt; :: = power | max2 | min2 &lt;numericFunction_with_3_param&gt; :: = max3 | min3 &lt;conditionalExpr&gt; :: = &lt;conditionalFunction&gt;（&lt;booleanExpr&gt;，&lt;arithmeticExpr&gt;，&lt;arithmeticExpr&gt;）&lt;conditionalFunction&gt; :: = condition &lt;castingExpr&gt; :: = &lt;castingFunction&gt;（&lt;arithmeticExpr&gt;）&lt;castingFunction&gt; :: = castint | castonebit | casttwobit | castfourbit | casteightbit | castBoolean &lt;booleanExpr&gt; :: = &lt;unaryBooleanExpr&gt; | &lt;binaryBooleanExpr&gt; | （&lt;booleanExpr&gt;）&lt;unaryBooleanExpr&gt; :: = &lt;unaryBooleanOp&gt; &lt;booleanExpr&gt; &lt;unaryBooleanOp&gt; :: =！&lt;binaryBooleanExpr&gt; :: = &lt;booleanExpr&gt; &lt;binaryBooleanOp&gt; &lt;booleanExpr&gt; | &lt;arithmeticExpr&gt; &lt;comparisonOp&gt; &lt;arithmeticExpr&gt; &lt;binaryBooleanOp&gt; :: =＆| | | ^ &lt;comparisonOp&gt; :: = = | &lt;| &gt; | &gt; = | &lt;= | ！= &lt;constantNumber&gt; :: = &lt;double number&gt; &lt;identifier&gt; :: = {&lt;ID&gt;，&lt;band&gt;} | {&lt;band&gt;} &lt;ID&gt; :: = &lt;整数&gt; &lt;band&gt; :: = &lt;整数&gt;</pre><p>表达式语言中代数运算符（+， - ，*，/等）的优先顺序符合一般约定。但是，在表达式可能被误解的任何情况下，您应该使用括号来阐明预期的解释。</p>
                  <p><code class="codeph">booleanExpr</code>可以用作<code class="codeph">arithmeticExpr</code> ，如GeoRaster栅格代数表达式语言中所定义。在这种情况下， <code class="codeph">booleanExpr</code>的<code class="codeph">TRUE</code>和<code class="codeph">FALSE</code>评估结果分别<code class="codeph">booleanExpr</code>为数值1和0。
                  </p>
                  <p>表达式中的<code class="codeph">identifier</code>指的是GeoRaster对象的栅格图层。如果只涉及一个GeoRaster对象，它可以是单个<code class="codeph">band</code>号，也可以是一对（ <code class="codeph">ID</code> ， <code class="codeph">band</code> ），其中<code class="codeph">ID</code>表示表达式中的一个GeoRaster对象，波段指的是该GeoRaster对象的特定层。此语言中的<code class="codeph">band</code>编号是指单元格空间中沿带宽度的层的纵坐标编号，因此它始终以0（零）开头。GeoRaster ID号始终以0（零）开头。
                  </p>
                  <p>以下过程为栅格代数操作提供了主要支持：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="sdo-geor-ra-ref.html#GUID-BB7A762E-E615-43AD-9D74-5E917D29F333">SDO_GEOR_RA.rasterMathOp使用</a> <code class="codeph">arithmeticExpr</code>执行数学运算或建模，使用<code class="codeph">conditionalExpr</code>和<code class="codeph">booleanExpr</code>执行逻辑运算，并使用<code class="codeph">statisticalFunction</code>表达式执行统计分析。
                        </p>
                     </li>
                     <li>
                        <p><a href="sdo-geor-ra-ref.html#GUID-67FDA0FA-D055-4821-964F-600660861A72">SDO_GEOR_RA.findCells</a>根据<code class="codeph">booleanExpr</code>条件搜索/屏蔽单元格。
                        </p>
                     </li>
                     <li>
                        <p><a href="sdo-geor-ra-ref.html#GUID-D9DA6608-7D97-4428-B1B2-002C371846E9">SDO_GEOR_RA.classify</a>将<code class="codeph">arithmeticExpr</code>应用于单元格，然后对栅格进行分段。
                        </p>
                     </li>
                     <li>
                        <p><a href="sdo-geor-ra-ref.html#GUID-7F1A50AC-9595-4AC3-83E3-D7233C9FAF2E">SDO_GEOR_RA.rasterUpdate</a>根据不同的<code class="codeph">booleanExpr</code>条件更新栅格的单元格值。
                        </p>
                     </li>
                     <li>
                        <p><a href="sdo-geor-ra-ref.html#GUID-B879FE32-88C6-4C85-95B8-47B7EDEE8C02">SDO_GEOR_RA.diff</a>和<a href="sdo-geor-ra-ref.html#GUID-D6105A06-3CC0-42C9-AC57-81333017C3A4">SDO_GEOR_RA.over</a>执行逻辑操作而不使用表达式。
                        </p>
                     </li>
                     <li>
                        <p><a href="sdo-geor-ra-ref.html#GUID-90E78211-B677-4D22-8CF8-2E7BB7740F39">SDO_GEOR_RA.stack</a>和许多其他子程序执行统计分析或生成统计数据。
                        </p>
                     </li>
                  </ul>
                  <p>这些栅格代数函数从一个或多个GeoRaster对象中获取多个层，在这些层上应用<code class="codeph">booleanExpr</code>和/或<code class="codeph">arithmeticExpr</code>表达式，执行特定的代数计算或建模，并输出新的GeoRaster对象。可以基于本节前面描述的语法以任何方式定义表达式。
                  </p>
                  <p>所有栅格代数函数都要求栅格图层相互重叠，如果它们是地理参考的，则具有相同的尺寸大小和分辨率，或者如果它们没有地理参考，则具有相同的尺寸大小。在两个或多个GeoRaster对象上应用栅格代数运算之前，可以使用<a href="sdo-geor-ra-ref.html#GUID-B64A8557-B92D-4588-812D-2F767338EA68">SDO_GEOR_RA.isOverlap</a>函数来确定GeoRaster对象是否具有相同的大小并覆盖相同的地面区域。
                  </p>
                  <p>光栅和图像数据库通常非常大。查询和操纵这些数据库是计算密集型操作。为了提高性能，所有GeoRaster栅格代数函数都是并行化的。在使用多CPU或多核服务器时，应始终考虑应用并行处理。</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="raster-algebra-and-analytics.html#GUID-E2DA56C4-CCC3-48FD-87FE-98B6966DE3BE">栅格代数表达式的示例</a><br></li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="raster-algebra-and-analytics.html#GUID-C75744C9-FA04-4391-96F2-59EF2EA212FF" title="本章介绍了栅格代数语言（PL / SQL和代数表达式）和相关的栅格操作，包括条件查询，基于单元格的更新或编辑，数学运算，分类，动态统计分析，逻辑运算及其制图建模中的应用。">栅格代数和分析</a></p>
                     </div>
                  </div>
               </div>
               <a id="GEORS1248"></a><a id="GEORS1249"></a><a id="GEORS1250"></a><a id="GEORS1247"></a><div class="props_rev_3"><a id="GUID-E2DA56C4-CCC3-48FD-87FE-98B6966DE3BE" name="GUID-E2DA56C4-CCC3-48FD-87FE-98B6966DE3BE"></a><h4 id="GEORS-GUID-E2DA56C4-CCC3-48FD-87FE-98B6966DE3BE" class="sect4"><span class="enumeration_section">5.1.1</span>光栅代数表达式的例子</h4>
                  <div>
                     <p>本节包含显示如何定义栅格代数表达式的示例。</p>
                     <div class="example" id="GUID-E2DA56C4-CCC3-48FD-87FE-98B6966DE3BE__BABCFFDB">
                        <p class="titleinexample">示例5-1基于比较查找像素（&gt;）</p>
                        <p><a href="raster-algebra-and-analytics.html#GUID-E2DA56C4-CCC3-48FD-87FE-98B6966DE3BE__BABCFFDB">示例5-1</a>查找满足由代数表达式<code class="codeph">'{1}&gt;200'</code>定义的条件的所有像素，因为过程中只涉及一个GeoRaster对象，因此<code class="codeph">{1}</code>引用第二层的单元格值（ <code class="codeph">{0}</code>将用于第一层）， <code class="codeph">'{1}&gt;200'</code>表示第二层值大于<code class="codeph">'{1}&gt;200'</code>任何像素。该示例假定源GeoRaster对象至少具有两个层。
                        </p><pre class="oac_no_warn" dir="ltr">DECLARE geor MDSYS.SDO_GEORASTER; geor1 MDSYS.SDO_GEORASTER; BEGIN从georaster_table中选择georaster到geor，其中georid = 1;从georaster_table中选择georaster到geor1，其中georid = 5表示更新; sdo_geor_ra.findcells（geor，'{1}&gt; 200'，'blocking = optimalpadding，blocking = true，blocksize =（512,512,3）'，geor1）;更新georaster_table set georaster = geor1 where georid = 5;承诺;结束; /</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-E2DA56C4-CCC3-48FD-87FE-98B6966DE3BE__BABHIBDJ">
                        <p class="titleinexample">例5-2基于表达式数组生成GeoRaster对象</p>
                        <p><a href="raster-algebra-and-analytics.html#GUID-E2DA56C4-CCC3-48FD-87FE-98B6966DE3BE__BABHIBDJ">例5-2</a>根据代数表达式数组<code class="codeph">SDO_STRING2_ARRAY('{0,0}-0.5*{1,0}','{0,1}-0.5*{1,1}','{0,2}-0.5*{1,2}')</code>从两个输入GeoRaster对象<code class="codeph">geor</code>和<code class="codeph">geor1</code>生成一个新的GeoRaster对象<code class="codeph">geor2</code> <code class="codeph">SDO_STRING2_ARRAY('{0,0}-0.5*{1,0}','{0,1}-0.5*{1,1}','{0,2}-0.5*{1,2}')</code> 。该示例假定两个源GeoRaster对象都是具有三个波段的图像。
                        </p><pre class="oac_no_warn" dir="ltr">DECLARE geor MDSYS.SDO_GEORASTER; geor1 MDSYS.SDO_GEORASTER; geor2 MDSYS.SDO_GEORASTER; geo_array MDSYS.SDO_GEORASTER_ARRAY; BEGIN从georaster_table中选择georaster到geor，其中georid = 1;从georaster_table中选择georaster到geor1，其中georid = 2;插入georaster_table值（17，sdo_geor.init（'rdt_1'，17））将georaster返回到geor2; geo_array：= MDSYS.SDO_GEORASTER_ARRAY（geor，geor1）; sdo_geor_ra.rasterMathOp（geo_array， <span class="bold">SDO_STRING2_ARRAY（'{0,0} -0.5 * {1,0}'，'{0,1} -0.5 * {1,1}'，'{0,2} -0.5 * { 1,2}'）</span> ，null，geor2）;更新georaster_table set georaster = geor2 where georid = 17;承诺;结束; /</pre><p>在<a href="raster-algebra-and-analytics.html#GUID-E2DA56C4-CCC3-48FD-87FE-98B6966DE3BE__BABHIBDJ">例5-2中</a>的代数表达式数组中：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">{0,0}</code>指的是第一个输入GeoRaster对象<code class="codeph">geor</code>的band 0的单元格值。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">{0,1}</code>指的是第一个输入GeoRaster对象<code class="codeph">geor</code>的band 1的单元格值。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">{0,2}</code>指的是第一个输入GeoRaster对象<code class="codeph">geor</code>的band 2的单元格值。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">{1,0}</code>指的是第二个输入GeoRaster对象<code class="codeph">geor1</code>的band 0的单元格值。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">{1,1}</code>指的是第二个输入GeoRaster对象<code class="codeph">geor1</code>的band 1的单元格值。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">{1,2}</code>指的是第二个输入GeoRaster对象<code class="codeph">geor1</code>的band 2的单元格值。
                              </p>
                           </li>
                        </ul>
                        <p>在<a href="raster-algebra-and-analytics.html#GUID-E2DA56C4-CCC3-48FD-87FE-98B6966DE3BE__BABHIBDJ">例5-2中</a> ，目标GeoRaster对象<code class="codeph">geor2</code>将具有三个波段，并且：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>目标GeoRaster对象<code class="codeph">geor2</code>的band 0的单元格值为： <code class="codeph">{0,0}-0.5*{1,0}</code></p>
                           </li>
                           <li>
                              <p>目标GeoRaster对象<code class="codeph">geor2</code>的band 1的单元格值为： <code class="codeph">{0,1}-0.5*{1,1}</code></p>
                           </li>
                           <li>
                              <p>目标GeoRaster对象<code class="codeph">geor2</code>的band 2的单元格值为： <code class="codeph">{0,2}-0.5*{1,2}</code></p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-E2DA56C4-CCC3-48FD-87FE-98B6966DE3BE__BABEFCFH">
                        <p class="titleinexample">示例5-3基于表达式数组更新GeoRaster对象</p>
                        <p><a href="raster-algebra-and-analytics.html#GUID-E2DA56C4-CCC3-48FD-87FE-98B6966DE3BE__BABEFCFH">例5-3</a>根据代数表达式数组<code class="codeph">SDO_STRING2_ARRAY('(abs({0}-{1})=48)&amp;({2}-{1}=-101)','2*{0}-{1}/3=108')</code>更新输入GeoRaster对象的单元格值<code class="codeph">SDO_STRING2_ARRAY('(abs({0}-{1})=48)&amp;({2}-{1}=-101)','2*{0}-{1}/3=108')</code> 。该示例假定源GeoRaster对象具有三个层。
                        </p><pre class="oac_no_warn" dir="ltr">DECLARE geor MDSYS.SDO_GEORASTER; geor1 MDSYS.SDO_GEORASTER;开始从georaster_table中选择georaster到geor，其中georid = 1; sdo_geor_ra.rasterUpdate（geor，0， <span class="bold">SDO_STRING2_ARRAY（'（abs（{0}  -  {1}）= 48）＆（{2}  -  {1} =  -  101）'，'2 * {0}  -  {1} / 3 = 108'），SDO_STRING2_ARRAYSET（SDO_STRING2_ARRAY（'123'，'54'，'89'），SDO_STRING2_ARRAY（'98'，'56'，'123'））</span> ）;结束; /</pre><p>在<a href="raster-algebra-and-analytics.html#GUID-E2DA56C4-CCC3-48FD-87FE-98B6966DE3BE__BABEFCFH">例5-3中</a> ，对于每个像素：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>如果<code class="codeph">(abs({0}-{1})=48)&amp;({2}-{1}=-101)</code>为真，那么三层的单元格值将更新为<code class="codeph">('123','54','89')</code> 。
                              </p>
                           </li>
                           <li>
                              <p>如果<code class="codeph">2*{0}-{1}/3=108</code>为真，则三层的单元格值将更新为<code class="codeph">('98','56','123')</code> 。
                              </p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="raster-algebra-and-analytics.html#GUID-A6F087DC-1E7E-4426-B778-8554A25B3494" title="栅格代数通常用于栅格数据分析和GIS建模。在GeoRaster中，GeoRaster栅格代数语言支持栅格代数。">栅格代数语言</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div><a id="GEORS1252"></a><a id="GEORS1253"></a><a id="GEORS1254"></a><a id="GEORS1251"></a><div class="props_rev_3"><a id="GUID-FF9C7591-6CCB-41B2-941D-7998F94B8FE9" name="GUID-FF9C7591-6CCB-41B2-941D-7998F94B8FE9"></a><h3 id="GEORS-GUID-FF9C7591-6CCB-41B2-941D-7998F94B8FE9" class="sect3"><span class="enumeration_section">5.2</span>基于单元格值的条件查询</h3>
               <div>
                  <p>使用基于单元格的条件查询，您可以根据指定的条件生成新的GeoRaster对象。</p>
                  <p>除了在栅格上使用基于空间的查询（例如使用<a href="SDO_GEOR-reference.html#GUID-CC66F0CA-96A9-4C4F-AB94-AEB5FE53C83D">SDO_GEOR.getRasterSubset</a> ）之外，基于单元格的查询在分析和应用程序建模中特别有用。要执行基于单元格值的条件查询并根据指定的条件生成新的GeoRaster对象，可以使用<a href="sdo-geor-ra-ref.html#GUID-67FDA0FA-D055-4821-964F-600660861A72">SDO_GEOR_RA.findCells</a>过程并指定适当的<code class="codeph">condition</code>参数。
                  </p>
                  <p><code class="codeph">condition</code>参数必须指定有效的<code class="codeph">booleanExpr</code>值（在<a href="raster-algebra-and-analytics.html#GUID-A6F087DC-1E7E-4426-B778-8554A25B3494" title="栅格代数通常用于栅格数据分析和GIS建模。在GeoRaster中，GeoRaster栅格代数语言支持栅格代数。">Raster Algebra Language中</a>解释）。该过程针对源GeoRaster对象中的每个单元计算<code class="codeph">booleanExpr</code> 。如果结果为<code class="codeph">TRUE</code> ，则原始单元格值将保留在输出GeoRaster对象中;如果结果为<code class="codeph">FALSE</code> ，则<code class="codeph">bgValues</code>用于填充输出GeoRaster对象中的单元格值。这也可以被视为掩蔽操作。
                  </p>
                  <div class="example" id="GUID-FF9C7591-6CCB-41B2-941D-7998F94B8FE9__BABDGJGJ">
                     <p class="titleinexample">例5-4条件查询</p>
                     <p><a href="raster-algebra-and-analytics.html#GUID-FF9C7591-6CCB-41B2-941D-7998F94B8FE9__BABDGJGJ">例5-4</a>调用<a href="sdo-geor-ra-ref.html#GUID-67FDA0FA-D055-4821-964F-600660861A72">SDO_GEOR_RA.findCells</a>过程来查找第二个波段的值大于200的所有像素。由于未指定bgValues参数，因此将值0用作背景值以填充使条件为false的所有像素。该示例假定源GeoRaster对象是具有两个以上波段的图像。
                     </p><pre class="oac_no_warn" dir="ltr">DECLARE geor SDO_GEORASTER; geor1 SDO_GEORASTER; BEGIN SELECT georaster INTO geor FROM georaster_table WHERE georid = 1;插入georaster_table值（5，sdo_geor.init（'rdt_1'，5））将georaster返回geor1; <span class="bold">sdo_geor_ra.findcells（geor，'{1}&gt; 200'，</span> 'blocking = optimalpadding，blocksize =（512,512,3）'，geor1）;更新georaster_table set georaster = geor1 WHERE georid = 5;承诺;结束; / <span class="bold">- 此像素设置为（0,0,0），因为</span> <span class="bold">- 第二个波段</span> <span class="bold">的单元格值为</span> <span class="bold">136，不大于200。</span>SELECT sdo_geor.getcellvalue（georaster，0,30,30，''）FROM georaster_table WHERE georid = 1 OR georid = 5 ORDER BY georid; SDO_GEOR.GETCELLVALUE（GEORASTER，0,30,30，''）----------------------------------- --------------------------------------------- SDO_NUMBER_ARRAY（88,136 ，35）选择SDO_NUMBER_ARRAY（0,0,0）2行。
 
<span class="bold">- 此像素保留原始值，因为</span> <span class="bold">第二个波段</span> <span class="bold">的单元格值</span> <span class="bold">大于200。</span>SELECT sdo_geor.getcellvalue（georaster，0,132,116，''）FROM georaster_table WHERE georid = 1 OR georid = 5 ORDER BY georid; SDO_GEOR.GETCELLVALUE（GEORASTER，0,132,116，''）--------------------------------------- ----------------------------------------- SDO_NUMBER_ARRAY（242,225,233）SDO_NUMBER_ARRAY （242,225,233）选择2行。
 
<span class="bold">- 此像素保留原始值，因为</span> <span class="bold">第二个波段</span> <span class="bold">的单元格值</span> <span class="bold">大于200。</span>SELECT sdo_geor.getcellvalue（georaster，0,261,185，''）FROM georaster_table WHERE georid = 1 OR georid = 5 ORDER BY georid; SDO_GEOR.GETCELLVALUE（GEORASTER，0,261,185，''）--------------------------------------- ----------------------------------------- SDO_NUMBER_ARRAY（255,214,2）SDO_NUMBER_ARRAY （255,214,2）</pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-FF9C7591-6CCB-41B2-941D-7998F94B8FE9__BABEGDCE">
                     <p class="titleinexample">示例5-5带有nodata参数的条件查询</p>
                     <p><a href="raster-algebra-and-analytics.html#GUID-FF9C7591-6CCB-41B2-941D-7998F94B8FE9__BABEGDCE">示例5-5</a>与<a href="raster-algebra-and-analytics.html#GUID-FF9C7591-6CCB-41B2-941D-7998F94B8FE9__BABDGJGJ">示例5-4</a>基本相同，只是将<code class="codeph">nodata</code>参数值设置为<code class="codeph">'TRUE'</code> ，以便所有NODATA像素保持其输出GeoRaster对象中输入GeoRaster对象的原始值。
                     </p><pre class="oac_no_warn" dir="ltr">DECLARE geor SDO_GEORASTER; geor1 SDO_GEORASTER; BEGIN SELECT georaster INTO geor FROM georaster_table WHERE georid = 1;插入georaster_table值（5，sdo_geor.init（'rdt_1'，5））将georaster返回geor1; <span class="bold">sdo_geor_ra.findcells（geor，'{1}&gt; 200'，</span> null，geor1，null， <span class="bold">'TRUE'</span> ）;更新georaster_table set georaster = geor1 WHERE georid = 5;承诺;结束; / SELECT sdo_geor.getcellvalue（georaster，0,30,30，''）FROM georaster_table WHERE georid = 1; SDO_GEOR.GETCELLVALUE（GEORASTER，0,30,30，''）----------------------------------- --------------------------------------------- SDO_NUMBER_ARRAY（88,136 ，35）选择1行。
 
<span class="bold">- 此像素保留其原始单元格值，因为它是nodata，即使</span> <span class="bold">- 第二个波段的单元格值不大于200。</span>SELECT sdo_geor.getcellvalue（georaster，0,30,30，''）FROM georaster_table WHERE georid = 5; SDO_GEOR.GETCELLVALUE（GEORASTER，0,30,30，''）----------------------------------- --------------------------------------------- SDO_NUMBER_ARRAY（88,136 ，35）选择1行。
 </pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-FF9C7591-6CCB-41B2-941D-7998F94B8FE9__BABEDCHD">
                     <p class="titleinexample">示例5-6使用parallelParam的条件查询</p>
                     <p><a href="raster-algebra-and-analytics.html#GUID-FF9C7591-6CCB-41B2-941D-7998F94B8FE9__BABEDCHD">例5-6</a>查找满足以下所有条件的所有像素：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>第一频带的单元值在（100,200）之间。</p>
                        </li>
                        <li>
                           <p>第二频带的单元值在[50,250]之间。</p>
                        </li>
                        <li>
                           <p>第三频带的单元值大于100。</p>
                        </li>
                     </ul>
                     <p>另外，因为<code class="codeph">parallelParam</code>被指定为<code class="codeph">'parallel=4'</code> ，所以<a href="raster-algebra-and-analytics.html#GUID-FF9C7591-6CCB-41B2-941D-7998F94B8FE9__BABEDCHD">例5-6中</a>的过程将与四个进程并行运行。
                     </p><pre class="oac_no_warn" dir="ltr">DECLARE geor SDO_GEORASTER; geor1 SDO_GEORASTER; BEGIN SELECT georaster INTO geor FROM georaster_table WHERE georid = 2;插入georaster_table值（10，sdo_geor.init（'rdt_1'，10））将georaster返回到geor1; <span class="bold">sdo_geor_ra.findcells（geor，'（{1}&gt; = 50）＆（{1} &lt;= 250）＆（{0}&gt; 100）＆（{0} &lt;200）＆{2}&gt; 100）'</span> ，null ，geor1，null，'false'， <span class="bold">'parallel = 4'</span> ）;更新georaster_table SET georaster = geor1 WHERE georid = 10;承诺;结束; /</pre></div>
                  <!-- class="example" -->
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="raster-algebra-and-analytics.html#GUID-C75744C9-FA04-4391-96F2-59EF2EA212FF" title="本章介绍了栅格代数语言（PL / SQL和代数表达式）和相关的栅格操作，包括条件查询，基于单元格的更新或编辑，数学运算，分类，动态统计分析，逻辑运算及其制图建模中的应用。">栅格代数和分析</a></p>
                     </div>
                  </div>
               </div>
               
            </div><a id="GEORS1256"></a><a id="GEORS1257"></a><a id="GEORS1255"></a><div class="props_rev_3"><a id="GUID-0AEAF37F-6147-4CC7-9573-929B1EF6B44F" name="GUID-0AEAF37F-6147-4CC7-9573-929B1EF6B44F"></a><h3 id="GEORS-GUID-0AEAF37F-6147-4CC7-9573-929B1EF6B44F" class="sect3"><span class="enumeration_section">5.3</span>基于单元格值的条件更新（编辑）</h3>
               <div>
                  <p>您可以根据条件更新栅格单元格值。</p>
                  <p>本节涉及基于单元格的栅格更新，而不是基于空间的栅格更新，这两种更新类型都在<a href="georaster-data-manipulation.html#GUID-D78B30EA-E592-4D34-94AC-AB2B1435D60E">查询和更新GeoRaster单元数据中</a>进行了描述。
                  </p>
                  <p>要根据条件更新栅格单元格值，可以使用<a href="sdo-geor-ra-ref.html#GUID-7F1A50AC-9595-4AC3-83E3-D7233C9FAF2E">SDO_GEOR_RA.rasterUpdate</a>过程并指定适当的<code class="codeph">condition</code>和<code class="codeph">vals</code>参数。
                  </p>
                  <p><code class="codeph">condition</code>参数指定布尔表达式数组， <code class="codeph">vals</code>参数指定数学表达式数组的数组。（参见<a href="raster-algebra-and-analytics.html#GUID-A6F087DC-1E7E-4426-B778-8554A25B3494" title="栅格代数通常用于栅格数据分析和GIS建模。在GeoRaster中，GeoRaster栅格代数语言支持栅格代数。">光栅代数语言中</a>的栅格代数运算解释）。对于每个单元格，如果<code class="codeph">condition</code>为<code class="codeph">TRUE</code> ，则其单元格值将更新为<code class="codeph">vals</code>数组中相应数学表达式的结果。
                  </p>
                  <div class="example" id="GUID-0AEAF37F-6147-4CC7-9573-929B1EF6B44F__BABJEABJ">
                     <p class="titleinexample">例5-7基于单元格值的更新</p>
                     <p><a href="raster-algebra-and-analytics.html#GUID-0AEAF37F-6147-4CC7-9573-929B1EF6B44F__BABJEABJ">例5-7</a>假定要更新的GeoRaster对象是具有三个波段的图像，并调用<a href="sdo-geor-ra-ref.html#GUID-7F1A50AC-9595-4AC3-83E3-D7233C9FAF2E">SDO_GEOR_RA.rasterUpdate</a>过程来执行以下操作：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>对于任何像素，如果abs（first_band_value  -  second_band_value）= 48并且（third_band_value  -  second_band_value = -101），则三个频带值将分别更新为（123,54,89）。</p>
                        </li>
                        <li>
                           <p>对于任何像素if（2 * first_band_value-second_band_value / 3）= 108，则三个频带值将分别更新为（98,56,123）。</p>
                        </li>
                     </ul>
                     <p><a href="raster-algebra-and-analytics.html#GUID-0AEAF37F-6147-4CC7-9573-929B1EF6B44F__BABJEABJ">例5-7</a>还包括对<a href="SDO_GEOR-reference.html#GUID-1E61D84B-F431-4532-B16E-E005596D4DAC">SDO_GEOR.getCellValue</a>函数的几次调用，以显示“之前”和“之后”值。
                     </p><pre class="oac_no_warn" dir="ltr">SELECT sdo_geor.getcellvalue（georaster，0,30,30，''）FROM georaster_table WHERE georid = 1; SDO_GEOR.GETCELLVALUE（GEORASTER，0,30,30，''）----------------------------------- --------------------------------------------- SDO_NUMBER_ARRAY（88,136 ，35）选择1行。SELECT sdo_geor.getcellvalue（georaster，0,130,130，''）FROM georaster_table WHERE georid = 1; SDO_GEOR.GETCELLVALUE（GEORASTER，0,130,130，''）--------------------------------------- ----------------------------------------- SDO_NUMBER_ARRAY（64,60,48）1行选中。SELECT sdo_geor.getcellvalue（georaster，0,230,230，''）FROM georaster_table WHERE georid = 1; SDO_GEOR.GETCELLVALUE（GEORASTER，0,230,230，''）--------------------------------------- ----------------------------------------- SDO_NUMBER_ARRAY（11,11,11）1行选中。DECLARE geor SDO_GEORASTER; geor1 SDO_GEORASTER; BEGIN SELECT georaster into geor FROM georaster_table WHERE georid = 1; <span class="bold">sdo_geor_ra.rasterUpdate（geor，0，SDO_STRING2_ARRAY（ '（ABS（{0} - {1}）= 48）（{2} - {1} = - 101）'，'2 * {0} - {1} / 3 = 108 '），SDO_STRING2_ARRAYSET（SDO_STRING2_ARRAY（' 123' ， '54'， '89'），SDO_STRING2_ARRAY（'98' ， '56'， '123'）））;</span>结束; / PL / SQL过程成功完成。显示错误;没有错误。
 
<span class="bold">- 此像素会更新，因为它符合第一个条件。</span>SELECT sdo_geor.getcellvalue（georaster，0,30,30，''）FROM georaster_table WHERE georid = 1; SDO_GEOR.GETCELLVALUE（GEORASTER，0,30,30，''）----------------------------------- --------------------------------------------- SDO_NUMBER_ARRAY（123,54 ，89）选择1行。
 
<span class="bold">- 此像素会更新，因为它符合第二个条件。</span>SELECT sdo_geor.getcellvalue（georaster，0,130,130，''）FROM georaster_table WHERE georid = 1; SDO_GEOR.GETCELLVALUE（GEORASTER，0,130,130，''）--------------------------------------- ----------------------------------------- SDO_NUMBER_ARRAY（98,56,123）1行选中。

<span class="bold">- 此像素保持其原始值，因为它不符合任何条件</span> <span class="bold">- 在“条件”数组中。</span>SELECT sdo_geor.getcellvalue（georaster，0,230,230，''）FROM georaster_table WHERE georid = 1; SDO_GEOR.GETCELLVALUE（GEORASTER，0,230,230，''）--------------------------------------- ----------------------------------------- SDO_NUMBER_ARRAY（11,11,11）1行选中。
</pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-0AEAF37F-6147-4CC7-9573-929B1EF6B44F__BABHCBGB">
                     <p class="titleinexample">例5-8带有nodata参数的基于单元格值的更新</p>
                     <p><a href="raster-algebra-and-analytics.html#GUID-0AEAF37F-6147-4CC7-9573-929B1EF6B44F__BABHCBGB">示例5-8</a>与<a href="raster-algebra-and-analytics.html#GUID-0AEAF37F-6147-4CC7-9573-929B1EF6B44F__BABJEABJ">示例5-7</a>基本相同，只是将<code class="codeph">nodata</code>参数值设置为<code class="codeph">'TRUE'</code> ，以便所有NODATA像素保持其输出GeoRaster对象中输入GeoRaster对象的原始值。
                     </p><pre class="oac_no_warn" dir="ltr">SELECT sdo_geor.getcellvalue（georaster，0,30,30，''）FROM georaster_table WHERE georid = 1; SDO_GEOR.GETCELLVALUE（GEORASTER，0,30,30，''）----------------------------------- --------------------------------------------- SDO_NUMBER_ARRAY（88,136 ，35）选择1行。SELECT sdo_geor.getcellvalue（georaster，0,130,130，''）FROM georaster_table WHERE georid = 1; SDO_GEOR.GETCELLVALUE（GEORASTER，0,130,130，''）--------------------------------------- ----------------------------------------- SDO_NUMBER_ARRAY（64,60,48）1行选中。SELECT sdo_geor.getcellvalue（georaster，0,230,230，''）FROM georaster_table WHERE georid = 1; SDO_GEOR.GETCELLVALUE（GEORASTER，0,230,230，''）--------------------------------------- ----------------------------------------- SDO_NUMBER_ARRAY（11,11,11）1行选中。DECLARE geor SDO_GEORASTER; geor1 SDO_GEORASTER; BEGIN SELECT georaster into geor FROM georaster_table WHERE georid = 1; <span class="bold">sdo_geor.addNODATA（geor，1,88）;</span> <span class="bold">sdo_geor_ra.rasterUpdate</span> （geor，0，SDO_STRING2_ARRAY（'（abs（{0}  -  {1}）= 48）＆（{2}  -  {1} =  -  101）'，'2 * {0}  -  {1} / 3 = 108'），SDO_STRING2_ARRAYSET（SDO_STRING2_ARRAY（'123'，'54'，'89'），SDO_STRING2_ARRAY（'98'，'56'，'123'）），null， <span class="bold">'true'</span> ）;结束; / PL / SQL过程成功完成。

<span class="bold">- 此像素保留其原始值，因为它是NODATA像素。</span>SELECT sdo_geor.getcellvalue（georaster，0,30,30，''）FROM georaster_table WHERE georid = 1; SDO_GEOR.GETCELLVALUE（GEORASTER，0,30,30，''）----------------------------------- --------------------------------------------- SDO_NUMBER_ARRAY（88,136 ，35）选择1行。- 此像素会更新，因为它符合第二个条件。SELECT sdo_geor.getcellvalue（georaster，0,130,130，''）FROM georaster_table WHERE georid = 1; SDO_GEOR.GETCELLVALUE（GEORASTER，0,130,130，''）--------------------------------------- ----------------------------------------- SDO_NUMBER_ARRAY（98,56,123）1行选中。</pre></div>
                  <!-- class="example" -->
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="raster-algebra-and-analytics.html#GUID-C75744C9-FA04-4391-96F2-59EF2EA212FF" title="本章介绍了栅格代数语言（PL / SQL和代数表达式）和相关的栅格操作，包括条件查询，基于单元格的更新或编辑，数学运算，分类，动态统计分析，逻辑运算及其制图建模中的应用。">栅格代数和分析</a></p>
                     </div>
                  </div>
               </div>
               
            </div><a id="GEORS1259"></a><a id="GEORS1260"></a><a id="GEORS1261"></a><a id="GEORS1258"></a><div class="props_rev_3"><a id="GUID-C6250398-2364-4FEE-B06E-644B5F1251AB" name="GUID-C6250398-2364-4FEE-B06E-644B5F1251AB"></a><h3 id="GEORS-GUID-C6250398-2364-4FEE-B06E-644B5F1251AB" class="sect3"><span class="enumeration_section">5.4</span>数学运算</h3>
               <div>
                  <p>栅格代数的主要用途是将数学模型应用于来自不同源的栅格图层。</p>
                  <p>要在一个或多个层（可能来自一个或多个GeoRaster对象）上应用数学运算来生成新的GeoRaster对象，可以使用<a href="sdo-geor-ra-ref.html#GUID-BB7A762E-E615-43AD-9D74-5E917D29F333">SDO_GEOR_RA.rasterMathOp</a>过程。
                  </p>
                  <p>对于此过程的大多数格式， <code class="codeph">operation</code>参数指定用于计算输出GeoRaster对象中的栅格单元值的<code class="codeph">arithmeticExpr</code>字符串数组。数组的每个元素对应于输出GeoRaster对象中的一个层。
                  </p>
                  <p>请注意， <code class="codeph">booleanExpr</code>也可以用作<code class="codeph">arithmeticExpr</code> ，如<a href="raster-algebra-and-analytics.html#GUID-0AEAF37F-6147-4CC7-9573-929B1EF6B44F__BABHCBGB">例5-8所示</a> 。
                  </p>
                  <div class="example" id="GUID-C6250398-2364-4FEE-B06E-644B5F1251AB__BABIEHFB">
                     <p class="titleinexample">例5-9数学运算（1）</p>
                     <p><a href="raster-algebra-and-analytics.html#GUID-C6250398-2364-4FEE-B06E-644B5F1251AB__BABIEHFB">例5-9</a>调用<a href="sdo-geor-ra-ref.html#GUID-BB7A762E-E615-43AD-9D74-5E917D29F333">SDO_GEOR_RA.rasterMathOp</a>过程从3层源GeoRaster对象生成新的6层GeoRaster对象，并遵循这些规则来计算目标GeoRaster对象的单元格值：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>目标GeoRaster对象的前三层的单元格值等于源GeoRaster对象的相应图层的值减去10。</p>
                        </li>
                        <li>
                           <p>最后三层目标GeoRaster对象的单元格值分别等于源GeoRaster对象的前三层的值。</p>
                        </li>
                     </ul><pre class="oac_no_warn" dir="ltr">DECLARE geor SDO_GEORASTER; geor1 SDO_GEORASTER; geor2 SDO_GEORASTER; BEGIN SELECT georaster INTO geor FROM georaster_table WHERE georid = 1;插入georaster_table值（16，sdo_geor.init（'rdt_1'，16））将georaster返回到geor1; <span class="bold">sdo_geor_ra.rasterMathOp（geor，SDO_STRING2_ARRAY（ '{0,0} -10'， '{0,1} -10'， '{0,2} -10'， '{0,0}'，“{0， 1}”， '{0,2}'），NULL，geor1）;</span>更新georaster_table SET georaster = geor1 WHERE georid = 16;承诺;结束; / PL / SQL过程成功完成。SELECT sdo_geor.getcellvalue（georaster，0,100,100，''）FROM georaster_table WHERE georid = 1; SDO_GEOR.GETCELLVALUE（GEORASTER，0,100,100，''）--------------------------------------- ----------------------------------------- SDO_NUMBER_ARRAY（181,163,159）1行选中。
 
<span class="bold">- 在下一个SELECT语句的结果中，注意：</span> <span class="bold">-  171 = 181-10</span> <span class="bold">-  153 = 163-10</span> <span class="bold">-  149 = 159-10</span> <span class="bold">-  181 = 181</span> <span class="bold">-  163 = 163</span> <span class="bold">-  159 = 159</span> SELECT sdo_geor.getcellvalue（georaster，0,100,100，''）FROM georaster_table WHERE georid = 16; SDO_GEOR.GETCELLVALUE（GEORASTER，0,100,100，''）--------------------------------------- ----------------------------------------- SDO_NUMBER_ARRAY（171,153,149,181 ，163,159）选择1行。
</pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-C6250398-2364-4FEE-B06E-644B5F1251AB__BABBCEJB">
                     <p class="titleinexample">例5-10数学运算（2）</p>
                     <p><a href="raster-algebra-and-analytics.html#GUID-C6250398-2364-4FEE-B06E-644B5F1251AB__BABBCEJB">例5-10</a>对2元素GeoRaster数组（包含两个3层源GeoRaster对象）应用操作，以生成新的3层GeoRaster对象。
                     </p><pre class="oac_no_warn" dir="ltr">DECLARE geor SDO_GEORASTER; geor1 SDO_GEORASTER; geor2 SDO_GEORASTER; geo_array SDO_GEORASTER_ARRAY; BEGIN SELECT georaster INTO geor FROM georaster_table WHERE georid = 1; SELECT georaster INTO geor2 FROM georaster_table WHERE georid = 2;插入georaster_table值（17，sdo_geor.init（'rdt_1'，17））将georaster返回geor1; <span class="bold">geo_array：= SDO_GEORASTER_ARRAY（geor，geor2）;</span> <span class="bold">sdo_geor_ra.rasterMathOp（geo_array，SDO_STRING2_ARRAY（ '{0,0} * -0.5 {1,0}'， '{0,1} * -0.5 {1,1}'，“{0,2} -0.5 * { 1,2} '），NULL，geor1，'假”，NULL， '平行= 4'）;</span>更新georaster_table SET georaster = geor1 WHERE georid = 17;承诺;结束; / PL / SQL过程成功完成。SELECT sdo_geor.getcellvalue（georaster，0,100,100，''）FROM georaster_table WHERE georid = 1或georid = 2; SDO_GEOR.GETCELLVALUE（GEORASTER，0,100,100，''）--------------------------------------- ----------------------------------------- SDO_NUMBER_ARRAY（181,163,159）SDO_NUMBER_ARRAY （60,80,90）选择2行。
 
<span class="bold">- 在下一个SELECT语句的结果中，注意：</span> <span class="bold">-  151 = 181-0.5 * 60</span> <span class="bold">-  123 = 163-0.5 * 80</span> <span class="bold">-  114 = 159-0.5 * 90</span> SELECT sdo_geor.getcellvalue（georaster，0,100,100，' '）FROM georaster_table WHERE georid = 17; SDO_GEOR.GETCELLVALUE（GEORASTER，0,100,100，''）--------------------------------------- ----------------------------------------- SDO_NUMBER_ARRAY（151,123 114）1行选择。
</pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-C6250398-2364-4FEE-B06E-644B5F1251AB__BABGBIIG">
                     <p class="titleinexample">例5-11数学运算（3）</p>
                     <p><a href="raster-algebra-and-analytics.html#GUID-C6250398-2364-4FEE-B06E-644B5F1251AB__BABGBIIG">例5-11</a>对两个3层输入GeoRaster对象应用减法运算，以生成新的GeoRaster对象。该示例还包括对<a href="SDO_GEOR-reference.html#GUID-1E61D84B-F431-4532-B16E-E005596D4DAC">SDO_GEOR.getCellValue</a>函数的多次调用，以显示“之前”和“之后”值。
                     </p><pre class="oac_no_warn" dir="ltr">SELECT sdo_geor.getcellvalue（georaster，0,10,10，'0-2'）FROM georaster_table WHERE georid = 1 OR georid = 5 ORDER BY georid; SDO_GEOR.GETCELLVALUE（GEORASTER，0,10,10，'0-2'）-------------------------------- ------------------------------------------------ SDO_NUMBER_ARRAY（ 88,137,32）SDO_NUMBER_ARRAY（98,147,42）选择了2行。SELECT sdo_geor.getcellvalue（georaster，0,100,100，'0-2'）FROM georaster_table WHERE georid = 1 OR georid = 5 ORDER BY georid; SDO_GEOR.GETCELLVALUE（GEORASTER，0,100,100，'0-2'）------------------------------------ -------------------------------------------- SDO_NUMBER_ARRAY（181,163， 159）SDO_NUMBER_ARRAY（191,173,169）选择了2行。DECLARE geor0 SDO_GEORASTER; geor SDO_GEORASTER; geor1 SDO_GEORASTER; BEGIN SELECT georaster INTO geor FROM georaster_table WHERE georid = 1; SELECT georaster INTO geor0 FROM georaster_table WHERE georid = 5;插入georaster_table值（6，sdo_geor.init（'rdt_1'，6））将georaster返回geor1; sdo_geor_ra.rasterMathOp（geor0，geor，null， <span class="bold">sdo_geor_ra。OPERATOR_SUBTRACT</span> ，null，geor1）;更新georaster_table SET georaster = geor1 WHERE georid = 6;承诺;结束; / PL / SQL过程成功完成。SELECT sdo_geor.getcellvalue（georaster，0,10,10，'0-2'）FROM georaster_table WHERE georid = 6; SDO_GEOR.GETCELLVALUE（GEORASTER，0,10,10，'0-2'）-------------------------------- ------------------------------------------------ SDO_NUMBER_ARRAY（ 10,10,10）选择1行。SELECT sdo_geor.getcellvalue（georaster，0,100,100，'0-2'）FROM georaster_table WHERE georid = 6; SDO_GEOR.GETCELLVALUE（GEORASTER，0,100,100，'0-2'）------------------------------------ -------------------------------------------- SDO_NUMBER_ARRAY（10,10， 10）选择1行。
</pre></div>
                  <!-- class="example" -->
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="raster-algebra-and-analytics.html#GUID-C75744C9-FA04-4391-96F2-59EF2EA212FF" title="本章介绍了栅格代数语言（PL / SQL和代数表达式）和相关的栅格操作，包括条件查询，基于单元格的更新或编辑，数学运算，分类，动态统计分析，逻辑运算及其制图建模中的应用。">栅格代数和分析</a></p>
                     </div>
                  </div>
               </div>
               
            </div><a id="GEORS1263"></a><a id="GEORS1264"></a><a id="GEORS1262"></a><div class="props_rev_3"><a id="GUID-57DE5ACD-7DE9-4871-9DF0-CC685DF5114E" name="GUID-57DE5ACD-7DE9-4871-9DF0-CC685DF5114E"></a><h3 id="GEORS-GUID-57DE5ACD-7DE9-4871-9DF0-CC685DF5114E" class="sect3"><span class="enumeration_section">5.5</span>分类操作</h3>
               <div>
                  <p>可以在源GeoRaster对象上应用分类（分段）操作以生成新对象。</p>
                  <p><a id="d21717e1014" class="indexterm-anchor"></a>要对源GeoRaster对象应用简单的分类操作并根据您的规范生成新的GeoRaster对象，可以使用<a href="sdo-geor-ra-ref.html#GUID-D9DA6608-7D97-4428-B1B2-002C371846E9">SDO_GEOR_RA.classify</a>过程并指定<code class="codeph">expression</code> ， <code class="codeph">rangeArray</code>和<code class="codeph">valueArray</code>参数。该分类过程也称为<span class="italic">分割</span> 。
                  </p>
                  <p><code class="codeph">expression</code>参数用于计算用于映射到<code class="codeph">rangeArray</code>参数中定义的值范围的值。<code class="codeph">rangeArray</code>参数指定一个数字数组，该数组定义用于对单元格值进行分类的范围，并且此数组必须至少包含一个元素。<code class="codeph">valueArray</code>参数是一个数字数组，用于定义每个范围的目标单元格值，其长度必须是<code class="codeph">rangeArray</code>的长度加1。
                  </p>
                  <div class="example" id="GUID-57DE5ACD-7DE9-4871-9DF0-CC685DF5114E__BABDFCHH">
                     <p class="titleinexample">例5-12分类</p>
                     <p><a href="raster-algebra-and-analytics.html#GUID-57DE5ACD-7DE9-4871-9DF0-CC685DF5114E__BABDFCHH">例5-12</a>调用<a href="sdo-geor-ra-ref.html#GUID-D9DA6608-7D97-4428-B1B2-002C371846E9">SDO_GEOR_RA.classify</a>过程对输入GeoRaster对象的第一个波段的值应用分段操作。该示例假定GeoRaster对象是图像。
                     </p><pre class="oac_no_warn" dir="ltr">DECLARE geor SDO_GEORASTER; geor1 SDO_GEORASTER; rangeArray SDO_NUMBER_ARRAY; valueArray SDO_NUMBER_ARRAY; BEGIN rangeArray：= sdo_number_array（70,80,90,100,110,120,130,140,150,160,170,180）; valueArray：= sdo_number_array（70,80,90,100,110,120,130,140,150,160,170,180,190）; SELECT georaster INTO geor FROM georaster_table WHERE georid = 1;插入georaster_table值（5，sdo_geor.init（'rdt_1'，5））将georaster返回geor1; <span class="bold">sdo_geor_ra.classify（geor， '{0}'，rangeArray，valueArray，NULL，geor1）;</span>更新georaster_table SET georaster = geor1 WHERE georid = 5;承诺;结束; / PL / SQL过程成功完成。
 
<span class="bold">- 在下一个语句中，目标值为90，因为</span> <span class="bold">源GeoRaster对象的第一个波段的值为88，介于80和90之间。</span>SELECT sdo_geor.getcellvalue（georaster，0,30,30，''）FROM georaster_table WHERE georid = 1 OR georid = 5 ORDER BY georid; SDO_GEOR.GETCELLVALUE（GEORASTER，0,30,30，''）----------------------------------- --------------------------------------------- SDO_NUMBER_ARRAY（88,136 ，35）SDO_NUMBER_ARRAY（90）选择了2行。
 
<span class="bold">- 在下一个语句中，目标值为190，因为</span> <span class="bold">源GeoRaster对象的第一个波段的值为242，大于180。</span>SELECT sdo_geor.getcellvalue（georaster，0,132,116，''）FROM georaster_table WHERE georid = 1 OR georid = 5 ORDER BY georid; SDO_GEOR.GETCELLVALUE（GEORASTER，0,132,116，''）--------------------------------------- ----------------------------------------- SDO_NUMBER_ARRAY（242,225,233）SDO_NUMBER_ARRAY （190）选择2行。
</pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-57DE5ACD-7DE9-4871-9DF0-CC685DF5114E__BABDBHDC">
                     <p class="titleinexample">示例5-13使用nodata和nodataValue参数进行分类</p>
                     <p><a href="raster-algebra-and-analytics.html#GUID-57DE5ACD-7DE9-4871-9DF0-CC685DF5114E__BABDBHDC">例5-13</a>调用<a href="sdo-geor-ra-ref.html#GUID-D9DA6608-7D97-4428-B1B2-002C371846E9">SDO_GEOR_RA.classify</a>过<code class="codeph">nodata</code> GeoRaster对象的第一层的值应用分段操作，并将<code class="codeph">nodata</code>参数设置为<code class="codeph">'TRUE'</code> ，将<code class="codeph">nodataValue</code>参数设置为5，以便所有NODATA像素将在目标GeoRaster对象中设置NODATA值为5。
                     </p><pre class="oac_no_warn" dir="ltr">DECLARE geor SDO_GEORASTER; geor1 SDO_GEORASTER; rangeArray SDO_NUMEBR_ARRAY; valueArray SDO_NUMEBR_ARRAY; BEGIN rangeArray：= sdo_number_array（70,80,90,100,110,120,130,140,150,160,170,180）; valueArray：= sdo_number_array（70,80,90,100,110,120,130,140,150,160,170,180,190）; SELECT georaster INTO geor FROM georaster_table WHERE georid = 1; <span class="bold">sdo_geor.addNODATA（geor，2,136）;</span>插入georaster_table值（5，sdo_geor.init（'rdt_1'，5））将georaster返回geor1; sdo_geor_ra.classify（geor，'{0}'，rangeArray，valueArray，null，geor1， <span class="bold">'true'</span> <span class="bold">，5</span> ）;更新georaster_table SET georaster = geor1 WHERE georid = 5;结束; / PL / SQL过程成功完成。
 
<span class="bold">- 在下一个语句中，单元格的目标值为5，因为</span> <span class="bold">输入GeoRaster对象的第二层的值为136，即nodata。</span>SELECT sdo_geor.getcellvalue（georaster，0,30,30，''）FROM georaster_table WHERE georid = 1 OR georid = 5 ORDER BY georid; SDO_GEOR.GETCELLVALUE（GEORASTER，0,30,30，''）----------------------------------- --------------------------------------------- SDO_NUMBER_ARRAY（88,136 ，35）SDO_NUMBER_ARRAY（5）选择了2行。</pre></div>
                  <!-- class="example" -->
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="raster-algebra-and-analytics.html#GUID-C75744C9-FA04-4391-96F2-59EF2EA212FF" title="本章介绍了栅格代数语言（PL / SQL和代数表达式）和相关的栅格操作，包括条件查询，基于单元格的更新或编辑，数学运算，分类，动态统计分析，逻辑运算及其制图建模中的应用。">栅格代数和分析</a></p>
                     </div>
                  </div>
               </div>
               
            </div>
            <div class="props_rev_3"><a id="GUID-B1A7F654-E438-48F1-9EB6-55268FA260B1" name="GUID-B1A7F654-E438-48F1-9EB6-55268FA260B1"></a><h3 id="GEORS-GUID-B1A7F654-E438-48F1-9EB6-55268FA260B1" class="sect3"><span class="enumeration_section">5.6</span>统计业务</h3>
               <div>
                  <p>要对来自一个或多个GeoRaster对象的一个或多个层应用统计操作，可以使用以下类型的操作。</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="raster-algebra-and-analytics.html#GUID-9FF22F4B-19E8-45B2-9811-8ABA00268613">实时统计分析</a><br></li>
                     <li class="ulchildlink"><a href="raster-algebra-and-analytics.html#GUID-94CA2FD0-EAF3-4ED9-803F-9129DD2E0584">堆栈统计分析</a><br></li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="raster-algebra-and-analytics.html#GUID-C75744C9-FA04-4391-96F2-59EF2EA212FF" title="本章介绍了栅格代数语言（PL / SQL和代数表达式）和相关的栅格操作，包括条件查询，基于单元格的更新或编辑，数学运算，分类，动态统计分析，逻辑运算及其制图建模中的应用。">栅格代数和分析</a></p>
                     </div>
                  </div>
               </div>
               <a id="GEORS1265"></a><div class="props_rev_3"><a id="GUID-9FF22F4B-19E8-45B2-9811-8ABA00268613" name="GUID-9FF22F4B-19E8-45B2-9811-8ABA00268613"></a><h4 id="GEORS-GUID-9FF22F4B-19E8-45B2-9811-8ABA00268613" class="sect4"><span class="enumeration_section">5.6.1</span>实时统计分析</h4>
                  <div>
                     <p>许多应用需要统计分析。GeoRaster提供统计分析功能，动态（“动态”）计算GeoRaster对象的完整统计值或以下各个统计值：最小值，最大值，平均值，中值，模式和标准偏差。您可以在不生成直方图和更新GeoRaster对象元数据的情况下执行此操作。</p>
                     <p>这些子程序支持金字塔，逐个波段和指定波段号的聚合。每个子程序返回一个SDO_NUMBER_ARRAY对象或一个数字。</p>
                     <p>有关这些动态统计计算子程序的说明和示例，请参阅参考信息：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="SDO_GEOR-reference.html#GUID-96B2E47F-17E2-491D-9FF6-AC7BEFB434D7">SDO_GEOR.generateStatistics</a></p>
                        </li>
                        <li>
                           <p><a href="SDO_GEOR-reference.html#GUID-FD88A636-A97B-456E-A07A-DE2D6AE54545">SDO_GEOR.generateStatisticsMax</a></p>
                        </li>
                        <li>
                           <p><a href="SDO_GEOR-reference.html#GUID-CE118FEB-6F5D-4B42-9D95-2989355D7222">SDO_GEOR.generateStatisticsMean</a></p>
                        </li>
                        <li>
                           <p><a href="SDO_GEOR-reference.html#GUID-5726F33E-CDE7-4793-9973-B0F779E629E8">SDO_GEOR.generateStatisticsMedian</a></p>
                        </li>
                        <li>
                           <p><a href="SDO_GEOR-reference.html#GUID-963EB183-C710-471B-A1DA-9665D93FE2DC">SDO_GEOR.generateStatisticsMin</a></p>
                        </li>
                        <li>
                           <p><a href="SDO_GEOR-reference.html#GUID-D36B7F54-FEF4-4111-AF3F-99A193BEC0D9">SDO_GEOR.generateStatisticsMode</a></p>
                        </li>
                        <li>
                           <p><a href="SDO_GEOR-reference.html#GUID-453A78AC-CCDB-4E87-9A67-7C2C113B1C57">SDO_GEOR.generateStatisticsSTD</a></p>
                        </li>
                     </ul>
                     <p>这些子程序不会修改GeoRaster对象中的元数据，除了某些格式的<a href="SDO_GEOR-reference.html#GUID-96B2E47F-17E2-491D-9FF6-AC7BEFB434D7">SDO_GEOR.generateStatistics</a>在GeoRaster对象元数据中设置统计数据并返回字符串值<code class="codeph">TRUE</code>或<code class="codeph">FALSE</code>而不是SDO_NUMBER_ARRAY对象。
                     </p>
                     <p>GeoRaster还提供统计分析功能，用于计算输入GeoRaster对象的特定窗口内的单元格和子单元格的面积加权统计平均值，并计算由数字高程模型（DEM）表示的三维（3D）表面区域）存储在GeoRaster对象中的数据。有关这些动态统计计算功能的说明和示例，请参阅参考信息：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="SDO_GEOR-reference.html#GUID-179F3873-50F9-48A9-A54C-644A0DABF231">SDO_GEOR.generateAreaWeightedMean</a></p>
                        </li>
                        <li>
                           <p><a href="SDO_GEOR_UTL-reference.html#GUID-7D97E9ED-64E7-44BD-8920-0CAF4B297DA1">SDO_GEOR_UTL.calcSurfaceArea</a></p>
                        </li>
                     </ul>
                     <p>这两个函数支持不规则多边形裁剪和子单元计算，从而提供非常准确的结果。</p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="raster-algebra-and-analytics.html#GUID-B1A7F654-E438-48F1-9EB6-55268FA260B1" title="要对来自一个或多个GeoRaster对象的一个或多个层应用统计操作，可以使用以下类型的操作。">统计操作</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="props_rev_3"><a id="GUID-94CA2FD0-EAF3-4ED9-803F-9129DD2E0584" name="GUID-94CA2FD0-EAF3-4ED9-803F-9129DD2E0584"></a><h4 id="GEORS-GUID-94CA2FD0-EAF3-4ED9-803F-9129DD2E0584" class="sect4"><span class="enumeration_section">5.6.2</span>堆栈统计分析</h4>
                  <div>
                     <p>堆栈统计分析通过计算每个单元格的以下统计值之一，从一个或多个层（一个或多个GeoRaster对象）生成新的单层GeoRaster对象：max，min，median，std，sum，minority，多数或多样性。</p>
                     <p>要执行堆栈统计分析，您有以下选择：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>使用<a href="sdo-geor-ra-ref.html#GUID-90E78211-B677-4D22-8CF8-2E7BB7740F39">SDO_GEOR_RA.stack</a>过程。
                           </p>
                           <p>此选项更直观，不需要构建栅格代数表达式（特别是对于具有多个图层的GeoRaster对象），并且它允许您指定图层列表而不是所有图层。</p>
                        </li>
                        <li>
                           <p>使用<a href="sdo-geor-ra-ref.html#GUID-BB7A762E-E615-43AD-9D74-5E917D29F333">SDO_GEOR_RA.rasterMathOp</a>过程。
                           </p>
                           <p>此选项更灵活，功能更强大，允许您执行更复杂的统计分析。</p>
                        </li>
                     </ul>
                     <div class="example" id="GUID-94CA2FD0-EAF3-4ED9-803F-9129DD2E0584__GUID-3C6CEF84-6802-4A13-A81B-2E29C0BA1FDA">
                        <p class="titleinexample">例5-14使用SDO_GEOR_RA.stack</p>
                        <p>此示例使用第一个选项执行堆栈统计分析。它通过计算两个3层源GeoRaster对象的第2层和第5层的最大（最大）值来调用<a href="sdo-geor-ra-ref.html#GUID-90E78211-B677-4D22-8CF8-2E7BB7740F39">SDO_GEOR_RA.stack</a>过程来生成新的GeoRaster对象。
                        </p><pre class="pre codeblock"><code>DECLARE geor MDSYS.SDO_GEORASTER; geor1 MDSYS.SDO_GEORASTER; geor2 MDSYS.SDO_GEORASTER; geom mdsys.sdo_geometry; BEGIN geom：= sdo_geometry（2003,82394，NULL，sdo_elem_info_array（1,1003,1），sdo_ordinate_array（20283.775,1011087.9,18783.775,1008687.9,21783.775,1008687.9,22683.775 + 0.001,1009587.9 + 0.001,20283.775,1011087.9））;从Georaster_table中选择georaster到geor，其中georid = 100;从georaster_table中选择georaster到geor2，其中georid = 102;从georaster_table中选择georaster到geor1，其中georid = 101进行更新; sdo_geor_ra.stack（SDO_GEORASTER_ARRAY（geor，geor2）的geom，SDO_NUMBER_ARRAY（2,5）， '最大'，NULL，geor1， '假'，0， 'TRUE'）;更新georaster_table set georaster = geor1 where georid = 101;结束; / PL / SQL过程成功完成。SELECT sdo_geor.getcellvalue（georaster，0,100,100，''）FROM georaster_table WHERE georid = 100; SDO_GEOR.GETCELLVALUE（GEORASTER，0,100,100，''）--------------------------------------- ----------------------------------------- SDO_NUMBER_ARRAY（121,66,181）1行选中。SELECT sdo_geor.getcellvalue（georaster，0,100,100，''）FROM georaster_table WHERE georid = 102; SDO_GEOR.GETCELLVALUE（GEORASTER，0,100,100，''）--------------------------------------- ----------------------------------------- SDO_NUMBER_ARRAY（33,55,56）1行选中。- 在下一个SELECT语句的结果中，注意： -  max（181,56）==&gt; 181 SELECT sdo_geor.getcellvalue（georaster，0,100,100，''）FROM georaster_table WHERE georid = 101; SDO_GEOR.GETCELLVALUE（GEORASTER，0,100,100，''）--------------------------------------- ----------------------------------------- SDO_NUMBER_ARRAY（181）选中1行。
</code></pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-94CA2FD0-EAF3-4ED9-803F-9129DD2E0584__GUID-77AE3ADC-60DA-4455-A8C2-C9C0FFB3C421">
                        <p class="titleinexample">例5-15使用SDO_GEOR_RA.rasterMathOp</p>
                        <p>此示例使用第二个选项执行堆栈统计分析。它调用<a href="sdo-geor-ra-ref.html#GUID-BB7A762E-E615-43AD-9D74-5E917D29F333">sdo_GEOR_RA.rasterMathOp</a>指定统计操作（max）以执行类似于前面示例的操作，但此示例适用于所有层。
                        </p><pre class="pre codeblock"><code>DECLARE geor MDSYS.SDO_GEORASTER; geor1 MDSYS.SDO_GEORASTER; geor2 MDSYS.SDO_GEORASTER; geo_array MDSYS.SDO_GEORASTER_ARRAY; BEGIN从Georaster_table中选择georaster到geor，其中georid = 100;从Georaster_table中选择georaster到geor1，其中georid = 101;从georaster_table中选择georaster到geor2，其中georid = 102进行更新; geo_array：= MDSYS.SDO_GEORASTER_ARRAY（geor，geor1）; sdo_geor_ra.rasterMathOp（geo_array，SDO_STRING2_ARRAY（ '最大（）'），NULL，geor2）;更新georaster_table set georaster = geor2 where georid = 102;承诺;结束; / PL / SQL过程成功完成。SELECT sdo_geor.getcellvalue（georaster，0,100,100，''）FROM georaster_table WHERE georid = 100; SDO_GEOR.GETCELLVALUE（GEORASTER，0,100,100，''）--------------------------------------- ----------------------------------------- SDO_NUMBER_ARRAY（181,163,159）1行选中。SELECT sdo_geor.getcellvalue（georaster，0,100,100，''）FROM georaster_table WHERE georid = 101; SDO_GEOR.GETCELLVALUE（GEORASTER，0,100,100，''）--------------------------------------- ----------------------------------------- SDO_NUMBER_ARRAY（181,122,159）1行选中。- 在下一个SELECT语句的结果中，注意： -  max（181,163,159,181,122,159）==&gt; 181 SELECT sdo_geor.getcellvalue（georaster，0,100,100，''）FROM georaster_table WHERE georid = 102; SDO_GEOR.GETCELLVALUE（GEORASTER，0,100,100，''）--------------------------------------- ----------------------------------------- SDO_NUMBER_ARRAY（181）选中1行。
</code></pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="raster-algebra-and-analytics.html#GUID-B1A7F654-E438-48F1-9EB6-55268FA260B1" title="要对来自一个或多个GeoRaster对象的一个或多个层应用统计操作，可以使用以下类型的操作。">统计操作</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div>
            <div class="props_rev_3"><a id="GUID-022F5214-9D1E-44B4-8487-967C93CC2954" name="GUID-022F5214-9D1E-44B4-8487-967C93CC2954"></a><h3 id="GEORS-GUID-022F5214-9D1E-44B4-8487-967C93CC2954" class="sect3"><span class="enumeration_section">5.7</span>逻辑操作</h3>
               <div>
                  <p>栅格代数的一个主要用途是将逻辑模型应用于来自不同来源的栅格图层;也就是说，您可以在一个或多个GeoRaster对象的一个或多个图层上应用逻辑运算，以生成新的GeoRaster对象。</p>
                  <p>要应用逻辑运算，您可以使用带有逻辑表达式的栅格代数过程，这种过程更灵活，功能更强大，主要用于某些复杂的栅格逻辑运算，或仅使用栅格代数程序，这些过程非常简单，不需要构造复杂的逻辑表达式。但是，仅使用栅格代数过程（即没有逻辑表达式）具有一些限制，主要用于某些特定的栅格逻辑操作。</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="raster-algebra-and-analytics.html#GUID-4CA82053-00A1-44BF-B675-969796BA8735">使用带有逻辑表达式的Raster代数过程</a><br></li>
                     <li class="ulchildlink"><a href="raster-algebra-and-analytics.html#GUID-DDCEB15D-3C90-4317-B8B5-A633AD248519">仅使用栅格代数函数</a><br></li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="raster-algebra-and-analytics.html#GUID-C75744C9-FA04-4391-96F2-59EF2EA212FF" title="本章介绍了栅格代数语言（PL / SQL和代数表达式）和相关的栅格操作，包括条件查询，基于单元格的更新或编辑，数学运算，分类，动态统计分析，逻辑运算及其制图建模中的应用。">栅格代数和分析</a></p>
                     </div>
                  </div>
               </div>
               
               <div class="props_rev_3"><a id="GUID-4CA82053-00A1-44BF-B675-969796BA8735" name="GUID-4CA82053-00A1-44BF-B675-969796BA8735"></a><h4 id="GEORS-GUID-4CA82053-00A1-44BF-B675-969796BA8735" class="sect4"><span class="enumeration_section">5.7.1</span>使用带有逻辑表达式的栅格代数程序</h4>
                  <div>
                     <p>GeoRaster逻辑表达式可以是条件表达式，布尔表达式或两者，它可以采用一元和二元布尔运算符（！，＆，|，^）和比较运算符（=，&lt;，&gt;，&lt;=，&gt; =， ！=）。</p>
                     <p>要在栅格数据上应用逻辑表达式，必须使用SDO_GEOR_RA包中定义的栅格代数过程，并使用构造的逻辑表达式指定适当的参数。</p>
                     <div class="example" id="GUID-4CA82053-00A1-44BF-B675-969796BA8735__GUID-825B0A0C-1E5C-414E-A112-B1AA14B374A3">
                        <p class="titleinexample">示例5-16将SDO_GEOR_RA.rasterMathOp与条件运算符一起使用</p>
                        <p>此示例实现以下伪代码中描述的逻辑以实现3波段栅格数据分段：</p><pre class="pre codeblock"><code>如果（（layer1 &lt;100）＆（layer2 &lt;1000）＆（layer3 &lt;500））则输出= 10 elsif（（layer1 &lt;200）＆（layer2 &lt;2000）＆（layer3 &lt;1000））则输出= 20 elsif（ （layer1 &lt;300）＆（layer2 &lt;3000）＆（layer3 &lt;1500））然后输出= 30 elsif（（layer1 &lt;400）＆（layer2 &lt;4000）＆（layer3 &lt;2000））然后输出= 40 elsif（（layer1 &lt;500）＆（layer2 &lt;5000）＆（layer3 &lt;2500））然后输出= 50 else output = 0</code></pre><p>该示例调用<a href="sdo-geor-ra-ref.html#GUID-BB7A762E-E615-43AD-9D74-5E917D29F333">SDO_GEOR_RA.rasterMathOp</a>过程，如下所示</p><pre class="pre codeblock"><code>DECLARE geor SDO_GEORASTER; geor1 SDO_GEORASTER; mycursor sys_refcursor; expr varchar2（1024）; BEGIN从Georaster_table中选择georaster到geor，其中georid = 100;从georaster_table中选择georaster到geor1，其中georid = 101进行更新; - 构造逻辑表达式expr：='condition（（{0} &lt;100）＆（{1} &lt;1000）＆（{2} &lt;500）），'|| '10，'||'condition（（ （{0} &lt;200）＆（{1} &lt;2000）＆（{2} &lt;1000）），'|| '20，'||'条件（（{0} &lt;300）＆（{1} &lt;3000）＆（{2} &lt;1500）），'|| '30，'||'条件（（{{0} &lt;400）＆（{1} &lt;4000）＆（{2} &lt;2000）） ，'|| '40，'||'条件（（{{0} &lt;500）＆（{1} &lt;5000）＆（{2} &lt;2500）），'|| '50，'||'0 ）'||'）'||'）'||'）'||'）'; sdo_geor_ra.rasterMathOp（geor，sdo_string2_array（expr），null，geor1，'true'，0，'parallel = 4'）;更新georaster_table set georaster = geor1 where georid = 101;承诺;结束; /</code></pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-4CA82053-00A1-44BF-B675-969796BA8735__GUID-F583AD13-36E6-4804-9D9E-0640119C70EC">
                        <p class="titleinexample">示例5-17将SDO_GEOR_RA.rasterMathOp与条件运算符一起使用</p>
                        <p>此示例使用统计函数和算术运算来实现以下伪代码中描述的简单逻辑：</p><pre class="pre codeblock"><code>if（sum（）&gt; min（）* 3）then output = sqrt（layer0 + layer2）else output = layer1 * 1.5</code></pre><p>该示例调用<a href="sdo-geor-ra-ref.html#GUID-BB7A762E-E615-43AD-9D74-5E917D29F333">SDO_GEOR_RA.rasterMathOp</a>过程，如下所示</p><pre class="pre codeblock"><code>DECLARE geor SDO_GEORASTER; geor1 SDO_GEORASTER; mycursor sys_refcursor; expr varchar2（1024）; BEGIN从Georaster_table中选择georaster到geor，其中georid = 100;从georaster_table中选择georaster到geor1，其中georid = 101进行更新; --construct逻辑表达式expr：='condition（sum（）&gt; min（）* 3，sqrt（{0} + {2}），{1} * 1.5）'; sdo_geor_ra.rasterMathOp（geor，sdo_string2_array（expr），null，geor1，'true'，0，'parallel = 4'）;更新georaster_table set georaster = geor1 where georid = 101;承诺;结束; /</code></pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="raster-algebra-and-analytics.html#GUID-022F5214-9D1E-44B4-8487-967C93CC2954" title="栅格代数的一个主要用途是将逻辑模型应用于来自不同来源的栅格图层;也就是说，您可以在一个或多个GeoRaster对象的一个或多个图层上应用逻辑运算，以生成新的GeoRaster对象。">逻辑操作</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="props_rev_3"><a id="GUID-DDCEB15D-3C90-4317-B8B5-A633AD248519" name="GUID-DDCEB15D-3C90-4317-B8B5-A633AD248519"></a><h4 id="GEORS-GUID-DDCEB15D-3C90-4317-B8B5-A633AD248519" class="sect4"><span class="enumeration_section">5.7.2</span>仅使用栅格代数函数</h4>
                  <div>
                     <p>要仅使用栅格代数函数执行逻辑运算，您有以下选项</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>使用<a href="sdo-geor-ra-ref.html#GUID-B879FE32-88C6-4C85-95B8-47B7EDEE8C02">SDO_GEOR_RA.diff</a>过程。
                           </p>
                           <p>例如，如果栅格A中的单元格值与栅格B中的单元格值不同，则返回栅格A中的单元格值。如果单元格值相同，则返回值0（零）。</p>
                        </li>
                        <li>
                           <p>使用<a href="sdo-geor-ra-ref.html#GUID-D6105A06-3CC0-42C9-AC57-81333017C3A4">SDO_GEOR_RA.over</a>过程。
                           </p>
                           <p>例如，如果栅格A中的单元格值不等于0（零），则返回栅格A中的单元格值。如果栅格A中的单元格值等于0，则返回栅格B中的单元格值。</p>
                        </li>
                     </ul>
                     <div class="example" id="GUID-DDCEB15D-3C90-4317-B8B5-A633AD248519__GUID-825B0A0C-1E5C-414E-A112-B1AA14B374A3">
                        <p class="titleinexample">例5-18使用SDO_GEOR_RA.diff</p>
                        <p>此示例调用<a href="sdo-geor-ra-ref.html#GUID-B879FE32-88C6-4C85-95B8-47B7EDEE8C02">SDO_GEOR_RA.diff</a>过程以从两个3层源GeoRaster对象生成新的GeoRaster对象。
                        </p><pre class="pre codeblock"><code>DECLARE geor SDO_GEORASTER; geor1 SDO_GEORASTER; geor2 SDO_GEORASTER; geom sdo_geometry; BEGIN从Georaster_table中选择georaster到geor，其中georid = 100;从Georaster_table中选择georaster到geor1，其中georid = 101;从georaster_table中选择georaster到geor2，其中georid = 102进行更新;的geom：= NULL; sdo_geor_ra.diff（geor，geor1，GEOM，NULL，geor2）;更新georaster_table set georaster = geor2 where georid = 102;结束; / PL / SQL过程成功完成。SELECT sdo_geor.getcellvalue（georaster，0,100,100，''）FROM georaster_table WHERE georid = 100; SDO_GEOR.GETCELLVALUE（GEORASTER，0,100,100，''）--------------------------------------- ----------------------------------------- SDO_NUMBER_ARRAY（181,163,159）1行选中。SELECT sdo_geor.getcellvalue（georaster，0,100,100，''）FROM georaster_table WHERE georid = 101; SDO_GEOR.GETCELLVALUE（GEORASTER，0,100,100，''）--------------------------------------- ----------------------------------------- SDO_NUMBER_ARRAY（181,122,159）1行选中。- 在下一个SELECT语句的结果中，注意： -  181 = 181 ==&gt; 0  -  163！= 122 ==&gt; 163  -  159 = 159 ==&gt; 0 SELECT sdo_geor.getcellvalue（georaster，0,100,100，''）FROM georaster_table WHERE georid = 102; SDO_GEOR.GETCELLVALUE（GEORASTER，0,100,100，''）--------------------------------------- ----------------------------------------- SDO_NUMBER_ARRAY（0,163,0）1行选中。
</code></pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-DDCEB15D-3C90-4317-B8B5-A633AD248519__GUID-2F65268D-B52A-4D58-88B3-08CEF286AC63">
                        <p class="titleinexample">示例5-19使用SDO_GEOR_RA.over</p>
                        <p>此示例调用<a href="sdo-geor-ra-ref.html#GUID-D6105A06-3CC0-42C9-AC57-81333017C3A4">SDO_GEOR_RA.over</a>过程以从两个3层源GeoRaster对象生成新的GeoRaster对象。
                        </p><pre class="pre codeblock"><code>DECLARE geor SDO_GEORASTER; geor1 SDO_GEORASTER; geor2 SDO_GEORASTER; geom sdo_geometry; BEGIN从georaster_table中选择georaster到geor，其中georid = 102;从Georaster_table中选择georaster到geor1，其中georid = 101;从georaster_table中选择georaster到geor2，其中georid = 100表示更新;的geom：= NULL; sdo_geor_ra.over（geor，geor1，GEOM，NULL，geor2）;更新georaster_table set georaster = geor2 where georid = 100;结束; / PL / SQL过程成功完成。SELECT sdo_geor.getcellvalue（georaster，0,100,100，''）FROM georaster_table WHERE georid = 102; SDO_GEOR.GETCELLVALUE（GEORASTER，0,100,100，''）--------------------------------------- ----------------------------------------- SDO_NUMBER_ARRAY（0,163,0）1行选中。SELECT sdo_geor.getcellvalue（georaster，0,100,100，''）FROM georaster_table WHERE georid = 101; SDO_GEOR.GETCELLVALUE（GEORASTER，0,100,100，''）--------------------------------------- ----------------------------------------- SDO_NUMBER_ARRAY（181,122,159）1行选中。- 在下一个SELECT语句的结果中，注意： -  0 = 0 ==&gt; 181 georid = 101  -  163的结果！= 0 ==&gt; 163 georid = 102  -  0 = 0 ==&gt; 159结果来自georid = 101 SELECT sdo_geor.getcellvalue（georaster，0,100,100，''）FROM georaster_table WHERE georid = 100; SDO_GEOR.GETCELLVALUE（GEORASTER，0,100,100，''）--------------------------------------- ----------------------------------------- SDO_NUMBER_ARRAY（181,163,159）1行选中。
</code></pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="raster-algebra-and-analytics.html#GUID-022F5214-9D1E-44B4-8487-967C93CC2954" title="栅格代数的一个主要用途是将逻辑模型应用于来自不同来源的栅格图层;也就是说，您可以在一个或多个GeoRaster对象的一个或多个图层上应用逻辑运算，以生成新的GeoRaster对象。">逻辑操作</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div><a id="GEORS1267"></a><a id="GEORS1268"></a><a id="GEORS1269"></a><a id="GEORS1266"></a><div class="props_rev_3"><a id="GUID-34B59129-70AC-4E51-BF6D-2E43AA2A813B" name="GUID-34B59129-70AC-4E51-BF6D-2E43AA2A813B"></a><h3 id="GEORS-GUID-34B59129-70AC-4E51-BF6D-2E43AA2A813B" class="sect3"><span class="enumeration_section">5.8</span>栅格数据缩放和偏移</h3>
               <div>
                  <p>您可以执行栅格数据缩放和偏移操作。</p>
                  <p>栅格代数有许多应用，例如制图建模（参见<a href="raster-algebra-and-analytics.html#GUID-F2EBC84A-8BB8-484B-9F32-FC88D4E5F166" title="栅格代数广泛用于制图建模，被认为是GIS系统的重要组成部分。使用PL / SQL和栅格代数表达式和函数，您可以对大量栅格和几乎无限大小的图像进行制图建模。">制图建模</a> ），植被指数计算（参见<a href="image-processing-virtual-mosaic.html#GUID-C2D99D00-071F-4BBC-A0A5-50C6F0FAF355" title="在遥感中，归一化植被指数（NDVI）是一种广泛使用的植被指数，使用户能够快速识别植被区域并监测植物的生长和“状况”。">植被指数计算</a> ）和穗帽变换（参见<a href="image-processing-virtual-mosaic.html#GUID-2530F5D2-7386-4DD4-877A-F004F2109912" title="Tasseled Cap Transformation（TCT）是一种使用遥感图像分析物理地面特征的有用工具。">Tasseled Cap Transformation</a> ）。本章以及<a href="image-processing-virtual-mosaic.html#GUID-EB60166B-6A52-4974-AF16-139CD6480EBC" title="本章介绍了高级图像处理功能，包括GCP地理配准，重投影，校正，正射校正，变形，图像缩放，拉伸，滤波，遮蔽，分割，NDVI计算，Tasseled Cap变换，图像追加，波段合并以及大规模高级图像镶嵌。">图像处理和虚拟马赛克中的主题</a>描述了GeoRaster栅格代数的一些示例应用程序。
                  </p>
                  <div class="example" id="GUID-34B59129-70AC-4E51-BF6D-2E43AA2A813B__BABFGGJJ">
                     <p class="titleinexample">示例5-20将DEM数据从英尺转换为米</p>
                     <p>GeoRaster对象的单元格值可以表示空间对象的定量属性，该属性可以在特定单元中。例如，DEM GeoRaster对象中的高程数据可以以英尺为单位。应用程序可能要求您将高程转换为另一个单位，例如仪表，以进行地理定位和其他操作。您可以使用栅格代数将DEM数据从英尺缩放到米（即单位转换），如<a href="raster-algebra-and-analytics.html#GUID-34B59129-70AC-4E51-BF6D-2E43AA2A813B__BABFGGJJ">例5-20</a>所示。
                     </p><pre class="oac_no_warn" dir="ltr">DECLARE geor1 SDO_GEORASTER; geor2 SDO_GEORASTER; BEGIN  - 具有单个DEM图层的源GeoRaster对象从georaster_table中选择georater到geor1，其中georid = 1; - 将输出DEM图层选择georaster从georaster_table存储到geor2中，其中georid = 2用于更新; - 使用单位因子sdo_geor_ra.rasterMathOp（geor1，SDO_STRING2_ARRAY（'{0} * 0.3048'），null，geor2）从英尺到米的刻度升高; - 对输出georaster对象进行更改georaster_table set georaster = geor2 georid = 2;承诺;结束; /</pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-34B59129-70AC-4E51-BF6D-2E43AA2A813B__BABJHCFE">
                     <p class="titleinexample">例5-21按大地水准面高度偏移DEM</p>
                     <p>GeoRaster对象的单元数据可能需要通过常量进行偏移以进行进一步处理。例如，DEM层可以表示正高度而不是椭球高度。为了对由RPC模型进行地理配准的原始图像进行正射校正，需要椭球升高。<a href="raster-algebra-and-analytics.html#GUID-34B59129-70AC-4E51-BF6D-2E43AA2A813B__BABJHCFE">例5-21</a>通过大地水准面高度偏移正交DEM，得到椭圆形DEM。</p><pre class="oac_no_warn" dir="ltr">DECLARE geor1 SDO_GEORASTER; geor2 SDO_GEORASTER; BEGIN  - 具有单个正交DEM层的源GeoRaster对象从georaster_table中选择georter到geor1，其中georid = 1; - 将输出DEM图层选择georaster从georaster_table存储到geor2中，其中georid = 2用于更新; - 通过大地水准面高度偏移得到椭圆形高程sdo_geor_ra.rasterMathOp（geor1，SDO_STRING2_ARRAY（'{0}  -  28.8'），null，geor2）; - 对输出进行更改GeoRaster对象更新georaster_table set georaster = geor2 where georid = 2;承诺;结束; /</pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-34B59129-70AC-4E51-BF6D-2E43AA2A813B__BABIFHIJ">
                     <p class="titleinexample">例5-22转换（缩放）和偏移</p>
                     <p>您可以将<a href="raster-algebra-and-analytics.html#GUID-34B59129-70AC-4E51-BF6D-2E43AA2A813B__BABFGGJJ">示例5-20</a>和<a href="raster-algebra-and-analytics.html#GUID-34B59129-70AC-4E51-BF6D-2E43AA2A813B__BABJHCFE">示例5-21</a>的操作组合成一个简单的步骤，如<a href="raster-algebra-and-analytics.html#GUID-34B59129-70AC-4E51-BF6D-2E43AA2A813B__BABIFHIJ">例5-22</a>所示。
                     </p><pre class="oac_no_warn" dir="ltr">DECLARE geor1 SDO_GEORASTER; geor2 SDO_GEORASTER; BEGIN  - 具有单个DEM图层的源GeoRaster对象从georaster_table中选择georater到geor1，其中georid = 1; - 将输出DEM图层选择georaster从georaster_table存储到geor2中，其中georid = 2用于更新; - 通过大地水准面高度sdo_geor_ra.rasterMathOp（geor1，SDO_STRING2_ARRAY（'{0} * 0.3048  -  28.8'），null，geor2），从英尺到米的高程和海拔高度 - 对输出georaster对象进行更改georaster_table set georaster = geor2 georid = 2;承诺;结束; /</pre></div>
                  <!-- class="example" -->
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="raster-algebra-and-analytics.html#GUID-C75744C9-FA04-4391-96F2-59EF2EA212FF" title="本章介绍了栅格代数语言（PL / SQL和代数表达式）和相关的栅格操作，包括条件查询，基于单元格的更新或编辑，数学运算，分类，动态统计分析，逻辑运算及其制图建模中的应用。">栅格代数和分析</a></p>
                     </div>
                  </div>
               </div>
               
            </div><a id="GEORS1271"></a><a id="GEORS1270"></a><div class="props_rev_3"><a id="GUID-13B8293B-2AE1-4687-B98A-9463EF42AC27" name="GUID-13B8293B-2AE1-4687-B98A-9463EF42AC27"></a><h3 id="GEORS-GUID-13B8293B-2AE1-4687-B98A-9463EF42AC27" class="sect3"><span class="enumeration_section">5.9</span>栅格数据转换</h3>
               <div>
                  <p>栅格数据转换将单元格值从一种数据类型映射到另一种数据类型</p>
                  <p>在GeoRaster中，有两种类型的转换操作：一种在操作的<code class="codeph">storageParam</code>参数中使用<code class="codeph">cellDepth</code>关键字，另<code class="codeph">castingExpr</code>在GeoRaster栅格代数中使用<code class="codeph">castingExpr</code>操作。 （ <code class="codeph">castingExpr</code>是<code class="codeph">arithmeticExpr</code>操作之一，如<a href="raster-algebra-and-analytics.html#GUID-A6F087DC-1E7E-4426-B778-8554A25B3494" title="栅格代数通常用于栅格数据分析和GIS建模。在GeoRaster中，GeoRaster栅格代数语言支持栅格代数。">Raster Algebra Language中所述</a> 。）
                  </p>
                  <p>无论何时应用将栅格数据结果存储到新GeoRaster对象的操作，都可以在该操作的<code class="codeph">storageParam</code>参数中使用<code class="codeph">cellDepth</code>关键字。（ <code class="codeph">cellDepth</code>关键字及其值在<a href="georaster-overview-and-concepts.html#GUID-4B5901B5-879D-4E5F-BE73-2242F3D7CF9D__CHDHJCBF" title="此2列表列出了栅格数据的storageParam关键字。第1列是关键字。第2列解释了关键字。">表1-1</a>中描述。）如果指定了<code class="codeph">cellDepth</code> ，则将使用该<code class="codeph">cellDepth</code>值创建目标GeoRaster对象，并且栅格单元数据将自动转换为该<code class="codeph">cellDepth</code>值以进行存储。如果源数据的单元格深度较低且结果数据的单元格深度较高，则可以直接在<code class="codeph">storageParam</code>参数中使用<code class="codeph">cellDepth</code>进行转换。在这种情况下，铸件是透明且快速的。
                  </p>
                  <p>但是，如果为较高单元格深度的数据指定<span class="italic">较低的</span>单元格深度，则使用<code class="codeph">storageParam</code>参数中的<code class="codeph">cellDepth</code>关键字更改单元格深度可能会导致数据丢失或更改，从而降低精度或质量。为了更好地控制精度和准确度，您可以使用Raster Algebra铸造运算符<code class="codeph">castingExpr</code> 。
                  </p>
                  <p>例如，假设您的栅格的单元格深度为<code class="codeph">32BIT_REAL</code> ，值范围为[ <code class="codeph">32BIT_REAL</code> ）。您可以使用<a href="raster-algebra-and-analytics.html#GUID-13B8293B-2AE1-4687-B98A-9463EF42AC27__BABGCGIG">示例5-23</a>将栅格线性分割为10个不同的类，每个类使用<code class="codeph">castint</code>运算符，其单元格值为10（ <code class="codeph">castint</code> ，...，90）的<code class="codeph">castint</code> 。此操作将所有单元格值转换为最接近10的较低倍数;例如，从60到69的所有数字都被强制转换为60。
                  </p>
                  <div class="example" id="GUID-13B8293B-2AE1-4687-B98A-9463EF42AC27__BABGCGIG">
                     <p class="titleinexample">例5-23光栅的线性分段</p><pre class="oac_no_warn" dir="ltr">DECLARE geor1 SDO_GEORASTER; geor2 SDO_GEORASTER; BEGIN  - 具有单元格值范围[0.0,100.0]的源georaster对象从Georaster_table中选择georaster到geor1，其中georid = 1; - 目标georaster对象存储输出层georaster从georaster_table到geor2，georid = 2用于更新; - 将源栅格直线分割为10个类并存储在8BIT单元格深度sdo_geor_ra.rasterMathOp（geor1，SDO_STRING2_ARRAY（'（ <span class="bold">castint（{0} / 10）* 10</span> '），' <span class="bold">celldepth = 8BIT</span> '，geor2）;  -提交更改输出georaster对象更新georaster_table set georaster = geor2 where georid = 2; commit; END; /</pre><p>如<a href="raster-algebra-and-analytics.html#GUID-13B8293B-2AE1-4687-B98A-9463EF42AC27__BABGCGIG">例5-23</a>所示，您可以将<code class="codeph">storageParam</code>参数中<code class="codeph">cellDepth</code>关键字的使用与栅格代数转换运算符组合使用，以便可以正确计算结果并以适当且简洁的方式存储。在<a href="raster-algebra-and-analytics.html#GUID-13B8293B-2AE1-4687-B98A-9463EF42AC27__BABGCGIG">例5-23中</a> ，输出单元格值是等于或小于90的整数，因此可以使用<code class="codeph">8BIT</code>单元格深度（而不是<code class="codeph">32BIT_REAL</code> ）存储生成的栅格，这样可以节省存储空间。
                     </p>
                  </div>
                  <!-- class="example" -->
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="raster-algebra-and-analytics.html#GUID-C75744C9-FA04-4391-96F2-59EF2EA212FF" title="本章介绍了栅格代数语言（PL / SQL和代数表达式）和相关的栅格操作，包括条件查询，基于单元格的更新或编辑，数学运算，分类，动态统计分析，逻辑运算及其制图建模中的应用。">栅格代数和分析</a></p>
                     </div>
                  </div>
               </div>
               
            </div><a id="GEORS1273"></a><a id="GEORS1272"></a><div class="props_rev_3"><a id="GUID-F2EBC84A-8BB8-484B-9F32-FC88D4E5F166" name="GUID-F2EBC84A-8BB8-484B-9F32-FC88D4E5F166"></a><h3 id="GEORS-GUID-F2EBC84A-8BB8-484B-9F32-FC88D4E5F166" class="sect3"><span class="enumeration_section">5.10</span>制图建模</h3>
               <div>
                  <p>栅格代数广泛用于制图建模，被认为是GIS系统的重要组成部分。使用PL / SQL和栅格代数表达式和函数，您可以对大量栅格和几乎无限大小的图像进行制图建模。</p>
                  <p>例如，野火评估的制图建模过程可以从一系列栅格图层中检索高程，坡度，坡向，温度，湿度和其他信息，然后逐个评估单元格以创建生成的栅格地图，可进一步分类以创建专题地图。使用栅格层覆盖技术的变化分析，选址，适用性分析，气候建模和油田评估是其他典型的制图建模过程。在这些情况下，可能需要组合算术运算，关系运算和逻辑运算。</p>
                  <p>假设假设的制图模型涉及七个不同的栅格图层，并具有如下表达式。并且建模结果是一个栅格地图，其中0和1作为单元格值：</p><pre class="oac_no_warn" dir="ltr">output = 1 if（（100 &lt;layer1 &lt;= 500）＆（layer2 == 3或layer2 == 10）＆（（layer3 + layer4）* log（Layer5）/ sqrt（layer5））&gt; = layer6）|| （第7层！= 1））否则为TRUE，否则为0</pre><p><a href="raster-algebra-and-analytics.html#GUID-F2EBC84A-8BB8-484B-9F32-FC88D4E5F166__BABGEBDG">例5-24</a>显示了如何在GeoRaster中运行前面的制图模型并将结果存储为位图。
                  </p>
                  <div class="example" id="GUID-F2EBC84A-8BB8-484B-9F32-FC88D4E5F166__BABGEBDG">
                     <p class="titleinexample">例5-24制图建模</p><pre class="oac_no_warn" dir="ltr">DECLARE geor SDO_GEORASTER; geor1 SDO_GEORASTER; mycursor sys_refcursor; expr varchar2（1024）; BEGIN --7个源GeoRaster对象，每个对象包含一个源序列，大小为1到7 OPEN mycursor FOR georaster from georaster_table，georid&gt; 0，georid &lt;= 7 order by georid; - 输出GeoRaster对象以将结果插入到georaster_table（georid，georaster）值（8，sdo_geor.init（'RDT_1'，8））中，将georaster返回到geor1; - 使用arithmeticExpr，booleanExpr和rasterMathOp建模expr：='condition（（（100 &lt;{0,0}）＆（{0,0} &lt;= 500））＆（（{1,0} = 3）| （{1,0} = 10））＆（（（（{2,0} + {3,0}）* log（{4,0}）/ sqrt（{4,0}））&gt; = {5 ，0}）|（{6,0}！= 1）），1,0）'; sdo_geor_ra.rasterMathOp（mycursor，sdo_string2_array（expr），'celldepth = 1BIT'，geor1，'true'，0，'parallel = 4'）;更新georaster_table set georaster = geor1 where georid = 8;承诺;结束; /</pre><p><a href="raster-algebra-and-analytics.html#GUID-F2EBC84A-8BB8-484B-9F32-FC88D4E5F166__BABGEBDG">例5-24中</a>的过程考虑了NODATA，并将0（零）分配给一个或多个源层中的NODATA单元的任何单元。它还并行化为四个进程，以利用数据库服务器的多个CPU来提高性能。
                     </p>
                  </div>
                  <!-- class="example" -->
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="raster-algebra-and-analytics.html#GUID-C75744C9-FA04-4391-96F2-59EF2EA212FF" title="本章介绍了栅格代数语言（PL / SQL和代数表达式）和相关的栅格操作，包括条件查询，基于单元格的更新或编辑，数学运算，分类，动态统计分析，逻辑运算及其制图建模中的应用。">栅格代数和分析</a></p>
                     </div>
                  </div>
               </div>
               
            </div>
            <div class="props_rev_3"><a id="GUID-90AF506E-C29A-464F-95F8-2923E79AFE9B" name="GUID-90AF506E-C29A-464F-95F8-2923E79AFE9B"></a><h3 id="GEORS-GUID-90AF506E-C29A-464F-95F8-2923E79AFE9B" class="sect3"><span class="enumeration_section">5.11</span>地形建模与分析</h3>
               <div>
                  <p>您可以使用输入GeoRaster对象中的数据来执行地形建模和分析。</p>
                  <p><a href="SDO_GEOR_GDAL-reference.html#GUID-1129639F-CFCD-40EB-ADE0-400EC9B4A459">SDO_GEOR_GDAL.dem</a>过程使用输入GeoRaster对象中的数据根据指定的<code class="codeph">processing</code>参数生成输出。输入的GeoRaster对象通常是数字高程模型， <code class="codeph">processing</code>值可以是诸如<code class="codeph">hillshade</code> ， <code class="codeph">slope</code> ， <code class="codeph">aspect</code> ， <code class="codeph">color-relief</code>或<code class="codeph">roughness</code> 。
                  </p>
                  <div class="example" id="GUID-90AF506E-C29A-464F-95F8-2923E79AFE9B__GUID-5D8A86BF-1F62-466C-A93A-236F46B32556">
                     <p class="titleinexample">例5-25山体阴影</p>
                     <p>如果<code class="codeph">processing</code>参数值是<code class="codeph">hillshade</code>则程序生成灰度图像，该图像表示相邻区域上方的高架区域的阴影，模仿太阳光的视觉效果。
                     </p>
                     <p>此示例创建山体阴影图像。</p><pre class="pre codeblock"><code>DECLARE gr1 sdo_georaster; gr2 sdo_georaster; BEGIN从图像中选择栅格到gr1，其中id = 1;从id = 2的图像中删除;插入图像值（2，sdo_geor.init（'imagery_rdt'，2））将栅格返回到gr2; sdo_geor_gdal.dem（gr1，gr2，'hillshade'）;更新图像集raster = gr2其中id = 2;承诺;结束; /</code></pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-90AF506E-C29A-464F-95F8-2923E79AFE9B__GUID-60221756-B417-4C62-80F2-70A1D4F81D2B">
                     <p class="titleinexample">例5-26斜率</p>
                     <p>该过程可以根据输入栅格的高程值生成坡度或坡向栅格。在这种情况下，输出像素值不会产生视觉吸引力输出，而是可用于土地使用和土地分配分析的有用栅格表面。例如，它可以用于根据坡度和暴露于太阳的角度（方面）定义适合葡萄酒生产的区域。</p>
                     <p>以下示例创建一个栅格，表示从栅格高程数据生成的斜率。生成的像素值将以百分比表示，而不是默认的度输出。</p><pre class="pre codeblock"><code>DECLARE gr1 sdo_georaster; gr3 sdo_georaster; BEGIN从图像中选择栅格到gr1，其中id = 1;从id = 3的图像中删除;插入图像值（3，sdo_geor.init（'imagery_rdt'，3））将栅格返回到gr3; sdo_geor_gdal.dem（gr1，gr3，'slope'，'slopevalue = percent'）;更新图像集raster = gr3其中id = 3;承诺;结束; /</code></pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-90AF506E-C29A-464F-95F8-2923E79AFE9B__GUID-551953E4-596F-425D-BC7D-3F54FA847919">
                     <p class="titleinexample">例5-27方面</p>
                     <p>此示例创建一个栅格，表示从栅格高程数据生成的方面o。表示平坦区域的像素将具有值0而不是默认值-9999。</p><pre class="pre codeblock"><code>DECLARE gr1 sdo_georaster; gr4 sdo_georaster; BEGIN从图像中选择栅格到gr1，其中id = 1;从id = 4的图像中删除;插入图像值（4，sdo_geor.init（'imagery_rdt'，4））将栅格返回到gr4; sdo_geor_gdal.dem（gr1，gr4，'aspect'，'zeroforflat = yes'）;更新图像集raster = gr4其中id = 4;承诺;结束; /</code></pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-90AF506E-C29A-464F-95F8-2923E79AFE9B__GUID-CAFD8DB2-7F40-4243-AFE1-226D6F38FAA9">
                     <p class="titleinexample">实施例5-28颜色浮雕</p>
                     <p>此示例使用文件colorfile.txt创建一个栅格，表示从栅格高程数据生成的颜色浮雕。对于此示例， <code class="codeph">colorfile.txt</code>文件包含以下“高程百分比红绿蓝”值</p><pre class="oac_no_warn" dir="ltr">0％180 0 255 10％70 0 255 20％0 70 255 30％0 180 255 40％0 255 180 50％0 255 70 60％70 255 0 70％180 255 0 80％255 180 0 90％255 70 0 nv 0 0 0</pre><pre class="pre codeblock"><code>DECLARE gr1 sdo_georaster; gr5 sdo_georaster; BEGIN从图像中选择栅格到gr1，其中id = 1;从id = 5的图像中删除;插入图像值（5，sdo_geor.init（'imagery_rdt'，5））将栅格返回到gr5; sdo_geor_gdal.dem（inGeoRaster =&gt; gr1，outGeoRaster =&gt; gr5，processing =&gt;'color-relief'，colorDirectory =&gt;'mydir'，colorFilename =&gt;'colorfile.txt'）;更新图像设置raster = gr5，其中id = 5;承诺;结束; /</code></pre><p>除了这些示例中显示的操作之外，您还可以使用该过程从DEM GeoRaster对象生成地形加粗索引（TRI）贴图，地形位置索引（TPI）贴图和粗糙度贴图。</p>
                  </div>
                  <!-- class="example" -->
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="raster-algebra-and-analytics.html#GUID-C75744C9-FA04-4391-96F2-59EF2EA212FF" title="本章介绍了栅格代数语言（PL / SQL和代数表达式）和相关的栅格操作，包括条件查询，基于单元格的更新或编辑，数学运算，分类，动态统计分析，逻辑运算及其制图建模中的应用。">栅格代数和分析</a></p>
                     </div>
                  </div>
               </div>
               
            </div>
         </div>
      </article>
   </body>
</html>