<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <meta name="abstract" content="This chapter explains how to enable IM column stores in an Oracle Real Application Clusters (Oracle RAC) environment, and configure objects for population."></meta>
      <meta name="description" content="This chapter explains how to enable IM column stores in an Oracle Real Application Clusters (Oracle RAC) environment, and configure objects for population."></meta>
      <title>在Oracle RAC中部署IM列存储</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Database In-Memory Guide"></meta>
      <meta property="og:description" content="This chapter explains how to enable IM column stores in an Oracle Real Application Clusters (Oracle RAC) environment, and configure objects for population."></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Database In-Memory Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="database-memory-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-04-22T09:02:38-07:00"></meta>
      <meta name="dcterms.title" content="Database In-Memory Guide"></meta>
      <meta name="dcterms.dateCopyrighted" content="2016, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96137-02"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="managing-im-faststart-for-im-column-store.html" title="Previous" type="text/html"></link>
      <link rel="next" href="deploying-im-column-store-with-adg.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.isVersionOf" content="INMEM"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="managing-im-faststart-for-im-column-store.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="deploying-im-column-store-with-adg.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">数据库内存指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="high-availability-and-the-im-column-store.html" property="item" typeof="WebPage"><span property="name">高可用性和IM列存储</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">在Oracle RAC中部署IM列存储</li>
            </ol>
            <a id="GUID-E897E3E9-1163-4FAE-9C74-B8B83B515E31" name="GUID-E897E3E9-1163-4FAE-9C74-B8B83B515E31"></a>
            
            <h2 id="INMEM-GUID-E897E3E9-1163-4FAE-9C74-B8B83B515E31" class="sect2"><span class="enumeration_chapter">12</span>在Oracle RAC中部署IM列存储</h2>
         </header>
         <div class="ind">
            <div>
               <p>本章介绍如何在Oracle Real Application Clusters（Oracle RAC）环境中启用IM列存储，以及如何为填充配置对象。</p>
               <p>本节包含以下主题：</p>
            </div>
            <div>
               <ul class="ullinks">
                  <li class="ulchildlink"><a href="deploying-in-memory-in-oracle-rac.html#GUID-63748559-8BC8-473C-BE6E-453DD38ED9A3">数据库内存和Oracle RAC概述</a><br>每个Oracle RAC节点都有自己的内存（IM）列存储。默认情况下，填充的对象分布在群集中的所有IM列存储中。
                  </li>
                  <li class="ulchildlink"><a href="deploying-in-memory-in-oracle-rac.html#GUID-C6DE0126-DCD7-4E6C-B673-F8FE1AECD23C">在Oracle RAC中配置内存服务</a><br><span class="bold">服务</span>代表一组实例。在Oracle RAC中，您可以使用服务将连接或应用程序定向到群集中的节点子集。
                  </li>
               </ul>
               <div class="familylinks">
                  <div class="parentlink">
                     <p><strong>父主题：</strong> <a href="high-availability-and-the-im-column-store.html#GUID-744E10A1-D345-4F73-82BD-6690CFF333D4" title="本部分介绍如何使用具有高可用性功能的IM列存储，例如内存中快速启动（IM FastStart），Oracle Data Guard和Oracle Real Application Clusters（Oracle RAC）。">高可用性和IM列存储</a></p>
                  </div>
               </div>
            </div>
            
            <div class="sect2"><a id="GUID-63748559-8BC8-473C-BE6E-453DD38ED9A3" name="GUID-63748559-8BC8-473C-BE6E-453DD38ED9A3"></a><h3 id="INMEM-GUID-63748559-8BC8-473C-BE6E-453DD38ED9A3" class="sect3"><span class="enumeration_section">12.1</span>数据库内存和Oracle RAC概述</h3>
               <div>
                  <p>每个Oracle RAC节点都有自己的内存（IM）列存储。默认情况下，填充的对象分布在群集中的所有IM列存储中。</p>
                  <p>Oracle建议您在每个Oracle RAC节点上均等地调整IM列存储的大小。如果Oracle RAC节点不需要IM列存储，则将<code class="codeph">INMEMORY_SIZE</code>参数设置为<code class="codeph">0</code> 。
                  </p>
                  <p>可以在每个节点上填充完全不同的对象，或者在集群中的所有IM列存储上分布更大的对象。在Oracle集成系统上，同一对象也可以出现在每个节点上的IM列存储中。跨集群中IM列存储的对象分布由<code class="codeph">INMEMORY</code>属性的两个子句控制： <code class="codeph">DISTRIBUTE</code>和<code class="codeph">DUPLICATE</code> 。</p>
                  <p>在Oracle RAC环境中，仅指定了<code class="codeph">INMEMORY</code>属性的对象将自动分布在群集中的IM列存储中。您可以使用<code class="codeph">DISTRIBUTE</code>子句指定对象在群集中的分布方式。默认情况下，使用的分区类型（如果有）确定对象的分布方式。如果对象未分区，则按rowid范围分发。或者，您可以指定<code class="codeph">DISTRIBUTE</code>子句以覆盖默认行为。
                  </p>
                  <p>在Oracle集成系统上，您可以跨群集中的IM列存储复制或镜像填充的对象。该技术提供最高级别的冗余。<code class="codeph">DUPLICATE</code>子句控制对象的复制方式。如果仅指定<code class="codeph">DUPLICATE</code> ，则数据的一个镜像副本将分布在群集中的IM列存储中。要复制每个IM列存储中的整个对象，请指定<code class="codeph">DUPLICATE ALL</code> 。</p>
                  <div class="infoboxnote" id="GUID-63748559-8BC8-473C-BE6E-453DD38ED9A3__GUID-066A39FB-3D36-4E0C-86EA-91CBF912EB51">
                     <p class="notep1">注意：</p>
                     <p>在非工程系统上部署Oracle RAC时， <code class="codeph">DUPLICATE</code>子句将被视为<code class="codeph">NO DUPLICATE</code> 。</p>
                  </div>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="deploying-in-memory-in-oracle-rac.html#GUID-8B5CA79B-AADD-482A-A04C-E7A954BD04BF">多个IM列存储</a><br>在Oracle RAC中，每个数据库实例都有自己的IM列存储。
                     </li>
                     <li class="ulchildlink"><a href="deploying-in-memory-in-oracle-rac.html#GUID-EC299917-17C4-4486-9371-A2DA7E1D5D02">Oracle RAC中列式数据的分发和复制</a><br>指定<code class="codeph">INMEMORY</code> ， <code class="codeph">DISTRIBUTE</code>和<code class="codeph">DUPLICATE</code>关键字控制对象的分布。
                     </li>
                     <li class="ulchildlink"><a href="deploying-in-memory-in-oracle-rac.html#GUID-86F5001A-9DFA-410B-9A01-BD7ACF1D8D07">Oracle RAC中的并行性</a><br>数据库实例必须访问它们所在的IM列存储中的IMCU。Oracle RAC中IM列存储的填充和访问必须并行发生，以便可以从任何实例访问所有IM列存储。
                     </li>
                     <li class="ulchildlink"><a href="deploying-in-memory-in-oracle-rac.html#GUID-5FCDE9BB-4285-4270-B1AE-FF9D3FF2400B">Oracle RAC中的FastStart区域</a><br>FastStart区域在所有Oracle RAC节点之间共享。此功能可实现群集中的最大共享和可重用性。
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="deploying-in-memory-in-oracle-rac.html#GUID-E897E3E9-1163-4FAE-9C74-B8B83B515E31" title="本章介绍如何在Oracle Real Application Clusters（Oracle RAC）环境中启用IM列存储，以及如何为填充配置对象。">在Oracle RAC中部署IM列存储</a></p>
                     </div>
                  </div>
               </div>
               
               <div class="sect3"><a id="GUID-8B5CA79B-AADD-482A-A04C-E7A954BD04BF" name="GUID-8B5CA79B-AADD-482A-A04C-E7A954BD04BF"></a><h4 id="INMEM-GUID-8B5CA79B-AADD-482A-A04C-E7A954BD04BF" class="sect4"><span class="enumeration_section">12.1.1</span>多个IM列存储</h4>
                  <div>
                     <p>在Oracle RAC中，每个数据库实例都有自己的IM列存储。</p>
                     <p>从概念上讲，Oracle RAC环境中的IM列存储使用无共享体系结构。在每个数据库实例上，您可以单独调整和管理IM列存储。数据库实例<span class="italic">不</span>使用Cache Fusion来回传输IMCU。
                     </p>
                     <div class="figure" id="GUID-8B5CA79B-AADD-482A-A04C-E7A954BD04BF__GUID-98D420AA-1B9A-428B-9F7D-354D97CEFEE9">
                        <p class="titleinfigure">图12-1 Oracle RAC数据库中的IM列存储</p>
                        <p>该图显示了一个双节点Oracle RAC集群。每个实例都有一个单独配置的IM列存储。</p><img src="img/inmem_3v_030.png" alt="下面是图12-1的描述" title="下面是图12-1的描述" longdesc="img_text/inmem_3v_030.html"><br><a href="img_text/inmem_3v_030.html">“图12-1 Oracle RAC数据库中的IM列存储”的说明</a></div>
                     <!-- class="figure" -->
                     <p>Oracle建议您将每个Oracle RAC节点上的IM列存储的大小设置为相等的值。例如，您可以为每个IM列存储分配100 GB的内存。对于不需要IM列存储的任何节点，请将此节点上的<code class="codeph">INMEMORY_SIZE</code>初始化参数设置为0。
                     </p>
                     <div class="figure" id="GUID-8B5CA79B-AADD-482A-A04C-E7A954BD04BF__GUID-022D5137-041A-4FC0-8DFB-D2643473CFC3">
                        <p class="titleinfigure">图12-2具有两个IM列存储的三节点Oracle RAC数据库</p>
                        <p>在此示例中，实例1和实例2都具有IM列存储。实例3不需要IM列存储，因此此节点上的<code class="codeph">INMEMORY_SIZE</code>初始化参数设置为0。
                        </p><img src="img/inmem_3v_026.png" alt="下面是图12-2的描述" title="下面是图12-2的描述" longdesc="img_text/inmem_3v_026.html"><br><a href="img_text/inmem_3v_026.html">“图12-2具有两个IM列存储的三节点Oracle RAC数据库”的说明</a></div>
                     <!-- class="figure" -->
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-8B5CA79B-AADD-482A-A04C-E7A954BD04BF__GUID-445173F7-1186-432C-B53B-D57A71584606">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><span class="q">“ <a href="enabling-the-im-column-store.html#GUID-6A220D69-66BA-4C50-8FAB-D5004C96B215" title="在可以将表或实例化视图填充到IM列存储中之前，必须为数据库启用IM列存储。">为数据库启用IM列存储</a> ”</span></p>
                           </li>
                           <li>
                              <p>有关<code class="codeph">INMEMORY_SIZE</code>初始化参数的详细信息，请<code class="codeph">INMEMORY_SIZE</code> <a href="../refrn/INMEMORY_SIZE.html#REFRN-GUID-B5BEB6BF-5308-485F-920D-CBB584DDDE8F" target="_blank"><span><cite>Oracle数据库参考</cite></span></a></p>
                           </li>
                           <li>
                              <p><a href="../racad/introduction-to-oracle-rac.html#RACAD-GUID-5A1B02A2-A327-42DD-A1AD-20610B2A9D92" target="_blank"><span><cite>“Oracle Real Application Clusters管理和部署指南”</cite></span></a> ，了解Oracle RAC简介</p>
                           </li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="deploying-in-memory-in-oracle-rac.html#GUID-63748559-8BC8-473C-BE6E-453DD38ED9A3" title="每个Oracle RAC节点都有自己的内存（IM）列存储。默认情况下，填充的对象分布在群集中的所有IM列存储中。">Database In-Memory和Oracle RAC概述</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="props_rev_3"><a id="GUID-EC299917-17C4-4486-9371-A2DA7E1D5D02" name="GUID-EC299917-17C4-4486-9371-A2DA7E1D5D02"></a><h4 id="INMEM-GUID-EC299917-17C4-4486-9371-A2DA7E1D5D02" class="sect4"><span class="enumeration_section">12.1.2</span> Oracle RAC中列式数据的分发和复制</h4>
                  <div>
                     <p>指定<code class="codeph">INMEMORY</code> ， <code class="codeph">DISTRIBUTE</code>和<code class="codeph">DUPLICATE</code>关键字控制对象的分布。
                     </p>
                     <p>Oracle RAC提供多种分发选项。您可以在每个节点上填充不同的对象，或者在Oracle RAC集群中的所有IM列存储中分布较大的对象。您还可以在每个节点上的IM列存储中填充相同的对象（仅限Oracle集成系统）。</p>
                     <div class="infoboxnote" id="GUID-EC299917-17C4-4486-9371-A2DA7E1D5D02__GUID-572C10BE-2246-41D7-A1E9-671CF4619746">
                        <p class="notep1">注意：</p>
                        <p><span>如果当前在IM列存储中填充了表，并且如果更改<span class="italic">除</span> <code class="codeph">PRIORITY</code> <span class="italic">之外</span>的表的任何<code class="codeph">INMEMORY</code>属性，则数据库将从IM列存储中逐出该表。重新填充行为取决于<code class="codeph">PRIORITY</code>设置。</span></p>
                     </div>
                     <p>本节包含以下主题：</p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="deploying-in-memory-in-oracle-rac.html#GUID-45BCCDEF-426A-4152-A0BB-218032B128B2">Oracle RAC中列式数据的分布</a><br><code class="codeph">INMEMORY</code>的<code class="codeph">DISTRIBUTE</code>子句控制IM列存储中的表数据如何跨Oracle RAC实例分布。
                        </li>
                        <li class="ulchildlink"><a href="deploying-in-memory-in-oracle-rac.html#GUID-AF767E49-B4FB-4CCB-A7BF-C62E871E59AA">Oracle RAC中的列式数据重复</a><br><code class="codeph">DUPLICATE</code>子句控制Oracle RAC数据库如何跨Oracle RAC实例复制列数据。
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="deploying-in-memory-in-oracle-rac.html#GUID-63748559-8BC8-473C-BE6E-453DD38ED9A3" title="每个Oracle RAC节点都有自己的内存（IM）列存储。默认情况下，填充的对象分布在群集中的所有IM列存储中。">Database In-Memory和Oracle RAC概述</a></p>
                        </div>
                     </div>
                  </div>
                  
                  <div class="sect4"><a id="GUID-45BCCDEF-426A-4152-A0BB-218032B128B2" name="GUID-45BCCDEF-426A-4152-A0BB-218032B128B2"></a><h5 id="INMEM-GUID-45BCCDEF-426A-4152-A0BB-218032B128B2" class="sect5"><span class="enumeration_section">12.1.2.1</span> Oracle RAC中列式数据的分布</h5>
                     <div>
                        <p><code class="codeph">INMEMORY</code>的<code class="codeph">DISTRIBUTE</code>子句控制IM列存储中的表数据如何跨Oracle RAC实例分布。
                        </p>
                        <p>设置默认选项<code class="codeph">AUTO</code> ，Oracle RAC实例会自动分发数据。在填充段时，空间管理从属进程（W <span class="italic">nnn</span> ）进程尝试在每个实例上放置相同数量的数据。分布取决于访问模式和对象大小。或者，您可以手动指定数据库必须如何跨实例分发分区，子分区或rowid范围。
                        </p>
                        <p>平等的数据分配对性能很重要。目标是并行查询过程在相同的数据集大小上工作，以便它们都在最短的时间内完成。如果数据分布有偏差，则长时间运行的进程会延迟查询的完成。</p>
                        <p>如果Oracle RAC实例失败，则失败实例上的IMCU将不可用。因此，需要存储在不可访问的IMCU中的数据的查询必须从其他位置读取它：数据库缓冲区高速缓存，闪存，磁盘或其他IM列存储中的镜像IMCU。</p>
                        <p><code class="codeph">DBA_TABLES.INMEMORY_DISTRIBUTE</code>列指示IMCU的分发方式。设置<code class="codeph">AUTO</code>选项后，列值为<code class="codeph">AUTO-DISTRIBUTE</code> 。</p>
                        <div class="example" id="GUID-45BCCDEF-426A-4152-A0BB-218032B128B2__GUID-6AE89458-6042-4DB6-899F-9D1DB5013C97">
                           <p class="titleinexample">例12-1默认分配</p>
                           <p>此示例显示数据库分发仅包含分区的<code class="codeph">sales</code>表： <code class="codeph">sales_2013_pt</code>和<code class="codeph">sales_2014_pt</code> 。数据库自动将<code class="codeph">sales_2013_pt</code>分区放在Instance 1中，将<code class="codeph">sales_2014_pt</code>放在Instance 2中。
                           </p>
                           <div class="figure" id="GUID-45BCCDEF-426A-4152-A0BB-218032B128B2__GUID-A0DBEB7E-5123-43C6-8524-3C7E660700DC">
                              <p class="titleinfigure">图12-3 Oracle RAC中的自动内存分发</p><img src="img/cncpt_vm_387.png" alt="下面是图12-3的描述" title="下面是图12-3的描述" longdesc="img_text/cncpt_vm_387.html"><br><a href="img_text/cncpt_vm_387.html">“图12-3 Oracle RAC中的自动内存中分发”的说明</a></div>
                           <!-- class="figure" -->
                           <p>本节包含以下主题：</p>
                        </div>
                        <!-- class="example" -->
                     </div>
                     <div>
                        <ul class="ullinks">
                           <li class="ulchildlink"><a href="deploying-in-memory-in-oracle-rac.html#GUID-53C9BA44-AD00-4BAC-8219-1A34D9DB8ED7">按分区分发</a><br>您可以使用<code class="codeph">DISTRIBUTE BY PARTITION</code>子句将分区中的数据分发到不同的Oracle RAC实例。
                           </li>
                           <li class="ulchildlink"><a href="deploying-in-memory-in-oracle-rac.html#GUID-32148BE2-9F5B-4989-8618-EC7FDFDA9213">按分区分配</a><br>在具有复合分区方案的表中，您可以使用<code class="codeph">DISTRIBUTE BY SUBPARTITION</code>子句将子分区中的数据分发到不同的实例。
                           </li>
                           <li class="ulchildlink"><a href="deploying-in-memory-in-oracle-rac.html#GUID-97960A3E-FB5D-4DD5-B77F-ED9FA6958099">按Rowid范围分布</a><br>您可以使用<code class="codeph">DISTRIBUTE BY ROWID RANGE</code>子句将特定范围的rowid中的数据分发到不同的Oracle RAC实例。
                           </li>
                        </ul>
                        <div class="infoboxnotealso" id="GUID-45BCCDEF-426A-4152-A0BB-218032B128B2__GUID-BC78427F-E4C3-45C8-B96F-2B4F4D40F157">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><span class="q">“ <a href="in-memory-column-store-architecture.html#GUID-C91A11F9-CFB7-4919-A8D7-8572ED1CAEF3" title="空间管理工作者流程（Wnnn）代表IMCO填充或重新填充数据。">空间管理工作者流程（Wnnn）</a> ”</span></p>
                              </li>
                              <li>
                                 <p><a href="../racad/introduction-to-oracle-rac.html#RACAD-GUID-5A1B02A2-A327-42DD-A1AD-20610B2A9D92" target="_blank"><span><cite>“Oracle Real Application Clusters管理和部署指南”</cite></span></a> ，了解如何在Oracle RAC上管理IM列存储</p>
                              </li>
                              <li>
                                 <p><a href="../sqlrf/CREATE-TABLE.html#SQLRF56768" target="_blank"><span><cite>Oracle数据库SQL语言参考，</cite></span></a>以了解有关<code class="codeph">DISTRIBUTE</code>子句的更多信息</p>
                              </li>
                              <li>
                                 <p><a href="../refrn/background-processes.html#REFRN104" target="_blank"><span><cite>Oracle Database Reference</cite></span></a>了解W <span class="italic">nnn</span>后台进程</p>
                              </li>
                           </ul>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="deploying-in-memory-in-oracle-rac.html#GUID-EC299917-17C4-4486-9371-A2DA7E1D5D02" title="指定INMEMORY时，DISTRIBUTE和DUPLICATE关键字控制对象的分布。">Oracle RAC中列式数据的分发和复制</a></p>
                           </div>
                        </div>
                     </div>
                     
                     <div class="sect5"><a id="GUID-53C9BA44-AD00-4BAC-8219-1A34D9DB8ED7" name="GUID-53C9BA44-AD00-4BAC-8219-1A34D9DB8ED7"></a><h6 id="INMEM-GUID-53C9BA44-AD00-4BAC-8219-1A34D9DB8ED7" class="sect6"><span class="enumeration_section">12.1.2.1.1</span>按分区分配</h6>
                        <div>
                           <p>您可以使用<code class="codeph">DISTRIBUTE BY PARTITION</code>子句将分区中的数据分发到不同的Oracle RAC实例。
                           </p>
                           <p>此技术非常适合散列分区。例如，要在<code class="codeph">orders</code>表中平均分配分区，可以在<code class="codeph">order_id</code>列上按哈希进行分区。如下图所示，Oracle数据库通过在<code class="codeph">order_id</code>列上进行散列来在四个实例之间分配分区。
                           </p>
                           <div class="figure" id="GUID-53C9BA44-AD00-4BAC-8219-1A34D9DB8ED7__GUID-CE35769F-2B18-4146-A697-45C9DCDF7682">
                              <p class="titleinfigure">图12-4按哈希分配分区</p><img src="img/inmem_3v_028.png" alt="下面是图12-4的描述" title="下面是图12-4的描述" longdesc="img_text/inmem_3v_028.html"><br><a href="img_text/inmem_3v_028.html">“图12-4按哈希分配分区”的描述</a></div>
                           <!-- class="figure" -->
                           <p>当统一访问分区时，此技术适用于其他分区方案。<code class="codeph">DISTRIBUTE BY PARTITION</code>子句还支持分区连接。
                           </p>
                           <div class="infoboxnote" id="GUID-53C9BA44-AD00-4BAC-8219-1A34D9DB8ED7__GUID-6D838C3B-5339-4F07-93A4-9C9BF4D83E31">
                              <p class="notep1">注意：</p>
                              <p>如果分区策略导致大数据偏差，即一个分区比其他分区大得多，那么Oracle建议您通过手动指定<code class="codeph">DISTRIBUTE BY ROWID RANGE</code>来覆盖默认分布（ <code class="codeph">BY PARTITION</code> ）。</p>
                           </div>
                        </div>
                        <div>
                           <div class="infoboxnotealso" id="GUID-53C9BA44-AD00-4BAC-8219-1A34D9DB8ED7__GUID-86F4882F-91A5-4A74-9D37-394C0C7C3954">
                              <p class="notep1">也可以看看：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p><a href="../sqlrf/CREATE-TABLE.html#SQLRF56768" target="_blank"><span><cite>Oracle数据库SQL语言参考，</cite></span></a>以了解有关<code class="codeph">DISTRIBUTE BY PARTITION</code>子条款的更多信息</p>
                                 </li>
                                 <li>
                                    <p><a href="../vldbg/partition-intro.html#VLDBG-GUID-D01AB935-0567-42C5-B21E-FB36BA9C7BAD" target="_blank"><span><cite>“Oracle数据库VLDB和分区指南”，</cite></span></a>用于介绍分区表</p>
                                 </li>
                              </ul>
                           </div>
                           <div class="familylinks">
                              <div class="parentlink">
                                 <p><strong>父主题：</strong> <a href="deploying-in-memory-in-oracle-rac.html#GUID-45BCCDEF-426A-4152-A0BB-218032B128B2" title="INMEMORY的DISTRIBUTE子句控制IM列存储中的表数据如何跨Oracle RAC实例分布。">Oracle RAC中的列式数据分布</a></p>
                              </div>
                           </div>
                        </div>
                        
                     </div>
                     <div class="sect5"><a id="GUID-32148BE2-9F5B-4989-8618-EC7FDFDA9213" name="GUID-32148BE2-9F5B-4989-8618-EC7FDFDA9213"></a><h6 id="INMEM-GUID-32148BE2-9F5B-4989-8618-EC7FDFDA9213" class="sect6"><span class="enumeration_section">12.1.2.1.2</span>按分区分配</h6>
                        <div>
                           <p>在具有复合分区方案的表中，您可以使用<code class="codeph">DISTRIBUTE BY SUBPARTITION</code>子句将子分区中的数据分发到不同的实例。
                           </p>
                           <p>这种技术非常适合哈希子分区。例如，要在<code class="codeph">orders</code>表中平均分配分区，可以在<code class="codeph">order_date</code>列上按范围分区，在<code class="codeph">order_id</code>列上按哈希分区。
                           </p>
                           <div class="figure" id="GUID-32148BE2-9F5B-4989-8618-EC7FDFDA9213__GUID-A3B9A0DE-27F7-498D-8901-BA270E1659B6">
                              <p class="titleinfigure">图12-5按范围和子分区按哈希分配分区</p><img src="img/inmem_3v_027.png" alt="下面是图12-5的描述" title="下面是图12-5的描述" longdesc="img_text/inmem_3v_027.html"><br><a href="img_text/inmem_3v_027.html">“图12-5按范围和子分区按哈希分配分区”的说明</a></div>
                           <!-- class="figure" -->
                           <p>当统一访问子分区时，此技术适用于其他分区方案。<code class="codeph">DISTRIBUTE BY PARTITION ...SUBPARTITION</code>子句还支持分区连接。
                           </p>
                        </div>
                        <div>
                           <div class="infoboxnotealso" id="GUID-32148BE2-9F5B-4989-8618-EC7FDFDA9213__GUID-0D9168F4-5D59-4AAD-9FC7-CFC5A15B1990">
                              <p class="notep1">也可以看看：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p><a href="../vldbg/partition-concepts.html#GUID-BE424ACC-F746-4CA8-973C-F578CF98FF10" target="_blank"><span><cite>Oracle Database VLDB和分区指南</cite></span></a> ，了解有关复合分区的更多信息</p>
                                 </li>
                                 <li>
                                    <p><a href="../sqlrf/CREATE-TABLE.html#SQLRF56768" target="_blank"><span><cite>Oracle数据库SQL语言参考，</cite></span></a>以了解有关<code class="codeph">DISTRIBUTE BY PARTITION ...更多信息<code class="codeph">DISTRIBUTE BY PARTITION ...SUBPARTITION</code>子条款</p>
                                 </li>
                              </ul>
                           </div>
                           <div class="familylinks">
                              <div class="parentlink">
                                 <p><strong>父主题：</strong> <a href="deploying-in-memory-in-oracle-rac.html#GUID-45BCCDEF-426A-4152-A0BB-218032B128B2" title="INMEMORY的DISTRIBUTE子句控制IM列存储中的表数据如何跨Oracle RAC实例分布。">Oracle RAC中的列式数据分布</a></p>
                              </div>
                           </div>
                        </div>
                        
                     </div>
                     <div class="sect5"><a id="GUID-97960A3E-FB5D-4DD5-B77F-ED9FA6958099" name="GUID-97960A3E-FB5D-4DD5-B77F-ED9FA6958099"></a><h6 id="INMEM-GUID-97960A3E-FB5D-4DD5-B77F-ED9FA6958099" class="sect6"><span class="enumeration_section">12.1.2.1.3</span>分布由ROWID范围</h6>
                        <div>
                           <p>您可以使用<code class="codeph">DISTRIBUTE BY ROWID RANGE</code>子句将特定范围的rowid中的数据分发到不同的Oracle RAC实例。
                           </p>
                           <p>此技术通过统一散列在第一个rowid上分发IMCU。例如，Oracle数据库可能会将<code class="codeph">orders</code>表中的1-105行分配给一个数据库实例，将行106-121分配给另一个实例，依此类推。
                           </p>
                           <div class="figure" id="GUID-97960A3E-FB5D-4DD5-B77F-ED9FA6958099__GUID-CC32C699-8413-46D4-B52E-7E81FEACD891">
                              <p class="titleinfigure">图12-6按Rowid范围分布</p><img src="img/inmem_3v_029.png" alt="下面是图12-6的描述" title="下面是图12-6的描述" longdesc="img_text/inmem_3v_029.html"><br><a href="img_text/inmem_3v_029.html">“图12-6按行数范围分布”的描述</a></div>
                           <!-- class="figure" -->
                           <p>rowid分发技术对于非分区表最有用。但是，如果分区策略导致较大的数据偏差（例如，一个分区比其他分区大得多），则Oracle建议通过手动指定<code class="codeph">DISTRIBUTE BY ROWID RANGE</code>来覆盖默认分布（ <code class="codeph">BY PARTITION</code> ）。</p>
                        </div>
                        <div>
                           <div class="infoboxnotealso" id="GUID-97960A3E-FB5D-4DD5-B77F-ED9FA6958099__GUID-00BAFEE8-738F-43BD-B60A-8393663A968B">
                              <p class="notep1">也可以看看：</p>
                              <p><a href="../sqlrf/CREATE-TABLE.html#SQLRF56768" target="_blank"><span><cite>Oracle Database SQL语言参考，</cite></span></a>以了解有关<code class="codeph">DISTRIBUTE BY ROWID RANGE</code>子条款的更多信息</p>
                           </div>
                           <div class="familylinks">
                              <div class="parentlink">
                                 <p><strong>父主题：</strong> <a href="deploying-in-memory-in-oracle-rac.html#GUID-45BCCDEF-426A-4152-A0BB-218032B128B2" title="INMEMORY的DISTRIBUTE子句控制IM列存储中的表数据如何跨Oracle RAC实例分布。">Oracle RAC中的列式数据分布</a></p>
                              </div>
                           </div>
                        </div>
                        
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-AF767E49-B4FB-4CCB-A7BF-C62E871E59AA" name="GUID-AF767E49-B4FB-4CCB-A7BF-C62E871E59AA"></a><h5 id="INMEM-GUID-AF767E49-B4FB-4CCB-A7BF-C62E871E59AA" class="sect5"><span class="enumeration_section">12.1.2.2</span> Oracle RAC中列式数据的复制</h5>
                     <div>
                        <p><code class="codeph">DUPLICATE</code>子句控制Oracle RAC数据库如何跨Oracle RAC实例复制列数据。
                        </p>
                        <div class="infoboxnote" id="GUID-AF767E49-B4FB-4CCB-A7BF-C62E871E59AA__GUID-D981E86D-1675-4CFA-8A9C-79275842D88F">
                           <p class="notep1">注意：</p>
                           <p><code class="codeph">DUPLICATE</code>子句仅适用于Oracle集成系统上的Oracle RAC。当Oracle RAC <span class="italic">不在</span> Oracle集成系统上运行时， <code class="codeph">DUPLICATE</code>子句在功能上等同于<code class="codeph">NO DUPLICATE</code> 。</p>
                        </div>
                        <p>要提供IM列存储容错，您可以选择镜像IMCU。通过<a href="glossary.html#GUID-38381C92-4A37-4475-87E1-25FA7CF037A1"><span class="xrefglossterm">IMCU镜像</span></a> ，相同的IMCU驻留在多个IM列存储中。该技术类似于存储镜像。
                        </p>
                        <div class="figure" id="GUID-AF767E49-B4FB-4CCB-A7BF-C62E871E59AA__GUID-045A9E4A-BC2F-4581-8FBE-183BCBA9DACB">
                           <p class="titleinfigure">图12-7 Oracle RAC中IMCU的复制</p><img src="img/inmem_3v_025.png" alt="下面是图12-7的描述" title="下面是图12-7的描述" longdesc="img_text/inmem_3v_025.html"><br><a href="img_text/inmem_3v_025.html">“图12-7 Oracle RAC中IMCU的复制”的说明</a></div>
                        <!-- class="figure" -->
                        <p>使用<code class="codeph">DUPLICATE</code>子句镜像表空间或对象（表，分区或子分区）级别的数据可提供以下好处：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>提供容错功能，因为如果一个节点发生故障，则可以从其他节点访问镜像列数据</p>
                           </li>
                           <li>
                              <p>提高性能，因为查询可以在本地访问数据，从而避免缓冲区缓存或磁盘访问</p>
                              <p>例如，在星型查询中，可以对事实表进行分区，而维度表使用<code class="codeph">DUPLICATE ALL</code> 。在此方案中，所有联接都完全在本地节点上进行。
                              </p>
                           </li>
                           <li>
                              <p>增强可管理性，因为您可以复制对象的子集</p>
                              <p>例如，您可以复制今年的分区，同时保留同一个表中的其他分区不重复。</p>
                           </li>
                        </ul>
                        <p>IMCU镜像的一个缺点是，当一个对象被复制<span class="italic">n</span>次，其内存需求由<span class="italic">n</span>倍增加。例如，在4个实例中重复的500 MB表占用总共2000 MB的内存。
                        </p>
                        <p>本节包含以下主题：</p>
                     </div>
                     <div>
                        <ul class="ullinks">
                           <li class="ulchildlink"><a href="deploying-in-memory-in-oracle-rac.html#GUID-B1A3E0D2-DE96-4DF5-B796-67FAB74B01AB">Oracle RAC中的DUPLICATE子句</a><br><code class="codeph">DUPLICATE</code>子句指定数据库在第二个数据库实例中维护每个IMCU的副本。因此，在两个Oracle RAC实例中填充相同的段。
                           </li>
                           <li class="ulchildlink"><a href="deploying-in-memory-in-oracle-rac.html#GUID-C979C5D2-944D-4422-8C92-430F92914975">Oracle RAC中的DUPLICATE ALL子句</a><br><code class="codeph">DUPLICATE ALL</code>子句指定在每个数据库实例上镜像每个In-Memory对象。
                           </li>
                           <li class="ulchildlink"><a href="deploying-in-memory-in-oracle-rac.html#GUID-CDB1862E-CCDE-44D3-833E-66CCAC45E1CA">Oracle RAC中没有DUPLICATE子句</a><br>缺省<code class="codeph">NO DUPLICATE</code>子句指定数据库仅维护对象的一个副本。
                           </li>
                        </ul>
                        <div class="infoboxnotealso" id="GUID-AF767E49-B4FB-4CCB-A7BF-C62E871E59AA__GUID-15F5C01A-6570-407F-A054-D012C3A8E1FC">
                           <p class="notep1">也可以看看：</p><a href="../sqlrf/CREATE-TABLE.html#SQLRF56953" target="_blank"><span><cite>Oracle数据库SQL语言参考，</cite></span></a>以了解有关<code class="codeph">DUPLICATE</code>子句的更多信息</div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="deploying-in-memory-in-oracle-rac.html#GUID-EC299917-17C4-4486-9371-A2DA7E1D5D02" title="指定INMEMORY时，DISTRIBUTE和DUPLICATE关键字控制对象的分布。">Oracle RAC中列式数据的分发和复制</a></p>
                           </div>
                        </div>
                     </div>
                     
                     <div class="sect5"><a id="GUID-B1A3E0D2-DE96-4DF5-B796-67FAB74B01AB" name="GUID-B1A3E0D2-DE96-4DF5-B796-67FAB74B01AB"></a><h6 id="INMEM-GUID-B1A3E0D2-DE96-4DF5-B796-67FAB74B01AB" class="sect6"><span class="enumeration_section">12.1.2.2.1</span> Oracle RAC中的DUPLICATE子句</h6>
                        <div>
                           <p><code class="codeph">DUPLICATE</code>子句指定数据库在第二个数据库实例中维护每个IMCU的副本。因此，在两个Oracle RAC实例中填充相同的段。
                           </p>
                           <p>对于每个对象，一个IMCU是主要的。辅助IMCU驻留在不同的数据库实例上。数据库可以使用任一副本来满足查询。如果具有IMCU主副本的数据库实例失败，则数据库可以使用幸存的IMCU来满足查询。</p>
                           <p>例如，您可以为分区<code class="codeph">sales_q1_2014</code>指定<code class="codeph">DUPLICATE</code> 。实例1和实例2中的IM列存储都具有相同的数据副本。如果实例1终止，则实例2上的IM列存储可以满足<code class="codeph">sales_q1_2014</code>请求。
                           </p>
                        </div>
                        <div>
                           <div class="infoboxnotealso" id="GUID-B1A3E0D2-DE96-4DF5-B796-67FAB74B01AB__GUID-BC78427F-E4C3-45C8-B96F-2B4F4D40F157">
                              <p class="notep1">也可以看看：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p><span class="q">“ <a href="in-memory-column-store-architecture.html#GUID-50A30EC3-1CD1-4BFC-9BD1-9AC55D0B4AAE" title="内存中压缩单元（IMCU）是一个压缩的只读存储单元，包含一列或多列的数据。">内存中压缩单元（IMCU）</a> ”</span></p>
                                 </li>
                                 <li>
                                    <p><a href="../sqlrf/CREATE-TABLE.html#SQLRF56953" target="_blank"><span class="italic">Oracle数据库SQL语言参考，</span></a>以了解有关<code class="codeph">DUPLICATE</code>子句的更多信息</p>
                                 </li>
                              </ul>
                           </div>
                           <div class="familylinks">
                              <div class="parentlink">
                                 <p><strong>父主题：</strong> <a href="deploying-in-memory-in-oracle-rac.html#GUID-AF767E49-B4FB-4CCB-A7BF-C62E871E59AA" title="DUPLICATE子句控制Oracle RAC数据库如何跨Oracle RAC实例复制列数据。">Oracle RAC中的列式数据的重复</a></p>
                              </div>
                           </div>
                        </div>
                        
                     </div>
                     <div class="sect5"><a id="GUID-C979C5D2-944D-4422-8C92-430F92914975" name="GUID-C979C5D2-944D-4422-8C92-430F92914975"></a><h6 id="INMEM-GUID-C979C5D2-944D-4422-8C92-430F92914975" class="sect6"><span class="enumeration_section">12.1.2.2.2</span>在Oracle RAC中重复所有子句</h6>
                        <div>
                           <p><code class="codeph">DUPLICATE ALL</code>子句指定在每个数据库实例上镜像每个In-Memory对象。
                           </p>
                           <p>此设置提供最高级别的冗余并提供线性可伸缩性，因为查询可以在单个节点内完全执行。例如， <code class="codeph">sales</code>表的每个IMCU都填充在实例1，实例2和实例3中的IM列存储中。因此，任何数据库实例都可以检索<code class="codeph">sales</code>查询所请求的数据。
                           </p>
                           <p><code class="codeph">DUPLICATE ALL</code>子句的结果是<code class="codeph">DISTRIBUTE</code>子条款没有应用程序，因为该对象的所有IMCU都是分布式的。您在对象级别指定复制，这意味着IM列存储中的所有对象都不需要<code class="codeph">DUPLICATE ALL</code>子句。
                           </p>
                           <p><code class="codeph">DUPLICATE ALL</code>技术的主要优点是：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>高可用性</p>
                                 <p>对所有内存中对象使用<code class="codeph">DUPLICATE ALL</code>子句时，具有<span class="italic">n个</span>实例的Oracle RAC数据库可以承受<span class="italic">n</span> -Oracle RAC实例故障。如果需要将一个数据库实例停止服务以进行维护，则至少有一个IM列存储中可以使用关键数据。所有数据都不可访问的唯一情况是群集中所有数据库实例都出现故障。
                                 </p>
                              </li>
                              <li>
                                 <p>明星查询的表现</p>
                                 <p>如果查询将较小的维度表连接到较大的分区事实表，则可以使用<code class="codeph">DUPLICATE ALL</code>在每个Oracle RAC实例中镜像维度表。事实表由分区或子分区分发。在此策略中，每个数据库实例中的IM列存储都具有星型连接所需的数据。此技术类似于分区连接，因为整个维度表都填充在每个IM列存储中。
                                 </p>
                              </li>
                           </ul>
                        </div>
                        <div>
                           <div class="infoboxnotealso" id="GUID-C979C5D2-944D-4422-8C92-430F92914975__GUID-5937F966-4797-4853-AC87-B0B20D60BA0B">
                              <p class="notep1">也可以看看：</p>
                              <p><a href="../sqlrf/CREATE-TABLE.html#SQLRF56953" target="_blank"><span><cite>Oracle数据库SQL语言参考，</cite></span></a>以了解有关<code class="codeph">DUPLICATE ALL</code>子句的更多信息</p>
                           </div>
                           <div class="familylinks">
                              <div class="parentlink">
                                 <p><strong>父主题：</strong> <a href="deploying-in-memory-in-oracle-rac.html#GUID-AF767E49-B4FB-4CCB-A7BF-C62E871E59AA" title="DUPLICATE子句控制Oracle RAC数据库如何跨Oracle RAC实例复制列数据。">Oracle RAC中的列式数据的重复</a></p>
                              </div>
                           </div>
                        </div>
                        
                     </div>
                     <div class="sect5"><a id="GUID-CDB1862E-CCDE-44D3-833E-66CCAC45E1CA" name="GUID-CDB1862E-CCDE-44D3-833E-66CCAC45E1CA"></a><h6 id="INMEM-GUID-CDB1862E-CCDE-44D3-833E-66CCAC45E1CA" class="sect6"><span class="enumeration_section">12.1.2.2.3</span> Oracle RAC中没有DUPLICATE子句</h6>
                        <div>
                           <p>缺省<code class="codeph">NO DUPLICATE</code>子句指定数据库仅维护对象的一个副本。
                           </p>
                           <p>例如，三节点Oracle RAC数据库可能存储实例1中的sales表的2012分区，实例2中的2013分区以及实例3中的2014分区。每个表分区只驻留在一个数据库实例中。</p>
                           <p>如果Oracle RAC节点未复制列数据，则故障节点上的列数据在群集上的IM列存储中不可用。针对缺失数据发出的查询不会失败。相反，查询从数据库缓冲区缓存或永久存储中访问数据，这可能会对性能产生负面影响。如果节点保持关闭一段时间，并且幸存的IM列存储中存在空间，则Oracle RAC会在群集中的其余节点上填充缺少的对象或对象片段。</p>
                        </div>
                        <div>
                           <div class="infoboxnotealso" id="GUID-CDB1862E-CCDE-44D3-833E-66CCAC45E1CA__GUID-374E5E03-884F-4617-B843-DA9B7233B693">
                              <p class="notep1">也可以看看：</p>
                              <p><a href="../sqlrf/CREATE-TABLE.html#SQLRF56953" target="_blank"><span><cite>Oracle数据库SQL语言参考，</cite></span></a>以了解有关<code class="codeph">NO DUPLICATE</code>子句的更多信息</p>
                           </div>
                           <div class="familylinks">
                              <div class="parentlink">
                                 <p><strong>父主题：</strong> <a href="deploying-in-memory-in-oracle-rac.html#GUID-AF767E49-B4FB-4CCB-A7BF-C62E871E59AA" title="DUPLICATE子句控制Oracle RAC数据库如何跨Oracle RAC实例复制列数据。">Oracle RAC中的列式数据的重复</a></p>
                              </div>
                           </div>
                        </div>
                        
                     </div>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-86F5001A-9DFA-410B-9A01-BD7ACF1D8D07" name="GUID-86F5001A-9DFA-410B-9A01-BD7ACF1D8D07"></a><h4 id="INMEM-GUID-86F5001A-9DFA-410B-9A01-BD7ACF1D8D07" class="sect4"><span class="enumeration_section">12.1.3</span> Oracle RAC中的并行性</h4>
                  <div>
                     <p>数据库实例必须访问它们所在的IM列存储中的IMCU。Oracle RAC中IM列存储的填充和访问必须并行发生，以便可以从任何实例访问所有IM列存储。</p>
                     <p>本节包含以下主题：</p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="deploying-in-memory-in-oracle-rac.html#GUID-AAF65A8A-56E8-409C-94F9-1FB3B72B3260">Oracle RAC中的串行和并行查询</a><br>Oracle RAC中的数据库内存是一种无共享架构。除非每个活动实例上至少运行一个并行服务器进程，否则无法保证查询从IM列存储中访问所有必需的数据。
                        </li>
                        <li class="ulchildlink"><a href="deploying-in-memory-in-oracle-rac.html#GUID-38008B94-65EA-4255-873A-B08839E88B59">Oracle RAC中的自动DOP</a><br>通过自动并行度（Auto DOP），优化器执行基于成本的计算，以确定SQL语句的并行度。
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="deploying-in-memory-in-oracle-rac.html#GUID-63748559-8BC8-473C-BE6E-453DD38ED9A3" title="每个Oracle RAC节点都有自己的内存（IM）列存储。默认情况下，填充的对象分布在群集中的所有IM列存储中。">Database In-Memory和Oracle RAC概述</a></p>
                        </div>
                     </div>
                  </div>
                  
                  <div class="sect4"><a id="GUID-AAF65A8A-56E8-409C-94F9-1FB3B72B3260" name="GUID-AAF65A8A-56E8-409C-94F9-1FB3B72B3260"></a><h5 id="INMEM-GUID-AAF65A8A-56E8-409C-94F9-1FB3B72B3260" class="sect5"><span class="enumeration_section">12.1.3.1</span> Oracle RAC中的串行和并行查询</h5>
                     <div>
                        <p>Oracle RAC中的数据库内存是一种无共享架构。除非每个活动实例上至少运行一个并行服务器进程，否则无法保证查询从IM列存储中访问所有必需的数据。</p>
                        <div class="section">
                           <p class="subhead3" id="GUID-AAF65A8A-56E8-409C-94F9-1FB3B72B3260__GUID-FC0A03AC-EFE6-4757-B9DF-2E1537445AFA">串行查询</p>
                           <p>在Oracle RAC数据库中的一个节点上运行的串行查询无法访问其他IM列存储中的IMCU。例如，在实例1上运行的串行查询请求<code class="codeph">sales</code>的完整扫描。某些<code class="codeph">sales</code>分区填充在实例1中的IM列存储中，而其他<code class="codeph">sales</code>分区则填充在实例2中的IM列存储中。查询只能访问实例1上IM列存储中的IMCU：其余数据必须来自磁盘存储。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-AAF65A8A-56E8-409C-94F9-1FB3B72B3260__GUID-E5D0D87B-E106-4F76-ABA2-A1867292ADCD">并行查询</p>
                           <p>启用并行执行但<code class="codeph">PARALLEL_DEGREE_POLICY</code>初始化参数未设置为<code class="codeph">AUTO</code> ，情况类似于串行查询情况。查询协调器在执行查询的数据库实例上运行。PQ进程将数据发送给协调器。在这种情况下，数据库启动多个PQ进程。但是，除非DOP大于或等于包含为查询中引用的对象填充的IMCU的IM列存储的数量，否则不能从IM列存储中访问所有数据。如果未启用“自动DOP”，请确保DOP至少与使用IMCU的IM列存储在查询中的填充对象一样大。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-AAF65A8A-56E8-409C-94F9-1FB3B72B3260__GUID-8FFD5675-3959-41E4-8122-2A70122E3B57">内存中动态扫描</p>
                           <p>串行和并行查询都可以执行内存中动态扫描（ <a href="glossary.html#GUID-594E26B3-2545-4F50-ABE9-173F03A859B9"><span class="xrefglossterm">IM动态扫描</span></a> ）并使用<a href="glossary.html#GUID-C40870DA-44B4-4001-B339-965DFC8D37F0"><span class="xrefglossterm">轻量级线程</span></a>基础结构。并行执行基础结构与新的线程基础结构共存，该基础结构由Oracle数据库资源管理器（资源管理器）动态管理。当<code class="codeph">INMEMORY_SIZE</code>大于<code class="codeph">0</code>时，默认情况下启用资源管理器。
                           </p>
                           <p><a href="glossary.html#GUID-9938DE9E-21B0-4A21-B69B-A80CA6295B44"><span class="xrefglossterm">表扫描过程</span></a>可以是串行查询中的前台进程，也可以是并行查询中的并行服务器进程。当并行查询执行IM动态扫描时，每个表扫描进程都可以拥有一个线程池。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-AAF65A8A-56E8-409C-94F9-1FB3B72B3260__GUID-47ADE23E-EFAA-4FB6-9303-8283786B5679">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><span class="q">“ <a href="in-memory-column-store-architecture.html#GUID-68EA52F3-D62F-474D-99FB-729A6AE43D70" title="内存中动态扫描（IM动态扫描）使用轻量级线程来并行化内存中的表扫描。">记忆内动态扫描</a> ”</span></p>
                              </li>
                              <li>
                                 <p><a href="../admin/managing-resources-with-oracle-database-resource-manager.html#ADMIN-GUID-E8FABE8D-A781-49BB-B623-98F096DED239" target="_blank"><span><cite>Oracle数据库管理员指南</cite></span></a> ，了解有关资源管理器的更多信息</p>
                              </li>
                              <li>
                                 <p><a href="../vldbg/parallel-exec-intro.html#GUID-0266F26D-7342-49CB-9613-228687108924" target="_blank"><span><cite>Oracle Database VLDB和分区指南，</cite></span></a>以了解有关Oracle RAC中并行查询的更多信息</p>
                              </li>
                              <li>
                                 <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/inmem&amp;id=GUID-BF09265F-8545-40D4-BD29-E58D5F02B0E5" target="_blank"><span><cite>Oracle Database Reference</cite></span></a>了解有关<code class="codeph">PARALLEL_DEGREE_POLICY</code>初始化参数的更多信息</p>
                              </li>
                           </ul>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="deploying-in-memory-in-oracle-rac.html#GUID-86F5001A-9DFA-410B-9A01-BD7ACF1D8D07" title="数据库实例必须访问它们所在的IM列存储中的IMCU。Oracle RAC中IM列存储的填充和访问必须并行发生，以便可以从任何实例访问所有IM列存储。">Oracle RAC中的并行性</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
                  <div class="sect4"><a id="GUID-38008B94-65EA-4255-873A-B08839E88B59" name="GUID-38008B94-65EA-4255-873A-B08839E88B59"></a><h5 id="INMEM-GUID-38008B94-65EA-4255-873A-B08839E88B59" class="sect5"><span class="enumeration_section">12.1.3.2</span> Oracle RAC中的自动DOP</h5>
                     <div>
                        <p>通过自动并行度（Auto DOP），优化器执行基于成本的计算，以确定SQL语句的并行度。</p>
                        <p>通过将<code class="codeph">PARALLEL_DEGREE_POLICY</code>初始化参数设置为<code class="codeph">AUTO</code>来启用自动DOP。当优化器解析SQL语句时，它会估计执行时间。它根据<code class="codeph">PARALLEL_MIN_TIME_THRESHOLD</code>初始化参数的设置检查此估计值，该参数在启用IM列存储时自动设置。然后，优化器会做出以下基于成本的决策：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>如果估计时间小于<code class="codeph">PARALLEL_MIN_TIME_THRESHOLD</code> ，则语句将按顺序执行。
                              </p>
                           </li>
                           <li>
                              <p>如果估计的时间大于<code class="codeph">PARALLEL_MIN_TIME_THRESHOLD</code> ，则语句并行执行。
                              </p>
                              <p>优化器根据资源需求计算并行度。计算受<code class="codeph">PARALLEL_DEGREE_LIMIT</code>初始化参数的限制，如果已配置，则受数据库资源管理器的限制。
                              </p>
                           </li>
                        </ul>
                        <p>在Oracle RAC环境中使用IM列存储时，目标是避免磁盘或缓冲区缓存访问。为此，您必须<span class="italic">保证</span>每个活动数据库实例上至少运行一个并行服务器进程。Auto DOP是实现此目标的推荐方式。
                        </p>
                        <div class="infoboxnote" id="GUID-38008B94-65EA-4255-873A-B08839E88B59__GUID-E13C5D3B-6B52-4BE8-83CF-FDD6FF24410F">
                           <p class="notep1">注意：</p>
                           <p>如果不使用自动DOP，则必须确保DOP大于或等于包含查询所需的IMCU的IM列存储的数量。</p>
                        </div>
                        <p>Auto DOP保证了足够的进程分配，因为每个共享池都存储元数据，指示所有IMCU的位置，它们的大小等等。每个共享池中都有相同的映射。无论查询源自集群，并行查询协调器都知道IMCU的<a href="glossary.html#GUID-6C8CE37F-46E9-40EE-BED8-D2FD9457769F"><span class="xrefglossterm">归属位置</span></a> （驻留的实例）。
                        </p>
                        <p>例如，PQ协调器知道2016的销售分区在实例1中，而2015的分区在实例2中。如果在实例1上运行的查询同时请求2015和2016分区，则查询协调器使用归属位置来确定要访问的IM列存储。如果DOP设置得足够高，则协调器会自动启动两个实例上的PQ进程，并且进程将请求的数据发送回查询协调器。</p>
                        <p></p>
                     </div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-38008B94-65EA-4255-873A-B08839E88B59__GUID-BC78427F-E4C3-45C8-B96F-2B4F4D40F157">
                           <p class="notep1">也可以看看：</p><a href="../vldbg/inmemory-parallel-exec.html#GUID-AFEB5E27-9E6F-4924-B9C2-5354A948A8A5" target="_blank"><span><cite>Oracle Database VLDB和分区指南</cite></span></a> ，了解Auto DOP</div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="deploying-in-memory-in-oracle-rac.html#GUID-86F5001A-9DFA-410B-9A01-BD7ACF1D8D07" title="数据库实例必须访问它们所在的IM列存储中的IMCU。Oracle RAC中IM列存储的填充和访问必须并行发生，以便可以从任何实例访问所有IM列存储。">Oracle RAC中的并行性</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div>
               <div class="sect3"><a id="GUID-5FCDE9BB-4285-4270-B1AE-FF9D3FF2400B" name="GUID-5FCDE9BB-4285-4270-B1AE-FF9D3FF2400B"></a><h4 id="INMEM-GUID-5FCDE9BB-4285-4270-B1AE-FF9D3FF2400B" class="sect4"><span class="enumeration_section">12.1.4</span> Oracle RAC中的FastStart区域</h4>
                  <div>
                     <p>FastStart区域在所有Oracle RAC节点之间共享。此功能可实现群集中的最大共享和可重用性。</p>
                     <p>只有一个IMCU副本位于FastStart区域。例如，如果为四节点群集中的对象指定了<code class="codeph">DUPLICATE ALL</code> ，则IM列列存储中将存在该对象的四个副本。但是，数据库仅将一个副本保存到FastStart区域。
                     </p>
                     <p>Oracle RAC集群中的任何数据库实例都可以使用FastStart区域中的IMCU。此功能可提高Oracle RAC环境中实例重新启动的性能。</p>
                     <p>例如， <code class="codeph">sales</code>表可能有三个分区： <code class="codeph">sales_2014</code> ， <code class="codeph">sales_2015</code>和<code class="codeph">sales_2016</code> ，每个分区都填充在不同的实例中。发生实例故障，一个实例无法重新启动。如果IM列存储中有足够的可用空间，则幸存的实例可以读取先前在不可访问的实例中填充的IMCU。因此，所有三个<code class="codeph">sales</code>表分区都可供应用程序使用。
                     </p>
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-5FCDE9BB-4285-4270-B1AE-FF9D3FF2400B__GUID-A2B2DAE3-D8A9-460E-8C8F-8D292D53B9CC">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><span class="q">“ <a href="deploying-in-memory-in-oracle-rac.html#GUID-5FCDE9BB-4285-4270-B1AE-FF9D3FF2400B" title="FastStart区域在所有Oracle RAC节点之间共享。此功能可实现群集中的最大共享和可重用性。">Oracle RAC中的FastStart区域</a> ”</span></p>
                           </li>
                           <li>
                              <p><a href="../sqlrf/CREATE-TABLE.html#SQLRF56953" target="_blank"><span><cite>Oracle数据库SQL语言参考，</cite></span></a>以了解有关<code class="codeph">DUPLICATE ALL</code>子句的更多信息</p>
                           </li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="deploying-in-memory-in-oracle-rac.html#GUID-63748559-8BC8-473C-BE6E-453DD38ED9A3" title="每个Oracle RAC节点都有自己的内存（IM）列存储。默认情况下，填充的对象分布在群集中的所有IM列存储中。">Database In-Memory和Oracle RAC概述</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div>
            <div class="sect2"><a id="GUID-C6DE0126-DCD7-4E6C-B673-F8FE1AECD23C" name="GUID-C6DE0126-DCD7-4E6C-B673-F8FE1AECD23C"></a><h3 id="INMEM-GUID-C6DE0126-DCD7-4E6C-B673-F8FE1AECD23C" class="sect3"><span class="enumeration_section">12.2</span>在Oracle RAC中配置内存服务</h3>
               <div>
                  <p><span class="bold">服务</span>代表一组实例。在Oracle RAC中，您可以使用服务将连接或应用程序定向到群集中的节点子集。
                  </p>
                  <p>本节包含以下主题：</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="deploying-in-memory-in-oracle-rac.html#GUID-45D38B7B-91EB-4FE1-AC4B-0B9F7B50CFF8">实例级服务控制</a><br>在Oracle RAC中，IM列存储的填充和访问必须并行发生，以便可以从任何数据库实例访问所有IM列存储。
                     </li>
                     <li class="ulchildlink"><a href="deploying-in-memory-in-oracle-rac.html#GUID-2CF933E4-102B-4C9B-9953-6953A8CE2BCE">对象级服务控件</a><br>对于单个对象， <code class="codeph">INMEMORY ...DISTRIBUTE</code>子句有一个<code class="codeph">FOR SERVICE</code>子句，它将群体限制为可以运行此服务的数据库实例。
                     </li>
                     <li class="ulchildlink"><a href="deploying-in-memory-in-oracle-rac.html#GUID-3C829D4E-3082-4E46-A9CD-FC5A55419EA5">Oracle RAC中的数据库内存服务的优点</a><br>服务和<code class="codeph">DUPLICATE</code>的组合使您可以控制节点访问和内存中的人口。
                     </li>
                     <li class="ulchildlink"><a href="deploying-in-memory-in-oracle-rac.html#GUID-631D6390-BAC3-4C6E-93E4-09D4F23525D2">为节点子集配置内存服务：示例</a><br>此任务说明如何将内存服务分配给Oracle RAC数据库中的节点子集。
                     </li>
                  </ul>
                  <div class="infoboxnotealso" id="GUID-C6DE0126-DCD7-4E6C-B673-F8FE1AECD23C__GUID-F9FFEC34-F1FC-418A-9C69-ADA7513059A8">
                     <p class="notep1">也可以看看：</p>
                     <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/inmem&amp;id=GUID-4CC2D344-02D6-40E7-85B6-BB3AA7D6461A" target="_blank"><span class="italic">“Oracle Real Application Clusters管理和部署指南”</span></a>以了解有关Oracle RAC中的服务的更多信息</p>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="deploying-in-memory-in-oracle-rac.html#GUID-E897E3E9-1163-4FAE-9C74-B8B83B515E31" title="本章介绍如何在Oracle Real Application Clusters（Oracle RAC）环境中启用IM列存储，以及如何为填充配置对象。">在Oracle RAC中部署IM列存储</a></p>
                     </div>
                  </div>
               </div>
               
               <div class="sect3"><a id="GUID-45D38B7B-91EB-4FE1-AC4B-0B9F7B50CFF8" name="GUID-45D38B7B-91EB-4FE1-AC4B-0B9F7B50CFF8"></a><h4 id="INMEM-GUID-45D38B7B-91EB-4FE1-AC4B-0B9F7B50CFF8" class="sect4"><span class="enumeration_section">12.2.1</span>实例级服务控制</h4>
                  <div>
                     <p>在Oracle RAC中，IM列存储的填充和访问必须并行发生，以便可以从任何数据库实例访问所有IM列存储。</p>
                     <p><code class="codeph">PARALLEL_INSTANCE_GROUP</code>初始化参数将并行查询操作限制为指定的服务。例如，如果群集中四个数据库实例中有三个具有IM列存储，则可以创建名为<code class="codeph">dbmperf</code>的服务，并使用<code class="codeph">PARALLEL_INSTANCE_GROUP</code>将这三个实例分配给此服务。然后，您可以限制与<code class="codeph">dbmperf</code>服务的所有客户端连接。并行操作仅在服务中定义的实例上生成并行执行进程。
                     </p>
                     <div class="figure" id="GUID-45D38B7B-91EB-4FE1-AC4B-0B9F7B50CFF8__GUID-4B1B330D-CC4D-455B-9BC3-752A15E294F0">
                        <p class="titleinfigure">图12-8为服务分配实例子集</p><img src="img/inmem_3v_018.png" alt="下面是图12-8的描述" title="下面是图12-8的描述" longdesc="img_text/inmem_3v_018.html"><br><a href="img_text/inmem_3v_018.html">“图12-8为服务分配实例子集”的说明</a></div>
                     <!-- class="figure" -->
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-45D38B7B-91EB-4FE1-AC4B-0B9F7B50CFF8__GUID-F1872FEB-394A-42EB-AB97-B184074C7692">
                        <p class="notep1">也可以看看：</p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/inmem&amp;id=GUID-F568ECFA-1796-494A-8F45-F888F69032E4" target="_blank"><span><cite>Oracle Database Reference</cite></span></a>了解有关<code class="codeph">PARALLEL_INSTANCE_GROUP</code>初始化参数的更多信息</div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="deploying-in-memory-in-oracle-rac.html#GUID-C6DE0126-DCD7-4E6C-B673-F8FE1AECD23C" title="服务代表一组实例。在Oracle RAC中，您可以使用服务将连接或应用程序定向到群集中的节点子集。">在Oracle RAC中配置内存服务</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="sect3"><a id="GUID-2CF933E4-102B-4C9B-9953-6953A8CE2BCE" name="GUID-2CF933E4-102B-4C9B-9953-6953A8CE2BCE"></a><h4 id="INMEM-GUID-2CF933E4-102B-4C9B-9953-6953A8CE2BCE" class="sect4"><span class="enumeration_section">12.2.2</span>对象级服务控制</h4>
                  <div>
                     <p>对于单个对象， <code class="codeph">INMEMORY ...DISTRIBUTE</code>子句有一个<code class="codeph">FOR SERVICE</code>子句，它将群体限制为可以运行此服务的数据库实例。
                     </p>
                     <p><code class="codeph">PARALLEL_INSTANCE_GROUP</code>初始化参数控制服务级别的段，其中服务表示一个或多个实例。相比之下， <code class="codeph">INMEMORY ...DISTRIBUTE FOR SERVICE</code>控制分段级别的分配。例如，您可以将<code class="codeph">INMEMORY</code>对象配置为仅在实例1上的IM列存储中填充，或仅在实例2上或在两个实例中填充。
                     </p>
                     <p><code class="codeph">DISTRIBUTE FOR SERVICE</code>选项包括：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">DEFAULT</code> - 如果设置了<code class="codeph">PARALLEL_INSTANCE_GROUP</code> ，则会在<code class="codeph">PARALLEL_INSTANCE_GROUP</code>指定了IM列存储的所有数据库实例中填充该对象。如果未设置<code class="codeph">PARALLEL_INSTANCE_GROUP</code> ，则会在具有IM列存储的所有实例中填充该对象。
                           </p>
                           <p>指定<code class="codeph">FOR SERVICE</code>等同于指定<code class="codeph">FOR SERVICE DEFAULT</code> 。</p>
                        </li>
                        <li>
                           <p><code class="codeph">ALL</code> - 数据库填充具有IM列存储的所有实例中的对象。
                           </p>
                           <div class="infoboxnote" id="GUID-2CF933E4-102B-4C9B-9953-6953A8CE2BCE__GUID-4B893751-254A-42DB-8F9E-7258BAA46F1A">
                              <p class="notep1">注意：</p>
                              <p>如果未设置<code class="codeph">PARALLEL_INSTANCE_GROUP</code> ，则<code class="codeph">DEFAULT</code>和<code class="codeph">ALL</code>在功能上是等效的。
                              </p>
                           </div>
                        </li>
                        <li>
                           <p><span class="italic">service_name</span> - 作为其职责的一部分，IMCO触发从分配给先前服务的数据库实例中删除对象，并将其填充到分配给新服务的实例中。
                           </p>
                           <p>重新分发段时，数据库会执行必要的最少工作。例如，服务<code class="codeph">dbmperf</code>被分配给实例1和实例2。<code class="codeph">sales</code>分区在实例1和实例2之间均匀分布。您将实例3添加到此服务。数据库仅填充实例3中的IMCU，然后在必要时从实例1或实例2中删除它们以进行均匀分发。一些IMCU保留在原始位置。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">NONE</code> -  IMCO从当前指定服务的IM列存储中删除对象。
                           </p>
                        </li>
                     </ul>
                     <p>如果对象的<code class="codeph">PRIORITY</code>值不是<code class="codeph">NONE</code> ，则在DDL执行或服务启动后，W <span class="italic">nnn</span>进程在下一个IMCO循环期间填充对象。但是，如果对象的<code class="codeph">PRIORITY</code>设置为<code class="codeph">NONE</code> ，则仅在完整表扫描期间填充对象。扫描会触发表的指定服务处于活动状态且未阻止的所有数据库实例上的内存容量。请注意，此服务可能与发布服务的扫描不同。
                     </p>
                     <p>如果用于内存中填充的服务停止，则数据库将从此服务表示的IM列存储中删除该段。在这方面，停止服务就像关闭实例一样。此对象的<code class="codeph">INMEMORY</code>属性不会更改。如果服务再次启动，则数据库将根据其<code class="codeph">INMEMORY</code>属性填充对象。要从IM列存储中删除对象， <code class="codeph">NO INMEMORY</code>在DDL语句中指定<code class="codeph">NO INMEMORY</code> 。
                     </p>
                     <p>您可以将<code class="codeph">DUPLICATE</code>与<code class="codeph">DISTRIBUTE FOR SERVICE</code>结合使用。例如，您可以指定对象对服务<code class="codeph">dbmperf</code>使用<code class="codeph">DUPLICATE ALL</code> ，该服务分配给四个节点中的三个节点。在这种情况下，这三个节点中的每一个上的IM列存储都具有该对象的副本。
                     </p>
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-2CF933E4-102B-4C9B-9953-6953A8CE2BCE__GUID-2E0ED88A-76FE-4821-89A2-401AD6D7D1F4">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><span class="q">“ <a href="populating-objects-in-memory.html#GUID-DE12F0E2-8BEC-4326-A816-D812E54A3D12" title="DDL语句包括一个INMEMORY PRIORITY子句，它提供了对总体队列的更多控制。">记忆中人口的优先顺序</a> ”</span></p>
                           </li>
                           <li>
                              <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/inmem&amp;id=SQLRF-GUID-F9CE0CC3-13AE-4744-A43C-EAC7A71AAAB6" target="_blank"><span><cite>Oracle Database SQL语言参考，</cite></span></a>以了解有关<code class="codeph">DISTRIBUTE FOR SERVICE</code>子条款的更多信息</p>
                           </li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="deploying-in-memory-in-oracle-rac.html#GUID-C6DE0126-DCD7-4E6C-B673-F8FE1AECD23C" title="服务代表一组实例。在Oracle RAC中，您可以使用服务将连接或应用程序定向到群集中的节点子集。">在Oracle RAC中配置内存服务</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="sect3"><a id="GUID-3C829D4E-3082-4E46-A9CD-FC5A55419EA5" name="GUID-3C829D4E-3082-4E46-A9CD-FC5A55419EA5"></a><h4 id="INMEM-GUID-3C829D4E-3082-4E46-A9CD-FC5A55419EA5" class="sect4"><span class="enumeration_section">12.2.3</span> Oracle RAC中数据库内存服务的优点</h4>
                  <div>
                     <p>服务和<code class="codeph">DUPLICATE</code>的组合使您可以控制节点访问和内存中的人口。
                     </p>
                     <p>服务的好处包括以下内容：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>滚动补丁和升级</p>
                           <p>假设您设置Oracle RAC服务以将客户端查询定向到包含IM列存储的实例。如果使用<code class="codeph">DUPLICATE</code>子句，则可以有选择地删除实例，而不会影响查询响应时间。此方法假定服务中的其他实例上存在足够的资源来处理已删除实例的工作负载。
                           </p>
                           <p>例如，在四节点群集中，您可以依次删除每个节点，对其进行修补，然后再次使其可用。暂时无法访问的节点的IMCU至少在另一个节点上可用，具体取决于您是使用<code class="codeph">DUPLICATE</code>还是<code class="codeph">DUPLICATE ALL</code>子句。因此，对列式数据的应用程序访问保持不间断。
                           </p>
                        </li>
                        <li>
                           <p>应用亲和力</p>
                           <p>您可以根据服务名称限制对单个节点的应用程序访问。例如，服务<code class="codeph">dbmperf1</code>仅限于节点1，服务<code class="codeph">dbmperf2</code>仅限于节点2，依此类推。当应用程序连接到特定服务并提交并行查询时，查询将使用属于同一服务的节点上的进程。例如，连接到服务<code class="codeph">dbmperf1</code>的应用程序仅使用节点1上的进程。
                           </p>
                           <p>应用程序可以独立地共存在Oracle RAC数据库中并访问列式数据。可以在每个节点中填充完全不同的对象。例如，您可以指示HR应用程序为<code class="codeph">dbmperf1</code>提供服务，并将销售历史记录应用程序指向服务<code class="codeph">dbmperf2</code> 。
                           </p>
                        </li>
                     </ul>
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-3C829D4E-3082-4E46-A9CD-FC5A55419EA5__GUID-994F2241-436E-4FE8-9D7D-4F165551A320">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><span class="q">“ <a href="populating-objects-in-memory.html#GUID-BFD476E7-C70D-4906-8B10-D33BC1E768C0" title="当数据库从磁盘读取现有行格式数据，将其转换为列格式，然后将其存储在IM列存储中时，会发生内存中的填充（填充）。">关于记忆中的人口</a> ”</span></p>
                           </li>
                           <li>
                              <p>用于<code class="codeph">DUPLICATE</code>语义的<a href="../sqlrf/CREATE-TABLE.html#GUID-F9CE0CC3-13AE-4744-A43C-EAC7A71AAAB6__GUID-B7580570-95AC-4CB7-B969-F195D4A7D675" target="_blank"><span><cite>Oracle数据库SQL语言参考</cite></span></a></p>
                           </li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="deploying-in-memory-in-oracle-rac.html#GUID-C6DE0126-DCD7-4E6C-B673-F8FE1AECD23C" title="服务代表一组实例。在Oracle RAC中，您可以使用服务将连接或应用程序定向到群集中的节点子集。">在Oracle RAC中配置内存服务</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="sect3"><a id="GUID-631D6390-BAC3-4C6E-93E4-09D4F23525D2" name="GUID-631D6390-BAC3-4C6E-93E4-09D4F23525D2"></a><h4 id="INMEM-GUID-631D6390-BAC3-4C6E-93E4-09D4F23525D2" class="sect4"><span class="enumeration_section">12.2.4</span>配置节点子集的内存服务：示例</h4>
                  <div>
                     <p>此任务说明如何将内存服务分配给Oracle RAC数据库中的节点子集。</p>
                     <div class="section">
                        <p>目标如下：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>在RAC数据库中的节点子集上创建IM列存储</p>
                           </li>
                           <li>
                              <p>定义服务以仅允许访问具有IM列存储的节点</p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-631D6390-BAC3-4C6E-93E4-09D4F23525D2__GUID-56F2AF60-4744-4C43-A143-C604C39D003C">假设</p>
                        <p>此任务假定以下内容：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>名为<code class="codeph">dbmm</code>的Oracle RAC数据库有四个实例： <code class="codeph">dbm1</code> ， <code class="codeph">dbm2</code> ， <code class="codeph">dbm3</code>和<code class="codeph">dbm4</code> 。见<span class="q">“ <a href="deploying-in-memory-in-oracle-rac.html#GUID-45D38B7B-91EB-4FE1-AC4B-0B9F7B50CFF8__GUID-4B1B330D-CC4D-455B-9BC3-752A15E294F0">图12-8</a> ”</span> 。
                              </p>
                           </li>
                           <li>
                              <p>除<code class="codeph">dbm4</code>之外的所有实例都将<code class="codeph">INMEMORY_SIZE</code>设置为非零值。
                              </p>
                           </li>
                           <li>
                              <p>您希望添加名为<code class="codeph">dbmperf</code>的服务，并将<code class="codeph">dbmperf</code>分配给具有IM列存储的三个节点。
                              </p>
                           </li>
                           <li>
                              <p>您希望填充附加到服务的IM列存储中的<code class="codeph">sales</code>表。
                              </p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-631D6390-BAC3-4C6E-93E4-09D4F23525D2__GUID-57349009-47ED-4BEA-9E5C-C797A0FF89A5">要为节点子集配置In-Memory服务：</p>
                        <ol>
                           <li>
                              <p>创建表示运行IM列存储的三个节点的服务。</p>
                              <p>在操作系统命令行上，使用以下格式使用<code class="codeph">srvctl</code>命令：</p><pre class="pre codeblock"><code>srvctl add service -db <span class="italic">db_name</span> -s <span class="italic">service_name</span> -preferred“ <span class="italic">instance_names</span> ”</code></pre><p>例如，输入以下命令：</p><pre class="pre codeblock"><code>srvctl add service -db dbmm -s dbmperf -preferred“dbm1，dbm2，dbm3”</code></pre></li>
                           <li>
                              <p>启动服务。</p>
                              <p>例如，要启动<code class="codeph">dbmperf</code>服务，请使用以下命令：</p><pre class="pre codeblock"><code>srvctl启动服务-db dbmm -service“dbmperf”</code></pre></li>
                           <li>
                              <p>为与服务的连接创建网络服务名称。</p>
                              <p>例如，更新<code class="codeph">tnsnames.ora</code>文件，如下所示：</p><pre class="pre codeblock"><code>DBMPERF =（DESCRIPTION =（ADDRESS =（PROTOCOL = TCP）（HOST = <span class="italic">host_name</span> ）（PORT = <span class="italic">listener_port</span> ））（CONNECT_DATA =（SERVER = DEDICATED）（SERVICE_NAME = DBMPERF）））</code></pre><p></p>
                           </li>
                           <li>
                              <p>使用<code class="codeph">DISTRIBUTE FOR SERVICE</code>子句将<code class="codeph">INMEMORY</code>属性分配给要填充的表。
                              </p>
                              <p>例如，更改<code class="codeph">sales</code>情况如下：</p><pre class="pre codeblock"><code>ALTER TABLE销售INMEMORY DISTRIBUTE FOR SERVICE“dbmperf”;</code></pre><p>上述语句对<code class="codeph">sales</code>表使用<code class="codeph">NONE</code>的默认<code class="codeph">PRIORITY</code>设置。因此，此表的填充是按需而不是自动发生的。
                              </p>
                           </li>
                           <li>
                              <p>要填充<code class="codeph">sales</code>表，请连接到<code class="codeph">dbmperf</code>服务，然后启动对表的完整扫描。
                              </p>
                              <p>例如，通过查询<code class="codeph">sales</code>强制执行完整扫描，如下所示：</p><pre class="pre codeblock"><code>SELECT / * + FULL（s）* / COUNT（*）FROM sales s;</code></pre></li>
                        </ol>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-631D6390-BAC3-4C6E-93E4-09D4F23525D2__GUID-83AF42C8-E581-49CB-942F-46C0BAEFB583">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="../sqlrf/CREATE-TABLE.html#SQLRF56768" target="_blank"><span><cite>Oracle数据库SQL语言参考，</cite></span></a>以了解有关<code class="codeph">ALTER TABLE</code>的<code class="codeph">INMEMORY DISTRIBUTE FOR SERVICE</code>子句的更多信息 
                              </p>
                           </li>
                           <li>
                              <p><a href="../admin/configuring-automatic-restart-of-an-oracle-database.html#GUID-5832E064-85C6-453C-B932-99700B1732A9" target="_blank"><span><cite>Oracle数据库管理员指南</cite></span></a> ，了解有关<code class="codeph">srvctl</code>实用程序的更多信息</p>
                           </li>
                           <li>
                              <p><a href="../netag/introducing-oracle-net-services.html#GUID-4A41F877-7839-4241-B13E-0A3839A102C5" target="_blank"><span><cite>Oracle数据库网络服务管理员指南</cite></span></a> ，了解有关网络服务名称的更多信息</p>
                           </li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="deploying-in-memory-in-oracle-rac.html#GUID-C6DE0126-DCD7-4E6C-B673-F8FE1AECD23C" title="服务代表一组实例。在Oracle RAC中，您可以使用服务将连接或应用程序定向到群集中的节点子集。">在Oracle RAC中配置内存服务</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div>
         </div>
      </article>
   </body>
</html>