<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <meta name="abstract" content="This chapter describes topics about OCI performance features."></meta>
      <meta name="description" content="This chapter describes topics about OCI performance features."></meta>
      <title>表演主题</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Programmer&#39;s Guide"></meta>
      <meta property="og:description" content="This chapter describes topics about OCI performance features."></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Programmer&#39;s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="oracle-call-interface-programmers-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-14T08:46:00-08:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="1996, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96204-01"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="user-defined-callback-functions.html" title="Previous" type="text/html"></link>
      <link rel="next" href="database-startup-and-shutdown.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Oracle Call Interface Programmer&#39;s Guide"></meta>
    <meta name="dcterms.isVersionOf" content="LNOCI"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="user-defined-callback-functions.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="database-startup-and-shutdown.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">程序员指南</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">表演主题</li>
            </ol>
            <a id="GUID-DF9CF68A-3F33-4CB6-B192-4480359FBFE2" name="GUID-DF9CF68A-3F33-4CB6-B192-4480359FBFE2"></a><a id="LNOCI73039"></a><a id="LNOCI092"></a>
            
            <h2 id="LNOCI-GUID-DF9CF68A-3F33-4CB6-B192-4480359FBFE2" class="sect2"><span class="enumeration_chapter">15</span>性能主题</h2>
         </header>
         <div class="ind">
            <div>
               <p>本章介绍有关OCI性能功能的主题。</p>
               <p>您可以使用OCI访问Oracle TimesTen内存数据库和Oracle TimesTen应用程序层数据库缓存。</p>
               <div class="section">
                  <div class="p">本章包括以下主题：<ul style="list-style-type:disc">
                        <li>
                           <p><a href="performance-topics.html#GUID-4947CAE8-1F00-4897-BB2B-7F921E495175" title="语句缓存是指为每个会话提供和管理语句缓存的功能。">OCI中的语句缓存</a></p>
                        </li>
                        <li>
                           <p><a href="performance-topics.html#GUID-03884D82-8E0C-4CAB-84F4-4ED4D8D8674B" title="本节介绍以下主题：">ROWID的隐式提取</a></p>
                        </li>
                        <li>
                           <p><a href="performance-topics.html#GUID-F5BF8851-F491-4EF8-BA20-B6146AF2700F" title="从Oracle Database 12c第1版（12.1）开始，PL / SQL可以从存储过程和匿名PL / SQL块中隐式返回结果（游标）。提供OCIStmtGetNextResult（）以检索和处理隐式结果。">OCI支持隐含结果</a></p>
                        </li>
                        <li>
                           <p><a href="performance-topics.html#GUID-F8BAB50F-7D21-43C0-846D-416D34429117" title="OCI应用程序可以使用客户端内存来利用OCI结果缓存来改善重复查询的响应时间。">客户端结果缓存</a></p>
                        </li>
                        <li>
                           <p><a href="performance-topics.html#GUID-75169FE4-DE2C-431F-BBA7-3691C7C33360" title="描述有关客户端语句高速缓存自动调整的主题。">客户端语句缓存自动调整</a></p>
                        </li>
                     </ul>
                  </div>
               </div>
               <!-- class="section" -->
            </div>
            <div class="props_rev_3"><a id="GUID-4947CAE8-1F00-4897-BB2B-7F921E495175" name="GUID-4947CAE8-1F00-4897-BB2B-7F921E495175"></a><h3 id="LNOCI-GUID-4947CAE8-1F00-4897-BB2B-7F921E495175" class="sect3"><span class="enumeration_section">15.1</span> OCI中的语句缓存</h3>
               <div>
                  <p>语句缓存是指为每个会话提供和管理语句缓存的功能。</p>
                  <p>在服务器中，这意味着可以使用游标而无需再次解析语句。您可以将语句缓存与连接池和会话池一起使用，并提高性能和可伸缩性。您也可以在没有会话池的情况下使用它。OCI调用实现语句缓存是：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><code class="codeph">OCIStmtPrepare2（）</code></p>
                     </li>
                     <li>
                        <p><code class="codeph">OCIStmtRelease（）</code></p>
                     </li>
                  </ul>
                  <div class="p">本节包括以下主题：<ul style="list-style-type:disc">
                        <li>
                           <p><a href="performance-topics.html#GUID-3525B9FE-2EE8-4016-90FF-54A684DF8198" title="要在没有会话池的情况下执行语句缓存，用户执行通常的OCI步骤来登录。">OCI中没有会话池的语句缓存</a></p>
                        </li>
                        <li>
                           <p><a href="performance-topics.html#GUID-75CA667E-81A1-4DDF-898B-9B1A46459ACA" title="对于具有会话池的语句缓存，概念保持不变，除了在会话池层而不是在会话层启用语句高速缓存。">在OCI中使用会话池进行语句缓存</a></p>
                        </li>
                        <li>
                           <p><a href="performance-topics.html#GUID-49C78457-8F76-48E1-A2CD-7EB22175042F" title="如果您正在使用语句缓存，请遵循这些规则。">OCI中的语句缓存规则</a></p>
                        </li>
                        <li>
                           <p><a href="performance-topics.html#GUID-969F29B1-BF1B-4D0F-B06D-5B90FDC56D78" title="为避免应用程序对缓存中的语句重复绑定和定义操作，应用程序可以使用从语句高速缓存中获取的语句注册不透明上下文，并使用服务上下文注册回调函数。">在语句缓存中绑定和定义优化</a></p>
                        </li>
                        <li>
                           <p><a href="performance-topics.html#GUID-514CBC11-2222-43B4-A8AD-C71842DF9840" title="指示在何处查找语句缓存的工作示例。">OCI语句缓存代码示例</a></p>
                        </li>
                     </ul>
                  </div>
                  <div class="infoboxnotealso" id="GUID-4947CAE8-1F00-4897-BB2B-7F921E495175__GUID-9191985B-BC63-438A-AE5B-360FA3DAE8B9">
                     <p class="notep1">也可以看看：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="statement-functions.html#GUID-E6C1DC67-D464-4D2A-9F19-737423D31779" title="准备SQL或PL / SQL语句以便执行。">OCIStmtPrepare2（）</a></p>
                        </li>
                        <li>
                           <p><a href="statement-functions.html#GUID-256034CE-2ADB-4BE5-BC8D-748307F2EA8E" title="释放通过调用OCIStmtPrepare2（）获得的语句句柄。">OCIStmtRelease（）</a></p>
                        </li>
                     </ul>
                  </div>
               </div>
               <div class="props_rev_3"><a id="GUID-3525B9FE-2EE8-4016-90FF-54A684DF8198" name="GUID-3525B9FE-2EE8-4016-90FF-54A684DF8198"></a><h4 id="LNOCI-GUID-3525B9FE-2EE8-4016-90FF-54A684DF8198" class="sect4"><span class="enumeration_section">15.1.1</span> OCI中没有会话池的语句缓存</h4>
                  <div>
                     <p>要在没有会话池的情况下执行语句缓存，用户执行通常的OCI步骤来登录。</p>
                     <p>获取会话的调用具有一种模式，该模式指定是否为会话启用语句高速缓存。最初语句缓存为空。开发人员尝试使用语句文本在缓存中查找语句。如果该语句存在，则API返回先前准备的语句句柄;否则，它返回一个新准备的语句句柄。</p>
                     <p>应用程序开发人员可以执行绑定和定义，然后在将语句返回缓存之前简单地执行和获取语句。如果在缓存中找不到语句句柄，则除了其他步骤之外，开发人员还必须在句柄上设置不同的属性。</p>
                     <p>如果在缓存中找不到该语句，则<code class="codeph">OCIStmtPrepare2()</code>采用一种模式来确定开发人员是否需要<code class="codeph">OCIStmtPrepare2()</code>准备语句句柄或空语句句柄。
                     </p>
                     <p>伪代码看起来像这样：</p><pre class="oac_no_warn" dir="ltr">OCISessionBegin（userhp，...OCI_STMT_CACHE）; OCIAttrset（svchp，userhp，...）; / *在服务上下文中设置用户句柄* / OCIStmtPrepare2（svchp，＆stmthp，stmttext，key，...）; OCIBindByPos（stmthp，...）; OCIDefineByPos（stmthp，...）; OCIStmtExecute（svchp，stmthp，...）; OCIStmtFetch2（svchp，...）; OCIStmtRelease（stmthp，...）; ...</pre><div class="infoboxnotealso" id="GUID-3525B9FE-2EE8-4016-90FF-54A684DF8198__GUID-A466A27D-1961-450F-8C0A-77A0084ADD41">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="statement-functions.html#GUID-E6C1DC67-D464-4D2A-9F19-737423D31779" title="准备SQL或PL / SQL语句以便执行。">OCIStmtPrepare2（）</a></p>
                     </div>
                  </div>
               </div>
               <div class="props_rev_3"><a id="GUID-75CA667E-81A1-4DDF-898B-9B1A46459ACA" name="GUID-75CA667E-81A1-4DDF-898B-9B1A46459ACA"></a><h4 id="LNOCI-GUID-75CA667E-81A1-4DDF-898B-9B1A46459ACA" class="sect4"><span class="enumeration_section">15.1.2</span> OCI中使用会话池的语句缓存</h4>
                  <div>
                     <p>对于具有会话池的语句缓存，概念保持不变，除了在会话池层而不是在会话层启用语句高速缓存。</p>
                     <p>属性<code class="codeph">OCI_ATTR_SPOOL_STMTCACHESIZE</code>为会话池中的每个会话设置默认语句高速缓存大小。它在<code class="codeph">OCI_HTYPE_SPOOL</code>句柄上设置。通过在该会话上使用<code class="codeph">OCI_ATTR_STMTCACHESIZE</code> ，可以随时覆盖池中特定会话的语句高速缓存大小。<code class="codeph">OCI_ATTR_SPOOL_STMTCACHESIZE</code>的值可以随时更改。您可以使用此属性在创建后启用或禁用池级别的语句高速缓存，就像使用属性<code class="codeph">OCI_ATTR_STMTCACHESIZE</code> （在服务上下文中）在会话级别启用或禁用语句高速缓存一样。当这些更改提供给用户时，此更改将反映在池中的各个会话中。标记的会话是此行为的一个例外。这将在本节后面解释。
                     </p>
                     <div class="infoboxnote" id="GUID-75CA667E-81A1-4DDF-898B-9B1A46459ACA__GUID-F8243F9A-3B83-4CD4-8114-F00044ADCBD3">
                        <p class="notep1">注意：</p>
                        <p>您可以在获取会话后更改属性。但是，一旦属性发生更改，它将保持在基础物理会话上设置。在将会话释放回会话池时，不会隐式重置此值。因此，开发人员有责任在使用<code class="codeph">OCIStmtRelease()</code>释放会话之前维护会话状态。
                        </p>
                     </div>
                     <p>在非池化会话中，允许在单个池化会话上启用或禁用语句高速缓存。</p>
                     <p>用户可以通过在mode参数中分别指定<code class="codeph">OCI_SESSGET_STMTCACHE</code>或<code class="codeph">OCI_LOGON2_STMTCACHE</code> ，在<code class="codeph">OCISessionGet()</code>或<code class="codeph">OCILogon2()</code>调用中从非语句高速缓存池中检索的会话上启用语句高速缓存。
                     </p>
                     <p>当用户从会话池请求会话时，该会话的语句高速缓存大小默认为池的大小。这也可能意味着在该会话中启用或禁用语句缓存。例如，如果池化会话（会话A）启用了语句缓存，并且池中的语句缓存已关闭，并且用户请求会话，并且返回了会话A，则会话A中的语句缓存将关闭。再举一个例子，如果池中的会话A没有启用语句缓存，并且池级别的语句缓存打开，那么在将会话A返回给用户之前，会话A上的语句缓存大小等于池的大小打开了。</p>
                     <p>如果要求并检索标记的会话，则不适用。在这种情况下，语句高速缓存的大小不会更改。因此，它没有打开或关闭。此外，如果用户在<code class="codeph">OCISessionGet()</code>调用中指定模式<code class="codeph">OCI_SESSGET_STMTCACHE</code> ，则会在标记会话时忽略该模式。在前面的示例中，如果标记了会话A，则将其原样返回给用户。
                     </p>
                     <div class="infoboxnotealso" id="GUID-75CA667E-81A1-4DDF-898B-9B1A46459ACA__GUID-BF2EDD53-B3FD-479C-AE9D-04B23F8599B6">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="connect-authorize-and-initialize-functions.html#GUID-890DFBC4-718B-4339-A0EA-6226A25B8241" title="获取一个会话。">OCISessionGet（）</a></p>
                           </li>
                           <li>
                              <p><a href="connect-authorize-and-initialize-functions.html#GUID-425D4B32-257C-480E-B69C-7112BE9482E6" title="获取一个会话。">OCILogon2（）</a></p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div>
               <div class="props_rev_3"><a id="GUID-49C78457-8F76-48E1-A2CD-7EB22175042F" name="GUID-49C78457-8F76-48E1-A2CD-7EB22175042F"></a><h4 id="LNOCI-GUID-49C78457-8F76-48E1-A2CD-7EB22175042F" class="sect4"><span class="enumeration_section">15.1.3</span> OCI中的语句缓存规则</h4>
                  <div>
                     <p>如果您正在使用语句缓存，请遵循这些规则。</p>
                     <p>以下是OCI中语句缓存的一些规则：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>使用函数<code class="codeph">OCIStmtPrepare2()</code>代替<code class="codeph">OCIStmtPrepare()</code> 。如果您正在使用<code class="codeph">OCIStmtPrepare()</code> ，强烈建议您不要在不同的服务上下文中使用语句句柄。如果<code class="codeph">OCIStmtPrepare2()</code>已获取该语句，则这样做会引发错误。将语句句柄迁移到新服务上下文实际上会关闭与旧会话关联的游标，因此不会实现共享。还没有获得客户端共享，因为在迁移语句句柄时，OCI释放与旧会话关联的所有缓冲区。
                           </p>
                        </li>
                        <li>
                           <p>您需要在每个会话中保留一个服务上下文。使用具有特定服务上下文的<code class="codeph">OCIStmtPrepare2()</code>获得的任何语句句柄随后应仅与相同的服务上下文一起使用，并且永远不会与不同的服务上下文一起使用。
                           </p>
                        </li>
                        <li>
                           <p>调用<code class="codeph">OCIStmtPrepare2()</code> ，即使会话没有语句高速缓存，也会分配语句句柄。因此，仅使用<code class="codeph">OCIStmtPrepare2()</code>应用程序不得为语句句柄调用<code class="codeph">OCIHandleAlloc()</code> 。
                           </p>
                        </li>
                        <li>
                           <p>要在通话<code class="codeph">OCIStmtPrepare2()</code>必须跟随一个呼叫<code class="codeph">OCIStmtRelease()</code>用户与该语句句柄完成之后。如果使用语句缓存，则会将语句释放到缓存。如果未使用语句高速缓存，则释放该语句。不要调用<code class="codeph">OCIHandleFree()</code>来释放内存。
                           </p>
                        </li>
                        <li>
                           <p>如果使用<code class="codeph">OCI_PREP2_CACHE_SEARCHONLY</code>模式调用<code class="codeph">OCIStmtPrepare2()</code>并返回<code class="codeph">NULL</code>语句（未找到语句），则不需要后续调用<code class="codeph">OCIStmtRelease()</code>也不得执行。
                           </p>
                        </li>
                        <li>
                           <p>不要叫<code class="codeph">OCIStmtRelease()</code>为方式，使用一份声明中<code class="codeph">OCIStmtPrepare()</code>
                           </p>
                        </li>
                        <li>
                           <p>语句高速缓存具有可由服务上下文的属性<code class="codeph">OCI_ATTR_STMTCACHESIZE</code>修改的最大大小（语句数）。默认值为20。此属性还可用于启用或禁用会话（池化或非池化）的语句缓存。如果在未将模式设置为<code class="codeph">OCI_STMT_CACHE</code>情况下调用<code class="codeph">OCISessionBegin()</code> ，则可以在服务上下文<code class="codeph">OCI_ATTR_STMTCACHESIZE</code>设置为非零属性以启用语句高速缓存。如果未在会话池级别打开语句高速缓存，则<code class="codeph">OCISessionGet()</code>将返回启用非语句高速缓存的会话。您可以使用<code class="codeph">OCI_ATTR_STMTCACHESIZE</code>打开缓存。同样，您可以使用相同的属性通过将高速缓存大小设置为零来关闭语句高速缓存。
                           </p>
                        </li>
                        <li>
                           <p>您可以在发布时标记语句，以便下次可以请求相同标记的语句。标签用于搜索缓存。未标记的语句（标记为<code class="codeph">NULL</code> ）是标记语句的特例。如果两个语句的标签不同，或者一个语句没有标记而另一个语句没有标记，则认为它们不同。
                           </p>
                        </li>
                     </ul>
                     <div class="infoboxnotealso" id="GUID-49C78457-8F76-48E1-A2CD-7EB22175042F__GUID-C4C4DA8B-7450-45E0-977D-951DB47323DE">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="statement-functions.html#GUID-E6C1DC67-D464-4D2A-9F19-737423D31779" title="准备SQL或PL / SQL语句以便执行。">OCIStmtPrepare2（）</a></p>
                           </li>
                           <li>
                              <p><a href="handle-and-descriptor-functions.html#GUID-C5BF55F7-A110-4CB5-9663-5056590F12B5" title="返回指向已分配和初始化句柄的指针。">OCIHandleAlloc（）</a></p>
                           </li>
                           <li>
                              <p><a href="statement-functions.html#GUID-256034CE-2ADB-4BE5-BC8D-748307F2EA8E" title="释放通过调用OCIStmtPrepare2（）获得的语句句柄。">OCIStmtRelease（）</a></p>
                           </li>
                           <li>
                              <p><a href="handle-and-descriptor-functions.html#GUID-E87E9F91-D3DC-4F35-BE7C-F1EFBFEEBA0A" title="显式释放句柄">OCIHandleFree（）</a></p>
                           </li>
                           <li>
                              <p><a href="connect-authorize-and-initialize-functions.html#GUID-31B1FDB3-056E-4AF9-9B89-8DA6AA156947" title="创建用户会话并开始给定服务器的用户会话。">OCISessionBegin（）</a></p>
                           </li>
                           <li>
                              <p><a href="connect-authorize-and-initialize-functions.html#GUID-890DFBC4-718B-4339-A0EA-6226A25B8241" title="获取一个会话。">OCISessionGet（）</a></p>
                           </li>
                           <li>
                              <p><a href="statement-functions.html#GUID-7C0AF073-7870-4866-BBC9-D2BF3D8E5CCE" title="列出并描述语句功能。">声明函数</a></p>
                           </li>
                           <li>
                              <p><a href="handle-and-descriptor-attributes.html#GUID-D8EE68EB-7E38-4068-B06E-DF5686379E5E" title="列出并描述服务上下文句柄属性。">服务上下文句柄属性</a></p>
                           </li>
                           <li>
                              <p><a href="handle-and-descriptor-attributes.html#GUID-34071823-66D0-4C54-BFBB-6323BDEF8015" title="列出并描述会话池句柄属性。">会话池句柄属性</a></p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div>
               <div class="props_rev_3"><a id="GUID-969F29B1-BF1B-4D0F-B06D-5B90FDC56D78" name="GUID-969F29B1-BF1B-4D0F-B06D-5B90FDC56D78"></a><h4 id="LNOCI-GUID-969F29B1-BF1B-4D0F-B06D-5B90FDC56D78" class="sect4"><span class="enumeration_section">15.1.4</span>在语句缓存中绑定和定义优化</h4>
                  <div>
                     <p>为避免应用程序对缓存中的语句重复绑定和定义操作，应用程序可以使用从语句高速缓存中获取的语句注册不透明上下文，并使用服务上下文注册回调函数。</p>
                     <p>诸如bind和define缓冲区之类的应用程序数据可以包含在opaque上下文中。在第一次从缓存中获取时，该语句将在语句中注册。当第二次及以后从缓存中获取语句时，应用程序可以重用已在该语句中注册的绑定和定义缓冲区。应用程序仍然负责管理绑定和定义。它可以重用绑定和定义数据以及缓冲区，或者它只能更改数据并重用缓冲区，或者如果当前大小不够，它可以释放和重新分配缓冲区。在最后一种情况下，它必须重新定义和重新定义。要清除应用程序为这些绑定和定义缓冲区分配的内存，在语句老化或在整个缓存中清除作为会话闭包的一部分时，将调用回调函数。为每个被清除的语句调用回调。应用程序释放内存并在回调函数中执行所需的任何其他清理。<a href="performance-topics.html#GUID-969F29B1-BF1B-4D0F-B06D-5B90FDC56D78__CACJDEDA">例15-1</a>显示了伪代码。
                     </p>
                     <div class="example" id="GUID-969F29B1-BF1B-4D0F-B06D-5B90FDC56D78__CACJDEDA">
                        <p class="titleinexample">示例15-1优化绑定并定义高速缓存中语句的操作</p><pre class="oac_no_warn" dir="ltr">使用OCIStmtPrepare2（...）获取声明从语句中获取不透明上下文（如果存在）如果不存在opaque上下文{分配获取缓冲区，执行OCIBindByPos，OCIDefineByPos等等，在上下文中包含缓冲区地址并在语句上设置上下文和回调函数}执行/使用该语句获取，并处理获取缓冲区中的数据。OCIStmtRelease（）语句Next OCIStmtPrepare2（）OCIAttrGet（）来自语句句柄的opaque应用程序上下文使用语句执行/获取并处理获取缓冲区中的数据。OCIStmtRelease（）。 。 。void callback_fn（context，statement，mode）{/ * mode = OCI_CBK_STMTCACHE_STMTPURGE表示当语句从语句缓存中老化或者会话结束时调用* / &lt;释放上下文中的缓冲区。&gt;}</pre><div class="infoboxnotealso" id="GUID-969F29B1-BF1B-4D0F-B06D-5B90FDC56D78__GUID-1B56ABFB-29B0-4323-AD27-DE975A7A0FB7">
                           <p class="notep1">也可以看看：</p>
                           <p> </p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><a href="handle-and-descriptor-attributes.html#GUID-A251CF91-EB9F-4DBC-8BB8-FB5EA92C20DE__BAJIDBEG">OCI_ATTR_STMTCACHE_CBKCTX</a></p>
                              </li>
                              <li>
                                 <p></p><a href="handle-and-descriptor-attributes.html#GUID-D8EE68EB-7E38-4068-B06E-DF5686379E5E__BAJDGBHB">OCI_ATTR_STMTCACHE_CBK</a></li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="example" -->
                  </div>
               </div>
               <div class="props_rev_3"><a id="GUID-514CBC11-2222-43B4-A8AD-C71842DF9840" name="GUID-514CBC11-2222-43B4-A8AD-C71842DF9840"></a><h4 id="LNOCI-GUID-514CBC11-2222-43B4-A8AD-C71842DF9840" class="sect4"><span class="enumeration_section">15.1.5</span> OCI语句缓存代码示例</h4>
                  <div>
                     <p>指示在何处查找语句缓存的工作示例。</p>
                     <p>有关语句缓存的工作示例，请参阅目录<code class="codeph">demo</code>中的<code class="codeph">cdemostc.c</code> 。
                     </p>
                  </div>
               </div>
            </div><a id="LNOCI73044"></a><a id="LNOCI10100"></a><div class="props_rev_3"><a id="GUID-03884D82-8E0C-4CAB-84F4-4ED4D8D8674B" name="GUID-03884D82-8E0C-4CAB-84F4-4ED4D8D8674B"></a><h3 id="LNOCI-GUID-03884D82-8E0C-4CAB-84F4-4ED4D8D8674B" class="sect3"><span class="enumeration_section">15.2</span> ROWID的隐式提取</h3>
               <div>
                  <p>本节介绍以下主题：</p>
                  <div class="p">
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="performance-topics.html#GUID-37F2A8CC-0350-4CEC-90C0-F007FCFA6064" title="ROWID是数据库中行的全局唯一标识符。它是在将行插入表中时创建的，并在删除时销毁。">关于ROWID的隐式提取</a></p>
                        </li>
                        <li>
                           <p><a href="performance-topics.html#GUID-5E17BFDD-07B5-4CE2-9301-DC3C41312993" title="显示隐式提取ROWID的示例。">ROWID的隐式提取示例</a></p>
                        </li>
                     </ul>
                  </div>
               </div><a id="LNOCI73045"></a><div class="props_rev_3"><a id="GUID-37F2A8CC-0350-4CEC-90C0-F007FCFA6064" name="GUID-37F2A8CC-0350-4CEC-90C0-F007FCFA6064"></a><h4 id="LNOCI-GUID-37F2A8CC-0350-4CEC-90C0-F007FCFA6064" class="sect4"><span class="enumeration_section">15.2.1</span>关于ROWID的隐式提取</h4>
                  <div>
                     <p><code class="codeph">ROWID</code>是数据库中行的全局唯一标识符。它是在将行插入表中时创建的，并在删除时销毁。
                     </p>
                     <p><code class="codeph">ROWID</code>值有几个重要用途。它们是表中行的唯一标识符。它们是访问单行的最快方法，可以显示表中行的存储方式。
                     </p>
                     <p>在<code class="codeph">SELECT</code>隐式提取<code class="codeph">ROWID</code> <code class="codeph">...</code> <code class="codeph">FOR</code> <code class="codeph">UPDATE</code>语句表示在客户端检索<code class="codeph">ROWID</code> ，即使它不是select语句中指定的列之一。<code class="codeph">OCIDefineByPos()</code>的<code class="codeph">position</code>参数设置为零（0）。可以指定这些主机变量来检索<code class="codeph">ROWID</code>伪列值：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">SQLT_CHR</code> （ <code class="codeph">VARCHAR2</code> ）</p>
                        </li>
                        <li>
                           <p><code class="codeph">SQLT_VCS</code> （ <code class="codeph">VARCHAR</code> ）</p>
                        </li>
                        <li>
                           <p><code class="codeph">SQLT_STR</code> （ <code class="codeph">NULL</code> -terminated string）</p>
                        </li>
                        <li>
                           <p><code class="codeph">SQLT_LVC</code> （ <code class="codeph">LONG</code> <code class="codeph">VARCHAR</code> ）</p>
                        </li>
                        <li>
                           <p><code class="codeph">SQLT_AFC</code> （ <code class="codeph">CHAR</code> ）</p>
                        </li>
                        <li>
                           <p><code class="codeph">SQLT_AVC</code> （ <code class="codeph">CHARZ</code> ）</p>
                        </li>
                        <li>
                           <p><code class="codeph">SQLT_VST</code> （ <span>OCI字符串</span> ）</p>
                        </li>
                        <li>
                           <p><code class="codeph">SQLT_RDD</code> （ <code class="codeph">ROWID</code>描述符）</p>
                        </li>
                     </ul>
                     <p><code class="codeph">SELECT</code> <code class="codeph">...</code> <code class="codeph">FOR</code> <code class="codeph">UPDATE</code>语句标识要更新的行，然后锁定结果集中的每一行。当您想要对行中的现有值进行更新时，这非常有用。在这种情况下，您必须确保其他用户不更改该行。
                     </p>
                     <p>当您指定用于存储<code class="codeph">ROWID</code>的值的字符缓冲区时（例如，如果以<code class="codeph">SQLT_STR</code>格式获取它），请分配足够的内存来存储<code class="codeph">ROWID</code> 。请记住<code class="codeph">ROWID</code>数据类型和<code class="codeph">UROWID</code>数据类型之间的差异。<code class="codeph">ROWID</code>数据类型只能存储物理<code class="codeph">ROWID</code> ，但<code class="codeph">UROWID</code>也可以存储逻辑<code class="codeph">ROWID</code> （索引组织表行的标识符）。<code class="codeph">ROWID</code>类型的最大内部长度是10个字节; <code class="codeph">UROWID</code>数据类型为3950字节。
                     </p>
                     <p>动态定义等效于调用<code class="codeph">OCIDefineByPos()</code>或<code class="codeph">OCIDefineByPos2()</code> ， <code class="codeph">mode</code>设置为<code class="codeph">OCI_DYNAMIC_FETCH</code> 。动态定义使您可以为特定的定义句柄设置其他属性。它指定一个回调函数，该函数在运行时调用以获取指向缓冲区的指针，读取的数据或其中的一部分将被检索到该缓冲区中。
                     </p>
                     <p>必须在语句句柄上设置属性<code class="codeph">OCI_ATTR_FETCH_ROWID</code>然后才能使用隐式提取<code class="codeph">ROWID</code> ，这样：</p><pre class="oac_no_warn" dir="ltr">OCIAttrSet（stmthp，OCI_HTYPE_STMT，0,0，OCI_ATTR_FETCH_ROWID，errhp）;</pre><p>动态定义与<code class="codeph">ROWID</code>的隐式提取不兼容。在正常情况下，此模式允许应用程序为每行的列提供缓冲区;也就是说，每次获取列值时都会调用回调。
                     </p>
                     <p>此功能使用<code class="codeph">OCIDefineByPos()</code>或<code class="codeph">OCIDefineByPos2()</code>作为位置0，用于同时将数据数据提取到用户缓冲区并同时获取它们各自的<code class="codeph">ROWID</code> 。它允许使用<code class="codeph">SELECT....获取<code class="codeph">ROWID</code> 。FOR UPDATE</code>语句，即使<code class="codeph">ROWID</code>不是<code class="codeph">SELECT</code>查询中的列之一。将数据逐个提取到用户缓冲区时，可以使用现有属性<code class="codeph">OCI_ATTR_ROWID</code> 。</p>
                     <p>如果使用此功能来获取<code class="codeph">ROWID</code> ，则不能同时使用语句句柄上的属性<code class="codeph">OCI_ATTR_ROWID</code>来获取<code class="codeph">ROWID</code> 。您一次只能使用其中一个用于特定语句句柄。
                     </p>
                     <div class="infoboxnotealso" id="GUID-37F2A8CC-0350-4CEC-90C0-F007FCFA6064__GUID-7BE90B21-8615-42AF-9D5D-8753E726B2FA">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="handle-and-descriptor-attributes.html#GUID-A251CF91-EB9F-4DBC-8BB8-FB5EA92C20DE__CHDEJDEE">OCI_ATTR_FETCH_ROWID</a></p>
                           </li>
                           <li>
                              <p><a href="bind-define-describe-functions.html#GUID-CFE5AA54-DEBC-42D3-8A27-AFF1E7815691" title="将选择列表中的项与类型和输出数据缓冲区相关联。">OCIDefineByPos（）</a>或<a href="bind-define-describe-functions.html#GUID-74939FB5-919E-4D24-B327-AFB532435061" title="将选择列表中的项与类型和输出数据缓冲区相关联。当客户端上的实际长度超过UB2MAXVAL时，在处理数据类型时使用此调用。">OCIDefineByPos2（）</a></p>
                           </li>
                        </ul>
                        <p></p>
                     </div>
                  </div>
               </div><a id="LNOCI72695"></a><a id="LNOCI16738"></a><div class="props_rev_3"><a id="GUID-5E17BFDD-07B5-4CE2-9301-DC3C41312993" name="GUID-5E17BFDD-07B5-4CE2-9301-DC3C41312993"></a><h4 id="LNOCI-GUID-5E17BFDD-07B5-4CE2-9301-DC3C41312993" class="sect4"><span class="enumeration_section">15.2.2</span> ROWID的隐式提取示例</h4>
                  <div>
                     <p>显示隐式提取ROWID的示例。</p>
                     <div class="section">
                        <p>使用<a href="performance-topics.html#GUID-5E17BFDD-07B5-4CE2-9301-DC3C41312993__CEGFFICH">例15-2</a>中的C程序片段进行构建。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-5E17BFDD-07B5-4CE2-9301-DC3C41312993__CEGFFICH">
                        <p class="titleinexample">例15-2 ROWID的隐式提取</p><pre class="oac_no_warn" dir="ltr">#include &lt;oci.h&gt; int main（）{...text * mySql =（text *）“SELECT emp_name FROM emp FOR UPDATE”; text rowid [100] [15] = {0}; text empName [100] [15] = {0}; .../ *设置环境，错误句柄等* / .../ *准备声明 - 选择...进行更新。* / if（OCIStmtPrepare（select_p，errhp，mySql，strlen（mySql），OCI_NTV_SYNTAX，OCI_DEFAULT））{printf（“Prepare failed \ n”）; return（OCI_ERROR）; / *设置在语句句柄上隐式提取ROWID的属性。* / if（OCIAttrSet（select_p，OCI_HTYPE_STMT，0,0，OCI_ATTR_FETCH_ROWID，errhp））{printf（“无法设置属性 -  OCI_ATTR_FETCH_ROWID \ n”）;返回OCI_ERROR; } / * *定义位置：0表示获取ROWID和其他位置*以获取其他列。*此外，通过以字符串格式获取* ROWID来隐式完成定义转换。* / if（OCIDefineByPos（select_p，＆defnp0，errhp，0，rowid [0]，15，SQLT_STR，（void *）ind，（void *）0，（void *）0，OCI_DEFAULT）|| OCIDefineByPos（select_p，＆defnp1 ，errhp，1，empName [0]，15，SQLT_STR，（void *）0，（void *）0，（void *）0，OCI_DEFAULT））{printf（“无法定义\ n”）; return（OCI_ERROR）; } / *执行语句。* / if（errr = OCIStmtExecute（svchp，select_p，errhp，（ub4）5，（ub4）0，（OCISnapshot *）NULL，（OCISnapshot *）NULL，（ub4）OCI_DEFAULT））{if（错误！= OCI_NO_DATA）return errr; } printf（“Column 0 \ t Column 1 \ n”）; printf（“_________ \ t ________ \ n”）; for（i = 0; i &lt;5 i ++）{printf（“％s \ t \ t％s \ n”，rowid [i]，empName [i]）; } return OCI_SUCCESS; }</pre></div>
                     <!-- class="example" -->
                  </div>
               </div>
            </div><a id="LNOCI73046"></a><a id="LNOCI73047"></a><a id="LNOCI73048"></a><a id="LNOCI73049"></a><a id="LNOCI73008"></a><div class="props_rev_3"><a id="GUID-F5BF8851-F491-4EF8-BA20-B6146AF2700F" name="GUID-F5BF8851-F491-4EF8-BA20-B6146AF2700F"></a><h3 id="LNOCI-GUID-F5BF8851-F491-4EF8-BA20-B6146AF2700F" class="sect3"><span class="enumeration_section">15.3</span> OCI对隐含结果的支持</h3>
               <div>
                  <p>从Oracle Database <span class="italic">12c</span>第1版（12.1）开始，PL / SQL可以从存储过程和匿名PL / SQL块中隐式返回结果（游标）。<code class="codeph">OCIStmtGetNextResult()</code>以检索和处理隐式结果。
                  </p>
                  <div class="section">
                     <p>PL / SQL在<code class="codeph">DBMS_SQL</code>包中提供了一个子程序<code class="codeph">RETURN_RESULT</code> ，用于返回执行语句的结果，如<a href="performance-topics.html#GUID-F5BF8851-F491-4EF8-BA20-B6146AF2700F__CEGBHFGH">例15-3</a>所示。在当前版本中，PL / SQL过程块只能隐式返回<code class="codeph">SELECT</code>查询结果集。<code class="codeph">OCIStmtGetNextResult()</code>返回一个OCI语句句柄，通常在其上执行OCI定义和获取调用以检索行。
                     </p>
                     <p><a href="performance-topics.html#GUID-F5BF8851-F491-4EF8-BA20-B6146AF2700F__CEGDFBAF">例15-4</a>显示了一个PL / SQL存储过程，用于隐式地将结果集（游标）返回给客户端。
                     </p>
                     <p><a href="performance-topics.html#GUID-F5BF8851-F491-4EF8-BA20-B6146AF2700F__CEGHGBDI">例15-5</a>显示了使用客户端发送的匿名PL / SQL块的相同方法。此示例显示应用程序如何使用隐式结果功能从OCI应用程序实现SQL语句的批处理。OCI应用程序可以动态形成PL / SQL匿名块，以执行多个和变量<code class="codeph">SELECT</code>语句，并使用<code class="codeph">DBMS_SQL.RETURN_RESULT</code>返回相应的游标。</p>
                     <p><a href="performance-topics.html#GUID-F5BF8851-F491-4EF8-BA20-B6146AF2700F__CEGIHJDF">例15-6</a>列出了一个OCI程序，它显示了如何使用<code class="codeph">OCIStmtGetNextResult()</code>调用来检索和处理PL / SQL存储过程（参见<a href="performance-topics.html#GUID-F5BF8851-F491-4EF8-BA20-B6146AF2700F__CEGDFBAF">例15-4</a> ）或匿名PL / SQL块返回的隐式结果（参见<a href="performance-topics.html#GUID-F5BF8851-F491-4EF8-BA20-B6146AF2700F__CEGHGBDI">例15） -5</a> ）。
                     </p>
                     <p>应用程序可以迭代地调用<code class="codeph">OCIStmtGetNextResult()</code> ，以从执行的PL / SQL语句中检索每个隐式结果。应用程序按顺序检索每个结果集，但可以独立地从任何结果集中获取行。顶级OCI语句句柄跟踪所有关联的结果集语句句柄。释放或释放顶级OCI语句句柄会自动关闭并释放所有隐式结果集。
                     </p>
                     <p>在OCI语句句柄上提供属性<code class="codeph">OCI_ATTR_IMPLICIT_RESULT_COUNT</code>以确定可用的隐式结果的数量。
                     </p>
                     <p><code class="codeph">OCIStmtGetNextResult()</code>的<code class="codeph">rtype</code>参数返回结果的类型。在此版本中，仅支持类型： <code class="codeph">OCI_RESULT_TYPE_SELECT</code> 。可以类似于任何<code class="codeph">SELECT</code> ResultSet访问返回结果集的描述元数据。
                     </p>
                     <div class="infoboxnote" id="GUID-F5BF8851-F491-4EF8-BA20-B6146AF2700F__GUID-3C5A3433-15B7-4882-B34E-8BE7EA95CFA6">
                        <p class="notep1">注意：</p>
                        <p>以下OCI代码也可以在外部过程中使用，以从隐式结果中获取。在这种情况下， <code class="codeph">OCI_PREP2_IMPL_RESULTS_CLIENT</code>作为模式传递给<code class="codeph">OCIStmtPrepare2()</code>调用。
                        </p>
                     </div>
                  </div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-F5BF8851-F491-4EF8-BA20-B6146AF2700F__CEGBHFGH">
                     <p class="titleinexample">例15-3 DBMS_SQL RETURN_RESULT子程序</p><pre class="oac_no_warn" dir="ltr">procedure return_result（rc in out sys_refcursor，to_client in boolean default true）; procedure return_result（rc in out integer，to_client in boolean default true）;</pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-F5BF8851-F491-4EF8-BA20-B6146AF2700F__CEGDFBAF">
                     <p class="titleinexample">示例15-4将结果集（游标）隐式返回给客户端的PL / SQL存储过程</p><pre class="oac_no_warn" dir="ltr">CREATE PROCEDURE foo AS c1 sys_refcursor; c2 sys_refcursor;从emp开始打开c1 for select *; dbms_sql.return_result（C1）; - 返回客户端 - 打开另一个光标打开c2 for select * from dept; dbms_sql.return_result（c2）; - 回到客户端;</pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-F5BF8851-F491-4EF8-BA20-B6146AF2700F__CEGHGBDI">
                     <p class="titleinexample">示例15-5匿名PL / SQL块以隐式返回结果集（游标）到客户端</p><pre class="oac_no_warn" dir="ltr">声明c1 sys_refcursor; c2 sys_refcursor;从emp开始打开c1 for select *; dbms_sql.return_result（c1）; - 返回客户端 - 打开另一个光标打开c2 for select * from dept; dbms_sql.return_result（c2）; - 回到客户端;</pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-F5BF8851-F491-4EF8-BA20-B6146AF2700F__CEGIHJDF">
                     <p class="titleinexample">示例15-6使用OCIStmtGetNextResult（）检索和处理PL / SQL存储过程或匿名块返回的隐式结果</p><pre class="oac_no_warn" dir="ltr">OCIStmt * stmthp; ub4 rsetcnt;无效*结果; ub4 rtype; char * sql =“begin foo; end;”; / *准备并执行PL / SQL过程。* / OCIStmtPrepare2（svchp，＆stmthp，errhp，（oratext *）sql，strlen（sql），NULL，0，OCI_NTV_SYNTAX，OCI_DEFAULT）; OCIStmtExecute（svchp，stmthp，errhp，1,0，（const OCISnapshot *）0，（OCISnapshot *）0，OCI_DEFAULT）; / *现在检查是否有任何隐式结果可用。* / OCIAttrGet（（void *）stmthp，OCI_HTYPE_STMT，＆rsetcnt，0，OCI_ATTR_IMPLICIT_RESULT_COUNT，errhp）; / *循环并检索隐式结果集。* ResultSet以与PL / SQL *过程/块中相同的顺序返回。* / while（OCIStmtGetNextResult（stmthp，errhp，＆result，＆rtype，OCI_DEFAULT）== OCI_SUCCESS）{/ *检查隐式ResultSet的类型，当前*仅支持的类型为OCI_RESULT_TYPE_SELECT * / if（rtype == OCI_RESULT_TYPE_SELECT）{OCIStmt * rsethp =（OCIStmt *）结果; / *执行正常的OCI操作以定义和获取行。* /} else printf（“未知结果类型％d \ n”，rtype）; / *结果集句柄不应由用户释放。* /} OCIStmtRelease（stmthp，errhp，NULL，0，OCI_DEFAULT）; / *释放语句句柄。* /</pre></div>
                  <!-- class="example" -->
                  <div class="section">
                     <div class="infoboxnotealso" id="GUID-F5BF8851-F491-4EF8-BA20-B6146AF2700F__GUID-3AAA3F6E-229F-41A2-931E-ECD008CF3B6D">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="statement-functions.html#GUID-60B998F9-F213-43BA-AB84-76F1EC6A6687" title="返回已执行的PL / SQL语句句柄的隐式结果。">OCIStmtGetNextResult（）</a></p>
                           </li>
                           <li>
                              <p><a href="handle-and-descriptor-attributes.html#GUID-A251CF91-EB9F-4DBC-8BB8-FB5EA92C20DE" title="列出并描述语句句柄属性。">语句句柄属性</a>有关属性<code class="codeph">OCI_ATTR_IMPLICIT_RESULT_COUNT</code>更多信息。</p>
                           </li>
                           <li>
                              <p><a href="statement-functions.html#GUID-E6C1DC67-D464-4D2A-9F19-737423D31779" title="准备SQL或PL / SQL语句以便执行。">OCIStmtPrepare2（）</a></p>
                           </li>
                        </ul>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div>
            </div><a id="LNOCI10103"></a><div class="props_rev_3"><a id="GUID-F8BAB50F-7D21-43C0-846D-416D34429117" name="GUID-F8BAB50F-7D21-43C0-846D-416D34429117"></a><h3 id="LNOCI-GUID-F8BAB50F-7D21-43C0-846D-416D34429117" class="sect3"><span class="enumeration_section">15.4</span>客户端结果缓存</h3>
               <div>
                  <p>OCI应用程序可以使用客户端内存来利用OCI结果缓存来改善重复查询的响应时间。</p>
                  <div class="infoboxnotealso" id="GUID-F8BAB50F-7D21-43C0-846D-416D34429117__GUID-BAC8F6A3-FA60-4DF2-901F-48EE88AC27D0">
                     <p class="notep1">也可以看看：</p>
                     <p>有关使用OCI客户端结果缓存的完整信息，请参见<a href="../adfns/performance-and-scalability.html#ADFNS213" target="_blank"><span><cite>“Oracle数据库开发指南</cite></span></a></p>
                  </div>
               </div>
            </div><a id="LNOCI73050"></a><a id="LNOCI73009"></a><div class="props_rev_3"><a id="GUID-75169FE4-DE2C-431F-BBA7-3691C7C33360" name="GUID-75169FE4-DE2C-431F-BBA7-3691C7C33360"></a><h3 id="LNOCI-GUID-75169FE4-DE2C-431F-BBA7-3691C7C33360" class="sect3"><span class="enumeration_section">15.5</span>客户端语句缓存自动调整</h3>
               <div>
                  <p>描述有关客户端语句高速缓存自动调整的主题。</p>
                  <div class="p">本节介绍以下主题：<ul style="list-style-type:disc">
                        <li>
                           <p><a href="performance-topics.html#GUID-6E21AA56-5BBE-422A-802C-197CAC8AAEA4" title="自动调整可优化中间层应用程序的OCI客户端会话功能，以获得更高的性能，而无需重新编程您的OCI应用程序。">关于自动调整客户端语句缓存</a></p>
                        </li>
                        <li>
                           <p><a href="performance-topics.html#GUID-5FA63226-6372-4A36-B36E-47141A73D036" title="自动调整客户端语句高速缓存的更具体的好处是透明地检测，监视和调整语句高速缓存大小，以提高性能或减少内存使用。">自动调整客户端语句缓存的好处</a></p>
                        </li>
                        <li>
                           <p><a href="performance-topics.html#GUID-C7D627E2-E210-4234-AF42-648E7295DA13" title="oraccess.xml中的以下连接特定参数可以按照配置别名设置，也可以使用默认的连接特定参数在所有连接字符串中设置。">客户端语句缓存自动调整参数</a></p>
                        </li>
                        <li>
                           <p><a href="performance-topics.html#GUID-A3B6A67A-9DB9-41DC-9D73-DC8557808EF0" title="以下是一些使用示例，显示了客户端语句高速缓存自动调整参数的使用和交互，这些参数也是特定于连接的参数。">客户端语句缓存自动调整的用法示例</a></p>
                        </li>
                        <li>
                           <p><a href="performance-topics.html#GUID-02A81F8A-84F7-44AB-942F-5F8BFA878289" title="描述启用和禁用OCI客户端自动调整的条件。">启用和禁用OCI客户端自动调整</a></p>
                        </li>
                        <li>
                           <p><a href="performance-topics.html#GUID-ECB2DEFC-6DCE-41C8-8A9C-162A13745E63" title="描述设置自动调整参数时使用的准则。">自动调整客户端语句缓存的使用指南</a></p>
                        </li>
                     </ul>
                  </div>
               </div><a id="LNOCI73051"></a><div class="props_rev_3"><a id="GUID-6E21AA56-5BBE-422A-802C-197CAC8AAEA4" name="GUID-6E21AA56-5BBE-422A-802C-197CAC8AAEA4"></a><h4 id="LNOCI-GUID-6E21AA56-5BBE-422A-802C-197CAC8AAEA4" class="sect4"><span class="enumeration_section">15.5.1</span>关于自动调整客户端语句缓存</h4>
                  <div>
                     <p>自动调整可优化中间层应用程序的OCI客户端会话功能，以获得更高的性能，而无需重新编程您的OCI应用程序。</p>
                     <p>在<code class="codeph">OCIStmtPrepare2()</code>和<code class="codeph">OCIStmtRelease()</code>定期调用期间，隐式地发生自动调整操作，如增加或减少高速缓存。如果需要检查，则在服务句柄上使用<code class="codeph">OCI_ATTR_STMTCACHESIZE</code>调用<code class="codeph">OCIAttrGet()</code>会使用当前缓存大小。
                     </p>
                     <p>编码的OCI客户端语句高速缓存大小设置可能是次优的。例如，这可能发生在更改工作负载导致不同的SQL语句工作集的情况下。如果大小太小，将导致过多的网络活动和服务器上的更多解析。如果尺寸太大，将使用过多的内存。客户端应用程序可能难以始终保持此高速缓存大小最佳。</p>
                     <p>自动调整会自动定期重新配置OCI语句高速缓存大小。通过提供部署时间设置来实现自动调整，该设置提供了重新配置OCI语句缓存以解决此潜在性能问题的选项。</p>
                     <p>这些设置在客户端<code class="codeph">oraaccess.xml</code>文件中作为基于连接字符串的部署设置提供，该文件将手动设置覆盖到OCI功能的用户配置。
                     </p>
                     <div class="infoboxnotealso" id="GUID-6E21AA56-5BBE-422A-802C-197CAC8AAEA4__GUID-60C0F818-4FCE-42E7-AA5A-82EBA05C4168">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="statement-functions.html#GUID-E6C1DC67-D464-4D2A-9F19-737423D31779" title="准备SQL或PL / SQL语句以便执行。">OCIStmtPrepare2（）</a></p>
                           </li>
                           <li>
                              <p><a href="statement-functions.html#GUID-256034CE-2ADB-4BE5-BC8D-748307F2EA8E" title="释放通过调用OCIStmtPrepare2（）获得的语句句柄。">OCIStmtRelease（）</a></p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="LNOCI73010"></a><div class="props_rev_3"><a id="GUID-5FA63226-6372-4A36-B36E-47141A73D036" name="GUID-5FA63226-6372-4A36-B36E-47141A73D036"></a><h4 id="LNOCI-GUID-5FA63226-6372-4A36-B36E-47141A73D036" class="sect4"><span class="enumeration_section">15.5.2</span>自动调整客户端语句缓存的好处</h4>
                  <div>
                     <p>自动调整客户端语句高速缓存的更具体的好处是透明地检测，监视和调整语句高速缓存大小，以提高性能或减少内存使用。</p>
                     <p>开发人员和DBA可以期望看到为其OCI客户端应用程序使用自动调整的以下好处：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>减少诊断和修复系统各部分性能问题的时间和精力，例如语句缓存</p>
                        </li>
                        <li>
                           <p>最小化手动修改以配置此OCI功能以提高性能。通常，此手动更正要求应用程序使用不同的配置参数重新启动多次，从而进一步降低客户端的高可用性</p>
                        </li>
                        <li>
                           <p>所有OCI应用程序都可以使用一种解决方案，即使在开箱即用的情况下也可以提高性能，而无需进行任何应用程序更改</p>
                        </li>
                        <li>
                           <p>OCI应用程序可以自由调整其OCI应用程序以优化性能和内存使用，从而无需进行自定义实现（可能容易出错）。此处自动调整仅限于OCI客户端语句高速缓存大小的内部自动调整。</p>
                        </li>
                     </ul>
                  </div>
               </div><a id="LNOCI73011"></a><div class="props_rev_3"><a id="GUID-C7D627E2-E210-4234-AF42-648E7295DA13" name="GUID-C7D627E2-E210-4234-AF42-648E7295DA13"></a><h4 id="LNOCI-GUID-C7D627E2-E210-4234-AF42-648E7295DA13" class="sect4"><span class="enumeration_section">15.5.3</span>客户端语句缓存自动调整参数</h4>
                  <div>
                     <p><code class="codeph">oraccess.xml</code>的以下连接特定参数可以按照配置别名设置，也可以使用默认的连接特定参数在所有连接字符串中设置。
                     </p>
                     <p>客户端<code class="codeph">oraaccess.xml</code>配置文件中指定的值将覆盖编程设置。
                     </p>
                     <div class="p">本节包括以下主题：<ul style="list-style-type:disc">
                           <li>
                              <p><a href="performance-topics.html#GUID-C69F99D2-2EAC-4A5E-BD7D-7266765C45C2" title="此参数是可选的，并设置语句高速缓存可调组件的限制。">&lt;statement_cache&gt;</a></p>
                           </li>
                           <li>
                              <p><a href="performance-topics.html#GUID-12F398F1-FEB6-490F-B7A3-7BAE48DCA8D4" title="本节指定自动调整参数。">&lt;auto_tune&gt;</a></p>
                           </li>
                           <li>
                              <p><a href="performance-topics.html#GUID-53634FE6-85C0-4C37-92FF-FB711676F82A" title="列出并描述所有自动调整参数的比较。">连接特定自动调整参数的比较</a></p>
                           </li>
                        </ul>
                     </div>
                     <div class="infoboxnotealso" id="GUID-C7D627E2-E210-4234-AF42-648E7295DA13__GUID-72B2DFC5-E5BA-4D68-BE39-716A87B8FF14">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="build-and-configure-oci-applications.html#GUID-6C76054A-0E0A-4783-B00D-9B65C80C24B0" title="描述可以为跨连接共享的连接参数设置的默认值。">关于为连接参数指定默认值</a>有关使用默认连接特定参数设置每个配置别名或所有连接字符串的详细信息</p>
                     </div>
                  </div><a id="LNOCI73013"></a><div class="props_rev_3"><a id="GUID-C69F99D2-2EAC-4A5E-BD7D-7266765C45C2" name="GUID-C69F99D2-2EAC-4A5E-BD7D-7266765C45C2"></a><h5 id="LNOCI-GUID-C69F99D2-2EAC-4A5E-BD7D-7266765C45C2" class="sect5"><span class="enumeration_section">15.5.3.1</span> &lt;statement_cache&gt;</h5>
                     <div>
                        <p>此参数是可选的，并设置语句高速缓存可调组件的限制。</p>
                        <div class="section"><pre class="oac_no_warn" dir="ltr">&lt;statement_cache&gt; &lt;size&gt; 100 &lt;/ size&gt; &lt;/ statement_cache&gt;</pre><p>限制是每个会话可以缓存的最大语句数。如果启用了自动调整，则<code class="codeph">oraaccess.xml</code>此设置<code class="codeph">oraaccess.xml</code>覆盖OCI语句高速缓存大小的编程设置。
                           </p>
                           <p>如果启用了自动调整，则此设置将是语句高速缓存大小的上限，同时进行动态调整。</p>
                           <p>如果会话未使用<code class="codeph">OCIStmtPrepare2()</code>和<code class="codeph">OCIStmtRelease()</code>语句缓存API，则忽略此设置。
                           </p>
                           <p>默认值如下：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>如果启用了自动调整，则会动态调整语句高速缓存，并将初始语句高速缓存大小设置为100个语句。</p>
                              </li>
                              <li>
                                 <p>如果禁用自动调整，则此设置将用作语句缓存大小的部署设置，从而覆盖任何编程设置。</p>
                              </li>
                           </ul>
                           <div class="infoboxnotealso" id="GUID-C69F99D2-2EAC-4A5E-BD7D-7266765C45C2__GUID-56565C29-4873-4D32-82E5-A6001ABBB805">
                              <p class="notep1">也可以看看：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p><a href="statement-functions.html#GUID-E6C1DC67-D464-4D2A-9F19-737423D31779" title="准备SQL或PL / SQL语句以便执行。">OCIStmtPrepare2（）</a></p>
                                 </li>
                                 <li>
                                    <p><a href="statement-functions.html#GUID-256034CE-2ADB-4BE5-BC8D-748307F2EA8E" title="释放通过调用OCIStmtPrepare2（）获得的语句句柄。">OCIStmtRelease（）</a></p>
                                 </li>
                                 <li>
                                    <p><a href="performance-topics.html#GUID-02A81F8A-84F7-44AB-942F-5F8BFA878289" title="描述启用和禁用OCI客户端自动调整的条件。">启用和禁用OCI客户端自动调整</a></p>
                                 </li>
                              </ul>
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNOCI73012"></a><div class="props_rev_3"><a id="GUID-12F398F1-FEB6-490F-B7A3-7BAE48DCA8D4" name="GUID-12F398F1-FEB6-490F-B7A3-7BAE48DCA8D4"></a><h5 id="LNOCI-GUID-12F398F1-FEB6-490F-B7A3-7BAE48DCA8D4" class="sect5"><span class="enumeration_section">15.5.3.2</span> &lt;auto_tune&gt;</h5>
                     <div>
                        <p>本节指定自动调整参数。</p>
                        <div class="section">
                           <p>如果OCI会话未使用<code class="codeph">OCIStmtPrepare2()</code>或<code class="codeph">OCIStmtRelease()</code>语句缓存API，则会话将忽略自动调整参数。在某个过程中，某些会话或连接可以启用自动调整，某些会话或连接可以禁用。
                           </p>
                           <div class="p">本节包括以下主题：<ul style="list-style-type:disc">
                                 <li>
                                    <p><a href="performance-topics.html#GUID-D02F22EA-9A36-4672-AE22-85C5CBD3691B" title="此参数可打开或关闭自动调谐。">&lt;启用&gt;真&lt;/启用&gt;</a></p>
                                 </li>
                                 <li>
                                    <p><a href="performance-topics.html#GUID-93048857-C168-4BA9-A126-CE06DA8F2D33" title="此参数是可选的。">&lt;ram_threshold&gt;</a></p>
                                 </li>
                                 <li>
                                    <p><a href="performance-topics.html#GUID-F624661F-FAC7-41F7-8F41-F2451EC2B47F" title="此参数是可选的。">&lt;MEMORY_TARGET&gt;</a></p>
                                 </li>
                              </ul>
                           </div>
                           <div class="infoboxnotealso" id="GUID-12F398F1-FEB6-490F-B7A3-7BAE48DCA8D4__GUID-1A20E822-01D1-45FE-9890-18293AD02F03">
                              <p class="notep1">也可以看看：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p><a href="statement-functions.html#GUID-E6C1DC67-D464-4D2A-9F19-737423D31779" title="准备SQL或PL / SQL语句以便执行。">OCIStmtPrepare2（）</a></p>
                                 </li>
                                 <li>
                                    <p><a href="statement-functions.html#GUID-256034CE-2ADB-4BE5-BC8D-748307F2EA8E" title="释放通过调用OCIStmtPrepare2（）获得的语句句柄。">OCIStmtRelease（）</a></p>
                                 </li>
                              </ul>
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div class="props_rev_3"><a id="GUID-D02F22EA-9A36-4672-AE22-85C5CBD3691B" name="GUID-D02F22EA-9A36-4672-AE22-85C5CBD3691B"></a><h6 id="LNOCI-GUID-D02F22EA-9A36-4672-AE22-85C5CBD3691B" class="sect6"><span class="enumeration_section">15.5.3.2.1</span> &lt;enable&gt; true &lt;/ enable&gt;</h6>
                        <div>
                           <p>此参数可打开或关闭自动调谐。</p>
                           <div class="section">
                              <p>默认为自动关闭<code class="codeph">(FALSE)</code>或禁用。
                              </p><pre class="oac_no_warn" dir="ltr">&lt;auto_tune&gt; &lt;enable&gt; true &lt;/ enable&gt; &lt;/ auto_tune&gt;</pre><p>启用自动调整以及内部默认设置。</p>
                              <div class="infoboxnotealso" id="GUID-D02F22EA-9A36-4672-AE22-85C5CBD3691B__GUID-6B0FCBAB-4D02-4440-AF48-9A0DAC8EB40F">
                                 <p class="notep1">也可以看看：</p>
                                 <p><a href="performance-topics.html#GUID-C69F99D2-2EAC-4A5E-BD7D-7266765C45C2" title="此参数是可选的，并设置语句高速缓存可调组件的限制。">&lt;statement_cache&gt;</a>有关自动调整的更多信息以及内部默认设置已启用</p>
                              </div>
                           </div>
                           <!-- class="section" -->
                        </div>
                     </div><a id="LNOCI73058"></a><div class="props_rev_3"><a id="GUID-93048857-C168-4BA9-A126-CE06DA8F2D33" name="GUID-93048857-C168-4BA9-A126-CE06DA8F2D33"></a><h6 id="LNOCI-GUID-93048857-C168-4BA9-A126-CE06DA8F2D33" class="sect6"><span class="enumeration_section">15.5.3.2.2</span> &lt;ram_threshold&gt;</h6>
                        <div>
                           <p>此参数是可选的。</p>
                           <div class="section"><pre class="oac_no_warn" dir="ltr">&lt;auto_tune&gt; &lt;enable&gt; true &lt;/ enable&gt; &lt;ram_threshold&gt; 0.1 &lt;/ ram_threshold&gt; &lt;/ auto_tune&gt;</pre><p>默认值为0.01％。它被指定为已安装RAM的百分比。这指定了共享此设置的进程中自动调整会话中可用的总内存。可以按进程或每个连接字符串别名指定此设置。</p>
                              <p>请注意，如果按连接字符串别名指定，则客户端进程使用的总自动调整内存可以相加。</p>
                              <p>因此，最好在<code class="codeph">oraaccess.xml</code>文件的<code class="codeph">&lt;default_parameters&gt;</code>部分中指定自动调整限制。这样，您就可以为客户端进程中的所有会话创建公共内存池。
                              </p>
                              <p>较小的限制使用较少的RAM进行自动调整，但最大限度地减少了系统上运行的其他程序在性能方面不会降低的可能性。</p>
                              <p>必须在<code class="codeph">&lt;auto_tune&gt;&lt;/auto_tune&gt;</code>部署设置中指定此参数。
                              </p>
                              <div class="infoboxnotealso" id="GUID-93048857-C168-4BA9-A126-CE06DA8F2D33__GUID-D9D4A61A-66CC-476E-AABF-DC489C9FD8F9">
                                 <p class="notep1">也可以看看：</p>
                                 <p><a href="build-and-configure-oci-applications.html#GUID-CD599644-135A-4116-8B3B-40A9BA172E5C" title="从Oracle Database Release 12c第1版（12.1）开始，Oracle提供了oraaccess.xml文件，即客户端配置文件。">关于oraaccess.xml</a></p>
                              </div>
                           </div>
                           <!-- class="section" -->
                        </div>
                     </div><a id="LNOCI73057"></a><div class="props_rev_3"><a id="GUID-F624661F-FAC7-41F7-8F41-F2451EC2B47F" name="GUID-F624661F-FAC7-41F7-8F41-F2451EC2B47F"></a><h6 id="LNOCI-GUID-F624661F-FAC7-41F7-8F41-F2451EC2B47F" class="sect6"><span class="enumeration_section">15.5.3.2.3</span> &lt;memory_target&gt;</h6>
                        <div>
                           <p>此参数是可选的。</p>
                           <div class="section"><pre class="oac_no_warn" dir="ltr">&lt;auto_tune&gt; &lt;enable&gt; true &lt;/ enable&gt; &lt;memory_target&gt; 40M &lt;/ memory_target&gt; &lt;/ auto_tune&gt;</pre><p>以字节为单位指定。默认值未定义。它指定共享此设置的进程中自动调整会话中可用的总内存。可以按进程或每个连接字符串别名指定此设置。</p>
                              <p>请注意，如果按连接字符串别名指定，则客户端进程使用的总自动调整内存可以相加。</p>
                              <p>因此，最好在<code class="codeph">oraaccess.xml</code>文件的<code class="codeph">&lt;default_parameters&gt;</code>部分中指定自动调整限制。这样，您就可以为客户端进程中的所有会话创建公共内存池。
                              </p>
                              <p>必须在<code class="codeph">&lt;auto_tune&gt;&lt;/auto_tune&gt;</code>部署设置中指定此参数。
                              </p>
                              <p>使用此参数可确保使用一致的内存限制进行自动调整，而不管该系统上安装的RAM是什么。</p>
                              <p>如果未指定，则自动调整内存限制基于<code class="codeph">&lt;ram_threshold&gt;</code>参数设置。
                              </p>
                              <p>如果同时指定了<code class="codeph">&lt;ram_threshold&gt;</code>和<code class="codeph">&lt;memory_target&gt;</code>参数，则有效限制是两个参数中的最小值。
                              </p>
                              <div class="infoboxnotealso" id="GUID-F624661F-FAC7-41F7-8F41-F2451EC2B47F__GUID-5B2CC834-9233-4AC8-90A2-6CD14889A4CC">
                                 <p class="notep1">也可以看看：</p>
                                 <p><a href="build-and-configure-oci-applications.html#GUID-CD599644-135A-4116-8B3B-40A9BA172E5C" title="从Oracle Database Release 12c第1版（12.1）开始，Oracle提供了oraaccess.xml文件，即客户端配置文件。">关于oraaccess.xml</a></p>
                              </div>
                           </div>
                           <!-- class="section" -->
                        </div>
                     </div>
                  </div><a id="LNOCI73019"></a><div class="props_rev_3"><a id="GUID-53634FE6-85C0-4C37-92FF-FB711676F82A" name="GUID-53634FE6-85C0-4C37-92FF-FB711676F82A"></a><h5 id="LNOCI-GUID-53634FE6-85C0-4C37-92FF-FB711676F82A" class="sect5"><span class="enumeration_section">15.5.3.3</span>连接特定自动调整参数的比较</h5>
                     <div>
                        <p>列出并描述所有自动调整参数的比较。</p>
                        <div class="section">
                           <p><a href="performance-topics.html#GUID-53634FE6-85C0-4C37-92FF-FB711676F82A__CEGJIEJE" title="描述所有自动调整参数的比较。该表由3列组成。第1列是自动调整参数名称，第2列是设置信息及其语义，第3列表示参数是用于自动调整还是部署设置。">表15-1</a>显示了特定于连接的自动调整参数的比较。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="tblformalwide" id="GUID-53634FE6-85C0-4C37-92FF-FB711676F82A__CEGJIEJE">
                           <p class="titleintable">表15-1某些特定于连接的自动调整参数的比较</p>
                           <table cellpadding="4" cellspacing="0" class="FormalWide" title="某些连接特定自动调整参数的比较" width="100%" border="1" summary="Describes a comparison of all auto-tuning parameters. The table consists of 3 columns. Column 1 is the auto-tuning parameter name, column 2 is the setting information and its semantics, and column 3 indicates whether the parameter is for auto-tuning or deployment setting." frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="36%" id="d131832e5375">参数</th>
                                    <th align="left" valign="bottom" width="27%" id="d131832e5378">设置和语义</th>
                                    <th align="left" valign="bottom" width="36%" id="d131832e5381">用于自动调整或部署设置</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="36%" id="d131832e5386" headers="d131832e5375 ">
                                       <p><code class="codeph">&lt;statement_cache&gt;</code></p>
                                    </td>
                                    <td align="left" valign="top" width="27%" headers="d131832e5386 d131832e5378 ">
                                       <p>可选设置。</p>
                                       <p>每个会话缓存大小。</p>
                                    </td>
                                    <td align="left" valign="top" width="36%" headers="d131832e5386 d131832e5381 ">
                                       <p>如果启用了自动调整（请参阅<span class="q">“ <a href="performance-topics.html#GUID-02A81F8A-84F7-44AB-942F-5F8BFA878289" title="描述启用和禁用OCI客户端自动调整的条件。">启用和禁用OCI客户端自动调整</a> ”</span> ），则这是每个会话语句高速缓存大小的上限，同时通过自动调整进行调整。
                                       </p>
                                       <p>否则它指的是语句缓存的部署设置。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="36%" id="d131832e5408" headers="d131832e5375 ">
                                       <p><code class="codeph">&lt;auto_tune&gt;</code></p>
                                    </td>
                                    <td align="left" valign="top" width="27%" headers="d131832e5408 d131832e5378 ">
                                       <p>可选设置。</p>
                                       <p>指定此参数以使用自动调整。如果指定了null connect string，则适用于使用此连接字符串的所有连接或所有连接。</p>
                                    </td>
                                    <td align="left" valign="top" width="36%" headers="d131832e5408 d131832e5381 ">
                                       <p>只有自动调整相关</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="36%" id="d131832e5421" headers="d131832e5375 ">
                                       <p><code class="codeph">&lt;ram_threshold&gt;</code> <code class="codeph">0.1&lt;/ram_threshold&gt;</code></p>
                                    </td>
                                    <td align="left" valign="top" width="27%" headers="d131832e5421 d131832e5378 ">
                                       <p>可选设置。</p>
                                       <p>根据该客户端或中间层系统上安装的RAM将百分比设置转换为内存值。</p>
                                       <p>这是用于客户端进程内自动调整的内存上限。</p>
                                       <p>对于已安装的8GB RAM，未指定此参数会在会话中提供800 KB的内存。</p>
                                       <p>请注意，每个连接都可能有自己的自动调整参数设置，因此这些值可以根据配置设置累加整个过程。因此最好在<code class="codeph">oraaccess.xml</code>文件的<code class="codeph">&lt;default_parameters&gt;</code>部分中使用此参数。有关语法的说明，请参阅<span class="q">“ <a href="build-and-configure-oci-applications.html#GUID-B8A13EE4-0D42-4856-A4F4-FE438650D691" title="为简单起见，列出了有关oraaccess.xml文件语法的一些高级规则。">文件（oraaccess.xml）属性</a> ”</span> 。
                                       </p>
                                    </td>
                                    <td align="left" valign="top" width="36%" headers="d131832e5421 d131832e5381 ">
                                       <p>只有自动调整相关。如果禁用自动调整，则忽略此参数设置。必须在<code class="codeph">&lt;auto_tune&gt;&lt;/auto_tune&gt;</code>部署设置中指定此参数。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="36%" id="d131832e5462" headers="d131832e5375 ">
                                       <p><code class="codeph">&lt;MEMORY_TARGET&gt; 1048576 &lt;/ MEMORY_TARGET&gt;</code></p>
                                    </td>
                                    <td align="left" valign="top" width="27%" headers="d131832e5462 d131832e5378 ">
                                       <p>可选设置。</p>
                                       <p>这是用于客户端进程内自动调整的内存上限。</p>
                                       <p>请注意，每个连接都可能有自己的自动调整参数设置，因此这些值可以根据配置设置累加整个过程。因此最好在<code class="codeph">oraaccess.xml</code>文件的<code class="codeph">&lt;default_parameters&gt;</code>部分中使用此参数。
                                       </p>
                                       <p>有关语法的说明，请参阅<span class="q">“ <a href="build-and-configure-oci-applications.html#GUID-B8A13EE4-0D42-4856-A4F4-FE438650D691" title="为简单起见，列出了有关oraaccess.xml文件语法的一些高级规则。">文件（oraaccess.xml）属性</a> ”</span> 。
                                       </p>
                                       <p>值以字节为单位。 1,048,576字节是1 MB。</p>
                                    </td>
                                    <td align="left" valign="top" width="36%" headers="d131832e5462 d131832e5381 ">
                                       <p>只有自动调整相关。如果禁用自动调整，则忽略此参数设置。必须在<code class="codeph">&lt;auto_tune&gt;&lt;/auto_tune&gt;</code>部署设置中指定此参数。
                                       </p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                     </div>
                  </div>
               </div><a id="LNOCI73020"></a><div class="props_rev_3"><a id="GUID-A3B6A67A-9DB9-41DC-9D73-DC8557808EF0" name="GUID-A3B6A67A-9DB9-41DC-9D73-DC8557808EF0"></a><h4 id="LNOCI-GUID-A3B6A67A-9DB9-41DC-9D73-DC8557808EF0" class="sect4"><span class="enumeration_section">15.5.4</span>客户端语句缓存自动调整的使用示例</h4>
                  <div>
                     <p>以下是一些使用示例，显示了客户端语句高速缓存自动调整参数的使用和交互，这些参数也是特定于连接的参数。</p><pre class="oac_no_warn" dir="ltr">&lt;statement_cache&gt; &lt;size&gt; 100 &lt;/ size&gt; &lt;/ statement_cache&gt;</pre><p>程序语句高速缓存大小将替换为此设置。禁用自动调整，并根据LRU管理缓存。在这种情况下，应用程序开发人员认为不需要覆盖OCI应用程序语句预取程序设置。</p><pre class="oac_no_warn" dir="ltr">&lt;auto_tune&gt; &lt;enable&gt; true &lt;/ enable&gt; &lt;/ auto_tune&gt;</pre><p>启用自动调整以及内部默认设置。</p><pre class="oac_no_warn" dir="ltr">&lt;statement_cache&gt; &lt;size&gt; 100 &lt;/ size&gt; &lt;/ statement_cache&gt; &lt;auto_tune&gt; &lt;enable&gt; true &lt;/ enable&gt; &lt;memory_target&gt; 40M &lt;/ memory_target&gt; &lt;/ auto_tune&gt;</pre><p>此语句缓存部署设置为100将替换程序语句高速缓存大小，并且由于启用了自动调整，因此将自动调整语句高速缓存。内存目标设置有效，因为启用了自动调整。</p>
                     <p>自动调整将始终尝试限制内存目标周围使用的总语句高速缓存内存。如果未指定内存目标，则它基于总安装RAM的百分比。</p>
                     <p>在这种情况下，内存限制是指定的内存目标。</p>
                     <div class="infoboxnotealso" id="GUID-A3B6A67A-9DB9-41DC-9D73-DC8557808EF0__GUID-3C52903D-1A11-4326-B93E-4F5381BA5114">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="performance-topics.html#GUID-C69F99D2-2EAC-4A5E-BD7D-7266765C45C2" title="此参数是可选的，并设置语句高速缓存可调组件的限制。">&lt;statement_cache&gt;</a>有关自动调整的更多信息以及内部默认设置已启用</p>
                     </div>
                  </div>
               </div><a id="LNOCI73025"></a><div class="props_rev_3"><a id="GUID-02A81F8A-84F7-44AB-942F-5F8BFA878289" name="GUID-02A81F8A-84F7-44AB-942F-5F8BFA878289"></a><h4 id="LNOCI-GUID-02A81F8A-84F7-44AB-942F-5F8BFA878289" class="sect4"><span class="enumeration_section">15.5.5</span>启用和禁用OCI客户端自动调整</h4>
                  <div>
                     <p>描述启用和禁用OCI客户端自动调整的条件。</p>
                     <p>以下条件启用和禁用OCI客户端自动调整：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>添加客户端<code class="codeph">oraaccess.xml</code> <code class="codeph">&lt;auto_tune&gt;</code>部分并启用指定为true， <code class="codeph">&lt;enable&gt;true&lt;/enable&gt;</code>时，将启用自动调整</p>
                        </li>
                        <li>
                           <p>自动调谐默认禁用或启用时被设置为假，&lt;启用&gt;假&lt;/启用&gt;在<code class="codeph">oraaccess.xml</code>下<code class="codeph">&lt;auto_tune&gt;</code>部。
                           </p>
                        </li>
                     </ul>
                  </div>
               </div><a id="LNOCI73022"></a><div class="props_rev_3"><a id="GUID-ECB2DEFC-6DCE-41C8-8A9C-162A13745E63" name="GUID-ECB2DEFC-6DCE-41C8-8A9C-162A13745E63"></a><h4 id="LNOCI-GUID-ECB2DEFC-6DCE-41C8-8A9C-162A13745E63" class="sect4"><span class="enumeration_section">15.5.6</span>自动调整客户端语句缓存的使用指南</h4>
                  <div>
                     <p>描述设置自动调整参数时使用的准则。</p>
                     <p>以下是设置自动调整参数时要使用的一些准则：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>当客户端响应，内存分配或客户端CPU很高并且您希望在不重建OCI应用程序的情况下获得性能时，可以使用<code class="codeph">&lt;auto_tune&gt;</code>设置或部署<code class="codeph">&lt;statement_cache&gt;</code>设置。自动调整还可以减少客户端和服务器之间传输的网络字节数。
                           </p>
                        </li>
                        <li>
                           <p>当AWR或ADDM报告大量解析但您不能或者您可能不希望以编程方式修改语句高速缓存大小时，可以指定语句高速缓存的自动调整或使用部署语句高速缓存设置<code class="codeph">&lt;statement_cache&gt;</code> 。
                           </p>
                        </li>
                     </ul>
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>