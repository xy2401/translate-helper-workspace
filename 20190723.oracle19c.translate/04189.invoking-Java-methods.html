<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <title>调用Java方法</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Java Developer&#39;s Guide "></meta>
      <meta property="og:description" content=""></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Java Developer&#39;s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="java-developers-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-11T00:55:24-08:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="1999, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96468-01"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="calling-Java-methods.html" title="Previous" type="text/html"></link>
      <link rel="next" href="running-on-server.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Java Developer&#39;s Guide"></meta>
    <meta name="dcterms.isVersionOf" content="JJDEV"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="calling-Java-methods.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="running-on-server.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">Java开发人员指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="calling-Java-methods.html" property="item" typeof="WebPage"><span property="name">在Oracle数据库中调用Java方法</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">调用Java方法</li>
            </ol>
            <a id="GUID-21F89FA2-D947-42C1-B16A-6722A219EBDA" name="GUID-21F89FA2-D947-42C1-B16A-6722A219EBDA"></a><a id="JJDEV13166"></a>
            
            <h2 id="JJDEV-GUID-21F89FA2-D947-42C1-B16A-6722A219EBDA" class="sect2"><span class="enumeration_section">3.1</span>调用Java方法</h2>
         </header>
         <div class="ind">
            <div>
               <div class="section">
                  <p>Java应用程序的类型确定客户端如何调用Java方法。以下部分讨论可用于调用Java方法的每个Java应用程序编程接口（API）：</p>
               </div>
               <!-- class="section" -->
               <div class="section">
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="invoking-Java-methods.html#GUID-EF778216-F348-4FA4-9862-3D0BCD7DB8AC">使用PL / SQL Wrappers</a></p>
                     </li>
                     <li>
                        <p><a href="invoking-Java-methods.html#GUID-D8B14DA6-B657-4830-ABC1-5A86067FB4E9">关于JNI支持</a></p>
                     </li>
                     <li>
                        <p><a href="invoking-Java-methods.html#GUID-2FEF0F2D-0A6D-422B-B1D1-0F5B9AD6C117">关于在数据库中使用SQLJ和JDBC与Java</a></p>
                     </li>
                     <li>
                        <p><a href="invoking-Java-methods.html#GUID-FC2894A1-87C3-4695-968E-A3E69344B353">关于使用命令行界面</a></p>
                     </li>
                     <li>
                        <p><a href="invoking-Java-methods.html#GUID-E081FA25-FAF4-48BE-A84E-05359631C532">使用客户端存根概述</a></p>
                     </li>
                  </ul>
               </div>
               <!-- class="section" -->
            </div><a id="JJDEV13167"></a><div class="props_rev_3"><a id="GUID-EF778216-F348-4FA4-9862-3D0BCD7DB8AC" name="GUID-EF778216-F348-4FA4-9862-3D0BCD7DB8AC"></a><h3 id="JJDEV-GUID-EF778216-F348-4FA4-9862-3D0BCD7DB8AC" class="sect3"><span class="enumeration_section">3.1.1</span>使用PL / SQL Wrappers</h3>
               <div>
                  <div class="section">
                     <p><a id="d19599e218" class="indexterm-anchor"></a>您可以像PL / SQL存储过程一样运行Java存储过程。在Oracle数据库中，Java通常通过PL / SQL接口调用。
                     </p>
                     <p>要调用Java存储过程，必须通过a发布它<a id="d19599e225" class="indexterm-anchor"></a>通话规范。以下示例说明如何创建，解析，加载和发布返回字符串的简单Java存储过程：</p>
                  </div>
                  <!-- class="section" -->
                  <ol>
                     <li class="stepexpand"><span>定义一个类<code class="codeph">Hello</code> ，如下所示：</span><div><pre class="oac_no_warn" dir="ltr">public class Hello {public static String world（）{return“Hello world”; }}</pre><p>将文件另存为<code class="codeph">Hello.java</code>文件。
                           </p>
                        </div>
                     </li>
                     <li class="stepexpand"><span>使用标准Java编译器在客户端系统上编译类，如下所示：</span><div><pre class="oac_no_warn" dir="ltr">javac Hello.java</pre><p>使用<code class="codeph">javac</code>命令在命令行上指定<code class="codeph">CLASSPATH</code>是个好主意，尤其是在编写shell脚本或make文件时。Java编译器生成Java二进制文件，在本例中为<code class="codeph">Hello.class</code> 。
                           </p>
                           <p>您必须确定此Java代码的运行位置。如果在客户端系统上运行<code class="codeph">Hello.class</code> ，那么它会在<code class="codeph">CLASSPATH</code>搜索<code class="codeph">Hello.class</code>运行所需的所有支持核心类。此搜索应导致在以下之一中定位依赖类：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>作为一个或多个目录中的单个文件，其中目录在<code class="codeph">CLASSPATH</code>中指定</p>
                              </li>
                              <li>
                                 <p>在<code class="codeph">.jar</code>或<code class="codeph">.zip</code>文件中，其中包含这些文件的目录在<code class="codeph">CLASSPATH</code>中指定</p>
                              </li>
                           </ul>
                        </div>
                     </li>
                     <li class="stepexpand"><span><a id="d19599e290" class="indexterm-anchor"></a>确定<code class="codeph">Hello</code>类的解析器。</span><div>
                           <p>在这种情况下，在服务器上加载<code class="codeph">Hello.class</code> ，它作为Java模式对象存储在数据库中。当您调用<code class="codeph">world()</code>方法时，Oracle JVM使用解析程序找到必要的支持类，例如<code class="codeph">String</code> 。在这种情况下，Oracle JVM使用默认解析程序。默认解析器首先在当前架构中查找这些类，然后在<code class="codeph">PUBLIC</code>查找。所有核心类库，包括<code class="codeph">java.lang</code>包，都可以在<code class="codeph">PUBLIC</code>中找到。您可能需要指定不同的解析器。通过在使用<code class="codeph">loadjava</code>工具时强制解决问题，可以更早地而不是在运行时跟踪问题。
                           </p>
                        </div>
                     </li>
                     <li class="stepexpand"><span><a id="d19599e325" class="indexterm-anchor"></a>使用<code class="codeph">loadjava</code>工具在服务器上加载类。您必须指定用户名和密码。运行<code class="codeph">loadjava</code>工具，如下所示：</span><div><pre class="oac_no_warn" dir="ltr">loadjava -user HR Hello.class密码： <span class="italic">密码</span>
</pre></div>
                     </li>
                     <li class="stepexpand"><span><a id="d19599e344" class="indexterm-anchor"></a>通过调用规范发布存储过程。</span><div>
                           <p>要使用SQL调用调用Java <code class="codeph">static</code>方法，必须使用调用规范发布该方法。调用规范定义了该方法采用的参数以及它返回的SQL类型。
                           </p>
                           <p>在SQL * Plus中，连接到数据库并为<code class="codeph">Hello.world()</code>定义顶级调用规范，如下所示：</p><pre class="oac_no_warn" dir="ltr">sqlplus HR输入密码： <span class="italic">密码</span>连接SQL&gt; CREATE OR REPLACE FUNCTION helloworld RETURN VARCHAR2 AS 2 LANGUAGE JAVA NAME'Hello.world（）返回java.lang。串'; 3 /创建功能。
</pre></div>
                     </li>
                     <li class="stepexpand"><span>调用存储过程，如下所示：</span><div><pre class="oac_no_warn" dir="ltr">SQL&gt; VARIABLE myString VARCHAR2（20）; SQL&gt; CALL helloworld（）INTO：myString;通话完成。SQL&gt; PRINT myString; MYSTRING --------------------------------------- Hello world SQL&gt;</pre><p><code class="codeph">call helloworld() into :myString</code>语句在Oracle数据库中执行顶级调用。SQL和PL / SQL在使用Java，PL / SQL或任何其他语言编写的存储过程之间没有区别。呼叫规范提供了以一致的方式将语言间呼叫联系在一起的方法。只有通过触发器或SQL和PL / SQL调用调用的入口点才需要调用规范。此外，JDeveloper可以自动完成编写调用规范的任务。
                           </p>
                        </div>
                     </li>
                  </ol>
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="preparing-Java-class-methods.html#GUID-F17E6450-17E3-49EE-9258-EF5E01748198">解决类依赖关系概述</a></li>
                        <li><a href="schema-objects-and-Oracle-JVM-utilities.html#GUID-2A76FBC2-3A4A-4620-9A83-CA01724B13DB">架构对象和Oracle JVM实用程序</a></li>
                        <li><a href="developing-Java-stored-procedures.html#GUID-AE1E5C4B-A077-4D1E-8821-6A7142BF1FEA">开发Java存储过程</a></li>
                     </ul>
                  </div>
               </div>
               
            </div><a id="JJDEV13168"></a><div class="props_rev_3"><a id="GUID-D8B14DA6-B657-4830-ABC1-5A86067FB4E9" name="GUID-D8B14DA6-B657-4830-ABC1-5A86067FB4E9"></a><h3 id="JJDEV-GUID-D8B14DA6-B657-4830-ABC1-5A86067FB4E9" class="sect3"><span class="enumeration_section">3.1.2</span>关于JNI支持</h3>
               <div>
                  <div class="section">
                     <p>该<a id="d19599e487" class="indexterm-anchor"></a><a id="d19599e489" class="indexterm-anchor"></a> Java Native Interface（JNI）是一个标准的编程接口，用于编写Java本机方法并将JVM嵌入到本机应用程序中。JNI的主要目标是提供使用特定于平台的本机库的Java应用程序的二进制兼容性。
                     </p>
                     <p>本机方法可能导致服务器故障，违反安全性和损坏数据。Oracle数据库不支持在Java应用程序中使用JNI。如果您使用JNI，那么您的应用程序不是100％纯Java，而本机方法需要在平台之间移植。</p>
                  </div>
                  <!-- class="section" -->
               </div>
            </div><a id="JJDEV13169"></a><div class="props_rev_3"><a id="GUID-2FEF0F2D-0A6D-422B-B1D1-0F5B9AD6C117" name="GUID-2FEF0F2D-0A6D-422B-B1D1-0F5B9AD6C117"></a><h3 id="JJDEV-GUID-2FEF0F2D-0A6D-422B-B1D1-0F5B9AD6C117" class="sect3"><span class="enumeration_section">3.1.3</span>关于在数据库中使用SQLJ和JDBC和Java</h3>
               <div>
                  <div class="section">
                     <p>您可以从Java客户端使用SQLJ和Java数据库连接（JDBC）API。两个API都在数据库上建立具有给定用户名和密码的会话，并对数据库运行SQL查询。下表列出了API及其说明：</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <div class="tblformal" id="GUID-2FEF0F2D-0A6D-422B-B1D1-0F5B9AD6C117__GUID-5CD499FE-4A8A-4F33-8104-EDC390567CAF">
                        <table cellpadding="4" cellspacing="0" class="Formal" title="" width="100%" border="1" summary="The left column of this table lists the APIs to use from a Java client. The right column describes the particular API." frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="19%" id="d19599e596">API</th>
                                 <th align="left" valign="bottom" width="81%" id="d19599e599">描述</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="19%" id="d19599e604" headers="d19599e596 ">
                                    <p><a id="d19599e606" class="indexterm-anchor"></a> JDBC</p>
                                 </td>
                                 <td align="left" valign="top" width="81%" headers="d19599e604 d19599e599 ">
                                    <p>将此API用于更复杂或动态的SQL查询。JDBC要求您建立会话，构造查询等。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="19%" id="d19599e615" headers="d19599e596 ">
                                    <p>SQLJ</p>
                                 </td>
                                 <td align="left" valign="top" width="81%" headers="d19599e615 d19599e599 ">
                                    <p>使用此API可以轻松进行静态和动态SQL查询。SQLJ通常针对具有已知列名的已知表运行。</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p>本节包括以下主题：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="invoking-Java-methods.html#GUID-934520A1-3EC2-4AA2-943C-9923AD67AF45">使用JDBC</a></p>
                        </li>
                        <li>
                           <p><a href="invoking-Java-methods.html#GUID-19DE9E4A-98FC-4BCC-8EDD-763FE5D93E0D">使用SQLJ</a></p>
                        </li>
                        <li>
                           <p><a href="invoking-Java-methods.html#GUID-AA8C889A-8A44-4C38-81A9-6CB970D42E06">示例比较JDBC和SQLJ</a></p>
                        </li>
                        <li>
                           <p><a href="invoking-Java-methods.html#GUID-ECAB7414-7C73-4B55-875A-4EACD2A92455">SQLJ强类型范例</a></p>
                        </li>
                        <li>
                           <p><a href="invoking-Java-methods.html#GUID-5F9792B3-7514-46BC-A736-8A7ABD2FEB30">翻译SQLJ程序</a></p>
                        </li>
                        <li>
                           <p><a href="invoking-Java-methods.html#GUID-B255842F-2D41-47E1-9A94-5F797F213EB2">与PL / SQL的交互</a></p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
               </div><a id="JJDEV13170"></a><div class="props_rev_3"><a id="GUID-934520A1-3EC2-4AA2-943C-9923AD67AF45" name="GUID-934520A1-3EC2-4AA2-943C-9923AD67AF45"></a><h4 id="JJDEV-GUID-934520A1-3EC2-4AA2-943C-9923AD67AF45" class="sect4"><span class="enumeration_section">3.1.3.1</span>使用JDBC</h4>
                  <div>
                     <div class="section">
                        <p>JDBC是一种行业标准API，允许您将SQL语句嵌入为Java方法参数。JDBC基于X / Open SQL调用级接口（CLI），符合SQL-92标准的入门级。每个供应商（例如Oracle）都通过实现来创建其JDBC实现<a id="d19599e745" class="indexterm-anchor"></a>标准<code class="codeph">java.sql</code>包的接口。Oracle提供了以下实现这些标准接口的JDBC驱动程序：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p>JDBC Thin驱动程序，100％纯Java解决方案，可用于客户端应用程序或applet，无需安装Oracle客户端。</p>
                           </li>
                           <li>
                              <p>JDBC OCI驱动程序，用于客户端应用程序并需要安装Oracle客户端。</p>
                           </li>
                           <li>
                              <p>嵌入在Oracle数据库中的服务器端JDBC驱动程序。</p>
                           </li>
                        </ul>
                        <p>使用JDBC是执行以下任务的分步过程：</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li><span>获取连接句柄</span></li>
                        <li><span>为所需的SQL操作创建某种类型的语句对象</span></li>
                        <li><span>分配要绑定到SQL操作的任何本地变量</span></li>
                        <li><span>执行操作</span></li>
                        <li><span>（可选）检索结果集</span></li>
                     </ol>
                     <div class="section">
                        <p>这个过程对于许多应用程序来说已经足够了，但对于任何复杂的语句来说都很麻烦动态SQL操作（直到运行时才知道操作）需要JDBC。但是，在典型的应用程序中，这代表了少数SQL操作。</p>
                        <div class="infoboxnotealso" id="GUID-934520A1-3EC2-4AA2-943C-9923AD67AF45__GUID-CDDC0713-91AF-44A4-B654-D1128E82419B">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="../jjdbc/introducing-JDBC.html#JJDBC-GUID-864DB502-5E50-4044-8132-33D6AAF8927A" target="_blank"><span><cite>Oracle数据库JDBC开发人员指南</cite></span></a></p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JJDEV13171"></a><div class="props_rev_3"><a id="GUID-19DE9E4A-98FC-4BCC-8EDD-763FE5D93E0D" name="GUID-19DE9E4A-98FC-4BCC-8EDD-763FE5D93E0D"></a><h4 id="JJDEV-GUID-19DE9E4A-98FC-4BCC-8EDD-763FE5D93E0D" class="sect4"><span class="enumeration_section">3.1.3.2</span>使用SQLJ</h4>
                  <div>
                     <div class="section">
                        <p>SQLJ提供了一种行业标准的方法，可以通过一个简单的步骤将任何静态SQL操作直接嵌入到Java源代码中，而无需多个JDBC步骤。 Oracle SQLJ符合X3H2-98-320美国国家标准协会（ANSI）标准。</p>
                        <p>SQLJ由一个翻译器和一个运行时组件组成，该翻译器是一个支持标准SQLJ编程语法的预编译器。在<code class="codeph">.sqlj</code>文件中创建SQLJ源代码后，使用<code class="codeph">.sqlj</code>程序处理它。翻译器将SQLJ源代码转换为标准Java源代码，SQL操作转换为对SQLJ运行时的调用。在Oracle Database SQLJ实现中，转换程序调用Java编译器来编译Java源代码。运行SQLJ应用程序时，SQLJ运行时调用JDBC与数据库进行通信。
                        </p>
                        <p>SQLJ还使您能够在运行时捕获SQL语句中的错误。JDBC代码是纯Java，直接编译。编译器无法检测SQL错误。另一方面，当您翻译SQLJ代码时，翻译器在语义和语法上分析嵌入式SQL语句，在开发期间捕获SQL错误，而不是允许最终用户在运行应用程序时捕获它们。</p>
                        <p>以下是一个简单的SQLJ程序的完整示例：</p><pre class="oac_no_warn" dir="ltr">import java.sql。*; import sqlj.runtime.ref。的DefaultContext; import oracle.sqlj.runtime。甲骨文; #sql iterator MyIter（String first_name，int employee_id，float salary）; public class MyExample {public static void main（String args []）抛出SQLException {Oracle.connect（“jdbc：oracle：thin：@localhost：5521：orcl”，“HR”，“ <span class="italic">&lt;password&gt;</span> ”）; #sql {INSERT INTO employees（first_name，employee_id，salary）VALUES（'SMITH'，32,20000）}; MyIter iter; #sql iter = {SELECT first_name，employee_id，salary FROM employees}; while（iter.next（））{System.out.println（iter.first_name（）+“”+ iter.employee_id（）+“”+ iter.salary（））; }}}</pre><p>在前面的示例中，您执行以下操作：</p>
                        <ol>
                           <li>
                              <p>声明你的迭代器。</p>
                              <p>SQLJ使用强类型的JDBC结果集，称为迭代器。迭代器具有特定数量的特定数据类型的列。您必须在使用它们之前定义迭代器类型，如本例所示。</p><pre class="oac_no_warn" dir="ltr">#sql ITERATOR MyIter（String first_name，int employee_id，float salary）;</pre><p>这个声明导致SQLJ创建一个迭代器类<code class="codeph">MyIter</code> 。<code class="codeph">MyIter</code>类型的迭代器可以存储第一列映射到Java <code class="codeph">String</code> ，第二列映射到Java <code class="codeph">int</code> ，第三列映射到Java <code class="codeph">float</code> 。此定义还将三列命名为<code class="codeph">first_name</code> ， <code class="codeph">employee_id</code>和<code class="codeph">salary</code> ，以匹配数据库中引用的表的列名。<code class="codeph">MyIter</code>是一个命名迭代器。
                              </p>
                           </li>
                           <li>
                              <p>连接到数据库。</p><pre class="oac_no_warn" dir="ltr">Oracle.connect（“jdbc：oracle：thin：@localhost：5521：orcl”，“HR”，“ <span class="italic">&lt;password&gt;</span> ”）;</pre><p>SQLJ提供<code class="codeph">Oracle</code>类，其<code class="codeph">connect()</code>方法完成以下重要任务：</p>
                              <ol type="a">
                                 <li>
                                    <p>注册SQLJ用于访问数据库的Oracle JDBC驱动程序，在本例中为JDBC Thin驱动程序。</p>
                                 </li>
                                 <li>
                                    <p>在指定的URL处打开指定架构的数据库连接，在本例中为具有指定密码的用户<code class="codeph">HR</code> 。在这种情况下，URL指向主机<code class="codeph">localhost</code> ，端口<code class="codeph">5521</code>和SID <code class="codeph">orcl</code> 。
                                    </p>
                                 </li>
                                 <li>
                                    <p>将此连接建立为SQLJ语句的默认连接。尽管每个JDBC语句都必须显式指定连接对象，但SQLJ语句可以隐式使用默认连接，也可以选择指定其他连接。</p>
                                 </li>
                              </ol>
                           </li>
                           <li>
                              <p>处理SQL语句。完成以下工作：</p>
                              <ol type="a">
                                 <li>
                                    <p>在<code class="codeph">employees</code>表中插入一行：</p><pre class="oac_no_warn" dir="ltr">#sql {INSERT INTO employees（first_name，employee_id，salary）VALUES（'SMITH'，32,20000）};</pre></li>
                                 <li>
                                    <p>实例化并填充迭代器：</p><pre class="oac_no_warn" dir="ltr">MyIter iter; #sql iter = {SELECT first_name，employee_id，salary FROM employees};</pre></li>
                              </ol>
                           </li>
                           <li>
                              <p>访问迭代器中填充的数据。</p><pre class="oac_no_warn" dir="ltr">while（iter.next（））{System.out.println（iter.first_name（）+“”+ iter.employee_id（）+“”+ iter.salary（））; }</pre><p><code class="codeph">next()</code>方法对所有迭代器都是通用的，并且与JDBC结果集的<code class="codeph">next()</code>方法扮演相同的角色，返回<code class="codeph">true</code>并移动到下一行数据（如果有任何行）。您可以通过调用名称与列名匹配的迭代器访问器方法来访问每行中的数据。这是所有命名迭代器的特征。在此示例中，您使用方法<code class="codeph">first_name()</code> ， <code class="codeph">employee_id()</code>和<code class="codeph">salary()</code>访问数据。
                              </p>
                           </li>
                        </ol>
                        <div class="infoboxnotealso" id="GUID-19DE9E4A-98FC-4BCC-8EDD-763FE5D93E0D__GUID-12240E74-8E36-4220-82F6-6E8633F4C95E">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="../jsqlj/intro-to-SQLJ.html#JSQLJ-GUID-B3A3C319-5C61-40C6-B3FB-37C2BD98AD48" target="_blank"><span><cite>Oracle数据库SQLJ开发人员指南</cite></span></a></p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JJDEV13173"></a><a id="JJDEV13174"></a><a id="JJDEV13172"></a><div class="props_rev_3"><a id="GUID-AA8C889A-8A44-4C38-81A9-6CB970D42E06" name="GUID-AA8C889A-8A44-4C38-81A9-6CB970D42E06"></a><h4 id="JJDEV-GUID-AA8C889A-8A44-4C38-81A9-6CB970D42E06" class="sect4"><span class="enumeration_section">3.1.3.3</span>比较JDBC和SQLJ的示例</h4>
                  <div>
                     <div class="section">
                        <p>以下是执行简单操作的JDBC代码和SQLJ代码的示例：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-AA8C889A-8A44-4C38-81A9-6CB970D42E06__GUID-2A73C304-2149-4938-9D16-F67087D924C9">JDBC：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section"><pre class="oac_no_warn" dir="ltr">//假设您已经有一个JDBC Connection对象conn //定义Java变量String name; int id = 37115;浮动工资= 20000; //设置JDBC预准备语句。PreparedStatement pstmt = conn.prepareStatement（“SELECT first_name FROM employees WHERE employee_id =？和薪水&gt;？“）; pstmt.setInt（1，id）; pstmt.setFloat（2，salary）; //执行查询;检索名称并将其分配给Java变量。ResultSet rs = pstmt.executeQuery（）; while（rs.next（））{name = rs.getString（1）; System.out.println（“名称是：”+名称）; } //关闭结果集和语句对象。rs.close（）pstmt.close（）;</pre><p>假设您已建立JDBC连接， <code class="codeph">conn</code> 。接下来，您必须执行以下操作：</p>
                        <ol>
                           <li>
                              <p>定义Java变量， <code class="codeph">name</code> ， <code class="codeph">id</code>和<code class="codeph">salary</code> 。
                              </p>
                           </li>
                           <li>
                              <p>创建<code class="codeph">PreparedStatement</code>实例。
                              </p>
                              <p>只要必须动态设置SQL语句中的值，就可以使用预准备语句。您可以使用不同的变量值重复使用相同的预准备语句。问号（？）在准备好的语句中是Java变量的占位符。在前面的示例中，使用<code class="codeph">pstmt.setInt()</code>和<code class="codeph">pstmt.setFloat()</code>方法为这些变量赋值。首先 ？指的是<code class="codeph">int</code>变量<code class="codeph">id</code> ，并设置为值<code class="codeph">37115</code> 。第二 ？指<code class="codeph">float</code>变量<code class="codeph">salary</code> ，并设置为值<code class="codeph">20000</code> 。
                              </p>
                           </li>
                           <li>
                              <p>运行查询并将数据返回到<code class="codeph">ResultSet</code>对象。
                              </p>
                           </li>
                           <li>
                              <p>从<code class="codeph">ResultSet</code>对象中检索感兴趣的数据并显示它。在这种情况下， <code class="codeph">first_name</code>列。结果集通常包含多行数据，但此示例只有一行。
                              </p>
                           </li>
                        </ol>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-AA8C889A-8A44-4C38-81A9-6CB970D42E06__GUID-8C7B6D0D-10E9-46C8-B614-080D019375AE">SQLJ：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section"><pre class="oac_no_warn" dir="ltr">字符串名称; int id = 37115;浮动工资= 20000; #sql {SELECT first_name INTO：name FROM employees WHERE employee_id =：id AND salary&gt;：salary}; System.out.println（“名称是：”+名称）;</pre><p>除了允许SQL语句直接嵌入Java代码之外，SQLJ还支持直接在SQL语句中使用的Java主机表达式（也称为绑定表达式）。在最简单的情况下，host表达式是一个简单变量，如本例所示。但是，也允许更复杂的表达式。每个宿主表达式都以冒号（:)开头。此示例使用Java主机表达式， <code class="codeph">name</code> ， <code class="codeph">id</code>和<code class="codeph">salary</code> 。在SQLJ中，由于其主机表达式支持，当您仅返回单行数据时，不需要结果集或等效项。
                        </p>
                        <div class="infoboxnote" id="GUID-AA8C889A-8A44-4C38-81A9-6CB970D42E06__GUID-9214E32D-8A8B-4C26-9969-2AC915A5CC0C">
                           <p class="notep1">注意：</p>
                           <p>所有SQLJ语句（包括声明）都以<code class="codeph">#sql</code>标记开头。
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JJDEV13176"></a><div class="props_rev_3"><a id="GUID-ECAB7414-7C73-4B55-875A-4EACD2A92455" name="GUID-ECAB7414-7C73-4B55-875A-4EACD2A92455"></a><h4 id="JJDEV-GUID-ECAB7414-7C73-4B55-875A-4EACD2A92455" class="sect4"><span class="enumeration_section">3.1.3.4</span> SQLJ强类型范例</h4>
                  <div>
                     <p>SQLJ使用强类型，例如迭代器，而不是结果集。这使得在转换期间可以针对数据库检查SQL指令。例如，SQLJ可以连接到数据库并根据将要查询的数据库表检查迭代器。翻译人员将验证它们是否匹配，使您能够在翻译期间捕获SQL错误，否则在用户运行您的应用程序之前不会被捕获。此外，如果随后对架构进行了更改，则可以通过重新运行转换程序来确定这些更改是否会影响应用程序。</p>
                  </div>
               </div><a id="JJDEV13177"></a><div class="props_rev_3"><a id="GUID-5F9792B3-7514-46BC-A736-8A7ABD2FEB30" name="GUID-5F9792B3-7514-46BC-A736-8A7ABD2FEB30"></a><h4 id="JJDEV-GUID-5F9792B3-7514-46BC-A736-8A7ABD2FEB30" class="sect4"><span class="enumeration_section">3.1.3.5</span>翻译SQLJ程序</h4>
                  <div>
                     <div class="section">
                        <p>集成开发环境（IDE）（例如Oracle JDeveloper）可以在构建SQLJ程序时对其进行转换，编译和自定义。Oracle JDeveloper是一个基于Microsoft Windows的Java编程可视化开发环境。如果您没有使用IDE，请使用前端SQLJ实用程序<code class="codeph">sqlj</code> 。您可以按如下方式运行它：</p><pre class="oac_no_warn" dir="ltr">％sqlj MyExample.sqlj</pre><p>SQLJ转换程序检查SQL操作的语法和语义。您可以启用在线检查以检查对数据库的操作。如果选择执行此操作，则必须在转换程序选项设置中指定示例数据库架构。模式没有必要使数据与程序最终运行的数据相同。但是，表必须包含具有相应名称和数据类型的列。使用user选项启用联机检查并指定架构的用户名，密码和URL，如以下示例所示：</p><pre class="oac_no_warn" dir="ltr">％sqlj -user = HR @ jdbc：oracle：thin：@localhost：5521：orcl MyExample.sqlj密码： <span class="italic">密码</span>
</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JJDEV13180"></a><div class="props_rev_3"><a id="GUID-B255842F-2D41-47E1-9A94-5F797F213EB2" name="GUID-B255842F-2D41-47E1-9A94-5F797F213EB2"></a><h4 id="JJDEV-GUID-B255842F-2D41-47E1-9A94-5F797F213EB2" class="sect4"><span class="enumeration_section">3.1.3.6</span>与PL / SQL的交互</h4>
                  <div>
                     <div class="section">
                        <p>所有Oracle JDBC驱动程序都与Oracle SQL和PL / SQL无缝通信，请务必注意SQLJ与PL / SQL进行互操作。您可以开始使用SQLJ，而无需重写任何PL / SQL存储过程。Oracle SQLJ包含用于调用PL / SQL存储过程的语法，还允许您在SQLJ语句中嵌入匿名PL / SQL块。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="JJDEV13181"></a><a id="JJDEV13182"></a><a id="JJDEV13183"></a><a id="JJDEV13184"></a><a id="JJDEV13185"></a><a id="JJDEV13186"></a><a id="JJDEV03140"></a><div class="props_rev_3"><a id="GUID-FC2894A1-87C3-4695-968E-A3E69344B353" name="GUID-FC2894A1-87C3-4695-968E-A3E69344B353"></a><h3 id="JJDEV-GUID-FC2894A1-87C3-4695-968E-A3E69344B353" class="sect3"><span class="enumeration_section">3.1.4</span>关于使用命令行界面</h3>
               <div>
                  <div class="section">
                     <p>Oracle JVM的命令行界面类似于使用JDK或JRE shell命令。您可以：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>使用标准的<code class="codeph">-classpath</code>语法指示要在何处查找要加载的类</p>
                        </li>
                        <li>
                           <p>使用标准<code class="codeph">-D</code>语法设置系统属性</p>
                        </li>
                     </ul>
                     <p>接口是一个PL / SQL函数，它接受一个字符串（ <code class="codeph">VARCHAR2</code> ）参数，将其解析为命令行输入，如果它正确形成，则在Oracle JVM中运行指示的Java方法。为此，PL / SQL包<code class="codeph">DBMS_JAVA</code>提供以下功能：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="invoking-Java-methods.html#GUID-FC2894A1-87C3-4695-968E-A3E69344B353__CHDBJEFD">runjava</a></p>
                        </li>
                        <li>
                           <p><a href="invoking-Java-methods.html#GUID-FC2894A1-87C3-4695-968E-A3E69344B353__CHDCFCGH">runjava_in_current_session</a></p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
                  <div class="section" id="GUID-FC2894A1-87C3-4695-968E-A3E69344B353__CHDBJEFD">
                     <p class="subhead2" id="GUID-FC2894A1-87C3-4695-968E-A3E69344B353__GUID-456313EF-21EC-4E1A-BCA8-B26C0D2F81EB">runjava</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p>此函数将Java命令行作为其唯一参数，并在Oracle JVM中运行它。成功完成后返回值为null，否则返回错误消息。命令行的格式与JDK shell命令的格式相同，即：</p><pre class="oac_no_warn" dir="ltr">[选项开关] name_of_class_to_execute [arg1 arg2 ... argn]</pre><p>您可以使用选项开关<code class="codeph">-classpath, -D, -Xbootclasspath,</code>和<code class="codeph">-jar.</code> 此函数与<code class="codeph">runjava_in_current_session</code>函数的不同之处在于，它在运行当前命令之前清除会话中以前使用Java时剩余的任何Java状态。特别是，这对于保证在类初始化时从<code class="codeph">-classpath</code>和<code class="codeph">-D</code>参数派生的静态变量值反映当前命令行中这些开关的值是必要的。
                     </p><pre class="oac_no_warn" dir="ltr">FUNCTION runjava（cmdline VARCHAR2）RETURN VARCHAR2;</pre></div>
                  <!-- class="section" -->
                  <div class="section" id="GUID-FC2894A1-87C3-4695-968E-A3E69344B353__CHDCFCGH">
                     <p class="subhead2" id="GUID-FC2894A1-87C3-4695-968E-A3E69344B353__GUID-138DE6C4-2A1D-4D4A-B857-219663B5DD59">runjava_in_current_session</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p>此函数与<code class="codeph">runjava</code>函数相同，只是在执行当前命令行之前，它不会清除会话中先前使用Java的剩余Java状态。
                     </p><pre class="oac_no_warn" dir="ltr">功能runjava_in_current_session（cmdline VARCHAR2）RETURN VARCHAR2;</pre></div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-FC2894A1-87C3-4695-968E-A3E69344B353__GUID-1D1DA06E-58F4-447A-9277-7F7D676D8235">句法</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p>命令行的语法具有以下形式：</p><pre class="oac_no_warn" dir="ltr">[-options] classname [arguments ...][-options] -jar jarfile [arguments ...]
</pre></div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-FC2894A1-87C3-4695-968E-A3E69344B353__GUID-E48908A5-A335-43EA-9257-CE6FB9732C30">选项</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section"><pre class="oac_no_warn" dir="ltr">-classpath -D -Xbootclasspath -Xbootclasspath / a -Xbootclasspath / p -cp</pre><div class="infoboxnote" id="GUID-FC2894A1-87C3-4695-968E-A3E69344B353__GUID-54D97D9D-D6DF-4454-AE69-08DB78F5DA91">
                        <p class="notep1">注意：</p>
                        <p>第一种形式的作用是使用参数运行classname标识的类的main方法。第二种形式的作用是运行由JAR标识的JAR文件的清单中的<code class="codeph">Main-Class</code>属性标识的类的main方法。这类似于JDK / JRE如何解释此语法。
                        </p>
                     </div>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-FC2894A1-87C3-4695-968E-A3E69344B353__GUID-6B996826-0789-497C-AE15-19060D1DD2E6">参数摘要</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p>下表总结了命令行参数。</p>
                  </div>
                  <!-- class="section" -->
                  <div class="tblformal" id="GUID-FC2894A1-87C3-4695-968E-A3E69344B353__CACBBFHC">
                     <p class="titleintable">表3-1命令行参数摘要</p>
                     <table cellpadding="4" cellspacing="0" class="Formal" title="命令行参数摘要" width="100%" border="1" summary="table" frame="hsides" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="26%" id="d19599e1701">争论</th>
                              <th align="left" valign="bottom" width="74%" id="d19599e1704">描述</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="26%" id="d19599e1709" headers="d19599e1701 ">
                                 <p>类路径</p>
                              </td>
                              <td align="left" valign="top" width="74%" headers="d19599e1709 d19599e1704 ">
                                 <p>接受冒号（:)分隔（在Windows系统上以分号分隔）目录，JAR存档和ZIP存档列表以搜索类文件。通常， <code class="codeph">-classpath</code>或类似参数的值与标准Java运行时中的文件系统位置相同。您还可以使用此语法的扩展，以允许引用数据库驻留Java对象和字节集的术语。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="26%" id="d19599e1719" headers="d19599e1701 ">
                                 <p>d</p>
                              </td>
                              <td align="left" valign="top" width="74%" headers="d19599e1719 d19599e1704 ">
                                 <p>当没有现有Java会话状态时，为系统属性建立值。命令行界面的默认行为（即<code class="codeph">runjava</code>函数）是在运行新命令之前终止任何现有Java会话。另一方面，替代函数<code class="codeph">runjava_in_current_session</code>使任何现有会话保持<code class="codeph">runjava_in_current_session</code> 。因此，既定值<code class="codeph">-D</code>选项会一直生效时<code class="codeph">runjava</code>使用功能，但是当值可能不会生效<code class="codeph">runjava_in_current_session</code>被使用的功能。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="26%" id="d19599e1741" headers="d19599e1701 ">
                                 <p>Xbootclasspath</p>
                              </td>
                              <td align="left" valign="top" width="74%" headers="d19599e1741 d19599e1704 ">
                                 <p>接受冒号（:)分隔（在Windows系统上以分号分隔）目录，JAR存档和ZIP存档列表。此选项用于设置引导类和资源的搜索路径。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="26%" id="d19599e1748" headers="d19599e1701 ">
                                 <p><code class="codeph">Xbootclasspath / A</code></p>
                              </td>
                              <td align="left" valign="top" width="74%" headers="d19599e1748 d19599e1704 ">
                                 <p>接受冒号（:)分隔（在Windows系统上以分号分隔）目录，JAR存档和ZIP存档列表。这将附加到引导类路径的末尾。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="26%" id="d19599e1756" headers="d19599e1701 ">
                                 <p><code class="codeph">Xbootclasspath / P</code></p>
                              </td>
                              <td align="left" valign="top" width="74%" headers="d19599e1756 d19599e1704 ">
                                 <p>接受冒号（:)分隔（在Windows系统上以分号分隔）目录，JAR存档和ZIP存档列表。这是在bootstrap类路径前添加的。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="26%" id="d19599e1764" headers="d19599e1701 ">
                                 <p><code class="codeph">CP</code></p>
                              </td>
                              <td align="left" valign="top" width="74%" headers="d19599e1764 d19599e1704 ">
                                 <p>充当<code class="codeph">-classpath</code>的同义词。
                                 </p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
                  <div class="section">
                     <div class="infoboxnote" id="GUID-FC2894A1-87C3-4695-968E-A3E69344B353__GUID-1E55486B-54FA-470F-8214-3907AB7CF54A">
                        <p class="notep1">注意：</p>
                        <p>在使用使用<code class="codeph">-Xbootclasspath</code>选项找到的任何文件或文件夹之前，始终使用<code class="codeph">create java system</code>创建的系统类。
                        </p>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="invoking-Java-methods.html#GUID-FC2894A1-87C3-4695-968E-A3E69344B353">关于使用命令行界面</a></li>
                     </ul>
                  </div>
               </div>
               
            </div><a id="JJDEV13188"></a><a id="JJDEV13187"></a><div class="props_rev_3"><a id="GUID-E081FA25-FAF4-48BE-A84E-05359631C532" name="GUID-E081FA25-FAF4-48BE-A84E-05359631C532"></a><h3 id="JJDEV-GUID-E081FA25-FAF4-48BE-A84E-05359631C532" class="sect3"><span class="enumeration_section">3.1.5</span>使用客户端存根的概述</h3>
               <div>
                  <p>Oracle数据库<span class="italic">10g</span>引入了客户端存根（以前称为本机Java接口），用于调用服务器端Java代码。它是一种简化的应用程序集成。客户端和中间层Java应用程序可以直接在数据库中调用Java，而无需定义PL / SQL包装器。客户端存根使用服务器端Java类反射功能。
                  </p>
                  <p>在以前的版本中，从数据库客户端调用Java存储过程和函数需要对相关的PL / SQL包装器进行Java数据库连接（JDBC）调用。必须使用SQL签名和Java实现手动发布每个包装器。这有以下缺点：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>签名仅允许具有直接SQL等效的Java类型</p>
                     </li>
                     <li>
                        <p>Java中发布的异常未正确返回</p>
                     </li>
                  </ul>
                  <p>从Oracle Database 12 <span class="italic">c</span>第2版（12.2.0.1）开始，您可以使用Oracle JVM Web服务调用实用程序生成客户端存根。
                  </p>
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="database-as-web-service-consumer.html#GUID-443CE9FD-2487-4ED2-9FFA-4C0F0B9880DA">Oracle JVM Web服务调用实用程序的体系结构</a></li>
                     </ul>
                  </div>
               </div>
               
               <div class="props_rev_3"><a id="GUID-BAEE663A-40D4-4C17-B0F7-294D1C4BD18A" name="GUID-BAEE663A-40D4-4C17-B0F7-294D1C4BD18A"></a><h4 id="JJDEV-GUID-BAEE663A-40D4-4C17-B0F7-294D1C4BD18A" class="sect4"><span class="enumeration_section">3.1.5.1</span>使用默认服务功能</h4>
                  <div>
                     <div class="section">
                        <p>从Oracle Database <span class="italic">11g第</span> 1版（11.1）开始，Oracle数据库客户端提供了新的默认连接功能。如果安装Oracle数据库客户端，则无需在连接URL中指定数据库服务器的所有详细信息。在某些情况下，Oracle数据库连接适配器仅需要安装数据库的计算机的主机名。
                        </p>
                        <p>例如，在JDBC连接URL语法中，即：</p><pre class="oac_no_warn" dir="ltr">JDBC：预言：driver_type：[用户名/密码] @ [//] HOST_NAME [：端口] [：ORCL]</pre><p>，以下内容已成为可选：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">//</code>是可选的。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">:port</code>是可选的。
                              </p>
                              <p>仅当未使用默认Oracle Net侦听器端口（1521）时，才必须指定端口。</p>
                           </li>
                           <li>
                              <p><code class="codeph">:ORCL</code>或服务名称是可选的。
                              </p>
                              <p>Oracle Database Client的连接适配器连接到主机上的默认服务。在主机上，它在<code class="codeph">listener.ora</code>文件中设置为<code class="codeph">ORCL</code> 。
                              </p>
                           </li>
                        </ul>
                        <div class="infoboxnote" id="GUID-BAEE663A-40D4-4C17-B0F7-294D1C4BD18A__GUID-A416961D-6CB8-4C41-AB24-A096875001D1">
                           <p class="notep1">注意：</p>
                           <p>默认服务是自Oracle Database <span class="italic">11g</span>第1版（11.1）以来的一项功能。如果使用Oracle Database <span class="italic">11g</span> Client之前的任何版本连接到数据库，则必须指定<code class="codeph">SID</code> 。</p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JJDEV13191"></a><div class="props_rev_3"><a id="GUID-D258923D-0E6B-4672-B2CC-51182A7730F7" name="GUID-D258923D-0E6B-4672-B2CC-51182A7730F7"></a><h4 id="JJDEV-GUID-D258923D-0E6B-4672-B2CC-51182A7730F7" class="sect4"><span class="enumeration_section">3.1.5.2</span>使用基本配置测试默认服务</h4>
                  <div>
                     <div class="section">
                        <p>以下代码段显示了<code class="codeph">listener.ora</code>文件的基本配置，其中定义了默认服务：</p><pre class="oac_no_warn" dir="ltr">MYLISTENER =（ADDRESS_LIST =（ADDRESS =（PROTOCOL = tcp）（HOST = testserver1）（PORT = 1521）））DEFAULT_SERVICE_MYLISTENER = dbjf.app.myserver.com SID_LIST_MYLISTENER =（SID_LIST =（SID_DESC =（SID_NAME = dbjf）（GLOBAL_DBNAME = dbjf.app.myserver.com）（ORACLE_HOME = / test / oracle）））</pre><p>定义<code class="codeph">listener.ora</code>文件后，使用以下命令重新启动侦听器：</p><pre class="oac_no_warn" dir="ltr">lsnrctl启动mylistener</pre><p>现在，以下任何URL都应该与<code class="codeph">listener.ora</code>文件的此配置一起使用：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">JDBC：预言：瘦：@ // testserver1.myserver.com.com</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">JDBC：预言：瘦：@ // testserver1.myserver.com:1521</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">JDBC：预言：瘦：@ testserver1.myserver.com</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">JDBC：神谕：薄：@ testserver1.myserver.com：1521</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">JDBC：预言：瘦：@（DESCRIPTION =（ADDRESS =（PROTOCOL = TCP）（HOST = testserver1.myserver.com）（PORT = 1521）））</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">JDBC：预言：瘦：@（DESCRIPTION =（ADDRESS =（PROTOCOL = TCP）（HOST = testserver1.myserver.com）））</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">JDBC：预言：瘦：@（DESCRIPTION =（ADDRESS =（PROTOCOL = TCP）（HOST = testserver1.myserver.com）（PORT = 1521））（CONNECT_DATA =（SERVICE_NAME =）））</code></p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>