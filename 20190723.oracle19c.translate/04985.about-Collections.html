<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <title>集合</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Programmer&#39;s Guide"></meta>
      <meta property="og:description" content=""></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Programmer&#39;s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="c-c-programmers-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-11T03:52:01-08:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="1996, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96467-01"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="about-Objects.html" title="Previous" type="text/html"></link>
      <link rel="next" href="the-Object-type.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Pro*C/C++ Programmer&#39;s Guide"></meta>
    <meta name="dcterms.isVersionOf" content="LNPCC"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="about-Objects.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="the-Object-type.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">程序员指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="applications.html" property="item" typeof="WebPage"><span property="name">应用</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">集合</li>
            </ol>
            <a id="GUID-BCAD71D2-D01D-40C8-8BAD-08902363ECDA" name="GUID-BCAD71D2-D01D-40C8-8BAD-08902363ECDA"></a><a id="LNPCC4375"></a>
            
            <h2 id="LNPCC-GUID-BCAD71D2-D01D-40C8-8BAD-08902363ECDA" class="sect2"><span class="enumeration_chapter">18</span>集</h2>
         </header>
         <div class="ind">
            <div>
               <p>本章介绍了其他类型的对象类型，称为<span class="italic">集合</span> ，以及在Pro * C / C ++中使用它们的方法。我们提供了访问集合及其元素的方法。本章包含以下主题：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="about-Collections.html#GUID-330FAC24-ED86-458F-8363-6A22BF67B7E6">集合</a></p>
                  </li>
                  <li>
                     <p><a href="about-Collections.html#GUID-0E38669D-177D-4F04-A789-530C0B49AEED">收藏品的描述符</a></p>
                  </li>
                  <li>
                     <p><a href="about-Collections.html#GUID-87377939-6FBA-414D-8295-D9F1EC664496">对象获取和设置</a></p>
                  </li>
                  <li>
                     <p><a href="about-Collections.html#GUID-6A7D030A-7B6B-4380-9896-EA926DA506CA">收集声明</a></p>
                  </li>
                  <li>
                     <p><a href="about-Collections.html#GUID-4475F8F4-9410-4405-A7B2-A678D6BE5270">集合示例代码</a></p>
                  </li>
               </ul>
            </div><a id="LNPCC4376"></a><div class="props_rev_3"><a id="GUID-330FAC24-ED86-458F-8363-6A22BF67B7E6" name="GUID-330FAC24-ED86-458F-8363-6A22BF67B7E6"></a><h3 id="LNPCC-GUID-330FAC24-ED86-458F-8363-6A22BF67B7E6" class="sect3"><span class="enumeration_section">18.1</span>收藏</h3>
               <div>
                  <p>收集对象类型有两种： <span class="italic">嵌套表</span>和<span class="italic">varrays</span> 。
                  </p>
                  <p>集合既可以在关系列中发生，也可以作为对象类型中的属性发生。所有集合必须在数据库中<span class="italic">命名为</span>对象类型。对于varrays，您必须首先在数据库中创建一个命名类型，指定所需的数组元素类型和最大数组维度。
                  </p>
                  <p>使用Oracle，您不再局限于单一级别的嵌套。Oracle支持多级对象集合，支持多级嵌套表和变量。</p>
               </div><a id="LNPCC4377"></a><div class="props_rev_3"><a id="GUID-43411CF9-D843-45BD-9127-ABF8879B0F11" name="GUID-43411CF9-D843-45BD-9127-ABF8879B0F11"></a><h4 id="LNPCC-GUID-43411CF9-D843-45BD-9127-ABF8879B0F11" class="sect4"><span class="enumeration_section">18.1.1</span>嵌套表</h4>
                  <div>
                     <p>嵌套表是列中称为元素的行的集合。对于数据库表的每一行，有许多这样的元素。一个简单的例子是每个员工正在处理的任务列表。因此，多对一关系可以存储在一个表中，而无需加入员工和任务表。</p>
                     <p>嵌套表在以下方面与C和C ++数组不同：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>数组有一个固定的上限;嵌套表是无界的（没有最大索引）。</p>
                        </li>
                        <li>
                           <p>数组有连续的下标（ <span class="italic">密集</span> ）;嵌套表可以是密集的也可以是<span class="italic">稀疏的</span> 。当嵌套表被检索到程序中的数组时，会跳过间隙，从而产生一个没有间隙的填充数组。
                           </p>
                        </li>
                     </ul>
                     <p>使用CREATE TYPE语句定义可以嵌套在关系表的一列或多列中的其他对象类型中的表类型。</p>
                     <p>例如：，在组织的每个部门中存储多个项目：</p><pre class="oac_no_warn" dir="ltr">CREATE TYPE project_type AS OBJECT（pno CHAR（5），pname CHAR（20），预算编号（7,2））; CREATE TYPE project_table AS TABLE OF project_type; CREATE TABLE depts（dno CHAR（5），dname CHAR（20），budgets_limit NUMBER（15,2），projects project_table）NESTED TABLE项目STORE AS depts_projects;</pre></div>
               </div><a id="LNPCC4378"></a><div class="props_rev_3"><a id="GUID-1D7CAF83-F166-4301-AB66-4BCC1EDF2B98" name="GUID-1D7CAF83-F166-4301-AB66-4BCC1EDF2B98"></a><h4 id="LNPCC-GUID-1D7CAF83-F166-4301-AB66-4BCC1EDF2B98" class="sect4"><span class="enumeration_section">18.1.2</span>变量</h4>
                  <div>
                     <p>与嵌套表不同，您必须在创建VARRAY类型时指定最大元素数。与嵌套表不同，Varrays只是密集的，可以是密集的或稀疏的。varray和嵌套表的元素都从0开始编号。</p>
                     <p>使用CREATE TYPE语句创建一个varray，例如：</p><pre class="oac_no_warn" dir="ltr">CREATE TYPE employee AS OBJECT（名称VARCHAR2（10），薪水NUMBER（8,2））; CREATE TYPE员工AS VARRAY（15）OF员工; CREATE TYPE部门AS OBJECT（名称VARCHAR2（15），团队员工）;</pre><p>使用VARRAY作为关系表的列的数据类型，或作为对象类型的属性。与每个团队最多包含15条记录的关系表相比，这节省了存储空间，每个记录包含团队的名称。</p>
                  </div>
               </div><a id="LNPCC4379"></a><div class="props_rev_3"><a id="GUID-53EAA36C-DC26-4138-9DB1-BB47E96C6804" name="GUID-53EAA36C-DC26-4138-9DB1-BB47E96C6804"></a><h4 id="LNPCC-GUID-53EAA36C-DC26-4138-9DB1-BB47E96C6804" class="sect4"><span class="enumeration_section">18.1.3</span> C和集合</h4>
                  <div>
                     <p>在C或C ++程序中，从集合的索引值0开始读取嵌套表。将嵌套表写入数组时，嵌套表的元素将从数组索引0开始存储。当稀疏的嵌套表（其索引中有间隙）存储到数组中时，将跳过间隙。将数组读回嵌套表时，会重新创建间隙。</p>
                     <p>在C或C ++程序中，varrays被写入数组，从索引0开始。当读回varray时，元素将从索引0开始以相同的顺序恢复。因此，数组很容易用于访问集合。</p>
                  </div>
               </div>
            </div><a id="LNPCC4380"></a><div class="props_rev_3"><a id="GUID-0E38669D-177D-4F04-A789-530C0B49AEED" name="GUID-0E38669D-177D-4F04-A789-530C0B49AEED"></a><h3 id="LNPCC-GUID-0E38669D-177D-4F04-A789-530C0B49AEED" class="sect3"><span class="enumeration_section">18.2</span>收集的描述符</h3>
               <div>
                  <p>嵌套表的C类型是指向OCITable的指针。对于varrays，它是指向OCIArray的指针。（两者都是指向OCIColl的指针的子类型）。使用OTT（对象类型转换器）实用程序在头文件中生成typedef，然后将其包含在应用程序代码中。</p>
                  <p>集合的主机结构是<span class="italic">描述符，</span>通过该<span class="italic">描述符</span>可以访问集合中的元素。这些描述符不包含集合的实际元素，而是包含指向它们的指针。描述符及其相关元素的内存来自对象缓存。
                  </p>
                  <p>按照对象类型的常规过程，必须在Pro * C / C ++的INTYPE预编译器选项和使用#include预处理器指令的Pro * C / C ++程序中包含的OTT生成的头中指定OTT生成的类型文件。这确保了在预编译期间可以执行对集合对象类型的正确类型检查。</p>
                  <p>但是，与其他对象类型不同，集合对象类型不需要OTT生成特殊的指示符结构;而是使用标量指示器。这是因为原子NULL指示符足以表示集合整体是否为NULL。集合中每个单独元素的NULL状态可以（可选地）在与每个元素相关联的单独指示符中表示。</p>
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="the-Object-type.html#GUID-502C3781-C88E-46B8-9EB2-9A93E0B4E7AE">对象类型转换器</a></li>
                     </ul>
                  </div>
               </div>
               <a id="LNPCC4381"></a><div class="props_rev_3"><a id="GUID-78DC4BA3-1CF9-4594-9E20-D9817B533C1A" name="GUID-78DC4BA3-1CF9-4594-9E20-D9817B533C1A"></a><h4 id="LNPCC-GUID-78DC4BA3-1CF9-4594-9E20-D9817B533C1A" class="sect4"><span class="enumeration_section">18.2.1</span>主机和指示变量的声明</h4>
                  <div>
                     <p>对于其他对象类型，必须将表示集合对象类型的主变量声明为指向相应OTT生成的typedef的指针。</p>
                     <p>但是，与其他对象类型不同，集合对象类型作为整体的指示符变量被声明为标量签名的2字节类型<code class="codeph">OCIInd</code> 。指示符变量是可选的，但对于在Pro * C / C ++中声明的每个主变量使用一个变量是一个很好的编程习惯。
                     </p>
                  </div>
               </div><a id="LNPCC4382"></a><div class="props_rev_3"><a id="GUID-7946C536-FCB0-4AA2-96AF-237D76D63711" name="GUID-7946C536-FCB0-4AA2-96AF-237D76D63711"></a><h4 id="LNPCC-GUID-7946C536-FCB0-4AA2-96AF-237D76D63711" class="sect4"><span class="enumeration_section">18.2.2</span>关于操作集合</h4>
                  <div>
                     <div class="section">
                        <p>有两种方法可以操作集合：集合被视为自治实体，无需访问其元素，或者访问，附加，截断等元素。</p>
                     </div>
                     <!-- class="section" -->
                  </div><a id="LNPCC4383"></a><div class="props_rev_3"><a id="GUID-C4FDF600-9067-4171-8C58-80FC7C37427E" name="GUID-C4FDF600-9067-4171-8C58-80FC7C37427E"></a><h5 id="LNPCC-GUID-C4FDF600-9067-4171-8C58-80FC7C37427E" class="sect5"><span class="enumeration_section">18.2.2.1</span>自主收集访问</h5>
                     <div>
                        <p>使用C集合描述符（OCITable或OCIArray）只允许将集合作为一个整体进行分配。OBJECT GET嵌入式SQL语句将集合绑定到C主机变量描述符。相反的情况发生在OBJECT SET语句中，该语句将C主机描述符绑定到集合。</p>
                        <p>可以将多个集合绑定到同一语句中的兼容C描述符，或者在集合绑定到C描述符的同一语句中包含其他标量的绑定。</p>
                     </div>
                     <div>
                        <div class="relinfo">
                           <p><strong>相关话题</strong></p>
                           <ul>
                              <li><a href="about-Objects.html#GUID-C0317114-582E-4D77-AC2E-C18E8DE6D23E">转换对象属性和C类型</a></li>
                           </ul>
                        </div>
                     </div>
                     
                  </div><a id="LNPCC4384"></a><div class="props_rev_3"><a id="GUID-8E3B9180-2AA1-4304-89D7-5D4907CFA393" name="GUID-8E3B9180-2AA1-4304-89D7-5D4907CFA393"></a><h5 id="LNPCC-GUID-8E3B9180-2AA1-4304-89D7-5D4907CFA393" class="sect5"><span class="enumeration_section">18.2.2.2</span>集合元素访问</h5>
                     <div>
                        <p>C集合描述符用于访问集合的元素。描述符包含集合的内部属性，例如其起点和终点以及其他信息。</p>
                        <p><span class="italic">一片</span>元素绑定到具有兼容数据类型的主机数组。集合的片段被定义为起始索引和结束索引之间的内容。切片映射到数组，该数组的维数可能大于切片元素的数量。
                        </p>
                        <p>绑定标量与具有维度1的主机数组相同，或者将可选的FOR子句评估为1。</p>
                     </div>
                  </div>
               </div><a id="LNPCC4385"></a><div class="props_rev_3"><a id="GUID-4EBBBCD1-7F23-497B-A56A-8CFA54167F04" name="GUID-4EBBBCD1-7F23-497B-A56A-8CFA54167F04"></a><h4 id="LNPCC-GUID-4EBBBCD1-7F23-497B-A56A-8CFA54167F04" class="sect4"><span class="enumeration_section">18.2.3</span>访问规则</h4>
                  <div>
                     <p>访问规则对于自治和元素访问是不同的。</p>
                  </div><a id="LNPCC4386"></a><div class="props_rev_3"><a id="GUID-686C9B51-8B6F-4670-9C71-9F11AC8D99A1" name="GUID-686C9B51-8B6F-4670-9C71-9F11AC8D99A1"></a><h5 id="LNPCC-GUID-686C9B51-8B6F-4670-9C71-9F11AC8D99A1" class="sect5"><span class="enumeration_section">18.2.3.1</span>自主访问</h5>
                     <div>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>不允许使用FOR子句，因为集合被视为一个整体。</p>
                           </li>
                           <li>
                              <p>由于嵌套表和变量的定义不同，因此无法在它们之间进行分配。</p>
                           </li>
                           <li>
                              <p>在同一语句中允许多个集合分配给C描述符。您可以将集合分配给C描述符，也可以在同一语句中绑定其他标量数据类型。</p>
                           </li>
                        </ul>
                     </div>
                  </div><a id="LNPCC4387"></a><div class="props_rev_3"><a id="GUID-B6289149-E0F4-4721-857E-7A522DE2D7B5" name="GUID-B6289149-E0F4-4721-857E-7A522DE2D7B5"></a><h5 id="LNPCC-GUID-B6289149-E0F4-4721-857E-7A522DE2D7B5" class="sect5"><span class="enumeration_section">18.2.3.2</span>元素访问</h5>
                     <div>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>FOR条款是允许的。如果省略，则最小的数组维度给出要执行的迭代次数。</p>
                           </li>
                           <li>
                              <p>一次只能访问一个集合。</p>
                              <div class="infoboxnote" id="GUID-B6289149-E0F4-4721-857E-7A522DE2D7B5__GUID-B1C91E7A-51BF-4E7A-A936-B714DB8031C3">
                                 <p class="notep1">注意：</p>
                                 <p>FOR子句变量指定要处理的数组元素的数量。确保数字不超过最小的数组维度。在内部，该值被视为无符号数量。尝试通过使用已签名的主机变量传递负值将导致不可预测的行为。</p>
                              </div>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="LNPCC4388"></a><div class="props_rev_3"><a id="GUID-A1F2326E-E31F-4AAE-9FDB-182AC96F96ED" name="GUID-A1F2326E-E31F-4AAE-9FDB-182AC96F96ED"></a><h4 id="LNPCC-GUID-A1F2326E-E31F-4AAE-9FDB-182AC96F96ED" class="sect4"><span class="enumeration_section">18.2.4</span>指标变量</h4>
                  <div>
                     <p>每种访问方法都有自己的使用指标变量的方法。</p>
                  </div><a id="LNPCC4389"></a><div class="props_rev_3"><a id="GUID-BC4B77A3-EC83-46E2-BEB0-78AE8B8E2581" name="GUID-BC4B77A3-EC83-46E2-BEB0-78AE8B8E2581"></a><h5 id="LNPCC-GUID-BC4B77A3-EC83-46E2-BEB0-78AE8B8E2581" class="sect5"><span class="enumeration_section">18.2.4.1</span>自治绑定</h5>
                     <div>
                        <p>单个指示符变量将集合的NULL状态保存为单个实体。这没有说明元素中的NULL状态。</p>
                     </div>
                  </div><a id="LNPCC4390"></a><div class="props_rev_3"><a id="GUID-07547942-BF90-4647-9324-5D9FE83D9F2F" name="GUID-07547942-BF90-4647-9324-5D9FE83D9F2F"></a><h5 id="LNPCC-GUID-07547942-BF90-4647-9324-5D9FE83D9F2F" class="sect5"><span class="enumeration_section">18.2.4.2</span>元素绑定</h5>
                     <div>
                        <p>指示符变量显示元素是否为NULL。如果将一片收集数据绑定到具有其自己的指示符数组的主机数组，则该指示符数组将包含该片中每个元素的NULL状态。</p>
                        <p>当集合元素类型是用户定义的对象类型时，与主变量关联的指示符变量包含对象及其属性的NULL状态。</p>
                     </div>
                  </div>
               </div>
            </div><a id="LNPCC4392"></a><a id="LNPCC4393"></a><a id="LNPCC4394"></a><a id="LNPCC4391"></a><div class="props_rev_3"><a id="GUID-87377939-6FBA-414D-8295-D9F1EC664496" name="GUID-87377939-6FBA-414D-8295-D9F1EC664496"></a><h3 id="LNPCC-GUID-87377939-6FBA-414D-8295-D9F1EC664496" class="sect3"><span class="enumeration_section">18.3</span>对象获取和设置</h3>
               <div>
                  <p>导航语句OBJECT SET和OBJECT GET允许您检索和更新集合属性以及您定义的对象类型。</p>
                  <p>对于作为对象类型的元素，OBJECT GET语句将其中的所有属性检索到主机变量中</p><pre class="oac_no_warn" dir="ltr">'*'| { <span class="italic">attr</span> [， <span class="italic">attr</span> ]} FROM</pre><p>省略子句，或使用'OBJECT GET * FROM'：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL [AT [：] <span class="italic">database</span> ] OBJECT GET ['*'| { <span class="italic">attr</span> [， <span class="italic">attr</span> ]} FROM]： <span class="italic">object</span> [[INDICATOR]： <span class="italic">object_ind</span> ] INTO {： <span class="italic">hv</span> [[INDICATOR]： <span class="italic">hv_ind</span> ] [，： <span class="italic">hv</span> [[INDICATOR]： <span class="italic">hv_ind</span> ]]};</pre><p>OBJECT SET语句会导致在使用主机变量时更新对象的所有属性</p><pre class="oac_no_warn" dir="ltr">'*'| { <span class="italic">attr</span> ，[， <span class="italic">attr</span> ]} OF</pre><p>省略子句或使用'OBJECT SET * OF'：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL [AT [：] <span class="italic">database</span> ] OBJECT SET ['*'| { <span class="italic">attr</span> [， <span class="italic">attr</span> ]} OF]： <span class="italic">object</span> [INDICATOR]： <span class="italic">object_ind</span> ] TO {： <span class="italic">hv</span> [[INDICATOR]： <span class="italic">hv_ind</span> ] [，： <span class="italic">hv</span> [[INDICATOR]： <span class="italic">hv_ind</span> ]]};</pre><p>此表显示了这两个语句如何映射对象和集合类型：</p>
                  <div class="tblformal" id="GUID-87377939-6FBA-414D-8295-D9F1EC664496__GUID-F457F9D3-50E6-4389-AC4A-E6E5C6C269BC">
                     <p class="titleintable">表18-1对象和集合属性</p>
                     <table cellpadding="4" cellspacing="0" class="Formal" title="对象和集合属性" width="100%" border="1" summary="Object and Collection Attributes" frame="hsides" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="21%" id="d98123e750">属性类型</th>
                              <th align="left" valign="bottom" width="38%" id="d98123e753">表示</th>
                              <th align="left" valign="bottom" width="41%" id="d98123e756">主机数据类型</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="21%" id="d98123e761" headers="d98123e750 ">
                                 <p>宾语</p>
                              </td>
                              <td align="left" valign="top" width="38%" headers="d98123e761 d98123e753 ">
                                 <p>OTT生成的结构</p>
                              </td>
                              <td align="left" valign="top" width="41%" headers="d98123e761 d98123e756 ">
                                 <p>指向OTT结构的指针</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="21%" id="d98123e771" headers="d98123e750 ">
                                 <p>采集</p>
                              </td>
                              <td align="left" valign="top" width="38%" headers="d98123e771 d98123e753 ">
                                 <p>OCIArray，OCITable（OCIColl）</p>
                              </td>
                              <td align="left" valign="top" width="41%" headers="d98123e771 d98123e756 ">
                                 <p>OCIArray *，OCITable *（OCIColl *）</p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
                  <p>对象或集合必须与其绑定的属性类型兼容。当且仅当它们是varray或嵌套表并且它们的元素类型兼容时，集合属性是类型兼容的。</p>
                  <p>下一个表显示了如何获得两种集合类型的元素的类型兼容性。</p>
                  <div class="tblformal" id="GUID-87377939-6FBA-414D-8295-D9F1EC664496__GUID-C82FAB20-D9E0-4926-BBD5-FB0B9A464002">
                     <p class="titleintable">表18-2集合和主机阵列允许的类型转换</p>
                     <table cellpadding="4" cellspacing="0" class="Formal" title="集合和主机阵列允许的类型转换" width="100%" border="1" summary="Collection and Host Array Allowable Type Conversions" frame="hsides" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="37%" id="d98123e796">集合元素类型</th>
                              <th align="left" valign="bottom" width="21%" id="d98123e799">表示</th>
                              <th align="left" valign="bottom" width="42%" id="d98123e802">主机数据类型</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="37%" id="d98123e807" headers="d98123e796 ">
                                 <p>CHAR，VARCHAR，VARCHAR2</p>
                              </td>
                              <td align="left" valign="top" width="21%" headers="d98123e807 d98123e799 ">
                                 <p>OCIString</p>
                              </td>
                              <td align="left" valign="top" width="42%" headers="d98123e807 d98123e802 ">
                                 <p>string，VARCHAR，CHARZ，OCIString</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="37%" id="d98123e817" headers="d98123e796 ">
                                 <p>REF</p>
                              </td>
                              <td align="left" valign="top" width="21%" headers="d98123e817 d98123e799 ">
                                 <p>OCIRef</p>
                              </td>
                              <td align="left" valign="top" width="42%" headers="d98123e817 d98123e802 ">
                                 <p>OCIRef</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="37%" id="d98123e827" headers="d98123e796 ">
                                 <p>INTEGER，SMALLINT，INT</p>
                              </td>
                              <td align="left" valign="top" width="21%" headers="d98123e827 d98123e799 ">
                                 <p>OCINumber</p>
                              </td>
                              <td align="left" valign="top" width="42%" headers="d98123e827 d98123e802 ">
                                 <p>int，short，OCINumber</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="37%" id="d98123e837" headers="d98123e796 ">
                                 <p>NUMBER，NUMERIC，REAL，FLOAT，DOUBLE PRECISION</p>
                              </td>
                              <td align="left" valign="top" width="21%" headers="d98123e837 d98123e799 ">
                                 <p>OCINumber</p>
                              </td>
                              <td align="left" valign="top" width="42%" headers="d98123e837 d98123e802 ">
                                 <p>int，float，double，OCINumber</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="37%" id="d98123e847" headers="d98123e796 ">
                                 <p>日期</p>
                              </td>
                              <td align="left" valign="top" width="21%" headers="d98123e847 d98123e799 ">
                                 <p>OCIDate</p>
                              </td>
                              <td align="left" valign="top" width="42%" headers="d98123e847 d98123e802 ">
                                 <p>string，VARCHAR，CHARZ，OCIDate</p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
                  <p>REF引用的对象必须与其绑定的REF类型兼容。</p>
                  <p>在两个表中，OBJECT GET使用“表示”列中指定的格式将数据库类型从左侧的类型转换为使用“主机数据类型”列中的格式的内部数据类型。OBJECT SET转换方向相反。</p>
                  <div class="section">
                     <p class="subhead2" id="GUID-87377939-6FBA-414D-8295-D9F1EC664496__GUID-3A0CCE20-266C-44F5-A21A-229A2D5D554F">没有显式类型检查</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p>预编译器不支持对集合元素数据类型和宿主变量数据类型之间的绑定进行显式类型检查。类型检查在运行时完成。</p>
                  </div>
                  <!-- class="section" -->
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="about-Objects.html#GUID-C0317114-582E-4D77-AC2E-C18E8DE6D23E">转换对象属性和C类型</a></li>
                     </ul>
                  </div>
               </div>
               
            </div><a id="LNPCC4395"></a><div class="props_rev_3"><a id="GUID-6A7D030A-7B6B-4380-9896-EA926DA506CA" name="GUID-6A7D030A-7B6B-4380-9896-EA926DA506CA"></a><h3 id="LNPCC-GUID-6A7D030A-7B6B-4380-9896-EA926DA506CA" class="sect3"><span class="enumeration_section">18.4</span>收集声明</h3>
               <div>
                  <p>本节包括集合语句的说明。</p>
               </div><a id="LNPCC4397"></a><a id="LNPCC4398"></a><a id="LNPCC4399"></a><a id="LNPCC4400"></a><a id="LNPCC4396"></a><div class="props_rev_3"><a id="GUID-BD54FAD3-30DF-45C9-9C5B-8C88C93F688C" name="GUID-BD54FAD3-30DF-45C9-9C5B-8C88C93F688C"></a><h4 id="LNPCC-GUID-BD54FAD3-30DF-45C9-9C5B-8C88C93F688C" class="sect4"><span class="enumeration_section">18.4.1</span>收集</h4>
                  <div>
                     <div class="section">
                        <p class="subhead3" id="GUID-BD54FAD3-30DF-45C9-9C5B-8C88C93F688C__GUID-388DE134-28F7-4B51-8D49-13E4A1B5EB11">目的</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>COLLECTION GET语句类似于OBJECT GET语句，但是专为集合而设计。它检索集合的元素，设置当前切片，并在适当的时候将元素转换为C类型。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-BD54FAD3-30DF-45C9-9C5B-8C88C93F688C__GUID-DC30BF61-2557-4F77-BAF9-1437E06C4739">句法</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section"><pre class="oac_no_warn" dir="ltr">EXEC SQL [AT [：] <span class="italic">database</span> ] [FOR： <span class="italic">num</span> ] COLLECTION GET： <span class="italic">collect</span> [[INDICATOR]： <span class="italic">collect_ind</span> ] INTO： <span class="italic">hv</span> [[INDICATOR]： <span class="italic">hv_ind</span> ];</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-BD54FAD3-30DF-45C9-9C5B-8C88C93F688C__GUID-937C4CBF-E58B-4273-947C-713AC69817D1">变量</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>num（IN）</p>
                        <p>请求的元素数量。如果省略此子句，则主变量的数组大小（标量为1）确定从集合中检索的元素数。</p>
                        <p>收集（IN）</p>
                        <p>主变量C集合描述符。</p>
                        <p>collect_ind（IN）</p>
                        <p>一个可选的指示符变量，返回集合的NULL状态。</p>
                        <p>hv（OUT）</p>
                        <p>接收集合元素值的宿主变量。</p>
                        <p>hv_ind（OUT）</p>
                        <p>一个可选的指示符变量，如果它是标量，则返回<code class="codeph">hv</code>的NULL状态，或者是一个包含切片中每个元素状态的数组。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-BD54FAD3-30DF-45C9-9C5B-8C88C93F688C__GUID-EBD3EB94-A3A3-41D1-A441-5C14D4256561">使用说明</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>在最后一次COLLECTION GET中实际返回的元素数量在sqlca.sqlerrd [2]中设置（不是所有GET的累计总数）。</p>
                        <p>返回的数字可能小于一个或两个切片端点超过集合边界时请求的数量。这可能发生在：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>集合描述符尚未在语法正确的ALLOCATE语句中初始化，为NULL或由于任何其他原因而无效。</p>
                           </li>
                           <li>
                              <p>该集合为NULL。其相关指标为-1。</p>
                           </li>
                           <li>
                              <p>该集合为空（没有元素）。</p>
                           </li>
                           <li>
                              <p>要求提供的元素多于收集中剩余的元素。</p>
                           </li>
                           <li>
                              <p>已执行COLLECTION TRIM语句，导致端点索引低于当前切片的起始索引。</p>
                           </li>
                        </ul>
                        <p>未正确初始化的C集合描述符会导致错误。列表中的所有其他情况将引发<code class="codeph">ORA-01403: no data found</code>错误情况。在这种情况下，在错误发生之前成功检索的元素总数仍存储在sqlca.sqlerrd [2]中。
                        </p>
                        <p>RESET后的初始GET或第一个GET会影响切片，如下所示：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>切片的结束索引将是找到最终元素的索引;这取决于请求的元素数量。如果集合的剩余部分中没有足够的元素来满足请求，则结束索引将是集合中的最后一个索引。</p>
                           </li>
                        </ul>
                        <p>后续GET会影响切片索引，如下所示：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>起始点的索引是在前一个切片的结束点之后找到第一个元素的索引。如果在前一个切片的结束点之后没有剩余的元素，则起始索引是集合中最后一个元素的索引。</p>
                           </li>
                           <li>
                              <p>下一个切片的结束索引将是找到最终元素的索引;这取决于请求的元素数量。如果集合的剩余部分中没有足够的元素来满足给定前一个切片的位置的请求，则结束索引将是集合中的最后一个索引。</p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="handling-run-time-errors.html#GUID-A6B85C80-DF68-425D-A55F-26B1E5F310C7">SQLERRD</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div><a id="LNPCC4402"></a><a id="LNPCC4403"></a><a id="LNPCC4404"></a><a id="LNPCC4405"></a><a id="LNPCC4401"></a><div class="props_rev_3"><a id="GUID-9557C98A-6ADA-4986-B8A4-E695AC1EFC07" name="GUID-9557C98A-6ADA-4986-B8A4-E695AC1EFC07"></a><h4 id="LNPCC-GUID-9557C98A-6ADA-4986-B8A4-E695AC1EFC07" class="sect4"><span class="enumeration_section">18.4.2</span>收集集</h4>
                  <div>
                     <div class="section">
                        <p class="subhead3" id="GUID-9557C98A-6ADA-4986-B8A4-E695AC1EFC07__GUID-036086BB-19E2-451B-8E79-D47F93C17FD4">目的</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>COLLECTION SET语句类似于OBJECT SET语句;它用于更新集合的元素值。当前切片中的元素将从本机C类型转换为Oracle数据类型。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-9557C98A-6ADA-4986-B8A4-E695AC1EFC07__GUID-440A0A1B-F9A7-46A9-B47E-3DCBE5B87861">句法</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section"><pre class="oac_no_warn" dir="ltr">EXEC SQL [AT [：] <span class="italic">database</span> ] [FOR： <span class="italic">num</span> ] COLLECTION SET： <span class="italic">收集</span> [[INDICATOR]： <span class="italic">collect_ind</span> ] TO： <span class="italic">hv</span> [[INDICATOR]： <span class="italic">hv_ind</span> ];</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-9557C98A-6ADA-4986-B8A4-E695AC1EFC07__GUID-266C0B16-A361-4F69-98A5-EED69AD29FA5">变量</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>num（IN）</p>
                        <p>此可选标量值是要在切片中更新的最大元素数。如果省略此子句，则主变量的数组大小（标量为1）确定从集合更新的元素数。</p>
                        <p>收集（OUT）</p>
                        <p>主变量C集合描述符。</p>
                        <p>collect_ind（OUT）</p>
                        <p>一个可选的指示符变量，用于确定集合的NULL状态。</p>
                        <p>hv（IN）</p>
                        <p>包含要在集合中更新的值的宿主变量。</p>
                        <p>hv_ind（IN）</p>
                        <p>一个关联的指示符变量，表示主变量的NULL状态。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-9557C98A-6ADA-4986-B8A4-E695AC1EFC07__GUID-C23F9BAE-313B-4F65-83A0-5CFBBB4707BB">使用说明</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>以下限制适用：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>必须在COLLECTION SET之前执行COLLECTION GET。</p>
                           </li>
                           <li>
                              <p>切片的起始和结束索引<span class="italic">始终</span>保持不变。即使在集合中放置的元素少于可以存储在当前切片中的元素，也是如此。SET语句<span class="italic">永远不会</span>更改切片的端点。它只更改当前切片中的元素。
                              </p>
                           </li>
                           <li>
                              <p>COLLECTION SET仅用于更新<span class="italic">当前切片中的</span>那些元素。您无法使用COLLECTION SET语句将新元素追加到集合中。
                              </p>
                           </li>
                           <li>
                              <p>如果尝试设置比当前切片包含的元素多的元素，则仅更新适合现有切片的那些元素。超出片的末尾的剩余元素不受影响，并且主机变量提供的任何额外值都未使用。</p>
                           </li>
                        </ul>
                        <p>主变量的维度或可选FOR子句中指定的值<code class="codeph">num</code>给出了请求在集合中更新的最大元素数。
                        </p>
                        <p>对于这些情况，变量sqlca.sqlerrd [2]返回前一个SET语句成功更新的元素数（不是累计总数），可以小于请求设置的数量（对于GET）：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>C集合描述符尚未在语法正确的ALLOCATE语句中正确初始化，或者为NULL，或者无效。</p>
                           </li>
                           <li>
                              <p>该集合是空的。</p>
                           </li>
                           <li>
                              <p>在给定集合中当前切片的位置的情况下，集合的剩余部分中的元素少于请求设置的元素。</p>
                           </li>
                           <li>
                              <p>当前切片的末尾被破坏。仅当尝试设置比现有切片中的元素更多的元素时，才会发生这种情况。</p>
                           </li>
                           <li>
                              <p>已对集合执行TRIM，使集合的最大端点索引值低于当前切片的起始索引。</p>
                           </li>
                        </ul>
                        <p>在COLLECTION GET或SET之后立即发出COLLECTION SET将仅更新<span class="italic">现有</span>切片中元素的值。紧接在COLLECTION SET之后的COLLECTION GET将如前所述推进切片。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCC4407"></a><a id="LNPCC4408"></a><a id="LNPCC4409"></a><a id="LNPCC4410"></a><a id="LNPCC4406"></a><div class="props_rev_3"><a id="GUID-786A8C5D-EAE6-46B4-9812-4254DDAE7300" name="GUID-786A8C5D-EAE6-46B4-9812-4254DDAE7300"></a><h4 id="LNPCC-GUID-786A8C5D-EAE6-46B4-9812-4254DDAE7300" class="sect4"><span class="enumeration_section">18.4.3</span>收集重置</h4>
                  <div>
                     <div class="section">
                        <p class="subhead3" id="GUID-786A8C5D-EAE6-46B4-9812-4254DDAE7300__GUID-D14BC85D-50E6-415C-B7BC-34364121844B">目的</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>将集合切片端点重置回集合的开头。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-786A8C5D-EAE6-46B4-9812-4254DDAE7300__GUID-F43D8E2A-2A06-4756-A5AF-0C679306B6ED">句法</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section"><pre class="oac_no_warn" dir="ltr">EXEC SQL [AT [：] <span class="italic">database</span> ] COLLECTION RESET： <span class="italic">collect</span> [[INDICATOR]： <span class="italic">collect_ind</span> ];</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-786A8C5D-EAE6-46B4-9812-4254DDAE7300__GUID-2BA589F3-8D9B-4683-A42C-A8C2925C255D">变量</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>收集（IN / OUT）</p>
                        <p>要重置其端点的集合。</p>
                        <p>collect_ind</p>
                        <p>可选指示符变量，用于确定集合的NULL状态。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-786A8C5D-EAE6-46B4-9812-4254DDAE7300__GUID-F984A53D-34C2-4FC5-8408-0B8762C6CB23">使用说明</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>如果给定集合为NULL或无效，则会发生错误。</p>
                        <p>COLLETION RESET不会影响集合的大小或内容。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCC4412"></a><a id="LNPCC4413"></a><a id="LNPCC4414"></a><a id="LNPCC4415"></a><a id="LNPCC4411"></a><div class="props_rev_3"><a id="GUID-61FD1CDA-2BF9-41E1-B876-6BC47BF08FCF" name="GUID-61FD1CDA-2BF9-41E1-B876-6BC47BF08FCF"></a><h4 id="LNPCC-GUID-61FD1CDA-2BF9-41E1-B876-6BC47BF08FCF" class="sect4"><span class="enumeration_section">18.4.4</span>收集附录</h4>
                  <div>
                     <div class="section">
                        <p class="subhead3" id="GUID-61FD1CDA-2BF9-41E1-B876-6BC47BF08FCF__GUID-343A11E3-FC60-4081-B34D-5D9BB9BC1513">目的</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>此语句将一组元素（一个或多个）附加到集合的末尾，从而增加集合的大小。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-61FD1CDA-2BF9-41E1-B876-6BC47BF08FCF__GUID-AB7B2B18-71D8-4926-92F7-EA18BC8CF301">句法</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section"><pre class="oac_no_warn" dir="ltr">EXEC SQL [AT [：] <span class="italic">database</span> ] [FOR： <span class="italic">num</span> ] COLLECTION APPEND： <span class="italic">src</span> [[INDICATOR]： <span class="italic">src_ind</span> ] TO： <span class="italic">collect</span> [[INDICATOR]： <span class="italic">collect_ind</span> ];</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-61FD1CDA-2BF9-41E1-B876-6BC47BF08FCF__GUID-A5A58F3F-44E9-449A-9A3E-3F262D04FC21">变量</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>num（IN）</p>
                        <p>标量，包含要追加的元素数。如果不存在，则<code class="codeph">src</code>的数组大小是要追加的元素数。
                        </p>
                        <p>src（IN）</p>
                        <p>要附加到集合的标量或元素数组。</p>
                        <p>src_ind（IN）</p>
                        <p>可选的指示符变量（标量或数组），用于确定附加元素的NULL状态。</p>
                        <p>收集（IN OUT）</p>
                        <p>附加元素的集合。</p>
                        <p>collect_ind（IN）</p>
                        <p>可选的指示符变量，用于确定集合的NULL状态。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-61FD1CDA-2BF9-41E1-B876-6BC47BF08FCF__GUID-FC270997-94BE-4C7A-87D1-DBB5EA8E5135">使用说明</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>元素一次附加一个（集合的大小增加一，数据被复制到该元素，依此类推）。</p>
                        <p>变量<code class="codeph">sqlca.sqlerrd[2]</code>返回最新APPEND成功附加的元素数（不是累计总数）。如果尝试添加超出集合上限的元素，或者附加到NULL集合，则会导致错误。仅附加适合的元素。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCC4417"></a><a id="LNPCC4418"></a><a id="LNPCC4419"></a><a id="LNPCC4420"></a><a id="LNPCC4416"></a><div class="props_rev_3"><a id="GUID-371BEEAC-527E-41D9-B27C-B4B1A045F71A" name="GUID-371BEEAC-527E-41D9-B27C-B4B1A045F71A"></a><h4 id="LNPCC-GUID-371BEEAC-527E-41D9-B27C-B4B1A045F71A" class="sect4"><span class="enumeration_section">18.4.5</span>收集<span class="enumeration_section">修剪</span></h4>
                  <div>
                     <div class="section">
                        <p class="subhead3" id="GUID-371BEEAC-527E-41D9-B27C-B4B1A045F71A__GUID-9EA547F1-1AB0-4425-BC9B-7C99A94C7519">目的</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>此语句从集合的末尾删除元素。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-371BEEAC-527E-41D9-B27C-B4B1A045F71A__GUID-40BAB460-8417-40D4-A4BA-6BB9BE2C6A7A">句法</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section"><pre class="oac_no_warn" dir="ltr">EXEC SQL [AT [：] <span class="italic">database</span> ] COLLECTION TRIM： <span class="italic">num</span> FROM： <span class="italic">collect</span> [[INDICATOR]： <span class="italic">collect_ind</span> ];</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-371BEEAC-527E-41D9-B27C-B4B1A045F71A__GUID-21A00A30-4ECA-491F-88AA-18CB333CEA3E">变量</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>num（IN）</p>
                        <p>主机标量变量，即要删除的元素数量。允许的最大值为2千兆字节。</p>
                        <p>收集（IN OUT）</p>
                        <p>要修剪的集合。</p>
                        <p>collect_ind（IN）</p>
                        <p>可选的指示符变量，用于确定集合的NULL状态。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-371BEEAC-527E-41D9-B27C-B4B1A045F71A__GUID-5E8CC8EE-219C-478D-972B-22778652548C">使用说明</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>适用限制：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>不允许使用FOR子句。</p>
                           </li>
                           <li>
                              <p><code class="codeph">num</code>的最大值是2千兆字节（4字节有符号二进制变量中的最大数字）。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">num</code>表示不允许使用指示符。
                              </p>
                           </li>
                        </ul>
                        <p>如果<code class="codeph">num</code>大于集合的大小，则返回错误。如果TRIM从当前切片中删除任何元素，则会返回警告。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCC4422"></a><a id="LNPCC4423"></a><a id="LNPCC4424"></a><a id="LNPCC4425"></a><a id="LNPCC4426"></a><a id="LNPCC4421"></a><div class="props_rev_3"><a id="GUID-B02F0C6C-15CC-4956-94B9-2BEAA543E8FF" name="GUID-B02F0C6C-15CC-4956-94B9-2BEAA543E8FF"></a><h4 id="LNPCC-GUID-B02F0C6C-15CC-4956-94B9-2BEAA543E8FF" class="sect4"><span class="enumeration_section">18.4.6</span>收集描述</h4>
                  <div>
                     <div class="section">
                        <p class="subhead3" id="GUID-B02F0C6C-15CC-4956-94B9-2BEAA543E8FF__GUID-BB7F5A71-0603-44E1-8B36-564300EBE757">目的</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>此语句返回有关集合的信息。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-B02F0C6C-15CC-4956-94B9-2BEAA543E8FF__GUID-AE241EEE-5F4D-4E0D-95C0-08A25154ACFA">句法</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section"><pre class="oac_no_warn" dir="ltr">EXEC SQL [AT [：] <span class="italic">database</span> ] COLLECTION DESCRIBE： <span class="italic">collect</span> [[INDICATOR]： <span class="italic">collect_ind</span> ] GET <span class="italic">attribute1</span> [{， <span class="italic">attributeN</span> }] INTO： <span class="italic">hv1</span> [[INDICATOR]： <span class="italic">hv_ind1</span> ] [{， <span class="italic">hvN</span> [[INDICATOR]： <span class="italic">hv_indN</span> ]} ];</pre><p>其中<code class="codeph">attributeN</code>是：</p><pre class="oac_no_warn" dir="ltr">DATA_SIZE | TYPECODE | DATA_TYPE | NUM_ELEMENTS |精度| SCALE | TYPE_NAME | TYPE_SCHEMA | SIZE | TABLE_SIZE</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-B02F0C6C-15CC-4956-94B9-2BEAA543E8FF__GUID-737CE237-6D06-436F-B58C-C3060255ADDF">变量</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>收集（IN）</p>
                        <p>宿主变量C集合描述符。</p>
                        <p>collect_ind（IN）</p>
                        <p>包含集合的NULL状态的可选指示符变量。</p>
                        <p>hv1 .. hvN（OUT）</p>
                        <p>输出要存储信息的主变量。</p>
                        <p>hv_ind1 .. hv_indN（OUT）</p>
                        <p>输出主机变量的指示符变量。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-B02F0C6C-15CC-4956-94B9-2BEAA543E8FF__GUID-75B72D28-3366-40AF-B56A-1306887FF807">使用说明</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>这些限制有效：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>集合不能为NULL。</p>
                           </li>
                           <li>
                              <p>主机变量类型应与返回的属性的类型兼容。</p>
                           </li>
                           <li>
                              <p>仅在可能发生文本截断的TYPE_NAME和TYPE_SCHEMA属性值中，才需要属性的指示符变量。</p>
                           </li>
                           <li>
                              <p>不允许使用FOR子句。</p>
                           </li>
                           <li>
                              <p>变量sqlca.sqlerrd [2]返回没有错误检索的成功属性的数量。如果DESCRIBE语句发生错误，则sqlca.sqlqerrd [2]包含在该错误之前返回的属性数，并且比发生错误的属性小1。</p>
                           </li>
                        </ul>
                        <p>下表给出了检索到的属性的属性，描述和C类型：<a id="d98123e1572" class="indexterm-anchor"></a><a id="d98123e1576" class="indexterm-anchor"></a><a id="d98123e1578" class="indexterm-anchor"></a></p>
                     </div>
                     <!-- class="section" -->
                     <div class="tblformalwide" id="GUID-B02F0C6C-15CC-4956-94B9-2BEAA543E8FF__GUID-EF7A8153-B3F5-4349-87B1-0580D5C4CA92">
                        <p class="titleintable">表18-3 COLLECTION DESCRIBE的属性</p>
                        <table cellpadding="4" cellspacing="0" class="FormalWide" title="COLLECTION DESCRIBE的属性" width="100%" border="1" summary="Attributes of a COLLECTION DESCRIBE" frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="18%" id="d98123e1592">属性</th>
                                 <th align="left" valign="bottom" width="41%" id="d98123e1595">描述</th>
                                 <th align="left" valign="bottom" width="16%" id="d98123e1598">C型</th>
                                 <th align="left" valign="bottom" width="25%" id="d98123e1601">笔记</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="18%" id="d98123e1606" headers="d98123e1592 ">
                                    <p>DATA_SIZE</p>
                                 </td>
                                 <td align="left" valign="top" width="41%" headers="d98123e1606 d98123e1595 ">
                                    <p>type属性的最大大小。返回的长度以字节为单位表示字符串。数字为22。</p>
                                 </td>
                                 <td align="left" valign="top" width="16%" headers="d98123e1606 d98123e1598 ">
                                    <p>未签约的短片</p>
                                 </td>
                                 <td align="left" valign="top" width="25%" headers="d98123e1606 d98123e1601 ">
                                    <p>对于对象或对象REF元素无效。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="18%" id="d98123e1619" headers="d98123e1592 ">
                                    <p>TYPECODE</p>
                                 </td>
                                 <td align="left" valign="top" width="41%" headers="d98123e1619 d98123e1595 ">
                                    <p>OCI类型代码。</p>
                                 </td>
                                 <td align="left" valign="top" width="16%" headers="d98123e1619 d98123e1598 ">
                                    <p>OCITypeCode</p>
                                 </td>
                                 <td align="left" valign="top" width="25%" headers="d98123e1619 d98123e1601 ">
                                    <p>-</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="18%" id="d98123e1632" headers="d98123e1592 ">
                                    <p>数据类型</p>
                                 </td>
                                 <td align="left" valign="top" width="41%" headers="d98123e1632 d98123e1595 ">
                                    <p>集合项的内部数字类型代码。</p>
                                 </td>
                                 <td align="left" valign="top" width="16%" headers="d98123e1632 d98123e1598 ">
                                    <p>未签约的短片</p>
                                 </td>
                                 <td align="left" valign="top" width="25%" headers="d98123e1632 d98123e1601 ">
                                    <p>-</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="18%" id="d98123e1645" headers="d98123e1592 ">
                                    <p>NUM_ELEMENTS</p>
                                 </td>
                                 <td align="left" valign="top" width="41%" headers="d98123e1645 d98123e1595 ">
                                    <p>varray中的最大元素数。</p>
                                 </td>
                                 <td align="left" valign="top" width="16%" headers="d98123e1645 d98123e1598 ">
                                    <p>unsigned int</p>
                                 </td>
                                 <td align="left" valign="top" width="25%" headers="d98123e1645 d98123e1601 ">
                                    <p>仅对VARRAY类型有效。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="18%" id="d98123e1658" headers="d98123e1592 ">
                                    <p>精确</p>
                                 </td>
                                 <td align="left" valign="top" width="41%" headers="d98123e1658 d98123e1595 ">
                                    <p>数字类型属性的精度。当返回值为0时，正在描述的项目未初始化，并且在数据字典中为NULL。</p>
                                 </td>
                                 <td align="left" valign="top" width="16%" headers="d98123e1658 d98123e1598 ">
                                    <p>无符号的字符</p>
                                 </td>
                                 <td align="left" valign="top" width="25%" headers="d98123e1658 d98123e1601 ">
                                    <p>仅对NUMBER类型的元素有效。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="18%" id="d98123e1671" headers="d98123e1592 ">
                                    <p>规模</p>
                                 </td>
                                 <td align="left" valign="top" width="41%" headers="d98123e1671 d98123e1595 ">
                                    <p>数字类型属性的比例。当返回值为-127时，所描述的项目未初始化，并且在数据字典中为NULL。</p>
                                 </td>
                                 <td align="left" valign="top" width="16%" headers="d98123e1671 d98123e1598 ">
                                    <p>签名的char</p>
                                 </td>
                                 <td align="left" valign="top" width="25%" headers="d98123e1671 d98123e1601 ">
                                    <p>仅对NUMBER类型的元素有效。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="18%" id="d98123e1684" headers="d98123e1592 ">
                                    <p>TYPE_NAME</p>
                                 </td>
                                 <td align="left" valign="top" width="41%" headers="d98123e1684 d98123e1595 ">
                                    <p>包含类型名称的字符串。对于对象类型，返回其名称。对于REF，返回REF指向的数据类型的名称。允许的外部数据类型是CHARZ，STRING和VARCHAR。</p>
                                 </td>
                                 <td align="left" valign="top" width="16%" headers="d98123e1684 d98123e1598 ">
                                    <p>char *</p>
                                 </td>
                                 <td align="left" valign="top" width="25%" headers="d98123e1684 d98123e1601 ">
                                    <p>仅对对象和对象REF元素有效。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="18%" id="d98123e1697" headers="d98123e1592 ">
                                    <p>TYPE_SCHEMA</p>
                                 </td>
                                 <td align="left" valign="top" width="41%" headers="d98123e1697 d98123e1595 ">
                                    <p>创建类型的模式名称。允许的外部数据类型是CHARZ，STRING和VARCHAR。</p>
                                 </td>
                                 <td align="left" valign="top" width="16%" headers="d98123e1697 d98123e1598 ">
                                    <p>char *</p>
                                 </td>
                                 <td align="left" valign="top" width="25%" headers="d98123e1697 d98123e1601 ">
                                    <p>仅对对象和对象REF元素有效。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="18%" id="d98123e1710" headers="d98123e1592 ">
                                    <p>尺寸</p>
                                 </td>
                                 <td align="left" valign="top" width="41%" headers="d98123e1710 d98123e1595 ">
                                    <p>实际存储在集合中的元素数量。对于嵌套表，SIZE包含空元素。TRIM语句通过修剪的元素数减少集合的SIZE。</p>
                                 </td>
                                 <td align="left" valign="top" width="16%" headers="d98123e1710 d98123e1598 ">
                                    <p>签名int</p>
                                 </td>
                                 <td align="left" valign="top" width="25%" headers="d98123e1710 d98123e1601 ">
                                    <p>-</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="18%" id="d98123e1723" headers="d98123e1592 ">
                                    <p>TABLE_SIZE</p>
                                 </td>
                                 <td align="left" valign="top" width="41%" headers="d98123e1723 d98123e1595 ">
                                    <p>嵌套表中的元素数。它不包括差距。</p>
                                 </td>
                                 <td align="left" valign="top" width="16%" headers="d98123e1723 d98123e1598 ">
                                    <p>签名int</p>
                                 </td>
                                 <td align="left" valign="top" width="25%" headers="d98123e1723 d98123e1601 ">
                                    <p>仅对嵌套表有效。</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                  </div><a id="LNPCC4427"></a><div class="props_rev_3"><a id="GUID-44FFEC3D-E4CE-4901-9D59-40285FB20F5D" name="GUID-44FFEC3D-E4CE-4901-9D59-40285FB20F5D"></a><h5 id="LNPCC-GUID-44FFEC3D-E4CE-4901-9D59-40285FB20F5D" class="sect5"><span class="enumeration_section">18.4.6.1</span>表中注释</h5>
                     <div>
                        <div class="section">
                           <p>Pro * C / C ++仅支持属性TYPE_NAME和TYPE_SCHEMA的外部数据类型CHARZ，STRING和VARCHAR。</p>
                           <p>除SIZE和TABLE_SIZE外，所有DESCRIBE属性都依赖于集合的元素类型，并且独立于集合的任何特定实例。另一方面，SIZE和TABLE_SIZE属性是其值严格依赖于集合的特定实例的属性。在重用已分配的集合描述符以引用同一集合的不同实例的情况下，SIZE或TABLE_SIZE值将从一个集合实例更改为另一个集合实例。NUM_ELEMENTS是集合类型的属性（在本例中为VARRAY），而不是集合元素类型，并且独立于集合的任何特定实例。</p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="LNPCC4428"></a><div class="props_rev_3"><a id="GUID-DB73C255-17AB-43EC-A1FE-D567E0FDD0F0" name="GUID-DB73C255-17AB-43EC-A1FE-D567E0FDD0F0"></a><h4 id="LNPCC-GUID-DB73C255-17AB-43EC-A1FE-D567E0FDD0F0" class="sect4"><span class="enumeration_section">18.4.7馆藏</span>使用规则</h4>
                  <div>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>必须始终显式分配主机变量集合描述符。</p>
                        </li>
                        <li>
                           <p><a id="d98123e1790" class="indexterm-anchor"></a>在ALLOCATE期间收集元数据（来自数据库的关于集合的内部Oracle数据及其元素类型）。当关闭ALLOCATE的连接或ALLOCATE之后类型发生更改时，该元数据将变为无效。</p>
                        </li>
                        <li>
                           <p>使用ALLOCATE和FREE语句开始和结束使用每个C集合描述符。</p>
                        </li>
                     </ul>
                  </div>
               </div>
            </div><a id="LNPCC4429"></a><div class="props_rev_3"><a id="GUID-4475F8F4-9410-4405-A7B2-A678D6BE5270" name="GUID-4475F8F4-9410-4405-A7B2-A678D6BE5270"></a><h3 id="LNPCC-GUID-4475F8F4-9410-4405-A7B2-A678D6BE5270" class="sect3"><span class="enumeration_section">18.5</span>集合示例代码</h3>
               <div>
                  <p>以下是SQL和Pro * C / C ++代码的示例，它们说明了COLLECTION SQL语句的用法：</p>
               </div><a id="LNPCC4430"></a><div class="props_rev_3"><a id="GUID-C64B13E1-20BB-4AA0-BB46-63CBFD3F2044" name="GUID-C64B13E1-20BB-4AA0-BB46-63CBFD3F2044"></a><h4 id="LNPCC-GUID-C64B13E1-20BB-4AA0-BB46-63CBFD3F2044" class="sect4"><span class="enumeration_section">18.5.1</span>类型和表创建</h4>
                  <div>
                     <div class="section">
                        <p>假设连接为scott / tiger，我们使用SQL创建以下类型：</p><pre class="oac_no_warn" dir="ltr">CREATE TYPE employee AS OBJECT（名称VARCHAR2（10），薪水NUMBER（8,2））; CREATE TYPE员工AS VARRAY（15）OF员工; CREATE TYPE部门AS OBJECT（名称VARCHAR2（15），团队员工）;</pre><p>现在为Object Type Translator生成的头文件。以下intype文件（称为in.typ）将用作OTT的输入：</p><pre class="oac_no_warn" dir="ltr">case =较低类型员工类型员工类型部门</pre><p>以下命令将生成头文件：</p><pre class="oac_no_warn" dir="ltr">ott intype = in.typ outtype = out.typ hfile = example.h user = scott / tiger code = c</pre><p>此头文件<code class="codeph">example.h,</code>由OTT生成：</p><pre class="oac_no_warn" dir="ltr">#ifndef EXAMPLE_ORACLE #define EXAMPLE_ORACLE #ifndef OCI_ORACLE #include &lt;oci.h&gt; #endif typedef OCIRef employee_ref; typedef OCIArray员工; typedef OCIRef department_ref; struct employee {OCIString * name; OCINumber薪水; }; typedef struct employee employee; struct employee_ind {OCIInd _atomic; OCIInd名称; OCIInd工资; }; typedef struct employee_ind employee_ind; struct department_ind {OCIInd _atomic; OCIInd名称; OCIInd团队; }; typedef struct department_ind department_ind; ＃万一</pre><div class="infoboxnote" id="GUID-C64B13E1-20BB-4AA0-BB46-63CBFD3F2044__GUID-5B6E51F0-B904-4613-BE0D-900801013532">
                           <p class="notep1">注意：</p>
                           <p><code class="codeph">oci.h</code>文件包含orl.h，它有一个定义OCIArray的typedef。那个typedef看起来像下面的'typedef OCIColl OCIArray;'其中OCIColl是一个代表通用集合的不透明结构。
                           </p>
                        </div>
                        <p>现在创建一个包含一列的简单表，如下所示：</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE部门（细分部门）;</pre><p>现在我们将在该表中插入几行：</p><pre class="oac_no_warn" dir="ltr">INSERT INTO division（细分）VALUES（部门（'会计'，员工（员工（'John'，75000），员工（'Jane'，75000））））; INSERT INTO分部（细分）VALUES（部门（'开发'，员工（员工（'Peter'，80000），员工（'Paula'，80000））））; INSERT INTO division（细分）VALUES（部门（'研究'，员工（员工（'Albert'，95000），员工（'Alison'，95000））））;</pre><p>我们现在可以在示例中使用这些类型定义和表信息。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCC4431"></a><div class="props_rev_3"><a id="GUID-1DDA1203-CE04-4007-9C17-A230217EAC0E" name="GUID-1DDA1203-CE04-4007-9C17-A230217EAC0E"></a><h4 id="LNPCC-GUID-1DDA1203-CE04-4007-9C17-A230217EAC0E" class="sect4"><span class="enumeration_section">18.5.2</span> GET和SET示例</h4>
                  <div>
                     <div class="section">
                        <p>假设我们想要从示例对象的collection属性中检索值，以一种简单的方式修改它们并将它们放回到集合中。</p>
                        <p>首先，我们需要包含example.h并为对象类型声明一个变量：</p><pre class="oac_no_warn" dir="ltr">#include &lt;example.h&gt; department * dept_p;</pre><p>现在我们将从分部表中选择“开发”部门：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL ALLOCATE：dept_p; EXEC SQL SELECT细分INTO：dept_p FROM division WHERE name ='Development';</pre><p>我们还需要一个用于员工对象类型的团队varray的变量和一个用于表示单个员工对象的变量。我们将为“开发”部门的所有团队成员加薪，因此我们还需要一个变量：</p><pre class="oac_no_warn" dir="ltr">员工* emp_array; employee * emp_p;双薪;</pre><p>现在我们必须分配我们的varray C Collection和employee对象描述符。我们将使用导航界面从对象中检索实际集合：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL ALLOCATE：emp_array; EXEC SQL ALLOCATE：emp_p; EXEC SQL OBJECT GET团队FROM：dept_p INTO：emp_array;</pre><p>我们将使用循环来遍历varray元素，使用WHENEVER指令控制循环终止：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL WHENEVER NOT FOUND DO break; while（TRUE）{</pre><p>首先，从集合中检索元素，以便我们可以更改它。实际的元素类型是员工对象：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL COLLECTION GET：emp_array INTO：emp_p;</pre><p>现在我们有了实际的对象元素，然后我们可以使用现有的导航界面继续更改属性的值。在这种情况下，我们给每个人加薪10％：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL OBJECT GET薪水来自：emp_p INTO：salary;薪水+ =（薪水* .10）; EXEC SQL OBJECT SET薪水：emp_p TO：薪水;</pre><p>完成更改后，我们可以更新集合中当前对象元素的属性值：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL COLLECTION SET：emp_array TO：emp_p; }</pre><p>一旦我们完成迭代所有集合元素，我们必须更新表的列，该表存储包含我们刚刚完成修改的集合的对象：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL UPDATE division SET subdivision =：dept_p;</pre><p>然后我们可以释放所有资源并委托我们的工作，从而终止这一系列的操作：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL FREE：emp_array; EXEC SQL FREE：emp_p; EXEC SQL FREE：dept_p; EXEC SQL COMMIT WORK;</pre><p>虽然这是一个相当小而简单的例子，但它非常全面。它清楚地演示了如何使用导航OBJECT GET语句的语义扩展从对象检索集合属性到C集合描述符。使用该C描述符，我们看到了如何使用新的COLLECTION GET和SET语句来检索和更新该集合的实际元素。我们使用导航界面来修改集合对象元素类型的属性值。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCC4432"></a><div class="props_rev_3"><a id="GUID-BBF65EC9-F226-4D1E-8937-BDE27FE88B89" name="GUID-BBF65EC9-F226-4D1E-8937-BDE27FE88B89"></a><h4 id="LNPCC-GUID-BBF65EC9-F226-4D1E-8937-BDE27FE88B89" class="sect4"><span class="enumeration_section">18.5.3</span> DESCRIBE示例</h4>
                  <div>
                     <div class="section">
                        <p>此示例说明了DESCRIBE SQL语句的简单用法。我们想要找出有关给定集合的一些基本信息。</p>
                        <p>首先，我们需要示例头文件，对象指针和SQL集合描述符：</p><pre class="oac_no_warn" dir="ltr">#include &lt;example.h&gt; department * dept_p;</pre><p>现在我们像以前一样ALLOCATE对象指针并从表中检索我们的对象：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL ALLOCATE：dept_p; EXEC SQL SELECT细分INTO：dept_p FROM division WHERE name ='Research';</pre><p>声明Pro * C / C ++变量来存储我们想要的集合属性信息：</p><pre class="oac_no_warn" dir="ltr">int size; char type_name [9];员工* emp_array;</pre><p>分配集合描述符，然后使用导航界面从对象获取集合属性：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL ALLOCATE：emp_array; EXEC SQL OBJECT GET团队FROM：dept_p INTO：emp_array;</pre><p>最后，我们可以使用新的COLLECTION DESCRIBE语句来提取所需的集合属性信息：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL COLLECTION DESCRIBE：emp_array GET SIZE，TYPE_NAME INTO：size，：type_name;</pre><div class="infoboxnote" id="GUID-BBF65EC9-F226-4D1E-8937-BDE27FE88B89__GUID-84B1C776-8ABC-4321-BF88-F1852698F1E6">
                           <p class="notep1">注意：</p>
                           <p>您可以使用与所需集合属性名称相同的主机变量名称，如本例所示。</p>
                        </div>
                        <p>因为类型<code class="codeph">employees</code>是对象员工的VARRAY，所以我们可以提取类型名称。
                        </p>
                        <p>成功完成DESCRIBE后， <code class="codeph">size</code>的值应为2（在此集合实例中，有两个元素，Albert和Alison，Research）。<code class="codeph">type_name</code>变量应为“EMPLOYEE \ 0”（默认情况下为CHARZ）。
                        </p>
                        <p>完成SQL描述符和对象指针后，我们可以释放他们的资源：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL FREE：emp_array; EXEC SQL FREE：dept_p;</pre><p>我们刚刚说明了DESCRIBE机制用于从C集合描述符中提取有关描述符所引用的底层集合的有用信息。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCC4433"></a><div class="props_rev_3"><a id="GUID-FC1A1996-3C00-4E59-B4D3-D5EA11924CAD" name="GUID-FC1A1996-3C00-4E59-B4D3-D5EA11924CAD"></a><h4 id="LNPCC-GUID-FC1A1996-3C00-4E59-B4D3-D5EA11924CAD" class="sect4"><span class="enumeration_section">18.5.4</span>复位示例</h4>
                  <div>
                     <div class="section">
                        <p>现在假设我们不是仅仅给予开发中的员工加薪，就像在GET和SET示例中那样，我们会给整个部门的每个人加薪。</p>
                        <p>我们像以前一样开始，包括由Object Type Translator生成的示例头文件。但是，这一次，我们将使用游标迭代分区中的所有部门，一次一个：</p><pre class="oac_no_warn" dir="ltr">#include &lt;example.h&gt; EXEC SQL DECLARE c CURSOR FOR SELECT细分FROM division;</pre><p>我们需要一些局部变量来操作我们的数据：</p><pre class="oac_no_warn" dir="ltr">部门* dept_p;员工* emp_array; employee * emp_p;双薪; int size;</pre><p>在我们可以使用对象和集合变量之前，我们必须首先使用此ALLOCATE语句对它们进行初始化：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL ALLOCATE：emp_array; EXEC SQL ALLOCATE：emp_p;</pre><p>现在我们准备使用我们的光标来遍历该部门的所有部门：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL OPEN c; EXEC SQL WHENEVER NOT FOUND DO break; while（TRUE）{EXEC SQL FETCH c INTO：dept_p;</pre><p>此时，我们有一个部门对象。我们需要使用导航界面从部门中提取“团队”VARRAY属性：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL OBJECT GET团队FROM：dept_p INTO：emp_array;</pre><p>在我们开始引用集合之前，我们需要通过使用RESET语句来保证切片端点设置为<span class="italic">当前</span>集合实例的开头（而不是前一个实例的结尾）：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL COLLECTION RESET：emp_array;</pre><p>现在我们将遍历varray的所有元素并像之前一样更新工资。现有的WHENEVER指令对此循环仍然有效：</p><pre class="oac_no_warn" dir="ltr">while（TRUE）{EXEC SQL COLLECTION GET：emp_array INTO：emp_p; EXEC SQL OBJECT GET薪水来自：emp_p INTO：salary;工资+ =（工资* .05）; EXEC SQL OBJECT SET薪水：emp_p TO：薪水;</pre><p>完成后，我们将更新集合属性：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL COLLECTION SET：emp_array TO：emp_p; }</pre><p>和以前一样，我们需要更新存储包含刚刚完成修改的集合的对象的表的列：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL UPDATE division SET subdivision =：dept_p; }</pre><p>循环终止表示处理结束。我们现在可以释放所有资源并承诺我们的工作：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL CLOSE c; EXEC SQL FREE：emp_p; EXEC SQL FREE：emp_array; EXEC SQL FREE：dept_p; EXEC SQL COMMIT WORK;</pre><p>此示例演示了如何将ALLOCATEd集合描述符重用于同一集合类型的不同实例。COLLECTION RESET语句确保将切片端点设置回<span class="italic">当前</span>集合实例的开头。在引用前一个集合实例期间移动后，它们不会保留在现有位置。
                        </p>
                        <p>通过以这种方式使用COLLECTION RESET语句，应用程序开发人员无需为每个相同集合类型的新实例显式释放和重新分配集合描述符。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCC4434"></a><div class="props_rev_3"><a id="GUID-D4DE2DA4-7440-4352-ACF3-A81BD01E7B7A" name="GUID-D4DE2DA4-7440-4352-ACF3-A81BD01E7B7A"></a><h4 id="LNPCC-GUID-D4DE2DA4-7440-4352-ACF3-A81BD01E7B7A" class="sect4"><span class="enumeration_section">18.5.5</span>示例程序：coldemo1.pc</h4>
                  <div>
                     <div class="section">
                        <p>以下程序coldemo1.pc位于demo目录中。<a id="d98123e2140" class="indexterm-anchor"></a></p>
                        <p>此示例演示了Pro * C客户端在集合类型数据库列中导航的三种方法。尽管提供的示例使用嵌套表，但它们也适用于varrays。</p>
                        <p>这是SQL * Plus文件coldemo1.sql，它使用calidata.sql中包含的插入和数据设置表：</p><pre class="oac_no_warn" dir="ltr">REM ************************************************* *********************** REM **这是一个SQL * Plus脚本，用于演示Pro * C / C ++中的集合操作REM **。REM **在为coldemo1.pc程序执行OTT之前运行此脚本REM ********************************** **************************************连接scott / tiger; set serveroutput on; REM确保数据库没有旧版本的表并且类型为DROP TABLE county_tbl; DROP TYPE citytbl_t; DROP TYPE city_t; REM摘要：REM县表包含有关特定美国州（此处使用加利福尼亚州）的每个REM县的人口普查信息。REM每个县都有一个名称和一组城市。REM每个城市都有一个名字和人口。REM实施：REM我们的实施遵循这种抽象REM每个城市都被实施为“城市”OBJECT，并且该县的城市REM集合使用REM实现的“城市”对象的嵌套表来实现。 CREATE TYPE city_t AS OBJECT（名称CHAR（30），人口NUMBER）; / CREATE TYPE citytbl_t AS TABLE OF city_t; / CREATE TABLE county_tbl（name CHAR（30），cities citytbl_t）NESTED TABLE cities STORE AS citytbl_t_tbl; REM使用数据加载县表。此示例使用1996年1月1日REM加州人口统计数据的估计值。@ calidata.sql; REM承诺保存COMMIT;</pre><p>有关如何设置表的说明，请参阅以下程序开头的注释，然后查看此程序演示的功能。</p><pre class="oac_no_warn" dir="ltr">/ * ***************************************** * / / *演示程序Pro * C * / * * * ************************************* * / / ********************************************* ******************************在SQL * Plus中，运行SQL脚本coldemo1.sql来创建： -  2种类型：city_t （OBJECT）和citytbl_t（NESTED TABLE） -  1个关系表county_tbl，其中包含citytbl_t嵌套表接下来，运行对象类型转换器（OTT）以生成与数据库中city_t和citytbl_t类型对应的C结构的typedef：ott int = coldemo1.typ outt = out.typ hfile = coldemo1.h code = c user = scott / tiger然后，运行Pro * C / C ++预编译器，如下所示：proc coldemo1 intype = out.typ最后，使用Pro链接生成的代码* C Makefile :(编译和链接应用程序是一个依赖于平台的步骤）。************************************************** **************************情景：我们考虑用于存储加利福尼亚州人口普查信息的数据库示例。该数据库有一个代表加利福尼亚州的表格。每个县都有一个名称和一组城市。每个城市都有一个名字和人口。应用程序概述：此示例演示了Pro * C客户端在集合类型数据库列中导航的三种方法。尽管提供的示例使用嵌套表，但它们也适用于varrays。特定于集合的功能在三个不同的功能中进行演示，如以下部分所述。PrintCounties显示*声明集合类型主机变量和数组的示例*分配和释放集合类型的主机变量*使用SQL加载集合类型的主机变量*使用集合类型主机变量的指示符*使用OCI检查集合 - 类型化主机变量PrintCounty显示*将引用游标主机变量绑定到嵌套表列的示例*分配和释放引用游标*使用SQL“CURSOR”子句CountyPopulation显示*将“DECLARED”游标绑定到嵌套表列的示例*使用SQL“THE”条款****************************************** ********************************** / / *包含文件* / #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; #include &lt;sqlca.h&gt; / * SQL通讯区* / #include &lt;coldemo1.h&gt; / * OTT生成的标头，带有用于* / / *数据库类型的C typedef city_t和citytbl_t * / #ifndef EXIT_SUCCESS #define EXIT_SUCCESS 0 #endif #ifndef EXIT_FAILURE #define EXIT_FA ILURE 1 #endif #define CITY_NAME_LEN 30 #define COUNTY_NAME_LEN 30 #define MAX_COUNTIES 60 / *函数原型* /＃if defined（__ STDC__）void OptionLoop（void）; boolean GetCountyName（char * countyName）; void PrintCounties（void）; long CountyPopulation（CONST char * countyName）; void PrintCounty（CONST char * countyName）; void PrintSQLError（void）; void PrintCountyHeader（CONST char * county）; void PrintCity（city_t * city）; #else void OptionLoop（）; boolean GetCountyName（/ * _ char * countyName _ * /）; void PrintCounties（）; long CountyPopulation（/ * _ CONST char * countyName _ * /）; void PrintCounty（/ * _ CONST char * countyName _ * /）; void PrintSQLError（/ * _ void _ * /）; void PrintCountyHeader（/ * _ CONST char * county _ * /）; void PrintCity（/ * _ city_t * city _ * /）; #endif / * * NAME * main * COLLECTION FEATURES * none * / int main（）{char * uid =“scott / tiger”;执行SQL WHENEVER SQLERROR DO PrintSQLError（）; printf（“\ nPro * Census：Release California  -  1996年1月1日。\ n”）; EXEC SQL CONNECT：uid; OptionLoop（）;的printf（ “\ nGoodbye \ n \ n”）; EXEC SQL ROLLBACK RELEASE;回报（EXIT_SUCCESS）; } / * * NAME * OptionLoop *说明*命令调度例程。* COLLECTION FEATURES * none * / void OptionLoop（）{char choice [30]; boolean done = FALSE; char countyName [COUNTY_NAME_LEN + 1];而（！完成）{printf（“\ nPro *人口普查选项：\ n”）; printf（“（A）ll县的\ t列表信息\ n”）; printf（“一个（C）ounty \ n”的\ t列表信息）; printf（一个县的“\ tlist（P）opulation total \ n”）;的printf（ “\吨（Q）UIT \ n”）;的printf（“选择？“）; fgets（choice，30，stdin）; switch（toupper（choice [0]））{case'A'：PrintCounties（）; break; case'C'：if（GetCountyName（countyName））PrintCounty（countyName） ; break; case'P'：if（GetCountyName（countyName））printf（“\ n Population for％s county：％ld \ n”，countyName，CountyPopulation（countyName））; break; case'Q'：done = TRUE; break;默认值：break;}}} / * * NAME * GetCountyName * DESCRIPTION *使用客户端提供的县名填充传递的缓冲区。*如果县在数据库中，则返回TRUE，否则返回FALSE。* COLLECTION FEATURES * none * / boolean GetCountyName（countyName）char * countyName; {int count; int i; printf（“县名？“）; fgets（countyName，COUNTY_NAME_LEN + 1，stdin）; / *将名称转换为大写并删除尾部'\ n'* / for（i = 0; countyName [i]！='\ 0'; i ++）{countyName [i] =（char）toupper（countyName [i]）; if（countyName [i] =='\ n'）countyName [i] ='\ 0'; EXEC SQL SELECT COUNT（*）INTO：count FROM county_tbl WHERE name =：countyName;如果（数！= 1）{printf（“\ n无法找到％s县。\ n”，countyName）;返回FALSE; } else返回TRUE; } / * * NAME * PrintCounties * DESCRIPTION *打印数据库中每个县*的每个城市的人口和名称。*集合特征*以下特征对应于内联注释数字* 1）集合类型对象的主变量使用* OTT生成的类型声明。允许使用数组和标量声明。*标量声明必须是指向集合类型的类型，而*数组声明必须是array-of-pointer-to-collection-type。* 2）SQL ALLOCATE应该用于为集合分配空间。*一旦不再需要集合，就应该使用SQL FREE来释放内存。分配或free'd *的主变量可以是数组也可以是标量。* 3）SQL用于加载或存储集合类型的主机变量*和数组。不需要特殊语法。* 4）集合的指标变量的类型是OCIInd。 *声明和使用集合的指示符，就像* int或字符串的指示符一样。* 5）COLLECTION GET接口用于访问和操作集合类型主变量的*内容。这里使用的*集合的每个成员都有类型city_t，由OTT生成。 * / void PrintCounties（）{citytbl_t * cityTable [MAX_COUNTIES]; / * 1 * / OCIInd cityInd [MAX_COUNTIES]; / * 4 * / char county [MAX_COUNTIES] [COUNTY_NAME_LEN + 1]; int i，numCounties; city_t * city; EXEC SQL ALLOCATE：cityTable; / * 2 * / EXEC SQL ALLOCATE：city; EXEC SQL SELECT名称，城市INTO：县，：cityTable：cityInd FROM county_tbl; / * 3,4 * / numCounties = sqlca.sqlerrd [2]; for（i = 0; i &lt;numCounties; i ++）{if（cityInd [i] == OCI_IND_NULL）/ * 4 * / {printf（“％s county \ n”的意外空城表，县[i]）; } else {/ * 5 * / PrintCountyHeader（county [i]）; EXEC SQL WHENEVER NOT FOUND DO break; while（TRUE）{EXEC SQL COLLECTION GET：cityTable [i] INTO：city;印刷城（市）; } EXEC SQL WHENEVER NOT FOUND CONTINUE; EXEC SQL FREE：city; EXEC SQL FREE：cityTable; / * 2 * /} / * * NAME * PrintCountyHeader * COLLECTION FEATURES * none * / void PrintCountyHeader（county）CONST char * county; {printf（“\ nCOUNTY：％s \ n”，县）; } / * * NAME * PrintCity * COLLECTION FEATURES * none * / void PrintCity（city）city_t * city; {varchar newCITY [CITY_NAME_LEN]; int newPOP; EXEC SQL OBJECT获取名称，人口来自：城市INTO：newCITY，：newPOP; printf（“CITY：％。* s POP：％d \ n”，CITY_NAME_LEN，newCITY.arr，newPOP）; } / * * NAME * PrintCounty * DESCRIPTION *打印特定县中每个城市的人口和名称。*收集功能*以下功能对应于内联注释数字* 1）引用游标主机变量可用于滚动集合的*行。* 2）使用SQL ALLOCATE / FREE创建和销毁引用游标。* 3）SQL中的“CURSOR”子句可用于加载ref cursor * host变量。在这种情况下，SELECT ...INTO对引用游标进行*隐式“打开”。*实现注意事项*对于包含嵌入式* CURSOR（...）子句的SQL SELECT语句，Pro * C“select_error”标志必须为“no”*以防止取消父光标。* / void PrintCounty（countyName）CONST char * countyName; {sql_cursor cityCursor; / * 1 * / city_t * city; EXEC SQL ALLOCATE：cityCursor; / * 2 * / EXEC SQL ALLOCATE：city; EXEC ORACLE OPTION（select_error = no）; EXEC SQL SELECT CURSOR（SELECT VALUE（c）FROM TABLE（county_tbl.cities）c）INTO：cityCursor FROM county_tbl WHERE county_tbl.name =：countyName; / * 3 * / EXEC ORACLE OPTION（select_error = yes）; PrintCountyHeader（countyName）; EXEC SQL WHENEVER NOT FOUND DO break; while（TRUE）{EXEC SQL FETCH：cityCursor INTO：city;印刷城（市）; } EXEC SQL WHENEVER NOT FOUND CONTINUE; EXEC SQL CLOSE：cityCursor; EXEC SQL FREE：cityCursor; / * 2 * / EXEC SQL免费：城市; } / * * NAME * CountyPopulation * DESCRIPTION *返回居住在特定县的人数。*收集功能*以下功能对应于内联注释数字* 1）“DECLARED”光标可用于滚动集合的*行。* 2）SQL中的“THE”子句用于将单个嵌套表*列转换为表。* / long CountyPopulation（countyName）CONST char * countyName; {长人口; long populationTotal = 0; EXEC SQL DECLARE cityCursor CURSOR FOR SELECT c.population FROM（SELECT CITY FROM county_tbl WHERE name =：countyName）AS c; / * 1,2 * / EXEC SQL OPEN cityCursor; EXEC SQL WHENEVER NOT FOUND DO break; while（TRUE）{EXEC SQL FETCH cityCursor INTO：population; populationTotal + =人口; } EXEC SQL WHENEVER NOT FOUND CONTINUE; EXEC SQL CLOSE cityCursor;返回人口总数; } / * * NAME * PrintSQLError * DESCRIPTION *使用sqlca中的info打印错误消息并调用exit。* COLLECTION FEATURES * none * / void PrintSQLError（）{EXEC SQL WHENEVER SQLERROR CONTINUE; printf（“发生SQL错误...... \ n”）; printf（“％。* s \ n”，（int）sqlca.sqlerrm.sqlerrml，（CONST char *）sqlca.sqlerrm.sqlerrmc）; EXEC SQL ROLLBACK RELEASE;出口（EXIT_FAILURE）; }</pre></div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>