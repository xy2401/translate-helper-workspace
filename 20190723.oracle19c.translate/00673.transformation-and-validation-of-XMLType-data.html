<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <meta name="abstract" content="There are several Oracle SQL functions and XMLType APIs for transforming XMLType data using XSLT stylesheets and for validating XMLType instances against an XML schema."></meta>
      <meta name="description" content="There are several Oracle SQL functions and XMLType APIs for transforming XMLType data using XSLT stylesheets and for validating XMLType instances against an XML schema."></meta>
      <title>XMLType数据的转换和验证</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Developer&#39;s Guide "></meta>
      <meta property="og:description" content="There are several Oracle SQL functions and XMLType APIs for transforming XMLType data using XSLT stylesheets and for validating XMLType instances against an XML schema."></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Developer&#39;s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="xml-db-developers-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-03-30T12:32:42-07:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="2002, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96222-03"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="indexes-for-XMLType-data.html" title="Previous" type="text/html"></link>
      <link rel="next" href="relational-data-to-and-from-XML-data.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="XML DB Developer&#39;s Guide"></meta>
    <meta name="dcterms.isVersionOf" content="ADXDB"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="indexes-for-XMLType-data.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="relational-data-to-and-from-XML-data.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">开发人员指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="manipulation-of-XML-in-XML-DB.html" property="item" typeof="WebPage"><span property="name">在Oracle XML DB中操作XML数据</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">XMLType数据的转换和验证</li>
            </ol>
            <a id="GUID-EC4E2212-67EF-425C-AB5E-D48E62EAB9A7" name="GUID-EC4E2212-67EF-425C-AB5E-D48E62EAB9A7"></a><a id="ADXDB0900"></a>
            
            <h2 id="ADXDB-GUID-EC4E2212-67EF-425C-AB5E-D48E62EAB9A7" class="sect2"><span class="enumeration_chapter">7</span> XMLType数据的转换和验证</h2>
         </header>
         <div class="ind">
            <div>
               <p>有几个Oracle SQL函数和<code class="codeph">XMLType</code> API，用于使用XSLT样式表转换<code class="codeph">XMLType</code>数据，以及根据XML模式验证<code class="codeph">XMLType</code>实例。
               </p>
            </div>
            <div>
               <ul class="ullinks">
                  <li class="ulchildlink"><a href="transformation-and-validation-of-XMLType-data.html#GUID-DBEB8B7E-B335-4D07-8A5D-42083A83155D">XSL转换和Oracle XML DB</a><br>您可以使用内置的Oracle XML DB XSLT处理器将XSL转换应用于基于XML Schema的文档。数据库内特定于XML的优化可以显着减少所需的内存，消除与解析相关的开销，并减少网络流量。
                  </li>
                  <li class="ulchildlink"><a href="transformation-and-validation-of-XMLType-data.html#GUID-45DAA30E-3F14-4D70-8105-ED3855B92A50">验证XMLType实例</a><br>除了需要知道特定XML文档是否格式正确之外，您还经常需要知道它是否符合给定的XML模式，即它是否对该XML模式有效。
                  </li>
               </ul>
               <div class="familylinks">
                  <div class="parentlink">
                     <p><strong>父主题：</strong> <a href="manipulation-of-XML-in-XML-DB.html#GUID-87C758D5-5792-483D-8894-4C01FCD2A8A0" title="此处介绍了以下内容：XQuery，XMLType操作和XML数据索引。">在Oracle XML DB中处理XML数据</a></p>
                  </div>
               </div>
            </div>
            <a id="ADXDB4172"></a><a id="ADXDB4171"></a><div class="props_rev_3"><a id="GUID-DBEB8B7E-B335-4D07-8A5D-42083A83155D" name="GUID-DBEB8B7E-B335-4D07-8A5D-42083A83155D"></a><h3 id="ADXDB-GUID-DBEB8B7E-B335-4D07-8A5D-42083A83155D" class="sect3"><span class="enumeration_section">7.1</span> XSL转换和Oracle XML DB</h3>
               <div>
                  <p>您可以使用内置的Oracle XML DB XSLT处理器将XSL转换应用于基于XML Schema的文档。数据库内特定于XML的优化可以显着减少所需的内存，消除与解析相关的开销，并减少网络流量。</p>
                  <p>W3C XSLT Recommendation定义了一种XML语言，用于指定如何将XML文档从一种形式转换为另一种形式。有关XSLT标准的信息，请参见<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/adxdb&amp;id=w3_org_tr_xslt" target="_blank"><code class="codeph">http://www.w3.org/TR/xslt</code></a> 。
                  </p>
                  <p>转换可以包括从一个XML模式映射到另一个XML模式，或者从XML映射到某些其他格式（如HTML或WML）。</p>
                  <p>就内存量和所需的处理而言，XSL转换可能是昂贵的。在典型的XSL处理器中，必须先解析整个源文档和样式表，然后才能开始处理。通常，XSL处理器使用DOM来提供文档和样式表的动态内存表示，以允许随机访问其不同的部分。然后，XSL处理器将样式表应用于源文档，生成第三个文档。</p>
                  <p>在开始转换之前将文档和样式表解析并加载到内存中需要大量的内存和处理器资源。当只需要转换文档的一小部分时，效率特别低。</p>
                  <p>Oracle XML DB包含一个XSLT处理器，可<span class="italic">在数据库</span>中执行XSL转换。通过这种方式，它可以提供特定于XML的优化，可以显着减少执行转换所需的内存，消除与解析相关的开销，并减少网络流量。
                  </p>
                  <p>但是， <span class="italic">仅</span>当转换源是基于<span class="italic">模式的</span> XML文档时， <span class="italic">才能</span>使用这些优化。在这种情况下，在处理开始之前无需解析。随着节点的访问，Oracle XML DB延迟加载的虚拟DOM仅在需要时加载内容。这也减少了所需的内存，因为只加载了需要处理的文档的一部分。
                  </p>
                  <p>您可以通过以下方式转换XML数据：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>在Oracle数据库中 - 使用Oracle SQL函数<code class="codeph">XMLtransform</code> ， <code class="codeph">XMLType</code>方法<code class="codeph">transform()</code>或PL / SQL包<code class="codeph">DBMS_XSLPROCESSOR</code></p>
                     </li>
                     <li>
                        <p>在中间层 - 使用Oracle XML Developer的Kit转换选项，例如XSLT Processor for Java。</p>
                     </li>
                  </ul>
                  <div class="infoboxnotealso" id="GUID-DBEB8B7E-B335-4D07-8A5D-42083A83155D__GUID-EF4E8E76-0AB6-4F9D-90FA-750FD31F6442">
                     <p class="notep1">也可以看看：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>有关SQL函数<code class="codeph">XMLTransform</code>信息，请<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/adxdb&amp;id=SQLRF06171" target="_blank"><span><cite>参见Oracle数据库SQL语言参考</cite></span></a></p>
                        </li>
                        <li>
                           <p><a href="PLSQL-APIs-for-XMLType.html#GUID-0E3358AF-0819-4B17-AF0B-793E96DA5EB9" title="您可以使用PL / SQL包DBMS_XSLPROCESSOR将一个XML文档转换为另一个XML文档，或将XML数据转换为HTML，PDF或其他格式。该包遍历文档的DOM树，并对其应用可扩展样式表语言转换（XSLT）语句以生成转换后的文档。">用于XMLType的PL / SQL XSLT处理器（DBMS_XSLPROCESSOR）</a>和<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/adxdb&amp;id=ARPLS379" target="_blank"><span><cite>Oracle数据库PL / SQL包和类型参考</cite></span></a>有关PL / SQL包<code class="codeph">DBMS_XSLPROCESSOR</code></p>
                        </li>
                        <li>
                           <p>有关XSLT Processor for Java的信息，请参阅<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/adxdb&amp;id=ADXDK19222" target="_blank"><span><cite>Oracle XML Developer's Kit程序员指南</cite></span></a></p>
                        </li>
                     </ul>
                  </div>
                  <p>这些XML转换方法中的每一个都以<code class="codeph">XMLType</code>实例的形式将源XML文档和XSL样式表作为输入。对于SQL函数<code class="codeph">XMLtransform</code>和<code class="codeph">XMLType</code>方法<code class="codeph">transform()</code> ， <code class="codeph">transform()</code>的结果可以是XML文档或非XML文档，例如HTML。但是，对于PL / SQL包<code class="codeph">DBMS_XSLPROCESSOR</code> ，转换的结果应该是有效的XML文档。使用包<code class="codeph">DBMS_XSLPROCESSOR</code>进行转换生成的任何HTML数据都是XHTML数据，它既是有效的XML数据，也是有效的HTML数据。
                  </p>
                  <p><a href="transformation-and-validation-of-XMLType-data.html#GUID-DBEB8B7E-B335-4D07-8A5D-42083A83155D__BJFCGIFJ">例7-1</a>显示了XSLT样式表<code class="codeph">PurchaseOrder.xsl</code> 。完整的样式表在<a href="oracle-supplied-XML-schemas-and-examples.html#GUID-7593BF83-2C00-477D-8973-C070253C4456" title="完整列表提供了XSLT样式表PurchaseOrder.xsl，它在各种示例中使用。">XSLT样式表示例PurchaseOrder.xsl中给出</a> 。
                  </p>
                  <p>对于<a href="transformation-and-validation-of-XMLType-data.html#GUID-DBEB8B7E-B335-4D07-8A5D-42083A83155D__BJFCGIFJ">示例7-1</a>的样式表，这些不是Oracle XML DB特有的。样式表可以存储在<code class="codeph">XMLType</code>表或列中，也可以存储为Oracle XML DB Repository中的非基于模式的XML数据。
                  </p>
                  <div class="example" id="GUID-DBEB8B7E-B335-4D07-8A5D-42083A83155D__BJFCGIFJ">
                     <p class="titleinexample">示例7-1 XSLT样式表示例：PurchaseOrder.xsl</p><pre class="oac_no_warn" dir="ltr">&lt;？xml version =“1.0”encoding =“WINDOWS-1252”？&gt; &lt;xsl：stylesheet version =“1.0”xmlns：xsl =“http://www.w3.org/1999/XSL/Transform”xmlns：xdb =“http://xmlns.oracle.com/xdb”xmlns： xsi =“http://www.w3.org/2001/XMLSchema-instance”&gt; &lt;xsl：template match =“/”&gt; &lt;html&gt; &lt;head /&gt; &lt;body bgcolor =“＃003333”text =“＃FFFFCC “link =”＃FFCC00“vlink =”＃66CC99“alink =”＃669999“&gt; &lt;FONT FACE =”Arial，Helvetica，sans-serif“&gt; &lt;xsl：for-each select =”PurchaseOrder“/&gt; &lt;xsl： for-each select =“PurchaseOrder”&gt; &lt;center&gt; &lt;span style =“font-family：Arial; font-weight：bold”&gt; &lt;FONT COLOR =“＃FF0000”&gt; &lt;B&gt; PurchaseOrder &lt;/ B&gt; &lt;/ FONT &gt; &lt;/ span&gt; &lt;/ center&gt; &lt;br/&gt; &lt;center&gt; &lt;xsl：for-each select =“Reference”&gt; &lt;span style =“font-family：Arial; font-weight：bold”&gt; &lt;xsl：apply -templates /&gt; &lt;/ span&gt; &lt;/ xsl：for-each&gt; &lt;/ center&gt; &lt;/ xsl：for-each&gt; &lt;P&gt; &lt;xsl：for-each select =“PurchaseOrder”&gt; &lt;br/&gt; &lt;/ xsl ：for-each&gt; &lt;P /&gt; &lt;P&gt; &lt;xsl：for-each select =“PurchaseOrder”&gt; &lt;br/&gt; &lt;/ xsl：for-each&gt; &lt;/ P&gt; &lt;/ P&gt; &lt;xsl：for-each select =“PurchaseOrder”/&gt; &lt;xsl：for-each select =“PurchaseOrder”&gt; &lt;table border =“0”width =“100％”BGCOLOR =“＃000000”&gt; &lt;tb ody&gt; &lt;tr&gt; &lt;td WIDTH =“296”&gt; &lt;P&gt; &lt;B&gt; &lt;FONT SIZE =“+ 1”COLOR =“＃FF0000”FACE =“Arial，Helvetica，sans-serif”&gt;内部&lt;/ FONT&gt; &lt;/ B&gt; &lt;/ P&gt; <span class="bold">......</span>&lt;/ td&gt; &lt;td width =“93”/&gt; &lt;td valign =“top”WIDTH =“340”&gt; &lt;B&gt; &lt;FONT COLOR =“＃FF0000”&gt; &lt;FONT SIZE =“+ 1”&gt;送货到&lt; / FONT&gt; &lt;/ FONT&gt; &lt;/ B&gt; &lt;xsl：for-each select =“ShippingInstructions”&gt; &lt;xsl：if test =“position（）= 1”/&gt; &lt;/ xsl：for-each&gt; &lt;xsl：for -each select =“ShippingInstructions”&gt; &lt;/ xsl：for-each&gt; <span class="bold">...</span>
</pre></div>
                  <!-- class="example" -->
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="transformation-and-validation-of-XMLType-data.html#GUID-9E65513C-C113-4EA1-8511-462AC3EEE2D8">SQL函数XMLTRANSFORM和XMLType方法TRANSFORM（）</a><br>SQL函数<code class="codeph">XMLtransform</code>使用XSLT样式表转换XML文档。它按照样式表的指定将处理后的输出作为XML，HTML等返回。
                     </li>
                     <li class="ulchildlink"><a href="transformation-and-validation-of-XMLType-data.html#GUID-A35A47AF-A28C-4B2F-BB1C-AA10500E3BAF">使用DBUri Servlet进行XSL转换</a><br>您可以将XSL转换应用于由DBUri servlet生成的XML内容。
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="transformation-and-validation-of-XMLType-data.html#GUID-EC4E2212-67EF-425C-AB5E-D48E62EAB9A7" title="有几个Oracle SQL函数和XMLType API，用于使用XSLT样式表转换XMLType数据，以及根据XML模式验证XMLType实例。">XMLType数据的转换和验证</a></p>
                     </div>
                  </div>
               </div>
               <a id="ADXDB4722"></a><a id="ADXDB4723"></a><a id="ADXDB4721"></a><div class="props_rev_3"><a id="GUID-9E65513C-C113-4EA1-8511-462AC3EEE2D8" name="GUID-9E65513C-C113-4EA1-8511-462AC3EEE2D8"></a><h4 id="ADXDB-GUID-9E65513C-C113-4EA1-8511-462AC3EEE2D8" class="sect4"><span class="enumeration_section">7.1.1</span> SQL函数XMLTRANSFORM和XMLType方法TRANSFORM（）</h4>
                  <div>
                     <p>SQL函数<code class="codeph">XMLtransform</code>使用XSLT样式表转换XML文档。它按照样式表的指定将处理后的输出作为XML，HTML等返回。
                     </p>
                     <p><a href="transformation-and-validation-of-XMLType-data.html#GUID-9E65513C-C113-4EA1-8511-462AC3EEE2D8__I1026954">图7-1</a>显示了Oracle SQL函数<code class="codeph">XMLtransform</code>的语法。此函数将<code class="codeph">XMLType</code>实例和XSLT样式表作为参数。样式表可以是<code class="codeph">XMLType</code>实例或<code class="codeph">VARCHAR2</code>字符串文字。它将样式表应用于实例并返回<code class="codeph">XMLType</code>实例。
                     </p>
                     <div class="figure" id="GUID-9E65513C-C113-4EA1-8511-462AC3EEE2D8__I1026954">
                        <p class="titleinfigure">图7-1 XMLTRANSFORM语法</p><img src="img/xmltransform.gif" width="391" alt="下面是图7-1的描述" title="下面是图7-1的描述" longdesc="img_text/xmltransform.html"><br><a href="img_text/xmltransform.html">“图7-1 XMLTRANSFORM语法”的说明</a></div>
                     <!-- class="figure" -->
                     <p>您也可以使用<code class="codeph">XMLType</code>方法<code class="codeph">transform()</code>作为Oracle SQL函数<code class="codeph">XMLtransform</code>的替代方法。它具有相同的功能。
                     </p>
                     <p><a href="transformation-and-validation-of-XMLType-data.html#GUID-9E65513C-C113-4EA1-8511-462AC3EEE2D8__I1026237">图7-2</a>显示了<code class="codeph">XMLtransform</code>如何使用XSLT样式表转换XML文档。它按照XSLT样式表的指定将处理后的输出作为XML，HTML等返回。在数据库中检索或生成存储为<code class="codeph">XMLType</code> XML文档时，通常使用<code class="codeph">XMLtransform</code> 。
                     </p>
                     <div class="infoboxnotealso" id="GUID-9E65513C-C113-4EA1-8511-462AC3EEE2D8__GUID-D322B013-B74D-40C1-90A9-9A4D54B532F9">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="intro-to-XML-DB.html#GUID-A8E97BAC-3685-46C8-8FD9-3D31D36F9344" title="Oracle XML DB通过以可互操作的方式包含SQL和XML数据模型，为Oracle数据库提供本机XML支持。">Oracle XML DB简介中的</a> <a href="intro-to-XML-DB.html#GUID-43B25825-FE37-4782-B627-8B2EFB44068D__BABCJCII">图1-3</a></p>
                     </div>
                     <div class="figure" id="GUID-9E65513C-C113-4EA1-8511-462AC3EEE2D8__I1026237">
                        <p class="titleinfigure">图7-2使用XMLTRANSFORM</p><img src="img/adxdb008.png" width="405" alt="下面是图7-2的描述" title="下面是图7-2的描述" longdesc="img_text/adxdb008.html"><br><a href="img_text/adxdb008.html">“图7-2使用XMLTRANSFORM”的描述</a></div>
                     <!-- class="figure" -->
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="transformation-and-validation-of-XMLType-data.html#GUID-8AC216AA-45F5-43F1-8E0E-0A85021E7091">XMLTRANSFORM和XMLType.transform（）：示例</a><br>示例说明如何使用Oracle SQL函数<code class="codeph">XMLtransform</code>和<code class="codeph">XMLType</code>方法<code class="codeph">transform()</code>将存储为<code class="codeph">XMLType</code> XML数据转换为各种格式。
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="transformation-and-validation-of-XMLType-data.html#GUID-DBEB8B7E-B335-4D07-8A5D-42083A83155D" title="您可以使用内置的Oracle XML DB XSLT处理器将XSL转换应用于基于XML Schema的文档。数据库内特定于XML的优化可以显着减少所需的内存，消除与解析相关的开销，并减少网络流量。">XSL转换和Oracle XML DB</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="ADXDB4725"></a><a id="ADXDB4726"></a><a id="ADXDB4728"></a><a id="ADXDB4173"></a><a id="ADXDB4724"></a><div class="props_rev_3"><a id="GUID-8AC216AA-45F5-43F1-8E0E-0A85021E7091" name="GUID-8AC216AA-45F5-43F1-8E0E-0A85021E7091"></a><h5 id="ADXDB-GUID-8AC216AA-45F5-43F1-8E0E-0A85021E7091" class="sect5"><span class="enumeration_section">7.1.1.1</span> XMLTRANSFORM和XMLType.transform（）：实施例</h5>
                     <div>
                        <p>示例说明如何使用Oracle SQL函数<code class="codeph">XMLtransform</code>和<code class="codeph">XMLType</code>方法<code class="codeph">transform()</code>将存储为<code class="codeph">XMLType</code> XML数据转换为各种格式。
                        </p>
                        <div class="section">
                           <p><a href="transformation-and-validation-of-XMLType-data.html#GUID-8AC216AA-45F5-43F1-8E0E-0A85021E7091__CFHJDEJE">示例7-2</a>设置了本章中运行其他示例所需的XML模式和表。这里对<code class="codeph">deleteSchema</code>的调用确保在创建之前没有现有的XML模式。如果不存在此类模式，则<code class="codeph">deleteSchema</code>会引发错误。
                           </p>
                           <p><a href="transformation-and-validation-of-XMLType-data.html#GUID-8AC216AA-45F5-43F1-8E0E-0A85021E7091__I1027535">示例7-3</a>存储了一个XSLT样式表，然后检索它并将其与Oracle SQL函数<code class="codeph">XMLTransform</code>一起使用，以转换<a href="transformation-and-validation-of-XMLType-data.html#GUID-8AC216AA-45F5-43F1-8E0E-0A85021E7091__CFHJDEJE">示例7-2中</a>存储的XML数据。
                           </p>
                           <p><a href="transformation-and-validation-of-XMLType-data.html#GUID-8AC216AA-45F5-43F1-8E0E-0A85021E7091__CFHGHGJI">例7-4</a>使用<code class="codeph">XMLType</code>方法<code class="codeph">transform()</code>和动态创建的XSL样式表。
                           </p>
                           <p><a href="transformation-and-validation-of-XMLType-data.html#GUID-8AC216AA-45F5-43F1-8E0E-0A85021E7091__BJFJJDIB">示例7-5</a>使用<code class="codeph">XMLTransform</code>应用XSL样式表来生成HTML代码。PL / SQL构造函数<code class="codeph">XDBURIType</code>从Oracle XML DB Repository读取XSL样式表。
                           </p>
                           <p><a href="transformation-and-validation-of-XMLType-data.html#GUID-8AC216AA-45F5-43F1-8E0E-0A85021E7091__BJFJJDIB">例7-5中</a>只显示了HTML结果的一部分。省略部分以表示省略号（ <span class="bold"><code class="codeph">. . .</code></span> ）。<a href="transformation-and-validation-of-XMLType-data.html#GUID-A35A47AF-A28C-4B2F-BB1C-AA10500E3BAF__BABJGIGH">图7-3</a>显示了Web浏览器中转换结果的样子。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-8AC216AA-45F5-43F1-8E0E-0A85021E7091__CFHJDEJE">
                           <p class="titleinexample">示例7-2注册XML模式并插入XML数据</p><pre class="oac_no_warn" dir="ltr">BEGIN  - 删除架构（如果已存在）。DBMS_XMLSCHEMA.deleteSchema（'http://www.example.com/schemas/ipo.xsd',4）;结束; / BEGIN  - 注册架构DBMS_XMLSCHEMA.registerSchema（SCHEMAURL =&gt;'http://www.example.com/schemas/ipo.xsd',SCHEMADOC =&gt;'&lt;schema targetNamespace =“http://www.example.com / IPO“xmlns =”http://www.w3.org/2001/XMLSchema“xmlns：ipo =”http://www.example.com/IPO“&gt; &lt;！ -  annotation&gt; &lt;documentation xml：lang = “en”&gt; Example.com版权所有2000 Example.com的国际采购订单架构。版权所有。&lt;/ documentation&gt; &lt;/ annotation  - &gt; &lt;element name =“purchaseOrder”type =“ipo：PurchaseOrderType”/&gt; &lt;element name =“comment”type =“string”/&gt; &lt;complexType name =“PurchaseOrderType”&gt; &lt;sequence &gt; &lt;element name =“shipTo”type =“ipo：Address”/&gt; &lt;element name =“billTo”type =“ipo：Address”/&gt; &lt;element ref =“ipo：comment”minOccurs =“0”/&gt; &lt; element name =“items”type =“ipo：Items”/&gt; &lt;/ sequence&gt; &lt;attribute name =“orderDate”type =“date”/&gt; &lt;/ complexType&gt; &lt;complexType name =“Items”&gt; &lt;sequence&gt; &lt;element name =“item”minOccurs =“0”maxOccurs =“unbounded”&gt; &lt;complexType&gt; &lt;sequence&gt; &lt;element name =“productName”type =“string”/&gt; &lt;element name =“quantity”&gt; &lt;simpleType&gt; &lt;restriction base =“positiveInteger”&gt; &lt;maxExclusive value =“100”/&gt; &lt;/ restriction&gt; &lt;/ simpleType&gt; &lt;/ element&gt; &lt;element name =“USPrice”type =“decimal”/&gt; &lt;element ref =“ipo：comment”minOccurs =“0”/&gt; &lt;element name =“shipDate”type =“date”minOccurs =“0”/&gt; &lt;/ sequence&gt; &lt;attribute name =“partNum”type =“ipo：SKU”use =“required”/&gt; &lt;/ complexType&gt; &lt;/ element&gt; &lt;/ sequence&gt; &lt;/ complexType&gt; &lt;comp lexType name =“Address”&gt; &lt;sequence&gt; &lt;element name =“name”type =“string”/&gt; &lt;element name =“street”type =“string”/&gt; &lt;element name =“city”type =“string” /&gt; &lt;element name =“state”type =“string”/&gt; &lt;element name =“country”type =“string”/&gt; &lt;element name =“zip”type =“string”/&gt; &lt;/ sequence&gt; &lt;/ complexType&gt; &lt;simpleType name =“SKU”&gt; &lt;restriction base =“string”&gt; &lt;pattern value =“[0-9] {3}  -  [AZ] {2}”/&gt; &lt;/ restriction&gt; &lt;/ simpleType&gt; &lt; / schema&gt;'，LOCAL =&gt; TRUE，GENTYPES =&gt; TRUE）;结束; /  - 创建表以保存XML采购订单文档，并插入文档DROP TABLE po_tab; CREATE TABLE po_tab（id NUMBER，xmlcol XMLType）XMLType COLUMN xmlcol XMLSCHEMA“http://www.example.com/schemas/ipo.xsd”ELEMENT“purchaseOrder”; INSERT INTO po_tab VALUES（1，XMLType（'&lt;？xml版本=“1.0”？&gt; &lt;ipo：purchaseOrder xmlns：xsi =“http://www.w3.org/2001/XMLSchema-instance”xmlns：ipo =“http://www.example.com/IPO”xsi：schemaLocation =“http： //www.example.com/IPO http://www.example.com/schemas/ipo.xsd“orderDate =”1999-12-01“&gt; &lt;shipTo&gt; &lt;name&gt; Helen Zoe &lt;/ name&gt; &lt;street&gt; 121百老汇&lt;/ street&gt; &lt;city&gt;加的夫&lt;/ city&gt; &lt;州&gt;威尔士&lt;/ state&gt; &lt;country&gt;英国&lt;/ country&gt; &lt;zip&gt; CF2 1QJ &lt;/ zip&gt; &lt;/ shipTo&gt; &lt;billTo&gt; &lt;name&gt; Robert史密斯&lt;/ name&gt; &lt;street&gt; 8 Oak Avenue &lt;/ street&gt; &lt;city&gt;旧城区&lt;/ city&gt; &lt;州&gt; CA &lt;/ state&gt; &lt;country&gt; US &lt;/ country&gt; &lt;zip&gt; 95819 &lt;/ zip&gt; &lt;/ billTo&gt; &lt;items&gt; &lt;item partNum =“833-AA”&gt; &lt;productName&gt; Lapis项链&lt;/ productName&gt; &lt;数量&gt; 1 &lt;/数量&gt; &lt;USPrice&gt; 99.95 &lt;/ USPrice&gt; &lt;ipo：comment&gt;想要这个假期！&lt;/ ipo：comment&gt; &lt;shipDate&gt; 1999-12-05 &lt;/ shipDate&gt; &lt;/ item&gt; &lt;/ items&gt; &lt;/ ipo：purchaseOrder&gt;'））;</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-8AC216AA-45F5-43F1-8E0E-0A85021E7091__I1027535">
                           <p class="titleinexample">示例7-3使用SQL函数XMLTRANSFORM应用XSL样式表</p><pre class="oac_no_warn" dir="ltr">DROP TABLE stylesheet_tab; CREATE TABLE stylesheet_tab（id NUMBER，stylesheet XMLType）; INSERT INTO stylesheet_tab VALUES（1，XMLType（'&lt;？xml版本=“1.0”？&gt; &lt;xsl：stylesheet version =“1.0”xmlns：xsl =“http://www.w3.org/1999/XSL/Transform”&gt; &lt;xsl：template match =“*”&gt; &lt;td&gt; &lt;xsl：choose&gt; &lt;xsl：when test =“count（child :: *）&gt; 1”&gt; &lt;xsl：call-template name =“nested”/&gt; &lt;/ xsl：when&gt; &lt;xsl：otherwise&gt; &lt;xsl：value-of select = “name（。）”/&gt;：&lt;xsl：value-of select =“text（）”/&gt; &lt;/ xsl：otherwise&gt; &lt;/ xsl：choose&gt; &lt;/ td&gt; &lt;/ xsl：template&gt; &lt;xsl：template match =“*”name =“nested”priority =“ -  1”mode =“nested2”&gt; &lt;b&gt; &lt;！ -  xsl：value-of select =“count（child :: *）”/  - &gt; &lt; xsl：choose&gt; &lt;xsl：when test =“count（child :: *）&gt; 1”&gt; &lt;xsl：value-of select =“name（。）”/&gt;：&lt;xsl：apply-templates mode =“nested2” /&gt; &lt;/ xsl：when&gt; &lt;xsl：otherwise&gt; &lt;xsl：value-of select =“name（。）”/&gt;：&lt;xsl：value-of select =“text（）”/&gt; &lt;/ xsl：否则&gt; &lt;/ xsl：choose&gt; &lt;/ b&gt; &lt;/ xsl：template&gt; &lt;/ xsl：stylesheet&gt;'））; SELECT XMLSerialize（DOCUMENT <span class="bold">XMLtransform</span> （x.xmlcol，y.stylesheet）AS VARCHAR2（1000））AS结果FROM po_tab x，stylesheet_tab y WHERE y.id = 1;</pre><p>这会产生以下输出（为了便于阅读，这里打印漂亮）：</p><pre class="oac_no_warn" dir="ltr">结果------------------------------------------------- -------- &lt;td&gt; &lt;b&gt; ipo：purchaseOrder：&lt;b&gt; shipTo：&lt;b&gt;名称：Helen Zoe &lt;/ b&gt; &lt;b&gt;街道：100 Broadway &lt;/ b&gt; &lt;b&gt;城市：加的夫&lt;/ b&gt; &lt;b&gt;州：威尔士&lt;/ b&gt; &lt;b&gt;国家：英国&lt;/ b&gt; &lt;b&gt;邮编：CF2 1QJ &lt;/ b&gt; &lt;/ b&gt; &lt;b&gt; billTo：&lt;b&gt;姓名：罗伯特史密斯&lt;/ b&gt; &lt;b&gt;街道：8橡树大道&lt;/ b&gt; &lt;b&gt;城市：旧城区&lt;/ b&gt; &lt;b&gt;州：CA &lt;/ b&gt; &lt;b&gt;国家：美国&lt;/ b&gt; &lt; b&gt; zip：95819 &lt;/ b&gt; &lt;/ b&gt; &lt;b&gt;项目：&lt;/ b&gt; &lt;/ b&gt; &lt;/ td&gt;</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-8AC216AA-45F5-43F1-8E0E-0A85021E7091__CFHGHGJI">
                           <p class="titleinexample">示例7-4使用带有Transient XSL样式表的XMLType方法TRANSFORM（）</p><pre class="oac_no_warn" dir="ltr">SELECT ResultSet.getString（column DOCUMENT x.xmlcol。 <span class="bold">变换</span> （的XMLType（'&lt;？xml版本=“1.0”？&gt; &lt;xsl：stylesheet version =“1.0”xmlns：xsl =“http://www.w3.org/1999/XSL/Transform”&gt; &lt;xsl：template match =“*”&gt; &lt;td&gt; &lt;xsl：choose&gt; &lt;xsl：when test =“count（child :: *）&gt; 1”&gt; &lt;xsl：call-template name =“nested”/&gt; &lt;/ xsl：when&gt; &lt;xsl：otherwise&gt; &lt;xsl：value-of select = “name（。）”/&gt;：&lt;xsl：value-of select =“text（）”/&gt; &lt;/ xsl：otherwise&gt; &lt;/ xsl：choose&gt; &lt;/ td&gt; &lt;/ xsl：template&gt; &lt;xsl：template match =“*”name =“nested”priority =“ -  1”mode =“nested2”&gt; &lt;b&gt; &lt;！ -  xsl：value-of select =“count（child :: *）”/  - &gt; &lt; xsl：choose&gt; &lt;xsl：when test =“count（child :: *）&gt; 1”&gt; &lt;xsl：value-of select =“name（。）”/&gt;：&lt;xsl：apply-templates mode =“nested2” /&gt; &lt;/ xsl：when&gt; &lt;xsl：otherwise&gt; &lt;xsl：value-of select =“name（。）”/&gt;：&lt;xsl：value-of select =“text（）”/&gt; &lt;/ xsl：否则&gt; &lt;/ xsl：choose&gt; &lt;/ b&gt; &lt;/ xsl：template&gt; &lt;/ xsl：stylesheet&gt;'））AS varchar2（1000））FROM po_tab x;</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-8AC216AA-45F5-43F1-8E0E-0A85021E7091__BJFJJDIB">
                           <p class="titleinexample">示例7-5使用XMLTRANSFORM应用使用XDBURIType检索的XSL样式表</p><pre class="oac_no_warn" dir="ltr">SELECT <span class="bold">XMLTransform</span> （OBJECT_VALUE， <span class="bold">XDBURIType</span> （'/ sources /schemas / poSource / xsl /purchaseOrder.xsl'）。getXML（））FROM purchaseorder WHERE XMLExists（'$ p / PurchaseOrder [Reference =“SBELL-2002100912333601PDT”]'PASSING OBJECT_VALUE AS “p”）; XMLTRANSFORM（OBJECT_VALUE，XDBURITYPE（'/ SOURCE / SCHEMAS / POSOURCE / XSL / PURCHASEORDER.XSL'）。GET ------------------------------------------------- -------------------------------------------- &lt;html xmlns：xdb = “http://xmlns.oracle.com/xdb”xmlns：xsi =“http://www.w3.org/2001/XMLSchema-instance”&gt; &lt;head /&gt; &lt;body bgcolor =“＃003333”text =“ #FFFFCC“link =”＃FFCC00“vlink =”＃66CC99“alink =”＃669999“&gt; &lt;FONT FACE =”Arial，Helvetica，sans-serif“&gt; &lt;center&gt; &lt;span style =”font-family：Arial; font-weight：bold“&gt; &lt;FONT COLOR =”＃FF0000“&gt; &lt;B&gt; PurchaseOrder &lt;/ B&gt; &lt;/ FONT&gt; &lt;/ span&gt; &lt;/ center&gt; &lt;br/&gt; &lt;center&gt; &lt;span style =”font- family：Arial; font-weight：bold“&gt; SBELL-2002100912333601PDT &lt;/ span&gt; &lt;/ center&gt; &lt;P&gt; &lt;br/&gt; &lt;P&gt; &lt;P&gt; &lt;/ P&gt; &lt;/ P&gt; &lt;table border =“0”width =“100％”BGCOLOR =“＃000000”&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td WIDTH =“296”&gt; &lt;P&gt; &lt;B&gt; &lt;FONT SIZE =“+ 1”COLOR =“＃ FF0000“FACE =”Arial，Helvetica，sans-serif“&gt;内部&lt;/ FONT&gt; &lt;/ B&gt; &lt;/ P&gt; &lt;table border =”0“width =”98％“BGCOLOR =”＃000099“&gt;</pre><pre class="oac_no_warn" dir="ltr"><span class="bold">。 。 。</span></pre><pre class="oac_no_warn" dir="ltr">&lt;/ table&gt; &lt;/ td&gt; &lt;td width =“93”&gt; &lt;/ td&gt; &lt;td valign =“top”WIDTH =“340”&gt; &lt;B&gt; &lt;FONT COLOR =“＃FF0000”&gt; &lt;FONT SIZE =“ +1“&gt;发货至&lt;/ FONT&gt; &lt;/ FONT&gt; &lt;/ B&gt; &lt;table border =”0“BGCOLOR =”＃999900“&gt; <span class="bold">。 。 。</span>&lt;/ table&gt; &lt;/ td&gt; &lt;/ tr&gt; &lt;/ tbody&gt; &lt;/ table&gt; &lt;br/&gt; &lt;B&gt; &lt;FONT COLOR =“＃FF0000”SIZE =“+ 1”&gt;项目：&lt;/ FONT&gt; &lt;/ B&gt; &lt;br/&gt; &lt;br/&gt; &lt;table border =“0”&gt; <span class="bold">。 。 。</span>&lt;/ table&gt; &lt;/ FONT&gt; &lt;/ body&gt; &lt;/ html&gt;选择了1行。</pre></div>
                        <!-- class="example" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="transformation-and-validation-of-XMLType-data.html#GUID-9E65513C-C113-4EA1-8511-462AC3EEE2D8" title="SQL函数XMLtransform使用XSLT样式表转换XML文档。它按照样式表的指定将处理后的输出作为XML，HTML等返回。">SQL函数XMLTRANSFORM和XMLType方法TRANSFORM（）</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="ADXDB4227"></a><a id="ADXDB4228"></a><a id="ADXDB4226"></a><div class="props_rev_3"><a id="GUID-A35A47AF-A28C-4B2F-BB1C-AA10500E3BAF" name="GUID-A35A47AF-A28C-4B2F-BB1C-AA10500E3BAF"></a><h4 id="ADXDB-GUID-A35A47AF-A28C-4B2F-BB1C-AA10500E3BAF" class="sect4"><span class="enumeration_section">7.1.2</span>使用DBUri Servlet进行XSL转换</h4>
                  <div>
                     <p>您可以将XSL转换应用于由DBUri servlet生成的XML内容。</p>
                     <p><a href="transformation-and-validation-of-XMLType-data.html#GUID-A35A47AF-A28C-4B2F-BB1C-AA10500E3BAF__BABJGIGH">图7-3</a>显示了这种转换的结果。URL如下（在此处拆分和截断）：</p><pre class="pre codeblock"><code>http：// localhost：8080 / oradb / SCOTT / PURCHASEORDER / ROW / PurchaseOrder [Reference =“SBELL-2003030912333601PDT”] contenttype = text / html＆ <span class="bold">transform = / home / SCOTT / xsl / purchaseOrder.xsl</span> ...
</code></pre><p>参数<code class="codeph">transform</code>的存在使DBUri servlet使用SQL函数<code class="codeph">XMLTransform</code>将<code class="codeph">/home/SCOTT/xsl/purchaseOrder.xsl</code>的XSL样式表应用于由主URL标识的<code class="codeph">PurchaseOrder</code>文档。转换结果（HTML代码）返回给浏览器进行显示。URL还使用参数<code class="codeph">contentType</code>指定最终文档的MIME类型是<code class="codeph">text/html</code> 。
                     </p>
                     <div class="figure" id="GUID-A35A47AF-A28C-4B2F-BB1C-AA10500E3BAF__BABJGIGH">
                        <p class="titleinfigure">图7-3使用DBUri Servlet的PurchaseOrder的数据库XSL转换</p><img src="img/xslt_po.gif" width="515" alt="下面是图7-3的描述" title="下面是图7-3的描述" longdesc="img_text/xslt_po.html"><br><a href="img_text/xslt_po.html">“图7-3使用DBUri Servlet的PurchaseOrder的数据库XSL转换”的描述</a></div>
                     <!-- class="figure" -->
                     <p><a href="transformation-and-validation-of-XMLType-data.html#GUID-A35A47AF-A28C-4B2F-BB1C-AA10500E3BAF__CEGGCDJE">图7-4</a>显示了显示为HTML文档的表<code class="codeph">departments</code> 。您无需代码即可实现此目的。您只需要一个基于SQL / XML函数的<code class="codeph">XMLType</code>视图，一个行业标准的XSL样式表和<code class="codeph">DBUri</code> servlet。
                     </p>
                     <div class="figure" id="GUID-A35A47AF-A28C-4B2F-BB1C-AA10500E3BAF__CEGGCDJE">
                        <p class="titleinfigure">图7-4使用DBUri Servlet的Departments表的数据库XSL转换</p><img src="img/dburi_emp.gif" width="597" alt="下面是图7-4的描述" title="下面是图7-4的描述" longdesc="img_text/dburi_emp.html"><br><a href="img_text/dburi_emp.html">“图7-4使用DBUri Servlet的Departments表的数据库XSL转换”的描述</a></div>
                     <!-- class="figure" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="transformation-and-validation-of-XMLType-data.html#GUID-DBEB8B7E-B335-4D07-8A5D-42083A83155D" title="您可以使用内置的Oracle XML DB XSLT处理器将XSL转换应用于基于XML Schema的文档。数据库内特定于XML的优化可以显着减少所需的内存，消除与解析相关的开销，并减少网络流量。">XSL转换和Oracle XML DB</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div><a id="ADXDB4729"></a><div class="props_rev_3"><a id="GUID-45DAA30E-3F14-4D70-8105-ED3855B92A50" name="GUID-45DAA30E-3F14-4D70-8105-ED3855B92A50"></a><h3 id="ADXDB-GUID-45DAA30E-3F14-4D70-8105-ED3855B92A50" class="sect3"><span class="enumeration_section">7.2</span>验证XMLType实例</h3>
               <div>
                  <p>除了需要知道特定XML文档是否格式正确之外，您还经常需要知道它是否符合给定的XML模式，即它是否对该XML模式有效。</p>
                  <p>基于XML模式的数据存储为二进制XML，无论何时插入或更新，它都会自动完全验证。此验证不需要构建DOM。它使用流式传输完成，这是有效的并且最小化了内存使用。</p>
                  <p>对于以对象关系存储的<code class="codeph">XMLType</code>数据，完整验证需要构建DOM，这在内存管理方面可能是昂贵的。因此，当您插入或更新以对象关系存储的数据时，Oracle XML DB不会自动执行完全验证。
                  </p>
                  <p>但是，在分解XML数据以对象关系存储它的过程中，Oracle XML DB会自动执行部分验证，以确保XML文档的结构符合从XML模式派生的SQL数据类型定义。</p>
                  <p>如果要求对对象存储的<code class="codeph">XMLType</code>数据进行完全验证，则在将数据插入数据库或更新数据之前，请考虑在客户端上进行验证。
                  </p>
                  <p>您可以使用以下命令执行完整验证并操作XML文档的记录验证状态：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>Oracle SQL函数<span class="bold"><code class="codeph">XMLIsValid</code></span>和<code class="codeph">XMLType</code>方法<span class="bold"><code class="codeph">IsSchemaValid()</code></span> - 无条件地运行验证过程。不记录任何验证状态。返回：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>如果确定文件<span class="italic">有效，</span>则为<code class="codeph">1</code> 。
                              </p>
                           </li>
                           <li>
                              <p>如果确定文档<span class="italic">无效</span>或<span class="italic">无法确定</span>文档的有效性，则为<code class="codeph">0</code> 。
                              </p>
                           </li>
                        </ul>
                     </li>
                     <li>
                        <p><code class="codeph">XMLType</code>方法<span class="bold"><code class="codeph">SchemaValidate()</code></span> - 如果验证状态为<code class="codeph">0</code> ，则运行验证过程，默认情况下为<code class="codeph">0</code> 。如果确定文档<span class="italic">有效，</span>则将验证状态设置为<code class="codeph">1</code> 。（否则，状态保持为<code class="codeph">0</code> ）
                        </p>
                     </li>
                     <li>
                        <p><code class="codeph">XMLType</code>方法<span class="bold"><code class="codeph">isSchemaValidated()</code></span>返回<code class="codeph">XMLType</code>实例的记录验证状态。
                        </p>
                     </li>
                     <li>
                        <p><code class="codeph">XMLType</code>方法<span class="bold"><code class="codeph">setSchemaValidated()</code></span>设置（记录） <code class="codeph">XMLType</code>实例的验证状态。
                        </p>
                     </li>
                  </ul>
                  <p>验证状态表明有效性的知识，如下：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><code class="codeph">1</code>表示该文档已知<span class="italic">有效</span> 。
                        </p>
                     </li>
                     <li>
                        <p><code class="codeph">0</code>表示文档的有效性<span class="italic">未知</span> 。在验证检查期间，该文档可能已被证明无效，但未记录该无效性。记录的验证状态为<code class="codeph">0</code>表示仅缺乏关于文档有效性的知识。
                        </p>
                     </li>
                  </ul>
                  <div class="section"></div>
                  <!-- class="section" -->
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="transformation-and-validation-of-XMLType-data.html#GUID-BEF51F7F-33A8-4FED-AA21-FE8849821BEC">部分和完整XML模式验证</a><br>将基于XML模式的文档插入数据库时，可以部分或完全验证它们。
                     </li>
                     <li class="ulchildlink"><a href="transformation-and-validation-of-XMLType-data.html#GUID-3563099E-B1F3-4B70-8D2F-8FA001FF632B">验证存储为XMLType的XML数据：示例</a><br>此处的示例说明了如何使用Oracle SQL函数<code class="codeph">XMLIsValid</code>和<code class="codeph">XMLType</code>方法<code class="codeph">isSchemaValid()</code>和<code class="codeph">schemaValidate()</code>来验证在Oracle XML DB中存储为<code class="codeph">XMLType</code>的XML数据。</li>
                  </ul>
                  <div class="infoboxnotealso" id="GUID-45DAA30E-3F14-4D70-8105-ED3855B92A50__GUID-F462B68A-F414-4F2B-98FB-5EBD0D1D0AAE">
                     <p class="notep1">也可以看看：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>有关Oracle SQL函数<code class="codeph">XMLIsValid</code>信息，请<a href="../sqlrf/XMLISVALID.html#SQLRF06147" target="_blank"><span><cite>参见Oracle数据库SQL语言参考</cite></span></a></p>
                        </li>
                        <li>
                           <p><a href="../arpls/XMLTYPE.html#ARPLS369" target="_blank"><span><cite>Oracle Database PL / SQL包和类型参考</cite></span></a>有关<code class="codeph">XMLType</code>方法的信息<code class="codeph">IsSchemaValid()</code> ， <code class="codeph">IsSchemaValidated()</code> ， <code class="codeph">SchemaValidate()</code>和<code class="codeph">setSchemaValidated()</code></p>
                        </li>
                     </ul>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="transformation-and-validation-of-XMLType-data.html#GUID-EC4E2212-67EF-425C-AB5E-D48E62EAB9A7" title="有几个Oracle SQL函数和XMLType API，用于使用XSLT样式表转换XMLType数据，以及根据XML模式验证XMLType实例。">XMLType数据的转换和验证</a></p>
                     </div>
                  </div>
               </div>
               <a id="ADXDB4102"></a><div class="props_rev_3"><a id="GUID-BEF51F7F-33A8-4FED-AA21-FE8849821BEC" name="GUID-BEF51F7F-33A8-4FED-AA21-FE8849821BEC"></a><h4 id="ADXDB-GUID-BEF51F7F-33A8-4FED-AA21-FE8849821BEC" class="sect4"><span class="enumeration_section">7.2.1</span>部分和完整XML模式验证</h4>
                  <div>
                     <p>将基于XML模式的文档插入数据库时，可以部分或完全验证它们。</p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="transformation-and-validation-of-XMLType-data.html#GUID-2360608F-BA11-4BEB-98F3-E79888A57BDD">部分验证</a><br>对于二进制XML存储，Oracle XML DB在将基于XML模式的文档插入<code class="codeph">XMLType</code>表或列时会完全验证它们。对于对象关系XML存储，仅执行部分验证。这是因为在性能方面，完整的XML模式验证对于对象关系存储来说是非常昂贵的。
                        </li>
                        <li class="ulchildlink"><a href="transformation-and-validation-of-XMLType-data.html#GUID-CD089007-3832-4812-8617-642B2854C6BE">完整验证</a><br>将基于XML模式的数据加载到二进制XML存储中可以完全根据目标XML模式验证它。对于对象关系<code class="codeph">XMLType</code>存储，您可以随时强制进行完全验证。
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="transformation-and-validation-of-XMLType-data.html#GUID-45DAA30E-3F14-4D70-8105-ED3855B92A50" title="除了需要知道特定XML文档是否格式正确之外，您还经常需要知道它是否符合给定的XML模式，即它是否对该XML模式有效。">XMLType实例的验证</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="ADXDB4104"></a><a id="ADXDB4103"></a><div class="props_rev_3"><a id="GUID-2360608F-BA11-4BEB-98F3-E79888A57BDD" name="GUID-2360608F-BA11-4BEB-98F3-E79888A57BDD"></a><h5 id="ADXDB-GUID-2360608F-BA11-4BEB-98F3-E79888A57BDD" class="sect5"><span class="enumeration_section">7.2.1.1</span>部分验证</h5>
                     <div>
                        <p>对于二进制XML存储，Oracle XML DB在将基于XML模式的文档插入<code class="codeph">XMLType</code>表或列时会完全验证它们。对于对象关系XML存储，仅执行部分验证。这是因为在性能方面，完整的XML模式验证对于对象关系存储来说是非常昂贵的。
                        </p>
                        <p><span class="bold">部分验证</span>仅确保存在所有必需元素和属性，并且文档中没有意外的元素或属性。也就是说，它仅确保XML文档的结构符合从XML模式派生的SQL数据类型定义。部分验证不能确保实例文档完全符合XML模式。
                        </p>
                        <p><a href="transformation-and-validation-of-XMLType-data.html#GUID-2360608F-BA11-4BEB-98F3-E79888A57BDD__BABFEGDC">示例7-6</a>提供了将XML文档插入表<code class="codeph">PurchaseOrder</code>时失败部分验证的示例，该表以对象关系存储。
                        </p>
                        <div class="example" id="GUID-2360608F-BA11-4BEB-98F3-E79888A57BDD__BABFEGDC">
                           <p class="titleinexample">示例7-6插入不正确的XML文档时出错（部分验证）</p><pre class="pre codeblock"><code>INSERT INTO purchaseorder VALUES（XMLType（bfilename（'XMLDIR'，'InvalidElement.xml'），nls_charset_id（'AL32UTF8'）））; VALUES（XMLType（bfilename（'XMLDIR'，'InvalidElement.xml'），*第2行的错误：ORA-30937：父级'/ PurchaseOrder'中没有'UserName'（命名空间'## local'）的模式定义</code></pre></div>
                        <!-- class="example" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="transformation-and-validation-of-XMLType-data.html#GUID-BEF51F7F-33A8-4FED-AA21-FE8849821BEC" title="将基于XML模式的文档插入数据库时，可以部分或完全验证它们。">部分和完整XML模式验证</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="ADXDB4105"></a><div class="props_rev_3"><a id="GUID-CD089007-3832-4812-8617-642B2854C6BE" name="GUID-CD089007-3832-4812-8617-642B2854C6BE"></a><h5 id="ADXDB-GUID-CD089007-3832-4812-8617-642B2854C6BE" class="sect5"><span class="enumeration_section">7.2.1.2</span>完全验证</h5>
                     <div>
                        <p>将基于XML模式的数据加载到二进制XML存储中可以完全根据目标XML模式验证它。对于对象关系<code class="codeph">XMLType</code>存储，您可以随时强制进行完全验证。
                        </p>
                        <p>要强制进行完全验证，请使用以下任一方法：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>表级<code class="codeph">CHECK</code>约束</p>
                           </li>
                           <li>
                              <p>PL / SQL <code class="codeph">BEFORE INSERT</code>触发器</p>
                           </li>
                        </ul>
                        <p>这两种方法都确保只有有效的XML文档才能存储在<code class="codeph">XMLType</code>表中。
                        </p>
                        <p><code class="codeph">TABLE CHECK</code>约束的优点是它易于编码。缺点是它基于Oracle SQL函数<code class="codeph">XMLisValid</code> ，因此它只能指示XML文档是否有效。如果XML文档无效，则<code class="codeph">TABLE CHECK</code>约束无法提供有关其无效<span class="italic">原因的</span>任何信息。
                        </p>
                        <p><code class="codeph">BEFORE INSERT</code>触发器需要稍多的代码。触发器通过调用<code class="codeph">XMLType</code>方法<code class="codeph">schemaValidate()</code>验证XML文档。使用<code class="codeph">schemaValidate()</code>的优点是引发的异常提供了有关实例文档错误的其他信息。使用<code class="codeph">BEFORE INSERT</code>触发器还可以在遇到无效文档时尝试纠正操作。
                        </p>
                     </div>
                     <div>
                        <ul class="ullinks">
                           <li class="ulchildlink"><a href="transformation-and-validation-of-XMLType-data.html#GUID-2920BC25-F964-452D-973B-5FACD538A744">完整的XML模式验证成本处理时间和内存使用情况</a><br>除非您使用二进制XML存储，否则完整的XML模式验证会花费处理时间和内存。因此，您应该仅在必要时执行完整的XML模式验证。
                           </li>
                        </ul>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="transformation-and-validation-of-XMLType-data.html#GUID-BEF51F7F-33A8-4FED-AA21-FE8849821BEC" title="将基于XML模式的文档插入数据库时，可以部分或完全验证它们。">部分和完整XML模式验证</a></p>
                           </div>
                        </div>
                     </div>
                     <a id="ADXDB4107"></a><a id="ADXDB4108"></a><a id="ADXDB4106"></a><div class="props_rev_3"><a id="GUID-2920BC25-F964-452D-973B-5FACD538A744" name="GUID-2920BC25-F964-452D-973B-5FACD538A744"></a><h6 id="ADXDB-GUID-2920BC25-F964-452D-973B-5FACD538A744" class="sect6"><span class="enumeration_section">7.2.1.2.1</span>完整XML模式验证成本处理时间和内存使用情况</h6>
                        <div>
                           <p>除非您使用二进制XML存储，否则完整的XML模式验证会花费处理时间和内存。因此，您应该仅在必要时执行完整的XML模式验证。</p>
                           <p>如果您可以依赖应用程序来验证XML文档，那么通过避免与完全验证相关的开销，您可以通过非二进制XML存储获得更高的总体吞吐量。如果无法确定传入XML文档的有效性，则可以依赖数据库来确保<code class="codeph">XMLType</code>表或列仅包含模式有效的XML文档。
                           </p>
                           <p><a href="transformation-and-validation-of-XMLType-data.html#GUID-2920BC25-F964-452D-973B-5FACD538A744__BABHIFBH">示例7-7</a>显示了如何通过向<code class="codeph">XMLType</code>表添加<code class="codeph">CHECK</code>约束来强制进行完整的XML模式验证。在<a href="transformation-and-validation-of-XMLType-data.html#GUID-2920BC25-F964-452D-973B-5FACD538A744__BABHIFBH">示例7-7中</a> ，XML文档<code class="codeph">InvalidReference</code>对于XML模式无效。XML模式为与<code class="codeph">Reference</code>元素关联的文本节点定义了最少18个字符的长度。在本文档中，节点包含值<code class="codeph">SBELL-20021009</code> ，其长度仅为14个字符。部分验证不会捕获此错误。除非存在约束或触发器，否则尝试将此文档插入数据库将成功。
                           </p>
                           <div class="example" id="GUID-2920BC25-F964-452D-973B-5FACD538A744__BABHIFBH">
                              <p class="titleinexample">示例7-7使用CHECK约束强制进行完整的XML模式验证</p><pre class="pre codeblock"><code>ALTER TABLE purchaseorder ADD CONSTRAINT validate_purchaseorder <span class="bold">CHECK（XMLIsValid（OBJECT_VALUE）= 1）;</span>表改变了。INSERT INTO purchaseorder VALUES（XMLType（bfilename（'XMLDIR'，'InvalidReference.xml'），nls_charset_id（'AL32UTF8'）））;在第1行插入购买订单*错误：ORA-02290：违反了检查约束（QUINE.VALIDATE_PURCHASEORDER）</code></pre><p>伪列<code class="codeph">OBJECT_VALUE</code>可用于从触发器内访问<code class="codeph">XMLType</code>表的内容。<a href="transformation-and-validation-of-XMLType-data.html#GUID-2920BC25-F964-452D-973B-5FACD538A744__BABDJDHC">示例7-8</a>说明了这一点，显示了如何使用<code class="codeph">BEFORE INSERT</code>触发器来验证插入到<code class="codeph">XMLType</code>表中的数据是否符合指定的XML模式。
                              </p>
                           </div>
                           <!-- class="example" -->
                           <div class="example" id="GUID-2920BC25-F964-452D-973B-5FACD538A744__BABDJDHC">
                              <p class="titleinexample">示例7-8使用BEFORE INSERT触发器实施完整的XML模式验证</p><pre class="pre codeblock"><code>在购买订单之前创建或替换TRIGGER validate_purchaseorder每个行开始IF（：new。OBJECT_VALUE不是NULL）那么：新的。<span class="bold">OBJECT_VALUE.schemavalidate</span> （）;万一;结束; / INSERT INTO purchaseorder VALUES（XMLType（bfilename（'XMLDIR'，'InvalidReference.xml'），nls_charset_id（'AL32UTF8'）））; VALUES（XMLType（bfilename（'XMLDIR'，'InvalidReference.xml'），*第2行的错误：ORA-31154：无效的XML文档ORA-19202：XML处理错误LSX-00221：“SBELL-20021009”也是short（最小长度为18）LSX-00213：只有0次出现的粒子“序列”，最小值为1 ORA-06512：在“SYS.XMLTYPE”，第354行ORA-06512：在“QUINE.VALIDATE_PURCHASEORDER”，第3行ORA -04088：执行触发器'QUINE.VALIDATE_PURCHASEORDER'时出错</code></pre></div>
                           <!-- class="example" -->
                        </div>
                        <div>
                           <div class="familylinks">
                              <div class="parentlink">
                                 <p><strong>父主题：</strong> <a href="transformation-and-validation-of-XMLType-data.html#GUID-CD089007-3832-4812-8617-642B2854C6BE" title="将基于XML模式的数据加载到二进制XML存储中可以完全根据目标XML模式验证它。对于对象关系XMLType存储，您可以随时强制进行完全验证。">完全验证</a></p>
                              </div>
                           </div>
                        </div>
                        
                     </div>
                  </div>
               </div><a id="ADXDB4741"></a><a id="ADXDB4742"></a><a id="ADXDB4743"></a><a id="ADXDB4744"></a><a id="ADXDB4740"></a><div class="props_rev_3"><a id="GUID-3563099E-B1F3-4B70-8D2F-8FA001FF632B" name="GUID-3563099E-B1F3-4B70-8D2F-8FA001FF632B"></a><h4 id="ADXDB-GUID-3563099E-B1F3-4B70-8D2F-8FA001FF632B" class="sect4"><span class="enumeration_section">7.2.2</span>验证存储为XMLType的XML数据：示例</h4>
                  <div>
                     <p>此处的示例说明了如何使用Oracle SQL函数<code class="codeph">XMLIsValid</code>和<code class="codeph">XMLType</code>方法<code class="codeph">isSchemaValid()</code>和<code class="codeph">schemaValidate()</code>来验证在Oracle XML DB中存储为<code class="codeph">XMLType</code>的XML数据。</p>
                     <div class="section">
                        <p><a href="transformation-and-validation-of-XMLType-data.html#GUID-3563099E-B1F3-4B70-8D2F-8FA001FF632B__CFHHFGAI">示例7-9</a>和<a href="transformation-and-validation-of-XMLType-data.html#GUID-3563099E-B1F3-4B70-8D2F-8FA001FF632B__CFHCEHFA">示例7-10</a>显示了如何使用PL / SQL方法<code class="codeph">isSchemaValid</code> （）针对XML模式验证XML实例。
                        </p>
                        <p><code class="codeph">XMLType</code>方法<code class="codeph">schemaValidate()</code>可以在<code class="codeph">INSERT</code>和<code class="codeph">UPDATE</code>触发器中使用，以确保存储在表中的所有实例都针对XML模式进行验证。<a href="transformation-and-validation-of-XMLType-data.html#GUID-3563099E-B1F3-4B70-8D2F-8FA001FF632B__CFHJFAEG">例7-11</a>说明了这一点。
                        </p>
                        <p><a href="transformation-and-validation-of-XMLType-data.html#GUID-3563099E-B1F3-4B70-8D2F-8FA001FF632B__CFHEGCDB">示例7-12</a>使用Oracle SQL函数<code class="codeph">XMLIsValid</code>执行以下操作：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p>验证<code class="codeph">XMLType</code>实例是否符合指定的XML架构</p>
                           </li>
                           <li>
                              <p>使用<code class="codeph">CHECK</code>约束确保传入的XML文档有效</p>
                           </li>
                        </ul>
                        <div class="infoboxnote" id="GUID-3563099E-B1F3-4B70-8D2F-8FA001FF632B__GUID-432B1B1F-C9D8-4FCA-BF9B-E888BBA6DA28">
                           <p class="notep1">注意：</p>
                           <p>验证<a href="transformation-and-validation-of-XMLType-data.html#GUID-45DAA30E-3F14-4D70-8105-ED3855B92A50" title="除了需要知道特定XML文档是否格式正确之外，您还经常需要知道它是否符合给定的XML模式，即它是否对该XML模式有效。">XMLType实例中</a>描述的验证函数和过程便于验证检查。其中， <code class="codeph">schemaValidate</code>是唯一一个引发错误的错误，指示验证失败的原因。
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-3563099E-B1F3-4B70-8D2F-8FA001FF632B__CFHHFGAI">
                        <p class="titleinexample">示例7-9在SQL中使用方法ISSCHEMAVALID（）验证XML</p><pre class="oac_no_warn" dir="ltr">SELECT x.xmlcol。 <span class="bold">isSchemaValid</span> （'http://www.example.com/schemas/ipo.xsd'，'purchaseOrder'）FROM po_tab x;</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-3563099E-B1F3-4B70-8D2F-8FA001FF632B__CFHCEHFA">
                        <p class="titleinexample">示例7-10使用PL / SQL中的方法ISSCHEMAVALID（）验证XML</p><pre class="oac_no_warn" dir="ltr">DECLARE xml_instance XMLType; BEGIN SELECT x.xmlcol INTO xml_instance FROM po_tab x WHERE id = 1;如果是xml_instance。 <span class="bold">isSchemaValid</span> （'http://www.example.com/schemas/ipo.xsd'）= 0 THEN raise_application_error（-20500，'Invalid Instance'）; ELSE DBMS_OUTPUT.put_line（'实例有效'）;万一;结束; / Instance是成功完成的有效PL / SQL过程。
</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-3563099E-B1F3-4B70-8D2F-8FA001FF632B__CFHJFAEG">
                        <p class="titleinexample">示例7-11使用触发器中的方法SCHEMAVALIDATE（）验证XML</p><pre class="oac_no_warn" dir="ltr">DROP TABLE po_tab; CREATE TABLE po_tab OF XMLType XMLSCHEMA“http://www.example.com/schemas/ipo.xsd”ELEMENT“purchaseOrder”;在插入或更新po_tab之前创建TRIGGER emp_trig对于每个行DECLARE newxml XMLType; BEGIn newxml：=：new。OBJECT_VALUE; XMLTYPE。 <span class="bold">schemavalidate</span> （newxml）;结束; /</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-3563099E-B1F3-4B70-8D2F-8FA001FF632B__CFHEGCDB">
                        <p class="titleinexample">示例7-12在CHECK约束内使用XMLISVALID检查XML有效性</p><pre class="oac_no_warn" dir="ltr">DROP TABLE po_tab; CREATE TABLE po_tab OF XMLType（ <span class="bold">CHECK</span> （ <span class="bold">XMLIsValid</span> （OBJECT_VALUE）= 1））XMLSCHEMA“http://www.example.com/schemas/ipo.xsd”ELEMENT“purchaseOrder”;</pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="transformation-and-validation-of-XMLType-data.html#GUID-45DAA30E-3F14-4D70-8105-ED3855B92A50" title="除了需要知道特定XML文档是否格式正确之外，您还经常需要知道它是否符合给定的XML模式，即它是否对该XML模式有效。">XMLType实例的验证</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div>
         </div>
      </article>
   </body>
</html>