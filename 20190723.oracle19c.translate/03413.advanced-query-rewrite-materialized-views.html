<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <title>物化视图的高级查询重写</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Data Warehousing Guide"></meta>
      <meta property="og:description" content=""></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Data Warehousing Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="database-data-warehousing-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-09T00:20:13-08:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="2001, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96243-01"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="basic-query-rewrite-materialized-views.html" title="Previous" type="text/html"></link>
      <link rel="next" href="attribute-clustering.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Database Data Warehousing Guide"></meta>
    <meta name="dcterms.isVersionOf" content="DWHSG"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="basic-query-rewrite-materialized-views.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="attribute-clustering.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">数据仓库指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="part-optimizing-dw.html" property="item" typeof="WebPage"><span property="name">优化数据仓库</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">物化视图的高级查询重写</li>
            </ol>
            <a id="GUID-0906CA6B-7EE3-42E1-A598-C6541BCD9B36" name="GUID-0906CA6B-7EE3-42E1-A598-C6541BCD9B36"></a>
            
            <h2 id="DWHSG-GUID-0906CA6B-7EE3-42E1-A598-C6541BCD9B36" class="sect2"><span class="enumeration_chapter">12</span>物化视图的高级查询重写</h2>
         </header>
         <div class="ind">
            <div>
               <p>本章讨论Oracle中的高级查询重写主题，并包含：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="advanced-query-rewrite-materialized-views.html#GUID-A8988A2F-DA65-4AB6-86ED-6C838B84DCE9">Oracle如何重写查询</a></p>
                  </li>
                  <li>
                     <p><a href="advanced-query-rewrite-materialized-views.html#GUID-5297DA70-0064-4EA4-B492-E45089E5074F">查询重写的类型</a></p>
                  </li>
                  <li>
                     <p><a href="advanced-query-rewrite-materialized-views.html#GUID-96BFEEAA-1C8A-4F8A-9EAF-6CDD9B148EA6" title="查询重写认为混合分区表中的外部分区具有UNKNOWN新鲜度。因此，当查询从一个或多个外部分区请求数据时，它只能在TRUSTED或STALE_TOLERATED完整性模式下重写。">其他查询重写注意事项</a></p>
                  </li>
                  <li>
                     <p><a href="advanced-query-rewrite-materialized-views.html#GUID-94D148DC-1E2A-4791-A7B6-28F9BF0306C1">使用等效性重写高级查询</a></p>
                  </li>
                  <li>
                     <p><a href="advanced-query-rewrite-materialized-views.html#GUID-71197259-E8A4-45E5-A462-A9ADF6517CD6">使用等效项创建结果缓存物化视图</a></p>
                  </li>
                  <li>
                     <p><a href="advanced-query-rewrite-materialized-views.html#GUID-41A13A98-E51A-435A-973E-05CC083F2CFC" title="如果可以使用物化视图回答这些查询，则会自动重写包含返回近似结果的SQL函数的查询以使用匹配的物化视图。">基于近似查询的查询重写和物化视图</a></p>
                  </li>
                  <li>
                     <p><a href="advanced-query-rewrite-materialized-views.html#GUID-3AB77341-BDA9-4F84-9691-EB79E4C8B832">验证是否已发生查询重写</a></p>
                  </li>
                  <li>
                     <p><a href="advanced-query-rewrite-materialized-views.html#GUID-098C13EA-774C-49D9-8199-A8092BA7D437">提高查询重写能力的设计考虑因素</a></p>
                  </li>
               </ul>
            </div><a id="DWHSG0801"></a><div class="props_rev_3"><a id="GUID-A8988A2F-DA65-4AB6-86ED-6C838B84DCE9" name="GUID-A8988A2F-DA65-4AB6-86ED-6C838B84DCE9"></a><h3 id="DWHSG-GUID-A8988A2F-DA65-4AB6-86ED-6C838B84DCE9" class="sect3"><span class="enumeration_section">12.1</span> Oracle如何重写查询</h3>
               <div>
                  <p><a id="d44607e92" class="indexterm-anchor"></a>优化器使用许多不同的方法来重写查询。确定查询重写是否可行的第一步是查看查询是否满足以下先决条件：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>实例化视图中存在的连接存在于SQL中。</p>
                     </li>
                     <li>
                        <p>物化视图中有足够的数据来回答查询。</p>
                     </li>
                  </ul>
                  <p>之后，它必须确定它将如何重写查询。当存储在物化视图中的结果与查询请求的结果完全匹配时，会出现最简单的情况。优化程序通过将查询文本与实例化视图定义的文本进行比较来进行此类确定。此文本匹配方法最直接，但符合此类查询重写条件的查询数量最少。</p>
                  <p>当文本比较测试失败时，优化器会根据提取的连接，选择，分组，聚合和列数据执行一系列通用检查。这是通过单独比较查询的各种子句（ <code class="codeph">SELECT</code> ， <code class="codeph">FROM</code> ， <code class="codeph">WHERE</code> ， <code class="codeph">HAVING</code>或<code class="codeph">GROUP</code> <code class="codeph">BY</code> ）与物化视图的子句来实现的。
                  </p>
                  <p>您可以使用以下类型的查询重写： <a href="advanced-query-rewrite-materialized-views.html#GUID-A95A5C58-B011-44FF-B5CB-EE4FDEE032D5">查询重写方法1：文本匹配重写</a>或<a href="advanced-query-rewrite-materialized-views.html#GUID-14503E5A-F841-4568-B1E7-79ED1C3718A2">常规查询重写方法</a> 。
                  </p>
                  <p>以下主题更详细地讨论了优化器：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="advanced-query-rewrite-materialized-views.html#GUID-5780D6A4-2675-4C4B-9DE9-80A3FE89BC1B">关于基于成本的优化和查询重写</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-query-rewrite-materialized-views.html#GUID-14503E5A-F841-4568-B1E7-79ED1C3718A2">一般查询重写方法</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-query-rewrite-materialized-views.html#GUID-AF8326B6-DADD-4893-85DB-7456A3DC2756">关于查询重写的检查</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-query-rewrite-materialized-views.html#GUID-9279E302-ECD5-4316-B0AC-493507C7F7F2">关于使用维度重写查询</a></p>
                     </li>
                  </ul>
               </div><a id="DWHSG8499"></a><a id="DWHSG08011"></a><div class="props_rev_3"><a id="GUID-5780D6A4-2675-4C4B-9DE9-80A3FE89BC1B" name="GUID-5780D6A4-2675-4C4B-9DE9-80A3FE89BC1B"></a><h4 id="DWHSG-GUID-5780D6A4-2675-4C4B-9DE9-80A3FE89BC1B" class="sect4"><span class="enumeration_section">12.1.1</span>关于基于成本的优化和查询重写</h4>
                  <div>
                     <p>重写查询时，Oracle基于成本的优化程序会比较重写查询和原始查询的成本，并选择更便宜的执行计划。</p>
                     <p><a id="d44607e184" class="indexterm-anchor"></a>查询重写可通过基于成本的优化获得。Oracle数据库在重写和不重写的情况下优化输入查询，并选择成本最低的替代方案。优化器通过一次一个地重写一个或多个查询块来重写查询。
                     </p>
                     <p>如果查询重写可以在多个物化视图之间进行选择以重写查询块，则会选择可以导致读取数据量最少的查询块。在为重写选择了物化视图之后，优化器然后测试是否可以使用其他物化视图进一步重写重写的查询。此过程继续，直到无法进一步重写为止。然后优化重写的查询并优化原始查询。优化器比较这两个优化并选择成本最低的替代方案。</p>
                     <p>由于优化基于成本，因此收集查询中涉及的表和表示物化视图的表的统计信息非常重要。统计信息是用于计算重写查询成本的基本度量，例如表中的行数。它们是使用<code class="codeph">DBMS_STATS</code>包创建的。
                     </p>
                     <p>包含内联视图或命名视图的查询也是查询重写的候选者。当查询包含命名视图时，视图名称用于在物化视图和查询之间进行匹配。当查询包含内联视图时，可以在实体化视图与查询之间进行匹配之前将内联视图合并到查询中。</p>
                     <p><a href="advanced-query-rewrite-materialized-views.html#GUID-5780D6A4-2675-4C4B-9DE9-80A3FE89BC1B__I1006234">图12-1</a>显示了重写过程中使用的基于成本的方法的图形视图。
                     </p>
                     <div class="figure" id="GUID-5780D6A4-2675-4C4B-9DE9-80A3FE89BC1B__I1006234">
                        <p class="titleinfigure">图12-1查询重写过程</p><img src="img/dwhsg017.gif" alt="下面是图12-1的描述" title="下面是图12-1的描述" longdesc="img_text/dwhsg017.html"><br><a href="img_text/dwhsg017.html">“图12-1查询重写过程”的描述</a></div>
                     <!-- class="figure" -->
                  </div>
               </div><a id="DWHSG08012"></a><div class="props_rev_3"><a id="GUID-14503E5A-F841-4568-B1E7-79ED1C3718A2" name="GUID-14503E5A-F841-4568-B1E7-79ED1C3718A2"></a><h4 id="DWHSG-GUID-14503E5A-F841-4568-B1E7-79ED1C3718A2" class="sect4"><span class="enumeration_section">12.1.2</span>一般查询重写方法</h4>
                  <div>
                     <p>优化器有许多不同类型的查询重写方法，可以从中选择回答查询。当文本匹配重写不可能时，这组重写方法称为通用查询重写。使用这些更高级技术的优点是可以使用一个或多个物化视图来回答许多不同的查询，并且查询并不总是必须完全匹配物化视图才能进行查询重写。</p>
                     <p>使用常规查询重写方法时，优化程序使用它可以依赖的数据关系，例如主键和外键约束和维对象。例如，主键和外键关系告诉优化器外键表中的每一行最多与主键表中的一行连接。此外，如果外键上存在<code class="codeph">NOT</code> <code class="codeph">NULL</code>约束，则表示外键表中的每一行必须连接到主键表中的一行。维度对象描述日期，月份和年份之间的关系，可用于将数据从日期汇总到月份级别。
                     </p>
                     <p>这些数据关系对于查询重写非常重要，因为它们告诉我们通过连接，分组或聚合数据产生什么类型的结果。因此，为了在数据库中存在此类数据关系时最大化大量查询的可重写性，您应该声明约束和维度。</p>
                     <div class="infoboxnotealso" id="GUID-14503E5A-F841-4568-B1E7-79ED1C3718A2__GUID-5E753C50-9979-4D16-B304-1EDFEB937903">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="advanced-query-rewrite-materialized-views.html#GUID-00BE44C0-6DC0-4C74-B50D-B5C67E8170BB">何时查询重写需要约束和维度？</a></p>
                     </div>
                  </div><a id="DWHSG8501"></a><a id="DWHSG8500"></a><div class="props_rev_3"><a id="GUID-00BE44C0-6DC0-4C74-B50D-B5C67E8170BB" name="GUID-00BE44C0-6DC0-4C74-B50D-B5C67E8170BB"></a><h5 id="DWHSG-GUID-00BE44C0-6DC0-4C74-B50D-B5C67E8170BB" class="sect5"><span class="enumeration_section">12.1.2.1</span>何时查询重写需要约束和维数？
                     </h5>
                     <div>
                        <p><a href="advanced-query-rewrite-materialized-views.html#GUID-00BE44C0-6DC0-4C74-B50D-B5C67E8170BB__g1021681" title="查询重写的维度和约束要求">表12-1</a>说明了不同类型的查询重写所需的维度和约束。本章将介绍这些类型的查询重写。
                        </p>
                        <div class="tblformal" id="GUID-00BE44C0-6DC0-4C74-B50D-B5C67E8170BB__g1021681">
                           <p class="titleintable">表12-1查询重写的维度和约束要求</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="查询重写的维度和约束要求" width="100%" border="1" summary="Dimension and Constraint Requirements for Query Rewrite" frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="31%" id="d44607e279">查询重写类型</th>
                                    <th align="left" valign="bottom" width="22%" id="d44607e282">外形尺寸</th>
                                    <th align="left" valign="bottom" width="48%" id="d44607e285">主键/外键/非空约束</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d44607e290" headers="d44607e279 ">
                                       <p>匹配SQL文本</p>
                                    </td>
                                    <td align="left" valign="top" width="22%" headers="d44607e290 d44607e282 ">
                                       <p>不需要</p>
                                    </td>
                                    <td align="left" valign="top" width="48%" headers="d44607e290 d44607e285 ">
                                       <p>不需要</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d44607e300" headers="d44607e279 ">
                                       <p>加入吧</p>
                                    </td>
                                    <td align="left" valign="top" width="22%" headers="d44607e300 d44607e282 ">
                                       <p>要求或</p>
                                    </td>
                                    <td align="left" valign="top" width="48%" headers="d44607e300 d44607e285 ">
                                       <p>需要</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d44607e310" headers="d44607e279 ">
                                       <p>聚合可计算性</p>
                                    </td>
                                    <td align="left" valign="top" width="22%" headers="d44607e310 d44607e282 ">
                                       <p>不需要</p>
                                    </td>
                                    <td align="left" valign="top" width="48%" headers="d44607e310 d44607e285 ">
                                       <p>不需要</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d44607e320" headers="d44607e279 ">
                                       <p>汇总汇总</p>
                                    </td>
                                    <td align="left" valign="top" width="22%" headers="d44607e320 d44607e282 ">
                                       <p>不需要</p>
                                    </td>
                                    <td align="left" valign="top" width="48%" headers="d44607e320 d44607e285 ">
                                       <p>不需要</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d44607e330" headers="d44607e279 ">
                                       <p>汇总使用维度</p>
                                    </td>
                                    <td align="left" valign="top" width="22%" headers="d44607e330 d44607e282 ">
                                       <p>需要</p>
                                    </td>
                                    <td align="left" valign="top" width="48%" headers="d44607e330 d44607e285 ">
                                       <p>不需要</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d44607e340" headers="d44607e279 ">
                                       <p>过滤数据</p>
                                    </td>
                                    <td align="left" valign="top" width="22%" headers="d44607e340 d44607e282 ">
                                       <p>不需要</p>
                                    </td>
                                    <td align="left" valign="top" width="48%" headers="d44607e340 d44607e285 ">
                                       <p>不需要</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d44607e350" headers="d44607e279 ">
                                       <p>PCT重写</p>
                                    </td>
                                    <td align="left" valign="top" width="22%" headers="d44607e350 d44607e282 ">
                                       <p>不需要</p>
                                    </td>
                                    <td align="left" valign="top" width="48%" headers="d44607e350 d44607e285 ">
                                       <p>不需要</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d44607e360" headers="d44607e279 ">
                                       <p>多个物化视图</p>
                                    </td>
                                    <td align="left" valign="top" width="22%" headers="d44607e360 d44607e282 ">
                                       <p>不需要</p>
                                    </td>
                                    <td align="left" valign="top" width="48%" headers="d44607e360 d44607e285 ">
                                       <p>不需要</p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                     </div>
                  </div>
               </div><a id="DWHSG08013"></a><div class="props_rev_3"><a id="GUID-AF8326B6-DADD-4893-85DB-7456A3DC2756" name="GUID-AF8326B6-DADD-4893-85DB-7456A3DC2756"></a><h4 id="DWHSG-GUID-AF8326B6-DADD-4893-85DB-7456A3DC2756" class="sect4"><span class="enumeration_section">12.1.3</span>关于查询重写检查</h4>
                  <div>
                     <p>查询<a id="d44607e392" class="indexterm-anchor"></a>重写要发生，有一些数据必须通过的检查。这些检查是：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="advanced-query-rewrite-materialized-views.html#GUID-CDDBBA45-FB35-481B-9CC9-8E049B40B8AB">加入查询重写的兼容性检查</a></p>
                        </li>
                        <li>
                           <p><a href="advanced-query-rewrite-materialized-views.html#GUID-5D05C98E-4020-4634-AC3E-9B24AF38893E">查询重写的数据充足性检查</a></p>
                        </li>
                        <li>
                           <p><a href="advanced-query-rewrite-materialized-views.html#GUID-9A52FD90-681E-40B6-9DBE-F0D338380BE4">分组兼容性检查查询重写</a></p>
                        </li>
                        <li>
                           <p><a href="advanced-query-rewrite-materialized-views.html#GUID-E0156059-DF92-4302-80D3-C6C066130B3E">查询重写的聚合可计算性检查</a></p>
                        </li>
                     </ul>
                  </div><a id="DWHSG8503"></a><a id="DWHSG8502"></a><div class="props_rev_3"><a id="GUID-CDDBBA45-FB35-481B-9CC9-8E049B40B8AB" name="GUID-CDDBBA45-FB35-481B-9CC9-8E049B40B8AB"></a><h5 id="DWHSG-GUID-CDDBBA45-FB35-481B-9CC9-8E049B40B8AB" class="sect5"><span class="enumeration_section">12.1.3.1</span>加入兼容性检查查询重写</h5>
                     <div>
                        <p><a id="d44607e440" class="indexterm-anchor"></a>在此检查中，将查询中的联接与实例化视图中的联接进行比较。通常，此比较会将联接分类分为三类：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>查询和物化视图中出现的公共连接。这些连接形成了共同的子图。</p>
                              <p>参见<a href="advanced-query-rewrite-materialized-views.html#GUID-C4AA632B-09EE-4A67-95B4-D6DD7B18950A">Common Joins</a> 。
                              </p>
                           </li>
                           <li>
                              <p>Delta连接在查询中发生但不在实体化视图中。这些连接形成查询delta子图。</p>
                              <p>请参阅<a href="advanced-query-rewrite-materialized-views.html#GUID-B8FC3ACE-11D3-404D-9C32-FFF9AEC945A7">查询增量连接</a> 。
                              </p>
                           </li>
                           <li>
                              <p>Delta连接发生在物化视图中但不在查询中。这些连接形成物化视图delta子图。</p>
                              <p>请参见<a href="advanced-query-rewrite-materialized-views.html#GUID-FB70D563-A1E9-4B15-B9AF-AAE736DAD8CD">物化视图Delta连接</a> 。
                              </p>
                           </li>
                        </ul>
                        <p>这些可以显示， <a href="advanced-query-rewrite-materialized-views.html#GUID-CDDBBA45-FB35-481B-9CC9-8E049B40B8AB__CHDDIIEJ">如图12-2</a>所示。
                        </p>
                        <div class="figure" id="GUID-CDDBBA45-FB35-481B-9CC9-8E049B40B8AB__CHDDIIEJ">
                           <p class="titleinfigure">图12-2查询重写子图</p><img src="img/dwhsg016.gif" alt="下面是图12-2的描述" title="下面是图12-2的描述" longdesc="img_text/dwhsg016.html"><br><a href="img_text/dwhsg016.html">“图12-2查询重写子图”的说明</a></div>
                        <!-- class="figure" -->
                        <div class="infoboxnotealso" id="GUID-CDDBBA45-FB35-481B-9CC9-8E049B40B8AB__GUID-4AC10C11-EB92-4E60-BF1B-914CEEF4F289">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="advanced-query-rewrite-materialized-views.html#GUID-AF8326B6-DADD-4893-85DB-7456A3DC2756">关于查询重写的检查</a></p>
                        </div>
                     </div>
                     <div class="props_rev_3"><a id="GUID-C4AA632B-09EE-4A67-95B4-D6DD7B18950A" name="GUID-C4AA632B-09EE-4A67-95B4-D6DD7B18950A"></a><h6 id="DWHSG-GUID-C4AA632B-09EE-4A67-95B4-D6DD7B18950A" class="sect6"><span class="enumeration_section">12.1.3.1.1</span>公共连接</h6>
                        <div>
                           <p>该<a id="d44607e506" class="indexterm-anchor"></a>两者之间的公共连接对必须是相同的类型，或者查询中的连接必须可以从物化视图中的连接派生。例如，如果物化视图包含表<code class="codeph">A</code>与表<code class="codeph">B</code>的外部联接，并且查询包含表<code class="codeph">A</code>与表<code class="codeph">B</code>的内部联接，则可以通过从结果中筛选反连接行来派生内部联接的结果。外连接。例如，请考虑以下查询：</p><pre class="oac_no_warn" dir="ltr">SELECT p.prod_name，t.week_ending_day，SUM（s.amount_sold）FROM sales s，products p，times t WHERE s.time_id = t.time_id AND s.prod_id = p.prod_id AND mv.week_ending_day BETWEEN TO_DATE（'01  - AUG-1999'，'DD-MON-YYYY'）和TO_DATE（'10 -AUG-1999'，'DD-MON-YYYY'）GROUP BY p.prod_name，mv.week_ending_day;</pre><p>此查询与物化视图<code class="codeph">join_sales_time_product_mv</code>之间的公共连接是：</p><pre class="oac_no_warn" dir="ltr">s.time_id = t.time_id AND s.prod_id = p.prod_id</pre><p>它们完全匹配，查询可以重写如下：</p><pre class="oac_no_warn" dir="ltr">SELECT p.prod_name，mv.week_ending_day，SUM（s.amount_sold）FROM join_sales_time_product_mv WHERE mv.week_ending_day BETWEEN TO_DATE（'01 -AUG-1999'，'DD-MON-YYYY'）和TO_DATE（'10 -AUG-1999' ，'DD-MON-YYYY'）GROUP BY mv.prod_name，mv.week_ending_day;</pre><p>还可以使用<code class="codeph">join_sales_time_product_oj_mv</code>物化视图来回答查询，其中查询中的内部联接可以从物化视图中的外部联接派生。重写版本（对用户透明）过滤掉反连接行。重写的查询具有以下结构：</p><pre class="oac_no_warn" dir="ltr">SELECT mv.prod_name，mv.week_ending_day，SUM（mv.amount_sold）FROM join_sales_time_product_oj_mv mv WHERE mv.week_ending_day BETWEEN TO_DATE（'01 -AUG-1999'，'DD-MON-YYYY'）和TO_DATE（'10 -AUG-1999 '，'DD-MON-YYYY'）和mv.prod_id IS NOT NULL GROUP by mv.prod_name，mv.week_ending_day;</pre><p>通常，如果在仅包含连接的实例化视图中使用外连接，则应在实体化视图中放置外连接右侧的主键或rowid。例如，在前面的示例<code class="codeph">join_sales_time_product_oj_mv</code> ， <code class="codeph">sales</code>和<code class="codeph">products</code>都有一个主键。
                           </p>
                           <p>使用仅包含连接的物化视图的另一个示例是半连接重写的情况。也就是说，查询包含具有单个表的<code class="codeph">EXISTS</code>或<code class="codeph">IN</code>子查询。请考虑以下查询，该查询报告销售额超过1,000美元的产品：</p><pre class="oac_no_warn" dir="ltr">SELECT DISTINCT p.prod_name FROM products p WHERE EXISTS（SELECT p.prod_id，SUM（s.amount_sold）FROM sales s WHERE p.prod_id = s.prod_id HAVING SUM（s.amount_sold）&gt; 1000）GROUP BY p.prod_id）;</pre><p>此查询也可以表示为：</p><pre class="oac_no_warn" dir="ltr">SELECT DISTINCT p.prod_name FROM products p WHERE p.prod_id IN（SELECT s.prod_id FROM sales s WHERE s.amount_sold&gt; 1000）;</pre><p>此查询包含<code class="codeph">products</code>和<code class="codeph">sales</code>表之间的半连接（ <code class="codeph">s.prod_id = p.prod_id</code> ）。
                           </p>
                           <p>该查询可以被改写为使用所述<code class="codeph">join_sales_time_product_mv</code>物化视图中，如果外键约束是活性或<code class="codeph">join_sales_time_product_oj_mv</code>物化视图中，如果主键是有效的。观察两个物化视图都包含<code class="codeph">s.prod_id=p.prod_id</code> ，可用于在查询中派生半连接。使用<code class="codeph">join_sales_time_product_mv</code>重写查询，如下所示：</p><pre class="oac_no_warn" dir="ltr">SELECT mv.prod_name FROM（SELECT DISTINCT mv.prod_name FROM join_sales_time_product_mv mv WHERE mv.amount_sold&gt; 1000）;</pre><p>如果物化视图<code class="codeph">join_sales_time_product_mv</code>由<code class="codeph">time_id</code>分区，则此查询可能比原始查询更有效，因为已避免<code class="codeph">sales</code>和<code class="codeph">products</code>之间的原始连接。可以使用<code class="codeph">join_sales_time_product_oj_mv</code>重写查询，如下所示。
                           </p><pre class="oac_no_warn" dir="ltr">SELECT mv.prod_name FROM（SELECT DISTINCT mv.prod_name FROM join_sales_time_product_oj_mv mv WHERE mv.amount_sold&gt; 1000 AND mv.prod_id IS NOT NULL）;</pre><p>具有半连接的重写仅限于仅具有连接的实体化视图，对于具有连接和聚合的实体化视图是不可能的。</p>
                           <div class="infoboxnotealso" id="GUID-C4AA632B-09EE-4A67-95B4-D6DD7B18950A__GUID-6BD3E1F2-1383-4F1A-BF69-FEB38F308745">
                              <p class="notep1">也可以看看：</p>
                              <p><a href="advanced-query-rewrite-materialized-views.html#GUID-AF8326B6-DADD-4893-85DB-7456A3DC2756">关于查询重写的检查</a></p>
                           </div>
                        </div>
                     </div><a id="DWHSG8505"></a><div class="props_rev_3"><a id="GUID-B8FC3ACE-11D3-404D-9C32-FFF9AEC945A7" name="GUID-B8FC3ACE-11D3-404D-9C32-FFF9AEC945A7"></a><h6 id="DWHSG-GUID-B8FC3ACE-11D3-404D-9C32-FFF9AEC945A7" class="sect6"><span class="enumeration_section">12.1.3.1.2</span>查询Delta连接</h6>
                        <div>
                           <p><span class="bold">查询</span> <span class="bold">增量</span> <span class="bold">连接</span>是显示在查询中但不在实例化视图中的连接。允许在查询中使用任何数量和类型的delta连接，并且在使用实例化视图重写查询时，只需保留它们。为了使保留的连接起作用，实例化视图必须包含连接键。重写后，实例化视图将连接到查询增量中的相应表。例如，请考虑以下查询：</p><pre class="oac_no_warn" dir="ltr">SELECT p.prod_name，t.week_ending_day，c.cust_city，SUM（s.amount_sold）FROM sales s，products p，times t，customers c WHERE s.time_id = t.time_id AND s.prod_id = p.prod_id AND s。 cust_id = c.cust_id GROUP BY p.prod_name，t.week_ending_day，c.cust_city;</pre><p>使用物化视图<code class="codeph">join_sales_time_product_mv</code> ，常见连接是： <code class="codeph">s.time_id=t.time_id</code>和<code class="codeph">s.prod_id=p.prod_id</code> 。查询中的delta连接是<code class="codeph">s.cust_id=c.cust_id</code> 。然后，重写的表单将<code class="codeph">join_sales_time_product_mv</code>物化视图与<code class="codeph">customers</code>表连接，如下所示：</p><pre class="oac_no_warn" dir="ltr">SELECT mv.prod_name，mv.week_ending_day，c.cust_city，SUM（mv.amount_sold）FROM join_sales_time_product_mv mv，customers c WHERE mv.cust_id = c.cust_id GROUP BY mv.prod_name，mv.week_ending_day，c.cust_city;</pre><div class="infoboxnotealso" id="GUID-B8FC3ACE-11D3-404D-9C32-FFF9AEC945A7__GUID-C7B41779-AF2C-476C-85F4-3C6C4D8BD55D">
                              <p class="notep1">也可以看看：</p>
                              <p><a href="advanced-query-rewrite-materialized-views.html#GUID-AF8326B6-DADD-4893-85DB-7456A3DC2756">关于查询重写的检查</a></p>
                           </div>
                        </div>
                     </div><a id="DWHSG8506"></a><div class="props_rev_3"><a id="GUID-FB70D563-A1E9-4B15-B9AF-AAE736DAD8CD" name="GUID-FB70D563-A1E9-4B15-B9AF-AAE736DAD8CD"></a><h6 id="DWHSG-GUID-FB70D563-A1E9-4B15-B9AF-AAE736DAD8CD" class="sect6"><span class="enumeration_section">12.1.3.1.3</span>物化视图Delta连接</h6>
                        <div>
                           <p><span class="bold">物化</span> <span class="bold">视图</span> <span class="bold">增量</span> <span class="bold">连接</span>是显示在实例化视图中但不显示在查询中的连接。在物化视图中的所有de lta连接都要求对于常见连接的结果是无损的。无损连接可确保公共连接的结果不受限制。<span class="bold">无损</span>连接是指如果将两个名为<code class="codeph">A</code>和<code class="codeph">B</code>表连接在一起，表<code class="codeph">A</code>行将始终与表<code class="codeph">B</code>行匹配，并且不会丢失任何数据，因此称为无损连接。例如，如果外键中不允许空值，则具有外键的每一行都与具有主键的行匹配。因此，为了保证无损连接，必须在适当的连接键上使用<code class="codeph">FOREIGN</code> <code class="codeph">KEY</code> ， <code class="codeph">PRIMARY</code> <code class="codeph">KEY</code>和<code class="codeph">NOT</code> <code class="codeph">NULL</code>约束。或者，如果表<code class="codeph">A</code>和<code class="codeph">B</code>之间的连接是外连接（ <code class="codeph">A</code>是外表），则它是无损的，因为它保留了表<code class="codeph">A</code>所有行。</p>
                           <p>物化视图中的所有delta连接都需要相对于公共连接的结果不重复。非重复连接可确保不重复公共连接的结果。例如，非重复连接是指如果表<code class="codeph">A</code>和表<code class="codeph">B</code>连接在一起，表<code class="codeph">A</code>行将与表<code class="codeph">B</code>中的最多一行匹配且不发生重复。为了保证非重复连接，必须使用主键或唯一约束将表<code class="codeph">B</code>的键约束为唯一值。
                           </p>
                           <p>考虑以下连接<code class="codeph">sales</code>和<code class="codeph">times</code>查询：</p><pre class="oac_no_warn" dir="ltr">SELECT t.week_ending_day，SUM（s.amount_sold）FROM sales s，times t WHERE s.time_id = t.time_id AND t.week_ending_day BETWEEN TO_DATE（'01 -AUG-1999'，'DD-MON-YYYY'）和TO_DATE （'10 -AUG-1999'，'DD-MON-YYYY'）GROUP BY week_ending_day;</pre><p>物化视图<code class="codeph">join_sales_time_product_mv</code>在<code class="codeph">sales</code>和<code class="codeph">products</code>之间有一个额外的连接（ <code class="codeph">s.prod_id=p.prod_id</code> ）。这是<code class="codeph">join_sales_time_product_mv</code>的delta连接。如果此连接是无损且非重复的，则可以重写查询。如果<code class="codeph">s.prod_id</code>是<code class="codeph">s.prod_id</code>的外键并且不为null， <code class="codeph">p.prod_id</code>这种情况。因此，查询被重写为：</p><pre class="oac_no_warn" dir="ltr">SELECT week_ending_day，SUM（amount_sold）FROM join_sales_time_product_mv WHERE week_ending_day BETWEEN TO_DATE（'01 -AUG-1999'，'DD-MON-YYYY'）和TO_DATE（'10 -AUG-1999'，'DD-MON-YYYY'）GROUP BY week_ending_day;</pre><p>也可以使用物化视图<code class="codeph">join_sales_time_product_mv_oj</code>重写查询，其中不需要外键约束。此视图包含<code class="codeph">sales</code>和<code class="codeph">products</code>之间的外部<code class="codeph">s.prod_id=p.prod_id</code> （ <code class="codeph">s.prod_id=p.prod_id</code> （+））。这使得连接无损。如果<code class="codeph">p.prod_id</code>是主键，则也满足非重复条件，优化器重写查询，如下所示：</p><pre class="oac_no_warn" dir="ltr">SELECT week_ending_day，SUM（amount_sold）FROM join_sales_time_product_oj_mv WHERE week_ending_day BETWEEN TO_DATE（'01 -AUG-1999'，'DD-MON-YYYY'）和TO_DATE（'10 -AUG-1999'，'DD-MON-YYYY'）GROUP BY week_ending_day;</pre><p>也可以使用物化视图<code class="codeph">join_sales_time_product_mv_oj</code>重写查询，其中不需要外键约束。此视图包含<code class="codeph">sales</code>和<code class="codeph">products</code>之间的外部<code class="codeph">s.prod_id=p.prod_id</code> （ <code class="codeph">s.prod_id=p.prod_id</code> （+））。这使得连接无损。如果<code class="codeph">p.prod_id</code>是主键，则也满足非重复条件，优化器重写查询，如下所示：</p><pre class="oac_no_warn" dir="ltr">SELECT week_ending_day，SUM（amount_sold）FROM join_sales_time_product_oj_mv WHERE week_ending_day BETWEEN TO_DATE（'01 -AUG-1999'，'DD-MON-YYYY'）和TO_DATE（'10 -AUG-1999'，'DD-MON-YYYY'）GROUP BY week_ending_day;</pre><p>请注意， <code class="codeph">join_sales_time_product_mv_oj</code>定义中的外连接不是必需的，因为主键 - <code class="codeph">sh</code>模式中的<code class="codeph">sales</code>和<code class="codeph">products</code>之间的外键关系已经是无损的。它仅用于演示目的，如果<code class="codeph">sales.prod_id</code>为空，则必须使用，因此违反了连接条件<code class="codeph">sales.prod_id = products.prod_id</code>的无损。
                           </p>
                           <p>当前限制将大多数带有外连接的重写限制为仅具有连接的物化视图。对具有外连接的物化聚合视图的重写的支持有限，因此这些实体化视图应该依赖外键约束来确保物化视图delta连接的无损。</p>
                           <div class="infoboxnotealso" id="GUID-FB70D563-A1E9-4B15-B9AF-AAE736DAD8CD__GUID-BA16C43C-DDF5-4E96-99E5-30DDEC22E93D">
                              <p class="notep1">也可以看看：</p>
                              <p><a href="advanced-query-rewrite-materialized-views.html#GUID-AF8326B6-DADD-4893-85DB-7456A3DC2756">关于查询重写的检查</a></p>
                           </div>
                        </div>
                     </div><a id="DWHSG8507"></a><div class="props_rev_3"><a id="GUID-A931828B-F676-427C-9170-8CF5AB5FAA1C" name="GUID-A931828B-F676-427C-9170-8CF5AB5FAA1C"></a><h6 id="DWHSG-GUID-A931828B-F676-427C-9170-8CF5AB5FAA1C" class="sect6"><span class="enumeration_section">12.1.3.1.4</span>加入等价识别</h6>
                        <div>
                           <p>查询重写能够基于等效连接的识别进行许多转换。查询重写将以下构造识别为等同于连接：</p><pre class="oac_no_warn" dir="ltr">WHERE table1.column1 = F（args）/ * sub-expression A * / AND table2.column2 = F（args）/ * sub-expression B * /</pre><p>如果<code class="codeph">F(args)</code>是一个被声明为确定性的PL / SQL函数，并且两个<code class="codeph">F</code>调用的参数相同，那么子表达式<code class="codeph">A</code>和子表达式<code class="codeph">B</code>的组合可以被识别为<code class="codeph">table1.column1</code>和<code class="codeph">table2.column2</code> 。也就是说，以下表达式等同于前一个表达式：</p><pre class="oac_no_warn" dir="ltr">WHERE table1.column1 = F（args）/ * sub-expression A * / AND table2.column2 = F（args）/ * sub-expression B * / AND table1.column1 = table2.column2 / * join-expression J * /</pre><p>因为可以从子表达式<code class="codeph">A</code>和子表达式<code class="codeph">B</code>推断出连接表达式<code class="codeph">J</code> ，所以推断的连接可以用于匹配物化视图中<code class="codeph">table1.column1 = table2.column2</code>的对应连接。
                           </p>
                        </div>
                     </div>
                  </div><a id="DWHSG8504"></a><a id="DWHSG8508"></a><div class="props_rev_3"><a id="GUID-5D05C98E-4020-4634-AC3E-9B24AF38893E" name="GUID-5D05C98E-4020-4634-AC3E-9B24AF38893E"></a><h5 id="DWHSG-GUID-5D05C98E-4020-4634-AC3E-9B24AF38893E" class="sect5"><span class="enumeration_section">12.1.3.2</span>数据充足性检查查询重写</h5>
                     <div>
                        <p><a id="d44607e976" class="indexterm-anchor"></a>在此检查中，优化程序确定是否可以从实例化视图获取查询所请求的必要列数据。为此，使用一列与另一列的等价。例如，如果表<code class="codeph">A</code>和表<code class="codeph">B</code>之间的内部联接基于连接谓词<code class="codeph">AX = BX</code> ，则列<code class="codeph">AX</code>的数据等于连接结果中列<code class="codeph">BX</code>中的数据。此数据属性用于将查询中的列<code class="codeph">AX</code>与物化视图中的列<code class="codeph">BX</code>匹配，反之亦然。例如，请考虑以下查询：</p><pre class="oac_no_warn" dir="ltr">SELECT p.prod_name，s.time_id，t.week_ending_day，SUM（s.amount_sold）FROM sales s，products p，times t WHERE s.time_id = t.time_id AND s.prod_id = p.prod_id GROUP BY p.prod_name， s.time_id，t.week_ending_day;</pre><p>该查询可以回答<code class="codeph">join_sales_time_product_mv</code>即使物化视图没有<code class="codeph">s.time_id</code> 。相反，它有<code class="codeph">t.time_id</code> ，它通过连接条件<code class="codeph">s.time_id=t.time_id</code>等同于<code class="codeph">s.time_id</code> 。因此，优化器可能会选择以下重写：</p><pre class="oac_no_warn" dir="ltr">SELECT prod_name，time_id，week_ending_day，SUM（amount_sold）FROM join_sales_time_product_mv GROUP BY prod_name，time_id，week_ending_day;</pre></div>
                  </div><a id="DWHSG8509"></a><div class="props_rev_3"><a id="GUID-9A52FD90-681E-40B6-9DBE-F0D338380BE4" name="GUID-9A52FD90-681E-40B6-9DBE-F0D338380BE4"></a><h5 id="DWHSG-GUID-9A52FD90-681E-40B6-9DBE-F0D338380BE4" class="sect5"><span class="enumeration_section">12.1.3.3</span>分组兼容性检查查询重写</h5>
                     <div>
                        <p><a id="d44607e1046" class="indexterm-anchor"></a>仅当物化视图和查询都包含<code class="codeph">GROUP</code> <code class="codeph">BY</code>子句时，才需要进行此检查。优化器首先确定查询所请求的数据分组是否与存储在物化视图中的数据分组完全相同。换句话说，查询和物化视图中的分组级别相同。如果实体化视图对查询中的所有列和表达式进行分组，并且还对其他列或表达式进行分组，则查询重写可以在分组列和查询表达式上重新聚合实体化视图，以获得查询请求的相同结果。
                        </p>
                     </div>
                  </div><a id="DWHSG8510"></a><div class="props_rev_3"><a id="GUID-E0156059-DF92-4302-80D3-C6C066130B3E" name="GUID-E0156059-DF92-4302-80D3-C6C066130B3E"></a><h5 id="DWHSG-GUID-E0156059-DF92-4302-80D3-C6C066130B3E" class="sect5"><span class="enumeration_section">12.1.3.4</span>查询重写的聚合可计算性检查</h5>
                     <div>
                        <p><a id="d44607e1078" class="indexterm-anchor"></a>仅当查询和物化视图都包含聚合时，才需要进行此检查。这里，优化器确定查询请求的聚合是否可以从存储在物化视图中的一个或多个聚合中派生或计算。例如，如果查询请求<code class="codeph">AVG(X)</code>并且物化视图包含<code class="codeph">SUM(X)</code>和<code class="codeph">COUNT(X)</code> ，则<code class="codeph">AVG(X)</code>可以计算为<code class="codeph">SUM(X)/COUNT(X)</code> 。
                        </p>
                        <p>如果分组兼容性检查确定需要存储在实例化视图中的聚合的汇总，则聚合可计算性检查确定是否可以使用实例化视图中的聚合来汇总查询所请求的每个聚合。</p>
                     </div>
                  </div>
               </div><a id="DWHSG08014"></a><div class="props_rev_3"><a id="GUID-9279E302-ECD5-4316-B0AC-493507C7F7F2" name="GUID-9279E302-ECD5-4316-B0AC-493507C7F7F2"></a><h4 id="DWHSG-GUID-9279E302-ECD5-4316-B0AC-493507C7F7F2" class="sect4"><span class="enumeration_section">12.1.4</span>关于使用维度重写查询</h4>
                  <div>
                     <p>本节讨论在重写环境中使用维度的以下方面：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="advanced-query-rewrite-materialized-views.html#GUID-2F32D121-29DA-42C6-A155-C8A52472CDD5">在查询重写环境中使用维度的好处</a></p>
                        </li>
                        <li>
                           <p><a href="advanced-query-rewrite-materialized-views.html#GUID-C0BDF64C-8D46-4928-BFAF-200761ED5ECA">如何定义查询重写的维度</a></p>
                        </li>
                     </ul>
                  </div><a id="DWHSG8511"></a><div class="props_rev_3"><a id="GUID-2F32D121-29DA-42C6-A155-C8A52472CDD5" name="GUID-2F32D121-29DA-42C6-A155-C8A52472CDD5"></a><h5 id="DWHSG-GUID-2F32D121-29DA-42C6-A155-C8A52472CDD5" class="sect5"><span class="enumeration_section">12.1.4.1</span>在查询重写环境中使用维度的好处</h5>
                     <div>
                        <p>维度定义列之间的分层（父/子）关系，其中所有列不必来自同一个表。</p>
                        <p>维度定义增加了查询重写的可能性，因为它们有助于在列之间建立功能依赖性。此外，维度可以表示不能由约束表达的表内关系。维度定义不占用额外的存储空间。相反，维度定义会建立描述架构内部和维度间关系的元数据。在创建实体化视图之前，第一步是检查模式并定义维度，因为这可以显着提高重写查询的机会。</p>
                     </div>
                  </div><a id="DWHSG8512"></a><div class="props_rev_3"><a id="GUID-C0BDF64C-8D46-4928-BFAF-200761ED5ECA" name="GUID-C0BDF64C-8D46-4928-BFAF-200761ED5ECA"></a><h5 id="DWHSG-GUID-C0BDF64C-8D46-4928-BFAF-200761ED5ECA" class="sect5"><span class="enumeration_section">12.1.4.2</span>如何定义查询重写的维度</h5>
                     <div>
                        <div class="section">
                           <p>对于任何给定的架构，请使用以下步骤创建维度：</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <ol>
                              <li><a href="advanced-query-rewrite-materialized-views.html#GUID-C0BDF64C-8D46-4928-BFAF-200761ED5ECA__CACCBIDA">识别架构中的所有维度和维度表</a></li>
                              <li><a href="advanced-query-rewrite-materialized-views.html#GUID-C0BDF64C-8D46-4928-BFAF-200761ED5ECA__CACJGGBJ">确定每个维度中的层次结构</a></li>
                              <li><a href="advanced-query-rewrite-materialized-views.html#GUID-C0BDF64C-8D46-4928-BFAF-200761ED5ECA__CACIBIHJ">确定层次结构的每个级别中的属性依赖性</a></li>
                              <li><a href="advanced-query-rewrite-materialized-views.html#GUID-C0BDF64C-8D46-4928-BFAF-200761ED5ECA__CACCIIHG">识别数据仓库中事实表到每个维度的连接</a></li>
                           </ol>
                           <p>请记住将参数<code class="codeph">QUERY_REWRITE_INTEGRITY</code>设置为<code class="codeph">TRUSTED</code>或<code class="codeph">STALE_TOLERATED</code>以进行查询重写，以利用维度中声明的关系。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section" id="GUID-C0BDF64C-8D46-4928-BFAF-200761ED5ECA__CACCBIDA">
                           <p class="subhead3" id="GUID-C0BDF64C-8D46-4928-BFAF-200761ED5ECA__GUID-264F6333-0E5F-4AA4-9C69-757066EC6620">识别架构中的所有维度和维度表</p>
                           <p>如果维度是规范化的，即存储在多个表中，则检查维度表之间的连接是否保证每个子端行与一个且只有一个父端行连接。在非规范化维度的情况下，检查子端列是否唯一地确定父端（或属性）列。不遵守这些规则可能会导致查询返回不正确的结果。</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section" id="GUID-C0BDF64C-8D46-4928-BFAF-200761ED5ECA__CACJGGBJ">
                           <p class="subhead3" id="GUID-C0BDF64C-8D46-4928-BFAF-200761ED5ECA__GUID-D8A463D8-ED27-43BA-90F6-F70EA11AC8D6">确定每个维度中的层次结构</p>
                           <p>例如，日是一个月的孩子（您可以将日级别数据汇总到一个月），而季度是一年中的孩子。</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section" id="GUID-C0BDF64C-8D46-4928-BFAF-200761ED5ECA__CACIBIHJ">
                           <p class="subhead3" id="GUID-C0BDF64C-8D46-4928-BFAF-200761ED5ECA__GUID-BE388844-D6F2-40E2-BB2B-5EA5B7B29D76">确定层次结构的每个级别中的属性依赖性</p>
                           <p>例如，标识<code class="codeph">calendar_month_name</code>是月份的属性。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section" id="GUID-C0BDF64C-8D46-4928-BFAF-200761ED5ECA__CACCIIHG">
                           <p class="subhead3" id="GUID-C0BDF64C-8D46-4928-BFAF-200761ED5ECA__GUID-ACA5CF35-3856-47C0-ADFE-4623C5E5FB76">识别数据仓库中事实表到每个维度的连接</p>
                           <p>然后检查每个连接是否可以保证每个事实行与一个且仅一个维度行连接。必须通过在事实键列上添加<code class="codeph">FOREIGN</code> <code class="codeph">KEY</code>和<code class="codeph">NOT</code> <code class="codeph">NULL</code>约束以及在父端连接键上添加<code class="codeph">PRIMARY</code> <code class="codeph">KEY</code>约束来声明并强制执行此条件。如果其他数据处理过程（例如，您的加载过程）可以保证这些关系，则可以使用<code class="codeph">NOVALIDATE</code>选项启用这些约束，以避免验证表中的每一行符合约束所需的时间。所有未经验证的约束也需要<code class="codeph">RELY</code>子句，以使它们有资格在查询重写中使用。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div><a id="DWHSG9412"></a><div class="props_rev_3"><a id="GUID-7D334590-98DE-475F-A815-1F36934B7ADA" name="GUID-7D334590-98DE-475F-A815-1F36934B7ADA"></a><h6 id="DWHSG-GUID-7D334590-98DE-475F-A815-1F36934B7ADA" class="sect6"><span class="enumeration_section">12.1.4.2.1</span>创建时间维度的示例SQL语句</h6>
                        <div><pre class="oac_no_warn" dir="ltr">创建维times_dim LEVEL一天TIMES.TIME_ID LEVEL一个月TIMES.CALENDAR_MONTH_DESC LEVEL季度TIMES.CALENDAR_QUARTER_DESC LEVEL一年TIMES.CALENDAR_YEAR LEVEL fis_week IS TIMES.WEEK_ENDING_DAY LEVEL fis_month IS TIMES.FISCAL_MONTH_DESC LEVEL fis_quarter IS TIMES.FISCAL_QUARTER_DESC LEVEL fis_year为Times。 FISCAL_YEAR HIERARCHY cal_rollup（每年四分之一孩子的一个孩子的日子）HIERARCHY fis_rollup（fis_wear孩子的fis_week孩子的fis_week孩子的一天孩子）attribute day DETERMINES（day_number_in_week，day_name，day_number_in_month，calendar_week_number）ATTRIBUTE month DETERMINES（calendar_month_desc， calendar_month_number，calendar_month_name，days_in_cal_month，end_of_cal_month）ATTRIBUTE quarter DETERMINES（calendar_quarter_desc，calendar_quarter_number，days_in_cal_quarter，end_of_cal_quarter）ATTRIBUTE year DETERMINES（calendar_year，days_in_cal_year，end_of_cal_year）ATTRIBUTE fis_week确定（week_ending_day，fiscal_week_数）;</pre></div>
                     </div>
                  </div>
               </div>
            </div><a id="DWHSG0802"></a><div class="props_rev_3"><a id="GUID-5297DA70-0064-4EA4-B492-E45089E5074F" name="GUID-5297DA70-0064-4EA4-B492-E45089E5074F"></a><h3 id="DWHSG-GUID-5297DA70-0064-4EA4-B492-E45089E5074F" class="sect3"><span class="enumeration_section">12.2</span>查询重写的类型</h3>
               <div>
                  <p>具有需要在大型表之间进行计算或在非常大的表之间进行连接的聚合的查询可能很昂贵，因此返回结果可能需要很长时间。查询重写使用具有预先计算结果的物化视图透明地重写此类查询，以便几乎可以即时回答查询。这些物化视图可以大致分为两组，即物化聚合视图和物化连接视图。物化聚合视图是具有预先计算的原始表中列的聚合值的表。类似地，物化连接视图是在原始表的列之间具有预先计算的连接的表。查询重写转换传入查询以从实例化视图列中获取结果。因为这些列包含已经预先计算的结果，所以几乎可以即时回答传入的查询。有关多维数据集组织的物化视图的查询重写的注意事项，请参阅<a href="../olaug/administering-oracle-olap.html#OLAUG700" target="_blank"><span class="italic">Oracle OLAP用户指南</span></a> 。
                  </p>
                  <p>本节讨论可用于重写查询的以下方法：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="advanced-query-rewrite-materialized-views.html#GUID-A95A5C58-B011-44FF-B5CB-EE4FDEE032D5">查询重写方法1：文本匹配重写</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-query-rewrite-materialized-views.html#GUID-512B09CD-D2C3-4FA9-BC7C-0A4EF6A4B74F">查询重写方法2：加入返回</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-query-rewrite-materialized-views.html#GUID-4682B101-191E-4C39-B90D-E927D84123DA">查询重写方法3：聚合可计算性</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-query-rewrite-materialized-views.html#GUID-34D5394E-9267-4785-8737-0DA0D35E4849">查询重写方法4：聚合汇总</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-query-rewrite-materialized-views.html#GUID-5CE61CCA-6A0A-4FB4-8F77-1A405AFC142F">查询重写方法5：使用维度汇总</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-query-rewrite-materialized-views.html#GUID-D8D9019B-EF84-408E-9DB8-75EAD33A3A9D">查询重写方法6：物化视图只有一个数据子集</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-query-rewrite-materialized-views.html#GUID-A32547B4-7E20-4EAB-B3B7-A7DBC1E5B4D8">分区更改跟踪（PCT）重写</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-query-rewrite-materialized-views.html#GUID-CECD1B60-A092-4AA7-AE32-B2DD97EBDD08">关于使用多个物化视图重写查询</a></p>
                     </li>
                  </ul>
               </div><a id="DWHSG08021"></a><div class="props_rev_3"><a id="GUID-A95A5C58-B011-44FF-B5CB-EE4FDEE032D5" name="GUID-A95A5C58-B011-44FF-B5CB-EE4FDEE032D5"></a><h4 id="DWHSG-GUID-A95A5C58-B011-44FF-B5CB-EE4FDEE032D5" class="sect4"><span class="enumeration_section">12.2.1</span>查询重写方法1：文本匹配重写</h4>
                  <div>
                     <p><a id="d44607e1370" class="indexterm-anchor"></a>查询重写引擎始终首先尝试将传入查询的文本与任何潜在物化视图的定义文本进行比较，以重写查询。这是因为与进行一般重写所需的复杂分析的成本相比，进行简单文本比较的开销通常可以忽略不计。
                     </p>
                     <p>查询重写引擎使用两种文本匹配方法，全文匹配重写和部分文本匹配重写。在全文匹配中，将查询的整个文本与实例化视图定义的整个文本（即整个<code class="codeph">SELECT</code>表达式）进行比较，在文本比较期间忽略空格。例如，假设您具有以下物化视图<code class="codeph">sum_sales_pscat_month_city_mv</code> ：</p><pre class="oac_no_warn" dir="ltr">CREATE MATERIALIZED VIEW sum_sales_pscat_month_city_mv ENABLE QUERY REWRITE AS SELECT p.prod_subcategory，t.calendar_month_desc，c.cust_city，SUM（s.amount_sold）AS sum_amount_sold，COUNT（s.amount_sold）AS count_amount_sold FROM sales s，products p，times t，customers c WHERE.time_id = t.time_id AND s.prod_id = p.prod_id AND s.cust_id = c.cust_id GROUP BY p.prod_subcategory，t.calendar_month_desc，c.cust_city;</pre><p>请考虑以下查询：</p><pre class="oac_no_warn" dir="ltr">SELECT p.prod_subcategory，t.calendar_month_desc，c.cust_city，SUM（s.amount_sold）AS sum_amount_sold，COUNT（s.amount_sold）AS count_amount_sold FROM sales s，products p，times t，customers c WHERE s.time_id = t.time_id AND s.prod_id = p.prod_id AND s.cust_id = c.cust_id GROUP BY p.prod_subcategory，t.calendar_month_desc，c.cust_city;</pre><p>此查询与<code class="codeph">sum_sales_pscat_month_city_mv</code> （不包括空格）匹配，并重写为：</p><pre class="oac_no_warn" dir="ltr">SELECT mv.prod_subcategory，mv.calendar_month_desc，mv.cust_city，mv.sum_amount_sold，mv.count_amount_sold FROM sum_sales_pscat_month_city_mv;</pre><p>当全文匹配失败时，优化程序将尝试部分文本匹配。在该方法中，从原料的文本<code class="codeph">FROM</code>查询的子句对文本进行比较开始与<code class="codeph">FROM</code>物化视图定义的条款。因此，可以重写以下查询：</p><pre class="oac_no_warn" dir="ltr">SELECT p.prod_subcategory，t.calendar_month_desc，c.cust_city，AVG（s.amount_sold）FROM sales s，products p，times t，customers c WHERE s.time_id = t.time_id AND s.prod_id = p.prod_id AND s。 cust_id = c.cust_id GROUP BY p.prod_subcategory，t.calendar_month_desc，c.cust_city;</pre><p>此查询被重写为：</p><pre class="oac_no_warn" dir="ltr">SELECT mv.prod_subcategory，mv.calendar_month_desc，mv.cust_city，mv.sum_amount_sold / mv.count_amount_sold FROM sum_sales_pscat_month_city_mv mv;</pre><p>请注意，在部分文本匹配重写方法下，查询所需的销售总计的平均值是使用物化视图中存储的销售总额和销售总计数计算的。</p>
                     <p>当文本匹配都不成功时，优化程序使用常规查询重写方法。</p>
                     <p>文本匹配重写可以区分大写和小写之间的差异很大而不重要的上下文。例如，以下语句是等效的：</p><pre class="oac_no_warn" dir="ltr">SELECT X，'aBc'FROM从y中选择x，'aBc'</pre></div>
               </div><a id="DWHSG08022"></a><div class="props_rev_3"><a id="GUID-512B09CD-D2C3-4FA9-BC7C-0A4EF6A4B74F" name="GUID-512B09CD-D2C3-4FA9-BC7C-0A4EF6A4B74F"></a><h4 id="DWHSG-GUID-512B09CD-D2C3-4FA9-BC7C-0A4EF6A4B74F" class="sect4"><span class="enumeration_section">12.2.2</span>查询重写方法2：加入返回</h4>
                  <div>
                     <p>如果无法从物化视图获得查询请求的某些列数据，则优化器还基于称为功能依赖性的数据关系来确定是否可以获得它。当列中的数据可以确定另一列中的数据时，这种关系称为功能依赖性或功能确定性。例如，如果表包含名为<code class="codeph">prod_id</code>的主键列和另一个名为<code class="codeph">prod_name</code>列，则在给定<code class="codeph">prod_id</code>值的情况下，可以查找相应的<code class="codeph">prod_name</code> 。相反的情况并非如此，这意味着<code class="codeph">prod_name</code>值不需要与唯一的<code class="codeph">prod_id</code> 。
                     </p>
                     <p>当查询所需的列数据在实例化视图中不可用时，仍然可以通过将实体化视图连接回包含所需列数据的表来获得此类列数据，前提是实体化视图包含在功能上确定所需列的键数据。例如，请考虑以下查询：</p><pre class="oac_no_warn" dir="ltr">SELECT p.prod_category，t.week_ending_day，SUM（s.amount_sold）FROM sales s，products p，times t WHERE s.time_id = t.time_id AND s.prod_id = p.prod_id AND p.prod_category ='CD'GROUP BY p.prod_category，t.week_ending_day;</pre><p>物化视图<code class="codeph">sum_sales_prod_week_mv</code>包含<code class="codeph">p.prod_id</code> ，但不包含<code class="codeph">p.prod_category</code> 。但是，您可以将<code class="codeph">sum_sales_prod_week_mv</code>加入<code class="codeph">products</code>以检索<code class="codeph">prod_category</code>因为<code class="codeph">prod_id</code>功能上确定了<code class="codeph">prod_category</code> 。优化程序使用<code class="codeph">sum_sales_prod_week_mv</code>重写此查询，如下所示：</p><pre class="oac_no_warn" dir="ltr">SELECT p.prod_category，mv.week_ending_day，SUM（mv.sum_amount_sold）FROM sum_sales_prod_week_mv mv，products p WHERE mv.prod_id = p.prod_id AND p.prod_category ='CD'GROUP BY p.prod_category，mv.week_ending_day;</pre><p>这里将<code class="codeph">products</code>表称为连接表，因为它最初是在物化视图中连接的，但在重写的查询中再次连接。
                     </p>
                     <p>您可以通过两种方式声明函数依赖：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>使用主键约束（如上例所示）</p>
                        </li>
                        <li>
                           <p>使用维度的<code class="codeph">DETERMINES</code>子句</p>
                        </li>
                     </ul>
                     <p>当确定另一列的列不能是主键时，维度定义的<code class="codeph">DETERMINES</code>子句可能是声明函数依赖性的唯一方法。例如， <code class="codeph">products</code>表是非规范化维度表，其具有列<code class="codeph">prod_id</code> ， <code class="codeph">prod_name</code>和<code class="codeph">prod_subcategory</code> ，其功能上确定<code class="codeph">prod_subcat_desc</code>和<code class="codeph">prod_category</code> ，用于确定<code class="codeph">prod_cat_desc</code> 。
                     </p>
                     <p>可以通过将<code class="codeph">prod_id</code>声明为主键而不是第二个函数依赖项来建立第一个函数依赖项，因为<code class="codeph">prod_subcategory</code>列包含重复值。在这种情况下，您可以使用维度的<code class="codeph">DETERMINES</code>子句来声明第二个函数依赖项。
                     </p>
                     <p>以下维度定义说明了如何声明功能依赖性：</p><pre class="oac_no_warn" dir="ltr">CREATE DIMENSION products_dim LEVEL产品IS（products.prod_id）LEVEL子类别IS（products.prod_subcategory）LEVEL类别IS（products.prod_category）HIERARCHY prod_rollup（产品类别子类别CHILD OF类别）ATTRIBUTE产品DETERMINES产品.prod_name ATTRIBUTE产品DETERMINES产品.prod_desc ATTRIBUTE子类别确定products.prod_subcat_desc属性类别DETERMINES products.prod_cat_desc;</pre><p>层次结构<code class="codeph">prod_rollup</code>声明了层次关系，它们也是<code class="codeph">1:n</code>功能依赖关系。使用<code class="codeph">DETERMINES</code>子句声明<code class="codeph">1:1</code>函数依赖项，如<code class="codeph">prod_subcategory</code>函数上确定<code class="codeph">prod_subcat_desc</code>时<code class="codeph">prod_subcat_desc</code> 。
                     </p>
                     <p>如果创建了以下物化视图：</p><pre class="oac_no_warn" dir="ltr">CREATE MATERIALIZED VIEW sum_sales_pscat_week_mv ENABLE QUERY REWRITE AS SELECT p.prod_subcategory，t.week_ending_day，SUM（s.amount_sold）AS sum_amount_sole FROM sales s，products p，times t WHERE s.time_id = t.time_id AND s.prod_id = p.prod_id GROUP BY p.prod_subcategory，t.week_ending_day;</pre><p>然后考虑以下查询：</p><pre class="oac_no_warn" dir="ltr">SELECT p.prod_subcategory_desc，t.week_ending_day，SUM（s.amount_sold）FROM sales s，products p，times t WHERE s.time_id = t.time_id AND s.prod_id = p.prod_id AND p.prod_subcat_desc LIKE'％Men'GROUP BY p.prod_subcat_desc，t.week_ending_day;</pre><p>这可以通过将<code class="codeph">sum_sales_pscat_week_mv</code>连接到<code class="codeph">products</code>表来重写，以便<code class="codeph">prod_subcat_desc</code>可用于评估谓词。但是，连接基于<code class="codeph">prod_subcategory</code>列，该列不是<code class="codeph">products</code>表中的主键;因此，它允许重复。这是通过使用选择不同值的内联视图来完成的，并且此视图将连接到实例化视图，如重写查询中所示。
                     </p><pre class="oac_no_warn" dir="ltr">SELECT iv.prod_subcat_desc，mv.week_ending_day，SUM（mv.sum_amount_sold）FROM sum_sales_pscat_week_mv mv，（SELECT DISTINCT prod_subcategory，prod_subcat_desc FROM products）iv WHERE mv.prod_subcategory = iv.prod_subcategory AND iv.prod_subcat_desc LIKE'％Men'GROUP BY iv。 prod_subcat_desc，mv.week_ending_day;</pre><p>这种类型的重写是可能的，因为<code class="codeph">prod_subcategory</code>功能上确定了维度中声明的<code class="codeph">prod_subcategory_desc</code> 。
                     </p>
                  </div>
               </div><a id="DWHSG08023"></a><div class="props_rev_3"><a id="GUID-4682B101-191E-4C39-B90D-E927D84123DA" name="GUID-4682B101-191E-4C39-B90D-E927D84123DA"></a><h4 id="DWHSG-GUID-4682B101-191E-4C39-B90D-E927D84123DA" class="sect4"><span class="enumeration_section">12.2.3</span>查询重写方法3：聚合可计算性</h4>
                  <div>
                     <p>当优化程序确定查询所请求的聚合是否可以从存储在实例化视图中的一个或多个聚合中派生或计算时，也可能发生查询重写。例如，如果查询请求<code class="codeph">AVG(X)</code>并且物化视图包含<code class="codeph">SUM(X)</code>和<code class="codeph">COUNT(X)</code> ，则<code class="codeph">AVG(X)</code>可以计算为<code class="codeph">SUM(X)/COUNT(X)</code> 。
                     </p>
                     <p>此外，如果确定需要存储在物化视图中的聚合的汇总，则如果可能，查询重写还会使用物化视图中的聚合汇总查询所请求的每个聚合。</p>
                     <p>例如， <code class="codeph">SUM(sales)</code>在城市一级可被卷起到<code class="codeph">SUM(sales)</code>在状态水平由所有求和<code class="codeph">SUM(sales)</code>具有相同的状态值的组中的聚集体。但是，除非<code class="codeph">COUNT(sales)</code>或<code class="codeph">SUM(sales)</code>在物化视图中也可用，否则<code class="codeph">AVG(sales)</code>无法汇总到更粗略的级别。同样，除非<code class="codeph">COUNT(sales)</code>和<code class="codeph">SUM(sales)</code>在物化视图中也可用，否则无法汇总<code class="codeph">VARIANCE(sales)</code>或<code class="codeph">STDDEV(sales)</code> 。例如，请考虑以下查询：</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE时间MODIFY CONSTRAINT time_pk RELY; ALTER TABLE客户MODIFY CONSTRAINT customers_pk RELY; ALTER TABLE销售MODIFY CONSTRAINT sales_time_pk RELY; ALTER TABLE销售MODIFY CONSTRAINT sales_customer_fk RELY; SELECT p.prod_subcategory，AVG（s.amount_sold）AS avg_sales FROM sales s，products p WHERE s.prod_id = p.prod_id GROUP BY p.prod_subcategory;</pre><p>如果<code class="codeph">sales</code>和<code class="codeph">times</code>以及<code class="codeph">sales</code>和<code class="codeph">customers</code>之间的连接是无损且无重复的，则可以使用物化视图<code class="codeph">sum_sales_pscat_month_city_mv</code>重写此语句。此外，查询按<code class="codeph">prod_subcategory</code>分组，而物化视图按<code class="codeph">prod_subcategory</code> ， <code class="codeph">calendar_month_desc</code>和<code class="codeph">cust_city</code> ，这意味着必须汇总存储在物化视图中的聚合。优化程序重写查询，如下所示：</p><pre class="oac_no_warn" dir="ltr">SELECT mv.prod_subcategory，SUM（mv.sum_amount_sold）/ COUNT（mv.count_amount_sold）AS avg_sales FROM sum_sales_pscat_month_city_mv mv GROUP BY mv.prod_subcategory;</pre><p>诸如<code class="codeph">SUM</code>的聚合的参数可以是诸如<code class="codeph">A+B</code>的算术表达式。优化器尝试匹配的集合体<code class="codeph">SUM(A+B)</code>与集料在查询中<code class="codeph">SUM(A+B)</code>或<code class="codeph">SUM(B+A)</code>存储在物化视图。换句话说，在将查询中的聚合的参数与实例化视图中的类似聚合的参数进行匹配时，将使用表达式等效。为实现此目的，Oracle将聚合参数表达式转换为规范形式，以便两个不同但等效的表达式转换为相同的规范形式。例如， <code class="codeph">A*(BC)</code> ， <code class="codeph">A*BC*A</code> ， <code class="codeph">(BC)*A</code>和<code class="codeph">-A*C+A*B</code>都转换为相同的规范形式，因此它们成功匹配。
                     </p>
                  </div>
               </div><a id="DWHSG08024"></a><div class="props_rev_3"><a id="GUID-34D5394E-9267-4785-8737-0DA0D35E4849" name="GUID-34D5394E-9267-4785-8737-0DA0D35E4849"></a><h4 id="DWHSG-GUID-34D5394E-9267-4785-8737-0DA0D35E4849" class="sect4"><span class="enumeration_section">12.2.4</span>查询重写方法4：聚合汇总</h4>
                  <div>
                     <p>如果查询请求的数据分组比物化视图中存储的数据分组更粗略，则优化程序仍然可以使用物化视图重写查询。例如，物化视图<code class="codeph">sum_sales_pscat_week_mv</code>按<code class="codeph">prod_subcategory</code>和<code class="codeph">week_ending_day</code> 。此查询按<code class="codeph">prod_subcategory</code>分组，这是一种较粗糙的分组粒度：</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE时间MODIFY CONSTRAINT time_pk RELY; ALTER TABLE销售MODIFY CONSTRAINT sales_time_fk RELY; SELECT p.prod_subcategory，SUM（s.amount_sold）AS sum_amount FROM sales s，products pWHERE s.prod_id = p.prod_id GROUP BY p.prod_subcategory;</pre><p>因此，优化程序将此查询重写为：</p><pre class="oac_no_warn" dir="ltr">SELECT mv.prod_subcategory，SUM（mv.sum_amount_sold）FROM sum_sales_pscat_week_mv mv GROUP BY mv.prod_subcategory;</pre></div>
               </div><a id="DWHSG08025"></a><div class="props_rev_3"><a id="GUID-5CE61CCA-6A0A-4FB4-8F77-1A405AFC142F" name="GUID-5CE61CCA-6A0A-4FB4-8F77-1A405AFC142F"></a><h4 id="DWHSG-GUID-5CE61CCA-6A0A-4FB4-8F77-1A405AFC142F" class="sect4"><span class="enumeration_section">12.2.5</span>查询重写方法5：使用维度汇总</h4>
                  <div>
                     <p>如果层次结构中的不同级别需要报告，则不必在层次结构中的每个级别创建实例化视图，前提是已定义维度。这是因为查询重写可以使用维度中的关系信息将物化视图中的数据汇总到层次结构中的所需级别。</p>
                     <p>在以下示例中，查询请求按<code class="codeph">prod_category</code>分组的数据，而<code class="codeph">prod_category</code>化视图存储按<code class="codeph">prod_subcategory</code>分组的数据。如果<code class="codeph">prod_subcategory</code>是<code class="codeph">CHILD</code> <code class="codeph">OF</code> <code class="codeph">prod_category</code> （参见前面的维度示例），则在重写查询时，可以通过<code class="codeph">prod_category</code>进一步对存储在物化视图中的分组数据进行分组。换言之，聚集在<code class="codeph">prod_subcategory</code>存储在物化视图可以卷起成聚集体的水平（更精细的粒度） <code class="codeph">prod_category</code>水平（较粗粒度）。
                     </p>
                     <p>例如，请考虑以下查询：</p><pre class="oac_no_warn" dir="ltr">SELECT p.prod_category，t.week_ending_day，SUM（s.amount_sold）AS sum_amount FROM sales s，products p，times t WHERE s.time_id = t.time_id AND s.prod_id = p.prod_id GROUP BY p.prod_category，t。 week_ending_day;</pre><p>因为<code class="codeph">prod_subcategory</code>功能上确定了<code class="codeph">prod_category</code> ， <code class="codeph">sum_sales_pscat_week_mv</code>可以与<code class="codeph">products</code>用于检索<code class="codeph">prod_category</code>列数据，然后聚合可以汇总到<code class="codeph">prod_category</code>级别，如下所示：</p><pre class="oac_no_warn" dir="ltr">SELECT pv.prod_category，mv.week_ending_day，SUM（mv.sum_amount_sold）FROM sum_sales_pscat_week_mv mv，（SELECT DISTINCT prod_subcategory，prod_category FROM products）pv WHERE mv.prod_subcategory = pv.prod_subcategory GROUP BY pv.prod_category，mv.week_ending_day;</pre></div>
               </div><a id="DWHSG8513"></a><div class="props_rev_3"><a id="GUID-D8D9019B-EF84-408E-9DB8-75EAD33A3A9D" name="GUID-D8D9019B-EF84-408E-9DB8-75EAD33A3A9D"></a><h4 id="DWHSG-GUID-D8D9019B-EF84-408E-9DB8-75EAD33A3A9D" class="sect4"><span class="enumeration_section">12.2.6</span>查询重写方法6：物化视图只有一个数据子集</h4>
                  <div>
                     <p>Oracle支持重写查询，以便它们使用物化视图，其中物化视图的<code class="codeph">HAVING</code>或<code class="codeph">WHERE</code>子句包含一个或多个表中数据子集的选择。例如，只有住在新罕布什尔州的客户。换句话说，物化视图中的<code class="codeph">WHERE</code>子句将是<code class="codeph">WHERE state = 'New Hampshire'</code> 。
                     </p>
                     <p>要执行此类查询重写，Oracle必须确定查询中请求的数据是否包含在物化视图中存储的数据中，或者是其中的子集。以下部分详细介绍了Oracle可以解决此问题的条件，从而重写查询以使用包含详细信息表中数据的已过滤部分的实体化视图。</p>
                     <p>要确定是否可以对筛选数据进行查询重写，当查询和物化视图都包含选择（非连接）并且对<code class="codeph">WHERE</code>以及<code class="codeph">HAVING</code>子句进行检查时，将执行选择可计算性检查。如果物化视图包含选择而查询不包含，则选择兼容性检查将失败，因为物化视图比查询更具限制性。如果查询有选择而物化视图没有，则不需要选择兼容性检查。
                     </p>
                     <p>物化视图的<code class="codeph">WHERE</code>或<code class="codeph">HAVING</code>子句可以包含连接，选择或两者，并且仍可用于重写查询。包含表达式的谓词子句或基于特定列的值选择行是非连接谓词的示例。
                     </p>
                     <p>本节包含以下主题：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="advanced-query-rewrite-materialized-views.html#GUID-8461E26C-8B80-4432-B7AE-F135003A3671">当物化视图只有一个数据子集时，查询重写定义</a></p>
                        </li>
                        <li>
                           <p><a href="advanced-query-rewrite-materialized-views.html#GUID-A606CB4D-1B46-411B-B166-9E1D688D0F1C">物化视图仅具有数据子集时的选择类别</a></p>
                        </li>
                        <li>
                           <p><a href="advanced-query-rewrite-materialized-views.html#GUID-4408FEDB-09D9-4EA8-A5F0-A3ADE7FC6AE5">查询重写选择的示例</a></p>
                        </li>
                        <li>
                           <p><a href="advanced-query-rewrite-materialized-views.html#GUID-8B6C8FC5-BDEB-4FEB-878B-03CA337E48B8">关于查询重写中HAVING子句的处理</a></p>
                        </li>
                        <li>
                           <p><a href="advanced-query-rewrite-materialized-views.html#GUID-191815BB-D689-4A2F-B1AD-32B88BC5CF44">关于实体化视图具有IN列表时的查询重写</a></p>
                        </li>
                     </ul>
                  </div><a id="DWHSG8514"></a><div class="props_rev_3"><a id="GUID-8461E26C-8B80-4432-B7AE-F135003A3671" name="GUID-8461E26C-8B80-4432-B7AE-F135003A3671"></a><h5 id="DWHSG-GUID-8461E26C-8B80-4432-B7AE-F135003A3671" class="sect5"><span class="enumeration_section">12.2.6.1</span>物化视图只有一个数据子集时的查询重写定义</h5>
                     <div>
                        <p>在描述查询重写仅与数据的子集一起使用时可能的情况之前，以下定义很有用：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><span class="italic">加入relop</span></p>
                              <p>是以下之一<code class="codeph">(=, &lt;, &lt;=, &gt;, &gt;=)</code></p>
                           </li>
                           <li>
                              <p><span class="italic">选择重新安置</span></p>
                              <p>是以下之一<code class="codeph">(=, &lt;, &lt;=, &gt;, &gt;=, !=，[NOT] BETWEEN | IN | LIKE | NULL）</code></p>
                           </li>
                           <li>
                              <p><span class="italic">加入谓词</span></p>
                              <p>是形式<code class="codeph">(</code> <span class="italic">column1</span> <code class="codeph"> </code> <span class="italic">加入</span> <code class="codeph"> </code> <span class="italic">relop</span> <code class="codeph"> </code> <span class="italic">column2</span> <code class="codeph">)</code> ，其中列来自当前查询块中同一<code class="codeph">FROM</code>子句中的不同表。因此，例如，外部参考是不可能的。
                              </p>
                           </li>
                           <li>
                              <p><span class="italic">选择谓词</span></p>
                              <p>是<span class="italic">左手边表达的形式</span> <code class="codeph"> </code> <span class="italic">relop</span> <code class="codeph"> </code> <span class="italic">右手边的表达</span> 。所有非连接谓词都是选择谓词。左侧通常包含一列，右侧包含值。例如， <code class="codeph">color='red'</code>表示左侧是<code class="codeph">color</code> ，右侧是<code class="codeph">'red'</code> ，关系运算符是<code class="codeph">(=)</code> 。
                              </p>
                           </li>
                        </ul>
                     </div>
                  </div><a id="DWHSG8515"></a><div class="props_rev_3"><a id="GUID-A606CB4D-1B46-411B-B166-9E1D688D0F1C" name="GUID-A606CB4D-1B46-411B-B166-9E1D688D0F1C"></a><h5 id="DWHSG-GUID-A606CB4D-1B46-411B-B166-9E1D688D0F1C" class="sect5"><span class="enumeration_section">12.2.6.2</span>物化视图只有一个数据子集时的选择类别</h5>
                     <div>
                        <p>选择分为以下几种情况：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>简单</p>
                              <p>简单的选择是<span class="italic">表达式relop常量</span> 。
                              </p>
                           </li>
                           <li>
                              <p>复杂</p>
                              <p>复杂的选择具有<span class="italic">表达式relop表达式</span> 。
                              </p>
                           </li>
                           <li>
                              <p>范围</p>
                              <p>范围选择的形式如<code class="codeph">WHERE (cust_last_name BETWEEN 'abacrombe' AND 'anakin')</code> 。
                              </p>
                              <p>请注意，使用关系运算符<code class="codeph">(&lt;,&lt;=,&gt;,&gt;=)</code>简单选择也被视为范围选择。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">IN</code> -列出</p>
                              <p>单列和多列<code class="codeph">IN</code>列表，例如<code class="codeph">WHERE(prod_id) IN (102, 233, ....)</code> 102,233 <code class="codeph">WHERE(prod_id) IN (102, 233, ....)</code> 。
                              </p>
                              <p>请注意，表单的选择<code class="codeph">(column1='v1' OR column1='v2' OR column1='v3' OR ....)</code>被视为一组并归类为<code class="codeph">IN</code> list。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">IS [NOT]为空</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">[不喜欢</code></p>
                           </li>
                           <li>
                              <p>其他</p>
                              <p>其他选择是无法确定数据的边界。例如， <code class="codeph">EXISTS</code> 。</p>
                           </li>
                        </ul>
                        <p>将查询中的选择与物化视图中的选择进行比较时，将比较两个选择的左侧。</p>
                        <p>如果左侧选择匹配，则检查右侧值是否包含。也就是说，查询选择的右侧值必须包含在物化视图选择的右侧值中。</p>
                        <p>您还可以在选择谓词中使用表达式。此过程类似于以下内容：</p><pre class="oac_no_warn" dir="ltr"><span class="italic">表达式关系运算符常量</span>
</pre><p><span class="italic">表达式</span>可以是Oracle数据库允许的任意算术表达式。物化视图和查询中的表达式必须匹配。Oracle尝试识别逻辑上等效的表达式，例如<code class="codeph">A+B</code>和<code class="codeph">B+A</code> ，并始终将相同的表达式视为等效。
                        </p>
                        <p>您还可以将运算符两侧的表达式或用户定义的函数用作运算符。当物化视图中的复杂谓词和查询在逻辑上等效时，就会发生查询重写。这意味着，与精确文本匹配不同，术语可以采用不同的顺序，只要表达式是等效的，重写仍然可以发生。</p>
                     </div>
                  </div><a id="DWHSG8517"></a><a id="DWHSG8518"></a><a id="DWHSG8519"></a><a id="DWHSG8520"></a><a id="DWHSG8521"></a><a id="DWHSG8522"></a><a id="DWHSG8523"></a><a id="DWHSG8524"></a><a id="DWHSG8525"></a><a id="DWHSG8516"></a><div class="props_rev_3"><a id="GUID-4408FEDB-09D9-4EA8-A5F0-A3ADE7FC6AE5" name="GUID-4408FEDB-09D9-4EA8-A5F0-A3ADE7FC6AE5"></a><h5 id="DWHSG-GUID-4408FEDB-09D9-4EA8-A5F0-A3ADE7FC6AE5" class="sect5"><span class="enumeration_section">12.2.6.3</span>查询重写选择示例</h5>
                     <div>
                        <p>以下是一些示例，说明了在过滤数据时如何仍然可以进行查询重写。</p>
                        <div class="example" id="GUID-4408FEDB-09D9-4EA8-A5F0-A3ADE7FC6AE5__GUID-167F7ABB-1E3F-4864-9F32-66EA692A8BF8">
                           <p class="titleinexample">例12-1单值选择</p>
                           <p>如果查询包含以下子句：</p><pre class="oac_no_warn" dir="ltr">在哪里prod_id = 102</pre><p>并且，如果物化视图包含以下子句：</p><pre class="oac_no_warn" dir="ltr">在哪里prod_id在0和200之间</pre><p>然后，左侧选择与<code class="codeph">prod_id</code>匹配，并且查询<code class="codeph">102</code>的右侧值在物化视图的范围内，因此查询重写是可能的。
                           </p>
                        </div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-4408FEDB-09D9-4EA8-A5F0-A3ADE7FC6AE5__GUID-925A8856-54C4-4A3A-8513-3202B3E1D8A7">
                           <p class="titleinexample">例12-2有界范围选择</p>
                           <p>选择可以是有界范围（具有上限值和下限值的范围）。例如，如果查询包含以下子句：</p><pre class="oac_no_warn" dir="ltr">在哪里prod_id&gt; 10 AND prod_id &lt;50</pre><p>如果物化视图包含以下子句：</p><pre class="oac_no_warn" dir="ltr">在哪里prod_id在0和200之间</pre><p>然后，选择在<code class="codeph">prod_id</code>上匹配，查询范围在物化视图范围内。在此示例中，请注意两个查询选择都基于同一列。
                           </p>
                        </div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-4408FEDB-09D9-4EA8-A5F0-A3ADE7FC6AE5__GUID-6BD15933-8F86-4E11-8385-C3C5AF3396C6">
                           <p class="titleinexample">例12-3用表达式选择</p>
                           <p>如果查询包含以下子句：</p><pre class="oac_no_warn" dir="ltr">WHERE（sales.amount_sold * .07）介于1.00和100.00之间</pre><p>如果物化视图包含以下子句：</p><pre class="oac_no_warn" dir="ltr">WHERE（sales.amount_sold * .07）BETWEEN 0.0和200.00</pre><p>然后，选择匹配<code class="codeph">(sales.amount_sold *.07)</code>并且查询的右侧值在<code class="codeph">(sales.amount_sold *.07)</code>化视图的范围内，因此可以进行查询重写。诸如此类的复杂选择要求左侧和右侧在物化视图的范围内匹配。
                           </p>
                        </div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-4408FEDB-09D9-4EA8-A5F0-A3ADE7FC6AE5__GUID-46199516-033E-4449-B5E3-3E2DC5766105">
                           <p class="titleinexample">示例12-4完全匹配选择</p>
                           <p>如果查询包含以下子句：</p><pre class="oac_no_warn" dir="ltr">WHERE（cost.unit_price * 0.95）&gt;（cost_unit_cost * 1.25）</pre><p>如果物化视图包含以下内容：</p><pre class="oac_no_warn" dir="ltr">WHERE（cost.unit_price * 0.95）&gt;（cost_unit_cost * 1.25）</pre><p>如果左侧和右侧与物化视图匹配且<span class="italic">selection_relop</span>相同，则通常可以从重写的查询中删除选择。否则，必须保留选择以从物化视图中过滤掉额外数据。
                           </p>
                           <p>如果查询重写可以从重写的查询中删除选择，则选择中的所有列可能不必在物化视图中，因此可以进行更多的重写。这可确保物化视图数据不会比查询更具限制性。</p>
                        </div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-4408FEDB-09D9-4EA8-A5F0-A3ADE7FC6AE5__GUID-E3FD30AD-7B01-4966-89F7-225DAD7986A8">
                           <p class="titleinexample">示例12-5查询中的更多选择</p>
                           <p>查询中的选择不必与实体化视图中的任何选择匹配，但如果是，则实体化视图必须包含右侧值。例如，如果查询包含以下子句：</p><pre class="oac_no_warn" dir="ltr">WHERE prod_name ='短裤'和'prod_category ='男士'</pre><p>如果物化视图包含以下子句：</p><pre class="oac_no_warn" dir="ltr">在哪里prod_category ='男人'</pre><p>然后，在此示例中，仅匹配与<code class="codeph">prod_category</code>选择。该查询具有一个不匹配的额外选择，但这是可以接受的，因为如果物化视图选择<code class="codeph">prod_name</code>或选择可以连接回详细信息表以获取<code class="codeph">prod_name</code>的列，则可以进行查询重写。唯一的要求是查询重写必须有一种方法将<code class="codeph">prod_name</code>选择应用于物化视图。
                           </p>
                        </div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-4408FEDB-09D9-4EA8-A5F0-A3ADE7FC6AE5__GUID-FE4FAE82-3025-4353-AB8D-7B425C5B5142">
                           <p class="titleinexample">示例12-6由于查询中的选择较少而无法重写</p>
                           <p>如果查询包含以下子句：</p><pre class="oac_no_warn" dir="ltr">在哪里prod_category ='男人'</pre><p>如果物化视图包含以下子句：</p><pre class="oac_no_warn" dir="ltr">WHERE prod_name ='短裤'和'prod_category ='男士'</pre><p>然后，与<code class="codeph">prod_name</code>的物化视图选择不匹配。物化视图比查询更具限制性，因为它只包含产品Shorts，因此，不会发生查询重写。
                           </p>
                        </div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-4408FEDB-09D9-4EA8-A5F0-A3ADE7FC6AE5__GUID-2B0951D2-B40A-4A91-A0C3-2727B4E1C530">
                           <p class="titleinexample">例12-7多列IN列表选择</p>
                           <p>查询重写还会检查查询是否具有多列<code class="codeph">IN</code>情况，其中列与物化视图单列<code class="codeph">IN</code>列表中的各列完全匹配。例如，如果查询包含以下内容：</p><pre class="oac_no_warn" dir="ltr">WHERE（prod_id，cust_id）IN（（1022,1000），（1033,2000））</pre><p>如果物化视图包含以下内容：</p><pre class="oac_no_warn" dir="ltr">WHERE prod_id IN（1022,1033）AND cust_id IN（1000,2000）</pre><p>然后，物化视图<code class="codeph">IN</code>列表由查询多列<code class="codeph">IN</code> -list中的列匹配。此外，查询选择的右侧值包含在物化视图中，以便进行重写。
                           </p>
                        </div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-4408FEDB-09D9-4EA8-A5F0-A3ADE7FC6AE5__GUID-9B9F38F2-1D15-4673-9AF3-860499AC9800">
                           <p class="titleinexample">示例12-8使用IN列表进行选择</p>
                           <p>选择兼容性还会检查实例化视图是否具有多列<code class="codeph">IN</code> ，其中列与查询中的<code class="codeph">IN</code>列表中的各列或列完全匹配。例如，如果查询包含以下内容：</p><pre class="oac_no_warn" dir="ltr">WHERE prod_id = 1022 AND cust_id IN（1000,2000）</pre><p>如果物化视图包含以下内容：</p><pre class="oac_no_warn" dir="ltr">WHERE（prod_id，cust_id）IN（（1022,1000），（1022,2000））</pre><p>然后，物化视图<code class="codeph">IN</code> -list列与查询选择中的列完全匹配。此外，查询选择的右侧值包含在物化视图中。所以重写成功。
                           </p>
                        </div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-4408FEDB-09D9-4EA8-A5F0-A3ADE7FC6AE5__GUID-2ECFD81D-E65D-42D5-AD1E-AFFE0B80530E">
                           <p class="titleinexample">例12-9多个选择或表达式</p>
                           <p>如果查询包含以下子句：</p><pre class="oac_no_warn" dir="ltr">WHERE（city_population&gt; 15000 AND city_population &lt;25000 AND state_name ='New Hampshire'）</pre><p>如果物化视图包含以下子句：</p><pre class="oac_no_warn" dir="ltr">WHERE（city_population &lt;5000 AND state_name ='New York'）OR（city_population BETWEEN 10000 AND 50000 AND state_name ='New Hampshire'）</pre><p>然后，该查询被称为具有单个析取（由<code class="codeph">AND</code>分隔的选择组），并且具体化视图具有由<code class="codeph">OR</code>分隔的两个析取。单个查询析取包含在第二个物化视图析取中，因此选择兼容性成功。很明显，物化视图包含的查询数据多于查询所需的数据，因此可以重写查询。
                           </p>
                        </div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="DWHSG8526"></a><div class="props_rev_3"><a id="GUID-8B6C8FC5-BDEB-4FEB-878B-03CA337E48B8" name="GUID-8B6C8FC5-BDEB-4FEB-878B-03CA337E48B8"></a><h5 id="DWHSG-GUID-8B6C8FC5-BDEB-4FEB-878B-03CA337E48B8" class="sect5"><span class="enumeration_section">12.2.6.4</span>关于在查询重写中处理HAVING子句</h5>
                     <div>
                        <p>当查询为<code class="codeph">HAVING</code>子句中的聚合指定一系列值时，也可能发生查询重写，例如<code class="codeph">SUM(s.amount_sold)</code> <code class="codeph">BETWEEN</code> <code class="codeph">10000</code> <code class="codeph">AND</code> <code class="codeph">20000</code> ，只要指定的范围在<code class="codeph">SUM(s.amount_sold)</code>化视图中指定的范围内。
                        </p><pre class="oac_no_warn" dir="ltr">CREATE MATERIALIZED VIEW product_sales_mv构建立即刷新强制使用QUERY REWRITE作为SELECT p.prod_name，SUM（s.amount_sold）AS dollar_sales FROM products p，sales s WHERE p.prod_id = s.prod_id GROUP BY prod_name HAVING SUM（s.amount_sold）BETWEEN 5000和50000;</pre><p>然后，可以重写以下查询：</p><pre class="oac_no_warn" dir="ltr">SELECT p.prod_name，SUM（s.amount_sold）AS dollar_sales FROM products p，sales s WHERE p.prod_id = s.prod_id GROUP BY prod_name HAVING SUM（s.amount_sold）BETWEEN 10000和20000;</pre><p>此查询将重写如下：</p><pre class="oac_no_warn" dir="ltr">SELECT mv.prod_name，mv.dollar_sales FROM product_sales_mv mv WHERE mv.dollar_sales BETWEEN 10000 AND 20000;</pre></div>
                  </div><a id="DWHSG8527"></a><div class="props_rev_3"><a id="GUID-191815BB-D689-4A2F-B1AD-32B88BC5CF44" name="GUID-191815BB-D689-4A2F-B1AD-32B88BC5CF44"></a><h5 id="DWHSG-GUID-191815BB-D689-4A2F-B1AD-32B88BC5CF44" class="sect5"><span class="enumeration_section">12.2.6.5</span>关于查询重写当物化视图具有IN列表时</h5>
                     <div>
                        <p>当物化视图包含<code class="codeph">IN</code>时，您可以使用查询重写。例如，给定以下物化视图定义：</p><pre class="oac_no_warn" dir="ltr">CREATE MATERIALIZED VIEW popular_promo_sales_mv构建立即刷新强制使用QUERY REWRITE作为SELECT p.promo_name，SUM（s.amount_sold）AS sum_amount_sold FROM promotion p，sales s WHERE s.promo_id = p.promo_id AND p.promo_name IN（'coupon'，' premium'，'赠品'）GROUP BY promo_name;</pre><p>可以重写以下查询：</p><pre class="oac_no_warn" dir="ltr">SELECT p.promo_name，SUM（s.amount_sold）FROM promotion p，sales s WHERE s.promo_id = p.promo_id AND p.promo_name IN（'coupon'，'premium'）GROUP BY p.promo_name;</pre><p>此查询将重写如下：</p><pre class="oac_no_warn" dir="ltr">SELECT * FROM popular_promo_sales_mv mv WHERE mv.promo_name IN（'coupon'，'premium'）;</pre></div>
                  </div>
               </div><a id="DWHSG08026"></a><div class="props_rev_3"><a id="GUID-A32547B4-7E20-4EAB-B3B7-A7DBC1E5B4D8" name="GUID-A32547B4-7E20-4EAB-B3B7-A7DBC1E5B4D8"></a><h4 id="DWHSG-GUID-A32547B4-7E20-4EAB-B3B7-A7DBC1E5B4D8" class="sect4"><span class="enumeration_section">12.2.7</span>分区变更跟踪（PCT）重写</h4>
                  <div>
                     <p>PCT重写使优化器能够使用仅部分新鲜的物化视图准确地使用新数据重写查询。为此，Oracle数据库会跟踪详细信息表中的哪些分区已更新。然后，Oracle数据库跟踪实例化视图中的哪些行来自详细信息表中受影响的分区。然后，优化器能够使用已知为新鲜的物化视图的那些部分。您可以使用<code class="codeph">DBA_MVIEWS</code> ， <code class="codeph">DBA_DETAIL_RELATIONS</code>和<code class="codeph">DBA_MVIEW_DETAIL_PARTITION</code>视图查看有关新鲜度的详细信息。有关使用这些视图的示例，请参阅<span class="q">“ <a href="refreshing-materialized-views.html#GUID-5B145F5C-C368-450D-8768-22D138A2ED39">查看分区新鲜度</a> ”</span> 。
                     </p>
                     <p>优化程序在<code class="codeph">QUERY_REWRITE_INTEGRITY = ENFORCED</code>和<code class="codeph">TRUSTED</code>模式下使用PCT重写。优化程序在<code class="codeph">STALE_TOLERATED</code>模式下不使用PCT重写，因为在该模式下不考虑数据新鲜度。此外，要进行PCT重写，需要<code class="codeph">WHERE</code>子句。
                     </p>
                     <p>您可以使用<a id="d44607e2504" class="indexterm-anchor"></a><a id="d44607e2506" class="indexterm-anchor"></a> PCT使用分区重写，但不支持散列分区。以下主题讨论了使用PCT的各个方面：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="advanced-query-rewrite-materialized-views.html#GUID-4C807F5F-B382-406B-A9AE-4E480BD002C3">基于范围分区表的PCT重写</a></p>
                        </li>
                        <li>
                           <p><a href="advanced-query-rewrite-materialized-views.html#GUID-DBF2A861-38DE-428F-8626-C158CB8D4DC8">基于范围列表分区表的PCT重写</a></p>
                        </li>
                        <li>
                           <p><a href="advanced-query-rewrite-materialized-views.html#GUID-6E5FEC09-4F3B-477A-A106-02E86112F8F5">基于列表分区表的PCT重写</a></p>
                        </li>
                        <li>
                           <p><a href="advanced-query-rewrite-materialized-views.html#GUID-DE6C1BA0-9FC5-416B-9743-F3F15BB45EBC">PCT重写和PMARKER</a></p>
                        </li>
                        <li>
                           <p><a href="advanced-query-rewrite-materialized-views.html#GUID-2AC7AFAB-F76C-4B97-9C5D-0A401336E89F">PCT使用Rowid重写为PMARKER</a></p>
                        </li>
                     </ul>
                  </div><a id="DWHSG8528"></a><div class="props_rev_3"><a id="GUID-4C807F5F-B382-406B-A9AE-4E480BD002C3" name="GUID-4C807F5F-B382-406B-A9AE-4E480BD002C3"></a><h5 id="DWHSG-GUID-4C807F5F-B382-406B-A9AE-4E480BD002C3" class="sect5"><span class="enumeration_section">12.2.7.1</span>基于范围分区表的PCT重写</h5>
                     <div>
                        <p>以下示例说明了PCT重写示例，其中物化视图通过分区键启用PCT，而基础基表在时间键上进行范围分区。</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE part_sales_by_time（time_id，prod_id，amount_sold，quantity_sold）PARTITION BY RANGE（time_id）（PARTITION old_data值小于（TO_DATE（'01 -01-1999'，'DD-MM-YYYY'））PCTFREE 0存储（初始8M） ），分区第一季度的价值不到（截止日期（'01 -04-1999'，'DD-MM-YYYY'））PCT免费0存储（最初8M），分区第二季度的价值不到（截止到（01-07-1999'） ，'DD-MM-YYYY'））PCTFREE 0存储（初始8M），分区第3季度（不到（'01 -10-1999'，'DD-MM-YYYY'））PCTFREE 0存储（初始8M） ，分区第四季度的价值不到（截止日期（'01 -01-2000'，'DD-MM-YYYY'））PCT免费0存储（最初8M），分区max_partition值不超过（最大值）PCTFREE 0存储（最初8M）） AS SELECT s.time_id，s.prod_id，s.amount_sold，s.quantity_sold FROM sales s;</pre><p>然后创建一个物化视图，其中包含按日期销售的产品总数。</p><pre class="oac_no_warn" dir="ltr">CREATE MATERIALIZED VIEW sales_in_1999_mv在需求中构建立即刷新强制启用QUERY REWRITE作为SELECT s.time_id，s.prod_id，p.prod_name，SUM（quantity_sold）FROM part_sales_by_time s，products p WHERE p.prod_id = s.prod_id AND s.time_id BETWEEN TO_DATE（'01 -01-1999'，'DD-MM-YYYY'）和TO_DATE（'31 -12-1999'，'DD-MM-YYYY'）GROUP BY s.time_id，s.prod_id，p.prod_name ;</pre><p>请注意，以下查询将使用物化视图<code class="codeph">sales_in_1999_mv</code>重写：</p><pre class="oac_no_warn" dir="ltr">SELECT s.time_id，p.prod_name，SUM（quantity_sold）FROM part_sales_by_time s，products p WHERE p.prod_id = s.prod_id AND s.time_id &lt;TO_DATE（'01 -02-1999'，'DD-MM-YYYY'） AND s.time_id&gt; = TO_DATE（'01 -01-1999'，'DD-MM-YYYY'）GROUP BY s.time_id，p.prod_name;</pre><p>如果在<code class="codeph">part_sales_by_time</code>向<code class="codeph">quarter4</code>添加一行， <code class="codeph">quarter4</code> ：</p><pre class="oac_no_warn" dir="ltr">INSERT INTO part_sales_by_time VALUES（TO_DATE（'26 -12-1999'，'DD-MM-YYYY'），38920,2500,20）;承诺;</pre><p>然后物化视图<code class="codeph">sales_in_1999_mv</code>变得陈旧。使用PCT重写，您可以重写仅从物化视图的新部分请求数据的查询。请注意，因为物化视图<code class="codeph">sales_in_1999_mv</code>在其<code class="codeph">SELECT</code>和<code class="codeph">GROUP</code> <code class="codeph">BY</code>子句中具有<code class="codeph">time_id</code> ，所以它已启用PCT，因此以下查询将成功重写，因为没有请求来自<code class="codeph">quarter4</code>数据。
                        </p><pre class="oac_no_warn" dir="ltr">SELECT s.time_id，p.prod_name，SUM（quantity_sold）FROM part_sales_by_time s，products p WHERE p.prod_id = s.prod_id AND s.time_id &lt;TO_DATE（'01 -07-1999'，'DD-MM-YYYY'） AND s.time_id&gt; = TO_DATE（'01 -03-1999'，'DD-MM-YYYY'）GROUP BY s.time_id，p.prod_name;</pre><p>如果将多个物化视图重写设置为关闭，则无法重写以下查询。由于默认情况下启用了多个物化视图重写，因此使用物化视图和基表重写以下查询：</p><pre class="oac_no_warn" dir="ltr">SELECT s.time_id，p.prod_name，SUM（quantity_sold）FROM part_sales_by_time s，products p WHERE p.prod_id = s.prod_id AND s.time_id &lt;TO_DATE（'31 -10-1999'，'DD-MM-YYYY'） AND s.time_id&gt; TO_DATE（'01 -07-1999'，'DD-MM-YYYY'）GROUP BY s.time_id，p.prod_name;</pre></div>
                  </div><a id="DWHSG8530"></a><a id="DWHSG8529"></a><div class="props_rev_3"><a id="GUID-DBF2A861-38DE-428F-8626-C158CB8D4DC8" name="GUID-DBF2A861-38DE-428F-8626-C158CB8D4DC8"></a><h5 id="DWHSG-GUID-DBF2A861-38DE-428F-8626-C158CB8D4DC8" class="sect5"><span class="enumeration_section">12.2.7.2</span>基于范围列表分区表的PCT重写</h5>
                     <div>
                        <p>如果详细信息表是范围列表分区，则依赖于此详细信息表的物化视图可以在分区和子分区级别支持PCT。如果物化视图中存在分区和子分区键，则PCT可以以更精细的粒度完成;物化视图刷新可以对物化视图的较小部分进行，并且可以使用陈旧的物化视图重写更多查询。或者，如果在物化视图中仅存在分区键，则可以使用courser粒度来完成PCT。</p>
                        <p>请考虑以下范围列表分区表：</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE sales_par_range_list（calendar_year，calendar_month_number，day_number_in_month，country_name，prod_id，prod_name，quantity_sold，amount_sold）PARTITION BY RANGE（calendar_month_number）按列表排序（country_name）（PARTITION q1 VALUE少于（4）（SUBPARTITION q1_America VALUES（'美国）美国'，'阿根廷'），SUBPARTITION q1_Asia VALUES（'日本'，'印度'），SUBPARTITION q1_Europe VALUES（'France'，'Spain'，'Ireland'）），PARTITION q2 VALUES少于（7）（增加q2_America） VALUES（'美利坚合众国'，'阿根廷'），SUBPARTITION q2_Asia VALUES（'日本'，'印度'），SUBPARTITION q2_Europe VALUES（'France'，'Spain'，'Ireland'）），PARTITION q3 VALUE少于（10）（提交q3_America VALUES（'美利坚合众国'，'阿根廷'），提交q3_Asia VALUES（'日本'，'印度'），提交q3_Europe VALUES（'法国'，'西班牙'，'爱尔兰'）） ，分区q4价值低于（13）（提升q4_America VALUES（'美利坚合众国'，'银色） ina'），SUBPARTITION q4_Asia VALUES（'Japan'，'India'），SUBPARTITION q4_Europe VALUES（'France'，'Spain'，'Ireland'）））AS SELECT t.calendar_year，t.calendar_month_number，t.day_number_in_month，c1 .country_name，s.prod_id，p.prod_name，s.quantity_sold，s.amount_sold FROM times t，countries c1，products p，sales s，customers c2 WHERE s.time_id = t.time_id AND s.prod_id = p.prod_id AND s.cust_id = c2.cust_id AND c2.country_id = c1.country_id AND c1.country_name IN（'United States of America'，'Argentina'，'Japan'，'India'，'France'，'Spain'，'Ireland “）;</pre><p>然后考虑以下物化视图<code class="codeph">sum_sales_per_year_month_mv</code> ，其中包含每年每月销售的产品总量：</p><pre class="oac_no_warn" dir="ltr">CREATE MATERIALIZED VIEW sum_sales_per_year_month_mv在需求中构建立即刷新强制使用QUERY REWRITE作为SELECT s.calendar_year，s.calendar_month_number，SUM（s.amount_sold）AS sum_sales，COUNT（*）AS cnt FROM sales_par_range_list s WHERE s.calendar_year&gt; 1990 GROUP BY s .calendar_year，s.calendar_month_number;</pre><p><code class="codeph">sales_per_country_mv</code>支持PCT对范围分区级别的<code class="codeph">sales_par_range_list</code> ，因为其范围分区键<code class="codeph">calendar_month_number</code>位于其<code class="codeph">SELECT</code>和<code class="codeph">GROUP</code> <code class="codeph">BY</code>列表中：</p><pre class="oac_no_warn" dir="ltr">INSERT INTO sales_par_range_list VALUES（2001,3,25，'Spain'，20，'PROD20'，300,20.50）;</pre><p>此语句插入一行，其中<code class="codeph">calendar_month_number = 3</code> ， <code class="codeph">country_name = 'Spain'</code> 。此行插入分区<code class="codeph">q1</code>子分区<code class="codeph">Europe</code> 。在此<code class="codeph">INSERT</code>语句之后， <code class="codeph">sum_sales_per_year_month_mv</code>相对于<code class="codeph">sales_par_range_list</code>分区<code class="codeph">q1</code>是<code class="codeph">sales_par_range_list</code> 。因此，无法重写任何从<code class="codeph">sales_par_range_list</code>此分区访问数据的传入查询，例如，以下语句：</p>
                        <p>请注意，以下查询访问分区<code class="codeph">q1</code>和<code class="codeph">q2</code> 。由于q1已更新，因此物化视图相对于<code class="codeph">q1</code>是陈旧的，因此PCT重写不可用。
                        </p><pre class="oac_no_warn" dir="ltr">SELECT s.calendar_year，SUM（s.amount_sold）AS sum_sales，COUNT（*）AS cnt FROM sales_par_range_list s WHERE s.calendar_year = 2000 AND s.calendar_month_number BETWEEN 2 AND 6 GROUP BY s.calendar_year;</pre><p>在<code class="codeph">INSERT</code>语句之后重写的语句的示例如下，因为它访问新材料：</p><pre class="oac_no_warn" dir="ltr">SELECT s.calendar_year，SUM（s.amount_sold）AS sum_sales，COUNT（*）AS cnt FROM sales_par_range_list s WHERE s.calendar_year = 2000 AND s.calendar_month_number BETWEEN 5 AND 9 GROUP BY s.calendar_year;</pre><p><a href="advanced-query-rewrite-materialized-views.html#GUID-DBF2A861-38DE-428F-8626-C158CB8D4DC8__CHDFDGCC">图12-3</a>提供了陈旧和新鲜的图解说明。
                        </p>
                        <div class="figure" id="GUID-DBF2A861-38DE-428F-8626-C158CB8D4DC8__CHDFDGCC">
                           <p class="titleinfigure">图12-3 PCT重写和范围列表分区</p><img src="img/dwhsg115.gif" alt="下面是图12-3的描述" title="下面是图12-3的描述" longdesc="img_text/dwhsg115.html"><br><a href="img_text/dwhsg115.html">“图12-3 PCT重写和范围列表分区”的说明</a></div>
                        <!-- class="figure" -->
                     </div>
                  </div><a id="DWHSG8532"></a><a id="DWHSG8531"></a><div class="props_rev_3"><a id="GUID-6E5FEC09-4F3B-477A-A106-02E86112F8F5" name="GUID-6E5FEC09-4F3B-477A-A106-02E86112F8F5"></a><h5 id="DWHSG-GUID-6E5FEC09-4F3B-477A-A106-02E86112F8F5" class="sect5"><span class="enumeration_section">12.2.7.3</span>基于列表分区表的PCT重写</h5>
                     <div>
                        <p>如果物化视图的<code class="codeph">SELECT</code>和<code class="codeph">GROUP</code> <code class="codeph">BY</code>存在<code class="codeph">LIST</code>分区键，则物化视图将支持PCT。无论支持的分区类型如何，如果详细信息表的分区标记或rowid存在于实例化视图中，则PCT将由该特定详细信息表上的实体化视图支持。
                        </p><pre class="oac_no_warn" dir="ltr">CREATE TABLE sales_par_list（calendar_year，calendar_month_number，day_number_in_month，country_name，prod_id，quantity_sold，amount_sold）PARTITION BY LIST（country_name）（PARTITION America VALUES（'United States of America'，'Argentina'），PARTITION Asia VALUES（'Japan'，'印度'），PARTITION Europe VALUES（'France'，'Spain'，'Ireland'））AS SELECT t.calendar_year，t.calendar_month_number，t.day_number_in_month，c1.country_name，s.prod_id，s.quantity_sold，s.amount_sold从时间t开始，国家c1，销售s，客户c2 WHERE s.time_id = t.time_id和s.cust_id = c2.cust_id和c2.country_id = c1.country_id和c1.country_name IN（'美利坚合众国'，'阿根廷'，'日本'，'印度'，'法国'，'西班牙'，'爱尔兰'）;</pre><p>如果在具有列表分区键的<code class="codeph">sales_par_list</code>表上创建物化视图，则PCT重写将使用该物化视图进行潜在的重写。
                        </p>
                        <p>为了说明此功能，以下示例创建一个物化视图，其中包含每个国家/地区每个产品的销售总量。视图取决于详细信息表<code class="codeph">sales_par_list</code>和<code class="codeph">products</code> 。
                        </p><pre class="oac_no_warn" dir="ltr">CREATE MATERIALIZED VIEW sales_per_country_mv根据需要构建立即刷新强制使用QUERY REWRITE作为SELECT s.calendar_year AS calendar_year，s.country_name AS country_name，p.prod_name AS prod_name，SUM（s.amount_sold）AS sum_sales，COUNT（*）AS cnt FROM sales_par_list s，产品p WHERE s.prod_id = p.prod_id AND s.calendar_year &lt;= 2000 GROUP BY s.calendar_year，s.country_name，prod_name;</pre><p><code class="codeph">sales_per_country_mv</code>支持PCT对<code class="codeph">sales_par_list</code>因为其列表分区键<code class="codeph">country_name</code>位于<code class="codeph">SELECT</code>和<code class="codeph">GROUP</code> <code class="codeph">BY</code>列表中。表<code class="codeph">products</code>未分区，因此<code class="codeph">sales_per_country_mv</code>不支持此表的PCT。
                        </p>
                        <p>根据<code class="codeph">ENFORCED</code>可以重写（在<code class="codeph">ENFORCED</code>或<code class="codeph">TRUSTED</code>模式下） <code class="codeph">sales_per_country_mv</code>即使传入查询仅访问物化视图的新部分， <code class="codeph">sales_per_country_mv</code>也是过时的。只有在物化视图中更新的表已启用PCT时，才能确定物化视图的哪些部分为<code class="codeph">FRESH</code> 。如果已更新非PCT启用表，则无法使用来自该特定物化视图的新数据进行重写，因为您无法识别物化视图的<code class="codeph">FRESH</code>部分。
                        </p>
                        <p><code class="codeph">sales_per_country_mv</code>支持在PCT <code class="codeph">sales_par_list</code>和不支持台产品PCT。如果表<code class="codeph">products</code>已更新，则<code class="codeph">sales_per_country_mv</code>无法进行PCT重写，因为您无法分辨物化视图的哪些部分是<code class="codeph">FRESH</code> 。</p>
                        <p>以下更新<code class="codeph">sales_par_list</code> ，如下所示：</p><pre class="oac_no_warn" dir="ltr">INSERT INTO sales_par_list VALUES（2000,10,22，'France'，900,20,200.99）;</pre><p>此语句在表<code class="codeph">sales_par_list</code>分区Europe中插入了一行。现在<code class="codeph">sales_per_country_mv</code>已过时，但PCT重写（在<code class="codeph">ENFORCED</code>和<code class="codeph">TRUSTED</code>模式下）是可能的，因为此物化视图支持PCT对表<code class="codeph">sales_par_list</code> 。物化视图的新鲜和陈旧区域基于分区详细信息表<code class="codeph">sales_par_list</code> 。
                        </p>
                        <p><a href="advanced-query-rewrite-materialized-views.html#GUID-6E5FEC09-4F3B-477A-A106-02E86112F8F5__I1015969">图12-4</a>说明了此示例中的新鲜内容和过时内容。
                        </p>
                        <div class="figure" id="GUID-6E5FEC09-4F3B-477A-A106-02E86112F8F5__I1015969">
                           <p class="titleinfigure">图12-4 PCT重写和列表分区</p><img src="img/dwhsg114.gif" alt="下面是图12-4的描述" title="下面是图12-4的描述" longdesc="img_text/dwhsg114.html"><br><a href="img_text/dwhsg114.html">“图12-4 PCT重写和列表分区”的说明</a></div>
                        <!-- class="figure" -->
                        <p>请考虑以下查询：</p><pre class="oac_no_warn" dir="ltr">SELECT s.country_name，p.prod_name，SUM（s.amount_sold）AS sum_sales，COUNT（*）AS cnt FROM sales_par_list s，products p WHERE s.prod_id = p.prod_id AND s.calendar_year = 2000 AND s.country_name IN（ '美利坚合众国'，'日本'）GROUP BY s.country_name，p.prod_name;</pre><p>此查询访问<code class="codeph">sales_par_list</code> <code class="codeph">America</code>和<code class="codeph">Asia</code>分区;这些分区尚未更新，因此可以使用陈旧的物化视图<code class="codeph">sales_per_country_mv</code>因为此查询只能访问物化视图的<code class="codeph">FRESH</code>部分。
                        </p>
                        <p>根据<code class="codeph">sales_per_country_mv</code>重写查询，如下所示：</p><pre class="oac_no_warn" dir="ltr">SELECT country_name，prod_name，SUM（sum_sales）AS sum_sales，SUM（cnt）AS cnt FROM sales_per_country_mv WHERE calendar_year = 2000 AND country_name IN（'United States of America'，'Japan'）GROUP BY country_name，prod_name;</pre><p>现在考虑以下查询：</p><pre class="oac_no_warn" dir="ltr">SELECT s.country_name，p.prod_name，SUM（s.amount_sold）AS sum_sales，COUNT（*）AS cnt FROM sales_par_list s，products p WHERE s.prod_id = p.prod_id AND s.calendar_year = 1999 AND s.country_name IN（ 'Japan'，'India'，'Spain'）GROUP BY s.country_name，p.prod_name;</pre><p>此查询在<code class="codeph">sales_par_list</code>访问<code class="codeph">Europe</code>和<code class="codeph">Asia</code>的<code class="codeph">sales_par_list</code> 。分区<code class="codeph">Europe</code>已更新，因此无法根据<code class="codeph">sales_per_country_mv</code>重写此查询，因为物化视图中的所需数据已过时。
                        </p>
                        <p>如果传入的查询访问物化视图的<code class="codeph">FRESH</code>部分，您将能够在对<code class="codeph">sales_par_list</code>进行任何类型的更新后重写，即DML，直接加载和分区维护操作（PMOP）。
                        </p>
                     </div>
                  </div><a id="DWHSG8534"></a><a id="DWHSG8533"></a><div class="props_rev_3"><a id="GUID-DE6C1BA0-9FC5-416B-9743-F3F15BB45EBC" name="GUID-DE6C1BA0-9FC5-416B-9743-F3F15BB45EBC"></a><h5 id="DWHSG-GUID-DE6C1BA0-9FC5-416B-9743-F3F15BB45EBC" class="sect5"><span class="enumeration_section">12.2.7.4</span> PCT重写和PMARKER</h5>
                     <div>
                        <p>在提供分区标记时，查询重写功能仅限于重写访问整个详细信息表分区的查询，因为来自特定分区的所有行具有相同的pmarker值。也就是说，如果查询访问详细信息表分区的一部分，则即使该数据对应于物化视图的<code class="codeph">FRESH</code>部分，也不会重写它。现在，物化视图的<code class="codeph">FRESH</code>部分由pmarker值确定。要确定物化视图的哪些行是新鲜的，请将新鲜度与标记值相关联，因此具有特定pmarker值的物化视图中的所有行都是<code class="codeph">FRESH</code>或<code class="codeph">STALE</code> 。</p>
                        <p>以下创建物化视图，其中包含每年<code class="codeph">sales_par_list</code>每个详细信息表分区中每个产品的总销售量。此物化视图还将依赖于详细信息表<code class="codeph">products</code> ，如下所示：</p><pre class="oac_no_warn" dir="ltr">CREATE MATERIALIZED VIEW sales_per_dt_partition_mv根据需要构建立即刷新强制使用QUERY REWRITE作为选项s.calendar_year AS calendar_year，p.prod_name AS prod_name，DBMS_MVIEW.PMARKER（s.rowid）pmarker，SUM（s.amount_sold）AS sum_sales，COUNT（*） AS cnt FROM sales_par_list s，products p WHERE s.prod_id = p.prod_id AND s.calendar_year&gt; 2000 GROUP BY s.calendar_year，DBMS_MVIEW.PMARKER（s.rowid），p.prod_name;</pre><p>物化视图<code class="codeph">sales_per_dt_partition_mv</code>提供每个<code class="codeph">sales_per_dt_partition_mv</code>分区的销售总和。此物化视图支持对表<code class="codeph">sales_par_list</code> PCT重写，因为分区标记位于<code class="codeph">SELECT</code>和<code class="codeph">GROUP</code> <code class="codeph">BY</code>子句中。<a href="advanced-query-rewrite-materialized-views.html#GUID-DE6C1BA0-9FC5-416B-9743-F3F15BB45EBC__g1021737" title="分区名称及其Pmarkers">表12-2</a>列出了此示例的分区名称及其标记。
                        </p>
                        <div class="tblformal" id="GUID-DE6C1BA0-9FC5-416B-9743-F3F15BB45EBC__g1021737">
                           <p class="titleintable">表12-2分区名称及其Pmarkers</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="分区名称及其Pmarkers" width="100%" border="1" summary="Partition Names and Their Pmarkers" frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="30%" id="d44607e3024">分区名称</th>
                                    <th align="left" valign="bottom" width="70%" id="d44607e3027">Pmarker</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="30%" id="d44607e3032" headers="d44607e3024 ">
                                       <p>美国</p>
                                    </td>
                                    <td align="left" valign="top" width="70%" headers="d44607e3032 d44607e3027 ">
                                       <p>1000</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="30%" id="d44607e3039" headers="d44607e3024 ">
                                       <p>亚洲</p>
                                    </td>
                                    <td align="left" valign="top" width="70%" headers="d44607e3039 d44607e3027 ">
                                       <p>1001</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="30%" id="d44607e3046" headers="d44607e3024 ">
                                       <p>欧洲</p>
                                    </td>
                                    <td align="left" valign="top" width="70%" headers="d44607e3046 d44607e3027 ">
                                       <p>1002</p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <p>然后更新表<code class="codeph">sales_par_list</code> ，如下所示：</p><pre class="oac_no_warn" dir="ltr">DELETE FROM sales_par_list WHERE country_name ='India';</pre><p>您已从表<code class="codeph">sales_par_list</code>删除了分区<code class="codeph">Asia</code>行。现在<code class="codeph">sales_per_dt_partition_mv</code>已过时，但PCT重写（在<code class="codeph">ENFORCED</code>和<code class="codeph">TRUSTED</code>模式下）是可能的，因为此物化视图支持PCT（基于pmarker）对表<code class="codeph">sales_par_list</code> 。
                        </p>
                        <p>现在考虑以下查询：</p><pre class="oac_no_warn" dir="ltr">SELECT p.prod_name，SUM（s.amount_sold）AS sum_sales，COUNT（*）AS cnt FROM sales_par_list s，products p WHERE s.prod_id = p.prod_id AND s.calendar_year = 2001 AND s.country_name IN（'United States of America'，'Argentina'）GROUP BY p.prod_name;</pre><p>该查询可以根据<code class="codeph">sales_per_dt_partition_mv</code>重写，因为访问了与详细表分区对应的所有数据，并且物化视图对于该数据是<code class="codeph">FRESH</code> 。此查询访问尚未更新的分区<code class="codeph">America</code>所有数据。
                        </p>
                        <p>根据<code class="codeph">sales_per_dt_partition_mv</code>重写查询，如下所示：</p><pre class="oac_no_warn" dir="ltr">SELECT prod_name，SUM（sum_sales）AS sum_sales，SUM（cnt）AS cnt FROM sales_per_dt_partition_mv WHERE calendar_year = 2001 AND pmarker = 1000 GROUP BY prod_name;</pre></div>
                  </div><a id="DWHSG8535"></a><div class="props_rev_3"><a id="GUID-2AC7AFAB-F76C-4B97-9C5D-0A401336E89F" name="GUID-2AC7AFAB-F76C-4B97-9C5D-0A401336E89F"></a><h5 id="DWHSG-GUID-2AC7AFAB-F76C-4B97-9C5D-0A401336E89F" class="sect5"><span class="enumeration_section">12.2.7.5</span>使用Rowid作为PMARKER重写PCT</h5>
                     <div>
                        <p>物化视图支持PCT重写提供的分区键或在其提供了一种分区标记<code class="codeph">SELECT</code>和<code class="codeph">GROUP</code> <code class="codeph">BY</code>子句，如果有一个<code class="codeph">GROUP</code> <code class="codeph">BY</code>子句。您可以使用分区表的rowid而不是pmarker或分区键。请注意，Oracle会在内部将rowid转换为pmarkers。请考虑下表：</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE product_par_list（prod_id，prod_name，prod_category，prod_subcategory，prod_list_price）PARTITION BY LIST（prod_category）（PARTITION prod_cat1 VALUES（'Boys'，'Men'），PARTITION prod_cat2 VALUES（'Girls'，'Women'））AS SELECT prod_id ，prod_name，prod_category，prod_subcategory，prod_list_price FROM products;</pre><p>让我们在表<code class="codeph">sales_par_list</code>和<code class="codeph">product_par_list</code>上创建以下物化视图：</p><pre class="oac_no_warn" dir="ltr">创建物化视图sum_sales_per_category_mv建立立即刷新强制需求启用QUERY REWRITE作为SELECT p.rowid prid，p.prod_category，SUM（s.amount_sold）sum_sales，COUNT（*）cnt FROM sales_par_list s，product_par_list p WHERE s.prod_id = p。 prod_id和s.calendar_year &lt;= 2000 GROUP BY p.rowid，p.prod_category;</pre><p>适用于pmarker重写的所有限制也适用于此处。传入的查询应该访问整个分区以便重写查询。在这种情况下使用以下pmarker表：</p><pre class="oac_no_warn" dir="ltr">product_par_list pmarker value ---------------- ------------- prod_cat1 1000 prod_cat2 1001 prod_cat3 1002</pre><p>然后更新表<code class="codeph">product_par_list</code> ，如下所示：</p><pre class="oac_no_warn" dir="ltr">DELETE FROM product_par_list WHERE prod_name ='MEN';</pre><p>所以<code class="codeph">sum_sales_per_category_mv</code>对于<code class="codeph">product_par_list</code>分区<code class="codeph">prod_list1</code> <code class="codeph">sum_sales_per_category_mv</code>是陈旧的。
                        </p>
                        <p>现在考虑以下查询：</p><pre class="oac_no_warn" dir="ltr">SELECT p.prod_category，SUM（s.amount_sold）AS sum_sales，COUNT（*）AS cnt FROM sales_par_list s，product_par_list p WHERE s.prod_id = p.prod_id AND p.prod_category IN（'Girls'，'Women'）AND s .calendar_year &lt;= 2000 GROUP BY p.prod_category;</pre><p>可以根据<code class="codeph">sum_sales_per_category_mv</code>重写该查询，因为访问了对应于详细信息表分区的所有数据，并且物化视图相对于该数据是<code class="codeph">FRESH</code> 。此查询访问分区<code class="codeph">prod_cat2</code>尚未更新的所有数据。以下是<code class="codeph">sum_sales_per_category_mv</code>重写的查询：</p><pre class="oac_no_warn" dir="ltr">SELECT prod_category，sum_sales，cnt FROM sum_sales_per_category_mv WHERE DBMS_MVIEW.PMARKER（srid）IN（1000）GROUP BY prod_category;</pre></div>
                  </div>
               </div><a id="DWHSG8536"></a><a id="DWHSG8537"></a><a id="DWHSG8538"></a><a id="DWHSG8539"></a><a id="DWHSG8540"></a><a id="DWHSG8541"></a><a id="DWHSG8542"></a><a id="DWHSG8543"></a><a id="DWHSG8544"></a><a id="DWHSG8545"></a><a id="DWHSG08027"></a><div class="props_rev_3"><a id="GUID-CECD1B60-A092-4AA7-AE32-B2DD97EBDD08" name="GUID-CECD1B60-A092-4AA7-AE32-B2DD97EBDD08"></a><h4 id="DWHSG-GUID-CECD1B60-A092-4AA7-AE32-B2DD97EBDD08" class="sect4"><span class="enumeration_section">12.2.8</span>关于使用多个物化视图重写查询</h4>
                  <div>
                     <div class="section">
                        <p>Que ry rewrite已扩展为允许使用多个物化视图重写查询。如果查询重写确定没有返回所有数据的物化视图集，则查询重写将从基表中检索剩余数据。
                        </p>
                        <p>使用多个物化视图的查询重写可以利用许多不同类型和重写的组合，例如使用PCT和<code class="codeph">IN</code>列表。以下示例说明了现在可以进行查询重写的一些查询。
                        </p>
                        <p>请考虑以下两个物化视图<code class="codeph">cust_avg_credit_mv1</code>和<code class="codeph">cust_avg_credit_mv2</code> 。 <code class="codeph">cust_avg_credit_mv1</code>要求所有客户在1940年至1950年之间出生的每个邮政编码的平均信用额度<code class="codeph">cust_avg_credit_mv2</code>要求客户在1950年之后以及1970年之前或之后出生的每个邮政编码的平均信用额度。
                        </p>
                        <p>物化视图对此示例的定义如下：</p><pre class="oac_no_warn" dir="ltr">CREATE MATERIALIZED VIEW cust_avg_credit_mv1 ENABLE QUERY REWRITE AS SELECT cust_postal_code，cust_year_of_birth，SUM（cust_credit_limit）AS sum_credit，COUNT（cust_credit_limit）AS count_credit FROM customers WHERE cust_year_of_birth BETWEEN 1940 AND 1950 GROUP BY cust_postal_code，cust_year_of_birth; CREATE MATERIALIZED VIEW cust_avg_credit_mv2 ENABLE QUERY REWRITE AS SELECT cust_postal_code，cust_year_of_birth，SUM（cust_credit_limit）AS sum_credit，COUNT（cust_credit_limit）AS count_credit FROM customers WHERE cust_year_of_birth&gt; 1950 AND cust_year_of_birth &lt;= 1970 GROUP BY cust_postal_code，cust_year_of_birth;</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-CECD1B60-A092-4AA7-AE32-B2DD97EBDD08__GUID-2A199DE6-DB16-4999-A4D5-761704D62FFF">查询1：物化视图和查询中的一个匹配间隔</p>
                        <p>考虑一个查询，询问所有客户在1940年至1970年之间出生的每个邮政编码的平均信用额度。此查询与<code class="codeph">cust_year_of_birth</code>上的间隔<code class="codeph">BETWEEN</code> <code class="codeph">cust_year_of_birth</code> 。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section"><pre class="oac_no_warn" dir="ltr">SELECT cust_postal_code，AVG（cust_credit_limit）AS avg_credit FROM customers c WHERE cust_year_of_birth BETWEEN 1940 AND 1970 GROUP BY cust_postal_code;</pre><p>可以根据这两个物化视图重写上述查询，以获得如下所有数据：</p><pre class="oac_no_warn" dir="ltr">SELECT v1.cust_postal_code，SUM（v1.sum_credit）/ SUM（v1.count_credit）AS avg_credit FROM（SELECT cust_postal_code，sum_credit，count_credit FROM <span class="bold">cust_avg_credit_mv1</span> GROUP BY cust_postal_code UNION ALL SELECT cust_postal_code，sum_credit，count_credit FROM <span class="bold">cust_avg_credit_mv2</span> GROUP BY cust_postal_code）v1 GROUP BY v1.cust_postal_code;</pre><p>请注意， <code class="codeph">UNION</code> <code class="codeph">ALL</code>查询在内联视图中使用，因为需要进行重新聚合。另请注意，查询重写是计数聚合以执行此汇总的方式。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-CECD1B60-A092-4AA7-AE32-B2DD97EBDD08__GUID-69EB227B-E5E6-4532-991B-EB8F74ABFB71">查询2：在物化视图中包含的数据之外进行查询</p>
                        <p>当物化视图超出查询所要求的范围时，会在重写的查询中添加一个过滤器（也称为选择），以删除物化视图返回的不需要的行。以下查询说明了这种情况：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section"><pre class="oac_no_warn" dir="ltr">SELECT cust_postal_code，SUM（cust_credit_limit）AS sum_credit FROM customers c WHERE cust_year_of_birth BETWEEN 1945 AND 1955 GROUP BY cust_postal_code;</pre><p>查询2被重写为：</p><pre class="oac_no_warn" dir="ltr">SELECT v1.cust_postal_code，SUM（v1.sum_credit）FROM（SELECT cust_postal_code，SUM（sum_credit）AS sum_credit FROM cust_avg_credit_mv1 WHERE cust_year_of_birth BETWEEN 1945 AND 1950 GROUP BY cust_postal_code UNION ALL SELECT cust_postal_code，SUM（sum_credit）AS sum_credit FROM cust_birth_mv2 WHERE cust_year_of_birth&gt; 1950 AND cust_year_of_birth &lt;= 1955 GROUP BY cust_postal_code）v1 GROUP BY v1.cust_postal_code;</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-CECD1B60-A092-4AA7-AE32-B2DD97EBDD08__GUID-0EFE1C20-5857-4B3C-9311-51B9B4795AEF">查询3：请求比物化视图中的更多数据</p>
                        <p>如果查询要求的数据多于两个物化视图中包含的数据，该怎么办？它仍然使用物化视图和基表中的数据重写。在以下示例中，定义了一组没有聚合的新物化视图。它仍将使用物化视图和基表中的数据进行重写。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section"><pre class="oac_no_warn" dir="ltr">CREATE MATERIALIZED VIEW cust_birth_mv1 ENABLE QUERY REWRITE AS SELECT cust_last_name，cust_first_name，cust_year_of_birth FROM customers WHERE cust_year_of_birth BETWEEN 1940 AND 1950; CREATE MATERIALIZED VIEW cust_avg_credit_mv2 ENABLE QUERY REWRITE AS SELECT cust_last_name，cust_first_name，cust_year_of_birth FROM customers WHERE cust_year_of_birth&gt; 1950 AND cust_year_of_birth &lt;= 1970;</pre><p>我们的查询现在要求所有在1940年至1990年之间出生的客户。</p><pre class="oac_no_warn" dir="ltr">SELECT cust_last_name，cust_first_name FROM customers c WHERE cust_year_of_birth BETWEEN 1940 AND 1990;</pre><p>查询重写需要访问基表以访问1970年以后以及1990年之前或之后出生的客户。因此，查询3被重写为以下内容：</p><pre class="oac_no_warn" dir="ltr">SELECT cust_last_name，cust_first_name FROM cust_birth_mv1 UNION ALL SELECT cust_last_name，cust_first_name FROM cust_birth_mv2 UNION ALL SELECT cust_last_name，cust_first_name FROM customers c WHERE cust_year_of_birth&gt; 1970 AND cust_year_of_birth &lt;= 1990;</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-CECD1B60-A092-4AA7-AE32-B2DD97EBDD08__GUID-98B23A7B-9BE0-472C-B379-675000D9DEAE">查询4：在多个选择列上请求数据</p>
                        <p>请考虑以下查询，该查询要求所有信用额度在1,000到10,000之间且出生于1945年至1960年之间的客户。此查询是一个多选查询，因为它要求多个选择列上的数据。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section"><pre class="oac_no_warn" dir="ltr">SELECT cust_last_name，cust_first_name FROM customers WHERE cust_year_of_birth BETWEEN 1945 AND 1960 AND cust_credit_limit BETWEEN 1000 AND 10000;</pre><p><a href="advanced-query-rewrite-materialized-views.html#GUID-CECD1B60-A092-4AA7-AE32-B2DD97EBDD08__BABJABEH">图12-5</a>显示了一个双选查询，可以使用下一节中描述的双选实体化视图重写。
                        </p>
                        <div class="figure" id="GUID-CECD1B60-A092-4AA7-AE32-B2DD97EBDD08__BABJABEH">
                           <p class="titleinfigure">图12-5使用多个物化视图重写查询</p><img src="img/dwhsg111.gif" alt="下面是图12-5的描述" title="下面是图12-5的描述" longdesc="img_text/dwhsg111.html"><br><a href="img_text/dwhsg111.html">“图12-5使用多个物化视图重写查询”的说明</a></div>
                        <!-- class="figure" -->
                        <p><a href="advanced-query-rewrite-materialized-views.html#GUID-CECD1B60-A092-4AA7-AE32-B2DD97EBDD08__BABJABEH">图12-5中</a>的图表说明了可用于满足此查询的物化视图。 <code class="codeph">credit_mv1</code>要求信用额度介于1,000和5,000之间且出生于1945年至1950年之间的客户<code class="codeph">credit_mv2</code>要求信用额度&gt; 5,000且&lt;= 10,000并且出生于1945年至1960年之间的客户<code class="codeph">credit_mv3</code>要求有信用额度的客户介于1,000和5,000之间，出生于1950年之后，1955年之前或之后。
                        </p>
                        <p>物化视图对此案例的定义如下：</p><pre class="oac_no_warn" dir="ltr">CREATE MATERIALIZED VIEW credit_mv1 ENABLE QUERY REWRITE AS SELECT cust_last_name，cust_first_name，cust_credit_limit，cust_year_of_birth FROM customers WHERE cust_credit_limit BETWEEN 1000 AND 5000 AND cust_year_of_birth BETWEEN 1945 AND 1950; CREATE MATERIALIZED VIEW credit_mv2 ENABLE QUERY REWRITE AS SELECT cust_last_name，cust_first_name，cust_credit_limit，cust_year_of_birth FROM customers WHERE cust_credit_limit&gt; 5000 AND cust_credit_limit &lt;= 10000 AND cust_year_of_birth BETWEEN 1945 AND 1960; CREATE MATERIALIZED VIEW credit_mv3 ENABLE QUERY REWRITE AS SELECT cust_last_name，cust_first_name，cust_credit_limit，cust_year_of_birth FROM customers WHERE cust_credit_limit BETWEEN 1000 AND 5000 AND cust_year_of_birth&gt; 1950 AND cust_year_of_birth &lt;= 1955;</pre><p>可以使用所有三个物化视图来重写查询4以访问大多数数据。但是，由于并非所有数据都可以从这三个物化视图中获得，因此查询重写还可以访问基表，以便为信用额度介于1,000和5,000之间且出生于1955年至1960年之间的客户检索数据。它改写如下：</p><pre class="oac_no_warn" dir="ltr">SELECT cust_last_name，cust_first_name FROM credit_mv1 UNION ALL SELECT cust_last_name，cust_first_name FROM credit_mv2 UNION ALL SELECT cust_last_name，cust_first_name FROM credit_mv3 UNION ALL SELECT cust_last_name，cust_first_name FROM customers WHERE cust_credit_limit BETWEEN 1000 AND 5000 AND cust_year_of_birth&gt; 1955 AND cust_year_of_birth &lt;= 1960;</pre><p>此示例说明了如何使用多个物化视图重写多选查询。简化示例以显示三个物化视图之间没有重叠数据。但是，查询重写可以执行类似的重写。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-CECD1B60-A092-4AA7-AE32-B2DD97EBDD08__GUID-4960319B-3B95-4920-B6C3-FEBE375B11FB">查询5：间隔和约束间隔</p>
                        <p>此示例说明如何使用单个选择实体化视图重写多选查询。在此示例中，查询中有两个间隔，物化视图中有一个约束间隔。它要求信用额度在1,000到10,000之间且出生于1945年至1960年之间的客户。但是假设<code class="codeph">credit_mv1</code>要求信用额度在1,000到5,000之间的客户。 <code class="codeph">credit_mv1</code>不是由一个选择受限<code class="codeph">cust_year_of_birth</code> ，因此覆盖了查询出生年份值的整个范围。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <div class="figure" id="GUID-CECD1B60-A092-4AA7-AE32-B2DD97EBDD08__BABCIEFD">
                           <p class="titleinfigure">图12-6约束的物化视图选择</p><img src="img/dwhsg113.gif" alt="下面是图12-6的描述" title="下面是图12-6的描述" longdesc="img_text/dwhsg113.html"><br><a href="img_text/dwhsg113.html">“图12-6约束物化视图选择”的说明</a></div>
                        <!-- class="figure" -->
                        <p><a href="advanced-query-rewrite-materialized-views.html#GUID-CECD1B60-A092-4AA7-AE32-B2DD97EBDD08__BABCIEFD">图12-6中</a>的线之间的区域表示数据<code class="codeph">credit1_mv</code> 。</p>
                        <p>新的<code class="codeph">credit_mv1</code>定义如下：</p><pre class="oac_no_warn" dir="ltr">CREATE MATERIALIZED VIEW credit_mv1 ENABLE QUERY REWRITE AS SELECT cust_last_name，cust_first_name，cust_credit_limit，cust_year_of_birth FROM customers WHERE cust_credit_limit BETWEEN 1000 AND 5000;</pre><p>查询如下：</p><pre class="oac_no_warn" dir="ltr">SELECT cust_last_name，cust_first_name FROM customers WHERE cust_year_of_birth BETWEEN 1945 AND 1960 AND cust_credit_limit BETWEEN 1000 AND 10000;</pre><p>最后重写的查询如下：</p><pre class="oac_no_warn" dir="ltr">SELECT cust_last_name，cust_first_name FROM credit_mv1 WHERE cust_year_of_birth BETWEEN 1945 AND 1960 UNION ALL SELECT cust_last_name，cust_first_name FROM customers WHERE cust_year_of_brith BETWEEN 1945 AND 1960 AND cust_credit_limit&gt; 5000 AND cust_credit_limit &lt;= 10000;</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-CECD1B60-A092-4AA7-AE32-B2DD97EBDD08__GUID-F509AA24-D808-46BA-BC70-885211B05A95">查询6：查询具有单列IN列表，物化视图具有单列间隔</p>
                        <p>多个物化视图查询重写可以处理传入查询中的<code class="codeph">IN</code> ，并根据在同一选择列上具有间隔的物化视图重写查询。假设<code class="codeph">IN</code> -list表示间隔中的离散值，则此重写功能是前面描述的仅间隔场景的自然扩展。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>以下是查询中的一列<code class="codeph">IN</code>选择和物化视图中的一个列间隔选择的示例。考虑一个询问，询问下一年出生的每个国家的客户数量：1945年，1950年，1955年，1960年，1965年，1970年或1975年。此查询受<code class="codeph">cust_year_of_birth</code>上的<code class="codeph">IN</code> -list <code class="codeph">cust_year_of_birth</code> 。
                        </p><pre class="oac_no_warn" dir="ltr">SELECT c2.country_name，count（c1.country_id）FROM customers c1，countries c2 WHERE c1.country_id = c2.country_id AND c1.cust_year_of_birth IN（1945,1950,1955,1960,1965,1970,1975）GROUP BY c2.country_name ;</pre><p>考虑以下两个物化视图。 <code class="codeph">cust_country_birth_mv1</code>询问1940年至1950年之间出生的每个国家的客户数量<code class="codeph">cust_country_birth_mv2</code>询问1950年之后以及1970年之前或之后出生的每个国家的客户数量。可以根据这两个物化视图重写上述查询，以获得在1945年，1950年，1955年，1960年，1965年和1970年出生的每个国家的客户总数。需要基表访问才能获得1975年出生的客户数量。
                        </p>
                        <p>物化视图对此示例的定义如下：</p><pre class="oac_no_warn" dir="ltr">CREATE MATERIALIZED VIEW cust_country_birth_mv1 ENABLE QUERY REWRITE AS SELECT c2.country_name，c1.cust_year_of_birth，COUNT（c1.country_id）AS count_customers FROM customers c1，countries c2 WHERE c1.country_id = c2.country_id AND cust_year_of_birth BETWEEN 1940 AND 1950 GROUP BY c2.country_name ，c1.cust_year_of_birth; CREATE MATERIALIZED VIEW cust_country_birth_mv2 ENABLE QUERY REWRITE AS SELECT c2.country_name，c1.cust_year_of_birth，COUNT（c1.country_id）AS count_customers FROM customers c1，countries c2 WHERE c1.country_id = c2.country_id AND cust_year_of_birth&gt; 1950 AND cust_year_of_birth &lt;= 1970 GROUP BY c2.country_name，c1.cust_year_of_birth;</pre><p>因此，查询6被重写为：</p><pre class="oac_no_warn" dir="ltr">SELECT v1.country_name，SUM（v1.count_customers）FROM（SELECT country_name，SUM（count_customers）AS count_customers FROM cust_country_birth_mv1 WHERE cust_year_of_birth IN（1945,1950）GROUP BY country_name UNION ALL SELECT country_name，SUM（count_customers）AS count_customers FROM cust_country_birth_mv2 WHERE cust_year_of_birth IN（1955,1960,1965,1970）GROUP BY country_name UNION ALL SELECT c2.country_name，COUNT（c1.country_id）AS count_customers FROM customers c1，countries c2 WHERE c1.country_id = c2.country_id AND cust_year_of_birth IN（1975）GROUP BY c2.country_name）v1 GROUP BY v1.country_name;</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-CECD1B60-A092-4AA7-AE32-B2DD97EBDD08__GUID-B11A24AD-62D2-4C4D-8934-D89ACB2F3DD0">查询7：使用多个物化视图重写PCT</p>
                        <p>使用多个物化视图重写也可以利用PCT重写。PCT重写是指在物化视图过时时仅使用物化视图的新鲜部分重写查询的功能。此功能用于<code class="codeph">ENFORCED</code>或<code class="codeph">TRUSTED</code>完整性模式，并且通过多个物化视图重写，它可以使用物化视图的新鲜部分从中获取新数据，并转到基表以获取过时数据。因此，重写的查询将<code class="codeph">UNION</code> <code class="codeph">ALL</code>仅来自一个或多个物化视图的新数据，并从基表获取其余数据以回答查询。因此，所有PCT规则和条件也适用于此。物化视图应该启用PCT，并且对基表的更改应该能够清楚地识别物化视图的新鲜和陈旧部分。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>此示例假设您有一个查询，要求信用额度介于1,000和10,000之间且出生于1945年至1964年之间的客户。此外，客户表由<code class="codeph">cust_date_of_birth</code>分区，并且有一个名为<code class="codeph">credit_mv1</code>的PCT启用的物化视图，该视图还要求信用额度介于1,000和10,000之间且出生于1945年至1964年的客户。
                        </p><pre class="oac_no_warn" dir="ltr">SELECT cust_last_name，cust_first_name FROM customers WHERE cust_credit_limit BETWEEN 1000 AND 10000;</pre><p>在<a href="advanced-query-rewrite-materialized-views.html#GUID-CECD1B60-A092-4AA7-AE32-B2DD97EBDD08__BABEFEFH">图12-7中</a> ，该图说明了物化视图中相对于基表分区<code class="codeph">p1</code> - <code class="codeph">p6</code>新鲜（暗）和陈旧（浅）的区域。
                        </p>
                        <div class="figure" id="GUID-CECD1B60-A092-4AA7-AE32-B2DD97EBDD08__BABEFEFH">
                           <p class="titleinfigure">图12-7 PCT和多个物化视图重写</p><img src="img/dwhsg112.gif" alt="下面是图12-7的描述" title="下面是图12-7的描述" longdesc="img_text/dwhsg112.html"><br><a href="img_text/dwhsg112.html">“图12-7 PCT和多个物化视图重写”的描述</a></div>
                        <!-- class="figure" -->
                        <p>假设您处于<code class="codeph">ENFORCED</code>模式，并且customer表的<code class="codeph">p1</code> ， <code class="codeph">p2</code> ， <code class="codeph">p3</code> ， <code class="codeph">p5</code>和<code class="codeph">p6</code>是新鲜的，而分区<code class="codeph">p4</code>是陈旧的。这意味着<code class="codeph">credit_mv1</code>所有分区都不能用于回答查询。重写的查询必须从其他实例化视图获取客户分区<code class="codeph">p4</code>的结果，或者如本例所示，从基表获取结果。下面，您可以看到<code class="codeph">customers</code>表的部分表定义，其中显示了表的分区方式：</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE客户（分区范围（cust_year_of_birth）分区p1值小于（1945），分区p2值小于（1950），分区p3值小于（1955），分区p4值小于（1960），分区p5值不大比（1965），PARTITION p6 VALUES少于（1970）;</pre><p>前面示例的物化视图定义如下：</p><pre class="oac_no_warn" dir="ltr">CREATE MATERIALIZED VIEW credit_mv1 ENABLE QUERY REWRITE AS SELECT cust_last_name，cust_first_name，cust_credit_limit，cust_year_of_birth FROM customers WHERE cust_credit_limit BETWEEN 1000 AND 10000 AND cust_year_of_birth BETWEEN 1945 AND 1964;</pre><p>请注意，对于表<code class="codeph">customers</code> ，此物化视图是PCT启用的。
                        </p>
                        <p>重写的查询如下：</p><pre class="oac_no_warn" dir="ltr">SELECT cust_last_name，cust_first_name FROM <span class="bold">credit_mv1</span> WHERE cust_credit_limit BETWEEN 1000 AND 10000 AND（cust_year_of_birth&gt; = 1945 AND cust_year_of_birth &lt;1955 OR cust_year_of_birth BETWEEN 1945 AND 1964）UNION ALL SELECT cust_last_name，cust_first_name FROM customers WHERE cust_credit_limit BETWEEN 1000 AND 10000 AND cust_year_of_birth &lt;1960 AND cust_year_of_birth&gt; = 1955;</pre></div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="DWHSG0803"></a><div class="props_rev_3"><a id="GUID-96BFEEAA-1C8A-4F8A-9EAF-6CDD9B148EA6" name="GUID-96BFEEAA-1C8A-4F8A-9EAF-6CDD9B148EA6"></a><h3 id="DWHSG-GUID-96BFEEAA-1C8A-4F8A-9EAF-6CDD9B148EA6" class="sect3"><span class="enumeration_section">12.3</span>其他查询重写注意事项</h3>
               <div>
                  <p>以下主题讨论了可以进行查询重写时的其他一些情况：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="advanced-query-rewrite-materialized-views.html#GUID-515C1FF2-E32D-40A8-8138-CD31DFC85568">关于使用嵌套的物化视图重写查询</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-query-rewrite-materialized-views.html#GUID-ED5B6A2D-BAF9-41BD-B075-008D8BD26AF3">关于内联视图存在时的查询重写</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-query-rewrite-materialized-views.html#GUID-6767990B-C315-4C89-BF67-1069DADC373C">关于使用远程表重写查询</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-query-rewrite-materialized-views.html#GUID-52DB7F2B-6A39-43F9-9DA5-65892266D48D">关于在重复表存在的情况下重写查询</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-query-rewrite-materialized-views.html#GUID-81BA0698-1E21-4301-B4DE-CD0E727213C6">关于使用日期折叠重写查询</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-query-rewrite-materialized-views.html#GUID-1CBDAF40-2412-4A1A-9E41-CF202A6AFDAF">关于使用视图约束重写查询</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-query-rewrite-materialized-views.html#GUID-F9ED3594-159E-451C-AABC-F74FB89B6C94">使用集合运算符物化视图查询重写</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-query-rewrite-materialized-views.html#GUID-FF240F3F-2EF8-4D46-8FAE-2B6C57FBA749">关于在分组集存在下的查询重写</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-query-rewrite-materialized-views.html#GUID-1BA3AB83-5155-47A5-90DA-1D8AEA8E8CC6">在窗函数存在的情况下查询重写</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-query-rewrite-materialized-views.html#GUID-E0B7B0AB-6D13-4AA4-BFCE-119B5834AAAF">查询重写和表达式匹配</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-query-rewrite-materialized-views.html#GUID-5C3DD547-5E57-40CE-9AC9-770214718949">查询重写期间的游标共享和绑定变量</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-query-rewrite-materialized-views.html#GUID-3FD90BE4-F577-4AB9-8762-2701C8B60193">在查询重写中处理表达式</a></p>
                     </li>
                  </ul>
               </div><a id="DWHSG08031"></a><div class="props_rev_3"><a id="GUID-515C1FF2-E32D-40A8-8138-CD31DFC85568" name="GUID-515C1FF2-E32D-40A8-8138-CD31DFC85568"></a><h4 id="DWHSG-GUID-515C1FF2-E32D-40A8-8138-CD31DFC85568" class="sect4"><span class="enumeration_section">12.3.1</span>关于使用嵌套物化视图重写查询</h4>
                  <div>
                     <p>询问<a id="d44607e3643" class="indexterm-anchor"></a>重写尝试迭代利用嵌套的物化视图。Oracle数据库首先尝试使用具有聚合和连接的实体化视图重写查询，然后使用仅包含连接的实体化视图。如果任何重写成功，Oracle将再次重复该过程，直到找不到重写。例如，假设您已创建物化视图<code class="codeph">join_sales_time_product_mv</code>和<code class="codeph">sum_sales_time_product_mv</code> ，如下所示：</p><pre class="oac_no_warn" dir="ltr">CREATE MATERIALIZED VIEW join_sales_time_product_mv ENABLE QUERY REWRITE AS SELECT p.prod_id，p.prod_name，t.time_id，t.week_ending_day，s.channel_id，s.promo_id，s.cust_id，s.amount_sold FROM sales s，products p，times t WHERE s.time_id = t.time_id AND s.prod_id = p.prod_id; CREATE MATERIALIZED VIEW sum_sales_time_product_mv ENABLE QUERY REWRITE AS SELECT mv.prod_name，mv.week_ending_day，COUNT（*）cnt_all，SUM（mv.amount_sold）sum_amount_sold，COUNT（mv.amount_sold）cnt_amount_sold FROM join_sales_time_product_mv mv GROUP BY mv.prod_name，mv.week_ending_day ;</pre><p>然后考虑以下查询：</p><pre class="oac_no_warn" dir="ltr">SELECT p.prod_name，t.week_ending_day，SUM（s.amount_sold）FROM sales s，products p，times t WHERE s.time_id = t.time_id AND s.prod_id = p.prod_id GROUP BY p.prod_name，t.week_ending_day;</pre><p>Oracle发现<code class="codeph">join_sales_time_product_mv</code>符合重写条件。重写的查询具有以下形式：</p><pre class="oac_no_warn" dir="ltr">SELECT mv.prod_name，mv.week_ending_day，SUM（mv.amount_sold）FROM join_sales_time_product_mv mv GROUP BY mv.prod_name，mv.week_ending_day;</pre><p>由于发生了重写，Oracle再次尝试该过程。这次，可以使用单表聚合物化视图<code class="codeph">sum_sales_store_time</code>将查询重写为以下形式：</p><pre class="oac_no_warn" dir="ltr">SELECT mv.prod_name，mv.week_ending_day，mv.sum_amount_sold FROM sum_sales_time_product_mv mv;</pre></div>
               </div><a id="DWHSG08032"></a><div class="props_rev_3"><a id="GUID-ED5B6A2D-BAF9-41BD-B075-008D8BD26AF3" name="GUID-ED5B6A2D-BAF9-41BD-B075-008D8BD26AF3"></a><h4 id="DWHSG-GUID-ED5B6A2D-BAF9-41BD-B075-008D8BD26AF3" class="sect4"><span class="enumeration_section">12.3.2</span>关于内联视图存在时的查询重写</h4>
                  <div>
                     <p>O racle Database支持使用内联视图以两种方式重写查询：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>当物化视图中的内联视图中的文本与请求查询中的文本完全匹配时</p>
                        </li>
                        <li>
                           <p>当请求查询包含与实例化视图中的内联视图等效的内联视图时</p>
                        </li>
                     </ul>
                     <p>如果两个内联视图的<code class="codeph">SELECT</code>列表和<code class="codeph">GROUP</code> <code class="codeph">BY</code>列表是等效的，则它们被认为是等价的， <code class="codeph">FROM</code>子句包含相同或等效的对象，它们的连接图，包括<code class="codeph">WHERE</code>子句中的所有选择是等效的，并且它们的<code class="codeph">HAVING</code>子句是等效的。
                     </p>
                     <p>以下示例说明了如何使用文本匹配和常规内联视图重写，使用内联视图的查询可以使用实例化视图进行重写。请考虑以下包含内联视图的物化视图：</p><pre class="oac_no_warn" dir="ltr">CREATE MATERIALIZED VIEW SUM_SALES_MV ENABLE QUERY REWRITE as SELECT mv_iv.prod_id，mv_iv.cust_id，sum（mv_iv.amount_sold）sum_amount_sold FROM（SELECT prod_id，cust_id，amount_sold FROM sales，products WHERE sales.prod_id = products.prod_id）MV_IV GROUP BY mv_iv。 prod_id，mv_iv.cust_id;</pre><p>以下查询具有内联视图，其文本与实例化视图的内联视图的文本完全匹配。因此，查询内联视图在内部被物化视图的内联视图替换，以便可以重写查询：</p><pre class="oac_no_warn" dir="ltr">SELECT iv.prod_id，iv.cust_id，SUM（iv.amount_sold）sum_amount_sold FROM（SELECT prod_id，cust_id，amount_sold FROM sales，products WHERE sales.prod_id = products.prod_id）IV GROUP BY iv.prod_id，iv.cust_id;</pre><p>以下查询的内联视图与前面的物化视图中的内联视图没有完全匹配的文本。请注意，切换查询内联视图中的连接谓词。即使此查询在文本上与实体化视图的内联视图的查询不匹配，查询重写也会将查询的内联视图标识为与实体化视图的内联视图等效。和以前一样，查询内联视图将在内部替换为实体化视图的内联视图，以便可以重写查询。</p><pre class="oac_no_warn" dir="ltr">SELECT iv.prod_id，iv.cust_id，SUM（iv.amount_sold）sum_amount_sold FROM（SELECT prod_id，cust_id，amount_sold FROM sales，products WHERE products.prod_id = sales.prod_id）IV GROUP BY iv.prod_id，iv.cust_id;</pre><p>这两个查询都使用<code class="codeph">SUM_SALES_MV</code>重写，如下所示：</p><pre class="oac_no_warn" dir="ltr">SELECT prod_id，cust_id，sum_amount_sold FROM SUM_SALES_MV;</pre><p>对于包含集合运算符， <code class="codeph">GROUPING</code> <code class="codeph">SET</code>子句，嵌套子查询，嵌套内联视图和远程表的查询，不支持常规内联视图重写。
                     </p>
                  </div>
               </div><a id="DWHSG00323"></a><div class="props_rev_3"><a id="GUID-6767990B-C315-4C89-BF67-1069DADC373C" name="GUID-6767990B-C315-4C89-BF67-1069DADC373C"></a><h4 id="DWHSG-GUID-6767990B-C315-4C89-BF67-1069DADC373C" class="sect4"><span class="enumeration_section">12.3.3</span>关于使用远程表重写查询</h4>
                  <div>
                     <p>Oracle数据库支持使用在单个远程数据库站点引用表的物化视图进行查询重写。请注意，实例化视图应出现在发出查询的站点上。由于任何远程表更新都无法同时传播到本地站点，因此查询重写仅适用于<code class="codeph">stale_tolerated</code>模式。每当查询包含在实例化视图中找不到的列时，它就会使用一种名为join back的技术来重写查询。但是，如果在本地站点上找不到联接回表，则不会进行查询重写。此外，由于远程站点的约束信息在远程站点不可用，因此查询重写不会使用任何约束信息。
                     </p>
                     <p>以下查询包含在单个远程站点上找到的表：</p><pre class="oac_no_warn" dir="ltr">SELECT p.prod_id，t.week_ending_day，s.cust_id，SUM（s.amount_sold）AS sum_amount_sold FROM sales @ remotedbl s，products @ remotedbl p，times @ remotedbl t WHERE s.time_id = t.time_id AND s.prod_id = p .prod_id GROUP BY p.prod_id，t.week_ending_day，s.cust_id;</pre><p>以下物化视图存在于本地站点，但它引用了在远程站点上找到的表：</p><pre class="oac_no_warn" dir="ltr">CREATE MATERIALIZED VIEW sum_sales_prod_week_mv ENABLE QUERY REWRITE AS SELECT p.prod_id，t.week_ending_day，s.cust_id，SUM（s.amount_sold）AS sum_amount_sold FROM sales @ remotedbl s，products @ remotedbl p，times @ remotedbl t WHERE s.time_id = t .time_id AND s.prod_id = p.prod_id GROUP BY p.prod_id，t.week_ending_day，s.cust_id;</pre><p>即使查询引用了远程表，也会使用以前的物化视图重写它，如下所示：</p><pre class="oac_no_warn" dir="ltr">SELECT prod_id，week_ending_day，cust_id，sum_amount_sold FROM sum_sales_prod_week_mv;</pre></div>
               </div><a id="DWHSG08034"></a><div class="props_rev_3"><a id="GUID-52DB7F2B-6A39-43F9-9DA5-65892266D48D" name="GUID-52DB7F2B-6A39-43F9-9DA5-65892266D48D"></a><h4 id="DWHSG-GUID-52DB7F2B-6A39-43F9-9DA5-65892266D48D" class="sect4"><span class="enumeration_section">12.3.4</span>关于在重复表存在的情况下重写查询</h4>
                  <div>
                     <p>Oracle数据库<a id="d44607e3817" class="indexterm-anchor"></a>完成查询重写包含对同一个表的多个引用的查询，或通过采用两种不同的策略进行自联接。使用第一个策略，您需要确保查询和物化视图定义对表的多个引用具有相同的别名。如果您未提供匹配的别名，Oracle将尝试第二种策略，其中比较查询和物化视图中的联接，以将查询中的多个引用与实例化视图中的多个引用相匹配。
                     </p>
                     <p>以下是物化视图和查询的示例。在此示例中，查询缺少对表中列的引用，因此精确的文本匹配不起作用。但是，可以进行常规查询重写，因为表引用的别名匹配。</p>
                     <p>为了演示<code class="codeph">sh</code>示例模式的自联接重写可能性，假设以下添加内容包括事实表中的实际发货和付款日期，引用相同的维度表时间。这仅用于演示目的，不会返回任何结果：</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE销售额ADD（time_id_ship DATE）; ALTER TABLE sales ADD（CONSTRAINT time_id_book_fk FOREIGN key（time_id_ship）REFERENCES times（time_id）ENABLE NOVALIDATE）; ALTER TABLE销售MODIFY CONSTRAINT time_id_book_fk RELY; ALTER TABLE销售额ADD（time_id_paid DATE）; ALTER TABLE sales ADD（CONSTRAINT time_id_paid_fk FOREIGN KEY（time_id_paid）REFERENCES次数（time_id）ENABLE NOVALIDATE）; ALTER TABLE销售MODIFY CONSTRAINT time_id_paid_fk RELY;</pre><p>现在，您可以按如下方式定义物化视图：</p><pre class="oac_no_warn" dir="ltr">CREATE MATERIALIZED VIEW sales_shipping_lag_mv ENABLE QUERY REWRITE AS SELECT t1.fiscal_week_number，s.prod_id，t2.fiscal_week_number -t1.fiscal_week_number AS lag from times t1，sales s，times t2 WHERE t1.time_id = s.time_id AND t2.time_id = s。 time_id_ship;</pre><p>以下查询未通过完全文本匹配测试但由于表引用的别名匹配而被重写：</p><pre class="oac_no_warn" dir="ltr">SELECT s.prod_id，t2.fiscal_week_number  -  t1.fiscal_week_number AS lag from times t1，sales s，times t2 WHERE t1.time_id = s.time_id AND t2.time_id = s.time_id_ship;</pre><p>请注意，Oracle数据库执行其他检查以确保请求查询中的乘法实例表的实例与实例化视图中的相应表实例正确匹配。例如，在以下示例中，Oracle正确确定用于表<code class="codeph">times</code>的多个实例的匹配别名不会在实例化视图中的多个表<code class="codeph">times</code>实例之间建立匹配。
                     </p>
                     <p>使用<code class="codeph">sales_shipping_lag_mv</code>无法重写以下查询，即使乘法实例化表<code class="codeph">time</code>的别名匹配，因为连接在<code class="codeph">t2</code>别名的<code class="codeph">time</code>实例之间不兼容：</p><pre class="oac_no_warn" dir="ltr">SELECT s.prod_id，t2.fiscal_week_number  -  t1.fiscal_week_number AS lag FROM times t1，sales s，times t2 WHERE t1.time_id = s.time_id AND t2.time_id = s.time_id_paid;</pre><p>此请求查询加入的实例<code class="codeph">time</code>通过别名表<code class="codeph">t2</code>上<code class="codeph">s.time_id_paid</code>列，而物化视图加入实例<code class="codeph">times</code>表通过别名<code class="codeph">t2</code>上<code class="codeph">s.time_id_ship</code>列。由于连接条件不同，Oracle正确地确定不能进行重写。
                     </p>
                     <p>以下查询在物化视图中没有任何匹配的别名， <code class="codeph">sales_shipping_lag_mv</code> ，表格，时间。但查询重写现在比较查询和物化视图之间的连接，并正确匹配多个时间实例。
                     </p><pre class="oac_no_warn" dir="ltr">SELECT s.prod_id，x2.fiscal_week_number  -  x1.fiscal_week_number AS lag FROM times x1，sales s，times x2 WHERE x1.time_id = s.time_id AND x2.time_id = s.time_id_ship;</pre></div>
               </div><a id="DWHSG08035"></a><div class="props_rev_3"><a id="GUID-81BA0698-1E21-4301-B4DE-CD0E727213C6" name="GUID-81BA0698-1E21-4301-B4DE-CD0E727213C6"></a><h4 id="DWHSG-GUID-81BA0698-1E21-4301-B4DE-CD0E727213C6" class="sect4"><span class="enumeration_section">12.3.5</span>关于使用日期折叠重写查询</h4>
                  <div>
                     <p><a id="d44607e3913" class="indexterm-anchor"></a><a id="d44607e3917" class="indexterm-anchor"></a>日期折叠重写是表达匹配重写的特定形式。在这种类型的重写中，查询中的日期范围被折叠到表示更高日期粒度的等效日期范围中。表示折叠日期范围中较高日期粒度的结果表达式与物化视图中的等效表达式匹配。当列的基础数据类型是Oracle <code class="codeph">DATE</code>时，将日期范围折叠为更高的日期粒度（例如月，季度或年）。表达式匹配是基于表达式的规范形式的使用完成的。
                     </p>
                     <p><code class="codeph">DATE</code>是一种内置数据类型，表示有序时间单位，如秒，天和月，并包含时间层次结构（第二 - &gt;分钟 - &gt;小时 - &gt;日 - &gt;月 - &gt;季 - &gt;年）。这种关于<code class="codeph">DATE</code>硬编码知识用于折叠日期范围，从较低日期颗粒到较高日期颗粒。具体而言，支持将日期值折叠到月，季，年或月末，季度，年的开头。例如，日期值<code class="codeph">1-jan-1999</code>可以折叠成的一年无论是年初<code class="codeph">1999</code>或季度<code class="codeph">1999-1</code>或每月<code class="codeph">1999-01</code> 。而且，日期值<code class="codeph">30-sep-1999</code>可以折叠成任何季度末的<code class="codeph">1999-03</code>或月<code class="codeph">1999-09</code> 。
                     </p>
                     <div class="infoboxnote" id="GUID-81BA0698-1E21-4301-B4DE-CD0E727213C6__GUID-49A7F06C-8E9E-45FF-91D4-96E2D3A8532F">
                        <p class="notep1">注意：</p>
                        <p>由于日期折叠的工作方式，使用<code class="codeph">BETWEEN</code>和日期列时应该小心。使用<code class="codeph">BETWEEN</code>和日期列的最佳方法是将较晚的日期增加1。换句话说，不应使用<code class="codeph">date_col BETWEEN '1-jan-1999' AND '30-jun-1999'</code> ，而应使用<code class="codeph">date_col</code> <code class="codeph">BETWEEN '1-jan-1999' AND '1-jul-1999'</code> 。您还可以使用<code class="codeph">TRUNC</code>函数来获得等效结果，如<code class="codeph">TRUNC(date_col)</code> <code class="codeph">BETWEEN '1-jan-1999' AND '30-jun-1999'</code> 。但是， <code class="codeph">TRUNC</code>将剥离时间值。
                        </p>
                     </div>
                     <p>由于日期值是有序的，因此日期列中指定的任何范围谓词都可以从较低级别的颗粒折叠成较高级别的颗粒，前提是日期范围表示较高级别颗粒的整数。例如，该范围谓词<code class="codeph">date_col &gt;= '1-jan-1999'</code> <code class="codeph">AND</code> <code class="codeph">date_col</code> <code class="codeph">&lt;</code> '30 -Jun-1999'可被折叠成或者一个月范围或使用四分之一范围<code class="codeph">TO_CHAR</code>功能，其提取从特定日期分量日期值。
                     </p>
                     <p>通过折叠日期值聚合数据的优点是对所实现数据的压缩。如果没有日期折叠，则会以最低粒度级别聚合数据，从而增加存储空间并增加I / O以扫描实例化视图。</p>
                     <p>考虑一个询问1998年产品类型的销售总额的查询：</p><pre class="oac_no_warn" dir="ltr">SELECT p.prod_category，SUM（s.amount_sold）FROM sales s，products p WHERE s.prod_id = p.prod_id AND s.time_id&gt; = TO_DATE（'01 -jan-1998'，'dd-mon-yyyy'）AND s.time_id &lt;TO_DATE（'01 -jan-1999'，'dd-mon-yyyy'）GROUP BY p.prod_category; CREATE MATERIALIZED VIEW sum_sales_pcat_monthly_mv ENABLE QUERY REWRITE AS SELECT p.prod_category，TO_CHAR（s.time_id，'YYYY-MM'）AS月，SUM（s.amount_sold）AS sum_amount FROM sales s，products p WHERE s.prod_id = p.prod_id GROUP BY p.prod_category，TO_CHAR（s.time_id，'YYYY-MM'）; SELECT p.prod_category，SUM（s.amount_sold）FROM sales s，products p WHERE s.prod_id = p.prod_id AND TO_CHAR（s.time_id，'YYYY-MM'）&gt; = '01 -jan-1998'AND TO_CHAR（ s.time_id，'YYYY-MM'）&lt;'01 -jan-1999'GROUP BY p.prod_category; SELECT mv.prod_category，mv.sum_amount FROM sum_sales_pcat_monthly_mv mv WHERE month&gt; = '01 -jan-1998'AND month &lt;'01 -jan-1999';</pre><p>查询中指定的范围表示整数年，季度或月。假设有一个物化视图<code class="codeph">mv3</code>通过包含预汇总销售<code class="codeph">prod_type</code>和定义如下：</p><pre class="oac_no_warn" dir="ltr">CREATE MATERIALIZED VIEW mv3启用QUERY REWRITE作为SELECT prod_name，TO_CHAR（sales.time_id，'yyyy-mm'）AS月，SUM（amount_sold）AS sum_sales FROM sales，products WHERE sales.prod_id = products.prod_id GROUP BY prod_name，TO_CHAR（ sales_time_id，'yyyy-mm'）;</pre><p>可以通过首先将日期范围折叠到月份范围中，然后将表示月份的表达式与<code class="codeph">mv3</code>的月份表达式进行匹配来重写查询。此重写分两步显示（首先折叠日期范围，然后是实际重写）。
                     </p><pre class="oac_no_warn" dir="ltr">SELECT prod_name，SUM（amount_sold）AS sum_sales FROM sales，products WHERE sales.prod_id = products.prod_id AND TO_CHAR（sales.time_id，'yyyy-mm'）&gt; = TO_CHAR（'01 -jan-1998'，'yyyy-mm '）AND TO_CHAR（sales.time_id，'01 -jan-1999'，'yyyy-mm'）&lt;TO_CHAR（TO_DATE（''01-jan-1999''，''dd-mon-yyyy''），' 'yyyy-mm''）GROUP BY prod_name; SELECT prod_name，sum_sales FROM mv3 WHERE month&gt; = TO_CHAR（TO_DATE（'01 -jan-1998'，'dd-mon-yyyy'），'yyyy-mm'）AND月&lt;TO_CHAR（TO_DATE（'01 -jan-1999） '，'dd-mon-yyyy'），'yyyy-mm'）;</pre><p>如果<code class="codeph">mv3</code>通过<code class="codeph">prod_name</code>和year而不是<code class="codeph">prod_name</code>和month预先汇总了销售额，则仍可以通过将日期范围折叠到年份范围然后匹配年份表达式来重写查询。
                     </p>
                  </div>
               </div><a id="DWHSG8546"></a><a id="DWHSG8547"></a><a id="DWHSG08036"></a><div class="props_rev_3"><a id="GUID-1CBDAF40-2412-4A1A-9E41-CF202A6AFDAF" name="GUID-1CBDAF40-2412-4A1A-9E41-CF202A6AFDAF"></a><h4 id="DWHSG-GUID-1CBDAF40-2412-4A1A-9E41-CF202A6AFDAF" class="sect4"><span class="enumeration_section">12.3.6</span>关于使用视图约束重写查询</h4>
                  <div>
                     <p>数据仓库<a id="d44607e4062" class="indexterm-anchor"></a><a id="d44607e4064" class="indexterm-anchor"></a><a id="d44607e4068" class="indexterm-anchor"></a>应用程序通过识别关系模式中的完整性约束来识别数据库中的多维立方体。完整性约束表示事实和维度表之间的主要和外部关键关系。通过查询数据字典，应用程序可以识别完整性约束，从而识别数据库中的多维数据集。但是，在数据库管理员出于架构复杂性或安全性原因定义事实和维度表的视图的情况下，这不起作用。在此类环境中，应用程序无法正确识别多维数据集。通过允许视图之间的约束定义，您可以将基表约束传播到视图，从而允许应用程序即使在受限制的环境中也能识别多维数据集。
                     </p>
                     <p>视图约束定义本质上是声明性的，但视图上的操作受基础基表上定义的完整性约束的约束，视图上的约束可以通过对基表的约束来实施。定义基表的约束不仅对于数据的正确性和清晰度是必要的，而且对于使用原始基础对象的物化视图查询重写目的也是必要的。</p>
                     <div class="infoboxnotealso" id="GUID-1CBDAF40-2412-4A1A-9E41-CF202A6AFDAF__GUID-E9054D4F-656F-4836-948A-5B1443AA16B4">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="advanced-query-rewrite-materialized-views.html#GUID-5A432C77-CFB2-41EF-ACBF-B57F39F712DB">Abut View约束限制</a></p>
                     </div>
                     <p>物化视图重写广泛使用约束进行查询重写。它们用于确定无损连接，这反过来又确定实体化视图中的连接是否与查询中的连接兼容，因此是否可以重写。</p>
                     <p><code class="codeph">DISABLE</code> <code class="codeph">NOVALIDATE</code>是视图约束的唯一有效状态。但是，您可以选择<code class="codeph">RELY</code>或<code class="codeph">NORELY</code>作为视图约束状态，以启用更复杂的查询重写。例如， <code class="codeph">RELY</code>状态中的视图约束允许在查询完整性级别设置为<code class="codeph">TRUSTED</code>时进行查询重写。 <a href="advanced-query-rewrite-materialized-views.html#GUID-1CBDAF40-2412-4A1A-9E41-CF202A6AFDAF__g1021713" title="查看约束并重写完整性模式">表12-3</a>说明了视图约束何时用于确定无损连接。
                     </p>
                     <p>请注意，视图约束不能用于查询重写完整性级别<code class="codeph">ENFORCED</code> 。此级别强制执行最高程度的约束强制执行<code class="codeph">ENABLE</code> <code class="codeph">VALIDATE</code> 。</p>
                     <div class="tblformal" id="GUID-1CBDAF40-2412-4A1A-9E41-CF202A6AFDAF__g1021713">
                        <p class="titleintable">表12-3视图约束和重写完整性模式</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="查看约束并重写完整性模式" width="100%" border="1" summary="View Constraints and Rewrite Integrity Modes" frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="39%" id="d44607e4129">约束国</th>
                                 <th align="left" valign="bottom" width="31%" id="d44607e4132">依靠</th>
                                 <th align="left" valign="bottom" width="31%" id="d44607e4135">NORELY</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="39%" id="d44607e4140" headers="d44607e4129 ">
                                    <p><code class="codeph">ENFORCED</code></p>
                                 </td>
                                 <td align="left" valign="top" width="31%" headers="d44607e4140 d44607e4132 ">
                                    <p>没有</p>
                                 </td>
                                 <td align="left" valign="top" width="31%" headers="d44607e4140 d44607e4135 ">
                                    <p>没有</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="39%" id="d44607e4151" headers="d44607e4129 ">
                                    <p><code class="codeph">可信</code></p>
                                 </td>
                                 <td align="left" valign="top" width="31%" headers="d44607e4151 d44607e4132 ">
                                    <p>是</p>
                                 </td>
                                 <td align="left" valign="top" width="31%" headers="d44607e4151 d44607e4135 ">
                                    <p>没有</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="39%" id="d44607e4162" headers="d44607e4129 ">
                                    <p><code class="codeph">STALE_TOLERATED</code></p>
                                 </td>
                                 <td align="left" valign="top" width="31%" headers="d44607e4162 d44607e4132 ">
                                    <p>是</p>
                                 </td>
                                 <td align="left" valign="top" width="31%" headers="d44607e4162 d44607e4135 ">
                                    <p>没有</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <div class="example" id="GUID-1CBDAF40-2412-4A1A-9E41-CF202A6AFDAF__GUID-71FAD2CE-6181-4F5D-A80B-05080F6A42A4">
                        <p class="titleinexample">示例12-10查看约束</p>
                        <p>要演示视图的重写功能，您需要扩展<code class="codeph">sh</code>示例模式，如下所示：</p><pre class="oac_no_warn" dir="ltr">CREATE VIEW time_view AS SELECT time_id，TO_NUMBER（TO_CHAR（time_id，'ddd'））AS day_in_year FROM times;</pre><p>您现在可以在视图和事实表之间建立外键/主键关系（在<code class="codeph">RELY</code>模式下），因此通过添加以下约束，可以按<a href="advanced-query-rewrite-materialized-views.html#GUID-1CBDAF40-2412-4A1A-9E41-CF202A6AFDAF__g1021713" title="查看约束并重写完整性模式">表12-3中</a>所述进行重写。然后，重写将在<code class="codeph">TRUSTED</code>模式下工作。
                        </p><pre class="oac_no_warn" dir="ltr">ALTER VIEW time_view ADD（CONSTRAINT time_view_pk PRIMARY KEY（time_id）DISABLE NOVALIDATE）; ALTER VIEW time_view MODIFY CONSTRAINT time_view_pk RELY; ALTER TABLE sales ADD（CONSTRAINT time_view_fk FOREIGN KEY（time_id）REFERENCES time_view（time_id）DISABLE NOVALIDATE）; ALTER TABLE销售MODIFY CONSTRAINT time_view_fk RELY;</pre><p>请考虑以下物化视图定义：</p><pre class="oac_no_warn" dir="ltr">CREATE MATERIALIZED VIEW sales_pcat_cal_day_mv ENABLE QUERY REWRITE AS SELECT p.prod_category，t.day_in_year，SUM（s.amount_sold）AS sum_amount_sold FROM time_view t，sales s，products p WHERE t.time_id = s.time_id AND p.prod_id = s.prod_id GROUP BY p.prod_category，t.day_in_year;</pre><p>以下查询（省略维表<code class="codeph">products</code> ）也会在没有主键/外键关系的情况下重写，因为已知<code class="codeph">sales</code>和<code class="codeph">products</code>之间的抑制连接是无损的。
                        </p><pre class="oac_no_warn" dir="ltr">SELECT t.day_in_year，SUM（s.amount_sold）AS sum_amount_sold FROM time_view t，sales s WHERE t.time_id = s.time_id GROUP BY t.day_in_year;</pre><p>但是，如果物化视图<code class="codeph">sales_pcat_cal_day_mv</code>都在视图中的术语所限定<code class="codeph">time_view</code> ，那么你可以不写下面的查询，然后抑制之间的连接<code class="codeph">sales</code>和<code class="codeph">time_view</code> ，因为对于三角洲losslessness物化视图是没有根据的加入。使用前面显示的附加约束，此查询也将重写。
                        </p><pre class="oac_no_warn" dir="ltr">SELECT p.prod_category，SUM（s.amount_sold）AS sum_amount_sold FROM sales s，products p WHERE p.prod_id = s.prod_id GROUP BY p.prod_category;</pre><p>要撤消对<code class="codeph">sh</code>模式所做的更改，请发出以下语句：</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE sales DROP CONSTRAINT time_view_fk; DROP VIEW time_view;</pre></div>
                     <!-- class="example" -->
                  </div><a id="DWHSG8548"></a><div class="props_rev_3"><a id="GUID-5A432C77-CFB2-41EF-ACBF-B57F39F712DB" name="GUID-5A432C77-CFB2-41EF-ACBF-B57F39F712DB"></a><h5 id="DWHSG-GUID-5A432C77-CFB2-41EF-ACBF-B57F39F712DB" class="sect5"><span class="enumeration_section">12.3.6.1</span> Abut视图约束限制</h5>
                     <div>
                        <div class="section">
                           <p>如果引用约束定义涉及视图，即外键或引用的键驻留在视图中，则约束只能处于<code class="codeph">DISABLE</code> <code class="codeph">NOVALIDATE</code>模式。
                           </p>
                           <p>甲<code class="codeph">RELY</code>如果引用的上视图约束只允许<code class="codeph">UNIQUE</code>或<code class="codeph">PRIMARY</code> <code class="codeph">KEY</code>在约束<code class="codeph">DISABLE</code> <code class="codeph">NOVALIDATE</code>模式也是<code class="codeph">RELY</code>约束。
                           </p>
                           <p>不允许与参照完整性约束关联的<code class="codeph">ON</code> <code class="codeph">DELETE</code>操作的规范（例如， <code class="codeph">DELETE</code>级联）。但是，由于视图约束处于<code class="codeph">DISABLE</code> <code class="codeph">NOVALIDATE</code>模式，因此对视图及其基表允许<code class="codeph">DELETE</code> ， <code class="codeph">UPDATE</code>和<code class="codeph">INSERT</code>操作。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-67BDE6F3-C911-4923-9778-D86654EF21DF" name="GUID-67BDE6F3-C911-4923-9778-D86654EF21DF"></a><h4 id="DWHSG-GUID-67BDE6F3-C911-4923-9778-D86654EF21DF" class="sect4"><span class="enumeration_section">12.3.7</span>关于混合分区表存在时的查询重写</h4>
                  <div>
                     <p>查询重写认为混合分区表中的外部分区具有UNKNOWN新鲜度。因此，当查询从一个或多个外部分区请求数据时，它只能在<code class="codeph">TRUSTED</code>或<code class="codeph">STALE_TOLERATED</code>完整性模式下重写。
                     </p>
                     <p></p>
                     <p>当基于混合分区表的物化视图在其<code class="codeph">SELECT</code>列表中包含分区键或分区标记时，它有资格进行分区跟踪。对于基于未启用PCT的混合分区表表的物化视图， <code class="codeph">STALE_TOLERATED</code>是唯一可能的完整性模式。
                     </p>
                     <p>仅当混合分区表是范围或列表分区时，才能使用<code class="codeph">ENFORCED</code>和<code class="codeph">TRUSTED</code>完整性模式下的PCT重写来重写对混合分区表的查询。
                     </p>
                     <div class="example" id="GUID-67BDE6F3-C911-4923-9778-D86654EF21DF__GUID-1723304E-8128-4666-98F2-85E5495A5171">
                        <p class="titleinexample">例12-11基于混合分区表的查询重写和物化视图</p>
                        <p>名为<code class="codeph">hybrid_sales</code>的混合分区表使用<code class="codeph">ENFORCED</code>完整性模式。其中一个内部分区是陈旧的。
                        </p>
                        <p>运行以下查询：</p><pre class="pre codeblock"><code>SELECT customer_no，sum（price）as sum_price FROM hybrid_sales WHERE time_id&gt; TO_DATE（'01 -01-1950'）和time_id &lt;TO_DATE（'06 -01-2001'）GROUP BY customer_no;</code></pre><p>可以重写此查询以使用混合分区表。PCT重写直接从基表中选择物化视图中的新分区和任何陈旧分区和外部分区。重写的查询如下：</p><pre class="pre codeblock"><code>SELECT v1.customer_no，SUM（v1.total_price）sum_price FROM（SELECT customer_no，SUM（total_price）FROM Hybrid_sales WHERE time_id&gt; TO_DATE（'01 -01-1950'）和time_id &lt;TO_DATE（'01 -01-2000'）GROUP BY customer_no UNION ALL SELECT customer_no，SUM（total_price）FROM HyPT_MV WHERE time_id&gt; TO_DATE（'01 -01-2000'）和time_id &lt;TO_DATE（'01 -01-2001'）GROUP BY customer_no UNION ALL SELECT customer_no，SUM（total_price ）FROM Hybrid_sales WHERE time_id&gt; TO_DATE（'01 -01-2001'）和time_id &lt;TO_DATE（'06 -01-2001'）GROUP BY customer_no）v1 GROUP BY v1.customer_no;</code></pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="DWHSG08037"></a><div class="props_rev_3"><a id="GUID-F9ED3594-159E-451C-AABC-F74FB89B6C94" name="GUID-F9ED3594-159E-451C-AABC-F74FB89B6C94"></a><h4 id="DWHSG-GUID-F9ED3594-159E-451C-AABC-F74FB89B6C94" class="sect4"><span class="enumeration_section">12.3.8</span>使用集合运算符物化视图重写查询</h4>
                  <div>
                     <p>您<a id="d44607e4405" class="indexterm-anchor"></a>可以使用包含集合运算符的物化视图的查询重写。在这种情况下，查询和物化视图不必在文本上匹配以进行重写。例如，请考虑以下物化视图，该视图使用来自旧金山或洛杉矶的男性客户的邮政编码：</p><pre class="oac_no_warn" dir="ltr">CREATE MATERIALIZED VIEW cust_male_postal_mv ENABLE QUERY REWRITE AS SELECT c.cust_city，c.cust_postal_code FROM customers c WHERE c.cust_gender ='M'AND c.cust_city ='San Francisco'UNION ALL SELECT c.cust_city，c.cust_postal_code FROM customers c WHERE c.cust_gender ='M'和c.cust_city ='洛杉矶';</pre><p>如果您有以下查询，该查询显示来自旧金山或洛杉矶的男性客户的邮政编码：</p><pre class="oac_no_warn" dir="ltr">SELECT c.cust_city，c.cust_postal_code FROM customers c WHERE c.cust_city ='洛杉矶'和c.cust_gender ='M'UNION ALL SELECT c.cust_city，c.cust_postal_code FROM customers c WHERE c.cust_city ='San Francisco' AND c.cust_gender ='M';</pre><p>重写的查询将如下：</p><pre class="oac_no_warn" dir="ltr">SELECT mv.cust_city，mv.cust_postal_code FROM cust_male_postal_mv mv;</pre><p>重写的查询已删除<code class="codeph">UNION</code> <code class="codeph">ALL</code>并将其替换为物化视图。通常，查询重写必须使用现有的一般资格规则集来确定<code class="codeph">UNION</code> <code class="codeph">ALL</code>下的<code class="codeph">SELECT</code>选择在查询和物化视图中是否相同。
                     </p>
                     <p>请参阅<a href="advanced-query-rewrite-materialized-views.html#GUID-26E9AF20-AE8E-4D6E-9AF0-E5C9679A09F6">UNION ALL Marker和Query Rewrite</a> 。
                     </p>
                     <p>例如，如果您有一个查询从旧金山，Palmdale或洛杉矶检索男性客户的邮政编码，则可能会发生与前一个示例相同的重写，但查询重写必须使<code class="codeph">UNION</code> <code class="codeph">ALL</code>保留基表，如下所示：</p><pre class="oac_no_warn" dir="ltr">SELECT c.cust_city，c.cust_postal_code FROM customers c WHERE c.cust_city ='Palmdale'AND c.cust_gender ='M'UNION ALL SELECT c.cust_city，c.cust_postal_code FROM customers c WHERE c.cust_city ='洛杉矶'和c.cust_gender ='M'UNION ALL SELECT c.cust_city，c.cust_postal_code FROM customers c WHERE c.cust_city ='San Francisco'AND c.cust_gender ='M';</pre><p>重写的查询将是：</p><pre class="oac_no_warn" dir="ltr">SELECT mv.cust_city，mv.cust_postal_code FROM cust_male_postal_mv mv UNION ALL SELECT c.cust_city，c.cust_postal_code FROM customers c WHERE c.cust_city ='Palmdale'AND c.cust_gender ='M';</pre><p>因此，查询重写检测可以使用物化视图<code class="codeph">cust_male_postal_mv</code>重写<code class="codeph">UNION</code> <code class="codeph">ALL</code>的子集的情况。</p>
                     <p><code class="codeph">UNION</code> ， <code class="codeph">UNION</code> <code class="codeph">ALL</code>和<code class="codeph">INTERSECT</code>是可交换的，因此无论在查询或物化视图中找到子选择的顺序如何，都可以重写查询重写。但是， <code class="codeph">MINUS</code>不是可交换的。<code class="codeph">MINUS</code> B不等于B <code class="codeph">MINUS</code> A.因此，子查询在查询中的<code class="codeph">MINUS</code>运算符下出现的顺序和物化视图必须按相同的顺序重写才能发生。例如，考虑存在名为<code class="codeph">customer_old</code>的旧版客户表的情况，并且您希望仅为居住在伦敦的男性客户找到旧表和当前客户表之间的差异。也就是说，您希望在当前的客户中找到那些不属于旧客户的客户。以下示例显示了如何使用<code class="codeph">MINUS</code>运算符完成此操作：</p><pre class="oac_no_warn" dir="ltr">SELECT c.cust_city，c.cust_postal_code FROM customers c WHERE c.cust_city ='洛杉矶'和c.cust_gender ='M'MINUS SELECT c.cust_city，c.cust_postal_code FROM customers_old c WHERE c.cust_city ='洛杉矶'和c.cust_gender ='M';</pre><p>切换子选择将产生不同的答案。这表明<code class="codeph">MINUS</code>不是可交换的。
                     </p>
                  </div><a id="DWHSG8549"></a><div class="props_rev_3"><a id="GUID-26E9AF20-AE8E-4D6E-9AF0-E5C9679A09F6" name="GUID-26E9AF20-AE8E-4D6E-9AF0-E5C9679A09F6"></a><h5 id="DWHSG-GUID-26E9AF20-AE8E-4D6E-9AF0-E5C9679A09F6" class="sect5"><span class="enumeration_section">12.3.8.1</span> UNION ALL标记和查询重写</h5>
                     <div>
                        <p>如果物化视图包含一个或多个<code class="codeph">UNION</code> <code class="codeph">ALL</code>运算符，则它还可以包含<code class="codeph">UNION</code> <code class="codeph">ALL</code>标记。<code class="codeph">UNION</code> <code class="codeph">ALL</code>标记用于标识物化视图中每一行的<code class="codeph">UNION</code> <code class="codeph">ALL</code>选择源。查询重写可以使用标记来区分来自物化视图的哪些行属于某个<code class="codeph">UNION</code> <code class="codeph">ALL</code>选择。如果查询仅需要来自物化视图的数据的子集，或者查询的子选择与物化视图的子选择在文本上不匹配，则此选项非常有用。例如，以下查询检索来自旧金山的男性客户和来自洛杉矶的女性客户的邮政编码：</p><pre class="oac_no_warn" dir="ltr">SELECT c.cust_city，c.cust_postal_code FROM customers c WHERE c.cust_gender ='M'和c.cust_city ='San Francisco'UNION ALL SELECT c.cust_city，c.cust_postal_code FROM customers c WHERE c.cust_gender ='F'and c.cust_city ='洛杉矶';</pre><p>可以使用以下物化视图回答查询：</p><pre class="oac_no_warn" dir="ltr">CREATE MATERIALIZED VIEW cust_postal_mv ENABLE QUERY REWRITE AS SELECT 1 AS marker，c.cust_gender，c.cust_city，c.cust_postal_code FROM customers c WHERE c.cust_city ='洛杉矶'UNION ALL SELECT 2 AS marker，c.cust_gender，c.cust_city ，c.cust_postal_code来自客户c WHERE c.cust_city ='旧金山';</pre><p>重写的查询如下：</p><pre class="oac_no_warn" dir="ltr">SELECT mv.cust_city，mv.cust_postal_code FROM cust_postal_mv mv WHERE mv.marker = 2 AND mv.cust_gender ='M'UNION ALL SELECT mv.cust_city，mv.cust_postal_code FROM cust_postal_mv mv WHERE mv.marker = 1 AND mv.cust_gender =' F';</pre><p>第一<code class="codeph">mv.marker = 2</code>选择的<code class="codeph">WHERE</code>子句包括<code class="codeph">mv.marker = 2</code>和<code class="codeph">mv.cust_gender = 'M'</code> ，它仅选择在<code class="codeph">UNION</code> <code class="codeph">ALL</code>的第二<code class="codeph">mv.cust_gender = 'M'</code>选择中表示男性客户的行。第二<code class="codeph">mv.marker = 1</code>选择的<code class="codeph">WHERE</code>子句包括<code class="codeph">mv.marker = 1</code>和<code class="codeph">mv.cust_gender = 'F'</code> ，它仅选择在<code class="codeph">UNION</code> <code class="codeph">ALL</code>的第一<code class="codeph">mv.cust_gender = 'F'</code>选择中代表女性客户的那些行。请注意，查询重写不能利用删除重复行或不同行的集合运算符。例如， <code class="codeph">UNION</code>删除重复项，因此查询重写无法分辨哪些行已被删除，如下所示：</p><pre class="oac_no_warn" dir="ltr">SELECT c.cust_city，c.cust_postal_code FROM customers c WHERE c.cust_city ='Palmdale'AND c.cust_gender ='M'SELECT c.cust_city，c.cust_postal_code FROM customers c WHERE c.cust_gender ='M'and c.cust_city ='旧金山'UNION ALL SELECT c.cust_city，c.cust_postal_code FROM customers c WHERE c.cust_gender ='F'和c.cust_city ='洛杉矶';</pre><p>使用<code class="codeph">UNION</code> <code class="codeph">ALL</code>标记的重写查询如下：</p><pre class="oac_no_warn" dir="ltr">SELECT c.cust_city，c.cust_postal_code FROM customers c WHERE c.cust_city ='Palmdale'AND c.cust_gender ='M'UNION ALL SELECT mv.cust_city，mv.cust_postal_code FROM cust_postal_mv mv WHERE mv.marker = 2 AND mv.cust_gender ='M'UNION ALL SELECT mv.cust_city，mv.cust_postal_code FROM cust_postal_mv mv WHERE mv.marker = 1 AND mv.cust_gender ='F';</pre><p>使用标记的规则是它必须：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>是一个常数或字符串，并且是所有<code class="codeph">UNION ALL</code>选择的相同数据类型。
                              </p>
                           </li>
                           <li>
                              <p>为每个<code class="codeph">UNION ALL</code>选择产生一个恒定的，不同的值。您不能在多个子选择中重复使用相同的值。
                              </p>
                           </li>
                           <li>
                              <p>对于所有子选择处于相同的顺序位置。</p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="DWHSG08038"></a><div class="props_rev_3"><a id="GUID-FF240F3F-2EF8-4D46-8FAE-2B6C57FBA749" name="GUID-FF240F3F-2EF8-4D46-8FAE-2B6C57FBA749"></a><h4 id="DWHSG-GUID-FF240F3F-2EF8-4D46-8FAE-2B6C57FBA749" class="sect4"><span class="enumeration_section">12.3.9</span>关于在分组集存在的情况下重写查询</h4>
                  <div>
                     <p>本节讨论将查询重写与分组集一起使用的以下注意事项：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="advanced-query-rewrite-materialized-views.html#GUID-9CBC8423-7D9C-4368-92F3-913C5700E1D3">关于使用GROUP BY Extensions时的查询重写</a></p>
                        </li>
                        <li>
                           <p><a href="advanced-query-rewrite-materialized-views.html#GUID-05CFC633-105D-45AB-97A0-805AEC29BFFF">使用扩展GROUP BY重写查询的提示</a></p>
                        </li>
                     </ul>
                  </div><a id="DWHSG8550"></a><div class="props_rev_3"><a id="GUID-9CBC8423-7D9C-4368-92F3-913C5700E1D3" name="GUID-9CBC8423-7D9C-4368-92F3-913C5700E1D3"></a><h5 id="DWHSG-GUID-9CBC8423-7D9C-4368-92F3-913C5700E1D3" class="sect5"><span class="enumeration_section">12.3.9.1</span>关于使用GROUP BY Extensions时的查询重写</h5>
                     <div>
                        <p>一些<a id="d44607e4694" class="indexterm-anchor"></a>可以使用<code class="codeph">GROUPING</code> <code class="codeph">SETS</code> ， <code class="codeph">CUBE, ROLLUP</code>及其串联形式的<code class="codeph">GROUP</code> <code class="codeph">BY</code>子句的扩展。这些扩展使您能够在查询的<code class="codeph">GROUP</code> <code class="codeph">BY</code>子句中有选择地指定感兴趣的分组。例如，以下是具有分组集的典型查询：</p><pre class="oac_no_warn" dir="ltr">SELECT p.prod_subcategory，t.calendar_month_desc，c.cust_city，SUM（s.amount_sold）AS sum_amount_sold FROM sales s，customers c，products p，times t WHERE s.time_id = t.time_id AND s.prod_id = p.prod_id AND s.cust_id = c.cust_id GROUP BY GROUPING SETS（（p.prod_subcategory，t.calendar_month_desc），（c.cust_city，p.prod_subcategory））;</pre><p>具有<code class="codeph">GROUP</code> <code class="codeph">BY</code>扩展的查询的术语<span class="bold">基本</span> <span class="bold">分组</span>表示<code class="codeph">GROUP</code> <code class="codeph">BY</code>子句中存在的所有唯一表达式。在上一个查询中，以下分组（ <code class="codeph">p.prod_subcategory, t.calendar_month_desc, c.cust_city</code> ）是基本分组。
                        </p>
                        <p>扩展可以存在于用户查询和定义物化视图的查询中。在这两种情况下，都应用了物化视图重写，您可以将重写功能区分为以下场景：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="advanced-query-rewrite-materialized-views.html#GUID-169C564C-2F46-4A30-861A-CEFC4264C919">Materialized View具有简单的GROUP BY，Query具有扩展的GROUP BY</a></p>
                           </li>
                           <li>
                              <p><a href="advanced-query-rewrite-materialized-views.html#GUID-E57F62F2-0F5B-4CD6-AA92-28EA67690850">物化视图具有扩展GROUP BY，Query具有简单GROUP BY</a></p>
                           </li>
                           <li>
                              <p><a href="advanced-query-rewrite-materialized-views.html#GUID-5826A5DA-3EC3-4DA6-929C-BB65704BEB19">物化视图和查询都具有扩展的GROUP BY</a></p>
                           </li>
                        </ul>
                     </div><a id="DWHSG8551"></a><div class="props_rev_3"><a id="GUID-169C564C-2F46-4A30-861A-CEFC4264C919" name="GUID-169C564C-2F46-4A30-861A-CEFC4264C919"></a><h6 id="DWHSG-GUID-169C564C-2F46-4A30-861A-CEFC4264C919" class="sect6"><span class="enumeration_section">12.3.9.1.1</span>物化视图具有简单GROUP BY，查询具有扩展GROUP BY</h6>
                        <div>
                           <p>当查询包含扩展的<code class="codeph">GROUP</code> <code class="codeph">BY</code>子句时，如果可以使用<span class="q">“ <a href="basic-query-rewrite-materialized-views.html#GUID-63B491A0-A479-4711-A5B0-40365904115F">Oracle何时重写查询</a> ”中所述的重写规则中列出的实例化视图重写其基本分组，则可以使用实例化视图对其进行重写<span class="q"><a href="basic-query-rewrite-materialized-views.html#GUID-63B491A0-A479-4711-A5B0-40365904115F">。</a>“</span> 。例如，在以下查询中：</p><pre class="oac_no_warn" dir="ltr">SELECT p.prod_subcategory，t.calendar_month_desc，c.cust_city，SUM（s.amount_sold）AS sum_amount_sold FROM sales s，customers c，products p，times t WHERE s.time_id = t.time_id AND s.prod_id = p.prod_id AND s.cust_id = c.cust_id GROUP BY GROUPING SETS（（p.prod_subcategory，t.calendar_month_desc），（c.cust_city，p.prod_subcategory））;</pre><p>基本分组是<code class="codeph">(p.prod_subcategory, t.calendar_month_desc, c.cust_city, p.prod_subcategory))</code> ，因此，Oracle可以使用<code class="codeph">sum_sales_pscat_month_city_mv</code>重写查询，如下所示：</p><pre class="oac_no_warn" dir="ltr">SELECT mv.prod_subcategory，mv.calendar_month_desc，mv.cust_city，SUM（mv.sum_amount_sold）AS sum_amount_sold FROM sum_sales_pscat_month_city_mv mv GROUP BY GROUPING SETS（（mv.prod_subcategory，mv.calendar_month_desc），（mv.cust_city，mv.prod_subcategory））;</pre><p>如果查询使用<code class="codeph">EXPAND_GSET_TO_UNION</code>提示， <code class="codeph">EXPAND_GSET_TO_UNION</code>出现特殊情况。有关使用<code class="codeph">EXPAND_GSET_TO_UNION</code>的示例，请参阅<span class="q">“ <a href="advanced-query-rewrite-materialized-views.html#GUID-05CFC633-105D-45AB-97A0-805AEC29BFFF">使用扩展GROUP BY重写查询的提示</a> ”</span> 。</p>
                        </div>
                     </div><a id="DWHSG8552"></a><div class="props_rev_3"><a id="GUID-E57F62F2-0F5B-4CD6-AA92-28EA67690850" name="GUID-E57F62F2-0F5B-4CD6-AA92-28EA67690850"></a><h6 id="DWHSG-GUID-E57F62F2-0F5B-4CD6-AA92-28EA67690850" class="sect6"><span class="enumeration_section">12.3.9.1.2</span>物化视图具有扩展GROUP BY，Query具有简单GROUP BY</h6>
                        <div>
                           <p>为了使用扩展<code class="codeph">GROUP</code> <code class="codeph">BY</code>的物化视图进行重写，它必须满足两个附加条件：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>它必须包含分组标识符，它是所有<code class="codeph">GROUP</code> <code class="codeph">BY</code>表达式上的<code class="codeph">GROUPING_ID</code>函数。例如，如果物化视图的<code class="codeph">GROUP</code> <code class="codeph">BY</code>子句是<code class="codeph">GROUP</code> <code class="codeph">BY</code> <code class="codeph">CUBE(a, b)</code> ，则<code class="codeph">SELECT</code>列表应包含<code class="codeph">GROUPING_ID(a, b)</code> 。
                                 </p>
                              </li>
                              <li>
                                 <p>物化视图的<code class="codeph">GROUP</code> <code class="codeph">BY</code>子句不应导致任何重复分组。例如， <code class="codeph">GROUP</code> <code class="codeph">BY</code> <code class="codeph">GROUPING</code> <code class="codeph">SETS</code> <code class="codeph">((a, b),</code> <code class="codeph">(a, b))</code>将取消物化视图与一般重写的资格。
                                 </p>
                              </li>
                           </ul>
                           <p>具有扩展<code class="codeph">GROUP</code> <code class="codeph">BY</code>物化视图包含多个分组。Oracle发现具有最低成本的分组，可以从中计算查询并将其用于重写。例如，请考虑以下物化视图：</p><pre class="oac_no_warn" dir="ltr">CREATE MATERIALIZED VIEW sum_grouping_set_mv ENABLE QUERY REWRITE AS SELECT p.prod_category，p.prod_subcategory，c.cust_state_province，c.cust_city，GROUPING_ID（p.prod_category，p.prod_subcategory，c.cust_state_province，c.cust_city）AS gid，SUM（s。 amount_sold）AS sum_amount_sold FROM sales s，products p，customers c WHERE s.prod_id = p.prod_id AND s.cust_id = c.cust_id GROUP BY GROUPING SETS（（p.prod_category，p.prod_subcategory，c.cust_city），（p .prod_category，p.prod_subcategory，c.cust_state_province，c.cust_city），（p.prod_category，p.prod_subcategory））;</pre><p>在这种情况下，将重写以下查询：</p><pre class="oac_no_warn" dir="ltr">SELECT p.prod_subcategory，c.cust_city，SUM（s.amount_sold）AS sum_amount_sold FROM sales s，products p，customers c WHERE s.prod_id = p.prod_id AND s.cust_id = c.cust_id GROUP BY p.prod_subcategory，c。 cust_city;</pre><p>使用物化视图中最接近的匹配分组重写此查询。也就是说， <code class="codeph">(prod_category, prod_subcategory, cust_city)</code>分组：</p><pre class="oac_no_warn" dir="ltr">SELECT prod_subcategory，cust_city，SUM（sum_amount_sold）AS sum_amount_sold FROM sum_grouping_set_mv WHERE gid = <span class="italic">分组标识符（prod_category，prod_subcategory，cust_city）</span> GROUP BY prod_subcategory，cust_city;</pre></div>
                     </div><a id="DWHSG8553"></a><div class="props_rev_3"><a id="GUID-5826A5DA-3EC3-4DA6-929C-BB65704BEB19" name="GUID-5826A5DA-3EC3-4DA6-929C-BB65704BEB19"></a><h6 id="DWHSG-GUID-5826A5DA-3EC3-4DA6-929C-BB65704BEB19" class="sect6"><span class="enumeration_section">12.3.9.1.3</span>物化视图和查询都具有扩展GROUP BY</h6>
                        <div>
                           <p>当物化视图和查询都包含<code class="codeph">GROUP</code> <code class="codeph">BY</code>扩展时，Oracle使用两种重写策略：分组匹配和<code class="codeph">UNION</code> <code class="codeph">ALL</code>重写。首先，Oracle尝试分组匹配。查询中的分组与实例化视图中的分组进行匹配，如果所有分组都没有汇总，Oracle将从物化视图中选择它们。例如，请考虑以下查询：</p><pre class="oac_no_warn" dir="ltr">SELECT p.prod_category，p.prod_subcategory，c.cust_city，SUM（s.amount_sold）AS sum_amount_sold FROM sales s，products p，customers c WHERE s.prod_id = p.prod_id AND s.cust_id = c.cust_id GROUP BY GROUPING SETS （（p.prod_category，p.prod_subcategory，c.cust_city），（p.prod_category，p.prod_subcategory））;</pre><p>此查询匹配<code class="codeph">sum_grouping_set_mv</code>中的两个分组，Oracle <code class="codeph">sum_grouping_set_mv</code>查询重写为以下内容：</p><pre class="oac_no_warn" dir="ltr">SELECT prod_subcategory，cust_city，sum_amount_sold FROM sum_grouping_set_mv WHERE gid = <span class="italic">分组标识符（prod_category，prod_subcategory，cust_city）</span>或gid = <span class="italic">分组标识符（prod_category，prod_subcategory）</span>
</pre><p>如果分组匹配失败，Oracle会尝试一种名为<code class="codeph">UNION</code> <code class="codeph">ALL</code>重写的通用重写机制。Oracle首先使用扩展<code class="codeph">GROUP</code> <code class="codeph">BY</code>子句将查询表示为等效的<code class="codeph">UNION</code> <code class="codeph">ALL</code>查询。原始查询的每个分组都放在单独的<code class="codeph">UNION</code> <code class="codeph">ALL</code>分支中。分支将有一个简单的<code class="codeph">GROUP</code> <code class="codeph">BY</code>子句。例如，考虑以下查询：</p><pre class="oac_no_warn" dir="ltr">SELECT p.prod_category，p.prod_subcategory，c.cust_state_province，t.calendar_month_desc，SUM（s.amount_sold）AS sum_amount_sold FROM sales s，products p，customers c，times t WHERE s.prod_id = p.prod_id AND s.cust_id = c.cust_id GROUP BY GROUPING SETS（（p.prod_subcategory，t.calendar_month_desc），（t.calendar_month_desc），（p.prod_category，p.prod_subcategory，c.cust_state_province），（p.prod_category，p.prod_subcategory））;</pre><p>这首先表示为<code class="codeph">UNION</code> <code class="codeph">ALL</code>有四个分支：</p><pre class="oac_no_warn" dir="ltr">SELECT null，p.prod_subcategory，null，t.calendar_month_desc，SUM（s.amount_sold）AS sum_amount_sold FROM sales s，products p，customers c，times t WHERE s.prod_id = p.prod_id AND s.cust_id = c.cust_id GROUP BY p.prod_subcategory，t.calendar_month_desc UNION ALL SELECT null，null，null，t.calendar_month_desc，SUM（s.amount_sold）AS sum_amount_sold FROM sales s，products p，customers c，times t WHERE s.prod_id = p.prod_id AND s.cust_id = c.cust_id GROUP BY t.calendar_month_desc UNION ALL SELECT p.prod_category，p.prod_subcategory，c.cust_state_province，null，SUM（s.amount_sold）AS sum_amount_sold FROM sales s，products p，customers c，times t WHERE s.prod_id = p.prod_id AND s.cust_id = c.cust_id GROUP BY p.prod_category，p.prod_subcategory，c.cust_state_province UNION ALL SELECT p.prod_category，p.prod_subcategory，null，null，SUM（s.amount_sold）AS sum_amount_sold FROM sales s，products p，customers c，times t WHERE s.prod_id = p.prod_id AND s.cust_id = c.cust_id GROUP BY p.prod_category， p.prod_subcategory;</pre><p>然后使用<span class="q">“ <a href="basic-query-rewrite-materialized-views.html#GUID-63B491A0-A479-4711-A5B0-40365904115F">Oracle何时重写查询？</a> ”中的规则分别重写每个分支<span class="q"><a href="basic-query-rewrite-materialized-views.html#GUID-63B491A0-A479-4711-A5B0-40365904115F">？</a>“</span> 。使用物化视图<code class="codeph">sum_grouping_set_mv</code> ，Oracle只能重写第三个分支（需要物化视图汇总）和四个（完全匹配物化视图）。unrewritten分支将转换回扩展的<code class="codeph">GROUP</code> <code class="codeph">BY</code>表单。因此，最终，查询被重写为：</p><pre class="oac_no_warn" dir="ltr">SELECT null，p.prod_subcategory，null，t.calendar_month_desc，SUM（s.amount_sold）AS sum_amount_sold FROM sales s，products p，customers c，times t WHERE s.prod_id = p.prod_id AND s.cust_id = c.cust_id GROUP BY GROUPING SETS（（p.prod_subcategory，t.calendar_month_desc），（t.calendar_month_desc），）UNION ALL SELECT prod_category，prod_subcategory，cust_state_province，null，SUM（sum_amount_sold）AS sum_amount_sold FROM sum_grouping_set_mv WHERE gid = &lt;grouping id of（prod_category， prod_subcategory，cust_city）&gt; GROUP BY p.prod_category，p.prod_subcategory，c.cust_state_province UNION ALL SELECT prod_category，prod_subcategory，null，null，sum_amount_sold FROM sum_grouping_set_mv WHERE gid = &lt;grouping id of（prod_category，prod_subcategory）&gt;</pre><p>请注意，具有扩展<code class="codeph">GROUP</code> <code class="codeph">BY</code>的查询表示为等效的<code class="codeph">UNION</code> <code class="codeph">ALL</code>并递归提交以进行重写优化。无法重写的分组保留在<code class="codeph">UNION</code> <code class="codeph">ALL</code>的最后一个分支中，而是访问基础数据。
                           </p>
                        </div>
                     </div>
                  </div><a id="DWHSG8554"></a><div class="props_rev_3"><a id="GUID-05CFC633-105D-45AB-97A0-805AEC29BFFF" name="GUID-05CFC633-105D-45AB-97A0-805AEC29BFFF"></a><h5 id="DWHSG-GUID-05CFC633-105D-45AB-97A0-805AEC29BFFF" class="sect5"><span class="enumeration_section">12.3.9.2</span>使用扩展GROUP BY重写查询的提示</h5>
                     <div>
                        <p>您可以<a id="d44607e5093" class="indexterm-anchor"></a><a id="d44607e5097" class="indexterm-anchor"></a>使用<code class="codeph">EXPAND_GSET_TO_UNION</code>提示强制将<code class="codeph">GROUP</code> <code class="codeph">BY</code>扩展的查询扩展为等效的<code class="codeph">UNION</code> <code class="codeph">ALL</code>查询。此提示可用于物化视图仅具有简单<code class="codeph">GROUP</code> <code class="codeph">BY</code>子句的环境中。在这种情况下，Oracle扩展了重写的灵活性，因为每个分支都可以由单独的物化视图独立重写。
                        </p>
                     </div>
                  </div>
               </div><a id="DWHSG08039"></a><div class="props_rev_3"><a id="GUID-1BA3AB83-5155-47A5-90DA-1D8AEA8E8CC6" name="GUID-1BA3AB83-5155-47A5-90DA-1D8AEA8E8CC6"></a><h4 id="DWHSG-GUID-1BA3AB83-5155-47A5-90DA-1D8AEA8E8CC6" class="sect4"><span class="enumeration_section">12.3.10</span>窗口函数存在时的查询重写</h4>
                  <div>
                     <p>窗口函数用于计算累积，移动和居中聚合。这些函数使用以下聚合： <code class="codeph">SUM</code> ， <code class="codeph">AVG</code> ， <code class="codeph">MIN</code> / <code class="codeph">MAX</code> 。， <code class="codeph">COUNT</code> ， <code class="codeph">VARIANCE</code> ， <code class="codeph">STDDEV</code> ， <code class="codeph">FIRST_VALUE</code>和<code class="codeph">LAST_VALUE</code> 。可以使用精确文本匹配重写来重写具有窗口函数的查询。这要求物化视图定义也与查询完全匹配。当物化视图上没有窗口函数时，如果在物化视图中找到查询中的聚合并且所有其他资格检查（例如连接可计算性检查）成功，则可以重写具有窗口函数的查询。使用规范格式将查询上的窗口函数与物化视图中的窗口函数进行比较。这使得查询重写能够重写甚至复杂的窗口函数。
                     </p>
                     <p>当具有窗口函数的查询在查询重写期间需要汇总时，查询重写将尽可能将查询拆分为具有聚合的内部查询和具有窗口函数的外部查询。这允许查询重写在应用窗口函数之前重写内部查询中的聚合。一个例外是查询同时具有窗口功能和分组集。在这种情况下，分组集的存在可防止查询重写分割查询，因此在这种情况下不会发生查询重写。</p>
                  </div>
               </div><a id="DWHSG08040"></a><div class="props_rev_3"><a id="GUID-E0B7B0AB-6D13-4AA4-BFCE-119B5834AAAF" name="GUID-E0B7B0AB-6D13-4AA4-BFCE-119B5834AAAF"></a><h4 id="DWHSG-GUID-E0B7B0AB-6D13-4AA4-BFCE-119B5834AAAF" class="sect4"><span class="enumeration_section">12.3.11</span>查询重写和表达式匹配</h4>
                  <div>
                     <p><a id="d44607e5195" class="indexterm-anchor"></a><a id="d44607e5199" class="indexterm-anchor"></a>如果物化视图列表示与查询中的表达式匹配的预计算表达式，则查询中显示的表达式可以替换为实例化视图中的简单列。如果可以重写查询以使用实体化视图，则会更快。这是因为物化视图包含预先计算的计算，不需要执行表达式计算。
                     </p>
                     <p>表达式匹配是通过首先将表达式转换为规范形式然后将它们进行相等性来完成的。因此，只要它们彼此等同，通常将匹配两个不同的表达。此外，如果查询中的整个表达式无法与实例化视图中的表达式匹配，则尝试使用它的子表达式来查找匹配项。子表达式以自上而下的顺序尝试以获得最大表达式匹配。</p>
                     <p>考虑一个询问按年龄段（1-10,11-20,21-30等）的销售总额的查询。</p><pre class="oac_no_warn" dir="ltr">CREATE MATERIALIZED VIEW sales_by_age_bracket_mv ENABLE QUERY REWRITE AS SELECT TO_CHAR（（2000-c.cust_year_of_birth）/10-0.5,999）AS age_bracket，SUM（s.amount_sold）AS sum_amount_sold FROM sales s，customers c WHERE s.cust_id = c.cust_id GROUP BY TO_CHAR（（2000-c.cust_year_of_birth）/10-0.5,999）;</pre><p>使用表达式匹配重写以下查询：</p><pre class="oac_no_warn" dir="ltr">SELECT TO_CHAR（（（2000-c.cust_year_of_birth）/ 10）-0.5,999），SUM（s.amount_sold）FROM sales s，customers c WHERE s.cust_id = c.cust_id GROUP BY TO_CHAR（（2000-c.cust_year_of_birth） ）/10-0.5,999）;</pre><p>该查询根据<code class="codeph">sales_by_age_bracket_mv</code>重写，基于年龄段表达式的规范形式（即2000- <code class="codeph">c.cust_year_of_birth</code> ）/10-0.5）的匹配，如下所示：</p><pre class="oac_no_warn" dir="ltr">SELECT age_bracket，sum_amount_sold FROM sales_by_age_bracket_mv;</pre></div><a id="DWHSG8555"></a><div class="props_rev_3"><a id="GUID-8906324F-1EAD-4F1B-B506-4824AE0F3E4B" name="GUID-8906324F-1EAD-4F1B-B506-4824AE0F3E4B"></a><h5 id="DWHSG-GUID-8906324F-1EAD-4F1B-B506-4824AE0F3E4B" class="sect5"><span class="enumeration_section">12.3.11.1</span>使用部分过时的物化视图重写查询</h5>
                     <div>
                        <p>更新详细信息表的分区后，只有物化视图的特定部分标记为过时。物化视图必须具有可以识别与物化视图的特定行或组对应的表的分区的信息。最简单的方案是表的分区键在物化视图的<code class="codeph">SELECT</code>列表中可用，因为这是将行映射到过时分区的最简单方法。使用部分过时的物化视图时的关键点是：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>如果已知用于回答查询的物化视图中的行是<code class="codeph">FRESH</code>查询重写可以在<code class="codeph">ENFORCED</code>或<code class="codeph">TRUSTED</code>模式下使用物化视图。</p>
                           </li>
                           <li>
                              <p>物化视图中的新行通过将选择谓词添加到物化视图的<code class="codeph">WHERE</code>子句来标识。如果查询的答案包含在此（受限制的）物化视图中，则Oracle会使用此物化视图重写查询。
                              </p>
                           </li>
                        </ul>
                        <p>事实表<code class="codeph">sales</code>根据<code class="codeph">time_id</code>范围进行<code class="codeph">time_id</code> ，如下所示：</p><pre class="oac_no_warn" dir="ltr">按比例分区（time_id）（PARTITION SALES_Q1_1998价值低于（截至_（01-APR-1998'，'DD-MON-YYYY'）），PARTITION SALES_Q2_1998价值低于（截止日期（'01 -JUL-1998'，'） DD-MON-YYYY'）），PARTITION SALES_Q3_1998价值不到（截止日期（'01 -OCT-1998'，'DD-MON-YYYY'）），......
</pre><p>假设您有按<code class="codeph">time_id</code>分组的物化视图，如下所示：</p><pre class="oac_no_warn" dir="ltr">CREATE MATERIALIZED VIEW sum_sales_per_city_mv ENABLE QUERY REWRITE AS SELECT s.time_id，p.prod_subcategory，c.cust_city，SUM（s.amount_sold）AS sum_amount_sold FROM sales s，products p，customers c WHERE s.cust_id = c.cust_id AND s.prod_id = p.prod_id GROUP BY time_id，prod_subcategory，cust_city;</pre><p>还假设将在2000年12月插入新数据，这些数据将分配给分区<code class="codeph">sales_q4_2000</code> 。出于测试目的，您可以对<code class="codeph">sales</code>应用任意DML操作，更改与<code class="codeph">sales_q1_2000</code>不同的分区，因为当此物化视图为新的时，以下查询请求此分区中的数据。例如，以下内容：</p><pre class="oac_no_warn" dir="ltr">插入销售价值（17,10，'01 -DEC-2000'，4,380,123.45,54321）;</pre><p>在完成刷新之前，物化视图通常是陈旧的，不能在强制模式下无限制地重写。但是，由于表<code class="codeph">sales</code>已分区，并且并非所有分区都已修改，因此Oracle可以识别尚未触及的所有分区。优化程序可以通过将选择谓词隐式添加到物化视图定义查询来识别物化视图中的新行（自上次刷新操作以来不受更新影响的数据），如下所示：</p><pre class="oac_no_warn" dir="ltr">SELECT s.time_id，p.prod_subcategory，c.cust_city，SUM（s.amount_sold）AS sum_amount_sold FROM sales s，products p，customers c WHERE s.cust_id = c.cust_id AND s.prod_id = p.prod_id AND s.time_id &lt;TO_DATE（'01 -OCT-2000'，'DD-MON-YYYY'）或s.time_id&gt; = TO_DATE（'01 -OCT-2001'，'DD-MON-YYYY'））GROUP BY time_id，prod_subcategory， cust_city;</pre><p>请注意，部分过时的物化视图的新鲜度是在每个分区基础上跟踪的，而不是在逻辑基础上。由于<code class="codeph">sales</code>事实表的分区策略是按季度进行的，因此2000年12月的更改会导致整个分区<code class="codeph">sales_q4_2000</code>变得陈旧。
                        </p>
                        <p>请考虑以下查询，该查询要求在2000年第1季度和第2季度进行销售：</p><pre class="oac_no_warn" dir="ltr">SELECT s.time_id，p.prod_subcategory，c.cust_city，SUM（s.amount_sold）AS sum_amount_sold FROM sales s，products p，customers c WHERE s.cust_id = c.cust_id AND s.prod_id = p.prod_id AND s.time_id在TO_DATE（'01 -JAN-2000'，'DD-MON-YYYY'）和TO_DATE（'01 -JUL-2000'，'DD-MON-YYYY'）GROUP BY time_id，prod_subcategory，cust_city;</pre><p>Oracle数据库知道物化视图中的那些行范围是新鲜的，因此可以使用物化视图重写查询。重写的查询如下所示：</p><pre class="oac_no_warn" dir="ltr">SELECT time_id，prod_subcategory，cust_city，sum_amount_sold FROM sum_sales_per_city_mv WHERE time_id BETWEEN TO_DATE（'01 -JAN-2000'，'DD-MON-YYYY'）和TO_DATE（'01 -JUL-2000'，'DD-MON-YYYY'） ;</pre><p>而不是分区键，分区标记（标识给定rowid的分区的函数）可以存在于物化视图的<code class="codeph">SELECT</code> （和<code class="codeph">GROUP</code> <code class="codeph">BY</code>列表）中。您可以使用物化视图重写仅需要来自某些分区（可通过分区标记识别）的数据的查询，例如，具有指定包含整个分区的分区键范围的谓词的查询。有关提供的分区标记功能<code class="codeph">DBMS_MVIEW.PMARKER</code>详细信息，请参阅<a href="advanced-materialized-views.html#GUID-F7394DFE-7CF6-401C-A312-C36603BEB01B" title="不支持在分析视图或层次结构的查询上创建物化视图。即使物化视图标记为陈旧，实时物化视图也会为用户查询提供新数据。实时物化视图是一种物化视图，即使物化视图由于数据更改而与其基表不同步，也可为用户查询提供新数据。使用实时物化视图受到某些限制。与物化视图一样，存在多种方法来访问存储在实时物化视图中的数据。要创建实时物化视图，请使用CREATE MATERIALIZED VIEW语句中的ON QUERY COMPUTATION子句。如果满足实时物化视图的先决条件，则可以通过更改其定义并启用查询计算，将现有物化视图转换为实时物化视图。对于重写用户查询以使用实时物化视图的查询重写机制，必须为实时物化视图启用查询重写。如果为实时物化视图启用了查询重写，则查询重写可以使用实时物化视图向用户查询提供结果，即使实时物化视图是陈旧的。只有当所有基本实时物化视图都是新鲜的时，嵌套的实时物化视图才有资格进行查询重写。您可以通过在查询中引用实时物化视图的名称来直接访问实时物化视图。数据字典视图中的ON_QUERY_COMPUTATION列ALL_MVIEWS，DBA_MVIEWS和USER_MVIEWS指示实例化视图是否是实时物化视图。要为使用实时物化视图的用户查询获得更好的性能，您可以遵循某些准则。">高级实体化视图</a> 。</p>
                        <p>以下示例说明了在物化视图中使用分区标记而不是直接使用分区键列：</p><pre class="oac_no_warn" dir="ltr">CREATE MATERIALIZED VIEW sum_sales_per_city_2_mv ENABLE QUERY REWRITE AS SELECT DBMS_MVIEW.PMARKER（s.rowid）AS pmarker，t.fiscal_quarter_desc，p.prod_subcategory，c.cust_city，SUM（s.amount_sold）AS sum_amount_sold FROM sales s，products p，customers c， times t WHERE s.cust_id = c.cust_id AND s.prod_id = p.prod_id AND s.time_id = t.time_id GROUP BY DBMS_MVIEW.PMARKER（s.rowid），p.prod_subcategory，c.cust_city，t.fiscal_quarter_desc;</pre><p>假设您知道分区<code class="codeph">sales_q1_2000</code>是新鲜的，并且对<code class="codeph">sales</code>表的其他分区进行了DML更改。出于测试目的，您可以对<code class="codeph">sales</code>应用任意DML操作，在物化视图为新的时更改与<code class="codeph">sales_q1_2000</code>不同的分区。一个例子如下：</p><pre class="oac_no_warn" dir="ltr">插入销售价值（17,10，'01 -DEC-2000'，4,380,123.45,54321）;</pre><p>虽然物化视图<code class="codeph">sum_sales_per_city_2_mv</code>现在通常被认为是陈旧的，但Oracle数据库可以使用此物化视图重写以下查询。此查询将数据限制为分区<code class="codeph">sales_q1_2000</code> ，并仅选择<code class="codeph">cust_city</code>某些值，如下所示：</p><pre class="oac_no_warn" dir="ltr">SELECT p.prod_subcategory，c.cust_city，SUM（s.amount_sold）AS sum_amount_sold FROM sales s，products p，customers c，times t WHERE s.cust_id = c.cust_id AND s.prod_id = p.prod_id AND s.time_id = t.time_id AND c.cust_city ='纽伦堡'和s.time_id&gt; = TO_DATE（'01 -JAN-2000'，'dd-mon-yyyy'）AND s.time_id &lt;TO_DATE（'01 -APR-2000'， 'dd-mon-yyyy'）GROUP BY prod_subcategory，cust_city;</pre><p>请注意，只有在访问一个或多个分区的完整数据内容并且谓词条件位于分区事实表本身时，才能使用包含<code class="codeph">PMARKER</code>函数的部分过时的物化视图进行重写，如前面的示例所示。
                        </p>
                        <p><code class="codeph">DBMS_MVIEW.PMARKER</code>函数为每个分区提供了一个不同的值。与分区键本身相比，这大大减少了潜在物化视图中的行数，但您也放弃了有关此键的任何详细信息。您知道的唯一信息是分区号，因此是下边界值和上边界值。这是减少范围分区列的基数以及因此减少行数的权衡。
                        </p>
                        <p>假设的值<code class="codeph">p_marker</code>为分区<code class="codeph">sales_q1_2000</code>是31070，前面示出的查询可以针对物化视图被重写如下：</p><pre class="oac_no_warn" dir="ltr">SELECT mv.prod_subcategory，mv.cust_city，SUM（mv.sum_amount_sold）FROM sum_sales_per_city_2_mv mv WHERE mv.pmarker = 31070 AND mv.cust_city ='Nuernberg'GROUP BY prod_subcategory，cust_city;</pre><p>因此，可以针对实体化视图重写查询，而无需访问过时数据。</p>
                     </div>
                  </div>
               </div><a id="DWHSG08041"></a><div class="props_rev_3"><a id="GUID-5C3DD547-5E57-40CE-9AC9-770214718949" name="GUID-5C3DD547-5E57-40CE-9AC9-770214718949"></a><h4 id="DWHSG-GUID-5C3DD547-5E57-40CE-9AC9-770214718949" class="sect4"><span class="enumeration_section">12.3.12</span>查询重写期间的游标共享和绑定变量</h4>
                  <div>
                     <p>询问<a id="d44607e5446" class="indexterm-anchor"></a><a id="d44607e5450" class="indexterm-anchor"></a>只要在查询重写期间不需要实际绑定值，查询包含用户绑定变量时，支持重写。如果在查询重写期间需要绑定变量的实际值，则可以说查询重写依赖于绑定值。由于在查询重写时间内用户绑定变量不可用，如果查询重写依赖于绑定值，则无法重写查询。例如，请考虑以下物化视图<code class="codeph">customer_mv</code> ，它在<code class="codeph">WHERE</code>子句中具有谓词（ <code class="codeph">customer_id &gt;= 1000</code> ）：</p><pre class="oac_no_warn" dir="ltr">CREATE MATERIALIZED VIEW customer_mv ENABLE QUERY REWRITE AS SELECT cust_id，prod_id，SUM（amount_sold）AS total_amount FROM sales WHERE cust_id&gt; = 1000 GROUP BY cust_id，prod_id;</pre><p>请考虑以下查询，该查询在其<code class="codeph">WHERE</code>子句中具有用户绑定变量<code class="codeph">:user_id</code> ：</p><pre class="oac_no_warn" dir="ltr">SELECT cust_id，prod_id，SUM（amount_sold）AS sum_amount FROM sales WHERE cust_id&gt;：user_id GROUP BY cust_id，prod_id;</pre><p>由于物化视图<code class="codeph">customer_mv</code>在其<code class="codeph">WHERE</code>子句中有选择，因此查询重写依赖于用户绑定变量<code class="codeph">user_id</code>的实际值来计算包含。由于<code class="codeph">user_id</code>在查询重写时间不可用，并且查询重写依赖于<code class="codeph">user_id</code>的绑定值，因此无法重写此查询。
                     </p>
                     <p>尽管前面的示例在<code class="codeph">WHERE</code>子句中有一个用户绑定变量，但无论用户绑定变量在查询中出现的位置如何都是如此。换句话说，无论用户绑定变量在查询中出现的位置如何，如果查询重写依赖于其值，则无法重写查询。
                     </p>
                     <p>现在考虑以下在<code class="codeph">SELECT</code>列表中具有用户绑定变量<code class="codeph">:user_id</code>查询：</p><pre class="oac_no_warn" dir="ltr">SELECT cust_id +：user_id，prod_id，SUM（amount_sold）AS total_amount FROM sales WHERE cust_id&gt; = 2000 GROUP BY cust_id，prod_id;</pre><p>由于在查询重写时间内不需要用户绑定变量<code class="codeph">user_id</code>的值，因此前面的查询将重写。
                     </p><pre class="oac_no_warn" dir="ltr">SELECT cust_id +：user_id，prod_id，total_amount FROM customer_mv;</pre></div>
               </div><a id="DWHSG08042"></a><div class="props_rev_3"><a id="GUID-3FD90BE4-F577-4AB9-8762-2701C8B60193" name="GUID-3FD90BE4-F577-4AB9-8762-2701C8B60193"></a><h4 id="DWHSG-GUID-3FD90BE4-F577-4AB9-8762-2701C8B60193" class="sect4"><span class="enumeration_section">12.3.13</span>在查询重写中处理表达式</h4>
                  <div>
                     <p>与一些表达式重写时表达式计算为一个常数，例如也支持<code class="codeph">TO_DATE(</code> <code class="codeph">'</code> <code class="codeph">12-SEP-1999</code> <code class="codeph">'</code> <code class="codeph">,</code> <code class="codeph">'</code> <code class="codeph">DD-Mon-YYYY</code> <code class="codeph">'</code> <code class="codeph">)</code> 。例如，如果现有的物化视图定义为：</p><pre class="oac_no_warn" dir="ltr">CREATE MATERIALIZED VIEW sales_on_valentines_day_99_mv构建立即刷新强制启用QUERY REWRITE作为SELECT s.prod_id，s.cust_id，s.amount_sold FROM times t，sales s WHERE s.time_id = t.time_id AND t.time_id = TO_DATE（'14-FEB- 1999'，'DD-MON-YYYY'）;</pre><p>然后可以重写以下查询：</p><pre class="oac_no_warn" dir="ltr">SELECT s.prod_id，s.cust_id，s.amount_sold FROM sales s，times t WHERE s.time_id = t.time_id AND t.time_id = TO_DATE（'14-FEB-1999'，'DD-MON-YYYY'）;</pre><p>此查询将重写如下：</p><pre class="oac_no_warn" dir="ltr">SELECT * FROM sales_on_valentines_day_99_mv;</pre><p>每当使用<code class="codeph">TO_DATE</code> ，仅当提供的日期掩码与<code class="codeph">NLS_DATE_FORMAT</code>指定的日期掩码相同时，才会发生查询重写。</p>
                  </div>
               </div>
            </div><a id="DWHSG8556"></a><a id="DWHSG8557"></a><a id="DWHSG8558"></a><a id="DWHSG0804"></a><div class="props_rev_3"><a id="GUID-94D148DC-1E2A-4791-A7B6-28F9BF0306C1" name="GUID-94D148DC-1E2A-4791-A7B6-28F9BF0306C1"></a><h3 id="DWHSG-GUID-94D148DC-1E2A-4791-A7B6-28F9BF0306C1" class="sect3"><span class="enumeration_section">12.4</span>使用等价重写高级查询</h3>
               <div>
                  <div class="section">
                     <p>有<a id="d44607e5600" class="indexterm-anchor"></a><a id="d44607e5604" class="indexterm-anchor"></a>一种特殊类型的查询重写，可以声明两个SQL语句在功能上是等效的。此功能使您可以将应用程序内部知识放入数据库中，以便数据库可以利用此知识来提高查询性能。这样做是通过声明两个<code class="codeph">SELECT</code>语句在功能上等效（返回相同的行和列）并指示其中一个<code class="codeph">SELECT</code>语句更有利于性能。
                     </p>
                     <p>这种高级重写功能通常可以应用于各种查询性能问题和机会。任何应用程序都可以使用此功能来影响复杂用户查询的重写，这些查询可以通过专门创建的更简单，更高性能的查询来回答，通常由具有内部应用程序知识的人员进行。</p>
                     <p>在许多情况下，您可以拥有允许SQL语句转换和调优的内部应用程序知识，从而显着提高性能。您可能希望影响的优化类型可能非常简单，也可能与查询的重大重构一样复杂。但是，传入的SQL查询通常由应用程序生成，您无法控制应用程序生成的查询的形式和结构。</p>
                     <p>要获得对此功能的访问权限，您需要以<code class="codeph">SYSDBA</code>身份进行连接，并明确授予将要声明重写等效的所需数据库管理员的执行权限。有关更多信息，请参见<a href="../arpls/DBMS_ADVANCED_REWRITE.html#ARPLS083" target="_blank"><span class="italic">Oracle Database PL / SQL包和类型参考</span></a> 。
                     </p>
                     <p>为了说明这种类型的高级重写，提供了一些使用多维数据的示例。为了优化资源使用，应用程序可以使用复杂的SQL，自定义C代码或表函数来从数据库中检索数据。就最终用户而言，这种复杂性无关紧要。用户仍然希望使用<code class="codeph">SELECT</code>典型查询获得他们的答案...<code class="codeph">GROUP</code> <code class="codeph">BY</code> 。</p>
                  </div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-94D148DC-1E2A-4791-A7B6-28F9BF0306C1__GUID-4F830616-3710-4710-A833-69FB860C60EF">
                     <p class="titleinexample">例12-12使用等价重写</p>
                     <p>此示例向Oracle声明必须使用指定的备用查询执行给定的用户查询。Oracle会识别这种关系，每次用户询问查询时，它都会使用替代方法透明地重写它。因此，用户可以免于理解和编写用于复杂聚合计算的SQL的麻烦。</p>
                     <p>有两个基表<code class="codeph">sales_fact</code>和<code class="codeph">geog_dim</code> 。您可以通过发出以下语句计算每个城市，州和地区的累计销售额：</p><pre class="oac_no_warn" dir="ltr">SELECT g.region，g.state，g.city，GROUPING_ID（g.city，g.state，g.region），SUM（sales）FROM sales_fact f，geog_dim g WHERE f.geog_key = g.geog_key GROUP BY ROLLUP（ g.region，g.state，g.city）;</pre><p>应用程序可能希望实现此查询以获得快速结果。不幸的是，生成的物化视图占用了太多的磁盘空间。但是，如果您有一个维度将城市向州或地区汇总，则可以使用解码语句轻松地将三个分组列压缩为一列。（这也称为嵌入式总计）：</p><pre class="oac_no_warn" dir="ltr">DECODE（gid，0，city，1，state，3，region，7，“grand_total”）</pre><p>这样做是使用层次结构的最低级别来表示整个信息。例如，说<code class="codeph">Boston</code>意味着<code class="codeph">Boston, MA, New England Region</code>并且<code class="codeph">CA</code>表示<code class="codeph">CA, Western Region</code> 。应用程序可以将这些嵌入的总结果存储到表中，例如<code class="codeph">embedded_total_sales</code> 。
                     </p>
                     <p>但是，将结果返回给用户时，您可能希望拥有所有数据列（城市，州，地区）。为了高效快速地返回结果，应用程序可以使用自定义表函数（ <code class="codeph">et_function</code> ）从扩展形式的<code class="codeph">embedded_total_sales</code>表中检索数据，如下所示：</p><pre class="oac_no_warn" dir="ltr">SELECT * FROM TABLE（et_function）;</pre><p>换句话说，此功能允许应用程序声明用户的先前查询与备用查询的等效性，如下所示：</p><pre class="oac_no_warn" dir="ltr">DBMS_ADVANCED_REWRITE.DECLARE_REWRITE_EQUIVALENCE（'EMBEDDED_TOTAL'，'SELECT g.region，g.state，g.city，GROUPING_ID（g.city，g.state，g.region），SUM（sales）FROM sales_fact f，geog_dim g WHERE f。 geog_key = g.geog_key GROUP BY ROLLUP（g.region，g.state，g.city）'，'SELECT * FROM TABLE（et_function）'）;</pre><p><code class="codeph">DECLARE_REWRITE_EQUIVALENCE</code>这个调用创建了一个名为<code class="codeph">EMBEDDED_TOTAL</code>的等价声明，声明指定的<code class="codeph">SOURCE_STMT</code>和指定的<code class="codeph">DESTINATION_STMT</code>在功能上是等效的，并且指定的<code class="codeph">DESTINATION_STMT</code>更适合于性能。在DBA创建这样的声明之后，用户不需要知道在封面下执行的空间优化。
                     </p>
                     <p>此功能还允许应用程序执行SQL查询的特定部分实现。例如，它可以使用<code class="codeph">UNION</code> <code class="codeph">ALL</code>三个关系执行汇总，如<a href="advanced-query-rewrite-materialized-views.html#GUID-94D148DC-1E2A-4791-A7B6-28F9BF0306C1__BABIGJAH">例12-13</a>所示。
                     </p>
                  </div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-94D148DC-1E2A-4791-A7B6-28F9BF0306C1__BABIGJAH">
                     <p class="titleinexample">例12-13使用等效重写（UNION ALL）</p><pre class="oac_no_warn" dir="ltr">创建物化视图T1作为选择g.region，g.state，g.city，0 AS gid，SUM（销售）AS销售来自sales_fact f，geog_dim g WHERE f.geog_key = g.geog_key GROUP BY g.region，g。国家，g.city;创建物料化视图T2作为选择t.region，t.state，SUM（t.sales）AS销售来自T1 GROUP BY t.region，t.state;创建视图T3作为选择t.region，SUM（t.sales）AS销售来自T2 GROUP BY t.region;</pre><p><code class="codeph">ROLLUP(region, state, city)</code>查询等同于：</p><pre class="oac_no_warn" dir="ltr">SELECT * FROM T1 UNION ALL SELECT region，state，NULL，1 AS gid，sales FROM T2 UNION ALL SELECT region，NULL，NULL，3 AS gid，sales FROM T3 UNION ALL SELECT NULL，NULL，NULL，7 AS gid，SUM （销售）来自T3;</pre><p>通过指定此等效性，Oracle数据库将使用更有效的第二种形式的查询来计算用户询问的<code class="codeph">ROLLUP</code>查询。
                     </p><pre class="oac_no_warn" dir="ltr">DBMS_ADVANCED_REWRITE.DECLARE_REWRITE_EQUIVALENCE（'CUSTOM_ROLLUP'，'SELECT g.region，g.state，g.city，GROUPING_ID（g.city，g.state，g.region），SUM（sales）FROM sales_fact f，geog_dim g WHERE f。 geog_key = g.geog_key GROUP BY ROLLUP（g.region，g.state，g.city'，'SELECT * FROM T1 UNION ALL SELECT region，state，NULL，1 as gid，sales FROM T2 UNION ALL SELECT region，NULL， NULL，3作为gid，销售来自T3 UNION ALL SELECT NULL，NULL，NULL，7作为gid，SUM（销售）FROM T3'）;</pre><p>此功能的另一个应用是为用户提供特殊的聚合计算，这些计算可能在概念上很简单，但在SQL中表达起来非常复杂。在这种情况下，应用程序要求用户使用指定的自定义聚合函数，并使用复杂的SQL在内部对其进行计算。</p>
                  </div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-94D148DC-1E2A-4791-A7B6-28F9BF0306C1__GUID-3278789A-FFC9-4A1D-A5DF-E0DF1D6C3A8D">
                     <p class="titleinexample">示例12-14使用等效重写（使用自定义聚合）</p>
                     <p>假设应用程序用户希望查看每个城市，州和地区的销售额以及特定季节的其他销售信息。例如，新英格兰用户希望在冬季月份为新英格兰的城市提供额外的销售信息。该应用程序将为您提供一个特殊的聚合<code class="codeph">Seasonal_Agg</code> ，用于计算早期的聚合。您会询问经典的摘要查询，但使用<code class="codeph">Seasonal_Agg(sales, region)</code>而不是<code class="codeph">SUM(sales)</code> 。
                     </p><pre class="oac_no_warn" dir="ltr">SELECT g.region，t.calendar_month_name，Seasonal_Agg（f.sales，g.region）AS sales FROM sales_fact f，geog_dim g，times t WHERE f.geog_key = g.geog_key AND f.time_id = t.time_id GROUP BY g。 region，t.calendar_month_name;</pre><p>应用程序可以使用此功能自动为它们执行此操作，而不是要求用户编写执行额外计算的SQL。在此示例中， <code class="codeph">Seasonal_Agg</code>是使用电子表格功能计算的（请参阅<a href="sql-modeling-data-warehouses.html#GUID-538F78AA-9BF3-46F2-93D1-39A8739B3237">SQL for Modeling</a> ）。请注意，即使<code class="codeph">Seasonal_Agg</code>是用户定义的聚合，所需的行为是在查询的答案中添加额外的行，这对于简单的PL / SQL函数来说是不容易的。
                     </p><pre class="oac_no_warn" dir="ltr">DBMS_ADVANCED_REWRITE.DECLARE_REWRITE_EQUIVALENCE（'CUSTOM_SEASONAL_AGG'，SELECT g.region，t.calendar_month_name，Seasonal_Agg（sales，region）AS sales FROM sales_fact f，geog_dim g，times t WHERE f.geog_key = g.geog_key AND f.time_id = t.time_id GROUP BY g.region，t.calendar_month_name'，'SELECT g，region，t.calendar_month_name，SUM（sales）AS sales FROM sales_fact f，geog_dim g WHERE f.geog_key = g.geog_key AND t.time_id = f.time_id GROUP BY g.region，g.state，g.city，t.calendar_month_name DIMENSION BY g.region，t.calendar_month_name（sales ['New England'，'Winter'] = AVG（sales）OVER calendar_month_name IN（'Dec'， 'Jan'，'Feb'，'Mar'），销售['Western'，'Summer'] = AVG（销售）超过calendar_month_name IN（'May'，'Jun'，'July'，'Aug'）,. ）;</pre></div>
                  <!-- class="example" -->
               </div>
            </div><a id="DWHSG8915"></a><a id="DWHSG0807"></a><div class="props_rev_3"><a id="GUID-71197259-E8A4-45E5-A462-A9ADF6517CD6" name="GUID-71197259-E8A4-45E5-A462-A9ADF6517CD6"></a><h3 id="DWHSG-GUID-71197259-E8A4-45E5-A462-A9ADF6517CD6" class="sect3"><span class="enumeration_section">12.5</span>创建具有等效性的结果缓存物化视图</h3>
               <div>
                  <p>一种特殊类型的物化视图（称为结果缓存物化视图（RCMV））使您可以在运行查询重写时使用结果缓存。这些结果缓存物化视图提供了结果缓存的主要优点，更快的访问需要更少的空间，而没有无法对它们运行查询重写的正常缺点。</p>
                  <p>使用这种物化视图的示例如下。</p>
                  <div class="example" id="GUID-71197259-E8A4-45E5-A462-A9ADF6517CD6__GUID-232AD555-A465-4DF8-AFA8-45C2256AA281">
                     <p class="titleinexample">示例12-15结果缓存物化视图</p>
                     <p>首先，授予必要的权限：</p><pre class="oac_no_warn" dir="ltr">CONNECT / AS SYSDBA GRANT创建物化视图sh;在DBMS_ADVANCED_REWRITE上执行GRANT EXECUTE到sh;</pre><p>接下来，创建结果缓存物化视图：</p><pre class="oac_no_warn" dir="ltr">CONNECT sh / sh begin sys。DBMS_ADVANCED_REWRITE.Declare_Rewrite_Equivalence（名称=&gt;'RCMV_SALES'，Source_Stmt =&gt;'select channel_id，prod_id，sum（amount_sold），count（amount_sold）来自销售组的prod_id，channel_id'，Destination_Stmt =&gt;'select * from（select / * + RESULT_CACHE（name = RCMV_SALES）* / channel_id，prod_id，sum（amount_sold），来自销售组的count（amount_sold）prod_id，channel_id）'，Validate =&gt; FALSE，Rewrite_Mode =&gt;'GENERAL'）;结束; / ALTER SESSION SET query_rewrite_integrity = stale_tolerated;</pre><p>然后，通过查看解释计划，验证所有不同的查询都重写为<code class="codeph">RCMV_SALES</code> ：</p><pre class="oac_no_warn" dir="ltr">EXPLAIN PLAN FOR SELECT channel_id，SUM（amount_sold）FROM sales GROUP BY channel_id; @？/ rdbms / admin / utlxpls PLAN_TABLE_OUTPUT ------------------------------------------- -------------------------------------计划哈希值：3903632134 -------- -------------------------------------------------- ---------------------- | Id |操作|名称|行|字节|成本（％CPU）|时间| Pstart | Pstop | -------------------------------------------------- ------------------------------- | 0 |选择声明| | 4 | 64 | 1340（68）| 00:00:17 | | | | 1 | HASH GROUP BY | | 4 | 64 | 1340（68）| 00:00:17 | | | | 2 |查看| | 204 | 3264 | 1340（68）| 00:00:17 | | | | 3 | RESULT CACHE | 3gps5zr86gyb53y36js9zuay2s | | | | | | | | 4 | HASH GROUP BY | | 204 | 2448 | 1340（68）| 00:00:17 | | | | 5 | PARTITION RANGE ALL | | 918K | 10M | 655（33）| 00：00：08 | 1 | 28 | | 6 |表访问完全|销售| 918K | 10M | 655（33）| 00：00：08 | 1 | 28 | -------------------------------------------------- -------------------------------结果缓存信息（由操作ID标识）：--------- --------------------------------------------- 3  - 列数= 4;依赖=（SH.SALES）; name =“RCMV_SALES”选择了18行。
</pre><p>然后，执行创建缓存结果的查询：</p><pre class="oac_no_warn" dir="ltr">SELECT channel_id，SUM（amount_sold）FROM sales GROUP BY channel_id; CHANNEL_ID SUM（AMOUNT_SOLD）---------- ---------------- 2 26346342.3 4 13706802 3 57875260.6 9 277426.26</pre><p>接下来，验证在结果缓存中是否实现了物化视图：</p><pre class="oac_no_warn" dir="ltr">CONNECT / AS SYSDBA SELECT name，scan_count hits，block_count blocks，depend_count dependencies FROM V $ RESULT_CACHE_OBJECTS WHERE name ='RCMV_SALES'; NAME HITS BLOCKS DEPENDENCIES ---------- ---- ------ ------------ RCMV_SALES 0 5 1</pre><p>最后，删除RCMV查询等价：</p><pre class="oac_no_warn" dir="ltr">开始sys。DBMS_ADVANCED_REWRITE.Drop_Rewrite_equivalence（ 'RCMV_SALES'）;结束; /</pre></div>
                  <!-- class="example" -->
                  <p>有关结果缓存的更多信息，请参见“ <a href="../tgsql/generating-and-displaying-execution-plans.html#TGSQL-GUID-FE0B82DA-1A06-4145-B03D-A1C39DB1F88F" target="_blank"><span><cite>Oracle数据库SQL调优指南”</cite></span></a> 。
                  </p>
               </div>
            </div>
            <div class="sect2"><a id="GUID-41A13A98-E51A-435A-973E-05CC083F2CFC" name="GUID-41A13A98-E51A-435A-973E-05CC083F2CFC"></a><h3 id="DWHSG-GUID-41A13A98-E51A-435A-973E-05CC083F2CFC" class="sect3"><span class="enumeration_section">12.6</span>基于近似查询的查询重写和物化视图</h3>
               <div>
                  <p>如果可以使用物化视图回答这些查询，则会自动重写包含返回近似结果的SQL函数的查询以使用匹配的物化视图。</p>
                  <p></p>
                  <p>对于包含SQL函数的查询，这些函数返回使用基于近似查询的实例化视图重写的近似结果，请确保为实例化视图启用了查询重写。还必须在数据库级别或当前会话中启用查询重写。</p>
                  <p>考虑物化视图<code class="codeph">approx_count_distinct_pdt_mv</code> ，其定义如下：</p><pre class="pre codeblock"><code>CREATE MATERIALIZED VIEW approx_count_distinct_pdt_mv ENABLE QUERY REWRITE AS SELECT t.calendar_year，t.calendar_month_number，t.day_number_in_month，approx_count_distinct_detail（prod_id）daily_detail FROM sales s，times t WHERE s.time_id = t.time_id GROUP BY t.calendar_year，t.calendar_month_number， t.day_number_in_month;</code></pre><p>当运行与<code class="codeph">approx_count_distinct_pdt_mv</code>的定义查询匹配的查询，并且满足本节中描述的先决条件时，将自动重写查询以使用此物化视图。重写以下查询以使用<code class="codeph">approx_count_distinct_pdt_mv</code> ，如为查询生成的执行计划所示。
                  </p><pre class="pre codeblock"><code>SELECT t.calendar_year，t.calendar_month_number，t.day_number_in_month，approx_count_distinct（prod_id）FROM sales s，times t WHERE s.time_id = t.time_id GROUP BY t.calendar_year，t.calendar_month_number，t.day_number_in_month; PLAN_TABLE_OUTPUT ------------------------------------------------- -------------------------------------------------- ----------计划哈希值：2307354865 ----------------------------------- -------------------------------------------------- ------------------------ | Id |操作|名称|行|字节|成本（％CPU）|时间| -------------------------------------------------- -------------------------------------------------- --------- | 0 |选择声明| | 1460 | 74460 | 205（0）| 00:00:01 | | 1 | MAT_VIEW REWRITE ACCESS FULL | APPROX_COUNT_DISTINCT_PDT_MV | 1460 | 74460 | 205（0）| 00:00:01 | -------------------------------------------------- -------------------------------------------------- ---------选择了8行。
</code></pre><p>还会重写以下查询以使用执行计划所指示的<code class="codeph">approx_count_distinct_pdt_mv</code> 。请注意，此查询将数据聚合到比定义的<code class="codeph">approx_count_distinct_pdt_mv</code>查询定义的更高的级别。</p><pre class="pre codeblock"><code>SELECT t.calendar_year，t.calendar_month_number，approx_count_distinct（prod_id）FROM sales s，times t WHERE s.time_id = t.time_id GROUP BY t.calendar_year，t.calendar_month_number; PLAN_TABLE_OUTPUT ------------------------------------------------- -------------------------------------------------- -----------计划哈希值：827336432 ---------------------------------- -------------------------------------------------- -------------------------- | Id |操作|名称|行|字节|成本（％CPU）|时间| -------------------------------------------------- -------------------------------------------------- ---------- | 0 |选择声明| | 34 | 1632 | 206（1）| 00:00:01 | | 1 | HASH GROUP BY APPROX | | 34 | 1632 | 206（1）| 00:00:01 | | 2 | MAT_VIEW REWRITE ACCESS FULL | APPROX_COUNT_DISTINCT_PDT_MV | 1460 | 70080 | 205（0）| 00:00:01 | -------------------------------------------------- -------------------------------------------------- ----------选择了9行。</code></pre><div class="section">
                     <p class="subhead2" id="GUID-41A13A98-E51A-435A-973E-05CC083F2CFC__GUID-B767DDCE-4DA1-40F5-BB0A-C2004AD2DDCF">使用精确函数重写查询以使用包含近似函数的实体化视图</p>
                     <p>如果设置数据库初始化参数，使用返回近似值的相应SQL函数替换精确函数，则优化程序可以重写包含精确函数的查询，以使用使用相同函数的近似版本定义的实体化视图。您无需重写查询即可使用相应的近似函数。</p>
                     <p>例如，如果<code class="codeph">approx_for_count_distinct</code>参数设置为<code class="codeph">TRUE</code> ，则优化程序将重写以下查询以使用物化视图<code class="codeph">approx_count_distinct_pdt_mv</code> ：</p><pre class="pre codeblock"><code>ALTER SESSION SET approx_for_count_distinct = TRUE; SELECT t.calendar_year，t.calendar_month_number，COUNT（DISTINCT prod_id）FROM sales s，times t WHERE s.time_id = t.time_id GROUP BY t.calendar_year，t.calendar_month_number; PLAN_TABLE_OUTPUT ------------------------------------------------- -------------------------------------------------- -----------计划哈希值：827336432 ---------------------------------- -------------------------------------------------- -------------------------- | Id |操作|名称|行|字节|成本（％CPU）|时间| -------------------------------------------------- -------------------------------------------------- ---------- | 0 |选择声明| | 34 | 1632 | 206（1）| 00:00:01 | | 1 | HASH GROUP BY APPROX | | 34 | 1632 | 206（1）| 00:00:01 | | 2 | MAT_VIEW REWRITE ACCESS FULL | APPROX_COUNT_DISTINCT_PDT_MV | 1460 | 70080 | 205（0）| 00:00:01 | -------------------------------------------------- -------------------------------------------------- ----------选择了9行。
</code></pre><p>请注意，上述执行计划与查询使用上一示例中的<code class="codeph">approx_count_distinct</code>时生成的执行计划相同。
                     </p>
                     <div class="infoboxnotealso" id="GUID-41A13A98-E51A-435A-973E-05CC083F2CFC__GUID-B8E12426-808E-409A-9CF1-261112F83EE5">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="data-warehouse-optimizations-techniques.html#GUID-F7E7DEA6-B225-43E6-97ED-CB3DBE86CD54" title="近似查询处理使用SQL函数为可接受近似值的探索性查询提供实时响应。包含返回近似结果的SQL函数的查询称为近似查询。">关于近似查询处理</a></p>
                           </li>
                           <li>
                              <p><a href="sql-analysis-reporting-data-warehouses.html#GUID-6A387B85-B347-4065-8A48-8F3E4AA91F87" title="使用返回近似结果的SQL函数计算近似聚合。它们主要用于数据探索查询，其中不需要精确值，并且可以接受近似值。">关于近似聚合</a></p>
                           </li>
                           <li>
                              <p><a href="basic-materialized-views.html#GUID-42B64F99-7391-48B8-B37D-1B486DC29645" title="基于近似查询的物化视图使用SQL函数，该函数在其定义查询中返回近似函数。">基于近似查询创建物化视图</a></p>
                           </li>
                        </ul>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div>
            </div>
            <div class="sect2"><a id="GUID-50F1CD49-F551-4443-96FD-6F8EDA694930" name="GUID-50F1CD49-F551-4443-96FD-6F8EDA694930"></a><h3 id="DWHSG-GUID-50F1CD49-F551-4443-96FD-6F8EDA694930" class="sect3"><span class="enumeration_section">12.7</span>基于位图的COUNT（DISTINCT）函数查询重写和物化视图</h3>
               <div>
                  <p>可以重写对整数列包含<code class="codeph">COUNT(DISTINCT)</code>操作的查询，以使用包含基于位图的函数的实体化视图。
                  </p>
                  <p></p>
                  <p>为物化视图启用查询重写，以便可以使用此物化视图重写SQL查询。</p>
                  <div class="example" id="GUID-50F1CD49-F551-4443-96FD-6F8EDA694930__GUID-3B53EFDB-DB29-4CD3-BA63-239C90AF5D40">
                     <p class="titleinexample">示例12-16使用包含COUNT的实体化视图重写查询（DISTINCT）</p>
                     <p>物化视图<code class="codeph">mv_sales</code>是使用以下命令创建的：</p><pre class="pre codeblock"><code>创建物化视图mv_sales作为选择PROMO_ID，BITMAP_BUCKET_NUMBER（PROD_ID）bm_bktno，BITMAP_CONSTRUCT_AGG（BITMAP_BIT_POSITION（PROD_ID），'RAW'）bm_details来自销售组PROMO_ID，BITMAP_BUCKET_NUMBER（PROD_ID）;</code></pre><p>已对物化视图<code class="codeph">mv_sales</code>启用了查询重写。
                     </p>
                     <p>当SQL查询对<code class="codeph">mv_sales</code>化视图定义中包含的数字列执行<code class="codeph">COUNT(DISTINCT)</code>操作时，将重写该查询以使用<code class="codeph">mv_sales</code>化视图。下面的执行计划显示使用了物化视图。
                     </p><pre class="pre codeblock"><code>SQL&gt; EXPLAIN PLAN FOR选择PROMO_ID，按PROMO_ID按PROMO_ID顺序从销售组中计算（不同的PROD_ID）;解释。SQL&gt; SELECT PLAN_TABLE_OUTPUT FROM TABLE（DBMS_XPLAN.DISPLAY（））; PLAN_TABLE_OUTPUT ------------------------------------------------- -------------------------------------------------- ---------计划哈希值：2440767223 ------------------------------------ ---------- | Id |操作|名称| ---------------------------------------------- | 0 |选择声明| | | 1 | SORT GROUP BY | | | 2 |查看| | | 3 | HASH GROUP BY | | | 4 | MAT_VIEW ACCESS FULL | MV_SALES | -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  注意  - - -   - 使用动态统计：动态采样（level = 2）选择15行。
</code></pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-50F1CD49-F551-4443-96FD-6F8EDA694930__GUID-B6CC0CF2-0AE6-449E-B06A-8DD6D7E6D345">
                     <p class="titleinexample">示例12-17使用基于位图的COUNT（DISTINCT）和Rollup进行查询重写</p>
                     <p>以下命令用于创建物化视图<code class="codeph">mv_sales_amount</code> ：</p><pre class="pre codeblock"><code>创建物化视图mv_sales_amount AS SELECT PROMO_ID，CHANNEL_ID，BITMAP_BUCKET_NUMBER（PROD_ID）为bm_bktno，BITMAP_CONSTRUCT_AGG（BITMAP_BIT_POSITION（PROD_ID））为bm_details，SUM（AMOUNT_SOLD）为amount_sold FROM sales GROUP BY PROMO_ID，CHANNEL_ID，BITMAP_BUCKET_NUMBER（PROD_ID）;</code></pre><p>已对物化视图<code class="codeph">mv_sales_amount</code>启用了查询重写。
                     </p>
                     <p>下面显示的SQL命令的执行计划演示了查询重写以满足包含<code class="codeph">COUNT(DISTINCT)</code>函数的查询。查询重写在不同的聚合级别和存在其他聚合的情况下执行。
                     </p><pre class="pre codeblock"><code>来自销售GROUP BY PROMO_ID的SELECT PROMO_ID，COUNT（DISTINCT PROD_ID），SUM（AMOUNT_SOLD）的EXPLAIN PLAN; -------------------------------------------------- ----------------------------------------- | Id |操作|名称|行|字节|成本（％CPU）|时间| -------------------------------------------------- ----------------------------------------- | 0 |选择声明| | 163 | 6357 | 8（13）| 00:00:01 | | 1 | HASH GROUP BY | | 163 | 6357 | 8（13）| 00:00:01 | | 2 |查看| | 163 | 6357 | 8（13）| 00:00:01 | | 3 | HASH GROUP BY | | 163 | 324K | 8（13）| 00:00:01 | | 4 | MAT_VIEW ACCESS FULL | MV_SALES_AMOUNT | 163 | 324K | 7（0）| 00:00:01 | -------------------------------------------------- -----------------------------------------</code></pre></div>
                  <!-- class="example" -->
               </div>
            </div><a id="DWHSG0805"></a><div class="props_rev_3"><a id="GUID-3AB77341-BDA9-4F84-9691-EB79E4C8B832" name="GUID-3AB77341-BDA9-4F84-9691-EB79E4C8B832"></a><h3 id="DWHSG-GUID-3AB77341-BDA9-4F84-9691-EB79E4C8B832" class="sect3"><span class="enumeration_section">12.8</span>验证是否发生了查询重写</h3>
               <div>
                  <div class="section">
                     <p>由于查询重写是透明的，因此必须采取特殊步骤来验证查询是否已被重写。当然，如果查询运行得更快，这应该表明已经发生了重写，但这不是证明。因此，要确认确实发生了查询重写，请使用<code class="codeph">EXPLAIN</code> <code class="codeph">PLAN</code>语句或<code class="codeph">DBMS_MVIEW.EXPLAIN_REWRITE</code>过程。
                     </p>
                     <p>本节包含以下主题：</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="advanced-query-rewrite-materialized-views.html#GUID-4D27E4FA-A642-42FD-8627-7060B1861884">使用EXPLAIN PLAN和Query Rewrite</a></p>
                        </li>
                        <li>
                           <p><a href="advanced-query-rewrite-materialized-views.html#GUID-D4E6983B-D503-4801-8B0C-5E69D5313A11">将EXPLAIN_REWRITE过程与Query Rewrite一起使用</a></p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
               </div><a id="DWHSG08051"></a><div class="props_rev_3"><a id="GUID-4D27E4FA-A642-42FD-8627-7060B1861884" name="GUID-4D27E4FA-A642-42FD-8627-7060B1861884"></a><h4 id="DWHSG-GUID-4D27E4FA-A642-42FD-8627-7060B1861884" class="sect4"><span class="enumeration_section">12.8.1</span>使用带有查询重写的EXPLAIN PLAN</h4>
                  <div>
                     <div class="section">
                        <p><a id="d44607e6081" class="indexterm-anchor"></a> <code class="codeph">EXPLAIN</code> <code class="codeph">PLAN</code>工具的使用方法如<a href="../sqlrf/EXPLAIN-PLAN.html#SQLRF01601" target="_blank"><span class="italic">Oracle数据库SQL语言参考中所述</span></a> 。对于查询重写，您需要检查的是操作显示<code class="codeph">MAT_VIEW</code> <code class="codeph">REWRITE</code> <code class="codeph">ACCESS</code> 。如果是，则发生查询重写。下面是一个示例，它创建了物化视图<code class="codeph">cal_month_sales_mv</code> ：</p><pre class="oac_no_warn" dir="ltr">CREATE MATERIALIZED VIEW cal_month_sales_mv ENABLE QUERY REWRITE as SELECT t.calendar_month_desc，SUM（s.amount_sold）AS $ FROM sales s，times t WHERE s.time_id = t.time_id GROUP BY t.calendar_month_desc;</pre><p>如果在以下SQL语句中使用<code class="codeph">EXPLAIN</code> <code class="codeph">PLAN</code> ，则结果将放在默认表<code class="codeph">PLAN_TABLE</code> 。但是，必须首先使用<code class="codeph">utlxplan.sql</code>脚本创建<code class="codeph">PLAN_TABLE</code> 。请注意， <code class="codeph">EXPLAIN</code> <code class="codeph">PLAN</code>实际上并不执行查询。
                        </p><pre class="oac_no_warn" dir="ltr">EXPLAIN PLAN FOR SELECT t.calendar_month_desc，SUM（s.amount_sold）FROM sales s，times t WHERE s.time_id = t.time_id GROUP BY t.calendar_month_desc;</pre><p>出于查询重写的目的， <code class="codeph">PLAN_TABLE</code>唯一感兴趣的信息是操作<code class="codeph">OBJECT_NAME</code> ，它标识用于执行此查询的方法。因此，您可能会在输出中看到操作<code class="codeph">MAT_VIEW</code> <code class="codeph">REWRITE</code> <code class="codeph">ACCESS</code> ，如下所示：</p><pre class="oac_no_warn" dir="ltr">来自PLAN_TABLE的SELECT OPERATION，OBJECT_NAME; OPERATION OBJECT_NAME -------------------- ----------------------- SELECT STATEMENT MAT_VIEW REWRITE ACCESS CALENDAR_MONTH_SALES_MV</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="DWHSG8559"></a><div class="props_rev_3"><a id="GUID-D4E6983B-D503-4801-8B0C-5E69D5313A11" name="GUID-D4E6983B-D503-4801-8B0C-5E69D5313A11"></a><h4 id="DWHSG-GUID-D4E6983B-D503-4801-8B0C-5E69D5313A11" class="sect4"><span class="enumeration_section">12.8.2</span>使用带有查询重写的EXPLAIN_REWRITE过程</h4>
                  <div>
                     <div class="section">
                        <p>这可能很困难<a id="d44607e6178" class="indexterm-anchor"></a><a id="d44607e6182" class="indexterm-anchor"></a><a id="d44607e6186" class="indexterm-anchor"></a>理解为什么查询没有重写。管理查询重写资格的规则非常复杂，涉及各种因素，例如约束，维度，查询重写完整性模式，物化视图的新鲜度以及查询本身的类型。此外，您可能想知道为什么查询重写选择了特定的物化视图而不是另一个。为了解决这个问题，Oracle数据库提供了<code class="codeph">DBMS_MVIEW.EXPLAIN_REWRITE</code>过程，以便在重写查询时提供建议，如果没有，为什么不重写。使用<code class="codeph">DBMS_MVIEW.EXPLAIN_REWRITE</code>的结果，您可以采取必要的相应操作，以便在可能的情况下重写查询。
                        </p>
                        <p>请注意， <code class="codeph">EXPLAIN_REWRITE</code>语句中指定的查询实际上并不执行。
                        </p>
                        <p>本节包含以下主题：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="advanced-query-rewrite-materialized-views.html#GUID-723FEA4B-2299-4DF1-8216-AAA5D03D8920">DBMS_MVIEW.EXPLAIN_REWRITE语法</a></p>
                           </li>
                           <li>
                              <p><a href="advanced-query-rewrite-materialized-views.html#GUID-5C0A241C-FDA4-4BBD-98EF-EC5FF47C8E62">使用REWRITE_TABLE查看EXPLAIN_REWRITE输出</a></p>
                           </li>
                           <li>
                              <p><a href="advanced-query-rewrite-materialized-views.html#GUID-F936CEE1-3568-4487-842A-015AFE940F87">使用Varray查看EXPLAIN_REWRITE输出</a></p>
                           </li>
                           <li>
                              <p><a href="advanced-query-rewrite-materialized-views.html#GUID-EB88C4EC-D843-4AB5-934D-063894CE51D5">EXPLAIN_REWRITE福利统计</a></p>
                           </li>
                           <li>
                              <p><a href="advanced-query-rewrite-materialized-views.html#GUID-80AAF9D9-DA04-4804-931D-432CF883CE54">在EXPLAIN_REWRITE中支持大于32KB的查询文本</a></p>
                           </li>
                           <li>
                              <p><a href="advanced-query-rewrite-materialized-views.html#GUID-C6BFEB7A-B1E3-4E08-B38D-87FA3D6B1BBC">关于EXPLAIN_REWRITE和多个物化视图</a></p>
                           </li>
                           <li>
                              <p><a href="advanced-query-rewrite-materialized-views.html#GUID-4A5FD50D-E2AB-4176-BD1B-418E7B2491BB">关于EXPLAIN_REWRITE输出</a></p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div><a id="DWHSG8560"></a><div class="props_rev_3"><a id="GUID-723FEA4B-2299-4DF1-8216-AAA5D03D8920" name="GUID-723FEA4B-2299-4DF1-8216-AAA5D03D8920"></a><h5 id="DWHSG-GUID-723FEA4B-2299-4DF1-8216-AAA5D03D8920" class="sect5"><span class="enumeration_section">12.8.2.1</span> DBMS_MVIEW.EXPLAIN_REWRITE语法</h5>
                     <div>
                        <div class="section">
                           <p>您可以通过两种方式从<code class="codeph">DBMS_MVIEW.EXPLAIN_REWRITE</code>获取输出。第一种是使用表，而第二种是创建<code class="codeph">VARRAY</code> 。以下显示了使用输出表的基本语法：</p><pre class="oac_no_warn" dir="ltr">DBMS_MVIEW.EXPLAIN_REWRITE（查询VARCHAR2，mv VARCHAR2（30），statement_id VARCHAR2（30））;</pre><p>您可以通过执行<code class="codeph">utlxrw.sql</code>脚本来创建名为<code class="codeph">REWRITE_TABLE</code>的输出表。
                           </p>
                           <p><code class="codeph">query</code>参数是表示SQL查询的文本字符串。参数<code class="codeph">mv</code>是<code class="codeph">schema.mv</code>形式的完全限定的物化视图名称。这是一个可选参数。如果未指定， <code class="codeph">EXPLAIN_REWRITE</code>将返回有关考虑重写给定查询的所有物化视图的任何相关消息。省略<code class="codeph">schema</code>并且仅指定<code class="codeph">mv</code> ， <code class="codeph">EXPLAIN_REWRITE</code>将在当前模式中查找<code class="codeph">EXPLAIN_REWRITE</code>化视图。
                           </p>
                           <p>如果要将<code class="codeph">EXPLAIN_REWRITE</code>的输出定向到varray而不是表，则应按如下方式调用过程：</p><pre class="oac_no_warn" dir="ltr">DBMS_MVIEW.EXPLAIN_REWRITE（查询[VARCHAR2 | CLOB]，mv VARCHAR2（30），output_array SYS.RewriteArrayType）;</pre><p>请注意，如果查询长度少于256个字符，则可以使用SQL * Plus中的<code class="codeph">EXECUTE</code>命令轻松调用<code class="codeph">EXPLAIN_REWRITE</code> 。否则，推荐的方法是使用PL / SQL <code class="codeph">BEGIN...END</code>块，如<code class="codeph">/rdbms/demo/smxrw*</code>中的示例所示。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="DWHSG8562"></a><a id="DWHSG8561"></a><div class="props_rev_3"><a id="GUID-5C0A241C-FDA4-4BBD-98EF-EC5FF47C8E62" name="GUID-5C0A241C-FDA4-4BBD-98EF-EC5FF47C8E62"></a><h5 id="DWHSG-GUID-5C0A241C-FDA4-4BBD-98EF-EC5FF47C8E62" class="sect5"><span class="enumeration_section">12.8.2.2</span>使用REWRITE_TABLE查看EXPLAIN_REWRITE输出</h5>
                     <div>
                        <div class="section">
                           <p><code class="codeph">EXPLAIN_REWRITE</code>的输出可以定向到名为<code class="codeph">REWRITE_TABLE</code>的表。您可以通过运行<code class="codeph">utlxrw.sql</code>脚本来创建此输出表。该脚本可以在<code class="codeph">admin</code>目录中找到。<code class="codeph">REWRITE_TABLE</code>的格式如下：</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE REWRITE_TABLE（statement_id VARCHAR2（30）， - 查询的id为mv_owner VARCHAR2（30）， -  MV mv_name VARCHAR2（30）的所有者， -  MV序列的名称INTEGER， -  msg的序列号query VARCHAR2（2000）， -  user query query_block_no INTEGER， -  block no of of current subquery rewritten_txt VARCHAR2（2000）， -  rewritten query message VARCHAR2（512）， -  EXPLAIN_REWRITE msg pass VARCHAR2（3）， -  rewrite传递没有mv_in_msg VARCHAR2（30）， - 当前消息中的MV measure_in_msg VARCHAR2（30）， - 当前消息中的度量join_back_tbl VARCHAR2（30）， - 联接消息中的表join_back_col VARCHAR2（30）， -  Join back column in message original_cost INTEGER， - 原始查询的成本rewritten_cost INTEGER， - 重写查询标志的成本INTEGER， - 相关标志reserved1 INTEGER， - 当前未使用reerved2 VARCHAR2（10）） - 当前未使用;</pre></div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-5C0A241C-FDA4-4BBD-98EF-EC5FF47C8E62__GUID-F6ADC987-2327-487D-B648-B5E6E3E690CD">
                           <p class="titleinexample">例12-18 EXPLAIN_REWRITE使用REWRITE_TABLE</p>
                           <p>PL / SQL调用示例如下：</p><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_MVIEW.EXPLAIN_REWRITE  - （'SELECT p.prod_name，SUM（amount_sold）'||  - 'FROM sales s，products p'||  - 'WHERE s.prod_id = p.prod_id'||  - 'AND prod_name&gt;'' B％'''||  - '和prod_name &lt;''C％'''||  - 'GROUP BY prod_name'， - 'TestXRW.PRODUCT_SALES_MV'， - 'SH'）; SELECT消息FROM rewrite_table ORDER BY sequence;信息  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  - - ------------------------------- QSM-01033：用物化视图重写查询，选择PRODUCT_SALES_MV 1行。
</pre><p>演示文件<code class="codeph">xrwutl.sql</code>包含一个过程，您可以调用该过程以提供<code class="codeph">EXPLAIN_REWRITE</code>的更详细输出。有关更多信息，请参见<span class="q">“ <a href="advanced-query-rewrite-materialized-views.html#GUID-4A5FD50D-E2AB-4176-BD1B-418E7B2491BB">关于EXPLAIN_REWRITE输出</a> ”</span> 。
                           </p>
                           <p>以下是一个示例，您可以在其中更详细地了解为什么不考虑某些物化视图，并最终选择物化视图<code class="codeph">sales_mv</code>作为最佳视图。
                           </p><pre class="oac_no_warn" dir="ltr">DECLARE qrytext VARCHAR2（500）：='SELECT cust_first_name，cust_last_name，SUM（amount_sold）AS dollar_sales FROM sales s，customers c WHERE s.cust_id = c.cust_id GROUP BY cust_first_name，cust_last_name'; idno VARCHAR2（30）：='ID1'; BEGIN DBMS_MVIEW.EXPLAIN_REWRITE（qrytext，''，idno）;结束; / SELECT消息FROM rewrite_table ORDER BY sequence;</pre><pre class="oac_no_warn" dir="ltr">SQL&gt; MESSAGE ----------------------------------------------- --------------------------------- QSM-01082：加入物化视图，CAL_MONTH_SALES_MV，表，SALES，不可能QSM-01022：使用比PRODUCT_SALES_MV更优化的物化视图来重写QSM-01022：使用比FWEEK_PSCAT_SALES_MV更优化的物化视图来重写QSM-01033：用物化视图重写的查询SALES_MV</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="DWHSG8564"></a><a id="DWHSG8563"></a><div class="props_rev_3"><a id="GUID-F936CEE1-3568-4487-842A-015AFE940F87" name="GUID-F936CEE1-3568-4487-842A-015AFE940F87"></a><h5 id="DWHSG-GUID-F936CEE1-3568-4487-842A-015AFE940F87" class="sect5"><span class="enumeration_section">12.8.2.3</span>使用Varray查看EXPLAIN_REWRITE输出</h5>
                     <div>
                        <div class="section">
                           <p>您可以将<code class="codeph">EXPLAIN_REWRITE</code>的输出保存在PL / SQL <code class="codeph">VARRAY</code> 。此数组的元素的类型为<code class="codeph">RewriteMessage</code> ，它是在<code class="codeph">SYS</code>模式中预定义的，如下所示：</p><pre class="oac_no_warn" dir="ltr">TYPE RewriteMessage IS OBJECT（mv_owner VARCHAR2（30）， -  MV的模式mv_name VARCHAR2（30）， -  MV序列的名称NUMBER（3）， -  msg query_text VARCHAR2（2000）的序列号， - 用户查询query_block_no NUMBER（3）， - 当前子查询的块no rewritten_text VARCHAR2（2000）， - 重写查询文本消息VARCHAR2（512）， -  EXPLAIN_REWRITE错误消息传递VARCHAR2（3）， - 查询重写传递没有mv_in_msg VARCHAR2 （30）， - 当前消息中的MV measure_in_msg VARCHAR2（30）， - 当前消息中的度量join_back_tbl VARCHAR2（30）， - 当前消息中的联接表msg join_back_col VARCHAR2（30）， - 当前消息中的联接列original_cost NUMBER（10）， - 原始查询的成本rewritten_cost NUMBER（10）， - 成本重写查询标志NUMBER， - 相关标志reserved1 NUMBER， - 供将来使用reserved2 VARCHAR2（10） - 供将来使用）;</pre><p>阵列型， <code class="codeph">RewriteArrayType</code> ，这是一个VARRAY <code class="codeph">RewriteMessage</code>对象，在预定义的<code class="codeph">SYS</code>模式如下：</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">TYPE RewriteArrayType AS VARRAY（256）OF RewriteMessage;</code></p>
                              </li>
                              <li>
                                 <p>现在，您可以使用此数组类型声明一个数组变量，并在<code class="codeph">EXPLAIN_REWRITE</code>语句中指定它。
                                 </p>
                              </li>
                              <li>
                                 <p>每个<code class="codeph">RewriteMessage</code>记录都提供有关重写处理的消息。
                                 </p>
                              </li>
                              <li>
                                 <p>参数与<code class="codeph">REWRITE_TABLE</code>相同，但<code class="codeph">statement_id</code>除外，当使用varray作为输出时不使用。
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">mv_owner</code>字段定义与消息相关的物化视图的所有者。
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">mv_name</code>字段定义与消息相关的<code class="codeph">mv_name</code>化视图的名称。
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">sequence</code>字段定义了应该对消息进行排序的顺序。
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">query_text</code>字段包含正在分析的查询文本的前2000个字符。
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">message</code>字段包含与重写处理<code class="codeph">query</code>相关的消息文本。
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">flags</code> ， <code class="codeph">reserved1</code>和<code class="codeph">reserved2</code>字段保留供将来使用。
                                 </p>
                              </li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-F936CEE1-3568-4487-842A-015AFE940F87__GUID-B0470E88-BB63-4361-8FB4-419CC9826993">
                           <p class="titleinexample">例12-19 EXPLAIN_REWRITE使用VARRAY</p>
                           <p>请考虑以下物化视图：</p><pre class="oac_no_warn" dir="ltr">CREATE MATERIALIZED VIEW avg_sales_city_state_mv ENABLE QUERY REWRITE AS SELECT c.cust_city，c.cust_state_province，AVG（s.amount_sold）FROM sales s，customers c WHERE s.cust_id = c.cust_id GROUP BY c.cust_city，c.cust_state_province;</pre><p>您可以尝试使用以下查询使用此物化视图：</p><pre class="oac_no_warn" dir="ltr">SELECT c.cust_state_province，AVG（s.amount_sold）FROM sales s，customers c WHERE s.cust_id = c.cust_id GROUP BY c.cust_state_province;</pre><p>但是，查询不会使用此物化视图重写。这对于新手用户来说可能非常混乱，因为看起来重写所需的所有信息都存在于物化视图中。您可以从<code class="codeph">DBMS_MVIEW.EXPLAIN_REWRITE</code>中找到无法从给定的物化视图计算<code class="codeph">AVG</code> 。问题是这里需要<code class="codeph">ROLLUP</code> ， <code class="codeph">AVG</code>需要<code class="codeph">COUNT</code>或<code class="codeph">SUM</code>来执行<code class="codeph">ROLLUP</code> 。</p>
                           <p>使用<code class="codeph">VARRAY</code>作为输出的先前查询的示例PL / SQL块如下：</p><pre class="oac_no_warn" dir="ltr">SET SERVEROUTPUT ON DECLARE Rewrite_Array SYS.RewriteArrayType：= SYS.RewriteArrayType（）; querytxt VARCHAR2（1500）：='SELECT c.cust_state_province，AVG（s.amount_sold）FROM sales s，customers c WHERE s.cust_id = c.cust_id GROUP BY c.cust_state_province';我号码; BEGIN DBMS_MVIEW.EXPLAIN_REWRITE（querytxt，'AVG_SALES_CITY_STATE_MV'，Rewrite_Array）; FOR I IN 1 ..Rewrite_Array.count LOOP DBMS_OUTPUT.PUT_LINE（Rewrite_Array（i）.message）;结束循环;结束; /</pre><p>以下是此<code class="codeph">EXPLAIN_REWRITE</code>语句的输出：</p><pre class="oac_no_warn" dir="ltr">QSM-01065：物化视图AVG_SALES_CITY_STATE_MV无法在查询QSM-01101中计算度量AVG：在mv上发生汇总，AVG_SALES_CITY_STATE_MV QSM-01053：表上的NORELY参照完整性约束，CUSTOMERS，在TRUSTED / STALE TOLERATED中完整性模式PL / SQL过程成功完成。</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="DWHSG8565"></a><div class="props_rev_3"><a id="GUID-EB88C4EC-D843-4AB5-934D-063894CE51D5" name="GUID-EB88C4EC-D843-4AB5-934D-063894CE51D5"></a><h5 id="DWHSG-GUID-EB88C4EC-D843-4AB5-934D-063894CE51D5" class="sect5"><span class="enumeration_section">12.8.2.4</span> EXPLAIN_REWRITE收益统计</h5>
                     <div>
                        <p><code class="codeph">EXPLAIN_REWRITE</code>的输出包含两列， <code class="codeph">original_cost</code>和<code class="codeph">rewritten_cost</code> ，可以帮助您估计查询成本。 <code class="codeph">original_cost</code>在禁用查询重写时给出优化程序对查询成本的估计。 <code class="codeph">rewritten_cost</code>在使用物化视图重写查询时，为优化程序估计查询成本。这些成本值可用于找出特定查询从重写中获得的好处。
                        </p>
                     </div>
                  </div><a id="DWHSG8566"></a><div class="props_rev_3"><a id="GUID-80AAF9D9-DA04-4804-931D-432CF883CE54" name="GUID-80AAF9D9-DA04-4804-931D-432CF883CE54"></a><h5 id="DWHSG-GUID-80AAF9D9-DA04-4804-931D-432CF883CE54" class="sect5"><span class="enumeration_section">12.8.2.5</span>支持EXPLAIN_REWRITE中大于32KB的查询文本</h5>
                     <div>
                        <p>在此版本中， <code class="codeph">EXPLAIN_REWRITE</code>过程已得到增强，可支持大型查询。现在可以使用<code class="codeph">CLOB</code>数据类型而不是<code class="codeph">VARCHAR</code>数据类型定义输入查询文本。这允许<code class="codeph">EXPLAIN_REWRITE</code>接受最多4 GB的查询。</p>
                        <p>使用<code class="codeph">CLOB</code>将<code class="codeph">EXPLAIN_REWRITE</code>用于获取表的输出的语法如下所示：</p><pre class="oac_no_warn" dir="ltr">DBMS_MVIEW.EXPLAIN_REWRITE（查询IN CLOB，mv IN VARCHAR2，statement_id IN VARCHAR2）;</pre><p>第二个参数<code class="codeph">mv</code>和第三个参数<code class="codeph">statement_id</code>可以为<code class="codeph">NULL</code> 。类似地，使用<code class="codeph">CLOB</code>使用<code class="codeph">EXPLAIN_REWRITE</code>获取输出到varray的语法如下所示：</p><pre class="oac_no_warn" dir="ltr">DBMS_MVIEW.EXPLAIN_REWRITE（查询IN CLOB，mv IN VARCHAR2，msg_array IN OUT SYS.RewriteArrayType）;</pre><p>和以前一样，第二个参数<code class="codeph">mv</code>可以是<code class="codeph">NULL</code> 。请注意，可以使用<code class="codeph">DBMS_LOB</code>包中提供的过程生成<code class="codeph">CLOB</code>中的长查询文本。
                        </p>
                     </div>
                  </div><a id="DWHSG8567"></a><div class="props_rev_3"><a id="GUID-C6BFEB7A-B1E3-4E08-B38D-87FA3D6B1BBC" name="GUID-C6BFEB7A-B1E3-4E08-B38D-87FA3D6B1BBC"></a><h5 id="DWHSG-GUID-C6BFEB7A-B1E3-4E08-B38D-87FA3D6B1BBC" class="sect5"><span class="enumeration_section">12.8.2.6</span>关于EXPLAIN_REWRITE和多个物化视图</h5>
                     <div>
                        <p>将<code class="codeph">EXPLAIN_REWRITE</code>与多个物化视图一起使用的语法与将其与单个物化视图一起使用的语法相同，只是物化视图由逗号分隔的字符串指定。例如，要查明一组给定的物化视图<code class="codeph">mv1</code> ， <code class="codeph">mv2</code>和<code class="codeph">mv3</code>是否可用于重写查询， <code class="codeph">query_txt</code> ，如果不是，为什么不<code class="codeph">query_txt</code> ，请使用<code class="codeph">EXPLAIN_REWRITE</code> ，如下所示：</p><pre class="oac_no_warn" dir="ltr">DBMS_MVIEW.EXPLAIN_REWRITE（query_txt，'mv1，mv2，mv3'）</pre><p>如果查询<code class="codeph">query_txt</code>使用给定的物化视图集重写，则会显示以下消息：</p><pre class="oac_no_warn" dir="ltr">QSM-01127：使用物化视图，mv1，mv2和mv3重写的查询。
</pre><p>如果查询无法使用一组或多组给定的物化视图重写，那么<code class="codeph">EXPLAIN_REWRITE</code>将为未参与重写的每个物化视图输出失败的原因。
                        </p>
                     </div>
                  </div><a id="DWHSG8568"></a><div class="props_rev_3"><a id="GUID-4A5FD50D-E2AB-4176-BD1B-418E7B2491BB" name="GUID-4A5FD50D-E2AB-4176-BD1B-418E7B2491BB"></a><h5 id="DWHSG-GUID-4A5FD50D-E2AB-4176-BD1B-418E7B2491BB" class="sect5"><span class="enumeration_section">12.8.2.7</span>关于EXPLAIN_REWRITE输出</h5>
                     <div>
                        <p>某些示例显示如何使用<code class="codeph">EXPLAIN_REWRITE</code>包含在<code class="codeph">/rdbms/demo/smxrw.sql</code> 。demo <code class="codeph">xrw</code>区域中还包含一个名为<code class="codeph">SYS.XRW</code>的实用程序，可帮助您从<code class="codeph">EXPLAIN_REWRITE</code>过程中选择输出。当<code class="codeph">EXPLAIN_REWRITE</code>评估查询时，其输出包括诸如重写的查询文本，查询块编号和重写查询的成本等信息。实用程序<code class="codeph">SYS.XRW</code>以整齐格式化的方式输出用户指定的字段，以便可以轻松理解输出。语法如下：</p><pre class="oac_no_warn" dir="ltr">SYS.XRW（list_of_mvs，list_of_commands，query_text），</pre><p>其中<code class="codeph">list_of_mvs</code>是用户期望查询重写使用的物化视图。如果有多个物化视图，则必须用逗号分隔， <code class="codeph">list_of_commands</code>是以下字段之一：</p><pre class="oac_no_warn" dir="ltr">QUERY_TXT：用户查询文本REWRITTEN_TXT：重写的查询文本QUERY_BLOCK_NO：查询块编号以在查询具有子查询或内联视图时标识每个查询块PASS：Pass指示在查询重写的视图合并过程之前或之后是否生成给定消息。成本：成本表示原始查询和重写查询的估计执行成本</pre><p>以下示例说明了此实用程序的用法：</p><pre class="oac_no_warn" dir="ltr">DROP MATERIALIZED VIEW month_sales_mv; CREATE MATERIALIZED VIEW month_sales_mv ENABLE QUERY REWRITE AS SELECT t.calendar_month_number，SUM（s.amount_sold）AS sum_dollars FROM sales s，times t WHERE s.time_id = t.time_id GROUP BY t.calendar_month_number; SET SERVEROUTPUT ON DECLARE querytxt VARCHAR2（1500）：='SELECT t.calendar_month_number，SUM（s.amount_sold）AS sum_dollars FROM sales s，times t WHERE s.time_id = t.time_id GROUP BY t.calendar_month_number'; BEGIN SYS.XRW（'MONTH_SALES_MV'，'COSTS，PASS，REWRITTEN_TXT，QUERY_BLOCK_NO'，querytxt）;结束; /</pre><p>以下是<code class="codeph">SYS.XRW</code>的输出。从输出中可以看出， <code class="codeph">SYS.XRW</code>输出原始查询成本，重写成本，重写查询文本，查询块编号以及是否在视图合并过程之前或之后生成消息。
                        </p><pre class="oac_no_warn" dir="ltr">================================================== ========================== &gt;&gt;消息：QSM-01151：查询被重写&gt;&gt; RW QUERY：SELECT MONTH_SALES_MV.CALENDAR_MONTH_NUMBER CALENDAR_MONTH_NUMBER，MONTH_SALES_MV。 SUM_DOLLARS SUM_DOLLARS来自SH.MONTH_SALES_MV MONTH_SALES_MV &gt;&gt; ORIG成本：19.952763130792 RW成本：1.80687108 ================================= =========================================== &gt;&gt; ----- -------------------- QUERY REWRITE分析-------------------------&gt; &gt; &gt;&gt; QRY BLK＃：0 &gt;&gt;消息：QSM-01209：用物化视图MONTH_SALES_MV重写查询，使用文本匹配算法&gt;&gt; RW QUERY：SELECT MONTH_SALES_MV.CALENDAR_MONTH_NUMBER CALENDAR_MONTH_NUMBER，MONTH_SALES_MV.SUM_DOLLARS SUM_DOLLARS来自SH.MONTH_SALES_MV MONTH_SALES_MV &gt;&gt; ORIG COST：19.952763130792 RW成本：1.80687108 &gt;&gt;在观看之前的消息输出......============================消息结束=================== ============ PL / SQL过程成功完成。</pre></div>
                  </div>
               </div>
            </div><a id="DWHSG0806"></a><div class="props_rev_3"><a id="GUID-098C13EA-774C-49D9-8199-A8092BA7D437" name="GUID-098C13EA-774C-49D9-8199-A8092BA7D437"></a><h3 id="DWHSG-GUID-098C13EA-774C-49D9-8199-A8092BA7D437" class="sect3"><span class="enumeration_section">12.9</span>提高查询重写能力的设计注意事项</h3>
               <div>
                  <p>本节讨论有助于从查询重写中获得最大好处的设计注意事项。它们不是强制使用查询重写，如果您遵循它们，则无法保证重写。它们是要考虑的一般规则，如下：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="advanced-query-rewrite-materialized-views.html#GUID-63E9C200-ECCD-4498-8EEE-F744AA0F1249">查询重写注意事项：约束</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-query-rewrite-materialized-views.html#GUID-80545DAD-1A1C-44B3-9D81-D1CEC7C397EA">查询重写注意事项：维度</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-query-rewrite-materialized-views.html#GUID-7C1DD903-100F-4E7B-8333-DA9CEF5BA2FE">查询重写注意事项：外部联接</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-query-rewrite-materialized-views.html#GUID-62FBB3B4-D352-4A0E-AEF7-450421F8E2C1">查询重写注意事项：文本匹配</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-query-rewrite-materialized-views.html#GUID-FD786B39-80E0-4725-A974-8B18D3568919">查询重写注意事项：聚合</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-query-rewrite-materialized-views.html#GUID-B3149060-5313-450B-84CA-0199B62D2F13">查询重写注意事项：分组条件</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-query-rewrite-materialized-views.html#GUID-402A542B-BB8D-4113-A2CB-C1DAB9D3EDF6">查询重写注意事项：表达式匹配</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-query-rewrite-materialized-views.html#GUID-65FD33D7-DEBD-4164-B49F-514B5419480C">查询重写注意事项：日期折叠</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-query-rewrite-materialized-views.html#GUID-C576AD61-4EEA-4F52-9E2E-8A2185D898FA">查询重写注意事项：统计信息</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-query-rewrite-materialized-views.html#GUID-30951956-2D59-4543-B421-7FA078315C9F">查询重写注意事项：提示</a></p>
                     </li>
                  </ul>
               </div><a id="DWHSG8569"></a><div class="props_rev_3"><a id="GUID-63E9C200-ECCD-4498-8EEE-F744AA0F1249" name="GUID-63E9C200-ECCD-4498-8EEE-F744AA0F1249"></a><h4 id="DWHSG-GUID-63E9C200-ECCD-4498-8EEE-F744AA0F1249" class="sect4"><span class="enumeration_section">12.9.1</span>查询重写注意事项：约束</h4>
                  <div>
                     <p><a id="d44607e6899" class="indexterm-anchor"></a>确保在实例化视图中引用的所有内部联接都具有引用完整性（外键/主键约束），并在外键列上具有其他<code class="codeph">NOT</code> <code class="codeph">NULL</code>约束。由于约束往往会产生很大的开销，因此可以将它们设置为<code class="codeph">NO</code> <code class="codeph">VALIDATE</code>和<code class="codeph">RELY</code> ，并将参数<code class="codeph">QUERY_REWRITE_INTEGRITY</code>设置为<code class="codeph">STALE_TOLERATED</code>或<code class="codeph">TRUSTED</code> 。但是，如果将<code class="codeph">QUERY_REWRITE_INTEGRITY</code>设置为<code class="codeph">ENFORCED</code> ，则必须启用，强制和验证所有约束以获得最大可重写性。
                     </p>
                     <p>您应该避免使用<code class="codeph">ON</code> <code class="codeph">DELETE</code>子句，因为它可能导致意外的结果。
                     </p>
                  </div>
               </div><a id="DWHSG8570"></a><div class="props_rev_3"><a id="GUID-80545DAD-1A1C-44B3-9D81-D1CEC7C397EA" name="GUID-80545DAD-1A1C-44B3-9D81-D1CEC7C397EA"></a><h4 id="DWHSG-GUID-80545DAD-1A1C-44B3-9D81-D1CEC7C397EA" class="sect4"><span class="enumeration_section">12.9.2</span>查询重写注意事项：维度</h4>
                  <div>
                     <p><a id="d44607e6964" class="indexterm-anchor"></a>您可以使用维度的<code class="codeph">HIERARCHY</code>和<code class="codeph">DETERMINES</code>子句在规范化或非规范化维度表中表示层次关系和函数依赖关系。维度可以表达不能由约束表达的表内关系。将参数<code class="codeph">QUERY_REWRITE_INTEGRITY</code>设置为<code class="codeph">TRUSTED</code>或<code class="codeph">STALE_TOLERATED</code>以进行查询重写，以利用维度中声明的关系。
                     </p>
                  </div>
               </div><a id="DWHSG8571"></a><div class="props_rev_3"><a id="GUID-7C1DD903-100F-4E7B-8333-DA9CEF5BA2FE" name="GUID-7C1DD903-100F-4E7B-8333-DA9CEF5BA2FE"></a><h4 id="DWHSG-GUID-7C1DD903-100F-4E7B-8333-DA9CEF5BA2FE" class="sect4"><span class="enumeration_section">12.9.3</span>查询重写注意事项：外连接</h4>
                  <div>
                     <p><a id="d44607e7006" class="indexterm-anchor"></a>避免约束的另一种方法是在物化视图中使用外连接。查询重写将能够从物化视图中的外连接<code class="codeph">(Aa = Bb(+))</code>派生查询中的内连接，例如<code class="codeph">(Aa=Bb)</code> ，只要<code class="codeph">B</code>或<code class="codeph">Bb</code>的rowid是在物化视图中可用。大多数对具有外连接的重写的支持仅为具有连接的物化视图提供。要利用它，具有外连接的物化视图应存储外连接的内部表的rowid或主键。例如，物化视图<code class="codeph">join_sales_time_product_mv_oj</code>存储外连接的内部表的主键<code class="codeph">prod_id</code>和<code class="codeph">time_id</code> 。
                     </p>
                  </div>
               </div><a id="DWHSG8572"></a><div class="props_rev_3"><a id="GUID-62FBB3B4-D352-4A0E-AEF7-450421F8E2C1" name="GUID-62FBB3B4-D352-4A0E-AEF7-450421F8E2C1"></a><h4 id="DWHSG-GUID-62FBB3B4-D352-4A0E-AEF7-450421F8E2C1" class="sect4"><span class="enumeration_section">12.9.4</span>查询重写注意事项：文本匹配</h4>
                  <div>
                     <p><a id="d44607e7054" class="indexterm-anchor"></a>如果需要加速极其复杂，长时间运行的查询，可以使用查询的确切文本创建实体化视图。然后，物化视图将包含查询结果，从而消除执行任何复杂连接所需的时间，并搜索所需数据。
                     </p>
                  </div>
               </div><a id="DWHSG8573"></a><div class="props_rev_3"><a id="GUID-FD786B39-80E0-4725-A974-8B18D3568919" name="GUID-FD786B39-80E0-4725-A974-8B18D3568919"></a><h4 id="DWHSG-GUID-FD786B39-80E0-4725-A974-8B18D3568919" class="sect4"><span class="enumeration_section">12.9.5</span>查询重写注意事项：聚合</h4>
                  <div>
                     <p><a id="d44607e7080" class="indexterm-anchor"></a>要从查询重写中获得最大收益，请确保在物化视图中存在计算目标查询集中所需聚合所需的所有聚合。聚合的条件与增量刷新的条件非常相似。例如，如果<code class="codeph">AVG(x)</code>在查询中，那么您应该在物化视图中存储<code class="codeph">COUNT(x)</code>和<code class="codeph">AVG(x)</code>或存储<code class="codeph">SUM(x)</code>和<code class="codeph">COUNT(x)</code> 。有关快速刷新要求，请参阅<span class="q">“ <a href="basic-materialized-views.html#GUID-505C24CF-5D56-4820-88AA-2221410950E7">快速刷新的一般限制</a> ”</span> 。
                     </p>
                  </div>
               </div><a id="DWHSG8574"></a><div class="props_rev_3"><a id="GUID-B3149060-5313-450B-84CA-0199B62D2F13" name="GUID-B3149060-5313-450B-84CA-0199B62D2F13"></a><h4 id="DWHSG-GUID-B3149060-5313-450B-84CA-0199B62D2F13" class="sect4"><span class="enumeration_section">12.9.6</span>查询重写注意事项：分组条件</h4>
                  <div>
                     <p><a id="d44607e7126" class="indexterm-anchor"></a>在层次结构中较低级别聚合数据优于在较高级别聚合，因为较低级别可用于重写更多查询。但请注意，这样做也会占用更多空间。例如，不是在州上分组，而是在城市上分组（除非空间限制禁止它）。
                     </p>
                     <p>不是使用重叠或分层相关的<code class="codeph">GROUP</code> <code class="codeph">BY</code>列创建多个物化视图，而是使用所有<code class="codeph">GROUP</code> <code class="codeph">BY</code>列创建单个物化视图。例如，不使用按城市分组的物化视图和按月分组的其他物化视图，而是使用按城市和月份分组的单个物化视图。
                     </p>
                     <p>对与维度中的级别对应但不依赖于功能的列的列使用<code class="codeph">GROUP</code> <code class="codeph">BY</code> ，因为查询重写将能够基于维度中的<code class="codeph">DETERMINES</code>子句自动使用功能依赖性。例如，不是在<code class="codeph">prod_name</code>上进行分组，而是在<code class="codeph">prod_id</code>上进行<code class="codeph">prod_id</code> （只要存在指示属性<code class="codeph">prod_id</code>确定<code class="codeph">prod_name</code> ，就会启用重写涉及<code class="codeph">prod_name</code>的查询）。
                     </p>
                  </div>
               </div><a id="DWHSG8575"></a><div class="props_rev_3"><a id="GUID-402A542B-BB8D-4113-A2CB-C1DAB9D3EDF6" name="GUID-402A542B-BB8D-4113-A2CB-C1DAB9D3EDF6"></a><h4 id="DWHSG-GUID-402A542B-BB8D-4113-A2CB-C1DAB9D3EDF6" class="sect4"><span class="enumeration_section">12.9.7</span>查询重写注意事项：表达式匹配</h4>
                  <div>
                     <p>如果多个查询共享相同的公共子选择，则创建具有公共子选择作为其<code class="codeph">SELECT</code>列之一的物化视图是有利的。这样，可以跨多个查询获得由于公共子选择的预计算而导致的性能益处。
                     </p>
                  </div>
               </div><a id="DWHSG8576"></a><div class="props_rev_3"><a id="GUID-65FD33D7-DEBD-4164-B49F-514B5419480C" name="GUID-65FD33D7-DEBD-4164-B49F-514B5419480C"></a><h4 id="DWHSG-GUID-65FD33D7-DEBD-4164-B49F-514B5419480C" class="sect4"><span class="enumeration_section">12.9.8</span>查询重写注意事项：日期折叠</h4>
                  <div>
                     <p>创建通过折叠日期粒度（如月或季度或年份）聚合数据的物化视图时，请始终使用年份组件作为前缀，但不能使用后缀。例如， <code class="codeph">TO_CHAR</code> （ <code class="codeph">date_col</code> ， <code class="codeph">'yyyy-q'</code> ）将日期折叠为四分之一，按年份顺序整理，而<code class="codeph">TO_CHAR</code> （ <code class="codeph">date_col, 'q-yyyy'</code> ）将日期折叠为四分之一，按季度整理。前者保留了排序，而后者则没有。因此，任何没有年份前缀的物化视图都不符合日期折叠重写的条件。
                     </p>
                  </div>
               </div><a id="DWHSG8577"></a><div class="props_rev_3"><a id="GUID-C576AD61-4EEA-4F52-9E2E-8A2185D898FA" name="GUID-C576AD61-4EEA-4F52-9E2E-8A2185D898FA"></a><h4 id="DWHSG-GUID-C576AD61-4EEA-4F52-9E2E-8A2185D898FA" class="sect4"><span class="enumeration_section">12.9.9</span>查询重写注意事项：统计信息</h4>
                  <div>
                     <p><a id="d44607e7256" class="indexterm-anchor"></a>物化视图的优化基于成本，优化器需要物化视图和查询中的表的统计信息，以进行基于成本的选择。因此，物化视图应使用<code class="codeph">DBMS_STATS</code>包收集统计信息。
                     </p>
                  </div>
               </div><a id="DWHSG8578"></a><div class="props_rev_3"><a id="GUID-30951956-2D59-4543-B421-7FA078315C9F" name="GUID-30951956-2D59-4543-B421-7FA078315C9F"></a><h4 id="DWHSG-GUID-30951956-2D59-4543-B421-7FA078315C9F" class="sect4"><span class="enumeration_section">12.9.10</span>查询重写注意事项：提示</h4>
                  <div>
                     <p>本节讨论以下注意事项：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="advanced-query-rewrite-materialized-views.html#GUID-AB5DA1BA-C714-420F-B329-370D1E68EB82">查询重写：REWRITE和NOREWRITE提示</a></p>
                        </li>
                        <li>
                           <p><a href="advanced-query-rewrite-materialized-views.html#GUID-C535DD88-E429-47CE-8F9D-040ADA30261C">查询重写：REWRITE_OR_ERROR提示</a></p>
                        </li>
                        <li>
                           <p><a href="advanced-query-rewrite-materialized-views.html#GUID-BB34C03E-88FB-408A-8486-A8F2C9670C08">查询重写：多个物化视图重写提示</a></p>
                        </li>
                        <li>
                           <p><a href="advanced-query-rewrite-materialized-views.html#GUID-DF01D4B0-1E95-400B-9815-63725519E5F0">查询重写：EXPAND_GSET_TO_UNION提示</a></p>
                        </li>
                     </ul>
                  </div><a id="DWHSG8579"></a><div class="props_rev_3"><a id="GUID-AB5DA1BA-C714-420F-B329-370D1E68EB82" name="GUID-AB5DA1BA-C714-420F-B329-370D1E68EB82"></a><h5 id="DWHSG-GUID-AB5DA1BA-C714-420F-B329-370D1E68EB82" class="sect5"><span class="enumeration_section">12.9.10.1</span>查询重写：REWRITE和NOREWRITE提示</h5>
                     <div>
                        <p><a id="d44607e7326" class="indexterm-anchor"></a>您可以在SQL语句的<code class="codeph">SELECT</code>块中包含提示，以控制是否发生查询重写。使用<a id="d44607e7334" class="indexterm-anchor"></a><a id="d44607e7338" class="indexterm-anchor"></a><a id="d44607e7340" class="indexterm-anchor"></a><a id="d44607e7342" class="indexterm-anchor"></a><a id="d44607e7346" class="indexterm-anchor"></a><a id="d44607e7352" class="indexterm-anchor"></a><a id="d44607e7358" class="indexterm-anchor"></a><a id="d44607e7365" class="indexterm-anchor"></a>查询中的<code class="codeph">NOREWRITE</code>提示会阻止优化程序重写它。
                        </p>
                        <p><code class="codeph">REWRITE</code>提示<a id="d44607e7378" class="indexterm-anchor"></a><a id="d44607e7380" class="indexterm-anchor"></a>如果查询中没有参数，则强制优化器使用实例化视图（如果有）来重写它，而不管成本如何。如果对参数使用<code class="codeph">REWRITE(mv1,mv2,...)</code>提示，则强制重写以从指定的名称列表中选择最合适的物化视图。
                        </p>
                        <p>要防止重写，可以使用以下语句：</p><pre class="oac_no_warn" dir="ltr">SELECT / * + NOREWRITE * / p.prod_subcategory，SUM（s.amount_sold）FROM sales s，products p WHERE s.prod_id = p.prod_id GROUP BY p.prod_subcategory;</pre><p>要使用<code class="codeph">sum_sales_pscat_week_mv</code>强制重写（如果可以重写），请使用以下语句：</p><pre class="oac_no_warn" dir="ltr">SELECT / * + REWRITE（sum_sales_pscat_week_mv）* / p.prod_subcategory，SUM（s.amount_sold）FROM sales s，products p WHERE s.prod_id = p.prod_id GROUP BY p.prod_subcategory;</pre><p>请注意，重写提示的范围是查询块。如果SQL语句由多个查询块（ <code class="codeph">SELECT</code>子句）组成，则必须在每个查询块上指定重写提示以控制整个语句的重写。
                        </p>
                     </div>
                  </div><a id="DWHSG8580"></a><div class="props_rev_3"><a id="GUID-C535DD88-E429-47CE-8F9D-040ADA30261C" name="GUID-C535DD88-E429-47CE-8F9D-040ADA30261C"></a><h5 id="DWHSG-GUID-C535DD88-E429-47CE-8F9D-040ADA30261C" class="sect5"><span class="enumeration_section">12.9.10.2</span>查询重写：REWRITE_OR_ERROR提示</h5>
                     <div>
                        <p>运用<a id="d44607e7426" class="indexterm-anchor"></a><a id="d44607e7428" class="indexterm-anchor"></a>如果查询无法重写，查询中的<code class="codeph">REWRITE_OR_ERROR</code>提示会导致以下错误：</p><pre class="oac_no_warn" dir="ltr">ORA-30393：语句中的查询块未重写</pre><p>例如，当没有合适的物化视图供查询重写使用时，以下查询会发出ORA-30393错误：</p><pre class="oac_no_warn" dir="ltr">SELECT / * + REWRITE_OR_ERROR * / p.prod_subcategory，SUM（s.amount_sold）FROM sales s，products p WHERE s.prod_id = p.prod_id GROUP BY p.prod_subcategory;</pre></div>
                  </div><a id="DWHSG8581"></a><div class="props_rev_3"><a id="GUID-BB34C03E-88FB-408A-8486-A8F2C9670C08" name="GUID-BB34C03E-88FB-408A-8486-A8F2C9670C08"></a><h5 id="DWHSG-GUID-BB34C03E-88FB-408A-8486-A8F2C9670C08" class="sect5"><span class="enumeration_section">12.9.10.3</span>查询重写：多个物化视图重写提示</h5>
                     <div>
                        <p>使用多个物化视图时，有两个提示可以控制重写。<code class="codeph">NO_MULTIMV_REWRITE</code>提示可防止使用多个物化视图重写查询， <code class="codeph">NO_BASETABLE_MULTIMV_REWRITE</code>提示可防止使用物化视图和基表的组合重写查询。
                        </p>
                     </div>
                  </div><a id="DWHSG8582"></a><div class="props_rev_3"><a id="GUID-DF01D4B0-1E95-400B-9815-63725519E5F0" name="GUID-DF01D4B0-1E95-400B-9815-63725519E5F0"></a><h5 id="DWHSG-GUID-DF01D4B0-1E95-400B-9815-63725519E5F0" class="sect5"><span class="enumeration_section">12.9.10.4</span>查询重写：EXPAND_GSET_TO_UNION提示</h5>
                     <div>
                        <p>你可以使用<a id="d44607e7493" class="indexterm-anchor"></a><a id="d44607e7497" class="indexterm-anchor"></a> <code class="codeph">EXPAND_GSET_TO_UNION</code>提示强制将<code class="codeph">GROUP</code> <code class="codeph">BY</code>扩展的查询扩展为等效的<code class="codeph">UNION</code> <code class="codeph">ALL</code>查询。有关详细信息，请参阅<span class="q">“ <a href="advanced-query-rewrite-materialized-views.html#GUID-05CFC633-105D-45AB-97A0-805AEC29BFFF">使用扩展GROUP BY重写查询的提示</a> ”</span> 。
                        </p>
                     </div>
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>