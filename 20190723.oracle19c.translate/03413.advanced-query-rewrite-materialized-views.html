<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html xml:lang="en-us" lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <title>Advanced Query Rewrite for Materialized Views</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="Data Warehousing Guide">
      <meta property="og:description" content="">
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="Data Warehousing Guide">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="database-data-warehousing-guide.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2019-01-09T00:20:13-08:00">
      
      <meta name="dcterms.dateCopyrighted" content="2001, 2019">
      <meta name="dcterms.category" content="database">
      <meta name="dcterms.identifier" content="E96243-01">
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19">
      
      <link rel="prev" href="basic-query-rewrite-materialized-views.html" title="Previous" type="text/html">
      <link rel="next" href="attribute-clustering.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Database Data Warehousing Guide">
    <meta name="dcterms.isVersionOf" content="DWHSG">
    <meta name="dcterms.release" content="Release 19">
  </head>
   <body>
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="basic-query-rewrite-materialized-views.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>Previous</a>
         <a href="attribute-clustering.html" class="pull-right">Next<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a>
         <span class="fa fa-exclamation-triangle" aria-hidden="true"></span> JavaScript must be enabled to correctly display this content
        
      </div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">Data Warehousing Guide</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="part-optimizing-dw.html" property="item" typeof="WebPage"><span property="name">Optimizing Data Warehouses</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">Advanced Query Rewrite for Materialized Views</li>
            </ol>
            <a id="GUID-0906CA6B-7EE3-42E1-A598-C6541BCD9B36" name="GUID-0906CA6B-7EE3-42E1-A598-C6541BCD9B36"></a>
            
            <h2 id="DWHSG-GUID-0906CA6B-7EE3-42E1-A598-C6541BCD9B36" class="sect2"><span class="enumeration_chapter">12 </span>Advanced Query Rewrite for Materialized Views
            </h2>
         </header>
         <div class="ind">
            <div>
               <p>This chapter discusses advanced query rewrite topics in Oracle, and contains:</p>
               <ul style="list-style-type: disc;">
                  <li>
                     <p><a href="advanced-query-rewrite-materialized-views.html#GUID-A8988A2F-DA65-4AB6-86ED-6C838B84DCE9">How Oracle Rewrites Queries</a></p>
                  </li>
                  <li>
                     <p><a href="advanced-query-rewrite-materialized-views.html#GUID-5297DA70-0064-4EA4-B492-E45089E5074F">Types of Query Rewrite</a></p>
                  </li>
                  <li>
                     <p><a href="advanced-query-rewrite-materialized-views.html#GUID-96BFEEAA-1C8A-4F8A-9EAF-6CDD9B148EA6" title="Query rewrite considers external partitions in a hybrid partitioned table to be of UNKNOWN freshness. Therefore, when a query requests data from one or more external partitions, it can only be rewritten under TRUSTED or STALE_TOLERATED integrity mode.">Other Query Rewrite Considerations</a></p>
                  </li>
                  <li>
                     <p><a href="advanced-query-rewrite-materialized-views.html#GUID-94D148DC-1E2A-4791-A7B6-28F9BF0306C1">Advanced Query Rewrite Using Equivalences</a></p>
                  </li>
                  <li>
                     <p><a href="advanced-query-rewrite-materialized-views.html#GUID-71197259-E8A4-45E5-A462-A9ADF6517CD6">Creating Result Cache Materialized Views with Equivalences</a></p>
                  </li>
                  <li>
                     <p><a href="advanced-query-rewrite-materialized-views.html#GUID-41A13A98-E51A-435A-973E-05CC083F2CFC" title="Queries containing SQL functions that return approximate results are automatically rewritten to use a matching materialized view, if these queries can be answered using the materialized view.">Query Rewrite and Materialized Views Based on Approximate Queries</a></p>
                  </li>
                  <li>
                     <p><a href="advanced-query-rewrite-materialized-views.html#GUID-3AB77341-BDA9-4F84-9691-EB79E4C8B832">Verifying that Query Rewrite has Occurred</a></p>
                  </li>
                  <li>
                     <p><a href="advanced-query-rewrite-materialized-views.html#GUID-098C13EA-774C-49D9-8199-A8092BA7D437">Design Considerations for Improving Query Rewrite Capabilities</a></p>
                  </li>
               </ul>
            </div><a id="DWHSG0801"></a><div class="props_rev_3"><a id="GUID-A8988A2F-DA65-4AB6-86ED-6C838B84DCE9" name="GUID-A8988A2F-DA65-4AB6-86ED-6C838B84DCE9"></a><h3 id="DWHSG-GUID-A8988A2F-DA65-4AB6-86ED-6C838B84DCE9" class="sect3"><span class="enumeration_section">12.1 </span>How Oracle Rewrites Queries
               </h3>
               <div>
                  <p><a id="d44607e92" class="indexterm-anchor"></a>The optimizer uses a number of different methods to rewrite a query. The first step in determining whether query rewrite is possible is to see if the query satisfies the following prerequisites:
                  </p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>Joins present in the materialized view are present in the SQL.</p>
                     </li>
                     <li>
                        <p>There is sufficient data in the materialized view(s) to answer the query.</p>
                     </li>
                  </ul>
                  <p>After that, it must determine how it will rewrite the query. The simplest case occurs when the result stored in a materialized view exactly matches what is requested by a query. The optimizer makes this type of determination by comparing the text of the query with the text of the materialized view definition. This text match method is most straightforward but the number of queries eligible for this type of query rewrite is minimal.</p>
                  <p>When the text comparison test fails, the optimizer performs a series of generalized checks based on the joins, selections, grouping, aggregates, and column data fetched. This is accomplished by individually comparing various clauses (<code class="codeph">SELECT</code>, <code class="codeph">FROM</code>, <code class="codeph">WHERE</code>, <code class="codeph">HAVING</code>, or <code class="codeph">GROUP</code> <code class="codeph">BY</code>) of a query with those of a materialized view.
                  </p>
                  <p>You can use the following types of query rewrite: <a href="advanced-query-rewrite-materialized-views.html#GUID-A95A5C58-B011-44FF-B5CB-EE4FDEE032D5">Query Rewrite Method 1: Text Match Rewrite</a> or <a href="advanced-query-rewrite-materialized-views.html#GUID-14503E5A-F841-4568-B1E7-79ED1C3718A2">General Query Rewrite Methods</a>.
                  </p>
                  <p>This following topics discuss the optimizer in more detail:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="advanced-query-rewrite-materialized-views.html#GUID-5780D6A4-2675-4C4B-9DE9-80A3FE89BC1B">About Cost-Based Optimization and Query Rewrite</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-query-rewrite-materialized-views.html#GUID-14503E5A-F841-4568-B1E7-79ED1C3718A2">General Query Rewrite Methods</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-query-rewrite-materialized-views.html#GUID-AF8326B6-DADD-4893-85DB-7456A3DC2756">About Checks Made by Query Rewrite</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-query-rewrite-materialized-views.html#GUID-9279E302-ECD5-4316-B0AC-493507C7F7F2">About Query Rewrite Using Dimensions</a></p>
                     </li>
                  </ul>
               </div><a id="DWHSG8499"></a><a id="DWHSG08011"></a><div class="props_rev_3"><a id="GUID-5780D6A4-2675-4C4B-9DE9-80A3FE89BC1B" name="GUID-5780D6A4-2675-4C4B-9DE9-80A3FE89BC1B"></a><h4 id="DWHSG-GUID-5780D6A4-2675-4C4B-9DE9-80A3FE89BC1B" class="sect4"><span class="enumeration_section">12.1.1 </span>About Cost-Based Optimization and Query Rewrite
                  </h4>
                  <div>
                     <p>When a query is rewritten, Oracle's cost-based optimizer compares the cost of the rewritten query and original query and chooses the cheaper execution plan.</p>
                     <p><a id="d44607e184" class="indexterm-anchor"></a>Query rewrite is available with cost-based optimization. Oracle Database optimizes the input query with and without rewrite and selects the least costly alternative. The optimizer rewrites a query by rewriting one or more query blocks, one at a time.
                     </p>
                     <p>If query rewrite has a choice between several materialized views to rewrite a query block, it selects the ones which can result in reading in the least amount of data. After a materialized view has been selected for a rewrite, the optimizer then tests whether the rewritten query can be rewritten further with other materialized views. This process continues until no further rewrites are possible. Then the rewritten query is optimized and the original query is optimized. The optimizer compares these two optimizations and selects the least costly alternative.</p>
                     <p>Because optimization is based on cost, it is important to collect statistics both on tables involved in the query and on the tables representing materialized views. Statistics are fundamental measures, such as the number of rows in a table, that are used to calculate the cost of a rewritten query. They are created by using the <code class="codeph">DBMS_STATS</code> package.
                     </p>
                     <p>Queries that contain inline or named views are also candidates for query rewrite. When a query contains a named view, the view name is used to do the matching between a materialized view and the query. When a query contains an inline view, the inline view can be merged into the query before matching between a materialized view and the query occurs.</p>
                     <p><a href="advanced-query-rewrite-materialized-views.html#GUID-5780D6A4-2675-4C4B-9DE9-80A3FE89BC1B__I1006234">Figure 12-1</a> presents a graphical view of the cost-based approach used during the rewrite process.
                     </p>
                     <div class="figure" id="GUID-5780D6A4-2675-4C4B-9DE9-80A3FE89BC1B__I1006234">
                        <p class="titleinfigure">Figure 12-1 The Query Rewrite Process</p><img src="img/dwhsg017.gif" alt="Description of Figure 12-1 follows" title="Description of Figure 12-1 follows" longdesc="img_text/dwhsg017.html"><br><a href="img_text/dwhsg017.html">Description of "Figure 12-1 The Query Rewrite Process"</a></div>
                     <!-- class="figure" -->
                  </div>
               </div><a id="DWHSG08012"></a><div class="props_rev_3"><a id="GUID-14503E5A-F841-4568-B1E7-79ED1C3718A2" name="GUID-14503E5A-F841-4568-B1E7-79ED1C3718A2"></a><h4 id="DWHSG-GUID-14503E5A-F841-4568-B1E7-79ED1C3718A2" class="sect4"><span class="enumeration_section">12.1.2 </span>General Query Rewrite Methods
                  </h4>
                  <div>
                     <p>The optimizer has a number of different types of query rewrite methods that it can choose from to answer a query. When text match rewrite is not possible, this group of rewrite methods is known as general query rewrite. The advantage of using these more advanced techniques is that one or more materialized views can be used to answer a number of different queries and the query does not always have to match the materialized view exactly for query rewrite to occur.</p>
                     <p>When using general query rewrite methods, the optimizer uses data relationships on which it can depend, such as primary and foreign key constraints and dimension objects. For example, primary key and foreign key relationships tell the optimizer that each row in the foreign key table joins with at most one row in the primary key table. Furthermore, if there is a <code class="codeph">NOT</code> <code class="codeph">NULL</code> constraint on the foreign key, it indicates that each row in the foreign key table must join to exactly one row in the primary key table. A dimension object describes the relationship between, say, day, months, and year, which can be used to roll up data from the day to the month level.
                     </p>
                     <p>Data relationships such as these are very important for query rewrite because they tell what type of result is produced by joins, grouping, or aggregation of data. Therefore, to maximize the rewritability of a large set of queries when such data relationships exist in a database, you should declare constraints and dimensions.</p>
                     <div class="infoboxnotealso" id="GUID-14503E5A-F841-4568-B1E7-79ED1C3718A2__GUID-5E753C50-9979-4D16-B304-1EDFEB937903">
                        <p class="notep1">See Also:</p>
                        <p><a href="advanced-query-rewrite-materialized-views.html#GUID-00BE44C0-6DC0-4C74-B50D-B5C67E8170BB">When are Constraints and Dimensions Needed for Query Rewrite?</a></p>
                     </div>
                  </div><a id="DWHSG8501"></a><a id="DWHSG8500"></a><div class="props_rev_3"><a id="GUID-00BE44C0-6DC0-4C74-B50D-B5C67E8170BB" name="GUID-00BE44C0-6DC0-4C74-B50D-B5C67E8170BB"></a><h5 id="DWHSG-GUID-00BE44C0-6DC0-4C74-B50D-B5C67E8170BB" class="sect5"><span class="enumeration_section">12.1.2.1 </span>When are Constraints and Dimensions Needed for Query Rewrite?
                     </h5>
                     <div>
                        <p><a href="advanced-query-rewrite-materialized-views.html#GUID-00BE44C0-6DC0-4C74-B50D-B5C67E8170BB__g1021681" title="Dimension and Constraint Requirements for Query Rewrite">Table 12-1</a> illustrates when dimensions and constraints are required for different types of query rewrite. These types of query rewrite are described throughout this chapter.
                        </p>
                        <div class="tblformal" id="GUID-00BE44C0-6DC0-4C74-B50D-B5C67E8170BB__g1021681">
                           <p class="titleintable">Table 12-1 Dimension and Constraint Requirements for Query Rewrite</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="Dimension and Constraint Requirements for Query Rewrite" summary="Dimension and Constraint Requirements for Query Rewrite" width="100%" frame="hsides" border="1" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="31%" id="d44607e279">Query Rewrite Types</th>
                                    <th align="left" valign="bottom" width="22%" id="d44607e282">Dimensions</th>
                                    <th align="left" valign="bottom" width="48%" id="d44607e285">Primary Key/Foreign Key/Not Null Constraints</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d44607e290" headers="d44607e279 ">
                                       <p>Matching SQL Text</p>
                                    </td>
                                    <td align="left" valign="top" width="22%" headers="d44607e290 d44607e282 ">
                                       <p>Not Required</p>
                                    </td>
                                    <td align="left" valign="top" width="48%" headers="d44607e290 d44607e285 ">
                                       <p>Not Required</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d44607e300" headers="d44607e279 ">
                                       <p>Join Back</p>
                                    </td>
                                    <td align="left" valign="top" width="22%" headers="d44607e300 d44607e282 ">
                                       <p>Required          OR </p>
                                    </td>
                                    <td align="left" valign="top" width="48%" headers="d44607e300 d44607e285 ">
                                       <p>Required</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d44607e310" headers="d44607e279 ">
                                       <p>Aggregate Computability</p>
                                    </td>
                                    <td align="left" valign="top" width="22%" headers="d44607e310 d44607e282 ">
                                       <p>Not Required</p>
                                    </td>
                                    <td align="left" valign="top" width="48%" headers="d44607e310 d44607e285 ">
                                       <p>Not Required</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d44607e320" headers="d44607e279 ">
                                       <p>Aggregate Rollup</p>
                                    </td>
                                    <td align="left" valign="top" width="22%" headers="d44607e320 d44607e282 ">
                                       <p>Not Required</p>
                                    </td>
                                    <td align="left" valign="top" width="48%" headers="d44607e320 d44607e285 ">
                                       <p>Not Required</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d44607e330" headers="d44607e279 ">
                                       <p>Rollup Using a Dimension</p>
                                    </td>
                                    <td align="left" valign="top" width="22%" headers="d44607e330 d44607e282 ">
                                       <p>Required</p>
                                    </td>
                                    <td align="left" valign="top" width="48%" headers="d44607e330 d44607e285 ">
                                       <p>Not Required</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d44607e340" headers="d44607e279 ">
                                       <p>Filtering the Data</p>
                                    </td>
                                    <td align="left" valign="top" width="22%" headers="d44607e340 d44607e282 ">
                                       <p>Not Required</p>
                                    </td>
                                    <td align="left" valign="top" width="48%" headers="d44607e340 d44607e285 ">
                                       <p>Not Required</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d44607e350" headers="d44607e279 ">
                                       <p>PCT Rewrite</p>
                                    </td>
                                    <td align="left" valign="top" width="22%" headers="d44607e350 d44607e282 ">
                                       <p>Not Required</p>
                                    </td>
                                    <td align="left" valign="top" width="48%" headers="d44607e350 d44607e285 ">
                                       <p>Not Required</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d44607e360" headers="d44607e279 ">
                                       <p>Multiple Materialized Views</p>
                                    </td>
                                    <td align="left" valign="top" width="22%" headers="d44607e360 d44607e282 ">
                                       <p>Not Required</p>
                                    </td>
                                    <td align="left" valign="top" width="48%" headers="d44607e360 d44607e285 ">
                                       <p>Not Required</p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                     </div>
                  </div>
               </div><a id="DWHSG08013"></a><div class="props_rev_3"><a id="GUID-AF8326B6-DADD-4893-85DB-7456A3DC2756" name="GUID-AF8326B6-DADD-4893-85DB-7456A3DC2756"></a><h4 id="DWHSG-GUID-AF8326B6-DADD-4893-85DB-7456A3DC2756" class="sect4"><span class="enumeration_section">12.1.3 </span>About Checks Made by Query Rewrite
                  </h4>
                  <div>
                     <p>For query<a id="d44607e392" class="indexterm-anchor"></a> rewrite to occur, there are a number of checks that the data must pass. These checks are:
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="advanced-query-rewrite-materialized-views.html#GUID-CDDBBA45-FB35-481B-9CC9-8E049B40B8AB">Join Compatibility Check for Query Rewrite</a></p>
                        </li>
                        <li>
                           <p><a href="advanced-query-rewrite-materialized-views.html#GUID-5D05C98E-4020-4634-AC3E-9B24AF38893E">Data Sufficiency Check for Query Rewrite</a></p>
                        </li>
                        <li>
                           <p><a href="advanced-query-rewrite-materialized-views.html#GUID-9A52FD90-681E-40B6-9DBE-F0D338380BE4">Grouping Compatibility Check for Query Rewrite</a></p>
                        </li>
                        <li>
                           <p><a href="advanced-query-rewrite-materialized-views.html#GUID-E0156059-DF92-4302-80D3-C6C066130B3E">Aggregate Computability Check for Query Rewrite</a></p>
                        </li>
                     </ul>
                  </div><a id="DWHSG8503"></a><a id="DWHSG8502"></a><div class="props_rev_3"><a id="GUID-CDDBBA45-FB35-481B-9CC9-8E049B40B8AB" name="GUID-CDDBBA45-FB35-481B-9CC9-8E049B40B8AB"></a><h5 id="DWHSG-GUID-CDDBBA45-FB35-481B-9CC9-8E049B40B8AB" class="sect5"><span class="enumeration_section">12.1.3.1 </span>Join Compatibility Check for Query Rewrite
                     </h5>
                     <div>
                        <p><a id="d44607e440" class="indexterm-anchor"></a>In this check, the joins in a query are compared against the joins in a materialized view. In general, this comparison results in the classification of joins into three categories:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Common joins that occur in both the query and the materialized view. These joins form the common subgraph.</p>
                              <p>See <a href="advanced-query-rewrite-materialized-views.html#GUID-C4AA632B-09EE-4A67-95B4-D6DD7B18950A">Common Joins</a>.
                              </p>
                           </li>
                           <li>
                              <p>Delta joins that occur in the query but not in the materialized view. These joins form the query delta subgraph.</p>
                              <p>See <a href="advanced-query-rewrite-materialized-views.html#GUID-B8FC3ACE-11D3-404D-9C32-FFF9AEC945A7">Query Delta Joins</a>.
                              </p>
                           </li>
                           <li>
                              <p>Delta joins that occur in the materialized view but not in the query. These joins form the materialized view delta subgraph.</p>
                              <p>See <a href="advanced-query-rewrite-materialized-views.html#GUID-FB70D563-A1E9-4B15-B9AF-AAE736DAD8CD">Materialized View Delta Joins</a>.
                              </p>
                           </li>
                        </ul>
                        <p>These can be visualized as shown in <a href="advanced-query-rewrite-materialized-views.html#GUID-CDDBBA45-FB35-481B-9CC9-8E049B40B8AB__CHDDIIEJ">Figure 12-2</a>.
                        </p>
                        <div class="figure" id="GUID-CDDBBA45-FB35-481B-9CC9-8E049B40B8AB__CHDDIIEJ">
                           <p class="titleinfigure">Figure 12-2 Query Rewrite Subgraphs</p><img src="img/dwhsg016.gif" alt="Description of Figure 12-2 follows" title="Description of Figure 12-2 follows" longdesc="img_text/dwhsg016.html"><br><a href="img_text/dwhsg016.html">Description of "Figure 12-2 Query Rewrite Subgraphs"</a></div>
                        <!-- class="figure" -->
                        <div class="infoboxnotealso" id="GUID-CDDBBA45-FB35-481B-9CC9-8E049B40B8AB__GUID-4AC10C11-EB92-4E60-BF1B-914CEEF4F289">
                           <p class="notep1">See Also:</p>
                           <p><a href="advanced-query-rewrite-materialized-views.html#GUID-AF8326B6-DADD-4893-85DB-7456A3DC2756">About Checks Made by Query Rewrite</a></p>
                        </div>
                     </div>
                     <div class="props_rev_3"><a id="GUID-C4AA632B-09EE-4A67-95B4-D6DD7B18950A" name="GUID-C4AA632B-09EE-4A67-95B4-D6DD7B18950A"></a><h6 id="DWHSG-GUID-C4AA632B-09EE-4A67-95B4-D6DD7B18950A" class="sect6"><span class="enumeration_section">12.1.3.1.1 </span>Common Joins
                        </h6>
                        <div>
                           <p>The <a id="d44607e506" class="indexterm-anchor"></a>common join pairs between the two must be of the same type, or the join in the query must be derivable from the join in the materialized view. For example, if a materialized view contains an outer join of table <code class="codeph">A</code> with table <code class="codeph">B</code>, and a query contains an inner join of table <code class="codeph">A</code> with table <code class="codeph">B</code>, the result of the inner join can be derived by filtering the antijoin rows from the result of the outer join. For example, consider the following query:
                           </p><pre class="oac_no_warn" dir="ltr">SELECT p.prod_name, t.week_ending_day, SUM(s.amount_sold)
FROM   sales s, products p, times t
WHERE  s.time_id=t.time_id AND s.prod_id = p.prod_id
AND mv.week_ending_day BETWEEN TO_DATE('01-AUG-1999', 'DD-MON-YYYY')
                          AND TO_DATE('10-AUG-1999', 'DD-MON-YYYY')
GROUP BY p.prod_name, mv.week_ending_day;
</pre><p>The common joins between this query and the materialized view <code class="codeph">join_sales_time_product_mv</code> are: 
                           </p><pre class="oac_no_warn" dir="ltr">s.time_id = t.time_id AND s.prod_id = p.prod_id
 </pre><p>They match exactly and the query can be rewritten as follows:</p><pre class="oac_no_warn" dir="ltr">SELECT p.prod_name, mv.week_ending_day, SUM(s.amount_sold)
FROM   join_sales_time_product_mv
WHERE  mv.week_ending_day BETWEEN TO_DATE('01-AUG-1999','DD-MON-YYYY')
                         AND   TO_DATE('10-AUG-1999','DD-MON-YYYY')
GROUP BY mv.prod_name, mv.week_ending_day;
</pre><p>The query could also be answered using the <code class="codeph">join_sales_time_product_oj_mv</code> materialized view where inner joins in the query can be derived from outer joins in the materialized view. The rewritten version (transparently to the user) filters out the antijoin rows. The rewritten query has the following structure:
                           </p><pre class="oac_no_warn" dir="ltr">SELECT mv.prod_name, mv.week_ending_day, SUM(mv.amount_sold)
FROM   join_sales_time_product_oj_mv mv
WHERE  mv.week_ending_day BETWEEN TO_DATE('01-AUG-1999','DD-MON-YYYY')
  AND  TO_DATE('10-AUG-1999','DD-MON-YYYY') AND mv.prod_id IS NOT NULL
GROUP BY mv.prod_name, mv.week_ending_day;
</pre><p>In general, if you use an outer join in a materialized view containing only joins, you should put in the materialized view either the primary key or the rowid on the right side of the outer join. For example, in the previous example, <code class="codeph">join_sales_time_product_oj_mv</code>, there is a primary key on both <code class="codeph">sales</code> and <code class="codeph">products</code>.
                           </p>
                           <p>Another example of when a materialized view containing only joins is used is the case of a semijoin rewrites. That is, a query contains either an <code class="codeph">EXISTS</code> or an <code class="codeph">IN</code> subquery with a single table. Consider the following query, which reports the products that had sales greater than $1,000:
                           </p><pre class="oac_no_warn" dir="ltr">SELECT DISTINCT p.prod_name
FROM products p
WHERE EXISTS (SELECT p.prod_id, SUM(s.amount_sold) FROM sales s
              WHERE p.prod_id=s.prod_id HAVING SUM(s.amount_sold) &gt; 1000)
              GROUP BY p.prod_id);
</pre><p>This query could also be represented as:</p><pre class="oac_no_warn" dir="ltr">SELECT DISTINCT p.prod_name
FROM products p WHERE p.prod_id IN (SELECT s.prod_id FROM sales s
                    WHERE s.amount_sold &gt; 1000);
</pre><p>This query contains a semijoin (<code class="codeph">s.prod_id = p.prod_id</code>) between the <code class="codeph">products</code> and the <code class="codeph">sales</code> table.
                           </p>
                           <p>This query can be rewritten to use either the <code class="codeph">join_sales_time_product_mv</code> materialized view, if foreign key constraints are active or <code class="codeph">join_sales_time_product_oj_mv</code> materialized view, if primary keys are active. Observe that both materialized views contain <code class="codeph">s.prod_id=p.prod_id</code>, which can be used to derive the semijoin in the query. The query is rewritten with <code class="codeph">join_sales_time_product_mv</code> as follows:
                           </p><pre class="oac_no_warn" dir="ltr">SELECT mv.prod_name
FROM (SELECT DISTINCT mv.prod_name FROM  join_sales_time_product_mv mv
      WHERE mv.amount_sold &gt; 1000);
</pre><p>If the materialized view <code class="codeph">join_sales_time_product_mv</code> is partitioned by <code class="codeph">time_id</code>, then this query is likely to be more efficient than the original query because the original join between <code class="codeph">sales</code> and <code class="codeph">products</code> has been avoided. The query could be rewritten using <code class="codeph">join_sales_time_product_oj_mv</code> as follows.
                           </p><pre class="oac_no_warn" dir="ltr">SELECT mv.prod_name 
FROM (SELECT DISTINCT mv.prod_name FROM join_sales_time_product_oj_mv mv
      WHERE mv.amount_sold &gt; 1000 AND mv.prod_id IS NOT NULL);
</pre><p>Rewrites with semi-joins are restricted to materialized views with joins only and are not possible for materialized views with joins and aggregates.</p>
                           <div class="infoboxnotealso" id="GUID-C4AA632B-09EE-4A67-95B4-D6DD7B18950A__GUID-6BD3E1F2-1383-4F1A-BF69-FEB38F308745">
                              <p class="notep1">See Also:</p>
                              <p><a href="advanced-query-rewrite-materialized-views.html#GUID-AF8326B6-DADD-4893-85DB-7456A3DC2756">About Checks Made by Query Rewrite</a></p>
                           </div>
                        </div>
                     </div><a id="DWHSG8505"></a><div class="props_rev_3"><a id="GUID-B8FC3ACE-11D3-404D-9C32-FFF9AEC945A7" name="GUID-B8FC3ACE-11D3-404D-9C32-FFF9AEC945A7"></a><h6 id="DWHSG-GUID-B8FC3ACE-11D3-404D-9C32-FFF9AEC945A7" class="sect6"><span class="enumeration_section">12.1.3.1.2 </span>Query Delta Joins
                        </h6>
                        <div>
                           <p>A <span class="bold">query</span> <span class="bold">delta</span> <span class="bold">join</span> is a join that appears in the query but not in the materialized view. Any number and type of delta joins in a query are allowed and they are simply retained when the query is rewritten with a materialized view. In order for the retained join to work, the materialized view must contain the joining key. Upon rewrite, the materialized view is joined to the appropriate tables in the query delta. For example, consider the following query:
                           </p><pre class="oac_no_warn" dir="ltr">SELECT p.prod_name, t.week_ending_day, c.cust_city, SUM(s.amount_sold)
FROM   sales s, products p, times t, customers c
WHERE  s.time_id=t.time_id AND s.prod_id = p.prod_id
AND    s.cust_id = c.cust_id
GROUP BY p.prod_name, t.week_ending_day, c.cust_city;
</pre><p>Using the materialized view <code class="codeph">join_sales_time_product_mv</code>, common joins are: <code class="codeph">s.time_id=t.time_id</code> and <code class="codeph">s.prod_id=p.prod_id</code>. The delta join in the query is <code class="codeph">s.cust_id=c.cust_id</code>. The rewritten form then joins the <code class="codeph">join_sales_time_product_mv</code> materialized view with the <code class="codeph">customers</code> table as follows:
                           </p><pre class="oac_no_warn" dir="ltr">SELECT mv.prod_name, mv.week_ending_day, c.cust_city, SUM(mv.amount_sold)
FROM   join_sales_time_product_mv mv, customers c
WHERE  mv.cust_id = c.cust_id
GROUP BY mv.prod_name, mv.week_ending_day, c.cust_city;</pre><div class="infoboxnotealso" id="GUID-B8FC3ACE-11D3-404D-9C32-FFF9AEC945A7__GUID-C7B41779-AF2C-476C-85F4-3C6C4D8BD55D">
                              <p class="notep1">See Also:</p>
                              <p><a href="advanced-query-rewrite-materialized-views.html#GUID-AF8326B6-DADD-4893-85DB-7456A3DC2756">About Checks Made by Query Rewrite</a></p>
                           </div>
                        </div>
                     </div><a id="DWHSG8506"></a><div class="props_rev_3"><a id="GUID-FB70D563-A1E9-4B15-B9AF-AAE736DAD8CD" name="GUID-FB70D563-A1E9-4B15-B9AF-AAE736DAD8CD"></a><h6 id="DWHSG-GUID-FB70D563-A1E9-4B15-B9AF-AAE736DAD8CD" class="sect6"><span class="enumeration_section">12.1.3.1.3 </span>Materialized View Delta Joins
                        </h6>
                        <div>
                           <p>A <span class="bold">materialized</span> <span class="bold">view</span> <span class="bold">delta</span> <span class="bold">join</span> is a join that appears in the materialized view but not the query. All de<a id="d44607e720" class="indexterm-anchor"></a>lta joins in a materialized view are required to be lossless with respect to the result of common joins. A lossless join guarantees that the result of common joins is not restricted. A <span class="bold">lossless</span> join is one where, if two tables called <code class="codeph">A</code> and <code class="codeph">B</code> are joined together, rows in table <code class="codeph">A</code> will always match with rows in table <code class="codeph">B</code> and no data will be lost, hence the term lossless join. For example, every row with the foreign key matches a row with a primary key provided no nulls are allowed in the foreign key. Therefore, to guarantee a lossless join, it is necessary to have <code class="codeph">FOREIGN</code> <code class="codeph">KEY</code>, <code class="codeph">PRIMARY</code> <code class="codeph">KEY</code>, and <code class="codeph">NOT</code> <code class="codeph">NULL</code> constraints on appropriate join keys. Alternatively, if the join between tables <code class="codeph">A</code> and <code class="codeph">B</code> is an outer join (<code class="codeph">A</code> being the outer table), it is lossless as it preserves all rows of table <code class="codeph">A</code>.
                           </p>
                           <p>All delta joins in a materialized view are required to be non-duplicating with respect to the result of common joins. A non-duplicating join guarantees that the result of common joins is not duplicated. For example, a non-duplicating join is one where, if table <code class="codeph">A</code> and table <code class="codeph">B</code> are joined together, rows in table <code class="codeph">A</code> will match with at most one row in table <code class="codeph">B</code> and no duplication occurs. To guarantee a non-duplicating join, the key in table <code class="codeph">B</code> must be constrained to unique values by using a primary key or unique constraint.
                           </p>
                           <p>Consider the following query that joins <code class="codeph">sales</code> and <code class="codeph">times</code>:
                           </p><pre class="oac_no_warn" dir="ltr">SELECT t.week_ending_day, SUM(s.amount_sold)
FROM   sales s, times t
WHERE s.time_id = t.time_id AND t.week_ending_day BETWEEN TO_DATE
 ('01-AUG-1999', 'DD-MON-YYYY') AND TO_DATE('10-AUG-1999', 'DD-MON-YYYY')
GROUP BY week_ending_day;
</pre><p>The materialized view <code class="codeph">join_sales_time_product_mv</code> has an additional join (<code class="codeph">s.prod_id=p.prod_id</code>) between <code class="codeph">sales</code> and <code class="codeph">products</code>. This is the delta join in <code class="codeph">join_sales_time_product_mv</code>. You can rewrite the query if this join is lossless and non-duplicating. This is the case if <code class="codeph">s.prod_id</code> is a foreign key to <code class="codeph">p.prod_id</code> and is not null. The query is therefore rewritten as: 
                           </p><pre class="oac_no_warn" dir="ltr">SELECT week_ending_day, SUM(amount_sold)
FROM   join_sales_time_product_mv
WHERE  week_ending_day BETWEEN TO_DATE('01-AUG-1999', 'DD-MON-YYYY')
                       AND     TO_DATE('10-AUG-1999', 'DD-MON-YYYY')
GROUP BY week_ending_day;
</pre><p>The query can also be rewritten with the materialized view <code class="codeph">join_sales_time_product_mv_oj</code> where foreign key constraints are not needed. This view contains an outer join (<code class="codeph">s.prod_id=p.prod_id</code>(+)) between <code class="codeph">sales</code> and <code class="codeph">products</code>. This makes the join lossless. If <code class="codeph">p.prod_id</code> is a primary key, then the non-duplicating condition is satisfied as well and optimizer rewrites the query as follows:
                           </p><pre class="oac_no_warn" dir="ltr">SELECT week_ending_day, SUM(amount_sold)
FROM   join_sales_time_product_oj_mv
WHERE  week_ending_day BETWEEN TO_DATE('01-AUG-1999', 'DD-MON-YYYY')
  AND  TO_DATE('10-AUG-1999', 'DD-MON-YYYY')
GROUP BY week_ending_day;
</pre><p>The query can also be rewritten with the materialized view <code class="codeph">join_sales_time_product_mv_oj</code> where foreign key constraints are not needed. This view contains an outer join (<code class="codeph">s.prod_id=p.prod_id</code>(+)) between <code class="codeph">sales</code> and <code class="codeph">products</code>. This makes the join lossless. If <code class="codeph">p.prod_id</code> is a primary key, then the non-duplicating condition is satisfied as well and optimizer rewrites the query as follows:
                           </p><pre class="oac_no_warn" dir="ltr">SELECT week_ending_day, SUM(amount_sold)
FROM   join_sales_time_product_oj_mv
WHERE  week_ending_day BETWEEN TO_DATE('01-AUG-1999', 'DD-MON-YYYY')
  AND  TO_DATE('10-AUG-1999', 'DD-MON-YYYY')
GROUP BY week_ending_day;
</pre><p>Note that the outer join in the definition of <code class="codeph">join_sales_time_product_mv_oj</code> is not necessary because the primary key - foreign key relationship between <code class="codeph">sales</code> and <code class="codeph">products</code> in the <code class="codeph">sh</code> schema is already lossless. It is used for demonstration purposes only, and would be necessary if <code class="codeph">sales.prod_id</code> were nullable, thus violating the losslessness of the join condition <code class="codeph">sales.prod_id = products.prod_id</code>.
                           </p>
                           <p>Current limitations restrict most rewrites with outer joins to materialized views with joins only. There is limited support for rewrites with materialized aggregate views with outer joins, so those materialized views should rely on foreign key constraints to assure losslessness of materialized view delta joins.</p>
                           <div class="infoboxnotealso" id="GUID-FB70D563-A1E9-4B15-B9AF-AAE736DAD8CD__GUID-BA16C43C-DDF5-4E96-99E5-30DDEC22E93D">
                              <p class="notep1">See Also:</p>
                              <p><a href="advanced-query-rewrite-materialized-views.html#GUID-AF8326B6-DADD-4893-85DB-7456A3DC2756">About Checks Made by Query Rewrite</a></p>
                           </div>
                        </div>
                     </div><a id="DWHSG8507"></a><div class="props_rev_3"><a id="GUID-A931828B-F676-427C-9170-8CF5AB5FAA1C" name="GUID-A931828B-F676-427C-9170-8CF5AB5FAA1C"></a><h6 id="DWHSG-GUID-A931828B-F676-427C-9170-8CF5AB5FAA1C" class="sect6"><span class="enumeration_section">12.1.3.1.4 </span>Join Equivalence Recognition
                        </h6>
                        <div>
                           <p>Query rewrite is able to make many transformations based upon the recognition of equivalent joins. Query rewrite recognizes the following construct as being equivalent to a join:</p><pre class="oac_no_warn" dir="ltr">WHERE table1.column1 = F(args)   /* sub-expression A */
AND table2.column2 = F(args)     /* sub-expression B */
</pre><p>If <code class="codeph">F(args)</code> is a PL/SQL function that is declared to be deterministic and the arguments to both invocations of <code class="codeph">F</code> are the same, then the combination of subexpression <code class="codeph">A</code> with subexpression <code class="codeph">B</code> be can be recognized as a join between <code class="codeph">table1.column1</code> and <code class="codeph">table2.column2</code>. That is, the following expression is equivalent to the previous expression:
                           </p><pre class="oac_no_warn" dir="ltr">WHERE table1.column1 = F(args)          /* sub-expression A */
AND table2.column2 = F(args)            /* sub-expression B */
AND table1.column1 = table2.column2     /* join-expression J */
</pre><p>Because join-expression <code class="codeph">J</code> can be inferred from sub-expression <code class="codeph">A</code> and subexpression <code class="codeph">B</code>, the inferred join can be used to match a corresponding join of <code class="codeph">table1.column1 = table2.column2</code> in a materialized view.
                           </p>
                        </div>
                     </div>
                  </div><a id="DWHSG8504"></a><a id="DWHSG8508"></a><div class="props_rev_3"><a id="GUID-5D05C98E-4020-4634-AC3E-9B24AF38893E" name="GUID-5D05C98E-4020-4634-AC3E-9B24AF38893E"></a><h5 id="DWHSG-GUID-5D05C98E-4020-4634-AC3E-9B24AF38893E" class="sect5"><span class="enumeration_section">12.1.3.2 </span>Data Sufficiency Check for Query Rewrite
                     </h5>
                     <div>
                        <p><a id="d44607e976" class="indexterm-anchor"></a>In this check, the optimizer determines if the necessary column data requested by a query can be obtained from a materialized view. For this, the equivalence of one column with another is used. For example, if an inner join between table <code class="codeph">A</code> and table <code class="codeph">B</code> is based on a join predicate <code class="codeph">A.X = B.X</code>, then the data in column <code class="codeph">A.X</code> equals the data in column <code class="codeph">B.X</code> in the result of the join. This data property is used to match column <code class="codeph">A.X</code> in a query with column <code class="codeph">B.X</code> in a materialized view or vice versa. For example, consider the following query:
                        </p><pre class="oac_no_warn" dir="ltr">SELECT p.prod_name, s.time_id, t.week_ending_day, SUM(s.amount_sold)
FROM sales s, products p, times t
WHERE s.time_id=t.time_id AND s.prod_id = p.prod_id
GROUP BY p.prod_name, s.time_id, t.week_ending_day;
</pre><p>This query can be answered with <code class="codeph">join_sales_time_product_mv</code> even though the materialized view does not have <code class="codeph">s.time_id</code>. Instead, it has <code class="codeph">t.time_id</code>, which, through a join condition <code class="codeph">s.time_id=t.time_id</code>, is equivalent to <code class="codeph">s.time_id</code>. Thus, the optimizer might select the following rewrite:
                        </p><pre class="oac_no_warn" dir="ltr">SELECT prod_name, time_id, week_ending_day, SUM(amount_sold)
FROM join_sales_time_product_mv
GROUP BY prod_name, time_id, week_ending_day;</pre></div>
                  </div><a id="DWHSG8509"></a><div class="props_rev_3"><a id="GUID-9A52FD90-681E-40B6-9DBE-F0D338380BE4" name="GUID-9A52FD90-681E-40B6-9DBE-F0D338380BE4"></a><h5 id="DWHSG-GUID-9A52FD90-681E-40B6-9DBE-F0D338380BE4" class="sect5"><span class="enumeration_section">12.1.3.3 </span>Grouping Compatibility Check for Query Rewrite
                     </h5>
                     <div>
                        <p><a id="d44607e1046" class="indexterm-anchor"></a>This check is required only if both the materialized view and the query contain a <code class="codeph">GROUP</code> <code class="codeph">BY</code> clause. The optimizer first determines if the grouping of data requested by a query is exactly the same as the grouping of data stored in a materialized view. In other words, the level of grouping is the same in both the query and the materialized view. If the materialized views groups on all the columns and expressions in the query and also groups on additional columns or expressions, query rewrite can reaggregate the materialized view over the grouping columns and expressions of the query to derive the same result requested by the query.
                        </p>
                     </div>
                  </div><a id="DWHSG8510"></a><div class="props_rev_3"><a id="GUID-E0156059-DF92-4302-80D3-C6C066130B3E" name="GUID-E0156059-DF92-4302-80D3-C6C066130B3E"></a><h5 id="DWHSG-GUID-E0156059-DF92-4302-80D3-C6C066130B3E" class="sect5"><span class="enumeration_section">12.1.3.4 </span>Aggregate Computability Check for Query Rewrite
                     </h5>
                     <div>
                        <p><a id="d44607e1078" class="indexterm-anchor"></a>This check is required only if both the query and the materialized view contain aggregates. Here the optimizer determines if the aggregates requested by a query can be derived or computed from one or more aggregates stored in a materialized view. For example, if a query requests <code class="codeph">AVG(X)</code> and a materialized view contains <code class="codeph">SUM(X)</code> and <code class="codeph">COUNT(X)</code>, then <code class="codeph">AVG(X)</code> can be computed as <code class="codeph">SUM(X)/COUNT(X)</code>.
                        </p>
                        <p>If the grouping compatibility check determined that the rollup of aggregates stored in a materialized view is required, then the aggregate computability check determines if it is possible to roll up each aggregate requested by the query using aggregates in the materialized view.</p>
                     </div>
                  </div>
               </div><a id="DWHSG08014"></a><div class="props_rev_3"><a id="GUID-9279E302-ECD5-4316-B0AC-493507C7F7F2" name="GUID-9279E302-ECD5-4316-B0AC-493507C7F7F2"></a><h4 id="DWHSG-GUID-9279E302-ECD5-4316-B0AC-493507C7F7F2" class="sect4"><span class="enumeration_section">12.1.4 </span>About Query Rewrite Using Dimensions
                  </h4>
                  <div>
                     <p>This section discusses the following aspects of using dimensions in a rewrite environment:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="advanced-query-rewrite-materialized-views.html#GUID-2F32D121-29DA-42C6-A155-C8A52472CDD5">Benefits of Using Dimensions in a Query Rewrite Environment</a></p>
                        </li>
                        <li>
                           <p><a href="advanced-query-rewrite-materialized-views.html#GUID-C0BDF64C-8D46-4928-BFAF-200761ED5ECA">How to Define Dimensions for Query Rewrite</a></p>
                        </li>
                     </ul>
                  </div><a id="DWHSG8511"></a><div class="props_rev_3"><a id="GUID-2F32D121-29DA-42C6-A155-C8A52472CDD5" name="GUID-2F32D121-29DA-42C6-A155-C8A52472CDD5"></a><h5 id="DWHSG-GUID-2F32D121-29DA-42C6-A155-C8A52472CDD5" class="sect5"><span class="enumeration_section">12.1.4.1 </span>Benefits of Using Dimensions in a Query Rewrite Environment
                     </h5>
                     <div>
                        <p>A dimension defines a hierarchical (parent/child) relationships between columns, where all the columns do not have to come from the same table.</p>
                        <p>Dimension definitions increase the possibility of query rewrite because they help to establish functional dependencies between the columns. In addition, dimensions can express intra-table relationships that cannot be expressed by constraints. A dimension definition does not occupy additional storage. Rather, a dimension definition establishes metadata that describes the intra- and inter-dimensional relationships within your schema. Before creating a materialized view, the first step is to review the schema and define the dimensions as this can significantly improve the chances of rewriting a query.</p>
                     </div>
                  </div><a id="DWHSG8512"></a><div class="props_rev_3"><a id="GUID-C0BDF64C-8D46-4928-BFAF-200761ED5ECA" name="GUID-C0BDF64C-8D46-4928-BFAF-200761ED5ECA"></a><h5 id="DWHSG-GUID-C0BDF64C-8D46-4928-BFAF-200761ED5ECA" class="sect5"><span class="enumeration_section">12.1.4.2 </span>How to Define Dimensions for Query Rewrite
                     </h5>
                     <div>
                        <div class="section">
                           <p>For any given schema, use the following steps to create dimensions:</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <ol>
                              <li><a href="advanced-query-rewrite-materialized-views.html#GUID-C0BDF64C-8D46-4928-BFAF-200761ED5ECA__CACCBIDA">Identify all dimensions and dimension tables in the schema</a></li>
                              <li><a href="advanced-query-rewrite-materialized-views.html#GUID-C0BDF64C-8D46-4928-BFAF-200761ED5ECA__CACJGGBJ">Identify the hierarchies within each dimension</a></li>
                              <li><a href="advanced-query-rewrite-materialized-views.html#GUID-C0BDF64C-8D46-4928-BFAF-200761ED5ECA__CACIBIHJ">Identify the attribute dependencies within each level of the hierarchy</a></li>
                              <li><a href="advanced-query-rewrite-materialized-views.html#GUID-C0BDF64C-8D46-4928-BFAF-200761ED5ECA__CACCIIHG">Identify joins from the fact table in a data warehouse to each dimension</a></li>
                           </ol>
                           <p>Remember to set the parameter <code class="codeph">QUERY_REWRITE_INTEGRITY</code> to <code class="codeph">TRUSTED</code> or <code class="codeph">STALE_TOLERATED</code> for query rewrite to take advantage of the relationships declared in dimensions.
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section" id="GUID-C0BDF64C-8D46-4928-BFAF-200761ED5ECA__CACCBIDA">
                           <p class="subhead3" id="GUID-C0BDF64C-8D46-4928-BFAF-200761ED5ECA__GUID-264F6333-0E5F-4AA4-9C69-757066EC6620">Identify all dimensions and dimension tables in the schema</p>
                           <p>If the dimensions are normalized, that is, stored in multiple tables, then check that a join between the dimension tables guarantees that each child-side row joins with one and only one parent-side row. In the case of denormalized dimensions, check that the child-side columns uniquely determine the parent-side (or attribute) columns. Failure to abide by these rules may result in incorrect results being returned from queries.</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section" id="GUID-C0BDF64C-8D46-4928-BFAF-200761ED5ECA__CACJGGBJ">
                           <p class="subhead3" id="GUID-C0BDF64C-8D46-4928-BFAF-200761ED5ECA__GUID-D8A463D8-ED27-43BA-90F6-F70EA11AC8D6">Identify the hierarchies within each dimension</p>
                           <p>As an example, day is a child of month (you can aggregate day level data up to month), and quarter is a child of year.</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section" id="GUID-C0BDF64C-8D46-4928-BFAF-200761ED5ECA__CACIBIHJ">
                           <p class="subhead3" id="GUID-C0BDF64C-8D46-4928-BFAF-200761ED5ECA__GUID-BE388844-D6F2-40E2-BB2B-5EA5B7B29D76">Identify the attribute dependencies within each level of the hierarchy</p>
                           <p>As an example, identify that <code class="codeph">calendar_month_name</code> is an attribute of month.
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section" id="GUID-C0BDF64C-8D46-4928-BFAF-200761ED5ECA__CACCIIHG">
                           <p class="subhead3" id="GUID-C0BDF64C-8D46-4928-BFAF-200761ED5ECA__GUID-ACA5CF35-3856-47C0-ADFE-4623C5E5FB76">Identify joins from the fact table in a data warehouse to each dimension</p>
                           <p>Then check that each join can guarantee that each fact row joins with one and only one dimension row. This condition must be declared, and optionally enforced, by adding <code class="codeph">FOREIGN</code> <code class="codeph">KEY</code> and <code class="codeph">NOT</code> <code class="codeph">NULL</code> constraints on the fact key columns and <code class="codeph">PRIMARY</code> <code class="codeph">KEY</code> constraints on the parent-side join keys. If these relationships can be guaranteed by other data handling procedures (for example, your load process), these constraints can be enabled using the <code class="codeph">NOVALIDATE</code> option to avoid the time required to validate that every row in the table conforms to the constraints. The <code class="codeph">RELY</code> clause is also required for all nonvalidated constraints to make them eligible for use in query rewrite.
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div><a id="DWHSG9412"></a><div class="props_rev_3"><a id="GUID-7D334590-98DE-475F-A815-1F36934B7ADA" name="GUID-7D334590-98DE-475F-A815-1F36934B7ADA"></a><h6 id="DWHSG-GUID-7D334590-98DE-475F-A815-1F36934B7ADA" class="sect6"><span class="enumeration_section">12.1.4.2.1 </span>Example SQL Statement to Create Time Dimensions
                        </h6>
                        <div><pre class="oac_no_warn" dir="ltr">CREATE DIMENSION times_dim
LEVEL day IS TIMES.TIME_ID
LEVEL month IS TIMES.CALENDAR_MONTH_DESC
LEVEL quarter IS TIMES.CALENDAR_QUARTER_DESC
LEVEL year IS TIMES.CALENDAR_YEAR
LEVEL fis_week IS TIMES.WEEK_ENDING_DAY
LEVEL fis_month  IS TIMES.FISCAL_MONTH_DESC
LEVEL fis_quarter IS TIMES.FISCAL_QUARTER_DESC
LEVEL fis_year IS TIMES.FISCAL_YEAR
        HIERARCHY cal_rollup
        (day  CHILD OF month CHILD OF quarter CHILD OF year)
        HIERARCHY fis_rollup    
        (day  CHILD OF fis_week CHILD OF fis_month CHILD OF fis_quarter 
        CHILD OF fis_year)
 
        ATTRIBUTE day DETERMINES
        (day_number_in_week, day_name, day_number_in_month,
         calendar_week_number)
 
        ATTRIBUTE month DETERMINES
        (calendar_month_desc, calendar_month_number, calendar_month_name, 
         days_in_cal_month, end_of_cal_month)
 
        ATTRIBUTE quarter DETERMINES 
        (calendar_quarter_desc, calendar_quarter_number,days_in_cal_quarter,
         end_of_cal_quarter)
 
        ATTRIBUTE year DETERMINES
        (calendar_year,  days_in_cal_year, end_of_cal_year)
 
        ATTRIBUTE fis_week DETERMINES
        (week_ending_day, fiscal_week_number);
</pre></div>
                     </div>
                  </div>
               </div>
            </div><a id="DWHSG0802"></a><div class="props_rev_3"><a id="GUID-5297DA70-0064-4EA4-B492-E45089E5074F" name="GUID-5297DA70-0064-4EA4-B492-E45089E5074F"></a><h3 id="DWHSG-GUID-5297DA70-0064-4EA4-B492-E45089E5074F" class="sect3"><span class="enumeration_section">12.2 </span>Types of Query Rewrite
               </h3>
               <div>
                  <p>Queries that have aggregates that require computations over a large number of rows or joins between very large tables can be expensive and thus can take a long time to return the results. Query rewrite transparently rewrites such queries using materialized views that have pre-computed results, so that the queries can be answered almost instantaneously. These materialized views can be broadly categorized into two groups, namely materialized aggregate views and materialized join views. Materialized aggregate views are tables that have pre-computed aggregate values for columns from original tables. Similarly, materialized join views are tables that have pre-computed joins between columns from original tables. Query rewrite transforms an incoming query to fetch the results from materialized view columns. Because these columns contain already pre-computed results, the incoming query can be answered almost instantaneously. For considerations regarding query rewrite of cube organized materialized views, see <a href="../olaug/administering-oracle-olap.html#OLAUG700" target="_blank"><span class="italic">Oracle OLAP User's Guide</span></a>.
                  </p>
                  <p>This section discusses the following methods that can be used to rewrite a query:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="advanced-query-rewrite-materialized-views.html#GUID-A95A5C58-B011-44FF-B5CB-EE4FDEE032D5">Query Rewrite Method 1: Text Match Rewrite</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-query-rewrite-materialized-views.html#GUID-512B09CD-D2C3-4FA9-BC7C-0A4EF6A4B74F">Query Rewrite Method 2: Join Back</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-query-rewrite-materialized-views.html#GUID-4682B101-191E-4C39-B90D-E927D84123DA">Query Rewrite Method 3: Aggregate Computability</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-query-rewrite-materialized-views.html#GUID-34D5394E-9267-4785-8737-0DA0D35E4849">Query Rewrite Method 4: Aggregate Rollup</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-query-rewrite-materialized-views.html#GUID-5CE61CCA-6A0A-4FB4-8F77-1A405AFC142F">Query Rewrite Method 5: Rollup Using a Dimension</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-query-rewrite-materialized-views.html#GUID-D8D9019B-EF84-408E-9DB8-75EAD33A3A9D">Query Rewrite Method 6: When Materialized Views Have Only a Subset of Data</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-query-rewrite-materialized-views.html#GUID-A32547B4-7E20-4EAB-B3B7-A7DBC1E5B4D8">Partition Change Tracking (PCT) Rewrite</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-query-rewrite-materialized-views.html#GUID-CECD1B60-A092-4AA7-AE32-B2DD97EBDD08">About Query Rewrite Using Multiple Materialized Views</a></p>
                     </li>
                  </ul>
               </div><a id="DWHSG08021"></a><div class="props_rev_3"><a id="GUID-A95A5C58-B011-44FF-B5CB-EE4FDEE032D5" name="GUID-A95A5C58-B011-44FF-B5CB-EE4FDEE032D5"></a><h4 id="DWHSG-GUID-A95A5C58-B011-44FF-B5CB-EE4FDEE032D5" class="sect4"><span class="enumeration_section">12.2.1 </span>Query Rewrite Method 1: Text Match Rewrite
                  </h4>
                  <div>
                     <p><a id="d44607e1370" class="indexterm-anchor"></a>The query rewrite engine always initially tries to compare the text of incoming query with the text of the definition of any potential materialized views to rewrite the query. This is because the overhead of doing a simple text comparison is usually negligible comparing to the cost of doing a complex analysis required for the general rewrite.
                     </p>
                     <p>The query rewrite engine uses two text match methods, full text match rewrite and partial text match rewrite. In full text match the entire text of a query is compared against the entire text of a materialized view definition (that is, the entire <code class="codeph">SELECT</code> expression), ignoring the white space during text comparison. For example, assume that you have the following materialized view, <code class="codeph">sum_sales_pscat_month_city_mv</code>:
                     </p><pre class="oac_no_warn" dir="ltr">CREATE MATERIALIZED VIEW sum_sales_pscat_month_city_mv
ENABLE QUERY REWRITE AS
   SELECT p.prod_subcategory, t.calendar_month_desc, c.cust_city,
   SUM(s.amount_sold) AS sum_amount_sold,
   COUNT(s.amount_sold) AS count_amount_sold
   FROM sales s, products p, times t, customers c
   WHERE s.time_id=t.time_id
      AND     s.prod_id=p.prod_id
      AND     s.cust_id=c.cust_id
  GROUP BY p.prod_subcategory, t.calendar_month_desc, c.cust_city;
</pre><p>Consider the following query:</p><pre class="oac_no_warn" dir="ltr">SELECT p.prod_subcategory, t.calendar_month_desc, c.cust_city,
       SUM(s.amount_sold) AS sum_amount_sold,
       COUNT(s.amount_sold) AS count_amount_sold
       FROM sales s, products p, times t, customers c
       WHERE s.time_id=t.time_id
         AND     s.prod_id=p.prod_id
         AND     s.cust_id=c.cust_id
       GROUP BY p.prod_subcategory, t.calendar_month_desc, c.cust_city;
 </pre><p>This query matches <code class="codeph">sum_sales_pscat_month_city_mv</code> (white space excluded) and is rewritten as:
                     </p><pre class="oac_no_warn" dir="ltr">SELECT mv.prod_subcategory, mv.calendar_month_desc, mv.cust_city,
       mv.sum_amount_sold, mv.count_amount_sold
FROM   sum_sales_pscat_month_city_mv;
</pre><p>When full text match fails, the optimizer then attempts a partial text match. In this method, the text starting from the <code class="codeph">FROM</code> clause of a query is compared against the text starting with the <code class="codeph">FROM</code> clause of a materialized view definition. Therefore, the following query can be rewritten:
                     </p><pre class="oac_no_warn" dir="ltr">SELECT p.prod_subcategory, t.calendar_month_desc, c.cust_city,
       AVG(s.amount_sold)
FROM   sales s, products p, times t, customers c
WHERE  s.time_id=t.time_id AND s.prod_id=p.prod_id
AND    s.cust_id=c.cust_id
GROUP BY p.prod_subcategory, t.calendar_month_desc, c.cust_city;
</pre><p>This query is rewritten as:</p><pre class="oac_no_warn" dir="ltr">SELECT mv.prod_subcategory, mv.calendar_month_desc, mv.cust_city,
       mv.sum_amount_sold/mv.count_amount_sold
FROM   sum_sales_pscat_month_city_mv mv;
</pre><p>Note that, under the partial text match rewrite method, the average of sales aggregate required by the query is computed using the sum of sales and count of sales aggregates stored in the materialized view. </p>
                     <p>When neither text match succeeds, the optimizer uses a general query rewrite method.</p>
                     <p>Text match rewrite can distinguish contexts where the difference between uppercase and lowercase is significant and where it is not. For example, the following statements are equivalent:</p><pre class="oac_no_warn" dir="ltr">SELECT X, 'aBc' FROM Y

Select x, 'aBc' From y</pre></div>
               </div><a id="DWHSG08022"></a><div class="props_rev_3"><a id="GUID-512B09CD-D2C3-4FA9-BC7C-0A4EF6A4B74F" name="GUID-512B09CD-D2C3-4FA9-BC7C-0A4EF6A4B74F"></a><h4 id="DWHSG-GUID-512B09CD-D2C3-4FA9-BC7C-0A4EF6A4B74F" class="sect4"><span class="enumeration_section">12.2.2 </span>Query Rewrite Method 2: Join Back
                  </h4>
                  <div>
                     <p>If some column data requested by a query cannot be obtained from a materialized view, the optimizer further determines if it can be obtained based on a data relationship called a functional dependency. When the data in a column can determine data in another column, such a relationship is called a functional dependency or functional determinance. For example, if a table contains a primary key column called <code class="codeph">prod_id</code> and another column called <code class="codeph">prod_name</code>, then, given a <code class="codeph">prod_id</code> value, it is possible to look up the corresponding <code class="codeph">prod_name</code>. The opposite is not true, which means a <code class="codeph">prod_name</code> value need not relate to a unique <code class="codeph">prod_id</code>.
                     </p>
                     <p>When the column data required by a query is not available from a materialized view, such column data can still be obtained by joining the materialized view back to the table that contains required column data provided the materialized view contains a key that functionally determines the required column data. For example, consider the following query:</p><pre class="oac_no_warn" dir="ltr">SELECT p.prod_category, t.week_ending_day, SUM(s.amount_sold)
FROM   sales s, products p, times t
WHERE  s.time_id=t.time_id  AND s.prod_id=p.prod_id AND p.prod_category='CD'
GROUP BY p.prod_category, t.week_ending_day;
</pre><p>The materialized view <code class="codeph">sum_sales_prod_week_mv</code> contains <code class="codeph">p.prod_id</code>, but not <code class="codeph">p.prod_category</code>. However, you can join <code class="codeph">sum_sales_prod_week_mv</code> back to <code class="codeph">products</code> to retrieve <code class="codeph">prod_category</code> because <code class="codeph">prod_id</code> functionally determines <code class="codeph">prod_category</code>. The optimizer rewrites this query using <code class="codeph">sum_sales_prod_week_mv</code> as follows:
                     </p><pre class="oac_no_warn" dir="ltr">SELECT p.prod_category, mv.week_ending_day, SUM(mv.sum_amount_sold)
FROM   sum_sales_prod_week_mv mv, products p
WHERE  mv.prod_id=p.prod_id AND p.prod_category='CD'
GROUP BY p.prod_category, mv.week_ending_day;
</pre><p>Here the <code class="codeph">products</code> table is called a joinback table because it was originally joined in the materialized view but joined again in the rewritten query.
                     </p>
                     <p>You can declare functional dependency in two ways:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Using the primary key constraint (as shown in the previous example)</p>
                        </li>
                        <li>
                           <p>Using the <code class="codeph">DETERMINES</code> clause of a dimension
                           </p>
                        </li>
                     </ul>
                     <p>The <code class="codeph">DETERMINES</code> clause of a dimension definition might be the only way you could declare functional dependency when the column that determines another column cannot be a primary key. For example, the <code class="codeph">products</code> table is a denormalized dimension table that has columns <code class="codeph">prod_id</code>, <code class="codeph">prod_name</code>, and <code class="codeph">prod_subcategory</code> that functionally determines <code class="codeph">prod_subcat_desc</code> and <code class="codeph">prod_category</code> that determines <code class="codeph">prod_cat_desc</code>.
                     </p>
                     <p>The first functional dependency can be established by declaring <code class="codeph">prod_id</code> as the primary key, but not the second functional dependency because the <code class="codeph">prod_subcategory</code> column contains duplicate values. In this situation, you can use the <code class="codeph">DETERMINES</code> clause of a dimension to declare the second functional dependency.
                     </p>
                     <p>The following dimension definition illustrates how functional dependencies are declared:</p><pre class="oac_no_warn" dir="ltr">CREATE DIMENSION products_dim 
        LEVEL product           IS (products.prod_id)
        LEVEL subcategory       IS (products.prod_subcategory) 
        LEVEL category          IS (products.prod_category) 
        HIERARCHY prod_rollup (
                product         CHILD OF 
                subcategory     CHILD OF 
                category
        )
        ATTRIBUTE product DETERMINES products.prod_name 
        ATTRIBUTE product DETERMINES products.prod_desc
        ATTRIBUTE subcategory DETERMINES products.prod_subcat_desc
        ATTRIBUTE category DETERMINES products.prod_cat_desc;
</pre><p>The hierarchy <code class="codeph">prod_rollup</code> declares hierarchical relationships that are also <code class="codeph">1:n</code> functional dependencies. The <code class="codeph">1:1</code> functional dependencies are declared using the <code class="codeph">DETERMINES</code> clause, as seen when <code class="codeph">prod_subcategory</code> functionally determines <code class="codeph">prod_subcat_desc</code>.
                     </p>
                     <p>If the following materialized view is created:</p><pre class="oac_no_warn" dir="ltr">CREATE MATERIALIZED VIEW sum_sales_pscat_week_mv
ENABLE QUERY REWRITE AS
SELECT p.prod_subcategory, t.week_ending_day,
       SUM(s.amount_sold) AS sum_amount_sole
FROM sales s, products p, times t
WHERE s.time_id = t.time_id AND s.prod_id = p.prod_id
GROUP BY p.prod_subcategory, t.week_ending_day;
</pre><p>Then consider the following query:</p><pre class="oac_no_warn" dir="ltr">SELECT p.prod_subcategory_desc, t.week_ending_day, SUM(s.amount_sold)
FROM   sales s, products p, times t
WHERE  s.time_id=t.time_id AND s.prod_id=p.prod_id
AND    p.prod_subcat_desc LIKE '%Men'
GROUP BY p.prod_subcat_desc, t.week_ending_day;
</pre><p>This can be rewritten by joining <code class="codeph">sum_sales_pscat_week_mv</code> to the <code class="codeph">products</code> table so that <code class="codeph">prod_subcat_desc</code> is available to evaluate the predicate. However, the join is based on the <code class="codeph">prod_subcategory</code> column, which is not a primary key in the <code class="codeph">products</code> table; therefore, it allows duplicates. This is accomplished by using an inline view that selects distinct values and this view is joined to the materialized view as shown in the rewritten query.
                     </p><pre class="oac_no_warn" dir="ltr">SELECT iv.prod_subcat_desc, mv.week_ending_day, SUM(mv.sum_amount_sold)
FROM  sum_sales_pscat_week_mv mv, 
     (SELECT DISTINCT prod_subcategory, prod_subcat_desc
      FROM products) iv
WHERE  mv.prod_subcategory=iv.prod_subcategory 
AND iv.prod_subcat_desc LIKE '%Men'
GROUP BY iv.prod_subcat_desc, mv.week_ending_day;
</pre><p>This type of rewrite is possible because <code class="codeph">prod_subcategory</code> functionally determines <code class="codeph">prod_subcategory_desc</code> as declared in the dimension.
                     </p>
                  </div>
               </div><a id="DWHSG08023"></a><div class="props_rev_3"><a id="GUID-4682B101-191E-4C39-B90D-E927D84123DA" name="GUID-4682B101-191E-4C39-B90D-E927D84123DA"></a><h4 id="DWHSG-GUID-4682B101-191E-4C39-B90D-E927D84123DA" class="sect4"><span class="enumeration_section">12.2.3 </span>Query Rewrite Method 3: Aggregate Computability
                  </h4>
                  <div>
                     <p>Query rewrite can also occur when the optimizer determines if the aggregates requested by a query can be derived or computed from one or more aggregates stored in a materialized view. For example, if a query requests <code class="codeph">AVG(X)</code> and a materialized view contains <code class="codeph">SUM(X)</code> and <code class="codeph">COUNT(X)</code>, then <code class="codeph">AVG(X)</code> can be computed as <code class="codeph">SUM(X)/COUNT(X)</code>.
                     </p>
                     <p>In addition, if it is determined that the rollup of aggregates stored in a materialized view is required, then, if it is possible, query rewrite also rolls up each aggregate requested by the query using aggregates in the materialized view. </p>
                     <p>For example, <code class="codeph">SUM(sales)</code> at the city level can be rolled up to <code class="codeph">SUM(sales)</code> at the state level by summing all <code class="codeph">SUM(sales)</code> aggregates in a group with the same state value. However, <code class="codeph">AVG(sales)</code> cannot be rolled up to a coarser level unless <code class="codeph">COUNT(sales)</code> or <code class="codeph">SUM(sales)</code> is also available in the materialized view. Similarly, <code class="codeph">VARIANCE(sales)</code> or <code class="codeph">STDDEV(sales)</code> cannot be rolled up unless both <code class="codeph">COUNT(sales)</code> and <code class="codeph">SUM(sales)</code> are also available in the materialized view. For example, consider the following query:
                     </p><pre class="oac_no_warn" dir="ltr">ALTER TABLE times MODIFY CONSTRAINT time_pk RELY;
ALTER TABLE customers MODIFY CONSTRAINT customers_pk RELY;
ALTER TABLE sales MODIFY CONSTRAINT sales_time_pk RELY;
ALTER TABLE sales MODIFY CONSTRAINT sales_customer_fk RELY;
SELECT  p.prod_subcategory, AVG(s.amount_sold) AS avg_sales
FROM  sales s, products p WHERE s.prod_id = p.prod_id
GROUP BY p.prod_subcategory;
</pre><p>This statement can be rewritten with materialized view <code class="codeph">sum_sales_pscat_month_city_mv</code> provided the join between <code class="codeph">sales</code> and <code class="codeph">times</code> and <code class="codeph">sales</code> and <code class="codeph">customers</code> are lossless and non-duplicating. Further, the query groups by <code class="codeph">prod_subcategory</code> whereas the materialized view groups by <code class="codeph">prod_subcategory</code>, <code class="codeph">calendar_month_desc</code> and <code class="codeph">cust_city</code>, which means the aggregates stored in the materialized view have to be rolled up. The optimizer rewrites the query as the following:
                     </p><pre class="oac_no_warn" dir="ltr">SELECT mv.prod_subcategory, SUM(mv.sum_amount_sold)/COUNT(mv.count_amount_sold) 
   AS avg_sales
FROM sum_sales_pscat_month_city_mv mv 
GROUP BY mv.prod_subcategory;
</pre><p>The argument of an aggregate such as <code class="codeph">SUM</code> can be an arithmetic expression such as <code class="codeph">A+B</code>. The optimizer tries to match an aggregate <code class="codeph">SUM(A+B)</code> in a query with an aggregate <code class="codeph">SUM(A+B)</code> or <code class="codeph">SUM(B+A)</code> stored in a materialized view. In other words, expression equivalence is used when matching the argument of an aggregate in a query with the argument of a similar aggregate in a materialized view. To accomplish this, Oracle converts the aggregate argument expression into a canonical form such that two different but equivalent expressions convert into the same canonical form. For example, <code class="codeph">A*(B-C)</code>, <code class="codeph">A*B-C*A</code>, <code class="codeph">(B-C)*A</code>, and <code class="codeph">-A*C+A*B</code> all convert into the same canonical form and, therefore, they are successfully matched.
                     </p>
                  </div>
               </div><a id="DWHSG08024"></a><div class="props_rev_3"><a id="GUID-34D5394E-9267-4785-8737-0DA0D35E4849" name="GUID-34D5394E-9267-4785-8737-0DA0D35E4849"></a><h4 id="DWHSG-GUID-34D5394E-9267-4785-8737-0DA0D35E4849" class="sect4"><span class="enumeration_section">12.2.4 </span>Query Rewrite Method 4: Aggregate Rollup
                  </h4>
                  <div>
                     <p>If the grouping of data requested by a query is at a coarser level than the grouping of data stored in a materialized view, the optimizer can still use the materialized view to rewrite the query. For example, the materialized view <code class="codeph">sum_sales_pscat_week_mv</code> groups by <code class="codeph">prod_subcategory</code> and <code class="codeph">week_ending_day</code>. This query groups by <code class="codeph">prod_subcategory</code>, a coarser grouping granularity:
                     </p><pre class="oac_no_warn" dir="ltr">ALTER TABLE times MODIFY CONSTRAINT time_pk RELY;
ALTER TABLE sales MODIFY CONSTRAINT sales_time_fk RELY;
SELECT p.prod_subcategory, SUM(s.amount_sold) AS sum_amount
FROM   sales s, products pWHERE  s.prod_id=p.prod_id 
GROUP BY p.prod_subcategory;
</pre><p>Therefore, the optimizer rewrites this query as:</p><pre class="oac_no_warn" dir="ltr">SELECT mv.prod_subcategory, SUM(mv.sum_amount_sold)
FROM   sum_sales_pscat_week_mv mv
GROUP BY mv.prod_subcategory;</pre></div>
               </div><a id="DWHSG08025"></a><div class="props_rev_3"><a id="GUID-5CE61CCA-6A0A-4FB4-8F77-1A405AFC142F" name="GUID-5CE61CCA-6A0A-4FB4-8F77-1A405AFC142F"></a><h4 id="DWHSG-GUID-5CE61CCA-6A0A-4FB4-8F77-1A405AFC142F" class="sect4"><span class="enumeration_section">12.2.5 </span>Query Rewrite Method 5: Rollup Using a Dimension
                  </h4>
                  <div>
                     <p>When reporting is required at different levels in a hierarchy, materialized views do not have to be created at each level in the hierarchy provided dimensions have been defined. This is because query rewrite can use the relationship information in the dimension to roll up the data in the materialized view to the required level in the hierarchy.</p>
                     <p>In the following example, a query requests data grouped by <code class="codeph">prod_category</code> while a materialized view stores data grouped by <code class="codeph">prod_subcategory</code>. If <code class="codeph">prod_subcategory</code> is a <code class="codeph">CHILD</code> <code class="codeph">OF</code> <code class="codeph">prod_category</code> (see the dimension example earlier), the grouped data stored in the materialized view can be further grouped by <code class="codeph">prod_category</code> when the query is rewritten. In other words, aggregates at <code class="codeph">prod_subcategory</code> level (finer granularity) stored in a materialized view can be rolled up into aggregates at <code class="codeph">prod_category</code> level (coarser granularity).
                     </p>
                     <p>For example, consider the following query:</p><pre class="oac_no_warn" dir="ltr">SELECT p.prod_category, t.week_ending_day, SUM(s.amount_sold) AS sum_amount
FROM   sales s, products p, times t
WHERE  s.time_id=t.time_id AND s.prod_id=p.prod_id
GROUP BY p.prod_category, t.week_ending_day;
</pre><p>Because <code class="codeph">prod_subcategory</code> functionally determines <code class="codeph">prod_category</code>, <code class="codeph">sum_sales_pscat_week_mv</code> can be used with a joinback to <code class="codeph">products</code> to retrieve <code class="codeph">prod_category</code> column data, and then aggregates can be rolled up to <code class="codeph">prod_category</code> level, as shown in the following:
                     </p><pre class="oac_no_warn" dir="ltr">SELECT pv.prod_category, mv.week_ending_day, SUM(mv.sum_amount_sold)
FROM   sum_sales_pscat_week_mv mv,
       (SELECT DISTINCT prod_subcategory, prod_category
        FROM products) pv
WHERE mv.prod_subcategory= pv.prod_subcategory
GROUP BY pv.prod_category, mv.week_ending_day;</pre></div>
               </div><a id="DWHSG8513"></a><div class="props_rev_3"><a id="GUID-D8D9019B-EF84-408E-9DB8-75EAD33A3A9D" name="GUID-D8D9019B-EF84-408E-9DB8-75EAD33A3A9D"></a><h4 id="DWHSG-GUID-D8D9019B-EF84-408E-9DB8-75EAD33A3A9D" class="sect4"><span class="enumeration_section">12.2.6 </span>Query Rewrite Method 6: When Materialized Views Have Only a Subset of Data
                  </h4>
                  <div>
                     <p>Oracle supports rewriting of queries so that they will use materialized views in which the <code class="codeph">HAVING</code> or <code class="codeph">WHERE</code> clause of the materialized view contains a selection of a subset of the data in a table or tables. For example, only those customers who live in New Hampshire. In other words, the <code class="codeph">WHERE</code> clause in the materialized view will be <code class="codeph">WHERE state = 'New Hampshire'</code>.
                     </p>
                     <p>To perform this type of query rewrite, Oracle must determine if the data requested in the query is contained in, or is a subset of, the data stored in the materialized view. The following sections detail the conditions where Oracle can solve this problem and thus rewrite a query to use a materialized view that contains a filtered portion of the data in the detail table.</p>
                     <p>To determine if query rewrite can occur on filtered data, a selection computability check is performed when both the query and the materialized view contain selections (non-joins) and the check is done on the <code class="codeph">WHERE</code> as well as the <code class="codeph">HAVING</code> clause. If the materialized view contains selections and the query does not, then the selection compatibility check fails because the materialized view is more restrictive than the query. If the query has selections and the materialized view does not, then the selection compatibility check is not needed.
                     </p>
                     <p>A materialized view's <code class="codeph">WHERE</code> or <code class="codeph">HAVING</code> clause can contain a join, a selection, or both, and still be used to rewrite a query. Predicate clauses containing expressions, or selecting rows based on the values of particular columns, are examples of non-join predicates.
                     </p>
                     <p>This section contains the following topics:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="advanced-query-rewrite-materialized-views.html#GUID-8461E26C-8B80-4432-B7AE-F135003A3671">Query Rewrite Definitions When Materialized Views Have Only a Subset of Data</a></p>
                        </li>
                        <li>
                           <p><a href="advanced-query-rewrite-materialized-views.html#GUID-A606CB4D-1B46-411B-B166-9E1D688D0F1C">Selection Categories When Materialized Views Have Only a Subset of Data</a></p>
                        </li>
                        <li>
                           <p><a href="advanced-query-rewrite-materialized-views.html#GUID-4408FEDB-09D9-4EA8-A5F0-A3ADE7FC6AE5">Examples of Query Rewrite Selection</a></p>
                        </li>
                        <li>
                           <p><a href="advanced-query-rewrite-materialized-views.html#GUID-8B6C8FC5-BDEB-4FEB-878B-03CA337E48B8">About Handling of the HAVING Clause in Query Rewrite</a></p>
                        </li>
                        <li>
                           <p><a href="advanced-query-rewrite-materialized-views.html#GUID-191815BB-D689-4A2F-B1AD-32B88BC5CF44">About Query Rewrite When the Materialized View has an IN-List</a></p>
                        </li>
                     </ul>
                  </div><a id="DWHSG8514"></a><div class="props_rev_3"><a id="GUID-8461E26C-8B80-4432-B7AE-F135003A3671" name="GUID-8461E26C-8B80-4432-B7AE-F135003A3671"></a><h5 id="DWHSG-GUID-8461E26C-8B80-4432-B7AE-F135003A3671" class="sect5"><span class="enumeration_section">12.2.6.1 </span>Query Rewrite Definitions When Materialized Views Have Only a Subset of Data
                     </h5>
                     <div>
                        <p>Before describing what is possible when query rewrite works with only a subset of the data, the following definitions are useful:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><span class="italic">join relop</span></p>
                              <p>Is one of the following <code class="codeph">(=, &lt;, &lt;=, &gt;, &gt;=)</code></p>
                           </li>
                           <li>
                              <p><span class="italic">selection relop</span></p>
                              <p>Is one of the following <code class="codeph">(=, &lt;, &lt;=, &gt;, &gt;=, !=, [NOT] BETWEEN | IN| LIKE |NULL)</code></p>
                           </li>
                           <li>
                              <p><span class="italic">join predicate</span></p>
                              <p>Is of the form <code class="codeph">(</code><span class="italic">column1</span><code class="codeph"> </code><span class="italic">join</span><code class="codeph"> </code><span class="italic">relop</span><code class="codeph"> </code><span class="italic">column2</span><code class="codeph">)</code>, where columns are from different tables within the same <code class="codeph">FROM</code> clause in the current query block. So, for example, an outer reference is not possible.
                              </p>
                           </li>
                           <li>
                              <p><span class="italic">selection predicate</span></p>
                              <p>Is of the form <span class="italic">left-hand-side-expression</span><code class="codeph"> </code><span class="italic">relop</span><code class="codeph"> </code><span class="italic">right-hand-side-expression</span>. All non-join predicates are selection predicates. The left-hand side usually contains a column and the right-hand side contains the values. For example, <code class="codeph">color='red'</code> means the left-hand side is <code class="codeph">color</code> and the right-hand side is <code class="codeph">'red'</code> and the relational operator is <code class="codeph">(=)</code>.
                              </p>
                           </li>
                        </ul>
                     </div>
                  </div><a id="DWHSG8515"></a><div class="props_rev_3"><a id="GUID-A606CB4D-1B46-411B-B166-9E1D688D0F1C" name="GUID-A606CB4D-1B46-411B-B166-9E1D688D0F1C"></a><h5 id="DWHSG-GUID-A606CB4D-1B46-411B-B166-9E1D688D0F1C" class="sect5"><span class="enumeration_section">12.2.6.2 </span>Selection Categories When Materialized Views Have Only a Subset of Data
                     </h5>
                     <div>
                        <p>Selections are categorized into the following cases:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Simple</p>
                              <p>Simple selections are of the form <span class="italic">expression relop constant</span>. 
                              </p>
                           </li>
                           <li>
                              <p>Complex</p>
                              <p>Complex selections are of the form <span class="italic">expression relop expression</span>.
                              </p>
                           </li>
                           <li>
                              <p>Range</p>
                              <p>Range selections are of a form such as <code class="codeph">WHERE (cust_last_name BETWEEN 'abacrombe' AND 'anakin')</code>.
                              </p>
                              <p>Note that simple selections with relational operators <code class="codeph">(&lt;,&lt;=,&gt;,&gt;=)</code>are also considered range selections.
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">IN</code>-lists
                              </p>
                              <p>Single and multi-column <code class="codeph">IN</code>-lists such as <code class="codeph">WHERE(prod_id) IN (102, 233, ....)</code>.
                              </p>
                              <p>Note that selections of the form <code class="codeph">(column1='v1' OR column1='v2' OR column1='v3' OR ....)</code> are treated as a group and classified as an <code class="codeph">IN</code>-list.
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">IS [NOT] NULL</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">[NOT] LIKE</code></p>
                           </li>
                           <li>
                              <p>Other</p>
                              <p>Other selections are when it cannot determine the boundaries for the data. For example, <code class="codeph">EXISTS</code>.
                              </p>
                           </li>
                        </ul>
                        <p>When comparing a selection from the query with a selection from the materialized view, the left-hand side of both selections are compared.</p>
                        <p>If the left-hand side selections match, then the right-hand side values are checked for containment. That is, the right-hand side values of the query selection must be contained by right-hand side values of the materialized view selection.</p>
                        <p>You can also use expressions in selection predicates. This process resembles the following:</p><pre class="oac_no_warn" dir="ltr"><span class="italic">expression relational operator constant</span>
</pre><p>Where <span class="italic">expression</span> can be any arbitrary arithmetic expression allowed by the Oracle Database. The expression in the materialized view and the query must match. Oracle attempts to discern expressions that are logically equivalent, such as <code class="codeph">A+B</code> and <code class="codeph">B+A</code>, and always recognizes identical expressions as being equivalent.
                        </p>
                        <p>You can also use queries with an expression on both sides of the operator or user-defined functions as operators. Query rewrite occurs when the complex predicate in the materialized view and the query are logically equivalent. This means that, unlike exact text match, terms could be in a different order and rewrite can still occur, as long as the expressions are equivalent.</p>
                     </div>
                  </div><a id="DWHSG8517"></a><a id="DWHSG8518"></a><a id="DWHSG8519"></a><a id="DWHSG8520"></a><a id="DWHSG8521"></a><a id="DWHSG8522"></a><a id="DWHSG8523"></a><a id="DWHSG8524"></a><a id="DWHSG8525"></a><a id="DWHSG8516"></a><div class="props_rev_3"><a id="GUID-4408FEDB-09D9-4EA8-A5F0-A3ADE7FC6AE5" name="GUID-4408FEDB-09D9-4EA8-A5F0-A3ADE7FC6AE5"></a><h5 id="DWHSG-GUID-4408FEDB-09D9-4EA8-A5F0-A3ADE7FC6AE5" class="sect5"><span class="enumeration_section">12.2.6.3 </span>Examples of Query Rewrite Selection
                     </h5>
                     <div>
                        <p>Here are a number of examples showing how query rewrite can still occur when the data is being filtered.</p>
                        <div class="example" id="GUID-4408FEDB-09D9-4EA8-A5F0-A3ADE7FC6AE5__GUID-167F7ABB-1E3F-4864-9F32-66EA692A8BF8">
                           <p class="titleinexample">Example 12-1 Single Value Selection</p>
                           <p>If the query contains the following clause:</p><pre class="oac_no_warn" dir="ltr">WHERE prod_id = 102
</pre><p>And, if a materialized view contains the following clause:</p><pre class="oac_no_warn" dir="ltr">WHERE prod_id BETWEEN 0 AND 200
</pre><p>Then, the left-hand side selections match on <code class="codeph">prod_id</code> and the right-hand side value of the query <code class="codeph">102</code> is within the range of the materialized view, so query rewrite is possible.
                           </p>
                        </div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-4408FEDB-09D9-4EA8-A5F0-A3ADE7FC6AE5__GUID-925A8856-54C4-4A3A-8513-3202B3E1D8A7">
                           <p class="titleinexample">Example 12-2 Bounded Range Selection</p>
                           <p>A selection can be a bounded range (a range with an upper and lower value). For example, if the query contains the following clause:</p><pre class="oac_no_warn" dir="ltr">WHERE prod_id &gt; 10 AND prod_id &lt; 50
</pre><p>And if a materialized view contains the following clause:</p><pre class="oac_no_warn" dir="ltr">WHERE prod_id BETWEEN 0 AND 200
</pre><p>Then, the selections are matched on <code class="codeph">prod_id</code> and the query range is within the materialized view range. In this example, notice that both query selections are based on the same column.
                           </p>
                        </div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-4408FEDB-09D9-4EA8-A5F0-A3ADE7FC6AE5__GUID-6BD15933-8F86-4E11-8385-C3C5AF3396C6">
                           <p class="titleinexample">Example 12-3 Selection With Expression</p>
                           <p>If the query contains the following clause:</p><pre class="oac_no_warn" dir="ltr">WHERE (sales.amount_sold * .07) BETWEEN 1.00 AND 100.00
</pre><p>And if a materialized view contains the following clause:</p><pre class="oac_no_warn" dir="ltr">WHERE (sales.amount_sold * .07) BETWEEN 0.0 AND 200.00
</pre><p>Then, the selections are matched on <code class="codeph">(sales.amount_sold *.07)</code> and the right-hand side value of the query is within the range of the materialized view, therefore query rewrite is possible. Complex selections such as this require that the left-hand side and the right-hand side be matched within range of the materialized view.
                           </p>
                        </div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-4408FEDB-09D9-4EA8-A5F0-A3ADE7FC6AE5__GUID-46199516-033E-4449-B5E3-3E2DC5766105">
                           <p class="titleinexample">Example 12-4 Exact Match Selections</p>
                           <p>If the query contains the following clause:</p><pre class="oac_no_warn" dir="ltr">WHERE (cost.unit_price * 0.95) &gt; (cost_unit_cost  * 1.25)
</pre><p>And if a materialized view contains the following:</p><pre class="oac_no_warn" dir="ltr">WHERE (cost.unit_price * 0.95) &gt; (cost_unit_cost  * 1.25)
</pre><p>If the left-hand side and the right-hand side match the materialized view and the <span class="italic">selection_relop</span> is the same, then the selection can usually be dropped from the rewritten query. Otherwise, the selection must be kept to filter out extra data from the materialized view.
                           </p>
                           <p>If query rewrite can drop the selection from the rewritten query, all columns from the selection may not have to be in the materialized view so more rewrites can be done. This ensures that the materialized view data is not more restrictive than the query.</p>
                        </div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-4408FEDB-09D9-4EA8-A5F0-A3ADE7FC6AE5__GUID-E3FD30AD-7B01-4966-89F7-225DAD7986A8">
                           <p class="titleinexample">Example 12-5 More Selection in the Query</p>
                           <p>Selections in the query do not have to be matched by any selections in the materialized view but, if they are, then the right-hand side values must be contained by the materialized view. For example, if the query contains the following clause:</p><pre class="oac_no_warn" dir="ltr">WHERE prod_name = 'Shorts' AND prod_category = 'Men'
</pre><p>And if a materialized view contains the following clause:</p><pre class="oac_no_warn" dir="ltr">WHERE prod_category = 'Men'
</pre><p>Then, in this example, only selection with <code class="codeph">prod_category</code> is matched. The query has an extra selection that is not matched but this is acceptable because if the materialized view selects <code class="codeph">prod_name</code> or selects a column that can be joined back to the detail table to get <code class="codeph">prod_name</code>, then query rewrite is possible. The only requirement is that query rewrite must have a way of applying the <code class="codeph">prod_name</code> selection to the materialized view.
                           </p>
                        </div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-4408FEDB-09D9-4EA8-A5F0-A3ADE7FC6AE5__GUID-FE4FAE82-3025-4353-AB8D-7B425C5B5142">
                           <p class="titleinexample">Example 12-6 No Rewrite Because of Fewer Selections in the Query</p>
                           <p>If the query contains the following clause:</p><pre class="oac_no_warn" dir="ltr">WHERE prod_category = 'Men'
</pre><p>And if a materialized view contains the following clause:</p><pre class="oac_no_warn" dir="ltr">WHERE prod_name = 'Shorts' AND prod_category = 'Men'
</pre><p>Then, the materialized view selection with <code class="codeph">prod_name</code> is not matched. The materialized view is more restrictive that the query because it only contains the product Shorts, therefore, query rewrite does not occur.
                           </p>
                        </div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-4408FEDB-09D9-4EA8-A5F0-A3ADE7FC6AE5__GUID-2B0951D2-B40A-4A91-A0C3-2727B4E1C530">
                           <p class="titleinexample">Example 12-7 Multi-Column IN-List Selections</p>
                           <p>Query rewrite also checks for cases where the query has a multi-column <code class="codeph">IN</code>-list where the columns are fully matched by individual columns from the materialized view single column <code class="codeph">IN</code>-lists. For example, if the query contains the following:
                           </p><pre class="oac_no_warn" dir="ltr">WHERE (prod_id, cust_id) IN ((1022, 1000), (1033, 2000))
</pre><p>And if a materialized view contains the following:</p><pre class="oac_no_warn" dir="ltr">WHERE prod_id IN (1022,1033) AND cust_id IN (1000, 2000)
</pre><p>Then, the materialized view <code class="codeph">IN</code>-lists are matched by the columns in the query multi-column <code class="codeph">IN</code>-list. Furthermore, the right-hand side values of the query selection are contained by the materialized view so that rewrite occurs.
                           </p>
                        </div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-4408FEDB-09D9-4EA8-A5F0-A3ADE7FC6AE5__GUID-9B9F38F2-1D15-4673-9AF3-860499AC9800">
                           <p class="titleinexample">Example 12-8 Selections Using IN-Lists</p>
                           <p>Selection compatibility also checks for cases where the materialized view has a multi-column <code class="codeph">IN</code>-list where the columns are fully matched by individual columns or columns from <code class="codeph">IN</code>-lists in the query. For example, if the query contains the following:
                           </p><pre class="oac_no_warn" dir="ltr">WHERE prod_id = 1022 AND cust_id IN (1000, 2000)
</pre><p>And if a materialized view contains the following:</p><pre class="oac_no_warn" dir="ltr">WHERE (prod_id, cust_id) IN ((1022, 1000), (1022, 2000))
</pre><p>Then, the materialized view <code class="codeph">IN</code>-list columns are fully matched by the columns in the query selections. Furthermore, the right-hand side values of the query selection are contained by the materialized view. So rewrite succeeds.
                           </p>
                        </div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-4408FEDB-09D9-4EA8-A5F0-A3ADE7FC6AE5__GUID-2ECFD81D-E65D-42D5-AD1E-AFFE0B80530E">
                           <p class="titleinexample">Example 12-9 Multiple Selections or Expressions</p>
                           <p>If the query contains the following clause:</p><pre class="oac_no_warn" dir="ltr">WHERE (city_population &gt; 15000 AND city_population &lt; 25000 
   AND state_name = 'New Hampshire')
</pre><p>And if a materialized view contains the following clause:</p><pre class="oac_no_warn" dir="ltr">WHERE (city_population &lt; 5000 AND state_name = 'New York') OR 
   (city_population BETWEEN 10000 AND 50000 AND state_name = 'New Hampshire')
</pre><p>Then, the query is said to have a single disjunct (group of selections separated by <code class="codeph">AND</code>) and the materialized view has two disjuncts separated by <code class="codeph">OR</code>. The single query disjunct is contained by the second materialized view disjunct so selection compatibility succeeds. It is clear that the materialized view contains more data than needed by the query so the query can be rewritten.
                           </p>
                        </div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="DWHSG8526"></a><div class="props_rev_3"><a id="GUID-8B6C8FC5-BDEB-4FEB-878B-03CA337E48B8" name="GUID-8B6C8FC5-BDEB-4FEB-878B-03CA337E48B8"></a><h5 id="DWHSG-GUID-8B6C8FC5-BDEB-4FEB-878B-03CA337E48B8" class="sect5"><span class="enumeration_section">12.2.6.4 </span>About Handling of the HAVING Clause in Query Rewrite
                     </h5>
                     <div>
                        <p>Query rewrite can also occur when the query specifies a range of values for an aggregate in the <code class="codeph">HAVING</code> clause, such as <code class="codeph">SUM(s.amount_sold)</code> <code class="codeph">BETWEEN</code> <code class="codeph">10000</code> <code class="codeph">AND</code> <code class="codeph">20000</code>, as long as the range specified is within the range specified in the materialized view.
                        </p><pre class="oac_no_warn" dir="ltr">CREATE MATERIALIZED VIEW product_sales_mv
BUILD IMMEDIATE
REFRESH FORCE
ENABLE QUERY REWRITE AS
SELECT p.prod_name, SUM(s.amount_sold) AS dollar_sales
FROM products p, sales s
WHERE p.prod_id = s.prod_id
GROUP BY prod_name
HAVING SUM(s.amount_sold) BETWEEN 5000 AND 50000;
</pre><p>Then, a query such as the following could be rewritten:</p><pre class="oac_no_warn" dir="ltr">SELECT p.prod_name, SUM(s.amount_sold) AS dollar_sales
FROM products p, sales s WHERE p.prod_id = s.prod_id
GROUP BY prod_name
HAVING SUM(s.amount_sold) BETWEEN 10000 AND 20000;
</pre><p>This query is rewritten as follows:</p><pre class="oac_no_warn" dir="ltr">SELECT mv.prod_name, mv.dollar_sales FROM product_sales_mv mv
WHERE mv.dollar_sales BETWEEN 10000 AND 20000;</pre></div>
                  </div><a id="DWHSG8527"></a><div class="props_rev_3"><a id="GUID-191815BB-D689-4A2F-B1AD-32B88BC5CF44" name="GUID-191815BB-D689-4A2F-B1AD-32B88BC5CF44"></a><h5 id="DWHSG-GUID-191815BB-D689-4A2F-B1AD-32B88BC5CF44" class="sect5"><span class="enumeration_section">12.2.6.5 </span>About Query Rewrite When the Materialized View has an IN-List
                     </h5>
                     <div>
                        <p>You can use query rewrite when the materialized view contains an <code class="codeph">IN</code>-list. For example, given the following materialized view definition:
                        </p><pre class="oac_no_warn" dir="ltr">CREATE MATERIALIZED VIEW popular_promo_sales_mv
BUILD IMMEDIATE
REFRESH FORCE
ENABLE QUERY REWRITE AS 
SELECT p.promo_name, SUM(s.amount_sold) AS sum_amount_sold
FROM  promotions p, sales s
WHERE s.promo_id = p.promo_id
AND p.promo_name IN ('coupon', 'premium', 'giveaway')
GROUP BY promo_name;
</pre><p>The following query can be rewritten:</p><pre class="oac_no_warn" dir="ltr">SELECT p.promo_name, SUM(s.amount_sold)
FROM  promotions p, sales s
WHERE s.promo_id = p.promo_id AND p.promo_name IN ('coupon', 'premium')
GROUP BY p.promo_name;
</pre><p>This query is rewritten as follows:</p><pre class="oac_no_warn" dir="ltr">SELECT * FROM popular_promo_sales_mv mv
WHERE mv.promo_name IN ('coupon', 'premium');</pre></div>
                  </div>
               </div><a id="DWHSG08026"></a><div class="props_rev_3"><a id="GUID-A32547B4-7E20-4EAB-B3B7-A7DBC1E5B4D8" name="GUID-A32547B4-7E20-4EAB-B3B7-A7DBC1E5B4D8"></a><h4 id="DWHSG-GUID-A32547B4-7E20-4EAB-B3B7-A7DBC1E5B4D8" class="sect4"><span class="enumeration_section">12.2.7 </span>Partition Change Tracking (PCT) Rewrite
                  </h4>
                  <div>
                     <p>PCT rewrite enables the optimizer to accurately rewrite queries with fresh data using materialized views that are only partially fresh. To do so, Oracle Database keeps track of which partitions in the detail tables have been updated. Oracle Database then tracks which rows in the materialized view originate from the affected partitions in the detail tables. The optimizer is then able to use those portions of the materialized view that are known to be fresh. You can check details about freshness with the <code class="codeph">DBA_MVIEWS</code>, <code class="codeph">DBA_DETAIL_RELATIONS</code>, and <code class="codeph">DBA_MVIEW_DETAIL_PARTITION</code> views. See <span class="q">"<a href="refreshing-materialized-views.html#GUID-5B145F5C-C368-450D-8768-22D138A2ED39">Viewing Partition Freshness</a>"</span> for examples of using these views.
                     </p>
                     <p>The optimizer uses PCT rewrite in <code class="codeph">QUERY_REWRITE_INTEGRITY = ENFORCED</code> and <code class="codeph">TRUSTED</code> modes. The optimizer does not use PCT rewrite in <code class="codeph">STALE_TOLERATED</code> mode because data freshness is not considered in that mode. Also, for PCT rewrite to occur, a <code class="codeph">WHERE</code> clause is required.
                     </p>
                     <p>You can use<a id="d44607e2504" class="indexterm-anchor"></a><a id="d44607e2506" class="indexterm-anchor"></a> PCT rewrite with partitioning, but hash partitioning is not supported. The following topics discuss aspects of using PCT:
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="advanced-query-rewrite-materialized-views.html#GUID-4C807F5F-B382-406B-A9AE-4E480BD002C3">PCT Rewrite Based on Range Partitioned Tables</a></p>
                        </li>
                        <li>
                           <p><a href="advanced-query-rewrite-materialized-views.html#GUID-DBF2A861-38DE-428F-8626-C158CB8D4DC8">PCT Rewrite Based on Range-List Partitioned Tables</a></p>
                        </li>
                        <li>
                           <p><a href="advanced-query-rewrite-materialized-views.html#GUID-6E5FEC09-4F3B-477A-A106-02E86112F8F5">PCT Rewrite Based on List Partitioned Tables</a></p>
                        </li>
                        <li>
                           <p><a href="advanced-query-rewrite-materialized-views.html#GUID-DE6C1BA0-9FC5-416B-9743-F3F15BB45EBC">PCT Rewrite and PMARKER</a></p>
                        </li>
                        <li>
                           <p><a href="advanced-query-rewrite-materialized-views.html#GUID-2AC7AFAB-F76C-4B97-9C5D-0A401336E89F">PCT Rewrite Using Rowid as PMARKER</a></p>
                        </li>
                     </ul>
                  </div><a id="DWHSG8528"></a><div class="props_rev_3"><a id="GUID-4C807F5F-B382-406B-A9AE-4E480BD002C3" name="GUID-4C807F5F-B382-406B-A9AE-4E480BD002C3"></a><h5 id="DWHSG-GUID-4C807F5F-B382-406B-A9AE-4E480BD002C3" class="sect5"><span class="enumeration_section">12.2.7.1 </span>PCT Rewrite Based on Range Partitioned Tables
                     </h5>
                     <div>
                        <p>The following example illustrates a PCT rewrite example where the materialized view is PCT enabled through partition key and the underlying base table is range partitioned on the time key.</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE part_sales_by_time (time_id, prod_id, amount_sold,
       quantity_sold)
  PARTITION BY RANGE (time_id)
  (
    PARTITION old_data
      VALUES LESS THAN (TO_DATE('01-01-1999', 'DD-MM-YYYY'))
      PCTFREE 0
      STORAGE (INITIAL 8M),
    PARTITION quarter1
      VALUES LESS THAN (TO_DATE('01-04-1999', 'DD-MM-YYYY'))
      PCTFREE 0
      STORAGE (INITIAL 8M),
    PARTITION quarter2
      VALUES LESS THAN (TO_DATE('01-07-1999', 'DD-MM-YYYY'))
      PCTFREE 0
      STORAGE (INITIAL 8M),
    PARTITION quarter3
      VALUES LESS THAN (TO_DATE('01-10-1999', 'DD-MM-YYYY'))
      PCTFREE 0
      STORAGE (INITIAL 8M),
    PARTITION quarter4
      VALUES LESS THAN (TO_DATE('01-01-2000', 'DD-MM-YYYY'))
      PCTFREE 0
      STORAGE (INITIAL 8M),
    PARTITION max_partition
      VALUES LESS THAN (MAXVALUE)
      PCTFREE 0
      STORAGE (INITIAL 8M)
  )
  AS
  SELECT s.time_id, s.prod_id, s.amount_sold, s.quantity_sold
  FROM sales s;
 </pre><p>Then create a materialized view that contains the total number of products sold by date.</p><pre class="oac_no_warn" dir="ltr">CREATE MATERIALIZED VIEW  sales_in_1999_mv
  BUILD IMMEDIATE
  REFRESH FORCE ON DEMAND
  ENABLE QUERY REWRITE
  AS
  SELECT s.time_id, s.prod_id, p.prod_name, SUM(quantity_sold)
  FROM part_sales_by_time s, products p
  WHERE p.prod_id = s.prod_id
    AND s.time_id BETWEEN TO_DATE('01-01-1999', 'DD-MM-YYYY')
    AND TO_DATE('31-12-1999', 'DD-MM-YYYY')
  GROUP BY s.time_id, s.prod_id, p.prod_name;
</pre><p>Note that the following query will be rewritten with materialized view <code class="codeph">sales_in_1999_mv</code>:
                        </p><pre class="oac_no_warn" dir="ltr">SELECT s.time_id, p.prod_name, SUM(quantity_sold)
  FROM part_sales_by_time s, products p
  WHERE p.prod_id = s.prod_id
    AND s.time_id &lt; TO_DATE('01-02-1999', 'DD-MM-YYYY')
    AND s.time_id &gt;= TO_DATE('01-01-1999', 'DD-MM-YYYY')
  GROUP BY s.time_id, p.prod_name;
</pre><p>If you add a row to <code class="codeph">quarter4</code> in <code class="codeph">part_sales_by_time</code> as:
                        </p><pre class="oac_no_warn" dir="ltr">INSERT INTO part_sales_by_time 
  VALUES (TO_DATE('26-12-1999', 'DD-MM-YYYY'),38920,2500, 20);
 
commit;
</pre><p>Then the materialized view <code class="codeph">sales_in_1999_mv</code> becomes stale. With PCT rewrite, you can rewrite queries that request data from only the fresh portions of the materialized view. Note that because the materialized view <code class="codeph">sales_in_1999_mv</code> has the <code class="codeph">time_id</code> in its <code class="codeph">SELECT</code> and <code class="codeph">GROUP</code> <code class="codeph">BY</code> clause, it is PCT enabled so the following query will be rewritten successfully as no data from <code class="codeph">quarter4</code> is requested.
                        </p><pre class="oac_no_warn" dir="ltr">SELECT s.time_id, p.prod_name, SUM(quantity_sold)
  FROM part_sales_by_time s, products p
  WHERE p.prod_id = s.prod_id
  AND s.time_id &lt; TO_DATE('01-07-1999', 'DD-MM-YYYY')
  AND s.time_id &gt;= TO_DATE('01-03-1999', 'DD-MM-YYYY')
  GROUP BY s.time_id, p.prod_name;
</pre><p>The following query cannot be rewritten if multiple materialized view rewrite is set to off. Because multiple materialized view rewrite is on by default, the following query is rewritten with materialized view and base tables:</p><pre class="oac_no_warn" dir="ltr">SELECT s.time_id, p.prod_name, SUM(quantity_sold)
  FROM part_sales_by_time s, products p
  WHERE p.prod_id = s.prod_id
  AND s.time_id &lt; TO_DATE('31-10-1999', 'DD-MM-YYYY') AND
      s.time_id &gt; TO_DATE('01-07-1999', 'DD-MM-YYYY')
  GROUP BY s.time_id, p.prod_name;</pre></div>
                  </div><a id="DWHSG8530"></a><a id="DWHSG8529"></a><div class="props_rev_3"><a id="GUID-DBF2A861-38DE-428F-8626-C158CB8D4DC8" name="GUID-DBF2A861-38DE-428F-8626-C158CB8D4DC8"></a><h5 id="DWHSG-GUID-DBF2A861-38DE-428F-8626-C158CB8D4DC8" class="sect5"><span class="enumeration_section">12.2.7.2 </span>PCT Rewrite Based on Range-List Partitioned Tables
                     </h5>
                     <div>
                        <p>If the detail table is range-list partitioned, a materialized view that depends on this detail table can support PCT at both the partitioning and subpartitioning levels. If both the partition and subpartition keys are present in the materialized view, PCT can be done at a finer granularity; materialized view refreshes can be done to smaller portions of the materialized view and more queries could be rewritten with a stale materialized view. Alternatively, if only the partition key is present in the materialized view, PCT can be done with courser granularity.</p>
                        <p>Consider the following range-list partitioned table:</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE sales_par_range_list
 (calendar_year, calendar_month_number, day_number_in_month,
  country_name, prod_id, prod_name, quantity_sold, amount_sold)
PARTITION BY RANGE (calendar_month_number)
SUBPARTITION BY LIST (country_name)
 (PARTITION q1 VALUES LESS THAN (4)
 (SUBPARTITION q1_America VALUES
 ('United States of America', 'Argentina'),
   SUBPARTITION q1_Asia VALUES ('Japan', 'India'),
   SUBPARTITION q1_Europe VALUES ('France', 'Spain', 'Ireland')),
   PARTITION q2 VALUES LESS THAN (7)
  (SUBPARTITION q2_America VALUES
   ('United States of America', 'Argentina'),
   SUBPARTITION q2_Asia VALUES ('Japan', 'India'),
   SUBPARTITION q2_Europe VALUES ('France', 'Spain', 'Ireland')),
     PARTITION q3 VALUES LESS THAN (10)
  (SUBPARTITION q3_America VALUES
   ('United States of America', 'Argentina'),
   SUBPARTITION q3_Asia VALUES ('Japan', 'India'),
   SUBPARTITION q3_Europe VALUES ('France', 'Spain', 'Ireland')),
     PARTITION q4 VALUES LESS THAN (13)
  (SUBPARTITION q4_America VALUES
   ('United States of America', 'Argentina'),
   SUBPARTITION q4_Asia VALUES ('Japan', 'India'),
   SUBPARTITION q4_Europe VALUES ('France', 'Spain', 'Ireland')))
  AS SELECT t.calendar_year, t.calendar_month_number,
     t.day_number_in_month, c1.country_name, s.prod_id,
     p.prod_name, s.quantity_sold, s.amount_sold
  FROM times t, countries c1, products p, sales s, customers c2
  WHERE s.time_id = t.time_id AND s.prod_id = p.prod_id AND
        s.cust_id = c2.cust_id AND c2.country_id = c1.country_id AND
        c1.country_name IN ('United States of America', 'Argentina',
          'Japan', 'India', 'France', 'Spain', 'Ireland');
</pre><p>Then consider the following materialized view <code class="codeph">sum_sales_per_year_month_mv</code>, which has the total amount of products sold each month of each year:
                        </p><pre class="oac_no_warn" dir="ltr">CREATE MATERIALIZED VIEW  sum_sales_per_year_month_mv
BUILD IMMEDIATE
REFRESH FORCE ON DEMAND
ENABLE QUERY REWRITE AS
SELECT s.calendar_year, s.calendar_month_number,
         SUM(s.amount_sold) AS sum_sales, COUNT(*) AS cnt
FROM sales_par_range_list s WHERE s.calendar_year &gt; 1990
GROUP BY s.calendar_year, s.calendar_month_number;
</pre><p><code class="codeph">sales_per_country_mv</code> supports PCT against <code class="codeph">sales_par_range_list</code> at the range partitioning level as its range partition key <code class="codeph">calendar_month_number</code> is in its <code class="codeph">SELECT</code> and <code class="codeph">GROUP</code> <code class="codeph">BY</code> list:
                        </p><pre class="oac_no_warn" dir="ltr">INSERT INTO sales_par_range_list
   VALUES (2001, 3, 25, 'Spain', 20, 'PROD20',  300,  20.50);
</pre><p>This statement inserts a row with <code class="codeph">calendar_month_number = 3</code> and <code class="codeph">country_name = 'Spain'</code>. This row is inserted into partition <code class="codeph">q1</code> subpartition <code class="codeph">Europe</code>. After this <code class="codeph">INSERT</code> statement, <code class="codeph">sum_sales_per_year_month_mv</code> is stale with respect to partition <code class="codeph">q1</code> of <code class="codeph">sales_par_range_list</code>. So any incoming query that accesses data from this partition in <code class="codeph">sales_par_range_list</code> cannot be rewritten, for example, the following statement:
                        </p>
                        <p>Note that the following query accesses data from partitions <code class="codeph">q1</code> and <code class="codeph">q2</code>. Because q1 was updated, the materialized view is stale with respect to <code class="codeph">q1</code> so PCT rewrite is unavailable.
                        </p><pre class="oac_no_warn" dir="ltr">SELECT s.calendar_year, SUM(s.amount_sold) AS sum_sales, COUNT(*) AS cnt
FROM sales_par_range_list s
WHERE s.calendar_year = 2000 
  AND s.calendar_month_number BETWEEN 2 AND 6
GROUP BY s.calendar_year;
</pre><p>An example of a statement that does rewrite after the <code class="codeph">INSERT</code> statement is the following, because it accesses fresh material:
                        </p><pre class="oac_no_warn" dir="ltr">SELECT s.calendar_year, SUM(s.amount_sold) AS sum_sales, COUNT(*) AS cnt
FROM sales_par_range_list s
WHERE s.calendar_year = 2000 AND s.calendar_month_number BETWEEN 5 AND 9
GROUP BY s.calendar_year;
</pre><p><a href="advanced-query-rewrite-materialized-views.html#GUID-DBF2A861-38DE-428F-8626-C158CB8D4DC8__CHDFDGCC">Figure 12-3</a> offers a graphical illustration of what is stale and what is fresh.
                        </p>
                        <div class="figure" id="GUID-DBF2A861-38DE-428F-8626-C158CB8D4DC8__CHDFDGCC">
                           <p class="titleinfigure">Figure 12-3 PCT Rewrite and Range-List Partitioning</p><img src="img/dwhsg115.gif" alt="Description of Figure 12-3 follows" title="Description of Figure 12-3 follows" longdesc="img_text/dwhsg115.html"><br><a href="img_text/dwhsg115.html">Description of "Figure 12-3 PCT Rewrite and Range-List Partitioning"</a></div>
                        <!-- class="figure" -->
                     </div>
                  </div><a id="DWHSG8532"></a><a id="DWHSG8531"></a><div class="props_rev_3"><a id="GUID-6E5FEC09-4F3B-477A-A106-02E86112F8F5" name="GUID-6E5FEC09-4F3B-477A-A106-02E86112F8F5"></a><h5 id="DWHSG-GUID-6E5FEC09-4F3B-477A-A106-02E86112F8F5" class="sect5"><span class="enumeration_section">12.2.7.3 </span>PCT Rewrite Based on List Partitioned Tables
                     </h5>
                     <div>
                        <p>If the <code class="codeph">LIST</code> partitioning key is present in the materialized view's <code class="codeph">SELECT</code> and <code class="codeph">GROUP</code> <code class="codeph">BY</code>, then PCT will be supported by the materialized view. Regardless of the supported partitioning type, if the partition marker or rowid of the detail table is present in the materialized view then PCT is supported by the materialized view on that specific detail table.
                        </p><pre class="oac_no_warn" dir="ltr">CREATE TABLE sales_par_list
(calendar_year, calendar_month_number, day_number_in_month,
 country_name, prod_id, quantity_sold, amount_sold)
 PARTITION BY LIST (country_name)
 (PARTITION America
      VALUES ('United States of America', 'Argentina'),
  PARTITION Asia
      VALUES ('Japan', 'India'),
  PARTITION Europe
      VALUES ('France', 'Spain', 'Ireland'))
  AS SELECT t.calendar_year, t.calendar_month_number, 
         t.day_number_in_month, c1.country_name, s.prod_id, 
         s.quantity_sold, s.amount_sold
  FROM times t, countries c1, sales s, customers c2
  WHERE s.time_id = t.time_id and s.cust_id = c2.cust_id and 
        c2.country_id = c1.country_id and
        c1.country_name IN ('United States of America', 'Argentina',
       'Japan', 'India', 'France', 'Spain', 'Ireland');
</pre><p>If a materialized view is created on the table <code class="codeph">sales_par_list</code>, which has a list partitioning key, PCT rewrite will use that materialized view for potential rewrites.
                        </p>
                        <p>To illustrate this feature, the following example creates a materialized view that has the total amounts sold of every product in each country for each year. The view depends on detail tables <code class="codeph">sales_par_list</code> and <code class="codeph">products</code>.
                        </p><pre class="oac_no_warn" dir="ltr">CREATE MATERIALIZED VIEW sales_per_country_mv
BUILD IMMEDIATE
REFRESH FORCE ON DEMAND
ENABLE QUERY REWRITE AS
SELECT s.calendar_year AS calendar_year, s.country_name AS country_name,
 p.prod_name AS prod_name, SUM(s.amount_sold) AS sum_sales, COUNT(*) AS cnt
FROM sales_par_list s, products p
WHERE s.prod_id = p.prod_id AND s.calendar_year &lt;= 2000
GROUP BY s.calendar_year, s.country_name, prod_name;
</pre><p><code class="codeph">sales_per_country_mv</code> supports PCT against <code class="codeph">sales_par_list</code> as its list partition key <code class="codeph">country_name</code> is in its <code class="codeph">SELECT</code> and <code class="codeph">GROUP</code> <code class="codeph">BY</code> list. Table <code class="codeph">products</code> is not partitioned, so <code class="codeph">sales_per_country_mv</code> does not support PCT against this table.
                        </p>
                        <p>A query could be rewritten (in <code class="codeph">ENFORCED</code> or <code class="codeph">TRUSTED</code> modes) in terms of <code class="codeph">sales_per_country_mv</code> even if <code class="codeph">sales_per_country_mv</code> is stale if the incoming query accesses only fresh parts of the materialized view. You can determine which parts of the materialized view are <code class="codeph">FRESH</code> only if the updated tables are PCT enabled in the materialized view. If non-PCT enabled tables have been updated, then the rewrite is not possible with fresh data from that specific materialized view as you cannot identify the <code class="codeph">FRESH</code> portions of the materialized view.
                        </p>
                        <p><code class="codeph">sales_per_country_mv</code> supports PCT on <code class="codeph">sales_par_list</code> and does not support PCT on table product. If table <code class="codeph">products</code> is updated, then PCT rewrite is not possible with <code class="codeph">sales_per_country_mv</code> as you cannot tell which portions of the materialized view are <code class="codeph">FRESH</code>.
                        </p>
                        <p>The following updates <code class="codeph">sales_par_list</code> as follows:
                        </p><pre class="oac_no_warn" dir="ltr">INSERT INTO sales_par_list VALUES (2000, 10, 22, 'France', 900, 20, 200.99);
</pre><p>This statement inserted a row into partition Europe in table <code class="codeph">sales_par_list</code>. Now <code class="codeph">sales_per_country_mv</code> is stale, but PCT rewrite (in <code class="codeph">ENFORCED</code> and <code class="codeph">TRUSTED</code> modes) is possible as this materialized view supports PCT against table <code class="codeph">sales_par_list</code>. The fresh and stale areas of the materialized view are identified based on the partitioned detail table <code class="codeph">sales_par_list</code>.
                        </p>
                        <p><a href="advanced-query-rewrite-materialized-views.html#GUID-6E5FEC09-4F3B-477A-A106-02E86112F8F5__I1015969">Figure 12-4</a> illustrates what is fresh and what is stale in this example.
                        </p>
                        <div class="figure" id="GUID-6E5FEC09-4F3B-477A-A106-02E86112F8F5__I1015969">
                           <p class="titleinfigure">Figure 12-4 PCT Rewrite and List Partitioning</p><img src="img/dwhsg114.gif" alt="Description of Figure 12-4 follows" title="Description of Figure 12-4 follows" longdesc="img_text/dwhsg114.html"><br><a href="img_text/dwhsg114.html">Description of "Figure 12-4 PCT Rewrite and List Partitioning"</a></div>
                        <!-- class="figure" -->
                        <p>Consider the following query:</p><pre class="oac_no_warn" dir="ltr">SELECT s.country_name, p.prod_name, SUM(s.amount_sold) AS sum_sales, 
   COUNT(*) AS cnt
FROM sales_par_list s, products p
WHERE s.prod_id = p.prod_id AND s.calendar_year = 2000
  AND s.country_name IN ('United States of America', 'Japan')
GROUP BY s.country_name, p.prod_name;
</pre><p>This query accesses partitions <code class="codeph">America</code> and <code class="codeph">Asia</code> in <code class="codeph">sales_par_list</code>; these partition have not been updated so rewrite is possible with stale materialized view <code class="codeph">sales_per_country_mv</code> as this query will access only <code class="codeph">FRESH</code> portions of the materialized view.
                        </p>
                        <p>The query is rewritten in terms of <code class="codeph">sales_per_country_mv</code> as follows:
                        </p><pre class="oac_no_warn" dir="ltr">SELECT country_name, prod_name, SUM(sum_sales) AS sum_sales, SUM(cnt) AS cnt
FROM sales_per_country_mv WHERE calendar_year = 2000 
  AND country_name IN ('United States of America', 'Japan')
GROUP BY country_name, prod_name;
</pre><p>Now consider the following query:</p><pre class="oac_no_warn" dir="ltr">SELECT s.country_name,  p.prod_name,
 SUM(s.amount_sold) AS sum_sales, COUNT(*) AS cnt
FROM sales_par_list s, products p
WHERE  s.prod_id = p.prod_id AND s.calendar_year = 1999
  AND s.country_name IN ('Japan', 'India', 'Spain')
GROUP BY s.country_name, p.prod_name;
</pre><p>This query accesses partitions <code class="codeph">Europe</code> and <code class="codeph">Asia</code> in <code class="codeph">sales_par_list</code>. Partition <code class="codeph">Europe</code> has been updated, so this query cannot be rewritten in terms of <code class="codeph">sales_per_country_mv</code> as the required data from the materialized view is stale.
                        </p>
                        <p>You will be able to rewrite after any kinds of updates to <code class="codeph">sales_par_list</code>, that is DMLs, direct loads and Partition Maintenance Operations (PMOPs) if the incoming query accesses <code class="codeph">FRESH</code> parts of the materialized view.
                        </p>
                     </div>
                  </div><a id="DWHSG8534"></a><a id="DWHSG8533"></a><div class="props_rev_3"><a id="GUID-DE6C1BA0-9FC5-416B-9743-F3F15BB45EBC" name="GUID-DE6C1BA0-9FC5-416B-9743-F3F15BB45EBC"></a><h5 id="DWHSG-GUID-DE6C1BA0-9FC5-416B-9743-F3F15BB45EBC" class="sect5"><span class="enumeration_section">12.2.7.4 </span>PCT Rewrite and PMARKER
                     </h5>
                     <div>
                        <p>Whe<a id="d44607e2960" class="indexterm-anchor"></a><a id="d44607e2964" class="indexterm-anchor"></a>n a partition marker is provided, the query rewrite capabilities are limited to rewrite queries that access whole detail table partitions as all rows from a specific partition have the same pmarker value. That is, if a query accesses a portion of a detail table partition, it is not rewritten even if that data corresponds to a <code class="codeph">FRESH</code> portion of the materialized view. Now <code class="codeph">FRESH</code> portions of the materialized view are determined by the pmarker value. To determine which rows of the materialized view are fresh, you associate freshness with the marker value, so all rows in the materialized view with a specific pmarker value are <code class="codeph">FRESH</code> or are <code class="codeph">STALE</code>.
                        </p>
                        <p>The following creates a materialized view has the total amounts sold of every product in each detail table partition of <code class="codeph">sales_par_list</code> for each year. This materialized view will also depend on detail table <code class="codeph">products</code> as shown in the following:
                        </p><pre class="oac_no_warn" dir="ltr">CREATE MATERIALIZED VIEW sales_per_dt_partition_mv
BUILD IMMEDIATE
REFRESH FORCE ON DEMAND
ENABLE QUERY REWRITE AS
SELECT s.calendar_year AS calendar_year, p.prod_name AS prod_name,
       DBMS_MVIEW.PMARKER(s.rowid) pmarker,
       SUM(s.amount_sold) AS sum_sales, COUNT(*) AS cnt
FROM sales_par_list s, products p
WHERE s.prod_id = p.prod_id AND s.calendar_year &gt; 2000
GROUP BY s.calendar_year, DBMS_MVIEW.PMARKER(s.rowid), p.prod_name;
</pre><p>The materialized view <code class="codeph">sales_per_dt_partition_mv</code> provides the sum of sales for each detail table partition. This materialized view supports PCT rewrite against table <code class="codeph">sales_par_list</code> because the partition marker is in its <code class="codeph">SELECT</code> and <code class="codeph">GROUP</code> <code class="codeph">BY</code> clauses. <a href="advanced-query-rewrite-materialized-views.html#GUID-DE6C1BA0-9FC5-416B-9743-F3F15BB45EBC__g1021737" title="Partition Names and Their Pmarkers">Table 12-2</a> lists the partition names and their pmarkers for this example.
                        </p>
                        <div class="tblformal" id="GUID-DE6C1BA0-9FC5-416B-9743-F3F15BB45EBC__g1021737">
                           <p class="titleintable">Table 12-2 Partition Names and Their Pmarkers</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="Partition Names and Their Pmarkers" summary="Partition Names and Their Pmarkers" width="100%" frame="hsides" border="1" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="30%" id="d44607e3024">Partition Name</th>
                                    <th align="left" valign="bottom" width="70%" id="d44607e3027">Pmarker</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="30%" id="d44607e3032" headers="d44607e3024 ">
                                       <p>America</p>
                                    </td>
                                    <td align="left" valign="top" width="70%" headers="d44607e3032 d44607e3027 ">
                                       <p>1000</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="30%" id="d44607e3039" headers="d44607e3024 ">
                                       <p>Asia</p>
                                    </td>
                                    <td align="left" valign="top" width="70%" headers="d44607e3039 d44607e3027 ">
                                       <p>1001</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="30%" id="d44607e3046" headers="d44607e3024 ">
                                       <p>Europe</p>
                                    </td>
                                    <td align="left" valign="top" width="70%" headers="d44607e3046 d44607e3027 ">
                                       <p>1002</p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <p>Then update the table <code class="codeph">sales_par_list</code> as follows:
                        </p><pre class="oac_no_warn" dir="ltr">DELETE FROM sales_par_list WHERE country_name = 'India';
</pre><p>You have deleted rows from partition <code class="codeph">Asia</code> in table <code class="codeph">sales_par_list</code>. Now <code class="codeph">sales_per_dt_partition_mv</code> is stale, but PCT rewrite (in <code class="codeph">ENFORCED</code> and <code class="codeph">TRUSTED</code> modes) is possible as this materialized view supports PCT (pmarker based) against table <code class="codeph">sales_par_list</code>.
                        </p>
                        <p>Now consider the following query:</p><pre class="oac_no_warn" dir="ltr">SELECT p.prod_name, SUM(s.amount_sold) AS sum_sales, COUNT(*) AS cnt
FROM sales_par_list s, products p
WHERE  s.prod_id = p.prod_id AND s.calendar_year = 2001 AND
       s.country_name IN ('United States of America', 'Argentina')
GROUP BY p.prod_name;
</pre><p>This query can be rewritten in terms of <code class="codeph">sales_per_dt_partition_mv</code> as all the data corresponding to a detail table partition is accessed, and the materialized view is <code class="codeph">FRESH</code> with respect to this data. This query accesses all data in partition <code class="codeph">America</code>, which has not been updated.
                        </p>
                        <p>The query is rewritten in terms of <code class="codeph">sales_per_dt_partition_mv</code> as follows:
                        </p><pre class="oac_no_warn" dir="ltr">SELECT prod_name, SUM(sum_sales) AS sum_sales, SUM(cnt) AS cnt
FROM sales_per_dt_partition_mv
WHERE calendar_year = 2001 AND pmarker = 1000
GROUP BY prod_name;</pre></div>
                  </div><a id="DWHSG8535"></a><div class="props_rev_3"><a id="GUID-2AC7AFAB-F76C-4B97-9C5D-0A401336E89F" name="GUID-2AC7AFAB-F76C-4B97-9C5D-0A401336E89F"></a><h5 id="DWHSG-GUID-2AC7AFAB-F76C-4B97-9C5D-0A401336E89F" class="sect5"><span class="enumeration_section">12.2.7.5 </span>PCT Rewrite Using Rowid as PMARKER
                     </h5>
                     <div>
                        <p>A materialized view supports PCT rewrite provided a partition key or a partition marker is provided in its <code class="codeph">SELECT</code> and <code class="codeph">GROUP</code> <code class="codeph">BY</code> clause, if there is a <code class="codeph">GROUP</code> <code class="codeph">BY</code> clause. You can use the rowids of the partitioned table instead of the pmarker or the partition key. Note that Oracle converts the rowids into pmarkers internally. Consider the following table:
                        </p><pre class="oac_no_warn" dir="ltr">CREATE TABLE product_par_list
(prod_id, prod_name, prod_category,
 prod_subcategory, prod_list_price)
 PARTITION BY LIST (prod_category)
 (PARTITION prod_cat1
      VALUES ('Boys', 'Men'),
  PARTITION prod_cat2
      VALUES ('Girls', 'Women'))
 AS
   SELECT prod_id, prod_name, prod_category, 
      prod_subcategory, prod_list_price
   FROM products;
</pre><p>Let us create the following materialized view on tables, <code class="codeph">sales_par_list</code> and <code class="codeph">product_par_list</code>:
                        </p><pre class="oac_no_warn" dir="ltr">CREATE MATERIALIZED VIEW  sum_sales_per_category_mv
BUILD IMMEDIATE
REFRESH FORCE ON DEMAND
ENABLE QUERY REWRITE AS
SELECT p.rowid prid, p.prod_category, 
       SUM (s.amount_sold) sum_sales, COUNT(*) cnt
FROM sales_par_list s, product_par_list p
WHERE s.prod_id = p.prod_id and s.calendar_year &lt;= 2000
GROUP BY p.rowid, p.prod_category;
</pre><p>All the limitations that apply to pmarker rewrite apply here as well. The incoming query should access a whole partition for the query to be rewritten. The following pmarker table is used in this case:</p><pre class="oac_no_warn" dir="ltr">product_par_list       pmarker value
----------------       -------------
prod_cat1                      1000
prod_cat2                      1001
prod_cat3                      1002
</pre><p>Then update table <code class="codeph">product_par_list</code> as follows:
                        </p><pre class="oac_no_warn" dir="ltr">DELETE FROM product_par_list WHERE prod_name = 'MEN';
</pre><p>So <code class="codeph">sum_sales_per_category_mv</code> is stale with respect to partition <code class="codeph">prod_list1</code> from <code class="codeph">product_par_list</code>.
                        </p>
                        <p>Now consider the following query:</p><pre class="oac_no_warn" dir="ltr">SELECT p.prod_category, SUM(s.amount_sold) AS sum_sales, COUNT(*) AS cnt
FROM sales_par_list s, product_par_list p
WHERE  s.prod_id = p.prod_id AND p.prod_category IN
       ('Girls', 'Women') AND s.calendar_year &lt;= 2000
GROUP BY p.prod_category;
</pre><p>This query can be rewritten in terms of <code class="codeph">sum_sales_per_category_mv</code> as all the data corresponding to a detail table partition is accessed, and the materialized view is <code class="codeph">FRESH</code> with respect to this data. This query accesses all data in partition <code class="codeph">prod_cat2</code>, which has not been updated. Following is the rewritten query in terms of <code class="codeph">sum_sales_per_category_mv</code>:
                        </p><pre class="oac_no_warn" dir="ltr">SELECT prod_category, sum_sales, cnt
FROM sum_sales_per_category_mv WHERE DBMS_MVIEW.PMARKER(srid) IN (1000)
GROUP BY prod_category;</pre></div>
                  </div>
               </div><a id="DWHSG8536"></a><a id="DWHSG8537"></a><a id="DWHSG8538"></a><a id="DWHSG8539"></a><a id="DWHSG8540"></a><a id="DWHSG8541"></a><a id="DWHSG8542"></a><a id="DWHSG8543"></a><a id="DWHSG8544"></a><a id="DWHSG8545"></a><a id="DWHSG08027"></a><div class="props_rev_3"><a id="GUID-CECD1B60-A092-4AA7-AE32-B2DD97EBDD08" name="GUID-CECD1B60-A092-4AA7-AE32-B2DD97EBDD08"></a><h4 id="DWHSG-GUID-CECD1B60-A092-4AA7-AE32-B2DD97EBDD08" class="sect4"><span class="enumeration_section">12.2.8 </span>About Query Rewrite Using Multiple Materialized Views
                  </h4>
                  <div>
                     <div class="section">
                        <p>Que<a id="d44607e3229" class="indexterm-anchor"></a><a id="d44607e3233" class="indexterm-anchor"></a>ry rewrite has been extended to enable the rewrite of a query using multiple materialized views. If query rewrite determines that there is no set of materialized views that returns all of the data, then query rewrite retrieves the remaining data from the base tables.
                        </p>
                        <p>Query rewrite using multiple materialized views can take advantage of many different types and combinations of rewrite, such as using PCT and <code class="codeph">IN</code>-lists. The following examples illustrate some of the queries where query rewrite is now possible.
                        </p>
                        <p>Consider the following two materialized views, <code class="codeph">cust_avg_credit_mv1</code> and <code class="codeph">cust_avg_credit_mv2</code>. <code class="codeph">cust_avg_credit_mv1</code> asks for all customers average credit limit for each postal code that were born between the years 1940 and 1950. <code class="codeph">cust_avg_credit_mv2</code> asks for customers average credit limit for each postal code that were born after 1950 and before or on 1970.
                        </p>
                        <p>The materialized views' definitions for this example are as follows:</p><pre class="oac_no_warn" dir="ltr">CREATE MATERIALIZED VIEW cust_avg_credit_mv1
ENABLE QUERY REWRITE
AS SELECT cust_postal_code, cust_year_of_birth, 
       SUM(cust_credit_limit) AS sum_credit,
       COUNT(cust_credit_limit) AS count_credit
FROM customers
WHERE cust_year_of_birth BETWEEN 1940 AND 1950
GROUP BY cust_postal_code, cust_year_of_birth;

CREATE MATERIALIZED VIEW cust_avg_credit_mv2
ENABLE QUERY REWRITE
AS SELECT cust_postal_code, cust_year_of_birth,
       SUM(cust_credit_limit) AS sum_credit, 
       COUNT(cust_credit_limit) AS count_credit
FROM customers 
WHERE cust_year_of_birth &gt; 1950 AND cust_year_of_birth &lt;= 1970
GROUP BY cust_postal_code, cust_year_of_birth;</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-CECD1B60-A092-4AA7-AE32-B2DD97EBDD08__GUID-2A199DE6-DB16-4999-A4D5-761704D62FFF">Query 1: One Matched Interval in Materialized View and Query</p>
                        <p>Consider a query that asks for all customers average credit limit for each postal code who were born between 1940 and 1970. This query is matched by the interval <code class="codeph">BETWEEN</code> on <code class="codeph">cust_year_of_birth</code>.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section"><pre class="oac_no_warn" dir="ltr">SELECT cust_postal_code, AVG(cust_credit_limit) AS avg_credit
FROM customers c
WHERE cust_year_of_birth BETWEEN 1940 AND 1970
GROUP BY cust_postal_code;
</pre><p>The preceding query can be rewritten in terms of these two materialized views to get all the data as follows:</p><pre class="oac_no_warn" dir="ltr">SELECT v1.cust_postal_code, 
SUM(v1.sum_credit)/SUM(v1.count_credit) AS avg_credit
FROM (SELECT cust_postal_code, sum_credit, count_credit
 FROM <span class="bold">cust_avg_credit_mv1</span> 
 GROUP BY cust_postal_code
 UNION ALL
 SELECT cust_postal_code, sum_credit, count_credit
 FROM <span class="bold">cust_avg_credit_mv2</span>
 GROUP BY cust_postal_code) v1
 GROUP BY v1.cust_postal_code;
</pre><p>Note that the <code class="codeph">UNION</code> <code class="codeph">ALL</code> query is used in an inline view because of the re-aggregation that needs to take place. Note also how query rewrite was the count aggregate to perform this rollup.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-CECD1B60-A092-4AA7-AE32-B2DD97EBDD08__GUID-69EB227B-E5E6-4532-991B-EB8F74ABFB71">Query 2: Query Outside of Data Contained in Materialized View</p>
                        <p>When the materialized view goes beyond the range asked by the query, a filter (also called selection) is added to the rewritten query to drop out the unneeded rows returned by the materialized view. This case is illustrated in the following query:</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section"><pre class="oac_no_warn" dir="ltr">SELECT cust_postal_code, SUM(cust_credit_limit) AS sum_credit
FROM customers c 
WHERE cust_year_of_birth BETWEEN 1945 AND 1955
GROUP BY cust_postal_code;
</pre><p>Query 2 is rewritten as:</p><pre class="oac_no_warn" dir="ltr">SELECT v1.cust_postal_code, SUM(v1.sum_credit)
FROM
(SELECT cust_postal_code, SUM(sum_credit) AS sum_credit
FROM cust_avg_credit_mv1 
WHERE cust_year_of_birth BETWEEN 1945 AND 1950
GROUP BY cust_postal_code
UNION ALL
SELECT cust_postal_code, SUM(sum_credit) AS sum_credit
FROM cust_birth_mv2
WHERE cust_year_of_birth &gt; 1950 AND cust_year_of_birth &lt;= 1955
GROUP BY cust_postal_code) v1
GROUP BY v1.cust_postal_code;</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-CECD1B60-A092-4AA7-AE32-B2DD97EBDD08__GUID-0EFE1C20-5857-4B3C-9311-51B9B4795AEF">Query 3: Requesting More Data Than is in the Materialized View</p>
                        <p>What if a query asks for more data than is contained in the two materialized views? It still rewrites using both materialized views and the data in the base table. In the following example, a new set of materialized views without aggregates is defined It will still rewrite using both materialized views and the data in the base table.</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section"><pre class="oac_no_warn" dir="ltr">CREATE MATERIALIZED VIEW cust_birth_mv1
ENABLE QUERY REWRITE
AS SELECT cust_last_name, cust_first_name, cust_year_of_birth
FROM customers WHERE cust_year_of_birth BETWEEN 1940 AND 1950;

CREATE MATERIALIZED VIEW cust_avg_credit_mv2
ENABLE QUERY REWRITE
AS SELECT cust_last_name, cust_first_name, cust_year_of_birth
FROM customers 
WHERE cust_year_of_birth &gt; 1950 AND cust_year_of_birth &lt;= 1970;
</pre><p>Our queries now require all customers born between 1940 and 1990.</p><pre class="oac_no_warn" dir="ltr">SELECT cust_last_name, cust_first_name 
FROM customers c WHERE cust_year_of_birth BETWEEN 1940 AND 1990;
</pre><p>Query rewrite needs to access the base table to access the customers that were born after 1970 and before or on 1990. Therefore, Query 3 is rewritten as the following:</p><pre class="oac_no_warn" dir="ltr">SELECT cust_last_name, cust_first_name 
FROM cust_birth_mv1 
UNION ALL
SELECT cust_last_name, cust_first_name 
FROM cust_birth_mv2
UNION ALL
SELECT cust_last_name, cust_first_name 
FROM customers c 
WHERE cust_year_of_birth &gt; 1970 AND cust_year_of_birth &lt;= 1990;</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-CECD1B60-A092-4AA7-AE32-B2DD97EBDD08__GUID-98B23A7B-9BE0-472C-B379-675000D9DEAE">Query 4: Requesting Data on Multiple Selection Columns</p>
                        <p>Consider the following query, which asks for all customers who have a credit limit between 1,000 and 10,000 and were born between the years 1945 and 1960. This query is a multi-selection query because it is asking for data on multiple selection columns.</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section"><pre class="oac_no_warn" dir="ltr">SELECT cust_last_name, cust_first_name
FROM customers WHERE cust_year_of_birth BETWEEN 1945 AND 1960 AND
   cust_credit_limit BETWEEN 1000 AND 10000;
</pre><p><a href="advanced-query-rewrite-materialized-views.html#GUID-CECD1B60-A092-4AA7-AE32-B2DD97EBDD08__BABJABEH">Figure 12-5</a> shows a two-selection query, which can be rewritten with the two-selection materialized views described in the following section.
                        </p>
                        <div class="figure" id="GUID-CECD1B60-A092-4AA7-AE32-B2DD97EBDD08__BABJABEH">
                           <p class="titleinfigure">Figure 12-5 Query Rewrite Using Multiple Materialized Views</p><img src="img/dwhsg111.gif" alt="Description of Figure 12-5 follows" title="Description of Figure 12-5 follows" longdesc="img_text/dwhsg111.html"><br><a href="img_text/dwhsg111.html">Description of "Figure 12-5 Query Rewrite Using Multiple Materialized Views"</a></div>
                        <!-- class="figure" -->
                        <p>The graph in <a href="advanced-query-rewrite-materialized-views.html#GUID-CECD1B60-A092-4AA7-AE32-B2DD97EBDD08__BABJABEH">Figure 12-5</a> illustrates the materialized views that can be used to satisfy this query. <code class="codeph">credit_mv1</code> asks for customers that have credit limits between 1,000 and 5,000 and were born between 1945 and 1950. <code class="codeph">credit_mv2</code> asks for customers that have credit limits &gt; 5,000 and &lt;= 10,000 and were born between 1945 and 1960. <code class="codeph">credit_mv3</code> asks for customers that have credit limits between 1,000 and 5,000 and were born after 1950 and before or on 1955. 
                        </p>
                        <p>The materialized views' definitions for this case are as follows:</p><pre class="oac_no_warn" dir="ltr">CREATE MATERIALIZED VIEW credit_mv1
ENABLE QUERY REWRITE
AS SELECT cust_last_name, cust_first_name, 
    cust_credit_limit, cust_year_of_birth
FROM customers
WHERE cust_credit_limit BETWEEN 1000 AND 5000 
AND cust_year_of_birth BETWEEN 1945 AND 1950;

CREATE MATERIALIZED VIEW credit_mv2
ENABLE QUERY REWRITE
AS SELECT cust_last_name, cust_first_name, 
   cust_credit_limit, cust_year_of_birth
FROM customers
WHERE cust_credit_limit &gt; 5000 
   AND cust_credit_limit &lt;= 10000 AND cust_year_of_birth 
   BETWEEN 1945 AND 1960;

CREATE MATERIALIZED VIEW credit_mv3
ENABLE QUERY REWRITE AS
SELECT cust_last_name, cust_first_name, 
   cust_credit_limit, cust_year_of_birth
FROM customers
WHERE cust_credit_limit BETWEEN 1000 AND 5000 
  AND cust_year_of_birth &gt; 1950 AND cust_year_of_birth &lt;= 1955;
</pre><p>Query 4 can be rewritten by using all three materialized views to access most of the data. However, because not all the data can be obtained from these three materialized views, query rewrite also accesses the base tables to retrieve the data for customers who have credit limits between 1,000 and 5,000 and were born between 1955 and 1960.   It is rewritten as follows:</p><pre class="oac_no_warn" dir="ltr">SELECT cust_last_name, cust_first_name
FROM credit_mv1
UNION ALL
SELECT cust_last_name, cust_first_name
FROM credit_mv2
UNION ALL
SELECT cust_last_name, cust_first_name
FROM credit_mv3
UNION ALL
SELECT cust_last_name, cust_first_name
FROM customers
WHERE cust_credit_limit BETWEEN 1000 AND 5000 
  AND cust_year_of_birth &gt; 1955 AND cust_year_of_birth &lt;= 1960;
</pre><p>This example illustrates how a multi-selection query can be rewritten with multiple materialized views. The example was simplified to show no overlapping data among the three materialized views. However, query rewrite can perform similar rewrites.</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-CECD1B60-A092-4AA7-AE32-B2DD97EBDD08__GUID-4960319B-3B95-4920-B6C3-FEBE375B11FB">Query 5: Intervals and Constrained Intervals</p>
                        <p>This example illustrates how a multi-selection query can be rewritten using a single selection materialized view. In this example, there are two intervals in the query and one constrained interval in the materialized view. It asks for customers that have credit limits between 1,000 and 10,000 and were born between 1945 and 1960. But suppose that <code class="codeph">credit_mv1</code> asks for just customers that have credit limits between 1,000 and 5,000. <code class="codeph">credit_mv1</code> is not constrained by a selection in <code class="codeph">cust_year_of_birth</code>, therefore covering the entire range of birth year values for the query.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <div class="figure" id="GUID-CECD1B60-A092-4AA7-AE32-B2DD97EBDD08__BABCIEFD">
                           <p class="titleinfigure">Figure 12-6 Constrained Materialized View Selections</p><img src="img/dwhsg113.gif" alt="Description of Figure 12-6 follows" title="Description of Figure 12-6 follows" longdesc="img_text/dwhsg113.html"><br><a href="img_text/dwhsg113.html">Description of "Figure 12-6 Constrained Materialized View Selections"</a></div>
                        <!-- class="figure" -->
                        <p>The area between the lines in <a href="advanced-query-rewrite-materialized-views.html#GUID-CECD1B60-A092-4AA7-AE32-B2DD97EBDD08__BABCIEFD">Figure 12-6</a> represents the data <code class="codeph">credit1_mv</code>.
                        </p>
                        <p>The new <code class="codeph">credit_mv1</code> is defined as follows:
                        </p><pre class="oac_no_warn" dir="ltr">CREATE MATERIALIZED VIEW credit_mv1
ENABLE QUERY REWRITE
AS SELECT cust_last_name, cust_first_name, 
   cust_credit_limit, cust_year_of_birth
FROM customers WHERE cust_credit_limit BETWEEN 1000 AND 5000;
</pre><p>The query is as follows:</p><pre class="oac_no_warn" dir="ltr">SELECT cust_last_name, cust_first_name
FROM customers WHERE cust_year_of_birth BETWEEN 1945 AND 1960
  AND cust_credit_limit BETWEEN 1000 AND 10000;
</pre><p>And finally the rewritten query is as follows:</p><pre class="oac_no_warn" dir="ltr">SELECT cust_last_name, cust_first_name
FROM credit_mv1 WHERE cust_year_of_birth BETWEEN 1945 AND 1960
UNION ALL
SELECT cust_last_name, cust_first_name
FROM customers WHERE cust_year_of_brith BETWEEN 1945 AND 1960
  AND cust_credit_limit &gt; 5000 AND cust_credit_limit &lt;= 10000;
</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-CECD1B60-A092-4AA7-AE32-B2DD97EBDD08__GUID-F509AA24-D808-46BA-BC70-885211B05A95">Query 6: Query has Single Column IN-List and Materialized Views have Single Column Intervals</p>
                        <p>Multiple materialized view query rewrite can process an <code class="codeph">IN</code>-list in the incoming query and rewrite the query in terms of materialized views that have intervals on the same selection column. Given that an <code class="codeph">IN</code>-list represents discrete values in an interval, this rewrite capability is a natural extension to the intervals only scenario described earlier.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>The following is an example of a one column <code class="codeph">IN</code>-list selection in the query and one column interval selection in the materialized views. Consider a query that asks for the number of customers for each country who were born in any of the following year: 1945, 1950, 1955, 1960, 1965, 1970 or 1975. This query is constrained by an <code class="codeph">IN</code>-list on <code class="codeph">cust_year_of_birth</code>.
                        </p><pre class="oac_no_warn" dir="ltr">SELECT c2.country_name, count(c1.country_id)
FROM customers c1, countries c2
WHERE c1.country_id = c2.country_id AND 
   c1.cust_year_of_birth IN (1945, 1950, 1955, 1960, 1965, 1970, 1975)
GROUP BY c2.country_name;
</pre><p>Consider the following two materialized views. <code class="codeph">cust_country_birth_mv1</code> asks for the number of customers for each country that were born between the years 1940 and 1950. <code class="codeph">cust_country_birth_mv2</code> asks for the number of customers for each country that were born after 1950 and before or on 1970. The preceding query can be rewritten in terms of these two materialized views to get the total number of customers for each country born in 1945, 1950, 1955, 1960, 1965 and 1970. The base table access is required to obtain the number of customers that were born in 1975.
                        </p>
                        <p>The materialized views' definitions for this example are as follows:</p><pre class="oac_no_warn" dir="ltr">CREATE MATERIALIZED VIEW cust_country_birth_mv1
ENABLE QUERY REWRITE
AS SELECT c2.country_name, c1.cust_year_of_birth,
 COUNT(c1.country_id) AS count_customers
FROM customers c1, countries c2
WHERE c1.country_id = c2.country_id AND 
      cust_year_of_birth BETWEEN 1940 AND 1950
GROUP BY c2.country_name, c1.cust_year_of_birth;

CREATE MATERIALIZED VIEW cust_country_birth_mv2
ENABLE QUERY REWRITE
AS SELECT c2.country_name, c1.cust_year_of_birth, 
 COUNT(c1.country_id) AS count_customers
FROM customers c1, countries c2
WHERE c1.country_id = c2.country_id AND cust_year_of_birth &gt; 1950 
AND cust_year_of_birth &lt;= 1970
GROUP BY c2.country_name, c1.cust_year_of_birth;
</pre><p>So, Query 6 is rewritten as:</p><pre class="oac_no_warn" dir="ltr">SELECT v1.country_name, SUM(v1.count_customers)
FROM (SELECT country_name, SUM(count_customers) AS count_customers
FROM cust_country_birth_mv1 
WHERE cust_year_of_birth IN (1945, 1950)
GROUP BY country_name
UNION ALL
SELECT country_name, SUM(count_customers) AS count_customers
FROM cust_country_birth_mv2
WHERE cust_year_of_birth IN (1955, 1960, 1965, 1970)
GROUP BY country_name
UNION ALL
SELECT c2.country_name, COUNT(c1.country_id) AS count_customers
FROM customers c1, countries c2
WHERE c1.country_id = c2.country_id AND cust_year_of_birth IN (1975)
GROUP BY c2.country_name) v1
GROUP BY v1.country_name;</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-CECD1B60-A092-4AA7-AE32-B2DD97EBDD08__GUID-B11A24AD-62D2-4C4D-8934-D89ACB2F3DD0">Query 7: PCT Rewrite with Multiple Materialized Views</p>
                        <p>Rewrite with multiple materialized views can also take advantage of PCT rewrite. PCT rewrite refers to the capability of rewriting a query with only the fresh portions of a materialized view when the materialized view is stale. This feature is used in <code class="codeph">ENFORCED</code> or <code class="codeph">TRUSTED</code> integrity modes, and with multiple materialized view rewrite, it can use the fresh portions of the materialized view to get the fresh data from it, and go to the base table to get the stale data. So the rewritten query will <code class="codeph">UNION</code> <code class="codeph">ALL</code> only the fresh data from one or more materialized views and obtain the rest of the data from the base tables to answer the query. Therefore, all the PCT rules and conditions apply here as well. The materialized view should be PCT enabled and the changes made to the base table should be such that the fresh and stale portions of the materialized view can be clearly identified.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>This example assumes you have a query that asks for customers who have credit limits between 1,000 and 10,000 and were born between 1945 and 1964. Also, the customer table is partitioned by <code class="codeph">cust_date_of_birth</code> and there is a PCT-enabled materialized view called <code class="codeph">credit_mv1</code> that also asks for customers who have a credit limit between 1,000 and 10,000 and were born between 1945 and 1964.
                        </p><pre class="oac_no_warn" dir="ltr">SELECT cust_last_name, cust_first_name
FROM customers WHERE cust_credit_limit BETWEEN 1000 AND 10000;
</pre><p>In <a href="advanced-query-rewrite-materialized-views.html#GUID-CECD1B60-A092-4AA7-AE32-B2DD97EBDD08__BABEFEFH">Figure 12-7</a>, the diagram illustrates those regions of the materialized view that are fresh (dark) and stale (light) with respect to the base table partitions <code class="codeph">p1</code>-<code class="codeph">p6</code>.
                        </p>
                        <div class="figure" id="GUID-CECD1B60-A092-4AA7-AE32-B2DD97EBDD08__BABEFEFH">
                           <p class="titleinfigure">Figure 12-7 PCT and Multiple Materialized View Rewrite</p><img src="img/dwhsg112.gif" alt="Description of Figure 12-7 follows" title="Description of Figure 12-7 follows" longdesc="img_text/dwhsg112.html"><br><a href="img_text/dwhsg112.html">Description of "Figure 12-7 PCT and Multiple Materialized View Rewrite"</a></div>
                        <!-- class="figure" -->
                        <p>Let us say that you are in <code class="codeph">ENFORCED</code> mode and that <code class="codeph">p1</code>, <code class="codeph">p2</code>, <code class="codeph">p3</code>, <code class="codeph">p5</code>, and <code class="codeph">p6</code> of the customer table are fresh and partition <code class="codeph">p4</code> is stale. This means that all partitions of <code class="codeph">credit_mv1</code> cannot be used to answer the query. The rewritten query must get the results for customer partition <code class="codeph">p4</code> from some other materialized view or as shown in this example, from the base table. Below, you can see part of the table definition for the <code class="codeph">customers</code> table showing how the table is partitioned:
                        </p><pre class="oac_no_warn" dir="ltr">CREATE TABLE customers
(PARTITION BY RANGE (cust_year_of_birth)
 PARTITION p1 VALUES LESS THAN (1945),
 PARTITION p2 VALUES LESS THAN (1950), 
 PARTITION p3 VALUES LESS THAN (1955),
 PARTITION p4 VALUES LESS THAN (1960),
 PARTITION p5 VALUES LESS THAN (1965),
 PARTITION p6 VALUES LESS THAN (1970);
</pre><p>The materialized view definition for the preceding example is as follows:</p><pre class="oac_no_warn" dir="ltr">CREATE MATERIALIZED VIEW credit_mv1
ENABLE QUERY REWRITE
AS SELECT cust_last_name, cust_first_name, 
   cust_credit_limit, cust_year_of_birth
FROM customers
WHERE cust_credit_limit BETWEEN 1000 AND 10000 
AND cust_year_of_birth BETWEEN 1945 AND 1964;
</pre><p>Note that this materialized view is PCT enabled with respect to table <code class="codeph">customers</code>.
                        </p>
                        <p>The rewritten query is as follows:</p><pre class="oac_no_warn" dir="ltr">SELECT cust_last_name, cust_first_name FROM <span class="bold">credit_mv1</span>
WHERE cust_credit_limit BETWEEN 1000 AND 10000 AND
   (cust_year_of_birth &gt;= 1945 AND cust_year_of_birth &lt; 1955 OR
    cust_year_of_birth BETWEEN 1945 AND 1964)
UNION ALL
SELECT cust_last_name, cust_first_name
FROM customers WHERE cust_credit_limit BETWEEN 1000 AND 10000 
  AND cust_year_of_birth &lt; 1960 AND cust_year_of_birth &gt;= 1955;</pre></div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="DWHSG0803"></a><div class="props_rev_3"><a id="GUID-96BFEEAA-1C8A-4F8A-9EAF-6CDD9B148EA6" name="GUID-96BFEEAA-1C8A-4F8A-9EAF-6CDD9B148EA6"></a><h3 id="DWHSG-GUID-96BFEEAA-1C8A-4F8A-9EAF-6CDD9B148EA6" class="sect3"><span class="enumeration_section">12.3 </span>Other Query Rewrite Considerations
               </h3>
               <div>
                  <p>The following topics discusses some of the other cases when query rewrite is possible:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="advanced-query-rewrite-materialized-views.html#GUID-515C1FF2-E32D-40A8-8138-CD31DFC85568">About Query Rewrite Using Nested Materialized Views</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-query-rewrite-materialized-views.html#GUID-ED5B6A2D-BAF9-41BD-B075-008D8BD26AF3">About Query Rewrite in the Presence of Inline Views</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-query-rewrite-materialized-views.html#GUID-6767990B-C315-4C89-BF67-1069DADC373C">About Query Rewrite Using Remote Tables</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-query-rewrite-materialized-views.html#GUID-52DB7F2B-6A39-43F9-9DA5-65892266D48D">About Query Rewrite in the Presence of Duplicate Tables</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-query-rewrite-materialized-views.html#GUID-81BA0698-1E21-4301-B4DE-CD0E727213C6">About Query Rewrite Using Date Folding</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-query-rewrite-materialized-views.html#GUID-1CBDAF40-2412-4A1A-9E41-CF202A6AFDAF">About Query Rewrite Using View Constraints</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-query-rewrite-materialized-views.html#GUID-F9ED3594-159E-451C-AABC-F74FB89B6C94">Query Rewrite Using Set Operator Materialized Views</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-query-rewrite-materialized-views.html#GUID-FF240F3F-2EF8-4D46-8FAE-2B6C57FBA749">About Query Rewrite in the Presence of Grouping Sets</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-query-rewrite-materialized-views.html#GUID-1BA3AB83-5155-47A5-90DA-1D8AEA8E8CC6">Query Rewrite in the Presence of Window Functions</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-query-rewrite-materialized-views.html#GUID-E0B7B0AB-6D13-4AA4-BFCE-119B5834AAAF">Query Rewrite and Expression Matching</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-query-rewrite-materialized-views.html#GUID-5C3DD547-5E57-40CE-9AC9-770214718949">Cursor Sharing and Bind Variables During Query Rewrite</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-query-rewrite-materialized-views.html#GUID-3FD90BE4-F577-4AB9-8762-2701C8B60193">Handling Expressions in Query Rewrite</a></p>
                     </li>
                  </ul>
               </div><a id="DWHSG08031"></a><div class="props_rev_3"><a id="GUID-515C1FF2-E32D-40A8-8138-CD31DFC85568" name="GUID-515C1FF2-E32D-40A8-8138-CD31DFC85568"></a><h4 id="DWHSG-GUID-515C1FF2-E32D-40A8-8138-CD31DFC85568" class="sect4"><span class="enumeration_section">12.3.1 </span>About Query Rewrite Using Nested Materialized Views
                  </h4>
                  <div>
                     <p>Query<a id="d44607e3643" class="indexterm-anchor"></a> rewrite attempts to iteratively take advantage of nested materialized views. Oracle Database first tries to rewrite a query with materialized views having aggregates and joins, then with a materialized view containing only joins. If any of the rewrites succeeds, Oracle repeats that process again until no rewrites are found. For example, assume that you had created materialized views <code class="codeph">join_sales_time_product_mv</code> and <code class="codeph">sum_sales_time_product_mv</code> as in the following:
                     </p><pre class="oac_no_warn" dir="ltr">CREATE MATERIALIZED VIEW join_sales_time_product_mv
ENABLE QUERY REWRITE AS
SELECT p.prod_id, p.prod_name, t.time_id, t.week_ending_day,
       s.channel_id, s.promo_id, s.cust_id, s.amount_sold
FROM   sales s, products p, times t
WHERE  s.time_id=t.time_id AND s.prod_id = p.prod_id;

CREATE MATERIALIZED VIEW sum_sales_time_product_mv
ENABLE QUERY REWRITE AS
SELECT mv.prod_name, mv.week_ending_day, COUNT(*) cnt_all, 
       SUM(mv.amount_sold) sum_amount_sold, 
       COUNT(mv.amount_sold) cnt_amount_sold
FROM join_sales_time_product_mv mv
GROUP BY mv.prod_name, mv.week_ending_day;
</pre><p>Then consider the following query:</p><pre class="oac_no_warn" dir="ltr">SELECT p.prod_name, t.week_ending_day, SUM(s.amount_sold)
FROM sales s, products p, times t
WHERE s.time_id=t.time_id AND s.prod_id=p.prod_id
GROUP BY p.prod_name, t.week_ending_day;
</pre><p>Oracle finds that <code class="codeph">join_sales_time_product_mv</code> is eligible for rewrite. The rewritten query has this form:
                     </p><pre class="oac_no_warn" dir="ltr">SELECT mv.prod_name, mv.week_ending_day, SUM(mv.amount_sold)
FROM join_sales_time_product_mv mv
GROUP BY mv.prod_name, mv.week_ending_day;
</pre><p>Because a rewrite occurred, Oracle tries the process again. This time, the query can be rewritten with single-table aggregate materialized view <code class="codeph">sum_sales_store_time</code> into the following form:
                     </p><pre class="oac_no_warn" dir="ltr">SELECT mv.prod_name, mv.week_ending_day, mv.sum_amount_sold
FROM sum_sales_time_product_mv mv;</pre></div>
               </div><a id="DWHSG08032"></a><div class="props_rev_3"><a id="GUID-ED5B6A2D-BAF9-41BD-B075-008D8BD26AF3" name="GUID-ED5B6A2D-BAF9-41BD-B075-008D8BD26AF3"></a><h4 id="DWHSG-GUID-ED5B6A2D-BAF9-41BD-B075-008D8BD26AF3" class="sect4"><span class="enumeration_section">12.3.2 </span>About Query Rewrite in the Presence of Inline Views
                  </h4>
                  <div>
                     <p>O<a id="d44607e3696" class="indexterm-anchor"></a>racle Database supports query rewrite with inline views in two ways: 
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>when the text from the inline views in the materialized view exactly matches the text in the request query</p>
                        </li>
                        <li>
                           <p>when the request query contains inline views that are equivalent to the inline views in the materialized view</p>
                        </li>
                     </ul>
                     <p>Two inline views are considered equivalent if their <code class="codeph">SELECT</code> lists and <code class="codeph">GROUP</code> <code class="codeph">BY</code> lists are equivalent, <code class="codeph">FROM</code> clauses contain the same or equivalent objects, their join graphs, including all the selections in the <code class="codeph">WHERE</code> clauses are equivalent and their <code class="codeph">HAVING</code> clauses are equivalent.
                     </p>
                     <p>The following examples illustrate how a query with an inline view can rewrite with a materialized view using text match and general inline view rewrites. Consider the following materialized view that contains an inline view:</p><pre class="oac_no_warn" dir="ltr">CREATE MATERIALIZED VIEW SUM_SALES_MV
ENABLE QUERY REWRITE AS
SELECT mv_iv.prod_id, mv_iv.cust_id,
sum(mv_iv.amount_sold) sum_amount_sold
FROM (SELECT prod_id, cust_id, amount_sold
FROM sales, products
WHERE sales.prod_id = products.prod_id) MV_IV
GROUP BY mv_iv.prod_id, mv_iv.cust_id;
</pre><p>The following query has an inline view whose text matches exactly with that of the materialized view's inline view. Hence, the query inline view is internally replaced with the materialized view's inline view so that the query can be rewritten:</p><pre class="oac_no_warn" dir="ltr">SELECT iv.prod_id, iv.cust_id,
SUM(iv.amount_sold) sum_amount_sold
FROM (SELECT prod_id, cust_id, amount_sold
FROM sales, products
WHERE sales.prod_id = products.prod_id) IV
GROUP BY iv.prod_id, iv.cust_id;
</pre><p>The following query has an inline view that does not have exact text match with the inline view in the preceding materialized view. Note that the join predicate in the query inline view is switched. Even though this query does not textually match with that of the materialized view's inline view, query rewrite identifies the query's inline view as equivalent to the materialized view's inline view. As before, the query inline view will be internally replaced with the materialized view's inline view so that the query can be rewritten.</p><pre class="oac_no_warn" dir="ltr">SELECT iv.prod_id, iv.cust_id,
SUM(iv.amount_sold) sum_amount_sold
FROM (SELECT prod_id, cust_id, amount_sold
FROM sales, products
WHERE products.prod_id = sales.prod_id) IV
GROUP BY iv.prod_id, iv.cust_id;
</pre><p>Both of these queries are rewritten with <code class="codeph">SUM_SALES_MV</code> as follows:
                     </p><pre class="oac_no_warn" dir="ltr">SELECT prod_id, cust_id, sum_amount_sold
FROM SUM_SALES_MV;
</pre><p>General inline view rewrite is not supported for queries that contain set operators, <code class="codeph">GROUPING</code> <code class="codeph">SET</code> clauses, nested subqueries, nested inline views, and remote tables.
                     </p>
                  </div>
               </div><a id="DWHSG00323"></a><div class="props_rev_3"><a id="GUID-6767990B-C315-4C89-BF67-1069DADC373C" name="GUID-6767990B-C315-4C89-BF67-1069DADC373C"></a><h4 id="DWHSG-GUID-6767990B-C315-4C89-BF67-1069DADC373C" class="sect4"><span class="enumeration_section">12.3.3 </span>About Query Rewrite Using Remote Tables
                  </h4>
                  <div>
                     <p>Oracle Database supports query rewrite with materialized views that reference tables at a single remote database site. Note that the materialized view should be present at the site where the query is being issued. Because any remote table update cannot be propagated to the local site simultaneously, query rewrite only works in the <code class="codeph">stale_tolerated</code> mode. Whenever a query contains columns that are not found in the materialized view, it uses a technique called join back to rewrite the query. However, if the join back table is not found at the local site, query rewrite does not take place. Also, because the constraint information of the remote tables is not available at the remote site, query rewrite does not make use of any constraint information.
                     </p>
                     <p>The following query contains tables that are found at a single remote site:</p><pre class="oac_no_warn" dir="ltr">SELECT p.prod_id, t.week_ending_day, s.cust_id,
       SUM(s.amount_sold) AS sum_amount_sold
FROM sales@remotedbl s, products@remotedbl p, times@remotedbl t
WHERE s.time_id=t.time_id AND s.prod_id=p.prod_id
GROUP BY p.prod_id, t.week_ending_day, s.cust_id;
</pre><p>The following materialized view is present at the local site, but it references tables that are all found at the remote site:</p><pre class="oac_no_warn" dir="ltr">CREATE MATERIALIZED VIEW sum_sales_prod_week_mv
ENABLE QUERY REWRITE AS
SELECT p.prod_id, t.week_ending_day, s.cust_id,
       SUM(s.amount_sold) AS sum_amount_sold
FROM sales@remotedbl s, products@remotedbl p, times@remotedbl t
WHERE s.time_id=t.time_id AND s.prod_id=p.prod_id
GROUP BY p.prod_id, t.week_ending_day, s.cust_id;
</pre><p>Even though the query references remote tables, it is rewritten using the previous materialized view as follows:</p><pre class="oac_no_warn" dir="ltr">SELECT prod_id, week_ending_day, cust_id,  sum_amount_sold
FROM sum_sales_prod_week_mv;</pre></div>
               </div><a id="DWHSG08034"></a><div class="props_rev_3"><a id="GUID-52DB7F2B-6A39-43F9-9DA5-65892266D48D" name="GUID-52DB7F2B-6A39-43F9-9DA5-65892266D48D"></a><h4 id="DWHSG-GUID-52DB7F2B-6A39-43F9-9DA5-65892266D48D" class="sect4"><span class="enumeration_section">12.3.4 </span>About Query Rewrite in the Presence of Duplicate Tables
                  </h4>
                  <div>
                     <p>Oracle Database <a id="d44607e3817" class="indexterm-anchor"></a>accomplishes query rewrite of queries that contain multiple references to the same tables, or self joins by employing two different strategies. Using the first strategy, you need to ensure that the query and the materialized view definitions have the same aliases for the multiple references to a table. If you do not provide a matching alias, Oracle tries the second strategy, where the joins in the query and the materialized view are compared to match the multiple references in the query to the multiple references in the materialized view.
                     </p>
                     <p>The following is an example of a materialized view and a query. In this example, the query is missing a reference to a column in a table so an exact text match does not work. General query rewrite can occur, however, because the aliases for the table references match.</p>
                     <p>To demonstrate the self-join rewriting possibility with the <code class="codeph">sh</code> sample schema, the following addition is assumed to include the actual shipping and payment date in the fact table, referencing the same dimension table times. This is for demonstration purposes only and does not return any results:
                     </p><pre class="oac_no_warn" dir="ltr">ALTER TABLE sales ADD (time_id_ship DATE);
ALTER TABLE sales ADD (CONSTRAINT time_id_book_fk FOREIGN key (time_id_ship)
 REFERENCES times(time_id) ENABLE NOVALIDATE);
ALTER TABLE sales MODIFY CONSTRAINT time_id_book_fk RELY;
ALTER TABLE sales ADD (time_id_paid DATE);
ALTER TABLE sales ADD (CONSTRAINT time_id_paid_fk FOREIGN KEY (time_id_paid)
 REFERENCES times(time_id) ENABLE NOVALIDATE);
ALTER TABLE sales MODIFY CONSTRAINT time_id_paid_fk RELY;
</pre><p>Now, you can define a materialized view as follows:</p><pre class="oac_no_warn" dir="ltr">CREATE MATERIALIZED VIEW sales_shipping_lag_mv
ENABLE QUERY REWRITE AS
SELECT t1.fiscal_week_number, s.prod_id,
         t2.fiscal_week_number - t1.fiscal_week_number AS lag
FROM times t1, sales s, times t2 
WHERE t1.time_id = s.time_id AND t2.time_id = s.time_id_ship;
</pre><p>The following query fails the exact text match test but is rewritten because the aliases for the table references match:</p><pre class="oac_no_warn" dir="ltr">SELECT s.prod_id, t2.fiscal_week_number - t1.fiscal_week_number AS lag
FROM times t1, sales s, times t2 
WHERE t1.time_id = s.time_id AND t2.time_id = s.time_id_ship;
</pre><p>Note that Oracle Database performs other checks to ensure the correct match of an instance of a multiply instanced table in the request query with the corresponding table instance in the materialized view. For instance, in the following example, Oracle correctly determines that the matching alias names used for the multiple instances of table <code class="codeph">times</code> does not establish a match between the multiple instances of table <code class="codeph">times</code> in the materialized view.
                     </p>
                     <p>The following query cannot be rewritten using <code class="codeph">sales_shipping_lag_mv</code>, even though the alias names of the multiply instanced table <code class="codeph">time</code> match because the joins are not compatible between the instances of <code class="codeph">time</code> aliased by <code class="codeph">t2</code>:
                     </p><pre class="oac_no_warn" dir="ltr">SELECT s.prod_id, t2.fiscal_week_number - t1.fiscal_week_number AS lag
FROM times t1, sales s, times t2 
WHERE t1.time_id = s.time_id AND t2.time_id = s.time_id_paid;
</pre><p>This request query joins the instance of the <code class="codeph">time</code> table aliased by <code class="codeph">t2</code> on the <code class="codeph">s.time_id_paid</code> column, while the materialized views joins the instance of the <code class="codeph">times</code> table aliased by <code class="codeph">t2</code> on the <code class="codeph">s.time_id_ship</code> column. Because the join conditions differ, Oracle correctly determines that rewrite cannot occur.
                     </p>
                     <p>The following query does not have any matching alias in the materialized view, <code class="codeph">sales_shipping_lag_mv</code>, for the table, times. But query rewrite now compares the joins between the query and the materialized view and correctly match the multiple instances of times.
                     </p><pre class="oac_no_warn" dir="ltr">SELECT s.prod_id, x2.fiscal_week_number - x1.fiscal_week_number AS lag
FROM times x1, sales s, times x2
WHERE x1.time_id = s.time_id AND x2.time_id = s.time_id_ship;</pre></div>
               </div><a id="DWHSG08035"></a><div class="props_rev_3"><a id="GUID-81BA0698-1E21-4301-B4DE-CD0E727213C6" name="GUID-81BA0698-1E21-4301-B4DE-CD0E727213C6"></a><h4 id="DWHSG-GUID-81BA0698-1E21-4301-B4DE-CD0E727213C6" class="sect4"><span class="enumeration_section">12.3.5 </span>About Query Rewrite Using Date Folding
                  </h4>
                  <div>
                     <p><a id="d44607e3913" class="indexterm-anchor"></a><a id="d44607e3917" class="indexterm-anchor"></a>Date folding rewrite is a specific form of expression matching rewrite. In this type of rewrite, a date range in a query is folded into an equivalent date range representing higher date granules. The resulting expressions representing higher date granules in the folded date range are matched with equivalent expressions in a materialized view. The folding of date range into higher date granules such as months, quarters, or years is done when the underlying data type of the column is an Oracle <code class="codeph">DATE</code>. The expression matching is done based on the use of canonical forms for the expressions.
                     </p>
                     <p><code class="codeph">DATE</code> is a built-in data type which represents ordered time units such as seconds, days, and months, and incorporates a time hierarchy (second -&gt; minute -&gt; hour -&gt; day -&gt; month -&gt; quarter -&gt; year). This hard-coded knowledge about <code class="codeph">DATE</code> is used in folding date ranges from lower-date granules to higher-date granules. Specifically, folding a date value to the beginning of a month, quarter, year, or to the end of a month, quarter, year is supported. For example, the date value <code class="codeph">1-jan-1999</code> can be folded into the beginning of either year <code class="codeph">1999</code> or quarter <code class="codeph">1999-1</code> or month <code class="codeph">1999-01</code>. And, the date value <code class="codeph">30-sep-1999</code> can be folded into the end of either quarter <code class="codeph">1999-03</code> or month <code class="codeph">1999-09</code>.
                     </p>
                     <div class="infoboxnote" id="GUID-81BA0698-1E21-4301-B4DE-CD0E727213C6__GUID-49A7F06C-8E9E-45FF-91D4-96E2D3A8532F">
                        <p class="notep1">Note:</p>
                        <p>Due to the way date folding works, you should be careful when using <code class="codeph">BETWEEN</code> and date columns. The best way to use <code class="codeph">BETWEEN</code> and date columns is to increment the later date by 1. In other words, instead of using <code class="codeph">date_col BETWEEN '1-jan-1999' AND '30-jun-1999'</code>, you should use <code class="codeph">date_col</code> <code class="codeph">BETWEEN '1-jan-1999' AND '1-jul-1999'</code>. You could also use the <code class="codeph">TRUNC</code> function to get the equivalent result, as in <code class="codeph">TRUNC(date_col)</code> <code class="codeph">BETWEEN '1-jan-1999' AND '30-jun-1999'</code>. <code class="codeph">TRUNC</code> will, however, strip time values.
                        </p>
                     </div>
                     <p>Because date values are ordered, any range predicate specified on date columns can be folded from lower level granules into higher level granules provided the date range represents an integral number of higher level granules. For example, the range predicate <code class="codeph">date_col &gt;= '1-jan-1999'</code> <code class="codeph">AND</code> <code class="codeph">date_col</code> <code class="codeph">&lt;</code> '30-jun-1999' can be folded into either a month range or a quarter range using the <code class="codeph">TO_CHAR</code> function, which extracts specific date components from a date value.
                     </p>
                     <p>The advantage of aggregating data by folded date values is the compression of data achieved. Without date folding, the data is aggregated at the lowest granularity level, resulting in increased disk space for storage and increased I/O to scan the materialized view.</p>
                     <p>Consider a query that asks for the sum of sales by product types for the year 1998:</p><pre class="oac_no_warn" dir="ltr">SELECT p.prod_category, SUM(s.amount_sold)
FROM sales s, products p
WHERE s.prod_id=p.prod_id AND s.time_id &gt;= TO_DATE('01-jan-1998', 'dd-mon-yyyy')
  AND s.time_id &lt;   TO_DATE('01-jan-1999', 'dd-mon-yyyy')
GROUP BY p.prod_category;

CREATE MATERIALIZED VIEW sum_sales_pcat_monthly_mv
ENABLE QUERY REWRITE AS
SELECT p.prod_category, TO_CHAR(s.time_id,'YYYY-MM') AS month, 
       SUM(s.amount_sold) AS sum_amount
FROM sales s, products p
WHERE s.prod_id=p.prod_id
GROUP BY p.prod_category, TO_CHAR(s.time_id, 'YYYY-MM');

SELECT p.prod_category, SUM(s.amount_sold)
FROM sales s, products p
WHERE s.prod_id=p.prod_id
AND TO_CHAR(s.time_id, 'YYYY-MM') &gt;= '01-jan-1998'
AND TO_CHAR(s.time_id, 'YYYY-MM') &lt; '01-jan-1999'
GROUP BY p.prod_category;

SELECT mv.prod_category, mv.sum_amount
FROM sum_sales_pcat_monthly_mv mv
WHERE month &gt;= '01-jan-1998' AND month &lt; '01-jan-1999';
</pre><p>The range specified in the query represents an integral number of years, quarters, or months. Assume that there is a materialized view <code class="codeph">mv3</code> that contains pre-summarized sales by <code class="codeph">prod_type</code> and is defined as follows:
                     </p><pre class="oac_no_warn" dir="ltr">CREATE MATERIALIZED VIEW mv3
ENABLE QUERY REWRITE AS
SELECT prod_name, TO_CHAR(sales.time_id,'yyyy-mm') 
   AS month, SUM(amount_sold) AS sum_sales
FROM sales, products WHERE sales.prod_id = products.prod_id
GROUP BY prod_name, TO_CHAR(sales_time_id, 'yyyy-mm');
</pre><p>The query can be rewritten by first folding the date range into the month range and then matching the expressions representing the months with the month expression in <code class="codeph">mv3</code>. This rewrite is shown in two steps (first folding the date range followed by the actual rewrite).
                     </p><pre class="oac_no_warn" dir="ltr">SELECT prod_name, SUM(amount_sold) AS sum_sales
FROM sales, products
WHERE sales.prod_id = products.prod_id AND TO_CHAR(sales.time_id, 'yyyy-mm') &gt;= 
      TO_CHAR('01-jan-1998', 'yyyy-mm') AND TO_CHAR(sales.time_id, '01-jan-1999',
 'yyyy-mm') &lt; TO_CHAR(TO_DATE(''01-jan-1999'', ''dd-mon-yyyy''), ''yyyy-mm'')
GROUP BY prod_name;

SELECT prod_name, sum_sales
FROM mv3 WHERE month &gt;=
      TO_CHAR(TO_DATE('01-jan-1998', 'dd-mon-yyyy'), 'yyyy-mm')
  AND month &lt; TO_CHAR(TO_DATE('01-jan-1999', 'dd-mon-yyyy'), 'yyyy-mm');
</pre><p>If <code class="codeph">mv3</code> had pre-summarized sales by <code class="codeph">prod_name</code> and year instead of <code class="codeph">prod_name</code> and month, the query could still be rewritten by folding the date range into year range and then matching the year expressions.
                     </p>
                  </div>
               </div><a id="DWHSG8546"></a><a id="DWHSG8547"></a><a id="DWHSG08036"></a><div class="props_rev_3"><a id="GUID-1CBDAF40-2412-4A1A-9E41-CF202A6AFDAF" name="GUID-1CBDAF40-2412-4A1A-9E41-CF202A6AFDAF"></a><h4 id="DWHSG-GUID-1CBDAF40-2412-4A1A-9E41-CF202A6AFDAF" class="sect4"><span class="enumeration_section">12.3.6 </span>About Query Rewrite Using View Constraints
                  </h4>
                  <div>
                     <p>Data warehouse <a id="d44607e4062" class="indexterm-anchor"></a><a id="d44607e4064" class="indexterm-anchor"></a><a id="d44607e4068" class="indexterm-anchor"></a>applications recognize multi-dimensional cubes in the database by identifying integrity constraints in the relational schema. Integrity constraints represent primary and foreign key relationships between fact and dimension tables. By querying the data dictionary, applications can recognize integrity constraints and hence the cubes in the database. However, this does not work in an environment where database administrators, for schema complexity or security reasons, define views on fact and dimension tables. In such environments, applications cannot identify the cubes properly. By allowing constraint definitions between views, you can propagate base table constraints to the views, thereby allowing applications to recognize cubes even in a restricted environment.
                     </p>
                     <p>View constraint definitions are declarative in nature, but operations on views are subject to the integrity constraints defined on the underlying base tables, and constraints on views can be enforced through constraints on base tables. Defining constraints on base tables is necessary, not only for data correctness and cleanliness, but also for materialized view query rewrite purposes using the original base objects.</p>
                     <div class="infoboxnotealso" id="GUID-1CBDAF40-2412-4A1A-9E41-CF202A6AFDAF__GUID-E9054D4F-656F-4836-948A-5B1443AA16B4">
                        <p class="notep1">See Also:</p>
                        <p><a href="advanced-query-rewrite-materialized-views.html#GUID-5A432C77-CFB2-41EF-ACBF-B57F39F712DB">Abut View Constraints Restrictions</a></p>
                     </div>
                     <p>Materialized view rewrite extensively uses constraints for query rewrite. They are used for determining lossless joins, which, in turn, determine if joins in the materialized view are compatible with joins in the query and thus if rewrite is possible.</p>
                     <p><code class="codeph">DISABLE</code> <code class="codeph">NOVALIDATE</code> is the only valid state for a view constraint. However, you can choose <code class="codeph">RELY</code> or <code class="codeph">NORELY</code> as the view constraint state to enable more sophisticated query rewrites. For example, a view constraint in the <code class="codeph">RELY</code> state allows query rewrite to occur when the query integrity level is set to <code class="codeph">TRUSTED</code>. <a href="advanced-query-rewrite-materialized-views.html#GUID-1CBDAF40-2412-4A1A-9E41-CF202A6AFDAF__g1021713" title="View Constraints and Rewrite Integrity Modes">Table 12-3</a> illustrates when view constraints are used for determining lossless joins.
                     </p>
                     <p>Note that view constraints cannot be used for query rewrite integrity level <code class="codeph">ENFORCED</code>. This level enforces the highest degree of constraint enforcement <code class="codeph">ENABLE</code> <code class="codeph">VALIDATE</code>.
                     </p>
                     <div class="tblformal" id="GUID-1CBDAF40-2412-4A1A-9E41-CF202A6AFDAF__g1021713">
                        <p class="titleintable">Table 12-3 View Constraints and Rewrite Integrity Modes</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="View Constraints and Rewrite Integrity Modes" summary="View Constraints and Rewrite Integrity Modes" width="100%" frame="hsides" border="1" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="39%" id="d44607e4129">Constraint States</th>
                                 <th align="left" valign="bottom" width="31%" id="d44607e4132">RELY</th>
                                 <th align="left" valign="bottom" width="31%" id="d44607e4135">NORELY</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="39%" id="d44607e4140" headers="d44607e4129 ">
                                    <p><code class="codeph">ENFORCED</code></p>
                                 </td>
                                 <td align="left" valign="top" width="31%" headers="d44607e4140 d44607e4132 ">
                                    <p>No</p>
                                 </td>
                                 <td align="left" valign="top" width="31%" headers="d44607e4140 d44607e4135 ">
                                    <p>No</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="39%" id="d44607e4151" headers="d44607e4129 ">
                                    <p><code class="codeph">TRUSTED</code></p>
                                 </td>
                                 <td align="left" valign="top" width="31%" headers="d44607e4151 d44607e4132 ">
                                    <p>Yes</p>
                                 </td>
                                 <td align="left" valign="top" width="31%" headers="d44607e4151 d44607e4135 ">
                                    <p>No</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="39%" id="d44607e4162" headers="d44607e4129 ">
                                    <p><code class="codeph">STALE_TOLERATED</code></p>
                                 </td>
                                 <td align="left" valign="top" width="31%" headers="d44607e4162 d44607e4132 ">
                                    <p>Yes</p>
                                 </td>
                                 <td align="left" valign="top" width="31%" headers="d44607e4162 d44607e4135 ">
                                    <p>No</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <div class="example" id="GUID-1CBDAF40-2412-4A1A-9E41-CF202A6AFDAF__GUID-71FAD2CE-6181-4F5D-A80B-05080F6A42A4">
                        <p class="titleinexample">Example 12-10 View Constraints</p>
                        <p>To demonstrate the rewrite capabilities on views, you need to extend the <code class="codeph">sh</code> sample schema as follows:
                        </p><pre class="oac_no_warn" dir="ltr">CREATE VIEW time_view AS
SELECT time_id, TO_NUMBER(TO_CHAR(time_id, 'ddd')) AS day_in_year FROM times;
</pre><p>You can now establish a foreign key/primary key relationship (in <code class="codeph">RELY</code> mode) between the view and the fact table, and thus rewrite takes place as described in <a href="advanced-query-rewrite-materialized-views.html#GUID-1CBDAF40-2412-4A1A-9E41-CF202A6AFDAF__g1021713" title="View Constraints and Rewrite Integrity Modes">Table 12-3</a>, by adding the following constraints. Rewrite will then work for example in <code class="codeph">TRUSTED</code> mode.
                        </p><pre class="oac_no_warn" dir="ltr">ALTER VIEW time_view ADD (CONSTRAINT time_view_pk 
   PRIMARY KEY (time_id) DISABLE NOVALIDATE);
ALTER VIEW time_view MODIFY CONSTRAINT time_view_pk RELY;
ALTER TABLE sales ADD (CONSTRAINT time_view_fk FOREIGN KEY (time_id)
   REFERENCES time_view(time_id) DISABLE NOVALIDATE);
ALTER TABLE sales MODIFY CONSTRAINT time_view_fk RELY;
</pre><p>Consider the following materialized view definition:</p><pre class="oac_no_warn" dir="ltr">CREATE MATERIALIZED VIEW sales_pcat_cal_day_mv 
ENABLE QUERY REWRITE AS
SELECT p.prod_category, t.day_in_year, SUM(s.amount_sold) AS sum_amount_sold
FROM time_view t, sales s, products p 
WHERE t.time_id = s.time_id AND p.prod_id = s.prod_id
GROUP BY p.prod_category, t.day_in_year;
</pre><p>The following query, omitting the dimension table <code class="codeph">products</code>, is also rewritten without the primary key/foreign key relationships, because the suppressed join between <code class="codeph">sales</code> and <code class="codeph">products</code> is known to be lossless.
                        </p><pre class="oac_no_warn" dir="ltr">SELECT t.day_in_year, SUM(s.amount_sold) AS sum_amount_sold
FROM time_view t, sales s WHERE t.time_id = s.time_id
GROUP BY t.day_in_year;
</pre><p>However, if the materialized view <code class="codeph">sales_pcat_cal_day_mv</code> were defined only in terms of the view <code class="codeph">time_view</code>, then you could not rewrite the following query, suppressing then join between <code class="codeph">sales</code> and <code class="codeph">time_view</code>, because there is no basis for losslessness of the delta materialized view join. With the additional constraints as shown previously, this query will also rewrite.
                        </p><pre class="oac_no_warn" dir="ltr">SELECT p.prod_category, SUM(s.amount_sold) AS sum_amount_sold
FROM sales s, products p WHERE p.prod_id = s.prod_id
GROUP BY p.prod_category;
</pre><p>To undo the changes you have made to the <code class="codeph">sh</code> schema, issue the following statements:
                        </p><pre class="oac_no_warn" dir="ltr">ALTER TABLE sales DROP CONSTRAINT time_view_fk;
DROP VIEW time_view;</pre></div>
                     <!-- class="example" -->
                  </div><a id="DWHSG8548"></a><div class="props_rev_3"><a id="GUID-5A432C77-CFB2-41EF-ACBF-B57F39F712DB" name="GUID-5A432C77-CFB2-41EF-ACBF-B57F39F712DB"></a><h5 id="DWHSG-GUID-5A432C77-CFB2-41EF-ACBF-B57F39F712DB" class="sect5"><span class="enumeration_section">12.3.6.1 </span>Abut View Constraints Restrictions
                     </h5>
                     <div>
                        <div class="section">
                           <p>If the referential constraint definition involves a view, that is, either the foreign key or the referenced key resides in a view, the constraint can only be in <code class="codeph">DISABLE</code> <code class="codeph">NOVALIDATE</code> mode. 
                           </p>
                           <p>A <code class="codeph">RELY</code> constraint on a view is allowed only if the referenced <code class="codeph">UNIQUE</code> or <code class="codeph">PRIMARY</code> <code class="codeph">KEY</code> constraint in <code class="codeph">DISABLE</code> <code class="codeph">NOVALIDATE</code> mode is also a <code class="codeph">RELY</code> constraint.
                           </p>
                           <p>The specification of <code class="codeph">ON</code> <code class="codeph">DELETE</code> actions associated with a referential Integrity constraint, is not allowed (for example, <code class="codeph">DELETE</code> cascade). However, <code class="codeph">DELETE</code>, <code class="codeph">UPDATE</code>, and <code class="codeph">INSERT</code> operations are allowed on views and their base tables as view constraints are in <code class="codeph">DISABLE</code> <code class="codeph">NOVALIDATE</code> mode.
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-67BDE6F3-C911-4923-9778-D86654EF21DF" name="GUID-67BDE6F3-C911-4923-9778-D86654EF21DF"></a><h4 id="DWHSG-GUID-67BDE6F3-C911-4923-9778-D86654EF21DF" class="sect4"><span class="enumeration_section">12.3.7 </span>About Query Rewrite in the Presence of Hybrid Partitioned Tables
                  </h4>
                  <div>
                     <p>Query rewrite considers external partitions in a hybrid partitioned table to be of UNKNOWN freshness. Therefore, when a query requests data from one or more external partitions, it can only be rewritten under <code class="codeph">TRUSTED</code> or <code class="codeph">STALE_TOLERATED</code> integrity mode.
                     </p>
                     <p></p>
                     <p>When a materialized view that is based on a hybrid partitioned table includes the partition key or partition marker in its <code class="codeph">SELECT</code> list, it is eligible for partition tracking. For materialized views based on hybrid partitioned table tables that are not PCT-enabled, <code class="codeph">STALE_TOLERATED</code> is the only possible integrity mode.
                     </p>
                     <p>Queries against hybrid partitioned tables can be rewritten using PCT rewrite under <code class="codeph">ENFORCED</code> and <code class="codeph">TRUSTED</code> integrity modes only if the hybrid partitioned table is range or list partitioned.
                     </p>
                     <div class="example" id="GUID-67BDE6F3-C911-4923-9778-D86654EF21DF__GUID-1723304E-8128-4666-98F2-85E5495A5171">
                        <p class="titleinexample">Example 12-11 Query Rewrite and Materialized Views Based on Hybrid Partitioned Tables</p>
                        <p>The hybrid partitioned table named <code class="codeph">hybrid_sales</code> uses the <code class="codeph">ENFORCED</code> integrity mode. One of the internal partitions is stale.
                        </p>
                        <p>The following query is run:</p><pre class="pre codeblock"><code>SELECT customer_no, sum(price) as sum_price
FROM hybrid_sales WHERE 
  time_id &gt; TO_DATE(01-01-1950) and time_id &lt; TO_DATE(06-01-2001)
GROUP BY customer_no;</code></pre><p>This query can be rewritten to use the hybrid partitioned table. PCT rewrite selects the fresh partitions from the materialized view and any stale partitions and external partitions directly from the base table. The rewritten query is as follows:</p><pre class="pre codeblock"><code>SELECT v1.customer_no, SUM(v1.total_price) sum_price
FROM 
  (SELECT customer_no, SUM(total_price) FROM Hybrid_sales WHERE 
    time_id &gt; TO_DATE(01-01-1950) and time_id &lt; TO_DATE(01-01-2000)
   GROUP BY customer_no 
   UNION ALL
   SELECT customer_no, SUM(total_price) FROM HyPT_MV WHERE 
    time_id &gt; TO_DATE(01-01-2000) and time_id &lt; TO_DATE(01-01-2001)
   GROUP BY customer_no
   UNION ALL
   SELECT customer_no, SUM(total_price) FROM Hybrid_sales WHERE 
    time_id &gt; TO_DATE(01-01-2001) and time_id &lt; TO_DATE(06-01-2001)
   GROUP BY customer_no
) v1
GROUP BY v1.customer_no;
</code></pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="DWHSG08037"></a><div class="props_rev_3"><a id="GUID-F9ED3594-159E-451C-AABC-F74FB89B6C94" name="GUID-F9ED3594-159E-451C-AABC-F74FB89B6C94"></a><h4 id="DWHSG-GUID-F9ED3594-159E-451C-AABC-F74FB89B6C94" class="sect4"><span class="enumeration_section">12.3.8 </span>Query Rewrite Using Set Operator Materialized Views
                  </h4>
                  <div>
                     <p>You<a id="d44607e4405" class="indexterm-anchor"></a> can use query rewrite with materialized views that contain set operators. In this case, the query and materialized view do not have to match textually for rewrite to occur. As an example, consider the following materialized view, which uses the postal codes for male customers from San Francisco or Los Angeles:
                     </p><pre class="oac_no_warn" dir="ltr">CREATE MATERIALIZED VIEW cust_male_postal_mv
ENABLE QUERY REWRITE AS
SELECT c.cust_city, c.cust_postal_code
FROM customers c
WHERE c.cust_gender = 'M' AND c.cust_city = 'San Francisco'
UNION ALL
SELECT c.cust_city, c.cust_postal_code
FROM customers c
WHERE c.cust_gender = 'M' AND c.cust_city = 'Los Angeles';
</pre><p>If you have the following query, which displays the postal codes for male customers from San Francisco or Los Angeles:</p><pre class="oac_no_warn" dir="ltr">SELECT c.cust_city, c.cust_postal_code
FROM customers c
WHERE c.cust_city = 'Los Angeles' AND c.cust_gender = 'M'
UNION ALL
SELECT c.cust_city, c.cust_postal_code
FROM customers c
WHERE c.cust_city = 'San Francisco' AND c.cust_gender = 'M';
</pre><p>The rewritten query will be the following:</p><pre class="oac_no_warn" dir="ltr">SELECT mv.cust_city, mv.cust_postal_code
FROM cust_male_postal_mv mv;
</pre><p>The rewritten query has dropped the <code class="codeph">UNION</code> <code class="codeph">ALL</code> and replaced it with the materialized view. Normally, query rewrite has to use the existing set of general eligibility rules to determine if the <code class="codeph">SELECT</code> subselections under the <code class="codeph">UNION</code> <code class="codeph">ALL</code> are equivalent in the query and the materialized view.
                     </p>
                     <p>See <a href="advanced-query-rewrite-materialized-views.html#GUID-26E9AF20-AE8E-4D6E-9AF0-E5C9679A09F6">UNION ALL Marker and Query Rewrite</a>.
                     </p>
                     <p>If, for example, you have a query that retrieves the postal codes for male customers from San Francisco, Palmdale, or Los Angeles, the same rewrite can occur as in the previous example but query rewrite must keep the <code class="codeph">UNION</code> <code class="codeph">ALL</code> with the base tables, as in the following:
                     </p><pre class="oac_no_warn" dir="ltr">SELECT c.cust_city, c.cust_postal_code
FROM customers c
WHERE c.cust_city= 'Palmdale' AND c.cust_gender ='M'
UNION ALL
SELECT c.cust_city, c.cust_postal_code
FROM customers c
WHERE c.cust_city = 'Los Angeles' AND c.cust_gender = 'M'
UNION ALL
SELECT c.cust_city, c.cust_postal_code
FROM customers c
WHERE c.cust_city = 'San Francisco' AND c.cust_gender = 'M';
</pre><p>The rewritten query will be:</p><pre class="oac_no_warn" dir="ltr">SELECT mv.cust_city, mv.cust_postal_code
FROM cust_male_postal_mv mv
UNION ALL
SELECT c.cust_city, c.cust_postal_code
FROM customers c
WHERE c.cust_city = 'Palmdale' AND c.cust_gender = 'M';
</pre><p>So query rewrite detects the case where a subset of the <code class="codeph">UNION</code> <code class="codeph">ALL</code> can be rewritten using the materialized view <code class="codeph">cust_male_postal_mv</code>.
                     </p>
                     <p><code class="codeph">UNION</code>, <code class="codeph">UNION</code> <code class="codeph">ALL</code>, and <code class="codeph">INTERSECT</code> are commutative, so query rewrite can rewrite regardless of the order the subselects are found in the query or materialized view. However, <code class="codeph">MINUS</code> is not commutative. A <code class="codeph">MINUS</code> B is not equivalent to B <code class="codeph">MINUS</code> A. Therefore, the order in which the subselects appear under the <code class="codeph">MINUS</code> operator in the query and the materialized view must be in the same order for rewrite to happen. As an example, consider the case where there exists an old version of the customer table called <code class="codeph">customer_old</code> and you want to find the difference between the old one and the current customer table only for male customers who live in London. That is, you want to find those customers in the current one that were not in the old one. The following example shows how this is done using a <code class="codeph">MINUS</code> operator:
                     </p><pre class="oac_no_warn" dir="ltr">SELECT c.cust_city, c.cust_postal_code
FROM customers c
WHERE c.cust_city= 'Los Angeles' AND c.cust_gender = 'M'
MINUS
SELECT c.cust_city, c.cust_postal_code
FROM customers_old c
WHERE c.cust_city = 'Los Angeles' AND c.cust_gender = 'M';
</pre><p>Switching the subselects would yield a different answer. This illustrates that <code class="codeph">MINUS</code> is not commutative.
                     </p>
                  </div><a id="DWHSG8549"></a><div class="props_rev_3"><a id="GUID-26E9AF20-AE8E-4D6E-9AF0-E5C9679A09F6" name="GUID-26E9AF20-AE8E-4D6E-9AF0-E5C9679A09F6"></a><h5 id="DWHSG-GUID-26E9AF20-AE8E-4D6E-9AF0-E5C9679A09F6" class="sect5"><span class="enumeration_section">12.3.8.1 </span>UNION ALL Marker and Query Rewrite
                     </h5>
                     <div>
                        <p>If a materialized view contains one or more <code class="codeph">UNION</code> <code class="codeph">ALL</code> operators, it can also include a <code class="codeph">UNION</code> <code class="codeph">ALL</code> marker. The <code class="codeph">UNION</code> <code class="codeph">ALL</code> marker is used to identify from which <code class="codeph">UNION</code> <code class="codeph">ALL</code> subselect each row in the materialized view originates. Query rewrite can use the marker to distinguish what rows coming from the materialized view belong to a certain <code class="codeph">UNION</code> <code class="codeph">ALL</code> subselect. This is useful if the query needs only a subset of the data from the materialized view or if the subselects of the query do not textually match with the subselects of the materialized view. As an example, the following query retrieves the postal codes for male customers from San Francisco and female customers from Los Angeles:
                        </p><pre class="oac_no_warn" dir="ltr">SELECT c.cust_city, c.cust_postal_code
FROM customers c
WHERE c.cust_gender = 'M' and c.cust_city = 'San Francisco'
UNION ALL
SELECT c.cust_city, c.cust_postal_code
FROM customers c
WHERE c.cust_gender = 'F' and c.cust_city = 'Los Angeles';
</pre><p>The query can be answered using the following materialized view:</p><pre class="oac_no_warn" dir="ltr">CREATE MATERIALIZED VIEW cust_postal_mv
ENABLE QUERY REWRITE AS
SELECT 1 AS marker, c.cust_gender, c.cust_city, c.cust_postal_code
FROM customers c
WHERE c.cust_city = 'Los Angeles'
UNION ALL
SELECT 2 AS marker, c.cust_gender, c.cust_city, c.cust_postal_code
FROM customers c
WHERE c.cust_city = 'San Francisco';
</pre><p>The rewritten query is as follows:</p><pre class="oac_no_warn" dir="ltr">SELECT mv.cust_city, mv.cust_postal_code
FROM cust_postal_mv mv
WHERE mv.marker = 2 AND mv.cust_gender = 'M'
UNION ALL
SELECT mv.cust_city, mv.cust_postal_code
FROM cust_postal_mv mv
WHERE mv.marker = 1 AND mv.cust_gender = 'F';
</pre><p>The <code class="codeph">WHERE</code> clause of the first subselect includes <code class="codeph">mv.marker = 2</code> and <code class="codeph">mv.cust_gender = 'M'</code>, which selects only the rows that represent male customers in the second subselect of the <code class="codeph">UNION</code> <code class="codeph">ALL</code>. The <code class="codeph">WHERE</code> clause of the second subselect includes <code class="codeph">mv.marker = 1</code> and <code class="codeph">mv.cust_gender = 'F'</code>, which selects only those rows that represent female customers in the first subselect of the <code class="codeph">UNION</code> <code class="codeph">ALL</code>. Note that query rewrite cannot take advantage of set operators that drop duplicate or distinct rows. For example, <code class="codeph">UNION</code> drops duplicates so query rewrite cannot tell what rows have been dropped, as in the following:
                        </p><pre class="oac_no_warn" dir="ltr">SELECT c.cust_city, c.cust_postal_code
FROM customers c
WHERE c.cust_city= 'Palmdale' AND c.cust_gender ='M'
SELECT c.cust_city, c.cust_postal_code
FROM customers c
WHERE c.cust_gender = 'M' and c.cust_city = 'San Francisco'
UNION ALL
SELECT c.cust_city, c.cust_postal_code
FROM customers c
WHERE c.cust_gender = 'F' and c.cust_city = 'Los Angeles';
</pre><p>The rewritten query using <code class="codeph">UNION</code> <code class="codeph">ALL</code> markers is as follows:
                        </p><pre class="oac_no_warn" dir="ltr">SELECT c.cust_city, c.cust_postal_code
FROM customers c
WHERE c.cust_city= 'Palmdale' AND c.cust_gender ='M'
UNION ALL
SELECT mv.cust_city, mv.cust_postal_code

FROM cust_postal_mv mv
WHERE mv.marker = 2 AND mv.cust_gender = 'M'
UNION ALL
  SELECT mv.cust_city, mv.cust_postal_code
  FROM cust_postal_mv mv
  WHERE mv.marker = 1 AND mv.cust_gender = 'F';
</pre><p>The rules for using a marker are that it must:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Be a constant number or string and be the same data type for all <code class="codeph">UNION ALL</code> subselects.
                              </p>
                           </li>
                           <li>
                              <p>Yield a constant, distinct value for each <code class="codeph">UNION ALL</code> subselect. You cannot reuse the same value in multiple subselects.
                              </p>
                           </li>
                           <li>
                              <p>Be in the same ordinal position for all subselects.</p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="DWHSG08038"></a><div class="props_rev_3"><a id="GUID-FF240F3F-2EF8-4D46-8FAE-2B6C57FBA749" name="GUID-FF240F3F-2EF8-4D46-8FAE-2B6C57FBA749"></a><h4 id="DWHSG-GUID-FF240F3F-2EF8-4D46-8FAE-2B6C57FBA749" class="sect4"><span class="enumeration_section">12.3.9 </span>About Query Rewrite in the Presence of Grouping Sets
                  </h4>
                  <div>
                     <p>This section discusses the following considerations for using query rewrite with grouping sets:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="advanced-query-rewrite-materialized-views.html#GUID-9CBC8423-7D9C-4368-92F3-913C5700E1D3">About Query Rewrite When Using GROUP BY Extensions</a></p>
                        </li>
                        <li>
                           <p><a href="advanced-query-rewrite-materialized-views.html#GUID-05CFC633-105D-45AB-97A0-805AEC29BFFF">Hint for Rewriting Queries with Extended GROUP BY</a></p>
                        </li>
                     </ul>
                  </div><a id="DWHSG8550"></a><div class="props_rev_3"><a id="GUID-9CBC8423-7D9C-4368-92F3-913C5700E1D3" name="GUID-9CBC8423-7D9C-4368-92F3-913C5700E1D3"></a><h5 id="DWHSG-GUID-9CBC8423-7D9C-4368-92F3-913C5700E1D3" class="sect5"><span class="enumeration_section">12.3.9.1 </span>About Query Rewrite When Using GROUP BY Extensions
                     </h5>
                     <div>
                        <p>Several <a id="d44607e4694" class="indexterm-anchor"></a>extensions to the <code class="codeph">GROUP</code> <code class="codeph">BY</code> clause in the form of <code class="codeph">GROUPING</code> <code class="codeph">SETS</code>, <code class="codeph">CUBE, ROLLUP</code>, and their concatenation are available. These extensions enable you to selectively specify the groupings of interest in the <code class="codeph">GROUP</code> <code class="codeph">BY</code> clause of the query. For example, the following is a typical query with grouping sets:
                        </p><pre class="oac_no_warn" dir="ltr">SELECT p.prod_subcategory, t.calendar_month_desc, c.cust_city, 
  SUM(s.amount_sold) AS sum_amount_sold
FROM sales s, customers c, products p, times t
WHERE s.time_id=t.time_id AND s.prod_id = p.prod_id AND s.cust_id = c.cust_id
GROUP BY GROUPING SETS ((p.prod_subcategory, t.calendar_month_desc),
   (c.cust_city, p.prod_subcategory));
</pre><p>The term <span class="bold">base</span> <span class="bold">grouping</span> for queries with <code class="codeph">GROUP</code> <code class="codeph">BY</code> extensions denotes all unique expressions present in the <code class="codeph">GROUP</code> <code class="codeph">BY</code> clause. In the previous query, the following grouping (<code class="codeph">p.prod_subcategory, t.calendar_month_desc, c.cust_city</code>) is a base grouping.
                        </p>
                        <p>The extensions can be present in user queries and in the queries defining materialized views. In both cases, materialized view rewrite applies and you can distinguish rewrite capabilities into the following scenarios:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><a href="advanced-query-rewrite-materialized-views.html#GUID-169C564C-2F46-4A30-861A-CEFC4264C919">Materialized View has Simple GROUP BY and Query has Extended GROUP BY</a></p>
                           </li>
                           <li>
                              <p><a href="advanced-query-rewrite-materialized-views.html#GUID-E57F62F2-0F5B-4CD6-AA92-28EA67690850">Materialized View has Extended GROUP BY and Query has Simple GROUP BY</a></p>
                           </li>
                           <li>
                              <p><a href="advanced-query-rewrite-materialized-views.html#GUID-5826A5DA-3EC3-4DA6-929C-BB65704BEB19">Both Materialized View and Query Have Extended GROUP BY</a></p>
                           </li>
                        </ul>
                     </div><a id="DWHSG8551"></a><div class="props_rev_3"><a id="GUID-169C564C-2F46-4A30-861A-CEFC4264C919" name="GUID-169C564C-2F46-4A30-861A-CEFC4264C919"></a><h6 id="DWHSG-GUID-169C564C-2F46-4A30-861A-CEFC4264C919" class="sect6"><span class="enumeration_section">12.3.9.1.1 </span>Materialized View has Simple GROUP BY and Query has Extended GROUP BY
                        </h6>
                        <div>
                           <p>When a query contains an extended <code class="codeph">GROUP</code> <code class="codeph">BY</code> clause, it can be rewritten with a materialized view if its base grouping can be rewritten using the materialized view as listed in the rewrite rules explained in <span class="q">"<a href="basic-query-rewrite-materialized-views.html#GUID-63B491A0-A479-4711-A5B0-40365904115F">When Does Oracle Rewrite a Query?</a>"</span>. For example, in the following query:
                           </p><pre class="oac_no_warn" dir="ltr">SELECT p.prod_subcategory, t.calendar_month_desc, c.cust_city, 
  SUM(s.amount_sold) AS sum_amount_sold
FROM sales s, customers c, products p, times t
WHERE s.time_id=t.time_id AND s.prod_id = p.prod_id AND s.cust_id = c.cust_id
GROUP BY GROUPING SETS 
((p.prod_subcategory, t.calendar_month_desc), 
   (c.cust_city, p.prod_subcategory));
</pre><p>The base grouping is <code class="codeph">(p.prod_subcategory, t.calendar_month_desc, c.cust_city, p.prod_subcategory))</code> and, consequently, Oracle can rewrite the query using <code class="codeph">sum_sales_pscat_month_city_mv</code> as follows:
                           </p><pre class="oac_no_warn" dir="ltr">SELECT mv.prod_subcategory, mv.calendar_month_desc, mv.cust_city,
  SUM(mv.sum_amount_sold) AS sum_amount_sold
FROM sum_sales_pscat_month_city_mv mv
GROUP BY GROUPING SETS 
((mv.prod_subcategory, mv.calendar_month_desc), 
  (mv.cust_city, mv.prod_subcategory));
</pre><p>A special situation arises if the query uses the <code class="codeph">EXPAND_GSET_TO_UNION</code> hint. See <span class="q">"<a href="advanced-query-rewrite-materialized-views.html#GUID-05CFC633-105D-45AB-97A0-805AEC29BFFF">Hint for Rewriting Queries with Extended GROUP BY</a>"</span> for an example of using <code class="codeph">EXPAND_GSET_TO_UNION</code>.
                           </p>
                        </div>
                     </div><a id="DWHSG8552"></a><div class="props_rev_3"><a id="GUID-E57F62F2-0F5B-4CD6-AA92-28EA67690850" name="GUID-E57F62F2-0F5B-4CD6-AA92-28EA67690850"></a><h6 id="DWHSG-GUID-E57F62F2-0F5B-4CD6-AA92-28EA67690850" class="sect6"><span class="enumeration_section">12.3.9.1.2 </span>Materialized View has Extended GROUP BY and Query has Simple GROUP BY
                        </h6>
                        <div>
                           <p>In order for a materialized view with an extended <code class="codeph">GROUP</code> <code class="codeph">BY</code> to be used for rewrite, it must satisfy two additional conditions:
                           </p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>It must contain a grouping distinguisher, which is the <code class="codeph">GROUPING_ID</code> function on all <code class="codeph">GROUP</code> <code class="codeph">BY</code> expressions. For example, if the <code class="codeph">GROUP</code> <code class="codeph">BY</code> clause of the materialized view is <code class="codeph">GROUP</code> <code class="codeph">BY</code> <code class="codeph">CUBE(a, b)</code>, then the <code class="codeph">SELECT</code> list should contain <code class="codeph">GROUPING_ID(a, b)</code>.
                                 </p>
                              </li>
                              <li>
                                 <p>The <code class="codeph">GROUP</code> <code class="codeph">BY</code> clause of the materialized view should not result in any duplicate groupings. For example, <code class="codeph">GROUP</code> <code class="codeph">BY</code> <code class="codeph">GROUPING</code> <code class="codeph">SETS</code><code class="codeph">((a, b),</code> <code class="codeph">(a, b))</code> would disqualify a materialized view from general rewrite.
                                 </p>
                              </li>
                           </ul>
                           <p>A materialized view with an extended <code class="codeph">GROUP</code> <code class="codeph">BY</code> contains multiple groupings. Oracle finds the grouping with the lowest cost from which the query can be computed and uses that for rewrite. For example, consider the following materialized view:
                           </p><pre class="oac_no_warn" dir="ltr">CREATE MATERIALIZED VIEW sum_grouping_set_mv
ENABLE QUERY REWRITE AS
SELECT p.prod_category, p.prod_subcategory, c.cust_state_province, c.cust_city,
  GROUPING_ID(p.prod_category,p.prod_subcategory,
              c.cust_state_province,c.cust_city) AS gid,
  SUM(s.amount_sold) AS sum_amount_sold
FROM sales s, products p, customers c
WHERE s.prod_id = p.prod_id AND s.cust_id = c.cust_id
GROUP BY GROUPING SETS 
((p.prod_category, p.prod_subcategory, c.cust_city), 
  (p.prod_category, p.prod_subcategory, c.cust_state_province, c.cust_city),
  (p.prod_category, p.prod_subcategory));
</pre><p>In this case, the following query is rewritten:</p><pre class="oac_no_warn" dir="ltr">SELECT p.prod_subcategory, c.cust_city, SUM(s.amount_sold) AS sum_amount_sold
FROM sales s, products p, customers c
WHERE s.prod_id = p.prod_id AND s.cust_id = c.cust_id
GROUP BY p.prod_subcategory, c.cust_city;
</pre><p>This query is rewritten with the closest matching grouping from the materialized view. That is, the <code class="codeph">(prod_category, prod_subcategory, cust_city)</code> grouping:
                           </p><pre class="oac_no_warn" dir="ltr">SELECT prod_subcategory, cust_city, SUM(sum_amount_sold) AS sum_amount_sold
FROM sum_grouping_set_mv
WHERE gid = <span class="italic">grouping identifier of (prod_category,prod_subcategory, cust_city)</span>
GROUP BY prod_subcategory, cust_city;</pre></div>
                     </div><a id="DWHSG8553"></a><div class="props_rev_3"><a id="GUID-5826A5DA-3EC3-4DA6-929C-BB65704BEB19" name="GUID-5826A5DA-3EC3-4DA6-929C-BB65704BEB19"></a><h6 id="DWHSG-GUID-5826A5DA-3EC3-4DA6-929C-BB65704BEB19" class="sect6"><span class="enumeration_section">12.3.9.1.3 </span>Both Materialized View and Query Have Extended GROUP BY
                        </h6>
                        <div>
                           <p>When both materialized view and the query contain <code class="codeph">GROUP</code> <code class="codeph">BY</code> extensions, Oracle uses two strategies for rewrite: grouping match and <code class="codeph">UNION</code> <code class="codeph">ALL</code> rewrite. First, Oracle tries grouping match. The groupings in the query are matched against groupings in the materialized view and if all are matched with no rollup, Oracle selects them from the materialized view. For example, consider the following query:
                           </p><pre class="oac_no_warn" dir="ltr">SELECT p.prod_category, p.prod_subcategory, c.cust_city,
       SUM(s.amount_sold) AS sum_amount_sold
FROM sales s, products p, customers c
WHERE s.prod_id = p.prod_id AND s.cust_id = c.cust_id
GROUP BY GROUPING SETS 
((p.prod_category, p.prod_subcategory, c.cust_city), 
  (p.prod_category, p.prod_subcategory));
</pre><p>This query matches two groupings from <code class="codeph">sum_grouping_set_mv</code> and Oracle rewrites the query as the following:
                           </p><pre class="oac_no_warn" dir="ltr">SELECT prod_subcategory, cust_city, sum_amount_sold
FROM sum_grouping_set_mv
WHERE gid = <span class="italic">grouping identifier of (prod_category,prod_subcategory, cust_city)</span>
   OR gid = <span class="italic">grouping identifier of (prod_category,prod_subcategory)</span>
</pre><p>If grouping match fails, Oracle tries a general rewrite mechanism called <code class="codeph">UNION</code> <code class="codeph">ALL</code> rewrite. Oracle first represents the query with the extended <code class="codeph">GROUP</code> <code class="codeph">BY</code> clause as an equivalent <code class="codeph">UNION</code> <code class="codeph">ALL</code> query. Every grouping of the original query is placed in a separate <code class="codeph">UNION</code> <code class="codeph">ALL</code> branch. The branch will have a simple <code class="codeph">GROUP</code> <code class="codeph">BY</code> clause. For example, consider this query:
                           </p><pre class="oac_no_warn" dir="ltr">SELECT p.prod_category, p.prod_subcategory, c.cust_state_province, 
  t.calendar_month_desc, SUM(s.amount_sold) AS sum_amount_sold
FROM sales s, products p, customers c, times t
WHERE s.prod_id = p.prod_id AND s.cust_id = c.cust_id
GROUP BY GROUPING SETS 
((p.prod_subcategory, t.calendar_month_desc), 
  (t.calendar_month_desc), 
  (p.prod_category, p.prod_subcategory, c.cust_state_province), 
  (p.prod_category, p.prod_subcategory));
</pre><p>This is first represented as <code class="codeph">UNION</code> <code class="codeph">ALL</code> with four branches:
                           </p><pre class="oac_no_warn" dir="ltr">SELECT null, p.prod_subcategory, null,
    t.calendar_month_desc, SUM(s.amount_sold) AS sum_amount_sold
FROM sales s, products p, customers c, times t
WHERE s.prod_id = p.prod_id AND s.cust_id = c.cust_id
GROUP BY p.prod_subcategory, t.calendar_month_desc
UNION ALL
  SELECT null, null, null,
    t.calendar_month_desc, SUM(s.amount_sold) AS sum_amount_sold
FROM sales s, products p, customers c, times t
WHERE s.prod_id = p.prod_id AND s.cust_id = c.cust_id
GROUP BY t.calendar_month_desc
UNION ALL
SELECT p.prod_category, p.prod_subcategory, c.cust_state_province,
    null, SUM(s.amount_sold) AS sum_amount_sold
FROM sales s, products p, customers c, times t
WHERE s.prod_id = p.prod_id AND s.cust_id = c.cust_id
GROUP BY p.prod_category, p.prod_subcategory, c.cust_state_province
UNION ALL 
  SELECT p.prod_category, p.prod_subcategory, null,
    null, SUM(s.amount_sold) AS sum_amount_sold
  FROM sales s, products p, customers c, times t
  WHERE s.prod_id = p.prod_id AND s.cust_id = c.cust_id
  GROUP BY p.prod_category, p.prod_subcategory;
</pre><p>Each branch is then rewritten separately using the rules from <span class="q">"<a href="basic-query-rewrite-materialized-views.html#GUID-63B491A0-A479-4711-A5B0-40365904115F">When Does Oracle Rewrite a Query?</a>"</span>. Using the materialized view <code class="codeph">sum_grouping_set_mv</code>, Oracle can rewrite only branches three (which requires materialized view rollup) and four (which matches the materialized view exactly). The unrewritten branches will be converted back to the extended <code class="codeph">GROUP</code> <code class="codeph">BY</code> form. Thus, eventually, the query is rewritten as:
                           </p><pre class="oac_no_warn" dir="ltr">SELECT null, p.prod_subcategory, null,
    t.calendar_month_desc, SUM(s.amount_sold) AS sum_amount_sold
FROM sales s, products p, customers c, times t
WHERE s.prod_id = p.prod_id AND s.cust_id = c.cust_id
GROUP BY GROUPING SETS
  ((p.prod_subcategory, t.calendar_month_desc),
    (t.calendar_month_desc),)
UNION ALL
  SELECT prod_category, prod_subcategory, cust_state_province,
    null, SUM(sum_amount_sold) AS sum_amount_sold
  FROM sum_grouping_set_mv
  WHERE gid = &lt;grouping id of (prod_category,prod_subcategory, cust_city)&gt;
  GROUP BY p.prod_category, p.prod_subcategory, c.cust_state_province
UNION ALL 
  SELECT prod_category, prod_subcategory, null,
    null, sum_amount_sold
  FROM sum_grouping_set_mv 
  WHERE gid = &lt;grouping id of (prod_category,prod_subcategory)&gt;
</pre><p>Note that a query with extended <code class="codeph">GROUP</code> <code class="codeph">BY</code> is represented as an equivalent <code class="codeph">UNION</code> <code class="codeph">ALL</code> and recursively submitted for rewrite optimization. The groupings that cannot be rewritten stay in the last branch of <code class="codeph">UNION</code> <code class="codeph">ALL</code> and access the base data instead.
                           </p>
                        </div>
                     </div>
                  </div><a id="DWHSG8554"></a><div class="props_rev_3"><a id="GUID-05CFC633-105D-45AB-97A0-805AEC29BFFF" name="GUID-05CFC633-105D-45AB-97A0-805AEC29BFFF"></a><h5 id="DWHSG-GUID-05CFC633-105D-45AB-97A0-805AEC29BFFF" class="sect5"><span class="enumeration_section">12.3.9.2 </span>Hint for Rewriting Queries with Extended GROUP BY
                     </h5>
                     <div>
                        <p>You can <a id="d44607e5093" class="indexterm-anchor"></a><a id="d44607e5097" class="indexterm-anchor"></a>use the <code class="codeph">EXPAND_GSET_TO_UNION</code> hint to force expansion of the query with <code class="codeph">GROUP</code> <code class="codeph">BY</code> extensions into the equivalent <code class="codeph">UNION</code> <code class="codeph">ALL</code> query. This hint can be used in an environment where materialized views have simple <code class="codeph">GROUP</code> <code class="codeph">BY</code> clauses only. In this case, Oracle extends rewrite flexibility as each branch can be independently rewritten by a separate materialized view.
                        </p>
                     </div>
                  </div>
               </div><a id="DWHSG08039"></a><div class="props_rev_3"><a id="GUID-1BA3AB83-5155-47A5-90DA-1D8AEA8E8CC6" name="GUID-1BA3AB83-5155-47A5-90DA-1D8AEA8E8CC6"></a><h4 id="DWHSG-GUID-1BA3AB83-5155-47A5-90DA-1D8AEA8E8CC6" class="sect4"><span class="enumeration_section">12.3.10 </span>Query Rewrite in the Presence of Window Functions
                  </h4>
                  <div>
                     <p>Window functions are used to compute cumulative, moving and centered aggregates. These functions work with the following aggregates: <code class="codeph">SUM</code>, <code class="codeph">AVG</code>, <code class="codeph">MIN</code>/<code class="codeph">MAX</code>., <code class="codeph">COUNT</code>, <code class="codeph">VARIANCE</code>, <code class="codeph">STDDEV</code>, <code class="codeph">FIRST_VALUE</code>, and <code class="codeph">LAST_VALUE</code>. A query with window function can be rewritten using exact text match rewrite. This requires that the materialized view definition also matches the query exactly. When there is no window function on the materialized view, then a query with a window function can be rewritten provided the aggregate in the query is found in the materialized view and all other eligibility checks such as the join computability checks are successful. A window function on the query is compared to the window function in the materialized view using its canonical form format. This enables query rewrite to rewrite even complex window functions.
                     </p>
                     <p>When a query with a window function requires rollup during query rewrite, query rewrite will, whenever possible, split the query into an inner query with the aggregate and an outer query with the windowing function. This permits query rewrite to rewrite the aggregate in the inner query before applying the window function. One exception is when the query has both a window function and grouping sets. In this case, presence of the grouping set prevents query rewrite from splitting the query so query rewrite does not take place in this case.</p>
                  </div>
               </div><a id="DWHSG08040"></a><div class="props_rev_3"><a id="GUID-E0B7B0AB-6D13-4AA4-BFCE-119B5834AAAF" name="GUID-E0B7B0AB-6D13-4AA4-BFCE-119B5834AAAF"></a><h4 id="DWHSG-GUID-E0B7B0AB-6D13-4AA4-BFCE-119B5834AAAF" class="sect4"><span class="enumeration_section">12.3.11 </span>Query Rewrite and Expression Matching
                  </h4>
                  <div>
                     <p><a id="d44607e5195" class="indexterm-anchor"></a><a id="d44607e5199" class="indexterm-anchor"></a>An expression that appears in a query can be replaced with a simple column in a materialized view provided the materialized view column represents a precomputed expression that matches with the expression in the query. If a query can be rewritten to use a materialized view, it will be faster. This is because materialized views contain precomputed calculations and do not need to perform expression computation.
                     </p>
                     <p>The expression matching is done by first converting the expressions into canonical forms and then comparing them for equality. Therefore, two different expressions will generally be matched as long as they are equivalent to each other. Further, if the entire expression in a query fails to match with an expression in a materialized view, then subexpressions of it are tried to find a match. The subexpressions are tried in a top-down order to get maximal expression matching.</p>
                     <p>Consider a query that asks for sum of sales by age brackets (1-10, 11-20, 21-30, and so on).</p><pre class="oac_no_warn" dir="ltr">CREATE MATERIALIZED VIEW sales_by_age_bracket_mv
ENABLE QUERY REWRITE AS
SELECT TO_CHAR((2000-c.cust_year_of_birth)/10-0.5,999) AS age_bracket,
       SUM(s.amount_sold) AS sum_amount_sold
FROM sales s, customers c WHERE s.cust_id=c.cust_id
GROUP BY TO_CHAR((2000-c.cust_year_of_birth)/10-0.5,999);
</pre><p>The following query rewrites, using expression matching:</p><pre class="oac_no_warn" dir="ltr">SELECT TO_CHAR(((2000-c.cust_year_of_birth)/10)-0.5,999), SUM(s.amount_sold) 
FROM sales s, customers c WHERE s.cust_id=c.cust_id
GROUP BY TO_CHAR((2000-c.cust_year_of_birth)/10-0.5,999);
</pre><p>This query is rewritten in terms of <code class="codeph">sales_by_age_bracket_mv</code> based on the matching of the canonical forms of the age bracket expressions (that is, 2000 - <code class="codeph">c.cust_year_of_birth</code>)/10-0.5), as follows:
                     </p><pre class="oac_no_warn" dir="ltr">SELECT age_bracket, sum_amount_sold FROM sales_by_age_bracket_mv;</pre></div><a id="DWHSG8555"></a><div class="props_rev_3"><a id="GUID-8906324F-1EAD-4F1B-B506-4824AE0F3E4B" name="GUID-8906324F-1EAD-4F1B-B506-4824AE0F3E4B"></a><h5 id="DWHSG-GUID-8906324F-1EAD-4F1B-B506-4824AE0F3E4B" class="sect5"><span class="enumeration_section">12.3.11.1 </span>Query Rewrite Using Partially Stale Materialized Views
                     </h5>
                     <div>
                        <p>Whe<a id="d44607e5246" class="indexterm-anchor"></a>n a partition of the detail table is updated, only specific sections of the materialized view are marked stale. The materialized view must have information that can identify the partition of the table corresponding to a particular row or group of the materialized view. The simplest scenario is when the partitioning key of the table is available in the <code class="codeph">SELECT</code> list of the materialized view because this is the easiest way to map a row to a stale partition. The key points when using partially stale materialized views are:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Query rewrite can use a materialized view in <code class="codeph">ENFORCED</code> or <code class="codeph">TRUSTED</code> mode if the rows from the materialized view used to answer the query are known to be <code class="codeph">FRESH</code>.
                              </p>
                           </li>
                           <li>
                              <p>The fresh rows in the materialized view are identified by adding selection predicates to the materialized view's <code class="codeph">WHERE</code> clause. Oracle rewrites a query with this materialized view if its answer is contained within this (restricted) materialized view.
                              </p>
                           </li>
                        </ul>
                        <p>The fact table <code class="codeph">sales</code> is partitioned based on ranges of <code class="codeph">time_id</code> as follows:
                        </p><pre class="oac_no_warn" dir="ltr">PARTITION BY RANGE (time_id)
(PARTITION SALES_Q1_1998 
           VALUES LESS THAN (TO_DATE('01-APR-1998', 'DD-MON-YYYY')),
 PARTITION SALES_Q2_1998 
           VALUES LESS THAN (TO_DATE('01-JUL-1998', 'DD-MON-YYYY')),
 PARTITION SALES_Q3_1998 
           VALUES LESS THAN (TO_DATE('01-OCT-1998', 'DD-MON-YYYY')), 
...
</pre><p>Suppose you have a materialized view grouping by <code class="codeph">time_id</code> as follows:
                        </p><pre class="oac_no_warn" dir="ltr">CREATE MATERIALIZED VIEW sum_sales_per_city_mv
ENABLE QUERY REWRITE AS
SELECT s.time_id, p.prod_subcategory, c.cust_city,
       SUM(s.amount_sold) AS sum_amount_sold
FROM sales s, products p, customers c
WHERE s.cust_id = c.cust_id AND s.prod_id = p.prod_id
GROUP BY time_id, prod_subcategory, cust_city;
</pre><p>Also suppose new data will be inserted for December 2000, which will be assigned to partition <code class="codeph">sales_q4_2000</code>. For testing purposes, you can apply an arbitrary DML operation on <code class="codeph">sales</code>, changing a different partition than <code class="codeph">sales_q1_2000</code> as the following query requests data in this partition when this materialized view is fresh. For example, the following:
                        </p><pre class="oac_no_warn" dir="ltr">INSERT INTO SALES VALUES(17, 10, '01-DEC-2000', 4, 380, 123.45, 54321);
</pre><p>Until a refresh is done, the materialized view is generically stale and cannot be used for unlimited rewrite in enforced mode. However, because the table <code class="codeph">sales</code> is partitioned and not all partitions have been modified, Oracle can identify all partitions that have not been touched. The optimizer can identify the fresh rows in the materialized view (the data which is unaffected by updates since the last refresh operation) by implicitly adding selection predicates to the materialized view defining query as follows:
                        </p><pre class="oac_no_warn" dir="ltr">SELECT s.time_id, p.prod_subcategory, c.cust_city,
       SUM(s.amount_sold) AS sum_amount_sold
FROM sales s, products p, customers c
WHERE s.cust_id = c.cust_id AND s.prod_id = p.prod_id
AND   s.time_id &lt; TO_DATE('01-OCT-2000','DD-MON-YYYY') 
OR s.time_id &gt;= TO_DATE('01-OCT-2001','DD-MON-YYYY'))
GROUP BY time_id, prod_subcategory, cust_city;
</pre><p>Note that the freshness of partially stale materialized views is tracked on a per-partition base, and not on a logical base. Because the partitioning strategy of the <code class="codeph">sales</code> fact table is on a quarterly base, changes in December 2000 causes the complete partition <code class="codeph">sales_q4_2000</code> to become stale.
                        </p>
                        <p>Consider the following query, which asks for sales in quarters 1 and 2 of 2000:</p><pre class="oac_no_warn" dir="ltr">SELECT s.time_id, p.prod_subcategory, c.cust_city,
       SUM(s.amount_sold) AS sum_amount_sold
FROM sales s, products p, customers c
WHERE s.cust_id = c.cust_id AND s.prod_id = p.prod_id
AND   s.time_id BETWEEN TO_DATE('01-JAN-2000', 'DD-MON-YYYY')
AND TO_DATE('01-JUL-2000', 'DD-MON-YYYY')
GROUP BY time_id, prod_subcategory, cust_city;
</pre><p>Oracle Database knows that those ranges of rows in the materialized view are fresh and can therefore rewrite the query with the materialized view. The rewritten query looks as follows:</p><pre class="oac_no_warn" dir="ltr">SELECT time_id, prod_subcategory, cust_city, sum_amount_sold
FROM sum_sales_per_city_mv
WHERE time_id BETWEEN TO_DATE('01-JAN-2000', 'DD-MON-YYYY')
AND TO_DATE('01-JUL-2000', 'DD-MON-YYYY');
</pre><p>Instead of the partitioning key, a partition marker (a function that identifies the partition given a rowid) can be present in the <code class="codeph">SELECT</code> (and <code class="codeph">GROUP</code> <code class="codeph">BY</code> list) of the materialized view. You can use the materialized view to rewrite queries that require data from only certain partitions (identifiable by the partition-marker), for instance, queries that have a predicate specifying ranges of the partitioning keys containing entire partitions. See <a href="advanced-materialized-views.html#GUID-F7394DFE-7CF6-401C-A312-C36603BEB01B" title="Creating a materialized view over queries of an analytic view or a hierarchy is not supported.Real-time materialized views provide fresh data to user queries even when the materialized view is marked as stale.A real-time materialized view is a type of materialized view that provides fresh data to user queries even when the materialized view is not in sync with its base tables because of data changes.Using real-time materialized views is subject to certain restrictions.As with materialized views, multiple methods exist to access data stored in real-time materialized views.To create a real-time materialized view, use the ON QUERY COMPUTATION clause in the CREATE MATERIALIZED VIEW statement.If the prerequisites for a real-time materialized view are met, then an existing materialized view can be converted into a real-time materialized view by altering its definition and enabling on-query computation.For the query rewrite mechanism to rewrite a user query to use real-time materialized views, query rewrite must be enabled for the real-time materialized view.Query rewrite can use a real-time materialized view to provide results to user queries, even if the real-time materialized view is stale, if query rewrite is enabled for the real-time materialized view. A nested real-time materialized view is eligible for query rewrite only if all its base real-time materialized views are fresh.You can access a real-time materialized view directly by referencing the name of the real-time materialized view in a query. The ON_QUERY_COMPUTATION column in the data dictionary views ALL_MVIEWS, DBA_MVIEWS, and USER_MVIEWS indicates if a materialized view is a real-time materialized view. To obtain better performance for user queries that use a real-time materialized view, you can follow certain guidelines.">Advanced Materialized Views</a> for details regarding the supplied partition marker function <code class="codeph">DBMS_MVIEW.PMARKER</code>.
                        </p>
                        <p>The following example illustrates the use of a partition marker in the materialized view instead of directly using the partition key column:</p><pre class="oac_no_warn" dir="ltr">CREATE MATERIALIZED VIEW sum_sales_per_city_2_mv
ENABLE QUERY REWRITE AS
SELECT DBMS_MVIEW.PMARKER(s.rowid) AS pmarker,
       t.fiscal_quarter_desc, p.prod_subcategory, c.cust_city,
       SUM(s.amount_sold) AS sum_amount_sold
FROM sales s, products p, customers c, times t
WHERE s.cust_id = c.cust_id AND s.prod_id = p.prod_id
AND   s.time_id = t.time_id
GROUP BY DBMS_MVIEW.PMARKER(s.rowid),
    p.prod_subcategory, c.cust_city, t.fiscal_quarter_desc;
</pre><p>Suppose you know that the partition <code class="codeph">sales_q1_2000</code> is fresh and DML changes have taken place for other partitions of the <code class="codeph">sales</code> table. For testing purposes, you can apply an arbitrary DML operation on <code class="codeph">sales</code>, changing a different partition than <code class="codeph">sales_q1_2000</code> when the materialized view is fresh. An example is the following:
                        </p><pre class="oac_no_warn" dir="ltr">INSERT INTO SALES VALUES(17, 10, '01-DEC-2000', 4, 380, 123.45, 54321);
</pre><p>Although the materialized view <code class="codeph">sum_sales_per_city_2_mv</code> is now considered generically stale, Oracle Database can rewrite the following query using this materialized view. This query restricts the data to the partition <code class="codeph">sales_q1_2000</code>, and selects only certain values of <code class="codeph">cust_city</code>, as shown in the following:
                        </p><pre class="oac_no_warn" dir="ltr">SELECT p.prod_subcategory, c.cust_city, SUM(s.amount_sold) AS sum_amount_sold 
FROM sales s, products p, customers c, times t
WHERE s.cust_id = c.cust_id AND s.prod_id = p.prod_id AND s.time_id = t.time_id
AND c.cust_city= 'Nuernberg' 
AND s.time_id &gt;=TO_DATE('01-JAN-2000','dd-mon-yyyy')
AND s.time_id &lt;  TO_DATE('01-APR-2000','dd-mon-yyyy') 
GROUP BY prod_subcategory, cust_city;
</pre><p>Note that rewrite with a partially stale materialized view that contains a <code class="codeph">PMARKER</code> function can only take place when the complete data content of one or more partitions is accessed and the predicate condition is on the partitioned fact table itself, as shown in the earlier example.
                        </p>
                        <p>The <code class="codeph">DBMS_MVIEW.PMARKER</code> function gives you exactly one distinct value for each partition. This dramatically reduces the number of rows in a potential materialized view compared to the partitioning key itself, but you are also giving up any detailed information about this key. The only information you know is the partition number and, therefore, the lower and upper boundary values. This is the trade-off for reducing the cardinality of the range partitioning column and thus the number of rows.
                        </p>
                        <p>Assuming the value of <code class="codeph">p_marker</code> for partition <code class="codeph">sales_q1_2000</code> is 31070, the previously shown queries can be rewritten against the materialized view as follows:
                        </p><pre class="oac_no_warn" dir="ltr">SELECT mv.prod_subcategory, mv.cust_city, SUM(mv.sum_amount_sold) 
FROM sum_sales_per_city_2_mv mv 
WHERE mv.pmarker = 31070 AND mv.cust_city= 'Nuernberg'
GROUP BY prod_subcategory, cust_city; 
</pre><p>So the query can be rewritten against the materialized view without accessing stale data.</p>
                     </div>
                  </div>
               </div><a id="DWHSG08041"></a><div class="props_rev_3"><a id="GUID-5C3DD547-5E57-40CE-9AC9-770214718949" name="GUID-5C3DD547-5E57-40CE-9AC9-770214718949"></a><h4 id="DWHSG-GUID-5C3DD547-5E57-40CE-9AC9-770214718949" class="sect4"><span class="enumeration_section">12.3.12 </span>Cursor Sharing and Bind Variables During Query Rewrite
                  </h4>
                  <div>
                     <p>Query<a id="d44607e5446" class="indexterm-anchor"></a><a id="d44607e5450" class="indexterm-anchor"></a> rewrite is supported when the query contains user bind variables as long as the actual bind values are not required during query rewrite. If the actual values of the bind variables are required during query rewrite, then you can say that query rewrite is dependent on the bind values. Because the user bind variables are not available during query rewrite time, if query rewrite is dependent on the bind values, it is not possible to rewrite the query. For example, consider the following materialized view, <code class="codeph">customer_mv</code>, which has the predicate, (<code class="codeph">customer_id &gt;= 1000</code>), in the <code class="codeph">WHERE</code> clause:
                     </p><pre class="oac_no_warn" dir="ltr">CREATE MATERIALIZED VIEW customer_mv
ENABLE QUERY REWRITE AS
SELECT cust_id, prod_id,  SUM(amount_sold) AS total_amount
FROM sales WHERE cust_id &gt;= 1000
GROUP BY cust_id, prod_id;
</pre><p>Consider the following query, which has a user bind variable, <code class="codeph">:user_id</code>, in its <code class="codeph">WHERE</code> clause:
                     </p><pre class="oac_no_warn" dir="ltr">SELECT cust_id, prod_id, SUM(amount_sold) AS sum_amount
FROM sales WHERE cust_id &gt; :user_id
GROUP BY cust_id, prod_id;
</pre><p>Because the materialized view, <code class="codeph">customer_mv</code>, has a selection in its <code class="codeph">WHERE</code> clause, query rewrite is dependent on the actual value of the user bind variable, <code class="codeph">user_id</code>, to compute the containment. Because <code class="codeph">user_id</code> is not available during query rewrite time and query rewrite is dependent on the bind value of <code class="codeph">user_id</code>, this query cannot be rewritten. 
                     </p>
                     <p>Even though the preceding example has a user bind variable in the <code class="codeph">WHERE</code> clause, the same is true regardless of where the user bind variable appears in the query. In other words, irrespective of where a user bind variable appears in a query, if query rewrite is dependent on its value, then the query cannot be rewritten.
                     </p>
                     <p>Now consider the following query which has a user bind variable, <code class="codeph">:user_id</code>, in its <code class="codeph">SELECT</code> list:
                     </p><pre class="oac_no_warn" dir="ltr">SELECT cust_id + :user_id, prod_id, SUM(amount_sold) AS total_amount
FROM sales WHERE cust_id &gt;= 2000
GROUP BY cust_id, prod_id;
</pre><p>Because the value of the user bind variable, <code class="codeph">user_id</code>, is not required during query rewrite time, the preceding query will rewrite.
                     </p><pre class="oac_no_warn" dir="ltr">SELECT cust_id + :user_id, prod_id, total_amount
FROM customer_mv;</pre></div>
               </div><a id="DWHSG08042"></a><div class="props_rev_3"><a id="GUID-3FD90BE4-F577-4AB9-8762-2701C8B60193" name="GUID-3FD90BE4-F577-4AB9-8762-2701C8B60193"></a><h4 id="DWHSG-GUID-3FD90BE4-F577-4AB9-8762-2701C8B60193" class="sect4"><span class="enumeration_section">12.3.13 </span>Handling Expressions in Query Rewrite
                  </h4>
                  <div>
                     <p>Rewrite with some expressions is also supported when the expression evaluates to a constant, such as <code class="codeph">TO_DATE(</code><code class="codeph">'</code><code class="codeph">12-SEP-1999</code><code class="codeph">'</code><code class="codeph">,</code><code class="codeph">'</code><code class="codeph">DD-Mon-YYYY</code><code class="codeph">'</code><code class="codeph">)</code>. For example, if an existing materialized view is defined as:
                     </p><pre class="oac_no_warn" dir="ltr">CREATE MATERIALIZED VIEW sales_on_valentines_day_99_mv
BUILD IMMEDIATE
REFRESH FORCE
ENABLE QUERY REWRITE AS
SELECT s.prod_id, s.cust_id, s.amount_sold
FROM times t, sales s WHERE s.time_id = t.time_id
AND t.time_id = TO_DATE('14-FEB-1999', 'DD-MON-YYYY');
</pre><p>Then the following query can be rewritten:</p><pre class="oac_no_warn" dir="ltr">SELECT s.prod_id, s.cust_id, s.amount_sold
FROM sales s, times t WHERE s.time_id = t.time_id
AND t.time_id = TO_DATE('14-FEB-1999', 'DD-MON-YYYY');
</pre><p>This query would be rewritten as follows:</p><pre class="oac_no_warn" dir="ltr">SELECT * FROM sales_on_valentines_day_99_mv;
</pre><p>Whenever <code class="codeph">TO_DATE</code> is used, query rewrite only occurs if the date mask supplied is the same as the one specified by the <code class="codeph">NLS_DATE_FORMAT</code>.
                     </p>
                  </div>
               </div>
            </div><a id="DWHSG8556"></a><a id="DWHSG8557"></a><a id="DWHSG8558"></a><a id="DWHSG0804"></a><div class="props_rev_3"><a id="GUID-94D148DC-1E2A-4791-A7B6-28F9BF0306C1" name="GUID-94D148DC-1E2A-4791-A7B6-28F9BF0306C1"></a><h3 id="DWHSG-GUID-94D148DC-1E2A-4791-A7B6-28F9BF0306C1" class="sect3"><span class="enumeration_section">12.4 </span>Advanced Query Rewrite Using Equivalences
               </h3>
               <div>
                  <div class="section">
                     <p>There is<a id="d44607e5600" class="indexterm-anchor"></a><a id="d44607e5604" class="indexterm-anchor"></a> a special type of query rewrite that is possible where a declaration is made that two SQL statements are functionally equivalent. This capability enables you to place inside application knowledge into the database so the database can exploit this knowledge for improved query performance. You do this by declaring two <code class="codeph">SELECT</code> statements to be functionally equivalent (returning the same rows and columns) and indicating that one of the <code class="codeph">SELECT</code> statements is more favorable for performance.
                     </p>
                     <p>This advanced rewrite capability can generally be applied to a variety of query performance problems and opportunities. Any application can use this capability to affect rewrites against complex user queries that can be answered with much simpler and more performant queries that have been specifically created, usually by someone with inside application knowledge.</p>
                     <p>There are many scenarios where you can have inside application knowledge that would allow SQL statement transformation and tuning for significantly improved performance. The types of optimizations you may wish to affect can be very simple or as sophisticated as significant restructuring of the query. However, the incoming SQL queries are often generated by applications and you have no control over the form and structure of the application-generated queries.</p>
                     <p>To gain access to this capability, you need to connect as <code class="codeph">SYSDBA</code> and explicitly grant execute access to the desired database administrators who will be declaring rewrite equivalences. See <a href="../arpls/DBMS_ADVANCED_REWRITE.html#ARPLS083" target="_blank"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for more information.
                     </p>
                     <p>To illustrate this type of advanced rewrite, some examples using multidimensional data are provided. To optimize resource usage, an application may employ complicated SQL, custom C code or table functions to retrieve the data from the database. This complexity is irrelevant as far as end users are concerned. Users would still want to obtain their answers using typical queries with <code class="codeph">SELECT</code> ... <code class="codeph">GROUP</code> <code class="codeph">BY</code>.
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-94D148DC-1E2A-4791-A7B6-28F9BF0306C1__GUID-4F830616-3710-4710-A833-69FB860C60EF">
                     <p class="titleinexample">Example 12-12 Rewrite Using Equivalence</p>
                     <p>This example declares to Oracle that a given user query must be executed using a specified alternative query. Oracle would recognize this relationship and every time the user asked the query, it would transparently rewrite it using the alternative. Thus, the user is saved from the trouble of understanding and writing SQL for complicated aggregate computations.</p>
                     <p>There are two base tables <code class="codeph">sales_fact</code> and <code class="codeph">geog_dim</code>. You can compute the total sales for each city, state and region with a rollup, by issuing the following statement:
                     </p><pre class="oac_no_warn" dir="ltr">SELECT g.region, g.state, g.city,
GROUPING_ID(g.city, g.state, g.region), SUM(sales)
FROM sales_fact f, geog_dim g WHERE f.geog_key = g.geog_key
GROUP BY ROLLUP(g.region, g.state, g.city);
</pre><p>An application may want to materialize this query for quick results. Unfortunately, the resulting materialized view occupies too much disk space. However, if you have a dimension rolling up city to state to region, you can easily compress the three grouping columns into one column using a decode statement. (This is also known as an embedded total):</p><pre class="oac_no_warn" dir="ltr">DECODE (gid, 0, city, 1, state, 3, region, 7, "grand_total")
</pre><p>What this does is use the lowest level of the hierarchy to represent the entire information. For example, saying <code class="codeph">Boston</code> means <code class="codeph">Boston, MA, New England Region</code> and saying <code class="codeph">CA</code> means <code class="codeph">CA, Western Region</code>. An application can store these embedded total results into a table, say, <code class="codeph">embedded_total_sales</code>.
                     </p>
                     <p>However, when returning the result back to the user, you would want to have all the data columns (city, state, region). In order to return the results efficiently and quickly, an application may use a custom table function (<code class="codeph">et_function</code>) to retrieve the data back from the <code class="codeph">embedded_total_sales</code> table in the expanded form as follows:
                     </p><pre class="oac_no_warn" dir="ltr">SELECT * FROM TABLE (et_function);
</pre><p>In other words, this feature allows an application to declare the equivalence of the user's preceding query to the alternative query, as in the following:</p><pre class="oac_no_warn" dir="ltr">DBMS_ADVANCED_REWRITE.DECLARE_REWRITE_EQUIVALENCE (
   'EMBEDDED_TOTAL',
   'SELECT g.region, g.state, g.city,
    GROUPING_ID(g.city, g.state, g.region), SUM(sales)
    FROM sales_fact f, geog_dim g
    WHERE f.geog_key = g.geog_key
    GROUP BY ROLLUP(g.region, g.state, g.city)',
    'SELECT * FROM TABLE(et_function)');
</pre><p>This invocation of <code class="codeph">DECLARE_REWRITE_EQUIVALENCE</code> creates an equivalence declaration named <code class="codeph">EMBEDDED_TOTAL</code> stating that the specified <code class="codeph">SOURCE_STMT</code> and the specified <code class="codeph">DESTINATION_STMT</code> are functionally equivalent, and that the specified <code class="codeph">DESTINATION_STMT</code> is preferable for performance. After the DBA creates such a declaration, the user need have no knowledge of the space optimization being performed underneath the covers.
                     </p>
                     <p>This capability also allows an application to perform specialized partial materializations of a SQL query. For instance, it could perform a rollup using a <code class="codeph">UNION</code> <code class="codeph">ALL</code> of three relations as shown in <a href="advanced-query-rewrite-materialized-views.html#GUID-94D148DC-1E2A-4791-A7B6-28F9BF0306C1__BABIGJAH">Example 12-13</a>.
                     </p>
                  </div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-94D148DC-1E2A-4791-A7B6-28F9BF0306C1__BABIGJAH">
                     <p class="titleinexample">Example 12-13 Rewrite Using Equivalence (UNION ALL)</p><pre class="oac_no_warn" dir="ltr">CREATE MATERIALIZED VIEW T1
AS SELECT g.region, g.state, g.city, 0 AS gid, SUM(sales) AS sales
FROM sales_fact f, geog_dim g WHERE f.geog_key = g.geog_key
GROUP BY g.region, g.state, g.city;

CREATE MATERIALIZED VIEW T2 AS
SELECT t.region, t.state, SUM(t.sales) AS sales
FROM T1 GROUP BY t.region, t.state;

CREATE VIEW T3 AS
SELECT t.region, SUM(t.sales) AS sales
FROM T2 GROUP BY t.region;
</pre><p>The <code class="codeph">ROLLUP(region, state, city)</code> query is then equivalent to:
                     </p><pre class="oac_no_warn" dir="ltr">SELECT * FROM T1 UNION ALL
SELECT region, state, NULL, 1 AS gid, sales FROM T2 UNION ALL
SELECT region, NULL, NULL, 3 AS gid, sales FROM T3 UNION ALL
SELECT NULL, NULL, NULL, 7 AS gid, SUM(sales) FROM T3;
</pre><p>By specifying this equivalence, Oracle Database would use the more efficient second form of the query to compute the <code class="codeph">ROLLUP</code> query asked by the user.
                     </p><pre class="oac_no_warn" dir="ltr">DBMS_ADVANCED_REWRITE.DECLARE_REWRITE_EQUIVALENCE (
   'CUSTOM_ROLLUP',
   'SELECT g.region, g.state, g.city,
   GROUPING_ID(g.city, g.state, g.region), SUM(sales)
   FROM sales_fact f, geog_dim g
   WHERE f.geog_key = g.geog_key
   GROUP BY ROLLUP(g.region, g.state, g.city ',
   ' SELECT * FROM T1
   UNION ALL
   SELECT region, state, NULL, 1 as gid, sales FROM T2
   UNION ALL
   SELECT region, NULL, NULL, 3 as gid, sales FROM T3
   UNION ALL
   SELECT NULL, NULL, NULL, 7 as gid, SUM(sales) FROM T3');
</pre><p>Another application of this feature is to provide users special aggregate computations that may be conceptually simple but extremely complex to express in SQL. In this case, the application asks the user to use a specified custom aggregate function and internally compute it using complex SQL.</p>
                  </div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-94D148DC-1E2A-4791-A7B6-28F9BF0306C1__GUID-3278789A-FFC9-4A1D-A5DF-E0DF1D6C3A8D">
                     <p class="titleinexample">Example 12-14 Rewrite Using Equivalence (Using a Custom Aggregate)</p>
                     <p>Suppose the application users want to see the sales for each city, state and region and also additional sales information for specific seasons. For example, the New England user wants additional sales information for cities in New England for the winter months. The application would provide you a special aggregate <code class="codeph">Seasonal_Agg</code> that computes the earlier aggregate. You would ask a classic summary query but use <code class="codeph">Seasonal_Agg(sales, region)</code> rather than <code class="codeph">SUM(sales)</code>.
                     </p><pre class="oac_no_warn" dir="ltr">SELECT g.region, t.calendar_month_name, Seasonal_Agg(f.sales, g.region) AS sales
FROM sales_fact f, geog_dim g, times t
WHERE f.geog_key = g.geog_key AND f.time_id = t.time_id
GROUP BY g.region, t.calendar_month_name;
</pre><p>Instead of asking the user to write SQL that does the extra computation, the application can do it automatically for them by using this feature. In this example, <code class="codeph">Seasonal_Agg</code> is computed using the spreadsheet functionality (see <a href="sql-modeling-data-warehouses.html#GUID-538F78AA-9BF3-46F2-93D1-39A8739B3237">SQL for Modeling</a>). Note that even though <code class="codeph">Seasonal_Agg</code> is a user-defined aggregate, the required behavior is to add extra rows to the query's answer, which cannot be easily done with simple PL/SQL functions.
                     </p><pre class="oac_no_warn" dir="ltr">DBMS_ADVANCED_REWRITE.DECLARE_REWRITE_EQUIVALENCE (
   'CUSTOM_SEASONAL_AGG',
   SELECT g.region, t.calendar_month_name, Seasonal_Agg(sales, region) AS sales
   FROM sales_fact f, geog_dim g, times t
   WHERE f.geog_key = g.geog_key AND f.time_id = t.time_id
   GROUP BY g.region, t.calendar_month_name',
   'SELECT g,region, t.calendar_month_name, SUM(sales) AS sales
   FROM sales_fact f, geog_dim g
   WHERE f.geog_key = g.geog_key AND t.time_id = f.time_id
   GROUP BY g.region, g.state, g.city, t.calendar_month_name
   DIMENSION BY g.region, t.calendar_month_name
   (sales ['New England', 'Winter'] = AVG(sales) OVER calendar_month_name IN
    ('Dec', 'Jan', 'Feb', 'Mar'),
   sales ['Western', 'Summer' ] = AVG(sales) OVER calendar_month_name IN
   ('May', 'Jun', 'July', 'Aug'), .);</pre></div>
                  <!-- class="example" -->
               </div>
            </div><a id="DWHSG8915"></a><a id="DWHSG0807"></a><div class="props_rev_3"><a id="GUID-71197259-E8A4-45E5-A462-A9ADF6517CD6" name="GUID-71197259-E8A4-45E5-A462-A9ADF6517CD6"></a><h3 id="DWHSG-GUID-71197259-E8A4-45E5-A462-A9ADF6517CD6" class="sect3"><span class="enumeration_section">12.5 </span>Creating Result Cache Materialized Views with Equivalences
               </h3>
               <div>
                  <p>A special type of materialized view, called a result cache materialized view (RCMV), enables you to use a result cache when running query rewrite. These result cache materialized views offer the main advantages of the result cache, faster access with less space required, without the normal drawback of being unable to run query rewrite against them.</p>
                  <p>An example of using this type of materialized view is the following.</p>
                  <div class="example" id="GUID-71197259-E8A4-45E5-A462-A9ADF6517CD6__GUID-232AD555-A465-4DF8-AFA8-45C2256AA281">
                     <p class="titleinexample">Example 12-15 Result Cache Materialized View</p>
                     <p>First, grant the requisite permissions:</p><pre class="oac_no_warn" dir="ltr">CONNECT / AS SYSDBA
GRANT CREATE MATERIALIZED VIEW TO sh;
GRANT EXECUTE ON DBMS_ADVANCED_REWRITE TO sh;
</pre><p>Next, create the result cache materialized view:</p><pre class="oac_no_warn" dir="ltr">CONNECT sh/sh
begin
   sys.DBMS_ADVANCED_REWRITE.Declare_Rewrite_Equivalence
    (
     Name               =&gt; 'RCMV_SALES',
     Source_Stmt        =&gt;
      'select channel_id, prod_id, sum(amount_sold), count(amount_sold)
       from sales
       group by prod_id, channel_id',
     Destination_Stmt   =&gt;
      'select * from
      (select /*+ RESULT_CACHE(name=RCMV_SALES) */
               channel_id, prod_id, sum(amount_sold), count(amount_sold)
         from sales
         group by prod_id, channel_id)',
       Validate         =&gt; FALSE,
       Rewrite_Mode     =&gt; 'GENERAL'
       );
end;
/

ALTER SESSION SET query_rewrite_integrity = stale_tolerated;
</pre><p>Then, verify that different queries all rewrite to <code class="codeph">RCMV_SALES</code> by looking at the explain plan:
                     </p><pre class="oac_no_warn" dir="ltr">EXPLAIN PLAN FOR
  SELECT channel_id, SUM(amount_sold) FROM sales GROUP BY channel_id;
@?/rdbms/admin/utlxpls

PLAN_TABLE_OUTPUT
--------------------------------------------------------------------------------
Plan hash value: 3903632134
--------------------------------------------------------------------------------
|Id |         Operation       | Name  |Rows|Bytes|Cost(%CPU)| Time |Pstart|Pstop|
---------------------------------------------------------------------------------
| 0 | SELECT STATEMENT        |       |  4 |   64| 1340 (68)|00:00:17|    |    |
| 1 |  HASH GROUP BY          |       |  4 |   64| 1340 (68)|00:00:17|    |    |
| 2 |   VIEW                  |       | 204| 3264| 1340 (68)|00:00:17|    |    |
| 3 |    RESULT CACHE         |3gps5zr86gyb53y36js9zuay2s| | | |     |    |    |
| 4 |     HASH GROUP BY       |       | 204| 2448| 1340 (68)|00:00:17|    |    |
| 5 |      PARTITION RANGE ALL|       |918K|  10M|  655 (33)|00:00:08|  1 | 28 |
| 6 |       TABLE ACCESS FULL | SALES |918K|  10M|  655 (33)|00:00:08|  1 | 28 |
---------------------------------------------------------------------------------

Result Cache Information (identified by operation id):
------------------------------------------------------
   3 - column-count=4; dependencies=(SH.SALES); name="RCMV_SALES"

18 rows selected.
</pre><p>Then, execute the query that creates the cached result:</p><pre class="oac_no_warn" dir="ltr">SELECT channel_id, SUM(amount_sold)
FROM sales
GROUP BY channel_id;

CHANNEL_ID  SUM(AMOUNT_SOLD)
----------  ----------------
         2        26346342.3
         4          13706802
         3        57875260.6
         9         277426.26

</pre><p>Next, verify that the materialized view was materialized in the result cache:</p><pre class="oac_no_warn" dir="ltr">CONNECT / AS SYSDBA

SELECT name, scan_count hits, block_count blocks, depend_count dependencies
FROM V$RESULT_CACHE_OBJECTS
WHERE name = 'RCMV_SALES';

NAME         HITS    BLOCKS   DEPENDENCIES
----------   ----    ------   ------------
RCMV_SALES      0         5              1
</pre><p>Finally, drop the RCMV query equivalence:</p><pre class="oac_no_warn" dir="ltr">begin
  sys.DBMS_ADVANCED_REWRITE.Drop_Rewrite_equivalence('RCMV_SALES');
end;
/
</pre></div>
                  <!-- class="example" -->
                  <p>For more information regarding result caches, see <a href="../tgsql/generating-and-displaying-execution-plans.html#TGSQL-GUID-FE0B82DA-1A06-4145-B03D-A1C39DB1F88F" target="_blank"><span><cite>Oracle Database SQL Tuning Guide</cite></span></a>.
                  </p>
               </div>
            </div>
            <div class="sect2"><a id="GUID-41A13A98-E51A-435A-973E-05CC083F2CFC" name="GUID-41A13A98-E51A-435A-973E-05CC083F2CFC"></a><h3 id="DWHSG-GUID-41A13A98-E51A-435A-973E-05CC083F2CFC" class="sect3"><span class="enumeration_section">12.6 </span>Query Rewrite and Materialized Views Based on Approximate Queries
               </h3>
               <div>
                  <p>Queries containing SQL functions that return approximate results are automatically rewritten to use a matching materialized view, if these queries can be answered using the materialized view.</p>
                  <p></p>
                  <p>For a query containing SQL functions that return approximate results to be rewritten using a materialized view that is based on an approximate query, ensure that query rewrite is enabled for the materialized view. Query rewrite must also be enabled either at the database level or for the current session.</p>
                  <p>Consider the materialized view <code class="codeph">approx_count_distinct_pdt_mv</code> that was defined as follows:
                  </p><pre class="pre codeblock"><code>CREATE MATERIALIZED VIEW approx_count_distinct_pdt_mv 
ENABLE QUERY REWRITE AS
SELECT t.calendar_year, t.calendar_month_number, t.day_number_in_month, approx_count_distinct_detail(prod_id) daily_detail
FROM sales s, times t
WHERE s.time_id = t.time_id
GROUP BY t.calendar_year, t.calendar_month_number, t.day_number_in_month;
</code></pre><p>When a query that matches the defining query of <code class="codeph">approx_count_distinct_pdt_mv</code> is run, and the prerequisites described in this section are met, the query is automatically rewritten to use this materialized view. The following query is rewritten to use <code class="codeph">approx_count_distinct_pdt_mv</code>, as indicated by the execution plan generated for the query.
                  </p><pre class="pre codeblock"><code>SELECT t.calendar_year, t.calendar_month_number, t.day_number_in_month, approx_count_distinct(prod_id) 
FROM sales s, times t
WHERE s.time_id = t.time_id 
GROUP BY t.calendar_year, t.calendar_month_number, t.day_number_in_month;

PLAN_TABLE_OUTPUT
-------------------------------------------------------------------------------------------------------------
Plan hash value: 2307354865
-------------------------------------------------------------------------------------------------------------
| Id  | Operation                    | Name                         | Rows  | Bytes | Cost (%CPU)| Time     |
-------------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT             |                              |  1460 | 74460 |   205   (0)| 00:00:01 |
|   1 |  MAT_VIEW REWRITE ACCESS FULL| APPROX_COUNT_DISTINCT_PDT_MV |  1460 | 74460 |   205   (0)| 00:00:01 |
-------------------------------------------------------------------------------------------------------------

8 rows selected.
</code></pre><p>The following query is also rewritten to use <code class="codeph">approx_count_distinct_pdt_mv</code> as indicated by the execution plan. Note that this query aggregates data to a higher level than that defined by the defining query of <code class="codeph">approx_count_distinct_pdt_mv</code>.
                  </p><pre class="pre codeblock"><code>SELECT t.calendar_year, t.calendar_month_number, approx_count_distinct(prod_id) 
FROM sales s, times t 
WHERE s.time_id = t.time_id 
GROUP BY t.calendar_year, t.calendar_month_number;

PLAN_TABLE_OUTPUT
--------------------------------------------------------------------------------------------------------------
Plan hash value: 827336432
--------------------------------------------------------------------------------------------------------------
| Id  | Operation                     | Name                         | Rows  | Bytes | Cost (%CPU)| Time     |
--------------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT              |                              |    34 |  1632 |   206   (1)| 00:00:01 |
|   1 |  HASH GROUP BY APPROX         |                              |    34 |  1632 |   206   (1)| 00:00:01 |
|   2 |   MAT_VIEW REWRITE ACCESS FULL| APPROX_COUNT_DISTINCT_PDT_MV |  1460 | 70080 |   205   (0)| 00:00:01 |
--------------------------------------------------------------------------------------------------------------

9 rows selected.</code></pre><div class="section">
                     <p class="subhead2" id="GUID-41A13A98-E51A-435A-973E-05CC083F2CFC__GUID-B767DDCE-4DA1-40F5-BB0A-C2004AD2DDCF">Rewriting Queries with Exact Functions to Use Materialized Views that Contain Approximate Functions</p>
                     <p>If you set database initialization parameters that substitute exact functions with the corresponding SQL functions that return approximate values, then the optimizer can rewrite queries containing exact functions to use materialized views that are defined using the approximate versions of the same functions. You need not rewrite the query to use the corresponding approximate functions.</p>
                     <p>For example, if the <code class="codeph">approx_for_count_distinct</code> parameter is set to <code class="codeph">TRUE</code>, then the optimizer rewrites the following query to use the materialized view <code class="codeph">approx_count_distinct_pdt_mv</code>:
                     </p><pre class="pre codeblock"><code>ALTER SESSION SET approx_for_count_distinct = TRUE;

SELECT t.calendar_year, t.calendar_month_number, COUNT (DISTINCT prod_id) 
FROM sales s, times t
WHERE s.time_id = t.time_id 
GROUP BY t.calendar_year, t.calendar_month_number;

PLAN_TABLE_OUTPUT
--------------------------------------------------------------------------------------------------------------
Plan hash value: 827336432
--------------------------------------------------------------------------------------------------------------
| Id  | Operation		      | Name			     | Rows  | Bytes | Cost (%CPU)| Time     |
--------------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT	      | 			     |	  34 |	1632 |	 206   (1)| 00:00:01 |
|   1 |  HASH GROUP BY APPROX	      | 			     |	  34 |	1632 |	 206   (1)| 00:00:01 |
|   2 |   MAT_VIEW REWRITE ACCESS FULL| APPROX_COUNT_DISTINCT_PDT_MV |	1460 | 70080 |	 205   (0)| 00:00:01 |
--------------------------------------------------------------------------------------------------------------

9 rows selected.
</code></pre><p>Observe that the above execution plan is the same as the execution plan that was generated when the query uses the <code class="codeph">approx_count_distinct</code> in the previous example.
                     </p>
                     <div class="infoboxnotealso" id="GUID-41A13A98-E51A-435A-973E-05CC083F2CFC__GUID-B8E12426-808E-409A-9CF1-261112F83EE5">
                        <p class="notep1">See Also:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><a href="data-warehouse-optimizations-techniques.html#GUID-F7E7DEA6-B225-43E6-97ED-CB3DBE86CD54" title="Approximate query processing uses SQL functions to provide real-time responses to explorative queries where approximations are acceptable. A query containing SQL functions that return approximate results is referred to as an approximate query.">About Approximate Query Processing</a></p>
                           </li>
                           <li>
                              <p><a href="sql-analysis-reporting-data-warehouses.html#GUID-6A387B85-B347-4065-8A48-8F3E4AA91F87" title="Approximate aggregates are computed using SQL functions that return approximate results. They are used primarily in data exploration queries where exact values are not required and approximations are acceptable.">About Approximate Aggregates</a></p>
                           </li>
                           <li>
                              <p><a href="basic-materialized-views.html#GUID-42B64F99-7391-48B8-B37D-1B486DC29645" title="A materialized view based on approximate queries uses SQL functions that return approximate functions in its defining query.">Creating Materialized Views Based on Approximate Queries</a></p>
                           </li>
                        </ul>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div>
            </div>
            <div class="sect2"><a id="GUID-50F1CD49-F551-4443-96FD-6F8EDA694930" name="GUID-50F1CD49-F551-4443-96FD-6F8EDA694930"></a><h3 id="DWHSG-GUID-50F1CD49-F551-4443-96FD-6F8EDA694930" class="sect3"><span class="enumeration_section">12.7 </span>Query Rewrite and Materialized Views Based on Bitmap-based COUNT(DISTINCT) Functions
               </h3>
               <div>
                  <p>Queries that contain <code class="codeph">COUNT(DISTINCT)</code> operations on integer columns can be rewritten to use materialized views that contain bitmap-based functions.
                  </p>
                  <p></p>
                  <p>Enable query rewrite for the materialized view so that SQL queries can be rewritten using this  materialized views.</p>
                  <div class="example" id="GUID-50F1CD49-F551-4443-96FD-6F8EDA694930__GUID-3B53EFDB-DB29-4CD3-BA63-239C90AF5D40">
                     <p class="titleinexample">Example 12-16 Query Rewrite Using Materialized Views Containing COUNT(DISTINCT)</p>
                     <p>The materialized view <code class="codeph">mv_sales</code> was created using the following command:
                     </p><pre class="pre codeblock"><code>create materialized view mv_sales as
  select PROMO_ID, BITMAP_BUCKET_NUMBER(PROD_ID) bm_bktno,
  BITMAP_CONSTRUCT_AGG(BITMAP_BIT_POSITION(PROD_ID),'RAW') bm_details
  from sales 
  group by PROMO_ID,BITMAP_BUCKET_NUMBER(PROD_ID);</code></pre><p>Query rewrite has been enabled for the materialized view <code class="codeph">mv_sales</code>.
                     </p>
                     <p>When a SQL query performs a <code class="codeph">COUNT(DISTINCT)</code> operation on a numeric column that is included in the <code class="codeph">mv_sales</code> materialized view definition, the query is rewritten to use the materialized view. The execution plan below shows that the materialized view was used.
                     </p><pre class="pre codeblock"><code>SQL&gt; EXPLAIN PLAN FOR select PROMO_ID,count(distinct PROD_ID) from sales group by PROMO_ID order by PROMO_ID;

Explained.

SQL&gt; SELECT PLAN_TABLE_OUTPUT FROM TABLE(DBMS_XPLAN.DISPLAY());

PLAN_TABLE_OUTPUT
------------------------------------------------------------------------------------------------------------
Plan hash value: 2440767223

----------------------------------------------
| Id  | Operation               | Name       |
----------------------------------------------
|   0 | SELECT STATEMENT        |            |
|   1 |  SORT GROUP BY          |            |
|   2 |   VIEW                  |            |
|   3 |    HASH GROUP BY        |            |
|   4 |     MAT_VIEW ACCESS FULL| MV_SALES   |
----------------------------------------------

Note
-----
   - dynamic statistics used: dynamic sampling (level=2)

15 rows selected.
</code></pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-50F1CD49-F551-4443-96FD-6F8EDA694930__GUID-B6CC0CF2-0AE6-449E-B06A-8DD6D7E6D345">
                     <p class="titleinexample">Example 12-17 Query Rewrite with Bitmap-based COUNT(DISTINCT) and Rollup</p>
                     <p>The following command was used to create the materialized view <code class="codeph">mv_sales_amount</code>:
                     </p><pre class="pre codeblock"><code>create materialized view mv_sales_amount AS
SELECT PROMO_ID, CHANNEL_ID,
       BITMAP_BUCKET_NUMBER(PROD_ID) as bm_bktno,
       BITMAP_CONSTRUCT_AGG(BITMAP_BIT_POSITION(PROD_ID)) as bm_details,
       SUM(AMOUNT_SOLD) as amount_sold
FROM sales
GROUP BY PROMO_ID, CHANNEL_ID, BITMAP_BUCKET_NUMBER(PROD_ID);</code></pre><p>Query rewrite has been enabled for the materialized view <code class="codeph">mv_sales_amount</code>.
                     </p>
                     <p>The execution plan for the SQL command shown below demonstrates query rewrite to satisfy queries containing a <code class="codeph">COUNT(DISTINCT)</code> function. Query rewrite is performed at different levels of aggregation and in the presence of other aggregates.
                     </p><pre class="pre codeblock"><code>EXPLAIN PLAN FOR
SELECT PROMO_ID, COUNT(DISTINCT PROD_ID), SUM(AMOUNT_SOLD)
FROM sales
GROUP BY PROMO_ID;
-------------------------------------------------------------------------------------------
| Id | Operation          | Name            | Rows| Bytes| Cost (%CPU) | Time     |
-------------------------------------------------------------------------------------------
| 0 | SELECT STATEMENT    |                 | 163 | 6357 | 8 (13)      | 00:00:01 |
| 1 | HASH GROUP BY       |                 | 163 | 6357 | 8 (13)      | 00:00:01 |
| 2 | VIEW                |                 | 163 | 6357 | 8 (13)      | 00:00:01 |
| 3 | HASH GROUP BY       |                 | 163 | 324K | 8 (13)      | 00:00:01 |
| 4 | MAT_VIEW ACCESS FULL| MV_SALES_AMOUNT | 163 | 324K | 7 (0)       | 00:00:01 |
-------------------------------------------------------------------------------------------</code></pre></div>
                  <!-- class="example" -->
               </div>
            </div><a id="DWHSG0805"></a><div class="props_rev_3"><a id="GUID-3AB77341-BDA9-4F84-9691-EB79E4C8B832" name="GUID-3AB77341-BDA9-4F84-9691-EB79E4C8B832"></a><h3 id="DWHSG-GUID-3AB77341-BDA9-4F84-9691-EB79E4C8B832" class="sect3"><span class="enumeration_section">12.8 </span>Verifying that Query Rewrite has Occurred
               </h3>
               <div>
                  <div class="section">
                     <p>Because query rewrite occurs transparently, special steps have to be taken to verify that a query has been rewritten. Of course, if the query runs faster, this should indicate that rewrite has occurred, but that is not proof. Therefore, to confirm that query rewrite does occur, use the <code class="codeph">EXPLAIN</code> <code class="codeph">PLAN</code> statement or the <code class="codeph">DBMS_MVIEW.EXPLAIN_REWRITE</code> procedure.
                     </p>
                     <p>This section contains the following topics:</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="advanced-query-rewrite-materialized-views.html#GUID-4D27E4FA-A642-42FD-8627-7060B1861884">Using EXPLAIN PLAN with Query Rewrite</a></p>
                        </li>
                        <li>
                           <p><a href="advanced-query-rewrite-materialized-views.html#GUID-D4E6983B-D503-4801-8B0C-5E69D5313A11">Using the EXPLAIN_REWRITE Procedure with Query Rewrite</a></p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
               </div><a id="DWHSG08051"></a><div class="props_rev_3"><a id="GUID-4D27E4FA-A642-42FD-8627-7060B1861884" name="GUID-4D27E4FA-A642-42FD-8627-7060B1861884"></a><h4 id="DWHSG-GUID-4D27E4FA-A642-42FD-8627-7060B1861884" class="sect4"><span class="enumeration_section">12.8.1 </span>Using EXPLAIN PLAN with Query Rewrite
                  </h4>
                  <div>
                     <div class="section">
                        <p><a id="d44607e6081" class="indexterm-anchor"></a>The <code class="codeph">EXPLAIN</code> <code class="codeph">PLAN</code> facility is used as described in <a href="../sqlrf/EXPLAIN-PLAN.html#SQLRF01601" target="_blank"><span class="italic">Oracle Database SQL Language Reference</span></a>. For query rewrite, all you need to check is that the operation shows <code class="codeph">MAT_VIEW</code> <code class="codeph">REWRITE</code> <code class="codeph">ACCESS</code>. If it does, then query rewrite has occurred. An example is the following, which creates the materialized view <code class="codeph">cal_month_sales_mv</code>:
                        </p><pre class="oac_no_warn" dir="ltr">CREATE MATERIALIZED VIEW cal_month_sales_mv
ENABLE QUERY REWRITE AS
SELECT  t.calendar_month_desc, SUM(s.amount_sold) AS dollars
FROM sales s, times t WHERE s.time_id = t.time_id
GROUP BY t.calendar_month_desc;
</pre><p>If <code class="codeph">EXPLAIN</code> <code class="codeph">PLAN</code> is used on the following SQL statement, the results are placed in the default table <code class="codeph">PLAN_TABLE</code>. However, <code class="codeph">PLAN_TABLE</code> must first be created using the <code class="codeph">utlxplan.sql</code> script. Note that <code class="codeph">EXPLAIN</code> <code class="codeph">PLAN</code> does not actually execute the query.
                        </p><pre class="oac_no_warn" dir="ltr">EXPLAIN PLAN FOR
SELECT  t.calendar_month_desc, SUM(s.amount_sold)
FROM  sales s, times t WHERE s.time_id = t.time_id
GROUP BY t.calendar_month_desc; 
</pre><p>For the purposes of query rewrite, the only information of interest from <code class="codeph">PLAN_TABLE</code> is the operation <code class="codeph">OBJECT_NAME</code>, which identifies the method used to execute this query. Therefore, you would expect to see the operation <code class="codeph">MAT_VIEW</code> <code class="codeph">REWRITE</code> <code class="codeph">ACCESS</code> in the output as illustrated in the following:
                        </p><pre class="oac_no_warn" dir="ltr">SELECT OPERATION, OBJECT_NAME FROM PLAN_TABLE;

OPERATION                  OBJECT_NAME
--------------------       -----------------------
SELECT STATEMENT
MAT_VIEW REWRITE ACCESS    CALENDAR_MONTH_SALES_MV</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="DWHSG8559"></a><div class="props_rev_3"><a id="GUID-D4E6983B-D503-4801-8B0C-5E69D5313A11" name="GUID-D4E6983B-D503-4801-8B0C-5E69D5313A11"></a><h4 id="DWHSG-GUID-D4E6983B-D503-4801-8B0C-5E69D5313A11" class="sect4"><span class="enumeration_section">12.8.2 </span>Using the EXPLAIN_REWRITE Procedure with Query Rewrite
                  </h4>
                  <div>
                     <div class="section">
                        <p>It can be difficult <a id="d44607e6178" class="indexterm-anchor"></a><a id="d44607e6182" class="indexterm-anchor"></a><a id="d44607e6186" class="indexterm-anchor"></a>to understand why a query did not rewrite. The rules governing query rewrite eligibility are quite complex, involving various factors such as constraints, dimensions, query rewrite integrity modes, freshness of the materialized views, and the types of queries themselves. In addition, you may want to know why query rewrite chose a particular materialized view instead of another. To help with this matter, Oracle Database provides the <code class="codeph">DBMS_MVIEW.EXPLAIN_REWRITE</code> procedure to advise you when a query can be rewritten and, if not, why not. Using the results from <code class="codeph">DBMS_MVIEW.EXPLAIN_REWRITE</code>, you can take the appropriate action needed to make a query rewrite if at all possible.
                        </p>
                        <p>Note that the query specified in the <code class="codeph">EXPLAIN_REWRITE</code> statement does not actually execute.
                        </p>
                        <p>This section contains the following topics:</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><a href="advanced-query-rewrite-materialized-views.html#GUID-723FEA4B-2299-4DF1-8216-AAA5D03D8920">DBMS_MVIEW.EXPLAIN_REWRITE Syntax</a></p>
                           </li>
                           <li>
                              <p><a href="advanced-query-rewrite-materialized-views.html#GUID-5C0A241C-FDA4-4BBD-98EF-EC5FF47C8E62">Using REWRITE_TABLE to View EXPLAIN_REWRITE Output</a></p>
                           </li>
                           <li>
                              <p><a href="advanced-query-rewrite-materialized-views.html#GUID-F936CEE1-3568-4487-842A-015AFE940F87">Using a Varray to View EXPLAIN_REWRITE Output</a></p>
                           </li>
                           <li>
                              <p><a href="advanced-query-rewrite-materialized-views.html#GUID-EB88C4EC-D843-4AB5-934D-063894CE51D5">EXPLAIN_REWRITE Benefit Statistics</a></p>
                           </li>
                           <li>
                              <p><a href="advanced-query-rewrite-materialized-views.html#GUID-80AAF9D9-DA04-4804-931D-432CF883CE54">Support for Query Text Larger than 32KB in EXPLAIN_REWRITE</a></p>
                           </li>
                           <li>
                              <p><a href="advanced-query-rewrite-materialized-views.html#GUID-C6BFEB7A-B1E3-4E08-B38D-87FA3D6B1BBC">About EXPLAIN_REWRITE and Multiple Materialized Views</a></p>
                           </li>
                           <li>
                              <p><a href="advanced-query-rewrite-materialized-views.html#GUID-4A5FD50D-E2AB-4176-BD1B-418E7B2491BB">About EXPLAIN_REWRITE Output</a></p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div><a id="DWHSG8560"></a><div class="props_rev_3"><a id="GUID-723FEA4B-2299-4DF1-8216-AAA5D03D8920" name="GUID-723FEA4B-2299-4DF1-8216-AAA5D03D8920"></a><h5 id="DWHSG-GUID-723FEA4B-2299-4DF1-8216-AAA5D03D8920" class="sect5"><span class="enumeration_section">12.8.2.1 </span>DBMS_MVIEW.EXPLAIN_REWRITE Syntax
                     </h5>
                     <div>
                        <div class="section">
                           <p>You can obtain the output from <code class="codeph">DBMS_MVIEW.EXPLAIN_REWRITE</code> in two ways. The first is to use a table, while the second is to create a <code class="codeph">VARRAY</code>. The following shows the basic syntax for using an output table:
                           </p><pre class="oac_no_warn" dir="ltr">DBMS_MVIEW.EXPLAIN_REWRITE (
    query           VARCHAR2,
    mv              VARCHAR2(30),
    statement_id    VARCHAR2(30));
</pre><p>You can create an output table called <code class="codeph">REWRITE_TABLE</code> by executing the <code class="codeph">utlxrw.sql</code> script.
                           </p>
                           <p>The <code class="codeph">query</code> parameter is a text string representing the SQL query. The parameter, <code class="codeph">mv</code>, is a fully-qualified materialized view name in the form of <code class="codeph">schema.mv</code>. This is an optional parameter. When it is not specified, <code class="codeph">EXPLAIN_REWRITE</code> returns any relevant messages regarding all the materialized views considered for rewriting the given query. When <code class="codeph">schema</code> is omitted and only <code class="codeph">mv</code> is specified, <code class="codeph">EXPLAIN_REWRITE</code> looks for the materialized view in the current schema.
                           </p>
                           <p>If you want to direct the output of <code class="codeph">EXPLAIN_REWRITE</code> to a varray instead of a table, you should call the procedure as follows:
                           </p><pre class="oac_no_warn" dir="ltr">DBMS_MVIEW.EXPLAIN_REWRITE (
    query           [VARCHAR2 | CLOB],
    mv               VARCHAR2(30),
    output_array     SYS.RewriteArrayType);
</pre><p>Note that if the query is less than 256 characters long, <code class="codeph">EXPLAIN_REWRITE</code> can be easily invoked with the <code class="codeph">EXECUTE</code> command from SQL*Plus. Otherwise, the recommended method is to use a PL/SQL <code class="codeph">BEGIN... END</code> block, as shown in the examples in <code class="codeph">/rdbms/demo/smxrw*</code>.
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="DWHSG8562"></a><a id="DWHSG8561"></a><div class="props_rev_3"><a id="GUID-5C0A241C-FDA4-4BBD-98EF-EC5FF47C8E62" name="GUID-5C0A241C-FDA4-4BBD-98EF-EC5FF47C8E62"></a><h5 id="DWHSG-GUID-5C0A241C-FDA4-4BBD-98EF-EC5FF47C8E62" class="sect5"><span class="enumeration_section">12.8.2.2 </span>Using REWRITE_TABLE to View EXPLAIN_REWRITE Output
                     </h5>
                     <div>
                        <div class="section">
                           <p>The output of <code class="codeph">EXPLAIN_REWRITE</code> can be directed to a table named <code class="codeph">REWRITE_TABLE</code>. You can create this output table by running the <code class="codeph">utlxrw.sql</code> script. This script can be found in the <code class="codeph">admin</code> directory. The format of <code class="codeph">REWRITE_TABLE</code> is as follows:
                           </p><pre class="oac_no_warn" dir="ltr">CREATE TABLE REWRITE_TABLE(
  statement_id          VARCHAR2(30),   -- id for the query
  mv_owner              VARCHAR2(30),   -- owner of the MV
  mv_name               VARCHAR2(30),   -- name of the MV
  sequence              INTEGER,        -- sequence no of the msg
  query                 VARCHAR2(2000), -- user query
  query_block_no        INTEGER,        -- block no of the current subquery
  rewritten_txt         VARCHAR2(2000), -- rewritten query
  message               VARCHAR2(512),  -- EXPLAIN_REWRITE msg
  pass                  VARCHAR2(3),    -- rewrite pass no
  mv_in_msg             VARCHAR2(30),   -- MV in current message 
  measure_in_msg        VARCHAR2(30),   -- Measure in current message 
  join_back_tbl         VARCHAR2(30),   -- Join back table in message 
  join_back_col         VARCHAR2(30),   -- Join back column in message
  original_cost         INTEGER,        -- Cost of original query
  rewritten_cost        INTEGER,        -- Cost of rewritten query
  flags                 INTEGER,        -- associated flags
  reserved1             INTEGER,        -- currently not used 
  reerved2              VARCHAR2(10))   -- currently not used;</pre></div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-5C0A241C-FDA4-4BBD-98EF-EC5FF47C8E62__GUID-F6ADC987-2327-487D-B648-B5E6E3E690CD">
                           <p class="titleinexample">Example 12-18 EXPLAIN_REWRITE Using REWRITE_TABLE</p>
                           <p>An example PL/SQL invocation is:</p><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_MVIEW.EXPLAIN_REWRITE -
('SELECT p.prod_name, SUM(amount_sold) ' || -
'FROM sales s, products p ' || -
'WHERE s.prod_id = p.prod_id ' || -
' AND prod_name &gt; ''B%'' ' || -
' AND prod_name &lt; ''C%'' ' || -
'GROUP BY prod_name', -
'TestXRW.PRODUCT_SALES_MV', -
'SH');

SELECT message FROM rewrite_table ORDER BY sequence;
MESSAGE                                                                         
--------------------------------------------------------------------------------
QSM-01033: query rewritten with materialized view, PRODUCT_SALES_MV             
1 row selected.
</pre><p>The demo file <code class="codeph">xrwutl.sql</code> contains a procedure that you can call to provide a more detailed output from <code class="codeph">EXPLAIN_REWRITE</code>. See <span class="q">"<a href="advanced-query-rewrite-materialized-views.html#GUID-4A5FD50D-E2AB-4176-BD1B-418E7B2491BB">About EXPLAIN_REWRITE Output</a>"</span> for more information.
                           </p>
                           <p>The following is an example where you can see a more detailed explanation of why some materialized views were not considered and, eventually, the materialized view <code class="codeph">sales_mv</code> was chosen as the best one.
                           </p><pre class="oac_no_warn" dir="ltr">DECLARE
  qrytext VARCHAR2(500)  :='SELECT cust_first_name, cust_last_name,
 SUM(amount_sold) AS dollar_sales FROM sales s, customers c WHERE s.cust_id=
 c.cust_id GROUP BY cust_first_name, cust_last_name';
    idno    VARCHAR2(30) :='ID1';
BEGIN
  DBMS_MVIEW.EXPLAIN_REWRITE(qrytext, '', idno);
END;
/
SELECT message FROM rewrite_table ORDER BY sequence;

</pre><pre class="oac_no_warn" dir="ltr">SQL&gt; MESSAGE                                      
--------------------------------------------------------------------------------
QSM-01082: Joining materialized view, CAL_MONTH_SALES_MV, with table, SALES, not possible
QSM-01022: a more optimal materialized view than PRODUCT_SALES_MV was used to rewrite
QSM-01022: a more optimal materialized view than FWEEK_PSCAT_SALES_MV was used to rewrite
QSM-01033: query rewritten with materialized view, SALES_MV</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="DWHSG8564"></a><a id="DWHSG8563"></a><div class="props_rev_3"><a id="GUID-F936CEE1-3568-4487-842A-015AFE940F87" name="GUID-F936CEE1-3568-4487-842A-015AFE940F87"></a><h5 id="DWHSG-GUID-F936CEE1-3568-4487-842A-015AFE940F87" class="sect5"><span class="enumeration_section">12.8.2.3 </span>Using a Varray to View EXPLAIN_REWRITE Output
                     </h5>
                     <div>
                        <div class="section">
                           <p>You can save the output of <code class="codeph">EXPLAIN_REWRITE</code> in a PL/SQL <code class="codeph">VARRAY</code>. The elements of this array are of the type <code class="codeph">RewriteMessage</code>, which is predefined in the <code class="codeph">SYS</code> schema as shown in the following:
                           </p><pre class="oac_no_warn" dir="ltr">TYPE RewriteMessage IS OBJECT(
  mv_owner        VARCHAR2(30),   -- MV's schema
  mv_name         VARCHAR2(30),   -- Name of the MV
  sequence        NUMBER(3),      -- sequence no of the msg 
  query_text      VARCHAR2(2000), -- User query
  query_block_no  NUMBER(3),      -- block no of the current subquery
  rewritten_text  VARCHAR2(2000), -- rewritten query text 
  message         VARCHAR2(512),  -- EXPLAIN_REWRITE error msg
  pass            VARCHAR2(3),    -- Query rewrite pass no 
  mv_in_msg       VARCHAR2(30),   -- MV in current message 
  measure_in_msg  VARCHAR2(30),   -- Measure in current message 
  join_back_tbl   VARCHAR2(30),   -- Join back table in current msg 
  join_back_col   VARCHAR2(30),   -- Join back column in current msg 
  original_cost   NUMBER(10),     -- Cost of original query 
  rewritten_cost  NUMBER(10),     -- Cost rewritten query 
  flags           NUMBER,         -- Associated flags
  reserved1       NUMBER,         -- For future use
  reserved2       VARCHAR2(10)    -- For future use
);
</pre><p>The array type, <code class="codeph">RewriteArrayType</code>, which is a varray of <code class="codeph">RewriteMessage</code> objects, is predefined in the <code class="codeph">SYS</code> schema as follows:
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><code class="codeph">TYPE RewriteArrayType AS VARRAY(256) OF RewriteMessage;</code></p>
                              </li>
                              <li>
                                 <p>Using this array type, now you can declare an array variable and specify it in the <code class="codeph">EXPLAIN_REWRITE</code> statement.
                                 </p>
                              </li>
                              <li>
                                 <p>Each <code class="codeph">RewriteMessage</code> record provides a message concerning rewrite processing.
                                 </p>
                              </li>
                              <li>
                                 <p>The parameters are the same as for <code class="codeph">REWRITE_TABLE</code>, except for <code class="codeph">statement_id</code>, which is not used when using a varray as output.
                                 </p>
                              </li>
                              <li>
                                 <p>The <code class="codeph">mv_owner</code> field defines the owner of materialized view that is relevant to the message.
                                 </p>
                              </li>
                              <li>
                                 <p>The <code class="codeph">mv_name</code> field defines the name of a materialized view that is relevant to the message.
                                 </p>
                              </li>
                              <li>
                                 <p>The <code class="codeph">sequence</code> field defines the sequence in which messages should be ordered.
                                 </p>
                              </li>
                              <li>
                                 <p>The <code class="codeph">query_text</code> field contains the first 2000 characters of the query text under analysis.
                                 </p>
                              </li>
                              <li>
                                 <p>The <code class="codeph">message</code> field contains the text of message relevant to rewrite processing of <code class="codeph">query</code>.
                                 </p>
                              </li>
                              <li>
                                 <p>The <code class="codeph">flags</code>, <code class="codeph">reserved1</code>, and <code class="codeph">reserved2</code> fields are reserved for future use.
                                 </p>
                              </li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-F936CEE1-3568-4487-842A-015AFE940F87__GUID-B0470E88-BB63-4361-8FB4-419CC9826993">
                           <p class="titleinexample">Example 12-19 EXPLAIN_REWRITE Using a VARRAY</p>
                           <p>Consider the following materialized view:</p><pre class="oac_no_warn" dir="ltr">CREATE MATERIALIZED VIEW avg_sales_city_state_mv
ENABLE QUERY REWRITE AS
SELECT c.cust_city, c.cust_state_province, AVG(s.amount_sold)
FROM sales s, customers c WHERE s.cust_id = c.cust_id
GROUP BY c.cust_city, c.cust_state_province;
</pre><p>You might try to use this materialized view with the following query:</p><pre class="oac_no_warn" dir="ltr">SELECT c.cust_state_province, AVG(s.amount_sold)
FROM sales s, customers c WHERE s.cust_id = c.cust_id
GROUP BY c.cust_state_province;
</pre><p>However, the query does not rewrite with this materialized view. This can be quite confusing to a novice user as it seems like all information required for rewrite is present in the materialized view. You can find out from <code class="codeph">DBMS_MVIEW.EXPLAIN_REWRITE</code> that <code class="codeph">AVG</code> cannot be computed from the given materialized view. The problem is that a <code class="codeph">ROLLUP</code> is required here and <code class="codeph">AVG</code> requires a <code class="codeph">COUNT</code> or a <code class="codeph">SUM</code> to do <code class="codeph">ROLLUP</code>.
                           </p>
                           <p>An example PL/SQL block for the previous query, using a <code class="codeph">VARRAY</code> as its output, is as follows:
                           </p><pre class="oac_no_warn" dir="ltr">SET SERVEROUTPUT ON
DECLARE
  Rewrite_Array SYS.RewriteArrayType := SYS.RewriteArrayType();
  querytxt VARCHAR2(1500) := 'SELECT c.cust_state_province,
  AVG(s.amount_sold)
   FROM sales s, customers c WHERE s.cust_id = c.cust_id
   GROUP BY c.cust_state_province';
  i NUMBER;
BEGIN
  DBMS_MVIEW.EXPLAIN_REWRITE(querytxt, 'AVG_SALES_CITY_STATE_MV',
  Rewrite_Array);
  FOR i IN 1..Rewrite_Array.count
  LOOP
    DBMS_OUTPUT.PUT_LINE(Rewrite_Array(i).message);
  END LOOP;
END;
/
</pre><p>The following is the output of this <code class="codeph">EXPLAIN_REWRITE</code> statement:
                           </p><pre class="oac_no_warn" dir="ltr">QSM-01065: materialized view, AVG_SALES_CITY_STATE_MV, cannot compute
  measure, AVG, in the query
QSM-01101: rollup(s) took place on mv, AVG_SALES_CITY_STATE_MV
QSM-01053: NORELY referential integrity constraint on table, CUSTOMERS,
  in TRUSTED/STALE TOLERATED integrity mode
PL/SQL procedure successfully completed.</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="DWHSG8565"></a><div class="props_rev_3"><a id="GUID-EB88C4EC-D843-4AB5-934D-063894CE51D5" name="GUID-EB88C4EC-D843-4AB5-934D-063894CE51D5"></a><h5 id="DWHSG-GUID-EB88C4EC-D843-4AB5-934D-063894CE51D5" class="sect5"><span class="enumeration_section">12.8.2.4 </span>EXPLAIN_REWRITE Benefit Statistics
                     </h5>
                     <div>
                        <p>The output of <code class="codeph">EXPLAIN_REWRITE</code> contains two columns, <code class="codeph">original_cost</code> and <code class="codeph">rewritten_cost</code>, that can help you estimate query cost. <code class="codeph">original_cost</code> gives the optimizer's estimation for the query cost when query rewrite was disabled. <code class="codeph">rewritten_cost</code> gives the optimizer's estimation for the query cost when query was rewritten using a materialized view. These cost values can be used to find out what benefit a particular query receives from rewrite.
                        </p>
                     </div>
                  </div><a id="DWHSG8566"></a><div class="props_rev_3"><a id="GUID-80AAF9D9-DA04-4804-931D-432CF883CE54" name="GUID-80AAF9D9-DA04-4804-931D-432CF883CE54"></a><h5 id="DWHSG-GUID-80AAF9D9-DA04-4804-931D-432CF883CE54" class="sect5"><span class="enumeration_section">12.8.2.5 </span>Support for Query Text Larger than 32KB in EXPLAIN_REWRITE
                     </h5>
                     <div>
                        <p>In this release, the <code class="codeph">EXPLAIN_REWRITE</code> procedure has been enhanced to support large queries. The input query text can now be defined using a <code class="codeph">CLOB</code> data type instead of a <code class="codeph">VARCHAR</code> data type. This allows <code class="codeph">EXPLAIN_REWRITE</code> to accept queries up to 4 GB.
                        </p>
                        <p>The syntax for using <code class="codeph">EXPLAIN_REWRITE</code> using <code class="codeph">CLOB</code> to obtain the output into a table is shown as follows:
                        </p><pre class="oac_no_warn" dir="ltr">DBMS_MVIEW.EXPLAIN_REWRITE(
   query          IN CLOB,
   mv             IN VARCHAR2,
   statement_id   IN VARCHAR2);
</pre><p>The second argument, <code class="codeph">mv</code>, and the third argument, <code class="codeph">statement_id</code>, can be <code class="codeph">NULL</code>. Similarly, the syntax for using <code class="codeph">EXPLAIN_REWRITE</code> using <code class="codeph">CLOB</code> to obtain the output into a varray is shown as follows:
                        </p><pre class="oac_no_warn" dir="ltr">DBMS_MVIEW.EXPLAIN_REWRITE(
   query           IN CLOB,
   mv              IN VARCHAR2,
   msg_array       IN OUT SYS.RewriteArrayType);
 </pre><p>As before, the second argument, <code class="codeph">mv</code>, can be <code class="codeph">NULL</code>. Note that long query texts in <code class="codeph">CLOB</code> can be generated using the procedures provided in the <code class="codeph">DBMS_LOB</code> package.
                        </p>
                     </div>
                  </div><a id="DWHSG8567"></a><div class="props_rev_3"><a id="GUID-C6BFEB7A-B1E3-4E08-B38D-87FA3D6B1BBC" name="GUID-C6BFEB7A-B1E3-4E08-B38D-87FA3D6B1BBC"></a><h5 id="DWHSG-GUID-C6BFEB7A-B1E3-4E08-B38D-87FA3D6B1BBC" class="sect5"><span class="enumeration_section">12.8.2.6 </span>About EXPLAIN_REWRITE and Multiple Materialized Views
                     </h5>
                     <div>
                        <p>The syntax for using <code class="codeph">EXPLAIN_REWRITE</code> with multiple materialized views is the same as using it with a single materialized view, except that the materialized views are specified by a comma-delimited string. For example, to find out whether a given set of materialized views <code class="codeph">mv1</code>, <code class="codeph">mv2</code>, and <code class="codeph">mv3</code> could be used to rewrite the query, <code class="codeph">query_txt</code>, and, if not, why not, use <code class="codeph">EXPLAIN_REWRITE</code> as follows:
                        </p><pre class="oac_no_warn" dir="ltr">DBMS_MVIEW.EXPLAIN_REWRITE(query_txt, 'mv1, mv2, mv3')
</pre><p>If the query, <code class="codeph">query_txt</code>, rewrote with the given set of materialized views, then the following message appears:
                        </p><pre class="oac_no_warn" dir="ltr">QSM-01127: query rewritten with materialized view(s), mv1, mv2, and mv3.
</pre><p>If the query fails to rewrite with one or more of the given set of materialized views, then the reason for the failure will be output by <code class="codeph">EXPLAIN_REWRITE</code> for each of the materialized views that did not participate in the rewrite.
                        </p>
                     </div>
                  </div><a id="DWHSG8568"></a><div class="props_rev_3"><a id="GUID-4A5FD50D-E2AB-4176-BD1B-418E7B2491BB" name="GUID-4A5FD50D-E2AB-4176-BD1B-418E7B2491BB"></a><h5 id="DWHSG-GUID-4A5FD50D-E2AB-4176-BD1B-418E7B2491BB" class="sect5"><span class="enumeration_section">12.8.2.7 </span>About EXPLAIN_REWRITE Output
                     </h5>
                     <div>
                        <p>Some examples showing how to use <code class="codeph">EXPLAIN_REWRITE</code> are included in <code class="codeph">/rdbms/demo/smxrw.sql</code>. There is also a utility called <code class="codeph">SYS.XRW</code> included in the demo <code class="codeph">xrw</code> area to help you select the output from the <code class="codeph">EXPLAIN_REWRITE</code> procedure. When <code class="codeph">EXPLAIN_REWRITE</code> evaluates a query, its output includes information such as the rewritten query text, query block number, and the cost of the rewritten query. The utility <code class="codeph">SYS.XRW</code> outputs the user specified fields in a neatly formatted way, so that the output can be easily understood. The syntax is as follows:
                        </p><pre class="oac_no_warn" dir="ltr">SYS.XRW(list_of_mvs, list_of_commands, query_text),
</pre><p>where <code class="codeph">list_of_mvs</code> are the materialized views the user would expect the query rewrite to use. If there is more than one materialized view, they must be separated by commas, and <code class="codeph">list_of_commands</code> is one of the following fields:
                        </p><pre class="oac_no_warn" dir="ltr">QUERY_TXT:      User query text
REWRITTEN_TXT:  Rewritten query text
QUERY_BLOCK_NO: Query block number to identify each query blocks in
                case the query has subqueries or inline views
PASS:           Pass indicates whether a given message was generated
                before or after the view merging process of query rewrite.
COSTS:          Costs indicates the estimated execution cost of the
                original query and the rewritten query
</pre><p>The following example illustrates the use of this utility:</p><pre class="oac_no_warn" dir="ltr">DROP MATERIALIZED VIEW month_sales_mv;
 
CREATE MATERIALIZED VIEW month_sales_mv
  ENABLE QUERY REWRITE
  AS
  SELECT t.calendar_month_number, SUM(s.amount_sold) AS sum_dollars
  FROM sales s, times t
  WHERE s.time_id = t.time_id
GROUP BY t.calendar_month_number;
 
SET SERVEROUTPUT ON
DECLARE
  querytxt VARCHAR2(1500) := 'SELECT t.calendar_month_number,
         SUM(s.amount_sold) AS sum_dollars FROM sales s, times t
  WHERE s.time_id = t.time_id GROUP BY t.calendar_month_number';
BEGIN
  SYS.XRW('MONTH_SALES_MV', 'COSTS, PASS, REWRITTEN_TXT, QUERY_BLOCK_NO', querytxt);
END;
/
</pre><p>Following is the output from <code class="codeph">SYS.XRW</code>. As can be seen from the output, <code class="codeph">SYS.XRW</code> outputs both the original query cost, rewritten costs, rewritten query text, query block number and whether the message was generated before or after the view merging process.
                        </p><pre class="oac_no_warn" dir="ltr">============================================================================
&gt;&gt; MESSAGE  : QSM-01151: query was rewritten
&gt;&gt; RW QUERY : SELECT MONTH_SALES_MV.CALENDAR_MONTH_NUMBER CALENDAR_MONTH_NUMBER,
MONTH_SALES_MV.SUM_DOLLARS SUM_DOLLARS FROM SH.MONTH_SALES_MV MONTH_SALES_MV
&gt;&gt; ORIG COST: 19.952763130792                  RW COST: 1.80687108
============================================================================
&gt;&gt;
------------------------- ANALYSIS OF QUERY REWRITE -------------------------
&gt;&gt;
&gt;&gt; QRY BLK #: 0
&gt;&gt; MESSAGE  : QSM-01209: query rewritten with materialized view, 
   MONTH_SALES_MV, using text match algorithm
&gt;&gt; RW QUERY : SELECT MONTH_SALES_MV.CALENDAR_MONTH_NUMBER CALENDAR_MONTH_NUMBER,
   MONTH_SALES_MV.SUM_DOLLARS SUM_DOLLARS FROM SH.MONTH_SALES_MV MONTH_SALES_MV
&gt;&gt; ORIG COST: 19.952763130792                  RW COST: 1.80687108
&gt;&gt; MESSAGE OUTPUT BEFORE VIEW MERGING...
============================ END OF MESSAGES ===============================
PL/SQL procedure successfully completed.</pre></div>
                  </div>
               </div>
            </div><a id="DWHSG0806"></a><div class="props_rev_3"><a id="GUID-098C13EA-774C-49D9-8199-A8092BA7D437" name="GUID-098C13EA-774C-49D9-8199-A8092BA7D437"></a><h3 id="DWHSG-GUID-098C13EA-774C-49D9-8199-A8092BA7D437" class="sect3"><span class="enumeration_section">12.9 </span>Design Considerations for Improving Query Rewrite Capabilities
               </h3>
               <div>
                  <p>This section discusses design considerations that will help in obtaining the maximum benefit from query rewrite. They are not mandatory for using query rewrite and rewrite is not guaranteed if you follow them. They are general rules to consider, and are the following:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="advanced-query-rewrite-materialized-views.html#GUID-63E9C200-ECCD-4498-8EEE-F744AA0F1249">Query Rewrite Considerations: Constraints</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-query-rewrite-materialized-views.html#GUID-80545DAD-1A1C-44B3-9D81-D1CEC7C397EA">Query Rewrite Considerations: Dimensions</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-query-rewrite-materialized-views.html#GUID-7C1DD903-100F-4E7B-8333-DA9CEF5BA2FE">Query Rewrite Considerations: Outer Joins</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-query-rewrite-materialized-views.html#GUID-62FBB3B4-D352-4A0E-AEF7-450421F8E2C1">Query Rewrite Considerations: Text Match</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-query-rewrite-materialized-views.html#GUID-FD786B39-80E0-4725-A974-8B18D3568919">Query Rewrite Considerations: Aggregates</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-query-rewrite-materialized-views.html#GUID-B3149060-5313-450B-84CA-0199B62D2F13">Query Rewrite Considerations: Grouping Conditions</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-query-rewrite-materialized-views.html#GUID-402A542B-BB8D-4113-A2CB-C1DAB9D3EDF6">Query Rewrite Considerations: Expression Matching</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-query-rewrite-materialized-views.html#GUID-65FD33D7-DEBD-4164-B49F-514B5419480C">Query Rewrite Considerations: Date Folding</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-query-rewrite-materialized-views.html#GUID-C576AD61-4EEA-4F52-9E2E-8A2185D898FA">Query Rewrite Considerations: Statistics</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-query-rewrite-materialized-views.html#GUID-30951956-2D59-4543-B421-7FA078315C9F">Query Rewrite Considerations: Hints</a></p>
                     </li>
                  </ul>
               </div><a id="DWHSG8569"></a><div class="props_rev_3"><a id="GUID-63E9C200-ECCD-4498-8EEE-F744AA0F1249" name="GUID-63E9C200-ECCD-4498-8EEE-F744AA0F1249"></a><h4 id="DWHSG-GUID-63E9C200-ECCD-4498-8EEE-F744AA0F1249" class="sect4"><span class="enumeration_section">12.9.1 </span>Query Rewrite Considerations: Constraints
                  </h4>
                  <div>
                     <p><a id="d44607e6899" class="indexterm-anchor"></a>Make sure all inner joins referred to in a materialized view have referential integrity (foreign key/primary key constraints) with additional <code class="codeph">NOT</code> <code class="codeph">NULL</code> constraints on the foreign key columns. Because constraints tend to impose a large overhead, you could make them <code class="codeph">NO</code> <code class="codeph">VALIDATE</code> and <code class="codeph">RELY</code> and set the parameter <code class="codeph">QUERY_REWRITE_INTEGRITY</code> to <code class="codeph">STALE_TOLERATED</code> or <code class="codeph">TRUSTED</code>. However, if you set <code class="codeph">QUERY_REWRITE_INTEGRITY</code> to <code class="codeph">ENFORCED</code>, all constraints must be enabled, enforced, and validated to get maximum rewritability.
                     </p>
                     <p>You should avoid using the <code class="codeph">ON</code> <code class="codeph">DELETE</code> clause as it can lead to unexpected results.
                     </p>
                  </div>
               </div><a id="DWHSG8570"></a><div class="props_rev_3"><a id="GUID-80545DAD-1A1C-44B3-9D81-D1CEC7C397EA" name="GUID-80545DAD-1A1C-44B3-9D81-D1CEC7C397EA"></a><h4 id="DWHSG-GUID-80545DAD-1A1C-44B3-9D81-D1CEC7C397EA" class="sect4"><span class="enumeration_section">12.9.2 </span>Query Rewrite Considerations: Dimensions
                  </h4>
                  <div>
                     <p><a id="d44607e6964" class="indexterm-anchor"></a>You can express the hierarchical relationships and functional dependencies in normalized or denormalized dimension tables using the <code class="codeph">HIERARCHY</code> and <code class="codeph">DETERMINES</code> clauses of a dimension. Dimensions can express intra-table relationships which cannot be expressed by constraints. Set the parameter <code class="codeph">QUERY_REWRITE_INTEGRITY</code> to <code class="codeph">TRUSTED</code> or <code class="codeph">STALE_TOLERATED</code> for query rewrite to take advantage of the relationships declared in dimensions.
                     </p>
                  </div>
               </div><a id="DWHSG8571"></a><div class="props_rev_3"><a id="GUID-7C1DD903-100F-4E7B-8333-DA9CEF5BA2FE" name="GUID-7C1DD903-100F-4E7B-8333-DA9CEF5BA2FE"></a><h4 id="DWHSG-GUID-7C1DD903-100F-4E7B-8333-DA9CEF5BA2FE" class="sect4"><span class="enumeration_section">12.9.3 </span>Query Rewrite Considerations: Outer Joins
                  </h4>
                  <div>
                     <p><a id="d44607e7006" class="indexterm-anchor"></a>Another way of avoiding constraints is to use outer joins in the materialized view. Query rewrite will be able to derive an inner join in the query, such as <code class="codeph">(A.a=B.b)</code>, from an outer join in the materialized view <code class="codeph">(A.a = B.b(+))</code>, as long as the rowid of <code class="codeph">B</code> or column <code class="codeph">B.b</code> is available in the materialized view. Most of the support for rewrites with outer joins is provided for materialized views with joins only. To exploit it, a materialized view with outer joins should store the rowid or primary key of the inner table of an outer join. For example, the materialized view <code class="codeph">join_sales_time_product_mv_oj</code> stores the primary keys <code class="codeph">prod_id</code> and <code class="codeph">time_id</code> of the inner tables of outer joins.
                     </p>
                  </div>
               </div><a id="DWHSG8572"></a><div class="props_rev_3"><a id="GUID-62FBB3B4-D352-4A0E-AEF7-450421F8E2C1" name="GUID-62FBB3B4-D352-4A0E-AEF7-450421F8E2C1"></a><h4 id="DWHSG-GUID-62FBB3B4-D352-4A0E-AEF7-450421F8E2C1" class="sect4"><span class="enumeration_section">12.9.4 </span>Query Rewrite Considerations: Text Match
                  </h4>
                  <div>
                     <p><a id="d44607e7054" class="indexterm-anchor"></a>If you need to speed up an extremely complex, long-running query, you could create a materialized view with the exact text of the query. Then the materialized view would contain the query results, thus eliminating the time required to perform any complex joins and search through all the data for that which is required.
                     </p>
                  </div>
               </div><a id="DWHSG8573"></a><div class="props_rev_3"><a id="GUID-FD786B39-80E0-4725-A974-8B18D3568919" name="GUID-FD786B39-80E0-4725-A974-8B18D3568919"></a><h4 id="DWHSG-GUID-FD786B39-80E0-4725-A974-8B18D3568919" class="sect4"><span class="enumeration_section">12.9.5 </span>Query Rewrite Considerations: Aggregates
                  </h4>
                  <div>
                     <p><a id="d44607e7080" class="indexterm-anchor"></a>To get the maximum benefit from query rewrite, make sure that all aggregates which are needed to compute ones in the targeted set of queries are present in the materialized view. The conditions on aggregates are quite similar to those for incremental refresh. For instance, if <code class="codeph">AVG(x)</code> is in the query, then you should store <code class="codeph">COUNT(x)</code> and <code class="codeph">AVG(x)</code> or store <code class="codeph">SUM(x)</code> and <code class="codeph">COUNT(x)</code> in the materialized view. See <span class="q">"<a href="basic-materialized-views.html#GUID-505C24CF-5D56-4820-88AA-2221410950E7">General Restrictions on Fast Refresh</a>"</span> for fast refresh requirements.
                     </p>
                  </div>
               </div><a id="DWHSG8574"></a><div class="props_rev_3"><a id="GUID-B3149060-5313-450B-84CA-0199B62D2F13" name="GUID-B3149060-5313-450B-84CA-0199B62D2F13"></a><h4 id="DWHSG-GUID-B3149060-5313-450B-84CA-0199B62D2F13" class="sect4"><span class="enumeration_section">12.9.6 </span>Query Rewrite Considerations: Grouping Conditions
                  </h4>
                  <div>
                     <p><a id="d44607e7126" class="indexterm-anchor"></a>Aggregating data at lower levels in the hierarchy is better than aggregating at higher levels because lower levels can be used to rewrite more queries. Note, however, that doing so will also take up more space. For example, instead of grouping on state, group on city (unless space constraints prohibit it).
                     </p>
                     <p>Instead of creating multiple materialized views with overlapping or hierarchically related <code class="codeph">GROUP</code> <code class="codeph">BY</code> columns, create a single materialized view with all those <code class="codeph">GROUP</code> <code class="codeph">BY</code> columns. For example, instead of using a materialized view that groups by city and another materialized view that groups by month, use a single materialized view that groups by city and month.
                     </p>
                     <p>Use <code class="codeph">GROUP</code> <code class="codeph">BY</code> on columns that correspond to levels in a dimension but not on columns that are functionally dependent, because query rewrite will be able to use the functional dependencies automatically based on the <code class="codeph">DETERMINES</code> clause in a dimension. For example, instead of grouping on <code class="codeph">prod_name</code>, group on <code class="codeph">prod_id</code> (as long as there is a dimension which indicates that the attribute <code class="codeph">prod_id</code> determines <code class="codeph">prod_name</code>, you will enable the rewrite of a query involving <code class="codeph">prod_name</code>).
                     </p>
                  </div>
               </div><a id="DWHSG8575"></a><div class="props_rev_3"><a id="GUID-402A542B-BB8D-4113-A2CB-C1DAB9D3EDF6" name="GUID-402A542B-BB8D-4113-A2CB-C1DAB9D3EDF6"></a><h4 id="DWHSG-GUID-402A542B-BB8D-4113-A2CB-C1DAB9D3EDF6" class="sect4"><span class="enumeration_section">12.9.7 </span>Query Rewrite Considerations: Expression Matching
                  </h4>
                  <div>
                     <p>If several queries share the same common subselect, it is advantageous to create a materialized view with the common subselect as one of its <code class="codeph">SELECT</code> columns. This way, the performance benefit due to precomputation of the common subselect can be obtained across several queries.
                     </p>
                  </div>
               </div><a id="DWHSG8576"></a><div class="props_rev_3"><a id="GUID-65FD33D7-DEBD-4164-B49F-514B5419480C" name="GUID-65FD33D7-DEBD-4164-B49F-514B5419480C"></a><h4 id="DWHSG-GUID-65FD33D7-DEBD-4164-B49F-514B5419480C" class="sect4"><span class="enumeration_section">12.9.8 </span>Query Rewrite Considerations: Date Folding
                  </h4>
                  <div>
                     <p>When creating a materialized view that aggregates data by folded date granules such as months or quarters or years, always use the year component as the prefix but not as the suffix. For example, <code class="codeph">TO_CHAR</code>(<code class="codeph">date_col</code>, <code class="codeph">'yyyy-q'</code>) folds the date into quarters, which collate in year order, whereas <code class="codeph">TO_CHAR</code>(<code class="codeph">date_col, 'q-yyyy'</code>) folds the date into quarters, which collate in quarter order. The former preserves the ordering while the latter does not. For this reason, any materialized view created without a year prefix will not be eligible for date folding rewrite.
                     </p>
                  </div>
               </div><a id="DWHSG8577"></a><div class="props_rev_3"><a id="GUID-C576AD61-4EEA-4F52-9E2E-8A2185D898FA" name="GUID-C576AD61-4EEA-4F52-9E2E-8A2185D898FA"></a><h4 id="DWHSG-GUID-C576AD61-4EEA-4F52-9E2E-8A2185D898FA" class="sect4"><span class="enumeration_section">12.9.9 </span>Query Rewrite Considerations: Statistics
                  </h4>
                  <div>
                     <p><a id="d44607e7256" class="indexterm-anchor"></a>Optimization with materialized views is based on cost and the optimizer needs statistics of both the materialized view and the tables in the query to make a cost-based choice. Materialized views should thus have statistics collected using the <code class="codeph">DBMS_STATS</code> package.
                     </p>
                  </div>
               </div><a id="DWHSG8578"></a><div class="props_rev_3"><a id="GUID-30951956-2D59-4543-B421-7FA078315C9F" name="GUID-30951956-2D59-4543-B421-7FA078315C9F"></a><h4 id="DWHSG-GUID-30951956-2D59-4543-B421-7FA078315C9F" class="sect4"><span class="enumeration_section">12.9.10 </span>Query Rewrite Considerations: Hints
                  </h4>
                  <div>
                     <p>This section discusses the following considerations:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="advanced-query-rewrite-materialized-views.html#GUID-AB5DA1BA-C714-420F-B329-370D1E68EB82">Query Rewrite: REWRITE and NOREWRITE Hints</a></p>
                        </li>
                        <li>
                           <p><a href="advanced-query-rewrite-materialized-views.html#GUID-C535DD88-E429-47CE-8F9D-040ADA30261C">Query Rewrite: REWRITE_OR_ERROR Hint</a></p>
                        </li>
                        <li>
                           <p><a href="advanced-query-rewrite-materialized-views.html#GUID-BB34C03E-88FB-408A-8486-A8F2C9670C08">Query Rewrite: Multiple Materialized View Rewrite Hints</a></p>
                        </li>
                        <li>
                           <p><a href="advanced-query-rewrite-materialized-views.html#GUID-DF01D4B0-1E95-400B-9815-63725519E5F0">Query Rewrite: EXPAND_GSET_TO_UNION Hint</a></p>
                        </li>
                     </ul>
                  </div><a id="DWHSG8579"></a><div class="props_rev_3"><a id="GUID-AB5DA1BA-C714-420F-B329-370D1E68EB82" name="GUID-AB5DA1BA-C714-420F-B329-370D1E68EB82"></a><h5 id="DWHSG-GUID-AB5DA1BA-C714-420F-B329-370D1E68EB82" class="sect5"><span class="enumeration_section">12.9.10.1 </span>Query Rewrite: REWRITE and NOREWRITE Hints
                     </h5>
                     <div>
                        <p><a id="d44607e7326" class="indexterm-anchor"></a>You can include hints in the <code class="codeph">SELECT</code> blocks of your SQL statements to control whether query rewrite occurs. Using the<a id="d44607e7334" class="indexterm-anchor"></a><a id="d44607e7338" class="indexterm-anchor"></a><a id="d44607e7340" class="indexterm-anchor"></a><a id="d44607e7342" class="indexterm-anchor"></a><a id="d44607e7346" class="indexterm-anchor"></a><a id="d44607e7352" class="indexterm-anchor"></a><a id="d44607e7358" class="indexterm-anchor"></a><a id="d44607e7365" class="indexterm-anchor"></a> <code class="codeph">NOREWRITE</code> hint in a query prevents the optimizer from rewriting it.
                        </p>
                        <p>The <code class="codeph">REWRITE</code> hint <a id="d44607e7378" class="indexterm-anchor"></a><a id="d44607e7380" class="indexterm-anchor"></a>with no argument in a query forces the optimizer to use a materialized view (if any) to rewrite it regardless of the cost. If you use the <code class="codeph">REWRITE(mv1,mv2,...)</code> hint with arguments, this forces rewrite to select the most suitable materialized view from the list of names specified.
                        </p>
                        <p>To prevent a rewrite, you can use the following statement:</p><pre class="oac_no_warn" dir="ltr">SELECT /*+ NOREWRITE */ p.prod_subcategory, SUM(s.amount_sold)
FROM   sales s, products p WHERE  s.prod_id = p.prod_id
GROUP BY p.prod_subcategory;
</pre><p>To force a rewrite using <code class="codeph">sum_sales_pscat_week_mv</code> (if such a rewrite is possible), use the following statement:
                        </p><pre class="oac_no_warn" dir="ltr">SELECT /*+ REWRITE (sum_sales_pscat_week_mv) */ 
       p.prod_subcategory,  SUM(s.amount_sold)
FROM   sales s, products p WHERE  s.prod_id=p.prod_id
GROUP BY p.prod_subcategory;
</pre><p>Note that the scope of a rewrite hint is a query block. If a SQL statement consists of several query blocks (<code class="codeph">SELECT</code> clauses), you must specify a rewrite hint on each query block to control the rewrite for the entire statement.
                        </p>
                     </div>
                  </div><a id="DWHSG8580"></a><div class="props_rev_3"><a id="GUID-C535DD88-E429-47CE-8F9D-040ADA30261C" name="GUID-C535DD88-E429-47CE-8F9D-040ADA30261C"></a><h5 id="DWHSG-GUID-C535DD88-E429-47CE-8F9D-040ADA30261C" class="sect5"><span class="enumeration_section">12.9.10.2 </span>Query Rewrite: REWRITE_OR_ERROR Hint
                     </h5>
                     <div>
                        <p>Using<a id="d44607e7426" class="indexterm-anchor"></a><a id="d44607e7428" class="indexterm-anchor"></a> the <code class="codeph">REWRITE_OR_ERROR</code> hint in a query causes the following error if the query failed to rewrite:
                        </p><pre class="oac_no_warn" dir="ltr">ORA-30393: a query block in the statement did not rewrite
</pre><p>For example, the following query issues an ORA-30393 error when there are no suitable materialized views for query rewrite to use:</p><pre class="oac_no_warn" dir="ltr">SELECT /*+ REWRITE_OR_ERROR */ p.prod_subcategory, SUM(s.amount_sold)
FROM sales s, products p WHERE s.prod_id = p.prod_id
GROUP BY p.prod_subcategory;</pre></div>
                  </div><a id="DWHSG8581"></a><div class="props_rev_3"><a id="GUID-BB34C03E-88FB-408A-8486-A8F2C9670C08" name="GUID-BB34C03E-88FB-408A-8486-A8F2C9670C08"></a><h5 id="DWHSG-GUID-BB34C03E-88FB-408A-8486-A8F2C9670C08" class="sect5"><span class="enumeration_section">12.9.10.3 </span>Query Rewrite: Multiple Materialized View Rewrite Hints
                     </h5>
                     <div>
                        <p>There are two hints to control rewrites when using multiple materialized views. The <code class="codeph">NO_MULTIMV_REWRITE</code> hint prevents the query from being rewritten with more than one materialized view and the <code class="codeph">NO_BASETABLE_MULTIMV_REWRITE</code> hint prevents the query from being rewritten with a combination of materialized views and the base tables.
                        </p>
                     </div>
                  </div><a id="DWHSG8582"></a><div class="props_rev_3"><a id="GUID-DF01D4B0-1E95-400B-9815-63725519E5F0" name="GUID-DF01D4B0-1E95-400B-9815-63725519E5F0"></a><h5 id="DWHSG-GUID-DF01D4B0-1E95-400B-9815-63725519E5F0" class="sect5"><span class="enumeration_section">12.9.10.4 </span>Query Rewrite: EXPAND_GSET_TO_UNION Hint
                     </h5>
                     <div>
                        <p>You can use the<a id="d44607e7493" class="indexterm-anchor"></a><a id="d44607e7497" class="indexterm-anchor"></a> <code class="codeph">EXPAND_GSET_TO_UNION</code> hint to force expansion of the query with <code class="codeph">GROUP</code> <code class="codeph">BY</code> extensions into the equivalent <code class="codeph">UNION</code> <code class="codeph">ALL</code> query. See <span class="q">"<a href="advanced-query-rewrite-materialized-views.html#GUID-05CFC633-105D-45AB-97A0-805AEC29BFFF">Hint for Rewriting Queries with Extended GROUP BY</a>"</span> for further information.
                        </p>
                     </div>
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>