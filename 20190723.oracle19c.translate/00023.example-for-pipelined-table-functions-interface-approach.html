<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <title>流水线表功能：接口方法示例</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Data Cartridge Developer&#39;s Guide"></meta>
      <meta property="og:description" content=""></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Data Cartridge Developer&#39;s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="data-cartridge-developers-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-10T07:34:53-08:00"></meta>
      <meta name="dcterms.title" content="Data Cartridge Developer&#39;s Guide"></meta>
      <meta name="dcterms.dateCopyrighted" content="1996, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96431-01"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="example-for-PSBTREE-extensible-indexing.html" title="Previous" type="text/html"></link>
      <link rel="next" href="reference.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.isVersionOf" content="ADDCI"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="example-for-PSBTREE-extensible-indexing.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="reference.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">数据盒式开发人员指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="scenarios-and-examples.html" property="item" typeof="WebPage"><span property="name">场景和示例</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">流水线表功能：接口方法示例</li>
            </ol>
            <a id="GUID-B4BE4F35-B893-45D6-B8B4-235E23F80C6B" name="GUID-B4BE4F35-B893-45D6-B8B4-235E23F80C6B"></a><a id="ADDCI3170"></a>
            
            <h2 id="ADDCI-GUID-B4BE4F35-B893-45D6-B8B4-235E23F80C6B" class="sect2"><span class="enumeration_chapter">17</span>流水线表功能：接口方法示例</h2>
         </header>
         <div class="ind">
            <div>
               <p>描述了使用接口方法的<code class="codeph">StockPivot</code>流水线表函数的两个完整实现。一个实现在C中，另一个在Java中。
               </p>
               <p>函数<code class="codeph">StockPivot</code>将类型的行<code class="codeph">(Ticker, OpenPrice, ClosePrice)</code>转换为表格的两行<code class="codeph">(Ticker, PriceType, Price)</code> 。例如，从输入行<code class="codeph">("ORCL", 41, 42)</code> ，表函数返回两行<code class="codeph">("ORCL", "O", 41)</code>和<code class="codeph">("ORCL", "C", 42)</code> 。
               </p>
               <div class="infobox-tip" id="GUID-B4BE4F35-B893-45D6-B8B4-235E23F80C6B__GUID-7584B193-CAF9-42B7-9A2F-1AADEE1BE9FC">
                  <p class="notep1">小费：</p>
                  <p>考虑<a href="using-pipelined-and-parallel-table-functions.html#GUID-EFB94CFB-3E44-4236-B490-ADBB480C94D4">使用流水线和并行表</a>函数中描述的<a href="using-pipelined-and-parallel-table-functions.html#GUID-EFB94CFB-3E44-4236-B490-ADBB480C94D4">表函数</a> 。
                  </p>
               </div>
            </div><a id="ADDCI4924"></a><div class="props_rev_3"><a id="GUID-EA77162D-9087-49EC-908B-8BBE2D236614" name="GUID-EA77162D-9087-49EC-908B-8BBE2D236614"></a><h3 id="ADDCI-GUID-EA77162D-9087-49EC-908B-8BBE2D236614" class="sect3"><span class="enumeration_section">17.1</span>流水线表函数示例：C实现</h3>
               <div>
                  <p>在此示例中，实现类型的三个<code class="codeph">ODCITable</code>接口方法在C中实现为外部函数。这些方法必须首先在SQL中声明。</p>
               </div><a id="ADDCI4926"></a><a id="ADDCI4925"></a><div class="props_rev_3"><a id="GUID-B8EFE14B-EBAC-43B2-8507-EEFB7C1F90F1" name="GUID-B8EFE14B-EBAC-43B2-8507-EEFB7C1F90F1"></a><h4 id="ADDCI-GUID-B8EFE14B-EBAC-43B2-8507-EEFB7C1F90F1" class="sect4"><span class="enumeration_section">17.1.1</span>为C实现制作SQL声明</h4>
                  <div>
                     <div class="section">
                        <p><a href="example-for-pipelined-table-functions-interface-approach.html#GUID-B8EFE14B-EBAC-43B2-8507-EEFB7C1F90F1__CHDJJDFC">例17-1</a>显示了如何在C语言的<a href="example-for-pipelined-table-functions-interface-approach.html#GUID-18A4428B-127E-456A-AEF8-BF26E04DF0FB">Implementation ODCITable Methods中用</a> C语言<a href="example-for-pipelined-table-functions-interface-approach.html#GUID-18A4428B-127E-456A-AEF8-BF26E04DF0FB">实现</a>的方法的SQL声明。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-B8EFE14B-EBAC-43B2-8507-EEFB7C1F90F1__CHDJJDFC">
                        <p class="titleinexample">例17-1为在C中实现ODCITableXXX（）做出SQL声明</p><pre class="oac_no_warn" dir="ltr">- 创建输入库存表CREATE TABLE StockTable（ticker VARCHAR（4），openprice NUMBER，closeprice NUMBER）; - 为表函数的输出集合创建类型 - 和集合元素CREATE TYPE TickerType AS OBJECT（ticker VARCHAR2（4），PriceType VARCHAR2（1），price NUMBER）; / CREATE TYPE TickerTypeSet AS TABLE OF TickerType; /  - 创建外部库对象CREATE LIBRARY StockPivotLib IS'/home/bill/libstock.so'; /  - 创建实现类型CREATE TYPE StockPivotImpl AS OBJECT（键RAW（4），STATIC FUNCTION ODCITableStart（sctx OUT StockPivotImpl，cur SYS_REFCURSOR）RETURN PLS_INTEGER as LANGUAGE C LIBRARY StockPivotLib NAME“ODCITableStart”WITH CONTEXT PARAMETERS（context，sctx，sctx INDICATOR STRUCT，cur，RETURN INT），成员函数ODCITableFetch（自我IN OUT StockPivotImpl，nrows IN NUMBER，outSet OUT TickerTypeSet）RETURN PLS_INTEGER as LANGUAGE C LIBRARY StockPivotLib NAME“ODCITableFetch”WITH CONTEXT PARAMETERS（context，self，self INDICATOR STRUCT，nrows ，outSet，outSet INDICATOR，RETURN INT），成员函数ODCITableClose（self IN StockPivotImpl）RETURN PLS_INTEGER as LANGUAGE C LIBRARY StockPivotLib NAME“ODCITableClose”WITH CONTEXT PARAMETERS（context，self，self INDICATOR STRUCT，RETURN INT））; /  - 定义引用游标类型CREATE PACKAGE refcur_pkg IS TYPE refcur_t IS REF CURSOR RETURN StockTable％ROWTYPE; END refcur_pkg; /  - 创建表函数CREATE FUNCTION StockPivot（p refcur_pkg.refcur_t）RETURN TickerTypeSet PIPELINED使用StockPivotImpl; /</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="ADDCI4928"></a><a id="ADDCI4927"></a><div class="props_rev_3"><a id="GUID-18A4428B-127E-456A-AEF8-BF26E04DF0FB" name="GUID-18A4428B-127E-456A-AEF8-BF26E04DF0FB"></a><h4 id="ADDCI-GUID-18A4428B-127E-456A-AEF8-BF26E04DF0FB" class="sect4"><span class="enumeration_section">17.1.2</span> C中的实现ODCITable方法</h4>
                  <div>
                     <div class="section">
                        <p><a href="example-for-pipelined-table-functions-interface-approach.html#GUID-18A4428B-127E-456A-AEF8-BF26E04DF0FB__CHDCFBFC">例17-2</a>将三个<code class="codeph">ODCITable</code>方法实现为C中的外部函数。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-18A4428B-127E-456A-AEF8-BF26E04DF0FB__CHDCFBFC">
                        <p class="titleinexample">例17-2在C中实现ODCTableXXX（）方法</p><pre class="oac_no_warn" dir="ltr">#ifndef OCI_ORACLE #include &lt;oci.h&gt; #endif #ifndef ODCI_ORACLE #include &lt;odci.h&gt; #endif / * ------------------------ -------------------------------------------------- - 私人类型和常态--------------------------------------------- ------------------------------ * / / *保存用户存储的上下文的结构* / struct StoredCtx {OCIStmt * stmthp; }; typedef struct StoredCtx StoredCtx; / * OCI句柄* / struct Handles_t {OCIExtProcContext * extProcCtx; OCIEnv * envhp; OCISvcCtx * svchp; OCIError * errhp; OCISession * usrhp; }; typedef struct Handles_t Handles_t; / ********************** SQL类型C表示********************** / / *表函数的实现类型* / struct StockPivotImpl {OCIRaw * key; }; typedef struct StockPivotImpl StockPivotImpl; struct StockPivotImpl_ind {short _atomic;短键; }; typedef struct StockPivotImpl_ind StockPivotImpl_ind; / *表函数的输出集合元素类型* / struct TickerType {OCIString * ticker; OCIString * PriceType; OCINumber价格; }; typedef struct TickerType TickerType; struct TickerType_ind {short _atomic;短线;短价格类型;价格短; }; typedef struct TickerType_ind TickerType_ind; / *表函数的输出集合类型* / typedef OCITable TickerTypeSet; / * ------------------------------------------------ -------------------------- * / / *静态函数* / / * -------------- -------------------------------------------------- ---------- * / static int GetHandles（OCIExtProcContext * extProcCtx，Handles_t * handle）; static StoredCtx * GetStoredCtx（Handles_t * handle，StockPivotImpl * self，StockPivotImpl_ind * self_ind）; static int checkerr（Handles_t * handle，sword status）; / * ------------------------------------------------ -------------------------- * / / *函数定义* / / * -------------- -------------------------------------------------- ---------- * / / * ODCITableStart的调用* / int ODCITableStart（OCIExtProcContext * extProcCtx，StockPivotImpl * self，StockPivotImpl_ind * self_ind，OCIStmt ** cur）{Handles_t句柄; / * OCI hanldes * / StoredCtx * storedCtx; / *存储上下文指针* / ub4键; / *键检索存储的上下文* / / *获取OCI句柄* / if（GetHandles（extProcCtx，＆handles））返回ODCI_ERROR; / *分配内存以保存存储的上下文* / if（checkerr（＆handles，OCIMemoryAlloc（（dvoid *）handles.usrhp，handles.errhp，（dvoid **）＆storedCtx，OCI_DURATION_STATEMENT，（ub4）sizeof（StoredCtx），OCI_MEMORY_CLEARED） ））返回ODCI_ERROR; / *将输入引用光标存储在存储的上下文中* / storedCtx-&gt; stmthp = * cur; / *生成一个键* / if（checkerr（＆handles，OCIContextGenerateKey（（dvoid *）handles.usrhp，handles.errhp，＆key）））返回ODCI_ERROR; / *将键值与存储的上下文地址* / if相关联（checkerr（＆handles，OCIContextSetValue（（dvoid *）handles.usrhp，handles.errhp，OCI_DURATION_STATEMENT，（ub1 *）＆key，（ub1）sizeof（key），（ dvoid *）storedCtx）））返回ODCI_ERROR; / *将密钥存储在扫描上下文中* / if（checkerr（＆handles，OCIRawAssignBytes（handles.envhp，handles.errhp，（ub1 *）＆key，（ub4）sizeof（key），＆（self-&gt; key））） ）返回ODCI_ERROR; / *设置扫描上下文的指示符* / self_ind  - &gt; _ atomic = OCI_IND_NOTNULL; self_ind-&gt; key = OCI_IND_NOTNULL; * cur =（OCIStmt *）0;返回ODCI_SUCCESS; / ************************************************ *********************** // *标注ODCITableFetch * / int ODCITableFetch（OCIExtProcContext * extProcCtx，StockPivotImpl * self，StockPivotImpl_ind * self_ind，OCINumber * nrows， TickerTypeSet ** outSet，short * outSet_ind）{Handles_t handle; / * OCI hanldes * / StoredCtx * storedCtx; / *存储的上下文指针* / int nrowsval; / *要返回的行数* / / *获取OCI句柄* / if（GetHandles（extProcCtx，＆handles））返回ODCI_ERROR; / *获取存储的上下文* / storedCtx = GetStoredCtx（＆handles，self，self_ind）;如果（！storedCtx）返回ODCI_ERROR; / *得到nrows * / if的值（checkerr（＆handles，OCINumberToInt（handles.errhp，nrows，sizeof（nrowsval），OCI_NUMBER_SIGNED，（dvoid *）＆nrowsval）））返回ODCI_ERROR; / *一次最多返回10行* / if（nrowsval&gt; 10）nrowsval = 10; / *最初将输出设置为null * / * outSet_ind = OCI_IND_NULL; while（nrowsval&gt; 0）{TickerType elem; / *当前集合元素* / TickerType_ind elem_ind; / *当前元素指示符* / OCIDefine * defnp1 =（OCIDefine *）0; / * define handle * / OCIDefine * defnp2 =（OCIDefine *）0; / * define handle * / OCIDefine * defnp3 =（OCIDefine *）0; / *定义句柄* /剑状态; char ticker [5]; float openprice;浮动关闭; char PriceType [2]; / *为股票代码* / if定义获取缓冲区（checkerr（＆handles，OCIDefineByPos（storedCtx-&gt; stmthp，＆defnp1，handles.errhp，（ub4）1，（dvoid *）＆ticker，（sb4）sizeof（ticker），SQLT_STR ，（dvoid *）0，（ub2 *）0，（ub2 *）0，（ub4）OCI_DEFAULT）））返回ODCI_ERROR; / *为开盘价定义获取缓冲区* / if（checkerr（＆handles，OCIDefineByPos（storedCtx-&gt; stmthp，＆defnp2，handles.errhp，（ub4）2，（dvoid *）＆openprice，（sb4）sizeof（openprice），SQLT_FLT ，（dvoid *）0，（ub2 *）0，（ub2 *）0，（ub4）OCI_DEFAULT）））返回ODCI_ERROR; / *定义获取缓冲区以收盘价* / if（checkerr（＆handles，OCIDefineByPos（storedCtx-&gt; stmthp，＆defnp3，handles.errhp，（ub4）3，（dvoid *）＆closeprice，（sb4）sizeof（closeprice），SQLT_FLT ，（dvoid *）0，（ub2 *）0，（ub2 *）0，（ub4）OCI_DEFAULT）））返回ODCI_ERROR; / *从输入引用游标中获取一行* / status = OCIStmtFetch（storedCtx-&gt; stmthp，handles.errhp，（ub4）1，（ub4）OCI_FETCH_NEXT，（ub4）OCI_DEFAULT）; / *如果没有更多数据* / if（状态！= OCI_SUCCESS &amp;&amp;状态！= OCI_SUCCESS_WITH_INFO）休息; / *初始化元素指示符struct * / elem_ind._atomic = OCI_IND_NOTNULL; elem_ind.ticker = OCI_IND_NOTNULL; elem_ind。PriceType = OCI_IND_NOTNULL; elem_ind.price = OCI_IND_NOTNULL; / *指定股票代码名称* / elem.ticker = NULL; if（checkerr（＆handles，OCIStringAssignText（handles.envhp，handles.errhp，（text *）ticker，（ub2）strlen（ticker），＆elem.ticker）））返回ODCI_ERROR; / *指定价格类型* / elem。PriceType = NULL;的sprintf（PriceType， “O”）; if（checkerr（＆handles，OCIStringAssignText（handles.envhp，handles.errhp，（text *）PriceType，（ub2）strlen（PriceType），＆elem。PriceType）））返回ODCI_ERROR; / *分配价格* / if（checkerr（＆handles，OCINumberFromReal（handles.errhp，＆openprice，sizeof（openprice），＆elem.price）））返回ODCI_ERROR; / *将元素附加到输出集合* / if（checkerr（＆handles，OCICollAppend（handles.envhp，handles.errhp，＆elem，＆elem_ind，* outSet）））返回ODCI_ERROR; / *指定价格类型* / elem。PriceType = NULL;的sprintf（PriceType， “C”）; if（checkerr（＆handles，OCIStringAssignText（handles.envhp，handles.errhp，（text *）PriceType，（ub2）strlen（PriceType），＆elem。PriceType）））返回ODCI_ERROR; / *分配价格* / if（checkerr（＆handles，OCINumberFromReal（handles.errhp，＆closeprice，sizeof（closeprice），＆elem.price）））返回ODCI_ERROR; / *将行附加到输出集合* / if（checkerr（＆handles，OCICollAppend（handles.envhp，handles.errhp，＆elem，＆elem_ind，* outSet）））返回ODCI_ERROR; / * set collection indicator to not null * / * outSet_ind = OCI_IND_NOTNULL; nrowsval- = 2; }返回ODCI_SUCCESS; / ************************************************ *********************** // *标注ODCITableClose * / int ODCITableClose（OCIExtProcContext * extProcCtx，StockPivotImpl * self，StockPivotImpl_ind * self_ind）{Handles_t handle; / * OCI hanldes * / StoredCtx * storedCtx; / *存储上下文指针* / / *获取OCI句柄* / if（GetHandles（extProcCtx，＆handles））返回ODCI_ERROR; / *获取存储的上下文* / storedCtx = GetStoredCtx（＆handles，self，self_ind）;如果（！storedCtx）返回ODCI_ERROR; / *为存储的上下文释放内存* / if（checkerr（＆handles，OCIMemoryFree（（dvoid *）handles.usrhp，handles.errhp，（dvoid *）storedCtx）））返回ODCI_ERROR;返回ODCI_SUCCESS; / ************************************************ *********************** //使用扫描上下文中的键获取存储的上下文* / static StoredCtx * GetStoredCtx（Handles_t * handles，StockPivotImpl * self，StockPivotImpl_ind * self_ind）{StoredCtx * storedCtx; / *存储的上下文指针* / ub1 * key; / *键检索上下文* / ub4 keylen; / *密钥长度* / / *如果PL / SQL上下文为NULL * / if返回NULL *（self_ind  - &gt; _ atomic == OCI_IND_NULL）返回NULL; / *获取密钥* / key = OCIRawPtr（handles-&gt; envhp，self-&gt; key）; keylen = OCIRawSize（handles-&gt; envhp，self-&gt; key）; / *使用键* / if检索存储的上下文（checkerr（handle，OCIContextGetValue（（dvoid *）handles-&gt; usrhp，handles-&gt; errhp，key，（ub1）keylen，（dvoid **）＆storedCtx）））返回NULL ; return storedCtx; / ************************************************ *********************** //使用ext-proc上下文获取OCI句柄* / static int GetHandles（OCIExtProcContext * extProcCtx，Handles_t * handles）{ / *将ext-proc上下文存储在句柄struct * / handles-&gt; extProcCtx = extProcCtx中; / *获取OCI句柄* / if（checkerr（handle，OCIExtProcGetEnv（extProcCtx，＆handles-&gt; envhp，＆handle-&gt; svchp，＆handle-&gt; errhp）））返回-1; / *获取用户句柄* / if（checkerr（句柄，OCIAttrGet（（dvoid *）handle-&gt; svchp，（ub4）OCI_HTYPE_SVCCTX，（dvoid *）＆handles-&gt; usrhp，（ub4 *）0，（ub4）OCI_ATTR_SESSION， handles-&gt; errhp）））return -1;返回0; / ************************************************ *********************** //检查错误状态并在必要时抛出异常* / static int checkerr（Handles_t * handle，sword status）{text errbuf [512]; / *错误消息缓冲区* / sb4错误代码; / * OCI错误代码* / switch（status）{case OCI_SUCCESS：case OCI_SUCCESS_WITH_INFO：return 0; case OCI_ERROR：OCIErrorGet（（dvoid *）handles-&gt; errhp，（ub4）1，（text *）NULL，＆errcode，errbuf，（ub4）sizeof（errbuf），（ub4）OCI_HTYPE_ERROR）; sprintf（（char *）errbuf，“OCI ERROR code％d”，errcode）;打破;默认值：sprintf（（char *）errbuf，“警告 - 错误状态％d”，状态）;打破; } OCIExtProcRaiseExcpWithMsg（handles-&gt; extProcCtx，29400，errbuf，strlen（（char *）errbuf））;返回-1; }</pre></div>
                     <!-- class="example" -->
                  </div>
               </div>
            </div><a id="ADDCI4929"></a><div class="props_rev_3"><a id="GUID-CBDE48C7-0770-4325-857A-F1CE75F13BB7" name="GUID-CBDE48C7-0770-4325-857A-F1CE75F13BB7"></a><h3 id="ADDCI-GUID-CBDE48C7-0770-4325-857A-F1CE75F13BB7" class="sect3"><span class="enumeration_section">17.2</span>流水线表函数示例：Java实现</h3>
               <div>
                  <p>在此示例中，实现类型的声明引用Java方法而不是C函数。这是前面的C示例中唯一的变化：所有其他对象（ <code class="codeph">TickerType</code> ， <code class="codeph">TickerTypeSet</code> ， <code class="codeph">refcur_pkg</code> ， <code class="codeph">StockTable</code>和<code class="codeph">StockPivot</code> ）都是相同的。必须首先在SQL中声明这些方法。</p>
               </div><a id="ADDCI4931"></a><a id="ADDCI4930"></a><div class="props_rev_3"><a id="GUID-12A0A2DB-021C-4521-8133-FFCF5FF44521" name="GUID-12A0A2DB-021C-4521-8133-FFCF5FF44521"></a><h4 id="ADDCI-GUID-12A0A2DB-021C-4521-8133-FFCF5FF44521" class="sect4"><span class="enumeration_section">17.2.1</span>为Java实现制作SQL声明</h4>
                  <div>
                     <div class="section">
                        <p><a href="example-for-pipelined-table-functions-interface-approach.html#GUID-12A0A2DB-021C-4521-8133-FFCF5FF44521__CHDIEJJD">例17-3</a>显示了如何在<a href="example-for-pipelined-table-functions-interface-approach.html#GUID-097FA7CA-3E73-4C96-8349-5CF6FC6C1DB1">实现Java中的ODCITable方法中</a>为C语言<a href="example-for-pipelined-table-functions-interface-approach.html#GUID-097FA7CA-3E73-4C96-8349-5CF6FC6C1DB1">实现的方法</a>创建SQL声明。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-12A0A2DB-021C-4521-8133-FFCF5FF44521__CHDIEJJD">
                        <p class="titleinexample">示例17-3使用Java实现OCITableXXX（）的SQL声明</p><pre class="oac_no_warn" dir="ltr">//创建目录对象CREATE OR REPLACE DIRECTORY JavaDir AS'/ home / bill / Java'; //编译java源代码CREATE AND COMPILE JAVA SOURCE NAMED source01使用BFILE（JavaDir，'StockPivotImpl.java'）; / show errors  - 创建实现类型CREATE TYPE StockPivotImpl AS OBJECT（键INTEGER，STATIC FUNCTION ODCITableStart（sctx OUT StockPivotImpl，cur SYS_REFCURSOR）RETURN NUMBER AS LANGUAGE JAVA NAME'StockPivotImpl。ODCITableStart（oracle.sql。STRUCT []，java.sql。ResultSet）返回java.math。BigDecimal'，成员函数ODCITableFetch（自我IN OUT StockPivotImpl，nrows IN NUMBER，outSet OUT TickerTypeSet）返回NUMBER作为语言JAVA NAME'StockPivotImpl。ODCITableFetch（java.math中。BigDecimal，oracle.sql。ARRAY []）返回java.math。BigDecimal'，成员函数ODCITableClose（自我IN StockPivotImpl）返回NUMBER作为语言JAVA NAME'StockPivotImpl。ODCITableClose（）返回java.math。BigDecimal'）; /显示错误</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="ADDCI4933"></a><a id="ADDCI4932"></a><div class="props_rev_3"><a id="GUID-097FA7CA-3E73-4C96-8349-5CF6FC6C1DB1" name="GUID-097FA7CA-3E73-4C96-8349-5CF6FC6C1DB1"></a><h4 id="ADDCI-GUID-097FA7CA-3E73-4C96-8349-5CF6FC6C1DB1" class="sect4"><span class="enumeration_section">17.2.2</span>在Java中实现ODCITable方法</h4>
                  <div>
                     <div class="section">
                        <p><a href="example-for-pipelined-table-functions-interface-approach.html#GUID-097FA7CA-3E73-4C96-8349-5CF6FC6C1DB1__CHDDGDDG">例17-4</a>将三个<code class="codeph">ODCITable</code>方法实现为Java中的外部函数。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-097FA7CA-3E73-4C96-8349-5CF6FC6C1DB1__CHDDGDDG">
                        <p class="titleinexample">示例17-4在Java中实现ODCITableXXX（）方法</p><pre class="oac_no_warn" dir="ltr">import java.io.*; import java.util。*; import oracle.sql。*; import java.sql。*; import java.math。BigDecimal的;导入oracle。CartridgeServices。*; //存储的上下文类型公共类StoredCtx {ResultSet rset; public StoredCtx（ResultSet rs）{rset = rs;实现类型公共类StockPivotImpl实现SQLData {private BigDecimal key; final static BigDecimal SUCCESS = new BigDecimal（0）; final static BigDecimal ERROR = new BigDecimal（1）; //实现SQLData接口。String sql_type; public String getSQLTypeName（）throws SQLException {return sql_type; public void readSQL（SQLInput stream，String typeName）抛出SQLException {sql_type = typeName; key = stream.readBigDecimal（）; public void writeSQL（SQLOutput stream）抛出SQLException {stream.writeBigDecimal（key）; } //类型实现ODCITable接口的方法static public BigDecimal ODCITableStart（STRUCT [] sctx，ResultSet rset）抛出SQLException {Connection conn = DriverManager.getConnection（“jdbc：default：connection：”）; //创建存储的上下文并将结果集存储在其中StoredCtx ctx = new StoredCtx（rset）; //用cartridge服务int key注册存储的上下文; try {key = ContextManager.setContext（ctx）; } catch（CountException ce）{return ERROR; } //创建一个StockPivotImpl实例并将密钥存储在其中Object [] impAttr = new Object [1]; impAttr [0] = new BigDecimal（key）; StructDescriptor sd = new StructDescriptor（“STOCKPIVOTIMPL”，conn）; sctx [0] =新STRUCT（sd，conn，impAttr）;返回SUCCESS; public BigDecimal ODCITableFetch（BigDecimal nrows，ARRAY [] outSet）抛出SQLException {Connection conn = DriverManager.getConnection（“jdbc：default：connection：”）; //使用密钥StoredCtx ctx检索存储的上下文; try {ctx =（StoredCtx）ContextManager.getContext（key.intValue（））; } catch（InvalidKeyException ik）{return ERROR; } //获取nrows参数，但最多返回10行int nrowsval = nrows.intValue（）; if（nrowsval&gt; 10）nrowsval = 10; //为获取的行创建一个向量Vector v = new Vector（nrowsval）; int i = 0; StructDescriptor outDesc = StructDescriptor.createDescriptor（“TICKERTYPE”，conn）; Object [] out_attr = new Object [3]; while（nrowsval&gt; 0 &amp;&amp; ctx.rset.next（））{out_attr [0] =（Object）ctx.rset.getString（1）; out_attr [1] =（Object）new String（“O”）; out_attr [2] =（Object）new BigDecimal（ctx.rset.getFloat（2））; v.add（（Object）new STRUCT（outDesc，conn，out_attr））; out_attr [1] =（Object）new String（“C”）; out_attr [2] =（Object）new BigDecimal（ctx.rset.getFloat（3））; v.add（（Object）new STRUCT（outDesc，conn，out_attr））; I + = 2; nrowsval- = 2; } //如果没有找到行，则返回if（i == 0）返回SUCCESS; //使用向量对象out_arr [] = v.toArray（）创建输出ARRAY; ArrayDescriptor ad = new ArrayDescriptor（“TICKERTYPESET”，conn）; outSet [0] =新ARRAY（ad，conn，out_arr）;返回SUCCESS; public BigDecimal ODCITableClose（）抛出SQLException {//使用键检索存储的上下文，并从ContextManager中删除StoredCtx ctx; try {ctx =（StoredCtx）ContextManager.clearContext（key.intValue（））; } catch（InvalidKeyException ik）{return ERROR; } //关闭结果集语句stmt = ctx.rset.getStatement（）; ctx.rset.close（）;如果（stmt是！= null）stmt.close（）;返回SUCCESS; }}</pre></div>
                     <!-- class="example" -->
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>