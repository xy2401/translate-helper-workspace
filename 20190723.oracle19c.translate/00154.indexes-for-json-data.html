<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <meta name="abstract" content="You can index JSON data as you would any data of the type you use to store it. In addition, you can define a JSON search index, which is useful for both ad hoc structural queries and full-text queries."></meta>
      <meta name="description" content="You can index JSON data as you would any data of the type you use to store it. In addition, you can define a JSON search index, which is useful for both ad hoc structural queries and full-text queries."></meta>
      <title>JSON数据的索引</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="JSON Developer&#39;s Guide"></meta>
      <meta property="og:description" content="You can index JSON data as you would any data of the type you use to store it. In addition, you can define a JSON search index, which is useful for both ad hoc structural queries and full-text queries."></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="JSON Developer&#39;s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="json-developers-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-02-22T10:58:31-08:00"></meta>
      <meta name="dcterms.title" content="JSON Developer&#39;s Guide"></meta>
      <meta name="dcterms.dateCopyrighted" content="2015, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96227-03"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="overview-of-performance-improvement-for-json.html" title="Previous" type="text/html"></link>
      <link rel="next" href="in-memory-json-data.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.isVersionOf" content="ADJSN"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="overview-of-performance-improvement-for-json.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="in-memory-json-data.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">JSON开发人员指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="performance-tuning-for-json-data.html" property="item" typeof="WebPage"><span property="name">JSON的性能调优</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">JSON数据的索引</li>
            </ol>
            <a id="GUID-8A1B098E-D4FE-436E-A715-D8B465655C0D" name="GUID-8A1B098E-D4FE-436E-A715-D8B465655C0D"></a>
            
            <h2 id="ADJSN-GUID-8A1B098E-D4FE-436E-A715-D8B465655C0D" class="sect2"><span class="enumeration_chapter">26个</span> JSON数据索引</h2>
         </header>
         <div class="ind">
            <div>
               <p>您可以像处理用于存储JSON数据的任何类型的数据一样索引JSON数据。此外，您还可以定义JSON搜索索引，这对于即席结构查询和全文查询都很有用。</p>
               <div class="section"></div>
               <!-- class="section" -->
            </div>
            <div>
               <ul class="ullinks">
                  <li class="ulchildlink"><a href="indexes-for-json-data.html#GUID-257BD1FC-410E-4C15-8C42-84F93EB61FCA">索引JSON数据概述</a><br>JSON数据没有专用的SQL数据类型，因此您可以通过常规方式对其进行索引。此外，您可以使用JSON搜索索引以一般方式对其进行索引，以进行即席结构查询和全文查询。
                  </li>
                  <li class="ulchildlink"><a href="indexes-for-json-data.html#GUID-7DD291FB-F22C-4AB9-ABDD-9D55CFB6CCAD">如何判断是否提取了基于函数的JSON数据索引</a><br>要确定给定查询是否获取给定的基于函数的索引，请在查询的执行计划中查找索引名称。
                  </li>
                  <li class="ulchildlink"><a href="indexes-for-json-data.html#GUID-DD0EE42E-7670-4AF8-8342-7BE97835F866">为SQL / JSON条件JSON_EXISTS创建位图索引</a><br>您可以为<code class="codeph">json_exists</code>返回的值创建位图索引。这是用于<code class="codeph">json_exists</code>的正确索引<code class="codeph">json_exists</code> ，因为条件只有两个可能的返回值（true和false）。
                  </li>
                  <li class="ulchildlink"><a href="indexes-for-json-data.html#GUID-FEE83855-780A-424B-9916-B899BFF2077B">创建基于函数的JSON_VALUE索引</a><br>您可以为SQL / JSON函数<code class="codeph">json_value</code>创建基于函数的索引。您可以使用标准语法，显式指定函数<code class="codeph">json_value</code> ，也可以使用简单的点符号语法。以这两种方式之一创建的索引可以与点符号查询和<code class="codeph">json_value</code>查询一起使用。
                  </li>
                  <li class="ulchildlink"><a href="indexes-for-json-data.html#GUID-7CEAFFC2-C7B8-4223-BAD9-870858990939">使用带有JSON_TABLE查询的JSON_VALUE基于函数的索引</a><br>如果<code class="codeph">WHERE</code>子句引用由<code class="codeph">json_table</code>投影的列，则使用带有<code class="codeph">ERROR ON ERROR</code> <code class="codeph">json_value</code>创建的索引可用于涉及<code class="codeph">json_table</code>的查询，并且以该<code class="codeph">json_table</code>目标的有效SQL / JSON路径与索引路径表达式匹配。
                  </li>
                  <li class="ulchildlink"><a href="indexes-for-json-data.html#GUID-E3721DDA-23C9-4859-B13B-FAA8544C32F8">使用带有JSON_EXISTS查询的JSON_VALUE基于函数的索引</a><br>使用带有<code class="codeph">ERROR ON ERROR</code> SQL / JSON函数<code class="codeph">json_value</code>创建的索引可用于涉及SQL / JSON条件<code class="codeph">json_exists</code>的查询，前提是查询路径表达式具有仅包含<span class="italic">路径表达式比较</span>的过滤器表达式或由<code class="codeph">&amp;&amp;</code>分隔的多个此类比较。
                  </li>
                  <li class="ulchildlink"><a href="indexes-for-json-data.html#GUID-90D76388-F022-444C-B5CD-0A7C27FEE30D">JSON_VALUE索引和查询的数据类型注意事项</a><br>默认情况下，SQL / JSON函数<code class="codeph">json_value</code>返回<code class="codeph">VARCHAR2</code>值。当您使用创建一个基于函数的索引<code class="codeph">json_value</code> ，除非你使用一个<code class="codeph">RETURNING</code>子句指定不同的返回数据类型，该指数不拿起对于预期非查询<code class="codeph">VARCHAR2</code>值。
                  </li>
                  <li class="ulchildlink"><a href="indexes-for-json-data.html#GUID-47CEF6AA-0FCF-40D2-90E0-C57C0B0E816F">使用复合B树索引索引多个JSON字段</a><br>要索引JSON对象的多个字段，首先要为它们创建虚拟列。然后在虚拟列上创建复合B树索引。
                  </li>
                  <li class="ulchildlink"><a href="indexes-for-json-data.html#GUID-D7A604E1-F617-4C92-A9D9-00B6AB78EFD8">JSON搜索索引：特殊查询和全文搜索</a><br>JSON搜索索引是<span class="italic">一般</span>索引。它可以改善（1）即席结构查询的性能，即您可能不会预期或经常使用的查询，以及（2）全文搜索。它是专为与JSON数据一起使用而设计的Oracle Text索引。
                  </li>
               </ul>
               <div class="familylinks">
                  <div class="parentlink">
                     <p><strong>父主题：</strong> <a href="performance-tuning-for-json-data.html#GUID-D3A3F17B-8372-43A7-83A3-E37C22E9011E" title="要调优查询性能，您可以通过多种方式索引JSON字段，将其值存储在内存中列存储（IM列存储）中，或使用实例化视图将它们公开为非JSON数据。">JSON的性能调优</a></p>
                  </div>
               </div>
            </div>
            
            <div class="sect2"><a id="GUID-257BD1FC-410E-4C15-8C42-84F93EB61FCA" name="GUID-257BD1FC-410E-4C15-8C42-84F93EB61FCA"></a><h3 id="ADJSN-GUID-257BD1FC-410E-4C15-8C42-84F93EB61FCA" class="sect3"><span class="enumeration_section">26.1</span>索引JSON数据概述</h3>
               <div>
                  <p>JSON数据没有专用的SQL数据类型，因此您可以通过常规方式对其进行索引。此外，您可以使用JSON搜索索引以一般方式对其进行索引，以进行即席结构查询和全文查询。</p>
                  <p>您可以像处理用于存储JSON数据的任何类型的数据一样索引JSON数据。特别是，您可以为SQL / JSON函数<code class="codeph">json_value</code>使用B树索引或位图索引，并且您可以使用SQL / JSON条件的位图索引<code class="codeph">is json</code> ， <code class="codeph">is not json</code>和<code class="codeph">json_exists</code> 。
                  </p>
                  <p>（更一般地，位图索引可适用于函数的可能值的数量较小的任何位置。例如，如果值预期为布尔值或者是少量字符串值之一，则可以对函数<code class="codeph">json_value</code>使用位图索引。）
                  </p>
                  <p>与往常一样，这种基于函数的索引适用于针对特定函数的查询，这些函数在SQL / JSON函数的上下文中表示特定的SQL / JSON <span class="italic">路径表达式</span> 。对于临时的，即任意的查询，它不是很有帮助。如果您知道经常查询特定路径表达式，请定义基于函数的索引。
                  </p>
                  <p>如果以临时方式查询，则定义<strong class="term">JSON搜索索引</strong> 。这是一个通用索引， <span class="italic">不针对</span>任何特定路径表达式。它适用于<span class="italic">结构</span>查询，例如查找具有特定值的JSON字段，以及使用SQL / JSON条件<code class="codeph">json_textcontains</code> <span class="italic">进行全文</span>查询，例如在各种字符串值中查找特定单词。
                  </p>
                  <p>您当然可以为同一JSON列定义基于函数的索引和JSON搜索索引。</p>
                  <p>JSON搜索索引是专门为与JSON数据一起使用而设计的Oracle Text（全文）索引。</p>
                  <div class="infoboxnote" id="GUID-257BD1FC-410E-4C15-8C42-84F93EB61FCA__GUID-C7569A37-C693-4C3A-9BC4-765D99432FD3">
                     <p class="notep1">注意：</p>
                     <p>Oracle建议您使用AL32UTF8作为数据库字符集。创建或应用索引时可以进行自动字符集转换。这种转换可能是有损的，这可能意味着不会返回您可能期望由查询返回的某些数据。请参阅<a href="json-character-sets-and-encoding.html#GUID-2BD7911A-0201-4BEC-906E-D174267B438A" title="JSON数据始终使用Unicode字符集。在这方面，JSON数据比XML数据更易于使用。这是JSON数据交换格式（RFC 4627）的重要组成部分。对于Oracle数据库处理的JSON数据，将自动执行任何所需的字符集转换。">JSON数据的字符集和字符编码</a> 。
                     </p>
                  </div>
                  <div class="section"></div>
                  <!-- class="section" -->
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="using-GeoJSON-geographic-data.html#GUID-2AD827B4-871E-4652-87F3-AC33FE7839AE" title="GeoJSON对象是表示地理数据的JSON对象。提供了创建GeoJSON数据，对其进行索引以及查询的示例。">使用GeoJSON地理数据</a></li>
                        <li><a href="indexes-for-json-data.html#GUID-D7A604E1-F617-4C92-A9D9-00B6AB78EFD8" title="JSON搜索索引是一般索引。它可以改善（1）即席结构查询的性能，即您可能不会预期或经常使用的查询，以及（2）全文搜索。它是专为与JSON数据一起使用而设计的Oracle Text索引。">JSON搜索索引：特殊查询和全文搜索</a></li>
                     </ul>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="indexes-for-json-data.html#GUID-8A1B098E-D4FE-436E-A715-D8B465655C0D" title="您可以像处理用于存储JSON数据的任何类型的数据一样索引JSON数据。此外，您还可以定义JSON搜索索引，这对于即席结构查询和全文查询都很有用。">JSON数据的索引</a></p>
                     </div>
                  </div>
               </div>
               
            </div><a id="ADXDB6394"></a><div class="props_rev_3"><a id="GUID-7DD291FB-F22C-4AB9-ABDD-9D55CFB6CCAD" name="GUID-7DD291FB-F22C-4AB9-ABDD-9D55CFB6CCAD"></a><h3 id="ADJSN-GUID-7DD291FB-F22C-4AB9-ABDD-9D55CFB6CCAD" class="sect3"><span class="enumeration_section">26.2</span>如何判断是否提取了基于函数的JSON数据索引</h3>
               <div>
                  <p>要确定给定查询是否获取给定的基于函数的索引，请在查询的执行计划中查找索引名称。</p>
                  <div class="section">
                     <p>例如，给定<a href="indexes-for-json-data.html#GUID-FEE83855-780A-424B-9916-B899BFF2077B__CACFJJDA">示例26-4中</a>定义的索引， <a href="simple-dot-notation-access-to-json-data.html#GUID-7249417B-A337-4854-8040-192D5CEFD576__CACGDHDB">示例12-1</a>的<code class="codeph">json_value</code>查询的执行计划引用索引为<code class="codeph">po_num_id1</code>的索引扫描。
                     </p>
                  </div>
                  <!-- class="section" -->
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="indexes-for-json-data.html#GUID-8A1B098E-D4FE-436E-A715-D8B465655C0D" title="您可以像处理用于存储JSON数据的任何类型的数据一样索引JSON数据。此外，您还可以定义JSON搜索索引，这对于即席结构查询和全文查询都很有用。">JSON数据的索引</a></p>
                     </div>
                  </div>
               </div>
               
            </div><a id="ADXDB6271"></a><a id="ADXDB6396"></a><a id="ADXDB6395"></a><div class="props_rev_3"><a id="GUID-DD0EE42E-7670-4AF8-8342-7BE97835F866" name="GUID-DD0EE42E-7670-4AF8-8342-7BE97835F866"></a><h3 id="ADJSN-GUID-DD0EE42E-7670-4AF8-8342-7BE97835F866" class="sect3"><span class="enumeration_section">26.3</span>为SQL / JSON条件JSON_EXISTS创建位图索引</h3>
               <div>
                  <p>您可以为<code class="codeph">json_exists</code>返回的值创建位图索引。这是用于<code class="codeph">json_exists</code>的正确索引<code class="codeph">json_exists</code> ，因为条件只有两个可能的返回值（true和false）。
                  </p>
                  <div class="section">
                     <p>这由<a href="indexes-for-json-data.html#GUID-DD0EE42E-7670-4AF8-8342-7BE97835F866__CACCCEBD">例26-1</a>说明。
                     </p>
                     <p><a href="indexes-for-json-data.html#GUID-DD0EE42E-7670-4AF8-8342-7BE97835F866__CACEIFEE">例26-2</a>为<code class="codeph">json_value</code>返回的值创建位图索引。<span class="italic">如果</span>数据中的字段<code class="codeph">CostCenter</code>只有很少的可能值， <span class="italic">则</span>这是一个合适的索引。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-DD0EE42E-7670-4AF8-8342-7BE97835F866__CACCCEBD">
                     <p class="titleinexample">示例26-1为JSON_EXISTS创建位图索引</p><pre class="pre codeblock"><code>CREATE BITMAP INDEX has_zipcode_idx ON j_purchaseorder（ <span class="bold">json_exists</span> （po_document，'$。ShippingInstructions。Address.zipCode'））;</code></pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-DD0EE42E-7670-4AF8-8342-7BE97835F866__CACEIFEE">
                     <p class="titleinexample">示例26-2为JSON_VALUE创建位图索引</p><pre class="pre codeblock"><code>CREATE BITMAP INDEX cost_ctr_idx ON j_purchaseorder（ <span class="bold">json_value</span> （po_document，'$。成本中心'））;</code></pre></div>
                  <!-- class="example" -->
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="indexes-for-json-data.html#GUID-8A1B098E-D4FE-436E-A715-D8B465655C0D" title="您可以像处理用于存储JSON数据的任何类型的数据一样索引JSON数据。此外，您还可以定义JSON搜索索引，这对于即席结构查询和全文查询都很有用。">JSON数据的索引</a></p>
                     </div>
                  </div>
               </div>
               
            </div><a id="ADXDB6267"></a><a id="ADXDB6398"></a><a id="ADXDB6397"></a><div class="props_rev_3"><a id="GUID-FEE83855-780A-424B-9916-B899BFF2077B" name="GUID-FEE83855-780A-424B-9916-B899BFF2077B"></a><h3 id="ADJSN-GUID-FEE83855-780A-424B-9916-B899BFF2077B" class="sect3"><span class="enumeration_section">26.4</span>创建基于函数的JSON_VALUE索引</h3>
               <div>
                  <p>您可以为SQL / JSON函数<code class="codeph">json_value</code>创建基于函数的索引。您可以使用标准语法，显式指定函数<code class="codeph">json_value</code> ，也可以使用简单的点符号语法。以这两种方式之一创建的索引可以与点符号查询和<code class="codeph">json_value</code>查询一起使用。
                  </p>
                  <div class="section">
                     <p><a href="indexes-for-json-data.html#GUID-FEE83855-780A-424B-9916-B899BFF2077B__CACFJJDA">例26-4</a>为表<code class="codeph">j_purchaseorder</code>列<code class="codeph">po_document</code>中的对象的字段<code class="codeph">PONumber</code>创建了<code class="codeph">json_value</code>的基于函数的索引。该对象作为路径表达式上下文项传递。
                     </p>
                     <p>这里使用<code class="codeph">ERROR ON ERROR</code>意味着如果数据包含<span class="italic">没有</span> <code class="codeph">PONumber</code>字段的记录，具有<span class="italic">多个</span> <code class="codeph">PONumber</code>字段，或者具有<span class="italic">非</span>数值的<code class="codeph">PONumber</code>字段，则索引创建失败。如果索引存在，则尝试插入此类记录失败。
                     </p>
                     <p>另一种方法是使用<a href="simple-dot-notation-access-to-json-data.html#GUID-7249417B-A337-4854-8040-192D5CEFD576" title="点符号设计用于简单，通用和常见用例。使用点符号语法的JSON数据查询尽可能返回JSON值。">简单点 - 符号访问JSON数据中</a>描述的简化语法创建索引。<a href="indexes-for-json-data.html#GUID-FEE83855-780A-424B-9916-B899BFF2077B__CACHAAIA">例26-3</a>说明了这一点;它会对标量和非标量结果进行索引，对应于点符号查询可以返回的内容。
                     </p>
                     <p>可以为使用点符号语法的查询或使用<code class="codeph">json_value</code>的查询拾取<a href="indexes-for-json-data.html#GUID-FEE83855-780A-424B-9916-B899BFF2077B__CACFJJDA">示例26-4</a>和<a href="indexes-for-json-data.html#GUID-FEE83855-780A-424B-9916-B899BFF2077B__CACHAAIA">示例26-3中</a>创建的索引。
                     </p>
                     <p>如果为<code class="codeph">json_value</code>查询选取<a href="indexes-for-json-data.html#GUID-FEE83855-780A-424B-9916-B899BFF2077B__CACHAAIA">示例26-3</a>的索引，则在索引拾取后应用过滤，以测试正确的字段值。非标量值可以存储在此索引中，因为点符号查询可以返回此类值，但<code class="codeph">json_value</code>查询不能，因此在索引拾取后过滤掉这些值。
                     </p>
                     <p>如果要允许索引可能缺少<code class="codeph">json_value</code>表达式所针对的字段的数据，则使用<code class="codeph">NULL ON EMPTY</code>子句以及<code class="codeph">ERROR ON ERROR</code>子句。<a href="indexes-for-json-data.html#GUID-FEE83855-780A-424B-9916-B899BFF2077B__GUID-A257EAA2-C71C-4F6B-A76F-CA539EACD555">例26-5</a>说明了这一点。
                     </p>
                     <p>Oracle <span class="italic">建议</span>您使用以下形式之一为<code class="codeph">json_value</code>创建基于函数的索引：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>点符号语法</p>
                           <p>索引值对应于点符号查询的灵活行为，它尽可能返回JSON值。它们可以包含非标量JSON值（JSON对象和数组）。除了<code class="codeph">json_value</code>查询之外，它们还可以匹配点符号查询。索引用于提供一组初始匹配，然后根据查询的细节进行过滤。例如，过滤掉任何非JSON标量的索引值。
                           </p>
                        </li>
                        <li>
                           <p>甲<code class="codeph">json_value</code>表达式，指定一个<span class="bold"><code class="codeph">RETURNING</code></span>数据类型，使用<span class="bold"><code class="codeph">ERROR ON ERROR</code></span> （以及任选地使用<code class="codeph">NULL ON EMPTY</code> ）。
                           </p>
                           <p>索引值仅是指定数据类型的（非<code class="codeph">null</code> ）标量值。然而，索引可以用于导致这种标量结果的点符号查询。
                           </p>
                        </li>
                     </ul>
                     <p>因此，以这些方式之一创建的索引可以与点符号查询和<code class="codeph">json_value</code>查询一起使用。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-FEE83855-780A-424B-9916-B899BFF2077B__CACHAAIA">
                     <p class="titleinexample">示例26-3为JSON字段创建基于函数的索引：点表示法</p><pre class="pre codeblock"><code>CREATE UNIQUE INDEX po_num_idx2 ON j_purchaseorder po（po.po_document。<span class="bold">PONumber</span> ）;</code></pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-FEE83855-780A-424B-9916-B899BFF2077B__CACFJJDA">
                     <p class="titleinexample">示例26-4为JSON字段创建基于函数的索引：JSON_VALUE</p><pre class="pre codeblock"><code>CREATE UNIQUE INDEX po_num_idx1 ON j_purchaseorder（ <span class="bold">json_value</span> （po_document，'$。<span class="bold">PONumber</span> '返回<span class="bold">错误的</span> <span class="bold">数字</span> <span class="bold">错误</span> ））;</code></pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-FEE83855-780A-424B-9916-B899BFF2077B__GUID-A257EAA2-C71C-4F6B-A76F-CA539EACD555">
                     <p class="titleinexample">示例26-5为JSON_VALUE基于函数的索引在EMPTY上指定NULL</p>
                     <p>由于<code class="codeph">NULL ON EMPTY</code>子句，索引<code class="codeph">po_ref_idx1</code>可以索引没有<code class="codeph">Reference</code>字段的JSON文档。
                     </p><pre class="pre codeblock"><code>CREATE UNIQUE INDEX po_ref_idx1 ON j_purchaseorder（json_value（po_document，'$。引用'RETURNING VARCHAR2（200）ERROR ON ERROR <span class="bold">NULL on EMPTY</span> ））;</code></pre></div>
                  <!-- class="example" -->
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="clauses-used-in-functions-and-conditions-for-json.html#GUID-3176ECEA-BBCE-4C7C-AB24-7FCE250B8443" title="SQL / JSON查询函数json_value，json_query和json_table接受可选的ON EMPTY子句，该子句指定在查询的数据中不存在目标JSON字段时要使用的处理。此处描述了此子句和默认行为（无ON EMPTY子句）。">SQL / JSON查询函数的空字段子句</a></li>
                        <li><a href="using-GeoJSON-geographic-data.html#GUID-2AD827B4-871E-4652-87F3-AC33FE7839AE" title="GeoJSON对象是表示地理数据的JSON对象。提供了创建GeoJSON数据，对其进行索引以及查询的示例。">使用GeoJSON地理数据</a></li>
                     </ul>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="indexes-for-json-data.html#GUID-8A1B098E-D4FE-436E-A715-D8B465655C0D" title="您可以像处理用于存储JSON数据的任何类型的数据一样索引JSON数据。此外，您还可以定义JSON搜索索引，这对于即席结构查询和全文查询都很有用。">JSON数据的索引</a></p>
                     </div>
                  </div>
               </div>
               
            </div><a id="ADXDB6400"></a><a id="ADXDB6399"></a><div class="props_rev_3"><a id="GUID-7CEAFFC2-C7B8-4223-BAD9-870858990939" name="GUID-7CEAFFC2-C7B8-4223-BAD9-870858990939"></a><h3 id="ADJSN-GUID-7CEAFFC2-C7B8-4223-BAD9-870858990939" class="sect3"><span class="enumeration_section">26.5</span>将JSON_VALUE基于函数的索引与JSON_TABLE查询一起使用</h3>
               <div>
                  <p>如果<code class="codeph">WHERE</code>子句引用由<code class="codeph">json_table</code>投影的列，则使用带有<code class="codeph">ERROR ON ERROR</code> <code class="codeph">json_value</code>创建的索引可用于涉及<code class="codeph">json_table</code>的查询，并且以该<code class="codeph">json_table</code>目标的有效SQL / JSON路径与索引路径表达式匹配。
                  </p>
                  <div class="section">
                     <p>索引充当索引路径的约束，以确保仅为JSON集合中的每个项目投射一个（非<code class="codeph">null</code> ）标量JSON值。
                     </p>
                     <p>因此， <a href="indexes-for-json-data.html#GUID-7CEAFFC2-C7B8-4223-BAD9-870858990939__CACBJDFA">例26-6中</a>的查询使用了<a href="indexes-for-json-data.html#GUID-FEE83855-780A-424B-9916-B899BFF2077B__CACFJJDA">例26-4中</a>创建的索引。
                     </p>
                     <div class="infoboxnote" id="GUID-7CEAFFC2-C7B8-4223-BAD9-870858990939__GUID-5973FB45-8522-43DA-905D-E56D1D9D8EE6">
                        <p class="notep1">注意：</p>
                        <p>只有在SQL <span class="italic">比较</span>条件中使用事件（例如<code class="codeph">&gt;=</code> ，才能在查询<code class="codeph">WHERE</code>子句中为相应的事件选取使用<code class="codeph">json_value</code>表达式或点表示法创建的基于函数的索引。特别是，它不会在条件<code class="codeph">IS NULL</code>或<code class="codeph">IS NOT NULL</code>使用的事件中被选中。</p>
                        <p>有关SQL比较条件的信息，请参见<a href="../sqlrf/Comparison-Conditions.html#SQLRF52105" target="_blank"><span><cite>Oracle数据库SQL语言参考</cite></span></a> 。
                        </p>
                     </div>
                  </div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-7CEAFFC2-C7B8-4223-BAD9-870858990939__CACBJDFA">
                     <p class="titleinexample">示例26-6使用带有JSON_TABLE查询的JSON_VALUE基于函数的索引</p><pre class="pre codeblock"><code>SELECT jt。* FROM j_purchaseorder po，json_table（po.po_document，'$'COLUMNS po_number NUMBER（5）PATH'$。<span class="bold">PONumber</span> '，引用VARCHAR2（30 CHAR）PATH'$。引用'，请求者VARCHAR2（32 CHAR）PATH'$。Requestor'，userid VARCHAR2（10 CHAR）PATH'$。用户'，costcenter VARCHAR2（16 CHAR）PATH'$。CostCenter'）jt <span class="bold">WHERE po_number = 1600;</span>
</code></pre></div>
                  <!-- class="example" -->
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="indexes-for-json-data.html#GUID-8A1B098E-D4FE-436E-A715-D8B465655C0D" title="您可以像处理用于存储JSON数据的任何类型的数据一样索引JSON数据。此外，您还可以定义JSON搜索索引，这对于即席结构查询和全文查询都很有用。">JSON数据的索引</a></p>
                     </div>
                  </div>
               </div>
               
            </div>
            <div class="sect2"><a id="GUID-E3721DDA-23C9-4859-B13B-FAA8544C32F8" name="GUID-E3721DDA-23C9-4859-B13B-FAA8544C32F8"></a><h3 id="ADJSN-GUID-E3721DDA-23C9-4859-B13B-FAA8544C32F8" class="sect3"><span class="enumeration_section">26.6</span>将JSON_VALUE基于函数的索引与JSON_EXISTS查询一起使用</h3>
               <div>
                  <p>使用带有<code class="codeph">ERROR ON ERROR</code> SQL / JSON函数<code class="codeph">json_value</code>创建的索引可用于涉及SQL / JSON条件<code class="codeph">json_exists</code>的查询，前提是查询路径表达式具有仅包含<span class="italic">路径表达式比较</span>的过滤器表达式或由<code class="codeph">&amp;&amp;</code>分隔的多个此类比较。
                  </p>
                  <div class="section">
                     <p>为了在查询的某个比较中选择基于<code class="codeph">json_value</code>函数的索引，该比较的类型必须与索引的返回SQL数据类型相同。使用的SQL数据类型是项目方法<code class="codeph">double()</code> ， <code class="codeph">number()</code> ， <code class="codeph">timestamp()</code> ， <code class="codeph">date()</code>和<code class="codeph">string()</code>所提到的那些 - 请参阅<a href="json-path-expressions.html#GUID-8656CAB9-C293-4A99-BB62-F38F3CFC4C13" title="描述了可用于SQL / JSON路径表达式的Oracle项目方法。">SQL / JSON路径表达式项方法</a> 。
                     </p>
                     <p>例如，如果索引返回一个数字，那么比较类型也必须是数字。如果查询过滤器表达式包含多个与<code class="codeph">json_value</code>索引匹配的比较，则优化程序将选择其中一个索引。
                     </p>
                     <p><span class="italic">比较</span>的<span class="italic">类型</span>确定如下：</p>
                     <ol>
                        <li>
                           <p>如果两个比较术语（比较的两侧）的SQL数据类型不同，则比较的类型是<span class="italic">未知的</span> ，并且不会拾取索引。否则，类型是相同的，这种类型是比较的类型。
                           </p>
                        </li>
                        <li>
                           <p>如果比较术语是SQL数据类型<span class="italic">字符串</span> （文本文字），则比较的<span class="italic">类型是另一个比较术语</span>的<span class="italic">类型</span> 。
                           </p>
                        </li>
                        <li>
                           <p>如果比较术语是具有函数步骤的<span class="italic">路径表达式</span> ，其<span class="italic">item方法强制执行SQL匹配类型，</span>那么这也是该比较术语的类型。强加SQL匹配类型的item方法是<code class="codeph">double()</code> ， <code class="codeph">number()</code> ， <code class="codeph">timestamp()</code> ， <code class="codeph">date()</code>和<code class="codeph">string()</code> 。
                           </p>
                        </li>
                        <li>
                           <p>如果比较术语是<span class="italic">没有</span>此类函数步骤的<span class="italic">路径表达式</span> ，则其类型为SQL <span class="italic">字符串</span> （文本文字）。
                           </p>
                        </li>
                     </ol>
                     <p><a href="indexes-for-json-data.html#GUID-FEE83855-780A-424B-9916-B899BFF2077B__CACFJJDA">实施例26-4</a>创建用于基于函数的索引<code class="codeph">json_value</code>上字段<code class="codeph">PONumber</code> 。索引返回类型为<code class="codeph">NUMBER</code> 。</p>
                     <p>在评估其<code class="codeph">json_exists</code>条件时， <a href="indexes-for-json-data.html#GUID-E3721DDA-23C9-4859-B13B-FAA8544C32F8__JSON_EXISTSQUERYTARGETINGFIELDCOMPA-3BEE8DDC">示例26-7</a> ， <a href="indexes-for-json-data.html#GUID-E3721DDA-23C9-4859-B13B-FAA8544C32F8__JSON_EXISTSQUERYTARGETINGFIELDCOMPA-3BEE906B">示例26-8</a>和<a href="indexes-for-json-data.html#GUID-E3721DDA-23C9-4859-B13B-FAA8544C32F8__JSON_EXISTSQUERYTARGETINGFIELDCASTT-3BEE923D">示例26-9中的</a>每个查询都可以使用此索引。这些查询中的每一个都使用比较，该比较涉及相对于绝对路径表达式<code class="codeph">$.的简单路径表达式<code class="codeph">$.PONumber</code> 。每种情况下的相对简单路径表达式都以当前过滤器项<code class="codeph">@</code>目标，但在<a href="indexes-for-json-data.html#GUID-E3721DDA-23C9-4859-B13B-FAA8544C32F8__JSON_EXISTSQUERYTARGETINGFIELDCASTT-3BEE923D">示例26-9中，</a>它将匹配数据转换（强制转换）为SQL数据类型<code class="codeph">NUMBER</code> 。</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section"></div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-E3721DDA-23C9-4859-B13B-FAA8544C32F8__JSON_EXISTSQUERYTARGETINGFIELDCOMPA-3BEE8DDC">
                     <p class="titleinexample">示例26-7 JSON_EXISTS查询定位字段与文字编号相比较</p>
                     <p>此查询使用索引，因为：</p>
                     <ol>
                        <li>
                           <p>一个比较术语是没有函数步骤的路径表达式，因此它的类型是SQL <span class="italic">字符串</span> （文本文字）。
                           </p>
                        </li>
                        <li>
                           <p>因为一个比较术语是字符串类型，所以比较具有另一个术语的类型，即<span class="italic">数字</span> （另一个术语是数字）。
                           </p>
                        </li>
                        <li>
                           <p>（单个）比较的类型与index： <span class="italic">number</span>返回的类型相同。
                           </p>
                        </li>
                     </ol><pre class="pre codeblock"><code>SELECT count（*）FROM j_purchaseorder WHERE json_exists（po_document，'$。订单号？（<span class="bold">@&gt; 1500</span> ）'）;</code></pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-E3721DDA-23C9-4859-B13B-FAA8544C32F8__JSON_EXISTSQUERYTARGETINGFIELDCOMPA-3BEE906B">
                     <p class="titleinexample">示例26-8 JSON_EXISTS查询定位字段与变量值的比较</p>
                     <p>此查询可以使用索引，因为：</p>
                     <ol>
                        <li>
                           <p>一个比较术语是没有函数步骤的路径表达式，因此它的类型是SQL <span class="italic">字符串</span> （文本文字）。
                           </p>
                        </li>
                        <li>
                           <p>因为一个比较术语是字符串类型，所以比较具有另一个术语的类型，即<span class="italic">数字</span> （另一个术语是绑定到数字的变量）。
                           </p>
                        </li>
                        <li>
                           <p>（单个）比较的类型与index： <span class="italic">number</span>返回的类型相同。
                           </p>
                        </li>
                     </ol><pre class="pre codeblock"><code>SELECT count（*）FROM j_purchaseorder WHERE json_exists（po_document，'$。订单号？（<span class="bold">@&gt; $ d</span> ）'通过<span class="bold">1500 AS“d”</span> ）;</code></pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-E3721DDA-23C9-4859-B13B-FAA8544C32F8__JSON_EXISTSQUERYTARGETINGFIELDCASTT-3BEE923D">
                     <p class="titleinexample">示例26-9 JSON_EXISTS查询目标字段转换为数字与变量值比较</p>
                     <p>此查询可以使用索引，因为：</p>
                     <ol>
                        <li>
                           <p>一个比较术语是具有功能步骤的路径表达式，其项目方法（ <code class="codeph">number()</code> ）将匹配数据转换为<span class="italic">数字</span> ，因此该比较术语的类型是SQL <span class="italic">编号</span> 。
                           </p>
                        </li>
                        <li>
                           <p>另一个比较术语是数字，它具有SQL类型<span class="italic">编号</span> 。比较术语的类型匹配，因此比较具有相同的类型， <span class="italic">数字</span> 。
                           </p>
                        </li>
                        <li>
                           <p>（单个）比较的类型与index： <span class="italic">number</span>返回的类型相同。
                           </p>
                        </li>
                     </ol><pre class="pre codeblock"><code>SELECT count（*）FROM j_purchaseorder WHERE json_exists（po_document，'$。订单号？（<span class="bold">@ .number（）&gt; $ d</span> ）' <span class="bold">PASSING</span> <span class="bold">1500 AS“d”</span> ）;</code></pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-E3721DDA-23C9-4859-B13B-FAA8544C32F8__JSON_EXISTSQUERYTARGETINGACONJUNCTI-3DEFBDBD">
                     <p class="titleinexample">示例26-10 JSON_EXISTS查询定位字段比较的连接</p>
                     <p>与<a href="indexes-for-json-data.html#GUID-E3721DDA-23C9-4859-B13B-FAA8544C32F8__JSON_EXISTSQUERYTARGETINGFIELDCOMPA-3BEE8DDC">例26-7一样</a> ，此查询可以使用字段<code class="codeph">PONumber</code>上的索引。如果还为字段<code class="codeph">Reference</code>定义了<code class="codeph">json_value</code>索引，则优化程序会选择要用于此查询的索引。
                     </p><pre class="pre codeblock"><code>SELECT count（*）FROM j_purchaseorder WHERE json_exists（po_document，'$？（@。PONumber&gt; 1500 <span class="bold">&amp;&amp;</span> @。参考==“ABULL-20140421”）'）;</code></pre></div>
                  <!-- class="example" -->
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="indexes-for-json-data.html#GUID-FEE83855-780A-424B-9916-B899BFF2077B" title="您可以为SQL / JSON函数json_value创建基于函数的索引。您可以使用标准语法，显式指定函数json_value，也可以使用简单的点符号语法。以这两种方式之一创建的索引可以与点符号查询和json_value查询一起使用。">创建基于函数的JSON_VALUE索引</a></li>
                        <li><a href="json-path-expressions.html#GUID-2DC05D71-3D62-4A14-855F-76E054032494" title="Oracle数据库使用SQL / JSON路径表达式提供对JSON数据的SQL访问。">SQL / JSON路径表达式</a></li>
                     </ul>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="indexes-for-json-data.html#GUID-8A1B098E-D4FE-436E-A715-D8B465655C0D" title="您可以像处理用于存储JSON数据的任何类型的数据一样索引JSON数据。此外，您还可以定义JSON搜索索引，这对于即席结构查询和全文查询都很有用。">JSON数据的索引</a></p>
                     </div>
                  </div>
               </div>
               
            </div><a id="ADXDB6402"></a><a id="ADXDB6403"></a><a id="ADXDB6404"></a><a id="ADXDB6401"></a><div class="props_rev_3"><a id="GUID-90D76388-F022-444C-B5CD-0A7C27FEE30D" name="GUID-90D76388-F022-444C-B5CD-0A7C27FEE30D"></a><h3 id="ADJSN-GUID-90D76388-F022-444C-B5CD-0A7C27FEE30D" class="sect3"><span class="enumeration_section">26.7</span> JSON_VALUE索引和查询的数据类型注意事项</h3>
               <div>
                  <p>默认情况下，SQL / JSON函数<code class="codeph">json_value</code>返回<code class="codeph">VARCHAR2</code>值。当您使用创建一个基于函数的索引<code class="codeph">json_value</code> ，除非你使用一个<code class="codeph">RETURNING</code>子句指定不同的返回数据类型，该指数不拿起对于预期非查询<code class="codeph">VARCHAR2</code>值。
                  </p>
                  <p>例如，在<a href="indexes-for-json-data.html#GUID-90D76388-F022-444C-B5CD-0A7C27FEE30D__CACCHJHD">示例26-11</a>的查询中， <code class="codeph">json_value</code>使用<code class="codeph">json_value</code> <code class="codeph">RETURNING NUMBER</code> 。可以为此查询拾取<a href="indexes-for-json-data.html#GUID-FEE83855-780A-424B-9916-B899BFF2077B__CACFJJDA">示例26-4中</a>创建的索引，因为索引的<code class="codeph">json_value</code>表达式指定返回类型<code class="codeph">NUMBER</code> 。</p>
                  <p>但是， <a href="indexes-for-json-data.html#GUID-FEE83855-780A-424B-9916-B899BFF2077B__CACHAAIA">示例26-3</a>中创建的索引不使用<code class="codeph">RETURNING NUMBER</code> （默认情况下返回类型为<code class="codeph">VARCHAR2(4000)</code> ），因此无法为此类查询选择它。
                  </p>
                  <p>现在考虑在查询<a href="indexes-for-json-data.html#GUID-90D76388-F022-444C-B5CD-0A7C27FEE30D__CACHECBI">实例26-12</a>和<a href="indexes-for-json-data.html#GUID-90D76388-F022-444C-B5CD-0A7C27FEE30D__CACIDDIF">实例26-13</a> ，它们使用<code class="codeph">json_value</code>没有<code class="codeph">RETURNING</code>子句，因此返回的值类型为<code class="codeph">VARCHAR2</code> 。
                  </p>
                  <p>在<a href="indexes-for-json-data.html#GUID-90D76388-F022-444C-B5CD-0A7C27FEE30D__CACHECBI">例26-12中</a> ，SQL函数<code class="codeph">to_number</code>显式地将<code class="codeph">json_value</code>返回的<code class="codeph">VARCHAR2</code>值转换为数字。类似地，在<a href="indexes-for-json-data.html#GUID-90D76388-F022-444C-B5CD-0A7C27FEE30D__CACIDDIF">例26-13中</a> ，比较条件&gt;（大于）隐式地将值转换为数字。
                  </p>
                  <p>对于这些查询中的任何一个，都没有选择<a href="indexes-for-json-data.html#GUID-FEE83855-780A-424B-9916-B899BFF2077B__CACFJJDA">示例26-4</a>和<a href="indexes-for-json-data.html#GUID-FEE83855-780A-424B-9916-B899BFF2077B__CACHAAIA">示例26-3</a>的索引。由于类型转换，查询可能会在每种情况下返回正确的结果，但索引不能用于评估查询。
                  </p>
                  <p>还要考虑如果某些数据无法转换为特定数据类型会发生什么。例如，给<code class="codeph">PONumber</code> <a href="indexes-for-json-data.html#GUID-90D76388-F022-444C-B5CD-0A7C27FEE30D__CACCHJHD">26-11</a> ， <a href="indexes-for-json-data.html#GUID-90D76388-F022-444C-B5CD-0A7C27FEE30D__CACHECBI">例26-12</a>和<a href="indexes-for-json-data.html#GUID-90D76388-F022-444C-B5CD-0A7C27FEE30D__CACIDDIF">例26-13中</a>的查询， <code class="codeph">PONumber</code>值如<code class="codeph">"alpha"</code>会发生什么？
                  </p>
                  <p>对于<a href="indexes-for-json-data.html#GUID-90D76388-F022-444C-B5CD-0A7C27FEE30D__CACHECBI">示例26-12</a>和<a href="indexes-for-json-data.html#GUID-90D76388-F022-444C-B5CD-0A7C27FEE30D__CACIDDIF">示例26-13</a> ，由于尝试将值<a href="indexes-for-json-data.html#GUID-90D76388-F022-444C-B5CD-0A7C27FEE30D__CACIDDIF">强制转换为数字</a> ，查询将停止错误。但是，对于<a href="indexes-for-json-data.html#GUID-90D76388-F022-444C-B5CD-0A7C27FEE30D__CACCHJHD">示例26-11</a> ，因为默认错误处理行为是<code class="codeph">NULL ON ERROR</code> ，所以简单地过滤掉非数字值<code class="codeph">"alpha"</code> 。该值已编制索引，但查询将忽略该值。
                  </p>
                  <p>类似地，如果查询使用，例如， <code class="codeph">DEFAULT '1000' ON ERROR</code> ，即，如果它指定了数字默认值，则不会为值<code class="codeph">"alpha"</code>引发错误：将使用默认值<code class="codeph">1000</code> 。
                  </p>
                  <div class="example" id="GUID-90D76388-F022-444C-B5CD-0A7C27FEE30D__CACCHJHD">
                     <p class="titleinexample">示例26-11带有显式RETURNING NUMBER的JSON_VALUE查询</p><pre class="pre codeblock"><code>SELECT count（*）FROM j_purchaseorder po WHERE json_value（po_document，'$。采购单号码” <span class="bold">返回NUMBER）&gt;</span> 1500;</code></pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-90D76388-F022-444C-B5CD-0A7C27FEE30D__CACHECBI">
                     <p class="titleinexample">示例26-12带显式数字转换的JSON_VALUE查询</p><pre class="pre codeblock"><code>SELECT count（*）FROM j_purchaseorder po WHERE <span class="bold">to_number（</span> json_value（po_document，'$。PONumber'） <span class="bold">）</span> &gt; 1500;</code></pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-90D76388-F022-444C-B5CD-0A7C27FEE30D__CACIDDIF">
                     <p class="titleinexample">示例26-13带隐式数字转换的JSON_VALUE查询</p><pre class="pre codeblock"><code>SELECT count（*）FROM j_purchaseorder po WHERE json_value（po_document，'$。PONumber'）&gt; 1500;</code></pre></div>
                  <!-- class="example" -->
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="indexes-for-json-data.html#GUID-8A1B098E-D4FE-436E-A715-D8B465655C0D" title="您可以像处理用于存储JSON数据的任何类型的数据一样索引JSON数据。此外，您还可以定义JSON搜索索引，这对于即席结构查询和全文查询都很有用。">JSON数据的索引</a></p>
                     </div>
                  </div>
               </div>
               
            </div><a id="ADXDB6268"></a><a id="ADXDB6269"></a><a id="ADXDB6270"></a><a id="ADXDB6405"></a><div class="props_rev_3"><a id="GUID-47CEF6AA-0FCF-40D2-90E0-C57C0B0E816F" name="GUID-47CEF6AA-0FCF-40D2-90E0-C57C0B0E816F"></a><h3 id="ADJSN-GUID-47CEF6AA-0FCF-40D2-90E0-C57C0B0E816F" class="sect3"><span class="enumeration_section">26.8</span>使用复合B树索引索引多个JSON字段</h3>
               <div>
                  <p>要索引JSON对象的多个字段，首先要为它们创建虚拟列。然后在虚拟列上创建复合B树索引。</p>
                  <div class="section">
                     <p><a href="indexes-for-json-data.html#GUID-47CEF6AA-0FCF-40D2-90E0-C57C0B0E816F__CACCEFDD">例26-14</a>和<a href="indexes-for-json-data.html#GUID-47CEF6AA-0FCF-40D2-90E0-C57C0B0E816F__CACFADBF">例26-15</a>说明了这一点。<a href="indexes-for-json-data.html#GUID-47CEF6AA-0FCF-40D2-90E0-C57C0B0E816F__CACCEFDD">示例26-14</a> <code class="codeph">costcenter</code>为JSON对象字段<code class="codeph">User</code>和<code class="codeph">CostCenter</code>创建虚拟列<code class="codeph">userid</code>和<code class="codeph">costcenter</code> 。
                     </p>
                     <p><a href="indexes-for-json-data.html#GUID-47CEF6AA-0FCF-40D2-90E0-C57C0B0E816F__CACFADBF">例26-15</a>在<a href="indexes-for-json-data.html#GUID-47CEF6AA-0FCF-40D2-90E0-C57C0B0E816F__CACCEFDD">例26-14</a>的虚拟列上创建了一个复合B树索引。
                     </p>
                     <p>引用虚拟列或相应JSON数据（对象字段）的SQL查询将获取复合索引。<a href="indexes-for-json-data.html#GUID-47CEF6AA-0FCF-40D2-90E0-C57C0B0E816F__CACGFJBE">例26-16中的</a>两个查询都是这种情况。
                     </p>
                     <p>这两个查询具有相同的效果，包括相同的性能。但是，第一个查询表单并不针对JSON数据本身;它以用于索引该数据的虚拟列为目标。</p>
                     <p>数据在逻辑上不依赖于为提高查询性能而实现的任何索引。如果您希望将此实现的独立性反映在您的代码中，那么请使用第二个查询表单。这样做可以确保查询在功能上具有相同或不具有索引的行为 - 索引仅用于提高性能。</p>
                  </div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-47CEF6AA-0FCF-40D2-90E0-C57C0B0E816F__CACCEFDD">
                     <p class="titleinexample">示例26-14为JSON对象字段创建虚拟列</p><pre class="pre codeblock"><code>ALTER TABLE j_purchaseorder ADD（ <span class="bold">userid</span> VARCHAR2（20） <span class="bold">GENERATED ALWAYS AS</span> （json_value（po_document，'$。<span class="bold">用户</span> 'RETURNING VARCHAR2（20））））; ALTER TABLE j_purchaseorder ADD（ <span class="bold">costcenter</span> VARCHAR2（6） <span class="bold">GENERATED ALWAYS AS</span> （json_value（po_document，'$。<span class="bold">CostCenter'RETURNING</span> VARCHAR2（6））））;</code></pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-47CEF6AA-0FCF-40D2-90E0-C57C0B0E816F__CACFADBF">
                     <p class="titleinexample">示例26-15为JSON对象字段创建复合B树索引</p><pre class="pre codeblock"><code>在j_purchaseorder上创建INDEX user_cost_ctr_idx（ <span class="bold">userid</span> ， <span class="bold">costcenter</span> ）;</code></pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-47CEF6AA-0FCF-40D2-90E0-C57C0B0E816F__CACGFJBE">
                     <p class="titleinexample">示例26-16查询使用复合索引索引的JSON数据的两种方法</p><pre class="pre codeblock"><code>SELECT po_document FROM j_purchaseorder WHERE <span class="bold">userid</span> ='ABULL'AND <span class="bold">costcenter</span> ='A50'; SELECT po_document FROM j_purchaseorder WHERE <span class="bold">json_value</span> （po_document， <span class="bold">'$。用户'</span> ）='ABULL'和<span class="bold">json_value</span> （po_document， <span class="bold">'$。CostCenter'</span> ）='A50';</code></pre></div>
                  <!-- class="example" -->
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="indexes-for-json-data.html#GUID-8A1B098E-D4FE-436E-A715-D8B465655C0D" title="您可以像处理用于存储JSON数据的任何类型的数据一样索引JSON数据。此外，您还可以定义JSON搜索索引，这对于即席结构查询和全文查询都很有用。">JSON数据的索引</a></p>
                     </div>
                  </div>
               </div>
               
            </div>
            <div class="props_rev_3"><a id="GUID-D7A604E1-F617-4C92-A9D9-00B6AB78EFD8" name="GUID-D7A604E1-F617-4C92-A9D9-00B6AB78EFD8"></a><h3 id="ADJSN-GUID-D7A604E1-F617-4C92-A9D9-00B6AB78EFD8" class="sect3"><span class="enumeration_section">26.9</span> JSON搜索索引：特殊查询和全文搜索</h3>
               <div>
                  <p>JSON搜索索引是<span class="italic">一般</span>索引。它可以改善（1）即席结构查询的性能，即您可能不会预期或经常使用的查询，以及（2）全文搜索。它是专为与JSON数据一起使用而设计的Oracle Text索引。
                  </p>
                  <div class="infoboxnote" id="GUID-D7A604E1-F617-4C92-A9D9-00B6AB78EFD8__GUID-F67A434C-6AB5-4091-B8D9-CC0B6D0CACF6">
                     <p class="notep1">注意：</p>
                     <p>如果您使用Oracle Database 12c第1版（12.1.0.2）创建了JSON搜索索引，那么Oracle建议您使用<code class="codeph">CREATE SEARCH INDEX</code> <span class="italic">删除</span>该索引并<span class="italic">创建一个新的搜索索引</span>以供更高版本使用，如下所示。
        
                     </p>
                  </div>
                  <div class="section">
                     <p class="subhead2" id="GUID-D7A604E1-F617-4C92-A9D9-00B6AB78EFD8__GUID-96A4B938-C0CD-4CC2-993D-C15452D4C754">JSON搜索索引简介</p>
                     <p>您可以使用<code class="codeph">CREATE SEARCH INDEX</code>和关键字<code class="codeph">FOR JSON</code>创建JSON搜索索引。 <a href="indexes-for-json-data.html#GUID-D7A604E1-F617-4C92-A9D9-00B6AB78EFD8__GUID-5DC9D338-2D42-46B1-ADAA-793B6DA0CF3A">例26-17</a>说明了这一点。
                     </p>
                     <p>如果您的查询的执行计划中存在JSON搜索索引的名称，那么您就知道该索引实际上是为该查询选取的。您将看到类似于<a href="indexes-for-json-data.html#GUID-D7A604E1-F617-4C92-A9D9-00B6AB78EFD8__CACIDIJG">例26-18</a>中所示的行。
                     </p>
                     <p>您可以指定<code class="codeph">PARAMETERS</code>子句来覆盖某些可配置选项的默认设置。默认情况下（没有<code class="codeph">PARAMETERS</code>子句），索引在提交时同步，文本和数字范围都被索引。
                     </p>
                     <p>JSON搜索索引按需异步维护。因此，您可以推迟索引维护的成本，仅在提交时执行，或者在数据库负载减少的某个时间执行。这可以提高DML性能。它还可以通过在同步索引时批量加载非同步索引行来提高索引维护性能。另一方面，索引的异步维护意味着在同步之前索引不用于已修改或新插入的数据。</p>
                     <p>如果使用JSON搜索索引的查询从不涉及数值范围，则可以通过为参数<code class="codeph">SEARCH_ON</code>指定<code class="codeph">TEXT</code>来节省一些索引维护时间和一些磁盘空间。 <code class="codeph">SEARCH_ON</code>的默认值为<code class="codeph">TEXT_VALUE</code> ，表示索引数字范围和文本。
                     </p>
                     <div class="infoboxnote" id="GUID-D7A604E1-F617-4C92-A9D9-00B6AB78EFD8__GUID-16D5C6A3-35C8-4178-9DAB-565B20423EBF">
                        <p class="notep1">注意：</p>
                        <p>要更改JSON搜索索引<code class="codeph">j_s_idx</code> ，请使用<code class="codeph">ALTER INDEX j_s_idx REBUILD ...</code> （ <span class="italic">不是</span> <code class="codeph">ALTER SEARCH INDEX j_s_idx ...</code> ）。
                        </p>
                     </div>
                  </div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-D7A604E1-F617-4C92-A9D9-00B6AB78EFD8__GUID-5DC9D338-2D42-46B1-ADAA-793B6DA0CF3A">
                     <p class="titleinexample">示例26-17创建JSON搜索索引</p><pre class="pre codeblock"><code>CREATE <span class="bold">SEARCH</span> INDEX po_search_idx ON j_purchaseorder（po_document） <span class="bold">FOR JSON</span> ;</code></pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-D7A604E1-F617-4C92-A9D9-00B6AB78EFD8__CACIDIJG">
                     <p class="titleinexample">示例26-18使用JSON搜索索引的执行计划指示</p><pre class="pre codeblock"><code>| * 2 | DOMAIN INDEX | <span class="bold">PO_SEARCH_IDX</span> | | | 4（0）</code></pre></div>
                  <!-- class="example" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-D7A604E1-F617-4C92-A9D9-00B6AB78EFD8__GUID-436882B8-F84F-4B25-B295-D5A644507C09">JSON数据的全文搜索</p>
                     <p>您可以在<code class="codeph">CASE</code>表达式中使用SQL / JSON条件<span class="bold"><code class="codeph">json_textcontains</code></span>或<code class="codeph">SELECT</code>语句的<code class="codeph">WHERE</code>子句来执行存储在<code class="codeph">VARCHAR2</code> ， <code class="codeph">BLOB</code>或<code class="codeph">CLOB</code>列中的JSON数据的全文搜索。
                     </p>
                     <p>Oracle Text技术是SQL条件<code class="codeph">json_textcontains</code>基础。这意味着，例如，您可以查询其他文本附近的文本，或查询使用模糊模式匹配。
                     </p>
                     <p>为了能够使用条件<code class="codeph">json_textcontains</code> ，首先必须创建一个JSON搜索索引。如果不这样做，则在使用<code class="codeph">json_textcontains</code>时会引发错误。
                     </p>
                     <p><a href="indexes-for-json-data.html#GUID-D7A604E1-F617-4C92-A9D9-00B6AB78EFD8__CACJJDFE">示例26-19</a>显示了一个全文查询，该查询在任何行项目部分描述中查找包含关键字<code class="codeph">Magic</code>采购订单文档。
                     </p>
                     <div class="infoboxnote" id="GUID-D7A604E1-F617-4C92-A9D9-00B6AB78EFD8__GUID-C9C60357-17D6-494B-8A74-75B535256EA3">
                        <p class="notep1">注意：</p>
                        <p>对于强大的全文搜索，请使用Oracle SQL函数<code class="codeph">json_textcontains</code> ，这需要您创建JSON搜索索引。作为一个不太强大的替代方案，如果你不创建一个JSON搜索索引，并且你只想在过滤条件中进行简单的字符串模式匹配，你可以使用任何模式匹配比较： <code class="codeph">has substring</code> ， <code class="codeph">starts with</code> ， <code class="codeph">like</code> ， <code class="codeph">like_regex</code>或<code class="codeph">eq_regex</code> 。
                        </p>
                     </div>
                  </div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-D7A604E1-F617-4C92-A9D9-00B6AB78EFD8__CACJJDFE">
                     <p class="titleinexample">示例26-19 JSON数据的全文查询</p><pre class="pre codeblock"><code>SELECT po_document FROM j_purchaseorder WHERE <span class="bold">json_textcontains</span> （po_document，'$。了LineItem。部分。描述'，' <span class="bold">魔术</span> '）;</code></pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-D7A604E1-F617-4C92-A9D9-00B6AB78EFD8__GUID-11AFF04C-8A07-4045-AA66-3118583E2188">
                     <p class="titleinexample">示例26-20带有转义搜索模式的JSON数据的全文查询</p>
                     <p>如果条件<code class="codeph">json_textcontains</code>的第三个参数包含相对于Oracle Text搜索<span class="italic">保留</span>的字符或单词，则必须<span class="italic">转义</span>该字符或单词。
                     </p>
                     <p>这里的查询搜索零件描述同时包含<code class="codeph">Magic</code>和<code class="codeph">Christmas</code>文档。他们使用Oracle Text的查询操作符<code class="codeph">&amp;</code>和<code class="codeph">and</code> ，这是相对于Oracle Text的搜索保留。
                     </p>
                     <p>第一个查询使用反斜杠（ <code class="codeph"><span class="bold">\</span></code> ）转义单个字符<code class="codeph">&amp;</code> 。第二个使用大括号（ <code class="codeph"><span class="bold">{</span></code> ， <code class="codeph"><span class="bold">}</span></code> ）转义整个搜索模式，因为它包含保留字<code class="codeph">and</code> 。（它可以可替换地使用<code class="codeph">{and}</code>逃脱仅在操作者的人物<code class="codeph">and</code> ）。
                     </p><pre class="pre codeblock"><code>SELECT po_document FROM j_purchaseorder WHERE json_textcontains（po_document，'$。了LineItem。部分。描述'，'魔术<span class="bold">\和</span>圣诞节'）;</code></pre><pre class="pre codeblock"><code>SELECT po_document FROM j_purchaseorder WHERE json_textcontains（po_document，'$。了LineItem。部分。描述'，' <span class="bold">{</span> Magic <span class="bold">and</span> Christmas <span class="bold">}</span> '）;</code></pre></div>
                  <!-- class="example" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-D7A604E1-F617-4C92-A9D9-00B6AB78EFD8__GUID-D74F3A3E-1203-4722-BC93-759932061042">JSON数据的特别查询</p>
                     <p><a href="indexes-for-json-data.html#GUID-D7A604E1-F617-4C92-A9D9-00B6AB78EFD8__CACGJADE">例26-21</a>显示了一些JSON数据的<span class="italic">非</span>全文查询，这些查询也使用了<a href="indexes-for-json-data.html#GUID-D7A604E1-F617-4C92-A9D9-00B6AB78EFD8__GUID-5DC9D338-2D42-46B1-ADAA-793B6DA0CF3A">例26-17中</a>创建的JSON搜索索引。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-D7A604E1-F617-4C92-A9D9-00B6AB78EFD8__CACGJADE">
                     <p class="titleinexample">示例26-21一些Ad Hoc JSON查询</p>
                     <p>此查询选择包含包含国家/地区的装运说明地址的文档。</p><pre class="pre codeblock"><code>SELECT po_document FROM j_purchaseorder WHERE json_exists（po_document，'$。ShippingInstructions。Address.country'）;</code></pre><p>此查询选择包含用户<code class="codeph">AKHOO</code>文档，其中订购的项目超过8个。它利用了数值范围索引。
                     </p><pre class="pre codeblock"><code>SELECT po_document FROM j_purchaseorder WHERE json_exists（po_document，'$？（@。用户==“AKHOO”&amp;&amp; @。了LineItem。数量&gt; 8）'）;</code></pre><p>此查询选择用户为<code class="codeph">AKHOO</code>文档。它在<code class="codeph">WHERE</code>子句中使用<code class="codeph">json_value</code>而不是<code class="codeph">json_exists</code> 。
                     </p><pre class="pre codeblock"><code>SELECT po_document FROM j_purchaseorder WHERE json_value（po_document，'$。用户'）='ABULL';</code></pre></div>
                  <!-- class="example" -->
                  <div class="section"></div>
                  <!-- class="section" -->
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="indexes-for-json-data.html#GUID-8A1B098E-D4FE-436E-A715-D8B465655C0D" title="您可以像处理用于存储JSON数据的任何类型的数据一样索引JSON数据。此外，您还可以定义JSON搜索索引，这对于即席结构查询和全文查询都很有用。">JSON数据的索引</a></li>
                        <li><a href="json-dataguide.html#GUID-219FC30E-89A7-4189-BC36-7B961A24067C" title="通过JSON数据指南，您可以发现有关Oracle数据库中存储的JSON文档的结构和内容的信息。">JSON数据指南</a></li>
                     </ul>
                  </div>
                  <div class="infoboxnotealso" id="GUID-D7A604E1-F617-4C92-A9D9-00B6AB78EFD8__GUID-4B8408A2-8425-4B94-91CE-A84B3DCD2243">
                     <p class="notep1">也可以看看：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>有关条件<code class="codeph">json_textcontains</code>信息，请<a href="../sqlrf/SQL-JSON-Conditions.html#SQLRF56963" target="_blank"><span><cite>参见Oracle数据库SQL语言参考</cite></span></a></p>
                        </li>
                        <li>
                           <p>有关<code class="codeph">CREATE SEARCH INDEX</code>的<code class="codeph">PARAMETERS</code>子句的信息，请参阅<a href="../ccref/oracle-text-SQL-statements-and-operators.html#CCREF-GUID-10013D4C-AB6A-44EB-B8B3-AD318EDE33A9" target="_blank"><span><cite>Oracle Text Reference</cite></span></a></p>
                        </li>
                        <li>
                           <p>有关<code class="codeph">ALTER INDEX</code>的<code class="codeph">PARAMETERS</code>子句的信息，请参阅<a href="../ccref/oracle-text-SQL-statements-and-operators.html#GUID-47E60252-C731-46A8-B587-AE30C1634F48__I996850" target="_blank"><span><cite>Oracle Text Reference</cite></span></a> ...<code class="codeph">重建</code></p>
                        </li>
                        <li>
                           <p>有关同步JSON搜索索引的信息，请参阅<a href="../ccref/oracle-text-SQL-statements-and-operators.html#CCREF23731" target="_blank"><span><cite>Oracle Text Reference</cite></span></a></p>
                        </li>
                        <li>
                           <p>有关优化和调整JSON搜索索引性能的指导，请参阅<a href="../ccapp/maintaining-oracle-text-indexes.html#CCAPP-GUID-9960D8E4-0AE8-48B0-82D5-B203695463DE" target="_blank"><span><cite>“Oracle Text Application Developer's Guide”</cite></span></a></p>
                        </li>
                        <li>
                           <p><a href="../ccref/special-characters-in-oracle-text-queries.html#CCREF-GUID-4639581C-7F65-4C9E-96CE-0A7EAA10086F" target="_blank"><span><cite>Oracle Text Reference</cite></span></a> ，提供有关Oracle Text搜索和<a href="../ccref/special-characters-in-oracle-text-queries.html#CCREF-GUID-F94D663C-6CE6-4FB0-AA4A-3AAEFF2E66D3" target="_blank"><span><cite>Oracle Text Reference</cite></span></a>保留的单词和字符的信息，以获取有关如何转义它们的信息。
                           </p>
                        </li>
                     </ul>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="indexes-for-json-data.html#GUID-8A1B098E-D4FE-436E-A715-D8B465655C0D" title="您可以像处理用于存储JSON数据的任何类型的数据一样索引JSON数据。此外，您还可以定义JSON搜索索引，这对于即席结构查询和全文查询都很有用。">JSON数据的索引</a></p>
                     </div>
                  </div>
               </div>
               
            </div>
         </div>
      </article>
   </body>
</html>