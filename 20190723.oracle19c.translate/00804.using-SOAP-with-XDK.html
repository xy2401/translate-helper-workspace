<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <meta name="abstract" content="An explanation is given of how to use Simple Object Access Protocol (SOAP) with the Oracle XML Developer&#39;s Kit (XDK) for C."></meta>
      <meta name="description" content="An explanation is given of how to use Simple Object Access Protocol (SOAP) with the Oracle XML Developer&#39;s Kit (XDK) for C."></meta>
      <title>将SOAP与Oracle XML Developer's Kit for C一起使用</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Programmer&#39;s Guide"></meta>
      <meta property="og:description" content="An explanation is given of how to use Simple Object Access Protocol (SOAP) with the Oracle XML Developer&#39;s Kit (XDK) for C."></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Programmer&#39;s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="xml-developers-kit-programmers-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-11T05:58:48-08:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="2001, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96292-01"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="determining-XML-differences-using-C.html" title="Previous" type="text/html"></link>
      <link rel="next" href="XDK-for-Java.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="XML Developers Kit Programmers Guide"></meta>
    <meta name="dcterms.isVersionOf" content="ADXDK"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="determining-XML-differences-using-C.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="XDK-for-Java.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">程序员指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="XDK-for-C.html" property="item" typeof="WebPage"><span property="name">适用于C的Oracle XML Developer's Kit</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">将SOAP与Oracle XML Developer's Kit for C一起使用</li>
            </ol>
            <a id="GUID-DC6C8B37-2B99-4C11-A4C6-D6CF2F5E441C" name="GUID-DC6C8B37-2B99-4C11-A4C6-D6CF2F5E441C"></a><a id="ADXDK1043"></a><a id="ADXDK19852"></a>
            
            <h2 id="ADXDK-GUID-DC6C8B37-2B99-4C11-A4C6-D6CF2F5E441C" class="sect2"><span class="enumeration_chapter">9</span>将SOAP与Oracle XML Developer's Kit for C一起使用</h2>
         </header>
         <div class="ind">
            <div>
               <p>给出了如何使用简单对象访问协议（SOAP）和Oracle XML Developer Kit（XDK）进行C语言的解释。</p>
               <div class="section"></div>
               <!-- class="section" -->
               <div class="infoboxnotealso" id="GUID-DC6C8B37-2B99-4C11-A4C6-D6CF2F5E441C__GUID-80387919-9AD6-464F-874D-B49E115CFC63">
                  <p class="notep1">也可以看看：</p>
                  <p><a href="../adxdb/native-XML-DB-web-services.html#ADXDB3900" target="_blank"><span><cite>Oracle XML DB开发人员指南</cite></span></a></p>
               </div>
            </div><a id="ADXDK19853"></a><div class="props_rev_3"><a id="GUID-97787437-6E3F-4FC0-949B-B151E1861C38" name="GUID-97787437-6E3F-4FC0-949B-B151E1861C38"></a><h3 id="ADXDK-GUID-97787437-6E3F-4FC0-949B-B151E1861C38" class="sect3">SOAP for C简介</h3>
               <div>
                  <p>SOAP是一种可扩展标记语言（XML）协议，用于在分布式环境中使用HTTP和HTTPS在对等体之间交换结构化和类型化信息。Oracle数据库10g第2版的XDK仅支持HTTP 1.0。</p>
                  <p>SOAP有三个部分：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>SOAP信封，定义如何呈现消息中的内容，谁必须处理消息，以及该处理是可选的还是必需的。</p>
                     </li>
                     <li>
                        <p>用于将应用程序数据类型转换为XML和从XML转换的一组序列化和反序列化规则。</p>
                     </li>
                     <li>
                        <p>SOAP远程过程调用（RPC），用于定义调用和响应。</p>
                        <div class="infoboxnote" id="GUID-97787437-6E3F-4FC0-949B-B151E1861C38__GUID-6E8C4645-D28D-4602-80CF-5BC1EF46AEEB">
                           <p class="notep1">注意：</p>
                           <p>此版本不支持RPC和序列化/反序列化。</p>
                        </div>
                     </li>
                  </ul>
                  <p>SOAP是操作系统和语言无关的，因为它是基于XML的。本章介绍读取和写入SOAP消息的函数的C实现。</p>
                  <p>SOAP Version 1.2是基于XML的消息的定义，它被指定为XML Infoset（一个抽象数据集，它可以是XML 1.0），它给出了消息内容的描述。还支持1.1版。</p>
               </div><a id="ADXDK19854"></a><div class="props_rev_3"><a id="GUID-EE6B64F4-9260-4E9D-A687-163AF7EE2D6D" name="GUID-EE6B64F4-9260-4E9D-A687-163AF7EE2D6D"></a><h4 id="ADXDK-GUID-EE6B64F4-9260-4E9D-A687-163AF7EE2D6D" class="sect4">SOAP消息传递概述</h4>
                  <div>
                     <p>SOAP是一种轻量级协议，用于在Internet上发送和接收请求和响应。由于它基于XML和传输协议（如HTTP），因此大多数防火墙都不会阻止它。SOAP独立于操作系统，实现语言和对象模型。</p>
                     <p>SOAP的强大功能是它能够充当异构软件组件之间的粘合剂。例如，Visual Basic客户端可以调用在UNIX计算机上运行的公共对象请求代理体系结构（CORBA）服务; Macintosh客户端可以调用在Linux上运行的Perl对象。</p>
                     <p>SOAP消息包含以下部分：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>包含消息的<strong class="term">信封</strong> ，定义如何处理消息以及处理消息的人员，以及处理是可选的还是必需的。<code class="codeph">Envelope</code>元素是必需的。
                           </p>
                        </li>
                        <li>
                           <p>一组描述应用程序数据类型的<strong class="term">编码规则</strong> 。这些规则定义了一种序列化机制，可以将应用程序数据类型转换为XML或从XML转换。</p>
                        </li>
                        <li>
                           <p><strong class="term">远程过程调用（RPC）</strong>请求和响应约定。这个必需元素称为body元素。<code class="codeph">Body</code>元素包含第一个子元素，其名称是方法的名称。此方法request元素包含每个输入和输出参数的元素。元素名称是参数名称。此版本目前不支持RPC。
                           </p>
                        </li>
                     </ul>
                     <p>SOAP独立于任何传输协议。然而，通过HTTP用于远程服务调用的SOAP已经成为通过Internet提供程序化内容的标准。</p>
                     <p>除了独立于传输协议之外，SOAP还独立于操作系统。换句话说，SOAP使程序即使在以不同语言编写并在不同操作系统上运行时也能进行通信。</p>
                  </div><a id="ADXDK19855"></a><div class="props_rev_3"><a id="GUID-221EA94A-2F7A-40DA-907B-D3214CFB28D9" name="GUID-221EA94A-2F7A-40DA-907B-D3214CFB28D9"></a><h5 id="ADXDK-GUID-221EA94A-2F7A-40DA-907B-D3214CFB28D9" class="sect5">SOAP消息格式</h5>
                     <div>
                        <p>描述了SOAP消息的类型。</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>对服务的请求，包括输入参数</p>
                           </li>
                           <li>
                              <p>来自请求的服务的响应，包括返回值和输出参数</p>
                           </li>
                           <li>
                              <p>包含错误代码和信息的可选故障元素</p>
                           </li>
                        </ul>
                        <p>在SOAP消息中， <strong class="term">有效负载</strong>包含XML编码的数据。有效负载不包含处理信息。相反，消息头可以包含处理信息。
                        </p>
                     </div><a id="ADXDK19857"></a><a id="ADXDK19856"></a><div class="sect5"><a id="GUID-683C406E-BA75-4D41-A422-835656CB4FF4" name="GUID-683C406E-BA75-4D41-A422-835656CB4FF4"></a><h6 id="ADXDK-GUID-683C406E-BA75-4D41-A422-835656CB4FF4" class="sect6">SOAP请求</h6>
                        <div>
                           <p>描述了SOAP请求。</p>
                           <p>在SOAP请求中，XML有效负载包含多个元素，包括：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>根元素</p>
                              </li>
                              <li>
                                 <p>方法元素</p>
                              </li>
                              <li>
                                 <p>标题元素（可选）</p>
                              </li>
                           </ul>
                           <p><a href="using-SOAP-with-XDK.html#GUID-683C406E-BA75-4D41-A422-835656CB4FF4__CHDHJHJJ">例9-1</a>显示了示例SOAP消息请求的格式。 <code class="codeph">GetLastTradePrice</code> SOAP请求被发送到<code class="codeph">StockQuote</code>服务。请求接受表示公司股票代码的字符串参数，并返回表示SOAP响应中股票价格的浮点数。
                           </p>
                           <div class="example" id="GUID-683C406E-BA75-4D41-A422-835656CB4FF4__CHDHJHJJ">
                              <p class="titleinexample">例9-1 SOAP请求消息</p><pre class="oac_no_warn" dir="ltr">POST / StockQuote HTTP / 1.0主机：www.stockquoteserver.com内容类型：application / soap + xml; charset =“utf-8”Content-Length：nnnn SOAPAction：“Some-URI”&lt;SOAP-ENV：Envelope xmlns：SOAP-ENV =“http://www.w3.org/2003/05/soap-envelope” SOAP-ENV：encodingStyle =“http://www.w3.org/2003/05/soap-encoding/”&gt; &lt;SOAP-ENV：Body&gt; &lt;m：GetLastTradePrice xmlns：m =“Some-URI”&gt; &lt;symbol &gt; ORCL &lt;/ symbol&gt; &lt;m：GetLastTradePrice&gt; &lt;/ SOAP-ENV：Body&gt; &lt;/ SOAP-ENV：Envelope&gt;</pre></div>
                           <!-- class="example" -->
                           <p>在<a href="using-SOAP-with-XDK.html#GUID-683C406E-BA75-4D41-A422-835656CB4FF4__CHDHJHJJ">例9-1中</a> ，XML文档是SOAP消息。<code class="codeph">&lt;SOAP-ENV:Envelope&gt;</code>元素是XML文档的顶级元素。有效负载由方法元素<code class="codeph">&lt;m:GetLastTradePrice&gt;</code> 。XML名称空间区分SOAP标识符和特定于应用程序的标识符。
                           </p>
                           <p>标头的第一行指定请求使用HTTP作为传输协议：</p><pre class="oac_no_warn" dir="ltr">POST / StockQuote HTTP / 1.1</pre><p>因为SOAP独立于传输协议，所以管理XML有效载荷格式的规则独立于使用HTTP来传输有效载荷。此HTTP请求指向URI <code class="codeph">/StockQuote</code> 。由于SOAP规范对组件激活问题没有提及，因此该URI背后的代码确定了如何激活组件并调用<code class="codeph">GetLastTradePrice</code>方法。
                           </p>
                        </div>
                     </div><a id="ADXDK19859"></a><a id="ADXDK19858"></a><div class="props_rev_3"><a id="GUID-B975BA93-4413-48F0-B27E-25E3B0C10DF0" name="GUID-B975BA93-4413-48F0-B27E-25E3B0C10DF0"></a><h6 id="ADXDK-GUID-B975BA93-4413-48F0-B27E-25E3B0C10DF0" class="sect6">SOAP响应的示例</h6>
                        <div>
                           <p>提供了SOAP响应的示例。</p>
                           <p><a href="using-SOAP-with-XDK.html#GUID-B975BA93-4413-48F0-B27E-25E3B0C10DF0__CHDCHGHH">例9-2</a>显示了<a href="using-SOAP-with-XDK.html#GUID-683C406E-BA75-4D41-A422-835656CB4FF4__CHDHJHJJ">例9-1中</a>对请求的响应格式。元素<code class="codeph">&lt;Price&gt;</code>包含第一条消息所请求的<code class="codeph">ORCL</code>的股票价格。
                           </p>
                           <p><a href="using-SOAP-with-XDK.html#GUID-683C406E-BA75-4D41-A422-835656CB4FF4__CHDHJHJJ">例9-1</a>和<a href="using-SOAP-with-XDK.html#GUID-B975BA93-4413-48F0-B27E-25E3B0C10DF0__CHDCHGHH">例9-2中</a>显示的消息显示了双向SOAP消息传递，即SOAP响应回答的SOAP请求。单向SOAP消息不需要SOAP消息作为响应。
                           </p>
                           <div class="example" id="GUID-B975BA93-4413-48F0-B27E-25E3B0C10DF0__CHDCHGHH">
                              <p class="titleinexample">例9-2 SOAP响应消息</p><pre class="pre codeblock"><code>HTTP / 1.0 200 OK内容类型：application / soap + xml; charset =“utf-8”Content-Length：nnnn &lt;SOAP-ENV：Envelope xmlns：SOAP-ENV =“http://www.w3.org/2003/05/soap-envelope”SOAP-ENV：encodingStyle =“ http://www.w3.org/2003/05/soap-encoding/“&gt; &lt;SOAP-ENV：Body&gt; &lt;m：GetLastTradePriceResponse xmlns：m =”Some-URI“&gt; &lt;Price&gt; 13.5 &lt;/ Price&gt; &lt; / m：GetLastTradePriceResponse&gt; &lt;/ SOAP-ENV：Body&gt; &lt;/ SOAP-ENV：Envelope&gt;</code></pre></div>
                           <!-- class="example" -->
                        </div>
                     </div>
                  </div>
               </div><a id="ADXDK19860"></a><div class="props_rev_3"><a id="GUID-E2B40E66-A184-4A1E-8790-B04B8F8A80CD" name="GUID-E2B40E66-A184-4A1E-8790-B04B8F8A80CD"></a><h4 id="ADXDK-GUID-E2B40E66-A184-4A1E-8790-B04B8F8A80CD" class="sect4">使用SOAP客户端</h4>
                  <div>
                     <p>SOAP客户端是用户编写的应用程序，用于生成XML文档。这些文档请求SOAP服务并处理SOAP响应。XDK中的SOAP实现处理来自发送有效SOAP请求的任何客户端的请求。</p>
                     <div class="section">
                        <p>SOAP客户端应用程序编程接口（API）具有以下功能：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>支持请求和响应的同步调用模型</p>
                           </li>
                           <li>
                              <p>便于编写客户端应用程序以发出SOAP请求</p>
                           </li>
                           <li>
                              <p>封装SOAP请求的创建以及通过底层传输协议发送请求的详细信息</p>
                           </li>
                           <li>
                              <p>支持可插拔传输，允许客户端轻松更改传输（可用传输包括HTTP和HTTPS，但此版本仅支持HTTP 1.0）</p>
                           </li>
                        </ul>
                        <p>SOAP客户端必须执行以下步骤来发出请求并接收响应：</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li><span>收集调用服务所需的所有参数。</span></li>
                        <li><span>创建SOAP服务请求消息，该消息是根据SOAP协议构建的XML消息。它包含以XML编码的所有输入参数的所有值。此过程称为<strong class="term">序列化</strong> 。</span></li>
                        <li><span>使用SOAP服务器支持的传输协议将请求提交到SOAP服务器。</span></li>
                        <li><span>收到SOAP响应消息。</span></li>
                        <li><span>通过处理SOAP Fault元素确定请求的成功或失败。</span></li>
                        <li><span>将返回的参数从XML转换为本机数据类型。此过程称为<strong class="term">反序列化</strong> 。</span></li>
                        <li><span>根据需要使用结果。</span></li>
                     </ol>
                  </div>
               </div><a id="ADXDK19861"></a><div class="props_rev_3"><a id="GUID-53495893-9965-441A-BADF-A848C5FB3DB6" name="GUID-53495893-9965-441A-BADF-A848C5FB3DB6"></a><h4 id="ADXDK-GUID-53495893-9965-441A-BADF-A848C5FB3DB6" class="sect4">使用SOAP服务器</h4>
                  <div>
                     <p>描述了SOAP服务器在执行SOAP服务请求时执行的步骤。</p>
                     <ol>
                        <li>
                           <p>SOAP服务器接收服务请求。</p>
                        </li>
                        <li>
                           <p>服务器解析XML请求，然后决定是执行还是拒绝该消息。</p>
                        </li>
                        <li>
                           <p>如果执行该消息，则服务器确定所请求的服务是否存在。</p>
                        </li>
                        <li>
                           <p>服务器将XML中的所有输入参数转换为服务理解的数据类型。</p>
                        </li>
                        <li>
                           <p>服务器调用该服务。</p>
                        </li>
                        <li>
                           <p>服务器将返回参数转换为XML并生成SOAP响应消息。</p>
                        </li>
                        <li>
                           <p>服务器将响应消息发送回调用者。</p>
                        </li>
                     </ol>
                  </div>
               </div>
            </div><a id="ADXDK19863"></a><a id="ADXDK19862"></a><div class="props_rev_3"><a id="GUID-8AA3100D-6E51-4D08-B5C4-4819C7EACF64" name="GUID-8AA3100D-6E51-4D08-B5C4-4819C7EACF64"></a><h3 id="ADXDK-GUID-8AA3100D-6E51-4D08-B5C4-4819C7EACF64" class="sect3">SOAP C函数</h3>
               <div>
                  <p>SOAP C实现使用<code class="codeph">xml.h</code>头。必须先创建<code class="codeph">xmlctx</code>类型的上下文， <code class="codeph">xmlctx</code>才能创建SOAP上下文。
                  </p>
                  <p>SOAP的HTTP方面对用户是隐藏的。SOAP端点被指定为一对（绑定，端点），其中绑定的类型为<code class="codeph">xmlsoapbind</code> ，端点是（ <code class="codeph">void *</code> ），具体取决于绑定。目前，只支持一个绑定， <code class="codeph">XMLSOAP_BIND_HTTP</code> 。对于HTTP绑定，端点是（ <code class="codeph">OraText *</code> ）URL。</p>
                  <p>SOAP层在端点之间创建和传输SOAP消息，并分解收到的SOAP消息。</p>
                  <p>C函数在<code class="codeph">xmlsoap.h</code>中声明。这是头文件的开头：</p>
                  <div class="infoboxnotealso" id="GUID-8AA3100D-6E51-4D08-B5C4-4819C7EACF64__GUID-51CF2FC4-5921-4DC5-BCA1-040F4B0E97D6">
                     <p class="notep1">也可以看看：</p>
                     <p> 适用于C SOAP API的<a href="../caxml/package-SOAP-API.html#CAXML01300" target="_blank"><span><cite>Oracle Database XML C API参考</cite></span></a></p>
                  </div>
                  <div class="example" id="GUID-8AA3100D-6E51-4D08-B5C4-4819C7EACF64__GUID-D73DB195-39E0-4C3B-BB9D-54CA6C540DDE">
                     <p class="titleinexample">示例9-3在xmlsoap.h中定义的SOAP C函数</p><pre class="oac_no_warn" dir="ltr">文件名xmlsoap.h  -  XML SOAP API文件描述XML SOAP公共API公共函数XmlSoapCreateCtx  - 创建并返回SOAP上下文XmlSoapDestroyCtx  - 销毁SOAP上下文XmlSoapCreateConnection  - 创建SOAP连接对象XmlSoapDestroyConnection  - 销毁SOAP连接对象XmlSoapCall  - 发送SOAP消息和等待回复XmlSoapCreateMsg  - 创建并返回一个空的SOAP消息XmlSoapDestroyMsg  - 销毁用XmlSoapCreateMsg创建的SOAP消息XmlSoapGetEnvelope  - 返回SOAP消息的信封XmlSoapGetHeader  - 返回SOAP消息的信封头XmlSoapGetBody  - 返回SOAP消息的信封体XmlSoapAddHeaderElement  -  Adds SOAP标头的元素XmlSoapGetHeaderElement  - 从SOAP标头获取元素XmlSoapAddBodyElement  - 向SOAP消息体添加元素XmlSoapGetBodyElement  - 从SOAP消息体中获取元素XmlSoapSetMustUnderstand  - 为SOAP hdr设置mustUnderstand attr元素XmlSoapGetMustUnderstand  - 获取mustUnderstand at SOAP from SOAP hdr elem XmlSoapSetRole  - 设置SOAP头元素的角色XmlSoapGetRole  - 从SOAP头元素获取角色XmlSoapSetRelay  - 设置中继头元素属性XmlSoapGetRelay  - 获取中继头元素属性XmlSoapSetFault  - 在SOAP消息中设置Fault XmlSoapHasFault  -  SOAP消息是否有故障？XmlSoapGetFault  - 返回故障代码，原因和详细信息XmlSoapAddFaultReason  - 向故障添加其他原因XmlSoapAddFaultSubDetail  - 向故障详细信息添加其他子项XmlSoapGetReasonNum  - 获取故障元素中的原因数XmlSoapGetReasonLang  - 获取具有特定iindex的原因。XmlSoapError  - 获取错误消息* / #ifndef XMLSOAP_ORACLE #define XMLSOAP_ORACLE #ifndef XML_ORACLE #include &lt;xml.h&gt; #endif / * -------------------- -------------------------------------------------- -----包SOAP  - 简单对象访问协议API W3C：“SOAP是一种轻量级协议，用于在分散的分布式环境中交换信息。它是一个基于XML的协议，由三部分组成：一个信封，用于定义用于描述消息中的内容以及如何处理消息的框架，一组用于表示应用程序定义的数据类型实例的编码规则，以及一个用于表示的约定远程过程调用和响应。“仅在Soap 1.1中允许附件在Soap 1.2中，如果存在Fault，则可能没有其他元素。SOAP消息的结构：[SOAP消息（XML文档）[SOAP信封[SOAP标头？element *] [SOAP body（element * | Fault）？]]] ----------------------------------------------- ---------------------------- * / ...</pre></div>
                  <!-- class="example" -->
               </div>
            </div><a id="ADXDK19865"></a><a id="ADXDK19866"></a><a id="ADXDK19864"></a><div class="props_rev_3"><a id="GUID-38829ADC-8292-419D-876E-4C0BB7019CA2" name="GUID-38829ADC-8292-419D-876E-4C0BB7019CA2"></a><h3 id="ADXDK-GUID-38829ADC-8292-419D-876E-4C0BB7019CA2" class="sect3">SOAP示例1：发送XML文档</h3>
               <div>
                  <p>提供了一份XML文件，其中显示了一个旅行公司要求在从纽约到洛杉矶的约翰史密斯的飞机上预订的请求。一个简单的示例创建XML文档，发送，接收和分解回复。有一些最小的错误检查。</p>
                  <p>显示<code class="codeph">DEBUG</code>选项用于纠正异常。该程序可能无法在所有操作系统上运行。要发送此XML文档，第一个客户端C程序遵循以下步骤：</p>
                  <ol>
                     <li>
                        <p>在声明变量后<code class="codeph">main()</code> ，XML上下文， <code class="codeph">xctx</code>中，使用创建<code class="codeph">XmlCreate()</code>然后将上下文用于创建SOAP上下文， <code class="codeph">ctx</code> ，使用<code class="codeph">XmlSoapCreateCtx()</code>
                        </p>
                     </li>
                     <li>
                        <p>要构造消息， <code class="codeph">XmlSoapCreateMsg()</code>并返回空SOAP消息。
                        </p>
                     </li>
                     <li>
                        <p>使用<code class="codeph">XmlSoapAddHeaderElement()</code> ， <code class="codeph">XmlSoapSetRole()</code> ， <code class="codeph">XmlSoapSetMustUnderstand()</code>和<code class="codeph">XmlDomAddTextElem()</code>构造标头以使用文本填充信封。
                        </p>
                     </li>
                     <li>
                        <p>body元素由<code class="codeph">XmlSoapAddBodyElement()</code> ， <code class="codeph">XmlDomCreateElemNS()</code>和一系列<code class="codeph">XmlDomAddTextElem()</code>调用<code class="codeph">XmlDomAddTextElem()</code> 。然后<code class="codeph">XmlDomAppendChild()</code>完成指定纽约到洛杉矶航班的正文部分。
                        </p>
                     </li>
                     <li>
                        <p>回程航班以类似的方式建造。住宿与另一个<code class="codeph">XmlSoapAddBodyElement()</code>调用一起添加。
                        </p>
                     </li>
                     <li>
                        <p>必须使用<code class="codeph">XmlSoapCreateConnection()</code>创建连接，指定HTTP绑定（现在唯一可用的绑定）和端点URL。</p>
                     </li>
                     <li>
                        <p>函数<code class="codeph">XmlSoapCall()</code>通过与SOAP服务器定义的连接发送消息，然后等待回复。
                        </p>
                     </li>
                     <li>
                        <p>消息回复以另一个SOAP消息的形式返回。这是通过<code class="codeph">XmlSaveDom()</code>和<code class="codeph">XmlSoapHasFault()</code>与<code class="codeph">XmlSoapGetFault()</code>一起使用来检查故障并分析故障。故障被解析为其部分，在此示例中输出。
                        </p>
                     </li>
                     <li>
                        <p>如果没有返回错误，则接着是<code class="codeph">XmlSoapGetBody()</code>以返回信封体。<code class="codeph">XmlSaveDom()</code>完成对返回消息的分析。
                        </p>
                     </li>
                     <li>
                        <p>要清理，使用<code class="codeph">XmlSoapDestroyMsg()</code>上的消息和回复， <code class="codeph">XmlDestroyCtx()</code>摧毁SOAP上下文， <code class="codeph">XmlDestroy()</code>来破坏XML上下文。
                        </p>
                     </li>
                  </ol>
                  <div class="example" id="GUID-38829ADC-8292-419D-876E-4C0BB7019CA2__GUID-E9CD8429-D166-439B-9101-9D5786426A4A">
                     <p class="titleinexample">例9-4示例1 SOAP消息</p><pre class="pre codeblock"><code>&lt;？xml版本='1.0'？&gt; &lt;env：Envelope xmlns：env =“http://www.w3.org/2003/05/soap-envelope”&gt; &lt;env：Header&gt; &lt;m：reservation xmlns：m =“http：//travelcompany.example .org / reservation“env：role =”http://www.w3.org/2003/05/soap-envelope/role/next“env：mustUnderstand =”true“&gt; &lt;m：reference&gt; uuid：093a2da1-q345 -739r-ba5d-pqff98fe8j7d &lt;/ m：reference&gt; &lt;m：dateAndTime&gt; 2001-11-29T13：20：00.000-05：00 &lt;/ m：dateAndTime&gt; &lt;/ m：reservation&gt; &lt;n：passenger xmlns：n = “http://mycompany.example.com/employees”env：role =“http://www.w3.org/2003/05/soap-envelope/role/next”env：mustUnderstand =“true”&gt; &lt;n ：name&gt; John Smith &lt;/ n：name&gt; &lt;/ n：passenger&gt; &lt;/ env：Header&gt; &lt;env：Body&gt; &lt;p：itinerary xmlns：p =“http://travelcompany.example.org/reservation/travel “&gt; &lt;p：离境&gt; &lt;p：离开&gt;纽约&lt;/ p：离开&gt; &lt;p：抵达&gt;洛杉矶&lt;/ p：到达&gt; &lt;p：departureDate&gt; 2001-12-14 &lt;/ p：departureDate&gt; &lt; p：departureTime&gt;傍晚&lt;/ p：departureTime&gt; &lt;p：seatPreference&gt; aisle &lt;/ p：seatPreference&gt; &lt;/ p：departure&gt; &lt;p：return&gt; &lt;p：departure&gt;洛杉矶&lt;/ p：departure&gt; &lt;p ：抵达&gt;纽约&lt;/ p：到达ving&gt; &lt;p：departureDate&gt; 2001-12-20 &lt;/ p：departureDate&gt; &lt;p：departureTime&gt;中午&lt;/ p：departureTime&gt; &lt;p：seatPreference /&gt; &lt;/ p：return&gt; &lt;/ p：itinerary&gt; &lt;q：住宿xmlns：q =“http://travelcompany.example.org/reservation/hotels”&gt; &lt;q：偏好&gt;无&lt;/ q：偏好&gt; &lt;/ q：住宿&gt; &lt;/ env：正文&gt; &lt;/ ENV：信封&gt;</code></pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-38829ADC-8292-419D-876E-4C0BB7019CA2__BABEGEGD">
                     <p class="titleinexample">例9-5示例1 SOAP C客户端</p><pre class="pre codeblock"><code>#ifndef S_ORACLE #include &lt;sh&gt; #endif #ifndef XML_ORACLE #include &lt;xml.h&gt; #endif #ifndef XMLSOAP_ORACLE #include &lt;xmlsoap.h&gt; #endif #define MY_URL“http://my_url.com”/ *静态函数声明* / static xmlerr add_ns_decl（xmlsoapctx * ctx，xmlctx * xctx，xmlelemnode * elem，oratext * pfx，oratext * uri）; sb4 main（sword argc，char * argv []）{xmlctx * xctx; xmlerr xerr; xmlsoapctx * ctx; oratext * url; xmlsoapcon * con; xmldocnode * msg1，* reply，* msg2，* msg3; xmlelemnode * res，* pas，* pref，* itin，* departure，* ret，* accommodation; xmlelemnode * departure，* arrival，* trans，* text，* charge，* card，* name; xmlelemnode * body，* header; boolean has_fault; oratext * code，* reason，* lang，* node，* role; xmlelemnode *详细信息; oratext * comp_uri =“http://travelcompany.example.org/”; oratext * mres_uri =“http://travelcompany.example.org/reservation”; oratext * trav_uri =“http://travelcompany.example.org/reservation/travel”; oratext * hotel_uri =“http://travelcompany.example.org/reservation/hotels”; oratext * npas_uri =“http://mycompany.example.com/employees”; oratext * tparty_uri =“http://thirdparty.example.org/transaction”; oratext * estyle_uri =“http://example.com/encoding”; oratext * soap_style_uri =“http://www.w3.org/2003/05/soap-encoding”; oratext * estyle =“env：encodingStyle”; oratext * finance_uri =“http://mycompany.example.com/financial”;如果（！（xctx = XmlCreate（＆xerr，（oratext *）“SOAP_test”，NULL）））{printf（“无法创建XML上下文，错误％u \ n”，（unsigned）xerr）;返回EX_FAIL; } / *创建SOAP上下文* / if（！（ctx = XmlSoapCreateCtx（xctx，＆xerr，（oratext *）“example”，NULL）））{printf（“无法创建SOAP上下文，错误％u \ n”，（unsigned）xerr）;返回EX_FAIL; } / *示例1 * / / *构造消息* / if（！（msg1 = XmlSoapCreateMsg（ctx，＆xerr）））{printf（“创建SOAP消息失败，错误％u \ n”，（无符号）xerr）;返回xerr; } res = XmlSoapAddHeaderElement（ctx，msg1，“m：reservation”，mres_uri，＆xerr）; xerr = XmlSoapSetRole（ctx，res，XMLSOAP_ROLE_NEXT）; xerr = XmlSoapSetMustUnderstand（ctx，res，TRUE）; （void）XmlDomAddTextElem（xctx，res，mres_uri，“m：reference”，“uuid：093a2da1-q345-739r-ba5d-pqff98fe8j7d”）; （void）XmlDomAddTextElem（xctx，res，mres_uri，“m：dateAndTime”，“2001-11-29T13：20：00.000-05：00”）; pas = XmlSoapAddHeaderElement（ctx，msg1，“n：passenger”，npas_uri，＆xerr）; xerr = XmlSoapSetRole（ctx，pas，XMLSOAP_ROLE_NEXT）; xerr = XmlSoapSetMustUnderstand（ctx，pas，TRUE）; （void）XmlDomAddTextElem（xctx，pas，npas_uri，“n：name”，“John Smith”）; / *填充正文* / / *行程* / itin = XmlSoapAddBodyElement（ctx，msg1，“p：itinerary”，trav_uri，＆xerr）; / *出发* /出发= XmlDomCreateElemNS（xctx，msg1，trav_uri，“p：departure”）; （void）XmlDomAddTextElem（xctx，departure，trav_uri，“p：departure”，“New York”）; （void）XmlDomAddTextElem（xctx，departure，trav_uri，“p：arrival”，“Los Angeles”）; （void）XmlDomAddTextElem（xctx，departure，trav_uri，“p：departureDate”，“2001-12-14”）; （void）XmlDomAddTextElem（xctx，departure，trav_uri，“p：departureTime”，“傍晚”）; （void）XmlDomAddTextElem（xctx，departure，trav_uri，“p：seatPreference”，“aisle”）; XmlDomAppendChild（xctx，itin，departure）; / *返回* / ret = XmlDomCreateElemNS（xctx，msg1，trav_uri，“p：return”）; （void）XmlDomAddTextElem（xctx，ret，trav_uri，“p：departure”，“洛杉矶”）; （void）XmlDomAddTextElem（xctx，ret，trav_uri，“p：arrival”，“New York”）; （void）XmlDomAddTextElem（xctx，ret，trav_uri，“p：departureDate”，“2001-12-20”）; （void）XmlDomAddTextElem（xctx，ret，trav_uri，“p：departureTime”，“mid-morning”）; pref = XmlDomCreateElemNS（xctx，msg1，trav_uri，“p：seatPreference”）; （void）XmlDomAppendChild（xctx，ret，pref）; XmlDomAppendChild（xctx，itin，ret）; / *住宿* /住宿= XmlSoapAddBodyElement（ctx，msg1，“q：住宿”，hotel_uri，＆xerr）; （void）XmlDomAddTextElem（xctx，accommodation，hotel_uri，“q：preference”，“none”）; #ifdef DEBUG / *以调试模式转储消息* / printf（“Message：\ n”）; XmlSaveDom（xctx，＆xerr，msg1，“stdio”，stdout，“indent_step”，1，NULL）; #endif / *示例1的结尾* / / *创建连接* / url = MY_URL;如果（！（con = XmlSoapCreateConnection（ctx，＆xerr，XMLSOAP_BIND_HTTP，url，NULL，0，NULL，0，“XTest：baz”，NULL）））{printf（“无法创建SOAP连接，错误％u \ n”，（无符号） XERR）;返回xerr; } reply = XmlSoapCall（ctx，con，msg1，＆xerr）; XmlSoapDestroyConnection（ctx，con）;如果（！回复）{printf（“呼叫失败，没有消息返回。\ n”）;返回xerr; } #ifdef DEBUG printf（“Reply：\ n”）; XmlSaveDom（xctx，＆xerr，reply，“stdio”，stdout，NULL）; #endif printf（“\ n ==== Header：\ n”）; header = XmlSoapGetHeader（ctx，reply，＆xerr）;如果（！header）{printf（“NULL \ n”）; } else XmlSaveDom（xctx，＆xerr，header，“stdio”，stdout，NULL）; / *检查错误* / has_fault = XmlSoapHasFault（ctx，reply，＆xerr）; if（has_fault）{lang = NULL; xerr = XmlSoapGetFault（ctx，reply，＆code，＆reason，＆lang，＆node，＆role，＆detail）; if（xerr）{printf（“error getting Fault％d \ n”，xerr）;返回EX_FAIL; } if（code）printf（“Code  - ％s \ n”，code）; else printf（“NO Code \ n”）; if（reason）printf（“Reason  - ％s \ n”，原因）; else printf（“NO Reason \ n”）; if（lang）printf（“Lang  - ％s \ n”，lang）; else printf（“NO Lang \ n”）; if（node）printf（“Node  - ％s \ n”，node）; else printf（“NO Node \ n”）; if（role）printf（“Role  - ％s \ n”，role）; else printf（“NO Role \ n”）; if（detail）{printf（“Detail \ n”）; XmlSaveDom（xctx，＆xerr，detail，“stdio”，stdout，NULL）;的printf（ “\ n”）; } else printf（“NO Detail \ n”）; } else {body = XmlSoapGetBody（ctx，reply，＆xerr）; printf（“==== Body：\ n”）;如果（！body）{printf（“NULL \ n”）;返回EX_FAIL; XmlSaveDom（xctx，＆xerr，body，“stdio”，stdout，NULL）; }（void）XmlSoapDestroyMsg（ctx，reply）; （void）XmlSoapDestroyMsg（ctx，msg1）; （void）XmlSoapDestroyCtx（ctx）; XmlDestroy（xctx）; }</code></pre></div>
                  <!-- class="example" -->
               </div>
            </div><a id="ADXDK19868"></a><a id="ADXDK19869"></a><a id="ADXDK19867"></a><div class="props_rev_3"><a id="GUID-6313E920-EAE2-43AF-AB90-866CA58A100C" name="GUID-6313E920-EAE2-43AF-AB90-866CA58A100C"></a><h3 id="ADXDK-GUID-6313E920-EAE2-43AF-AB90-866CA58A100C" class="sect3">SOAP示例2：响应请求澄清</h3>
               <div>
                  <p>一家旅游公司想知道哪位纽约机场的旅行者约翰史密斯将离开：JFK，EWR或LGA。它发送一条响应消息，要求进行此类澄清。</p>
                  <p>要将此XML文档作为SOAP消息发送，请将此代码块替换为以<code class="codeph">/* EXAMPLE 1 */</code>开头的行，并以<a href="using-SOAP-with-XDK.html#GUID-38829ADC-8292-419D-876E-4C0BB7019CA2__BABEGEGD">示例9-5中的</a> <code class="codeph">/* END OF EXAMPLE 1 */</code>结尾</p>
                  <div class="example" id="GUID-6313E920-EAE2-43AF-AB90-866CA58A100C__GUID-77BBA2A6-3005-4837-B9C1-9483C7AF7D1F">
                     <p class="titleinexample">例9-6示例2 SOAP消息</p><pre class="pre codeblock"><code>&lt;？xml版本='1.0'？&gt; &lt;env：Envelope xmlns：env =“http://www.w3.org/2003/05/soap-envelope”&gt; &lt;env：Header&gt; &lt;m：reservation xmlns：m =“http：//travelcompany.example .org / reservation“env：role =”http://www.w3.org/2003/05/soap-envelope/role/next“env：mustUnderstand =”true“&gt; &lt;m：reference&gt; uuid：093a2da1-q345 -739r-ba5d-pqff98fe8j7d &lt;/ m：reference&gt; &lt;m：dateAndTime&gt; 2001-11-29T13：35：00.000-05：00 &lt;/ m：dateAndTime&gt; &lt;/ m：reservation&gt; &lt;n：passenger xmlns：n = “http://mycompany.example.com/employees”env：role =“http://www.w3.org/2003/05/soap-envelope/role/next”env：mustUnderstand =“true”&gt; &lt;n ：name&gt; John Smith &lt;/ n：name&gt; &lt;/ n：passenger&gt; &lt;/ env：Header&gt; &lt;env：Body&gt; &lt;p：itineraryClarification xmlns：p =“http://travelcompany.example.org/reservation/travel “&gt; &lt;p：出发&gt; &lt;p：离开&gt; &lt;p：airportChoices&gt; JFK LGA EWR &lt;/ p：airportChoices&gt; &lt;/ p：departure&gt; &lt;/ p：departure&gt; &lt;p：return&gt; &lt;p：arrival&gt; &lt;p ：airportChoices&gt; JFK LGA EWR &lt;/ p：airportChoices&gt; &lt;/ p：arrival&gt; &lt;/ p：return&gt; &lt;/ p：itineraryClarification&gt; &lt;/ env：Body&gt; &lt;/ env：Envelope&gt;</code></pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-6313E920-EAE2-43AF-AB90-866CA58A100C__GUID-B665E6E0-8400-4647-B2EC-A1630E655CB8">
                     <p class="titleinexample">例9-7示例2 SOAP C客户端</p><pre class="pre codeblock"><code>#define XMLSOAP_MAX_NAME 1024 / *我们需要此函数用于示例2和3 * / static xmlerr add_ns_decl（xmlsoapctx * ctx，xmlctx * xctx，xmlelemnode * elem，oratext * pfx，oratext * uri）{oratext * aq，aqbuf [XMLSOAP_MAX_NAME] ; xmldocnode * doc; oratext * xmlns =“xmlns：”; / *如果没有“xmlns：usersprefix \ 0”的空间则现在失败* / if（（strlen（（char *）pfx）+ strlen（（char *）xmlns））&gt; sizeof（aqbuf））返回EX_FAIL; （void）strcpy（（char *）aqbuf，（char *）xmlns）; strcat（（char *）aqbuf，（char *）pfx）; doc = XmlDomGetOwnerDocument（xctx，elem）; aq = XmlDomSaveString（xctx，doc，aqbuf）; XmlDomSetAttrNS（xctx，elem，uri，aq，uri）;返回XMLERR_OK; } / *示例2 * / / *构造消息* / if（！（msg2 = XmlSoapCreateMsg（ctx，＆xerr）））{printf（“无法创建SOAP消息，错误％u \ n”，（unsigned）xerr）;返回xerr; } res = XmlSoapAddHeaderElement（ctx，msg2，“m：reservation”，mres_uri，＆xerr）; xerr = XmlSoapSetRole（ctx，res，XMLSOAP_ROLE_NEXT）; xerr = XmlSoapSetMustUnderstand（ctx，res，TRUE）; （void）XmlDomAddTextElem（xctx，res，mres_uri，“m：reference”，“uuid：093a2da1-q345-739r-ba5d-pqff98fe8j7d”）; （void）XmlDomAddTextElem（xctx，res，mres_uri，“m：dateAndTime”，“2001-11-29T13：35：00.000-05：00”）; pas = XmlSoapAddHeaderElement（ctx，msg2，“n：passenger”，npas_uri，＆xerr）; xerr = XmlSoapSetRole（ctx，pas，XMLSOAP_ROLE_NEXT）; xerr = XmlSoapSetMustUnderstand（ctx，pas，TRUE）; （void）XmlDomAddTextElem（xctx，pas，npas_uri，“n：name”，“John Smith”）; / *填充正文* / / *行程* / itin = XmlSoapAddBodyElement（ctx，msg2，“p：itineraryClarification”，trav_uri，＆xerr）; / *出发* /出发= XmlDomCreateElemNS（xctx，msg2，trav_uri，“p：departure”）; departure = XmlDomCreateElem（xctx，msg2，“p：departure”）; （void）XmlDomAddTextElem（xctx，departure，trav_uri，“p：airportChoices”，“JFK LGA EWR”）; （void）XmlDomAppendChild（xctx，departure，departure）; XmlDomAppendChild（xctx，itin，departure）; / *返回* / ret = XmlDomCreateElemNS（xctx，msg2，trav_uri，“p：return”）;到达= XmlDomCreateElemNS（xctx，msg2，trav_uri，“p：arrival”）; （void）XmlDomAddTextElem（xctx，arrival，trav_uri，“p：airportChoices”，“JFK LGA EWR”）; XmlDomAppendChild（xctx，ret，arrival）; XmlDomAppendChild（xctx，itin，ret）; #ifdef DEBUG XmlSaveDom（xctx，＆xerr，msg2，“stdio”，stdout，“indent_step”，1，NULL）; ＃万一</code></pre></div>
                  <!-- class="example" -->
               </div>
            </div><a id="ADXDK19871"></a><a id="ADXDK19872"></a><a id="ADXDK19870"></a><div class="props_rev_3"><a id="GUID-C850D49A-2E4F-4F4A-BED4-5B6E3CF7D130" name="GUID-C850D49A-2E4F-4F4A-BED4-5B6E3CF7D130"></a><h3 id="ADXDK-GUID-C850D49A-2E4F-4F4A-BED4-5B6E3CF7D130" class="sect3">SOAP示例3：使用POST</h3>
               <div>
                  <p>示例使用方法<code class="codeph">POST</code>将John Smith的信用卡信息作为XML文档发送。 <code class="codeph">XmlSoapCall()</code>在示例中写入XML消息之前的HTTP标头。
                  </p>
                  <p>C客户端包含此代码块，其替换方式与<a href="using-SOAP-with-XDK.html#GUID-38829ADC-8292-419D-876E-4C0BB7019CA2__BABEGEGD">例9-5中</a>的第二个示例相同：</p>
                  <div class="example" id="GUID-C850D49A-2E4F-4F4A-BED4-5B6E3CF7D130__GUID-58DDA73F-62AB-403A-A4C0-21F992FD6E86">
                     <p class="titleinexample">例9-8示例3 SOAP消息</p><pre class="pre codeblock"><code>POST / Reservations HTTP / 1.0主机：travelcompany.example.org内容类型：application / soap + xml; charset =“utf-8”内容长度：nnnn &lt;？xml版本='1.0'？&gt; &lt;env：Envelope xmlns：env =“http://www.w3.org/2003/05/soap-envelope”&gt; &lt;env：Header&gt; &lt;t：transaction xmlns：t =“http：//thirdparty.example .org / transaction“env：encodingStyle =”http://example.com/encoding“env：mustUnderstand =”true“&gt; 5 &lt;/ t：transaction&gt; &lt;/ env：Header&gt; &lt;env：Body&gt; &lt;m：chargeReservation env：encodingStyle =“http://www.w3.org/2003/05/soap-encoding”xmlns：m =“http://travelcompany.example.org/”&gt; &lt;m：reservation xmlns：m =“http ：//travelcompany.example.org/reservation“&gt; &lt;m：code&gt; FT35ZBQ &lt;/ m：code&gt; &lt;/ m：reservation&gt; &lt;o：creditCard xmlns：o =”http://mycompany.example.com/financial “&gt; &lt;n：name xmlns：n =”http://mycompany.example.com/employees“&gt; John Smith &lt;/ n：name&gt; &lt;o：number&gt; 123456789099999 &lt;/ o：number&gt; &lt;o：expiration&gt; 2005 -02 &lt;/ o：到期&gt; &lt;/ o：creditCard&gt; &lt;/ m：chargeReservation&gt; &lt;/ env：Body&gt; &lt;/ env：Envelope&gt;</code></pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-C850D49A-2E4F-4F4A-BED4-5B6E3CF7D130__GUID-09E4AA70-22BF-473A-AA7F-83743438E9E4">
                     <p class="titleinexample">例9-9示例3 SOAP C客户端</p><pre class="pre codeblock"><code>#define XMLSOAP_MAX_NAME 1024 / *我们需要此函数用于示例2和3 * / static xmlerr add_ns_decl（xmlsoapctx * ctx，xmlctx * xctx，xmlelemnode * elem，oratext * pfx，oratext * uri）{oratext * aq，aqbuf [XMLSOAP_MAX_NAME] ; xmldocnode * doc; oratext * xmlns =“xmlns：”; / *如果没有“xmlns：usersprefix \ 0”的空间则现在失败* / if（（strlen（（char *）pfx）+ strlen（（char *）xmlns））&gt; sizeof（aqbuf））返回EX_FAIL; （void）strcpy（（char *）aqbuf，（char *）xmlns）; strcat（（char *）aqbuf，（char *）pfx）; doc = XmlDomGetOwnerDocument（xctx，elem）; aq = XmlDomSaveString（xctx，doc，aqbuf）; XmlDomSetAttrNS（xctx，elem，uri，aq，uri）;返回XMLERR_OK; } / *例3 * / if（！（msg3 = XmlSoapCreateMsg（ctx，＆xerr）））{printf（“无法创建SOAP消息，错误％u \ n”，（unsigned）xerr）;返回xerr; } trans = XmlSoapAddHeaderElement（ctx，msg3，“t：transaction”，tparty_uri，＆xerr）; xerr = XmlSoapSetMustUnderstand（ctx，trans，TRUE）; XmlDomSetAttr（xctx，trans，estyle，estyle_uri）; text = XmlDomCreateText（xctx，msg3，“5”）; XmlDomAppendChild（xctx，trans，text）; / *填充正文* / / *费用预订* / charge = XmlSoapAddBodyElement（ctx，msg3，“m：chargeReservation”，comp_uri，＆xerr）; XmlDomSetAttr（xctx，charge，estyle，soap_style_uri）; res = XmlDomCreateElemNS（xctx，msg3，mres_uri，“m：reservation”）; if（add_ns_decl（ctx，xctx，res，“m”，mres_uri））返回EX_FAIL; （void）XmlDomAddTextElem（xctx，res，mres_uri，“m：code”，“FT35ZBQ”）; （void）XmlDomAppendChild（xctx，charge，res）; / *使用命名空间创建卡片elem * / card = XmlDomCreateElemNS（xctx，msg3，finance_uri，“o：creditCard”）; if（add_ns_decl（ctx，xctx，card，“o”，finance_uri））返回EX_FAIL; name = XmlDomAddTextElem（xctx，card，npas_uri，“n：name”，“John Smith”）; / *添加命名空间* / if（add_ns_decl（ctx，xctx，name，“n”，npas_uri））返回EX_FAIL; （void）XmlDomAddTextElem（xctx，card，finance_uri，“o：number”，“123456789099999”）; （void）XmlDomAddTextElem（xctx，card，finance_uri，“o：expiration”，“2005-02”）; （void）XmlDomAppendChild（xctx，charge，card）; #ifdef DEBUG XmlSaveDom（xctx，＆xerr，msg3，“stdio”，stdout，“indent_step”，1，NULL）; ＃万一</code></pre></div>
                  <!-- class="example" -->
               </div>
            </div>
         </div>
      </article>
   </body>
</html>