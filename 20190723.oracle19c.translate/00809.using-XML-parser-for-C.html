<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <meta name="abstract" content="An explanation is given of how to use the Extensible Markup Language (XML) parser for C."></meta>
      <meta name="description" content="An explanation is given of how to use the Extensible Markup Language (XML) parser for C."></meta>
      <title>使用XML Parser for C</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Programmer&#39;s Guide"></meta>
      <meta property="og:description" content="An explanation is given of how to use the Extensible Markup Language (XML) parser for C."></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Programmer&#39;s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="xml-developers-kit-programmers-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-11T05:58:48-08:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="2001, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96292-01"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="using-XSLT-and-XVM-processors-for-C.html" title="Previous" type="text/html"></link>
      <link rel="next" href="using-binary-XML-with-C.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="XML Developers Kit Programmers Guide"></meta>
    <meta name="dcterms.isVersionOf" content="ADXDK"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="using-XSLT-and-XVM-processors-for-C.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="using-binary-XML-with-C.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">程序员指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="XDK-for-C.html" property="item" typeof="WebPage"><span property="name">适用于C的Oracle XML Developer's Kit</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">使用XML Parser for C</li>
            </ol>
            <a id="GUID-6A39885C-865B-4386-B49C-1FBAB09529C6" name="GUID-6A39885C-865B-4386-B49C-1FBAB09529C6"></a><a id="ADXDK1035"></a><a id="ADXDK1400"></a>
            
            <h2 id="ADXDK-GUID-6A39885C-865B-4386-B49C-1FBAB09529C6" class="sect2"><span class="enumeration_chapter">5</span>使用XML Parser for C</h2>
         </header>
         <div class="ind">
            <div>
               <p>解释了如何为C使用可扩展标记语言（XML）解析器。</p>
               <div class="section"></div>
               <!-- class="section" -->
            </div><a id="ADXDK1036"></a><a id="ADXDK19749"></a><div class="props_rev_3"><a id="GUID-26A982BF-4D33-4C90-8BFA-F227D3C5CE5B" name="GUID-26A982BF-4D33-4C90-8BFA-F227D3C5CE5B"></a><h3 id="ADXDK-GUID-26A982BF-4D33-4C90-8BFA-F227D3C5CE5B" class="sect3">C的XML解析器简介</h3>
               <div>
                  <p>这里的主题包括C语言XML解析器的先决条件和标准。</p>
                  <div class="section"></div>
                  <!-- class="section" -->
                  <div class="section">
                     <div class="infoboxnotealso" id="GUID-26A982BF-4D33-4C90-8BFA-F227D3C5CE5B__GUID-121BFA4D-E639-4F87-B8AC-D5E30303ADCB">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="XML-parsing-for-Java.html#GUID-4BC9CC77-9343-421D-A5A0-9F073961DC75" title="描述了Java的XML解析。">XML解析Java</a>解析使用文档对象模型（DOM）和Simple API for XML（SAX）进行XML解析的一般性介绍。引言中的大部分信息都与语言无关，同样适用于C.</p>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div><a id="ADXDK19750"></a><div class="sect3"><a id="GUID-A2821602-38A1-4613-8DB4-5FEBD5C8027E" name="GUID-A2821602-38A1-4613-8DB4-5FEBD5C8027E"></a><h4 id="ADXDK-GUID-A2821602-38A1-4613-8DB4-5FEBD5C8027E" class="sect4">使用XML Parser for C的先决条件</h4>
                  <div>
                     <p>用于C的Oracle XML解析器读取XML文档并使用DOM或SAX应用程序编程接口（API）来提供对其内容和结构的编程访问。您可以在验证或非验证模式下使用解析器。拉解析器也可用。</p>
                     <p>本章假定您熟悉这些技术：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="glossary.html#GUID-0969F796-24C8-4A02-B671-B2EE8BD49F5B"><span class="xrefglossterm">文档对象模型（DOM）</span></a> 。DOM是XML文档结构的内存树表示。
                           </p>
                        </li>
                        <li>
                           <p><a href="glossary.html#GUID-6B57591D-3889-4BCD-8598-58ED2DC9E9EE"><span class="xrefglossterm">简单的XML API（SAX）</span></a> 。SAX是基于事件的XML解析的标准。
                           </p>
                        </li>
                        <li>
                           <p><a href="using-XML-parser-for-C.html#GUID-C244DBA6-8578-4224-B21D-CD5FF48B0EEC" title="XML Pull Parser是XML Events接口的一个实现。XML Pull Parser和SAX解析器类似，但是使用Pull Parser，应用程序（使用者）驱动事件，而在SAX中，解析器（生产者）驱动事件。">使用XML Pull Parser for C。</a> Pull Parser使用XML事件。
                           </p>
                        </li>
                        <li>
                           <p><a href="glossary.html#GUID-F2AC11F4-F0D2-4EFB-B28B-8114CC0D7C38"><span class="xrefglossterm">文档类型定义（DTD）</span></a> 。XML DTD定义XML文档的合法结构。
                           </p>
                        </li>
                        <li>
                           <p><a href="glossary.html#GUID-25F8F1D2-58B2-4A3F-B38C-3C2652C9C19C"><span class="xrefglossterm">XML Schema</span></a> 。与DTD一样，XML模式定义XML文档的合法结构。
                           </p>
                        </li>
                        <li>
                           <p><a href="glossary.html#GUID-55AB1901-F16B-4FBD-9C2B-7164C71662B0" title="XML文档中的相关元素名称或属性。命名空间语法和用法由W3C建议定义。例如，元素&lt;xsl：apply-templates /&gt;被标识为XSL名称空间的一部分。命名空间在使用之前在XML文档或DTD中声明，使用以下属性语法：xmlns：xsl =" http:="" /="" /www.w3.org="" /tr="" /wd-xs="." =""><span class="xrefglossterm">XML命名空间</span></a> 。命名空间是一种区分元素和属性名称的机制。
                           </p>
                        </li>
                     </ul>
                     <p>如果您需要对上述技术进行一般性介绍，请参阅<a href="preface.html#GUID-2CD1F6B6-C8EC-42E3-97F2-589AABF9AFFB" title="列出了与此文档相关的Oracle资源。">相关文档中</a>列出的XML资源。
                     </p>
                  </div>
               </div><a id="ADXDK19751"></a><div class="props_rev_3"><a id="GUID-80662259-9C17-4F27-A03B-99CC6E1196EB" name="GUID-80662259-9C17-4F27-A03B-99CC6E1196EB"></a><h4 id="ADXDK-GUID-80662259-9C17-4F27-A03B-99CC6E1196EB" class="sect4">用于C的XML解析器的标准和规范</h4>
                  <div>
                     <p>描述了XDK XML解析器的标准和规范。</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>XML 1.0是W3C推荐标准。用于C API的Oracle XML Developer's Kit（XDK）提供对XML 1.0（第二版）的完全支持。</p>
                        </li>
                        <li>
                           <p>DOM Level 1，Level 2和Level 3规范是万维网联盟（W3C）建议。XDK for C API完全支持DOM Level 1和2，但不支持Level 3。</p>
                        </li>
                        <li>
                           <p>SAX适用于1.0版本，已弃用，2.0版本。SAX不是W3C规范。XDK for C API完全支持SAX 1.0和2.0。</p>
                        </li>
                        <li>
                           <p>XML命名空间是W3C推荐标准。</p>
                        </li>
                     </ul>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="XDK-standards.html#GUID-795A483B-12AC-4F6D-A606-6BE9DA963F0F" title="描述了Oracle XML Developer&#39;s Kit（XDK）标准。">Oracle XML Developer的套件标准</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div>
            </div><a id="ADXDK19752"></a><div class="props_rev_3"><a id="GUID-39C29945-6705-46C8-815B-DBBBF5D37C03" name="GUID-39C29945-6705-46C8-815B-DBBBF5D37C03"></a><h3 id="ADXDK-GUID-39C29945-6705-46C8-815B-DBBBF5D37C03" class="sect3">使用C的XML Parser API</h3>
               <div>
                  <p>用于C的Oracle XML解析器检查XML文档是否格式正确，并可选择根据DTD对其进行验证。您的应用程序可以通过DOM或SAX API访问已解析的数据。</p>
               </div><a id="ADXDK19754"></a><a id="ADXDK19753"></a><div class="props_rev_3"><a id="GUID-CDED5CE7-8514-4680-90EE-47C82C4303E8" name="GUID-CDED5CE7-8514-4680-90EE-47C82C4303E8"></a><h4 id="ADXDK-GUID-CDED5CE7-8514-4680-90EE-47C82C4303E8" class="sect4">C的Parser API概述</h4>
                  <div>
                     <p>XML解析API的核心是XML，DOM和SAX API。</p>
                     <p><a href="using-XML-parser-for-C.html#GUID-CDED5CE7-8514-4680-90EE-47C82C4303E8__CCHEDFAC" title="总结了XML解析器的C API。">表5-1</a>介绍了这些API的接口。有关完整的API文档，请参阅<a href="../caxml/datatypes.html#CAXML00100" target="_blank"><span><cite>Oracle数据库XML C API参考</cite></span></a> 。
                     </p>
                     <div class="tblformalwide" id="GUID-CDED5CE7-8514-4680-90EE-47C82C4303E8__CCHEDFAC">
                        <p class="titleintable">表5-1 XML，DOM和SAX API的接口</p>
                        <table cellpadding="4" cellspacing="0" class="FormalWide" title="XML，DOM和SAX API的接口" width="100%" border="1" summary="Summarizes the C APIs for the XML parser." frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="10%" id="d19652e581">包</th>
                                 <th align="left" valign="bottom" width="62%" id="d19652e584">接口</th>
                                 <th align="left" valign="bottom" width="27%" id="d19652e587">功能名称约定</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="10%" id="d19652e592" headers="d19652e581 ">
                                    <p>XML</p>
                                 </td>
                                 <td align="left" valign="top" width="62%" headers="d19652e592 d19652e584 ">
                                    <p>该包实现了单个<code class="codeph">XML</code>接口。该接口定义了这些任务的功能：</p>
                                    <ul style="list-style-type:disc">
                                       <li>
                                          <p>创建和销毁上下文。顶级XML上下文（ <code class="codeph">xmlctx</code> ）共享协作XML组件之间的公共信息。
                                          </p>
                                       </li>
                                       <li>
                                          <p>创建和解析XML文档和DTD。</p>
                                       </li>
                                    </ul>
                                 </td>
                                 <td align="left" valign="top" width="27%" headers="d19652e592 d19652e587 ">
                                    <p>函数名称以字符串<code class="codeph">Xml</code>开头。
                                    </p>
                                    <p>有关API文档，请参阅<a href="../caxml/package-XmlDiff-API.html#CAXML6192" target="_blank"><span><cite>Oracle数据库XML C API参考</cite></span></a> 。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="10%" id="d19652e626" headers="d19652e581 ">
                                    <p>DOM</p>
                                 </td>
                                 <td align="left" valign="top" width="62%" headers="d19652e626 d19652e584 ">
                                    <p>该包提供对已解析XML的编程访问。该包实现了这些接口：</p>
                                    <ul style="list-style-type:disc">
                                       <li>
                                          <p><code class="codeph">Attr</code>定义了XML属性的get和set函数。
                                          </p>
                                       </li>
                                       <li>
                                          <p><code class="codeph">CharacterData</code>定义用于操纵字符数据的函数。
                                          </p>
                                       </li>
                                       <li>
                                          <p><code class="codeph">Document</code>定义了用于创建XML节点，获取有关XML文档的信息以及为文档设置DTD的功能。
                                          </p>
                                       </li>
                                       <li>
                                          <p><code class="codeph">DocumentType</code>定义了DTD的get函数。
                                          </p>
                                       </li>
                                       <li>
                                          <p><code class="codeph">Element</code>定义XML元素的get和set函数。
                                          </p>
                                       </li>
                                       <li>
                                          <p><code class="codeph">Entity</code>为XML实体定义get函数。
                                          </p>
                                       </li>
                                       <li>
                                          <p><code class="codeph">NamedNodeMap</code>定义了命名节点的get函数。
                                          </p>
                                       </li>
                                       <li>
                                          <p><code class="codeph">Node</code>定义XML节点的get和set函数。
                                          </p>
                                       </li>
                                       <li>
                                          <p><code class="codeph">NodeList</code>定义释放节点列表并从列表中获取节点的函数。
                                          </p>
                                       </li>
                                       <li>
                                          <p><code class="codeph">Notation</code>定义了从节点获取系统和公共ID的函数。
                                          </p>
                                       </li>
                                       <li>
                                          <p><code class="codeph">ProcessingInstruction</code>定义处理指令的get和set函数。
                                          </p>
                                       </li>
                                       <li>
                                          <p><code class="codeph">Text</code>定义了一个将文本节点拆分为两个的函数。
                                          </p>
                                       </li>
                                    </ul>
                                 </td>
                                 <td align="left" valign="top" width="27%" headers="d19652e626 d19652e587 ">
                                    <p>函数名称以字符串<code class="codeph">XmlDom</code> 。
                                    </p>
                                    <p>有关API文档，请参阅<a href="../caxml/package-DOM-API.html#CAXML00300" target="_blank"><span><cite>Oracle数据库XML C API参考</cite></span></a> 。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="10%" id="d19652e709" headers="d19652e581 ">
                                    <p>SAX</p>
                                 </td>
                                 <td align="left" valign="top" width="62%" headers="d19652e709 d19652e584 ">
                                    <p>该包提供对已解析XML的编程访问。该包实现了<code class="codeph">SAX</code>接口，该接口定义了接收SAX事件通知的函数。
                                    </p>
                                 </td>
                                 <td align="left" valign="top" width="27%" headers="d19652e709 d19652e587 ">
                                    <p>函数名称以字符串<code class="codeph">XmlSax</code> 。
                                    </p>
                                    <p>有关API文档，请参阅<a href="../caxml/package-SAX-API.html#CAXML5908" target="_blank"><span><cite>Oracle数据库XML C API参考</cite></span></a> 。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="10%" id="d19652e733" headers="d19652e581 ">
                                    <p>XML Pull Parser</p>
                                 </td>
                                 <td align="left" valign="top" width="62%" headers="d19652e733 d19652e584 ">
                                    <p>XML事件是XML文档的表示，类似于SAX事件，因为文档表示为一系列事件，如开始标记，结束标记，注释等。区别在于SAX事件由解析器（生产者）驱动，XML事件由应用程序（消费者）驱动。</p>
                                 </td>
                                 <td align="left" valign="top" width="27%" headers="d19652e733 d19652e587 ">
                                    <p>函数名称以字符串<code class="codeph">XmlEv</code> 。</p>
                                    <p>有关API文档，请参阅<a href="../caxml/package-Event-API.html#CAXML02000" target="_blank"><span><cite>Oracle数据库XML C API参考</cite></span></a> 。
                                    </p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                  </div><a id="ADXDK19756"></a><a id="ADXDK19755"></a><div class="props_rev_3"><a id="GUID-8D335450-FD8E-483D-974E-5BD5C05E2BB3" name="GUID-8D335450-FD8E-483D-974E-5BD5C05E2BB3"></a><h5 id="ADXDK-GUID-8D335450-FD8E-483D-974E-5BD5C05E2BB3" class="sect5">用于C数据类型的XML解析器</h5>
                     <div>
                        <p>描述了用于C的XML解析器中使用的数据类型。</p>
                        <p>有关XDK for C的完整数据类型列表，请参阅<a href="../caxml/datatypes.html#CAXML00100" target="_blank"><span><cite>Oracle数据库XML C API参考</cite></span></a> 。</p>
                        <div class="tblformal" id="GUID-8D335450-FD8E-483D-974E-5BD5C05E2BB3__G455054">
                           <p class="titleintable">表5-2 C的XML解析器中使用的数据类型</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="用于C的XML解析器中的数据类型" width="100%" border="1" summary="This table describes the data types used in the XML parser for C. Datatype and Description are the column names." frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="17%" id="d19652e850">数据类型</th>
                                    <th align="left" valign="bottom" width="83%" id="d19652e853">描述</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="17%" id="d19652e858" headers="d19652e850 ">
                                       <p><code class="codeph">oratext</code></p>
                                    </td>
                                    <td align="left" valign="top" width="83%" headers="d19652e858 d19652e853 ">
                                       <p>字符串指针</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="17%" id="d19652e866" headers="d19652e850 ">
                                       <p><code class="codeph">xmlctx</code></p>
                                    </td>
                                    <td align="left" valign="top" width="83%" headers="d19652e866 d19652e853 ">
                                       <p>掌握XML上下文</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="17%" id="d19652e874" headers="d19652e850 ">
                                       <p><code class="codeph">xmlsaxcb</code></p>
                                    </td>
                                    <td align="left" valign="top" width="83%" headers="d19652e874 d19652e853 ">
                                       <p>SAX回调结构（仅限SAX）</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="17%" id="d19652e882" headers="d19652e850 ">
                                       <p><code class="codeph">UB4</code></p>
                                    </td>
                                    <td align="left" valign="top" width="83%" headers="d19652e882 d19652e853 ">
                                       <p>32位（或更大）无符号整数</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="17%" id="d19652e890" headers="d19652e850 ">
                                       <p><code class="codeph">UWORD</code></p>
                                    </td>
                                    <td align="left" valign="top" width="83%" headers="d19652e890 d19652e853 ">
                                       <p>原始无符号整数</p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                     </div>
                  </div><a id="ADXDK19757"></a><div class="props_rev_3"><a id="GUID-42B8F527-3013-4896-80EF-624B983BA725" name="GUID-42B8F527-3013-4896-80EF-624B983BA725"></a><h5 id="ADXDK-GUID-42B8F527-3013-4896-80EF-624B983BA725" class="sect5">C默认值的XML解析器</h5>
                     <div>
                        <p>描述了C的XML解析器的默认值。</p>
                        <p>这些是默认值：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>字符集编码是Unicode（UTF-8）的8位编码。如果所有文档都是ASCII，则将编码设置为US-ASCII可提高性能。</p>
                           </li>
                           <li>
                              <p>解析器将消息打印到<code class="codeph">stderr</code>除非提供了错误处理程序。
                              </p>
                           </li>
                           <li>
                              <p>解析器检查输入文档是否格式良好但不是有效性。您可以设置属性“validate”以验证输入。</p>
                              <div class="infoboxnote" id="GUID-42B8F527-3013-4896-80EF-624B983BA725__GUID-8184CEC3-4F19-435D-97AA-FB84D46DC180">
                                 <p class="notep1">注意：</p>
                                 <p>如果仅使用单字节字符集（例如US-ASCII或任何ISO-8859字符集），Oracle建议您显式设置默认编码，以提高性能，而不是使用多字节字符集（如UTF-8）。</p>
                              </div>
                           </li>
                           <li>
                              <p>处理空白时，解析器符合XML 1.0规范，即解析器将所有空白空间报告给应用程序，但指示可以忽略哪个空格。但是，某些应用程序可能更喜欢设置属性“discard-white space”，它会丢弃end-element标记和此start-element标记之间的所有空格。</p>
                           </li>
                        </ul>
                        <div class="infoboxnotealso" id="GUID-42B8F527-3013-4896-80EF-624B983BA725__GUID-0A91D34B-745C-4173-9F04-CF2D34969529">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>适用于DOM，SAX，pull解析器和回调API的<a href="../caxml/package-DOM-API.html#CAXML00300" target="_blank"><span><cite>Oracle Database XML C API参考</cite></span></a> 。</p>
                              </li>
                           </ul>
                        </div>
                     </div>
                  </div>
               </div><a id="ADXDK19759"></a><a id="ADXDK19758"></a><div class="props_rev_3"><a id="GUID-4C2307E5-610E-470C-B1BB-BA81D6D1D9D5" name="GUID-4C2307E5-610E-470C-B1BB-BA81D6D1D9D5"></a><h4 id="ADXDK-GUID-4C2307E5-610E-470C-B1BB-BA81D6D1D9D5" class="sect4">C调用序列的XML解析器</h4>
                  <div>
                     <p>示出了用于C的XML解析器的调用序列。</p>
                     <div class="figure" id="GUID-4C2307E5-610E-470C-B1BB-BA81D6D1D9D5__BABCDCDC">
                        <p class="titleinfigure">图5-1 C调用序列的XML解析器</p><img src="img/adxdk096.gif" width="589" alt="下面是图5-1的描述" title="下面是图5-1的描述" longdesc="img_text/adxdk096.html"><br><a href="img_text/adxdk096.html">“图5-1 C调用序列的XML解析器”的描述</a></div>
                     <!-- class="figure" -->
                  </div>
               </div><a id="ADXDK19760"></a><div class="props_rev_3"><a id="GUID-12636E6D-1E3A-4B2C-941E-FF59196FD7DA" name="GUID-12636E6D-1E3A-4B2C-941E-FF59196FD7DA"></a><h4 id="ADXDK-GUID-12636E6D-1E3A-4B2C-941E-FF59196FD7DA" class="sect4">使用XML Parser for C：Basic Process</h4>
                  <div>
                     <p>描述了使用XML解析器进行C语言的基本过程。</p>
                     <div class="section">
                        <p>在您的应用程序中执行以下步骤</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>使用<code class="codeph">XmlCreate()</code>函数初始化解析过程。以下示例代码片段来自<code class="codeph">DOMNamespace.c</code> ：</span><div><pre class="pre codeblock"><code>xmlctx * xctx; ...xctx = XmlCreate（＆ecode，（oratext *）“namespace_xctx”，NULL）;</code></pre></div>
                        </li>
                        <li class="stepexpand"><span>解析输入项，可以是XML文档或字符串缓冲区。</span><div>
                              <p>如果要使用DOM进行语法分析，请调用<code class="codeph">XmlLoadDom()</code>函数。以下示例代码片段来自<code class="codeph">DOMNamespace.c</code> ：</p><pre class="pre codeblock"><code>xmldocnode * doc; ...doc = XmlLoadDom（xctx，＆ecode，“file”，DOCUMENT，“validate”，TRUE，“discard_whitespace”，TRUE，NULL）;</code></pre><p>如果要使用SAX进行语法分析，请调用<code class="codeph">XmlLoadSax()</code>函数。以下示例代码片段来自<code class="codeph">SAXNamespace.c</code> ：</p><pre class="pre codeblock"><code>xmlerr ecode; ...ecode = XmlLoadSax（xctx，＆sax_callback，＆sc，“file”，DOCUMENT，“validate”，TRUE，“discard_whitespace”，TRUE，NULL）;</code></pre><p>如果您正在使用pull解析器，那么请包含以下步骤来创建事件上下文并加载要解析的文档：</p><pre class="pre codeblock"><code>evctx = XmlEvCreatePPCtx（xctx，＆xerr，NULL）; XmlEvLoadPPDoc（xctx，evctx，“File”，input_filenames [i]，0，NULL）;</code></pre></div>
                        </li>
                        <li class="stepexpand"><span>如果您使用的是DOM接口，请包含以下步骤：</span><div>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>使用<code class="codeph">XmlLoadDom()</code>函数调用<code class="codeph">XmlDomGetDocElem()</code> 。此步骤调用其他DOM函数，这些函数通常是根据需要输出DOM文档的节点或打印函数。以下示例代码片段来自<code class="codeph">DOMNamespace.c</code> ：</p><pre class="pre codeblock"><code>printElements（xctx，XmlDomGetDocElem（xctx，doc））;</code></pre></li>
                                 <li>
                                    <p>调用<code class="codeph">XmlFreeDocument()</code>函数以清除在解析过程中创建的任何数据结构。以下示例代码片段来自<code class="codeph">DOMNamespace.c</code> ：</p><pre class="pre codeblock"><code>XmlFreeDocument（xctx，doc）;</code></pre></li>
                              </ul>
                              <p>如果您使用的是SAX界面，请包含以下步骤：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>使用回调函数处理调用<code class="codeph">XmlLoadSax()</code>的结果，例如：</p><pre class="pre codeblock"><code>xmlsaxcb saxcb = {UserStartDocument，/ *用户自己的回调函数* / UserEndDocument，/ * ...* /}; if（XmlLoadSax（xctx，＆saxcb，NULL，“file”，“some_file.xml”，NULL）！= 0）/ *发生错误* /</code></pre></li>
                                 <li>
                                    <p>注册回调函数。如果不需要，您可以将任何SAX回调函数设置为<code class="codeph">NULL</code> 。
                                    </p>
                                 </li>
                              </ul>
                              <p>如果您正在使用pull解析器，请使用以下方法迭代事件：</p><pre class="pre codeblock"><code>cur_event = XmlEvNext（evctx）;</code></pre><p>使用Get API获取有关该事件的信息。</p>
                           </div>
                        </li>
                        <li class="stepexpand"><span>使用<code class="codeph">XmlFreeDocument()</code>清理解析期间使用的内存和结构。在调用<code class="codeph">XMLFreeDocument()</code>或<code class="codeph">XMLDestroy()</code>之前，程序不释放为传递给SAX回调的参数或者用DOM解析树存储的节点和数据释放的内存。以下示例代码片段来自<code class="codeph">DOMNamespace.c</code> ：</span><div><pre class="pre codeblock"><code>XmlFreeDocument（xctx，doc）;</code></pre><p>返回步骤2或继续下一步。</p>
                              <p>对于pull解析器调用<code class="codeph">XmlEvCleanPPCtx()</code>来释放在解析期间使用的内存和结构。应用程序可以再次调用<code class="codeph">XmlEvLoadPPDoc()</code>来解析另一个文档。或者，它可以调用<code class="codeph">XMLEvDestroyPPCtx()</code>之后不能再次使用pull解析器上下文。
                              </p><pre class="pre codeblock"><code>XmlEvCleanPPCtx（xctx，evctx）; ...XmlEvDestroyPPCtx（xctx，evctx）;</code></pre></div>
                        </li>
                        <li class="stepexpand"><span>使用<code class="codeph">XmlDestroy()</code>终止解析过程。以下示例代码片段来自<code class="codeph">DOMNamespace.c</code> ：</span><div><pre class="pre codeblock"><code>（void）XmlDestroy（xctx）;</code></pre><p>如果线程在初始化和终止之间的调用序列中的某个地方分叉，则应用程序会产生不可预测的行为和结果。</p>
                           </div>
                        </li>
                     </ol>
                     <div class="section">
                        <p>您可以使用内存回调函数<code class="codeph">XML_ALLOC_F</code>和<code class="codeph">XML_FREE_F</code>进行自己的内存分配。如果这样做，则指定两个函数。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="using-XML-parser-for-C.html#GUID-C244DBA6-8578-4224-B21D-CD5FF48B0EEC" title="XML Pull Parser是XML Events接口的一个实现。XML Pull Parser和SAX解析器类似，但是使用Pull Parser，应用程序（使用者）驱动事件，而在SAX中，解析器（生产者）驱动事件。">使用XML Pull Parser for C</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div><a id="ADXDK19762"></a><a id="ADXDK19761"></a><div class="props_rev_3"><a id="GUID-247C9003-4689-447B-94B1-1EAAD497C45C" name="GUID-247C9003-4689-447B-94B1-1EAAD497C45C"></a><h4 id="ADXDK-GUID-247C9003-4689-447B-94B1-1EAAD497C45C" class="sect4">为C演示程序运行XML Parser</h4>
                  <div>
                     <p><code class="codeph">$ORACLE_HOME/xdk/demo/c/</code> （UNIX）和<code class="codeph">%ORACLE_HOME%\xdk\demo\c</code> （Windows）目录包括几个XML应用程序，它们展示了如何使用带有DOM和SAX接口的C语言的XML解析器。
                     </p>
                     <div class="section">
                        <p><a href="using-XML-parser-for-C.html#GUID-247C9003-4689-447B-94B1-1EAAD497C45C__CCHJHGCD" title="描述/ demo / java目录的子目录。">表5-3</a>介绍了演示。
                        </p>
                        <p><code class="codeph">make</code>实用程序编译源文件<span class="italic"><code class="codeph">fileName.c</code></span>以生成演示程序<span class="italic"><code class="codeph">fileName</code></span>和输出文件<span class="italic"><code class="codeph">fileName.out</code></span> 。<span class="italic"><code class="codeph">fileName.std</code></span>是预期的输出。
                        </p>
                        <div class="tblformalwide" id="GUID-247C9003-4689-447B-94B1-1EAAD497C45C__CCHJHGCD">
                           <p class="titleintable">表5-3 C分析器演示</p>
                           <table cellpadding="4" cellspacing="0" class="FormalWide" title="C解析器演示" width="100%" border="1" summary="Describes the subdirectories of the /demo/java directory." frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="10%" id="d19652e1480">目录</th>
                                    <th align="left" valign="bottom" width="16%" id="d19652e1483">内容</th>
                                    <th align="left" valign="bottom" width="74%" id="d19652e1486">演示</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="10%" id="d19652e1491" headers="d19652e1480 ">
                                       <p><code class="codeph">DOM</code></p>
                                    </td>
                                    <td align="left" valign="top" width="16%" headers="d19652e1491 d19652e1483 "><pre class="oac_no_warn" dir="ltr">DOMNamespace.c DOMSample.c FullDom.c FullDom.xml NSExample.xml Traverse.c XPointer.c class.xml cleo.xml pantry.xml</pre></td>
                                    <td align="left" valign="top" width="74%" headers="d19652e1491 d19652e1486 ">
                                       <p>以下演示程序使用DOM API：</p>
                                       <ul style="list-style-type:disc">
                                          <li>
                                             <p><code class="codeph">DOMNamespace</code>程序使用DOM API的Namespace扩展。它打印出<code class="codeph">NSExample.xml</code>所有元素和属性以及完整的命名空间信息。
                                             </p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">DOMSample</code>程序使用DOM API来显示<span class="italic">Cleopatra</span>的轮廓，即XML元素<code class="codeph">ACT</code>和<code class="codeph">SCENE</code> 。 <code class="codeph">cleo.xml</code>文档包含莎士比亚的<span class="italic">“悲剧的安东尼和克利奥帕特拉”</span>的XML版本。
                                             </p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">FullDom</code>程序显示完整DOM接口的示例用法。它会执行所有调用。该程序接受<code class="codeph">FullDom.xml</code> ，它显示实体的使用，作为输入。
                                             </p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">Traverse</code>程序显示了DOM迭代器，树步行器和范围的使用。该程序接受<code class="codeph">class.xml</code>文档，该文档描述了大学微积分课程作为输入。
                                             </p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">XPointer</code>程序通过在<code class="codeph">pantry.xml</code>定位<code class="codeph">&lt;pantry&gt;</code> <code class="codeph">pantry.xml</code> <code class="codeph">&lt;pantry&gt;</code>元素的子元素来显示XML指针语言的使用。
                                             </p>
                                          </li>
                                       </ul>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="10%" id="d19652e1564" headers="d19652e1480 ">
                                       <p><code class="codeph">萨克斯</code></p>
                                    </td>
                                    <td align="left" valign="top" width="16%" headers="d19652e1564 d19652e1483 "><pre class="oac_no_warn" dir="ltr">NSExample.xml SAXNamespace.c SAXSample.c cleo.xml</pre></td>
                                    <td align="left" valign="top" width="74%" headers="d19652e1564 d19652e1486 ">
                                       <p>以下演示程序使用SAX API：</p>
                                       <ul style="list-style-type:disc">
                                          <li>
                                             <p><code class="codeph">SAXNamespace</code>程序使用SAX API的命名空间扩展。它打印出<code class="codeph">NSExample.xml</code>所有元素和属性以及完整的命名空间信息。
                                             </p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">SAXSample</code>程序使用SAX API显示包含给定单词的游戏<span class="italic">Cleopatra</span>中的所有行。如果您没有指定单词，则使用“死亡”一词。 <code class="codeph">cleo.xml</code>文档包含莎士比亚的<span class="italic">“悲剧的安东尼和克利奥帕特拉”</span>的XML版本。
                                             </p>
                                          </li>
                                       </ul>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <p>您可以在同一目录中找到描述如何在<code class="codeph">README</code>中编译和运行示例程序的文档。基本步骤是：</p>
                        <ol>
                           <li>
                              <p>转到<code class="codeph">$ORACLE_HOME/xdk/demo/c</code>目录（UNIX）或<code class="codeph">%ORACLE_HOME%\xdk\demo\c</code>目录（Windows）。
                              </p>
                           </li>
                           <li>
                              <p>确保按照<a href="getting-started-with-XDK-for-C.html#GUID-8BCD12B3-3D56-4F00-8C2E-B46AA6A428B7" title="描述了与XDK for C组件一起使用所需的UNIX环境变量。">在UNIX</a> <a href="getting-started-with-XDK-for-C.html#GUID-C64E22E0-7FAE-4409-8A04-758F4458F0D9" title="The Windows environment variables required for use with the XDK for C components are described.">上为C环境变量设置XDK</a>和<a href="getting-started-with-XDK-for-C.html#GUID-C64E22E0-7FAE-4409-8A04-758F4458F0D9" title="描述了与XDK for C组件一起使用所需的Windows环境变量。">在Windows上为C环境变量设置XDK中所述设置环境变量</a> 。
                              </p>
                           </li>
                           <li>
                              <p>在系统提示符下运行<code class="codeph">make</code> （UNIX）或<code class="codeph">Make.bat</code> （Windows）。<code class="codeph">make</code>实用程序更改为每个demo子目录并运行<code class="codeph">make</code>来执行此操作：</p>
                              <ol type="a">
                                 <li>
                                    <p>使用<code class="codeph">cc</code>实用程序编译C源文件。例如， <code class="codeph">$ORACLE_HOME/xdk/demo/c/dom</code>目录中的<code class="codeph">Makefile</code>包含以下行：</p><pre class="oac_no_warn" dir="ltr">$（CC）-o DOMSample $（INCLUDE）$ @。c $（LIB）</pre></li>
                                 <li>
                                    <p>运行每个演示程序并将输出重定向到文件。例如， <code class="codeph">$ORACLE_HOME/xdk/demo/c/dom</code>目录中的<code class="codeph">Makefile</code>包含以下行：</p><pre class="oac_no_warn" dir="ltr">。/ DOMSample&gt; DOMSample.out</pre></li>
                              </ol>
                           </li>
                           <li>
                              <p>将<code class="codeph">*.std</code>文件与每个程序的<code class="codeph">*.out</code>文件进行比较。<code class="codeph">*.std</code>文件包含每个程序的预期输出。例如， <code class="codeph">DOMSample.std</code>包含运行<code class="codeph">DOMSample</code>的预期输出。
                              </p>
                           </li>
                        </ol>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ADXDK19764"></a><a id="ADXDK19763"></a><div class="props_rev_3"><a id="GUID-D7F8125B-A91C-41FA-A75E-5B9E0C620645" name="GUID-D7F8125B-A91C-41FA-A75E-5B9E0C620645"></a><h4 id="ADXDK-GUID-D7F8125B-A91C-41FA-A75E-5B9E0C620645" class="sect4">使用C XML Parser命令行实用程序</h4>
                  <div>
                     <p><code class="codeph">xml</code>实用程序位于<code class="codeph">$ORACLE_HOME/bin</code> （UNIX）或<code class="codeph">%ORACLE_HOME%\bin</code> （Windows）中，是一个解析XML文档的命令行界面。它检查结构良好和有效性。
                     </p>
                     <div class="section">
                        <p>要使用<code class="codeph">xml</code> ，请确保按照<a href="getting-started-with-XDK-for-C.html#GUID-8BCD12B3-3D56-4F00-8C2E-B46AA6A428B7" title="描述了与XDK for C组件一起使用所需的UNIX环境变量。">在UNIX</a> <a href="getting-started-with-XDK-for-C.html#GUID-C64E22E0-7FAE-4409-8A04-758F4458F0D9" title="The Windows environment variables required for use with the XDK for C components are described.">上为C环境变量设置XDK</a>和<a href="getting-started-with-XDK-for-C.html#GUID-C64E22E0-7FAE-4409-8A04-758F4458F0D9" title="描述了与XDK for C组件一起使用所需的Windows环境变量。">在Windows上为C环境变量设置XDK中所述设置环境</a> 。
                        </p>
                        <p>在命令行上使用此语法来调用<code class="codeph">xml</code> 。使用<code class="codeph">xml.exe</code> for Windows：</p><pre class="oac_no_warn" dir="ltr">xml [options] [document URI] xml -f [options] [document filespec]</pre><p><a href="using-XML-parser-for-C.html#GUID-D7F8125B-A91C-41FA-A75E-5B9E0C620645__G1016893" title="此表描述命令行选项。选项和描述是列。">表5-4说明</a>了命令行选项。
                        </p>
                        <div class="tblformal" id="GUID-D7F8125B-A91C-41FA-A75E-5B9E0C620645__G1016893">
                           <p class="titleintable">表5-4 C XML Parser命令行选项</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="C XML Parser命令行选项" width="100%" border="1" summary="This table describes the command-line options. Option and Description are the columns." frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="26%" id="d19652e1821">选项</th>
                                    <th align="left" valign="bottom" width="74%" id="d19652e1824">描述</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="26%" id="d19652e1829" headers="d19652e1821 ">
                                       <p><code class="codeph">-B</code> BaseURI</p>
                                    </td>
                                    <td align="left" valign="top" width="74%" headers="d19652e1829 d19652e1824 ">
                                       <p>设置XSLT处理器的基URI。碱的URI <code class="codeph">http://pqr/xsl.txt</code>解析<code class="codeph">pqr.txt</code>到<code class="codeph">http://pqr/pqr.txt</code> 。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="26%" id="d19652e1847" headers="d19652e1821 ">
                                       <p><code class="codeph">-C</code></p>
                                    </td>
                                    <td align="left" valign="top" width="74%" headers="d19652e1847 d19652e1824 ">
                                       <p>检查格式良好，但不执行验证。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="26%" id="d19652e1855" headers="d19652e1821 ">
                                       <p><code class="codeph">-e</code> <span class="italic"><code class="codeph">encoding</code></span></p>
                                    </td>
                                    <td align="left" valign="top" width="74%" headers="d19652e1855 d19652e1824 ">
                                       <p>指定默认输入文件编码（“incoding”）。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="26%" id="d19652e1866" headers="d19652e1821 ">
                                       <p><code class="codeph">-E</code> <span class="italic"><code class="codeph">encoding</code></span> 
                                       </p>
                                    </td>
                                    <td align="left" valign="top" width="74%" headers="d19652e1866 d19652e1824 ">
                                       <p>指定DOM / SAX编码（“outcoding”）。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="26%" id="d19652e1879" headers="d19652e1821 ">
                                       <p><code class="codeph">-f</code> <span class="italic"><code class="codeph">file</code></span></p>
                                    </td>
                                    <td align="left" valign="top" width="74%" headers="d19652e1879 d19652e1824 ">
                                       <p>将文件解释为filespec，而不是URI。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="26%" id="d19652e1891" headers="d19652e1821 ">
                                       <p><code class="codeph">-G</code> <span class="italic"><code class="codeph">xptr_exprs</code></span></p>
                                    </td>
                                    <td align="left" valign="top" width="74%" headers="d19652e1891 d19652e1824 ">
                                       <p>评估文件中给出的<code class="codeph">XPointer</code>方案示例。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="26%" id="d19652e1906" headers="d19652e1821 ">
                                       <p><code class="codeph">-H</code></p>
                                    </td>
                                    <td align="left" valign="top" width="74%" headers="d19652e1906 d19652e1824 ">
                                       <p>显示使用帮助和命令行选项的基本列表。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="26%" id="d19652e1914" headers="d19652e1821 ">
                                       <p><code class="codeph">-hh</code></p>
                                    </td>
                                    <td align="left" valign="top" width="74%" headers="d19652e1914 d19652e1824 ">
                                       <p>显示完整的列表命令行选项。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="26%" id="d19652e1922" headers="d19652e1821 ">
                                       <p><code class="codeph">-i</code> <span class="italic"><code class="codeph">n</code></span></p>
                                    </td>
                                    <td align="left" valign="top" width="74%" headers="d19652e1922 d19652e1824 ">
                                       <p>指定迭代<code class="codeph">XSLT</code>处理的次数。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="26%" id="d19652e1936" headers="d19652e1821 ">
                                       <p><code class="codeph">-l</code> <span class="italic"><code class="codeph">language</code></span></p>
                                    </td>
                                    <td align="left" valign="top" width="74%" headers="d19652e1936 d19652e1824 ">
                                       <p>指定错误报告的语言。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="26%" id="d19652e1948" headers="d19652e1821 ">
                                       <p><code class="codeph">-n</code></p>
                                    </td>
                                    <td align="left" valign="top" width="74%" headers="d19652e1948 d19652e1824 ">
                                       <p>遍历DOM并报告元素数量，如此示例输出中所示：</p><pre class="oac_no_warn" dir="ltr">ELEMENT 1 PCDATA 1 DOC 1 TOTAL 3 * 60 = 180</pre></td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="26%" id="d19652e1959" headers="d19652e1821 ">
                                       <p><code class="codeph">-o</code> <span class="italic"><code class="codeph">XSLoutfile</code></span></p>
                                    </td>
                                    <td align="left" valign="top" width="74%" headers="d19652e1959 d19652e1824 ">
                                       <p>指定<code class="codeph">XSLT</code>处理器的输出文件。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="26%" id="d19652e1973" headers="d19652e1821 ">
                                       <p><code class="codeph">-p</code></p>
                                    </td>
                                    <td align="left" valign="top" width="74%" headers="d19652e1973 d19652e1824 ">
                                       <p>在解析后打印文档/ DTD结构。例如，根元素<code class="codeph">&lt;greeting&gt;hello&lt;/greeting&gt;</code>打印为：</p><pre class="oac_no_warn" dir="ltr">+ --- ELEMENT greeting + --- PCDATA“你好”</pre></td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="26%" id="d19652e1986" headers="d19652e1821 ">
                                       <p><code class="codeph">-P</code></p>
                                    </td>
                                    <td align="left" valign="top" width="74%" headers="d19652e1986 d19652e1824 ">
                                       <p>从根元素打印文档。例如，根元素<code class="codeph">&lt;greeting&gt;hello&lt;/greeting&gt;</code>打印为：</p><pre class="oac_no_warn" dir="ltr">&lt;问候&gt;你好&lt;/问候&gt;</pre></td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="26%" id="d19652e1999" headers="d19652e1821 ">
                                       <p><code class="codeph">-PP</code></p>
                                    </td>
                                    <td align="left" valign="top" width="74%" headers="d19652e1999 d19652e1824 ">
                                       <p>从根节点（DOC）打印并包含XML声明。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="26%" id="d19652e2007" headers="d19652e1821 ">
                                       <p><span class="italic"><code class="codeph">-PE编码</code></span></p>
                                    </td>
                                    <td align="left" valign="top" width="74%" headers="d19652e2007 d19652e1824 ">
                                       <p>指定<code class="codeph">-P</code>或<code class="codeph">-PP</code>输出的编码。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="26%" id="d19652e2022" headers="d19652e1821 ">
                                       <p><code class="codeph">-PX</code></p>
                                    </td>
                                    <td align="left" valign="top" width="74%" headers="d19652e2022 d19652e1824 ">
                                       <p>在输出中包含XML声明。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="26%" id="d19652e2030" headers="d19652e1821 ">
                                       <p><code class="codeph">-s</code> <span class="italic"><code class="codeph">stylesheet</code></span></p>
                                    </td>
                                    <td align="left" valign="top" width="74%" headers="d19652e2030 d19652e1824 ">
                                       <p>指定<code class="codeph">XSLT</code>样式表。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="26%" id="d19652e2044" headers="d19652e1821 ">
                                       <p><code class="codeph">-v</code></p>
                                    </td>
                                    <td align="left" valign="top" width="74%" headers="d19652e2044 d19652e1824 ">
                                       <p>显示XDK解析器版本，然后退出。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="26%" id="d19652e2052" headers="d19652e1821 ">
                                       <p><code class="codeph">-V</code> <span class="italic"><code class="codeph">var value</code></span></p>
                                    </td>
                                    <td align="left" valign="top" width="74%" headers="d19652e2052 d19652e1824 ">
                                       <p>测试<code class="codeph">CXSLT</code>顶级变量。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="26%" id="d19652e2066" headers="d19652e1821 ">
                                       <p><code class="codeph">-w</code></p>
                                    </td>
                                    <td align="left" valign="top" width="74%" headers="d19652e2066 d19652e1824 ">
                                       <p>保留所有空白区域。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="26%" id="d19652e2074" headers="d19652e1821 ">
                                       <p><code class="codeph">-W</code></p>
                                    </td>
                                    <td align="left" valign="top" width="74%" headers="d19652e2074 d19652e1824 ">
                                       <p>警告后停止解析。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="26%" id="d19652e2083" headers="d19652e1821 ">
                                       <p><code class="codeph">-X</code></p>
                                    </td>
                                    <td align="left" valign="top" width="74%" headers="d19652e2083 d19652e1824 ">
                                       <p>练习SAX界面并打印文档，如以下示例输出所示：</p><pre class="oac_no_warn" dir="ltr">StartDocument XMLDECL version ='1.0'encoding = FALSE &lt;greeting&gt;“hello”&lt;/ greeting&gt; EndDocument</pre></td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                     </div>
                     <!-- class="section" -->
                  </div><a id="ADXDK19766"></a><a id="ADXDK19767"></a><a id="ADXDK19765"></a><div class="props_rev_3"><a id="GUID-60CB9C7B-A2E9-4BAC-8A3C-9591230C9445" name="GUID-60CB9C7B-A2E9-4BAC-8A3C-9591230C9445"></a><h5 id="ADXDK-GUID-60CB9C7B-A2E9-4BAC-8A3C-9591230C9445" class="sect5">使用XML Parser命令行实用程序：示例</h5>
                     <div>
                        <p>您可以使用位于<code class="codeph">$ORACLE_HOME/xdk/demo/c</code>的各种XML文件来测试<code class="codeph">xml</code>文档。
                        </p>
                        <div class="section">
                           <p> <a href="using-XML-parser-for-C.html#GUID-60CB9C7B-A2E9-4BAC-8A3C-9591230C9445__BGBFHECI">例5-1</a>显示了<code class="codeph">NSExample.xml</code>的内容。
                           </p>
                           <p>您可以解析此文件，计算元素数量，并显示DOM树，如下例所示：</p><pre class="pre codeblock"><code>xml -np NSEample.xml&gt; xml.out</code></pre><p><a href="using-XML-parser-for-C.html#GUID-60CB9C7B-A2E9-4BAC-8A3C-9591230C9445__GUID-D6CBD9FF-F2C6-452A-9C86-BA2C70A5973D">例5-2</a>显示了输出。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-60CB9C7B-A2E9-4BAC-8A3C-9591230C9445__BGBFHECI">
                           <p class="titleinexample">例5-1 NSExample.xml</p><pre class="pre codeblock"><code>&lt;！DOCTYPE doc [&lt;！ELEMENT doc（孩子*）&gt; &lt;！ATTLIST doc xmlns：nsprefix CDATA #IMPLIED&gt; &lt;！ATTLIST doc xmlns CDATA #IMPLIED&gt; &lt;！ATTLIST doc nsfix：a1 CDATA #IMPLIED&gt; &lt;！ELEMENT子（#PCDATA）&gt;]&gt; &lt;doc nsprefix：a1 =“v1”xmlns =“http://www.w3c.org”xmlns：nsprefix =“http://www.oracle.com”&gt; &lt;child&gt;此元素继承doc的默认命名空间。&lt;/ child&gt; &lt;/ doc&gt;</code></pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-60CB9C7B-A2E9-4BAC-8A3C-9591230C9445__GUID-D6CBD9FF-F2C6-452A-9C86-BA2C70A5973D">
                           <p class="titleinexample">例5-2 xml.out</p><pre class="pre codeblock"><code>ELEMENT 2 PCDATA 1 DOC 1 DTD 1 ELEMDECL 2 ATTRDECL 3 TOTAL 10 * 112 = 1120 + --- ELEMENT doc [nsprefix：a1 ='v1'*，xmlns ='http：//www.w3c.org'*,xmlns ：nsprefix ='http：//www.oracle.com'*] + --- ELEMENT child + --- PCDATA“此元素继承了doc的默认命名空间。“</code></pre></div>
                        <!-- class="example" -->
                     </div>
                  </div>
               </div>
            </div><a id="ADXDK1037"></a><a id="ADXDK19768"></a><div class="props_rev_3"><a id="GUID-0C749FC8-C0B3-41AF-9382-82F0E4FC3BEF" name="GUID-0C749FC8-C0B3-41AF-9382-82F0E4FC3BEF"></a><h3 id="ADXDK-GUID-0C749FC8-C0B3-41AF-9382-82F0E4FC3BEF" class="sect3">使用DOM API for C</h3>
               <div>
                  <p>这里的主题包括控制XML文档的编码，使用NULL终止和长度编码的函数，以及处理错误。</p>
                  <div class="section"></div>
                  <!-- class="section" -->
               </div><a id="ADXDK19769"></a><div class="props_rev_3"><a id="GUID-8C9F7915-889D-417F-8E6A-3118AD8C883B" name="GUID-8C9F7915-889D-417F-8E6A-3118AD8C883B"></a><h4 id="ADXDK-GUID-8C9F7915-889D-417F-8E6A-3118AD8C883B" class="sect4">控制C API的XML文档的数据编码</h4>
                  <div>
                     <p>XML数据以许多编码形式出现。您可以通过各种方式控制XML编码。</p>
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p>为非自描述文件指定默认编码</p>
                           </li>
                           <li>
                              <p>指定DOM或SAX的表示编码</p>
                           </li>
                           <li>
                              <p>在序列化DOM时重新编码</p>
                           </li>
                        </ul>
                        <p>输入XML数据始终是编码的。某些编码完全是自描述的，例如Unicode（UTF-16）的16位编码，它需要在实际数据开始之前使用特定的字节顺序标记（BOM）。<code class="codeph">XMLDecl</code>或多用途Internet邮件扩展（MIME）标头也可以指定编码。如果应用程序无法确定特定编码，则它应用默认输入编码。如果您未提供默认值，则应用程序在ASCII平台上采用UTF-8，在EBCDIC平台上采用UTF-EBCDIC。
                        </p>
                        <p>API为输入文档的编码数据损坏时的情况提供了条件。例如，假设具有<code class="codeph">encoding=ascii</code>的<code class="codeph">XMLDecl</code>的ASCII文档被盲目地转换为EBCDIC。新的EBCDIC文档包含（在EBCDIC中）一个错误地声称该文档是ASCII的<code class="codeph">XMLDecl</code> 。重新编码XML数据的程序的正确行为是重新生成但不转换<code class="codeph">XMLDecl</code> 。<code class="codeph">XMLDecl</code>是元数据，而不是数据本身。但是，此规则通常会被忽略，从而导致文档损坏。为了解决这个问题，API提供了一个额外的标志，使您能够强制设置输入编码，从而克服不正确的<code class="codeph">XMLDecl</code> 。
                        </p>
                        <p>确定输入编码的优先规则是：</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>用户指定的强制编码</span><div>
                              <div class="infoboxnote" id="GUID-8C9F7915-889D-417F-8E6A-3118AD8C883B__GUID-6E34C31E-0805-4430-B307-A0C0686AA8CC">
                                 <p class="notep1">注意：</p>
                                 <p>如果存在冲突，强制编码可能会导致致命错误。例如，输入文档是UTF-16并以UTF-16 BOM开头，但用户指定强制UTF-8编码。在这种情况下，解析器会对冲突进行对象。</p>
                              </div>
                           </div>
                        </li>
                        <li class="stepexpand"><span>协议规范（HTTP标头等）</span></li>
                        <li class="stepexpand"><span><code class="codeph">XMLDecl</code>规范</span></li>
                        <li class="stepexpand"><span>用户的默认输入编码</span></li>
                        <li class="stepexpand"><span>默认值，即ASCII平台上的UTF-8或EBCDIC平台上的UTF-E</span></li>
                     </ol>
                     <div class="section">
                        <p>应用程序确定输入编码后，它可以解析文档并显示数据。您可以选择演示文稿编码;无论原始输入编码如何，数据都处于该编码状态。</p>
                        <p>当应用程序以序列化形式回写DOM时，它可以选择在那时重新编码表示数据。因此，您可以将序列化文档放在任何编码中。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ADXDK19771"></a><a id="ADXDK19770"></a><div class="props_rev_3"><a id="GUID-ABFE98DC-EB47-4733-BF8F-C3371FA30646" name="GUID-ABFE98DC-EB47-4733-BF8F-C3371FA30646"></a><h4 id="ADXDK-GUID-ABFE98DC-EB47-4733-BF8F-C3371FA30646" class="sect4">使用NULL终止和长度编码的C API函数</h4>
                  <div>
                     <p>C中的本机字符串表示以null结尾。因此，主DOM接口接受并返回以null结尾的字符串。但是，以表格形式存储时，Oracle XML DB数据<span class="italic">不是以</span>空值终止的，而是经过<span class="italic">长度编码的</span> 。因此，XDK为高频情况提供了一组额外的长度编码API，以提高性能。
                     </p>
                     <p>特别是， <a href="using-XML-parser-for-C.html#GUID-ABFE98DC-EB47-4733-BF8F-C3371FA30646__CCHBCCCF" title="此表列出了NULL终止和长度编码的C API函数。NULL-Terminated API和Length-Encoded API是列。">表5-5中</a>的DOM函数具有双API。</p>
                     <div class="tblformal" id="GUID-ABFE98DC-EB47-4733-BF8F-C3371FA30646__CCHBCCCF">
                        <p class="titleintable">表5-5 NULL终止和长度编码的C API函数</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="NULL终止和长度编码的C API函数" width="100%" border="1" summary="This table lists NULL-Terminated and Length-Encoded C API Functions. NULL-Terminated API and Length-Encoded  API are the columns." frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="45%" id="d19652e2530">NULL终止的API</th>
                                 <th align="left" valign="bottom" width="55%" id="d19652e2533">长度编码的API</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="45%" id="d19652e2538" headers="d19652e2530 ">
                                    <p><code class="codeph">XmlDomGetNodeName（）</code></p>
                                 </td>
                                 <td align="left" valign="top" width="55%" headers="d19652e2538 d19652e2533 ">
                                    <p><code class="codeph">XmlDomGetNodeNameLen（）</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="45%" id="d19652e2547" headers="d19652e2530 ">
                                    <p><code class="codeph">XmlDomGetNodeLocal（）</code></p>
                                 </td>
                                 <td align="left" valign="top" width="55%" headers="d19652e2547 d19652e2533 ">
                                    <p><code class="codeph">XmlDomGetNodeLocalLen（）</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="45%" id="d19652e2556" headers="d19652e2530 ">
                                    <p><code class="codeph">XmlDomGetNodeURI（）</code></p>
                                 </td>
                                 <td align="left" valign="top" width="55%" headers="d19652e2556 d19652e2533 ">
                                    <p><code class="codeph">XmlDomGetNodeURILen（）</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="45%" id="d19652e2565" headers="d19652e2530 ">
                                    <p><code class="codeph">XmlDomGetNodeValue（）</code></p>
                                 </td>
                                 <td align="left" valign="top" width="55%" headers="d19652e2565 d19652e2533 ">
                                    <p><code class="codeph">XmlDomGetNodeValueLen（）</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="45%" id="d19652e2574" headers="d19652e2530 ">
                                    <p><code class="codeph">XmlDomGetAttrName（）</code></p>
                                 </td>
                                 <td align="left" valign="top" width="55%" headers="d19652e2574 d19652e2533 ">
                                    <p><code class="codeph">XmlDomGetAttrNameLen（）</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="45%" id="d19652e2583" headers="d19652e2530 ">
                                    <p><code class="codeph">XmlDomGetAttrLocal（）</code></p>
                                 </td>
                                 <td align="left" valign="top" width="55%" headers="d19652e2583 d19652e2533 ">
                                    <p><code class="codeph">XmlDomGetAttrLocalLen（）</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="45%" id="d19652e2592" headers="d19652e2530 ">
                                    <p><code class="codeph">XmlDomGetAttrURI（）</code></p>
                                 </td>
                                 <td align="left" valign="top" width="55%" headers="d19652e2592 d19652e2533 ">
                                    <p><code class="codeph">XmlDomGetAttrURILen（）</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="45%" id="d19652e2601" headers="d19652e2530 ">
                                    <p><code class="codeph">XmlDomGetAttrValue（）</code></p>
                                 </td>
                                 <td align="left" valign="top" width="55%" headers="d19652e2601 d19652e2533 ">
                                    <p><code class="codeph">XmlDomGetAttrValueLen（）</code></p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                  </div>
               </div><a id="ADXDK19772"></a><div class="props_rev_3"><a id="GUID-462C7E68-35A3-4CD9-A767-B0F900E92BE8" name="GUID-462C7E68-35A3-4CD9-A767-B0F900E92BE8"></a><h4 id="ADXDK-GUID-462C7E68-35A3-4CD9-A767-B0F900E92BE8" class="sect4">使用C API处理错误</h4>
                  <div>
                     <p>C API函数通常返回一个数字错误代码（0表示成功，非零表示失败），或者通过变量传回错误代码。在所有情况下，API都会存储错误代码。您的应用程序可以通过调用<code class="codeph">XmlDomGetLastError()</code>函数来检索最新的错误。
                     </p>
                     <div class="section">
                        <p>默认情况下，函数将错误消息输出到<code class="codeph">stderr</code> 。但是，您可以在初始化时注册错误消息回调。发生错误时，应用程序将调用已注册的回调并且不会输出错误。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="ADXDK99935"></a><a id="ADXDK99918"></a><div class="props_rev_3"><a id="GUID-B36E81CE-DD87-4619-B308-708175CCDD0B" name="GUID-B36E81CE-DD87-4619-B308-708175CCDD0B"></a><h3 id="ADXDK-GUID-B36E81CE-DD87-4619-B308-708175CCDD0B" class="sect3">使用orastream函数</h3>
               <div>
                  <p>orastream函数API是一个接口，使您能够从节点中流出大块数据，而不是将其全部整合在一起。因此可访问大于64 KB的节点。</p>
                  <div class="section">
                     <p>orastream API表示通用输入或输出流。该接口可通过<code class="codeph">xml.h</code>由XDK用户使用，并由<code class="codeph">orastream</code>数据结构和一组实现该接口的函数定义。流的创建者将流功能地址列表以及流上下文传递给<code class="codeph">OraStreamInit</code> 。此函数返回<code class="codeph">orastream</code>结构的实例。
                     </p>
                     <p>初始化时指定了几个流属性。如果提供了读或写，则流使用<code class="codeph">OraStreamRead()</code>和<code class="codeph">OraStreamWrite()</code>以字节模式运行。如果提供“read_char”或“write_char”，则流使用<code class="codeph">OraStreamReadChar()</code>和<code class="codeph">OraStreamWriteChar()</code>以字符模式运行。在字符模式下，只读取或写入完整字符，并且永远不会在缓冲区边界上拆分。
                     </p>
                     <p>流上下文用于表示orastream的状态，并且它在流的生存期内持续存在。</p>
                     <p>就像Java中的输入或输出流一样，始终指定数据的源或接收器。输出流存储外部流或对象的地址，它们必须填充数据。类似地，输入流存储读取的对象的地址。</p>
                     <p>以下是orastream功能：</p><pre class="oac_no_warn" dir="ltr">结构orastream; typedef struct orastream orastream; typedef ub4 oraerr; / *错误代码：零是成功，非零是失败* /</pre><pre class="oac_no_warn" dir="ltr">/ *初始化（创建）和销毁（终止）流对象* / orastream * OraStreamInit（void * sctx，void * sid，oraerr * err，...）; oraerr OraStreamTerm（orastream * stream）; / *设置或更改流的SID（streamID）（通过osid返回旧的流ID）* / oraerr OraStreamSid（orastream * stream，void * sid，void ** osid）; / *流是可读还是可写？* / boolean OraStreamReadable（orastream * stream）; boolean OraStreamWritable（orastream * stream）; / *打开和关闭流* / oraerr OraStreamOpen（orastream * stream，ubig_ora * length）; oraerr OraStreamClose（orastream * stream）; / *阅读|写字节流* / oraerr OraStreamRead（orastream * stream，oratext * dest，ubig_ora size，oratext ** start，ubig_ora * nread，ub1 * eoi）; oraerr OraStreamWrite（orastream * stream，oratext * src，ubig_ora size，ubig_ora * nwrote）; / *阅读|写字符串* / oraerr OraStreamReadChar（orastream * stream，oratext * dest，ubig_ora size，oratext ** start，ubig_ora * nread，ub1 * eoi）; oraerr OraStreamWriteChar（orastream * stream，oratext * src，ubig_ora size，ubig_ora * nwrote）; / *返回句点* * orastreamhdl * OraStreamHandle（orastream * stream）; / *返回状态：如果流对象当前是否打开* / boolean OraStreamIsOpen（orastream * stream）;</pre><p>流错误代码是：</p><pre class="oac_no_warn" dir="ltr">#define ORASTREAM_ERR_NULL_POINTER 1 / *给出空指针* / #define ORASTREAM_ERR_BAD_STREAM 2 / *无效流对象* / #define ORASTREAM_ERR_WRONG_DECTION 3 / *尝试错误方向I / O * / #define ORASTREAM_ERR_UNKNOWN_PROPERTY 4 / *未知创建道具* / #define ORASTREAM_ERR_NO_DIRECTION 5 / *既不读也不写？* / #define ORASTREAM_ERR_BI_DIRECTION 6 / *都读取任何写入？* / #define ORASTREAM_ERR_NOT_OPEN 7 / *流未打开* / #define ORASTREAM_ERR_WRONG_MODE 8 / *写入字节/字符模式* / / * ---打开错误--- * / #define ORASTREAM_ERR_CANT_OPEN 10 / *无法打开流* / / * ---关闭错误--- * / #define ORASTREAM_ERR_CANT_CLOSE 20 / *无法关闭流* /</pre><div class="infoboxnotealso" id="GUID-B36E81CE-DD87-4619-B308-708175CCDD0B__GUID-A39B7D88-BB54-490A-A7C1-B6A327B1FC53">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="../caxml/package-Orastream-API.html#CAXML01400" target="_blank"><span><cite>Oracle Database XML C API参考，</cite></span></a>用于参考信息，例如orastream API中的参数定义</p>
                     </div>
                  </div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-B36E81CE-DD87-4619-B308-708175CCDD0B__GUID-C03C7044-B5BF-4362-9F13-A1CD877C0ED2">
                     <p class="titleinexample">例5-3使用orastream函数</p><pre class="oac_no_warn" dir="ltr">int test_read（）{xmlctx * xctx = NULL; oratext * barray，* docName =“NSExample.xml”; orastream * ostream =（orastream *）0; xmlerr ecode = 0; ub4 wcount = 0; ubig_ora destsize，nread; oraerr oerr = 0; ub1 eoi = 0; nread = destsize = 1024;如果（！（xctx = XmlCreateNew（＆ecode，（oratext *）“stream_xctx”，NULL，wcount，NULL）））{printf（“无法创建XML上下文，错误％u \ n”，（unsigned）ecode）;返回-1; } barray = XmlAlloc（xctx，sizeof（oratext）* destsize）;应指定/ * open函数以便正确读取。* / if（！（ostream = OraStreamInit（NULL，docName，（oraerr *）＆ecode，“open”，fileopen，“read”，fileread，NULL）））{printf（“无法初始化OrsStream，错误％u \ n”，（unsigned）ecode ）;返回-1; } / *检查可读和可写* / if（OraStreamReadable（ostream））printf（“ostream是可读的\ n”）; else printf（“ostream不可读\ n”）; if（OraStreamWritable（ostream））printf（“ostream是可写的\ n”）; else printf（“ostream不可写\ n”）; if（oerr = OraStreamRead（ostream，barray，destsize，＆barray，＆nread，＆eoi））{printf（“因orastream而未能阅读，错误％u \ n”，oerr）; } / * open orastream * / OraStreamOpen（ostream，NULL）; / *阅读文档* / OraStreamRead（ostream，barray，destsize，＆barray，＆nread，＆eoi）; OraStreamTerm（ostream的）; XmlDestroy（xctx）;返回0; ORASTREAM_OPEN_F（fileopen，sctx，sid，hdl，length）{FILE * fh = NULL; printf（“打开orastream％s ... \ n”，（oratext *）sid）; if（sid &amp;&amp;（（fh = fopen（sid，“r”））！= NULL））{printf（“打开orastream％s ... \ n”，（oratext *）sid）; } else {printf（“无法打开输入文件。\ n”）;返回-1; } / *一般存储文件句柄，NULL表示stdout * / hdl-&gt; ptr_orastreamhdl = fh;返回XMLERR_OK; } ORASTREAM_READ_F（fileread，sctx，sid，hdl，dest，size，start，nread，eoi）{FILE * fh = NULL; int i = 0; printf（“阅读orastream％s ... \ n”，（oratext *）sid）; //将数据从文件读取到dest if（（fh =（FILE *）hdl-&gt; ptr_orastreamhdl）！= NULL）* nread = fread（dest，1，size，fh）; printf（“从orastream读取％d个字节...... \ n”，（int）* nread）; * eoi =（* nread &lt;size）; if（start）* start = dest; printf（“打印文件...... \ n”）; for（i = 0; i &lt;* nread; i ++）printf（“％c”，（char）dest [i]）; printf（“\ nend ... \ n”）;返回ORAERR_OK; }</pre></div>
                  <!-- class="example" -->
               </div>
            </div><a id="ADXDK19773"></a><div class="props_rev_3"><a id="GUID-34FE324C-DF9F-4FE7-B2EF-48FE4FB38B6E" name="GUID-34FE324C-DF9F-4FE7-B2EF-48FE4FB38B6E"></a><h3 id="ADXDK-GUID-34FE324C-DF9F-4FE7-B2EF-48FE4FB38B6E" class="sect3">使用SAX API for C</h3>
               <div>
                  <p>要使用SAX，请使用函数指针初始化<code class="codeph">xmlsaxcb</code>结构并将其传递给<code class="codeph">XmlLoadSax()</code> 。您还可以包含指向用户定义的上下文结构的指针，并将其传递给每个SAX函数。
                  </p>
                  <div class="section">
                     <div class="infoboxnotealso" id="GUID-34FE324C-DF9F-4FE7-B2EF-48FE4FB38B6E__GUID-883F4A36-85D5-40CA-B3D1-BCD12F56ED17">
                        <p class="notep1">也可以看看：</p>
                        <p>SAX回调结构的<a href="../caxml/package-SAX-API.html#CAXML5908" target="_blank"><span><cite>Oracle Database XML C API参考</cite></span></a></p>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div>
            </div><a id="ADXDK1038"></a><a id="ADXDK1410"></a><div class="props_rev_3"><a id="GUID-C244DBA6-8578-4224-B21D-CD5FF48B0EEC" name="GUID-C244DBA6-8578-4224-B21D-CD5FF48B0EEC"></a><h3 id="ADXDK-GUID-C244DBA6-8578-4224-B21D-CD5FF48B0EEC" class="sect3">使用XML Pull Parser for C</h3>
               <div>
                  <p>XML Pull Parser是XML Events接口的一个实现。XML Pull Parser和SAX解析器类似，但是使用Pull Parser，应用程序（使用者）驱动事件，而在SAX中，解析器（生产者）驱动事件。</p>
                  <div class="section">
                     <p>XML Pull Parser和SAX都将文档表示为一系列事件，包括开始标记，结束标记和注释。XML Pull Parser通过公开一组简单的API和一组基础事件来控制应用程序。诸如<code class="codeph">XmlEvNext</code>方法允许应用程序请求（或拉取）下一个事件，而不是像在SAX中那样在回调中处理事件。因此，应用程序对XML处理具有更多的程序控制。此外，与解析整个文档的SAX应用程序不同，应用程序可以决定停止进一步处理。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="section"></div>
                  <!-- class="section" -->
               </div><a id="ADXDK19774"></a><div class="props_rev_3"><a id="GUID-9440C355-936A-44ED-99A9-80B49758D000" name="GUID-9440C355-936A-44ED-99A9-80B49758D000"></a><h4 id="ADXDK-GUID-9440C355-936A-44ED-99A9-80B49758D000" class="sect4">使用Basic XML Pull Parsing功能</h4>
                  <div>
                     <p>描述了使用XML Pull Parser所需的步骤。</p>
                     <ol>
                        <li class="stepexpand"><span>调用<code class="codeph">XmlCreate</code>以初始化XML元上下文。</span></li>
                        <li class="stepexpand"><span>通过调用<code class="codeph">XmlEvCreatePPCtx</code>函数初始化Pull Parser上下文，该函数创建并返回事件上下文。</span><div>
                              <p><code class="codeph">XmlEvCreatePPCtx</code>函数支持<code class="codeph">XmlLoadDom</code>和<code class="codeph">XmlLoadSax</code>支持的所有属性，以及一些其他属性。
                              </p>
                              <p><code class="codeph">XmlEvCreatePPCtx</code>和<code class="codeph">XmlEvCreatePPCtxVA</code>函数已完全实现。
                              </p>
                           </div>
                        </li>
                        <li class="stepexpand"><span>确保将事件上下文传递给Pull Parser的所有后续调用。</span></li>
                        <li class="stepexpand"><span>通过调用<code class="codeph">XmlEvDestoryPPCtx</code>函数终止Pull Parser上下文来清理内存。</span></li>
                        <li class="stepexpand"><span>通过调用<code class="codeph">XmlDestoryCtx</code>函数来销毁XML元上下文。</span></li>
                     </ol>
                  </div><a id="ADXDK19776"></a><a id="ADXDK19775"></a><div class="props_rev_3"><a id="GUID-DC1CF9B5-DCD1-4743-950B-EDBFD9E5ABEF" name="GUID-DC1CF9B5-DCD1-4743-950B-EDBFD9E5ABEF"></a><h5 id="ADXDK-GUID-DC1CF9B5-DCD1-4743-950B-EDBFD9E5ABEF" class="sect5">XML事件上下文</h5>
                     <div>
                        <p>显示了XML事件上下文结构。</p>
                        <div class="example" id="GUID-DC1CF9B5-DCD1-4743-950B-EDBFD9E5ABEF__CCHJDIHJ">
                           <p class="titleinexample">示例5-4 XML事件上下文</p><pre class="pre codeblock"><code>typedef struct {void * ctx_xmlevctx; / *实现特定上下文* / xmlevdisp * disp_xmlevctx; / * dispatch table * / ub4 checkword_xmlevctx; / * checkword for integrity check * / ub4 flags_xmlevctx; / *模式;默认值：expand_entity * / struct xmlevctx * input_xmlevctx; / *输入xmlevctx;链接XML事件上下文* /} xmlevctx;</code></pre></div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="ADXDK19777"></a><div class="props_rev_3"><a id="GUID-60864BD6-729A-409C-B06E-D5454040A0B3" name="GUID-60864BD6-729A-409C-B06E-D5454040A0B3"></a><h5 id="ADXDK-GUID-60864BD6-729A-409C-B06E-D5454040A0B3" class="sect5">关于XML事件上下文</h5>
                     <div>
                        <p>允许每个XML Pull Parser创建自己的上下文并实现自己的API函数。</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>派遣表</p>
                              <p>除了<code class="codeph">XmlEvCreatePPCtx</code> ， <code class="codeph">XmlEvCreatePPCtxVA</code> ， <code class="codeph">XmlEvDestoryPPCtx</code> ， <code class="codeph">XmlEvLoadPPDoc</code>和<code class="codeph">XmlEvCleanPPCtx</code>函数之外，调度表<code class="codeph">disp_xmlevctx</code>包含每个API函数的一个指针。
                              </p>
                              <p>创建事件上下文时，将使用该静态表的地址初始化指针<code class="codeph">disp_xmlevctx</code> 。
                              </p>
                           </li>
                           <li>
                              <p>特定于实现的事件上下文</p>
                              <p>必须使用特定于此特定实现的调用的上下文的地址初始化字段<code class="codeph">ctx_xmlevctx</code> 。特定于实现的事件上下文的类型为<code class="codeph">*void</code> ，因此它可以针对不同的应用程序而有所不同。
                              </p>
                           </li>
                           <li>
                              <p>输入事件上下文</p>
                              <p>每个Pull Parser都可以指定输入事件上下文<code class="codeph">xmlevctx</code> 。此字段使解析器能够链接多个事件生成器。因此，如果在上下文中将调度函数指定为<code class="codeph">NULL</code> ，则应用程序将使用输入事件上下文链中的下一个非空调度函数。基本<code class="codeph">xmlevctx</code>必须确保所有调度函数指针都为非null。
                              </p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="ADXDK19778"></a><div class="props_rev_3"><a id="GUID-75020C67-9F3A-46DA-81C9-08CA086135E8" name="GUID-75020C67-9F3A-46DA-81C9-08CA086135E8"></a><h4 id="ADXDK-GUID-75020C67-9F3A-46DA-81C9-08CA086135E8" class="sect4">解析多个XML文档</h4>
                  <div>
                     <p>在创建和初始化XML事件上下文之后，应用程序可以使用<code class="codeph">XmlEvLoadPPDoc</code>和<code class="codeph">XmlEvCleanPPCtx</code>重复调用来解析多个文档。
                     </p>
                     <div class="section">
                        <p>在每次调用<code class="codeph">XmlLoadPPDoc</code>函数时，无法更改应用程序在XML事件上下文创建期间定义的属性。要更改属性，请销毁事件上下文，然后重新创建它。
                        </p>
                        <p>在<code class="codeph">XmlEvCleanPPCtx</code>清除当前解析器的内部结构之后，可以重用事件上下文来解析另一个文档。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ADXDK19780"></a><a id="ADXDK19781"></a><a id="ADXDK19782"></a><a id="ADXDK19779"></a><div class="props_rev_3"><a id="GUID-48E4B443-A445-4BAA-9A5F-11096A355BFE" name="GUID-48E4B443-A445-4BAA-9A5F-11096A355BFE"></a><h4 id="ADXDK-GUID-48E4B443-A445-4BAA-9A5F-11096A355BFE" class="sect4">ID回拨</h4>
                  <div>
                     <p>您可以提供回调以将基于文本的名称转换为8字节标识符（ID）。</p>
                     <div class="section">
                        <p class="subhead3" id="GUID-48E4B443-A445-4BAA-9A5F-11096A355BFE__GUID-0143E44D-3A5F-4A52-948B-74767635184B">回调函数签名</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section"><pre class="oac_no_warn" dir="ltr">typedef sb8（* xmlev_id_cb_funcp）（void * ctx，ub1 type，ub1 * token，ub4 tok_len，sb8 nmspid，boolean isAttribute）;</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-48E4B443-A445-4BAA-9A5F-11096A355BFE__GUID-E631A425-2160-4FAD-853D-AC9748E7D519">回报价值</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p><code class="codeph">sb8</code> ：一个8字节的ID。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-48E4B443-A445-4BAA-9A5F-11096A355BFE__GUID-018164CB-A939-4A4E-ACAE-7B50251EFFB4">参数</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p>* <code class="codeph">ctx</code> ：实现上下文。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">type</code> ：类型，由此枚举指示：</p><pre class="oac_no_warn" dir="ltr">typedef enum {XML_EVENT_ID_URI，XML_EVENT_ID_QNAME，} xmlevidtype;</pre></li>
                           <li>
                              <p>* <code class="codeph">token</code>和<code class="codeph">tok_len</code> ：要转换的实际文本。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">nmspid</code> ：命名空间ID。</p>
                           </li>
                           <li>
                              <p><code class="codeph">isAttribute</code> ：指示属性的布尔值。
                              </p>
                           </li>
                        </ul>
                        <p>在内部， <code class="codeph">XmlEvGetTagId</code>和<code class="codeph">XmlEvGetAttrID</code> API两次调用此回调，一次获取命名空间ID，一次获取标记的实际ID或属性<code class="codeph">Qname</code> 。
                        </p>
                        <p><code class="codeph">XmlEvGetTagUriID</code>和<code class="codeph">XmlEvGetAttrUriID</code>函数调用此回调一次以获取相应的<code class="codeph">XmlEvGetTagUriID</code>资源标识符（URI）的ID。
                        </p>
                        <p>如果未提供回调，则在使用这些API时会返回错误<code class="codeph">XML_ERR_EVENT_NOIDCBK</code> 。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ADXDK19783"></a><div class="props_rev_3"><a id="GUID-D17D4D58-50E4-4C6E-BA79-91E5F196F04C" name="GUID-D17D4D58-50E4-4C6E-BA79-91E5F196F04C"></a><h4 id="ADXDK-GUID-D17D4D58-50E4-4C6E-BA79-91E5F196F04C" class="sect4">XML Pull Parser的错误处理</h4>
                  <div>
                     <p>描述了XML Pull Parser的错误处理。</p>
                  </div><a id="ADXDK19784"></a><div class="props_rev_3"><a id="GUID-1D5E95DB-55EE-44A7-8360-D530BEAD6477" name="GUID-1D5E95DB-55EE-44A7-8360-D530BEAD6477"></a><h5 id="ADXDK-GUID-1D5E95DB-55EE-44A7-8360-D530BEAD6477" class="sect5">分析器错误</h5>
                     <div>
                        <p>描述了解析器引发的错误。</p>
                        <p>XML Pull Parser在抛出错误时返回消息<code class="codeph">XML_EVENT_FATAL_ERROR</code> ，因为输入文档格式错误。提供函数<code class="codeph">XmlEvGetError</code>以获取错误号和消息。
                        </p>
                        <p>在<code class="codeph">XmlEvCreatePPCtx</code>操作期间，将覆盖<code class="codeph">XmlCreate</code>期间应用程序提供的任何错误处理程序。应用程序必须在<code class="codeph">XmlEvDestroyPPCtx</code>操作之后调用<code class="codeph">XmlErrSetHandler</code>函数以恢复原始回调。
                        </p>
                     </div>
                  </div><a id="ADXDK19785"></a><div class="props_rev_3"><a id="GUID-A32A6E3E-CA3E-4ED5-9FA3-AFC9DC357331" name="GUID-A32A6E3E-CA3E-4ED5-9FA3-AFC9DC357331"></a><h5 id="ADXDK-GUID-A32A6E3E-CA3E-4ED5-9FA3-AFC9DC357331" class="sect5">编程错误</h5>
                     <div>
                        <p>处理程序错误。XDK提供应用程序在创建事件上下文时可以提供的回调。当应用程序调用非法API时，将调用此回调。</p>
                        <div class="section">
                           <p>回调签名是：</p><pre class="oac_no_warn" dir="ltr">typedef void（* xmlev_err_cb_funcp）（xmlctx * xctx，xmlevctx * evctx，xmlevtype cur_event）;</pre><p>非法API调用的示例是：</p>
                           <p><code class="codeph">XmlEvGetName</code>不能呼吁<code class="codeph">XML_EVENT_CHARACTERS</code>事件。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="ADXDK19788"></a><a id="ADXDK19790"></a><a id="ADXDK19792"></a><a id="ADXDK19786"></a><div class="props_rev_3"><a id="GUID-DAE9B130-2651-403C-8442-A71634C12312" name="GUID-DAE9B130-2651-403C-8442-A71634C12312"></a><h4 id="ADXDK-GUID-DAE9B130-2651-403C-8442-A71634C12312" class="sect4">样本拉分析器应用程序</h4>
                  <div>
                     <p>提供了示例拉解析器应用程序，要解析的文档以及应用程序从文档生成的事件列表。</p>
                     <p><a href="using-XML-parser-for-C.html#GUID-DAE9B130-2651-403C-8442-A71634C12312__BABCJHAB">例5-5</a>显示了示例应用程序代码。
                     </p>
                     <p><a href="using-XML-parser-for-C.html#GUID-DAE9B130-2651-403C-8442-A71634C12312__BGBCACGI">例5-6</a>显示了要解析的示例文档。
                     </p>
                     <p><a href="using-XML-parser-for-C.html#GUID-DAE9B130-2651-403C-8442-A71634C12312__BGBBEAEB">示例5-7</a>显示了属性events属性为<code class="codeph">FALSE</code>且展开实体属性为<code class="codeph">TRUE</code>时生成的事件序列。</p>
                     <div class="example" id="GUID-DAE9B130-2651-403C-8442-A71634C12312__BABCJHAB">
                        <p class="titleinexample">例5-5 Sample Pull Parser应用程序示例</p><pre class="oac_no_warn" dir="ltr">#include“xml.h”#include“xmlev.h”......xmlctx * xctx; xmlevctx * evtcx;如果（！（xctx = XmlCreate（＆xerr，（oratext *）“test”）））{printf（“无法创建XML上下文，错误％u \ n”，（unsigned）xerr）;返回-1; } ...如果（！（evctx = XmlEvCreatePPCtx（xctx，＆xerr，NULL）））{printf（“无法创建EVENT上下文，错误％u \ n”，（无符号）xerr）;返回-1; } for（i = 0; i &lt;numDocs; i ++）{if（xerr = XmlEvLoadPPDoc（xctx，evctx，“file”，input_filenames [i]，0，NULL）{printf（“无法加载文档，错误％u \ n“，（unsigned）xerr）;返回-1;} ...for（;;）{xmlevtype cur_event; cur_event = XmlEvNext（evctx）; switch（cur_event）{case XML_EVENT_FATAL_ERROR：XmlEvGetError（evctx，（oratext **）＆errmsg）; printf（“Error％s \ n”，errmsg）;返回; case XML_EVENT_START_ELEMENT：printf（“&lt;％s&gt;”，XmlEvGetName0（evctx））;打破; case XML_EVENT_END_DOCUMENT：printf（“&lt;％s&gt;”，XmlEvGetName0（evctx））;返回; XmlEvCleanPPCtx（xctx，evctx）; XmlEvDestroyPPCtx（xctx，evctx）; XmlDestroy（xctx）;</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-DAE9B130-2651-403C-8442-A71634C12312__BGBCACGI">
                        <p class="titleinexample">例5-6要解析的示例文档</p><pre class="oac_no_warn" dir="ltr">&lt;！DOCTYPE doc [&lt;！ENTITY ent SYSTEM“file：attendees.txt”&gt; &lt;！ELEMENT doc ANY&gt; &lt;！ELEMENT会议（主题，日期，发布受试者）&gt; &lt;！ELEMENT publishAttendees（#PCDATA）&gt; &lt;！ELEMENT主题（#PCDATA）&gt; &lt;！ELEMENT日期（#PCDATA）&gt;]&gt; &lt;！ - 开始文档 - &gt; &lt;doc&gt; &lt;！ - 有关会议的信息 - &gt; &lt;会议&gt; &lt;主题&gt;小组会议&lt;/ topic&gt; &lt;日期&gt; 4月25日， 2005 &lt;/ date&gt; &lt;publishAttendees&gt;＆ent; &lt;/ publishAttendees&gt; &lt;/ meeting&gt; &lt;/ doc&gt; &lt;！ -  End Document  - &gt;</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-DAE9B130-2651-403C-8442-A71634C12312__BGBBEAEB">
                        <p class="titleinexample">示例5-7通过解析示例文档生成的事件</p><pre class="oac_no_warn" dir="ltr">XML_EVENT_START_DOCUMENT XML_EVENT_START_DTD XML_EVENT_PE_DECLARATION XML_EVENT_ELEMENT_DECLARATION XML_EVENT_ELEMENT_DECLARATION XML_EVENT_ELEMENT_DECLARATION XML_EVENT_ELEMENT_DECLARATION XML_EVENT_ELEMENT_DECLARATION XML_EVENT_END_DTD XML_EVENT_COMMENT XML_EVENT_START_ELEMENT XML_EVENT_SPACE XML_EVENT_COMMENT XML_EVENT_SPACE XML_EVENT_START_ELEMENT XML_EVENT_START_ELEMENT XML_EVENT_CHARACTERS XML_EVENT_END_ELEMENT XML_EVENT_START_ELEMENT XML_EVENT_CHARACTERS XML_EVENT_END_ELEMENT XML_EVENT_START_ELEMENT XML_EVENT_START_ENTITY XML_EVENT_CHARACTERS XML_EVENT_END_ENTITY XML_EVENT_END_ELEMENT XML_EVENT_END_ELEMENT XML_EVENT_SPACE XML_EVENT_END_ELEMENT XML_EVENT_COMMENT XML_EVENT_END_DOCUMENT</pre></div>
                     <!-- class="example" -->
                  </div>
               </div>
            </div><a id="ADXDK19793"></a><div class="props_rev_3"><a id="GUID-0B3D2810-F81E-4748-9E2B-152865F2A8B3" name="GUID-0B3D2810-F81E-4748-9E2B-152865F2A8B3"></a><h3 id="ADXDK-GUID-0B3D2810-F81E-4748-9E2B-152865F2A8B3" class="sect3">使用OCI和XDK for C API</h3>
               <div>
                  <p>本节介绍如何从Oracle调用接口（OCI）访问CD函数的XDK。</p>
               </div><a id="ADXDK19795"></a><a id="ADXDK19794"></a><div class="props_rev_3"><a id="GUID-0E4FBFA3-1B16-4886-A5B9-A0F5A8FA9693" name="GUID-0E4FBFA3-1B16-4886-A5B9-A0F5A8FA9693"></a><h4 id="ADXDK-GUID-0E4FBFA3-1B16-4886-A5B9-A0F5A8FA9693" class="sect4">使用XMLType函数和描述</h4>
                  <div>
                     <p>您可以在数据库中使用带有<code class="codeph">XMLType</code>列的C API for XML。Oracle调用接口（OCI）程序可以通过初始化OCI句柄的值来访问存储在表中的XML数据。
                     </p>
                     <div class="section">
                        <p>这适用于以下句柄：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>环境处理</p>
                           </li>
                           <li>
                              <p>服务处理</p>
                           </li>
                           <li>
                              <p>错误句柄</p>
                           </li>
                           <li>
                              <p>可选参数</p>
                           </li>
                        </ul>
                        <p>程序可以将这些输入值传递给函数<code class="codeph">OCIXmlDbInitXmlCtx()</code> ，该函数返回XML上下文。程序调用C API后，函数<code class="codeph">OCIXmlDbFreeXmlCtx()</code>释放上下文。
                        </p>
                        <div class="tblformal" id="GUID-0E4FBFA3-1B16-4886-A5B9-A0F5A8FA9693__CCHBDJDE">
                           <p class="titleintable">表5-6 XMLType函数</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="XMLType函数" width="100%" border="1" summary="This table describes a few of the functions for XML operations. Description and Function Name are the columns." frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="42%" id="d19652e4208">功能名称</th>
                                    <th align="left" valign="bottom" width="58%" id="d19652e4211">描述</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="42%" id="d19652e4216" headers="d19652e4208 ">
                                       <p><code class="codeph">XmlCreateDocument（）</code></p>
                                    </td>
                                    <td align="left" valign="top" width="58%" headers="d19652e4216 d19652e4211 ">
                                       <p>创建空<code class="codeph">XMLType</code>实例</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="42%" id="d19652e4227" headers="d19652e4208 ">
                                       <p><code class="codeph">XmlLoadDom()</code>等等</p>
                                    </td>
                                    <td align="left" valign="top" width="58%" headers="d19652e4227 d19652e4211 ">
                                       <p>从源缓冲区创建</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="42%" id="d19652e4236" headers="d19652e4208 ">
                                       <p><code class="codeph">XmlXPathEvalexpr()</code>和系列</p>
                                    </td>
                                    <td align="left" valign="top" width="58%" headers="d19652e4236 d19652e4211 ">
                                       <p>提取<code class="codeph">XPath</code>表达式</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="42%" id="d19652e4248" headers="d19652e4208 ">
                                       <p><code class="codeph">XmlXslProcess()</code>和系列</p>
                                    </td>
                                    <td align="left" valign="top" width="58%" headers="d19652e4248 d19652e4211 ">
                                       <p>使用可扩展样式表语言转换（XSLT）样式表进行转换</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="42%" id="d19652e4257" headers="d19652e4208 ">
                                       <p><code class="codeph">XmlXPathEvalexpr()</code>和系列</p>
                                    </td>
                                    <td align="left" valign="top" width="58%" headers="d19652e4257 d19652e4211 ">
                                       <p>检查是否存在<code class="codeph">XPath</code></p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="42%" id="d19652e4269" headers="d19652e4208 ">
                                       <p><code class="codeph">XmlDomIsSchemaBased（）</code></p>
                                    </td>
                                    <td align="left" valign="top" width="58%" headers="d19652e4269 d19652e4211 ">
                                       <p>是基于文档架构吗？</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="42%" id="d19652e4277" headers="d19652e4208 ">
                                       <p><code class="codeph">XmlDomGetSchema（）</code></p>
                                    </td>
                                    <td align="left" valign="top" width="58%" headers="d19652e4277 d19652e4211 ">
                                       <p>获取架构信息</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="42%" id="d19652e4285" headers="d19652e4208 ">
                                       <p><code class="codeph">XmlDomGetNodeURI（）</code></p>
                                    </td>
                                    <td align="left" valign="top" width="58%" headers="d19652e4285 d19652e4211 ">
                                       <p>获取文档命名空间</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="42%" id="d19652e4293" headers="d19652e4208 ">
                                       <p><code class="codeph">XmlSchemaValidate（）</code></p>
                                    </td>
                                    <td align="left" valign="top" width="58%" headers="d19652e4293 d19652e4211 ">
                                       <p>使用架构验证</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="42%" id="d19652e4301" headers="d19652e4208 ">
                                       <p>Cast <code class="codeph">(void *)</code> to <code class="codeph">(xmldocnode *)</code></p>
                                    </td>
                                    <td align="left" valign="top" width="58%" headers="d19652e4301 d19652e4211 ">
                                       <p>从<code class="codeph">XMLType</code>获取DOM</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="42%" id="d19652e4315" headers="d19652e4208 ">
                                       <p>将<code class="codeph">(xmldocnode *)</code>为<code class="codeph">(void *)</code></p>
                                    </td>
                                    <td align="left" valign="top" width="58%" headers="d19652e4315 d19652e4211 ">
                                       <p>从DOM获取<code class="codeph">XMLType</code></p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ADXDK19796"></a><div class="props_rev_3"><a id="GUID-AFBCF39A-784B-4D78-9613-6E11EEBE4A20" name="GUID-AFBCF39A-784B-4D78-9613-6E11EEBE4A20"></a><h4 id="ADXDK-GUID-AFBCF39A-784B-4D78-9613-6E11EEBE4A20" class="sect4">初始化Oracle XML DB的XML上下文</h4>
                  <div>
                     <p>XML上下文是每个C DOM API函数中的必需参数。此不透明上下文封装了与数据编码，错误消息语言等有关的信息。对于XDK应用程序和Oracle XML DB应用程序，此XML上下文的内容是不同的。</p>
                     <div class="section">
                        <div class="infoboxnote" id="GUID-AFBCF39A-784B-4D78-9613-6E11EEBE4A20__GUID-0EF7C0D6-C9B5-4ED6-8B63-7C282A5E238F">
                           <p class="notep1">注意：</p>
                           <p>不要在Oracle XML DB应用程序中为XDK使用XML上下文，也不要在XDK应用程序中为Oracle XML DB使用XML上下文。</p>
                        </div>
                        <p>对于Oracle XML DB，初始化和释放XML上下文的两个OCI函数具有以下原型：</p><pre class="oac_no_warn" dir="ltr">xmlctx * OCIXmlDbInitXmlCtx（OCIEnv * envhp，OCISvcCtx * svchp，OCIError * errhp，ocixmldbparam * params，ub4 num_params）; void OCIXmlDbFreeXmlCtx（xmlctx * xctx）;</pre><div class="infoboxnotealso" id="GUID-AFBCF39A-784B-4D78-9613-6E11EEBE4A20__GUID-F3A2423D-C0FF-4FF9-82D3-3C6377347C10">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><a href="../lnoci/oci-xml-databse-functions.html#LNOCI220" target="_blank"><span><cite>Oracle Call Interface Programmer's Guide</cite></span></a> ，了解有关函数的参考资料</p>
                              </li>
                              <li>
                                 <p>关于OCI对XML的支持的讨论的<a href="../lnoci/index.html" target="_blank"><span><cite>Oracle调用接口程序员指南</cite></span></a></p>
                              </li>
                              <li>
                                 <p>有关DOM API的参考信息，请参阅<a href="../caxml/package-DOM-API.html#CAXML00300" target="_blank"><span><cite>Oracle Database XML C API参考</cite></span></a></p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ADXDK19797"></a><div class="props_rev_3"><a id="GUID-E6F4271E-BBF5-46C2-B8AB-C1702175BBB0" name="GUID-E6F4271E-BBF5-46C2-B8AB-C1702175BBB0"></a><h4 id="ADXDK-GUID-E6F4271E-BBF5-46C2-B8AB-C1702175BBB0" class="sect4">在客户端上创建XMLType实例</h4>
                  <div>
                     <p>您可以使用<code class="codeph">XmlLoadDom()</code>调用在客户端上构造新的<code class="codeph">XMLType</code>实例。
                     </p>
                     <div class="section">
                        <p>请遵循以下基本步骤：</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>您必须初始化<code class="codeph">xmlctx</code> ，如<a href="using-XML-parser-for-C.html#GUID-0C749FC8-C0B3-41AF-9382-82F0E4FC3BEF" title="这里的主题包括控制XML文档的编码，使用NULL终止和长度编码的函数，以及处理错误。">使用DOM API for C</a>中的示例所示。</span></li>
                        <li class="stepexpand"><span>您可以从以下来源构建XML数据：</span><div>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>用户缓冲区</p>
                                 </li>
                                 <li>
                                    <p>本地文件</p>
                                 </li>
                                 <li>
                                    <p>URI</p>
                                 </li>
                              </ul>
                              <p>这些返回值是<code class="codeph">(xmldocnode *)</code> ，您可以在其他常见C API中使用它。</p>
                           </div>
                        </li>
                        <li class="stepexpand"><span>您可以将<code class="codeph">(xmldocnode *)</code>转换为（ <code class="codeph">void *)</code>并在需要时直接将其作为绑定值提供。</span></li>
                     </ol>
                     <div class="section">
                        <p>您可以通过调用<code class="codeph">XmlCreateDocument()</code>来构造空的<code class="codeph">XMLType</code>实例。对于其他类型，此函数等效于<code class="codeph">OCIObjectNew()</code> 。您可以对前面调用返回的<code class="codeph">(xmldocnode *)</code>进行操作，如果必须将其作为绑定值提供，则最终将其<code class="codeph">(xmldocnode *)</code>转换为<code class="codeph">(void *)</code> 。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ADXDK19798"></a><div class="props_rev_3"><a id="GUID-62F87C40-EB28-4B61-9CE1-2692C7EB5F60" name="GUID-62F87C40-EB28-4B61-9CE1-2692C7EB5F60"></a><h4 id="ADXDK-GUID-62F87C40-EB28-4B61-9CE1-2692C7EB5F60" class="sect4">在数据库服务器上操作XML数据</h4>
                  <div>
                     <p>您可以使用OCI语句在Oracle数据库中操作XML数据。您可以使用<code class="codeph">xmldocnode</code>绑定和定义<code class="codeph">XMLType</code>值，并使用OCI语句从数据库中提取XML数据。您可以直接在C DOM函数中使用此数据，也可以将值直接绑定到SQL语句。
                     </p>
                  </div>
               </div><a id="ADXDK19800"></a><a id="ADXDK19801"></a><a id="ADXDK19799"></a><div class="props_rev_3"><a id="GUID-649191E3-099B-49C4-97E3-4DC58F3960C0" name="GUID-649191E3-099B-49C4-97E3-4DC58F3960C0"></a><h4 id="ADXDK-GUID-649191E3-099B-49C4-97E3-4DC58F3960C0" class="sect4">使用OCI和XDK for C API：示例</h4>
                  <div>
                     <p>示例显示如何使用DOM API构造和保存基于XML模式的文档以及修改数据库文档。</p>
                     <div class="section">
                        <p><a href="using-XML-parser-for-C.html#GUID-649191E3-099B-49C4-97E3-4DC58F3960C0__CCHHJFAE">示例5-8</a>显示了如何使用DOM API构造基于模式的文档并将其保存到数据库中。您必须包含头文件<code class="codeph">xml.h</code>和<code class="codeph">ocixmldb.h</code> 。
                        </p>
                        <p><a href="using-XML-parser-for-C.html#GUID-649191E3-099B-49C4-97E3-4DC58F3960C0__CCHDJDBE">例5-9</a>显示了如何从数据库中获取文档并使用DOM API对其进行修改。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-649191E3-099B-49C4-97E3-4DC58F3960C0__CCHHJFAE">
                        <p class="titleinexample">示例5-8使用DOM API构造基于模式的文档</p><pre class="pre codeblock"><code>#include &lt;xml.h&gt; #include &lt;ocixmldb.h&gt; static oratext tlpxml_test_sch [] =“&lt;TOP xmlns ='example1.xsd'\ n \ xmlns：xsi ='http：//www.w3.org/2001/ XMLSchema-instance'\ n \ xsi：schemaLocation ='example1.xsd example1.xsd'/&gt;“; void example1（）{OCIEnv * envhp; OCIError * errhp; OCISvcCtx * svchp; OCIStmt * stmthp; OCIDuration dur; OCIType * xmltdo; xmldocnode * doc; ocixmldbparam params [1]; xmlnode * quux，* foo，* foo_data; xmlerr错误; / *初始化envhp，svchp，errhp，dur，stmthp * / / * ........* / / *获取xml上下文* / params [0] .name_ocixmldbparam = XCTXINIT_OCIDUR; params [0] .value_ocixmldbparam =＆dur; xctx = OCIXmlDbInitXmlCtx（envhp，svchp，errhp，params，1）; / *开始处理* / printf（“支持XML 1.0：％s \ n”，XmlHasFeature（xctx，（oratext *）“xml”，（oratext *）“1.0”）？“是”：“否”）; / *解析基于模式的文档* / if（！（doc = XmlLoadDom（xctx，＆err，“buffer”，tlpxml_test_sch，“buffer_length”，sizeof（tlpxml_test_sch）-1，“validate”，TRUE，NULL）））{printf（“Parse failed，code％d \ n”）;返回; } / *创建一些元素并将它们添加到文档中* / top = XmlDomGetDocElem（xctx，doc）; quux =（xmlnode *）XmlDomCreateElem（xctx，doc，（oratext *）“QUUX”）; foo =（xmlnode *）XmlDomCreateElem（xctx，doc，（oratext *）“FOO”）; foo_data =（xmlnode *）XmlDomCreateText（xctx，doc，（oratext *）“foo的数据”）; foo_data = XmlDomAppendChild（xctx，（xmlnode *）foo，（xmlnode *）foo_data）; foo = XmlDomAppendChild（xctx，quux，foo）; quux = XmlDomAppendChild（xctx，top，quux）; XmlSaveDom（xctx，＆err，top，“stdio”，stdout，NULL）; XmlSaveDom（xctx，＆err，doc，“stdio”，stdout，NULL）; / *将文档插入my_table * / ins_stmt =“插入my_table值（：1）”; status = OCITypeByName（envhp，errhp，svchp，（const text *）“SYS”，（ub4）strlen（（char *）“SYS”），（const text *）“XMLTYPE”，（ub4）strlen（（char * ）“XMLTYPE”），（CONST text *）0，（ub4）0，dur，OCI_TYPEGET_HEADER，（OCIType **）＆xmltdo））; if（status == OCI_SUCCESS）{exec_bind_xml（svchp，errhp，stmthp，（void *）doc，xmltdo，ins_stmt））; } / * free xml ctx * / OCIXmlDbFreeXmlCtx（xctx）; } / * ----------------------------------------------- --------- * / / *执行一个绑定xml数据的sql语句* / / * ------------------------- ------------------------------- * / sword exec_bind_xml（svchp，errhp，stmthp，xml，xmltdo，sqlstmt）OCISvcCtx * svchp; OCIError * errhp; OCIStmt * stmthp; void * xml; OCIType * xmltdo; OraText * sqlstmt; {OCIBind * bndhp1 =（OCIBind *）0; OCIBind * bndhp2 =（OCIBind *）0;剑状态= 0; OCIInd ind = OCI_IND_NOTNULL; OCIInd * indp =＆ind; if（status = OCIStmtPrepare（stmthp，errhp，（OraText *）sqlstmt，（ub4）strlen（（char *）sqlstmt），（ub4）OCI_NTV_SYNTAX，（ub4）OCI_DEFAULT））{return OCI_ERROR; } if（status = OCIBindByPos（stmthp，＆bndhp1，errhp，（ub4）1，（dvoid *）0，（sb4）0，SQLT_NTY，（dvoid *）0，（ub2 *）0，（ub2 *）0，（ ub4）0，（ub4 *）0，（ub4）OCI_DEFAULT））{return OCI_ERROR; } if（status = OCIBindObject（bndhp1，errhp，（CONST OCIType *）xmltdo，（dvoid **）＆xml，（ub4 *）0，（dvoid **）＆indp，（ub4 *）0））{return OCI_ERROR; } if（status = OCIStmtExecute（svchp，stmthp，errhp，（ub4）1，（ub4）0，（CONST OCISnapshot *）0，（OCISnapshot *）0，（ub4）OCI_DEFAULT））{return OCI_ERROR; } return OCI_SUCCESS; }</code></pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-649191E3-099B-49C4-97E3-4DC58F3960C0__CCHDJDBE">
                        <p class="titleinexample">示例5-9使用DOM API修改数据库文档</p><pre class="pre codeblock"><code>#include &lt;xml.h&gt; #include &lt;ocixmldb.h&gt; sword example2（）{OCIEnv * envhp; OCIError * errhp; OCISvcCtx * svchp; OCIStmt * stmthp; OCIDuration dur; OCIType * xmltdo; xmldocnode * doc; xmlnodelist * item_list; ub4 ilist_l; ocixmldbparam params [1]; text * sel_xml_stmt =（text *）“SELECT xml_col FROM my_table”; ub4 xmlsize = 0;剑状态= 0; OCIDefine * defnp =（OCIDefine *）0; / *初始化envhp，svchp，errhp，dur，stmthp * / / * ...* / / *获取xml上下文* / params [0] .name_ocixmldbparam = XCTXINIT_OCIDUR; params [0] .value_ocixmldbparam =＆dur; xctx = OCIXmlDbInitXmlCtx（envhp，svchp，errhp，params，1）; / *开始处理* / if（status = OCITypeByName（envhp，errhp，svchp，（const text *）“SYS”，（ub4）strlen（（char *）“SYS”），（const text *）“XMLTYPE”， （ub4）strlen（（char *）“XMLTYPE”），（CONST text *）0，（ub4）0，dur，OCI_TYPEGET_HEADER，（OCIType **）xmltdo_p））{return OCI_ERROR; if（！（* xmltdo_p））{printf（“NULL tdo returns \ n”）;返回OCI_ERROR; } if（status = OCIStmtPrepare（stmthp，errhp，（OraText *）selstmt，（ub4）strlen（（char *）selstmt），（ub4）OCI_NTV_SYNTAX，（ub4）OCI_DEFAULT））{return OCI_ERROR; } if（status = OCIDefineByPos（stmthp，＆defnp，errhp，（ub4）1，（dvoid *）0，（sb4）0，SQLT_NTY，（dvoid *）0，（ub2 *）0，（ub2 *）0，（ ub4）OCI_DEFAULT））{return OCI_ERROR; } if（status = OCIDefineObject（defnp，errhp，（OCIType *）* xmltdo_p，（dvoid **）＆doc，＆xmlsize，（dvoid **）0，（ub4 *）0））{return OCI_ERROR; } if（status = OCIStmtExecute（svchp，stmthp，errhp，（ub4）1，（ub4）0，（CONST OCISnapshot *）0，（OCISnapshot *）0，（ub4）OCI_DEFAULT））{return OCI_ERROR;我们有文件。现在我们可以对它进行操作* / printf（“获取项目列表...... \ n”）; item_list = XmlDomGetElemsByTag（xctx，（xmlelemnode *）elem，（oratext *）“Item”）; ilist_l = XmlDomGetNodeListLength（xctx，item_list）; printf（“项目列表长度=％d \ n”，ilist_l）; for（i = 0; i &lt;ilist_l; i ++）{elem = XmlDomGetNodeListItem（xctx，item_list，i）; printf（“Elem Name：％s \ n”，XmlDomGetNodeName（xctx，fragelem））; XmlDomRemoveChild（xctx，fragelem）; XmlSaveDom（xctx，＆err，doc，“stdio”，stdout，NULL）; / * free xml ctx * / OCIXmlDbFreeXmlCtx（xctx）;返回OCI_SUCCESS; }</code></pre></div>
                     <!-- class="example" -->
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>