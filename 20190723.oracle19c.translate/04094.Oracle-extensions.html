<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <title>Oracle Extensions</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="JDBC Developer&#39;s Guide"></meta>
      <meta property="og:description" content=""></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="JDBC Developer&#39;s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="jdbc-developers-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-02-13T13:20:37-08:00"></meta>
      <meta name="dcterms.title" content="JDBC Developer&#39;s Guide"></meta>
      <meta name="dcterms.dateCopyrighted" content="1999, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96471-02"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="JDBC-standards-support.html" title="Previous" type="text/html"></link>
      <link rel="next" href="JDBC-Thin-features.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.isVersionOf" content="JJDBC"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="JDBC-standards-support.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="JDBC-Thin-features.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">JDBC开发人员指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="overview-Oracle-JDBC.html" property="item" typeof="WebPage"><span property="name">Oracle JDBC</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">Oracle Extensions</li>
            </ol>
            <a id="GUID-2A28CD5C-7696-4EFF-B9AF-8A62E89E3652" name="GUID-2A28CD5C-7696-4EFF-B9AF-8A62E89E3652"></a><a id="JJDBC28120"></a>
            
            <h2 id="JJDBC-GUID-2A28CD5C-7696-4EFF-B9AF-8A62E89E3652" class="sect2"><span class="enumeration_chapter">4个</span> Oracle扩展</h2>
         </header>
         <div class="ind">
            <div>
               <p><a id="d23567e21" class="indexterm-anchor"></a><a id="d23567e25" class="indexterm-anchor"></a> Oracle提供了扩展Java数据库连接（JDBC）标准实现的Java类和接口，使您能够访问和操作Oracle数据类型并使用Oracle性能扩展。本章概述了Oracle提供的扩展JDBC标准实现的类和接口。它还描述了扩展的一些关键支持功能。
               </p>
               <p>本章包含以下部分：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="Oracle-extensions.html#GUID-AC9387F5-5333-4602-9C43-467CCBCD67A2">Oracle Extensions概述</a></p>
                  </li>
                  <li>
                     <p><a href="Oracle-extensions.html#GUID-868B15D0-71BF-4501-83F6-11ABCE319803">Oracle Extensions的功能</a></p>
                  </li>
                  <li>
                     <p><a href="Oracle-extensions.html#GUID-D61F7AAC-3708-4437-8070-52F707B68259">Oracle JDBC包</a></p>
                  </li>
                  <li>
                     <p><a href="Oracle-extensions.html#GUID-E180187D-07AA-4D64-9946-4D08FBB2E46E">Oracle字符数据类型支持</a></p>
                  </li>
                  <li>
                     <p><a href="Oracle-extensions.html#GUID-0DA598C9-4C4E-42D7-B581-B971B8D87A96">其他Oracle Type Extensions</a></p>
                  </li>
                  <li>
                     <p><a href="Oracle-extensions.html#GUID-9EC82134-1206-4325-A17B-9FA7610F0169">DML返回</a></p>
                  </li>
                  <li>
                     <p><a href="Oracle-extensions.html#GUID-2EF2089E-11B3-4395-8464-E6EFC23285AB">访问PL / SQL关联数组</a></p>
                  </li>
               </ul>
            </div>
            <div>
               <div class="relinfo">
                  <p><strong>相关话题</strong></p>
                  <ul>
                     <li><a href="performance-extensions.html#GUID-FEECA64F-44F4-453F-B8A8-AFBF6D29ABA4">性能扩展</a></li>
                  </ul>
               </div>
            </div>
            <a id="JJDBC28121"></a><div class="props_rev_3"><a id="GUID-AC9387F5-5333-4602-9C43-467CCBCD67A2" name="GUID-AC9387F5-5333-4602-9C43-467CCBCD67A2"></a><h3 id="JJDBC-GUID-AC9387F5-5333-4602-9C43-467CCBCD67A2" class="sect3"><span class="enumeration_section">4.1</span> Oracle Extensions概述</h3>
               <div>
                  <p>除标准功能外，Oracle JDBC驱动程序还提供特定于Oracle的类型扩展和性能扩展。这些扩展通过以下Java包提供：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><code class="codeph">oracle.sql</code></p>
                        <p>提供以Oracle格式表示SQL数据的类</p>
                     </li>
                     <li>
                        <p><code class="codeph">oracle.jdbc</code></p>
                        <p>提供支持Oracle类型格式的数据库访问和更新的接口</p>
                     </li>
                  </ul>
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="Oracle-extensions.html#GUID-D61F7AAC-3708-4437-8070-52F707B68259">Oracle JDBC包</a></li>
                     </ul>
                  </div>
               </div>
               
            </div><a id="JJDBC28122"></a><div class="props_rev_3"><a id="GUID-868B15D0-71BF-4501-83F6-11ABCE319803" name="GUID-868B15D0-71BF-4501-83F6-11ABCE319803"></a><h3 id="JJDBC-GUID-868B15D0-71BF-4501-83F6-11ABCE319803" class="sect3"><span class="enumeration_section">4.2</span> Oracle Extensions的功能</h3>
               <div>
                  <div class="section">
                     <p>Oracle的JDBC扩展包括许多增强您使用Oracle数据库的功能。这些包括以下内容：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="Oracle-extensions.html#GUID-CC7CA29D-EDD8-42C8-9730-F03C279CC13B">使用JDBC进行数据库管理</a></p>
                        </li>
                        <li>
                           <p><a href="Oracle-extensions.html#GUID-98B72A83-155A-438A-BC8A-C88F89D24233">支持Oracle数据类型</a></p>
                        </li>
                        <li>
                           <p><a href="Oracle-extensions.html#GUID-2B5B46DD-5608-4407-A5D9-4944567487D1">支持Oracle Objects</a></p>
                        </li>
                        <li>
                           <p><a href="Oracle-extensions.html#GUID-FA1A98DC-9D88-4038-8C2F-839D659C813C">支持架构命名</a></p>
                        </li>
                        <li>
                           <p><a href="Oracle-extensions.html#GUID-27FDA3E3-6E75-4970-8274-8AECAA10E235">DML返回</a></p>
                        </li>
                        <li>
                           <p><a href="Oracle-extensions.html#GUID-6FD9F303-8C2F-42A8-AD4E-106FE155891A">关于访问PL / SQL关联数组</a></p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
               </div><a id="JJDBC28123"></a><div class="props_rev_3"><a id="GUID-CC7CA29D-EDD8-42C8-9730-F03C279CC13B" name="GUID-CC7CA29D-EDD8-42C8-9730-F03C279CC13B"></a><h4 id="JJDBC-GUID-CC7CA29D-EDD8-42C8-9730-F03C279CC13B" class="sect4"><span class="enumeration_section">4.2.1</span>使用JDBC进行数据库管理</h4>
                  <div>
                     <div class="section">
                        <p>从Oracle Database <span class="italic">11g</span>第1版开始， <code class="codeph">oracle.jdbc.OracleConnection</code>接口有两个JDBC方法， <code class="codeph">startup</code>和<code class="codeph">shutdown</code> ，使您可以启动和关闭Oracle数据库实例。
                        </p>
                        <div class="infoboxnote" id="GUID-CC7CA29D-EDD8-42C8-9730-F03C279CC13B__GUID-8738A08A-2248-4076-B7CD-6E9975A4FFC3">
                           <p class="notep1">注意：</p>
                           <p>我的Oracle支持说明335754.1宣布Oracle Database <span class="italic">11g</span> JDBC驱动程序中对<code class="codeph">oracle.jdbc.driver.*</code>包的支持。换句话说，Oracle Database <span class="italic">10g</span>第2版是支持此软件包的最后一个数据库，任何依赖于<code class="codeph">oracle.jdbc.driver.*</code>软件包的API都无法在当前版本的数据库中进行编译。您必须删除此类API并迁移到标准API。例如，如果您的代码使用<code class="codeph">oracle.jdbc.CustomDatum</code>和<code class="codeph">oracle.jdbc.CustomDatumFactory</code>接口，然后必须用<code class="codeph">java.sql.替换它们<code class="codeph">java.sql.Struct</code>或<code class="codeph">java.sql.SQLData</code>接口。
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="database-administration.html#GUID-6EC16CE6-5734-473E-A270-EB387A9C0043">数据库管理</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div><a id="JJDBC28125"></a><div class="props_rev_3"><a id="GUID-98B72A83-155A-438A-BC8A-C88F89D24233" name="GUID-98B72A83-155A-438A-BC8A-C88F89D24233"></a><h4 id="JJDBC-GUID-98B72A83-155A-438A-BC8A-C88F89D24233" class="sect4"><span class="enumeration_section">4.2.2</span>支持Oracle数据类型</h4>
                  <div>
                     <div class="section">
                        <p>Oracle JDBC扩展的一个特性是类型支持<a id="d23567e283" class="indexterm-anchor"></a> <code class="codeph">oracle.sql</code>包。此包包含的类是Oracle格式数据的精确表示。在程序中使用<code class="codeph">oracle.sql</code>类型时，请记住以下要点：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>对于数字类型的数据，由于数据转换过程的限制，转换为标准Java类型并不能保证保持完整的精度。使用<code class="codeph">BigDecimal</code>类型可以最大限度地减少任何数据丢失问题。
                              </p>
                           </li>
                           <li>
                              <p>对于某些数据类型，转换为标准Java类型可能取决于系统设置，并且您的程序可能无法按预期运行。将数据从<code class="codeph">oracle.sql</code>类型转换为标准Java类型时，这是一个已知的限制。
                              </p>
                           </li>
                           <li>
                              <p>如果程序的功能仅限于从一个表读取数据并将其写入另一个表，那么对于数字和日期数据，与标准Java类型相比， <code class="codeph">oracle.sql</code>类型稍微快一些。但是，如果您的程序甚至涉及比较或打印等简单的数据操作操作，那么标准Java类型会更快。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">oracle.sql。CHAR</code>不是Oracle格式数据的精确表示。 <code class="codeph">oracle.sql.CHAR</code>由<code class="codeph">java.lang.构造<code class="codeph">java.lang.String</code> 。使用<code class="codeph">oracle.sql.没有任何优势<code class="codeph">oracle.sql.CHAR</code>因为<code class="codeph">java.lang.String</code>总是更快并且表示相同的字符集，不包括一些不支持的字符集。
                              </p>
                           </li>
                        </ul>
                        <div class="infoboxnote" id="GUID-98B72A83-155A-438A-BC8A-C88F89D24233__GUID-2B89DBAD-D736-4D0F-8676-47D21B701124">
                           <p class="notep1">注意：</p>
                           <p>Oracle强烈建议您使用标准Java类型，并将任何现有的<code class="codeph">oracle.sql</code>类型的数据转换为标准Java类型。在内部，Oracle JDBC驱动程序致力于最大化Java标准类型的性能。支持<code class="codeph">oracle.sql</code>类型<span class="italic">只是</span>为了向后兼容，不鼓励使用它们。
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="Oracle-extensions.html#GUID-DB1F687A-CF1C-4B3F-92C0-126DC782EF53">包oracle.sql</a></li>
                           <li><a href="Oracle-extensions.html#GUID-E180187D-07AA-4D64-9946-4D08FBB2E46E">Oracle字符数据类型支持</a></li>
                           <li><a href="Oracle-extensions.html#GUID-0DA598C9-4C4E-42D7-B581-B971B8D87A96">其他Oracle Type Extensions</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div><a id="JJDBC28126"></a><div class="props_rev_3"><a id="GUID-2B5B46DD-5608-4407-A5D9-4944567487D1" name="GUID-2B5B46DD-5608-4407-A5D9-4944567487D1"></a><h4 id="JJDBC-GUID-2B5B46DD-5608-4407-A5D9-4944567487D1" class="sect4"><span class="enumeration_section">4.2.3</span>支持Oracle Objects</h4>
                  <div>
                     <div class="section">
                        <p>Oracle JDBC支持在数据库中使用结构化对象，其中对象数据类型是具有嵌套属性的用户定义类型。例如，用户应用程序可以定义<code class="codeph">Employee</code>对象类型，其中每个<code class="codeph">Employee</code>对象都具有<code class="codeph">firstname</code>属性（字符串）， <code class="codeph">lastname</code>属性（字符串）和<code class="codeph">employeenumber</code>属性（整数）。
                        </p>
                        <p>Oracle JDBC支持Oracle对象数据类型。在Java应用程序中使用Oracle对象数据类型时，必须考虑以下事项：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>如何在Oracle对象数据类型和Java类之间进行映射</p>
                           </li>
                           <li>
                              <p>如何在相应的Java对象中存储Oracle对象属性</p>
                           </li>
                           <li>
                              <p>如何在SQL和Java格式之间转换属性数据</p>
                           </li>
                           <li>
                              <p>如何访问数据</p>
                           </li>
                        </ul>
                        <p>Oracle对象可以映射到弱<code class="codeph">java.sql.Struct</code>类型或强类型自定义类。这些强类型被称为<a id="d23567e429" class="indexterm-anchor"></a>自定义Java类，必须实现标准<code class="codeph">java.sql.SQLData</code>接口或Oracle扩展<code class="codeph">oracle.jdbc.OracleData</code>接口。每个接口都指定在SQL和Java之间转换数据的方法。
                        </p>
                        <div class="infoboxnote" id="GUID-2B5B46DD-5608-4407-A5D9-4944567487D1__GUID-C4651E43-F902-4F14-878D-E53083867727">
                           <p class="notep1">注意：</p>
                           <p>从Oracle Database 12 <span class="italic">c</span>第1版（12.1）开始， <code class="codeph">OracleData</code>接口已取代<code class="codeph">ORAData</code>接口。
                           </p>
                        </div>
                        <p>Oracle建议使用Oracle JVM Web服务调用实用程序来创建与Oracle对象对应的自定义Java类。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="Oracle-object-types.html#GUID-5905674A-A045-40B1-96DE-726761517D50">使用Oracle对象类型</a></li>
                           <li><a href="../jjdev/database-as-web-service-consumer.html#JJDEV-GUID-E66168C4-6043-4A49-9062-A4937B76ABC0" target="_blank"><span><cite>Oracle数据库Java开发人员指南</cite></span></a></li>
                        </ul>
                     </div>
                  </div>
               </div><a id="JJDBC28127"></a><div class="props_rev_3"><a id="GUID-FA1A98DC-9D88-4038-8C2F-839D659C813C" name="GUID-FA1A98DC-9D88-4038-8C2F-839D659C813C"></a><h4 id="JJDBC-GUID-FA1A98DC-9D88-4038-8C2F-839D659C813C" class="sect4"><span class="enumeration_section">4.2.4</span>支持模式命名</h4>
                  <div>
                     <p>Oracle对象数据类型类具有接受和返回完全限定的模式名称的能力。完全限定的模式名称具有以下语法：</p><pre class="oac_no_warn" dir="ltr">{[ <span class="italic">schema_name</span> ]。} [ <span class="italic">sql_type_name]</span> 
 </pre><p>其中， <span class="italic"><code class="codeph">schema_name</code></span>是模式的名称， <span class="italic"><code class="codeph">sql_type_name</code></span>是对象的SQL类型名称。 <span class="italic"><code class="codeph">schema_name</code></span>和<span class="italic"><code class="codeph">sql_type_name</code></span>由句点（ <code class="codeph">.</code> ）分隔。
                     </p>
                     <p>要在JDBC中指定对象类型，请使用其完全限定名称。如果类型名称在当前命名空间（即当前架构）中，则无需输入架构名称。模式命名遵循以下规则：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>架构名称和类型名称都可以在引号内，也可以不在引号内。但是，如果SQL类型名称中包含句点，例如<code class="codeph">CORPORATE.EMPLOYEE</code> ，则必须引用类型名称。
                           </p>
                        </li>
                        <li>
                           <p>JDBC驱动程序在对象名称中查找不在引号内的第一个句点，并使用句点之前的字符串作为模式名称，并将句点后面的字符串用作类型名称。如果未找到句点，则JDBC驱动程序将当前架构视为默认值。也就是说，如果对象类型名称属于当前架构，则只能指定类型名称而不指示架构，而不是指定完全限定名称。这也解释了为什么必须在类型名称中包含点的情况下将类型名称放在引号内。</p>
                           <p>例如，假设用户<code class="codeph">HR</code>创建了一个名为<code class="codeph">person.address</code>的类型，然后想要在他的会话中使用它。<code class="codeph">HR</code>可能希望跳过模式名称并将<code class="codeph">person.address</code>传递给JDBC驱动程序。在这种情况下，如果<code class="codeph">person.address</code>不在引号内，则检测到句点，并且JDBC驱动程序错误地将<code class="codeph">person</code>解释为模式名称和<code class="codeph">address</code>作为类型名称。
                           </p>
                        </li>
                        <li>
                           <p>JDBC将对象类型名称字符串传递给数据库不变。也就是说，即使对象类型名称在引号内，JDBC驱动程序也不会更改字符大小写。</p>
                           <p>例如，如果<code class="codeph">HR.PersonType</code>作为对象类型名称传递给JDBC驱动程序，则JDBC驱动程序将字符串传递给数据库不变。另一个例子，如果类型名称字符串中的字符之间有空格，则JDBC驱动程序不会删除空格。
                           </p>
                        </li>
                     </ul>
                  </div>
               </div><a id="JJDBC28128"></a><div class="props_rev_3"><a id="GUID-27FDA3E3-6E75-4970-8274-8AECAA10E235" name="GUID-27FDA3E3-6E75-4970-8274-8AECAA10E235"></a><h4 id="JJDBC-GUID-27FDA3E3-6E75-4970-8274-8AECAA10E235" class="sect4"><span class="enumeration_section">4.2.5</span> DML返回</h4>
                  <div>
                     <div class="section">
                        <p>Oracle数据库支持将<code class="codeph">RETURNING</code>子句与数据操作语言（DML）语句一起使用。这使您可以将两个SQL语句合并为一个。Oracle JDBC Oracle调用接口（OCI）驱动程序和Oracle JDBC Thin驱动程序都支持DML返回。
                        </p>
                        <div class="infoboxnotealso" id="GUID-27FDA3E3-6E75-4970-8274-8AECAA10E235__GUID-4713F5FF-DAFE-4DDF-92D2-98EF0E263B92">
                           <p class="notep1">也可以看看：</p>
                           <p><span class="q">“ <a href="Oracle-extensions.html#GUID-9EC82134-1206-4325-A17B-9FA7610F0169">DML回归</a> ”</span></p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JJDBC28129"></a><div class="props_rev_3"><a id="GUID-6FD9F303-8C2F-42A8-AD4E-106FE155891A" name="GUID-6FD9F303-8C2F-42A8-AD4E-106FE155891A"></a><h4 id="JJDBC-GUID-6FD9F303-8C2F-42A8-AD4E-106FE155891A" class="sect4"><span class="enumeration_section">4.2.6</span> PL / SQL关联数组</h4>
                  <div>
                     <div class="section">
                        <p>Oracle JDBC驱动程序使JDBC应用程序能够使用关联数组参数进行PL / SQL调用。Oracle JDBC驱动程序支持标量数据类型的PL / SQL关联数组</p>
                        <div class="infoboxnotealso" id="GUID-6FD9F303-8C2F-42A8-AD4E-106FE155891A__GUID-DC8286DE-0320-4779-936C-D430454421EE">
                           <p class="notep1">也可以看看：</p>
                           <p><span class="q">“ <a href="Oracle-extensions.html#GUID-2EF2089E-11B3-4395-8464-E6EFC23285AB">访问PL / SQL关联数组</a> ”</span></p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="JJDBC28130"></a><div class="props_rev_3"><a id="GUID-D61F7AAC-3708-4437-8070-52F707B68259" name="GUID-D61F7AAC-3708-4437-8070-52F707B68259"></a><h3 id="JJDBC-GUID-D61F7AAC-3708-4437-8070-52F707B68259" class="sect3"><span class="enumeration_section">4.3</span> Oracle JDBC包</h3>
               <div>
                  <div class="section">
                     <p>本节介绍以下支持Oracle JDBC扩展的Java包：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="Oracle-extensions.html#GUID-DB1F687A-CF1C-4B3F-92C0-126DC782EF53">包oracle.sql</a></p>
                        </li>
                        <li>
                           <p><a href="Oracle-extensions.html#GUID-7AA5D4CC-57C2-4E85-8486-45B52D447B66">包oracle.jdbc</a></p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
               </div><a id="JJDBC28132"></a><a id="JJDBC28133"></a><a id="JJDBC28134"></a><a id="JJDBC28136"></a><a id="JJDBC28137"></a><a id="JJDBC28138"></a><a id="JJDBC28139"></a><a id="JJDBC28131"></a><div class="props_rev_3"><a id="GUID-DB1F687A-CF1C-4B3F-92C0-126DC782EF53" name="GUID-DB1F687A-CF1C-4B3F-92C0-126DC782EF53"></a><h4 id="JJDBC-GUID-DB1F687A-CF1C-4B3F-92C0-126DC782EF53" class="sect4"><span class="enumeration_section">4.3.1</span>打包oracle.sql</h4>
                  <div>
                     <div class="section">
                        <p><code class="codeph">oracle.sql</code>包支持以SQL格式直接访问数据。该包主要包含为SQL数据类型及其支持类提供Java映射的类。本质上，这些类充当SQL数据的Java容器。
                        </p>
                        <p>每个<code class="codeph">oracle.sql.*</code>数据类型类都扩展了<code class="codeph">oracle.sql.Datum</code> ，一个封装所有数据类型共有的功能的超类。某些类适用于符合JDBC 2.0的数据类型。这些类在<code class="codeph">java.sql</code>包中实现标准的JDBC 2.0接口，以及扩展<code class="codeph">oracle.sql.Datum</code>类。
                        </p>
                        <p><code class="codeph">LONG</code>和<code class="codeph">LONG</code> <code class="codeph">RAW</code> SQL类型和<code class="codeph">REF</code> <code class="codeph">CURSOR</code>类型类没有<code class="codeph">oracle.sql.*</code>类。对这些类型使用标准JDBC功能。例如，使用标准JDBC结果集和可调用语句方法<code class="codeph">getBinaryStream</code>和<code class="codeph">getCharacterStream</code>检索<code class="codeph">LONG</code>或<code class="codeph">LONG</code> <code class="codeph">RAW</code>数据作为输入流。对<code class="codeph">REF</code> <code class="codeph">CURSOR</code>类型使用<code class="codeph">getCursor</code>方法。
                        </p>
                        <div class="infoboxnote" id="GUID-DB1F687A-CF1C-4B3F-92C0-126DC782EF53__GUID-7FC029E1-8DDA-4D00-8AA2-7E42A285F657">
                           <p class="notep1">注意：</p>
                           <p>Oracle建议尽可能使用标准JDBC类型或Java类型。提供<code class="codeph">oracle.sql.*</code>包中的类型主要是为了向后兼容或支持一些Oracle特定功能，如<code class="codeph">OPAQUE</code> ， <code class="codeph">OracleData</code> ， <code class="codeph">TIMESTAMPTZ</code>等。
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-DB1F687A-CF1C-4B3F-92C0-126DC782EF53__GUID-71C625B6-4E30-487F-9C52-5CE080BCD26A">一般oracle.sql。*数据类型支持</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>每一个<a id="d23567e802" class="indexterm-anchor"></a> Oracle数据类型类提供了以下内容：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>数据存储为SQL数据的Java字节数组</p>
                           </li>
                           <li>
                              <p>一个<code class="codeph">getBytes()</code>方法，它将SQL数据作为字节数组返回</p>
                           </li>
                           <li>
                              <p>一种<code class="codeph">toJdbc()</code>方法，它将数据转换为JDBC规范中定义的相应Java类的对象</p>
                              <p>JDBC驱动程序不转换不属于JDBC规范的特定于Oracle的数据类型，例如<code class="codeph">BFILE</code> 。驱动程序以相应的<code class="codeph">oracle.sql.*</code>格式返回对象。
                              </p>
                           </li>
                           <li>
                              <p>适当的<span class="italic"><code class="codeph">xxx</code></span> <code class="codeph">Value</code>方法将SQL数据转换为Java类型。例如， <code class="codeph">stringValue</code> ， <code class="codeph">intValue</code> ， <code class="codeph">booleanValue</code> ， <code class="codeph">dateValue</code>和<code class="codeph">bigDecimalValue</code></p>
                           </li>
                           <li>
                              <p>其他转换方法，根据需要<code class="codeph">get</code> <span class="italic"><code class="codeph">XXX</code></span>和<code class="codeph">set</code> <span class="italic"><code class="codeph">XXX</code></span>以获取数据类型的功能，例如将数据作为流获取的大对象（LOB）类中的方法以及获取和设置对象的<code class="codeph">REF</code>类中的方法数据通过对象引用。
                              </p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-DB1F687A-CF1C-4B3F-92C0-126DC782EF53__I1075337">
                        <p class="subhead3" id="GUID-DB1F687A-CF1C-4B3F-92C0-126DC782EF53__GUID-274246BF-8C24-4569-9C06-2F7F26A14E15">类oracle.sql概述。STRUCT</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p><code class="codeph">oracle.sql。STRUCT</code>类是<code class="codeph">java.sql.的Oracle实现<code class="codeph">java.sql.Struct</code>界面。此类是值类，您不应在构造后更改类的内容。与所有<code class="codeph">oracle.sql.*</code>数据类型类一样，此类是<code class="codeph">oracle.sql.的子类<code class="codeph">oracle.sql.Datum</code>类。
                        </p>
                        <div class="infoboxnote" id="GUID-DB1F687A-CF1C-4B3F-92C0-126DC782EF53__GUID-42E3AD51-0D59-4EB3-AFB0-C6FB9E69EEE7">
                           <p class="notep1">注意：</p>
                           <p>从Oracle Database 12 <span class="italic">c</span>第1版（12.1）开始， <code class="codeph">oracle.sql.不推荐使用STRUCT</code>类，并将其替换为<code class="codeph">oracle.jdbc.OracleStruct</code>接口，它是<code class="codeph">oracle.jdbc</code>包的一部分。Oracle强烈建议您尽可能使用<code class="codeph">java.sql</code>包中提供的方法，以获得Oracle特定扩展的<code class="codeph">oracle.jdbc</code>包中提供的标准兼容性和方法。有关<code class="codeph">oracle.jdbc.更多信息，请参阅MoS Note 1364193.1 <code class="codeph">oracle.jdbc.OracleStruct</code>接口。
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-DB1F687A-CF1C-4B3F-92C0-126DC782EF53__GUID-EBA55865-F5EA-4C0D-BBA5-7DCBC0BAC8EC">类oracle.sql概述。REF</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p><code class="codeph">oracle.sql.REF</code>类是支持Oracle对象引用的泛型类。与所有<code class="codeph">oracle.sql.*</code>数据类型类一样，此类是<code class="codeph">oracle.sql.的子类<code class="codeph">oracle.sql.Datum</code>类。
                        </p>
                        <div class="infoboxnote" id="GUID-DB1F687A-CF1C-4B3F-92C0-126DC782EF53__GUID-70192D47-A0D5-4EFC-B689-A3733F21B37F">
                           <p class="notep1">注意：</p>
                           <p>从Oracle Database 12 <span class="italic">c</span>第1版（12.1）开始， <code class="codeph">oracle.sql.不推荐使用REF</code>类，并将其替换为<code class="codeph">oracle.jdbc.OracleRef</code>接口，它是<code class="codeph">oracle.jdbc</code>包的一部分。Oracle强烈建议您尽可能使用<code class="codeph">java.sql</code>包中提供的方法，以获得Oracle特定扩展的<code class="codeph">oracle.jdbc</code>包中提供的标准兼容性和方法。有关<code class="codeph">oracle.jdbc.更多信息，请参阅MoS Note 1364193.1 <code class="codeph">oracle.jdbc.OracleRef</code>接口。
                           </p>
                        </div>
                        <p><code class="codeph">REF</code>类具有检索和传递对象引用的方法。但是，选择对象引用仅检索指向对象的指针。这不会实现对象本身。但<code class="codeph">REF</code>类还包括检索和传递对象数据的方法。您无法在JDBC应用程序中创建<code class="codeph">REF</code>对象。您只能从数据库中检索现有的<code class="codeph">REF</code>对象。
                        </p>
                        <p>您应该使用JDBC标准类型<code class="codeph">java.sql.Ref</code>和JDBC标准方法优先使用<code class="codeph">oracle.sql.REF</code> 。如果希望代码更具可移植性，则必须使用标准类型，因为只有Oracle JDBC驱动程序才会使用<code class="codeph">oracle.sql.实例<code class="codeph">oracle.sql.REF</code>类型。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-DB1F687A-CF1C-4B3F-92C0-126DC782EF53__GUID-3162BA52-E80E-4EC3-8B0C-573B70FFE05C">类oracle.sql概述。BLOB，oracle.sql。CLOB，oracle.sql。BFILE</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p><a id="d23567e985" class="indexterm-anchor"></a><a id="d23567e987" class="indexterm-anchor"></a><a id="d23567e989" class="indexterm-anchor"></a><a id="d23567e991" class="indexterm-anchor"></a><a id="d23567e995" class="indexterm-anchor"></a><a id="d23567e999" class="indexterm-anchor"></a>二进制大对象（BLOB），字符大对象（CLOB）和二进制文件（BFILE）用于太大而无法直接存储在数据库表中的数据项。相反，数据库表存储指向实际数据位置的定位器。
                        </p>
                        <div class="infoboxnote" id="GUID-DB1F687A-CF1C-4B3F-92C0-126DC782EF53__GUID-00FA74C8-7830-4208-81BF-CCA02015CF00">
                           <p class="notep1">注意：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>从Oracle Database 12 <span class="italic">c</span>第1版（12.1）开始， <code class="codeph">oracle.sql.BLOB</code>和<code class="codeph">Oracle.sql.不推荐使用CLOB</code>类，并将其替换为<code class="codeph">oracle.jdbc.OracleBlob</code>和<code class="codeph">oracle.jdbc.OracleClob</code>接口分别是<code class="codeph">oracle.jdbc</code>包的一部分。Oracle强烈建议您尽可能使用<code class="codeph">java.sql</code>包中提供的方法，以获得Oracle特定扩展的<code class="codeph">oracle.jdbc</code>包中提供的标准兼容性和方法。有关<code class="codeph">oracle.jdbc.更多信息，请参阅MoS Note 1364193.1 <code class="codeph">oracle.jdbc.OracleBlob</code>和<code class="codeph">oracle.jdbc.OracleClob</code>接口。
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">oracle.sql。BFILE</code>是Oracle专有扩展，没有等效的JDBC标准。
                                 </p>
                              </li>
                           </ul>
                        </div>
                        <p><code class="codeph">oracle.sql</code>包以几种方式支持这些数据类型：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>BLOB指向大型非结构化二进制数据项，并由<code class="codeph">oracle.sql.支持<code class="codeph">oracle.sql.BLOB</code>类。
                              </p>
                           </li>
                           <li>
                              <p>CLOB指向大字符数据项，并由<code class="codeph">oracle.sql.支持<code class="codeph">oracle.sql.CLOB</code>类。
                              </p>
                           </li>
                           <li>
                              <p>BFILE指向外部文件（操作系统文件）的内容，并受<code class="codeph">oracle.sql.支持<code class="codeph">oracle.sql.BFILE</code>类。BFiles是只读的。
                              </p>
                           </li>
                        </ul>
                        <p>你可以选择一个BLOB， <a id="d23567e1071" class="indexterm-anchor"></a><a id="d23567e1075" class="indexterm-anchor"></a> CLOB，或<a id="d23567e1082" class="indexterm-anchor"></a>来自数据库的BFILE定位器使用标准的<code class="codeph">SELECT</code>语句。但是，您只收到定位器，而不是数据。检索数据需要其他步骤。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-DB1F687A-CF1C-4B3F-92C0-126DC782EF53__GUID-F81B776A-7B4E-44CC-907F-0A8F9D665FB7">类oracle.sql概述。DATE，oracle.sql。NUMBER和oracle.sql。生的</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p><a id="d23567e1093" class="indexterm-anchor"></a><a id="d23567e1095" class="indexterm-anchor"></a><a id="d23567e1097" class="indexterm-anchor"></a><a id="d23567e1099" class="indexterm-anchor"></a><a id="d23567e1101" class="indexterm-anchor"></a><a id="d23567e1103" class="indexterm-anchor"></a><a id="d23567e1105" class="indexterm-anchor"></a><a id="d23567e1109" class="indexterm-anchor"></a>这些类在Oracle本机表示中包含原始SQL数据类型。在大多数情况下，驱动程序不会在内部使用这些类型，您应该使用标准JDBC类型。
                        </p>
                        <p>Java <code class="codeph">Double</code>和<code class="codeph">Float</code> <code class="codeph">NaN</code>值没有等效的Oracle <code class="codeph">NUMBER</code>表示。例如，对于Oracle <code class="codeph">BINARY_FLOAT</code>和<code class="codeph">BINARY_DOUBLE</code>数据类型，负零被强制为正零，并且所有NaN都被强制转换为规范的NaN。因此，只要<code class="codeph">Double. ，就会抛出<code class="codeph">NullPointerException</code> <code class="codeph">Double.NaN</code>值或<code class="codeph">Float.使用<code class="codeph">oracle.sql. NaN</code>值转换为Oracle <code class="codeph">NUMBER</code> <code class="codeph">oracle.sql.NUMBER</code>班。例如，以下代码抛出<code class="codeph">NullPointerException</code> ：</p><pre class="oac_no_warn" dir="ltr">oracle.sql。NUMBER n =新的oracle.sql。数（双。NAN）;的System.out.println（n.doubleValue（））; //抛出NullPointerException</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-DB1F687A-CF1C-4B3F-92C0-126DC782EF53__GUID-E3A7683E-90A3-481E-BB42-4628106CD2BD">类oracle.sql概述。TIMESTAMP，oracle.sql。TIMESTAMPTZ和oracle.sql。TIMESTAMPLTZ</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>JDBC驱动程序支持以下日期/时间数据类型：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">TIMESTAMP</code> （ <code class="codeph">TIMESTAMP</code> ）</p>
                           </li>
                           <li>
                              <p><code class="codeph">TIMESTAMP WITH TIME ZONE</code> （ <code class="codeph">TIMESTAMPTZ</code> ）</p>
                           </li>
                           <li>
                              <p><code class="codeph">TIMESTAMP WITH LOCAL TIME ZONE</code> （ <code class="codeph">TIMESTAMPLTZ</code> ）</p>
                           </li>
                        </ul>
                        <p>JDBC驱动程序允许<code class="codeph">DATE</code>和日期/时间数据类型之间的转换。例如，您可以将<code class="codeph">TIMESTAMP WITH TIME ZONE</code>列作为<code class="codeph">DATE</code>值进行访问。
                        </p>
                        <p>JDBC驱动程序支持业界使用的最流行的时区名称以及JDK中定义的大多数时区名称。使用<code class="codeph">java.util.指定时区<code class="codeph">java.util.TimeZone</code>类。
                        </p>
                        <div class="infoboxnote" id="GUID-DB1F687A-CF1C-4B3F-92C0-126DC782EF53__GUID-88138F75-1730-4ED5-9818-0D3029DBAFD3">
                           <p class="notep1">注意：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>不要使用<code class="codeph">TimeZone.getTimeZone</code>来创建时区对象。Oracle时区数据类型支持的时区名称多于JDK。</p>
                              </li>
                              <li>
                                 <p>如果结果集包含<code class="codeph">TIMESTAMPLTZ</code>列，后跟<code class="codeph">LONG</code>列，则读取<code class="codeph">LONG</code>列会导致错误。
                                 </p>
                              </li>
                           </ul>
                        </div>
                        <p>以下代码显示如何为<code class="codeph">US_PACIFIC</code>创建<code class="codeph">TimeZone</code>和<code class="codeph">Calendar</code>对象， <code class="codeph">US_PACIFIC</code>是JDK中未定义的时区名称：</p><pre class="oac_no_warn" dir="ltr">TimeZone tz = TimeZone.getDefault（）; tz.setID（ “US_PACIFIC”）; GregorianCalendar gcal = new GregorianCalendar（tz）;</pre><p>以下Java类表示SQL日期/时间类型：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">oracle.sql。TIMESTAMP</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">oracle.sql。TIMESTAMPTZ</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">oracle.sql。TIMESTAMPLTZ</code></p>
                           </li>
                        </ul>
                        <p>在<code class="codeph">TIMESTAMP WITH LOCAL TIME ZONE</code>数据访问<code class="codeph">TIMESTAMP WITH LOCAL TIME ZONE</code>之前，请调用<code class="codeph">OracleConnection.setSessionTimeZone(String regionName)</code>方法来设置会话时区。调用此方法时，JDBC驱动程序会设置连接的会话时区并保存会话时区，以便可以使用会话时区调整通过JDBC访问的任何<code class="codeph">TIMESTAMP WITH LOCAL TIME ZONE</code>数据。
                        </p>
                        <div class="infoboxnote" id="GUID-DB1F687A-CF1C-4B3F-92C0-126DC782EF53__GUID-C7C1A672-4B20-4EC5-A512-44EDC2BAAAEA">
                           <p class="notep1">注意：</p>
                           <p><code class="codeph">TIMESTAMP WITH TIME ZONE</code>和<code class="codeph">TIMESTAMP WITH LOCAL TIME ZONE</code>类型可以表示为标准<code class="codeph">java.sql.Timestamp</code>类型。<code class="codeph">TIMESTAMP WITH TIME ZONE</code>和<code class="codeph">TIMESTAMP WITH LOCAL TIME ZONE</code>类型的字节表示<code class="codeph">java.sql.为<code class="codeph">java.sql.Timestamp</code>是直截了当的。这是因为<code class="codeph">TIMESTAMP WITH TIME ZONE</code>和<code class="codeph">TIMESTAMP WITH LOCAL TIME ZONE</code>数据类型的内部格式是GMT和<code class="codeph">java.sql.Timestamp</code>类型对象在内部使用毫秒时间值，该值是自EPOCH以来的毫秒数。但是，这些数据类型的<code class="codeph">String</code>表示需要从服务器动态获取并在客户端缓存的时区信息。
                           </p>
                           <p>在早期版本的JDBC驱动程序中，时区缓存是在不同连接之间共享的。由于各个时区的不兼容性，这通常会导致问题。从Oracle Database 11版本的JDBC驱动程序开始，时区缓存基于数据库提供的时区版本。这种新设计的缓存可避免与时区版本不兼容相关的任何问题。</p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-DB1F687A-CF1C-4B3F-92C0-126DC782EF53__GUID-85C16990-1115-4B49-B5D7-E31C27FB388E">类oracle.sql概述。不透明</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p><code class="codeph">oracle.sql.OPAQUE</code>类提供<code class="codeph">OPAQUE</code>类型的名称和特征以及任何属性。<code class="codeph">OPAQUE</code>类型仅提供对实例的不间断字节的访问。
                        </p>
                        <div class="infoboxnote" id="GUID-DB1F687A-CF1C-4B3F-92C0-126DC782EF53__GUID-E810526C-912F-4B39-B32F-473276E15648">
                           <p class="notep1">注意：</p>
                           <p>从Oracle Database 12 <span class="italic">c</span>第1版（12.1）开始， <code class="codeph">oracle.sql.不推荐使用OPAQUE</code>类，并将其替换为<code class="codeph">oracle.jdbc.OracleOpaque</code>接口，它是<code class="codeph">oracle.jdbc</code>包的一部分。Oracle建议您尽可能使用<code class="codeph">java.sql</code>包中提供的方法，以<code class="codeph">java.sql</code> Oracle特定扩展的<code class="codeph">oracle.jdbc</code>包中提供的标准兼容性和方法。有关<code class="codeph">oracle.jdbc.更多信息，请参阅MoS Note 1364193.1 <code class="codeph">oracle.jdbc.OracleOpaque</code>接口。
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="../sqlrf/Data-Types.html#SQLRF-GUID-75209AF6-476D-4C44-A5DC-5FA70D701B78" target="_blank"><span><cite>Oracle数据库SQL语言参考</cite></span></a></li>
                           <li><a href="http://docs.oracle.com/database/122/JAJDB/" target="_blank">JDBC Java API参考</a></li>
                           <li><a href="LOBs-and-BFiles.html#GUID-401E10DB-16B5-41C9-965E-E5F286F01E4C">使用LOB和BFILE</a></li>
                        </ul>
                     </div>
                  </div>
               </div><a id="JJDBC28140"></a><div class="props_rev_3"><a id="GUID-7AA5D4CC-57C2-4E85-8486-45B52D447B66" name="GUID-7AA5D4CC-57C2-4E85-8486-45B52D447B66"></a><h4 id="JJDBC-GUID-7AA5D4CC-57C2-4E85-8486-45B52D447B66" class="sect4"><span class="enumeration_section">4.3.2</span>打包oracle.jdbc</h4>
                  <div>
                     <div class="section">
                        <p><code class="codeph">oracle.jdbc</code>包的接口定义了<code class="codeph">java.sql</code>接口的Oracle扩展。这些扩展提供对Oracle SQL格式数据和其他Oracle特定功能的访问，包括Oracle性能增强。
                        </p>
                        <div class="infoboxnotealso" id="GUID-7AA5D4CC-57C2-4E85-8486-45B52D447B66__GUID-487760FD-FA2C-4245-AB6D-019381E17145">
                           <p class="notep1">也可以看看：</p>
                           <p><span class="q">“ <a href="Oracle-extensions.html#GUID-E17FE2C3-9384-432C-9040-09EDF98CB8D6">oracle.jdbc包</a> ”</span></p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="JJDBC28141"></a><div class="props_rev_3"><a id="GUID-E180187D-07AA-4D64-9946-4D08FBB2E46E" name="GUID-E180187D-07AA-4D64-9946-4D08FBB2E46E"></a><h3 id="JJDBC-GUID-E180187D-07AA-4D64-9946-4D08FBB2E46E" class="sect3"><span class="enumeration_section">4.4</span> Oracle字符数据类型支持</h3>
               <div>
                  <div class="section">
                     <p>Oracle字符数据类型包括SQL CHAR和NCHAR数据类型。以下部分描述了如何使用<code class="codeph">oracle.sql.*</code>类访问这些数据类型：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="Oracle-extensions.html#GUID-450C64D2-0A26-4E4C-A51E-7B02E0A9D8A8">SQL CHAR数据类型</a></p>
                        </li>
                        <li>
                           <p><a href="Oracle-extensions.html#GUID-9EFED893-8352-4E90-90DA-436D3727F02F">SQL NCHAR数据类型</a></p>
                        </li>
                        <li>
                           <p><a href="Oracle-extensions.html#GUID-CFA6BCB6-9B8A-49E3-BAEF-F68F26A16A88">类oracle.sql。CHAR</a></p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
               </div><a id="JJDBC28142"></a><div class="props_rev_3"><a id="GUID-450C64D2-0A26-4E4C-A51E-7B02E0A9D8A8" name="GUID-450C64D2-0A26-4E4C-A51E-7B02E0A9D8A8"></a><h4 id="JJDBC-GUID-450C64D2-0A26-4E4C-A51E-7B02E0A9D8A8" class="sect4"><span class="enumeration_section">4.4.1</span> SQL CHAR数据类型</h4>
                  <div>
                     <div class="section">
                        <p>SQL CHAR数据类型包括<code class="codeph">CHAR</code> ， <code class="codeph">VARCHAR2</code>和<code class="codeph">CLOB</code> 。这些数据类型允许您以数据库字符集编码方案存储字符数据。创建数据库时会建立数据库的字符集。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JJDBC28143"></a><div class="props_rev_3"><a id="GUID-9EFED893-8352-4E90-90DA-436D3727F02F" name="GUID-9EFED893-8352-4E90-90DA-436D3727F02F"></a><h4 id="JJDBC-GUID-9EFED893-8352-4E90-90DA-436D3727F02F" class="sect4"><span class="enumeration_section">4.4.2</span> SQL NCHAR数据类型</h4>
                  <div>
                     <div class="section">
                        <p>为全球化支持创建了SQL <code class="codeph">NCHAR</code>数据类型。SQL <code class="codeph">NCHAR</code>数据类型包括<code class="codeph">NCHAR</code> ， <code class="codeph">NVARCHAR2</code>和<code class="codeph">NCLOB</code> 。这些数据类型使您可以存储<a id="d23567e1509" class="indexterm-anchor"></a>数据库中的Unicode数据<code class="codeph">NCHAR</code>字符集编码。在创建数据库时，将建立永不更改的<code class="codeph">NCHAR</code>字符集。
                        </p>
                        <div class="infoboxnote" id="GUID-9EFED893-8352-4E90-90DA-436D3727F02F__GUID-4B4F4832-1342-44D0-B446-760B6936015C">
                           <p class="notep1">注意：</p>
                           <p>由于不推荐使用<code class="codeph">UnicodeStream</code>类而使用<code class="codeph">CharacterStream</code>类，因此<code class="codeph">NCHAR</code>数据类型访问不支持<code class="codeph">setUnicodeStream</code>和<code class="codeph">getUnicodeStream</code>方法。如果要使用流访问，请使用<code class="codeph">setCharacterStream</code>方法和<code class="codeph">getCharacterStream</code>方法。
                           </p>
                        </div>
                        <p>SQL <code class="codeph">NCHAR</code>数据类型的用法类似于SQL <code class="codeph">CHAR</code>数据类型。JDBC使用相同的类和方法来访问用于相应SQL <code class="codeph">CHAR</code>数据类型的SQL <code class="codeph">NCHAR</code>数据类型。因此，在<code class="codeph">oracle.sql</code>包中没有为SQL <code class="codeph">NCHAR</code>数据类型定义单独的相应类。同样， <code class="codeph">oracle.jdbc.没有定义单独的相应常量<code class="codeph">oracle.jdbc.SQL <code class="codeph">NCHAR</code>数据类型的OracleTypes</code>类。
                        </p>
                        <div class="infoboxnotealso" id="GUID-9EFED893-8352-4E90-90DA-436D3727F02F__GUID-FC3E0EB4-2ABF-4F1D-B61C-CB538E473CC5">
                           <p class="notep1">也可以看看：</p>
                           <p><span class="q">“ <a href="globalization-support.html#GUID-C29926B3-8B5B-4B05-9193-29B247B52C66">NCHAR_ NVARCHAR2_ NCLOB和defaultNChar属性</a> ”</span></p>
                        </div>
                        <div class="infoboxnote" id="GUID-9EFED893-8352-4E90-90DA-436D3727F02F__GUID-275435FA-0122-4305-9634-F9E1CFC3B0EE">
                           <p class="notep1">注意：</p>
                           <p>必须在调用<code class="codeph">registerOutParameter</code>方法之前调用<code class="codeph">setFormOfUse</code>方法，以避免不可预测的结果。
                           </p>
                        </div>
                        <p>以下代码显示了如何访问SQL <code class="codeph">NCHAR</code>数据：</p><pre class="oac_no_warn" dir="ltr">// //表TEST具有以下列：//  -  NUMBER //  -  NVARCHAR2 //  -  NCHAR // oracle.jdbc。OraclePreparedStatement pstmt =（oracle.jdbc。OraclePreparedStatement）conn.prepareStatement（“插入TEST值（？，？，？）“）; // // oracle.jdbc。OraclePreparedStatement。FORM_NCHAR应该用于所有NCHAR，// NVARCHAR2和NCLOB数据类型。// pstmt.setInt（1,1）; // NUMBER列pstmt.setNString（2，myUnicodeString1）; // NVARCHAR2列pstmt.setNString（3，myUnicodeString2）; // NCHAR列pstmt.execute（）;</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JJDBC28145"></a><a id="JJDBC28146"></a><a id="JJDBC28144"></a><div class="props_rev_3"><a id="GUID-CFA6BCB6-9B8A-49E3-BAEF-F68F26A16A88" name="GUID-CFA6BCB6-9B8A-49E3-BAEF-F68F26A16A88"></a><h4 id="JJDBC-GUID-CFA6BCB6-9B8A-49E3-BAEF-F68F26A16A88" class="sect4"><span class="enumeration_section">4.4.3</span>类oracle.sql。CHAR</h4>
                  <div>
                     <div class="section">
                        <p><code class="codeph">oracle.sql.Oracle JDBC在处理和转换字符数据时使用CHAR</code>类。此类提供全球化支持功能以转换字符数据。该类有两个关键属性：全球化支持字符集和字符数据。全球化支持字符集定义字符数据的编码。它是一个在构造<code class="codeph">CHAR</code>对象时始终传递的参数。如果没有全球化支持字符集信息， <code class="codeph">CHAR</code>对象中的数据字节将毫无意义。<code class="codeph">oracle.sql.CHAR</code>类用于SQL <code class="codeph">CHAR</code>和SQL <code class="codeph">NCHAR</code>数据类型。
                        </p>
                        <div class="infoboxnote" id="GUID-CFA6BCB6-9B8A-49E3-BAEF-F68F26A16A88__GUID-D1723C80-0BAB-492E-8B47-5606EEAB6F6D">
                           <p class="notep1">注意：</p>
                           <p>在<span class="italic">10g</span>第1版之前的Oracle JDBC驱动程序版本中，使用<code class="codeph">oracle.具有性能优势<code class="codeph">oracle.SQL.CHAR</code> 。从Oracle数据库<span class="italic">10g开始</span> ，不再具有任何此类优势。实际上，使用<code class="codeph">java.lang.可以实现最佳性能<code class="codeph">java.lang.String</code> 。所有Oracle JDBC驱动程序都处理Java UCS2字符集中的所有字符数据。使用<code class="codeph">oracle.sql.CHAR</code>不会阻止数据库字符集和UCS2字符集之间的转换。
                           </p>
                        </div>
                        <p>唯一剩下的使用<code class="codeph">oracle.sql.CHAR</code>类用于处理Oracle全球化支持字符集中编码的原始字节形式的字符数据。应使用<code class="codeph">java.lang.访问从Oracle数据库检索的所有字符数据<code class="codeph">java.lang.String</code>类。处理来自其他源的字节数据时，可以使用<code class="codeph">oracle.sql.用于将字节转换为<code class="codeph">java.lang. CHAR</code> <code class="codeph">java.lang.String</code> 。
                        </p>
                        <p>转换<code class="codeph">oracle.sql.CHAR</code> ，您必须提供数据字节和<code class="codeph">oracle.sql.CharacterSet</code>实例，表示用于对数据字节进行编码的全球化支持字符集。
                        </p>
                        <p>作为Oracle对象属性的<code class="codeph">CHAR</code>对象在数据库字符集中返回。
                        </p>
                        <p>JDBC应用程序代码很少需要直接构造<code class="codeph">CHAR</code>对象，因为JDBC驱动程序会在需要在极少数情况下创建<code class="codeph">CHAR</code>对象时自动创建它们。
                        </p>
                        <p>要构造<code class="codeph">CHAR</code>对象，必须通过<code class="codeph">CharacterSet</code>类的实例向<code class="codeph">CHAR</code>对象提供字符集信息。此类的每个实例都代表Oracle支持的全球化支持字符集之一。<code class="codeph">CharacterSet</code>实例封装了字符集的方法和属性，主要涉及转换为其他字符集或从其他字符集转换的功能。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-CFA6BCB6-9B8A-49E3-BAEF-F68F26A16A88__GUID-F8E4C87C-D126-4D14-8223-255512B51A53">构造一个oracle.sql。CHAR对象</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>按照以下常规步骤构造<code class="codeph">CHAR</code>对象：</p>
                        <ol>
                           <li>
                              <p>通过调用<code class="codeph">static</code> <code class="codeph">CharacterSet.make</code>方法创建一个<code class="codeph">CharacterSet</code>对象。
                              </p>
                              <p>此方法是字符集实例的工厂。<code class="codeph">make</code>方法采用整数作为输入，它对应于Oracle支持的字符集ID。例如：</p><pre class="oac_no_warn" dir="ltr">int oracleId = CharacterSet。JA16SJIS_CHARSET; //这是字符集ID，// 832 ......CharacterSet mycharset = CharacterSet.make（oracleId）;</pre><p>Oracle支持的每个字符集都具有唯一的预定义Oracle ID。</p>
                           </li>
                           <li>
                              <p>构造一个<code class="codeph">CHAR</code>对象。
                              </p>
                              <p>将字符串或表示字符串的字节与<code class="codeph">CharacterSet</code>对象一起传递给构造函数，该对象指示如何根据字符集解释字节。例如：</p><pre class="oac_no_warn" dir="ltr">String mystring =“teststring”; ...CHAR mychar = new CHAR（teststring，mycharset）;</pre><p><code class="codeph">CHAR</code>有多个构造函数，可以将<code class="codeph">String</code> ， <code class="codeph">byte</code>数组或对象作为输入与<code class="codeph">CharacterSet</code>对象一起使用。对于<code class="codeph">String</code> ，在放入<code class="codeph">CHAR</code>对象之前，该字符串将转换为<code class="codeph">CharacterSet</code>对象指示的字符集。
                              </p>
                              <div class="infoboxnote" id="GUID-CFA6BCB6-9B8A-49E3-BAEF-F68F26A16A88__GUID-4036EE0A-DC25-44E4-9C34-7DA4A4941727">
                                 <p class="notep1">注意：</p>
                                 <ul style="list-style-type:disc">
                                    <li>
                                       <p><code class="codeph">CharacterSet</code>对象不能是null值。
                                       </p>
                                    </li>
                                    <li>
                                       <p><code class="codeph">CharacterSet</code>类是一个抽象类，因此它没有构造函数。创建实例的唯一方法是使用<code class="codeph">make</code>方法。
                                       </p>
                                    </li>
                                    <li>
                                       <p>服务器识别特殊值<code class="codeph">CharacterSet.DEFAULT_CHARSET</code>作为数据库字符集。对于客户端，此值没有意义。
                                       </p>
                                    </li>
                                    <li>
                                       <p>Oracle不打算或建议用户扩展<code class="codeph">CharacterSet</code>类。
                                       </p>
                                    </li>
                                 </ul>
                              </div>
                           </li>
                        </ol>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-CFA6BCB6-9B8A-49E3-BAEF-F68F26A16A88__GUID-1D1CB0B8-913F-42F2-86E0-F0B5D433B231">oracle.sql。CHAR转换方法</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p><code class="codeph">CHAR</code>类提供以下方法将字符数据转换为字符串：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">的getString</code></p>
                              <p>此方法将<code class="codeph">CHAR</code>对象表示的字符序列转换为字符串，返回Java <code class="codeph">String</code>对象。如果输入无效的<code class="codeph">OracleID</code> ，则不会识别该字符集，并且<code class="codeph">getString</code>方法将抛出<code class="codeph">SQLException</code>异常。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">的toString</code></p>
                              <p>此方法与<code class="codeph">getString</code>方法相同。但是，如果输入无效的<code class="codeph">OracleID</code> ，则无法识别字符集，并且<code class="codeph">toString</code>方法将返回<code class="codeph">CHAR</code>数据的十六进制表示形式，并且<span class="italic">不会</span>抛出<code class="codeph">SQLException</code>异常。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">getStringWithReplacement</code></p>
                              <p>此方法与<code class="codeph">getString</code>方法相同，但默认替换字符替换<code class="codeph">CHAR</code>对象字符集中没有unicode表示的字符。此默认字符从字符集到字符集不等，但通常是问号（ <code class="codeph">?</code> ）。
                              </p>
                           </li>
                        </ul>
                        <p>数据库服务器和客户端或客户端上运行的应用程序可以使用不同的<a id="d23567e1876" class="indexterm-anchor"></a>字符集。使用<code class="codeph">CHAR</code>类的方法在服务器和客户端之间传输数据时，JDBC驱动程序必须将数据从服务器字符集转换为客户端字符集，反之亦然。要转换数据，驱动程序使用全球化支持。
                        </p>
                        <div class="infoboxnotealso" id="GUID-CFA6BCB6-9B8A-49E3-BAEF-F68F26A16A88__GUID-B21327E9-69AC-4A35-9794-3C24C09E738B">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="globalization-support.html#GUID-CE02B998-DD6A-46FC-8ECF-AD2413F09A97">全球化支持</a></p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="JJDBC28148"></a><div class="props_rev_3"><a id="GUID-0DA598C9-4C4E-42D7-B581-B971B8D87A96" name="GUID-0DA598C9-4C4E-42D7-B581-B971B8D87A96"></a><h3 id="JJDBC-GUID-0DA598C9-4C4E-42D7-B581-B971B8D87A96" class="sect3"><span class="enumeration_section">4.5</span>其他Oracle类型扩展</h3>
               <div>
                  <div class="section">
                     <p>Oracle JDBC驱动程序支持特定于Oracle的<code class="codeph">BFILE</code>和<code class="codeph">ROWID</code>数据类型以及<code class="codeph">REF</code> <code class="codeph">CURSOR</code>类型，这些类型不属于标准JDBC规范。本节介绍<code class="codeph">ROWID</code>和<code class="codeph">REF CURSOR</code>类型扩展。支持<code class="codeph">ROWID</code>作为Java字符串，并且支持<code class="codeph">REF</code> <code class="codeph">CURSOR</code>类型作为JDBC结果集。
                     </p>
                     <p>本节包括以下主题：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="Oracle-extensions.html#GUID-8069D705-A031-469D-855F-53525798F64F">Oracle ROWID类型</a></p>
                        </li>
                        <li>
                           <p><a href="Oracle-extensions.html#GUID-BD58E992-5CAA-4F77-93B5-DD75A90E6555">Oracle REF CURSOR类型类别</a></p>
                        </li>
                        <li>
                           <p><a href="Oracle-extensions.html#GUID-FC9510C6-8FF2-41A7-864A-890B85A316BC">Oracle BINARY_FLOAT和BINARY_DOUBLE类型</a></p>
                        </li>
                        <li>
                           <p><a href="Oracle-extensions.html#GUID-E5105E30-7F12-4069-8A68-F12BF1CF7671">Oracle SYS.ANYTYPE和SYS.ANYDATA类型</a></p>
                        </li>
                        <li>
                           <p><a href="Oracle-extensions.html#GUID-E17FE2C3-9384-432C-9040-09EDF98CB8D6">oracle.jdbc包</a></p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
               </div><a id="JJDBC28150"></a><a id="JJDBC28149"></a><div class="props_rev_3"><a id="GUID-8069D705-A031-469D-855F-53525798F64F" name="GUID-8069D705-A031-469D-855F-53525798F64F"></a><h4 id="JJDBC-GUID-8069D705-A031-469D-855F-53525798F64F" class="sect4"><span class="enumeration_section">4.5.1</span> Oracle ROWID类型</h4>
                  <div>
                     <div class="section">
                        <p>一个<a id="d23567e1995" class="indexterm-anchor"></a> ROWID是Oracle数据库表的每一行唯一的标识标记。ROWID可以被认为是一个虚拟列，包含每行的ID。
                        </p>
                        <p><code class="codeph">oracle.sql.ROWID</code>类作为<code class="codeph">ROWID</code> SQL数据类型的容器提供。
                        </p>
                        <p>ROWID提供的功能类似于<code class="codeph">java.sql.指定的<code class="codeph">getCursorName</code>方法<code class="codeph">java.sql.ResultSet</code>接口和<code class="codeph">java.sql.指定的<code class="codeph">setCursorName</code>方法<code class="codeph">java.sql.Statement</code>界面。
                        </p>
                        <p>如果在查询中包含ROWID伪列，则可以使用结果集<code class="codeph">getString</code>方法检索ROWID。您还可以使用<code class="codeph">setString</code>方法将ROWID绑定到<code class="codeph">PreparedStatement</code>参数。这使得就地更新成为可能，如下面的示例所示。
                        </p>
                        <div class="infoboxnote" id="GUID-8069D705-A031-469D-855F-53525798F64F__GUID-FE4169A6-D108-4287-B606-77B33F356385">
                           <p class="notep1">注意：</p>
                           <p>使用<code class="codeph">oracle.sql.ROWID</code>类，仅在使用J2SE 5.0时。对于JSE 6，您应该使用标准的<code class="codeph">java.sql.而是RowId</code>接口。
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-8069D705-A031-469D-855F-53525798F64F__GUID-D56D9FA4-DBE7-4C63-8D26-FA8607B8136F">例</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>以下示例显示如何访问和操作ROWID数据：</p>
                        <div class="infoboxnote" id="GUID-8069D705-A031-469D-855F-53525798F64F__GUID-0544D8EC-84DF-43CC-ACFF-866BFE55B009">
                           <p class="notep1">注意：</p>
                           <p>以下示例仅适用于JSE 6。</p>
                        </div><pre class="oac_no_warn" dir="ltr">语句stmt = conn.createStatement（）; //使用“FOR UPDATE”查询员工姓名以锁定行。//选择ROWID以标识要更新的行。ResultSet rset = stmt.executeQuery（“SELECT first_name，rowid FROM employees FOR UPDATE”）; //准备一个语句来更新给定ROWID的first_name列PreparedStatement pstmt = conn.prepareStatement（“UPDATE employees SET first_name =？在哪里rowid =？“）; //循环查询结果while（rset.next（））{String ename = rset.getString（1）; RowId rowid = rset.getROWID（2）; //将ROWID作为String pstmt获取.setString（1，ename.toLowerCase（））; pstmt.setROWID（2，rowid）; //将ROWID传递给更新语句pstmt.executeUpdate（）; //执行更新}</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JJDBC28152"></a><a id="JJDBC28151"></a><div class="props_rev_3"><a id="GUID-BD58E992-5CAA-4F77-93B5-DD75A90E6555" name="GUID-BD58E992-5CAA-4F77-93B5-DD75A90E6555"></a><h4 id="JJDBC-GUID-BD58E992-5CAA-4F77-93B5-DD75A90E6555" class="sect4"><span class="enumeration_section">4.5.2</span> Oracle REF CURSOR类型类别</h4>
                  <div>
                     <div class="section">
                        <p>游标变量保存查询工作区的内存位置，而不是区域的内容。声明游标变量会创建一个指针。在SQL中，指针的数据类型为<code class="codeph">REF</code> <span class="italic"><code class="codeph">x</code></span> ，其中<code class="codeph">REF</code>是<code class="codeph">REFERENCE</code>缩写， <span class="italic"><code class="codeph">x</code></span>表示被引用的实体。然后， <code class="codeph">REF CURSOR</code>标识对游标变量的引用。由于许多游标变量可能存在指向许多工作区域，因此可以将<code class="codeph">REF</code> <code class="codeph">CURSOR</code>视为标识许多不同类型游标变量的类别或数据类型说明符。从Oracle Database Release 18 <span class="italic">c开始</span> ，JDBC驱动程序支持<code class="codeph">REF CURSOR</code>作为IN绑定变量。
                        </p>
                        <div class="infoboxnote" id="GUID-BD58E992-5CAA-4F77-93B5-DD75A90E6555__GUID-293F1483-0528-42D7-84C5-2926C5A24296">
                           <p class="notep1">注意：</p>
                           <p><code class="codeph">REF CURSOR</code>实例不可滚动。
                           </p>
                        </div>
                        <p>执行以下步骤以创建游标变量：</p>
                        <ol>
                           <li>
                              <p>标识属于<code class="codeph">REF</code> <code class="codeph">CURSOR</code>类别的类型。例如：</p><pre class="pre codeblock"><code>DECLARE TYPE DeptCursorTyp是REF CURSOR</code></pre></li>
                           <li>
                              <p>然后，通过将其声明为<code class="codeph">DeptCursorTyp</code>类型来创建游标变量：</p><pre class="pre codeblock"><code>dept_cv DeptCursorTyp  -   - 声明游标变量...
</code></pre><p>那么， <code class="codeph">REF</code> <code class="codeph">CURSOR</code>是一类数据类型，而不是特定的数据类型。
                              </p>
                           </li>
                        </ol>
                        <p>存储过程可以接受或返回的游标变量<a id="d23567e2148" class="indexterm-anchor"></a> <code class="codeph">REF</code> <code class="codeph">CURSOR</code>类别。此输出等效于数据库游标或JDBC结果集。<code class="codeph">REF CURSOR</code>基本上封装了查询的结果。
                        </p>
                        <p>在JDBC中，可以按如下方式访问<code class="codeph">REF CURSOR</code> ：</p>
                        <ol>
                           <li>
                              <p>使用JDBC可调用语句或预准备语句来调用存储过程。</p>
                           </li>
                           <li>
                              <p>存储过程接受或返回<code class="codeph">REF CURSOR</code> 。</p>
                           </li>
                           <li>
                              <p>Java应用程序将可调用语句或预准备语句强制转换为Oracle可调用语句或Oracle预准备语句。</p>
                           </li>
                           <li>
                              <p>Java应用程序使用<code class="codeph">setCursor</code>所述的方法<code class="codeph">OraclePreparedStatement</code>接口或<code class="codeph">getCursor</code>所述的方法<code class="codeph">OracleCallableStatement</code>接口物化为<code class="codeph">REF CURSOR</code>作为JDBC <code class="codeph">ResultSet</code>对象。
                              </p>
                           </li>
                           <li>
                              <p>结果集按要求处理。</p>
                              <div class="infoboxnote" id="GUID-BD58E992-5CAA-4F77-93B5-DD75A90E6555__GUID-2FF15DBE-344A-4414-9618-D884FA8B3CD8">
                                 <p class="notep1">注意：</p>
                                 <ul style="list-style-type:disc">
                                    <li>
                                       <p>只要生成<code class="codeph">REF CURSOR</code>的语句对象关闭，就关闭与<code class="codeph">REF CURSOR</code>关联的<code class="codeph">REF CURSOR</code> 。
                                       </p>
                                    </li>
                                    <li>
                                       <p>不像过去的版本，具有相关联的光标<code class="codeph">REF CURSOR</code>时，其中的结果集对象<span class="italic">不是</span>封闭<code class="codeph">REF CURSOR</code>被物化被关闭。
                                       </p>
                                    </li>
                                 </ul>
                              </div>
                           </li>
                        </ol>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-BD58E992-5CAA-4F77-93B5-DD75A90E6555__GUID-F8DFA999-3799-4BB6-9086-B08C6D2A3F5F">例</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>此示例显示如何访问<code class="codeph">REF CURSOR</code>数据。
                        </p><pre class="pre codeblock"><code>...//准备PL / SQL调用CallableStatement cstmt = conn.prepareCall（“DECLARE rc sys_refcursor; curid NUMBER; BEGIN open rc FOR SELECT empno FROM emp order by empno;？：= rc; END;”）; cstmt.registerOutParameter（1，OracleTypes。光标）; cstmt.execute（）; ResultSet rset =（ResultSet）cstmt.getObject（1）; if（rset.next（））{show（rset.getString（“empno”））; } CallableStatement cstmt2 = conn.prepareCall（“DECLARE rc sys_refcursor; v1 NUMBER; BEGIN rc：=？;获取rc INTO v1; ？ ：= v1; END;“）;（（OracleCallableStatement）call2）。setCursor（1，rset）; cstmt2.registerOutParameter（2，OracleTypes。整数）; cstmt2.execute（）; int empno = cstmt2.getInt（2）; show（“Fetch in PL / SQL empno =”+ empno）; //转移（rset.next（））show（rset.getString（“empno”））; //关闭所有资源rset.close（）; cstmt.close（）; cstmt2.close（）; ...</code></pre><p>在前面的示例中：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>使用<code class="codeph">Connection</code>类的<code class="codeph">prepareCall</code>方法创建两个<code class="codeph">CallableStatement</code>对象<code class="codeph">cstmt1</code>和<code class="codeph">cstmt2</code> 。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">cstmt2</code>可调用语句使用<code class="codeph">REF CURSOR</code>作为输入参数。
                              </p>
                           </li>
                           <li>
                              <p>可调用语句实现返回<code class="codeph">REF CURSOR</code> PL / SQL过程。</p>
                           </li>
                           <li>
                              <p>与往常一样，必须注册可调用语句的输出参数以定义其类型。使用类型代码<code class="codeph">OracleTypes.CURSOR</code>一个<code class="codeph">REF CURSOR</code> 。</p>
                           </li>
                           <li>
                              <p>运行可调用语句，返回<code class="codeph">REF CURSOR</code>或发送<code class="codeph">REF CURSOR</code>作为输入绑定。
                              </p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JJDBC28153"></a><div class="props_rev_3"><a id="GUID-FC9510C6-8FF2-41A7-864A-890B85A316BC" name="GUID-FC9510C6-8FF2-41A7-864A-890B85A316BC"></a><h4 id="JJDBC-GUID-FC9510C6-8FF2-41A7-864A-890B85A316BC" class="sect4"><span class="enumeration_section">4.5.3</span> Oracle BINARY_FLOAT和BINARY_DOUBLE类型</h4>
                  <div>
                     <div class="section">
                        <p>Oracle <code class="codeph">BINARY_FLOAT</code>和<code class="codeph">BINARY_DOUBLE</code>类型用于存储IEEE 574浮点数和双精度数据。这些对应于Java <code class="codeph">float</code>和<code class="codeph">double</code>标量类型，但负零和<code class="codeph">NaN</code>除外。</p>
                        <div class="infoboxnotealso" id="GUID-FC9510C6-8FF2-41A7-864A-890B85A316BC__GUID-387634EF-70D5-42B1-ACE9-50441978700B">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="../sqlrf/Data-Types.html#SQLRF00209" target="_blank"><span class="italic">Oracle数据库SQL语言参考</span></a></p>
                        </div>
                        <p>如果在查询中包含<code class="codeph">BINARY_DOUBLE</code>列， <code class="codeph">BINARY_DOUBLE</code>二进制格式从数据库中检索数据。此外， <code class="codeph">getDouble</code>方法将以二进制格式返回数据。相反，对于<code class="codeph">NUMBER</code>数据类型列，返回数字位并将其转换为Java <code class="codeph">double</code>数据类型。
                        </p>
                        <div class="infoboxnote" id="GUID-FC9510C6-8FF2-41A7-864A-890B85A316BC__GUID-FAE9EFB2-569E-4111-A64C-E350771B8114">
                           <p class="notep1">注意：</p>
                           <p>SQL <code class="codeph">FLOAT</code> ， <code class="codeph">DOUBLE PRECISION</code>和<code class="codeph">REAL</code>数据类型的Oracle表示使用Oracle <code class="codeph">NUMBER</code>表示。<code class="codeph">BINARY_FLOAT</code>和<code class="codeph">BINARY_DOUBLE</code>数据类型可以视为专有类型。
                           </p>
                        </div>
                        <p>调用<code class="codeph">PreparedStatement</code>接口的JDBC标准<code class="codeph">setDouble(int, double)</code>方法会将Java <code class="codeph">double</code>参数转换为Oracle <code class="codeph">NUMBER</code>样式位并将它们发送到数据库。相比之下， <code class="codeph">oracle.jdbc.的<code class="codeph">setBinaryDouble(int, double)</code>方法<code class="codeph">oracle.jdbc.OraclePreparedStatement</code>接口将数据转换为内部二进制位并将它们发送到数据库。
                        </p>
                        <p>您必须确保使用的数据格式与<code class="codeph">PreparedStatement</code>接口的目标参数的类型相匹配。这将导致正确的数据和最少的CPU使用。如果将<code class="codeph">setBinaryDouble</code>用于<code class="codeph">NUMBER</code>参数，则将二进制位发送到服务器并转换为<code class="codeph">NUMBER</code>格式。数据是正确的，但服务器CPU负载会增加。如果将<code class="codeph">setDouble</code>用于<code class="codeph">BINARY_DOUBLE</code>参数，则数据将首先在客户端上转换为<code class="codeph">NUMBER</code>位并发送到服务器，然后将其转换回二进制格式。这将增加客户端和服务器上的CPU负载，并且还可能导致数据损坏。
                        </p>
                        <p>设置为<code class="codeph">true</code>时， <code class="codeph">SetFloatAndDoubleUseBinary</code>连接属性会导致JDBC标准API， <code class="codeph">setFloat(int,</code> <code class="codeph">float)</code> ， <code class="codeph">setDouble(int,</code> <code class="codeph">double)</code>和所有变体发送内部二进制位而不是<code class="codeph">NUBMER</code>位。
                        </p>
                        <div class="infoboxnote" id="GUID-FC9510C6-8FF2-41A7-864A-890B85A316BC__GUID-9A59B83C-A3FC-4527-BAB5-F5A0181E3772">
                           <p class="notep1">注意：</p>
                           <p>虽然本节主要讨论<code class="codeph">BINARY_DOUBLE</code> ，但<code class="codeph">BINARY_FLOAT</code>也是如此。
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JJDBC28155"></a><a id="JJDBC28156"></a><a id="JJDBC28157"></a><a id="JJDBC28158"></a><a id="JJDBC28159"></a><a id="JJDBC28160"></a><a id="JJDBC28154"></a><div class="props_rev_3"><a id="GUID-E5105E30-7F12-4069-8A68-F12BF1CF7671" name="GUID-E5105E30-7F12-4069-8A68-F12BF1CF7671"></a><h4 id="JJDBC-GUID-E5105E30-7F12-4069-8A68-F12BF1CF7671" class="sect4"><span class="enumeration_section">4.5.4</span> Oracle SYS.ANYTYPE和SYS.ANYDATA类型</h4>
                  <div>
                     <div class="section">
                        <p>Oracle Database <span class="italic">12c</span>第1版（12.1）提供了一个Java接口来访问<a id="d23567e2485" class="indexterm-anchor"></a><a id="d23567e2487" class="indexterm-anchor"></a> <code class="codeph">SYS.ANYTYPE</code>和<a id="d23567e2492" class="indexterm-anchor"></a><a id="d23567e2494" class="indexterm-anchor"></a> <code class="codeph">SYS.ANYDATA</code> Oracle类型。
                        </p>
                        <div class="infoboxnotealso" id="GUID-E5105E30-7F12-4069-8A68-F12BF1CF7671__GUID-866CA3EB-E6E9-4BC2-AA54-D7E55E9FD618">
                           <p class="notep1">也可以看看：</p>
                           <p>有关这些Oracle类型的信息，请参阅<a href="../arpls/ANYTYPE-TYPE.html#ARPLS-GUID-4E6D7301-47C5-4495-A074-BAE102960751" target="_blank"><span><cite>Oracle Database PL / SQL包和类型参考</cite></span></a></p>
                        </div>
                        <p><code class="codeph">SYS.ANYTYPE</code>类型的实例包含任何SQL类型的类型描述，持久或临时，命名或未命名，包括对象类型和集合类型。您可以使用<code class="codeph">oracle.sql.TypeDescriptor</code>类，用于访问<code class="codeph">SYS.ANYTYPE</code>类型。可以从PL / SQL过程或SQL <code class="codeph">SELECT</code>语句中检索<code class="codeph">ANYTYPE</code>实例，其中<code class="codeph">SYS.ANYTYPE</code>用作列类型。要从数据库中检索<code class="codeph">ANYTYPE</code>实例，请使用<code class="codeph">getObject</code>方法。此方法返回<code class="codeph">TypeDescriptor</code>的实例。
                        </p>
                        <p>检索到的<code class="codeph">ANYTYPE</code>实例可以是以下任何一种：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>瞬态对象类型</p>
                           </li>
                           <li>
                              <p>瞬态预定义类型</p>
                           </li>
                           <li>
                              <p>持久对象类型</p>
                           </li>
                           <li>
                              <p>持久预定义类型</p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-E5105E30-7F12-4069-8A68-F12BF1CF7671__GUID-E12B1896-516B-433F-B2FA-E79AE98225D9">
                        <p class="titleinexample">示例4-1访问SYS.ANYTYPE类型</p>
                        <p>以下代码段说明了如何从数据库中检索<code class="codeph">ANYTYPE</code>的实例：</p><pre class="oac_no_warn" dir="ltr">...ResultSet rs = stmt.executeQuery（“从my_table中选择anytype_column”）; TypeDescriptor td =（TypeDescriptor）rs.getObject（1）; short typeCode = td.getInternalTypeCode（）; if（typeCode == TypeDescriptor。TYPECODE_OBJECT）{//检查它是否是瞬态类型if（td.isTransientType（））{AttributeDescriptor [] attributes =（（StructDescriptor）td）.getAttributesDescriptor（）; for（int i = 0; i &lt;attributes.length; i ++）System.out.println（attributes [i] .getAttributeName（））; } else {System.out.println（td.getTypeName（））; } ...</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-E5105E30-7F12-4069-8A68-F12BF1CF7671__GUID-DBF7C48C-03BB-45B6-AE21-E724BAACCB4C">
                        <p class="titleinexample">示例4-2通过PL / SQL创建瞬态对象类型并通过JDBC检索</p>
                        <p>此示例提供了一个代码片段，说明如何通过JDBC检索瞬态对象类型。</p><pre class="oac_no_warn" dir="ltr">...OracleCallableStatement cstmt =（OracleCallableStatement）conn.prepareCall（“BEGIN？：= transient_obj_type（）; END;”）; cstmt.registerOutParameter（1，OracleTypes。不透明的， “SYS.ANYTYPE”）; cstmt.execute（）; TypeDescriptor obj =（TypeDescriptor）cstmt.getObject（1）;如果（！obj.isTransient（））System.out.println（“这必须是JDBC错误”）; cstmt.close（）;返回obj; ...
</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-E5105E30-7F12-4069-8A68-F12BF1CF7671__GUID-A7BDB53F-4960-4C3D-AD6F-FFFF116EEF2A">
                        <p class="titleinexample">示例4-3调用将ANYTPE作为IN参数的PL / SQL存储过程</p>
                        <p>以下代码段说明了如何调用将<code class="codeph">ANYTYPE</code>作为<code class="codeph">IN</code>参数的PL / SQL存储过程：</p><pre class="oac_no_warn" dir="ltr">...CallableStatement cstmt = conn.prepareCall（“BEGIN？：= dumpanytype（？）; END;“）; cstmt.registerOutParameter（1，OracleTypes。VARCHAR）; // obj是您检索到的cstmt.setObject（2，obj）的TypeDescriptor实例; cstmt.execute（）; String str =（String）cstmt.getObject（1）; ...
</pre></div>
                     <!-- class="example" -->
                     <div class="section">
                        <p><code class="codeph">oracle.sql.ANYDATA</code>类使您可以从数据库访问<code class="codeph">SYS.ANYDATA</code>实例。可以从任何有效的<code class="codeph">oracle.sql.实例获取此类的实例<code class="codeph">oracle.sql.Datum</code>类。<code class="codeph">convertDatum</code>工厂方法接受一个<code class="codeph">Datum</code>实例并返回一个<code class="codeph">ANYDATA</code>实例。此工厂方法的语法如下：</p><pre class="oac_no_warn" dir="ltr">public static ANYDATA convertDatum（Datum datum）抛出SQLException</pre><p>以下是用于创建<code class="codeph">oracle.sql.实例的示例代码<code class="codeph">oracle.sql.ANYDATA</code> ：</p><pre class="oac_no_warn" dir="ltr">// struct是oracle.sql的有效实例。STRUCT来自//数据库或者是用Java构建的。ANYDATA myAnyData = ANYDATA.convertDatum（struct）;</pre></div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-E5105E30-7F12-4069-8A68-F12BF1CF7671__GUID-BBEEAF43-08A9-4E93-A405-5B55F412EB88">
                        <p class="titleinexample">示例4-4从数据库访问ANYDATA实例</p><pre class="oac_no_warn" dir="ltr">...// anydata_table已创建为：// CREATE TABLE anydata_tab（data SYS.ANYDATA）语句stmt = conn.createStatement（）; ResultSet rs = stmt.executeQuery（“从my_anydata_tab中选择数据”）; while（rs.next（））{ANYDATA anydata =（ANYDATA）rs.getObject（1）;如果（！anydata.isNull（））{TypeDescriptor td = anydata.getTypeDescriptor（）; if（td.getTypeCode（）== OracleType。TYPECODE_OBJECT）STRUCT struct =（STRUCT）anydata.accessDatum（）; } ...
</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-E5105E30-7F12-4069-8A68-F12BF1CF7671__GUID-C53803E1-F05D-469D-BB9C-70100C0C08DD">
                        <p class="titleinexample">示例4-5将对象作为ANYDATA插入数据库表中</p>
                        <p>考虑以下表和对象类型定义：</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE anydata_tab（id NUMBER，data SYS.ANYDATA）CREATE OR REPLACE TYPE employee AS OBJECT（employee_id NUMBER，first_name VARCHAR2（10））</pre><p>您可以通过以下方式创建<code class="codeph">EMPLOYEE</code> SQL对象类型的实例并将其插入<code class="codeph">anydata_tab</code>中：</p><pre class="oac_no_warn" dir="ltr">...PreparedStatement pstmt = conn.prepareStatement（“插入anydata_table值（？，？）“）; struct myEmployeeStr = conn.createStruct（”EMPLOYEE“，new Object [] {1120，”Papageno“}）; ANYDATA anyda = ANYDATA.convertDatum（myEmployeeStr）; pstmt.setInt（1,123）; pstmt.setObject（2， anyda）; pstmt.executeUpdate（）; ...
</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-E5105E30-7F12-4069-8A68-F12BF1CF7671__GUID-B599ACA6-FE69-4AFE-AC8B-30D1302F4068">
                        <p class="titleinexample">示例4-6从数据库表中选择ANYDATA列</p><pre class="oac_no_warn" dir="ltr">...语句stmt = conn.createStatement（）; ResultSet rs = stmt.executeQuery（“从anydata_table中选择数据”）; while（rs.next（））{ANYDATA obj =（ANYDATA）rs.getObject（1）; TypeDescriptor td = obj.getTypeDescriptor（）; } rs.close（）; stmt.close（）; ...
</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="JJDBC28162"></a><a id="JJDBC28161"></a><div class="props_rev_3"><a id="GUID-E17FE2C3-9384-432C-9040-09EDF98CB8D6" name="GUID-E17FE2C3-9384-432C-9040-09EDF98CB8D6"></a><h4 id="JJDBC-GUID-E17FE2C3-9384-432C-9040-09EDF98CB8D6" class="sect4"><span class="enumeration_section">4.5.5</span> oracle.jdbc包</h4>
                  <div>
                     <div class="section">
                        <p><code class="codeph">oracle.jdbc</code>包的接口定义了<code class="codeph">java.sql</code>接口的Oracle扩展。这些扩展提供了对本章所述的SQL格式数据的访问。它们还提供对其他Oracle特定功能的访问，包括Oracle性能增强。
                        </p>
                        <p>对于<code class="codeph">oracle.jdbc</code>包， <a href="Oracle-extensions.html#GUID-E17FE2C3-9384-432C-9040-09EDF98CB8D6__g1076271" title="表">表4-1</a>列出了用于连接，语句和结果集的关键接口和类。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="tblformal" id="GUID-E17FE2C3-9384-432C-9040-09EDF98CB8D6__g1076271">
                        <p class="titleintable">表4-1 oracle.jdbc包的关键接口和类</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="oracle.jdbc包的关键接口和类" width="100%" border="1" summary="table" frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="40%" id="d23567e2696">名称</th>
                                 <th align="left" valign="bottom" width="13%" id="d23567e2699">接口或类</th>
                                 <th align="left" valign="bottom" width="47%" id="d23567e2702">关键功能</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="40%" id="d23567e2707" headers="d23567e2696 ">
                                    <p><code class="codeph">一个OracleDriver</code></p>
                                 </td>
                                 <td align="left" valign="top" width="13%" headers="d23567e2707 d23567e2699 ">
                                    <p>类</p>
                                 </td>
                                 <td align="left" valign="top" width="47%" headers="d23567e2707 d23567e2702 ">
                                    <p>实现<code class="codeph">java.sql.司机</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="40%" id="d23567e2720" headers="d23567e2696 ">
                                    <p><code class="codeph">的OracleConnection</code></p>
                                 </td>
                                 <td align="left" valign="top" width="13%" headers="d23567e2720 d23567e2699 ">
                                    <p>接口</p>
                                 </td>
                                 <td align="left" valign="top" width="47%" headers="d23567e2720 d23567e2702 ">
                                    <p>提供启动和停止Oracle数据库实例以及返回Oracle语句对象和方法的方法，以便为当前连接中运行的任何语句设置Oracle性能扩展。</p>
                                    <p>实现<code class="codeph">java.sql.连接。</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="40%" id="d23567e2735" headers="d23567e2696 ">
                                    <p><code class="codeph">OracleStatement</code></p>
                                 </td>
                                 <td align="left" valign="top" width="13%" headers="d23567e2735 d23567e2699 ">
                                    <p>接口</p>
                                 </td>
                                 <td align="left" valign="top" width="47%" headers="d23567e2735 d23567e2702 ">
                                    <p>提供为单个语句设置Oracle性能扩展的方法。</p>
                                    <p>是的超类型<code class="codeph">OraclePreparedStatement</code>和<code class="codeph">OracleCallableStatement</code> 。
                                    </p>
                                    <p>实现<code class="codeph">java.sql.声明。</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="40%" id="d23567e2758" headers="d23567e2696 ">
                                    <p><code class="codeph">OraclePreparedStatement</code></p>
                                 </td>
                                 <td align="left" valign="top" width="13%" headers="d23567e2758 d23567e2699 ">
                                    <p>接口</p>
                                 </td>
                                 <td align="left" valign="top" width="47%" headers="d23567e2758 d23567e2702 ">
                                    <p>提供<code class="codeph">set</code> <span class="italic"><code class="codeph">XXX</code></span>方法将<code class="codeph">oracle.sql.*</code>类型绑定到<code class="codeph">oracle.sql.*</code>准备语句中。
                                    </p>
                                    <p>提供<code class="codeph">getMetaData</code>方法以从<code class="codeph">getMetaData</code>准备语句中获取元数据，而无需执行SELECT语句。
                                    </p>
                                    <p>实现<code class="codeph">java.sql.PreparedStatement的。</code></p>
                                    <p>扩展<code class="codeph">OracleStatement.</code></p>
                                    <p>是<code class="codeph">OracleCallableStatement</code>的超类型。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="40%" id="d23567e2796" headers="d23567e2696 ">
                                    <p><code class="codeph">OracleCallableStatement</code></p>
                                 </td>
                                 <td align="left" valign="top" width="13%" headers="d23567e2796 d23567e2699 ">
                                    <p>接口</p>
                                 </td>
                                 <td align="left" valign="top" width="47%" headers="d23567e2796 d23567e2702 ">
                                    <p>提供<code class="codeph">get</code> <span class="italic"><code class="codeph">XXX</code></span>方法以检索<code class="codeph">oracle.sql</code>格式的数据，并<code class="codeph">set</code> <span class="italic"><code class="codeph">XXX</code></span>方法以将<code class="codeph">oracle.sql.*</code>类型绑定到可调用语句中。
                                    </p>
                                    <p>实现<code class="codeph">java.sql.CallableStatement中。</code></p>
                                    <p>扩展<code class="codeph">OraclePreparedStatement.</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="40%" id="d23567e2833" headers="d23567e2696 ">
                                    <p><code class="codeph">OracleResultSet</code></p>
                                 </td>
                                 <td align="left" valign="top" width="13%" headers="d23567e2833 d23567e2699 ">
                                    <p>接口</p>
                                 </td>
                                 <td align="left" valign="top" width="47%" headers="d23567e2833 d23567e2702 ">
                                    <p>提供<code class="codeph">get</code> <span class="italic"><code class="codeph">XXX</code></span>方法以检索<code class="codeph">oracle.sql</code>格式的数据。
                                    </p>
                                    <p>实现<code class="codeph">java.sql.ResultSet</code> 。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="40%" id="d23567e2858" headers="d23567e2696 ">
                                    <p><code class="codeph">OracleResultSetMetaData</code></p>
                                 </td>
                                 <td align="left" valign="top" width="13%" headers="d23567e2858 d23567e2699 ">
                                    <p>接口</p>
                                 </td>
                                 <td align="left" valign="top" width="47%" headers="d23567e2858 d23567e2702 ">
                                    <p>提供获取有关Oracle结果集的元数据信息的方法，例如列名和数据类型。</p>
                                    <p>实现<code class="codeph">java.sql.ResultSetMetaData</code> 。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="40%" id="d23567e2874" headers="d23567e2696 ">
                                    <p><code class="codeph">OracleDatabaseMetaData</code></p>
                                 </td>
                                 <td align="left" valign="top" width="13%" headers="d23567e2874 d23567e2699 ">
                                    <p>类</p>
                                 </td>
                                 <td align="left" valign="top" width="47%" headers="d23567e2874 d23567e2702 ">
                                    <p>提供获取有关数据库的元数据信息的方法，例如数据库产品名称和版本，表信息以及默认事务隔离级别。</p>
                                    <p>实现<code class="codeph">java.sql.DatabaseMetaData</code> ）。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="40%" id="d23567e2890" headers="d23567e2696 ">
                                    <p><code class="codeph">OracleTypes</code></p>
                                 </td>
                                 <td align="left" valign="top" width="13%" headers="d23567e2890 d23567e2699 ">
                                    <p>类</p>
                                 </td>
                                 <td align="left" valign="top" width="47%" headers="d23567e2890 d23567e2702 ">
                                    <p>定义用于标识SQL类型的整数常量。</p>
                                    <p>对于标准类型，它使用与标准<code class="codeph">java.sql.相同的值<code class="codeph">java.sql.Types</code>类。此外，它还为Oracle扩展类型添加了常量。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="40%" id="d23567e2906" headers="d23567e2696 ">
                                    <p><code class="codeph">OracleArray</code></p>
                                 </td>
                                 <td align="left" valign="top" width="13%" headers="d23567e2906 d23567e2699 ">
                                    <p>接口</p>
                                 </td>
                                 <td align="left" valign="top" width="47%" headers="d23567e2906 d23567e2702 ">
                                    <p>包括作为整体检索数组，检索数组元素的子集以及检索数组元素的SQL基类型名称的功能。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="40%" id="d23567e2917" headers="d23567e2696 ">
                                    <p><code class="codeph">OracleStruct</code></p>
                                 </td>
                                 <td align="left" valign="top" width="13%" headers="d23567e2917 d23567e2699 ">
                                    <p>接口</p>
                                 </td>
                                 <td align="left" valign="top" width="47%" headers="d23567e2917 d23567e2702 "> </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="40%" id="d23567e2927" headers="d23567e2696 ">
                                    <p><code class="codeph">OracleClob</code></p>
                                 </td>
                                 <td align="left" valign="top" width="13%" headers="d23567e2927 d23567e2699 ">
                                    <p>接口</p>
                                 </td>
                                 <td align="left" valign="top" width="47%" headers="d23567e2927 d23567e2702 "> </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="40%" id="d23567e2936" headers="d23567e2696 ">
                                    <p><code class="codeph">OracleBlob</code></p>
                                 </td>
                                 <td align="left" valign="top" width="13%" headers="d23567e2936 d23567e2699 ">
                                    <p>接口</p>
                                 </td>
                                 <td align="left" valign="top" width="47%" headers="d23567e2936 d23567e2702 "> </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="40%" id="d23567e2945" headers="d23567e2696 ">
                                    <p><code class="codeph">OracleRef</code></p>
                                 </td>
                                 <td align="left" valign="top" width="13%" headers="d23567e2945 d23567e2699 ">
                                    <p>接口</p>
                                 </td>
                                 <td align="left" valign="top" width="47%" headers="d23567e2945 d23567e2702 "> </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="40%" id="d23567e2954" headers="d23567e2696 ">
                                    <p><code class="codeph">OracleOpaque</code></p>
                                 </td>
                                 <td align="left" valign="top" width="13%" headers="d23567e2954 d23567e2699 ">
                                    <p>接口</p>
                                 </td>
                                 <td align="left" valign="top" width="47%" headers="d23567e2954 d23567e2702 "> </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <div class="section">
                        <p>本节包括以下主题：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="Oracle-extensions.html#GUID-745C9F2E-C5ED-4959-A315-09DB008DBC59">接口oracle.jdbc。的OracleConnection</a></p>
                           </li>
                           <li>
                              <p><a href="Oracle-extensions.html#GUID-46404619-5332-4C70-B7BE-7A31372932C3">接口oracle.jdbc。OracleStatement</a></p>
                           </li>
                           <li>
                              <p><a href="Oracle-extensions.html#GUID-B5463D4F-6319-4A21-AB35-A5A7F3FDFC61">接口oracle.jdbc。OraclePreparedStatement</a></p>
                           </li>
                           <li>
                              <p><a href="Oracle-extensions.html#GUID-0C1F7E0A-5A10-4E81-B789-F275D81E12F7">接口oracle.jdbc。OracleCallableStatement</a></p>
                           </li>
                           <li>
                              <p><a href="Oracle-extensions.html#GUID-40FC3C62-E48D-42A8-A9AB-DA45DC8E6B3E">接口oracle.jdbc。OracleResultSet</a></p>
                           </li>
                           <li>
                              <p><a href="Oracle-extensions.html#GUID-177EF9E3-B054-4D91-90D6-23F986C250DD">接口oracle.jdbc。OracleResultSetMetaData</a></p>
                           </li>
                           <li>
                              <p><a href="Oracle-extensions.html#GUID-A8B450ED-A95B-4B40-B720-922C209D7D88">类oracle.jdbc。OracleTypes</a></p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div><a id="JJDBC28164"></a><a id="JJDBC28163"></a><div class="props_rev_3"><a id="GUID-745C9F2E-C5ED-4959-A315-09DB008DBC59" name="GUID-745C9F2E-C5ED-4959-A315-09DB008DBC59"></a><h5 id="JJDBC-GUID-745C9F2E-C5ED-4959-A315-09DB008DBC59" class="sect5"><span class="enumeration_section">4.5.5.1</span>接口oracle.jdbc。的OracleConnection</h5>
                     <div>
                        <div class="section">
                           <p><a id="d23567e3026" class="indexterm-anchor"></a><a id="d23567e3028" class="indexterm-anchor"></a>此接口扩展了标准JDBC连接功能，以创建和返回Oracle语句对象，为Oracle性能扩展设置标志和选项，支持Oracle对象的类型映射以及支持客户端标识符。
                           </p>
                           <p>在Oracle Database <span class="italic">11g</span>第1版中，此接口添加了新方法，可以启动和关闭Oracle数据库实例。此外，为了更好的可见性和清晰度，所有连接属性都在<code class="codeph">OracleConnection</code>接口中定义为常量。
                           </p>
                           <p>此接口还定义用于构造<code class="codeph">oracle.sql</code>数据值（如<code class="codeph">DATE</code>和<code class="codeph">NUMBER</code>工厂方法。使用工厂方法时请记住以下几点：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>构造<code class="codeph">oracle.sql</code>类型实例的所有代码都应使用Oracle扩展工厂方法。例如， <code class="codeph">ARRAY</code> ， <code class="codeph">BFILE</code> ， <code class="codeph">DATE</code> ， <code class="codeph">INTERVALDS</code> ， <code class="codeph">NUMBER</code> ， <code class="codeph">STRUCT</code> ， <code class="codeph">TIME</code> ， <code class="codeph">TIMESTAMP</code>等。
                                 </p>
                              </li>
                              <li>
                                 <p>构造标准类型实例的所有代码都应使用JDBC 4.0标准工厂方法。例如， <code class="codeph">CLOB</code> ， <code class="codeph">BLOB</code> ， <code class="codeph">NCLOB</code>等。
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">CHAR</code> ， <code class="codeph">JAVA_STRUCT</code> ， <code class="codeph">ArrayDescriptor</code>和<code class="codeph">StructDescriptor.</code>没有工厂方法<code class="codeph">StructDescriptor.</code> 这些类型仅供内部驱动程序使用。
                                 </p>
                                 <div class="infoboxnote" id="GUID-745C9F2E-C5ED-4959-A315-09DB008DBC59__GUID-69E3481B-1454-4D36-A812-93E71D750B2D">
                                    <p class="notep1">注意：</p>
                                    <p>在Oracle Database <span class="italic">11g</span>第1版之前，您必须构造<code class="codeph">ArrayDescriptors</code>和<code class="codeph">StructDescriptors</code>以便将参数作为参数传递给<code class="codeph">ARRAY</code>和<code class="codeph">STRUCT</code>类构造函数。新的<code class="codeph">ARRAY</code>和<code class="codeph">Struct</code>工厂方法没有任何描述符参数。驱动程序仍然在内部使用描述符，但您不需要创建它们。
                                    </p>
                                 </div>
                              </li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-745C9F2E-C5ED-4959-A315-09DB008DBC59__GUID-BCA973AE-19FD-4CCA-875C-DE8B7409BF7B">客户标识符</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p>在连接池环境中，客户端标识符可用于使用当前的数据库会话来标识轻量级用户。客户端标识符还可用于在不同数据库会话之间共享全局访问的应用程序上下文。打开数据库审计时，将审计在数据库会话中设置的客户端标识符。</p>
                           <div class="infoboxnotealso" id="GUID-745C9F2E-C5ED-4959-A315-09DB008DBC59__GUID-B0183873-4948-42C7-8069-523B2AE31585">
                              <p class="notep1">也可以看看：</p>
                              <p>有关更多信息，请<a href="../jajdb/index.html" target="_blank"><span><cite>参见Oracle数据库JDBC Java API参考</cite></span></a></p>
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="JJDBC28165"></a><div class="props_rev_3"><a id="GUID-46404619-5332-4C70-B7BE-7A31372932C3" name="GUID-46404619-5332-4C70-B7BE-7A31372932C3"></a><h5 id="JJDBC-GUID-46404619-5332-4C70-B7BE-7A31372932C3" class="sect5"><span class="enumeration_section">4.5.5.2</span>接口oracle.jdbc。OracleStatement</h5>
                     <div>
                        <div class="section">
                           <p><a id="d23567e3172" class="indexterm-anchor"></a><a id="d23567e3174" class="indexterm-anchor"></a>此接口扩展了标准JDBC语句的作用，是的超接口<code class="codeph">OraclePreparedStatement</code>和<code class="codeph">OracleCallableStatement</code>类。扩展功能包括支持在逐个语句的基础上为Oracle性能扩展设置标志和选项，而不是在连接范围内设置这些标志和选项的<code class="codeph">OracleConnection</code>接口。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="JJDBC28166"></a><div class="props_rev_3"><a id="GUID-B5463D4F-6319-4A21-AB35-A5A7F3FDFC61" name="GUID-B5463D4F-6319-4A21-AB35-A5A7F3FDFC61"></a><h5 id="JJDBC-GUID-B5463D4F-6319-4A21-AB35-A5A7F3FDFC61" class="sect5"><span class="enumeration_section">4.5.5.3</span>接口oracle.jdbc。OraclePreparedStatement</h5>
                     <div>
                        <div class="section">
                           <p><a id="d23567e3211" class="indexterm-anchor"></a><a id="d23567e3213" class="indexterm-anchor"></a>此接口扩展了<code class="codeph">OracleStatement</code>接口并扩展了标准的JDBC <code class="codeph">OracleStatement</code>准备语句功能。另外， <code class="codeph">oracle.jdbc.OraclePreparedStatement</code>接口由扩展<code class="codeph">OracleCallableStatement</code>接口。扩展功能包括以下内容：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">set</code> <span class="italic"><code class="codeph">XXX</code></span>方法将<code class="codeph">oracle.sql.*</code>类型和对象绑定到<code class="codeph">oracle.sql.*</code>准备语句</p>
                              </li>
                              <li>
                                 <p><code class="codeph">getMetaData</code>方法从<code class="codeph">getMetaData</code>准备语句中获取元数据而不执行SELECT语句</p>
                              </li>
                              <li>
                                 <p>在逐个语句的基础上支持Oracle性能扩展的方法</p>
                              </li>
                           </ul>
                           <div class="infoboxnote" id="GUID-B5463D4F-6319-4A21-AB35-A5A7F3FDFC61__GUID-26397C18-728B-4F4A-9F0A-21C0666DA6CB">
                              <p class="notep1">注意：</p>
                              <p>不要使用<code class="codeph">PreparedStatement</code>接口来创建引用<code class="codeph">:NEW</code>或<code class="codeph">:OLD</code>列的触发器。请改用<code class="codeph">Statement</code> 。使用<code class="codeph">PreparedStatement</code>将导致执行失败并显示消息<code class="codeph">java.sql.SQLException: Missing IN or OUT parameter at index:: 1</code> 。
                              </p>
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="JJDBC28167"></a><div class="props_rev_3"><a id="GUID-0C1F7E0A-5A10-4E81-B789-F275D81E12F7" name="GUID-0C1F7E0A-5A10-4E81-B789-F275D81E12F7"></a><h5 id="JJDBC-GUID-0C1F7E0A-5A10-4E81-B789-F275D81E12F7" class="sect5"><span class="enumeration_section">4.5.5.4</span>接口oracle.jdbc。OracleCallableStatement</h5>
                     <div>
                        <div class="section">
                           <p><a id="d23567e3291" class="indexterm-anchor"></a><a id="d23567e3293" class="indexterm-anchor"></a>此接口扩展了<code class="codeph">OraclePreparedStatement</code>接口，该接口扩展了<code class="codeph">OracleStatement</code>接口并包含标准的JDBC可调用语句功能。
                           </p>
                           <div class="infoboxnote" id="GUID-0C1F7E0A-5A10-4E81-B789-F275D81E12F7__GUID-18AA8E77-48E2-4274-8C2C-D4AF1BC5CB28">
                              <p class="notep1">注意：</p>
                              <p>不要使用<code class="codeph">CallableStatement</code>接口来创建引用<code class="codeph">:NEW</code>或<code class="codeph">:OLD</code>列的触发器。改用<code class="codeph">Statement</code> ;使用<code class="codeph">CallableStatement</code>将导致执行失败并显示消息<code class="codeph">java.sql.SQLException：在index :: 1处缺少IN或OUT参数</code></p>
                           </div>
                           <div class="infoboxnote" id="GUID-0C1F7E0A-5A10-4E81-B789-F275D81E12F7__GUID-08C68E79-FC43-401D-9909-55A7F023F981">
                              <p class="notep1">注意：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>仅当所有绑定仅是过程或函数参数时，才能使用<code class="codeph">set</code> <span class="italic"><code class="codeph">XXX</code></span> <code class="codeph">(String,...)</code>和<code class="codeph">registerOutParameter(String,...)</code>方法。该语句不能包含其他绑定，参数绑定必须用问号（ <code class="codeph">?)</code> 而不是<code class="codeph">:</code> <span class="italic"><code class="codeph">XX</code></span> 。</p>
                                 </li>
                                 <li>
                                    <p>如果你使用<code class="codeph">set</code> <span class="italic"><code class="codeph">XXX</code></span> <code class="codeph">(int,...) or</code> <code class="codeph">set</code> <span class="italic"><code class="codeph">XXX</code></span> <code class="codeph">AtName(String,...)</code>方法，那么任何输出参数都与<code class="codeph">registerOutParameter(int,...)</code>绑定而不是<code class="codeph">registerOutParameter(String,...)</code> ，用于命名参数表示法。
                                    </p>
                                 </li>
                              </ul>
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="JJDBC28168"></a><div class="props_rev_3"><a id="GUID-40FC3C62-E48D-42A8-A9AB-DA45DC8E6B3E" name="GUID-40FC3C62-E48D-42A8-A9AB-DA45DC8E6B3E"></a><h5 id="JJDBC-GUID-40FC3C62-E48D-42A8-A9AB-DA45DC8E6B3E" class="sect5"><span class="enumeration_section">4.5.5.5</span>接口oracle.jdbc。OracleResultSet</h5>
                     <div>
                        <div class="section">
                           <p><a id="d23567e3398" class="indexterm-anchor"></a><a id="d23567e3400" class="indexterm-anchor"></a>此接口扩展了标准JDBC结果集功能，实现了<code class="codeph">get</code> <span class="italic"><code class="codeph">XXX</code></span>方法，用于将数据检索到<code class="codeph">oracle.sql.*</code>对象中。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="JJDBC28169"></a><div class="props_rev_3"><a id="GUID-177EF9E3-B054-4D91-90D6-23F986C250DD" name="GUID-177EF9E3-B054-4D91-90D6-23F986C250DD"></a><h5 id="JJDBC-GUID-177EF9E3-B054-4D91-90D6-23F986C250DD" class="sect5"><span class="enumeration_section">4.5.5.6</span>接口oracle.jdbc。OracleResultSetMetaData</h5>
                     <div>
                        <div class="section">
                           <p><a id="d23567e3437" class="indexterm-anchor"></a><a id="d23567e3439" class="indexterm-anchor"></a>此接口扩展了标准JDBC结果集元数据功能，以检索有关Oracle的信息<a id="d23567e3442" class="indexterm-anchor"></a>结果集对象。
                           </p>
                           <div class="infoboxnotealso" id="GUID-177EF9E3-B054-4D91-90D6-23F986C250DD__GUID-88122DB7-34CF-4A46-A272-6E6197C7356F">
                              <p class="notep1">也可以看看：</p>
                              <p><span class="q">“ <a href="accessing-and-manipulating-Oracle-data.html#GUID-C9AF8539-12BA-4F19-AAB9-0EE481D78F19">使用结果集元数据扩展</a> ”</span></p>
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="JJDBC28171"></a><a id="JJDBC28172"></a><a id="JJDBC28170"></a><div class="props_rev_3"><a id="GUID-A8B450ED-A95B-4B40-B720-922C209D7D88" name="GUID-A8B450ED-A95B-4B40-B720-922C209D7D88"></a><h5 id="JJDBC-GUID-A8B450ED-A95B-4B40-B720-922C209D7D88" class="sect5"><span class="enumeration_section">4.5.5.7</span>类oracle.jdbc。OracleTypes</h5>
                     <div>
                        <div class="section">
                           <p><a id="d23567e3479" class="indexterm-anchor"></a><a id="d23567e3481" class="indexterm-anchor"></a> <code class="codeph">OracleTypes</code>类定义<a id="d23567e3487" class="indexterm-anchor"></a><a id="d23567e3489" class="indexterm-anchor"></a> JDBC用于标识SQL类型的常量。此类中的每个变量都有一个常量整数值。<code class="codeph">oracle.jdbc.OracleTypes</code>类复制标准Java <code class="codeph">java.sql.的类型代码定义<code class="codeph">java.sql.Types</code>类，包含Oracle扩展的这些附加类型代码：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">OracleTypes。BFILE</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">OracleTypes。ROWID</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">OracleTypes。CURSOR</code> （适用于<code class="codeph">REF CURSOR</code>类型）</p>
                              </li>
                              <li>
                                 <p><code class="codeph">OracleTypes。CHAR_BYTES</code> （用于在同一列上调用<code class="codeph">setNull</code>和<code class="codeph">setCHAR</code>方法）</p>
                              </li>
                           </ul>
                           <p>与<code class="codeph">java.sql.Types</code> ，所有变量名都是大写文本。
                           </p>
                           <p>JDBC在两个主要方面使用由<code class="codeph">OracleTypes</code>类的元素标识的SQL类型：注册输出参数和<code class="codeph">PreparedStatement</code>类的<code class="codeph">setNull</code>方法。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-A8B450ED-A95B-4B40-B720-922C209D7D88__GUID-E19F38F4-C3D2-4C4D-A35D-B39D08884C96">OracleTypes和注册输出参数</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p><code class="codeph">java.sql.的类型代码<code class="codeph">java.sql.Types</code>或<code class="codeph">oracle.jdbc.OracleTypes</code>在<code class="codeph">java.sql.的<code class="codeph">registerOutParameter</code>方法中标识输出参数的SQL类型<code class="codeph">java.sql.CallableStatement</code>和<code class="codeph">oracle.jdbc.OracleCallableStatement</code>接口。
                           </p>
                           <p>这些是<code class="codeph">registerOutputParameter</code>方法可以为<code class="codeph">CallableStatement</code>和<code class="codeph">OracleCallableStatement</code>接口采用的形式</p><pre class="oac_no_warn" dir="ltr">cs.registerOutParameter（int index，int sqlType）; cs.registerOutParameter（int index，int sqlType，String sql_name）; cs.registerOutParameter（int index，int sqlType，int scale）;</pre><p>在这些签名中， <code class="codeph">index</code>表示参数索引， <code class="codeph">sqlType</code>是SQL数据类型的类型代码， <code class="codeph">sql_name</code>是为数据类型<code class="codeph">sql_name</code>的名称，对于用户定义的类型，当<code class="codeph">sqlType</code>是<code class="codeph">STRUCT</code> ， <code class="codeph">REF</code>或<code class="codeph">ARRAY</code>类型代码时，当<code class="codeph">sqlType</code>是<code class="codeph">NUMERIC</code>或<code class="codeph">DECIMAL</code>类型代码时， <code class="codeph">scale</code>表示小数点右边的位数。
                           </p>
                           <p>以下示例使用<code class="codeph">CallableStatement</code>接口调用名为<code class="codeph">charout</code>的过程，该过程返回<code class="codeph">CHAR</code>数据类型。请注意<code class="codeph">OracleTypes.的使用<code class="codeph">OracleTypes.<code class="codeph">registerOutParameter</code>方法中的CHAR</code>类型代码。
                           </p><pre class="oac_no_warn" dir="ltr">CallableStatement cs = conn.prepareCall（“BEGIN charout（？）; END;“）; cs.registerOutParameter（1，OracleTypes。CHAR）; cs.execute（）; System.out.println（“Out参数是：”+ cs.getString（1））;</pre><p>下一个示例使用<code class="codeph">CallableStatement</code>接口调用<code class="codeph">structout</code> ，它返回<code class="codeph">STRUCT</code>数据类型。<code class="codeph">registerOutParameter</code>的形式要求您指定类型代码， <code class="codeph">Types.STRUCT</code>或<code class="codeph">OracleTypes.STRUCT</code> ，以及SQL名称， <code class="codeph">EMPLOYEE</code> 。</p>
                           <p>该示例假定未为<code class="codeph">EMPLOYEE</code>类型声明类型映射，因此将其检索为<code class="codeph">STRUCT</code>数据类型。要将<code class="codeph">EMPLOYEE</code>的值检索为<code class="codeph">oracle.sql.STRUCT</code>对象，Statement对象<code class="codeph">cs</code>被转换为<code class="codeph">OracleCallableStatement</code>和Oracle扩展<code class="codeph">getSTRUCT</code>方法被调用。
                           </p><pre class="oac_no_warn" dir="ltr">CallableStatement cs = conn.prepareCall（“BEGIN structout（？）; END;“）; cs.registerOutParameter（1，OracleTypes。STRUCT，“EMPLOYEE”）; cs.execute（）; //将值输入STRUCT，因为假设没有定义类型映射STRUCT emp =（（OracleCallableStatement）cs）.getSTRUCT（1）;</pre></div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-A8B450ED-A95B-4B40-B720-922C209D7D88__GUID-CCFCD935-713B-4F02-83B6-8E52C56A3567">OracleTypes和setNull方法</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p><code class="codeph">Types</code>和<code class="codeph">OracleTypes</code>的类型代码标识数据项的SQL类型， <code class="codeph">setNull</code>方法将其设置为<code class="codeph">NULL</code> 。 <code class="codeph">setNull</code>方法可以在<code class="codeph">java.sql.找到<code class="codeph">java.sql.PreparedStatement</code>和<code class="codeph">oracle.jdbc.OraclePreparedStatement</code>接口。
                           </p>
                           <p>这些是<code class="codeph">setNull</code>方法可以为<code class="codeph">PreparedStatement</code>和<code class="codeph">OraclePreparedStatement</code>对象采用的形式：</p><pre class="oac_no_warn" dir="ltr">ps.setNull（int index，int sqlType）; ps.setNull（int index，int sqlType，String sql_name）;</pre><p>在这些签名中， <code class="codeph">index</code>表示参数索引， <code class="codeph">sqlType</code>是SQL数据类型的类型代码， <code class="codeph">sql_name</code>是数据类型的名称，对于用户定义的类型，当<code class="codeph">sqlType</code>是<code class="codeph">STRUCT</code> ， <code class="codeph">REF</code>或<code class="codeph">ARRAY</code>类型代码时。如果输入无效的<code class="codeph">sqlType</code> ，则抛出<code class="codeph">ParameterTypeConflict</code>异常。
                           </p>
                           <p>以下示例使用预准备语句将空值插入数据库。请注意<code class="codeph">OracleTypes.的使用<code class="codeph">OracleTypes.NUMERIC</code>用于标识设置为<code class="codeph">NULL</code>的数字对象。或者， <code class="codeph">Types.可以使用NUMERIC</code> 。
                           </p><pre class="oac_no_warn" dir="ltr">PreparedStatement pstmt = conn.prepareStatement（“INSERT INTO num_table VALUES（？）“）; pstmt.setNull（1，OracleTypes。数字）; pstmt.execute（）;</pre><p>在此示例中， <code class="codeph">STRUCT</code>准备语句将<code class="codeph">EMPLOYEE</code>类型的<code class="codeph">NULL</code> <code class="codeph">STRUCT</code>对象插入到数据库中。
                           </p><pre class="oac_no_warn" dir="ltr">PreparedStatement pstmt = conn.prepareStatement（“INSERT INTO employees VALUES（？）“）; pstmt.setNull（1，OracleTypes。STRUCT，“EMPLOYEE”）; pstmt.execute（）;</pre><p>您也可以使用<code class="codeph">OracleTypes.CHAR_BYTES</code>键入带有<code class="codeph">setNull</code>方法，如果你也想叫<code class="codeph">setCHAR</code>在同一列的方法。例如：</p><pre class="oac_no_warn" dir="ltr">ps.setCHAR（n，aCHAR）; ps.addBatch（）; ps.setNull（n，OracleTypes。CHAR_BYTES）; ps.addBatch（）;</pre><p>在前面的示例中，除<code class="codeph">OracleTypes.之外的任何其他类型<code class="codeph">OracleTypes.CHAR_BYTES</code>类型，将导致数据库的额外往返。或者，您也可以在不使用<code class="codeph">setNull</code>方法的情况下编写代码。例如，您也可以编写代码，如以下示例所示：</p><pre class="oac_no_warn" dir="ltr">ps.setCHAR（n，null）;</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div>
            </div><a id="JJDBC28174"></a><div class="props_rev_3"><a id="GUID-9EC82134-1206-4325-A17B-9FA7610F0169" name="GUID-9EC82134-1206-4325-A17B-9FA7610F0169"></a><h3 id="JJDBC-GUID-9EC82134-1206-4325-A17B-9FA7610F0169" class="sect3"><span class="enumeration_section">4.6</span> DML返回</h3>
               <div>
                  <div class="section">
                     <p>与检索自动生成的密钥相比，DML返回功能提供了更多功能。它不仅可用于检索自动生成的密钥，还可用于检索应用程序可能使用的其他列或值。</p>
                     <div class="infoboxnote" id="GUID-9EC82134-1206-4325-A17B-9FA7610F0169__GUID-23348EDA-BFA2-4909-9140-6BE89BFED53D">
                        <p class="notep1">注意：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>服务器端内部驱动程序不支持DML返回和检索自动生成的密钥。</p>
                           </li>
                           <li>
                              <p>您不能在同一语句中同时使用DML返回和检索自动生成的键。</p>
                           </li>
                        </ul>
                     </div>
                     <p>以下部分解释了对DML返回的支持：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="Oracle-extensions.html#GUID-F0E9897E-6F04-479F-9568-07FFCE7FB66F">特定于Oracle的API</a></p>
                        </li>
                        <li>
                           <p><a href="Oracle-extensions.html#GUID-E27DE9F3-236A-49F1-98BD-F3513110F3A5">关于运行DML返回语句</a></p>
                        </li>
                        <li>
                           <p><a href="Oracle-extensions.html#GUID-B2935E57-0E0A-4C4E-9515-9C63FCBDB87B">DML返回的示例</a></p>
                        </li>
                        <li>
                           <p><a href="Oracle-extensions.html#GUID-4D193775-764B-4080-9BD1-FC6F7135F086">DML返回的局限性</a></p>
                        </li>
                     </ul>
                     <div class="infoboxnotealso" id="GUID-9EC82134-1206-4325-A17B-9FA7610F0169__GUID-798FAA62-3C05-42CB-B055-AB9DD87270D9">
                        <p class="notep1">也可以看看：</p>
                        <p><span class="q">“ <a href="JDBC-standards-support.html#GUID-11E3AAF8-009C-418E-8263-E41EE49F2EA8">检索自动生成的密钥</a> ”</span></p>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div><a id="JJDBC28175"></a><div class="props_rev_3"><a id="GUID-F0E9897E-6F04-479F-9568-07FFCE7FB66F" name="GUID-F0E9897E-6F04-479F-9568-07FFCE7FB66F"></a><h4 id="JJDBC-GUID-F0E9897E-6F04-479F-9568-07FFCE7FB66F" class="sect4"><span class="enumeration_section">4.6.1</span>特定于Oracle的API</h4>
                  <div>
                     <div class="section">
                        <p><code class="codeph">OraclePreparedStatement</code>接口通过Oracle特定的应用程序编程接口（API）得到增强，以支持DML返回。<code class="codeph">registerReturnParameter</code>和<code class="codeph">getReturnResultSet</code>方法已添加到<code class="codeph">oracle.jdbc.OraclePreparedStatement</code>接口，用于注册返回的参数和由DML返回的数据。
                        </p>
                        <p><code class="codeph">registerReturnParameter</code>方法用于注册返回DML的返回参数。如果发生错误，该方法将抛出<code class="codeph">SQLException</code>实例。您必须传递一个正整数，指定返回参数的索引。您还必须指定返回参数的类型。您还可以指定返回参数的最大字节数或字符数。此方法只能用于<code class="codeph">char</code>或<code class="codeph">RAW</code>类型。您还可以指定SQL结构类型的完全限定名称。
                        </p>
                        <div class="infoboxnote" id="GUID-F0E9897E-6F04-479F-9568-07FFCE7FB66F__GUID-1BE0C9BE-D483-4393-9898-D1A5001D5926">
                           <p class="notep1">注意：</p>
                           <p>如果您不知道返回参数的最大大小，那么您应该使用<code class="codeph">registerReturnParameter(int paramIndex, int externalType)</code> ，它选择默认的最大大小。如果知道返回参数的最大大小，则使用<code class="codeph">registerReturnParameter(int paramIndex, int externalType, int maxSize)</code>可以减少内存消耗。
                           </p>
                        </div>
                        <p><code class="codeph">getReturnResultSet</code>方法获取从DML返回的数据，并将其作为<code class="codeph">ResultSet</code>对象返回。如果发生错误，该方法将抛出<code class="codeph">SQLException</code>异常。
                        </p>
                        <div class="infoboxnote" id="GUID-F0E9897E-6F04-479F-9568-07FFCE7FB66F__GUID-203F81E9-92B2-4552-B14B-95CF4D88182F">
                           <p class="notep1">注意：</p>
                           <p>对于DML恢复功能的Oracle特定的API是<code class="codeph">ojdbc6.jar</code>的Java开发工具包（JDK）6.0和<code class="codeph">ojdbc7.jar</code>为JDK 7。
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JJDBC28176"></a><div class="props_rev_3"><a id="GUID-E27DE9F3-236A-49F1-98BD-F3513110F3A5" name="GUID-E27DE9F3-236A-49F1-98BD-F3513110F3A5"></a><h4 id="JJDBC-GUID-E27DE9F3-236A-49F1-98BD-F3513110F3A5" class="sect4"><span class="enumeration_section">4.6.2</span>关于运行DML返回语句</h4>
                  <div>
                     <div class="section">
                        <p>在运行DML返回语句之前，JDBC应用程序必须调用一个或多个<code class="codeph">registerReturnParameter</code>方法。该方法为JDBC驱动程序提供返回参数的信息，例如类型和大小。然后使用标准JDBC API之一， <code class="codeph">executeUpdate</code>或<code class="codeph">execute</code>处理DML返回语句。然后，您可以使用<code class="codeph">oracle.jdbc.的<code class="codeph">getReturnResultSet</code>方法将返回的参数作为<code class="codeph">ResultSet</code>对象<code class="codeph">ResultSet</code> <code class="codeph">oracle.jdbc.OraclePreparedStatement</code>接口。
                        </p>
                        <p>要读取<code class="codeph">ResultSet</code>对象中的<code class="codeph">ResultSet</code> ，必须打开基础<code class="codeph">Statement</code>对象。关闭基础<code class="codeph">Statement</code>对象时，也会关闭返回的<code class="codeph">ResultSet</code>对象。这与通过处理SQL查询语句检索的<code class="codeph">ResultSet</code>对象一致。
                        </p>
                        <p>运行DML返回语句时， <code class="codeph">getReturnResultSet</code>方法返回的<code class="codeph">ResultSet</code>对象的并发性必须为<code class="codeph">CONCUR_READ_ONLY</code>并且<code class="codeph">ResultSet</code>对象的类型必须为<code class="codeph">TYPE_FORWARD_ONLY</code>或<code class="codeph">TYPE_SCROLL_INSENSITIVE</code> 。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JJDBC28177"></a><div class="props_rev_3"><a id="GUID-B2935E57-0E0A-4C4E-9515-9C63FCBDB87B" name="GUID-B2935E57-0E0A-4C4E-9515-9C63FCBDB87B"></a><h4 id="JJDBC-GUID-B2935E57-0E0A-4C4E-9515-9C63FCBDB87B" class="sect4"><span class="enumeration_section">4.6.3</span> DML返回示例</h4>
                  <div>
                     <div class="section">
                        <p>本节提供了两个DML返回的代码示例。</p>
                        <p>以下代码示例说明了使用DML返回。在此示例中，假设<code class="codeph">name</code>列的最大大小为100个字符。因为<code class="codeph">name</code>列的最大大小是已知的，所以使用<code class="codeph">registerReturnParameter(int paramIndex, int externalType, int maxSize)</code>方法。
                        </p><pre class="oac_no_warn" dir="ltr">...OraclePreparedStatement pstmt =（OraclePreparedStatement）conn.prepareStatement（“从tab1删除其中age &lt;？将名字归还？“）; pstmt.setInt（1,18）; / **寄存器返回参数*在这种情况下，名称的最大大小为100个字符* / pstmt.registerReturnParameter（2，OracleTypes。VARCHAR，100）; //处理DML返回语句count = pstmt.executeUpdate（）; if（count&gt; 0）{ResultSet rset = pstmt.getReturnResultSet（）; // rest不是null而不是空的（rset.next（））{String name = rset.getString（1）; ...} ...
</pre><p>以下代码示例还说明了DML返回的用法。但是，在这种情况下，返回参数的最大大小是未知的。因此，使用<code class="codeph">registerReturnParameter(int paramIndex, int externalType)</code>方法。
                        </p><pre class="oac_no_warn" dir="ltr">...OraclePreparedStatement pstmt =（OraclePreparedStatement）conn.prepareStatement（“插入lobtab值（100，empty_clob（））将col1，col2返回到？，？“）; //注册返回参数pstmt.registerReturnParameter（1，OracleTypes。整数）; pstmt.registerReturnParameter（2，OracleTypes。CLOB）; //处理DML返回SQL语句pstmt.executeUpdate（）; ResultSet rset = pstmt.getReturnResultSet（）; int r; CLOB clob; if（rset.next（））{r = rset.getInt（1）;的System.out.println（R）; clob =（CLOB）rset.getClob（2）; ...} ...
</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JJDBC28178"></a><div class="props_rev_3"><a id="GUID-4D193775-764B-4080-9BD1-FC6F7135F086" name="GUID-4D193775-764B-4080-9BD1-FC6F7135F086"></a><h4 id="JJDBC-GUID-4D193775-764B-4080-9BD1-FC6F7135F086" class="sect4"><span class="enumeration_section">4.6.4</span> DML返回的限制</h4>
                  <div>
                     <div class="section">
                        <p>使用DML返回时，请注意以下事项：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>未指定<code class="codeph">getReturnResultSet</code>方法在<code class="codeph">getReturnResultSet</code>调用时返回的内容。你不应该依赖这方面的任何具体行动。
                              </p>
                           </li>
                           <li>
                              <p>从执行DML返回语句返回的<code class="codeph">ResultSet</code>对象不支持<code class="codeph">ResultSetMetaData</code>类型。因此，应用程序必须在运行DML返回语句之前知道返回参数的信息。
                              </p>
                           </li>
                           <li>
                              <p>DML返回不支持流。</p>
                           </li>
                           <li>
                              <p>DML返回不能与批量更新结合使用。</p>
                           </li>
                           <li>
                              <p>您不能在单个SQL DML语句中同时使用自动生成的键功能和DML返回功能。例如，不允许以下内容：</p><pre class="oac_no_warn" dir="ltr">...PreparedStatement pstmt = conn.prepareStatement（'插入订单（？，？，？）将order_id返回？“）; pstmt.setInt（1，seq01。NEXTVAL）; pstmt.setInt（2,100）; pstmt.setInt（3,966431502）; pstmt.registerReturnParam（4，OracleTypes。整数）; pstmt.executeUpdate; ResultSet rset = pstmt.getGeneratedKeys; ...
</pre></li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="JJDBC28179"></a><div class="props_rev_3"><a id="GUID-2EF2089E-11B3-4395-8464-E6EFC23285AB" name="GUID-2EF2089E-11B3-4395-8464-E6EFC23285AB"></a><h3 id="JJDBC-GUID-2EF2089E-11B3-4395-8464-E6EFC23285AB" class="sect3"><span class="enumeration_section">4.7</span>访问PL / SQL关联数组</h3>
               <div>
                  <p></p>
                  <div class="section">
                     <p>Oracle JDBC驱动程序使JDBC应用程序能够使用Associative Arrays参数进行PL / SQL调用。在PL / SQL中，关联数组是一组键值对，其中键可以是<code class="codeph">PLS_INTEGER</code>或字符串。键可以具有任何值，并且不需要密集。从客户端应用程序，您只能使用<code class="codeph">PLS_INTEGER</code>或<code class="codeph">BINARY_INTEGER</code>键。
                     </p>
                     <div class="infoboxnote" id="GUID-2EF2089E-11B3-4395-8464-E6EFC23285AB__GUID-D8880935-CEFB-4737-9597-25339D1F8750">
                        <p class="notep1">注意：</p>
                        <p><code class="codeph">PLS_INTEGER</code>和<code class="codeph">BINARY_INTEGER</code>是相同的数据类型。
                        </p>
                     </div>
                     <p>以前版本的Oracle JDBC驱动程序仅支持标量数据类型的PL / SQL关联数组。此外，支持仅限于数组的键值对的值。Oracle Database Release 18c支持访问关联数组的键（索引）和值，还支持对象类型的关联数组。使用以下方法来实现新功能：</p>
                     <ul style="list-style-type:disc">
                        <li><pre class="pre codeblock"><code>Array createOracleArray（String arrayTypeName，Object elements）抛出SQLException</code></pre></li>
                        <li><pre class="pre codeblock"><code>ARRAY createARRAY（String typeName，Object elements）抛出SQLException</code></pre><p>在上述两种方法中，第二个参数都可以是<code class="codeph">java.util.地图&lt;整数，？&gt;</code>保存关联数组的键值对，或者它只能是值数组。如果它是值数组，则JDBC驱动程序将索引默认为0,1,2，依此类推。如果是<code class="codeph">java.util.地图&lt;整数，？&gt;</code> ，然后JDBC驱动程序不会默认密钥。它们保持在Map中的指定，并且可以是稀疏的和负的。
                           </p>
                        </li>
                        <li><pre class="pre codeblock"><code>地图&lt;？，？&gt; oracle.jdbc。OracleArray.getJavaMap（）;</code></pre><p>这个方法返回一个<code class="codeph">Map&lt;?,?&gt;</code>表示关联数组中的数据类型，对于嵌套表和VARRAY表为<code class="codeph">null</code> 。
                           </p>
                        </li>
                     </ul>
                     <div class="infoboxnote" id="GUID-2EF2089E-11B3-4395-8464-E6EFC23285AB__GUID-7184BC8E-93C6-4C9F-9CC0-1E4B8AE7E0AA">
                        <p class="notep1">注意：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>关联数组以前称为索引表。</p>
                           </li>
                           <li>
                              <p>使用字符串数据类型时，大小限制为PL / SQL中的大小为32767个字符。对于服务器端内部驱动程序，限制较低。</p>
                           </li>
                        </ul>
                     </div>
                     <div class="infoboxnotealso" id="GUID-2EF2089E-11B3-4395-8464-E6EFC23285AB__GUID-37514249-E899-4DFD-A0FA-D0256B2C54B8">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><span><cite>Oracle数据库JDBC Java API参考</cite></span></p>
                           </li>
                           <li>
                              <p><a href="../lnpls/plsql-collections-and-records.html#LNPLS-GUID-8060F01F-B53B-48D4-9239-7EA8461C2170" target="_blank"><span><cite>Oracle数据库PL / SQL语言参考</cite></span></a></p>有关关联数组的更多信息</li>
                        </ul>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div>
            </div>
         </div>
      </article>
   </body>
</html>