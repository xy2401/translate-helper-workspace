<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html xml:lang="en-us" lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <title>Oracle Extensions</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="JDBC Developer's Guide">
      <meta property="og:description" content="">
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="JDBC Developer's Guide">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="jdbc-developers-guide.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2019-02-13T13:20:37-08:00">
      <meta name="dcterms.title" content="JDBC Developer's Guide">
      <meta name="dcterms.dateCopyrighted" content="1999, 2019">
      <meta name="dcterms.category" content="database">
      <meta name="dcterms.identifier" content="E96471-02">
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19">
      
      <link rel="prev" href="JDBC-standards-support.html" title="Previous" type="text/html">
      <link rel="next" href="JDBC-Thin-features.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.isVersionOf" content="JJDBC">
    <meta name="dcterms.release" content="Release 19">
  </head>
   <body>
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="JDBC-standards-support.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>Previous</a>
         <a href="JDBC-Thin-features.html" class="pull-right">Next<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a>
         <span class="fa fa-exclamation-triangle" aria-hidden="true"></span> JavaScript must be enabled to correctly display this content
        
      </div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">JDBC Developer's Guide</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="overview-Oracle-JDBC.html" property="item" typeof="WebPage"><span property="name"> Oracle JDBC</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem"> Oracle Extensions </li>
            </ol>
            <a id="GUID-2A28CD5C-7696-4EFF-B9AF-8A62E89E3652" name="GUID-2A28CD5C-7696-4EFF-B9AF-8A62E89E3652"></a><a id="JJDBC28120"></a>
            
            <h2 id="JJDBC-GUID-2A28CD5C-7696-4EFF-B9AF-8A62E89E3652" class="sect2"><span class="enumeration_chapter">4 </span> Oracle Extensions 
            </h2>
         </header>
         <div class="ind">
            <div>
               <p><a id="d23567e21" class="indexterm-anchor"></a><a id="d23567e25" class="indexterm-anchor"></a>Oracle provides Java classes and interfaces that extend the Java Database Connectivity (JDBC) standard implementation, enabling you to access and manipulate Oracle data types and use Oracle performance extensions. This chapter provides an overview of the classes and interfaces provided by Oracle that extend the JDBC standard implementation. It also describes some of the key support features of the extensions.
               </p>
               <p>This chapter contains the following sections:</p>
               <ul style="list-style-type: disc;">
                  <li>
                     <p><a href="Oracle-extensions.html#GUID-AC9387F5-5333-4602-9C43-467CCBCD67A2">Overview of Oracle Extensions</a></p>
                  </li>
                  <li>
                     <p><a href="Oracle-extensions.html#GUID-868B15D0-71BF-4501-83F6-11ABCE319803">Features of the Oracle Extensions </a></p>
                  </li>
                  <li>
                     <p><a href="Oracle-extensions.html#GUID-D61F7AAC-3708-4437-8070-52F707B68259">Oracle JDBC Packages</a></p>
                  </li>
                  <li>
                     <p><a href="Oracle-extensions.html#GUID-E180187D-07AA-4D64-9946-4D08FBB2E46E">Oracle Character Data Types Support</a></p>
                  </li>
                  <li>
                     <p><a href="Oracle-extensions.html#GUID-0DA598C9-4C4E-42D7-B581-B971B8D87A96">Additional Oracle Type Extensions</a></p>
                  </li>
                  <li>
                     <p><a href="Oracle-extensions.html#GUID-9EC82134-1206-4325-A17B-9FA7610F0169">DML Returning</a></p>
                  </li>
                  <li>
                     <p><a href="Oracle-extensions.html#GUID-2EF2089E-11B3-4395-8464-E6EFC23285AB">Accessing PL/SQL Associative Arrays</a></p>
                  </li>
               </ul>
            </div>
            <div>
               <div class="relinfo">
                  <p><strong>Related Topics</strong></p>
                  <ul>
                     <li><a href="performance-extensions.html#GUID-FEECA64F-44F4-453F-B8A8-AFBF6D29ABA4">Performance Extensions</a></li>
                  </ul>
               </div>
            </div>
            <a id="JJDBC28121"></a><div class="props_rev_3"><a id="GUID-AC9387F5-5333-4602-9C43-467CCBCD67A2" name="GUID-AC9387F5-5333-4602-9C43-467CCBCD67A2"></a><h3 id="JJDBC-GUID-AC9387F5-5333-4602-9C43-467CCBCD67A2" class="sect3"><span class="enumeration_section">4.1 </span>Overview of Oracle Extensions
               </h3>
               <div>
                  <p>Beyond standard features, Oracle JDBC drivers provide Oracle-specific type extensions and performance extensions. These extensions are provided through the following Java packages:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><code class="codeph">oracle.sql</code></p>
                        <p>Provides classes that represent SQL data in Oracle format</p>
                     </li>
                     <li>
                        <p><code class="codeph">oracle.jdbc</code></p>
                        <p>Provides interfaces to support database access and updates in Oracle type formats</p>
                     </li>
                  </ul>
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>Related Topics</strong></p>
                     <ul>
                        <li><a href="Oracle-extensions.html#GUID-D61F7AAC-3708-4437-8070-52F707B68259">Oracle JDBC Packages</a></li>
                     </ul>
                  </div>
               </div>
               
            </div><a id="JJDBC28122"></a><div class="props_rev_3"><a id="GUID-868B15D0-71BF-4501-83F6-11ABCE319803" name="GUID-868B15D0-71BF-4501-83F6-11ABCE319803"></a><h3 id="JJDBC-GUID-868B15D0-71BF-4501-83F6-11ABCE319803" class="sect3"><span class="enumeration_section">4.2 </span>Features of the Oracle Extensions 
               </h3>
               <div>
                  <div class="section">
                     <p>The Oracle extensions to JDBC include a number of features that enhance your ability to work with Oracle Databases. These include the following:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="Oracle-extensions.html#GUID-CC7CA29D-EDD8-42C8-9730-F03C279CC13B">Database Management Using JDBC</a></p>
                        </li>
                        <li>
                           <p><a href="Oracle-extensions.html#GUID-98B72A83-155A-438A-BC8A-C88F89D24233">Support for Oracle Data Types</a></p>
                        </li>
                        <li>
                           <p><a href="Oracle-extensions.html#GUID-2B5B46DD-5608-4407-A5D9-4944567487D1">Support for Oracle Objects</a></p>
                        </li>
                        <li>
                           <p><a href="Oracle-extensions.html#GUID-FA1A98DC-9D88-4038-8C2F-839D659C813C">Support for Schema Naming</a></p>
                        </li>
                        <li>
                           <p><a href="Oracle-extensions.html#GUID-27FDA3E3-6E75-4970-8274-8AECAA10E235">DML Returning</a></p>
                        </li>
                        <li>
                           <p><a href="Oracle-extensions.html#GUID-6FD9F303-8C2F-42A8-AD4E-106FE155891A">About Accessing PL/SQL Associative Arrays</a></p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
               </div><a id="JJDBC28123"></a><div class="props_rev_3"><a id="GUID-CC7CA29D-EDD8-42C8-9730-F03C279CC13B" name="GUID-CC7CA29D-EDD8-42C8-9730-F03C279CC13B"></a><h4 id="JJDBC-GUID-CC7CA29D-EDD8-42C8-9730-F03C279CC13B" class="sect4"><span class="enumeration_section">4.2.1 </span>Database Management Using JDBC
                  </h4>
                  <div>
                     <div class="section">
                        <p>Starting from Oracle Database 11<span class="italic">g</span> Release 1, the <code class="codeph">oracle.jdbc.OracleConnection</code> interface has two JDBC methods, <code class="codeph">startup</code> and <code class="codeph">shutdown</code>, which enable you to start up and shut down an Oracle Database instance.
                        </p>
                        <div class="infoboxnote" id="GUID-CC7CA29D-EDD8-42C8-9730-F03C279CC13B__GUID-8738A08A-2248-4076-B7CD-6E9975A4FFC3">
                           <p class="notep1">Note:</p>
                           <p>My Oracle Support Note 335754.1 announces the desupport of the <code class="codeph">oracle.jdbc.driver.*</code> package in Oracle Database 11<span class="italic">g</span> JDBC drivers. In other words, Oracle Database 10<span class="italic">g</span> Release 2 was the last database to support this package and any API depending on the <code class="codeph">oracle.jdbc.driver.*</code> package will fail to compile in the current release of the Database. You must remove such APIs and migrate to the standard APIs. For example, if your code uses the  <code class="codeph">oracle.jdbc.CustomDatum</code> and <code class="codeph">oracle.jdbc.CustomDatumFactory</code> interfaces, then you must replace them with the <code class="codeph">java.sql.Struct</code> or <code class="codeph">java.sql.SQLData</code> interfaces.
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>Related Topics</strong></p>
                        <ul>
                           <li><a href="database-administration.html#GUID-6EC16CE6-5734-473E-A270-EB387A9C0043">Database Administration</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div><a id="JJDBC28125"></a><div class="props_rev_3"><a id="GUID-98B72A83-155A-438A-BC8A-C88F89D24233" name="GUID-98B72A83-155A-438A-BC8A-C88F89D24233"></a><h4 id="JJDBC-GUID-98B72A83-155A-438A-BC8A-C88F89D24233" class="sect4"><span class="enumeration_section">4.2.2 </span>Support for Oracle Data Types
                  </h4>
                  <div>
                     <div class="section">
                        <p>One of the features of the Oracle JDBC extensions is the type support in the <a id="d23567e283" class="indexterm-anchor"></a><code class="codeph">oracle.sql</code> package. This package includes classes that are an exact representation of the data in Oracle format. Keep the following important points in mind, when you use <code class="codeph">oracle.sql</code> types in your program:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>For numeric type of data, the conversion to standard Java types does not guarantee to retain full precision due to limitations of the data conversion process. Use the <code class="codeph">BigDecimal</code> type to minimize any data loss issues.
                              </p>
                           </li>
                           <li>
                              <p>For certain data types, the conversion to standard Java types can be dependent on the system settings and your program may not run as expected. This is a known limitation while converting data from <code class="codeph">oracle.sql</code> types to standard Java types.
                              </p>
                           </li>
                           <li>
                              <p>If the functionalities of your program is limited to reading data from one table and writing the same to another table, then for numeric and date data, <code class="codeph">oracle.sql</code> types are slightly faster as compared to standard Java types. But, if your program involves even a simple data manipulation operation like compare or print, then standard Java types are faster.
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">oracle.sql.CHAR</code> is not an exact representation of the data in Oracle format. <code class="codeph">oracle.sql.CHAR</code> is constructed from <code class="codeph">java.lang.String</code>. There is no advantage of using <code class="codeph">oracle.sql.CHAR</code> because <code class="codeph">java.lang.String</code> is always faster and represents the same character sets, excluding a couple of desupported character sets.
                              </p>
                           </li>
                        </ul>
                        <div class="infoboxnote" id="GUID-98B72A83-155A-438A-BC8A-C88F89D24233__GUID-2B89DBAD-D736-4D0F-8676-47D21B701124">
                           <p class="notep1">Note:</p>
                           <p>Oracle strongly recommends you to use standard Java types and convert any existing <code class="codeph">oracle.sql</code> type of data to standard Java types. Internally, the Oracle JDBC drivers strive to maximize the performance of Java standard types. <code class="codeph">oracle.sql</code> types are supported <span class="italic">only</span> for backward compatibility and their use is discouraged.
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>Related Topics</strong></p>
                        <ul>
                           <li><a href="Oracle-extensions.html#GUID-DB1F687A-CF1C-4B3F-92C0-126DC782EF53">Package oracle.sql</a></li>
                           <li><a href="Oracle-extensions.html#GUID-E180187D-07AA-4D64-9946-4D08FBB2E46E">Oracle Character Data Types Support</a></li>
                           <li><a href="Oracle-extensions.html#GUID-0DA598C9-4C4E-42D7-B581-B971B8D87A96">Additional Oracle Type Extensions</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div><a id="JJDBC28126"></a><div class="props_rev_3"><a id="GUID-2B5B46DD-5608-4407-A5D9-4944567487D1" name="GUID-2B5B46DD-5608-4407-A5D9-4944567487D1"></a><h4 id="JJDBC-GUID-2B5B46DD-5608-4407-A5D9-4944567487D1" class="sect4"><span class="enumeration_section">4.2.3 </span>Support for Oracle Objects
                  </h4>
                  <div>
                     <div class="section">
                        <p>Oracle JDBC supports the use of structured objects in the database, where an object data type is a user-defined type with nested attributes. For example, a user application could define an <code class="codeph">Employee</code> object type, where each <code class="codeph">Employee</code> object has a <code class="codeph">firstname</code> attribute (character string), a <code class="codeph">lastname</code> attribute (character string), and an <code class="codeph">employeenumber</code> attribute (integer).
                        </p>
                        <p>Oracle JDBC supports Oracle object data types. When you work with Oracle object data types in a Java application, you must consider the following:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>How to map between Oracle object data types and Java classes</p>
                           </li>
                           <li>
                              <p>How to store Oracle object attributes in corresponding Java objects</p>
                           </li>
                           <li>
                              <p>How to convert attribute data between SQL and Java formats</p>
                           </li>
                           <li>
                              <p>How to access data</p>
                           </li>
                        </ul>
                        <p>Oracle objects can be mapped either to the weak <code class="codeph">java.sql.Struct</code> type or to strongly typed customized classes. These strong types are referred to as <a id="d23567e429" class="indexterm-anchor"></a>custom Java classes, which must implement either the standard <code class="codeph">java.sql.SQLData</code> interface or the Oracle extension <code class="codeph">oracle.jdbc.OracleData</code> interface. Each interface specifies methods to convert data between SQL and Java.
                        </p>
                        <div class="infoboxnote" id="GUID-2B5B46DD-5608-4407-A5D9-4944567487D1__GUID-C4651E43-F902-4F14-878D-E53083867727">
                           <p class="notep1">Note:</p>
                           <p>Starting from Oracle Database 12<span class="italic">c </span>Release 1 (12.1), the <code class="codeph">OracleData</code> interface has replaced the <code class="codeph">ORAData</code> interface.
                           </p>
                        </div>
                        <p>Oracle recommends the use of the Oracle JVM Web Service Call-Out Utility to create custom Java classes to correspond to your Oracle objects.</p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>Related Topics</strong></p>
                        <ul>
                           <li><a href="Oracle-object-types.html#GUID-5905674A-A045-40B1-96DE-726761517D50">Working with Oracle Object Types</a></li>
                           <li><a href="../jjdev/database-as-web-service-consumer.html#JJDEV-GUID-E66168C4-6043-4A49-9062-A4937B76ABC0" target="_blank"><span><cite>Oracle Database Java Developerâ€™s Guide</cite></span></a></li>
                        </ul>
                     </div>
                  </div>
               </div><a id="JJDBC28127"></a><div class="props_rev_3"><a id="GUID-FA1A98DC-9D88-4038-8C2F-839D659C813C" name="GUID-FA1A98DC-9D88-4038-8C2F-839D659C813C"></a><h4 id="JJDBC-GUID-FA1A98DC-9D88-4038-8C2F-839D659C813C" class="sect4"><span class="enumeration_section">4.2.4 </span>Support for Schema Naming
                  </h4>
                  <div>
                     <p>Oracle object data type classes have the ability to accept and return fully qualified schema names. A fully qualified schema name has this syntax:</p><pre class="oac_no_warn" dir="ltr">{[<span class="italic">schema_name</span>].}[<span class="italic">sql_type_name]</span> 
 </pre><p>Where, <span class="italic"><code class="codeph">schema_name</code></span> is the name of the schema and <span class="italic"><code class="codeph">sql_type_name</code></span> is the SQL type name of the object. <span class="italic"><code class="codeph">schema_name</code></span> and <span class="italic"><code class="codeph">sql_type_name</code></span> are separated by a period (<code class="codeph">.</code>). 
                     </p>
                     <p>To specify an object type in JDBC, use its fully qualified name. It is not necessary to enter a schema name if the type name is in the current naming space, that is, the current schema. Schema naming follows these rules:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Both the schema name and the type name may or may not be within quotation marks. However, if the SQL type name has a period in it, such as <code class="codeph">CORPORATE.EMPLOYEE</code>, the type name must be quoted. 
                           </p>
                        </li>
                        <li>
                           <p>The JDBC driver looks for the first period in the object name that is not within quotation marks and uses the string before the period as the schema name and the string following the period as the type name. If no period is found, then the JDBC driver takes the current schema as default. That is, you can specify only the type name, without indicating a schema, instead of specifying the fully qualified name if the object type name belongs to the current schema. This also explains why you must put the type name within quotation marks if the type name has a dot in it. </p>
                           <p>For example, assume that user <code class="codeph">HR</code> creates a type called <code class="codeph">person.address</code> and then wants to use it in his session. <code class="codeph">HR</code> may want to skip the schema name and pass in <code class="codeph">person.address</code> to the JDBC driver. In this case, if <code class="codeph">person.address</code> is not within quotation marks, then the period is detected and the JDBC driver mistakenly interprets <code class="codeph">person</code> as the schema name and <code class="codeph">address</code> as the type name.
                           </p>
                        </li>
                        <li>
                           <p>JDBC passes the object type name string to the database unchanged. That is, the JDBC driver does not change the character case even if the object type name is within quotation marks. </p>
                           <p>For example, if <code class="codeph">HR.PersonType</code> is passed to the JDBC driver as an object type name, then the JDBC driver passes the string to the database unchanged. As another example, if there is white space between characters in the type name string, then the JDBC driver will not remove the white space. 
                           </p>
                        </li>
                     </ul>
                  </div>
               </div><a id="JJDBC28128"></a><div class="props_rev_3"><a id="GUID-27FDA3E3-6E75-4970-8274-8AECAA10E235" name="GUID-27FDA3E3-6E75-4970-8274-8AECAA10E235"></a><h4 id="JJDBC-GUID-27FDA3E3-6E75-4970-8274-8AECAA10E235" class="sect4"><span class="enumeration_section">4.2.5 </span>DML Returning
                  </h4>
                  <div>
                     <div class="section">
                        <p>Oracle Database supports the use of the <code class="codeph">RETURNING</code> clause with data manipulation language (DML) statements. This enables you to combine two SQL statements into one. Both the Oracle JDBC Oracle Call Interface (OCI) driver and the Oracle JDBC Thin driver support DML returning.
                        </p>
                        <div class="infoboxnotealso" id="GUID-27FDA3E3-6E75-4970-8274-8AECAA10E235__GUID-4713F5FF-DAFE-4DDF-92D2-98EF0E263B92">
                           <p class="notep1">See Also:</p>
                           <p><span class="q">"<a href="Oracle-extensions.html#GUID-9EC82134-1206-4325-A17B-9FA7610F0169">DML Returning</a>"</span></p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JJDBC28129"></a><div class="props_rev_3"><a id="GUID-6FD9F303-8C2F-42A8-AD4E-106FE155891A" name="GUID-6FD9F303-8C2F-42A8-AD4E-106FE155891A"></a><h4 id="JJDBC-GUID-6FD9F303-8C2F-42A8-AD4E-106FE155891A" class="sect4"><span class="enumeration_section">4.2.6 </span>PL/SQL Associative Arrays
                  </h4>
                  <div>
                     <div class="section">
                        <p>Oracle JDBC drivers enable JDBC applications to make PL/SQL calls with Associative Array parameters. Oracle JDBC drivers support PL/SQL Associative Arrays of scalar data types</p>
                        <div class="infoboxnotealso" id="GUID-6FD9F303-8C2F-42A8-AD4E-106FE155891A__GUID-DC8286DE-0320-4779-936C-D430454421EE">
                           <p class="notep1">See Also:</p>
                           <p><span class="q">"<a href="Oracle-extensions.html#GUID-2EF2089E-11B3-4395-8464-E6EFC23285AB">Accessing PL/SQL Associative Arrays</a>"</span></p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="JJDBC28130"></a><div class="props_rev_3"><a id="GUID-D61F7AAC-3708-4437-8070-52F707B68259" name="GUID-D61F7AAC-3708-4437-8070-52F707B68259"></a><h3 id="JJDBC-GUID-D61F7AAC-3708-4437-8070-52F707B68259" class="sect3"><span class="enumeration_section">4.3 </span>Oracle JDBC Packages
               </h3>
               <div>
                  <div class="section">
                     <p>This section describes the following Java packages, which support the Oracle JDBC extensions:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="Oracle-extensions.html#GUID-DB1F687A-CF1C-4B3F-92C0-126DC782EF53">Package oracle.sql</a></p>
                        </li>
                        <li>
                           <p><a href="Oracle-extensions.html#GUID-7AA5D4CC-57C2-4E85-8486-45B52D447B66">Package oracle.jdbc</a></p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
               </div><a id="JJDBC28132"></a><a id="JJDBC28133"></a><a id="JJDBC28134"></a><a id="JJDBC28136"></a><a id="JJDBC28137"></a><a id="JJDBC28138"></a><a id="JJDBC28139"></a><a id="JJDBC28131"></a><div class="props_rev_3"><a id="GUID-DB1F687A-CF1C-4B3F-92C0-126DC782EF53" name="GUID-DB1F687A-CF1C-4B3F-92C0-126DC782EF53"></a><h4 id="JJDBC-GUID-DB1F687A-CF1C-4B3F-92C0-126DC782EF53" class="sect4"><span class="enumeration_section">4.3.1 </span>Package oracle.sql
                  </h4>
                  <div>
                     <div class="section">
                        <p>The <code class="codeph">oracle.sql</code> package supports direct access to data in SQL format. This package consists primarily of classes that provide Java mappings to SQL data types and their support classes. Essentially, the classes act as Java containers for SQL data.
                        </p>
                        <p>Each of the <code class="codeph">oracle.sql.*</code> data type classes extends <code class="codeph">oracle.sql.Datum</code>, a superclass that encapsulates functionality common to all the data types. Some of the classes are for JDBC 2.0-compliant data types. These classes, implement standard JDBC 2.0 interfaces in the <code class="codeph">java.sql</code> package, as well as extending the <code class="codeph">oracle.sql.Datum</code> class.
                        </p>
                        <p>The <code class="codeph">LONG</code> and <code class="codeph">LONG</code> <code class="codeph">RAW</code> SQL types and <code class="codeph">REF</code> <code class="codeph">CURSOR</code> type category have no <code class="codeph">oracle.sql.*</code> classes. Use standard JDBC functionality for these types. For example, retrieve <code class="codeph">LONG</code> or <code class="codeph">LONG</code> <code class="codeph">RAW</code> data as input streams using the standard JDBC result set and callable statement methods <code class="codeph">getBinaryStream</code> and <code class="codeph">getCharacterStream</code>. Use the <code class="codeph">getCursor</code> method for <code class="codeph">REF</code> <code class="codeph">CURSOR</code> types.
                        </p>
                        <div class="infoboxnote" id="GUID-DB1F687A-CF1C-4B3F-92C0-126DC782EF53__GUID-7FC029E1-8DDA-4D00-8AA2-7E42A285F657">
                           <p class="notep1">Note:</p>
                           <p>Oracle recommends the use of standard JDBC types or Java types whenever possible. The types in the package <code class="codeph">oracle.sql.*</code> are provided primarily for backward compatibility or for support of a few Oracle specific features such as <code class="codeph">OPAQUE</code>, <code class="codeph">OracleData</code>, <code class="codeph">TIMESTAMPTZ</code>, and so on.
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-DB1F687A-CF1C-4B3F-92C0-126DC782EF53__GUID-71C625B6-4E30-487F-9C52-5CE080BCD26A">General oracle.sql.* Data Type Support</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>Each of the <a id="d23567e802" class="indexterm-anchor"></a>Oracle data type classes provides, among other things, the following:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Data storage as Java byte arrays for SQL data</p>
                           </li>
                           <li>
                              <p>A <code class="codeph">getBytes()</code> method, which returns the SQL data as a byte array
                              </p>
                           </li>
                           <li>
                              <p>A <code class="codeph">toJdbc()</code> method that converts the data into an object of a corresponding Java class as defined in the JDBC specification
                              </p>
                              <p>The JDBC driver does not convert Oracle-specific data types that are not part of the JDBC specification, such as <code class="codeph">BFILE</code>. The driver returns the object in the corresponding <code class="codeph">oracle.sql.*</code> format.
                              </p>
                           </li>
                           <li>
                              <p>Appropriate <span class="italic"><code class="codeph">xxx</code></span><code class="codeph">Value</code> methods to convert SQL data to Java type. For example, <code class="codeph">stringValue</code>, <code class="codeph">intValue</code>, <code class="codeph">booleanValue</code>, <code class="codeph">dateValue</code>, and <code class="codeph">bigDecimalValue</code></p>
                           </li>
                           <li>
                              <p>Additional conversion methods, <code class="codeph">get</code><span class="italic"><code class="codeph">XXX</code></span> and <code class="codeph">set</code><span class="italic"><code class="codeph">XXX</code></span>, as appropriate, for the functionality of the data type, such as methods in the large object (LOB) classes that get the data as a stream and methods in the <code class="codeph">REF</code> class that get and set object data through the object reference.
                              </p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-DB1F687A-CF1C-4B3F-92C0-126DC782EF53__I1075337">
                        <p class="subhead3" id="GUID-DB1F687A-CF1C-4B3F-92C0-126DC782EF53__GUID-274246BF-8C24-4569-9C06-2F7F26A14E15">Overview of Class oracle.sql.STRUCT</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p><code class="codeph">oracle.sql.STRUCT</code> class is the Oracle implementation of <code class="codeph">java.sql.Struct</code> interface. This class is a value class and you should not change the contents of the class after construction. This class, as with all <code class="codeph">oracle.sql.*</code> data type classes, is a subclass of the <code class="codeph">oracle.sql.Datum</code> class.
                        </p>
                        <div class="infoboxnote" id="GUID-DB1F687A-CF1C-4B3F-92C0-126DC782EF53__GUID-42E3AD51-0D59-4EB3-AFB0-C6FB9E69EEE7">
                           <p class="notep1">Note:</p>
                           <p>Starting from Oracle Database 12<span class="italic">c </span>Release 1 (12.1), the <code class="codeph">oracle.sql.STRUCT</code> class is deprecated and replaced with the <code class="codeph">oracle.jdbc.OracleStruct</code> interface, which is a part of the <code class="codeph">oracle.jdbc</code> package. Oracle strongly recommends you to use the methods available in the <code class="codeph">java.sql</code> package, where possible, for standard compatibility and methods available in the <code class="codeph">oracle.jdbc</code> package for Oracle specific extensions. Refer to MoS Note 1364193.1 for more information about the <code class="codeph">oracle.jdbc.OracleStruct</code> interface.
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-DB1F687A-CF1C-4B3F-92C0-126DC782EF53__GUID-EBA55865-F5EA-4C0D-BBA5-7DCBC0BAC8EC">Overview of Class oracle.sql.REF</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>The <code class="codeph">oracle.sql.REF</code> class is the generic class that supports Oracle object references. This class, as with all <code class="codeph">oracle.sql.*</code> data type classes, is a subclass of the <code class="codeph">oracle.sql.Datum</code> class.
                        </p>
                        <div class="infoboxnote" id="GUID-DB1F687A-CF1C-4B3F-92C0-126DC782EF53__GUID-70192D47-A0D5-4EFC-B689-A3733F21B37F">
                           <p class="notep1">Note:</p>
                           <p>Starting from Oracle Database 12<span class="italic">c </span>Release 1 (12.1), the <code class="codeph">oracle.sql.REF</code> class is deprecated and replaced with the <code class="codeph">oracle.jdbc.OracleRef</code> interface, which is a part of the <code class="codeph">oracle.jdbc</code> package. Oracle strongly recommends you to use the methods available in the <code class="codeph">java.sql</code> package, where possible, for standard compatibility and methods available in the <code class="codeph">oracle.jdbc</code> package for Oracle specific extensions. Refer to MoS Note 1364193.1 for more information about the <code class="codeph">oracle.jdbc.OracleRef</code> interface.
                           </p>
                        </div>
                        <p>The <code class="codeph">REF</code> class has methods to retrieve and pass object references. However, selecting an object reference retrieves only a pointer to an object. This does not materialize the object itself. But the <code class="codeph">REF</code> class also includes methods to retrieve and pass the object data. You cannot create <code class="codeph">REF</code> objects in your JDBC application. You can only retrieve existing <code class="codeph">REF</code> objects from the database.
                        </p>
                        <p>You should use the JDBC standard type, <code class="codeph">java.sql.Ref</code>, and the JDBC standard methods in preference to using <code class="codeph">oracle.sql.REF</code>. If you want your code to be more portable, then you must use the standard type because only the Oracle JDBC drivers will use instances of <code class="codeph">oracle.sql.REF</code> type.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-DB1F687A-CF1C-4B3F-92C0-126DC782EF53__GUID-3162BA52-E80E-4EC3-8B0C-573B70FFE05C">Overview of Classes oracle.sql.BLOB, oracle.sql.CLOB, oracle.sql.BFILE</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p><a id="d23567e985" class="indexterm-anchor"></a><a id="d23567e987" class="indexterm-anchor"></a><a id="d23567e989" class="indexterm-anchor"></a><a id="d23567e991" class="indexterm-anchor"></a><a id="d23567e995" class="indexterm-anchor"></a><a id="d23567e999" class="indexterm-anchor"></a>Binary large objects (BLOBs), character large objects (CLOBs), and binary files (BFILEs) are for data items that are too large to store directly in a database table. Instead, the database table stores a locator that points to the location of the actual data.
                        </p>
                        <div class="infoboxnote" id="GUID-DB1F687A-CF1C-4B3F-92C0-126DC782EF53__GUID-00FA74C8-7830-4208-81BF-CCA02015CF00">
                           <p class="notep1">Note:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>Starting from Oracle Database 12<span class="italic">c </span>Release 1 (12.1), the <code class="codeph">oracle.sql.BLOB</code> and <code class="codeph">Oracle.sql.CLOB</code> classes are deprecated and replaced with the <code class="codeph">oracle.jdbc.OracleBlob</code> and <code class="codeph">oracle.jdbc.OracleClob</code> interfaces respectively, which are a part of the <code class="codeph">oracle.jdbc</code> package. Oracle strongly recommends you to use the methods available in the <code class="codeph">java.sql</code> package, where possible, for standard compatibility and methods available in the <code class="codeph">oracle.jdbc</code> package for Oracle specific extensions. Refer to MoS Note 1364193.1 for more information about the <code class="codeph">oracle.jdbc.OracleBlob</code> and <code class="codeph">oracle.jdbc.OracleClob</code> interfaces.
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">oracle.sql.BFILE</code> is an Oracle proprietary extension and there is no JDBC standard equivalent.
                                 </p>
                              </li>
                           </ul>
                        </div>
                        <p>The <code class="codeph">oracle.sql</code> package supports these data types in several ways:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>BLOBs point to large unstructured binary data items and are supported by the <code class="codeph">oracle.sql.BLOB</code> class. 
                              </p>
                           </li>
                           <li>
                              <p>CLOBs point to large character data items and are supported by the <code class="codeph">oracle.sql.CLOB</code> class. 
                              </p>
                           </li>
                           <li>
                              <p>BFILEs point to the content of external files (operating system files) and are supported by the <code class="codeph">oracle.sql.BFILE</code> class. BFiles are read-only.
                              </p>
                           </li>
                        </ul>
                        <p>You can select a BLOB, <a id="d23567e1071" class="indexterm-anchor"></a><a id="d23567e1075" class="indexterm-anchor"></a>CLOB, or <a id="d23567e1082" class="indexterm-anchor"></a>BFILE locator from the database using a standard <code class="codeph">SELECT</code> statement. However, you receive only the locator, and not the data. Additional steps are necessary to retrieve the data. 
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-DB1F687A-CF1C-4B3F-92C0-126DC782EF53__GUID-F81B776A-7B4E-44CC-907F-0A8F9D665FB7">Overview of Classes oracle.sql.DATE, oracle.sql.NUMBER, and oracle.sql.RAW</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p><a id="d23567e1093" class="indexterm-anchor"></a><a id="d23567e1095" class="indexterm-anchor"></a><a id="d23567e1097" class="indexterm-anchor"></a><a id="d23567e1099" class="indexterm-anchor"></a><a id="d23567e1101" class="indexterm-anchor"></a><a id="d23567e1103" class="indexterm-anchor"></a><a id="d23567e1105" class="indexterm-anchor"></a><a id="d23567e1109" class="indexterm-anchor"></a>These classes hold primitive SQL data types in Oracle native representation. In most cases, these types are not used internally by the drivers and you should use the standard JDBC types instead.
                        </p>
                        <p>Java <code class="codeph">Double</code> and <code class="codeph">Float</code> <code class="codeph">NaN</code> values do not have an equivalent Oracle <code class="codeph">NUMBER</code> representation. For example, for Oracle <code class="codeph">BINARY_FLOAT</code> and <code class="codeph">BINARY_DOUBLE</code> data types, negative zero is coerced to positive zero and all NaNs are coerced to the canonical one. So, a <code class="codeph">NullPointerException</code> is thrown whenever a <code class="codeph">Double.NaN</code> value or a <code class="codeph">Float.NaN</code> value is converted into an Oracle <code class="codeph">NUMBER</code> using the <code class="codeph">oracle.sql.NUMBER</code> class. For instance, the following code throws a <code class="codeph">NullPointerException</code>:
                        </p><pre class="oac_no_warn" dir="ltr">oracle.sql.NUMBER n = new oracle.sql.NUMBER(Double.NaN); 
System.out.println(n.doubleValue());  // throws NullPointerException</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-DB1F687A-CF1C-4B3F-92C0-126DC782EF53__GUID-E3A7683E-90A3-481E-BB42-4628106CD2BD">Overview of Classes oracle.sql.TIMESTAMP, oracle.sql.TIMESTAMPTZ, and oracle.sql.TIMESTAMPLTZ</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>The JDBC drivers support the following date/time data types:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><code class="codeph">TIMESTAMP</code> (<code class="codeph">TIMESTAMP</code>)
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">TIMESTAMP WITH TIME ZONE</code> (<code class="codeph">TIMESTAMPTZ</code>)
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">TIMESTAMP WITH LOCAL TIME ZONE</code> (<code class="codeph">TIMESTAMPLTZ</code>)
                              </p>
                           </li>
                        </ul>
                        <p>The JDBC drivers allow conversions between <code class="codeph">DATE</code> and date/time data types. For example, you can access a <code class="codeph">TIMESTAMP WITH TIME ZONE</code> column as a <code class="codeph">DATE</code> value.
                        </p>
                        <p>The JDBC drivers support the most popular time zone names used in the industry as well as most of the time zone names defined in the JDK. Time zones are specified by using the <code class="codeph">java.util.TimeZone</code> class.
                        </p>
                        <div class="infoboxnote" id="GUID-DB1F687A-CF1C-4B3F-92C0-126DC782EF53__GUID-88138F75-1730-4ED5-9818-0D3029DBAFD3">
                           <p class="notep1">Note:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>Do not use <code class="codeph">TimeZone.getTimeZone</code> to create time zone objects. The Oracle time zone data types support more time zone names than JDK.
                                 </p>
                              </li>
                              <li>
                                 <p>If a result set contains a <code class="codeph">TIMESTAMPLTZ</code> column followed by a <code class="codeph">LONG</code> column, then reading the <code class="codeph">LONG</code> column results in an error.
                                 </p>
                              </li>
                           </ul>
                        </div>
                        <p>The following code shows how the <code class="codeph">TimeZone</code> and <code class="codeph">Calendar</code> objects are created for <code class="codeph">US_PACIFIC</code>, which is a time zone name not defined in JDK:
                        </p><pre class="oac_no_warn" dir="ltr">TimeZone tz = TimeZone.getDefault();
tz.setID("US_PACIFIC");
GregorianCalendar gcal = new GregorianCalendar(tz);
</pre><p>The following Java classes represent the SQL date/time types:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><code class="codeph">oracle.sql.TIMESTAMP</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">oracle.sql.TIMESTAMPTZ</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">oracle.sql.TIMESTAMPLTZ</code></p>
                           </li>
                        </ul>
                        <p>Before accessing <code class="codeph">TIMESTAMP WITH LOCAL TIME ZONE</code> data, call the <code class="codeph">OracleConnection.setSessionTimeZone(String regionName)</code> method to set the session time zone. When this method is called, the JDBC driver sets the session time zone of the connection and saves the session time zone so that any <code class="codeph">TIMESTAMP WITH LOCAL TIME ZONE</code> data accessed through JDBC can be adjusted using the session time zone.
                        </p>
                        <div class="infoboxnote" id="GUID-DB1F687A-CF1C-4B3F-92C0-126DC782EF53__GUID-C7C1A672-4B20-4EC5-A512-44EDC2BAAAEA">
                           <p class="notep1">Note:</p>
                           <p><code class="codeph">TIMESTAMP WITH TIME ZONE</code> and <code class="codeph">TIMESTAMP WITH LOCAL TIME ZONE</code> types can be represented as standard <code class="codeph">java.sql.Timestamp</code> type. The byte representation of <code class="codeph">TIMESTAMP WITH TIME ZONE</code> and <code class="codeph">TIMESTAMP WITH LOCAL TIME ZONE</code> types to <code class="codeph">java.sql.Timestamp</code> is straight forward. This is because the internal format of <code class="codeph">TIMESTAMP WITH TIME ZONE</code> and <code class="codeph">TIMESTAMP WITH LOCAL TIME ZONE</code> data types is GMT, and <code class="codeph">java.sql.Timestamp</code> type objects internally use a milliseconds time value that is the number of milliseconds since EPOCH. However, the <code class="codeph">String</code> representation of these data types requires time zone information that is obtained dynamically from the server and cached on the client side.
                           </p>
                           <p>In earlier versions of JDBC drivers, the cache of time zone was shared across different connections. This used to cause problems sometimes due to incompatibility in various time zones. Starting from Oracle Database 11 Release 2 version of JDBC drivers, the time zone cache is based on the time zone version supplied by the database. This newly designed cache avoids any issues related to version incompatibility of time zones.</p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-DB1F687A-CF1C-4B3F-92C0-126DC782EF53__GUID-85C16990-1115-4B49-B5D7-E31C27FB388E">Overview of Class oracle.sql.OPAQUE</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>The <code class="codeph">oracle.sql.OPAQUE</code> class provides the name and characteristics of the <code class="codeph">OPAQUE</code> type and any attributes. The <code class="codeph">OPAQUE</code> type provides access only to the uninterrupted bytes of the instance.
                        </p>
                        <div class="infoboxnote" id="GUID-DB1F687A-CF1C-4B3F-92C0-126DC782EF53__GUID-E810526C-912F-4B39-B32F-473276E15648">
                           <p class="notep1">Note:</p>
                           <p>Starting from Oracle Database 12<span class="italic">c </span>Release 1 (12.1), the <code class="codeph">oracle.sql.OPAQUE</code> class is deprecated and replaced with the <code class="codeph">oracle.jdbc.OracleOpaque</code> interface, which is a part of the <code class="codeph">oracle.jdbc</code> package. Oracle recommends you to use the methods available in the <code class="codeph">java.sql</code> package, where possible, for standard compatibility and methods available in the <code class="codeph">oracle.jdbc</code> package for Oracle specific extensions. Refer to MoS Note 1364193.1 for more information about the <code class="codeph">oracle.jdbc.OracleOpaque</code> interface.
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>Related Topics</strong></p>
                        <ul>
                           <li><a href="../sqlrf/Data-Types.html#SQLRF-GUID-75209AF6-476D-4C44-A5DC-5FA70D701B78" target="_blank"><span><cite>Oracle Database SQL Language Reference</cite></span></a></li>
                           <li><a href="http://docs.oracle.com/database/122/JAJDB/" target="_blank">JDBC Java API Reference</a></li>
                           <li><a href="LOBs-and-BFiles.html#GUID-401E10DB-16B5-41C9-965E-E5F286F01E4C">Working with LOBs and BFILEs</a></li>
                        </ul>
                     </div>
                  </div>
               </div><a id="JJDBC28140"></a><div class="props_rev_3"><a id="GUID-7AA5D4CC-57C2-4E85-8486-45B52D447B66" name="GUID-7AA5D4CC-57C2-4E85-8486-45B52D447B66"></a><h4 id="JJDBC-GUID-7AA5D4CC-57C2-4E85-8486-45B52D447B66" class="sect4"><span class="enumeration_section">4.3.2 </span>Package oracle.jdbc
                  </h4>
                  <div>
                     <div class="section">
                        <p>The interfaces of the <code class="codeph">oracle.jdbc</code> package define the Oracle extensions to the interfaces in <code class="codeph">java.sql</code>. These extensions provide access to Oracle SQL-format data and other Oracle-specific functionality, including Oracle performance enhancements.
                        </p>
                        <div class="infoboxnotealso" id="GUID-7AA5D4CC-57C2-4E85-8486-45B52D447B66__GUID-487760FD-FA2C-4245-AB6D-019381E17145">
                           <p class="notep1">See Also:</p>
                           <p><span class="q">"<a href="Oracle-extensions.html#GUID-E17FE2C3-9384-432C-9040-09EDF98CB8D6">The oracle.jdbc Package</a>"</span></p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="JJDBC28141"></a><div class="props_rev_3"><a id="GUID-E180187D-07AA-4D64-9946-4D08FBB2E46E" name="GUID-E180187D-07AA-4D64-9946-4D08FBB2E46E"></a><h3 id="JJDBC-GUID-E180187D-07AA-4D64-9946-4D08FBB2E46E" class="sect3"><span class="enumeration_section">4.4 </span>Oracle Character Data Types Support
               </h3>
               <div>
                  <div class="section">
                     <p>Oracle character data types include the SQL CHAR and NCHAR data types. The following sections describe how these data types can be accessed using the <code class="codeph">oracle.sql.*</code> classes:
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="Oracle-extensions.html#GUID-450C64D2-0A26-4E4C-A51E-7B02E0A9D8A8">SQL CHAR Data Types</a></p>
                        </li>
                        <li>
                           <p><a href="Oracle-extensions.html#GUID-9EFED893-8352-4E90-90DA-436D3727F02F">SQL NCHAR Data Types</a></p>
                        </li>
                        <li>
                           <p><a href="Oracle-extensions.html#GUID-CFA6BCB6-9B8A-49E3-BAEF-F68F26A16A88">Class oracle.sql.CHAR</a></p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
               </div><a id="JJDBC28142"></a><div class="props_rev_3"><a id="GUID-450C64D2-0A26-4E4C-A51E-7B02E0A9D8A8" name="GUID-450C64D2-0A26-4E4C-A51E-7B02E0A9D8A8"></a><h4 id="JJDBC-GUID-450C64D2-0A26-4E4C-A51E-7B02E0A9D8A8" class="sect4"><span class="enumeration_section">4.4.1 </span>SQL CHAR Data Types
                  </h4>
                  <div>
                     <div class="section">
                        <p>The SQL CHAR data types include <code class="codeph">CHAR</code>, <code class="codeph">VARCHAR2</code>, and <code class="codeph">CLOB</code>. These data types let you store character data in the database character set encoding scheme. The character set of the database is established when you create the database.
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JJDBC28143"></a><div class="props_rev_3"><a id="GUID-9EFED893-8352-4E90-90DA-436D3727F02F" name="GUID-9EFED893-8352-4E90-90DA-436D3727F02F"></a><h4 id="JJDBC-GUID-9EFED893-8352-4E90-90DA-436D3727F02F" class="sect4"><span class="enumeration_section">4.4.2 </span>SQL NCHAR Data Types
                  </h4>
                  <div>
                     <div class="section">
                        <p>The SQL <code class="codeph">NCHAR</code> data types were created for Globalization Support. The SQL <code class="codeph">NCHAR</code> data types include <code class="codeph">NCHAR</code>, <code class="codeph">NVARCHAR2</code>, and <code class="codeph">NCLOB</code>. These data types enable you to store <a id="d23567e1509" class="indexterm-anchor"></a>Unicode data in the database <code class="codeph">NCHAR</code> character set encoding. The <code class="codeph">NCHAR</code> character set, which never changes, is established when you create the database.
                        </p>
                        <div class="infoboxnote" id="GUID-9EFED893-8352-4E90-90DA-436D3727F02F__GUID-4B4F4832-1342-44D0-B446-760B6936015C">
                           <p class="notep1">Note:</p>
                           <p>Because the <code class="codeph">UnicodeStream</code> class is deprecated in favor of the <code class="codeph">CharacterStream</code> class, the <code class="codeph">setUnicodeStream</code> and <code class="codeph">getUnicodeStream</code> methods are not supported for <code class="codeph">NCHAR</code> data type access. Use the <code class="codeph">setCharacterStream</code> method and the <code class="codeph">getCharacterStream</code> method if you want to use stream access.
                           </p>
                        </div>
                        <p>The usage of SQL <code class="codeph">NCHAR</code> data types is similar to that of the SQL <code class="codeph">CHAR</code> data types. JDBC uses the same classes and methods to access SQL <code class="codeph">NCHAR</code> data types that are used for the corresponding SQL <code class="codeph">CHAR</code> data types. Therefore, there are no separate, corresponding classes defined in the <code class="codeph">oracle.sql</code> package for SQL <code class="codeph">NCHAR</code> data types. Similarly, there is no separate, corresponding constant defined in the <code class="codeph">oracle.jdbc.OracleTypes</code> class for SQL <code class="codeph">NCHAR</code> data types.
                        </p>
                        <div class="infoboxnotealso" id="GUID-9EFED893-8352-4E90-90DA-436D3727F02F__GUID-FC3E0EB4-2ABF-4F1D-B61C-CB538E473CC5">
                           <p class="notep1">See Also:</p>
                           <p><span class="q">"<a href="globalization-support.html#GUID-C29926B3-8B5B-4B05-9193-29B247B52C66">NCHAR_ NVARCHAR2_ NCLOB and the defaultNChar Property</a>"</span></p>
                        </div>
                        <div class="infoboxnote" id="GUID-9EFED893-8352-4E90-90DA-436D3727F02F__GUID-275435FA-0122-4305-9634-F9E1CFC3B0EE">
                           <p class="notep1">Note:</p>
                           <p>The <code class="codeph">setFormOfUse</code> method must be called before the <code class="codeph">registerOutParameter</code> method is called in order to avoid unpredictable results. 
                           </p>
                        </div>
                        <p>The following code shows how to access SQL <code class="codeph">NCHAR</code> data:
                        </p><pre class="oac_no_warn" dir="ltr">// 
// Table TEST has the following columns: 
// - NUMBER 
// - NVARCHAR2 
// - NCHAR 
// 
oracle.jdbc.OraclePreparedStatement pstmt = 
  (oracle.jdbc.OraclePreparedStatement) 
conn.prepareStatement("insert into TEST values(?, ?, ?)");

// 
// oracle.jdbc.OraclePreparedStatement.FORM_NCHAR should be used for all NCHAR, 
// NVARCHAR2 and NCLOB data types.
//

pstmt.setInt(1, 1);                    // NUMBER column
pstmt.setNString(2, myUnicodeString1);  // NVARCHAR2 column
pstmt.setNString(3, myUnicodeString2);  // NCHAR column
pstmt.execute();
</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JJDBC28145"></a><a id="JJDBC28146"></a><a id="JJDBC28144"></a><div class="props_rev_3"><a id="GUID-CFA6BCB6-9B8A-49E3-BAEF-F68F26A16A88" name="GUID-CFA6BCB6-9B8A-49E3-BAEF-F68F26A16A88"></a><h4 id="JJDBC-GUID-CFA6BCB6-9B8A-49E3-BAEF-F68F26A16A88" class="sect4"><span class="enumeration_section">4.4.3 </span>Class oracle.sql.CHAR
                  </h4>
                  <div>
                     <div class="section">
                        <p>The <code class="codeph">oracle.sql.CHAR</code> class is used by Oracle JDBC in handling and converting character data. This class provides the Globalization Support functionality to convert character data. This class has two key attributes: Globalization Support character set and the character data. The Globalization Support character set defines the encoding of the character data. It is a parameter that is always passed when a <code class="codeph">CHAR</code> object is constructed. Without the Globalization Support character set information, the data bytes in the <code class="codeph">CHAR</code> object are meaningless. The <code class="codeph">oracle.sql.CHAR</code> class is used for both SQL <code class="codeph">CHAR</code> and SQL <code class="codeph">NCHAR</code> data types.
                        </p>
                        <div class="infoboxnote" id="GUID-CFA6BCB6-9B8A-49E3-BAEF-F68F26A16A88__GUID-D1723C80-0BAB-492E-8B47-5606EEAB6F6D">
                           <p class="notep1">Note:</p>
                           <p>In versions of Oracle JDBC drivers prior to 10<span class="italic">g</span> Release 1, there were performance advantages to using the <code class="codeph">oracle.SQL.CHAR</code>. Starting from Oracle Database 10<span class="italic">g</span>, there are no longer any such advantages. In fact, optimum performance is achieved using the <code class="codeph">java.lang.String</code>. All Oracle JDBC drivers handle all character data in the Java UCS2 character set. Using the <code class="codeph">oracle.sql.CHAR</code> does not prevent conversions between the database character set and UCS2 character set.
                           </p>
                        </div>
                        <p>The only remaining use of the <code class="codeph">oracle.sql.CHAR</code> class is to handle character data in the form of raw bytes encoded in an Oracle Globalization Support character set. All character data retrieved from Oracle Database should be accessed using the <code class="codeph">java.lang.String</code> class. When processing byte data from another source, you can use an <code class="codeph">oracle.sql.CHAR</code> to convert the bytes to <code class="codeph">java.lang.String</code>.
                        </p>
                        <p>To convert an <code class="codeph">oracle.sql.CHAR</code>, you must provide the data bytes and an <code class="codeph">oracle.sql.CharacterSet</code> instance that represents the Globalization Support character set used to encode the data bytes. 
                        </p>
                        <p>The <code class="codeph">CHAR</code> objects that are Oracle object attributes are returned in the database character set.
                        </p>
                        <p>JDBC application code rarely needs to construct <code class="codeph">CHAR</code> objects directly, because the JDBC driver automatically creates <code class="codeph">CHAR</code> objects, when it is needed to create them on those rare occasions.
                        </p>
                        <p>To construct a <code class="codeph">CHAR</code> object, you must provide character set information to the <code class="codeph">CHAR</code> object by way of an instance of the <code class="codeph">CharacterSet</code> class. Each instance of this class represents one of the Globalization Support character sets that Oracle supports. A <code class="codeph">CharacterSet</code> instance encapsulates methods and attributes of the character set, mainly involving functionality to convert to or from other character sets.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-CFA6BCB6-9B8A-49E3-BAEF-F68F26A16A88__GUID-F8E4C87C-D126-4D14-8223-255512B51A53">Constructing an oracle.sql.CHAR Object</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>Follow these general steps to construct a <code class="codeph">CHAR</code> object:
                        </p>
                        <ol>
                           <li>
                              <p>Create a <code class="codeph">CharacterSet</code> object by calling the <code class="codeph">static</code> <code class="codeph">CharacterSet.make</code> method.
                              </p>
                              <p>This method is a factory for the character set instance. The <code class="codeph">make</code> method takes an integer as input, which corresponds to a character set ID that Oracle supports. For example:
                              </p><pre class="oac_no_warn" dir="ltr">int oracleId = CharacterSet.JA16SJIS_CHARSET; // this is character set ID,
                                              // 832
...
CharacterSet mycharset = CharacterSet.make(oracleId);
</pre><p>Each character set that Oracle supports has a unique, predefined Oracle ID.</p>
                           </li>
                           <li>
                              <p>Construct a <code class="codeph">CHAR</code> object. 
                              </p>
                              <p>Pass a string, or the bytes that represent the string, to the constructor along with the <code class="codeph">CharacterSet</code> object that indicates how to interpret the bytes based on the character set. For example:
                              </p><pre class="oac_no_warn" dir="ltr">String mystring = "teststring";
...
CHAR mychar = new CHAR(teststring, mycharset);
</pre><p>There are multiple constructors for <code class="codeph">CHAR</code>, which can take a <code class="codeph">String</code>, a <code class="codeph">byte</code> array, or an object as input along with the <code class="codeph">CharacterSet</code> object. In the case of a <code class="codeph">String</code>, the string is converted to the character set indicated by the <code class="codeph">CharacterSet</code> object before being placed into the <code class="codeph">CHAR</code> object.
                              </p>
                              <div class="infoboxnote" id="GUID-CFA6BCB6-9B8A-49E3-BAEF-F68F26A16A88__GUID-4036EE0A-DC25-44E4-9C34-7DA4A4941727">
                                 <p class="notep1">Note:</p>
                                 <ul style="list-style-type: disc;">
                                    <li>
                                       <p>The <code class="codeph">CharacterSet</code> object cannot be a null value. 
                                       </p>
                                    </li>
                                    <li>
                                       <p>The <code class="codeph">CharacterSet</code> class is an abstract class, therefore it has no constructor. The only way to create instances is to use the <code class="codeph">make</code> method.
                                       </p>
                                    </li>
                                    <li>
                                       <p>The server recognizes the special value <code class="codeph">CharacterSet.DEFAULT_CHARSET</code> as the database character set. For the client, this value is not meaningful. 
                                       </p>
                                    </li>
                                    <li>
                                       <p>Oracle does not intend or recommend that users extend the <code class="codeph">CharacterSet</code> class.
                                       </p>
                                    </li>
                                 </ul>
                              </div>
                           </li>
                        </ol>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-CFA6BCB6-9B8A-49E3-BAEF-F68F26A16A88__GUID-1D1CB0B8-913F-42F2-86E0-F0B5D433B231">oracle.sql.CHAR Conversion Methods</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>The <code class="codeph">CHAR</code> class provides the following methods for translating character data to strings:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><code class="codeph">getString</code></p>
                              <p>This method converts the sequence of characters represented by the <code class="codeph">CHAR</code> object to a string, returning a Java <code class="codeph">String</code> object. If you enter an invalid <code class="codeph">OracleID</code>, then the character set will not be recognized and the <code class="codeph">getString</code> method will throw a <code class="codeph">SQLException</code> exception.
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">toString</code></p>
                              <p>This method is identical to the <code class="codeph">getString</code> method. But if you enter an invalid <code class="codeph">OracleID</code>, then the character set will not be recognized and the <code class="codeph">toString</code> method will return a hexadecimal representation of the <code class="codeph">CHAR</code> data and will <span class="italic">not</span> throw a <code class="codeph">SQLException</code> exception.
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">getStringWithReplacement</code></p>
                              <p>This method is identical to the <code class="codeph">getString</code> method, except a default replacement character replaces characters that have no unicode representation in the <code class="codeph">CHAR</code> object character set. This default character varies from character set to character set, but is often a question mark (<code class="codeph">?</code>).
                              </p>
                           </li>
                        </ul>
                        <p>The database server and the client, or application running on the client, can use different <a id="d23567e1876" class="indexterm-anchor"></a>character sets. When you use the methods of the <code class="codeph">CHAR</code> class to transfer data between the server and the client, the JDBC drivers must convert the data from the server character set to the client character set or vice versa. To convert the data, the drivers use Globalization Support.
                        </p>
                        <div class="infoboxnotealso" id="GUID-CFA6BCB6-9B8A-49E3-BAEF-F68F26A16A88__GUID-B21327E9-69AC-4A35-9794-3C24C09E738B">
                           <p class="notep1">See Also:</p>
                           <p><a href="globalization-support.html#GUID-CE02B998-DD6A-46FC-8ECF-AD2413F09A97"> Globalization Support </a></p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="JJDBC28148"></a><div class="props_rev_3"><a id="GUID-0DA598C9-4C4E-42D7-B581-B971B8D87A96" name="GUID-0DA598C9-4C4E-42D7-B581-B971B8D87A96"></a><h3 id="JJDBC-GUID-0DA598C9-4C4E-42D7-B581-B971B8D87A96" class="sect3"><span class="enumeration_section">4.5 </span>Additional Oracle Type Extensions
               </h3>
               <div>
                  <div class="section">
                     <p>Oracle JDBC drivers support the Oracle-specific <code class="codeph">BFILE</code> and <code class="codeph">ROWID</code> data types and <code class="codeph">REF</code> <code class="codeph">CURSOR</code> types, which are not part of the standard JDBC specification. This section describes the <code class="codeph">ROWID</code> and <code class="codeph">REF CURSOR</code> type extensions. The <code class="codeph">ROWID</code> is supported as a Java string, and <code class="codeph">REF</code> <code class="codeph">CURSOR</code> types are supported as JDBC result sets.
                     </p>
                     <p>This section covers the following topics:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="Oracle-extensions.html#GUID-8069D705-A031-469D-855F-53525798F64F">Oracle ROWID Type</a></p>
                        </li>
                        <li>
                           <p><a href="Oracle-extensions.html#GUID-BD58E992-5CAA-4F77-93B5-DD75A90E6555">Oracle REF CURSOR Type Category</a></p>
                        </li>
                        <li>
                           <p><a href="Oracle-extensions.html#GUID-FC9510C6-8FF2-41A7-864A-890B85A316BC">Oracle BINARY_FLOAT and BINARY_DOUBLE Types</a></p>
                        </li>
                        <li>
                           <p><a href="Oracle-extensions.html#GUID-E5105E30-7F12-4069-8A68-F12BF1CF7671">Oracle SYS.ANYTYPE and SYS.ANYDATA Types</a></p>
                        </li>
                        <li>
                           <p><a href="Oracle-extensions.html#GUID-E17FE2C3-9384-432C-9040-09EDF98CB8D6">The oracle.jdbc Package</a></p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
               </div><a id="JJDBC28150"></a><a id="JJDBC28149"></a><div class="props_rev_3"><a id="GUID-8069D705-A031-469D-855F-53525798F64F" name="GUID-8069D705-A031-469D-855F-53525798F64F"></a><h4 id="JJDBC-GUID-8069D705-A031-469D-855F-53525798F64F" class="sect4"><span class="enumeration_section">4.5.1 </span>Oracle ROWID Type
                  </h4>
                  <div>
                     <div class="section">
                        <p>A <a id="d23567e1995" class="indexterm-anchor"></a>ROWID is an identification tag unique for each row of an Oracle Database table. The ROWID can be thought of as a virtual column, containing the ID for each row.
                        </p>
                        <p>The <code class="codeph">oracle.sql.ROWID</code> class is supplied as a container for <code class="codeph">ROWID</code> SQL data type.
                        </p>
                        <p>ROWIDs provide functionality similar to the <code class="codeph">getCursorName</code> method specified in the <code class="codeph">java.sql.ResultSet</code> interface and the <code class="codeph">setCursorName</code> method specified in the <code class="codeph">java.sql.Statement</code> interface.
                        </p>
                        <p>If you include the ROWID pseudo-column in a query, then you can retrieve the ROWIDs with the result set <code class="codeph">getString</code> method. You can also bind a ROWID to a <code class="codeph">PreparedStatement</code> parameter with the <code class="codeph">setString</code> method. This enables in-place updating, as in the example that follows.
                        </p>
                        <div class="infoboxnote" id="GUID-8069D705-A031-469D-855F-53525798F64F__GUID-FE4169A6-D108-4287-B606-77B33F356385">
                           <p class="notep1">Note:</p>
                           <p>Use the <code class="codeph">oracle.sql.ROWID</code> class, only when you are using J2SE 5.0. For JSE 6, you should use the standard <code class="codeph">java.sql.RowId</code> interface instead.
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-8069D705-A031-469D-855F-53525798F64F__GUID-D56D9FA4-DBE7-4C63-8D26-FA8607B8136F">Example</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>The following example shows how to access and manipulate ROWID data:</p>
                        <div class="infoboxnote" id="GUID-8069D705-A031-469D-855F-53525798F64F__GUID-0544D8EC-84DF-43CC-ACFF-866BFE55B009">
                           <p class="notep1">Note:</p>
                           <p>The following example works only with JSE 6.</p>
                        </div><pre class="oac_no_warn" dir="ltr">Statement stmt = conn.createStatement(); 

// Query the employee names with "FOR UPDATE" to lock the rows. 
// Select the ROWID to identify the rows to be updated. 

ResultSet rset =  
   stmt.executeQuery ("SELECT first_name, rowid FROM employees FOR UPDATE"); 

// Prepare a statement to update the first_name column at a given ROWID 

PreparedStatement pstmt = 
   conn.prepareStatement ("UPDATE employees SET first_name = ? WHERE rowid = ?"); 

// Loop through the results of the query 
while (rset.next ()) 
{ 
    String ename = rset.getString (1); 
 RowId rowid = rset.getROWID(2); // Get the ROWID as a String 
    pstmt.setString (1, ename.toLowerCase ()); 
    pstmt.setROWID (2, rowid); // Pass ROWID to the update statement 
    pstmt.executeUpdate ();     // Do the update 
} 
</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JJDBC28152"></a><a id="JJDBC28151"></a><div class="props_rev_3"><a id="GUID-BD58E992-5CAA-4F77-93B5-DD75A90E6555" name="GUID-BD58E992-5CAA-4F77-93B5-DD75A90E6555"></a><h4 id="JJDBC-GUID-BD58E992-5CAA-4F77-93B5-DD75A90E6555" class="sect4"><span class="enumeration_section">4.5.2 </span>Oracle REF CURSOR Type Category
                  </h4>
                  <div>
                     <div class="section">
                        <p>A cursor variable holds the memory location of a query work area, rather than the contents of the area. Declaring a cursor variable creates a pointer. In SQL, a pointer has the data type <code class="codeph">REF</code> <span class="italic"><code class="codeph">x</code></span>, where <code class="codeph">REF</code> is short for <code class="codeph">REFERENCE</code> and <span class="italic"><code class="codeph">x</code></span> represents the entity being referenced. A <code class="codeph">REF CURSOR</code>, then, identifies a reference to a cursor variable. Because many cursor variables might exist to point to many work areas, <code class="codeph">REF</code> <code class="codeph">CURSOR</code> can be thought of as a category or data type specifier that identifies many different types of cursor variables. Starting from Oracle Database Release 18 <span class="italic">c</span>, JDBC drivers support <code class="codeph">REF CURSOR</code> as IN bind variables.
                        </p>
                        <div class="infoboxnote" id="GUID-BD58E992-5CAA-4F77-93B5-DD75A90E6555__GUID-293F1483-0528-42D7-84C5-2926C5A24296">
                           <p class="notep1">Note:</p>
                           <p><code class="codeph">REF CURSOR</code> instances are not scrollable.
                           </p>
                        </div>
                        <p>Perform the following steps to create a cursor variable:</p>
                        <ol>
                           <li>
                              <p>Identify a type that belongs to the <code class="codeph">REF</code> <code class="codeph">CURSOR</code> category. For example: 
                              </p><pre class="pre codeblock"><code>DECLARE TYPE DeptCursorTyp IS REF CURSOR
</code></pre></li>
                           <li>
                              <p>Then, create the cursor variable by declaring it to be of the type <code class="codeph">DeptCursorTyp</code>: 
                              </p><pre class="pre codeblock"><code>dept_cv DeptCursorTyp  - - declare cursor variable
...
</code></pre><p><code class="codeph">REF</code> <code class="codeph">CURSOR</code>, then, is a category of data types, rather than a particular data type.
                              </p>
                           </li>
                        </ol>
                        <p>Stored procedures can accept or return cursor variables of the <a id="d23567e2148" class="indexterm-anchor"></a><code class="codeph">REF</code> <code class="codeph">CURSOR</code> category. This output is equivalent to a database cursor or a JDBC result set. A <code class="codeph">REF CURSOR</code> essentially encapsulates the results of a query.
                        </p>
                        <p>In JDBC, a <code class="codeph">REF CURSOR</code> can be accessed as follows: 
                        </p>
                        <ol>
                           <li>
                              <p>Use a JDBC callable statement or a prepared statement to call a stored procedure.</p>
                           </li>
                           <li>
                              <p>The stored procedure accepts or returns a <code class="codeph">REF CURSOR</code>.
                              </p>
                           </li>
                           <li>
                              <p>The Java application casts the callable statement or prepared statement to an Oracle callable statement or Oracle prepared statement.</p>
                           </li>
                           <li>
                              <p>The Java application uses the <code class="codeph">setCursor</code> method of the <code class="codeph">OraclePreparedStatement</code> interface or the <code class="codeph">getCursor</code> method of the <code class="codeph">OracleCallableStatement</code> interface to materialize the <code class="codeph">REF CURSOR</code> as a JDBC <code class="codeph">ResultSet</code> object.
                              </p>
                           </li>
                           <li>
                              <p>The result set is processed as requested.</p>
                              <div class="infoboxnote" id="GUID-BD58E992-5CAA-4F77-93B5-DD75A90E6555__GUID-2FF15DBE-344A-4414-9618-D884FA8B3CD8">
                                 <p class="notep1">Note:</p>
                                 <ul style="list-style-type: disc;">
                                    <li>
                                       <p>The cursor associated with a <code class="codeph">REF CURSOR</code> is closed whenever the statement object that produced the <code class="codeph">REF CURSOR</code> is closed.
                                       </p>
                                    </li>
                                    <li>
                                       <p>Unlike in past releases, the cursor associated with a <code class="codeph">REF CURSOR</code> is <span class="italic">not</span> closed when the result set object in which the <code class="codeph">REF CURSOR</code> was materialized is closed.
                                       </p>
                                    </li>
                                 </ul>
                              </div>
                           </li>
                        </ol>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-BD58E992-5CAA-4F77-93B5-DD75A90E6555__GUID-F8DFA999-3799-4BB6-9086-B08C6D2A3F5F">Example</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>This example shows how to access <code class="codeph">REF CURSOR</code> data.
                        </p><pre class="pre codeblock"><code>    ...
    // Prepare a PL/SQL call
    CallableStatement cstmt =
      conn.prepareCall ("DECLARE  rc sys_refcursor; curid NUMBER;BEGIN open rc FOR SELECT empno FROM emp order by empno; ? := rc;  END;"); 

    cstmt.registerOutParameter (1, OracleTypes.CURSOR);
    cstmt.execute ();
    ResultSet rset = (ResultSet)cstmt.getObject (1);

    if (rset.next ()) {
      show (rset.getString ("empno"));
    }
    
    CallableStatement cstmt2 =
      conn.prepareCall ("DECLARE  rc sys_refcursor; v1 NUMBER; BEGIN rc := ?; fetch rc INTO v1; ? := v1; END;");  
    ((OracleCallableStatement)call2).setCursor(1, rset);
    cstmt2.registerOutParameter (2, OracleTypes.INTEGER);
    
    cstmt2.execute();
    
    int empno = cstmt2.getInt(2);
    
    show("Fetch in PL/SQL empno=" + empno);
    
    // Dump the cursor
    while (rset.next ())
      show (rset.getString ("empno")); 

    // Close all the resources
    rset.close();
    cstmt.close();
    cstmt2.close();
  ...</code></pre><p>In the preceding example:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Two <code class="codeph">CallableStatement</code> objects <code class="codeph">cstmt1</code> and <code class="codeph">cstmt2</code> are created using the <code class="codeph">prepareCall</code> method of the <code class="codeph">Connection</code> class. 
                              </p>
                           </li>
                           <li>
                              <p>The <code class="codeph">cstmt2</code> callable statement uses <code class="codeph">REF CURSOR</code> as input parameter.
                              </p>
                           </li>
                           <li>
                              <p>The callable statements implement PL/SQL procedure that returns a <code class="codeph">REF CURSOR</code>.
                              </p>
                           </li>
                           <li>
                              <p>As always, the output parameter of the callable statement must be registered to define its type. Use the type code <code class="codeph">OracleTypes.CURSOR</code> for a <code class="codeph">REF CURSOR</code>.
                              </p>
                           </li>
                           <li>
                              <p>The callable statements are run, returning the <code class="codeph">REF CURSOR</code> or sending the <code class="codeph">REF CURSOR</code> as input bind.
                              </p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JJDBC28153"></a><div class="props_rev_3"><a id="GUID-FC9510C6-8FF2-41A7-864A-890B85A316BC" name="GUID-FC9510C6-8FF2-41A7-864A-890B85A316BC"></a><h4 id="JJDBC-GUID-FC9510C6-8FF2-41A7-864A-890B85A316BC" class="sect4"><span class="enumeration_section">4.5.3 </span>Oracle BINARY_FLOAT and BINARY_DOUBLE Types
                  </h4>
                  <div>
                     <div class="section">
                        <p>The Oracle <code class="codeph">BINARY_FLOAT</code> and <code class="codeph">BINARY_DOUBLE</code> types are used to store IEEE 574 float and double data. These correspond to the Java <code class="codeph">float</code> and <code class="codeph">double</code> scalar types with the exception of negative zero and <code class="codeph">NaN</code>.
                        </p>
                        <div class="infoboxnotealso" id="GUID-FC9510C6-8FF2-41A7-864A-890B85A316BC__GUID-387634EF-70D5-42B1-ACE9-50441978700B">
                           <p class="notep1">See Also:</p>
                           <p><a href="../sqlrf/Data-Types.html#SQLRF00209" target="_blank"><span class="italic">Oracle Database SQL Language Reference</span></a></p>
                        </div>
                        <p>If you include a <code class="codeph">BINARY_DOUBLE</code> column in a query, then the data is retrieved from the database in the binary format. Also, the <code class="codeph">getDouble</code> method will return the data in the binary format. In contrast, for a <code class="codeph">NUMBER</code> data type column, the number bits are returned and converted to the Java <code class="codeph">double</code> data type.
                        </p>
                        <div class="infoboxnote" id="GUID-FC9510C6-8FF2-41A7-864A-890B85A316BC__GUID-FAE9EFB2-569E-4111-A64C-E350771B8114">
                           <p class="notep1">Note:</p>
                           <p>The Oracle representation for the SQL <code class="codeph">FLOAT</code>, <code class="codeph">DOUBLE PRECISION</code>, and <code class="codeph">REAL</code> data types use the Oracle <code class="codeph">NUMBER</code> representation. The <code class="codeph">BINARY_FLOAT</code> and <code class="codeph">BINARY_DOUBLE</code> data types can be regarded as proprietary types.
                           </p>
                        </div>
                        <p>A call to the JDBC standard <code class="codeph">setDouble(int, double)</code> method of the <code class="codeph">PreparedStatement</code> interface converts the Java <code class="codeph">double</code> argument to Oracle <code class="codeph">NUMBER</code> style bits and send them to the database. In contrast, the <code class="codeph">setBinaryDouble(int, double)</code> method of the <code class="codeph">oracle.jdbc.OraclePreparedStatement</code> interface converts the data to the internal binary bits and sends them to the database.
                        </p>
                        <p>You must ensure that the data format used matches the type of the target parameter of the <code class="codeph">PreparedStatement</code> interface. This will result in correct data and least use of CPU. If you use <code class="codeph">setBinaryDouble</code> for a <code class="codeph">NUMBER</code> parameter, then the binary bits are sent to the server and converted to <code class="codeph">NUMBER</code> format. The data will be correct, but server CPU load will be increased. If you use <code class="codeph">setDouble</code> for a <code class="codeph">BINARY_DOUBLE</code> parameter, then the data will first be converted to <code class="codeph">NUMBER</code> bits on the client and sent to the server, where it will be converted back to binary format. This will increase the CPU load on both client and server and can result in data corruption as well.
                        </p>
                        <p>The <code class="codeph">SetFloatAndDoubleUseBinary</code> connection property when set to <code class="codeph">true</code> causes the JDBC standard APIs, <code class="codeph">setFloat(int,</code> <code class="codeph">float)</code>, <code class="codeph">setDouble(int,</code> <code class="codeph">double)</code>, and all the variations, to send internal binary bits instead of <code class="codeph">NUBMER</code> bits.
                        </p>
                        <div class="infoboxnote" id="GUID-FC9510C6-8FF2-41A7-864A-890B85A316BC__GUID-9A59B83C-A3FC-4527-BAB5-F5A0181E3772">
                           <p class="notep1">Note:</p>
                           <p>Although this section largely discusses <code class="codeph">BINARY_DOUBLE</code>, the same is true for <code class="codeph">BINARY_FLOAT</code> as well.
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JJDBC28155"></a><a id="JJDBC28156"></a><a id="JJDBC28157"></a><a id="JJDBC28158"></a><a id="JJDBC28159"></a><a id="JJDBC28160"></a><a id="JJDBC28154"></a><div class="props_rev_3"><a id="GUID-E5105E30-7F12-4069-8A68-F12BF1CF7671" name="GUID-E5105E30-7F12-4069-8A68-F12BF1CF7671"></a><h4 id="JJDBC-GUID-E5105E30-7F12-4069-8A68-F12BF1CF7671" class="sect4"><span class="enumeration_section">4.5.4 </span>Oracle SYS.ANYTYPE and SYS.ANYDATA Types
                  </h4>
                  <div>
                     <div class="section">
                        <p>Oracle Database 12<span class="italic">c </span>Release 1 (12.1) provides a Java interface to access the <a id="d23567e2485" class="indexterm-anchor"></a><a id="d23567e2487" class="indexterm-anchor"></a><code class="codeph">SYS.ANYTYPE</code> and <a id="d23567e2492" class="indexterm-anchor"></a><a id="d23567e2494" class="indexterm-anchor"></a><code class="codeph">SYS.ANYDATA</code> Oracle types.
                        </p>
                        <div class="infoboxnotealso" id="GUID-E5105E30-7F12-4069-8A68-F12BF1CF7671__GUID-866CA3EB-E6E9-4BC2-AA54-D7E55E9FD618">
                           <p class="notep1">See Also:</p>
                           <p>For information about these Oracle types, refer <a href="../arpls/ANYTYPE-TYPE.html#ARPLS-GUID-4E6D7301-47C5-4495-A074-BAE102960751" target="_blank"><span><cite>Oracle Database PL/SQL Packages and Types Reference</cite></span></a></p>
                        </div>
                        <p>An instance of the <code class="codeph">SYS.ANYTYPE</code> type contains a type description of any SQL type, persistent or transient, named or unnamed, including object types and collection types. You can use the <code class="codeph">oracle.sql.TypeDescriptor</code> class to access the <code class="codeph">SYS.ANYTYPE</code> type. An <code class="codeph">ANYTYPE</code> instance can be retrieved from a PL/SQL procedure or a SQL <code class="codeph">SELECT</code> statement where <code class="codeph">SYS.ANYTYPE</code> is used as a column type. To retrieve an <code class="codeph">ANYTYPE</code> instance from the database, use the <code class="codeph">getObject</code> method. This method returns an instance of the <code class="codeph">TypeDescriptor</code>.
                        </p>
                        <p>The retrieved <code class="codeph">ANYTYPE</code> instance could be any of the following:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Transient object type</p>
                           </li>
                           <li>
                              <p>Transient predefined type</p>
                           </li>
                           <li>
                              <p>Persistent object type</p>
                           </li>
                           <li>
                              <p>Persistent predefined type</p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-E5105E30-7F12-4069-8A68-F12BF1CF7671__GUID-E12B1896-516B-433F-B2FA-E79AE98225D9">
                        <p class="titleinexample">Example 4-1 Accessing SYS.ANYTYPE Type</p>
                        <p>The following code snippet illustrates how to retrieve an instance of <code class="codeph">ANYTYPE</code> from the database:
                        </p><pre class="oac_no_warn" dir="ltr">...
ResultSet rs = stmt.executeQuery("select anytype_column from my_table");
TypeDescriptor td = (TypeDescriptor)rs.getObject(1);
short typeCode = td.getInternalTypeCode();
if(typeCode == TypeDescriptor.TYPECODE_OBJECT)
{
  // check if it's a transient type
  if(td.isTransientType())
  {
    AttributeDescriptor[] attributes = ((StructDescriptor)td).getAttributesDescriptor();
    for(int i=0; i&lt;attributes.length; i++)
      System.out.println(attributes[i].getAttributeName());
  }
  else
  {    System.out.println(td.getTypeName());  }}
...</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-E5105E30-7F12-4069-8A68-F12BF1CF7671__GUID-DBF7C48C-03BB-45B6-AE21-E724BAACCB4C">
                        <p class="titleinexample">Example 4-2 Creating a Transient Object Type Through PL/SQL and Retrieving Through JDBC</p>
                        <p>This example provides a code snippet illustrating how to retrieve a transient object type through JDBC.</p><pre class="oac_no_warn" dir="ltr">...
OracleCallableStatement cstmt = (OracleCallableStatement)conn.prepareCall
  ("BEGIN ? := transient_obj_type (); END;");
cstmt.registerOutParameter(1,OracleTypes.OPAQUE,"SYS.ANYTYPE");
cstmt.execute();
TypeDescriptor obj = (TypeDescriptor)cstmt.getObject(1);
if(!obj.isTransient())
  System.out.println("This must be a JDBC bug");
cstmt.close();
return obj;
...
</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-E5105E30-7F12-4069-8A68-F12BF1CF7671__GUID-A7BDB53F-4960-4C3D-AD6F-FFFF116EEF2A">
                        <p class="titleinexample">Example 4-3 Calling a PL/SQL Stored Procedure That Takes an ANYTPE as IN Parameter</p>
                        <p>The following code snippet illustrates how to call a PL/SQL stored procedure that takes an <code class="codeph">ANYTYPE</code> as <code class="codeph">IN</code> parameter:
                        </p><pre class="oac_no_warn" dir="ltr">...
CallableStatement cstmt = conn.prepareCall("BEGIN ? := dumpanytype(?); END;");
cstmt.registerOutParameter(1,OracleTypes.VARCHAR);
// obj is the instance of TypeDescriptor that you have retrieved
cstmt.setObject(2,obj);
cstmt.execute();
String str = (String)cstmt.getObject(1);
...
</pre></div>
                     <!-- class="example" -->
                     <div class="section">
                        <p>The <code class="codeph">oracle.sql.ANYDATA</code> class enables you to access <code class="codeph">SYS.ANYDATA</code> instances from the database. An instance of this class can be obtained from any valid instance of <code class="codeph">oracle.sql.Datum</code> class. The <code class="codeph">convertDatum</code> factory method takes an instance of <code class="codeph">Datum</code> and returns an instance of <code class="codeph">ANYDATA</code>. The syntax for this factory method is as follows:
                        </p><pre class="oac_no_warn" dir="ltr">public static ANYDATA convertDatum(Datum datum) throws SQLException
</pre><p>The following is sample code for creating an instance of <code class="codeph">oracle.sql.ANYDATA</code>:
                        </p><pre class="oac_no_warn" dir="ltr">// struct is a valid instance of oracle.sql.STRUCT that either comes from the 
// database or has been constructed in Java.
ANYDATA myAnyData = ANYDATA.convertDatum(struct);
</pre></div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-E5105E30-7F12-4069-8A68-F12BF1CF7671__GUID-BBEEAF43-08A9-4E93-A405-5B55F412EB88">
                        <p class="titleinexample">Example 4-4 Accessing an Instance of ANYDATA from the Database</p><pre class="oac_no_warn" dir="ltr">...
// anydata_table has been created as:
// CREATE TABLE anydata_tab (data SYS.ANYDATA)
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery("select data from my_anydata_tab");
while(rs.next())
{
  ANYDATA anydata = (ANYDATA)rs.getObject(1);
  if(!anydata.isNull())
  {
    TypeDescriptor td = anydata.getTypeDescriptor();
    if(td.getTypeCode() == OracleType.TYPECODE_OBJECT)
      STRUCT struct = (STRUCT)anydata.accessDatum();
  }
}
...
</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-E5105E30-7F12-4069-8A68-F12BF1CF7671__GUID-C53803E1-F05D-469D-BB9C-70100C0C08DD">
                        <p class="titleinexample">Example 4-5 Inserting an Object as ANYDATA in a Database Table</p>
                        <p>Consider the following table and object type definition:</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE anydata_tab ( id NUMBER, data SYS.ANYDATA)

CREATE OR REPLACE TYPE employee AS OBJECT ( employee_id NUMBER, first_name VARCHAR2(10) )
</pre><p>You can create an instance of the <code class="codeph">EMPLOYEE</code> SQL object type and to insert it into <code class="codeph">anydata_tab</code>le in the following way:
                        </p><pre class="oac_no_warn" dir="ltr">...
PreparedStatement pstmt = conn.prepareStatement("insert into anydata_table values (?,?)");
Struct myEmployeeStr = conn.createStruct("EMPLOYEE", new Object[]{1120, "Papageno"});
ANYDATA anyda = ANYDATA.convertDatum(myEmployeeStr);
pstmt.setInt(1,123);
pstmt.setObject(2,anyda);
pstmt.executeUpdate();
...
</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-E5105E30-7F12-4069-8A68-F12BF1CF7671__GUID-B599ACA6-FE69-4AFE-AC8B-30D1302F4068">
                        <p class="titleinexample">Example 4-6 Selecting an ANYDATA Column from a Database Table</p><pre class="oac_no_warn" dir="ltr">...
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery("select data from anydata_table");
while(rs.next())
{
  ANYDATA obj = (ANYDATA)rs.getObject(1);
  TypeDescriptor td = obj.getTypeDescriptor();
}
rs.close();
stmt.close();
...
</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="JJDBC28162"></a><a id="JJDBC28161"></a><div class="props_rev_3"><a id="GUID-E17FE2C3-9384-432C-9040-09EDF98CB8D6" name="GUID-E17FE2C3-9384-432C-9040-09EDF98CB8D6"></a><h4 id="JJDBC-GUID-E17FE2C3-9384-432C-9040-09EDF98CB8D6" class="sect4"><span class="enumeration_section">4.5.5 </span>The oracle.jdbc Package
                  </h4>
                  <div>
                     <div class="section">
                        <p>The interfaces of the <code class="codeph">oracle.jdbc</code> package define the Oracle extensions to the interfaces in <code class="codeph">java.sql</code>. These extensions provide access to SQL-format data as described in this chapter. They also provide access to other Oracle-specific functionality, including Oracle performance enhancements.
                        </p>
                        <p>For the <code class="codeph">oracle.jdbc</code> package, <a href="Oracle-extensions.html#GUID-E17FE2C3-9384-432C-9040-09EDF98CB8D6__g1076271" title="table">Table 4-1</a> lists key interfaces and classes used for connections, statements, and result sets.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="tblformal" id="GUID-E17FE2C3-9384-432C-9040-09EDF98CB8D6__g1076271">
                        <p class="titleintable">Table 4-1 Key Interfaces and Classes of the oracle.jdbc Package </p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="Key Interfaces and Classes of the oracle.jdbc Package " summary="table" width="100%" frame="hsides" border="1" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="40%" id="d23567e2696">Name</th>
                                 <th align="left" valign="bottom" width="13%" id="d23567e2699">Interface or Class</th>
                                 <th align="left" valign="bottom" width="47%" id="d23567e2702">Key Functionality</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="40%" id="d23567e2707" headers="d23567e2696 ">
                                    <p><code class="codeph">OracleDriver</code></p>
                                 </td>
                                 <td align="left" valign="top" width="13%" headers="d23567e2707 d23567e2699 ">
                                    <p>Class</p>
                                 </td>
                                 <td align="left" valign="top" width="47%" headers="d23567e2707 d23567e2702 ">
                                    <p>Implements <code class="codeph">java.sql.Driver</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="40%" id="d23567e2720" headers="d23567e2696 ">
                                    <p><code class="codeph">OracleConnection</code></p>
                                 </td>
                                 <td align="left" valign="top" width="13%" headers="d23567e2720 d23567e2699 ">
                                    <p>Interface</p>
                                 </td>
                                 <td align="left" valign="top" width="47%" headers="d23567e2720 d23567e2702 ">
                                    <p>Provides methods to start and stop an Oracle Database instance and to return Oracle statement objects and methods to set Oracle performance extensions for any statement run in the current connection.</p>
                                    <p>Implements <code class="codeph">java.sql.Connection.</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="40%" id="d23567e2735" headers="d23567e2696 ">
                                    <p><code class="codeph">OracleStatement</code></p>
                                 </td>
                                 <td align="left" valign="top" width="13%" headers="d23567e2735 d23567e2699 ">
                                    <p>Interface</p>
                                 </td>
                                 <td align="left" valign="top" width="47%" headers="d23567e2735 d23567e2702 ">
                                    <p>Provides methods to set Oracle performance extensions for individual statement.</p>
                                    <p>Is a supertype of <code class="codeph">OraclePreparedStatement</code> and <code class="codeph">OracleCallableStatement</code>.
                                    </p>
                                    <p>Implements <code class="codeph">java.sql.Statement.</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="40%" id="d23567e2758" headers="d23567e2696 ">
                                    <p><code class="codeph">OraclePreparedStatement</code></p>
                                 </td>
                                 <td align="left" valign="top" width="13%" headers="d23567e2758 d23567e2699 ">
                                    <p>Interface</p>
                                 </td>
                                 <td align="left" valign="top" width="47%" headers="d23567e2758 d23567e2702 ">
                                    <p>Provides <code class="codeph">set</code><span class="italic"><code class="codeph">XXX</code></span> methods to bind <code class="codeph">oracle.sql.*</code> types into a prepared statement.
                                    </p>
                                    <p>Provides <code class="codeph">getMetaData</code> method to get the metadata from the prepared statements without executing the SELECT statements.
                                    </p>
                                    <p>Implements <code class="codeph">java.sql.PreparedStatement.</code></p>
                                    <p>Extends <code class="codeph">OracleStatement.</code></p>
                                    <p>Is a supertype of <code class="codeph">OracleCallableStatement</code>.
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="40%" id="d23567e2796" headers="d23567e2696 ">
                                    <p><code class="codeph">OracleCallableStatement</code></p>
                                 </td>
                                 <td align="left" valign="top" width="13%" headers="d23567e2796 d23567e2699 ">
                                    <p>Interface</p>
                                 </td>
                                 <td align="left" valign="top" width="47%" headers="d23567e2796 d23567e2702 ">
                                    <p>Provides <code class="codeph">get</code><span class="italic"><code class="codeph">XXX</code></span> methods to retrieve data in <code class="codeph">oracle.sql</code> format and <code class="codeph">set</code><span class="italic"><code class="codeph">XXX</code></span> methods to bind <code class="codeph">oracle.sql.*</code> types into a callable statement.
                                    </p>
                                    <p>Implements <code class="codeph">java.sql.CallableStatement.</code></p>
                                    <p>Extends <code class="codeph">OraclePreparedStatement.</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="40%" id="d23567e2833" headers="d23567e2696 ">
                                    <p><code class="codeph">OracleResultSet</code></p>
                                 </td>
                                 <td align="left" valign="top" width="13%" headers="d23567e2833 d23567e2699 ">
                                    <p>Interface</p>
                                 </td>
                                 <td align="left" valign="top" width="47%" headers="d23567e2833 d23567e2702 ">
                                    <p>Provides <code class="codeph">get</code><span class="italic"><code class="codeph">XXX</code></span> methods to retrieve data in <code class="codeph">oracle.sql</code> format.
                                    </p>
                                    <p>Implements <code class="codeph">java.sql.ResultSet</code>.
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="40%" id="d23567e2858" headers="d23567e2696 ">
                                    <p><code class="codeph">OracleResultSetMetaData</code></p>
                                 </td>
                                 <td align="left" valign="top" width="13%" headers="d23567e2858 d23567e2699 ">
                                    <p>Interface</p>
                                 </td>
                                 <td align="left" valign="top" width="47%" headers="d23567e2858 d23567e2702 ">
                                    <p>Provides methods to get metadata information about Oracle result sets, such as column names and data types.</p>
                                    <p>Implements <code class="codeph">java.sql.ResultSetMetaData</code>.
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="40%" id="d23567e2874" headers="d23567e2696 ">
                                    <p><code class="codeph">OracleDatabaseMetaData</code></p>
                                 </td>
                                 <td align="left" valign="top" width="13%" headers="d23567e2874 d23567e2699 ">
                                    <p>Class</p>
                                 </td>
                                 <td align="left" valign="top" width="47%" headers="d23567e2874 d23567e2702 ">
                                    <p>Provides methods to get metadata information about the database, such as database product name and version, table information, and default transaction isolation level.</p>
                                    <p>Implements <code class="codeph">java.sql.DatabaseMetaData</code>).
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="40%" id="d23567e2890" headers="d23567e2696 ">
                                    <p><code class="codeph">OracleTypes</code></p>
                                 </td>
                                 <td align="left" valign="top" width="13%" headers="d23567e2890 d23567e2699 ">
                                    <p>Class</p>
                                 </td>
                                 <td align="left" valign="top" width="47%" headers="d23567e2890 d23567e2702 ">
                                    <p>Defines integer constants used to identify SQL types.</p>
                                    <p>For standard types, it uses the same values as the standard <code class="codeph">java.sql.Types</code> class. In addition, it adds constants for Oracle extended types.
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="40%" id="d23567e2906" headers="d23567e2696 ">
                                    <p><code class="codeph">OracleArray</code></p>
                                 </td>
                                 <td align="left" valign="top" width="13%" headers="d23567e2906 d23567e2699 ">
                                    <p>Interface</p>
                                 </td>
                                 <td align="left" valign="top" width="47%" headers="d23567e2906 d23567e2702 ">
                                    <p>Includes functionality to retrieve the array as a whole, retrieve a subset of the array elements, and retrieve the SQL base type name of the array elements.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="40%" id="d23567e2917" headers="d23567e2696 ">
                                    <p><code class="codeph">OracleStruct</code></p>
                                 </td>
                                 <td align="left" valign="top" width="13%" headers="d23567e2917 d23567e2699 ">
                                    <p>Interface</p>
                                 </td>
                                 <td align="left" valign="top" width="47%" headers="d23567e2917 d23567e2702 ">&nbsp;</td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="40%" id="d23567e2927" headers="d23567e2696 ">
                                    <p><code class="codeph">OracleClob</code></p>
                                 </td>
                                 <td align="left" valign="top" width="13%" headers="d23567e2927 d23567e2699 ">
                                    <p>Interface</p>
                                 </td>
                                 <td align="left" valign="top" width="47%" headers="d23567e2927 d23567e2702 ">&nbsp;</td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="40%" id="d23567e2936" headers="d23567e2696 ">
                                    <p><code class="codeph">OracleBlob</code></p>
                                 </td>
                                 <td align="left" valign="top" width="13%" headers="d23567e2936 d23567e2699 ">
                                    <p>Interface</p>
                                 </td>
                                 <td align="left" valign="top" width="47%" headers="d23567e2936 d23567e2702 ">&nbsp;</td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="40%" id="d23567e2945" headers="d23567e2696 ">
                                    <p><code class="codeph">OracleRef</code></p>
                                 </td>
                                 <td align="left" valign="top" width="13%" headers="d23567e2945 d23567e2699 ">
                                    <p>Interface</p>
                                 </td>
                                 <td align="left" valign="top" width="47%" headers="d23567e2945 d23567e2702 ">&nbsp;</td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="40%" id="d23567e2954" headers="d23567e2696 ">
                                    <p><code class="codeph">OracleOpaque</code></p>
                                 </td>
                                 <td align="left" valign="top" width="13%" headers="d23567e2954 d23567e2699 ">
                                    <p>Interface</p>
                                 </td>
                                 <td align="left" valign="top" width="47%" headers="d23567e2954 d23567e2702 ">&nbsp;</td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <div class="section">
                        <p>This section covers the following topics:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><a href="Oracle-extensions.html#GUID-745C9F2E-C5ED-4959-A315-09DB008DBC59">Interface oracle.jdbc.OracleConnection</a></p>
                           </li>
                           <li>
                              <p><a href="Oracle-extensions.html#GUID-46404619-5332-4C70-B7BE-7A31372932C3">Interface oracle.jdbc.OracleStatement</a></p>
                           </li>
                           <li>
                              <p><a href="Oracle-extensions.html#GUID-B5463D4F-6319-4A21-AB35-A5A7F3FDFC61">Interface oracle.jdbc.OraclePreparedStatement</a></p>
                           </li>
                           <li>
                              <p><a href="Oracle-extensions.html#GUID-0C1F7E0A-5A10-4E81-B789-F275D81E12F7">Interface oracle.jdbc.OracleCallableStatement</a></p>
                           </li>
                           <li>
                              <p><a href="Oracle-extensions.html#GUID-40FC3C62-E48D-42A8-A9AB-DA45DC8E6B3E">Interface oracle.jdbc.OracleResultSet</a></p>
                           </li>
                           <li>
                              <p><a href="Oracle-extensions.html#GUID-177EF9E3-B054-4D91-90D6-23F986C250DD">Interface oracle.jdbc.OracleResultSetMetaData</a></p>
                           </li>
                           <li>
                              <p><a href="Oracle-extensions.html#GUID-A8B450ED-A95B-4B40-B720-922C209D7D88">Class oracle.jdbc.OracleTypes</a></p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div><a id="JJDBC28164"></a><a id="JJDBC28163"></a><div class="props_rev_3"><a id="GUID-745C9F2E-C5ED-4959-A315-09DB008DBC59" name="GUID-745C9F2E-C5ED-4959-A315-09DB008DBC59"></a><h5 id="JJDBC-GUID-745C9F2E-C5ED-4959-A315-09DB008DBC59" class="sect5"><span class="enumeration_section">4.5.5.1 </span>Interface oracle.jdbc.OracleConnection
                     </h5>
                     <div>
                        <div class="section">
                           <p><a id="d23567e3026" class="indexterm-anchor"></a><a id="d23567e3028" class="indexterm-anchor"></a>This interface extends standard JDBC connection functionality to create and return Oracle statement objects, set flags and options for Oracle performance extensions, support type maps for Oracle objects, and support client identifiers.
                           </p>
                           <p>In Oracle Database 11<span class="italic">g</span> Release 1, new methods were added to this interface that enable the starting up and shutting down of an Oracle Database instance. Also, for better visibility and clarity, all connection properties are defined as constants in the <code class="codeph">OracleConnection</code> interface.
                           </p>
                           <p>This interface also defines factory methods for constructing <code class="codeph">oracle.sql</code> data values like <code class="codeph">DATE</code> and <code class="codeph">NUMBER</code>. Remember the following points while using factory methods:
                           </p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>All code that constructs instances of the <code class="codeph">oracle.sql</code> types should use the Oracle extension factory methods. For example, <code class="codeph">ARRAY</code>, <code class="codeph">BFILE</code>, <code class="codeph">DATE</code>, <code class="codeph">INTERVALDS</code>, <code class="codeph">NUMBER</code>, <code class="codeph">STRUCT</code>, <code class="codeph">TIME</code>, <code class="codeph">TIMESTAMP</code>, and so on.
                                 </p>
                              </li>
                              <li>
                                 <p>All code that constructs instances of the standard types should use the JDBC 4.0 standard factory methods. For example, <code class="codeph">CLOB</code>, <code class="codeph">BLOB</code>, <code class="codeph">NCLOB</code>, and so on.
                                 </p>
                              </li>
                              <li>
                                 <p>There are no factory methods for <code class="codeph">CHAR</code>, <code class="codeph">JAVA_STRUCT</code>, <code class="codeph">ArrayDescriptor</code>, and <code class="codeph">StructDescriptor.</code> These types are for internal driver use only.
                                 </p>
                                 <div class="infoboxnote" id="GUID-745C9F2E-C5ED-4959-A315-09DB008DBC59__GUID-69E3481B-1454-4D36-A812-93E71D750B2D">
                                    <p class="notep1">Note:</p>
                                    <p>Prior to Oracle Database 11<span class="italic">g</span> Release 1, you had to construct <code class="codeph">ArrayDescriptors</code> and <code class="codeph">StructDescriptors</code> for passing as arguments to the <code class="codeph">ARRAY</code> and <code class="codeph">STRUCT</code> class constructors. The new <code class="codeph">ARRAY</code> and <code class="codeph">Struct</code> factory methods do not have any descriptor arguments. The driver still uses descriptors internally, but you do not need to create them.
                                    </p>
                                 </div>
                              </li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-745C9F2E-C5ED-4959-A315-09DB008DBC59__GUID-BCA973AE-19FD-4CCA-875C-DE8B7409BF7B">Client Identifiers</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p>In a connection pooling environment, the client identifier can be used to identify the lightweight user using the database session currently. A client identifier can also be used to share the Globally Accessed Application Context between different database sessions. The client identifier set in a database session is audited when database auditing is turned on.</p>
                           <div class="infoboxnotealso" id="GUID-745C9F2E-C5ED-4959-A315-09DB008DBC59__GUID-B0183873-4948-42C7-8069-523B2AE31585">
                              <p class="notep1">See Also:</p>
                              <p><a href="../jajdb/index.html" target="_blank"><span><cite>Oracle Database JDBC Java API Reference</cite></span></a> for more information
                              </p>
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="JJDBC28165"></a><div class="props_rev_3"><a id="GUID-46404619-5332-4C70-B7BE-7A31372932C3" name="GUID-46404619-5332-4C70-B7BE-7A31372932C3"></a><h5 id="JJDBC-GUID-46404619-5332-4C70-B7BE-7A31372932C3" class="sect5"><span class="enumeration_section">4.5.5.2 </span>Interface oracle.jdbc.OracleStatement
                     </h5>
                     <div>
                        <div class="section">
                           <p><a id="d23567e3172" class="indexterm-anchor"></a><a id="d23567e3174" class="indexterm-anchor"></a>This interface extends standard JDBC statement functionality and is the superinterface of the <code class="codeph">OraclePreparedStatement</code> and <code class="codeph">OracleCallableStatement</code> classes. Extended functionality includes support for setting flags and options for Oracle performance extensions on a statement-by-statement basis, as opposed to the <code class="codeph">OracleConnection</code> interface that sets these on a connectionwide basis.
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="JJDBC28166"></a><div class="props_rev_3"><a id="GUID-B5463D4F-6319-4A21-AB35-A5A7F3FDFC61" name="GUID-B5463D4F-6319-4A21-AB35-A5A7F3FDFC61"></a><h5 id="JJDBC-GUID-B5463D4F-6319-4A21-AB35-A5A7F3FDFC61" class="sect5"><span class="enumeration_section">4.5.5.3 </span>Interface oracle.jdbc.OraclePreparedStatement
                     </h5>
                     <div>
                        <div class="section">
                           <p><a id="d23567e3211" class="indexterm-anchor"></a><a id="d23567e3213" class="indexterm-anchor"></a>This interface extends the <code class="codeph">OracleStatement</code> interface and extends standard JDBC prepared statement functionality. Also, the <code class="codeph">oracle.jdbc.OraclePreparedStatement</code> interface is extended by the <code class="codeph">OracleCallableStatement</code> interface. Extended functionality consists of the following:
                           </p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><code class="codeph">set</code><span class="italic"><code class="codeph">XXX</code></span> methods for binding <code class="codeph">oracle.sql.*</code> types and objects to prepared statements
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">getMetaData</code> method to get the metadata from the prepared statements without executing the SELECT statements
                                 </p>
                              </li>
                              <li>
                                 <p>Methods to support Oracle performance extensions on a statement-by-statement basis</p>
                              </li>
                           </ul>
                           <div class="infoboxnote" id="GUID-B5463D4F-6319-4A21-AB35-A5A7F3FDFC61__GUID-26397C18-728B-4F4A-9F0A-21C0666DA6CB">
                              <p class="notep1">Note:</p>
                              <p>Do not use the <code class="codeph">PreparedStatement</code> interface to create a trigger that refers to a<code class="codeph">:NEW</code> or <code class="codeph">:OLD</code> column. Use <code class="codeph">Statement</code> instead. Using <code class="codeph">PreparedStatement</code> will cause execution to fail with the message <code class="codeph">java.sql.SQLException: Missing IN or OUT parameter at index:: 1</code>.
                              </p>
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="JJDBC28167"></a><div class="props_rev_3"><a id="GUID-0C1F7E0A-5A10-4E81-B789-F275D81E12F7" name="GUID-0C1F7E0A-5A10-4E81-B789-F275D81E12F7"></a><h5 id="JJDBC-GUID-0C1F7E0A-5A10-4E81-B789-F275D81E12F7" class="sect5"><span class="enumeration_section">4.5.5.4 </span>Interface oracle.jdbc.OracleCallableStatement
                     </h5>
                     <div>
                        <div class="section">
                           <p><a id="d23567e3291" class="indexterm-anchor"></a><a id="d23567e3293" class="indexterm-anchor"></a>This interface extends the <code class="codeph">OraclePreparedStatement</code> interface, which extends the <code class="codeph">OracleStatement</code> interface and incorporates standard JDBC callable statement functionality.
                           </p>
                           <div class="infoboxnote" id="GUID-0C1F7E0A-5A10-4E81-B789-F275D81E12F7__GUID-18AA8E77-48E2-4274-8C2C-D4AF1BC5CB28">
                              <p class="notep1">Note:</p>
                              <p>Do not use the <code class="codeph">CallableStatement</code> interface to create a trigger that refers to a<code class="codeph">:NEW</code> or <code class="codeph">:OLD</code> column. Use <code class="codeph">Statement</code> instead; using <code class="codeph">CallableStatement</code> will cause execution to fail with the message <code class="codeph">java.sql.SQLException: Missing IN or OUT parameter at index::1</code></p>
                           </div>
                           <div class="infoboxnote" id="GUID-0C1F7E0A-5A10-4E81-B789-F275D81E12F7__GUID-08C68E79-FC43-401D-9909-55A7F023F981">
                              <p class="notep1">Note:</p>
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p>The <code class="codeph">set</code><span class="italic"><code class="codeph">XXX</code></span><code class="codeph">(String,...)</code> and <code class="codeph">registerOutParameter(String,...)</code> methods can be used only if all binds are procedure or function parameters only. The statement can contain no other binds and the parameter binds must be indicated with a question mark (<code class="codeph">?)</code> and not <code class="codeph">:</code><span class="italic"><code class="codeph">XX</code></span>.
                                    </p>
                                 </li>
                                 <li>
                                    <p>If you are using <code class="codeph">set</code><span class="italic"><code class="codeph">XXX</code></span><code class="codeph">(int,...) or</code> <code class="codeph">set</code><span class="italic"><code class="codeph">XXX</code></span><code class="codeph">AtName(String,...)</code> method, then any output parameter is bound with <code class="codeph">registerOutParameter(int,...)</code> and not <code class="codeph">registerOutParameter(String,...)</code>, which is for named parameter notation.
                                    </p>
                                 </li>
                              </ul>
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="JJDBC28168"></a><div class="props_rev_3"><a id="GUID-40FC3C62-E48D-42A8-A9AB-DA45DC8E6B3E" name="GUID-40FC3C62-E48D-42A8-A9AB-DA45DC8E6B3E"></a><h5 id="JJDBC-GUID-40FC3C62-E48D-42A8-A9AB-DA45DC8E6B3E" class="sect5"><span class="enumeration_section">4.5.5.5 </span>Interface oracle.jdbc.OracleResultSet
                     </h5>
                     <div>
                        <div class="section">
                           <p><a id="d23567e3398" class="indexterm-anchor"></a><a id="d23567e3400" class="indexterm-anchor"></a>This interface extends standard JDBC result set functionality, implementing <code class="codeph">get</code><span class="italic"><code class="codeph">XXX</code></span> methods for retrieving data into <code class="codeph">oracle.sql.*</code> objects.
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="JJDBC28169"></a><div class="props_rev_3"><a id="GUID-177EF9E3-B054-4D91-90D6-23F986C250DD" name="GUID-177EF9E3-B054-4D91-90D6-23F986C250DD"></a><h5 id="JJDBC-GUID-177EF9E3-B054-4D91-90D6-23F986C250DD" class="sect5"><span class="enumeration_section">4.5.5.6 </span>Interface oracle.jdbc.OracleResultSetMetaData
                     </h5>
                     <div>
                        <div class="section">
                           <p><a id="d23567e3437" class="indexterm-anchor"></a><a id="d23567e3439" class="indexterm-anchor"></a>This interface extends standard JDBC result set metadata functionality to retrieve information about Oracle <a id="d23567e3442" class="indexterm-anchor"></a>result set objects.
                           </p>
                           <div class="infoboxnotealso" id="GUID-177EF9E3-B054-4D91-90D6-23F986C250DD__GUID-88122DB7-34CF-4A46-A272-6E6197C7356F">
                              <p class="notep1">See Also:</p>
                              <p><span class="q">"<a href="accessing-and-manipulating-Oracle-data.html#GUID-C9AF8539-12BA-4F19-AAB9-0EE481D78F19">Using Result Set Metadata Extensions</a>"</span></p>
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="JJDBC28171"></a><a id="JJDBC28172"></a><a id="JJDBC28170"></a><div class="props_rev_3"><a id="GUID-A8B450ED-A95B-4B40-B720-922C209D7D88" name="GUID-A8B450ED-A95B-4B40-B720-922C209D7D88"></a><h5 id="JJDBC-GUID-A8B450ED-A95B-4B40-B720-922C209D7D88" class="sect5"><span class="enumeration_section">4.5.5.7 </span>Class oracle.jdbc.OracleTypes
                     </h5>
                     <div>
                        <div class="section">
                           <p><a id="d23567e3479" class="indexterm-anchor"></a><a id="d23567e3481" class="indexterm-anchor"></a>The <code class="codeph">OracleTypes</code> class defines <a id="d23567e3487" class="indexterm-anchor"></a><a id="d23567e3489" class="indexterm-anchor"></a>constants that JDBC uses to identify SQL types. Each variable in this class has a constant integer value. The <code class="codeph">oracle.jdbc.OracleTypes</code> class duplicates the type code definitions of the standard Java <code class="codeph">java.sql.Types</code> class and contains these additional type codes for Oracle extensions:
                           </p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><code class="codeph">OracleTypes.BFILE</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">OracleTypes.ROWID</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">OracleTypes.CURSOR</code> (for <code class="codeph">REF CURSOR</code> types)
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">OracleTypes.CHAR_BYTES</code> (for calling <code class="codeph">setNull</code> and <code class="codeph">setCHAR</code> methods on the same column)
                                 </p>
                              </li>
                           </ul>
                           <p>As in <code class="codeph">java.sql.Types</code>, all the variable names are in uppercase text. 
                           </p>
                           <p>JDBC uses the SQL types identified by the elements of the <code class="codeph">OracleTypes</code> class in two main areas: registering output parameters and in the <code class="codeph">setNull</code> method of the <code class="codeph">PreparedStatement</code> class.
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-A8B450ED-A95B-4B40-B720-922C209D7D88__GUID-E19F38F4-C3D2-4C4D-A35D-B39D08884C96">OracleTypes and Registering Output Parameters</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p>The type codes in <code class="codeph">java.sql.Types</code> or <code class="codeph">oracle.jdbc.OracleTypes</code> identify the SQL types of the output parameters in the <code class="codeph">registerOutParameter</code> method of the <code class="codeph">java.sql.CallableStatement</code> and <code class="codeph">oracle.jdbc.OracleCallableStatement</code> interfaces.
                           </p>
                           <p>These are the forms that the <code class="codeph">registerOutputParameter</code> method can take for the <code class="codeph">CallableStatement</code> and <code class="codeph">OracleCallableStatement</code> interfaces
                           </p><pre class="oac_no_warn" dir="ltr">cs.registerOutParameter(int index, int sqlType);

cs.registerOutParameter(int index, int sqlType, String sql_name);

cs.registerOutParameter(int index, int sqlType, int scale);
</pre><p>In these signatures, <code class="codeph">index</code> represents the parameter index, <code class="codeph">sqlType</code> is the type code for the SQL data type, <code class="codeph">sql_name</code> is the name given to the data type, for user-defined types, when <code class="codeph">sqlType</code> is a <code class="codeph">STRUCT</code>, <code class="codeph">REF</code>, or <code class="codeph">ARRAY</code> type code, and <code class="codeph">scale</code> represents the number of digits to the right of the decimal point, when <code class="codeph">sqlType</code> is a <code class="codeph">NUMERIC</code> or <code class="codeph">DECIMAL</code> type code. 
                           </p>
                           <p>The following example uses a <code class="codeph">CallableStatement</code> interface to call a procedure named <code class="codeph">charout</code>, which returns a <code class="codeph">CHAR</code> data type. Note the use of the <code class="codeph">OracleTypes.CHAR</code> type code in the <code class="codeph">registerOutParameter</code> method. 
                           </p><pre class="oac_no_warn" dir="ltr">CallableStatement cs = conn.prepareCall ("BEGIN charout (?); END;");
cs.registerOutParameter (1, OracleTypes.CHAR);
cs.execute ();
System.out.println ("Out argument is: " + cs.getString (1));
</pre><p>The next example uses a <code class="codeph">CallableStatement</code> interface to call <code class="codeph">structout</code>, which returns a <code class="codeph">STRUCT</code> data type. The form of <code class="codeph">registerOutParameter</code> requires you to specify the type code, <code class="codeph">Types.STRUCT</code> or <code class="codeph">OracleTypes.STRUCT</code>, as well as the SQL name, <code class="codeph">EMPLOYEE</code>.
                           </p>
                           <p>The example assumes that no type mapping has been declared for the <code class="codeph">EMPLOYEE</code> type, so it is retrieved into a <code class="codeph">STRUCT</code> data type. To retrieve the value of <code class="codeph">EMPLOYEE</code> as an <code class="codeph">oracle.sql.STRUCT</code> object, the statement object <code class="codeph">cs</code> is cast to <code class="codeph">OracleCallableStatement</code> and the Oracle extension <code class="codeph">getSTRUCT</code> method is invoked.
                           </p><pre class="oac_no_warn" dir="ltr">CallableStatement cs = conn.prepareCall ("BEGIN structout (?); END;");
cs.registerOutParameter (1, OracleTypes.STRUCT, "EMPLOYEE");
cs.execute ();

// get the value into a STRUCT because it 
// is assumed that no type map has been defined
STRUCT emp = ((OracleCallableStatement)cs).getSTRUCT (1);</pre></div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-A8B450ED-A95B-4B40-B720-922C209D7D88__GUID-CCFCD935-713B-4F02-83B6-8E52C56A3567">OracleTypes and the setNull Method</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p>The type codes in <code class="codeph">Types</code> and <code class="codeph">OracleTypes</code> identify the SQL type of the data item, which the <code class="codeph">setNull</code> method sets to <code class="codeph">NULL</code>. The <code class="codeph">setNull</code> method can be found in the <code class="codeph">java.sql.PreparedStatement</code> and <code class="codeph">oracle.jdbc.OraclePreparedStatement</code> interfaces.
                           </p>
                           <p>These are the forms that the <code class="codeph">setNull</code> method can take for the <code class="codeph">PreparedStatement</code> and <code class="codeph">OraclePreparedStatement</code> objects:
                           </p><pre class="oac_no_warn" dir="ltr">ps.setNull(int index, int sqlType);

ps.setNull(int index, int sqlType, String sql_name);
</pre><p>In these signatures, <code class="codeph">index</code> represents the parameter index, <code class="codeph">sqlType</code> is the type code for the SQL data type, and <code class="codeph">sql_name</code> is the name given to the data type, for user-defined types, when <code class="codeph">sqlType</code> is a <code class="codeph">STRUCT</code>, <code class="codeph">REF</code>, or <code class="codeph">ARRAY</code> type code. If you enter an invalid <code class="codeph">sqlType</code>, a <code class="codeph">ParameterTypeConflict</code> exception is thrown.
                           </p>
                           <p>The following example uses a prepared statement to insert a null value into the database. Note the use of <code class="codeph">OracleTypes.NUMERIC</code> to identify the numeric object set to <code class="codeph">NULL</code>. Alternatively, <code class="codeph">Types.NUMERIC</code> can be used.
                           </p><pre class="oac_no_warn" dir="ltr">PreparedStatement pstmt =
    conn.prepareStatement ("INSERT INTO num_table VALUES (?)");

pstmt.setNull (1, OracleTypes.NUMERIC);
pstmt.execute ();
</pre><p>In this example, the prepared statement inserts a <code class="codeph">NULL</code> <code class="codeph">STRUCT</code> object of type <code class="codeph">EMPLOYEE</code> into the database. 
                           </p><pre class="oac_no_warn" dir="ltr">PreparedStatement pstmt = conn.prepareStatement 
                               ("INSERT INTO employees VALUES (?)");

pstmt.setNull (1, OracleTypes.STRUCT, "EMPLOYEE");
pstmt.execute ();
</pre><p>You can also use the <code class="codeph">OracleTypes.CHAR_BYTES</code> type with the <code class="codeph">setNull</code> method, if you also want to call the <code class="codeph">setCHAR</code> method on the same column. For example:
                           </p><pre class="oac_no_warn" dir="ltr"> ps.setCHAR(n, aCHAR);
  ps.addBatch();
  ps.setNull(n, OracleTypes.CHAR_BYTES);
  ps.addBatch();
</pre><p>In this preceding example, any other type, apart from the <code class="codeph">OracleTypes.CHAR_BYTES</code> type, will cause extra round trips to the Database. Alternatively, you can also write your code without using the <code class="codeph">setNull</code> method. For example, you can also write your code as shown in the following example:
                           </p><pre class="oac_no_warn" dir="ltr">ps.setCHAR(n, null);
</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div>
            </div><a id="JJDBC28174"></a><div class="props_rev_3"><a id="GUID-9EC82134-1206-4325-A17B-9FA7610F0169" name="GUID-9EC82134-1206-4325-A17B-9FA7610F0169"></a><h3 id="JJDBC-GUID-9EC82134-1206-4325-A17B-9FA7610F0169" class="sect3"><span class="enumeration_section">4.6 </span>DML Returning
               </h3>
               <div>
                  <div class="section">
                     <p>The DML returning feature provides more functionality compared to retrieval of auto-generated keys. It can be used to retrieve not only auto-generated keys, but also other columns or values that the application may use.</p>
                     <div class="infoboxnote" id="GUID-9EC82134-1206-4325-A17B-9FA7610F0169__GUID-23348EDA-BFA2-4909-9140-6BE89BFED53D">
                        <p class="notep1">Note:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>The server-side internal driver does not support DML returning and retrieval of auto-generated keys.</p>
                           </li>
                           <li>
                              <p>You cannot use both DML returning and retrieval of auto-generated keys in the same statement.</p>
                           </li>
                        </ul>
                     </div>
                     <p>The following sections explain the support for DML returning:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="Oracle-extensions.html#GUID-F0E9897E-6F04-479F-9568-07FFCE7FB66F">Oracle-Specific APIs</a></p>
                        </li>
                        <li>
                           <p><a href="Oracle-extensions.html#GUID-E27DE9F3-236A-49F1-98BD-F3513110F3A5">About Running DML Returning Statements</a></p>
                        </li>
                        <li>
                           <p><a href="Oracle-extensions.html#GUID-B2935E57-0E0A-4C4E-9515-9C63FCBDB87B">Example of DML Returning</a></p>
                        </li>
                        <li>
                           <p><a href="Oracle-extensions.html#GUID-4D193775-764B-4080-9BD1-FC6F7135F086">Limitations of DML Returning</a></p>
                        </li>
                     </ul>
                     <div class="infoboxnotealso" id="GUID-9EC82134-1206-4325-A17B-9FA7610F0169__GUID-798FAA62-3C05-42CB-B055-AB9DD87270D9">
                        <p class="notep1">See Also:</p>
                        <p><span class="q">"<a href="JDBC-standards-support.html#GUID-11E3AAF8-009C-418E-8263-E41EE49F2EA8">Retrieval of Auto-Generated Keys</a>"</span></p>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div><a id="JJDBC28175"></a><div class="props_rev_3"><a id="GUID-F0E9897E-6F04-479F-9568-07FFCE7FB66F" name="GUID-F0E9897E-6F04-479F-9568-07FFCE7FB66F"></a><h4 id="JJDBC-GUID-F0E9897E-6F04-479F-9568-07FFCE7FB66F" class="sect4"><span class="enumeration_section">4.6.1 </span>Oracle-Specific APIs
                  </h4>
                  <div>
                     <div class="section">
                        <p>The <code class="codeph">OraclePreparedStatement</code> interface is enhanced with Oracle-specific application programming interfaces (APIs) to support DML returning. The <code class="codeph">registerReturnParameter</code> and <code class="codeph">getReturnResultSet</code> methods have been added to the <code class="codeph">oracle.jdbc.OraclePreparedStatement</code> interface, to register parameters that are returned and data retrieved by DML returning.
                        </p>
                        <p>The <code class="codeph">registerReturnParameter</code> method is used to register the return parameter for DML returning. The method throws a <code class="codeph">SQLException</code> instance if an error occurs. You must pass a positive integer specifying the index of the return parameter. You also must specify the type of the return parameter. You can also specify the maximum bytes or characters of the return parameter. This method can be used only with <code class="codeph">char</code> or <code class="codeph">RAW</code> types. You can also specify the fully qualified name of a SQL structure type.
                        </p>
                        <div class="infoboxnote" id="GUID-F0E9897E-6F04-479F-9568-07FFCE7FB66F__GUID-1BE0C9BE-D483-4393-9898-D1A5001D5926">
                           <p class="notep1">Note:</p>
                           <p>If you do not know the maximum size of the return parameters, then you should use <code class="codeph">registerReturnParameter(int paramIndex, int externalType)</code>, which picks the default maximum size. If you know the maximum size of return parameters, using <code class="codeph">registerReturnParameter(int paramIndex, int externalType, int maxSize)</code> can reduce memory consumption.
                           </p>
                        </div>
                        <p>The <code class="codeph">getReturnResultSet</code> method fetches the data returned from DML returning and returns it as a <code class="codeph">ResultSet</code> object. The method throws a <code class="codeph">SQLException</code> exception if an error occurs.
                        </p>
                        <div class="infoboxnote" id="GUID-F0E9897E-6F04-479F-9568-07FFCE7FB66F__GUID-203F81E9-92B2-4552-B14B-95CF4D88182F">
                           <p class="notep1">Note:</p>
                           <p>The Oracle-specific APIs for the DML returning feature are in <code class="codeph">ojdbc6.jar</code> for Java Development Kit (JDK) 6.0 and in <code class="codeph">ojdbc7.jar</code> for JDK 7.
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JJDBC28176"></a><div class="props_rev_3"><a id="GUID-E27DE9F3-236A-49F1-98BD-F3513110F3A5" name="GUID-E27DE9F3-236A-49F1-98BD-F3513110F3A5"></a><h4 id="JJDBC-GUID-E27DE9F3-236A-49F1-98BD-F3513110F3A5" class="sect4"><span class="enumeration_section">4.6.2 </span>About Running DML Returning Statements
                  </h4>
                  <div>
                     <div class="section">
                        <p>Before running a DML returning statement, the JDBC application must call one or more of the <code class="codeph">registerReturnParameter</code> methods. The method provides the JDBC drivers with information, such as type and size, of the return parameters. The DML returning statement is then processed using one of the standard JDBC APIs, <code class="codeph">executeUpdate</code> or <code class="codeph">execute</code>. You can then fetch the returned parameters as a <code class="codeph">ResultSet</code> object using the <code class="codeph">getReturnResultSet</code> method of the <code class="codeph">oracle.jdbc.OraclePreparedStatement</code> interface.
                        </p>
                        <p>In order to read the values in the <code class="codeph">ResultSet</code> object, the underlying <code class="codeph">Statement</code> object must be open. When the underlying <code class="codeph">Statement</code> object is closed, the returned <code class="codeph">ResultSet</code> object is also closed. This is consistent with <code class="codeph">ResultSet</code> objects that are retrieved by processing SQL query statements.
                        </p>
                        <p>When a DML returning statement is run, the concurrency of the <code class="codeph">ResultSet</code> object returned by the <code class="codeph">getReturnResultSet</code> method must be <code class="codeph">CONCUR_READ_ONLY</code> and the type of the <code class="codeph">ResultSet</code> object must be <code class="codeph">TYPE_FORWARD_ONLY</code> or <code class="codeph">TYPE_SCROLL_INSENSITIVE</code>.
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JJDBC28177"></a><div class="props_rev_3"><a id="GUID-B2935E57-0E0A-4C4E-9515-9C63FCBDB87B" name="GUID-B2935E57-0E0A-4C4E-9515-9C63FCBDB87B"></a><h4 id="JJDBC-GUID-B2935E57-0E0A-4C4E-9515-9C63FCBDB87B" class="sect4"><span class="enumeration_section">4.6.3 </span>Example of DML Returning
                  </h4>
                  <div>
                     <div class="section">
                        <p>This section provides two code examples of DML returning.</p>
                        <p>The following code example illustrates the use of DML returning. In this example, assume that the maximum size of the <code class="codeph">name</code> column is 100 characters. Because the maximum size of the <code class="codeph">name</code> column is known, the <code class="codeph">registerReturnParameter(int paramIndex, int externalType, int maxSize)</code> method is used.
                        </p><pre class="oac_no_warn" dir="ltr">...
OraclePreparedStatement pstmt = (OraclePreparedStatement)conn.prepareStatement(
       "delete from tab1 where age &lt; ? returning name into ?");
pstmt.setInt(1,18);

/** register returned parameter
  * in this case the maximum size of name is 100 chars
  */
pstmt.registerReturnParameter(2, OracleTypes.VARCHAR, 100);

// process the DML returning statement
count = pstmt.executeUpdate();
if (count&gt;0)
{
  ResultSet rset = pstmt.getReturnResultSet(); //rest is not null and not empty
  while(rset.next())
  {
    String name = rset.getString(1);
    ...
  }
}
...
</pre><p>The following code example also illustrates the use of DML returning. However, in this case, the maximum size of the return parameters is not known. Therefore, the <code class="codeph">registerReturnParameter(int paramIndex, int externalType)</code> method is used.
                        </p><pre class="oac_no_warn" dir="ltr">...
OraclePreparedStatement pstmt = (OraclePreparedStatement)conn.prepareStatement(
  "insert into lobtab values (100, empty_clob()) returning col1, col2 into ?, ?");

// register return parameters
pstmt.registerReturnParameter(1, OracleTypes.INTEGER);
pstmt.registerReturnParameter(2, OracleTypes.CLOB);

// process the DML returning SQL statement
pstmt.executeUpdate();
ResultSet rset = pstmt.getReturnResultSet();
int r;
CLOB clob;
if (rset.next())
{
  r = rset.getInt(1);
  System.out.println(r);
  clob = (CLOB)rset.getClob(2);
  ...
}
...
</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JJDBC28178"></a><div class="props_rev_3"><a id="GUID-4D193775-764B-4080-9BD1-FC6F7135F086" name="GUID-4D193775-764B-4080-9BD1-FC6F7135F086"></a><h4 id="JJDBC-GUID-4D193775-764B-4080-9BD1-FC6F7135F086" class="sect4"><span class="enumeration_section">4.6.4 </span>Limitations of DML Returning
                  </h4>
                  <div>
                     <div class="section">
                        <p>When using DML returning, be aware of the following:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>It is unspecified what the <code class="codeph">getReturnResultSet</code> method returns when it is invoked more than once. You should not rely on any specific action in this regard.
                              </p>
                           </li>
                           <li>
                              <p>The <code class="codeph">ResultSet</code> objects returned from the execution of DML returning statements do not support the <code class="codeph">ResultSetMetaData</code> type. Therefore, the applications must know the information of return parameters before running DML returning statements.
                              </p>
                           </li>
                           <li>
                              <p>Streams are not supported with DML returning.</p>
                           </li>
                           <li>
                              <p>DML returning cannot be combined with batch update.</p>
                           </li>
                           <li>
                              <p>You cannot use both the auto-generated key feature and the DML returning feature in a single SQL DML statement. For example, the following is not allowed:</p><pre class="oac_no_warn" dir="ltr">...
PreparedStatement pstmt = conn.prepareStatement('insert into orders (?, ?, ?) returning order_id into ?");
pstmt.setInt(1, seq01.NEXTVAL);
pstmt.setInt(2, 100);
pstmt.setInt(3, 966431502);
pstmt.registerReturnParam(4, OracleTypes.INTEGER);
pstmt.executeUpdate;
ResultSet rset = pstmt.getGeneratedKeys;
...
</pre></li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="JJDBC28179"></a><div class="props_rev_3"><a id="GUID-2EF2089E-11B3-4395-8464-E6EFC23285AB" name="GUID-2EF2089E-11B3-4395-8464-E6EFC23285AB"></a><h3 id="JJDBC-GUID-2EF2089E-11B3-4395-8464-E6EFC23285AB" class="sect3"><span class="enumeration_section">4.7 </span>Accessing PL/SQL Associative Arrays
               </h3>
               <div>
                  <p></p>
                  <div class="section">
                     <p>Oracle JDBC drivers enable JDBC applications to make PL/SQL calls with Associative Arrays parameters. In PL/SQL, an Associative Array is a set of key-value pairs, where the keys may be <code class="codeph">PLS_INTEGER</code>s or Strings. The keys may have any value and need not be dense. From a client application, you can work only with <code class="codeph">PLS_INTEGER</code> or <code class="codeph">BINARY_INTEGER</code> keys.
                     </p>
                     <div class="infoboxnote" id="GUID-2EF2089E-11B3-4395-8464-E6EFC23285AB__GUID-D8880935-CEFB-4737-9597-25339D1F8750">
                        <p class="notep1">Note:</p>
                        <p>The <code class="codeph">PLS_INTEGER</code> and <code class="codeph">BINARY_INTEGER</code> are identical data types.
                        </p>
                     </div>
                     <p>The previous release of Oracle JDBC drivers provided support only for PL/SQL Associative Arrays of Scalar data types. Also, the support was restricted only to the values of the key-value pairs of the Arrays. Oracle Database Release 18c supports accessing both the keys (indexes) and values of Associative Arrays, and also provides support for Associative Arrays of object types. Use the following methods to achieve the new functionalities:</p>
                     <ul style="list-style-type: disc;">
                        <li><pre class="pre codeblock"><code>Array createOracleArray(String arrayTypeName,

                        Object elements)

                        throws SQLException</code></pre></li>
                        <li><pre class="pre codeblock"><code>ARRAY createARRAY(String typeName,

                  Object elements)

                  throws SQLException</code></pre><p>In both the preceding methods, the second parameter can either be a <code class="codeph">java.util.Map&lt;Integer, ?&gt;</code> that holds the key-value pairs of the Associative Arrays, or it can only be an array of values. If it is an array of values, then the JDBC driver defaults the indexes to 0,1,2 and so on. If it is <code class="codeph">java.util.Map&lt;Integer, ?&gt;</code>,  then the JDBC driver does not default the keys. They remain as specified in the Map, and can be sparse and negative.
                           </p>
                        </li>
                        <li><pre class="pre codeblock"><code>Map&lt;?,?&gt; oracle.jdbc.OracleArray.getJavaMap();</code></pre><p>This method returns a <code class="codeph">Map&lt;?,?&gt;</code> for the data types in the Associative Array and <code class="codeph">null</code> for Nested Tables and VARRAYs.
                           </p>
                        </li>
                     </ul>
                     <div class="infoboxnote" id="GUID-2EF2089E-11B3-4395-8464-E6EFC23285AB__GUID-7184BC8E-93C6-4C9F-9CC0-1E4B8AE7E0AA">
                        <p class="notep1">Note:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Associative Arrays were previously known as index-by tables.</p>
                           </li>
                           <li>
                              <p>When you use String data types, the size is limited to the size in PL/SQL that is 32767 characters. For the server-side internal driver, the limits are lower.</p>
                           </li>
                        </ul>
                     </div>
                     <div class="infoboxnotealso" id="GUID-2EF2089E-11B3-4395-8464-E6EFC23285AB__GUID-37514249-E899-4DFD-A0FA-D0256B2C54B8">
                        <p class="notep1">See Also:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><span><cite>Oracle Database JDBC Java API Reference</cite></span></p>
                           </li>
                           <li>
                              <p><a href="../lnpls/plsql-collections-and-records.html#LNPLS-GUID-8060F01F-B53B-48D4-9239-7EA8461C2170" target="_blank"><span><cite>Oracle Database PL/SQL Language Reference</cite></span></a></p> for more information about Associative Arrays
                           </li>
                        </ul>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div>
            </div>
         </div>
      </article>
   </body>
</html>