<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <meta name="abstract" content="Static SQL is a PL/SQL feature that allows SQL syntax directly in a PL/SQL statement."></meta>
      <meta name="description" content="Static SQL is a PL/SQL feature that allows SQL syntax directly in a PL/SQL statement."></meta>
      <title>PL / SQL静态SQL</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Database PL/SQL Language Reference "></meta>
      <meta property="og:description" content="Static SQL is a PL/SQL feature that allows SQL syntax directly in a PL/SQL statement."></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Database PL/SQL Language Reference"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="database-pl-sql-language-reference.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-13T20:26:20-08:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="1996, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96448-02"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="plsql-collections-and-records.html" title="Previous" type="text/html"></link>
      <link rel="next" href="dynamic-sql.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Database PL/SQL Language Reference"></meta>
    <meta name="dcterms.isVersionOf" content="LNPLS"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="plsql-collections-and-records.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="dynamic-sql.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">数据库PL / SQL语言参考</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">PL / SQL静态SQL</li>
            </ol>
            <a id="GUID-A2E4086F-94DC-4CC7-9E4B-30285BEC3313" name="GUID-A2E4086F-94DC-4CC7-9E4B-30285BEC3313"></a><a id="LNPLS453"></a><a id="LNPLS006"></a>
            
            <h2 id="LNPLS-GUID-A2E4086F-94DC-4CC7-9E4B-30285BEC3313" class="sect2"><span class="enumeration_chapter">6</span> PL / SQL静态SQL</h2>
         </header>
         <div class="ind">
            <div>
               <p><span class="bold">静态SQL</span>是一种PL / SQL功能，它允许直接在PL / SQL语句中使用SQL语法。
               </p>
               <p>本章介绍静态SQL并说明如何使用它。</p>
               <div class="section">
                  <p class="subhead1" id="GUID-A2E4086F-94DC-4CC7-9E4B-30285BEC3313__GUID-B2CDC307-B759-40FC-BCBC-9E7FF4B17A71">话题</p>
               </div>
               <!-- class="section" -->
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="static-sql.html#GUID-54ABD9E3-EA4D-4C60-A84A-021925501C0C" title="除非另有说明，否则静态SQL具有与SQL相同的语法。">静态SQL的描述</a></p>
                  </li>
                  <li>
                     <p><a href="static-sql.html#GUID-F1FE15F9-5C96-4C4E-B240-B7363D25A8F1" title="游标是指向私有SQL区域的指针，该区域存储有关处理特定SELECT或DML语句的信息。">游标概述</a></p>
                  </li>
                  <li>
                     <p><a href="static-sql.html#GUID-E6BCE8B1-71AA-459F-845F-2C34541A534D" title="在PL / SQL中，与传统的数据库编程一样，您使用游标来处理查询结果集。但是，在PL / SQL中，您可以使用隐式或显式游标。">处理查询结果集</a></p>
                  </li>
                  <li>
                     <p><a href="static-sql.html#GUID-4A6E054A-4002-418D-A1CA-DE849CD7E6D5" title="要创建游标变量，请声明预定义类型SYS_REFCURSOR的变量或定义REF CURSOR类型，然后声明该类型的变量。打开游标变量后，可以使用FETCH语句获取查询结果集的行。您可以为PL / SQL游标变量分配另一个PL / SQL游标变量或主机游标变量的值。与游标变量关联的查询可以引用其范围中的任何变量。您可以使用游标变量作为子程序参数，这使得它可以在子程序之间传递查询结果。您可以将游标变量用作主变量，这使得在PL / SQL存储的子程序及其客户端之间传递查询结果非常有用。">游标变量</a></p>
                  </li>
                  <li>
                     <p><a href="static-sql.html#GUID-77FF2850-F338-4C77-9577-0FE3399D39BA" title="CURSOR表达式返回嵌套游标。">CURSOR表达式</a></p>
                  </li>
                  <li>
                     <p><a href="static-sql.html#GUID-218080C2-A7C5-42CC-B34E-A08A0C9341C1" title="事务处理是Oracle数据库功能，允许多个用户同时处理数据库，并确保每个用户看到一致的数据版本，并确保以正确的顺序应用所有更改。">交易处理和控制</a></p>
                  </li>
                  <li>
                     <p><a href="static-sql.html#GUID-BC564905-51F4-4ADB-B300-9F15B1AC3099" title="自治事务是由另一个事务（主事务）启动的独立事务。">自治交易</a></p>
                  </li>
               </ul>
               <div class="infoboxnotealso" id="GUID-A2E4086F-94DC-4CC7-9E4B-30285BEC3313__GUID-CCA1F5D9-AC64-4312-AE51-5719B87520F0">
                  <p class="notep1">也可以看看：</p>
                  <p><span class="q">“ <a href="plsql-name-resolution.html#GUID-0D18B5E5-A6F7-45B7-A1FA-F7D930C6999C">静态SQL语句中的名称解析</a> ”</span></p>
               </div>
            </div><a id="LNPLS454"></a><a id="LNPLS00601"></a><div class="props_rev_3"><a id="GUID-54ABD9E3-EA4D-4C60-A84A-021925501C0C" name="GUID-54ABD9E3-EA4D-4C60-A84A-021925501C0C"></a><h3 id="LNPLS-GUID-54ABD9E3-EA4D-4C60-A84A-021925501C0C" class="sect3"><span class="enumeration_section">6.1</span>静态SQL的描述</h3>
               <div>
                  <p>除非另有说明，否则静态SQL具有与SQL相同的语法。</p>
                  <div class="section">
                     <p class="subhead2" id="GUID-54ABD9E3-EA4D-4C60-A84A-021925501C0C__GUID-42035B6D-1782-4CF7-BE39-E23FEE6AD318">话题</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="static-sql.html#GUID-A22B737E-68B3-47A5-8EB3-3EDC53D8571D">声明</a></p>
                        </li>
                        <li>
                           <p><a href="static-sql.html#GUID-A0B54A7B-FBBB-48EF-8D3C-BD92CC7FF4C6" title="伪列的行为类似于表列，但它不存储在表中。">伪列</a></p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
               </div><a id="LNPLS455"></a><a id="LNPLS99878"></a><div class="props_rev_3"><a id="GUID-A22B737E-68B3-47A5-8EB3-3EDC53D8571D" name="GUID-A22B737E-68B3-47A5-8EB3-3EDC53D8571D"></a><h4 id="LNPLS-GUID-A22B737E-68B3-47A5-8EB3-3EDC53D8571D" class="sect4"><span class="enumeration_section">6.1.1</span>声明</h4>
                  <div>
                     <p>这些是PL / SQL静态SQL语句，它们具有与相应SQL语句相同的语法，除非另有说明：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">SELECT</code> （此语句也称为<span class="bold">查询</span> ）</p>
                           <p>有关PL / SQL语法，请参阅<span class="q">“ <a href="SELECT-INTO-statement.html#GUID-6E14E04D-4344-45F3-BE80-979DD26C7A90" title="SELECT INTO语句从一个或多个数据库表中检索值（如SQL SELECT语句所做的那样）并将它们存储在变量中（SQL SELECT语句不这样做）。">SELECT INTO语句</a> ”</span> 。
                           </p>
                        </li>
                        <li>
                           <p>数据操作语言（DML）语句：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">插入</code></p>
                                 <p>有关PL / SQL语法，请参阅<span class="q">“ <a href="INSERT-statement-extension.html#GUID-D81224C4-06DE-4635-A850-41D29D4A8E1B" title="SQL INSERT语句的PL / SQL扩展允许您在single_table_insert的values_clause中指定记录名，而不是在insert_into_clause中指定列列表">INSERT语句扩展</a> ”</span> 。
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">UPDATE</code></p>
                                 <p>有关PL / SQL语法，请参阅<span class="q">“ <a href="UPDATE-statement-extensions.html#GUID-8FA29ACC-5E0F-4BE1-BC33-2B882C87E36D">UPDATE语句扩展</a> ”</span> 。
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">删除</code></p>
                                 <p>有关PL / SQL语法，请参阅<span class="q">“ <a href="DELETE-statement-extension.html#GUID-9BEEC5E0-EF77-4E88-9DD4-B9BA1EABABCF" title="SQL DELETE语句的where_clause的PL / SQL扩展允许您指定CURRENT OF子句，该子句将DELETE语句限制为指定游标的当前行。">DELETE语句扩展</a> ”</span> 。
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">MERGE</code> （有关语法，请参阅<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/lnpls&amp;id=SQLRF01606" target="_blank"><span class="italic">Oracle数据库SQL语言参考</span></a> ）</p>
                              </li>
                           </ul>
                           <div class="infoboxnote" id="GUID-A22B737E-68B3-47A5-8EB3-3EDC53D8571D__GUID-4C5BCA30-28A7-415C-8678-AA636907106B">
                              <p class="notep1">注意：</p>
                              <p><a href="../sqlrf/Types-of-SQL-Statements.html#SQLRF30042" target="_blank"><span class="italic">Oracle数据库SQL语言参考以</span></a>不同方式定义DML。
                              </p>
                           </div>
                        </li>
                        <li>
                           <p>事务控制语言（TCL）语句：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">COMMIT</code> （有关语法，请参阅<a href="../sqlrf/COMMIT.html#SQLRF01110" target="_blank"><span class="italic">Oracle数据库SQL语言参考</span></a> ）</p>
                              </li>
                              <li>
                                 <p><code class="codeph">ROLLBACK</code> （有关语法，请参阅<a href="../sqlrf/ROLLBACK.html#SQLRF01610" target="_blank"><span class="italic">Oracle数据库SQL语言参考</span></a> ）</p>
                              </li>
                              <li>
                                 <p><code class="codeph">SAVEPOINT</code> （有关语法，请参阅<a href="../sqlrf/SAVEPOINT.html#SQLRF01701" target="_blank"><span class="italic">Oracle数据库SQL语言参考</span></a> ）</p>
                              </li>
                              <li>
                                 <p><code class="codeph">SET</code> <code class="codeph">TRANSACTION</code> （有关语法，请参阅<a href="../sqlrf/SET-TRANSACTION.html#SQLRF01705" target="_blank"><span class="italic">Oracle数据库SQL语言参考</span></a> ）</p>
                              </li>
                           </ul>
                        </li>
                        <li>
                           <p><code class="codeph">LOCK</code> <code class="codeph">TABLE</code> （有关语法，请参阅<a href="../sqlrf/LOCK-TABLE.html#SQLRF01605" target="_blank"><span class="italic">Oracle数据库SQL语言参考</span></a> ）</p>
                        </li>
                     </ul>
                     <p>PL / SQL静态SQL语句可以具有PL / SQL标识符，只要其SQL副本可以具有绑定变量的占位符。PL / SQL标识符必须标识变量或形式参数。</p>
                     <p>要对表名，列名等使用PL / SQL标识符，请使用<span class="q">“本<a href="dynamic-sql.html#GUID-D2613968-6660-4AA2-9057-28E425A3040D" title="本机动态SQL使用EXECUTE IMMEDIATE语句处理大多数动态SQL语句。">机动态SQL</a> ”中</span>说明的<code class="codeph">EXECUTE</code> <code class="codeph">IMMEDIATE</code>语句。</p>
                     <div class="infoboxnote" id="GUID-A22B737E-68B3-47A5-8EB3-3EDC53D8571D__GUID-492EA28F-D11F-430E-8649-DF7A1D03232F">
                        <p class="notep1">注意：</p>
                        <p>在PL / SQL代码运行DML语句之后，某些变量的值是未定义的。例如：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>在<code class="codeph">FETCH</code>或<code class="codeph">SELECT</code>语句引发异常之后，该语句之后的define变量的值是未定义的。
                              </p>
                           </li>
                           <li>
                              <p>在影响零行的DML语句之后， <code class="codeph">OUT</code>绑定变量的值是未定义的，除非DML语句是<code class="codeph">BULK</code>或多行操作。
                              </p>
                           </li>
                        </ul>
                     </div>
                     <div class="example" id="GUID-A22B737E-68B3-47A5-8EB3-3EDC53D8571D__BABIEJGE">
                        <p class="titleinexample">示例6-1静态SQL语句</p>
                        <p>在此示例中，PL / SQL匿名块声明了三个PL / SQL变量，并在静态SQL语句<code class="codeph">INSERT</code> ， <code class="codeph">UPDATE</code> ， <code class="codeph">DELETE</code>使用它们。该块还使用静态SQL语句<code class="codeph">COMMIT</code> 。</p><pre class="oac_no_warn" dir="ltr">DROP TABLE employees_temp; CREATE TABLE employees_temp AS SELECT employee_id，first_name，last_name FROM employees; DECLARE emp_id employees_temp.employee_id％TYPE：= 299; emp_first_name employees_temp.first_name％TYPE：='Bob'; emp_last_name employees_temp.last_name％TYPE：='Henry'; BEGIN <span class="bold">INSERT</span> INTO employees_temp（employee_id，first_name，last_name）VALUES（ <span class="bold">emp_id</span> ， <span class="bold">emp_first_name</span> ， <span class="bold">emp_last_name</span> ）; <span class="bold">UPDATE</span> employees_temp SET first_name ='Robert'WHERER employee_id = <span class="bold">emp_id</span> ; <span class="bold">DELETE</span> FROM employees_temp WHERE employee_id = <span class="bold">emp_id</span> <span class="bold">RETURNING</span> first_name，last_name INTO <span class="bold">emp_first_name</span> ， <span class="bold">emp_last_name</span> ; <span class="bold">COMMIT</span> ; DBMS_OUTPUT.PUT_LINE（emp_first_name ||''|| emp_last_name）;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">罗伯特亨利</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="LNPLS00611"></a><div class="props_rev_3"><a id="GUID-A0B54A7B-FBBB-48EF-8D3C-BD92CC7FF4C6" name="GUID-A0B54A7B-FBBB-48EF-8D3C-BD92CC7FF4C6"></a><h4 id="LNPLS-GUID-A0B54A7B-FBBB-48EF-8D3C-BD92CC7FF4C6" class="sect4"><span class="enumeration_section">6.1.2</span>伪列</h4>
                  <div>
                     <p>伪列的行为类似于表列，但它不存储在表中。</p>
                     <p>有关伪列的一般信息（包括限制），请参见<a href="../sqlrf/Pseudocolumns.html#SQLRF0025" target="_blank"><span class="italic">Oracle数据库SQL语言参考</span></a> 。
                     </p>
                     <p>静态SQL包括以下SQL伪列：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">CURRVAL</code>和<code class="codeph">NEXTVAL</code> ，在<span class="q">“ <a href="static-sql.html#GUID-68348EB4-62D0-4D86-A056-8BDC0CB50187" title="创建序列后，可以使用CURRVAL伪列访问SQL语句中的值，该伪列返回序列的当前值，或NEXTVAL伪列，它会递增序列并返回新值。">PL / SQL中的CURRVAL和NEXTVAL</a> ”中描述</span> 。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">LEVEL</code> ，在<a href="../sqlrf/Hierarchical-Query-Pseudocolumns.html#SQLRF50942" target="_blank"><span class="italic">Oracle数据库SQL语言参考中</span></a>描述</p>
                        </li>
                        <li>
                           <p><code class="codeph">OBJECT_VALUE</code> ，在<a href="../sqlrf/OBJECT_VALUE-Pseudocolumn.html#SQLRF50952" target="_blank"><span class="italic">Oracle数据库SQL语言参考中</span></a>描述</p>
                           <div class="infoboxnotealso" id="GUID-A0B54A7B-FBBB-48EF-8D3C-BD92CC7FF4C6__GUID-4879ECB2-5EBD-47A7-B80D-3526D1531E2F">
                              <p class="notep1">也可以看看：</p>
                              <p><span class="q">“ <a href="plsql-triggers.html#GUID-C42CC16B-EAC1-4093-85C8-6359D08C912F">OBJECT_VALUE Pseudocolumn</a> ”</span>有关在触发器中使用<code class="codeph">OBJECT_VALUE</code>信息</p>
                           </div>
                        </li>
                        <li>
                           <p><code class="codeph">ROWID</code> ，在<a href="../sqlrf/ROWID-Pseudocolumn.html#SQLRF00254" target="_blank"><span class="italic">Oracle数据库SQL语言参考中</span></a>描述</p>
                           <div class="infoboxnotealso" id="GUID-A0B54A7B-FBBB-48EF-8D3C-BD92CC7FF4C6__GUID-E2BF1953-13E8-4C78-B636-9AE92081B1A6">
                              <p class="notep1">也可以看看：</p>
                              <p><span class="q">“ <a href="static-sql.html#GUID-E9A9E94A-9E63-42E0-A4DC-F25E9B7A23B9">使用ROWID Pseudocolumn模拟CURRENT OF子句</a> ”</span></p>
                           </div>
                        </li>
                        <li>
                           <p><code class="codeph">ROWNUM</code> ，在<a href="../sqlrf/ROWNUM-Pseudocolumn.html#SQLRF00255" target="_blank"><span class="italic">Oracle数据库SQL语言参考中</span></a>描述</p>
                        </li>
                     </ul>
                  </div><a id="LNPLS512"></a><a id="LNPLS00610"></a><div class="props_rev_3"><a id="GUID-68348EB4-62D0-4D86-A056-8BDC0CB50187" name="GUID-68348EB4-62D0-4D86-A056-8BDC0CB50187"></a><h5 id="LNPLS-GUID-68348EB4-62D0-4D86-A056-8BDC0CB50187" class="sect5"><span class="enumeration_section">6.1.2.1</span> PL / SQL中的CURRVAL和NEXTVAL</h5>
                     <div>
                        <p>创建序列后，可以使用<code class="codeph">CURRVAL</code>伪列访问SQL语句中的值，该伪列返回序列的当前值，或<code class="codeph">NEXTVAL</code>伪列，它会递增序列并返回新值。
                        </p>
                        <p>要引用这些伪列，请使用点表示法 - 例如<span class="italic"><code class="codeph">sequence_name</code></span> 。<code class="codeph">CURRVAL</code> 。</p>
                        <div class="infoboxnote" id="GUID-68348EB4-62D0-4D86-A056-8BDC0CB50187__GUID-CD274D00-0FA6-43E3-B66B-1CC5A40B1A08">
                           <p class="notep1">注意：</p>
                           <p>每次引用<span class="italic"><code class="codeph">sequence_name</code></span> 。<code class="codeph">NEXTVAL</code> ，无论您提交还是回滚交易，序列都会立即永久递增。
                           </p>
                        </div>
                        <p>您可以使用<span class="italic"><code class="codeph">sequence_name</code></span> 。<code class="codeph">CURRVAL</code>和<span class="italic"><code class="codeph">sequence_name</code></span> 。只要您可以使用<code class="codeph">NUMBER</code>表达式，就可以在PL / SQL表达式中使用<code class="codeph">NEXTVAL</code> 。然而：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>使用<span class="italic"><code class="codeph">sequence_name</code></span> 。<code class="codeph">CURRVAL</code>或<span class="italic"><code class="codeph">sequence_name</code></span> 。<code class="codeph">NEXTVAL</code>为ADT方法参数提供默认值会导致编译错误。
                              </p>
                           </li>
                           <li>
                              <p>PL / SQL计算每次出现的<span class="italic"><code class="codeph">sequence_name</code></span> 。<code class="codeph">CURRVAL</code>和<span class="italic"><code class="codeph">sequence_name</code></span> 。<code class="codeph">NEXTVAL</code> （与SQL不同，它会为出现的每一行计算序列表达式）。
                              </p>
                           </li>
                        </ul>
                        <div class="infoboxnotealso" id="GUID-68348EB4-62D0-4D86-A056-8BDC0CB50187__GUID-E343B5C4-8B0D-4646-A4AF-7899196288DC">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><a href="../sqlrf/CREATE-SEQUENCE.html#SQLRF01314" target="_blank"><span class="italic">Oracle Database SQL语言参考</span></a> ，了解有关序列的一般信息</p>
                              </li>
                              <li>
                                 <p>适用于<code class="codeph">CURRVAL</code>和<code class="codeph">NEXTVAL</code> <a href="../sqlrf/Sequence-Pseudocolumns.html#SQLRF00253" target="_blank"><span class="italic">Oracle数据库SQL语言参考</span></a>完整语法</p>
                              </li>
                           </ul>
                        </div>
                        <div class="example" id="GUID-68348EB4-62D0-4D86-A056-8BDC0CB50187__BABDDFGI">
                           <p class="titleinexample">例6-2 CURRVAL和NEXTVAL伪列</p>
                           <p>此示例为序列<code class="codeph">HR.EMPLOYEES_SEQ</code>生成序列号，并在多个语句中引用该数字。
                           </p><pre class="oac_no_warn" dir="ltr">DROP TABLE employees_temp; CREATE TABLE employees_temp AS SELECT employee_id，first_name，last_name FROM employees; DROP TABLE employees_temp2; CREATE TABLE employees_temp2 AS SELECT employee_id，first_name，last_name FROM employees; DECLARE seq_value NUMBER; BEGIN <span class="bold">- 生成初始序列号</span> seq_value：= <span class="bold">employees_seq。NEXTVAL</span> ; - 打印初始序列号：DBMS_OUTPUT.PUT_LINE（'初始序列值：'|| TO_CHAR（seq_value））; <span class="bold">- 插入数据时使用NEXTVAL创建唯一编号：</span> INSERT INTO employees_temp（employee_id，first_name，last_name）VALUES（ <span class="bold">employees_seq。NEXTVAL</span> ，'Lynette'，'史密斯'）; <span class="bold">- 使用CURRVAL在其他地方存储相同的值：</span> INSERT INTO employees_temp2 VALUES（ <span class="bold">employees_seq。CURRVAL</span> ，'摩根'，'史密斯'）; / *由于NEXTVAL值可能被不同的用户和应用程序引用，并且某些NEXTVAL值可能未存储在数据库中，因此可能存在序列间隙。* / <span class="bold">- 使用CURRVAL指定要删除的记录：</span> seq_value：= <span class="bold">employees_seq。CURRVAL</span> ; DELETE FROM employees_temp2 WHERE employee_id = seq_value; <span class="bold">- 使用NEXTVAL更新employee_id以获取指定记录：</span> UPDATE employees_temp SET employee_id = <span class="bold">employees_seq。NEXTVAL</span> WHERE first_name ='Lynette'和last_name ='Smith'; <span class="bold">- 显示CURRVAL的最终值：</span> seq_value：= <span class="bold">employees_seq。CURRVAL</span> ; DBMS_OUTPUT.PUT_LINE（'结束序列值：'|| TO_CHAR（seq_value））;结束; /</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div>
               </div>
            </div><a id="LNPLS00602"></a><div class="props_rev_3"><a id="GUID-F1FE15F9-5C96-4C4E-B240-B7363D25A8F1" name="GUID-F1FE15F9-5C96-4C4E-B240-B7363D25A8F1"></a><h3 id="LNPLS-GUID-F1FE15F9-5C96-4C4E-B240-B7363D25A8F1" class="sect3"><span class="enumeration_section">6.2</span>游标概述</h3>
               <div>
                  <p><span class="bold">游标</span>是指向私有SQL区域的指针，该区域存储有关处理特定<code class="codeph">SELECT</code>或DML语句的信息。
                  </p>
                  <div class="infoboxnote" id="GUID-F1FE15F9-5C96-4C4E-B240-B7363D25A8F1__GUID-4244A2F2-6C24-4E81-8271-9E17BE532025">
                     <p class="notep1">注意：</p>
                     <p>本主题解释的游标是会话游标。<span class="bold">会话游标</span>位于会话内存中，直到会话结束，此时它不再存在。
                     </p>
                  </div>
                  <p>由PL / SQL构造和管理的<span class="bold">游标</span>是<span class="bold">隐式游标</span> 。您构造和管理的<span class="bold">游标</span>是<span class="bold">显式游标</span> 。
                  </p>
                  <p>您可以从其属性中获取有关任何会话游标的信息（可以在过程语句中引用，但不能在SQL语句中引用）。</p>
                  <p>要列出每个用户会话当前已打开和解析的会话游标，请查询动态性能视图<code class="codeph">V$OPEN_CURSOR</code> 。</p>
                  <p>会话可以同时打开的游标数由以下因素决定：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>会话可用的内存量</p>
                     </li>
                     <li>
                        <p>初始化参数<code class="codeph">OPEN_CURSORS</code>的值</p>
                     </li>
                  </ul>
                  <div class="infoboxnote" id="GUID-F1FE15F9-5C96-4C4E-B240-B7363D25A8F1__GUID-ACE515DD-F096-46B3-A049-7C0864ABAB0F">
                     <p class="notep1">注意：</p>
                     <p>通常，PL / SQL仅在会话第一次打开时解析显式游标，并仅在语句第一次运行时解析SQL语句（创建隐式游标）。</p>
                     <p>缓存所有已解析的SQL语句。仅当SQL语句通过新SQL语句从缓存中老化时才会重新解析它。虽然必须先关闭显式游标才能重新打开它，但PL / SQL不需要重新分析关联的查询。如果关闭并立即重新打开显式游标，则PL / SQL不会重新分析关联的查询。</p>
                  </div>
                  <p>话题</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="static-sql.html#GUID-596C1961-5A94-40ED-9920-668BB05632C5">隐含游标</a></p>
                     </li>
                     <li>
                        <p><a href="static-sql.html#GUID-89E0242F-42AC-4B21-9DF1-ACD6F4FC03B9">显式游标</a></p>
                     </li>
                  </ul>
                  <div class="infoboxnotealso" id="GUID-F1FE15F9-5C96-4C4E-B240-B7363D25A8F1__GUID-5583E783-B15B-4DF4-BA25-EC5BE962CFA5">
                     <p class="notep1">也可以看看：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>有关动态性能视图<code class="codeph">V$OPEN_CURSOR</code>信息，请<a href="../refrn/V-OPEN_CURSOR.html#REFRN30166" target="_blank"><span class="italic">参见Oracle数据库参考</span></a></p>
                        </li>
                        <li>
                           <p>有关初始化参数<code class="codeph">OPEN_CURSORS</code>信息，请<a href="../refrn/OPEN_CURSORS.html#REFRN10137" target="_blank"><span class="italic">参见Oracle数据库参考</span></a></p>
                        </li>
                     </ul>
                  </div>
               </div><a id="LNPLS99957"></a><div class="props_rev_3"><a id="GUID-596C1961-5A94-40ED-9920-668BB05632C5" name="GUID-596C1961-5A94-40ED-9920-668BB05632C5"></a><h4 id="LNPLS-GUID-596C1961-5A94-40ED-9920-668BB05632C5" class="sect4"><span class="enumeration_section">6.2.1</span>隐式游标</h4>
                  <div>
                     <p><span class="bold">隐式游标</span>是由PL / SQL构造和管理的会话游标。每次运行<code class="codeph">SELECT</code>或DML语句时，PL / SQL都会打开一个隐式游标。您无法控制隐式游标，但可以从其属性中获取信息。
                     </p>
                     <p>隐式游标属性值的语法是<code class="codeph">SQL</code> <span class="italic"><code class="codeph">attribute</code></span> （因此，隐式游标也称为<span class="bold">SQL游标</span> ）。<code class="codeph">SQL</code> <span class="italic"><code class="codeph">attribute</code></span>始终引用最近运行的<code class="codeph">SELECT</code>或DML语句。如果没有运行此类语句，则<code class="codeph">SQL</code> <span class="italic"><code class="codeph">attribute</code></span>值为<code class="codeph">NULL</code> 。</p>
                     <p>隐式游标在其关联语句运行后关闭;但是，在另一个<code class="codeph">SELECT</code>或DML语句运行之前，其属性值仍然可用。
                     </p>
                     <p>最近运行的<code class="codeph">SELECT</code>或DML语句可能位于不同的范围内。要保存属性值以供以后使用，请立即将其分配给本地变量。否则，其他操作（如子程序调用）可能会在您测试之前更改属性的值。
                     </p>
                     <p>隐式游标属性是：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="static-sql.html#GUID-122BA765-31BB-4BA5-AEF7-F7EAD3960AF5">SQL％ISOPEN属性：光标是否打开？</a></p>
                        </li>
                        <li>
                           <p><a href="static-sql.html#GUID-5C2BBA53-40E2-4BF4-9924-20845A9FB4B8">SQL％FOUND属性：是否受到任何影响？</a></p>
                        </li>
                        <li>
                           <p><a href="static-sql.html#GUID-87C3CAFD-625D-4785-A32F-14E2440335DC">SQL％NOTFOUND属性：没有行受影响？</a></p>
                        </li>
                        <li>
                           <p><a href="static-sql.html#GUID-0C789D68-82D8-4896-97BF-AF2356B9C8D5">SQL％ROWCOUNT属性：受影响的行数是多少？</a></p>
                        </li>
                        <li>
                           <p><code class="codeph">SQL%BULK_ROWCOUNT</code> （请参阅<span class="q">“ <a href="plsql-optimization-and-tuning.html#GUID-DDB5CCDA-8060-4511-BA20-4D1F2C478412" title="FORALL语句完成后，您可以从隐式游标属性SQL％BULK_ROWCOUNT获取每个DML语句影响的行数。">获取受FORALL语句影响的行数</a> ”</span></p>
                        </li>
                        <li>
                           <p><code class="codeph">SQL%BULK_EXCEPTIONS</code> （请参阅<span class="q">“ <a href="plsql-optimization-and-tuning.html#GUID-DAF46F06-EF3F-4B1A-A518-5238B80C69FA" title="要允许FORALL语句继续，即使它的某些DML语句失败，也包括SAVE EXCEPTIONS子句。当DML语句失败时，PL / SQL不会引发异常;相反，它保存了有关失败的信息。FORALL语句完成后，PL / SQL为FORALL语句（ORA-24381）引发一个异常。">处理FORALL语句完成后的FORALL异常</a> ”</span></p>
                        </li>
                     </ul>
                     <div class="infoboxnotealso" id="GUID-596C1961-5A94-40ED-9920-668BB05632C5__GUID-1B7BAB86-1B59-4C39-BBF2-0214DC309676">
                        <p class="notep1">也可以看看：</p>
                        <p>完整语法和语义的<span class="q">“ <a href="implicit-cursor-attribute.html#GUID-5A938EE7-E8D2-468C-B60F-81898F110BE1" title="隐式游标具有返回有关最近运行的SELECT或DML语句的信息的属性，该语句与命名游标无关。">隐式游标属性</a> ”</span></p>
                     </div>
                  </div><a id="LNPLS526"></a><div class="props_rev_3"><a id="GUID-122BA765-31BB-4BA5-AEF7-F7EAD3960AF5" name="GUID-122BA765-31BB-4BA5-AEF7-F7EAD3960AF5"></a><h5 id="LNPLS-GUID-122BA765-31BB-4BA5-AEF7-F7EAD3960AF5" class="sect5"><span class="enumeration_section">6.2.1.1</span> SQL％ISOPEN属性：光标是否打开？
                     </h5>
                     <div>
                        <p><code class="codeph">SQL%ISOPEN</code>始终返回<code class="codeph">FALSE</code> ，因为隐式游标在其关联语句运行后始终关闭。
                        </p>
                     </div>
                  </div><a id="LNPLS525"></a><a id="LNPLS524"></a><div class="props_rev_3"><a id="GUID-5C2BBA53-40E2-4BF4-9924-20845A9FB4B8" name="GUID-5C2BBA53-40E2-4BF4-9924-20845A9FB4B8"></a><h5 id="LNPLS-GUID-5C2BBA53-40E2-4BF4-9924-20845A9FB4B8" class="sect5"><span class="enumeration_section">6.2.1.2</span> SQL％FOUND属性：是否受到任何影响？
                     </h5>
                     <div>
                        <p><code class="codeph">SQL%FOUND</code>返回：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>如果没有运行<code class="codeph">SELECT</code>或DML语句，则为<code class="codeph">NULL</code></p>
                           </li>
                           <li>
                              <p>如果<code class="codeph">SELECT</code>语句返回一行或多行或DML语句影响一行或多行，则为<code class="codeph">TRUE</code></p>
                           </li>
                           <li>
                              <p>否则为<code class="codeph">FALSE</code></p>
                           </li>
                        </ul>
                        <p><a href="static-sql.html#GUID-5C2BBA53-40E2-4BF4-9924-20845A9FB4B8__BABJGHAI">示例6-3</a>使用<code class="codeph">SQL%FOUND</code>确定<code class="codeph">DELETE</code>语句是否影响任何行。
                        </p>
                        <div class="example" id="GUID-5C2BBA53-40E2-4BF4-9924-20845A9FB4B8__BABJGHAI">
                           <p class="titleinexample">示例6-3 SQL％FOUND隐式游标属性</p><pre class="oac_no_warn" dir="ltr">DROP TABLE dept_temp; CREATE TABLE dept_temp AS SELECT * FROM departments;创建或替换过程p（dept_no NUMBER）AUTHID CURRENT_USER从dept_temp开始删除WHERE department_id = dept_no;如果<span class="bold">SQL％找到</span> DBMS_OUTPUT.PUT_LINE（'删除部门号成功'|| dept_no）; ELSE DBMS_OUTPUT.PUT_LINE（'无部门编号'|| dept_no）;万一;结束; / BEGIN p（270）; P（400）;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">删除部门号码270没有部门号码400</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="LNPLS527"></a><div class="props_rev_3"><a id="GUID-87C3CAFD-625D-4785-A32F-14E2440335DC" name="GUID-87C3CAFD-625D-4785-A32F-14E2440335DC"></a><h5 id="LNPLS-GUID-87C3CAFD-625D-4785-A32F-14E2440335DC" class="sect5"><span class="enumeration_section">6.2.1.3</span> SQL％NOTFOUND属性：没有行受影响？
                     </h5>
                     <div>
                        <p><code class="codeph">SQL%NOTFOUND</code> （与<code class="codeph">SQL%FOUND</code>逻辑相反）返回：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>如果没有运行<code class="codeph">SELECT</code>或DML语句，则为<code class="codeph">NULL</code></p>
                           </li>
                           <li>
                              <p>如果<code class="codeph">SELECT</code>语句返回一行或多行或DML语句影响一行或多行，则为<code class="codeph">FALSE</code></p>
                           </li>
                           <li>
                              <p>否则为<code class="codeph">TRUE</code></p>
                           </li>
                        </ul>
                        <p><code class="codeph">SQL%NOTFOUND</code>属性对PL / SQL <code class="codeph">SELECT</code> <code class="codeph">INTO</code>语句没有用，因为：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>如果<code class="codeph">SELECT</code> <code class="codeph">INTO</code>语句没有返回任何行，PL / SQL会立即引发预定义的异常<code class="codeph">NO_DATA_FOUND</code> ，然后才能检查<code class="codeph">SQL%NOTFOUND</code> 。</p>
                           </li>
                           <li>
                              <p>调用SQL聚合函数的<code class="codeph">SELECT</code> <code class="codeph">INTO</code>语句始终返回一个值（可能为<code class="codeph">NULL</code> ）。在这样的语句之后， <code class="codeph">SQL%NOTFOUND</code>属性总是为<code class="codeph">FALSE</code> ，因此检查它是不必要的。
                              </p>
                           </li>
                        </ul>
                     </div>
                  </div><a id="LNPLS529"></a><a id="LNPLS528"></a><div class="props_rev_3"><a id="GUID-0C789D68-82D8-4896-97BF-AF2356B9C8D5" name="GUID-0C789D68-82D8-4896-97BF-AF2356B9C8D5"></a><h5 id="LNPLS-GUID-0C789D68-82D8-4896-97BF-AF2356B9C8D5" class="sect5"><span class="enumeration_section">6.2.1.4</span> SQL％ROWCOUNT属性：受影响的行数是多少？
                     </h5>
                     <div>
                        <p><code class="codeph">SQL%ROWCOUNT</code>返回：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>如果没有运行<code class="codeph">SELECT</code>或DML语句，则为<code class="codeph">NULL</code></p>
                           </li>
                           <li>
                              <p>否则， <code class="codeph">SELECT</code>语句返回的行数或受DML语句（ <code class="codeph">INTEGER</code> ）影响的行数</p>
                           </li>
                        </ul>
                        <div class="infoboxnote" id="GUID-0C789D68-82D8-4896-97BF-AF2356B9C8D5__GUID-6AB908BC-FED4-473E-B060-2AA2BF821667">
                           <p class="notep1">注意：</p>
                           <p>如果服务器是Oracle Database 12c或更高版本且其客户端是Oracle Database 11g第2版或更早版本（或反向），则<code class="codeph">SQL%ROWCOUNT</code>返回的最大数量为4,294,967,295。
                           </p>
                        </div>
                        <p><a href="static-sql.html#GUID-0C789D68-82D8-4896-97BF-AF2356B9C8D5__BABJCAAG">示例6-4</a>使用<code class="codeph">SQL%ROWCOUNT</code>来确定已删除的行数。
                        </p>
                        <p>如果没有<code class="codeph">BULK</code> <code class="codeph">COLLECT</code>子句的<code class="codeph">SELECT</code> <code class="codeph">INTO</code>语句返回多行，PL / SQL将引发预定义的异常<code class="codeph">TOO_MANY_ROWS</code>并且<code class="codeph">SQL%ROWCOUNT</code>返回1，而不是满足查询的实际行数。
                        </p>
                        <p><code class="codeph">SQL%ROWCOUNT</code>属性的值与事务的状态无关。因此：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>当事务回滚到保存点时， <code class="codeph">SQL%ROWCOUNT</code>的值不会恢复为保存点之前的值。
                              </p>
                           </li>
                           <li>
                              <p>自治事务结束时， <code class="codeph">SQL%ROWCOUNT</code>不会还原为父事务中的原始值。
                              </p>
                           </li>
                        </ul>
                        <div class="example" id="GUID-0C789D68-82D8-4896-97BF-AF2356B9C8D5__BABJCAAG">
                           <p class="titleinexample">示例6-4 SQL％ROWCOUNT隐式游标属性</p><pre class="oac_no_warn" dir="ltr">DROP TABLE employees_temp; CREATE TABLE employees_temp AS SELECT * FROM employees; DECLARE mgr_no NUMBER（6）：= 122; BEGIN DELETE FROM employees_temp WHERE manager_id = mgr_no; DBMS_OUTPUT.PUT_LINE（'删除的员工数：'|| TO_CHAR（ <span class="bold">SQL％ROWCOUNT</span> ））;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">被删除的员工人数：8</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div>
               </div><a id="LNPLS456"></a><a id="LNPLS99956"></a><div class="props_rev_3"><a id="GUID-89E0242F-42AC-4B21-9DF1-ACD6F4FC03B9" name="GUID-89E0242F-42AC-4B21-9DF1-ACD6F4FC03B9"></a><h4 id="LNPLS-GUID-89E0242F-42AC-4B21-9DF1-ACD6F4FC03B9" class="sect4"><span class="enumeration_section">6.2.2</span>显式游标</h4>
                  <div>
                     <p><span class="bold">显式游标</span>是您构造和管理的会话游标。您必须声明并定义显式游标，为其指定名称并将其与查询相关联（通常，查询返回多行）。然后，您可以通过以下任一方式处理查询结果集：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>打开显式游标（使用<code class="codeph">OPEN</code>语句），从结果集中获取行（使用<code class="codeph">FETCH</code>语句），然后关闭显式游标（使用<code class="codeph">CLOSE</code>语句）。
                           </p>
                        </li>
                        <li>
                           <p>在游标<code class="codeph">FOR</code> <code class="codeph">LOOP</code>语句中使用显式游标（请参阅<span class="q">“ <a href="static-sql.html#GUID-25917214-FD91-499D-AB39-CE21484AB167" title="游标FOR LOOP语句允许您运行SELECT语句，然后立即循环遍历结果集的行。">使用光标处理查询结果集以获取LOOP语句</a> ”）</span> 。
                           </p>
                        </li>
                     </ul>
                     <p>您不能为显式游标指定值，在表达式中使用它，或将其用作正式子程序参数或主机变量。您<span class="italic">可以</span>使用游标变量执行这些操作（请参阅<span class="q">“ <a href="static-sql.html#GUID-4A6E054A-4002-418D-A1CA-DE849CD7E6D5" title="要创建游标变量，请声明预定义类型SYS_REFCURSOR的变量或定义REF CURSOR类型，然后声明该类型的变量。打开游标变量后，可以使用FETCH语句获取查询结果集的行。您可以为PL / SQL游标变量分配另一个PL / SQL游标变量或主机游标变量的值。与游标变量关联的查询可以引用其范围中的任何变量。您可以使用游标变量作为子程序参数，这使得它可以在子程序之间传递查询结果。您可以将游标变量用作主变量，这使得在PL / SQL存储的子程序及其客户端之间传递查询结果非常有用。">游标变量</a> ”</span> ）。
                     </p>
                     <p>与隐式游标不同，您可以通过名称引用显式游标或游标变量。因此，显式游标或游标变量称为<span class="bold">命名游标</span> 。
                     </p>
                     <div class="section">
                        <p class="subhead3" id="GUID-89E0242F-42AC-4B21-9DF1-ACD6F4FC03B9__GUID-A960C139-C552-48A5-BFCE-80F4D29B3BF4">话题</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="static-sql.html#GUID-05C186C1-147E-4DA6-8133-F42B24C73ADA">声明和定义显式游标</a></p>
                           </li>
                           <li>
                              <p><a href="static-sql.html#GUID-3FD3219B-E28D-47D0-A447-812C758BCDFB">打开和关闭显式游标</a></p>
                           </li>
                           <li>
                              <p><a href="static-sql.html#GUID-9DEED64C-A87E-4EAD-97DA-ABDD3FDF172C">使用显式游标获取数据</a></p>
                           </li>
                           <li>
                              <p><a href="static-sql.html#GUID-8E770DA2-799E-454E-9AD8-1DDBACE1E3A2">显式游标查询中的变量</a></p>
                           </li>
                           <li>
                              <p><a href="static-sql.html#GUID-2CC94B79-7D23-4456-87B0-440DF9A95D44">当显式游标查询需要列别名时</a></p>
                           </li>
                           <li>
                              <p><a href="static-sql.html#GUID-2DEFB351-F8B6-453C-AA74-86B5B99C3B20">接受参数的显式游标</a></p>
                           </li>
                           <li>
                              <p><a href="static-sql.html#GUID-D483DF0B-15DB-4466-9870-0F6E1518A40D">显式游标属性</a></p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div><a id="LNPLS532"></a><a id="LNPLS531"></a><div class="props_rev_3"><a id="GUID-05C186C1-147E-4DA6-8133-F42B24C73ADA" name="GUID-05C186C1-147E-4DA6-8133-F42B24C73ADA"></a><h5 id="LNPLS-GUID-05C186C1-147E-4DA6-8133-F42B24C73ADA" class="sect5"><span class="enumeration_section">6.2.2.1</span>声明和定义显式游标</h5>
                     <div>
                        <div class="section">
                           <p>您可以先声明一个显式游标，然后在同一个块，子程序或包中定义它，或者同时声明和定义它。</p>
                           <p><span class="bold">显式游标声明</span>仅声明游标，具有以下语法：</p><pre class="oac_no_warn" dir="ltr">CURSOR <span class="italic">cursor_name</span> [ <span class="italic">parameter_list</span> ] RETURN <span class="italic">return_type</span> ;</pre><p><span class="bold">显式游标定义</span>具有以下语法：</p><pre class="oac_no_warn" dir="ltr">CURSOR <span class="italic">cursor_name</span> [ <span class="italic">parameter_list</span> ] [RETURN <span class="italic">return_type</span> ] IS <span class="italic">select_statement</span> ;</pre><p>如果您之前声明了游标，那么显式游标定义会定义它;否则，它都声明并定义它。</p>
                           <p><a href="static-sql.html#GUID-05C186C1-147E-4DA6-8133-F42B24C73ADA__BABHICAF">例6-5</a>声明并定义了三个显式游标。
                           </p>
                           <div class="infoboxnotealso" id="GUID-05C186C1-147E-4DA6-8133-F42B24C73ADA__GUID-E69B13F7-541F-462F-93B4-91174935D8AC">
                              <p class="notep1">也可以看看：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p><span class="q">“ <a href="explicit-cursor-declaration-and-definition.html#GUID-38C5DBA3-9DEC-4AF2-9B5E-7B721D11A77C" title="An explicit cursor is a named pointer to a private SQL area that stores information for processing a specific query or DML statement—typically, one that returns or affects multiple rows.">显式游标声明和定义</a> ”，</span>用于<span class="q"><a href="explicit-cursor-declaration-and-definition.html#GUID-38C5DBA3-9DEC-4AF2-9B5E-7B721D11A77C" title="显式游标是指向私有SQL区域的命名指针，该区域存储用于处理特定查询或DML语句的信息 - 通常是返回或影响多行的语句。">显式游标声明和定义</a></span>的完整语法和语义</p>
                                 </li>
                                 <li>
                                    <p><span class="q">“ <a href="static-sql.html#GUID-2DEFB351-F8B6-453C-AA74-86B5B99C3B20">接受参数的显式游标</a> ”</span></p>
                                 </li>
                              </ul>
                           </div>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-05C186C1-147E-4DA6-8133-F42B24C73ADA__BABHICAF">
                           <p class="titleinexample">例6-5显式游标声明和定义</p><pre class="oac_no_warn" dir="ltr">DECLARE CURSOR c1 RETURN部门％ROWTYPE; - 声明c1 CURSOR c2 IS  - 声明并定义c2 SELECT employee_id，job_id，salary FROM employees WHERE salary&gt; 2000; CURSOR c1 RETURN部门％ROWTYPE IS  - 定义c1，SELECT * FROM部门 - 重复返回类型WHERE department_id = 110; CURSOR c3 RETURN位置％ROWTYPE; - 声明c3 CURSOR c3 IS  - 定义c3，SELECT * FROM位置 - 省略返回类型WHERE country_id ='JP'; BEGIN NULL;结束; /</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="LNPLS533"></a><div class="props_rev_3"><a id="GUID-3FD3219B-E28D-47D0-A447-812C758BCDFB" name="GUID-3FD3219B-E28D-47D0-A447-812C758BCDFB"></a><h5 id="LNPLS-GUID-3FD3219B-E28D-47D0-A447-812C758BCDFB" class="sect5"><span class="enumeration_section">6.2.2.2</span>打开和关闭显式游标</h5>
                     <div>
                        <div class="section">
                           <p>声明和定义显式游标后，可以使用<code class="codeph">OPEN</code>语句打开它，该语句执行以下操作：</p>
                           <ol>
                              <li>
                                 <p>分配数据库资源以处理查询</p>
                              </li>
                              <li>
                                 <p>处理查询;那是：</p>
                                 <ol type="a">
                                    <li>
                                       <p>标识结果集</p>
                                       <p>如果查询引用变量或游标参数，则它们的值会影响结果集。有关详细信息，请参阅<span class="q">“ <a href="static-sql.html#GUID-8E770DA2-799E-454E-9AD8-1DDBACE1E3A2">显式游标查询中的变量</a> ”</span>和<span class="q">“ <a href="static-sql.html#GUID-2DEFB351-F8B6-453C-AA74-86B5B99C3B20">接受参数的显式游标</a> ”</span> 。
                                       </p>
                                    </li>
                                    <li>
                                       <p>如果查询具有<code class="codeph">FOR</code> <code class="codeph">UPDATE</code>子句，则锁定结果集的行</p>
                                       <p>有关详细信息，请参阅<span class="q">“ <a href="static-sql.html#GUID-6A1C2FD9-9476-4F8D-A2E4-2C967D7F8C08">SELECT FOR UPDATE和FOR UPDATE Cursors</a> ”</span> 。
                                       </p>
                                    </li>
                                 </ol>
                              </li>
                              <li>
                                 <p>将光标定位在结果集的第一行之前</p>
                              </li>
                           </ol>
                           <p>使用<code class="codeph">CLOSE</code>语句关闭打开的显式游标，从而允许重用其资源。关闭游标后，您无法从其结果集中获取记录或引用其属性。如果您尝试，PL / SQL会引发预定义的异常<code class="codeph">INVALID_CURSOR</code> 。</p>
                           <p>您可以重新打开关闭的光标。在尝试重新打开之前，必须关闭显式游标。否则，PL / SQL会引发预定义的异常<code class="codeph">CURSOR_ALREADY_OPEN</code> 。</p>
                           <div class="infoboxnotealso" id="GUID-3FD3219B-E28D-47D0-A447-812C758BCDFB__GUID-D945F31C-5E0A-4010-A8D6-8B168E04C84A">
                              <p class="notep1">也可以看看：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p><span class="q">“ <a href="OPEN-statement.html#GUID-FB5A9CC3-655F-4AF4-8105-14CB39F2FEA8" title="OPEN语句打开显式游标，分配数据库资源以处理关联查询，标识结果集，并将光标定位在结果集的第一行之前。">OPEN语句</a> ”</span>的语法和语义</p>
                                 </li>
                                 <li>
                                    <p><span class="q">“ <a href="CLOSE-statement.html#GUID-46E7086C-8C29-4689-A062-0FF059E268FD" title="CLOSE语句关闭一个命名游标，释放其资源以供重用。">CLOSE Statement</a> ”</span>的语法和语义</p>
                                 </li>
                              </ul>
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNPLS535"></a><a id="LNPLS537"></a><a id="LNPLS534"></a><div class="props_rev_3"><a id="GUID-9DEED64C-A87E-4EAD-97DA-ABDD3FDF172C" name="GUID-9DEED64C-A87E-4EAD-97DA-ABDD3FDF172C"></a><h5 id="LNPLS-GUID-9DEED64C-A87E-4EAD-97DA-ABDD3FDF172C" class="sect5"><span class="enumeration_section">6.2.2.3</span>使用显式游标获取数据</h5>
                     <div>
                        <div class="section">
                           <p>打开显式游标后，可以使用<code class="codeph">FETCH</code>语句获取查询结果集的行。返回一行的<code class="codeph">FETCH</code>语句的基本语法是：</p><pre class="oac_no_warn" dir="ltr">FETCH <span class="italic">cursor_name</span> INTO <span class="italic">into_clause</span>
</pre><p><span class="italic"><code class="codeph">into_clause</code></span>是变量列表或单个记录变量。对于查询返回的每个列，变量列表或记录必须具有对应的类型兼容变量或字段。<code class="codeph">%TYPE</code>和<code class="codeph">%ROWTYPE</code>属性对于声明用于<code class="codeph">FETCH</code>语句的变量和记录很有用。
                           </p>
                           <p><code class="codeph">FETCH</code>语句检索结果集的当前行，将该行的列值存储到变量或记录中，并将光标前进到下一行。
                           </p>
                           <p>通常，您在<code class="codeph">LOOP</code>语句中使用<code class="codeph">FETCH</code>语句，当<code class="codeph">FETCH</code>语句用完行时，您将退出该语句。要检测此退出条件，请使用游标属性<code class="codeph">%NOTFOUND</code> （描述于<span class="q">“ <a href="static-sql.html#GUID-BC2BA7E6-EFCE-4105-8305-807074F8B6A5">％NOTFOUND属性：是否已获取行？</a>“</span> ）。当<code class="codeph">FETCH</code>语句不返回任何行时，PL / SQL不会引发异常。
                           </p>
                           <p><a href="static-sql.html#GUID-9DEED64C-A87E-4EAD-97DA-ABDD3FDF172C__BABCFDJE">例6-6</a>在<code class="codeph">LOOP</code>语句中使用<code class="codeph">FETCH</code>和<code class="codeph">%NOTFOUND</code>一次一行地获取两个显式游标的结果集。第一个<code class="codeph">FETCH</code>语句将列值检索为变量。第二个<code class="codeph">FETCH</code>语句将列值检索到记录中。变量和记录分别用<code class="codeph">%TYPE</code>和<code class="codeph">%ROWTYPE</code>声明。
                           </p>
                           <p><a href="static-sql.html#GUID-9DEED64C-A87E-4EAD-97DA-ABDD3FDF172C__CJADGBJE">例6-7</a>使用五个<code class="codeph">FETCH</code>语句将结果集的前五行读取到五个记录中，每个<code class="codeph">FETCH</code>语句获取一个不同的记录变量。记录变量使用<code class="codeph">%ROWTYPE</code>声明。</p>
                           <div class="infoboxnotealso" id="GUID-9DEED64C-A87E-4EAD-97DA-ABDD3FDF172C__GUID-FA715B02-74FD-47E3-AEE5-F0023325FCEC">
                              <p class="notep1">也可以看看：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p><span class="q">“ <a href="FETCH-statement.html#GUID-75BC6E63-841A-4103-9B96-8AC97F5C28BB" title="FETCH语句从多行查询的结果集中检索数据行 - 一次一行，一次几行，或一次所有行 - 并将数据存储在变量，记录或集合中。">FETCH语句</a> ”</span>的完整语法和语义</p>
                                 </li>
                                 <li>
                                    <p><span class="q">“ <a href="plsql-optimization-and-tuning.html#GUID-541A8B35-9B8F-432F-9E30-E73305A6E17C" title="具有BULK COLLECT子句（也称为FETCH BULK COLLECT语句）的FETCH语句将整个结果集提取到一个或多个集合变量中。">带有BULK COLLECT子句的</a></span> <code class="codeph">FETCH</code>语句<span class="q">”，</span>以获取有关一次返回多行的<code class="codeph">FETCH</code>语句的信息</p>
                                 </li>
                              </ul>
                           </div>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-9DEED64C-A87E-4EAD-97DA-ABDD3FDF172C__BABCFDJE">
                           <p class="titleinexample">例6-6 LOOP语句中的FETCH语句</p><pre class="oac_no_warn" dir="ltr">DECLARE CURSOR c1 IS SELECT last_name，job_id FROM employees WHERE REGEXP_LIKE（job_id，'S [HT] _CLERK'）ORDER BY last_name; v_lastname employees.last_name <span class="bold">％TYPE</span> ; -  last_name的变量v_jobid employees.job_id <span class="bold">％TYPE</span> ; -  job_id的变量CURSOR c2 IS SELECT * FROM employees WHERE REGEXP_LIKE（job_id，'[ACADFIMKSA] _M [ANGR]'）ORDER BY job_id; v_employees employees <span class="bold">％ROWTYPE</span> ; - 表格行的记录变量BEGIN OPEN c1; <span class="bold">LOOP</span> - 将2列写入变量<span class="bold">FETCH c1 INTO v_lastname，v_jobid;</span> <span class="bold">退出时c1％NOTFOUND;</span> DBMS_OUTPUT.PUT_LINE（RPAD（v_lastname，25，''）|| v_jobid）; <span class="bold">结束循环;</span>关闭c1; DBMS_OUTPUT.PUT_LINE（'-------------------------------------'）;打开c2; <span class="bold">LOOP</span> - 将整行提取到v_employees记录<span class="bold">FETCH c2 INTO v_employees;</span> <span class="bold">退出时c2％未找到;</span> DBMS_OUTPUT.PUT_LINE（RPAD（v_employees.last_name，25，''）|| v_employees.job_id）; <span class="bold">结束循环;</span>关闭c2;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">Atkinson ST_CLERK Bell SH_CLERK Bissot ST_CLERK ......Walsh SH_CLERK ------------------------------------- Higgins AC_MGR Greenberg FI_MGR Hartstein MK_MAN ...Zlotkey SA_MAN</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-9DEED64C-A87E-4EAD-97DA-ABDD3FDF172C__CJADGBJE">
                           <p class="titleinexample">例6-7将同一显式游标提取到不同的变量中</p><pre class="oac_no_warn" dir="ltr">DECLARE CURSOR c IS SELECT e.job_id，j.job_title FROM employees e，jobs j WHERE e.job_id = j.job_id AND e.manager_id = 100 ORDER BY last_name; - 记录游标结果集行的变量：job1 c <span class="bold">％ROWTYPE</span> ; job2 c <span class="bold">％ROWTYPE</span> ; job3 c <span class="bold">％ROWTYPE</span> ; job4 c <span class="bold">％ROWTYPE</span> ; job5 c <span class="bold">％ROWTYPE</span> ; BEGIN OPEN c; <span class="bold">FETCH c INTO job1;</span> - 取第一行<span class="bold">FETCH c INTO job2;</span> - 取第二行<span class="bold">FETCH c INTO job3;</span> - 取第三行<span class="bold">FETCH c INTO job4;</span> - 取第四行<span class="bold">FETCH c INTO job5;</span> - 取第五行CLOSE c; DBMS_OUTPUT.PUT_LINE（job1.job_title ||'（'|| job1.job_id ||'）'）; DBMS_OUTPUT.PUT_LINE（job2.job_title ||'（'|| job2.job_id ||'）'）; DBMS_OUTPUT.PUT_LINE（job3.job_title ||'（'|| job3.job_id ||'）'）; DBMS_OUTPUT.PUT_LINE（job4.job_title ||'（'|| job4.job_id ||'）'）; DBMS_OUTPUT.PUT_LINE（job5.job_title ||'（'|| job5.job_id ||'）'）;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">销售经理（SA_MAN）管理副总裁（AD_VP）销售经理（SA_MAN）股票经理（ST_MAN）营销经理（MK_MAN）PL / SQL程序成功完成。</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="LNPLS536"></a><a id="LNPLS457"></a><a id="LNPLS99879"></a><div class="props_rev_3"><a id="GUID-8E770DA2-799E-454E-9AD8-1DDBACE1E3A2" name="GUID-8E770DA2-799E-454E-9AD8-1DDBACE1E3A2"></a><h5 id="LNPLS-GUID-8E770DA2-799E-454E-9AD8-1DDBACE1E3A2" class="sect5"><span class="enumeration_section">6.2.2.4</span>显式游标查询中的变量</h5>
                     <div>
                        <p>显式游标查询可以引用其范围内的任何变量。当您打开显式游标时，PL / SQL会评估查询中的所有变量，并在识别结果集时使用这些值。稍后更改变量的值不会更改结果集。</p>
                        <p>在<a href="static-sql.html#GUID-8E770DA2-799E-454E-9AD8-1DDBACE1E3A2__CJAJAIFF">示例6-8中</a> ，显式游标查询引用了变量<code class="codeph">factor</code> 。当光标打开时， <code class="codeph">factor</code>的值为2。因此， <code class="codeph">sal_multiple</code>总是2倍<code class="codeph">sal</code> ，尽管该<code class="codeph">factor</code>在每次提取后递增。
                        </p>
                        <p>要更改结果集，必须关闭光标，更改变量的值，然后再次打开光标，如<a href="static-sql.html#GUID-8E770DA2-799E-454E-9AD8-1DDBACE1E3A2__BABCAAFB">例6-9所示</a> 。
                        </p>
                        <div class="example" id="GUID-8E770DA2-799E-454E-9AD8-1DDBACE1E3A2__CJAJAIFF">
                           <p class="titleinexample">示例6-8显式游标查询中的变量 - 无结果集更改</p><pre class="oac_no_warn" dir="ltr">DECLARE sal employees.salary％TYPE; sal_multiple employees.salary％TYPE; <span class="bold">因子INTEGER：= 2;</span> CURSOR c1 IS SELECT薪水，薪水* <span class="bold">因素</span>来自员工WHERE job_id LIKE'AD_％';开始<span class="bold">打开c1; -  PL / SQL评估因子</span> LOOP <span class="bold">FETCH c1 INTO sal，sal_multiple;</span>退出时c1％NOTFOUND; DBMS_OUTPUT.PUT_LINE（'factor ='|| factor）; DBMS_OUTPUT.PUT_LINE（'sal ='|| sal）; DBMS_OUTPUT.PUT_LINE（'sal_multiple ='|| sal_multiple）; <span class="bold">factor：= factor + 1; - 不影响sal_multiple</span> END LOOP;关闭c1;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">factor = 2 sal = 4400 sal_multiple = 8800 factor = 3 sal = 24000 sal_multiple = 48000 factor = 4 sal = 17000 sal_multiple = 34000 factor = 5 sal = 17000 sal_multiple = 34000</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-8E770DA2-799E-454E-9AD8-1DDBACE1E3A2__BABCAAFB">
                           <p class="titleinexample">示例6-9显式游标查询 - 结果集更改中的变量</p><pre class="oac_no_warn" dir="ltr">DECLARE sal employees.salary％TYPE; sal_multiple employees.salary％TYPE;因子INTEGER：= 2; CURSOR c1 IS SELECT薪水，薪水*因素来自员工WHERE job_id LIKE'AD_％'; BEGIN DBMS_OUTPUT.PUT_LINE（'factor ='|| factor）; <span class="bold">打开c1; -  PL / SQL评估因子</span> LOOP FETCH c1 INTO sal，sal_multiple;退出时c1％NOTFOUND; DBMS_OUTPUT.PUT_LINE（'sal ='|| sal）; DBMS_OUTPUT.PUT_LINE（'sal_multiple ='|| sal_multiple）;结束循环; <span class="bold">关闭c1;</span> <span class="bold">factor：= factor + 1;</span> DBMS_OUTPUT.PUT_LINE（'factor ='|| factor）; <span class="bold">打开c1; -  PL / SQL评估因子</span> LOOP FETCH c1 INTO sal，sal_multiple;退出时c1％NOTFOUND; DBMS_OUTPUT.PUT_LINE（'sal ='|| sal）; DBMS_OUTPUT.PUT_LINE（'sal_multiple ='|| sal_multiple）;结束循环;关闭c1;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">factor = 2 sal = 4400 sal_multiple = 8800 sal = 24000 sal_multiple = 48000 sal = 17000 sal_multiple = 34000 sal = 17000 sal_multiple = 34000 factor = 3 sal = 4400 sal_multiple = 13200 sal = 24000 sal_multiple = 72000 sal = 17000 sal_multiple = 51000 sal = 17000 sal_multiple = 51000</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="LNPLS458"></a><a id="LNPLS225"></a><div class="props_rev_3"><a id="GUID-2CC94B79-7D23-4456-87B0-440DF9A95D44" name="GUID-2CC94B79-7D23-4456-87B0-440DF9A95D44"></a><h5 id="LNPLS-GUID-2CC94B79-7D23-4456-87B0-440DF9A95D44" class="sect5"><span class="enumeration_section">6.2.2.5</span>当显式游标查询需要列别名时</h5>
                     <div>
                        <p>当显式游标查询包含虚拟列（表达式）时，如果满足以下任一条件，则该列必须具有别名：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>您可以使用游标获取使用<code class="codeph">%ROWTYPE</code>声明的记录。</p>
                           </li>
                           <li>
                              <p>您想要引用程序中的虚拟列。</p>
                           </li>
                        </ul>
                        <p>在<a href="static-sql.html#GUID-2CC94B79-7D23-4456-87B0-440DF9A95D44__CHDCEGIF">示例6-10中</a> ，显式游标中的虚拟列需要前面两个原因的别名。
                        </p>
                        <div class="infoboxnotealso" id="GUID-2CC94B79-7D23-4456-87B0-440DF9A95D44__GUID-A233946B-25CA-49F8-9493-FB44F67F35F2">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="static-sql.html#GUID-25917214-FD91-499D-AB39-CE21484AB167__CJAIBIDJ">例6-21</a></p>
                        </div>
                        <div class="example" id="GUID-2CC94B79-7D23-4456-87B0-440DF9A95D44__CHDCEGIF">
                           <p class="titleinexample">示例6-10具有需要别名的虚拟列的显式游标</p><pre class="oac_no_warn" dir="ltr">DECLARE CURSOR c1 IS SELECT employee_id， <span class="bold">（salary * .05）raise</span> FROM employees WHERE job_id LIKE'％_ MAN'ORDER BY employee_id; <span class="bold">emp_rec c1％ROWTYPE;</span>开始打开c1; LOOP <span class="bold">FETCH c1 INTO emp_rec;</span>退出时c1％NOTFOUND; DBMS_OUTPUT.PUT_LINE（'为员工提升＃'|| emp_rec.employee_id ||'是$'|| <span class="bold">emp_rec.raise</span> ）;结束循环;关闭c1;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">员工＃114的薪酬是550美元员工＃120是400美元员工薪酬400美元员工＃121升资410美元员工薪酬$ 122是员工薪酬395美元＃123是325美元员工薪酬＃124是$ 368.445员工＃145升薪700美元员工＃146为675美元员工提升＃147为600美元员工提升＃148为550美元员工提升＃149为525美元员工提升＃201为650美元</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="LNPLS460"></a><a id="LNPLS459"></a><a id="LNPLS564"></a><div class="props_rev_3"><a id="GUID-2DEFB351-F8B6-453C-AA74-86B5B99C3B20" name="GUID-2DEFB351-F8B6-453C-AA74-86B5B99C3B20"></a><h5 id="LNPLS-GUID-2DEFB351-F8B6-453C-AA74-86B5B99C3B20" class="sect5"><span class="enumeration_section">6.2.2.6</span>接受参数的显式游标</h5>
                     <div>
                        <p>您可以创建具有形式参数的显式游标，然后在每次打开时将不同的实际参数传递给游标。在游标查询中，您可以在任何可以使用常量的地方使用正式游标参数。在游标查询之外，您无法引用正式的游标参数。</p>
                        <div class="infobox-tip" id="GUID-2DEFB351-F8B6-453C-AA74-86B5B99C3B20__GUID-DB204128-EE4F-4115-A179-DD3CEC4B2DD9">
                           <p class="notep1">小费：</p>
                           <p>为避免混淆，请为正式和实际游标参数使用不同的名称。</p>
                        </div>
                        <p><a href="static-sql.html#GUID-2DEFB351-F8B6-453C-AA74-86B5B99C3B20__BABHBHIC">例6-11</a>创建了一个显式游标，其两个形式参数代表一个作业及其最高工资。当使用指定的作业和最大工资打开时，游标查询选择具有该作业的员工多付（对于每个此类员工，查询选择姓名和金额多付）。接下来，该示例创建一个打印游标查询结果集的过程（有关过程的信息，请参阅<a href="plsql-subprograms.html#GUID-13BEBBEC-02D4-48E8-A059-DFEAC4751A3B" title="当PL / SQL函数具有RESULT_CACHE选项时，其结果将缓存在共享全局区域（SGA）中，因此连接到同一实例的会话可以在可用时重用这些结果。PL / SQL函数结果缓存与结果缓存共享其管理和可管理性基础结构。如果在DR单元（定义者权限单元）中包含已连接的用户数据库链接，则必须向将运行DR单元的用户授予INHERIT REMOTE PRIVILEGES权限。">PL / SQL子程序</a> ）。最后，该示例使用一组实际参数打开光标，打印结果集，关闭光标，使用不同的实际参数打开光标，打印结果集，然后关闭光标。
                        </p>
                        <div class="section">
                           <p class="subhead3" id="GUID-2DEFB351-F8B6-453C-AA74-86B5B99C3B20__GUID-D4BD5A65-04E1-481D-BFF5-1FCE55FED022">话题</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><a href="static-sql.html#GUID-9990E85A-2B99-4F8C-BDB1-631D18857DEC">具有默认值的正式游标参数</a></p>
                              </li>
                              <li>
                                 <p><a href="static-sql.html#GUID-D23657CD-9AC5-4690-B78A-018445D59FC7">使用默认值添加正式游标参数</a></p>
                              </li>
                           </ul>
                           <div class="infoboxnotealso" id="GUID-2DEFB351-F8B6-453C-AA74-86B5B99C3B20__GUID-FD37D50D-87B7-4FD3-8085-DC7DE7D3F544">
                              <p class="notep1">也可以看看：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>有关正式游标参数的更多信息，请参阅<span class="q">“ <a href="explicit-cursor-declaration-and-definition.html#GUID-38C5DBA3-9DEC-4AF2-9B5E-7B721D11A77C" title="显式游标是指向私有SQL区域的命名指针，该区域存储用于处理特定查询或DML语句的信息 - 通常是返回或影响多行的语句。">显式游标声明和定义</a> ”</span></p>
                                 </li>
                                 <li>
                                    <p>有关实际游标参数的更多信息，请<span class="q"><a href="OPEN-statement.html#GUID-FB5A9CC3-655F-4AF4-8105-14CB39F2FEA8" title="The OPEN statement opens an explicit cursor, allocates database resources to process the associated query, identifies the result set, and positions the cursor before the first row of the result set.">参见</a> “ <a href="OPEN-statement.html#GUID-FB5A9CC3-655F-4AF4-8105-14CB39F2FEA8" title="OPEN语句打开显式游标，分配数据库资源以处理关联查询，标识结果集，并将光标定位在结果集的第一行之前。">OPEN语句</a> ”</span></p>
                                 </li>
                              </ul>
                           </div>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-2DEFB351-F8B6-453C-AA74-86B5B99C3B20__BABHBHIC">
                           <p class="titleinexample">例6-11接受参数的显式游标</p><pre class="oac_no_warn" dir="ltr">DECLARE CURSOR c <span class="bold">（作业VARCHAR2，max_sal NUMBER）</span> IS SELECT last_name，first_name，（salary  - <span class="bold">max_sal</span> ）多付款FROM员工WHERE job_id = <span class="bold">工作</span>和工资&gt; <span class="bold">max_sal</span> ORDER BY工资; PROCEDURE print_overpaid是last_name_ employees.last_name％TYPE; first_name_ employees.first_name％TYPE; overpayment_ employees.salary％TYPE; BEGIN LOOP FETCH c INTO last_name_，first_name_，overpayment_;退出时c％NOTFOUND; DBMS_OUTPUT.PUT_LINE（last_name_ ||'，'|| first_name_ ||'（by'|| overpayment_ ||'）'）;结束循环; END print_overpaid; BEGIN DBMS_OUTPUT.PUT_LINE（'----------------------'）; DBMS_OUTPUT.PUT_LINE（'Overpaid Stock Clerks：'）; DBMS_OUTPUT.PUT_LINE（ '----------------------'）; <span class="bold">OPEN c（'ST_CLERK'，5000）;</span> print_overpaid;关闭c; DBMS_OUTPUT.PUT_LINE（ '-------------------------------'）; DBMS_OUTPUT.PUT_LINE（'多付销售代表：'）; DBMS_OUTPUT.PUT_LINE（ '-------------------------------'）; <span class="bold">OPEN c（'SA_REP'，10000）;</span> print_overpaid;关闭c;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">----------------------多付股票的职员：----------------------  - -----------------------------多付的销售代表：----------------- -------------- Vishney，Clara（500）Abel，Ellen（1000）Ozer，Lisa（1500年）PL / SQL程序顺利完成。</pre></div>
                        <!-- class="example" -->
                     </div><a id="LNPLS465"></a><a id="LNPLS99874"></a><div class="props_rev_3"><a id="GUID-9990E85A-2B99-4F8C-BDB1-631D18857DEC" name="GUID-9990E85A-2B99-4F8C-BDB1-631D18857DEC"></a><h6 id="LNPLS-GUID-9990E85A-2B99-4F8C-BDB1-631D18857DEC" class="sect6"><span class="enumeration_section">6.2.2.6.1</span>具有默认值的正式游标参数</h6>
                        <div>
                           <p>使用形式参数创建显式游标时，可以为它们指定默认值。当形式参数具有默认值时，其对应的实际参数是可选的。如果在未指定实际参数的情况下打开游标，则formal参数具有其默认值。</p>
                           <p><a href="static-sql.html#GUID-9990E85A-2B99-4F8C-BDB1-631D18857DEC__BABHCIAC">例6-12</a>创建了一个显式游标，其形式参数代表一个位置ID。参数的默认值是公司总部的位置ID。
                           </p>
                           <div class="example" id="GUID-9990E85A-2B99-4F8C-BDB1-631D18857DEC__BABHCIAC">
                              <p class="titleinexample">示例6-12具有默认值的游标参数</p><pre class="oac_no_warn" dir="ltr">DECLARE CURSOR c（ <span class="bold">位置</span> NUMBER <span class="bold">DEFAULT 1700</span> ）IS SELECT d.department_name，e.last_name manager，l.city FROM departments d，employees e，locations l WHERE l.location_id = <span class="bold">location</span> AND l.location_id = d.location_id AND d.department_id = e.department_id ORDER BY d.department_id; PROCEDURE print_depts IS dept_name departments.department_name％TYPE; mgr_name employees.last_name％TYPE; city_name locations.city％TYPE; BEGIN LOOP FETCH c INTO dept_name，mgr_name，city_name;退出时c％NOTFOUND; DBMS_OUTPUT.PUT_LINE（dept_name ||'（经理：'|| mgr_name ||'）'）;结束循环; END print_depts; BEGIN DBMS_OUTPUT.PUT_LINE（'总部的部门：'）; DBMS_OUTPUT.PUT_LINE（ '--------------------------------'）; <span class="bold">OPEN c;</span> print_depts; DBMS_OUTPUT.PUT_LINE（ '--------------------------------'）;关闭c; DBMS_OUTPUT.PUT_LINE（'加拿大的部门：'）; DBMS_OUTPUT.PUT_LINE（ '--------------------------------'）; <span class="bold">OPEN c（1800）;</span> - 多伦多print_depts;关闭c; <span class="bold">OPEN c（1900）;</span> - 怀特霍斯print_depts;关闭c;结束; /</pre><p>结果类似于：</p><pre class="oac_no_warn" dir="ltr">总部的部门：--------------------------------行政（经理：Whalen）采购（经理：Colmenares）采购（经理：Baida）采购（经理：Himuro）采购（经理：Raphaely）采购（经理：Khoo）采购（经理：Tobias）执行经理（经理：Kochhar）执行经理（经理：De Haan）执行经理（经理：King）财务（经理） ：Popp）财务（经理：Greenberg）财务（经理：Faviet）财务（经理：陈）财务（经理：Urman）财务（经理：Sciarra）会计（经理：Gietz）会计（经理：希金斯）----- ---------------------------加拿大的部门：------------------- -------------营销（经理：Hartstein）营销（经理：Fay）PL / SQL程序顺利完成。</pre></div>
                           <!-- class="example" -->
                        </div>
                     </div><a id="LNPLS466"></a><a id="LNPLS99873"></a><div class="props_rev_3"><a id="GUID-D23657CD-9AC5-4690-B78A-018445D59FC7" name="GUID-D23657CD-9AC5-4690-B78A-018445D59FC7"></a><h6 id="LNPLS-GUID-D23657CD-9AC5-4690-B78A-018445D59FC7" class="sect6"><span class="enumeration_section">6.2.2.6.2</span>使用默认值添加正式游标参数</h6>
                        <div>
                           <div class="section">
                              <p>如果向游标添加形式参数，并为添加的参数指定默认值，则无需更改对游标的现有引用。比较<a href="static-sql.html#GUID-D23657CD-9AC5-4690-B78A-018445D59FC7__BABCBJGC">例6-13</a>和<a href="static-sql.html#GUID-2DEFB351-F8B6-453C-AA74-86B5B99C3B20__BABHBHIC">例6-11</a> 。
                              </p>
                           </div>
                           <!-- class="section" -->
                           <div class="example" id="GUID-D23657CD-9AC5-4690-B78A-018445D59FC7__BABCBJGC">
                              <p class="titleinexample">例6-13为现有游标添加形式参数</p><pre class="oac_no_warn" dir="ltr">DECLARE CURSOR c（作业VARCHAR2，max_sal NUMBER， <span class="bold">雇用DATE DEFAULT TO_DATE（'31 -DEC-1999'，'DD-MON-YYYY'）</span> ）IS SELECT last_name，first_name，（salary-max_sal）多付来自员工WHERE job_id = job AND salary&gt; max_sal <span class="bold">AND hire_date&gt;雇用</span> ORDER BY薪水; PROCEDURE print_overpaid是last_name_ employees.last_name％TYPE; first_name_ employees.first_name％TYPE; overpayment_ employees.salary％TYPE; BEGIN LOOP FETCH c INTO last_name_，first_name_，overpayment_;退出时c％NOTFOUND; DBMS_OUTPUT.PUT_LINE（last_name_ ||'，'|| first_name_ ||'（by'|| overpayment_ ||'）'）;结束循环; END print_overpaid; BEGIN DBMS_OUTPUT.PUT_LINE（'-------------------------------'）; DBMS_OUTPUT.PUT_LINE（'多付销售代表：'）; DBMS_OUTPUT.PUT_LINE（ '-------------------------------'）; OPEN c（'SA_REP'，10000）; <span class="bold">- 现有参考</span> print_overpaid;关闭c; DBMS_OUTPUT.PUT_LINE（'--------------------------------------------- ---'）; DBMS_OUTPUT.PUT_LINE（'2004年以后雇用的高薪销售代表：'）; DBMS_OUTPUT.PUT_LINE（'--------------------------------------------- ---'）; OPEN c（'SA_REP'，10000， <span class="bold">TO_DATE（'31 -DEC-2004'，'DD-MON-YYYY'）</span> ）; <span class="bold">- 新参考</span> print_overpaid;关闭c;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">-------------------------------多付的销售代表：--------------- ---------------- Vishney，Clara（500）Abel，Ellen（1000）Ozer，Lisa（1500）------------- ----------------------------------- 2004年以后聘请多付的销售代表：-------- ---------------------------------------- Vishney，Clara（由500）Ozer，Lisa （到1500）PL / SQL程序成功完成。</pre></div>
                           <!-- class="example" -->
                        </div>
                     </div>
                  </div><a id="LNPLS541"></a><div class="props_rev_3"><a id="GUID-D483DF0B-15DB-4466-9870-0F6E1518A40D" name="GUID-D483DF0B-15DB-4466-9870-0F6E1518A40D"></a><h5 id="LNPLS-GUID-D483DF0B-15DB-4466-9870-0F6E1518A40D" class="sect5"><span class="enumeration_section">6.2.2.7</span>显式游标属性</h5>
                     <div>
                        <p>显式游标属性值的语法是<span class="italic"><code class="codeph">cursor_name</code></span> ，后面紧跟<span class="italic"><code class="codeph">attribute</code></span> （例如， <code class="codeph">c1%ISOPEN</code> ）。
                        </p>
                        <div class="infoboxnote" id="GUID-D483DF0B-15DB-4466-9870-0F6E1518A40D__GUID-DC0AC2F4-95E7-4366-ACC5-E226BF048DD6">
                           <p class="notep1">注意：</p>
                           <p>显式游标和游标变量（命名游标）具有相同的属性。除非另有说明，否则本主题适用于所有已命名的游标。</p>
                        </div>
                        <p>显式游标属性是：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>％ISOPEN属性：光标是否打开？</p>
                           </li>
                           <li>
                              <p>％FOUND属性：有一行被提取？</p>
                           </li>
                           <li>
                              <p>％NOTFOUND属性：是否已获取行？</p>
                           </li>
                           <li>
                              <p>％ROWCOUNT属性：获取了多少行？</p>
                           </li>
                        </ul>
                        <p>如果显式游标未打开，则引用除<code class="codeph">%ISOPEN</code>之外的任何属性都会引发预定义的异常<code class="codeph">INVALID_CURSOR</code> 。</p>
                        <div class="infoboxnotealso" id="GUID-D483DF0B-15DB-4466-9870-0F6E1518A40D__GUID-E5596E88-D8EF-448C-9AA4-705A244B5C89">
                           <p class="notep1">也可以看看：</p>
                           <p><span class="q">“ <a href="named-cursor-attribute.html#GUID-CD8D8415-FF19-4D81-99BA-7825FD40CC96" title="每个命名游标（显式游标或游标变量）都有四个属性，每个属性都返回有关DML语句执行的信息。">命名游标属性</a> ”，</span>用于命名游标（显式游标和游标变量）属性的完整语法和语义</p>
                        </div>
                     </div><a id="LNPLS545"></a><a id="LNPLS544"></a><div class="props_rev_3"><a id="GUID-17C89B39-53A8-4FB5-B90C-2937C994CE80" name="GUID-17C89B39-53A8-4FB5-B90C-2937C994CE80"></a><h6 id="LNPLS-GUID-17C89B39-53A8-4FB5-B90C-2937C994CE80" class="sect6"><span class="enumeration_section">6.2.2.7.1</span> ％ISOPEN属性：光标是否打开？
                        </h6>
                        <div>
                           <p><code class="codeph">%ISOPEN</code>如果显式游标打开则返回<code class="codeph">TRUE</code> ;否则为<code class="codeph">FALSE</code> 。
                           </p>
                           <p><code class="codeph">%ISOPEN</code>内容非常有用：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>在尝试打开它之前，检查显式游标是否尚未打开。</p>
                                 <p>如果尝试打开已打开的显式游标，PL / SQL将引发预定义的异常<code class="codeph">CURSOR_ALREADY_OPEN</code> 。必须先关闭显式光标，然后才能重新打开它。
                                 </p>
                                 <div class="infoboxnote" id="GUID-17C89B39-53A8-4FB5-B90C-2937C994CE80__GUID-8630BBEF-BC2D-4856-BFCE-247A5BC1E80B">
                                    <p class="notep1">注意：</p>
                                    <p>前一段不适用于游标变量。</p>
                                 </div>
                              </li>
                              <li>
                                 <p>在尝试关闭之前检查显式游标是否已打开。</p>
                              </li>
                           </ul>
                           <p><a href="static-sql.html#GUID-17C89B39-53A8-4FB5-B90C-2937C994CE80__BABJHBGA">示例6-14</a>仅在未打开时才打开显式游标<code class="codeph">c1</code>仅在打开时才关闭它。
                           </p>
                           <div class="example" id="GUID-17C89B39-53A8-4FB5-B90C-2937C994CE80__BABJHBGA">
                              <p class="titleinexample">示例6-14％ISOPEN显式游标属性</p><pre class="oac_no_warn" dir="ltr">DECLARE CURSOR c1 IS SELECT last_name，salary FROM employees WHERE ROWNUM &lt;11; the_name employees.last_name％TYPE; the_salary employees.salary％TYPE;开始如果<span class="bold">不是c1％ISOPEN</span>那么开放c1;万一; FETCH c1 INTO the_name，the_salary;如果<span class="bold">c1％ISOPEN</span>那么关闭c1;万一;结束; /</pre></div>
                           <!-- class="example" -->
                        </div>
                     </div><a id="LNPLS543"></a><a id="LNPLS542"></a><div class="props_rev_3"><a id="GUID-585F5F92-FB36-4950-AF08-C3AA63DB9470" name="GUID-585F5F92-FB36-4950-AF08-C3AA63DB9470"></a><h6 id="LNPLS-GUID-585F5F92-FB36-4950-AF08-C3AA63DB9470" class="sect6"><span class="enumeration_section">6.2.2.7.2</span> ％FOUND属性：有一行被提取？
                        </h6>
                        <div>
                           <p><code class="codeph">%FOUND</code>返回：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>在显式游标打开之后但在第一次获取之前为<code class="codeph">NULL</code></p>
                              </li>
                              <li>
                                 <p>如果显式游标的最新提取返回一行，则为<code class="codeph">TRUE</code></p>
                              </li>
                              <li>
                                 <p>否则为<code class="codeph">FALSE</code></p>
                              </li>
                           </ul>
                           <p><code class="codeph">%FOUND</code>可用于确定是否存在要处理的已提取行。
                           </p>
                           <p><a href="static-sql.html#GUID-585F5F92-FB36-4950-AF08-C3AA63DB9470__CJAEDJEE">例6-15</a>循环遍历结果集，打印每个获取的行，并在没有更多行要提取时退出。
                           </p>
                           <div class="example" id="GUID-585F5F92-FB36-4950-AF08-C3AA63DB9470__CJAEDJEE">
                              <p class="titleinexample">示例6-15％FOUND显式游标属性</p><pre class="oac_no_warn" dir="ltr">DECLARE CURSOR c1 IS SELECT last_name，salary FROM employees WHERE ROWNUM &lt;11 ORDER BY last_name; my_ename employees.last_name％TYPE; my_salary employees.salary％TYPE;开始打开c1; LOOP FETCH c1 INTO my_ename，my_salary; IF <span class="bold">c1％FOUND</span> THEN  - 获取成功DBMS_OUTPUT.PUT_LINE（'Name ='|| my_ename ||'，salary ='|| my_salary）; ELSE  - 获取失败EXIT;万一;结束循环;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">姓名= Austin，薪水= 4800姓名= De Haan，薪水= 17000姓名=恩斯特，薪水= 6000姓名= Faviet，薪水= 9000姓名= Greenberg，薪水= 12008姓名= Hunold，薪水= 9000姓名=国王，薪水= 24000姓名= Kochhar，薪水= 17000姓名= Lorentz，薪水= 4200姓名= Pataballa，薪水= 4800</pre></div>
                           <!-- class="example" -->
                        </div>
                     </div><a id="LNPLS547"></a><a id="LNPLS546"></a><div class="props_rev_3"><a id="GUID-BC2BA7E6-EFCE-4105-8305-807074F8B6A5" name="GUID-BC2BA7E6-EFCE-4105-8305-807074F8B6A5"></a><h6 id="LNPLS-GUID-BC2BA7E6-EFCE-4105-8305-807074F8B6A5" class="sect6"><span class="enumeration_section">6.2.2.7.3</span> ％NOTFOUND属性：没有获取行？
                        </h6>
                        <div>
                           <p><code class="codeph">%NOTFOUND</code> （ <code class="codeph">%FOUND</code>的逻辑反面）返回：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>在显式游标打开之后但在第一次获取之前为<code class="codeph">NULL</code></p>
                              </li>
                              <li>
                                 <p>如果显式游标的最新提取返回一行，则为<code class="codeph">FALSE</code></p>
                              </li>
                              <li>
                                 <p>否则为<code class="codeph">TRUE</code></p>
                              </li>
                           </ul>
                           <p>当<code class="codeph">FETCH</code>无法返回行时， <code class="codeph">%NOTFOUND</code>对于退出循环非常有用，如<a href="static-sql.html#GUID-BC2BA7E6-EFCE-4105-8305-807074F8B6A5__CJAHDJIF">例6-16所示</a> 。
                           </p>
                           <div class="example" id="GUID-BC2BA7E6-EFCE-4105-8305-807074F8B6A5__CJAHDJIF">
                              <p class="titleinexample">示例6-16％NOTFOUND显式游标属性</p><pre class="oac_no_warn" dir="ltr">DECLARE CURSOR c1 IS SELECT last_name，salary FROM employees WHERE ROWNUM &lt;11 ORDER BY last_name; my_ename employees.last_name％TYPE; my_salary employees.salary％TYPE;开始打开c1; LOOP FETCH c1 INTO my_ename，my_salary;如果<span class="bold">c1％NOTFOUND</span>那么 - 获取失败退出; ELSE  - 获取成功DBMS_OUTPUT.PUT_LINE（'Name ='|| my_ename ||'，salary ='|| my_salary）;万一;结束循环;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">姓名= Austin，薪水= 4800姓名= De Haan，薪水= 17000姓名=恩斯特，薪水= 6000姓名= Faviet，薪水= 9000姓名= Greenberg，薪水= 12008姓名= Hunold，薪水= 9000姓名=国王，薪水= 24000姓名= Kochhar，薪水= 17000姓名= Lorentz，薪水= 4200姓名= Pataballa，薪水= 4800</pre></div>
                           <!-- class="example" -->
                        </div>
                     </div><a id="LNPLS549"></a><a id="LNPLS548"></a><div class="props_rev_3"><a id="GUID-737259F5-05E2-46E9-B00D-D9AF03D62D09" name="GUID-737259F5-05E2-46E9-B00D-D9AF03D62D09"></a><h6 id="LNPLS-GUID-737259F5-05E2-46E9-B00D-D9AF03D62D09" class="sect6"><span class="enumeration_section">6.2.2.7.4</span> ％ROWCOUNT属性：获取了多少行？
                        </h6>
                        <div>
                           <p><code class="codeph">%ROWCOUNT</code>返回：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>显式游标打开后但在第一次获取之前为零</p>
                              </li>
                              <li>
                                 <p>否则，获取的行数（ <code class="codeph">INTEGER</code> ）</p>
                                 <div class="infoboxnote" id="GUID-737259F5-05E2-46E9-B00D-D9AF03D62D09__GUID-6A6BA1B8-8298-4C00-BFDC-0C2818EB2B72">
                                    <p class="notep1">注意：</p>
                                    <p>如果服务器是Oracle Database 12 <span class="italic">c</span>或更高版本且其客户端是Oracle Database 11 <span class="italic">g</span> 2或更早版本（或反向），则<code class="codeph">SQL%ROWCOUNT</code>返回的最大数量为4,294,967,295。
                                    </p>
                                 </div>
                              </li>
                           </ul>
                           <p><a href="static-sql.html#GUID-737259F5-05E2-46E9-B00D-D9AF03D62D09__CJAFIFIB">例6-17</a>编号并打印它获取的行，并在获取第五行后打印一条消息。
                           </p>
                           <div class="example" id="GUID-737259F5-05E2-46E9-B00D-D9AF03D62D09__CJAFIFIB">
                              <p class="titleinexample">示例6-17％ROWCOUNT显式游标属性</p><pre class="oac_no_warn" dir="ltr">DECLARE CURSOR c1 IS SELECT last_name FROM employees WHERE ROWNUM &lt;11 ORDER BY last_name; name employees.last_name％TYPE;开始打开c1; LOOP FETCH c1 INTO名称;当c1％NOTFOUND或c1％NOTFOUND为空时退出; DBMS_OUTPUT.PUT_LINE（ <span class="bold">c1％ROWCOUNT</span> ||'。'|| name）; <span class="bold">如果c1％ROWCOUNT = 5</span>那么DBMS_OUTPUT.PUT_LINE（'---获取第5行---'）;万一;结束循环;关闭c1;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">1。亚伯2。安德3。阿特金森4。奥斯汀5。贝尔---获得第5排--- 6。百大7。班达8。贝茨9。贝尔10。伯恩斯坦</pre></div>
                           <!-- class="example" -->
                        </div>
                     </div>
                  </div>
               </div>
            </div><a id="LNPLS467"></a><a id="LNPLS00603"></a><div class="props_rev_3"><a id="GUID-E6BCE8B1-71AA-459F-845F-2C34541A534D" name="GUID-E6BCE8B1-71AA-459F-845F-2C34541A534D"></a><h3 id="LNPLS-GUID-E6BCE8B1-71AA-459F-845F-2C34541A534D" class="sect3"><span class="enumeration_section">6.3</span>处理查询结果集</h3>
               <div>
                  <p>在PL / SQL中，与传统的数据库编程一样，您使用游标来处理查询结果集。但是，在PL / SQL中，您可以使用隐式或显式游标。</p>
                  <div class="section">
                     <p>前者需要的代码较少，但后者更灵活。例如，显式游标可以接受参数。</p>
                     <p>以下PL / SQL语句使用PL / SQL为您定义和管理的隐式游标：</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">SELECT</code> <code class="codeph">INTO</code></p>
                        </li>
                        <li>
                           <p>隐含游标<code class="codeph">FOR</code> <code class="codeph">LOOP</code></p>
                        </li>
                     </ul>
                     <p>以下PL / SQL语句使用显式游标：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>显式游标<code class="codeph">FOR</code> <code class="codeph">LOOP</code></p>
                           <p>您可以定义显式游标，但PL / SQL会在语句运行时对其进行管理。</p>
                        </li>
                        <li>
                           <p><code class="codeph">OPEN</code> ， <code class="codeph">FETCH</code>和<code class="codeph">CLOSE</code></p>
                           <p>您可以定义和管理显式游标。</p>
                        </li>
                     </ul>
                     <div class="infoboxnote" id="GUID-E6BCE8B1-71AA-459F-845F-2C34541A534D__GUID-D1C31C73-B244-40DF-8E7A-1AFFF5B55283">
                        <p class="notep1">注意：</p>
                        <p>如果查询未返回任何行，则PL / SQL会引发异常<code class="codeph">NO_DATA_FOUND</code> 。</p>
                     </div>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-E6BCE8B1-71AA-459F-845F-2C34541A534D__GUID-1F435F41-BDDE-443C-ABF4-F078B50CB2E9">话题</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="static-sql.html#GUID-6BEF411F-DCA9-4777-BE1F-6740B7C9B647" title="使用隐式游标，SELECT INTO语句从一个或多个数据库表中检索值（如SQL SELECT语句所做的那样）并将它们存储在变量中（SQL SELECT语句不这样做）。">使用SELECT INTO语句处理查询结果集</a></p>
                        </li>
                        <li>
                           <p><a href="static-sql.html#GUID-25917214-FD91-499D-AB39-CE21484AB167" title="游标FOR LOOP语句允许您运行SELECT语句，然后立即循环遍历结果集的行。">处理查询结果集与光标FOR LOOP语句</a></p>
                        </li>
                        <li>
                           <p><a href="static-sql.html#GUID-BCCE0985-AB78-48B8-A453-F44FCC4DA595" title="要完全控制查询结果集处理，请声明显式游标并使用语句OPEN，FETCH和CLOSE管理它们。">使用显式游标，OPEN，FETCH和CLOSE处理查询结果集</a></p>
                        </li>
                        <li>
                           <p><a href="static-sql.html#GUID-8DD487B1-1CC5-4F26-98F2-97753A7EEF70" title="如果通过循环遍历查询结果集并为每行运行另一个查询来处理查询结果集，则可以通过从循环内部删除第二个查询并使其成为第一个查询的子查询来提高性能。">使用子查询处理查询结果集</a></p>
                        </li>
                     </ul>
                     <div class="infoboxnotealso" id="GUID-E6BCE8B1-71AA-459F-845F-2C34541A534D__GUID-9F4F9353-7798-4A67-83C1-53E7C7C12A96">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><span class="q">“ <a href="static-sql.html#GUID-2DEFB351-F8B6-453C-AA74-86B5B99C3B20">接受参数的显式游标</a> ”</span></p>
                           </li>
                           <li>
                              <p>有关将结果集返回给客户端的信息，请参阅<a href="../adfns/coding-subprograms-and-packages.html#ADFNS00903" target="_blank"><span class="italic">Oracle数据库开发指</span></a></p>
                           </li>
                           <li>
                              <p>有关处理异常的信息，请使用<span class="q">“ <a href="exception-handler.html#GUID-3FECF29B-A240-4191-A635-92C612D00C4D" title="异常处理程序处理引发的异常。">异常处理程序</a> ”</span></p>
                           </li>
                        </ul>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div><a id="LNPLS476"></a><a id="LNPLS551"></a><div class="props_rev_3"><a id="GUID-6BEF411F-DCA9-4777-BE1F-6740B7C9B647" name="GUID-6BEF411F-DCA9-4777-BE1F-6740B7C9B647"></a><h4 id="LNPLS-GUID-6BEF411F-DCA9-4777-BE1F-6740B7C9B647" class="sect4"><span class="enumeration_section">6.3.1</span>使用SELECT INTO语句处理查询结果集</h4>
                  <div>
                     <p>使用隐式游标， <code class="codeph">SELECT</code> <code class="codeph">INTO</code>语句从一个或多个数据库表中检索值（如SQL <code class="codeph">SELECT</code>语句所做的那样）并将它们存储在变量中（SQL <code class="codeph">SELECT</code>语句不这样做）。
                     </p>
                     <div class="section">
                        <p class="subhead3" id="GUID-6BEF411F-DCA9-4777-BE1F-6740B7C9B647__GUID-54037446-E299-4D70-B459-E87525B29841">话题</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="static-sql.html#GUID-93E44519-5370-4E5B-B157-4C12509DFDEF" title="如果希望查询只返回一行，则使用SELECT INTO语句将该行中的值存储在一个或多个标量变量或一个记录变量中。">处理单行结果集</a></p>
                           </li>
                           <li>
                              <p><a href="static-sql.html#GUID-8E633AC0-3EA2-4500-8338-09D39C24FE92" title="如果必须将大量表数据分配给变量，Oracle建议将SELECT INTO语句与BULK COLLECT子句一起使用。">处理大型多行结果集</a></p>
                           </li>
                        </ul>
                        <div class="infoboxnotealso" id="GUID-6BEF411F-DCA9-4777-BE1F-6740B7C9B647__GUID-32355F98-83A3-46F8-9FE3-54B6B2FA1742">
                           <p class="notep1">也可以看看：</p>
                           <p><span class="q">“ <a href="SELECT-INTO-statement.html#GUID-6E14E04D-4344-45F3-BE80-979DD26C7A90" title="SELECT INTO语句从一个或多个数据库表中检索值（如SQL SELECT语句所做的那样）并将它们存储在变量中（SQL SELECT语句不这样做）。">SELECT INTO Statement</a> ”</span>的完整语法和语义</p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div><a id="LNPLS99881"></a><div class="props_rev_3"><a id="GUID-93E44519-5370-4E5B-B157-4C12509DFDEF" name="GUID-93E44519-5370-4E5B-B157-4C12509DFDEF"></a><h5 id="LNPLS-GUID-93E44519-5370-4E5B-B157-4C12509DFDEF" class="sect5"><span class="enumeration_section">6.3.1.1</span>处理单行结果集</h5>
                     <div>
                        <p>如果希望查询只返回一行，则使用<code class="codeph">SELECT</code> <code class="codeph">INTO</code>语句将该行中的值存储在一个或多个标量变量或一个记录变量中。
                        </p>
                        <div class="section">
                           <p>如果查询可能返回多行，但您只关心第<span class="italic">n</span>行，则使用子句<code class="codeph">WHERE</code> <code class="codeph">ROWNUM=</code> <span class="italic"><code class="codeph">n</code></span>将结果集限制为该行。
                           </p>
                           <div class="infoboxnotealso" id="GUID-93E44519-5370-4E5B-B157-4C12509DFDEF__GUID-38803AD9-14AA-4925-8B2E-E8107AB4796C">
                              <p class="notep1">也可以看看：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p><span class="q">“ <a href="plsql-language-fundamentals.html#GUID-EDB2297F-A80D-48B3-8EF1-5437BF981CC2">使用SELECT INTO语句将值分配给变量</a> ”</span></p>
                                 </li>
                                 <li>
                                    <p><span class="q">“ <a href="plsql-collections-and-records.html#GUID-785E5E7E-7FCD-4291-8F62-389814A261EC">使用SELECT INTO将行分配给记录变量</a> ”</span></p>
                                 </li>
                                 <li>
                                    <p> 有关<code class="codeph">ROWNUM</code>伪列的更多信息，请<a href="../sqlrf/ROWNUM-Pseudocolumn.html#SQLRF00255" target="_blank"><span class="italic">参见Oracle数据库SQL语言参考</span></a></p>
                                 </li>
                              </ul>
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNPLS99880"></a><div class="props_rev_3"><a id="GUID-8E633AC0-3EA2-4500-8338-09D39C24FE92" name="GUID-8E633AC0-3EA2-4500-8338-09D39C24FE92"></a><h5 id="LNPLS-GUID-8E633AC0-3EA2-4500-8338-09D39C24FE92" class="sect5"><span class="enumeration_section">6.3.1.2</span>处理大型多行结果集</h5>
                     <div>
                        <p>如果必须将大量表数据分配给变量，Oracle建议将<code class="codeph">SELECT</code> <code class="codeph">INTO</code>语句与<code class="codeph">BULK</code> <code class="codeph">COLLECT</code>子句一起使用。
                        </p>
                        <div class="section">
                           <p>此语句将整个结果集检索到一个或多个集合变量中。</p>
                           <p>有关更多信息，请参阅<span class="q">“ <a href="plsql-optimization-and-tuning.html#GUID-6E09E4FC-28C0-43C8-9E7C-A54D6398D1DE" title="带有BULK COLLECT子句的SELECT INTO语句（也称为SELECT BULK COLLECT INTO语句）将整个结果集选择为一个或多个集合变量。">使用BULK COLLECT子句选择INTO语句</a> ”</span> 。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="LNPLS477"></a><a id="LNPLS481"></a><a id="LNPLS565"></a><a id="LNPLS559"></a><a id="LNPLS553"></a><div class="props_rev_3"><a id="GUID-25917214-FD91-499D-AB39-CE21484AB167" name="GUID-25917214-FD91-499D-AB39-CE21484AB167"></a><h4 id="LNPLS-GUID-25917214-FD91-499D-AB39-CE21484AB167" class="sect4"><span class="enumeration_section">6.3.2</span>使用光标处理查询结果集以进行LOOP语句</h4>
                  <div>
                     <p>游标<code class="codeph">FOR</code> <code class="codeph">LOOP</code>语句允许您运行<code class="codeph">SELECT</code>语句，然后立即循环遍历结果集的行。
                     </p>
                     <div class="section">
                        <p>此语句可以使用隐式或显式游标（但不能使用游标变量）。</p>
                        <p>如果您使用<code class="codeph">SELECT</code>只在游标语句<code class="codeph">FOR</code> <code class="codeph">LOOP</code>语句，然后指定<code class="codeph">SELECT</code>语句中的游标内<code class="codeph">FOR</code> <code class="codeph">LOOP</code>语句，如<a href="static-sql.html#GUID-25917214-FD91-499D-AB39-CE21484AB167__CHDBJBJE">例6-18</a> 。这种形式的游标<code class="codeph">FOR</code> <code class="codeph">LOOP</code>语句使用隐式游标，并被称为<span class="bold">隐式游标</span> <span class="bold"><code class="codeph">FOR</code></span> <span class="bold"><code class="codeph">LOOP</code></span> <span class="bold">语句</span> 。因为隐式游标是语句的内部游标，所以不能使用名称<code class="codeph">SQL</code>引用它。</p>
                        <p>如果在同一个PL / SQL单元中多次使用<code class="codeph">SELECT</code>语句，则为其定义一个显式游标，并在游标<code class="codeph">FOR</code> <code class="codeph">LOOP</code>语句中指定该游标，如<a href="static-sql.html#GUID-25917214-FD91-499D-AB39-CE21484AB167__BABGJBEA">例6-19所示</a> 。这种形式的游标<code class="codeph">FOR</code> <code class="codeph">LOOP</code>语句称为<span class="bold">显式游标</span> <span class="bold"><code class="codeph">FOR</code></span> <span class="bold"><code class="codeph">LOOP</code></span> <span class="bold">语句</span> 。您可以在同一个PL / SQL单元中的其他位置使用相同的显式游标。
                        </p>
                        <p>游标<code class="codeph">FOR</code> <code class="codeph">LOOP</code>语句隐式声明其循环索引为其游标返回的类型的<code class="codeph">%ROWTYPE</code>记录变量。此记录是循环的本地记录，仅在循环执行期间存在。循环内的语句可以引用记录及其字段。它们只能通过别名引用虚拟列，如<a href="static-sql.html#GUID-25917214-FD91-499D-AB39-CE21484AB167__CJAIBIDJ">例6-21所示</a> 。
                        </p>
                        <p>声明循环索引记录变量后， <code class="codeph">FOR</code> <code class="codeph">LOOP</code>语句将打开指定的游标。对于循环的每次迭代， <code class="codeph">FOR</code> <code class="codeph">LOOP</code>语句从结果集中提取一行并将其存储在记录中。当没有更多要获取的行时，游标<code class="codeph">FOR</code> <code class="codeph">LOOP</code>语句将关闭游标。如果循环内的语句将控制转移到循环外部或者PL / SQL引发异常，则游标也会关闭。
                        </p>
                        <div class="infoboxnotealso" id="GUID-25917214-FD91-499D-AB39-CE21484AB167__GUID-9AA02AEA-24F7-4AC9-BADE-6FBC8077FC72">
                           <p class="notep1">也可以看看：</p>
                           <p><span class="q">“ <a href="cursor-FOR-LOOP-statement.html#GUID-62C9A3C8-82F9-468F-8D84-81672E67736D" title="游标FOR LOOP语句隐式声明其循环索引为指定游标返回的行类型的记录变量，然后打开游标。">光标FOR LOOP语句</a> ”</span>的完整语法和语义</p>
                        </div>
                        <div class="infoboxnote" id="GUID-25917214-FD91-499D-AB39-CE21484AB167__GUID-130BE73A-42C2-4AC5-91B9-C542A371CD3E">
                           <p class="notep1">注意：</p>
                           <p>当在游标<code class="codeph">FOR</code> <code class="codeph">LOOP</code>语句中引发异常时，游标在异常处理程序运行之前关闭。因此，显式游标属性的值在处理程序中不可用。
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-25917214-FD91-499D-AB39-CE21484AB167__CHDBJBJE">
                        <p class="titleinexample">例6-18 LOOP语句的隐式游标</p>
                        <p>在此示例中，隐式游标<code class="codeph">FOR</code> <code class="codeph">LOOP</code>语句打印其经理ID大于120的每个职员的姓氏和工作ID。
                        </p><pre class="oac_no_warn" dir="ltr">BEGIN FOR项目IN（SELECT last_name，job_id FROM employees WHERE job_id LIKE'％CLERK％'AND manager_id&gt; 120 ORDER BY last_name）LOOP DBMS_OUTPUT.PUT_LINE（'Name ='|| item.last_name ||'，Job ='|| item.job_id）;结束循环;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">Name = Atkinson，Job = ST_CLERK Name = Bell，Job = SH_CLERK Name = Bissot，Job = ST_CLERK ......Name = Walsh，Job = SH_CLERK</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-25917214-FD91-499D-AB39-CE21484AB167__BABGJBEA">
                        <p class="titleinexample">例6-19 LOOP语句的显式游标</p>
                        <p>这个例子类似于<a href="static-sql.html#GUID-25917214-FD91-499D-AB39-CE21484AB167__CHDBJBJE">例6-18</a> ，除了它使用显式游标<code class="codeph">FOR</code> <code class="codeph">LOOP</code>语句。
                        </p><pre class="oac_no_warn" dir="ltr">DECLARE CURSOR c1 IS SELECT last_name，job_id FROM employees WHERE job_id LIKE'％CLERK％'AND manager_id&gt; 120 ORDER BY last_name;在c1 LOOP DBMS_OUTPUT.PUT_LINE（'Name ='|| item.last_name ||'，Job ='|| item.job_id）中的项目开始;结束循环;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">Name = Atkinson，Job = ST_CLERK Name = Bell，Job = SH_CLERK Name = Bissot，Job = ST_CLERK ......Name = Walsh，Job = SH_CLERK</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-25917214-FD91-499D-AB39-CE21484AB167__I45976">
                        <p class="titleinexample">示例6-20将参数传递给显式游标FOR LOOP语句</p>
                        <p>此示例声明并定义一个显式游标，该游标接受两个参数，然后在显式游标<code class="codeph">FOR</code> <code class="codeph">LOOP</code>语句中使用它来显示支付给在指定部门中获得超过指定工资的员工的工资。
                        </p><pre class="oac_no_warn" dir="ltr">DECLARE CURSOR c1 <span class="bold">（job VARCHAR2，max_wage NUMBER）</span> IS SELECT * FROM employees WHERE job_id = job and salary&gt; max_wage; BEGIN FOR person IN <span class="bold">c1（'ST_CLERK'，3000）</span> LOOP  - 处理数据记录DBMS_OUTPUT.PUT_LINE（'Name ='|| person.last_name ||'，salary ='|| person.salary ||'，Job Id = '|| person.job_id）;结束循环;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">Name = Nayer，salary = 3200，Job Id = ST_CLERK Name = Bissot，salary = 3300，Job Id = ST_CLERK Name = Mallin，salary = 3300，Job Id = ST_CLERK Name = Ladwig，salary = 3600，Job Id = ST_CLERK Name = Stiles，薪水= 3200，工作ID = ST_CLERK姓名= Rajs，工资= 3500，工作ID = ST_CLERK姓名=戴维斯，工资= 3100，工作ID = ST_CLERK</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-25917214-FD91-499D-AB39-CE21484AB167__CJAIBIDJ">
                        <p class="titleinexample">示例6-21光标FOR循环引用虚拟列</p>
                        <p>在此示例中，隐式游标<code class="codeph">FOR</code> <code class="codeph">LOOP</code>通过其别名<code class="codeph">full_name</code>和<code class="codeph">dream_salary</code>引用虚拟列。
                        </p><pre class="oac_no_warn" dir="ltr">BEGIN FOR项IN（SELECT名字|| '' ||姓氏AS <span class="bold">FULL_NAME，</span>工资* 10 AS <span class="bold">dream_salary</span> FROM雇员WHERE ROWNUM &lt;= 5 ORDER BY dream_salary DESC，姓氏ASC）LOOP DBMS_OUTPUT.PUT_LINE（项目<span class="bold">。FULL_NAME</span> ||'的梦想制作'|| <span class="bold">item.doream_salary</span> ）;结束循环;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">斯蒂芬金梦想制造240000 Lex De Haan梦想让17万Neena Kochhar梦想让170000亚历山大Hunold梦想让90000布鲁斯恩斯特梦想制造60000</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="LNPLS554"></a><div class="props_rev_3"><a id="GUID-BCCE0985-AB78-48B8-A453-F44FCC4DA595" name="GUID-BCCE0985-AB78-48B8-A453-F44FCC4DA595"></a><h4 id="LNPLS-GUID-BCCE0985-AB78-48B8-A453-F44FCC4DA595" class="sect4"><span class="enumeration_section">6.3.3</span>使用显式游标，OPEN，FETCH和CLOSE处理查询结果集</h4>
                  <div>
                     <p>要完全控制查询结果集处理，请声明显式游标并使用语句OPEN，FETCH和CLOSE管理它们。</p>
                     <div class="section">
                        <p>这种结果集处理技术比其他技术更复杂，但它也更灵活。例如，您可以：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p>使用多个游标并行处理多个结果集。</p>
                           </li>
                           <li>
                              <p>在单个循环迭代中处理多个行，跳过行或将处理拆分为多个循环。</p>
                           </li>
                           <li>
                              <p>在一个PL / SQL单元中指定查询，但在另一个PL / SQL单元中检索行。</p>
                           </li>
                        </ul>
                        <p>有关说明和示例，请参阅<span class="q">“ <a href="static-sql.html#GUID-89E0242F-42AC-4B21-9DF1-ACD6F4FC03B9">显式游标</a> ”</span> 。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPLS561"></a><a id="LNPLS563"></a><a id="LNPLS00604"></a><div class="props_rev_3"><a id="GUID-8DD487B1-1CC5-4F26-98F2-97753A7EEF70" name="GUID-8DD487B1-1CC5-4F26-98F2-97753A7EEF70"></a><h4 id="LNPLS-GUID-8DD487B1-1CC5-4F26-98F2-97753A7EEF70" class="sect4"><span class="enumeration_section">6.3.4</span>使用子查询处理查询结果集</h4>
                  <div>
                     <p>如果通过循环遍历查询结果集并为每行运行另一个查询来处理查询结果集，则可以通过从循环内部删除第二个查询并使其成为第一个查询的子查询来提高性能。</p>
                     <div class="section">
                        <p>在为每个表计算普通子查询时，将为每一行评估<span class="bold">相关子查询</span> 。
                        </p>
                        <p>有关子查询的更多信息，请参见<a href="../sqlrf/Using-Subqueries.html#SQLRF52357" target="_blank"><span class="italic">Oracle数据库SQL语言参考</span></a> 。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-8DD487B1-1CC5-4F26-98F2-97753A7EEF70__CJABHDCB">
                        <p class="titleinexample">示例6-22父查询的FROM子句中的子查询</p>
                        <p>此示例使用<code class="codeph">FROM</code>子句包含子查询的查询定义显式游标<code class="codeph">c1</code> 。
                        </p><pre class="oac_no_warn" dir="ltr">DECLARE CURSOR c1 IS SELECT t1.department_id，department_name，staff FROM departments t1， <span class="bold">（SELECT department_id，COUNT（*）AS staff</span> <span class="bold">FROM employees</span> <span class="bold">GROUP BY department_id</span> <span class="bold">）</span> t2 WHERE（t1.department_id = t2.department_id）AND staff&gt; = 5 ORDER BY员工;开始在c1 LOOP DBMS_OUTPUT.PUT_LINE（'Department ='|| dept.department_name ||'，staff ='|| dept.staff）;结束循环;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">部门= IT，员工= 5部门=财务，员工= 6部门=采购，员工= 6部门=销售，员工= 34部门=运输，员工= 45</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-8DD487B1-1CC5-4F26-98F2-97753A7EEF70__BABCEJBA">
                        <p class="titleinexample">示例6-23相关子查询</p>
                        <p>此示例返回其薪水超过部门平均值的每个员工的姓名和薪水。对于表中的每一行，相关子查询计算相应部门的平均工资。</p><pre class="oac_no_warn" dir="ltr">DECLARE CURSOR c1 IS SELECT department_id，last_name，salary FROM employees t WHERE salary&gt; <span class="bold">（SELECT AVG（salary）</span> <span class="bold">FROM employees</span> <span class="bold">WHERE t.department_id = department_id</span> ）ORDER BY department_id，last_name; BEGIN for person IN c1 LOOP DBMS_OUTPUT.PUT_LINE（'高于平均工资='|| person.last_name）;结束循环;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">高于平均水平= Hartstein高于平均水平= Raphaely高于平均水平=贝尔......高于平均水平的薪水=希金斯</pre></div>
                     <!-- class="example" -->
                  </div>
               </div>
            </div><a id="LNPLS482"></a><a id="LNPLS00605"></a><div class="props_rev_3"><a id="GUID-4A6E054A-4002-418D-A1CA-DE849CD7E6D5" name="GUID-4A6E054A-4002-418D-A1CA-DE849CD7E6D5"></a><h3 id="LNPLS-GUID-4A6E054A-4002-418D-A1CA-DE849CD7E6D5" class="sect3"><span class="enumeration_section">6.4</span>光标变量</h3>
               <div>
                  <p><span class="bold">游标变量</span>类似于显式游标，但以下情况除外：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>它不仅限于一个查询。</p>
                        <p>您可以打开查询的游标变量，处理结果集，然后将游标变量用于另一个查询。</p>
                     </li>
                     <li>
                        <p>您可以为其分配值。</p>
                     </li>
                     <li>
                        <p>您可以在表达式中使用它。</p>
                     </li>
                     <li>
                        <p>它可以是子程序参数。</p>
                        <p>您可以使用游标变量在子程序之间传递查询结果集。</p>
                     </li>
                     <li>
                        <p>它可以是宿主变量。</p>
                        <p>您可以使用游标变量在PL / SQL存储的子程序与其客户端之间传递查询结果集。</p>
                     </li>
                     <li>
                        <p>它不能接受参数。</p>
                        <p>您不能将参数传递给游标变量，但可以将整个查询传递给它。查询可以包含变量。</p>
                     </li>
                  </ul>
                  <p>游标变量具有这种灵活性，因为它是一个指针;也就是说，它的值是项目的地址，而不是项目本身。</p>
                  <p>在引用游标变量之前，必须将其指向SQL工作区，方法是打开它或者为其指定一个打开的PL / SQL游标变量或打开的主机游标变量的值。</p>
                  <div class="infoboxnote" id="GUID-4A6E054A-4002-418D-A1CA-DE849CD7E6D5__GUID-8DFBB3C0-B415-451C-90CC-3001FBAC0E39">
                     <p class="notep1">注意：</p>
                     <p>游标变量和显式游标不可互换 - 您不能使用另一个期望的游标。例如，您无法在游标<code class="codeph">FOR</code> <code class="codeph">LOOP</code>语句中引用游标变量。
                     </p>
                  </div>
                  <div class="section">
                     <p class="subhead2" id="GUID-4A6E054A-4002-418D-A1CA-DE849CD7E6D5__GUID-F072E89D-7B32-4E1D-A328-ABA0F17DAC09">话题</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="static-sql.html#GUID-470A7A99-888A-46C2-BDAF-D4710E650F27" title="要创建游标变量，请声明预定义类型SYS_REFCURSOR的变量或定义REF CURSOR类型，然后声明该类型的变量。">创建游标变量</a></p>
                        </li>
                        <li>
                           <p><a href="static-sql.html#GUID-87B4D958-520C-4483-BC63-2D1FE4C4CC01">打开和关闭光标变量</a></p>
                        </li>
                        <li>
                           <p><a href="static-sql.html#GUID-AA5A2016-1B76-4961-9AFB-EB052F0D0FB2" title="打开游标变量后，可以使用FETCH语句获取查询结果集的行。">使用游标变量获取数据</a></p>
                        </li>
                        <li>
                           <p><a href="static-sql.html#GUID-7251E068-86C3-4B82-A8CE-54E0C9B9FCB2" title="您可以为PL / SQL游标变量分配另一个PL / SQL游标变量或主机游标变量的值。">将值分配给游标变量</a></p>
                        </li>
                        <li>
                           <p><a href="static-sql.html#GUID-E03A2A12-D298-4D1C-8CCE-3B5D17DDFC7C" title="与游标变量关联的查询可以引用其范围中的任何变量。">游标变量查询中的变量</a></p>
                        </li>
                        <li>
                           <p><a href="static-sql.html#GUID-65ADB424-2C2D-49ED-9E98-99A3A68BA248">查询集合</a></p>
                        </li>
                        <li>
                           <p><a href="static-sql.html#GUID-1361A503-BA2D-400B-987A-59B2824E316E">游标变量属性</a></p>
                        </li>
                        <li>
                           <p><a href="static-sql.html#GUID-9713DFC2-3C2E-49B2-922F-02D43F9D0619" title="您可以使用游标变量作为子程序参数，这使得它可以在子程序之间传递查询结果。">光标变量作为子程序参数</a></p>
                        </li>
                        <li>
                           <p><a href="static-sql.html#GUID-04CBBBFB-959B-4991-9580-521DC6156489" title="您可以将游标变量用作主变量，这使得在PL / SQL存储的子程序及其客户端之间传递查询结果非常有用。">光标变量作为主机变量</a></p>
                        </li>
                     </ul>
                     <div class="infoboxnotealso" id="GUID-4A6E054A-4002-418D-A1CA-DE849CD7E6D5__GUID-A8A3AA92-B472-4461-81DD-776DE1D0965D">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>有关显式游标的更多信息，请参阅<span class="q">“ <a href="static-sql.html#GUID-89E0242F-42AC-4B21-9DF1-ACD6F4FC03B9">显式游标</a> ”</span></p>
                           </li>
                           <li>
                              <p><span class="q">“ <a href="cursor-variable-declaration.html#GUID-CE884B31-07F0-46AA-8067-EBAF73821F3D__CJABEBDA">对游标变量的限制</a> ”</span></p>
                           </li>
                           <li>
                              <p><a href="../adfns/coding-subprograms-and-packages.html#ADFNS159" target="_blank"><span class="italic">Oracle数据库开发指南</span></a> ，了解游标变量的优点</p>
                           </li>
                           <li>
                              <p><a href="../adfns/coding-subprograms-and-packages.html#ADFNS160" target="_blank"><span class="italic">Oracle数据库开发指南</span></a> ，了解游标变量的缺点</p>
                           </li>
                        </ul>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div><a id="LNPLS483"></a><a id="LNPLS571"></a><a id="LNPLS568"></a><div class="props_rev_3"><a id="GUID-470A7A99-888A-46C2-BDAF-D4710E650F27" name="GUID-470A7A99-888A-46C2-BDAF-D4710E650F27"></a><h4 id="LNPLS-GUID-470A7A99-888A-46C2-BDAF-D4710E650F27" class="sect4"><span class="enumeration_section">6.4.1</span>创建游标变量</h4>
                  <div>
                     <p>要创建游标变量，请声明预定义类型<code class="codeph">SYS_REFCURSOR</code>的变量或定义<code class="codeph">REF</code> <code class="codeph">CURSOR</code>类型，然后声明该类型的变量。
                     </p>
                     <div class="section">
                        <p></p>
                        <div class="infoboxnote" id="GUID-470A7A99-888A-46C2-BDAF-D4710E650F27__GUID-1451E4B1-0D00-451E-A2F3-6C2186557C9A">
                           <p class="notep1">注意：</p>
                           <p>非正式地，游标变量有时被称为<code class="codeph">REF</code> <code class="codeph">CURSOR</code> ）。
                           </p>
                        </div>
                        <p><code class="codeph">REF</code> <code class="codeph">CURSOR</code>类型定义的基本语法是：</p><pre class="oac_no_warn" dir="ltr">TYPE <span class="italic">type_name</span> IS REF CURSOR [RETURN <span class="italic">return_type</span> ]</pre><p>有关完整的语法和语义，请参阅<span class="q">“ <a href="cursor-variable-declaration.html#GUID-CE884B31-07F0-46AA-8067-EBAF73821F3D" title="游标变量类似于显式游标，不限于一个查询。">游标变量声明</a> ”</span> 。
                        </p>
                        <p>如果指定<span class="italic"><code class="codeph">return_type</code></span> ，则该类型的<code class="codeph">REF</code> <code class="codeph">CURSOR</code>类型和游标变量<span class="bold">很强</span> ;如果没有，他们就会变<span class="bold">弱</span> 。<code class="codeph">SYS_REFCURSOR</code>和该类型的游标变量很弱。
                        </p>
                        <p>使用强大的游标变量，您只能关联返回指定类型的查询。使用弱游标变量，您可以关联任何查询。</p>
                        <p>弱光标变量比强光标变量更容易出错，但它们也更灵活。弱<code class="codeph">REF</code> <code class="codeph">CURSOR</code>类型可以互相交换，也可以与预定义类型<code class="codeph">SYS_REFCURSOR</code> 。您可以将弱光标变量的值分配给任何其他弱光标变量。
                        </p>
                        <p>仅当两个游标变量具有相同类型（不仅仅是相同的返回类型）时，才能将强游标变量的值分配给另一个强游标变量。</p>
                        <div class="infoboxnote" id="GUID-470A7A99-888A-46C2-BDAF-D4710E650F27__GUID-75DC04C0-C04D-4CA1-AD89-F5E3623EB8FB">
                           <p class="notep1">注意：</p>
                           <p>您可以仅使用<code class="codeph">PARTITION</code> <code class="codeph">BY</code> <code class="codeph">ANY</code>子句将弱游标变量参数分区为表函数，而不是使用<code class="codeph">PARTITION</code> <code class="codeph">BY</code> <code class="codeph">RANGE</code>或<code class="codeph">PARTITION</code> <code class="codeph">BY</code> <code class="codeph">HASH</code> 。</p>
                           <p>有关语法和语义，请参阅<span class="q">“ <a href="PARALLEL_ENABLE-clause.html#GUID-CFF3C7D3-6438-44C2-9FAF-569F246C37CA" title="启用并行执行功能，使其可以安全地用于并行DML评估的从属会话。">PARALLEL_ENABLE子句</a> ”</span> 。
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-470A7A99-888A-46C2-BDAF-D4710E650F27__BABFHFHH">
                        <p class="titleinexample">例6-24游标变量声明</p>
                        <p>此示例定义强和弱<code class="codeph">REF</code> <code class="codeph">CURSOR</code>类型，这些类型的变量以及预定义类型<code class="codeph">SYS_REFCURSOR</code>的变量。</p><pre class="oac_no_warn" dir="ltr">DECLARE TYPE empcurtyp IS REF CURSOR <span class="bold">RETURN员工％ROWTYPE</span> ; - 强类型TYPE genericcurtyp IS REF CURSOR; - 弱类型cursor1 empcurtyp; - 强大的游标变量cursor2 genericcurtyp; - 弱游标变量my_cursor SYS_REFCURSOR; - 弱光标变量TYPE deptcurtyp IS REF CURSOR <span class="bold">RETURN departments％ROWTYPE</span> ; - 强类型dept_cv deptcurtyp; - 强大的游标变量BEGIN NULL;结束; /</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-470A7A99-888A-46C2-BDAF-D4710E650F27__BABHIJGD">
                        <p class="titleinexample">示例6-25具有用户定义的返回类型的游标变量</p>
                        <p>在此示例中， <span class="italic"><code class="codeph">EmpRecTyp</code></span>是用户定义的<code class="codeph">RECORD</code>类型。
                        </p><pre class="oac_no_warn" dir="ltr">DECLARE <span class="bold">TYPE EmpRecTyp IS RECORD</span> （employee_id NUMBER，last_name VARCHAR2（25），薪水NUMBER（8,2））; TYPE EmpCurTyp是REF CURSOR <span class="bold">RETURN EmpRecTyp</span> ; emp_cv EmpCurTyp; BEGIN NULL;结束; /</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="LNPLS575"></a><div class="props_rev_3"><a id="GUID-87B4D958-520C-4483-BC63-2D1FE4C4CC01" name="GUID-87B4D958-520C-4483-BC63-2D1FE4C4CC01"></a><h4 id="LNPLS-GUID-87B4D958-520C-4483-BC63-2D1FE4C4CC01" class="sect4"><span class="enumeration_section">6.4.2</span>打开和关闭光标变量</h4>
                  <div>
                     <div class="section">
                        <p>声明游标变量后，可以使用<code class="codeph">OPEN</code> <code class="codeph">FOR</code>语句打开它，该语句执行以下操作：</p>
                        <ol>
                           <li>
                              <p>将游标变量与查询关联（通常，查询返回多行）</p>
                              <p>查询可以包含绑定变量的占位符，其值在<code class="codeph">OPEN</code> <code class="codeph">FOR</code>语句的<code class="codeph">USING</code>子句中指定。
                              </p>
                           </li>
                           <li>
                              <p>分配数据库资源以处理查询</p>
                           </li>
                           <li>
                              <p>处理查询;那是：</p>
                              <ol type="a">
                                 <li>
                                    <p>标识结果集</p>
                                    <p>如果查询引用变量，则它们的值会影响结果集。有关详细信息，请参阅<span class="q">“ <a href="static-sql.html#GUID-E03A2A12-D298-4D1C-8CCE-3B5D17DDFC7C" title="与游标变量关联的查询可以引用其范围中的任何变量。">游标变量查询中的变量</a> ”</span> 。
                                    </p>
                                 </li>
                                 <li>
                                    <p>如果查询具有<code class="codeph">FOR</code> <code class="codeph">UPDATE</code>子句，则锁定结果集的行</p>
                                    <p>有关详细信息，请参阅<span class="q">“ <a href="static-sql.html#GUID-6A1C2FD9-9476-4F8D-A2E4-2C967D7F8C08">SELECT FOR UPDATE和FOR UPDATE Cursors</a> ”</span> 。
                                    </p>
                                 </li>
                              </ol>
                           </li>
                           <li>
                              <p>将光标定位在结果集的第一行之前</p>
                           </li>
                        </ol>
                        <p>您无需在重新打开之前关闭游标变量（即，在另一个<code class="codeph">OPEN</code> <code class="codeph">FOR</code>语句中使用它）。重新打开游标变量后，先前与其关联的查询将丢失。
                        </p>
                        <p>当您不再需要游标变量时，请使用<code class="codeph">CLOSE</code>语句将其<code class="codeph">CLOSE</code> ，从而允许重用其资源。关闭游标变量后，无法从其结果集中获取记录或引用其属性。如果您尝试，PL / SQL会引发预定义的异常<code class="codeph">INVALID_CURSOR</code> 。</p>
                        <p>您可以重新打开一个关闭的游标变量。</p>
                        <div class="infoboxnotealso" id="GUID-87B4D958-520C-4483-BC63-2D1FE4C4CC01__GUID-FB759EEE-5DC8-4B19-818E-57305E7A2305">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><span class="q">“ <a href="OPEN-FOR-statement.html#GUID-EB7AF439-FDD3-4461-9E3F-B621E8ABFB96" title="OPEN FOR语句将游标变量与查询相关联，分配数据库资源以处理查询，标识结果集，并将光标定位在结果集的第一行之前。">OPEN FOR Statement</a> ”</span>的语法和语义</p>
                              </li>
                              <li>
                                 <p><span class="q">“ <a href="CLOSE-statement.html#GUID-46E7086C-8C29-4689-A062-0FF059E268FD" title="CLOSE语句关闭一个命名游标，释放其资源以供重用。">CLOSE Statement</a> ”</span>的语法和语义</p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPLS484"></a><a id="LNPLS583"></a><a id="LNPLS581"></a><div class="props_rev_3"><a id="GUID-AA5A2016-1B76-4961-9AFB-EB052F0D0FB2" name="GUID-AA5A2016-1B76-4961-9AFB-EB052F0D0FB2"></a><h4 id="LNPLS-GUID-AA5A2016-1B76-4961-9AFB-EB052F0D0FB2" class="sect4"><span class="enumeration_section">6.4.3</span>使用游标变量获取数据</h4>
                  <div>
                     <p>打开游标变量后，可以使用<code class="codeph">FETCH</code>语句获取查询结果集的行。
                     </p>
                     <div class="section">
                        <p>游标变量的返回类型必须与<code class="codeph">FETCH</code>语句的<span class="italic"><code class="codeph">into_clause</code></span>兼容。如果游标变量很强，PL / SQL会在编译时捕获不兼容性。如果游标变量很弱，PL / SQL会在运行时捕获不兼容性，在第一次获取之前引发预定义的异常<code class="codeph">ROWTYPE_MISMATCH</code> 。
                        </p>
                        <div class="infoboxnotealso" id="GUID-AA5A2016-1B76-4961-9AFB-EB052F0D0FB2__GUID-E31F3575-D2FD-44EC-876B-AA95BA3D1869">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><span class="q">“ <a href="static-sql.html#GUID-9DEED64C-A87E-4EAD-97DA-ABDD3FDF172C">使用显式游标获取数据</a> ”</span></p>
                              </li>
                              <li>
                                 <p><span class="q">“ <a href="FETCH-statement.html#GUID-75BC6E63-841A-4103-9B96-8AC97F5C28BB" title="FETCH语句从多行查询的结果集中检索数据行 - 一次一行，一次几行，或一次所有行 - 并将数据存储在变量，记录或集合中。">FETCH语句</a> ”</span>的完整语法和语义</p>
                              </li>
                              <li>
                                 <p><span class="q">“ <a href="plsql-optimization-and-tuning.html#GUID-541A8B35-9B8F-432F-9E30-E73305A6E17C" title="具有BULK COLLECT子句（也称为FETCH BULK COLLECT语句）的FETCH语句将整个结果集提取到一个或多个集合变量中。">带有BULK COLLECT子句的</a></span> <code class="codeph">FETCH</code>语句<span class="q">”，</span>以获取有关一次返回多行的<code class="codeph">FETCH</code>语句的信息</p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-AA5A2016-1B76-4961-9AFB-EB052F0D0FB2__BABDJIFB">
                        <p class="titleinexample">示例6-26使用游标变量获取数据</p>
                        <p>此示例使用一个游标变量来执行<a href="static-sql.html#GUID-9DEED64C-A87E-4EAD-97DA-ABDD3FDF172C__BABCFDJE">示例6-6</a>对两个显式游标的操作。第一个<code class="codeph">OPEN</code> <code class="codeph">FOR</code>语句包括查询本身。第二个<code class="codeph">OPEN</code> <code class="codeph">FOR</code>语句引用一个值为查询的变量。
                        </p><pre class="oac_no_warn" dir="ltr">DECLARE <span class="bold">cv SYS_REFCURSOR; - 游标变量</span> v_lastname employees.last_name％TYPE; -  last_name的变量v_jobid employees.job_id％TYPE; -  job_id的变量<span class="bold">query_2 VARCHAR2（200）：=</span> <span class="bold">'SELECT * FROM employees</span> <span class="bold">WHERE REGEXP_LIKE（job_id，''[ACADFIMKSA] _M [ANGR]''）</span> <span class="bold">ORDER BY job_id';</span> v_employees employees％ROWTYPE; - 记录变量行表BEGIN <span class="bold">OPEN cv FOR</span> <span class="bold">SELECT last_name，job_id FROM employees</span> <span class="bold">WHERE REGEXP_LIKE（job_id，'S [HT] _CLERK'）</span> <span class="bold">ORDER BY last_name;</span> LOOP  - 将2列写入变量FETCH <span class="bold">cv</span> INTO v_lastname，v_jobid; <span class="bold">cv</span> ％NOTFOUND时退出; DBMS_OUTPUT.PUT_LINE（RPAD（v_lastname，25，''）|| v_jobid）;结束循环; DBMS_OUTPUT.PUT_LINE（'-------------------------------------'）; <span class="bold">打开cv FOR query_2;</span> LOOP  - 将整行提取到v_employees记录FETCH <span class="bold">cv</span> INTO v_employees; <span class="bold">cv</span> ％NOTFOUND时退出; DBMS_OUTPUT.PUT_LINE（RPAD（v_employees.last_name，25，''）|| v_employees.job_id）;结束循环;关闭<span class="bold">cv</span> ;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">Atkinson ST_CLERK Bell SH_CLERK Bissot ST_CLERK ......Walsh SH_CLERK ------------------------------------- Higgins AC_MGR Greenberg FI_MGR Hartstein MK_MAN ...Zlotkey SA_MAN</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-AA5A2016-1B76-4961-9AFB-EB052F0D0FB2__BABGAICI">
                        <p class="titleinexample">示例6-27从游标变量获取到集合中</p>
                        <p>此示例使用<code class="codeph">FETCH</code>语句的<code class="codeph">BULK</code> <code class="codeph">COLLECT</code>子句从游标变量获取到两个集合（嵌套表）。
                        </p><pre class="oac_no_warn" dir="ltr">DECLARE TYPE empcurtyp是REF CURSOR; TYPE名称列表IS TABLE OF employees.last_name％TYPE; TYPE sallist IS TABLE OF employees.salary％TYPE; emp_cv empcurtyp;姓名列表; sals sallist; BEGIN OPEN emp_cv FOR SELECT last_name，salary FROM employees WHERE job_id ='SA_REP'ORDER BY salary DESC; <span class="bold">FETCH emp_cv BULK收集名称，sals;</span>关闭emp_cv; - 遍历名称和sals集合FOR i IN名称。第一..名字。LAST LOOP DBMS_OUTPUT.PUT_LINE（'Name ='|| names（i）||'，salary ='|| sals（i））;结束循环;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">姓名= Ozer，薪水= 11500姓名= Abel，薪水= 11000姓名= Vishney，薪水= 10500 ......姓名=库马尔，薪水= 6100</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="LNPLS485"></a><div class="props_rev_3"><a id="GUID-7251E068-86C3-4B82-A8CE-54E0C9B9FCB2" name="GUID-7251E068-86C3-4B82-A8CE-54E0C9B9FCB2"></a><h4 id="LNPLS-GUID-7251E068-86C3-4B82-A8CE-54E0C9B9FCB2" class="sect4"><span class="enumeration_section">6.4.4</span>为光标变量赋值</h4>
                  <div>
                     <p>您可以为PL / SQL游标变量分配另一个PL / SQL游标变量或主机游标变量的值。</p>
                     <div class="section">
                        <p>语法是：</p><pre class="oac_no_warn" dir="ltr"><span class="italic">target_cursor_variable</span> ：= <span class="italic">source_cursor_variable</span> ;</pre><p>如果<span class="italic"><code class="codeph">source_cursor_variable</code></span>打开，那么在赋值之后， <span class="italic"><code class="codeph">target_cursor_variable</code></span>也会打开。两个游标变量指向同一个SQL工作区。
                        </p>
                        <p>如果<span class="italic"><code class="codeph">source_cursor_variable</code></span>未打开，则在赋值后打开<span class="italic"><code class="codeph">target_cursor_variable</code></span>不会打开<span class="italic"><code class="codeph">source_cursor_variable</code></span> 。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPLS488"></a><a id="LNPLS489"></a><a id="LNPLS487"></a><div class="props_rev_3"><a id="GUID-E03A2A12-D298-4D1C-8CCE-3B5D17DDFC7C" name="GUID-E03A2A12-D298-4D1C-8CCE-3B5D17DDFC7C"></a><h4 id="LNPLS-GUID-E03A2A12-D298-4D1C-8CCE-3B5D17DDFC7C" class="sect4"><span class="enumeration_section">6.4.5</span>游标变量查询中的变量</h4>
                  <div>
                     <p>与游标变量关联的查询可以引用其范围中的任何变量。</p>
                     <p>当您使用<code class="codeph">OPEN</code> <code class="codeph">FOR</code>语句打开游标变量时，PL / SQL会评估查询中的所有变量，并在识别结果集时使用这些值。稍后更改变量的值不会更改结果集。
                     </p>
                     <p>要更改结果集，必须更改变量的值，然后再次为同一查询打开游标变量，如<a href="static-sql.html#GUID-E03A2A12-D298-4D1C-8CCE-3B5D17DDFC7C__BABIHIBA">例6-29所示</a> 。
                     </p>
                     <div class="example" id="GUID-E03A2A12-D298-4D1C-8CCE-3B5D17DDFC7C__BABCHEGG">
                        <p class="titleinexample">示例6-28游标变量查询中的变量 - 无结果集更改</p>
                        <p>此示例为引用变量<code class="codeph">factor</code>的查询打开游标变量，该变量<code class="codeph">factor</code>的值为2。因此， <code class="codeph">sal_multiple</code>总是2倍<code class="codeph">sal</code> ，尽管该<code class="codeph">factor</code>在每次提取后递增。
                        </p><pre class="oac_no_warn" dir="ltr">DECLARE sal employees.salary％TYPE; sal_multiple employees.salary％TYPE; <span class="bold">因子INTEGER：= 2;</span> cv SYS_REFCURSOR; BEGIN <span class="bold">OPEN cv FOR</span> <span class="bold">SELECT薪水，薪水*因素</span> <span class="bold">来自员工</span> <span class="bold">WHERE job_id LIKE'AD_％'; -  PL / SQL评估因子</span> LOOP <span class="bold">FETCH cv INTO sal，sal_multiple;</span> cv％NOTFOUND时退出; DBMS_OUTPUT.PUT_LINE（'factor ='|| factor）; DBMS_OUTPUT.PUT_LINE（'sal ='|| sal）; DBMS_OUTPUT.PUT_LINE（'sal_multiple ='|| sal_multiple）; <span class="bold">factor：= factor + 1; - 不影响sal_multiple</span> END LOOP;关闭cv;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">factor = 2 sal = 4400 sal_multiple = 8800 factor = 3 sal = 24000 sal_multiple = 48000 factor = 4 sal = 17000 sal_multiple = 34000 factor = 5 sal = 17000 sal_multiple = 34000</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-E03A2A12-D298-4D1C-8CCE-3B5D17DDFC7C__BABIHIBA">
                        <p class="titleinexample">示例6-29游标变量查询 - 结果集更改中的变量</p><pre class="oac_no_warn" dir="ltr">DECLARE sal employees.salary％TYPE; sal_multiple employees.salary％TYPE; <span class="bold">因子INTEGER：= 2;</span> cv SYS_REFCURSOR; BEGIN DBMS_OUTPUT.PUT_LINE（'factor ='|| factor）; <span class="bold">OPEN cv FOR</span> <span class="bold">SELECT薪水，薪水*因素</span> <span class="bold">FROM员工</span> <span class="bold">WHERE job_id LIKE'AD_％'; -  PL / SQL评估因子</span> LOOP FETCH cv INTO sal，sal_multiple; cv％NOTFOUND时退出; DBMS_OUTPUT.PUT_LINE（'sal ='|| sal）; DBMS_OUTPUT.PUT_LINE（'sal_multiple ='|| sal_multiple）;结束循环; <span class="bold">factor：= factor + 1;</span> DBMS_OUTPUT.PUT_LINE（'factor ='|| factor）; <span class="bold">OPEN cv FOR</span> <span class="bold">SELECT薪水，薪水*因素</span> <span class="bold">FROM员工</span> <span class="bold">WHERE job_id LIKE'AD_％'; -  PL / SQL评估因子</span> LOOP FETCH cv INTO sal，sal_multiple; cv％NOTFOUND时退出; DBMS_OUTPUT.PUT_LINE（'sal ='|| sal）; DBMS_OUTPUT.PUT_LINE（'sal_multiple ='|| sal_multiple）;结束循环;关闭cv;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">factor = 2 sal = 4400 sal_multiple = 8800 sal = 24000 sal_multiple = 48000 sal = 17000 sal_multiple = 34000 sal = 17000 sal_multiple = 34000 factor = 3 sal = 4400 sal_multiple = 13200 sal = 24000 sal_multiple = 72000 sal = 17000 sal_multiple = 51000 sal = 17000 sal_multiple = 51000</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="LNPLS491"></a><a id="LNPLS590"></a><div class="props_rev_3"><a id="GUID-65ADB424-2C2D-49ED-9E98-99A3A68BA248" name="GUID-65ADB424-2C2D-49ED-9E98-99A3A68BA248"></a><h4 id="LNPLS-GUID-65ADB424-2C2D-49ED-9E98-99A3A68BA248" class="sect4"><span class="enumeration_section">6.4.6</span>查询集合</h4>
                  <div>
                     <div class="section">
                        <p>如果满足以下所有条件，您可以查询集合：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p>集合的数据类型要么在架构级别创建，要么在包规范中声明。</p>
                           </li>
                           <li>
                              <p>集合元素的数据类型是标量数据类型，用户定义类型或记录类型。</p>
                           </li>
                        </ul>
                        <p>在查询<code class="codeph">FROM</code>子句中，集合在<span class="italic"><code class="codeph">table_collection_expression</code></span>显示为<code class="codeph">TABLE</code>运算符的参数。
                        </p>
                        <div class="infoboxnote" id="GUID-65ADB424-2C2D-49ED-9E98-99A3A68BA248__GUID-F4EE93B3-BA9A-4212-877F-8CB0F63EB33C">
                           <p class="notep1">注意：</p>
                           <p>在SQL上下文中，您不能使用在包规范中声明其返回类型的函数。</p>
                        </div>
                        <div class="infoboxnotealso" id="GUID-65ADB424-2C2D-49ED-9E98-99A3A68BA248__GUID-68A74A5E-1207-423A-A260-15AC3B635EB9">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>有关<span class="italic"><code class="codeph">table_collection_expression</code></span>信息，请<span class="italic"><code class="codeph">table_collection_expression</code></span> <a href="../sqlrf/SELECT.html#SQLRF55241" target="_blank"><span class="italic">Oracle数据库SQL语言参考</span></a></p>
                              </li>
                              <li>
                                 <p>有关<code class="codeph">CREATE</code> <code class="codeph">PACKAGE</code>语句的信息，请<span class="q"><a href="CREATE-PACKAGE-statement.html#GUID-03A70A54-90FF-4293-B6B8-F0B35E184AC5" title="The CREATE PACKAGE statement creates or replaces the specification for a stored package, which is an encapsulated collection of related procedures, functions, and other program objects stored as a unit in the database.">参见</a> “ <a href="CREATE-PACKAGE-statement.html#GUID-03A70A54-90FF-4293-B6B8-F0B35E184AC5" title="CREATE PACKAGE语句创建或替换存储包的规范，存储包是数据库中作为一个单元存储的相关过程，函数和其他程序对象的封装集合。">CREATE PACKAGE语句</a> ”</span></p>
                              </li>
                              <li>
                                 <p> 有关集合类型和集合变量的信息，请参阅<span class="q">“ <a href="plsql-collections-and-records.html#GUID-7115C8B6-62F9-496D-BEC3-F7441DFE148A" title="PL / SQL允许您定义两种复合数据类型：集合和记录。">PL / SQL集合和记录</a> ”</span></p>
                              </li>
                              <li>
                                 <p><a href="dynamic-sql.html#GUID-BAC52F38-B427-4860-9B6D-336B3AEE6AD2__CHDDBFJB">例7-9</a> ， <span class="q">“使用本机动态SQL查询集合”</span></p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-65ADB424-2C2D-49ED-9E98-99A3A68BA248__BABJDADA">
                        <p class="titleinexample">示例6-30使用静态SQL查询集合</p>
                        <p>在此示例中，游标变量与关联记录数组上的查询相关联。嵌套表类型<code class="codeph">mytab</code>在包规范中声明。
                        </p><pre class="oac_no_warn" dir="ltr">创建或替换包装pkg AUTHID DEFINER作为类型rec IS RECORD（f1 NUMBER，f2 VARCHAR2（30））; TYPE mytab IS TABLE OF rec INDEX BY pls_integer;结束; DECLARE <span class="bold">v1 pkg.mytab; - 记录集合</span> v2 pkg.rec; c1 SYS_REFCURSOR; BEGIN v1（1）.f1：= 1; v1（1）.f2：='one'; <span class="bold">OPEN c1 FOR SELECT * FROM TABLE（v1）;</span> FETCH c1 INTO v2;关闭c1; DBMS_OUTPUT.PUT_LINE（'记录中的值为'|| v2.f1 ||'和'|| v2.f2）;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">记录中的值是1和1</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="LNPLS494"></a><div class="props_rev_3"><a id="GUID-1361A503-BA2D-400B-987A-59B2824E316E" name="GUID-1361A503-BA2D-400B-987A-59B2824E316E"></a><h4 id="LNPLS-GUID-1361A503-BA2D-400B-987A-59B2824E316E" class="sect4"><span class="enumeration_section">6.4.7</span>游标变量属性</h4>
                  <div>
                     <p>游标变量与显式游标具有相同的属性（请参阅<a href="static-sql.html#GUID-D483DF0B-15DB-4466-9870-0F6E1518A40D">显式游标属性</a> 。）。游标变量属性值的语法是<span class="italic"><code class="codeph">cursor_variable_name</code></span> ，后面紧跟<span class="italic"><code class="codeph">attribute</code></span> （例如， <code class="codeph">cv%ISOPEN</code> ）。如果游标变量未打开，则引用除<code class="codeph">%ISOPEN</code>之外的任何属性都会引发预定义的异常<code class="codeph">INVALID_CURSOR</code> 。</p>
                  </div>
               </div><a id="LNPLS577"></a><a id="LNPLS578"></a><a id="LNPLS579"></a><a id="LNPLS572"></a><div class="props_rev_3"><a id="GUID-9713DFC2-3C2E-49B2-922F-02D43F9D0619" name="GUID-9713DFC2-3C2E-49B2-922F-02D43F9D0619"></a><h4 id="LNPLS-GUID-9713DFC2-3C2E-49B2-922F-02D43F9D0619" class="sect4"><span class="enumeration_section">6.4.8</span>光标变量作为子程序参数</h4>
                  <div>
                     <p>您可以使用游标变量作为子程序参数，这使得它可以在子程序之间传递查询结果。</p>
                     <p>例如：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>您可以在一个子程序中打开游标变量，并在不同的子程序中处理它。</p>
                        </li>
                        <li>
                           <p>在多语言应用程序中，PL / SQL子程序可以使用游标变量将结果集返回到用不同语言编写的子程序。</p>
                        </li>
                     </ul>
                     <div class="infoboxnote" id="GUID-9713DFC2-3C2E-49B2-922F-02D43F9D0619__GUID-0AC269D2-89A3-45DA-80A0-5873F394FDF3">
                        <p class="notep1">注意：</p>
                        <p>调用和调用的子程序必须位于同一个数据库实例中。您不能将游标变量传递或返回到通过数据库链接调用的子程序。</p>
                     </div>
                     <div class="infoboxnote" id="GUID-9713DFC2-3C2E-49B2-922F-02D43F9D0619__GUID-0A68C42F-B015-47F0-A777-56ADCE4BA2E8">
                        <p class="notep1">警告：</p>
                        <p>因为游标变量是指针，所以将它们用作子程序参数会增加子程序参数混叠的可能性，这可能会产生意想不到的结果。有关详细信息，请参见<span class="q">“ <a href="plsql-subprograms.html#GUID-2CCDEA03-F0ED-463A-BEC1-3F9430047692">使用光标变量参数的子程序参数别名</a> ”</span> 。
                        </p>
                     </div>
                     <p>将游标变量声明为子程序的形式参数时：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>如果子程序打开或为游标变量赋值，则参数模式必须为<code class="codeph">IN</code> <code class="codeph">OUT</code> 。</p>
                        </li>
                        <li>
                           <p>如果子程序仅从光标变量中取出或关闭，则参数模式可以是<code class="codeph">IN</code>或<code class="codeph">IN</code> <code class="codeph">OUT</code> 。</p>
                        </li>
                     </ul>
                     <p>相应的形式和实际游标变量参数必须具有兼容的返回类型。否则，PL / SQL会引发预定义的异常<code class="codeph">ROWTYPE_MISMATCH</code> 。</p>
                     <p>要在不同PL / SQL单元的子程序之间传递游标变量参数，请在包中定义参数的<code class="codeph">REF</code> <code class="codeph">CURSOR</code>类型。当类型在包中时，多个子程序可以使用它。一个子程序可以声明该类型的形式参数，其他子程序可以声明该类型的变量并将它们传递给第一个子程序。
                     </p>
                     <div class="infoboxnotealso" id="GUID-9713DFC2-3C2E-49B2-922F-02D43F9D0619__GUID-70AC559A-0CBE-4CEA-8798-F1F604760F5D">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li></li>
                           <li>
                              <p><span class="q">“ <a href="plsql-subprograms.html#GUID-C0397690-70F4-480D-ADC9-02D277DAA1BB">子程序参数</a> ”</span>有关子程序参数的更多信息</p>
                           </li>
                           <li>
                              <p><span class="q">“ <a href="static-sql.html#GUID-77FF2850-F338-4C77-9577-0FE3399D39BA" title="CURSOR表达式返回嵌套游标。">CURSOR表达式</a> ”</span>有关<code class="codeph">CURSOR</code>表达式的信息，可以是正式游标变量参数的实际参数</p>
                           </li>
                           <li>
                              <p><a href="plsql-packages.html#GUID-C285EC5A-BE50-4192-A88E-48C0778B34E0" title="本章介绍如何将相关的PL / SQL代码和数据捆绑到一个包中，其内容可供许多应用程序使用。">PL / SQL包</a> ，有关包的更多信息</p>
                           </li>
                        </ul>
                     </div>
                     <div class="example" id="GUID-9713DFC2-3C2E-49B2-922F-02D43F9D0619__BABIIGAG">
                        <p class="titleinexample">示例6-31打开一个查询的游标变量的过程</p>
                        <p>此示例在包中定义<code class="codeph">REF</code> <code class="codeph">CURSOR</code>类型和打开该类型的游标变量参数的过程。
                        </p><pre class="oac_no_warn" dir="ltr">创建或替换包装emp_data AUTHID DEFINER作为类型empcurtyp IS REF CURSOR RETURN员工％ROWTYPE;程序open_emp_cv（emp_cv IN OUT empcurtyp）; END emp_data; /创建或替换程序包emp_data作为程序open_emp_cv（ <span class="bold">emp_cv IN OUT EmpCurTyp</span> ）是开始的<span class="bold">emp_cv FOR SELECT * FROM employees;</span> END open_emp_cv; END emp_data; /</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-9713DFC2-3C2E-49B2-922F-02D43F9D0619__BABFEJED">
                        <p class="titleinexample">示例6-32为选择的查询打开游标变量（相同的返回类型）</p>
                        <p>在此示例中，存储过程为所选查询打开其游标变量参数。查询具有相同的返回类型。</p><pre class="oac_no_warn" dir="ltr">创建或替换包装emp_data AUTHID DEFINER作为类型empcurtyp IS REF CURSOR RETURN员工％ROWTYPE;程序open_emp_cv（emp_cv IN OUT empcurtyp，选择INT）; END emp_data; / CREATE OR REPLACE PACKAGE BODY emp_data AS程序open_emp_cv（ <span class="bold">emp_cv IN OUT empcurtyp，choice INT</span> ）IS BEGIN IF <span class="bold">choice = 1</span>然后打开emp_cv FOR SELECT * FROM employees <span class="bold">WHERE commission_pct IS NOT NULL</span> ; ELSIF <span class="bold">选择= 2</span>然后打开emp_cv FOR SELECT * FROM employees <span class="bold">WHERE salary&gt; 2500</span> ; ELSIF <span class="bold">选择= 3</span>然后打开emp_cv FOR SELECT * FROM employees <span class="bold">WHERE department_id = 100</span> ;万一;结束; END emp_data; /</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-9713DFC2-3C2E-49B2-922F-02D43F9D0619__BABEJEII">
                        <p class="titleinexample">示例6-33为选择的查询打开游标变量（不同的返回类型）</p>
                        <p>在此示例中，存储过程为所选查询打开其游标变量参数。查询具有不同的返回类型。</p><pre class="oac_no_warn" dir="ltr">创建或替换包装admin_data AUTHID DEFINER作为类型gencurtyp是REF CURSOR; PROCEDURE open_cv（generic_cv IN OUT gencurtyp，choice INT）; END admin_data; /创建或替换程序包admin_data AS程序open_cv（ <span class="bold">generic_cv IN OUT gencurtyp，choice INT</span> ）IS BEGIN IF <span class="bold">choice = 1</span>那么OPEN generic_cv FOR SELECT * FROM <span class="bold">employees</span> ; ELSIF <span class="bold">选择= 2</span>然后打开generic_cv FOR SELECT * FROM <span class="bold">部门</span> ; ELSIF <span class="bold">choice = 3</span> THEN OPEN generic_cv FOR SELECT * FROM <span class="bold">jobs</span> ;万一;结束; END admin_data; /</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="LNPLS498"></a><a id="LNPLS580"></a><div class="props_rev_3"><a id="GUID-04CBBBFB-959B-4991-9580-521DC6156489" name="GUID-04CBBBFB-959B-4991-9580-521DC6156489"></a><h4 id="LNPLS-GUID-04CBBBFB-959B-4991-9580-521DC6156489" class="sect4"><span class="enumeration_section">6.4.9</span>光标变量作为主机变量</h4>
                  <div>
                     <p>您可以将游标变量用作主变量，这使得在PL / SQL存储的子程序及其客户端之间传递查询结果非常有用。</p>
                     <p>当游标变量是主变量时，PL / SQL和客户端（主机环境）共享指向存储结果集的SQL工作区的指针。</p>
                     <p>要将游标变量用作主变量，请在主机环境中声明游标变量，然后将其作为输入主机变量（绑定变量）传递给PL / SQL。主机游标变量与任何查询返回类型兼容（如弱PL / SQL游标变量）。</p>
                     <p>即使您将游标变量的值从一个作用域传递到另一个作用域，任何游标变量都指向SQL工作区仍然可以访问。例如，在<a href="static-sql.html#GUID-04CBBBFB-959B-4991-9580-521DC6156489__CHDJEEFC">例6-34中</a> ，Pro * C程序将主机游标变量传递给嵌入式PL / SQL匿名块。块运行后，游标变量仍指向SQL工作区。
                     </p>
                     <p>如果客户端有PL / SQL引擎，则从客户端到服务器的调用不受任何限制。例如，您可以在客户端声明游标变量，在服务器端打开并从中获取，并继续从客户端获取它。您还可以使用PL / SQL匿名块减少网络流量，该块在一次往返中打开或关闭多个主机游标变量。例如：</p><pre class="oac_no_warn" dir="ltr">/ *主机环境中的PL / SQL匿名块* / BEGIN OPEN：emp_cv FOR SELECT * FROM employees; OPEN：dept_cv FOR SELECT * FROM departments; OPEN：loc_cv FOR SELECT * FROM locations;结束; /</pre><p>因为在PL / SQL匿名块运行后，游标变量仍然指向SQL工作区，所以客户端程序可以使用它们。当客户端程序不再需要游标时，它可以使用PL / SQL匿名块来关闭它们。例如：</p><pre class="oac_no_warn" dir="ltr">/ *主机环境中的PL / SQL匿名块* / BEGIN CLOSE：emp_cv;关闭：dept_cv;关闭：loc_cv;结束; /</pre><p>此方法对于填充多块表单非常有用，就像在Oracle Forms中一样。例如，您可以在一次往返中打开多个SQL工作区，如下所示：</p><pre class="oac_no_warn" dir="ltr">/ *主机环境中的PL / SQL匿名块* / BEGIN OPEN：c1 FOR SELECT 1 FROM DUAL; OPEN：c2 FOR SELECT 1 FROM DUAL; OPEN：c3 FOR SELECT 1 FROM DUAL;结束; /</pre><div class="infoboxnote" id="GUID-04CBBBFB-959B-4991-9580-521DC6156489__GUID-D5A3C4B8-C0F1-4E40-BCF5-598B6CE0CE32">
                        <p class="notep1">注意：</p>
                        <p>如果将主机游标变量从Oracle调用接口（OCI）客户端绑定到PL / SQL，那么除非您在同一服务器调用上打开它，否则无法从服务器端获取它。</p>
                     </div>
                     <div class="example" id="GUID-04CBBBFB-959B-4991-9580-521DC6156489__CHDJEEFC">
                        <p class="titleinexample">示例6-34 Pro * C客户端程序中的游标变量作为主变量</p>
                        <p>在此示例中，Pro * C客户端程序声明游标变量和选择器，并将它们作为主机变量传递给PL / SQL匿名块，这将打开所选查询的游标变量。</p><pre class="oac_no_warn" dir="ltr">EXEC SQL BEGIN DECLARE SECTION; SQL_CURSOR generic_cv; - 声明主机游标变量。int选择; - 声明选择器。EXEC SQL END DECLARE SECTION; EXEC SQL ALLOCATE：generic_cv; - 初始化主机游标变量。- 将主机游标变量和选择器传递给PL / SQL块。/ EXEC SQL EXECUTE BEGIN IF：choice = 1然后打开：generic_cv FOR SELECT * FROM employees; ELSIF：choice = 2然后打开：generic_cv FOR SELECT * FROM departments; ELSIF：choice = 3然后打开：generic_cv FOR SELECT * FROM jobs;万一;结束; END-EXEC;</pre></div>
                     <!-- class="example" -->
                  </div>
               </div>
            </div><a id="LNPLS589"></a><a id="LNPLS00606"></a><div class="props_rev_3"><a id="GUID-77FF2850-F338-4C77-9577-0FE3399D39BA" name="GUID-77FF2850-F338-4C77-9577-0FE3399D39BA"></a><h3 id="LNPLS-GUID-77FF2850-F338-4C77-9577-0FE3399D39BA" class="sect3"><span class="enumeration_section">6.5</span> CURSOR表达式</h3>
               <div>
                  <p><code class="codeph">CURSOR</code>表达式返回嵌套游标。
                  </p>
                  <p>它有这样的语法：</p><pre class="oac_no_warn" dir="ltr">CURSOR（ <span class="italic">子查询</span> ）</pre><p>您可以在不是子查询的<code class="codeph">SELECT</code>语句中使用<code class="codeph">CURSOR</code>表达式（如<a href="static-sql.html#GUID-77FF2850-F338-4C77-9577-0FE3399D39BA__BABFGHDG">示例6-35所示</a> ），也可以将其传递给接受游标变量参数的函数（请参阅<span class="q">“将<a href="plsql-optimization-and-tuning.html#GUID-BC13A2D1-A182-46C7-A3DC-959724DD5BD6">CURSOR表达式传递给流水线表函数</a> ”</span> ）。您不能将游标表达式与隐式游标一起使用。
                  </p>
                  <div class="infoboxnotealso" id="GUID-77FF2850-F338-4C77-9577-0FE3399D39BA__GUID-6AF346EB-B050-4754-9D1F-1EE3960FF72F">
                     <p class="notep1">也可以看看：</p>
                     <p>有关<code class="codeph">CURSOR</code>表达式的更多信息，包括限制，请参阅<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/lnpls&amp;id=SQLRF52077" target="_blank"><span class="italic">Oracle数据库SQL语言参考</span></a></p>
                  </div>
                  <div class="example" id="GUID-77FF2850-F338-4C77-9577-0FE3399D39BA__BABFGHDG">
                     <p class="titleinexample">例6-35 CURSOR表达式</p>
                     <p>此示例声明并定义包含游标表达式的查询的显式游标。对于<code class="codeph">departments</code>表中的每个部门，嵌套游标返回该部门中每个员工的姓氏（它从<code class="codeph">employees</code>表中检索）。
                     </p><pre class="oac_no_warn" dir="ltr">DECLARE TYPE emp_cur_typ是REF CURSOR; emp_cur emp_cur_typ; dept_name departments.department_name％TYPE; emp_name employees.last_name％TYPE; CURSOR c1 IS SELECT department_name， <span class="bold">CURSOR（SELECT</span> <span class="bold">e.last_name</span> <span class="bold">FROM employees e</span> <span class="bold">WHERE e.department_id = d.department_id</span> <span class="bold">ORDER BY</span> <span class="bold">e.last_name</span> <span class="bold">）</span> employees FROM departments d WHERE department_name <span class="bold">LIKE'A</span> ％'ORDER BY department_name;开始打开c1; LOOP  - 处理查询结果集的每一行FETCH c1 INTO dept_name，emp_cur;退出时c1％NOTFOUND; DBMS_OUTPUT.PUT_LINE（'Department：'|| dept_name）; LOOP  - 处理每行子查询结果集FETCH emp_cur INTO emp_name;当emp_cur％NOTFOUND时退出; DBMS_OUTPUT.PUT_LINE（' -  Employee：'|| emp_name）;结束循环;结束循环;关闭c1;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">部门：会计 - 员工：Gietz  - 员工：Higgins部门：行政 - 员工：Whalen</pre></div>
                  <!-- class="example" -->
               </div>
            </div><a id="LNPLS503"></a><a id="LNPLS00608"></a><div class="props_rev_3"><a id="GUID-218080C2-A7C5-42CC-B34E-A08A0C9341C1" name="GUID-218080C2-A7C5-42CC-B34E-A08A0C9341C1"></a><h3 id="LNPLS-GUID-218080C2-A7C5-42CC-B34E-A08A0C9341C1" class="sect3"><span class="enumeration_section">6.6</span>交易处理和控制</h3>
               <div>
                  <p><span class="bold">事务处理</span>是Oracle数据库功能，允许多个用户同时处理数据库，并确保每个用户看到一致的数据版本，并确保以正确的顺序应用所有更改。
                  </p>
                  <p><span class="bold">事务</span>是Oracle数据库作为一个单元处理的一个或多个SQL语句的序列：要么执行所有语句，要么都不执行。
                  </p>
                  <p>不同的用户可以写入相同的数据结构，而不会伤害彼此的数据或相互协调，因为Oracle数据库会自动锁定数据结构。为了最大限度地提高数据可用性，Oracle数据库会在最短的时间内锁定最少量的数据。</p>
                  <p>您很少需要编写额外的代码来防止多个用户同时访问数据的问题。但是，如果确实需要此级别的控制，则可以手动覆盖Oracle数据库的默认锁定机制。</p>
                  <div class="section">
                     <p class="subhead2" id="GUID-218080C2-A7C5-42CC-B34E-A08A0C9341C1__GUID-7B8E02AC-BE21-4252-ADAB-F57FF58B2E0B">话题</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="static-sql.html#GUID-56EC1B31-CA06-4460-A098-49ABD4706B9C" title="COMMIT语句结束当前事务，使其更改成为永久性且对其他用户可见。">COMMIT声明</a></p>
                        </li>
                        <li>
                           <p><a href="static-sql.html#GUID-B1B20D2F-C421-446C-9171-1D03E2D77BF8" title="ROLLBACK语句结束当前事务并撤消在该事务期间所做的任何更改。">ROLLBACK声明</a></p>
                        </li>
                        <li>
                           <p><a href="static-sql.html#GUID-68924CF6-130E-497B-9DA8-7B3E4D510FA6" title="SAVEPOINT语句命名并标记事务处理中的当前点。">SAVEPOINT声明</a></p>
                        </li>
                        <li>
                           <p><a href="static-sql.html#GUID-A0771963-D96F-4AC5-A74A-242D064825DA" title="在运行INSERT，UPDATE，DELETE或MERGE语句之前，数据库标记一个隐式保存点（对您不可用）。如果语句失败，则数据库将回滚到保存点。">隐式回滚</a></p>
                        </li>
                        <li>
                           <p><a href="static-sql.html#GUID-EC9CC8B7-5DDD-4B60-83BF-686A9FD43B3D" title="您可以使用SET TRANSACTION语句开始只读或读写事务，建立隔离级别，或将当前事务分配给指定的回滚段。">SET TRANSACTION声明</a></p>
                        </li>
                        <li>
                           <p><a href="static-sql.html#GUID-213C196F-7FE4-425C-93E4-54B9FAFF5030" title="默认情况下，Oracle数据库会自动锁定数据结构，这样可以让不同的应用程序写入相同的数据结构，而不会损害彼此的数据或相互协调。">覆盖默认锁定</a></p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <div class="infoboxnotealso" id="GUID-218080C2-A7C5-42CC-B34E-A08A0C9341C1__GUID-1B6E192B-EA8C-4869-B85F-0D57624C8570">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/lnpls&amp;id=CNCPT016" target="_blank"><span class="italic">Oracle Database Concepts</span></a>有关事务的更多信息</p>
                           </li>
                           <li>
                              <p>有关事务处理的更多信息，请<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/lnpls&amp;id=CNCPT1118" target="_blank"><span class="italic">参见Oracle Database Concepts</span></a></p>
                           </li>
                           <li>
                              <p>有关Oracle数据库锁定机制的更多信息，请<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/lnpls&amp;id=CNCPT1331" target="_blank"><span class="italic">参见Oracle数据库概念</span></a></p>
                           </li>
                           <li>
                              <p> 有关手动数据锁的更多信息，请<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/lnpls&amp;id=CNCPT1363" target="_blank"><span class="italic">参见Oracle数据库概念</span></a></p>
                           </li>
                        </ul>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div><a id="LNPLS593"></a><a id="LNPLS592"></a><div class="props_rev_3"><a id="GUID-56EC1B31-CA06-4460-A098-49ABD4706B9C" name="GUID-56EC1B31-CA06-4460-A098-49ABD4706B9C"></a><h4 id="LNPLS-GUID-56EC1B31-CA06-4460-A098-49ABD4706B9C" class="sect4"><span class="enumeration_section">6.6.1</span> COMMIT声明</h4>
                  <div>
                     <p><code class="codeph">COMMIT</code>语句结束当前事务，使其更改成为永久性且对其他用户可见。
                     </p>
                     <div class="infoboxnote" id="GUID-56EC1B31-CA06-4460-A098-49ABD4706B9C__GUID-F935E073-45EA-4A5D-8D4A-B7E74BF15B1A">
                        <p class="notep1">注意：</p>
                        <p>事务可以跨多个块，块可以包含多个事务。</p>
                     </div>
                     <p><code class="codeph">COMMIT</code>语句的<code class="codeph">WRITE</code>子句指定Oracle数据库向重做日志写入提交操作生成的信息的优先级。
                     </p>
                     <div class="infoboxnote" id="GUID-56EC1B31-CA06-4460-A098-49ABD4706B9C__GUID-737F1A89-C919-4A16-9D47-3AD09A1DBE65">
                        <p class="notep1">注意：</p>
                        <p>如果尚未设置<code class="codeph">COMMIT_LOGGING</code>和<code class="codeph">COMMIT_WAIT</code>数据库初始化参数，则非<code class="codeph">COMMIT_LOGGING</code>事务的默认PL / SQL提交行为为<code class="codeph">BATCH</code> <code class="codeph">NOWAIT</code> 。
                        </p>
                     </div>
                     <div class="infoboxnotealso" id="GUID-56EC1B31-CA06-4460-A098-49ABD4706B9C__GUID-52B32BCE-69B5-4130-A284-2A9E1A0C9CE6">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>有关提交事务的更多信息，请参阅<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/lnpls&amp;id=CNCPT1119" target="_blank"><span class="italic">Oracle数据库概念</span></a></p>
                           </li>
                           <li>
                              <p>有关分布式事务的信息，请参阅<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/lnpls&amp;id=CNCPT016" target="_blank"><span class="italic">Oracle Database Concepts</span></a></p>
                           </li>
                           <li>
                              <p>有关<code class="codeph">COMMIT</code>语句的信息，请<a href="../sqlrf/COMMIT.html#SQLRF01110" target="_blank"><span class="italic">参见Oracle数据库SQL语言参考</span></a></p>
                           </li>
                           <li>
                              <p>有关确保在故障转移到备用数据库期间不会丢失数据的信息，请参阅<a href="../sbydb/oracle-data-guard-protection-modes.html#SBYDB02000" target="_blank"><span class="italic">Oracle Data Guard概念和管理</span></a></p>
                           </li>
                        </ul>
                     </div>
                     <div class="example" id="GUID-56EC1B31-CA06-4460-A098-49ABD4706B9C__CJAIDJID">
                        <p class="titleinexample">例6-36具有COMMENT和WRITE子句的COMMIT语句</p>
                        <p>在此示例中，交易将资金从一个银行帐户转移到另一个银行帐户。重要的是，这笔钱都留下一个帐户并进入另一个帐户，因此<code class="codeph">COMMIT</code> <code class="codeph">WRITE</code> <code class="codeph">IMMEDIATE</code> <code class="codeph">NOWAIT</code>语句。
                        </p><pre class="oac_no_warn" dir="ltr">DROP TABLE帐户; CREATE TABLE帐户（account_id NUMBER（6），余额NUMBER（10,2））; INSERT INTO帐户（account_id，balance）VALUES（7715,6350.00）; INSERT INTO帐户（account_id，balance）VALUES（7720,5100.50）;创建或替换程序转移（from_acct NUMBER，to_acct NUMBER，NUMBER）AUTHID CURRENT_USER as BEGIN UPDATE accounts SET balance = balance  -  amount WHERE account_id = from_acct;更新帐户SET余额=余额+金额WHERE account_id = to_acct;承诺写立即NOWAIT;结束; /</pre><p>转移前查询：</p><pre class="oac_no_warn" dir="ltr">SELECT * FROM accounts;</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">ACCOUNT_ID平衡---------- ---------- 7715 6350 7720 5100.5 BEGIN转移（7715,7720,250）;结束; /</pre><p>转移后查询：</p><pre class="oac_no_warn" dir="ltr">SELECT * FROM accounts;</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">ACCOUNT_ID平衡---------- ---------- 7715 6100 7720 5350.5</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="LNPLS595"></a><a id="LNPLS594"></a><div class="props_rev_3"><a id="GUID-B1B20D2F-C421-446C-9171-1D03E2D77BF8" name="GUID-B1B20D2F-C421-446C-9171-1D03E2D77BF8"></a><h4 id="LNPLS-GUID-B1B20D2F-C421-446C-9171-1D03E2D77BF8" class="sect4"><span class="enumeration_section">6.6.2</span> ROLLBACK声明</h4>
                  <div>
                     <p><code class="codeph">ROLLBACK</code>语句结束当前事务并撤消在该事务期间所做的任何更改。
                     </p>
                     <p>如果出错，例如从表中删除错误的行，则回滚会恢复原始数据。如果由于SQL语句失败或PL / SQL引发异常而无法完成事务，则回滚可让您采取纠正措施并重新开始。</p>
                     <div class="infoboxnotealso" id="GUID-B1B20D2F-C421-446C-9171-1D03E2D77BF8__GUID-F68D2A1D-18A5-4A42-BECB-A1E9B0457C3B">
                        <p class="notep1">也可以看看：</p>
                        <p>有关<code class="codeph">ROLLBACK</code>语句的更多信息，请<a href="../sqlrf/EXPLAIN-PLAN.html#SQLRF01601" target="_blank"><span class="italic">参见Oracle数据库SQL语言参考</span></a></p>
                     </div>
                     <div class="example" id="GUID-B1B20D2F-C421-446C-9171-1D03E2D77BF8__CJACGAFD">
                        <p class="titleinexample">例6-37 ROLLBACK语句</p>
                        <p>此示例将有关员工的信息插入到三个不同的表中。如果<code class="codeph">INSERT</code>语句尝试存储重复的员工编号，则PL / SQL会引发预定义的异常<code class="codeph">DUP_VAL_ON_INDEX</code> 。为了确保撤消对所有三个表的更改，异常处理程序运行<code class="codeph">ROLLBACK</code> 。</p><pre class="oac_no_warn" dir="ltr">DROP TABLE emp_name; CREATE TABLE emp_name AS SELECT employee_id，last_name FROM employees; CREATE UNIQUE INDEX empname_ix ON emp_name（employee_id）; DROP TABLE emp_sal; CREATE TABLE emp_sal AS SELECT employee_id，salary FROM employees; CREATE UNIQUE INDEX empsal_ix ON emp_sal（employee_id）; DROP TABLE emp_job; CREATE TABLE emp_job AS SELECT employee_id，job_id FROM employees; CREATE UNIQUE INDEX empjobid_ix ON emp_job（employee_id）; DECLARE emp_id NUMBER（6）; emp_lastname VARCHAR2（25）; emp_salary NUMBER（8,2）; emp_jobid VARCHAR2（10）; BEGIN SELECT employee_id，last_name，salary，job_id INTO emp_id，emp_lastname，emp_salary，emp_jobid FROM employees WHERE employee_id = 120; INSERT INTO emp_name（employee_id，last_name）VALUES（emp_id，emp_lastname）; INSERT INTO emp_sal（employee_id，salary）VALUES（emp_id，emp_salary）; INSERT INTO emp_job（employee_id，job_id）VALUES（emp_id，emp_jobid）; <span class="bold">DUP_VAL_ON_INDEX然后</span> <span class="bold">ROLLBACK的</span> <span class="bold">例外情况</span> <span class="bold">;</span> DBMS_OUTPUT.PUT_LINE（'插入回滚'）;结束; /</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="LNPLS596"></a><a id="LNPLS597"></a><a id="LNPLS99976"></a><div class="props_rev_3"><a id="GUID-68924CF6-130E-497B-9DA8-7B3E4D510FA6" name="GUID-68924CF6-130E-497B-9DA8-7B3E4D510FA6"></a><h4 id="LNPLS-GUID-68924CF6-130E-497B-9DA8-7B3E4D510FA6" class="sect4"><span class="enumeration_section">6.6.3</span> SAVEPOINT声明</h4>
                  <div>
                     <p><code class="codeph">SAVEPOINT</code>语句命名并标记事务处理中的当前点。
                     </p>
                     <p>保存点允许您回滚部分事务而不是整个事务。每个会话的活动保存点数量不受限制。</p>
                     <p>回滚到保存点时，将删除在该保存点之后标记的所有保存点。您回滚的保存点不会被删除。简单的回滚或提交会清除所有保存点。</p>
                     <p>如果在递归子程序中标记保存点，则<code class="codeph">SAVEPOINT</code>语句的新实例将在递归下降的每个级别运行，但您只能回滚到最近标记的保存点。
                     </p>
                     <p>保存点名称是未声明的标识符。在事务中重用保存点名称会将保存点从其旧位置移动到事务中的当前点，这意味着回滚到保存点仅影响事务的当前部分。</p>
                     <div class="infoboxnotealso" id="GUID-68924CF6-130E-497B-9DA8-7B3E4D510FA6__GUID-3398D4C6-C6FA-4429-8529-16C6F34CE613">
                        <p class="notep1">也可以看看：</p>
                        <p>有关<code class="codeph">SET</code> <code class="codeph">TRANSACTION</code> SQL语句的更多信息，请<a href="../sqlrf/SET-TRANSACTION.html#SQLRF01705" target="_blank"><span class="italic">参见Oracle数据库SQL语言参考</span></a></p>
                     </div>
                     <div class="example" id="GUID-68924CF6-130E-497B-9DA8-7B3E4D510FA6__BABGAAIG">
                        <p class="titleinexample">例6-38 SAVEPOINT和ROLLBACK语句</p>
                        <p>此示例在执行插入之前标记保存点。如果<code class="codeph">INSERT</code>语句尝试在<code class="codeph">employee_id</code>列中存储重复值，则PL / SQL会引发预定义的异常<code class="codeph">DUP_VAL_ON_INDEX</code> ，并且事务将回滚到保存点，仅撤消<code class="codeph">INSERT</code>语句。
                        </p><pre class="oac_no_warn" dir="ltr">DROP TABLE emp_name; CREATE TABLE emp_name AS SELECT employee_id，last_name，salary FROM employees; CREATE UNIQUE INDEX empname_ix ON emp_name（employee_id）; DECLARE emp_id employees.employee_id％TYPE; emp_lastname employees.last_name％TYPE; emp_salary employees.salary％TYPE; BEGIN SELECT employee_id，last_name，salary INTO emp_id，emp_lastname，emp_salary FROM employees WHERE employee_id = 120; UPDATE emp_name SET salary = salary * 1.1 WHERE employee_id = emp_id; DELETE FROM emp_name WHERE employee_id = 130; <span class="bold">SAVEPOINT do_insert;</span> INSERT INTO emp_name（employee_id，last_name，salary）VALUES（emp_id，emp_lastname，emp_salary）; <span class="bold">异常，</span> <span class="bold">当DUP_VAL_ON_INDEX THEN</span> <span class="bold">ROLLBACK TO do_insert;</span> DBMS_OUTPUT.PUT_LINE（'Insert was rolled'）;结束; /</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-68924CF6-130E-497B-9DA8-7B3E4D510FA6__GUID-94B674C0-0259-4A04-9BF5-0A4A0687B82B">
                        <p class="titleinexample">例6-39重复使用SAVEPOINT和ROLLBACK</p><pre class="oac_no_warn" dir="ltr">DROP TABLE emp_name; CREATE TABLE emp_name AS SELECT employee_id，last_name，salary FROM employees; CREATE UNIQUE INDEX empname_ix ON emp_name（employee_id）; DECLARE emp_id employees.employee_id％TYPE; emp_lastname employees.last_name％TYPE; emp_salary employees.salary％TYPE; BEGIN SELECT employee_id，last_name，salary INTO emp_id，emp_lastname，emp_salary FROM employees WHERE employee_id = 120; <span class="bold">SAVEPOINT my_savepoint;</span> UPDATE emp_name SET salary = salary * 1.1 WHERE employee_id = emp_id; DELETE FROM emp_name WHERE employee_id = 130; <span class="bold">SAVEPOINT my_savepoint;</span> INSERT INTO emp_name（employee_id，last_name，salary）VALUES（emp_id，emp_lastname，emp_salary）; DUP_VAL_ON_INDEX然后返回<span class="bold">到my_savepoint时的异常;</span> DBMS_OUTPUT.PUT_LINE（'事务已回滚。“）;结束; /</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="LNPLS598"></a><div class="props_rev_3"><a id="GUID-A0771963-D96F-4AC5-A74A-242D064825DA" name="GUID-A0771963-D96F-4AC5-A74A-242D064825DA"></a><h4 id="LNPLS-GUID-A0771963-D96F-4AC5-A74A-242D064825DA" class="sect4"><span class="enumeration_section">6.6.4</span>隐式回滚</h4>
                  <div>
                     <p>在运行<code class="codeph">INSERT</code> ， <code class="codeph">UPDATE</code> ， <code class="codeph">DELETE</code>或<code class="codeph">MERGE</code>语句之前，数据库标记一个隐式保存点（对您不可用）。如果语句失败，则数据库将回滚到保存点。
                     </p>
                     <p>通常，只回滚失败的SQL语句，而不是整个事务。如果语句引发未处理的异常，则主机环境确定回滚的内容。</p>
                     <p>数据库还可以回滚单个SQL语句以打破死锁。数据库向参与的事务发出错误信号并回滚该事务中的当前语句。</p>
                     <p>在运行SQL语句之前，数据库必须对其进行解析，即检查它以确保它遵循语法规则并引用有效的模式对象。运行SQL语句时检测到的错误会导致回滚，但在解析语句时检测到的错误则不会。</p>
                     <p>如果退出存储的具有未处理异常的子程序，PL / SQL不会为<code class="codeph">OUT</code>参数赋值，也不会执行任何回滚。
                     </p>
                     <p>有关处理异常的信息，请参阅<a href="plsql-error-handling.html#GUID-0502DC1A-F0A5-4180-A912-6A5CDC855F56" title="在编译存储的PL / SQL单元时，PL / SQL编译器会为不足以导致错误并阻止编译的条件生成警告 - 例如，使用不推荐的PL / SQL功能。">PL / SQL错误处理</a></p>
                  </div>
               </div><a id="LNPLS600"></a><a id="LNPLS99975"></a><div class="props_rev_3"><a id="GUID-EC9CC8B7-5DDD-4B60-83BF-686A9FD43B3D" name="GUID-EC9CC8B7-5DDD-4B60-83BF-686A9FD43B3D"></a><h4 id="LNPLS-GUID-EC9CC8B7-5DDD-4B60-83BF-686A9FD43B3D" class="sect4"><span class="enumeration_section">6.6.5</span> SET TRANSACTION语句</h4>
                  <div>
                     <p>您可以使用<code class="codeph">SET</code> <code class="codeph">TRANSACTION</code>语句开始只读或读写事务，建立隔离级别，或将当前事务分配给指定的回滚段。
                     </p>
                     <p>只读事务对于运行多个查询非常有用，而其他用户则更新相同的表。</p>
                     <p>在只读事务期间，所有查询都引用数据库的相同快照，从而提供多表，多查询，读一致视图。其他用户可以像往常一样继续查询或更新数据。提交或回滚结束事务。</p>
                     <p><code class="codeph">SET</code> <code class="codeph">TRANSACTION</code>语句必须是只读事务中的第一个SQL语句，并且只能在事务中出现一次。如果将事务设置为<code class="codeph">READ</code> <code class="codeph">ONLY</code> ，则后续查询仅查看事务开始之前提交的更改。使用<code class="codeph">READ</code> <code class="codeph">ONLY</code>不会影响其他用户或事务。
                     </p>
                     <p>只读事务中只允许<code class="codeph">SELECT</code> ， <code class="codeph">OPEN</code> ， <code class="codeph">FETCH</code> ， <code class="codeph">CLOSE</code> ， <code class="codeph">LOCK</code> <code class="codeph">TABLE</code> ， <code class="codeph">COMMIT</code>和<code class="codeph">ROLLBACK</code>语句。查询不能是<code class="codeph">FOR</code> <code class="codeph">UPDATE</code> 。</p>
                     <div class="infoboxnotealso" id="GUID-EC9CC8B7-5DDD-4B60-83BF-686A9FD43B3D__GUID-B5DFDC80-BFC2-4091-908A-8C024D8BFAC2">
                        <p class="notep1">也可以看看：</p>
                        <p>有关SQL语句<code class="codeph">SET</code> <code class="codeph">TRANSACTION</code>更多信息，请<a href="../sqlrf/SET-TRANSACTION.html#SQLRF01705" target="_blank"><span class="italic">参见Oracle数据库SQL语言参考</span></a></p>
                     </div>
                     <div class="example" id="GUID-EC9CC8B7-5DDD-4B60-83BF-686A9FD43B3D__BABJIHCC">
                        <p class="titleinexample">例6-40只读事务中的SET TRANSACTION语句</p>
                        <p>在此示例中，当天，过去一周和过去一个月的只读事务收集订单总计。在事务期间更新数据库的其他用户不会影响总计。<code class="codeph">orders</code>表位于示例模式OE中。</p><pre class="oac_no_warn" dir="ltr">DECLARE daily_order_total NUMBER（12,2）; weekly_order_total NUMBER（12,2）; monthly_order_total NUMBER（12,2）;开始执行; - 结束上一笔交易SET TRANSACTION READ ONLY NAME'Calculate Order Totals'; SELECT SUM（order_total）INTO daily_order_total FROM orders WHERE order_date = SYSDATE; SELECT SUM（order_total）INTO weekly_order_total FROM orders WHERE order_date = SYSDATE  -  7; SELECT SUM（order_total）INTO monthly_order_total FROM orders WHERE order_date = SYSDATE  -  30;承诺; - 结束只读事务END; /</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="LNPLS504"></a><a id="LNPLS602"></a><div class="props_rev_3"><a id="GUID-213C196F-7FE4-425C-93E4-54B9FAFF5030" name="GUID-213C196F-7FE4-425C-93E4-54B9FAFF5030"></a><h4 id="LNPLS-GUID-213C196F-7FE4-425C-93E4-54B9FAFF5030" class="sect4"><span class="enumeration_section">6.6.6</span>覆盖默认锁定</h4>
                  <div>
                     <p>默认情况下，Oracle数据库会自动锁定数据结构，这样可以让不同的应用程序写入相同的数据结构，而不会损害彼此的数据或相互协调。</p>
                     <div class="section">
                        <p>如果在事务期间必须具有对数据的独占访问权限，则可以使用以下SQL语句覆盖默认锁定：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">LOCK</code> <code class="codeph">TABLE</code> ，它显式锁定整个表。
                              </p>
                           </li>
                           <li>
                              <p>使用<code class="codeph">FOR</code> <code class="codeph">UPDATE</code>子句（ <code class="codeph">SELECT</code> <code class="codeph">FOR</code> <code class="codeph">UPDATE</code> ）进行<code class="codeph">SELECT</code> ，该子句显式锁定表的特定行。
                              </p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-213C196F-7FE4-425C-93E4-54B9FAFF5030__GUID-2991ADBF-3AF2-4DDC-B50B-D20E99A6E3D9">话题</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="static-sql.html#GUID-4596DC9D-6011-4B4E-B14D-8C232334712F">锁表声明</a></p>
                           </li>
                           <li>
                              <p><a href="static-sql.html#GUID-6A1C2FD9-9476-4F8D-A2E4-2C967D7F8C08">SELECT FOR UPDATE和FOR UPDATE Cursors</a></p>
                           </li>
                           <li>
                              <p><a href="static-sql.html#GUID-E9A9E94A-9E63-42E0-A4DC-F25E9B7A23B9">用ROWID伪列模拟CURRENT OF子句</a></p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div><a id="LNPLS605"></a><div class="props_rev_3"><a id="GUID-4596DC9D-6011-4B4E-B14D-8C232334712F" name="GUID-4596DC9D-6011-4B4E-B14D-8C232334712F"></a><h5 id="LNPLS-GUID-4596DC9D-6011-4B4E-B14D-8C232334712F" class="sect5"><span class="enumeration_section">6.6.6.1</span> LOCK TABLE语句</h5>
                     <div>
                        <p><code class="codeph">LOCK</code> <code class="codeph">TABLE</code>语句以指定的锁定模式显式锁定一个或多个表，以便您可以共享或拒绝对它们的访问。
                        </p>
                        <p>锁定模式确定可以在表格上放置哪些其他锁定。例如，许多用户可以同时获取表上的行共享锁，但一次只能有一个用户获得独占锁。当一个用户对表具有独占锁定时，其他用户不能插入，删除或更新该表中的行。</p>
                        <p>表锁永远不会阻止其他用户查询表，并且查询永远不会获取表锁。只有当两个不同的事务尝试修改同一行时，一个事务才会等待另一个事务完成。<code class="codeph">LOCK</code> <code class="codeph">TABLE</code>语句允许您指定等待另一个事务完成的时间。
                        </p>
                        <p>当获取它们的事务被提交或回滚时，将释放表锁。</p>
                        <div class="infoboxnotealso" id="GUID-4596DC9D-6011-4B4E-B14D-8C232334712F__GUID-0FF274D4-3739-4D6D-AC3F-C4E5BDC8B33E">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>有关显式锁定表的更多信息，请参见<a href="../adfns/sql-processing-for-application-developers.html#ADFNS00203" target="_blank"><span class="italic">Oracle数据库开发指南</span></a></p>
                              </li>
                              <li>
                                 <p>有关<code class="codeph">LOCK</code> <code class="codeph">TABLE</code>语句的详细信息，请<a href="../sqlrf/LOCK-TABLE.html#SQLRF01605" target="_blank"><span class="italic">参见Oracle数据库SQL语言参考</span></a></p>
                              </li>
                           </ul>
                        </div>
                     </div>
                  </div><a id="LNPLS505"></a><a id="LNPLS506"></a><a id="LNPLS603"></a><div class="props_rev_3"><a id="GUID-6A1C2FD9-9476-4F8D-A2E4-2C967D7F8C08" name="GUID-6A1C2FD9-9476-4F8D-A2E4-2C967D7F8C08"></a><h5 id="LNPLS-GUID-6A1C2FD9-9476-4F8D-A2E4-2C967D7F8C08" class="sect5"><span class="enumeration_section">6.6.6.2</span>选择更新和更新游标</h5>
                     <div>
                        <p>带有<code class="codeph">FOR</code> <code class="codeph">UPDATE</code>子句的<code class="codeph">SELECT</code>语句（ <code class="codeph">SELECT</code> <code class="codeph">FOR</code> <code class="codeph">UPDATE</code>语句）选择结果集的行并锁定它们。<code class="codeph">SELECT</code> <code class="codeph">FOR</code> <code class="codeph">UPDATE</code>允许您基于行中的现有值进行更新，因为它确保在更新这些值之前没有其他用户可以更改这些值。您还可以使用<code class="codeph">SELECT</code> <code class="codeph">FOR</code> <code class="codeph">UPDATE</code>来锁定您不想更新的行，如<a href="plsql-triggers.html#GUID-2DC16B21-35B1-4D09-BD4E-02797AA278EA__BCFGAHIB">例9-6所示</a> 。
                        </p>
                        <div class="infoboxnote" id="GUID-6A1C2FD9-9476-4F8D-A2E4-2C967D7F8C08__GUID-F0317D70-A128-4F29-A62E-A7A71FA43D76">
                           <p class="notep1">注意：</p>
                           <p>在使用混合列压缩（HCC）压缩的表中，DML语句锁定压缩单元而不是行。<a href="../cncpt/tables-and-table-clusters.html#CNCPT89198" target="_blank"><span class="italic">Oracle数据库概念中</span></a>描述了HCC，某些Oracle存储系统的一个特性。
                           </p>
                        </div>
                        <p>默认情况下， <code class="codeph">SELECT</code> <code class="codeph">FOR</code> <code class="codeph">UPDATE</code>语句将一直等到获取请求的行锁定。若要更改此行为，请使用<code class="codeph">SELECT</code> <code class="codeph">FOR</code> <code class="codeph">UPDATE</code>语句的<code class="codeph">NOWAIT</code> ， <code class="codeph">WAIT</code>或<code class="codeph">SKIP</code> <code class="codeph">LOCKED</code>子句。有关这些子句的信息，请参阅<a href="../sqlrf/SELECT.html#SQLRF01702" target="_blank"><span class="italic">Oracle数据库SQL语言参考</span></a> 。
                        </p>
                        <p>当<code class="codeph">SELECT</code> <code class="codeph">FOR</code> <code class="codeph">UPDATE</code>与显式游标相关联时，游标称为<span class="bold"><code class="codeph">FOR</code></span> <span class="bold"><code class="codeph">UPDATE</code></span> <span class="bold">游标</span> 。只有<code class="codeph">FOR</code> <code class="codeph">UPDATE</code>游标才能出现在<code class="codeph">UPDATE</code>或<code class="codeph">DELETE</code>语句的<code class="codeph">CURRENT</code> <code class="codeph">OF</code>子句中。（ <code class="codeph">CURRENT</code> <code class="codeph">OF</code>子句是SQL语句<code class="codeph">UPDATE</code>和<code class="codeph">DELETE</code>的<code class="codeph">WHERE</code>子句的PL / SQL扩展， <code class="codeph">WHERE</code>语句限制为游标的当前行。）
                        </p>
                        <p>当<code class="codeph">SELECT</code> <code class="codeph">FOR</code> <code class="codeph">UPDATE</code>查询多个表时，它仅锁定其列出现在<code class="codeph">FOR</code> <code class="codeph">UPDATE</code>子句中的行。
                        </p>
                     </div>
                  </div><a id="LNPLS507"></a><a id="LNPLS607"></a><a id="LNPLS606"></a><div class="props_rev_3"><a id="GUID-E9A9E94A-9E63-42E0-A4DC-F25E9B7A23B9" name="GUID-E9A9E94A-9E63-42E0-A4DC-F25E9B7A23B9"></a><h5 id="LNPLS-GUID-E9A9E94A-9E63-42E0-A4DC-F25E9B7A23B9" class="sect5"><span class="enumeration_section">6.6.6.3</span>使用ROWID伪<span class="enumeration_section">列</span>模拟CURRENT OF子句</h5>
                     <div>
                        <div class="section">
                           <p>打开<code class="codeph">FOR</code> <code class="codeph">UPDATE</code>游标时，结果集的行将被锁定，而不是在获取它们时。提交或回滚事务时，行将被解锁。在解锁行之后，您无法从<code class="codeph">FOR</code> <code class="codeph">UPDATE</code>游标中获取，如<a href="static-sql.html#GUID-E9A9E94A-9E63-42E0-A4DC-F25E9B7A23B9__CHDHIIAI">示例6-41</a>所示（如果您将<code class="codeph">ROLLBACK</code>替换为<code class="codeph">COMMIT</code>则结果相同）。
                           </p>
                           <p>解决方法是使用<code class="codeph">ROWID</code>伪列（在<a href="../sqlrf/ROWID-Pseudocolumn.html#SQLRF00254" target="_blank"><span class="italic">Oracle数据库SQL语言参考中</span></a>描述）模拟<code class="codeph">CURRENT</code> <code class="codeph">OF</code>子句。将每行的rowid选择为<code class="codeph">UROWID</code>变量，并使用rowid在后续更新和删除期间标识当前行，如<a href="static-sql.html#GUID-E9A9E94A-9E63-42E0-A4DC-F25E9B7A23B9__CIHIJAAE">例6-42所示</a> 。（要打印<code class="codeph">UROWID</code>变量的值，请使用<a href="../sqlrf/ROWIDTOCHAR.html#SQLRF06101" target="_blank"><span class="italic">Oracle数据库SQL语言参考中</span></a>描述的<code class="codeph">ROWIDTOCHAR</code>函数将其转换为<code class="codeph">VARCHAR2</code> 。）
                           </p>
                           <div class="infoboxnote" id="GUID-E9A9E94A-9E63-42E0-A4DC-F25E9B7A23B9__GUID-05A0BC49-8B11-4249-8610-E64198D512A4">
                              <p class="notep1">注意：</p>
                              <p>更新使用混合列压缩（HCC）压缩的表中的行时，行的<code class="codeph">ROWID</code>会更改。<a href="../cncpt/tables-and-table-clusters.html#CNCPT89198" target="_blank"><span class="italic">Oracle数据库概念中</span></a>描述了HCC，某些Oracle存储系统的一个特性。
                              </p>
                           </div>
                           <div class="infoboxnote" id="GUID-E9A9E94A-9E63-42E0-A4DC-F25E9B7A23B9__GUID-F5F3D45B-6DBA-4D89-8273-79D15B9A74E7">
                              <p class="notep1">警告：</p>
                              <p>由于没有<code class="codeph">FOR</code> <code class="codeph">UPDATE</code>子句锁定获取的行，因此其他用户可能会无意中覆盖您的更改。
                              </p>
                           </div>
                           <div class="infoboxnote" id="GUID-E9A9E94A-9E63-42E0-A4DC-F25E9B7A23B9__GUID-E4E27B50-9407-4F19-A37D-B00F023AEA50">
                              <p class="notep1">注意：</p>
                              <p>在光标关闭之前，不会释放读取一致性所需的额外空间，这会减慢大型更新的处理速度。</p>
                           </div>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-E9A9E94A-9E63-42E0-A4DC-F25E9B7A23B9__CHDHIIAI">
                           <p class="titleinexample">示例6-41带有FOR UPDATE游标的FETCH在COMMIT语句之后</p><pre class="oac_no_warn" dir="ltr">DROP TABLE emp; CREATE TABLE emp AS SELECT * FROM employees; DECLARE CURSOR c1 IS SELECT * FROM emp <span class="bold">FOR更新工资</span>订单by employee_id; emp_rec emp％ROWTYPE;开始打开c1; LOOP <span class="bold">FETCH c1 INTO emp_rec; - 第二次迭代失败</span>退出时c1％NOTFOUND; DBMS_OUTPUT.PUT_LINE（'emp_rec.employee_id ='|| TO_CHAR（emp_rec.employee_id））; UPDATE emp SET salary = salary * 1.05 WHERE employee_id = 105; <span class="bold">承诺; - 释放锁定</span> END LOOP;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">第1行的emp_rec.employee_id = 100 DECLARE * ERROR：ORA-01002：取出序列ORA-06512：第11行</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-E9A9E94A-9E63-42E0-A4DC-F25E9B7A23B9__CIHIJAAE">
                           <p class="titleinexample">例6-42使用ROWID伪列模拟CURRENT OF子句</p><pre class="oac_no_warn" dir="ltr">DROP TABLE emp; CREATE TABLE emp AS SELECT * FROM employees; DECLARE CURSOR c1 IS SELECT last_name，job_id， <span class="bold">rowid</span> FROM emp; <span class="bold">- 没有FOR UPDATE子句</span> my_lastname employees.last_name％TYPE; my_jobid employees.job_id％TYPE; <span class="bold">my_rowid UROWID;</span>开始打开c1; LOOP FETCH c1 INTO my_lastname，my_jobid，my_rowid;退出时c1％NOTFOUND; UPDATE emp SET salary = salary * 1.02 <span class="bold">WHERE rowid = my_rowid; - 模拟c1</span> COMMIT的<span class="bold">WHERE CURRENT</span> ;结束循环;关闭c1;结束; /</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div>
               </div>
            </div><a id="LNPLS608"></a><a id="LNPLS508"></a><a id="LNPLS00609"></a><div class="props_rev_3"><a id="GUID-BC564905-51F4-4ADB-B300-9F15B1AC3099" name="GUID-BC564905-51F4-4ADB-B300-9F15B1AC3099"></a><h3 id="LNPLS-GUID-BC564905-51F4-4ADB-B300-9F15B1AC3099" class="sect3"><span class="enumeration_section">6.7</span>自治交易</h3>
               <div>
                  <p><span class="bold">自治事务</span>是由另一个事务（主事务）启动的独立事务。
                  </p>
                  <p>自治事务执行SQL操作并提交或回滚，而无需提交或回滚主事务。</p>
                  <p><a href="static-sql.html#GUID-BC564905-51F4-4ADB-B300-9F15B1AC3099__I28274">图6-1</a>显示了控制如何从主事务（MT）流向自治例程（ <code class="codeph">proc2</code> ）并再次返回。自治例程提交两个自治事务（AT1和AT2）。
                  </p>
                  <div class="figure" id="GUID-BC564905-51F4-4ADB-B300-9F15B1AC3099__I28274">
                     <p class="titleinfigure">图6-1事务控制流程</p><img src="img/lnpls028.gif" alt="下面是图6-1的描述" title="下面是图6-1的描述" longdesc="img_text/lnpls028.html"><br><a href="img_text/lnpls028.html">“图6-1交易控制流程”的描述</a></div>
                  <!-- class="figure" -->
                  <div class="infoboxnote" id="GUID-BC564905-51F4-4ADB-B300-9F15B1AC3099__GUID-6BBCB951-D541-4057-8B9D-9C80C7BA20BF">
                     <p class="notep1">注意：</p>
                     <p>虽然自治事务由另一个事务启动，但它不是嵌套事务，因为：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>它不与主事务共享事务资源（例如锁）。</p>
                        </li>
                        <li>
                           <p>它不依赖于主要交易。</p>
                           <p>例如，如果主事务回滚，则嵌套事务回滚，但自治事务不回滚。</p>
                        </li>
                        <li>
                           <p>其提交的更改立即对其他事务可见。</p>
                           <p>在主事务提交之前，嵌套事务的已提交更改对其他事务不可见。</p>
                        </li>
                        <li>
                           <p>自治事务中引发的异常会导致事务级回滚，而不是语句级回滚。</p>
                        </li>
                     </ul>
                  </div>
                  <div class="section">
                     <p class="subhead2" id="GUID-BC564905-51F4-4ADB-B300-9F15B1AC3099__GUID-DFDB7567-AEB0-4671-8DD4-CB24412E0A6C">话题</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="static-sql.html#GUID-4B7E30F5-61CB-4A94-B198-09E2706C4CA5">自治交易的优点</a></p>
                        </li>
                        <li>
                           <p><a href="static-sql.html#GUID-E6F6EE1A-5BEB-426A-9EBC-A3C1FFD3A237">交易背景</a></p>
                        </li>
                        <li>
                           <p><a href="static-sql.html#GUID-F8D52E78-230A-4DCE-ACC6-823C214C0C4E">交易可见性</a></p>
                        </li>
                        <li>
                           <p><a href="static-sql.html#GUID-FBD2040A-9047-44DB-8C82-5F6D08990227" title="要声明自治例程，请使用AUTONOMOUS_TRANSACTION编译指示。">宣布自治例程</a></p>
                        </li>
                        <li>
                           <p><a href="static-sql.html#GUID-F3D2490E-09A3-4EC4-9E31-45402099E23F">控制自治交易</a></p>
                        </li>
                        <li>
                           <p><a href="static-sql.html#GUID-DD6F0BF4-A958-4EE2-8616-C7AE08910908" title="触发器必须是自治的才能运行TCL或DDL语句。">自主触发器</a></p>
                        </li>
                        <li>
                           <p><a href="static-sql.html#GUID-D80328F0-79E5-4F8F-87E4-ED302A0752BE" title="从SQL语句调用的函数必须遵守用于控制副作用的规则。">从SQL调用自治函数</a></p>
                        </li>
                     </ul>
                     <div class="infoboxnotealso" id="GUID-BC564905-51F4-4ADB-B300-9F15B1AC3099__GUID-F810458A-DFF7-46D1-9361-64EE39C976DB">
                        <p class="notep1">也可以看看：</p>
                        <p>有关自治事务的更多信息，请参见<a href="../adfns/sql-processing-for-application-developers.html#ADFNS00205" target="_blank"><span class="italic">Oracle数据库开发指</span></a></p>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div><a id="LNPLS509"></a><div class="props_rev_3"><a id="GUID-4B7E30F5-61CB-4A94-B198-09E2706C4CA5" name="GUID-4B7E30F5-61CB-4A94-B198-09E2706C4CA5"></a><h4 id="LNPLS-GUID-4B7E30F5-61CB-4A94-B198-09E2706C4CA5" class="sect4"><span class="enumeration_section">6.7.1</span>自治交易的优点</h4>
                  <div>
                     <p>启动后，自治事务完全独立。它与主事务不共享锁，资源或提交依赖性。即使主事务回滚，您也可以记录事件，增加重试计数器等。</p>
                     <p>自治事务可帮助您构建模块化，可重用的软件组件。您可以在存储的子程序中封装自治事务。调用应用程序无需知道该存储的子程序所执行的操作是成功还是失败。</p>
                  </div>
               </div><a id="LNPLS616"></a><div class="props_rev_3"><a id="GUID-E6F6EE1A-5BEB-426A-9EBC-A3C1FFD3A237" name="GUID-E6F6EE1A-5BEB-426A-9EBC-A3C1FFD3A237"></a><h4 id="LNPLS-GUID-E6F6EE1A-5BEB-426A-9EBC-A3C1FFD3A237" class="sect4"><span class="enumeration_section">6.7.2</span>交易背景</h4>
                  <div>
                     <p>主事务与嵌套例程共享其上下文，但不与自治事务共享。当一个自治例程调用另一个（或本身，递归）时，例程不共享事务上下文。当自治例程调用非自治例程时，例程共享相同的事务上下文。</p>
                  </div>
               </div><a id="LNPLS617"></a><div class="props_rev_3"><a id="GUID-F8D52E78-230A-4DCE-ACC6-823C214C0C4E" name="GUID-F8D52E78-230A-4DCE-ACC6-823C214C0C4E"></a><h4 id="LNPLS-GUID-F8D52E78-230A-4DCE-ACC6-823C214C0C4E" class="sect4"><span class="enumeration_section">6.7.3</span>交易可见性</h4>
                  <div>
                     <p>当自治事务提交时，自治事务所做的更改对其他事务可见。如果主事务的隔离级别设置为<code class="codeph">READ</code> <code class="codeph">COMMITTED</code> （默认值），则这些更改在恢复时对主事务可见。
                     </p>
                     <p>如果将主事务的隔离级别设置为<code class="codeph">SERIALIZABLE</code> ，则自动事务所做的更改在恢复时对主事务<span class="italic">不</span>可见：</p><pre class="oac_no_warn" dir="ltr">设置交易隔离级别可串行化;</pre><div class="infoboxnote" id="GUID-F8D52E78-230A-4DCE-ACC6-823C214C0C4E__GUID-6BF7A85D-6C03-444B-86F2-07CD00B71AA3">
                        <p class="notep1">注意：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>交易属性仅适用于设置它们的交易。</p>
                           </li>
                           <li>
                              <p>游标属性不受自治事务的影响。</p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="LNPLS611"></a><a id="LNPLS612"></a><a id="LNPLS613"></a><a id="LNPLS610"></a><div class="props_rev_3"><a id="GUID-FBD2040A-9047-44DB-8C82-5F6D08990227" name="GUID-FBD2040A-9047-44DB-8C82-5F6D08990227"></a><h4 id="LNPLS-GUID-FBD2040A-9047-44DB-8C82-5F6D08990227" class="sect4"><span class="enumeration_section">6.7.4</span>声明自治套路</h4>
                  <div>
                     <p>要声明自治例程，请使用<code class="codeph">AUTONOMOUS_TRANSACTION</code>编译指示。
                     </p>
                     <div class="section">
                        <p>有关此pragma的信息，请参阅<span class="q">“ <a href="AUTONOMOUS_TRANSACTION-pragma.html#GUID-AD33D949-081B-4CD3-A240-C29773E908C3" title="AUTONOMOUS_TRANSACTION编译指示将例程标记为自治;也就是说，独立于主要交易。">AUTONOMOUS_TRANSACTION Pragma</a> ”</span> 。
                        </p>
                        <div class="infobox-tip" id="GUID-FBD2040A-9047-44DB-8C82-5F6D08990227__GUID-49741028-4EE8-4AF6-898F-E5B757B2F340">
                           <p class="notep1">小费：</p>
                           <p>为了便于阅读，请将<code class="codeph">AUTONOMOUS_TRANSACTION</code>编译指示放在声明部分的顶部。（在声明部分的任何地方都允许使用该pragma。）
                           </p>
                        </div>
                        <p>您不能将<code class="codeph">AUTONOMOUS_TRANSACTION</code>编译指示应用于整个包或ADT，但您可以将其应用于包中的每个子程序或ADT的每个方法。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-FBD2040A-9047-44DB-8C82-5F6D08990227__BABIIHBJ">
                        <p class="titleinexample">例6-43在包中声明自治功能</p>
                        <p>此示例将包函数标记为自治。</p><pre class="oac_no_warn" dir="ltr">CREATE或REPLACE PACKAGE emp_actions AUTHID DEFINER AS  - <span class="bold">包规范</span> <span class="bold">FUNCTION raise_salary</span> （emp_id NUMBER，sal_raise NUMBER）返回号码; END emp_actions; / CREATE OR REPLACE PACKAGE BODY emp_actions AS  - <span class="bold">包体</span> - 函数的代码raise_salary <span class="bold">FUNCTION raise_salary</span> （emp_id NUMBER，sal_raise NUMBER）返回号码是<span class="bold">PRAGMA AUTONOMOUS_TRANSACTION</span> ; new_sal NUMBER（8,2）; BEGIN UPDATE员工SET薪水=薪水+ sal_raise WHERE employee_id = emp_id;承诺; SELECT薪水INTO new_sal FROM employees WHERE employee_id = emp_id;返回new_sal; END raise_salary; END emp_actions; /</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-FBD2040A-9047-44DB-8C82-5F6D08990227__BABEECAF">
                        <p class="titleinexample">例6-44声明自治独立过程</p>
                        <p>此示例将独立子程序标记为自治。</p><pre class="oac_no_warn" dir="ltr">创建或替换程序lower_salary（emp_id NUMBER，amount NUMBER）作为<span class="bold">PRAGMA AUTONOMOUS_TRANSACTION的</span> AUTHID DEFINER; BEGIN UPDATE员工SET薪水=工资 - 金额WHERE employee_id = emp_id;承诺; END lower_salary; /</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-FBD2040A-9047-44DB-8C82-5F6D08990227__BABIJEID">
                        <p class="titleinexample">例6-45声明自治PL / SQL块</p>
                        <p>此示例将模式级PL / SQL块标记为自治。（嵌套的PL / SQL块不能自治。）</p><pre class="oac_no_warn" dir="ltr">DROP TABLE emp; CREATE TABLE emp AS SELECT * FROM employees; DECLARE <span class="bold">PRAGMA AUTONOMOUS_TRANSACTION;</span> emp_id NUMBER（6）：= 200;金额NUMBER（6,2）：= 200; BEGIN UPDATE员工SET薪水=工资 - 金额WHERE employee_id = emp_id;承诺;结束; /</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="LNPLS510"></a><a id="LNPLS99982"></a><div class="props_rev_3"><a id="GUID-F3D2490E-09A3-4EC4-9E31-45402099E23F" name="GUID-F3D2490E-09A3-4EC4-9E31-45402099E23F"></a><h4 id="LNPLS-GUID-F3D2490E-09A3-4EC4-9E31-45402099E23F" class="sect4"><span class="enumeration_section">6.7.5</span>控制自治事务</h4>
                  <div>
                     <div class="section">
                        <p>自治例程中的第一个SQL语句开始一个事务。当一个事务结束时，下一个SQL语句开始另一个事务。自上次提交或回滚以来运行的所有SQL语句都包含当前事务。要控制自治事务，请使用这些语句，这些语句仅适用于当前（活动）事务：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">承诺</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">ROLLBACK</code> [ <code class="codeph">TO</code> <span class="italic"><code class="codeph">savepoint_name</code></span> ]</p>
                           </li>
                           <li>
                              <p><code class="codeph">SAVEPOINT</code> <span class="italic"><code class="codeph">savepoint_name</code></span></p>
                           </li>
                           <li>
                              <p><code class="codeph">SET</code> <code class="codeph">TRANSACTION</code></p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-F3D2490E-09A3-4EC4-9E31-45402099E23F__GUID-F7DCA9D8-78E1-4A5F-94F6-CAB3D7F0139B">话题</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="static-sql.html#GUID-B3C2CC11-3554-4E96-8544-C5FA4A6163A9">进入和退出自治套路</a></p>
                           </li>
                           <li>
                              <p><a href="static-sql.html#GUID-9D2A3D88-8454-486F-919D-34CB27935EE3">承诺和回滚自治交易</a></p>
                           </li>
                           <li>
                              <p><a href="static-sql.html#GUID-68AF5B28-83ED-4D1B-AB8E-4A7EFEBCE5CB">保存点</a></p>
                           </li>
                           <li>
                              <p><a href="static-sql.html#GUID-CD2A248B-A1F7-474D-A1A9-73743A318B52">避免自治事务的错误</a></p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div><a id="LNPLS618"></a><div class="props_rev_3"><a id="GUID-B3C2CC11-3554-4E96-8544-C5FA4A6163A9" name="GUID-B3C2CC11-3554-4E96-8544-C5FA4A6163A9"></a><h5 id="LNPLS-GUID-B3C2CC11-3554-4E96-8544-C5FA4A6163A9" class="sect5"><span class="enumeration_section">6.7.5.1</span>进入和退出自治套路</h5>
                     <div>
                        <div class="section">
                           <p>当您输入自治例程的可执行部分时，主事务将暂停。退出例程时，主事务将恢复。</p>
                           <p>如果尝试在未提交或回滚的情况下退出活动的自治事务，则数据库会引发异常。如果未处理异常，或者由于某些其他未处理的异常而导致事务结束，则事务将回滚。</p>
                           <p>要正常退出，例程必须显式提交或回滚所有自治事务。如果例程（或由它调用的任何例程）具有挂起的事务，则PL / SQL引发异常并且挂起的事务回滚。</p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNPLS619"></a><div class="props_rev_3"><a id="GUID-9D2A3D88-8454-486F-919D-34CB27935EE3" name="GUID-9D2A3D88-8454-486F-919D-34CB27935EE3"></a><h5 id="LNPLS-GUID-9D2A3D88-8454-486F-919D-34CB27935EE3" class="sect5"><span class="enumeration_section">6.7.5.2</span>承诺和回滚自治事务</h5>
                     <div>
                        <div class="section">
                           <p><code class="codeph">COMMIT</code>和<code class="codeph">ROLLBACK</code>结束活动的自治事务，但不退出自治例程。当一个事务结束时，下一个SQL语句开始另一个事务。如果单个自治例程发出多个<code class="codeph">COMMIT</code>语句，则它可以包含多个自治事务。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNPLS620"></a><div class="props_rev_3"><a id="GUID-68AF5B28-83ED-4D1B-AB8E-4A7EFEBCE5CB" name="GUID-68AF5B28-83ED-4D1B-AB8E-4A7EFEBCE5CB"></a><h5 id="LNPLS-GUID-68AF5B28-83ED-4D1B-AB8E-4A7EFEBCE5CB" class="sect5"><span class="enumeration_section">6.7.5.3</span>保存点</h5>
                     <div>
                        <p>保存点的范围是定义它的事务。主事务中定义的保存点与其自治事务中定义的保存点无关。实际上，主事务和自治事务可以使用相同的保存点名称。</p>
                        <p>您只能回滚到当前事务中标记的保存点。在自治事务中，您无法回滚到主事务中标记的保存点。为此，您必须通过退出自治例程来恢复主事务。</p>
                        <p>在主事务中，回滚到在启动自治事务之前标记的保存点<span class="italic">不会</span>回滚自治事务。请记住，自主交易完全独立于主要交易。
                        </p>
                     </div>
                  </div><a id="LNPLS621"></a><div class="props_rev_3"><a id="GUID-CD2A248B-A1F7-474D-A1A9-73743A318B52" name="GUID-CD2A248B-A1F7-474D-A1A9-73743A318B52"></a><h5 id="LNPLS-GUID-CD2A248B-A1F7-474D-A1A9-73743A318B52" class="sect5"><span class="enumeration_section">6.7.5.4</span>避免自治事务的错误</h5>
                     <div>
                        <p>为避免一些常见错误，请记住：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>如果自治事务尝试访问主事务持有的资源，则可能发生死锁。数据库在自治事务中引发异常，如果异常未处理，则会回滚。</p>
                           </li>
                           <li>
                              <p>数据库初始化参数<code class="codeph">TRANSACTIONS</code>指定最大并发事务数。可能会超出该数量，因为自治事务与主事务同时运行。
                              </p>
                           </li>
                           <li>
                              <p>如果尝试在未提交或回滚的情况下退出活动的自治事务，则数据库会引发异常。如果未处理异常，则事务将回滚。</p>
                           </li>
                           <li>
                              <p>在自治事务处于打开状态时，您无法在自治例程中运行<code class="codeph">PIPE</code> <code class="codeph">ROW</code>语句。您必须在运行<code class="codeph">PIPE</code> <code class="codeph">ROW</code>语句之前关闭自治事务。这通常通过在运行<code class="codeph">PIPE</code> <code class="codeph">ROW</code>语句之前提交或回滚自治事务来完成。
                              </p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="LNPLS623"></a><a id="LNPLS511"></a><a id="LNPLS622"></a><div class="props_rev_3"><a id="GUID-DD6F0BF4-A958-4EE2-8616-C7AE08910908" name="GUID-DD6F0BF4-A958-4EE2-8616-C7AE08910908"></a><h4 id="LNPLS-GUID-DD6F0BF4-A958-4EE2-8616-C7AE08910908" class="sect4"><span class="enumeration_section">6.7.6</span>自主触发器</h4>
                  <div>
                     <p>触发器必须是自治的才能运行TCL或DDL语句。</p>
                     <p>要运行DDL语句，触发器必须使用本机动态SQL。</p>
                     <div class="infoboxnotealso" id="GUID-DD6F0BF4-A958-4EE2-8616-C7AE08910908__GUID-4DA66B6D-2367-47E1-B6A3-6DA87E2464B3">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="plsql-triggers.html#GUID-217E8B13-29EF-45F3-8D0F-2384F9F1D231" title="触发器就像Oracle Database在发生指定事件时自动调用的存储过程。">PL / SQL触发器</a> ，用于有关触发器的一般信息</p>
                           </li>
                           <li>
                              <p><span class="q">“ <a href="static-sql.html#GUID-54ABD9E3-EA4D-4C60-A84A-021925501C0C" title="除非另有说明，否则静态SQL具有与SQL相同的语法。">静态SQL的描述</a> ”</span> ，了解有关TCL语句的一般信息</p>
                           </li>
                           <li>
                              <p>有关DDL语句的信息，请<a href="../sqlrf/Types-of-SQL-Statements.html#SQLRF30041" target="_blank"><span class="italic">参见Oracle数据库SQL语言参考</span></a></p>
                           </li>
                           <li>
                              <p><span class="q">“本<a href="dynamic-sql.html#GUID-D2613968-6660-4AA2-9057-28E425A3040D" title="本机动态SQL使用EXECUTE IMMEDIATE语句处理大多数动态SQL语句。">机动态SQL</a> ”，</span>用于获取有关本机动态SQL的信息</p>
                           </li>
                        </ul>
                     </div>
                     <p>触发器的一个用途是透明地记录事件 - 例如，将所有插入记录到表中，甚至是回滚的表。</p>
                     <div class="example" id="GUID-DD6F0BF4-A958-4EE2-8616-C7AE08910908__CJAICEDA">
                        <p class="titleinexample">例6-46自主触发日志INSERT语句</p>
                        <p>在此示例中，只要将行插入<code class="codeph">EMPLOYEES</code>表，触发器就会将同一行插入到日志表中。由于触发器是自治的，因此无论是否将其提交到主表，它都可以提交对日志表的更改。
                        </p><pre class="oac_no_warn" dir="ltr">DROP TABLE emp; CREATE TABLE emp AS SELECT * FROM employees; - 日志表：DROP TABLE日志; CREATE TABLE log（log_id NUMBER（6），up_date DATE，new_sal NUMBER（8,2），old_sal NUMBER（8,2））; -  emp表上的自主触发：创建或替换<span class="bold">TRIGGER log_sal</span>在更新工资之前，每个行的<span class="bold">DECAGARE</span> <span class="bold">PRAGMA AUTONOMOUS_TRANSACTION;</span> BEGIN INSERT INTO log（log_id，up_date，new_sal，old_sal）VALUES（：old.employee_id，SYSDATE，：new.salary，：old.salary）; <span class="bold">承诺;</span>结束; / UPDATE emp SET salary = salary * 1.05 WHERE employee_id = 115; <span class="bold">承诺;</span> UPDATE emp SET salary = salary * 1.05 WHERE employee_id = 116; <span class="bold">ROLLBACK;</span> - 显示已提交和回滚的更新 - 向日志表添加行<span class="bold">SELECT * FROM log</span> <span class="bold">WHERE log_id = 115 OR log_id = 116;</span>
</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">LOG_ID UP_DATE NEW_SAL OLD_SAL ---------- --------- ---------- ---------- 115 02-OCT-12 3255 3100 116 02-OCT-12 3045 2900选择2行。
</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-DD6F0BF4-A958-4EE2-8616-C7AE08910908__CHDFJBDA">
                        <p class="titleinexample">例6-47自主触发器为DDL使用本机动态SQL</p>
                        <p>在此示例中，自动触发器使用本机动态SQL（ <code class="codeph">EXECUTE</code> <code class="codeph">IMMEDIATE</code>语句）在将行插入表<code class="codeph">log</code>后删除临时表。
                        </p><pre class="oac_no_warn" dir="ltr">DROP TABLE临时; CREATE TABLE temp（temp_id NUMBER（6），up_date DATE）;在插入日志DECLARE <span class="bold">PRAGMA</span> <span class="bold">AUTONOMOUS_TRANSACTION</span>之后创建或替换<span class="bold">TRIGGER drop_temp_table</span> ; BEGIN <span class="bold">EXECUTE IMMEDIATE'DROP TABLE temp';</span>承诺;结束; /  - 显示触发器如何工作<span class="bold">SELECT * FROM temp;</span>
 </pre><p>结果：</p><pre class="oac_no_warn" dir="ltr"><span class="bold">没有选择行</span> INSERT INTO log（log_id，up_date，new_sal，old_sal）VALUES（999，SYSDATE，5000,4500）;已创建1行。
 
<span class="bold">SELECT * FROM temp;</span>
 </pre><p>结果：</p><pre class="oac_no_warn" dir="ltr"><span class="bold">第1行的</span> <span class="bold">SELECT * FROM temp</span> <span class="bold">*</span> <span class="bold">ERROR：</span> <span class="bold">ORA-00942：表或视图不存在</span></pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="LNPLS625"></a><a id="LNPLS624"></a><div class="props_rev_3"><a id="GUID-D80328F0-79E5-4F8F-87E4-ED302A0752BE" name="GUID-D80328F0-79E5-4F8F-87E4-ED302A0752BE"></a><h4 id="LNPLS-GUID-D80328F0-79E5-4F8F-87E4-ED302A0752BE" class="sect4"><span class="enumeration_section">6.7.7</span>从SQL调用自治函数</h4>
                  <div>
                     <p>从SQL语句调用的函数必须遵守用于控制副作用的规则。</p>
                     <div class="section">
                        <p>根据定义，自治例程永远不会读取或写入数据库状态（也就是说，它既不查询也不修改任何数据库表）。</p>
                        <div class="infoboxnotealso" id="GUID-D80328F0-79E5-4F8F-87E4-ED302A0752BE__GUID-F1DC804B-7EB8-40B4-BA64-B636FD3A8C65">
                           <p class="notep1">也可以看看：</p>
                           <p><span class="q">“ <a href="plsql-subprograms.html#GUID-6C6A828F-8FA0-4278-97D2-6D5649A66A9A">子程序副作用</a> ”</span>了解更多信息</p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-D80328F0-79E5-4F8F-87E4-ED302A0752BE__CJAIGCJF">
                        <p class="titleinexample">例6-48调用自治函数</p>
                        <p>包函数<code class="codeph">log_msg</code>是自治的。因此，当查询调用该函数时，该函数<code class="codeph">debug_output</code>消息插入数据库表<code class="codeph">debug_output</code>而不会违反写入数据库状态的规则（修改数据库表）。
                        </p><pre class="oac_no_warn" dir="ltr">DROP TABLE debug_output; CREATE TABLE debug_output（message VARCHAR2（200））; CREATE OR REPLACE PACKAGE调试AUTHID DEFINER作为函数log_msg（msg VARCHAR2）RETURN VARCHAR2; END调试; / CREATE OR REPLACE PACKAGE BODY调试AS功能log_msg（msg VARCHAR2）RETURN VARCHAR2是<span class="bold">PRAGMA AUTONOMOUS_TRANSACTION;</span> BEGIN INSERT INTO debug_output（message）VALUES（msg）;承诺;返回消息;结束; END调试; /  - 从查询DECLARE my_emp_id NUMBER（6）调用包函数; my_last_name VARCHAR2（25）; my_count NUMBER; BEGIN my_emp_id：= 120; SELECT <span class="bold">debugging.log_msg（last_name）</span> INTO my_last_name FROM employees WHERE employee_id = my_emp_id; / *即使你在这个范围内回滚，插入'debug_output'仍然会被提交，因为它是自治事务的一部分。* / ROLLBACK;结束; /</pre></div>
                     <!-- class="example" -->
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>