<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <title>对象类型转换器</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Programmer&#39;s Guide"></meta>
      <meta property="og:description" content=""></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Programmer&#39;s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="c-c-programmers-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-11T03:52:01-08:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="1996, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96467-01"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="about-Collections.html" title="Previous" type="text/html"></link>
      <link rel="next" href="user-exits.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Pro*C/C++ Programmer&#39;s Guide"></meta>
    <meta name="dcterms.isVersionOf" content="LNPCC"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="about-Collections.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="user-exits.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">程序员指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="applications.html" property="item" typeof="WebPage"><span property="name">应用</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">对象类型转换器</li>
            </ol>
            <a id="GUID-502C3781-C88E-46B8-9EB2-9A93E0B4E7AE" name="GUID-502C3781-C88E-46B8-9EB2-9A93E0B4E7AE"></a><a id="LNPCC019"></a>
            
            <h2 id="LNPCC-GUID-502C3781-C88E-46B8-9EB2-9A93E0B4E7AE" class="sect2"><span class="enumeration_chapter">19</span>对象类型转换器</h2>
         </header>
         <div class="ind">
            <div>
               <p>本章讨论OTT（对象类型转换器） <a id="d101336e22" class="indexterm-anchor"></a> ，它将数据库对象类型，LOB类型和集合类型映射到C结构，以便在Pro * C / C ++应用程序中使用。
               </p>
               <p>本章包括以下部分：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="the-Object-type.html#GUID-D51AFFD7-9B76-4CAA-A7B9-1A997BABE42F">OTT概述</a></p>
                  </li>
                  <li>
                     <p><a href="the-Object-type.html#GUID-AA1C144E-3E94-47E5-A391-16318A9E262D">什么是对象类型转换器</a></p>
                  </li>
                  <li>
                     <p><a href="the-Object-type.html#GUID-8A7E3E30-3339-498F-91D0-F4E60C5544C3">使用OCI应用程序进行OTT</a></p>
                  </li>
                  <li>
                     <p><a href="the-Object-type.html#GUID-FFFE16F3-943D-4848-9E63-B590EA2A8942">关于在Pro * C / C ++应用程序中使用OTT</a></p>
                  </li>
                  <li>
                     <p><a href="the-Object-type.html#GUID-8E754758-8639-47E4-A8C5-2251C41A3BB0">OTT参考</a></p>
                  </li>
               </ul>
            </div><a id="LNPCC4435"></a><div class="props_rev_3"><a id="GUID-D51AFFD7-9B76-4CAA-A7B9-1A997BABE42F" name="GUID-D51AFFD7-9B76-4CAA-A7B9-1A997BABE42F"></a><h3 id="LNPCC-GUID-D51AFFD7-9B76-4CAA-A7B9-1A997BABE42F" class="sect3"><span class="enumeration_section">19.1</span> OTT概述</h3>
               <div>
                  <p>OTT（对象类型转换器）有助于开发在Oracle服务器中使用用户定义类型的应用程序。</p>
                  <p>通过使用SQL CREATE TYPE语句，您可以创建对象类型。这些类型的定义存储在数据库中，可用于创建数据库表。填充这些表后，OCI，Pro * C / C ++或Java程序员可以访问存储在表中的对象。</p>
                  <p>访问对象数据的应用程序必须能够以宿主语言格式表示数据。这是通过将对象类型表示为C结构来实现的。程序员可以手动编写结构声明来表示数据库对象类型，但如果涉及许多类型，这可能非常耗时且容易出错。OTT通过自动生成适当的结构声明来简化此步骤。对于Pro * C / C ++，应用程序只需要包含OTT生成的头文件。在OCI中，应用程序还需要调用OTT生成的初始化函数。</p>
                  <p>除了创建表示存储数据类型的结构之外，OTT还生成并行指示符结构，指示对象类型或其字段是否为NULL。</p>
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="about-LOBs.html#GUID-DEBB0C35-161B-4725-BE0D-A209B64B98A2">的LOB</a></li>
                        <li><a href="about-Objects.html#GUID-0C106FBC-C023-4B86-817A-1867A69388F7">对象</a></li>
                        <li><a href="about-Collections.html#GUID-BCAD71D2-D01D-40C8-8BAD-08902363ECDA">集合</a></li>
                     </ul>
                  </div>
               </div>
               
            </div><a id="LNPCC4436"></a><div class="props_rev_3"><a id="GUID-AA1C144E-3E94-47E5-A391-16318A9E262D" name="GUID-AA1C144E-3E94-47E5-A391-16318A9E262D"></a><h3 id="LNPCC-GUID-AA1C144E-3E94-47E5-A391-16318A9E262D" class="sect3"><span class="enumeration_section">19.2</span>什么是对象类型转换器</h3>
               <div>
                  <p>对象类型转换器（OTT）将对象类型和命名集合类型的数据库定义转换为C结构声明，这些声明可以包含在OCI或Pro * C / C ++应用程序中。</p>
                  <p>OCI程序员和Pro * C / C ++程序员都必须显式调用OTT才能将数据库类型转换为C表示。OCI程序员还必须初始化一个名为<span class="italic">Type Version Table</span>的数据结构，其中包含有关程序所需的用户定义类型的信息。执行此初始化的代码由OTT生成。在Pro * C / C ++中，类型版本信息记录在<code class="codeph">OUTTYPE</code>文件中，该文件作为参数传递给Pro * C / C ++。
                  </p>
                  <p>在大多数操作系统上，在命令行上调用OTT。它将<code class="codeph">INTYPE</code>文件作为输入，它生成一个<code class="codeph">OUTTYPE</code>文件和一个或多个C头文件以及一个可选的实现文件（对于OCI程序员）。以下是调用OTT的命令示例：</p><pre class="oac_no_warn" dir="ltr">ott userid = scott / tiger intype = demoin.typ outtype = demoout.typ code = c hfile = demo.h</pre><p></p>
                  <p>此命令使OTT使用用户名<span class="italic">scott</span>和密码<span class="italic">tiger</span>连接到数据库，并根据<code class="codeph">INTYPE</code>文件<span class="italic"><code class="codeph">demoin.typ</code></span>中的说明将数据库类型转换为C结构。生成的结构将输出到头文件<span class="italic">demo.h中</span> ，用于<code class="codeph">CODE</code>参数指定的主机语言（C）。<code class="codeph">OUTTYPE</code>文件<span class="italic"><code class="codeph">demoout.typ</code></span>接收有关翻译的信息。
                  </p>
                  <p>本章后面的部分将详细介绍这些参数中的每一个。</p>
                  <p>示例<code class="codeph">demoin.typ</code>文件：</p><pre class="oac_no_warn" dir="ltr">CASE = LOWER TYPE员工</pre><p>示例<code class="codeph">demoout.typ</code>文件：</p><pre class="oac_no_warn" dir="ltr">CASE = LOWER TYPE SCOTT.EMPLOYEE AS员工VERSION =“$ 8.0”HFILE = demo.h</pre><p>在此示例中， <code class="codeph">demoin.typ</code>文件包含要转换的类型，前面是TYPE（例如，TYPE employee）。<code class="codeph">OUTTYPE</code>文件的结构类似于<code class="codeph">INTYPE</code>文件，添加了OTT获取的信息。</p>
                  <p>OTT完成转换后，头文件包含<code class="codeph">INTYPE</code>文件中指定的每种类型的C结构表示，以及与每种类型对应的NULL指示符结构。例如，如果<code class="codeph">INTYPE</code>文件中列出的员工类型定义为</p><pre class="oac_no_warn" dir="ltr">CREATE TYPE employee AS OBJECT（名称VARCHAR2（30），empno NUMBER，deptno NUMBER，hiredate DATE，salary NUMBER）;</pre><p>OTT（ <code class="codeph">demo.h</code> ）生成的头文件包括以下声明，以及其他项目：</p><pre class="oac_no_warn" dir="ltr">struct employee {OCIString * name; OCINumber empno; OCINumber deptno; OCIDate雇用; OCINumber薪水; }; typedef struct emp_type emp_type; struct employee_ind {OCIInd _atomic; OCIInd名称; OCIInd empno; OCIInd deptno; OCIInd雇用; OCIInd工资; }; typedef struct employee_ind employee_ind;</pre><p>结构声明中出现的数据类型（例如， <span class="bold">OCIString</span>和<span class="bold">OCIInd</span> ）是Oracle 8中新增的特殊数据类型。
                  </p>
                  <p>以下部分描述了使用OTT的这些方面：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="the-Object-type.html#GUID-FF35352F-4611-4341-813E-0E955DA528F5">关于在数据库中创建类型</a></p>
                     </li>
                     <li>
                        <p><a href="the-Object-type.html#GUID-B49AE2D1-4035-458D-A960-079AE4AC49E2">关于调用OTT</a></p>
                     </li>
                     <li>
                        <p><a href="the-Object-type.html#GUID-030B4AA0-E54B-438C-B0A1-C3BE7ADF1530">OTT命令行</a></p>
                     </li>
                     <li>
                        <p><a href="the-Object-type.html#GUID-58C0A751-AB3E-4AAB-8BAF-9F5C70FF6338">INTYPE文件</a></p>
                     </li>
                     <li>
                        <p><a href="the-Object-type.html#GUID-38E440CA-2AD1-457C-B189-83E8EA965FF9">OTT数据类型映射</a></p>
                     </li>
                     <li>
                        <p><a href="the-Object-type.html#GUID-1E36744C-52EA-49D1-B05D-0E73C36436A4">NULL指示符结构</a></p>
                     </li>
                     <li>
                        <p><a href="the-Object-type.html#GUID-A9A00891-FD32-4B0A-813A-4064DF43557B">OTT支持类型继承</a></p>
                     </li>
                  </ul>
                  <p>本章的其余部分讨论OTT与OCI和Pro * C / C ++的使用，后面是描述命令行语法，参数， <code class="codeph">INTYPE</code>文件结构，嵌套<code class="codeph">#include</code>文件生成，模式名称用法，默认名称映射的参考部分和限制。
                  </p>
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="the-Object-type.html#GUID-38E440CA-2AD1-457C-B189-83E8EA965FF9">OTT数据类型映射</a></li>
                     </ul>
                  </div>
               </div>
               <a id="LNPCC4437"></a><div class="props_rev_3"><a id="GUID-FF35352F-4611-4341-813E-0E955DA528F5" name="GUID-FF35352F-4611-4341-813E-0E955DA528F5"></a><h4 id="LNPCC-GUID-FF35352F-4611-4341-813E-0E955DA528F5" class="sect4"><span class="enumeration_section">19.2.1</span>关于在数据库中创建类型</h4>
                  <div>
                     <p>使用OTT的第一步是创建对象类型或命名集合类型并将它们存储在数据库中。这是通过使用SQL CREATE TYPE语句完成的。</p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="about-Objects.html#GUID-0C106FBC-C023-4B86-817A-1867A69388F7">对象</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div><a id="LNPCC4438"></a><div class="props_rev_3"><a id="GUID-B49AE2D1-4035-458D-A960-079AE4AC49E2" name="GUID-B49AE2D1-4035-458D-A960-079AE4AC49E2"></a><h4 id="LNPCC-GUID-B49AE2D1-4035-458D-A960-079AE4AC49E2" class="sect4"><span class="enumeration_section">19.2.2</span>关于调用OTT</h4>
                  <div>
                     <p>下一步是调用OTT。</p>
                     <p>您可以在命令行或称为配置文件的文件中指定OTT参数。某些参数也可以在<code class="codeph">INTYPE</code>文件中指定。
                     </p>
                     <p>如果在多个位置指定参数，则其在命令行上的值将优先于其在<code class="codeph">INTYPE</code>文件中的值，该值优先于其在用户定义的配置文件中的值，该文件优先于其在默认配置文件。
                     </p>
                     <p>对于全局选项 - 即命令行上的选项或任何TYPE语句之前<code class="codeph">INTYPE</code>文件开头的选项 - 命令行上的值将覆盖<code class="codeph">INTYPE</code>文件中的值。（可以在<code class="codeph">INTYPE</code>文件中全局指定的选项是<code class="codeph">CASE</code> ， <code class="codeph">CODE</code> ， <code class="codeph">INITFILE</code> ， <code class="codeph">OUTDIR</code>和<code class="codeph">INITFUNC</code> ，但不是<code class="codeph">HFILE</code> 。）TYPE规范中<code class="codeph">INTYPE</code>文件中的任何内容仅适用于特定类型，并覆盖命令行上可能适用于该类型的任何内容。因此，如果输入<code class="codeph">TYPE person HFILE=ph</code> ，它仅适用于<code class="codeph">person</code>并覆盖命令行上的<code class="codeph">HFILE</code> 。该语句不被视为命令行参数。
                     </p>
                  </div><a id="LNPCC4439"></a><div class="props_rev_3"><a id="GUID-20260BFB-6BCF-4340-A462-A881B1FB7B12" name="GUID-20260BFB-6BCF-4340-A462-A881B1FB7B12"></a><h5 id="LNPCC-GUID-20260BFB-6BCF-4340-A462-A881B1FB7B12" class="sect5"><span class="enumeration_section">19.2.2.1</span>命令行</h5>
                     <div>
                        <div class="section">
                           <p>在命令行上设置的参数（也称为选项）会覆盖其他任何设置。</p>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="relinfo">
                           <p><strong>相关话题</strong></p>
                           <ul>
                              <li><a href="about-Objects.html#GUID-0C106FBC-C023-4B86-817A-1867A69388F7">对象</a></li>
                           </ul>
                        </div>
                     </div>
                     
                  </div><a id="LNPCC4440"></a><div class="props_rev_3"><a id="GUID-CF25B6AE-12F6-4D2D-B2FC-F00D19CF61E0" name="GUID-CF25B6AE-12F6-4D2D-B2FC-F00D19CF61E0"></a><h5 id="LNPCC-GUID-CF25B6AE-12F6-4D2D-B2FC-F00D19CF61E0" class="sect5"><span class="enumeration_section">19.2.2.2</span>配置文件</h5>
                     <div>
                        <div class="section">
                           <p>配置文件是包含OTT参数的文本文件。文件中的每个非空行包含一个参数及其关联的值。如果在一行上放置多个参数，则仅使用第一个参数。配置文件的任何非空行都不会出现空格。</p>
                           <p>可以在命令行上命名配置文件。此外，始终读取默认配置文件。此默认配置文件必须始终存在，但可以为空。默认配置文件的名称是<code class="codeph">ottcfg.cfg</code> ，文件的位置是特定于系统的。有关详细信息，请参阅特定于平台的文档。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNPCC4441"></a><div class="props_rev_3"><a id="GUID-DA80A959-3A3D-4487-B92E-638EDD21BEBC" name="GUID-DA80A959-3A3D-4487-B92E-638EDD21BEBC"></a><h5 id="LNPCC-GUID-DA80A959-3A3D-4487-B92E-638EDD21BEBC" class="sect5"><span class="enumeration_section">19.2.2.3</span> INTYPE文件</h5>
                     <div>
                        <div class="section">
                           <p><code class="codeph">INTYPE</code>文件提供了要翻译的OTT类型列表。
                           </p>
                           <p>参数<code class="codeph">CASE</code> ， <code class="codeph">HFILE</code> ， <code class="codeph">INITFUNC</code>和<code class="codeph">INITFILE</code>可以出现在<code class="codeph">INTYPE</code>文件中。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="relinfo">
                           <p><strong>相关话题</strong></p>
                           <ul>
                              <li><a href="the-Object-type.html#GUID-58C0A751-AB3E-4AAB-8BAF-9F5C70FF6338">INTYPE文件</a></li>
                           </ul>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="LNPCC4442"></a><div class="props_rev_3"><a id="GUID-030B4AA0-E54B-438C-B0A1-C3BE7ADF1530" name="GUID-030B4AA0-E54B-438C-B0A1-C3BE7ADF1530"></a><h4 id="LNPCC-GUID-030B4AA0-E54B-438C-B0A1-C3BE7ADF1530" class="sect4"><span class="enumeration_section">19.2.3</span> OTT命令行</h4>
                  <div>
                     <p>在大多数平台上，在命令行上调用OTT。您可以指定输入和输出文件以及数据库连接信息等。请参阅特定于平台的文档，了解如何在平台上调用OTT。</p>
                     <p>以下是命令行中OTT调用的示例（示例1）：</p><pre class="oac_no_warn" dir="ltr">ott userid = scott / tiger intype = demoin.typ outtype = demoout.typ code = c hfile = demo.h</pre><div class="infoboxnote" id="GUID-030B4AA0-E54B-438C-B0A1-C3BE7ADF1530__GUID-18ACB56E-8EAB-49C3-97EE-AFEC587CC8A2">
                        <p class="notep1">注意：</p>
                        <p>等号（=）周围不允许有空格。</p>
                     </div>
                     <p>以下部分描述了此示例中使用的命令行的元素。</p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="the-Object-type.html#GUID-8E754758-8639-47E4-A8C5-2251C41A3BB0">OTT参考</a></li>
                        </ul>
                     </div>
                  </div>
                  <a id="LNPCC4443"></a><div class="props_rev_3"><a id="GUID-0C941794-AB99-45A3-87DF-E4DCFD45F782" name="GUID-0C941794-AB99-45A3-87DF-E4DCFD45F782"></a><h5 id="LNPCC-GUID-0C941794-AB99-45A3-87DF-E4DCFD45F782" class="sect5"><span class="enumeration_section">19.2.3.1</span> OTT</h5>
                     <div>
                        <div class="section">
                           <p>导致OTT被调用。它必须是命令行中的第一项。</p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNPCC4444"></a><div class="props_rev_3"><a id="GUID-FC89B923-810B-46A8-86E8-2E5962363B2F" name="GUID-FC89B923-810B-46A8-86E8-2E5962363B2F"></a><h5 id="LNPCC-GUID-FC89B923-810B-46A8-86E8-2E5962363B2F" class="sect5"><span class="enumeration_section">19.2.3.2</span>用户ID</h5>
                     <div>
                        <div class="section">
                           <p>指定OTT将使用的数据库连接信息。在示例一中，OTT将尝试使用用户名<span class="italic">scott</span>和密码<span class="italic">tiger连接</span> 。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNPCC4445"></a><div class="props_rev_3"><a id="GUID-EB3E26F1-1A80-46BB-B2A5-7422BD21A413" name="GUID-EB3E26F1-1A80-46BB-B2A5-7422BD21A413"></a><h5 id="LNPCC-GUID-EB3E26F1-1A80-46BB-B2A5-7422BD21A413" class="sect5"><span class="enumeration_section">19.2.3.3</span> INTYPE</h5>
                     <div>
                        <div class="section">
                           <p>指定将使用的<code class="codeph">INTYPE</code>文件的名称。在示例1中， <code class="codeph">INTYPE</code>文件的名称指定为<span class="italic"><code class="codeph">demoin.typ</code></span> 。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNPCC4446"></a><div class="props_rev_3"><a id="GUID-AD4F9B94-CCFD-4A1A-960D-E6A6FC41BCA8" name="GUID-AD4F9B94-CCFD-4A1A-960D-E6A6FC41BCA8"></a><h5 id="LNPCC-GUID-AD4F9B94-CCFD-4A1A-960D-E6A6FC41BCA8" class="sect5"><span class="enumeration_section">19.2.3.4</span> OUTTYPE</h5>
                     <div>
                        <div class="section">
                           <p>指定<code class="codeph">OUTTYPE</code>文件的名称。当OTT生成C头文件时，它还会将有关已翻译类型的信息写入<code class="codeph">OUTTYPE</code>文件。此文件包含每个要转换的类型的条目，包括其版本字符串以及写入其C表示的头文件。
                           </p>
                           <p>在示例一中，OUTTYPE文件的名称被指定为<span class="italic"><code class="codeph">demoout.typ</code></span> 。
                           </p>
                           <div class="infoboxnote" id="GUID-AD4F9B94-CCFD-4A1A-960D-E6A6FC41BCA8__GUID-F4123970-5857-4488-A840-1019949744C4">
                              <p class="notep1">注意：</p>
                              <p>如果<code class="codeph">OUTTYPE</code>指定的文件已存在，则OTT运行时将覆盖该文件，但有一个例外：如果OTT生成的文件内容与文件的先前内容相同，则OTT实际上不会写入文件。这样可以保留文件的修改时间，以便UNIX <span class="italic">make</span>和其他平台上的类似工具不会执行不必要的重新编译。
                              </p>
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNPCC4447"></a><div class="props_rev_3"><a id="GUID-AEBCB4B8-121D-4B57-A82C-B4A4416EBA77" name="GUID-AEBCB4B8-121D-4B57-A82C-B4A4416EBA77"></a><h5 id="LNPCC-GUID-AEBCB4B8-121D-4B57-A82C-B4A4416EBA77" class="sect5"><span class="enumeration_section">19.2.3.5</span>代码</h5>
                     <div>
                        <div class="section">
                           <p>指定转换的目标语言。可以使用以下选项：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>C（相当于ANSI_C）</p>
                              </li>
                              <li>
                                 <p>ANSI_C（ANSI C）</p>
                              </li>
                              <li>
                                 <p>KR_C（适用于Kernighan＆Ritchie C）</p>
                              </li>
                           </ul>
                           <p>目前没有默认值，因此该参数是必需的。</p>
                           <p>两种C方言中的结构声明都是相同的。定义<code class="codeph">INITFILE</code>文件中定义的初始化函数的样式取决于是否使用KR_C。如果未使用<code class="codeph">INITFILE</code>选项，则所有三个选项都是等效的。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNPCC4448"></a><div class="props_rev_3"><a id="GUID-95725365-3E75-4FD9-AA06-9C2493F5AE32" name="GUID-95725365-3E75-4FD9-AA06-9C2493F5AE32"></a><h5 id="LNPCC-GUID-95725365-3E75-4FD9-AA06-9C2493F5AE32" class="sect5"><span class="enumeration_section">19.2.3.6</span> HFILE</h5>
                     <div>
                        <div class="section">
                           <p>指定应将生成的结构写入的C头文件的名称。在示例1中，生成的结构将存储在名为<code class="codeph">demo.h</code>的文件中。
                           </p>
                           <div class="infoboxnote" id="GUID-95725365-3E75-4FD9-AA06-9C2493F5AE32__GUID-10FAE0BF-E45A-4F60-8EC4-B0BF742151B8">
                              <p class="notep1">注意：</p>
                              <p>如果<code class="codeph">HFILE</code>指定的文件已存在，则OTT运行时将覆盖该文件，但有一个例外：如果OTT生成的文件内容与文件的先前内容相同，则OTT实际上不会写入该文件。这样可以保留文件的修改时间，以便UNIX <span class="italic">make</span>和其他平台上的类似工具不会执行不必要的重新编译。
                              </p>
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNPCC4449"></a><div class="props_rev_3"><a id="GUID-BAFA5489-925B-4E74-BFDC-D664BFE87602" name="GUID-BAFA5489-925B-4E74-BFDC-D664BFE87602"></a><h5 id="LNPCC-GUID-BAFA5489-925B-4E74-BFDC-D664BFE87602" class="sect5"><span class="enumeration_section">19.2.3.7</span> INITFILE</h5>
                     <div>
                        <div class="section">
                           <p>指定要在其中写入类型初始化函数的C源文件的使用。</p>
                           <p>初始化功能仅在OCI程序中需要。在Pro * C / C ++程序中，Pro * C / C ++运行时库初始化用户的类型。</p>
                           <div class="infoboxnote" id="GUID-BAFA5489-925B-4E74-BFDC-D664BFE87602__GUID-ED488FC5-398A-468B-8DC6-557529461D47">
                              <p class="notep1">注意：</p>
                              <p>如果<code class="codeph">INITFILE</code>指定的文件已存在，则OTT运行时将覆盖该文件，但有一个例外：如果OTT生成的文件内容与文件的先前内容相同，则OTT实际上不会写入文件。这样可以保留文件的修改时间，以便UNIX <span class="italic">make</span>和其他平台上的类似工具不会执行不必要的重新编译。
                              </p>
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNPCC4450"></a><div class="props_rev_3"><a id="GUID-E85CFF2F-403E-47A2-9310-2F5082E29CF9" name="GUID-E85CFF2F-403E-47A2-9310-2F5082E29CF9"></a><h5 id="LNPCC-GUID-E85CFF2F-403E-47A2-9310-2F5082E29CF9" class="sect5"><span class="enumeration_section">19.2.3.8</span> INITFUNC</h5>
                     <div>
                        <div class="section">
                           <p>指定要在<code class="codeph">INITFILE</code>定义的初始化函数的名称。</p>
                           <p>如果未使用此参数并生成初始化函数，则初始化函数的名称将与<code class="codeph">INITFILE</code>的基本名称相同。</p>
                           <p>只有在OCI程序中才需要此功能。</p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="LNPCC4451"></a><div class="props_rev_3"><a id="GUID-58C0A751-AB3E-4AAB-8BAF-9F5C70FF6338" name="GUID-58C0A751-AB3E-4AAB-8BAF-9F5C70FF6338"></a><h4 id="LNPCC-GUID-58C0A751-AB3E-4AAB-8BAF-9F5C70FF6338" class="sect4"><span class="enumeration_section">19.2.4</span> INTYPE文件</h4>
                  <div>
                     <p>运行OTT时， <code class="codeph">INTYPE</code>文件告诉OTT应转换哪些数据库类型。它还可以控制生成的结构的命名。您可以创建<code class="codeph">INTYPE</code>文件，或使用先前调用OTT的<code class="codeph">OUTTYPE</code>文件。如果未使用<code class="codeph">INTYPE</code>参数，则转换OTT连接的架构中的所有类型。
                     </p>
                     <p>以下是用户创建的<code class="codeph">INTYPE</code>文件的简单示例：</p><pre class="oac_no_warn" dir="ltr">CASE = LOWER TYPE员工TRANSLATE SALARY $ AS薪水DEPTNO AS部门类型地址类型项目类型“人员”TYPE PURCHASE_ORDER as p_o</pre><p>第一行带有<code class="codeph">CASE</code>关键字，表示生成的C标识符应为小写。但是，此<code class="codeph">CASE</code>选项仅适用于<code class="codeph">INTYPE</code>文件中未明确提及的那些标识符。因此， <span class="italic">员工</span> <code class="codeph"> </code>和<span class="italic">ADDRESS</span>将始终分别导致C结构<code class="codeph">employee</code>和<code class="codeph">ADDRESS</code> 。这些结构的成员将以小写字母命名。
                     </p>
                     <p>以TYPE关键字开头的行指定应转换数据库中的哪些类型。在这种情况下， <span class="italic">EMPLOYEE，ADDRESS，ITEM，PERSON</span>和<span class="italic">PURCHASE_ORDER</span>类型。
                     </p>
                     <p>翻译......AS关键字指定在将类型转换为C结构时应更改对象属性的名称。在这种情况下， <code class="codeph">employee</code>类型的SALARY $属性将转换为<code class="codeph">salary</code> 。
                     </p>
                     <p>最后一行中的AS关键字指定在将对象类型转换为结构时应更改该对象类型的名称。在这种情况下， <span class="italic">purchase_order</span>数据库类型将转换为名为<span class="italic">p_o</span>的结构。
                     </p>
                     <p>如果不使用AS来转换类型或属性名称，则类型或属性的数据库名称将用作C标识符名称，但将遵守<code class="codeph">CASE</code>选项，以及无法映射到合法的任何字符C标识符字符将替换为下划线。翻译类型或属性名称的原因包括：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>名称包含字母，数字和下划线以外的字符</p>
                        </li>
                        <li>
                           <p>名称与C关键字冲突</p>
                        </li>
                        <li>
                           <p>类型名称与同一范围内的另一个标识符冲突。例如，如果程序使用来自不同模式的两个具有相同名称的类型，则会发生这种情况。</p>
                        </li>
                        <li>
                           <p>程序员喜欢不同的名字</p>
                        </li>
                     </ul>
                     <p>OTT可能需要转换<code class="codeph">INTYPE</code>文件中未列出的其他类型。这是因为OTT在执行转换之前分析<code class="codeph">INTYPE</code>文件中的类型依赖关系类型，并根据需要转换其他类型。例如，如果是<span class="italic">ADDRESS</span> <code class="codeph"> </code>类型未在<code class="codeph">INTYPE</code>文件中列出，但<span class="italic">Person</span>类型具有<span class="italic">ADDRESS</span>类型的属性，OTT仍将转换<span class="italic">ADDRESS，</span>因为它需要定义<span class="italic">Person</span>类型。
                     </p>
                     <div class="infoboxnote" id="GUID-58C0A751-AB3E-4AAB-8BAF-9F5C70FF6338__GUID-458036D6-00D4-4715-9322-9EE3C0DB0831">
                        <p class="notep1">注意：</p>
                        <p>从版本1（9.0.1）开始，用户可以指定TRANSITIVE = FALSE以<span class="italic">不</span>生成<code class="codeph">INTYPE</code>文件中未指定的类型。默认情况下，TRANSITIVE设置为TRUE。
                        </p>
                     </div>
                     <p>正常的不区分大小写的SQL标识符可以在<code class="codeph">INTYPE</code>文件中以大写和小写的任意组合拼写，并且不引用。
                     </p>
                     <p>使用引号（例如TYPE“ <span class="italic">Person</span> ”）来引用以区分大小写的方式创建的SQL标识符，例如，CREATE TYPE“ <span class="italic">Person</span> ”。如果SQL标识符在声明时引用，则它区分大小写。
                     </p>
                     <p>引号也可用于表示也是OTT保留字的SQL标识符，例如TYPE“CASE”。在这种情况下，如果SQL标识符是以不区分大小写的方式创建的，则引用的名称必须为大写，例如，CREATE TYPE Case。如果OTT保留字用于引用SQL标识符的名称但未引用，则OTT将在<code class="codeph">INTYPE</code>文件中报告语法错误。
                     </p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="the-Object-type.html#GUID-2910B3D2-50E0-4E3F-93B4-A20ED287CCE9">案件</a></li>
                           <li><a href="the-Object-type.html#GUID-D114064D-E05F-42DD-9DB9-EAEEE5A9619B">INTYPE文件的结构</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div><a id="LNPCC4452"></a><div class="props_rev_3"><a id="GUID-38E440CA-2AD1-457C-B189-83E8EA965FF9" name="GUID-38E440CA-2AD1-457C-B189-83E8EA965FF9"></a><h4 id="LNPCC-GUID-38E440CA-2AD1-457C-B189-83E8EA965FF9" class="sect4"><span class="enumeration_section">19.2.5</span> OTT数据类型映射</h4>
                  <div>
                     <p>当OTT从数据库类型生成C结构时，该结构包含一个对应于对象类型的每个属性的元素。属性的数据类型映射到Oracle对象数据类型中使用的类型。Oracle中的数据类型包括一组预定义的原始类型，并提供用户定义类型的创建，如对象类型和集合。</p>
                     <p>预定义类型集包括大多数程序员熟悉的标准类型，包括数字和字符类型。它还包括Oracle8引入的数据类型（例如，BLOB或CLOB）。</p>
                     <p>Oracle还包括一组预定义类型，用于表示C结构中的对象类型属性。作为示例，请考虑以下对象类型定义及其对应的OTT生成的结构声明：</p><pre class="oac_no_warn" dir="ltr">CREATE TYPE employee AS OBJECT（名称VARCHAR2（30），empno NUMBER，deptno NUMBER，雇用日期，工资$ NUMBER）;</pre><p>假设<code class="codeph">CASE=LOWER</code>且没有类型或属性名称的显式映射，OTT输出为：</p><pre class="oac_no_warn" dir="ltr">struct employee {OCIString * name; OCINumber empno; OCINumber部门; OCIDate雇用; OCINumber salary_; }; typedef struct emp_type emp_type; struct employee_ind {OCIInd _atomic; OCIInd名称; OCIInd empno; OCIInd部门; OCIInd雇用; OCIInd salary_; } typedef struct employee_ind employee_ind;</pre><p>指示符struct <code class="codeph">(struct employee_ind)</code>在<span class="q">“ <a href="the-Object-type.html#GUID-1E36744C-52EA-49D1-B05D-0E73C36436A4">NULL Indicator Structs</a> ”中进行了</span>解释。
                     </p>
                     <p>结构声明中的数据类型<code class="codeph">OCIString</code> ， <code class="codeph">OCINumber</code> ， <code class="codeph">OCIDate</code> ， <code class="codeph">OCIInd</code>是Oracle8中引入的对象类型的C映射。它们用于映射对象类型属性的数据类型。例如， <code class="codeph">empno</code>属性的<code class="codeph">NUMBER</code>数据类型映射到新的<code class="codeph">OCINumber</code>数据类型。这些新数据类型也可以用作绑定和定义变量的类型。
                     </p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="../lnoci/oci-programming-basics.html#LNOCI-GUID-3CA268B4-AFC8-467C-B127-0E15E90A14DB" target="_blank"><span class="italic">OCI数据结构</span></a></li>
                        </ul>
                     </div>
                  </div><a id="LNPCC4454"></a><a id="LNPCC4455"></a><a id="LNPCC4453"></a><div class="props_rev_3"><a id="GUID-40348350-2921-4CA0-8609-A66CCE4F952A" name="GUID-40348350-2921-4CA0-8609-A66CCE4F952A"></a><h5 id="LNPCC-GUID-40348350-2921-4CA0-8609-A66CCE4F952A" class="sect5"><span class="enumeration_section">19.2.5.1将</span>对象数据类型映射到C</h5>
                     <div>
                        <div class="section">
                           <p>本节描述了对象属性类型到OTT生成的C类型的映射。 <a href="the-Object-type.html#GUID-40348350-2921-4CA0-8609-A66CCE4F952A__CHDFGJDA" title="对象类型属性的对象数据类型映射">表19-1</a>列出了可用作OTT生成的对象数据类型属性的类型的映射。</p>
                        </div>
                        <!-- class="section" -->
                        <div class="tblformal" id="GUID-40348350-2921-4CA0-8609-A66CCE4F952A__CHDFGJDA">
                           <p class="titleintable">表19-1对象类型属性的对象数据类型映射</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="对象类型属性的对象数据类型映射" width="100%" border="1" summary="Object Datatype Mappings for Object Type Attributes" frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="54%" id="d101336e1194">对象属性类型</th>
                                    <th align="left" valign="bottom" width="46%" id="d101336e1197">C映射</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="54%" id="d101336e1202" headers="d101336e1194 ">
                                       <p>VARCHAR2（N）</p>
                                    </td>
                                    <td align="left" valign="top" width="46%" headers="d101336e1202 d101336e1197 ">
                                       <p>OCIString *</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="54%" id="d101336e1209" headers="d101336e1194 ">
                                       <p>VARCHAR（N）</p>
                                    </td>
                                    <td align="left" valign="top" width="46%" headers="d101336e1209 d101336e1197 ">
                                       <p>OCIString *</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="54%" id="d101336e1216" headers="d101336e1194 ">
                                       <p>CHAR（N），CHARACTER（N）</p>
                                    </td>
                                    <td align="left" valign="top" width="46%" headers="d101336e1216 d101336e1197 ">
                                       <p>OCIString *</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="54%" id="d101336e1223" headers="d101336e1194 ">
                                       <p>NUMBER，NUMBER（N），NUMBER（N，N）</p>
                                    </td>
                                    <td align="left" valign="top" width="46%" headers="d101336e1223 d101336e1197 ">
                                       <p>OCINumber</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="54%" id="d101336e1230" headers="d101336e1194 ">
                                       <p>NUMERIC，NUMERIC（N），NUMERIC（N，N）</p>
                                    </td>
                                    <td align="left" valign="top" width="46%" headers="d101336e1230 d101336e1197 ">
                                       <p>OCINumber</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="54%" id="d101336e1237" headers="d101336e1194 ">
                                       <p>真实</p>
                                    </td>
                                    <td align="left" valign="top" width="46%" headers="d101336e1237 d101336e1197 ">
                                       <p>OCINumber</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="54%" id="d101336e1244" headers="d101336e1194 ">
                                       <p>INT，INTEGER，SMALLINT</p>
                                    </td>
                                    <td align="left" valign="top" width="46%" headers="d101336e1244 d101336e1197 ">
                                       <p>OCINumber</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="54%" id="d101336e1251" headers="d101336e1194 ">
                                       <p>FLOAT，FLOAT（N），双精度</p>
                                    </td>
                                    <td align="left" valign="top" width="46%" headers="d101336e1251 d101336e1197 ">
                                       <p>OCINumber</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="54%" id="d101336e1258" headers="d101336e1194 ">
                                       <p>DEC，DEC（N），DEC（N，N）</p>
                                    </td>
                                    <td align="left" valign="top" width="46%" headers="d101336e1258 d101336e1197 ">
                                       <p>OCINumber</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="54%" id="d101336e1265" headers="d101336e1194 ">
                                       <p>DECIMAL，DECIMAL（N），DECIMAL（N，N）</p>
                                    </td>
                                    <td align="left" valign="top" width="46%" headers="d101336e1265 d101336e1197 ">
                                       <p>OCINumber</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="54%" id="d101336e1272" headers="d101336e1194 ">
                                       <p>日期</p>
                                    </td>
                                    <td align="left" valign="top" width="46%" headers="d101336e1272 d101336e1197 ">
                                       <p>OCIDate *</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="54%" id="d101336e1280" headers="d101336e1194 ">
                                       <p>BLOB</p>
                                    </td>
                                    <td align="left" valign="top" width="46%" headers="d101336e1280 d101336e1197 ">
                                       <p>OCIBlobLocator *</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="54%" id="d101336e1287" headers="d101336e1194 ">
                                       <p>CLOB</p>
                                    </td>
                                    <td align="left" valign="top" width="46%" headers="d101336e1287 d101336e1197 ">
                                       <p>OCIClobLocator *</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="54%" id="d101336e1294" headers="d101336e1194 ">
                                       <p>BFILE</p>
                                    </td>
                                    <td align="left" valign="top" width="46%" headers="d101336e1294 d101336e1197 ">
                                       <p>OCIBFileLocator *</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="54%" id="d101336e1301" headers="d101336e1194 ">
                                       <p>嵌套对象类型</p>
                                    </td>
                                    <td align="left" valign="top" width="46%" headers="d101336e1301 d101336e1197 ">
                                       <p>嵌套对象类型的C名称。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="54%" id="d101336e1308" headers="d101336e1194 ">
                                       <p>REF</p>
                                    </td>
                                    <td align="left" valign="top" width="46%" headers="d101336e1308 d101336e1197 ">
                                       <p>使用typedef声明;相当于OCIRef *。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="54%" id="d101336e1315" headers="d101336e1194 ">
                                       <p>RAW（N）</p>
                                    </td>
                                    <td align="left" valign="top" width="46%" headers="d101336e1315 d101336e1197 ">
                                       <p>OCIRaw *</p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <div class="section">
                           <p><a href="the-Object-type.html#GUID-40348350-2921-4CA0-8609-A66CCE4F952A__G454458" title="集合类型的对象数据类型映射">表19-2</a>显示了命名集合类型到OTT生成的对象数据类型的映射：</p>
                        </div>
                        <!-- class="section" -->
                        <div class="tblformal" id="GUID-40348350-2921-4CA0-8609-A66CCE4F952A__G454458">
                           <p class="titleintable">表19-2集合类型的对象数据类型映射</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="集合类型的对象数据类型映射" width="100%" border="1" summary="Object Datatype Mappings for Collection Types" frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="32%" id="d101336e1338">命名集合类型</th>
                                    <th align="left" valign="bottom" width="68%" id="d101336e1341">C映射</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="32%" id="d101336e1346" headers="d101336e1338 ">
                                       <p>VARRAY</p>
                                    </td>
                                    <td align="left" valign="top" width="68%" headers="d101336e1346 d101336e1341 ">
                                       <p>使用typedef声明;相当于OCIArray *。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="32%" id="d101336e1353" headers="d101336e1338 ">
                                       <p>嵌套表</p>
                                    </td>
                                    <td align="left" valign="top" width="68%" headers="d101336e1353 d101336e1341 ">
                                       <p>使用typedef声明;相当于OCITable *。</p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <div class="section">
                           <div class="infoboxnote" id="GUID-40348350-2921-4CA0-8609-A66CCE4F952A__GUID-D7D19BC1-470F-48B4-AAD6-D50291D03F52">
                              <p class="notep1">注意：</p>
                              <p>对于REF，VARRAY和NESTED TABLE类型，OTT生成typedef。然后，在typedef中声明的类型将用作struct声明中数据成员的类型。</p>
                           </div>
                           <p>如果对象类型包括REF或集合类型的属性，则首先生成REF或集合类型的typedef。然后生成对应于对象类型的struct声明。该struct包含一个元素，其类型是指向REF或集合类型的指针。</p>
                           <p>如果对象类型包含其类型为另一种对象类型的属性，则OTT首先生成嵌套类型（如果TRANSITIVE = TRUE。）然后，它将对象类型属性映射到嵌套对象类型的嵌套结构。</p>
                           <p>OTT映射非对象数据库属性类型的C数据类型是结构，除OCIDate外，它们是不透明的。</p>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="relinfo">
                           <p><strong>相关话题</strong></p>
                           <ul>
                              <li><a href="the-Object-type.html#GUID-D478DA42-5F8B-422A-B6EB-34AB6546EA2A">OTT类型映射示例</a></li>
                           </ul>
                        </div>
                     </div>
                     
                  </div><a id="LNPCC4456"></a><div class="props_rev_3"><a id="GUID-D478DA42-5F8B-422A-B6EB-34AB6546EA2A" name="GUID-D478DA42-5F8B-422A-B6EB-34AB6546EA2A"></a><h5 id="LNPCC-GUID-D478DA42-5F8B-422A-B6EB-34AB6546EA2A" class="sect5"><span class="enumeration_section">19.2.5.2</span> OTT类型映射示例</h5>
                     <div>
                        <div class="section">
                           <p>以下示例演示OTT创建的各种类型映射。</p>
                           <p>给定以下数据库类型：</p><pre class="oac_no_warn" dir="ltr">CREATE TYPE my_varray AS VARRAY（5）的整数; CREATE TYPE object_type AS OBJECT（object_name VARCHAR2（20））; CREATE TYPE my_table AS TABLE OF object_type; CREATE TYPE many_types AS OBJECT（the_varchar VARCHAR2（30），the_char CHAR（3），the_blob BLOB，the_clob CLOB，the_object object_type，another_ref REF other_type，the_ref REF many_types，the_varray my_varray，the_table my_table，the_date DATE，the_num NUMBER，the_raw RAW（ 255））;</pre><p>和一个包含以下内容的<code class="codeph">INTYPE</code>文件：</p><pre class="oac_no_warn" dir="ltr">CASE = LOWER TYPE many_types</pre><p>OTT将生成以下C结构：</p>
                           <div class="infoboxnote" id="GUID-D478DA42-5F8B-422A-B6EB-34AB6546EA2A__GUID-BAC39CEC-5273-45CA-B3AD-23BDF48ABE41">
                              <p class="notep1">注意：</p>
                              <p>这里提供的评论有助于解释结构。这些注释不是实际OTT输出的一部分。</p>
                           </div><pre class="oac_no_warn" dir="ltr">#ifndef MYFILENAME_ORACLE #define MYFILENAME_ORACLE #ifndef OCI_ORACLE #include &lt;oci.h&gt; #endif typedef OCIRef many_types_ref; typedef OCIRef object_type_ref; typedef OCIArray my_varray; / * many_types的一部分* / typedef OCITable my_table; / * many_types的一部分* / typedef OCIRef other_type_ref; struct object_type / * many_types的一部分* / {OCIString * object_name; }; typedef struct object_type object_type; struct object_type_ind / *指示符结构，用于* / {/ * object_types * / OCIInd _atomic; OCIInd object_name; }; typedef struct object_type_ind object_type_ind; struct many_types {OCIString * the_varchar; OCIString * the_char; OCIBlobLocator * the_blob; OCIClobLocator * the_clob; struct object_type the_object; other_type_ref * another_ref; many_types_ref * the_ref; my_varray * the_varray; my_table * the_table; OCIDate the_date; OCINumber the_num; OCIRaw * the_raw; }; typedef struct many_types many_types; struct many_types_ind / *指示符结构，用于* / {/ * many_types * / OCIInd _atomic; OCIInd the_varchar; OCIInd the_char; OCIInd the_blob; OCIInd the_clob; struct object_type_ind the_object; / *嵌套* / OCIInd another_ref; OCIInd the_ref; OCIInd the_varray; OCIInd the_table; OCIInd the_date; OCIInd the_num; OCIInd the_raw; }; typedef struct many_types_ind many_types_ind; ＃万一</pre><p>请注意，即使在<code class="codeph">INTYPE</code>文件中仅列出了一个要翻译的项目，也会翻译两个对象类型和两个命名的集合类型。这是因为OTT参数<span class="q">“ <a href="the-Object-type.html#GUID-07AB8BBD-35A4-4BCA-B522-10BB7F9049E7">TRANSITIVE</a> ”</span>的默认值为TRUE。如该部分所述，当TRANSITIVE = TRUE时，OTT自动翻译用作被翻译类型属性的任何类型，以完成所列类型的翻译。
                           </p>
                           <p>对于仅由对象类型属性中的指针或REF访问的类型，情况并非如此。例如，尽管<span class="italic">many_types</span> <code class="codeph">type contains the attribute</code> <span class="italic">another_ref</span> <code class="codeph"> </code> <span class="italic">REF other_type</span> <code class="codeph">, a declaration of struct other_type</code>未生成<code class="codeph">, a declaration of struct other_type</code> 。
                           </p>
                           <p>此示例还说明了如何使用typedef声明VARRAY，NESTED TABLE和REF类型。</p>
                           <p>typedef出现在开头附近：</p><pre class="oac_no_warn" dir="ltr">typedef OCIRef many_types_ref; typedef OCIRef object_type_ref; typedef OCIArray my_varray; typedef OCITable my_table; typedef OCIRef other_type_ref;</pre><p></p>
                           <p>在struct <code class="codeph">many_types</code> ，声明了VARRAY，NESTED TABLE和REF属性：</p><pre class="oac_no_warn" dir="ltr">struct many_types {...other_type_ref * another_ref; many_types_ref * the_ref; my_varray * the_varray; my_table * the_table; ...}</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="LNPCC4457"></a><div class="props_rev_3"><a id="GUID-1E36744C-52EA-49D1-B05D-0E73C36436A4" name="GUID-1E36744C-52EA-49D1-B05D-0E73C36436A4"></a><h4 id="LNPCC-GUID-1E36744C-52EA-49D1-B05D-0E73C36436A4" class="sect4"><span class="enumeration_section">19.2.6</span> NULL指示符结构</h4>
                  <div>
                     <p>每当OTT生成一个C结构来表示数据库对象类型时，它也会生成相应的NULL指示符结构。当在C结构中选择对象类型时，可以将NULL指示符信息选择为并行结构。</p>
                     <p>例如，在上一节的示例中生成了以下NULL指示符结构：</p><pre class="oac_no_warn" dir="ltr">struct many_types_ind {OCIInd _atomic; OCIInd the_varchar; OCIInd the_char; OCIInd the_blob; OCIInd the_clob; struct object_type_ind the_object; OCIInd another_ref; OCIInd the_ref; OCIInd the_varray; OCIInd the_table; OCIInd the_date; OCIInd the_num; OCIInd the_raw; }; typedef struct many_types_ind many_types_ind;</pre><p>NULL结构的布局很重要。struct（ <code class="codeph">_atomic</code> ）中的第一个元素是<span class="italic">原子NULL指示符</span> 。此值指示整个对象类型的NULL状态。原子NULL指示符之后是对应于OTT生成的结构中表示对象类型的每个元素的指示符元素。
                     </p>
                     <p>请注意，当对象类型包含另一个对象类型作为其定义的一部分时（在前面的示例中，它是<span class="italic">object_type</span> <code class="codeph"> </code>属性），该属性的指示符条目是与嵌套对象类型对应的NULL指示符struct（ <code class="codeph">object_type_ind</code> ）。
                     </p>
                     <p>VARRAY和NESTED TABLE包含其元素的NULL信息。NULL指示符结构的所有其他元素的数据类型是<code class="codeph">OCIInd</code> 。</p>
                     <p>有关原子NULLness的更多信息，请参阅<a href="../lnoci/data-types.html#LNOCI-GUID-027FB2E2-593C-43F1-9184-DFEF7A984A27" target="_blank">数据类型</a>中对象类型的讨论。
                     </p>
                  </div>
               </div><a id="LNPCC4458"></a><div class="props_rev_3"><a id="GUID-A9A00891-FD32-4B0A-813A-4064DF43557B" name="GUID-A9A00891-FD32-4B0A-813A-4064DF43557B"></a><h4 id="LNPCC-GUID-A9A00891-FD32-4B0A-813A-4064DF43557B" class="sect4"><span class="enumeration_section">19.2.7</span>类型继承的OTT支持</h4>
                  <div>
                     <p>为了支持对象的类型继承，OTT通过在声明新属性之前使用特殊名称“_super”声明封装结构中的继承属性来生成表示对象子类型的C结构。因此，对于从超类型继承的对象子类型，结构中的第一个元素名为'_super'，后跟与子类型的每个属性对应的元素。名为'_super'的元素的类型是超类型的名称。</p>
                     <p>例如，给定类型<code class="codeph">Person_t</code> ，子类型为<code class="codeph">Student_t</code> ，子类型为<code class="codeph">Employee_t,</code>其创建方式如下：</p><pre class="oac_no_warn" dir="ltr">CREATE TYPE Person_t AS OBJECT（ssn NUMBER，name VARCHAR2（30），address VARCHAR2（100））NOT FINAL; CREATE TYPE Student_t UNDER Person_t（deptid NUMBER，major VARCHAR2（30））NOT FINAL; CREATE TYPE Employee_t UNDER Person_t（empid NUMBER，mgr VARCHAR2（30））;</pre><p>并且，给定一个<code class="codeph">INTYPE</code>文件，其中包括：</p><pre class="oac_no_warn" dir="ltr">案例=同一类型员工_T型学生_TTYPE PERSON_T</pre><p>OTT为<code class="codeph">Person_t</code> ， <code class="codeph">Student_t</code>和<code class="codeph">Employee_t</code>及其空指示符结构生成以下C结构：</p><pre class="oac_no_warn" dir="ltr">#ifndef MYFILENAME_ORACLE #define MYFILENAME_ORACLE #ifndef OCI_ORACLE #include &lt;oci.h&gt; #endif typedef OCIRef EMPLOYEE_T_ref; typedef OCIRef STUDENT_T_ref; typedef OCIRef PERSON_T_ref; struct PERSON_T {OCINumber SSN; OCIString * NAME; OCIString * ADDRESS; }; typedef struct PERSON_T PERSON_T; struct PERSON_T_ind {OCIInd _atomic; OCIInd SSN; OCIInd NAME; OCIInd ADDRESS; }; typedef struct PERSON_T_ind PERSON_T_ind; struct EMPLOYEE_T {PERSON_T _super; OCINumber EMPID; OCIString * MGR; }; typedef struct EMPLOYEE_T EMPLOYEE_T; struct EMPLOYEE_T_ind {PERSON_T _super; OCIInd EMPID; OCIInd MGR; }; typedef struct EMPLOYEE_T_ind EMPLOYEE_T_ind; struct STUDENT_T {PERSON_T _super; OCINumber DEPTID; OCIString * MAJOR; }; typedef struct STUDENT_T STUDENT_T; struct STUDENT_T_ind {PERSON_T _super; OCIInd DEPTID; OCIInd MAJOR; }; typedef struct STUDENT_T_ind STUDENT_T_ind; ＃万一</pre><p>较早的C映射约定允许从子类型的实例简单地向上转换为C中的超类型实例以正常工作。例如：</p><pre class="oac_no_warn" dir="ltr">STUDENT_T * stu_ptr = some_ptr; / *一些STUDENT_T实例* / PERSON_T * pers_ptr =（PERSON_T *）stu_ptr; / *上传* /</pre><p>null指示符结构类似地生成。请注意，对于超类型<code class="codeph">Person_t</code> null指示符结构，第一个元素是'_atomic'，而对于子类型<code class="codeph">Employee_t</code>和<code class="codeph">Student_t</code> null指示符结构，第一个元素是'_super'（没有为子类型生成原子元素）。
                     </p>
                  </div><a id="LNPCC4459"></a><div class="props_rev_3"><a id="GUID-C4A17F01-6EF7-4333-958C-3C1B36BDFBD2" name="GUID-C4A17F01-6EF7-4333-958C-3C1B36BDFBD2"></a><h5 id="LNPCC-GUID-C4A17F01-6EF7-4333-958C-3C1B36BDFBD2" class="sect5"><span class="enumeration_section">19.2.7.1可</span>替换对象属性</h5>
                     <div>
                        <p>对于NOT FINAL类型的属性（因此可能是可替换的），嵌入的属性表示为指针。</p>
                        <p>考虑创建的类型<code class="codeph">Book_t</code> ：</p><pre class="oac_no_warn" dir="ltr">CREATE TYPE Book_t AS OBJECT（标题VARCHAR2（30），作者Person_t / * substitutable * /）;</pre><p>OTT生成的相应C结构包含指向<code class="codeph">Person_t</code>的指针：</p><pre class="oac_no_warn" dir="ltr">struct Book_t {OCIString * title; Person_t *作者; / *指向Person_t struct * /}的指针</pre><p>与早期类型对应的空指示符结构是：</p><pre class="oac_no_warn" dir="ltr">struct Book_t_ind {OCIInd _atomic; OCIInd头衔; OCIInd作者; }</pre><p>请注意，可以从<code class="codeph">author</code>对象本身获取与<code class="codeph">author</code>属性对应的null指示符结构。
                        </p>
                        <p>如果将类型定义为FINAL，则它不能具有任何子类型。因此，FINAL类型的属性不可替代。在这种情况下，映射与以前一样：属性struct是内联的。现在，如果类型被更改并定义为NOT FINAL，则映射必须更改。通过再次运行OTT生成新映射。</p>
                     </div>
                     <div>
                        <div class="relinfo">
                           <p><strong>相关话题</strong></p>
                           <ul>
                              <li><a href="about-Objects.html#GUID-C8E8F151-455E-45FD-AA11-68DD84D6B411">对象获取</a></li>
                           </ul>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="LNPCC4460"></a><div class="props_rev_3"><a id="GUID-5227CAB0-3505-453B-9075-B0ED867C3B49" name="GUID-5227CAB0-3505-453B-9075-B0ED867C3B49"></a><h4 id="LNPCC-GUID-5227CAB0-3505-453B-9075-B0ED867C3B49" class="sect4"><span class="enumeration_section">19.2.8</span>的OUTTYPE文件</h4>
                  <div>
                     <p><code class="codeph">OUTTYPE</code>文件在OTT命令行上命名。当OTT生成C头文件时，它还会将转换结果写入<code class="codeph">OUTTYPE</code>文件。此文件包含每个要转换的类型的条目，包括其版本字符串以及写入其C表示的头文件。
                     </p>
                     <p>所述<code class="codeph">OUTTYPE</code>从一个OTT运行文件可以被用作<code class="codeph">INTYPE</code>用于后续调用OTT文件。
                     </p>
                     <p>例如，给定本章前面使用的简单<code class="codeph">INTYPE</code>文件</p><pre class="oac_no_warn" dir="ltr">CASE = LOWER TYPE员工TRANSLATE SALARY $ AS薪水DEPTNO AS部门类型地址类型项目类型人员类型PURCHASE_ORDER作为p_o</pre><p>用户已选择为OTT生成的C标识符指定大小写，并提供了应翻译的类型列表。在其中两种类型中，指定了命名约定。</p>
                     <p>以下示例显示运行OTT后<code class="codeph">OUTTYPE</code>文件的外观：</p><pre class="oac_no_warn" dir="ltr">CASE = LOWER TYPE EMPLOYEE AS员工VERSION =“$ 8.0”HFILE = demo.h TRANSLATE SALARY $ AS薪水DEPTNO AS部门类型地址作为地址VERSION =“$ 8.0”HFILE = demo.h类型项目为VERSION =“$ 8.0”HFILE = demo.h TYPE“Person”AS Person VERSION =“$ 8.0”HFILE = demo.h TYPE PURCHASE_ORDER as p_o VERSION =“$ 8.0”HFILE = demo.h</pre><p>检查<code class="codeph">OUTTYPE</code>文件的内容时，您可能会发现列出的类型未包含在<code class="codeph">INTYPE</code>规范中。例如，如果<code class="codeph">INTYPE</code>文件仅指定要翻译的<span class="italic">人员</span>类型：</p><pre class="oac_no_warn" dir="ltr">案例=较低级别的人</pre><p>并且person类型的定义包括<span class="italic">address</span>类型的属性，然后<code class="codeph">OUTTYPE</code>文件将包含<code class="codeph">PERSON</code>和<code class="codeph">ADDRESS</code>条目。如果没有首先翻译<span class="italic">地址，</span>则无法完全翻译<code class="codeph">person</code>类型。
                     </p>
                     <p>当参数TRANSITIVE设置为TRUE（默认值）时，OTT会在执行转换之前分析<code class="codeph">INTYPE</code>文件中的类型依赖关系，并根据需要转换其他类型。
                     </p>
                  </div>
               </div>
            </div><a id="LNPCC4462"></a><a id="LNPCC4461"></a><div class="props_rev_3"><a id="GUID-8A7E3E30-3339-498F-91D0-F4E60C5544C3" name="GUID-8A7E3E30-3339-498F-91D0-F4E60C5544C3"></a><h3 id="LNPCC-GUID-8A7E3E30-3339-498F-91D0-F4E60C5544C3" class="sect3"><span class="enumeration_section">19.3</span>使用OCI应用程序进行OTT</h3>
               <div>
                  <div class="section">
                     <p>由OTT生成的C头和实现文件可以由访问数据库服务器中的对象的OCI应用程序使用。使用<code class="codeph">#include</code>语句将头文件合并到OCI代码中。
                     </p>
                     <p>一旦包含头文件，OCI应用程序就可以访问和操作主机语言格式的对象数据。</p>
                     <p><a href="the-Object-type.html#GUID-8A7E3E30-3339-498F-91D0-F4E60C5544C3__I440389">图19-1</a>显示了使用OTT和OCI所涉及的步骤。</p>
                  </div>
                  <!-- class="section" -->
                  <ol>
                     <li><span>SQL用于在数据库中创建类型定义。</span></li>
                     <li><span>OTT生成一个头文件，其中包含对象类型和命名集合类型的C表示。它还生成一个实现文件，以<code class="codeph">INITFILE</code>选项命名。</span></li>
                     <li><span>该应用程序是写的。OCI应用程序中用户编写的代码声明并调用<code class="codeph">INITFUNC</code>函数。</span></li>
                     <li><span>头文件包含在OCI源代码文件中。</span></li>
                     <li><span>OCI应用程序（包括OTT生成的实现文件）被编译并与OCI库链接。</span></li>
                     <li><span>OCI可执行文件是针对Oracle Server运行的。</span></li>
                  </ol>
                  <div class="section">
                     <div class="figure" id="GUID-8A7E3E30-3339-498F-91D0-F4E60C5544C3__I440389">
                        <p class="titleinfigure">图19-1使用OTT和OCI</p><img src="img/lnpcc072.gif" width="499" alt="下面是图19-1的描述" title="下面是图19-1的描述" longdesc="img_text/lnpcc072.html"><br><a href="img_text/lnpcc072.html">“图19-1使用OTT和OCI”的描述</a></div>
                     <!-- class="figure" -->
                  </div>
                  <!-- class="section" -->
               </div><a id="LNPCC4463"></a><div class="props_rev_3"><a id="GUID-AFBAC4B3-B6F2-40C6-829A-02ECD71C9782" name="GUID-AFBAC4B3-B6F2-40C6-829A-02ECD71C9782"></a><h4 id="LNPCC-GUID-AFBAC4B3-B6F2-40C6-829A-02ECD71C9782" class="sect4"><span class="enumeration_section">19.3.1</span>关于使用OCI访问和操作对象</h4>
                  <div>
                     <p>在应用程序中，OCI程序可以使用声明为OTT生成的头文件中出现的类型的程序变量来执行绑定和定义操作。</p>
                     <p>例如，应用程序可能使用SQL SELECT语句将REF提取到对象，然后使用适当的OCI函数固定该对象。固定对象后，可以使用其他OCI功能访问和操作其属性数据。</p>
                     <p>OCI包括一组数据类型映射和操作函数，专门用于处理对象类型和命名集合类型的属性。</p>
                     <p>一些可用的功能如下：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">OCIStringSize()</code>获取<code class="codeph">OCIString</code>字符串的大小。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">OCINumberAdd()</code>将两个<code class="codeph">OCINumber</code>编号一起添加。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">OCILobIsEqual()</code>比较两个LOB定位器是否相等。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">OCIRawPtr()</code>获取指向<code class="codeph">OCIRaw</code>原始数据类型的指针。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">OCICollAppend()</code>将一个元素追加到集合类型（ <code class="codeph">OCIArray</code>或<code class="codeph">OCITable</code> ）。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">OCITableFirst()</code>返回嵌套表（ <code class="codeph">OCITable</code> ）的第一个现有元素的索引。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">OCIRefIsNull()</code>测试REF（ <code class="codeph">OCIRef)</code>是否为NULL</p>
                        </li>
                     </ul>
                     <p><a href="../lnoci/index.html" target="_blank"><span class="italic">Oracle Call Interface Programmer's Guide</span></a>的以下章节将详细介绍这些函数：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>第2章，涵盖OCI概念，包括绑定和定义</p>
                        </li>
                        <li>
                           <p>第6章，介绍对象访问和导航</p>
                        </li>
                        <li>
                           <p>第7章，其中介绍了数据类型映射和操作</p>
                        </li>
                        <li>
                           <p>第12章，列出了数据类型映射和操作函数</p>
                        </li>
                     </ul>
                  </div>
               </div><a id="LNPCC4464"></a><div class="props_rev_3"><a id="GUID-EF2F2C50-A944-438A-904A-907DBF9D8C22" name="GUID-EF2F2C50-A944-438A-904A-907DBF9D8C22"></a><h4 id="LNPCC-GUID-EF2F2C50-A944-438A-904A-907DBF9D8C22" class="sect4"><span class="enumeration_section">19.3.2</span>关于调用初始化函数</h4>
                  <div>
                     <p>如果请求，OTT会生成C初始化函数。初始化函数告诉环境，对于程序中使用的每个对象类型，使用哪种类型的类型。您可以在使用<code class="codeph">INITFUNC</code>选项调用OTT时指定初始化函数的名称，或者可以允许OTT根据包含该函数的实现文件（ <code class="codeph">INITFILE</code> ）的名称选择默认名称。
                     </p>
                     <p>初始化函数有两个参数，一个是环境句柄指针和一个错误句柄指针。通常只有一个初始化函数，但这不是必需的。如果程序有几个需要不同类型的单独编译的部分，您可能需要为每个部分单独执行OTT，每个部分需要一个包含初始化函数的初始化文件。</p>
                     <p>通过显式OCI对象调用创建环境句柄后，例如，通过调用<span class="bold"> </span> <code class="codeph">OCIEnvInit()</code> ，您还必须为每个环境句柄显式调用初始化函数。这使每个句柄都可以访问整个程序中使用的所有数据类型。
                     </p>
                     <p>如果使用嵌入式SQL语句（例如EXEC SQL CONTEXT USE和EXEC SQL CONNECT）隐式创建环境句柄，则会隐式初始化句柄，并且无需调用初始化函数。这与Pro * C / C ++应用程序或Pro * C / C ++与OCI应用程序组合时相关。</p>
                     <p>以下示例显示了初始化函数。</p>
                     <p>给定一个<code class="codeph">INTYPE</code>文件，ex2c.typ，包含</p><pre class="oac_no_warn" dir="ltr">TYPE SCOTT.PERSON TYPE SCOTT.ADDRESS</pre><p>和命令行</p><pre class="oac_no_warn" dir="ltr">ott userid = scott / tiger intype = ex2c outtype = ex2co hfile = ex2ch.h initfile = ex2cv.c</pre><p>OTT为ex2cv.c文件生成以下内容：</p><pre class="oac_no_warn" dir="ltr">#ifndef OCI_ORACLE #include &lt;oci.h&gt; #endif sword ex2cv（OCIEnv * env，OCIError * err）{sword status = OCITypeVTInit（env，err）; if（status == OCI_SUCCESS）status = OCITypeVTInsert（env，err，“SCOTT”，5，“PERSON”，6，“$ 8.0”，4）; if（status == OCI_SUCCESS）status = OCITypeVTInsert（env，err，“SCOTT”，5，“ADDRESS”，7，“$ 8.0”，4）;返回状态; }</pre><p>函数<span class="italic">ex2cv</span>创建类型版本表并插入类型SCOTT.PERSON和SCOTT.ADDRESS。</p>
                     <p>如果程序显式创建环境句柄，则必须生成，编译和链接所有初始化函数，因为必须为每个显式创建的句柄调用它们。如果程序未显式创建任何环境句柄，则不需要初始化函数。</p>
                     <p>使用OTT生成的头文件的程序还必须使用同时生成的初始化函数。更确切地说，如果由OTT生成的头文件包含在生成链接到程序P的代码的编译中，并且在程序P中的某处显式创建了环境句柄，则由相同的OTT调用生成的实现文件也必须是编译并链接到程序P.正确执行此操作是您的责任。</p>
                  </div>
               </div><a id="LNPCC4465"></a><div class="props_rev_3"><a id="GUID-C7686FA7-0258-403E-95CF-2D080F422D01" name="GUID-C7686FA7-0258-403E-95CF-2D080F422D01"></a><h4 id="LNPCC-GUID-C7686FA7-0258-403E-95CF-2D080F422D01" class="sect4"><span class="enumeration_section">19.3.3</span>初始化函数的任务</h4>
                  <div>
                     <p>C初始化函数提供有关OTT处理的类型的版本信息。它向类型版本表添加了每个OTT处理的对象数据类型的名称和版本标识符。</p>
                     <p>Open Type Manager（OTM）使用类型版本表来确定特定程序使用的类型的版本。OTT在不同时间生成的不同初始化函数可以向类型版本表添加一些相同的类型。当多次添加类型时，OTM确保每次都注册相同版本的类型。</p>
                     <p>OCI程序员有责任为初始化函数声明函数原型，并调用该函数。</p>
                     <div class="infoboxnote" id="GUID-C7686FA7-0258-403E-95CF-2D080F422D01__GUID-A1203C4B-892C-4960-B7BD-CD9FDA71077E">
                        <p class="notep1">注意：</p>
                        <p>在当前版本的Oracle中，每种类型只有一个版本。只有与Oracle的未来版本兼容，才需要初始化类型版本表。</p>
                     </div>
                  </div>
               </div>
            </div><a id="LNPCC4467"></a><a id="LNPCC4466"></a><div class="props_rev_3"><a id="GUID-FFFE16F3-943D-4848-9E63-B590EA2A8942" name="GUID-FFFE16F3-943D-4848-9E63-B590EA2A8942"></a><h3 id="LNPCC-GUID-FFFE16F3-943D-4848-9E63-B590EA2A8942" class="sect3"><span class="enumeration_section">19.4</span>关于在Pro * C / C ++应用程序中使用OTT</h3>
               <div>
                  <div class="section">
                     <p>在构建Pro * C / C ++应用程序时，类型转换过程可以比构建基于OCI的应用程序更简单。这是因为预编译器生成的代码将自动初始化类型版本表。</p>
                     <p>Pro * C / C ++应用程序可以使用OTT生成的AC头文件来访问数据库服务器中的对象。头文件通过<code class="codeph">#include</code>语句合并到代码中。一旦包含头文件，Pro * C / C ++应用程序就可以访问和操作主机语言格式的对象数据。
                     </p>
                     <p><a href="the-Object-type.html#GUID-FFFE16F3-943D-4848-9E63-B590EA2A8942__I440384">图19-2</a>显示了使用OTT和Pro * C / C ++所涉及的步骤。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <ol>
                        <li>
                           <p>SQL用于在数据库中创建类型定义。</p>
                        </li>
                        <li>
                           <p>OTT生成一个头文件，其中包含对象类型，REF类型和命名集合类型的C表示。它还会生成一个<code class="codeph">OUTTYPE</code>文件，该文件作为<code class="codeph">INTYPE</code>参数传递给Pro * C / C ++。
                           </p>
                        </li>
                        <li>
                           <p>头文件包含在Pro * C / C ++源代码文件中。</p>
                        </li>
                        <li>
                           <p>Pro * C / C ++应用程序已编译并与Pro * C / C ++运行时库SQLLIB链接。</p>
                        </li>
                        <li>
                           <p>Pro * C / C ++可执行文件是针对Oracle Server运行的。</p>
                        </li>
                     </ol>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <div class="figure" id="GUID-FFFE16F3-943D-4848-9E63-B590EA2A8942__I440384">
                        <p class="titleinfigure">图19-2构建面向对象的Pro * C / C ++应用程序</p><img src="img/lnpcc068.gif" width="499" alt="下面是图19-2的描述" title="下面是图19-2的描述" longdesc="img_text/lnpcc068.html"><br><a href="img_text/lnpcc068.html">“图19-2构建面向对象的Pro * C / C ++应用程序”的描述</a></div>
                     <!-- class="figure" -->
                     <p>如前面的步骤2中所述，OTT生成的<code class="codeph">OUTTYPE</code>文件为Pro * C / C ++程序员提供了特殊用途。调用Pro * C / C ++时，将<code class="codeph">OUTTYPE</code>文件传递给新的<code class="codeph">INTYPE</code>命令行参数。预编译器使用此文件的内容来确定哪些数据库类型对应于哪些OTT生成的结构。OCI程序员必须通过使用特殊的绑定，定义和类型信息访问功能来明确地建立这种关联。
                     </p>
                     <p>此外，预编译器生成代码以使用OTT <code class="codeph">OUTTYPE</code> （Pro * C / C ++ <code class="codeph">INTYPE</code> ）文件中指定的类型初始化类型版本表。
                     </p>
                     <div class="infoboxnote" id="GUID-FFFE16F3-943D-4848-9E63-B590EA2A8942__GUID-07C9E2E4-5399-448A-8C90-2AD05E48C398">
                        <p class="notep1">注意：</p>
                        <p>Oracle建议OTT中的<code class="codeph">OUTTYPE</code>文件始终作为Pro * C / C ++的<code class="codeph">INTYPE</code>文件。您可以为Pro * C / C ++编写<code class="codeph">INTYPE</code>文件，但由于可能会引入错误，因此不建议这样做。
                        </p>
                     </div>
                     <p>操纵从服务器检索的对象的属性的一种方法是调用OCI数据类型映射和操作函数。在执行此操作之前，应用程序必须首先调用<code class="codeph">SQLEnvGet()</code>以获取OCI环境句柄以传递给OCI函数，并且<code class="codeph">SQLSvcCtxGet()</code>以获取OCI服务上下文以传递给OCI函数。还有Pro * C工具可用于操作对象属性。
                     </p>
                  </div>
                  <!-- class="section" -->
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="about-Objects.html#GUID-0C106FBC-C023-4B86-817A-1867A69388F7">对象</a></li>
                        <li><a href="the-Object-type.html#GUID-AFBAC4B3-B6F2-40C6-829A-02ECD71C9782">关于使用OCI访问和操作对象</a></li>
                        <li><a href="../lnoci/data-types.html#LNOCI030" target="_blank">https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/lnpcc&amp;id=LNOCI030</a></li>
                     </ul>
                  </div>
               </div>
            </div><a id="LNPCC4468"></a><div class="props_rev_3"><a id="GUID-8E754758-8639-47E4-A8C5-2251C41A3BB0" name="GUID-8E754758-8639-47E4-A8C5-2251C41A3BB0"></a><h3 id="LNPCC-GUID-8E754758-8639-47E4-A8C5-2251C41A3BB0" class="sect3"><span class="enumeration_section">19.5</span> OTT参考</h3>
               <div>
                  <p>OTT的行为由可以出现在OTT命令行或CONFIG文件中的参数控制。某些参数也可能出现在<code class="codeph">INTYPE</code>文件中。本节提供有关以下主题的详细信息：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="the-Object-type.html#GUID-4E52BADE-8D12-4DE6-A8C2-332EE1E09002">OTT命令行语法</a></p>
                     </li>
                     <li>
                        <p><a href="the-Object-type.html#GUID-FEE40170-97EE-4B3D-96DF-1FCF4246ABE4">OTT参数</a></p>
                     </li>
                     <li>
                        <p><a href="the-Object-type.html#GUID-104B9584-F2A9-405A-9E29-7C945219CF46">OTT参数可以出现的地方</a></p>
                     </li>
                     <li>
                        <p><a href="the-Object-type.html#GUID-D114064D-E05F-42DD-9DB9-EAEEE5A9619B">INTYPE文件的结构</a></p>
                     </li>
                     <li>
                        <p><a href="the-Object-type.html#GUID-585A7EBC-989C-4A19-8884-9CFCB303D04A">嵌套#include文件生成</a></p>
                     </li>
                     <li>
                        <p><a href="the-Object-type.html#GUID-E21D4C5F-FB6D-4573-9703-3D2B5863382E">SCHEMA_NAMES用法</a></p>
                     </li>
                     <li>
                        <p><a href="the-Object-type.html#GUID-825D5648-2443-490D-90F0-C5748F915A29">默认名称映射</a></p>
                     </li>
                     <li>
                        <p><a href="the-Object-type.html#GUID-C1EB0F45-A82F-4555-9662-B5A1F821E212">限制</a></p>
                     </li>
                  </ul>
                  <p>本章使用以下约定来描述OTT语法：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>斜体字符串由用户提供。</p>
                     </li>
                     <li>
                        <p>如图所示输入大写字符串，但大小写不重要。</p>
                     </li>
                     <li>
                        <p>方括号[...]包含可选项。</p>
                     </li>
                     <li>
                        <p>紧跟在项目之后的省略号（...）（或括在括号中的项目）意味着该项目可以重复任意次。</p>
                     </li>
                     <li>
                        <p>如图所示输入除前面描述的标点符号之外的标点符号。这些包括'。'，'@'等。</p>
                     </li>
                  </ul>
               </div><a id="LNPCC4469"></a><div class="props_rev_3"><a id="GUID-4E52BADE-8D12-4DE6-A8C2-332EE1E09002" name="GUID-4E52BADE-8D12-4DE6-A8C2-332EE1E09002"></a><h4 id="LNPCC-GUID-4E52BADE-8D12-4DE6-A8C2-332EE1E09002" class="sect4"><span class="enumeration_section">19.5.1</span> OTT命令行语法</h4>
                  <div>
                     <div class="section">
                        <p>在显式调用OTT以将数据库类型转换为C结构时，将使用OTT命令行界面。在开发使用对象的OCI应用程序或Pro * C / C ++应用程序时，始终需要这样做。</p>
                        <p>OTT命令行语句由关键字<code class="codeph">OTT</code> ，后跟OTT参数列表。
                        </p>
                        <p>可以出现在OTT命令行语句中的参数如下：</p><pre class="oac_no_warn" dir="ltr">[USERID = <span class="italic">用户名</span> / <span class="italic">密码</span> [@ <span class="italic">DB_NAME]]</span> [法菜单= <span class="italic">in_filename]</span> OUTTYPE = <span class="italic">out_filename</span> CODE = {C | ANSI_C | KR_C} [HFILE = <span class="italic">文件名</span> ] [ERRTYPE = <span class="italic">文件名</span> ] [CONFIG = <span class="italic">文件名</span> ] [INITFILE = <span class="italic">文件名</span> ] [INITFUNC = <span class="italic">filename</span> ] [CASE = {SAME | LOWER | UPPER | OPPOSITE}] [SCHEMA_NAMES = {ALWAYS | IF_NEEDED | FROM_INTYPE}] [TRANSITIVE = TRUE | FALSE]</pre><div class="infoboxnote" id="GUID-4E52BADE-8D12-4DE6-A8C2-332EE1E09002__GUID-A592FFFC-B2B9-45E1-A2A4-C13FD57D90BC">
                           <p class="notep1">注意：</p>
                           <p>通常，OTT命令后面的参数顺序无关紧要，只需要<code class="codeph">OUTTYPE</code>和<code class="codeph">CODE</code>参数。
                           </p>
                        </div>
                        <p>几乎总是使用<code class="codeph">HFILE</code>参数。如果省略， <code class="codeph">HFILE</code>必须为<code class="codeph">INTYPE</code>文件中的每种类型单独指定<code class="codeph">INTYPE</code> 。如果OTT确定必须翻译<code class="codeph">INTYPE</code>文件中未列出的类型，则将报告错误。因此，仅当<code class="codeph">INTYPE</code>文件先前作为OTT <code class="codeph">OUTTYPE</code>文件生成时，才能安全地省略<code class="codeph">HFILE</code>参数。
                        </p>
                        <p>如果省略<code class="codeph">INTYPE</code>文件，则将翻译整个模式。有关详细信息，请参阅以下部分中的参数说明。
                        </p>
                        <p>以下是OTT命令行语句的示例（将其作为一行输入）：</p><pre class="oac_no_warn" dir="ltr">OTT userid = scott / tiger intype = in.typ outtype = out.typ code = c hfile = demo.h errtype = demo.tls case = lower</pre><p>以下各节介绍了每个OTT命令行参数。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCC4470"></a><div class="props_rev_3"><a id="GUID-FEE40170-97EE-4B3D-96DF-1FCF4246ABE4" name="GUID-FEE40170-97EE-4B3D-96DF-1FCF4246ABE4"></a><h4 id="LNPCC-GUID-FEE40170-97EE-4B3D-96DF-1FCF4246ABE4" class="sect4"><span class="enumeration_section">19.5.2</span> OTT参数</h4>
                  <div>
                     <p>使用以下格式在OTT命令行上输入参数：</p>
                     <p><span class="italic">参数</span> = <span class="italic">值</span></p>
                     <p>其中<span class="italic">parameter</span>是文字参数字符串， <span class="italic">value</span>是有效参数设置。文字参数字符串不区分大小写。
                     </p>
                     <p>使用空格或制表符分隔命令行参数。</p>
                     <p>参数也可以出现在配置文件中，但在这种情况下，行内不允许有空格，并且每个参数必须出现在单独的行中。此外，参数<code class="codeph">CASE</code> ， <code class="codeph">HFILE</code> ， <code class="codeph">INITFUNC</code>和<code class="codeph">INITFILE</code>可以出现在<code class="codeph">INTYPE</code>文件中。
                     </p>
                  </div><a id="LNPCC4471"></a><div class="props_rev_3"><a id="GUID-75725874-9343-4420-A00C-C5D8A380186B" name="GUID-75725874-9343-4420-A00C-C5D8A380186B"></a><h5 id="LNPCC-GUID-75725874-9343-4420-A00C-C5D8A380186B" class="sect5"><span class="enumeration_section">19.5.2.1</span> USERID</h5>
                     <div>
                        <div class="section">
                           <p>USERID参数指定Oracle用户名，密码和可选数据库名称（Oracle Net数据库规范字符串）。如果省略数据库名称，则假定使用缺省数据库。该参数的语法是：</p><pre class="oac_no_warn" dir="ltr">USERID = <span class="italic">用户名</span> / <span class="italic">密码</span> [ <span class="italic">@db_name</span> ]</pre><p></p>
                           <p>如果这是第一个参数，则可以省略“USERID =”，如下所示：</p><pre class="oac_no_warn" dir="ltr">OTT <span class="italic">用户名</span> / <span class="italic">密码......</span></pre><p></p>
                           <p>USERID参数是可选的。如果省略它，OTT会自动尝试以用户CLUSTER $ <span class="italic">username</span>连接到默认数据库，其中<span class="italic">username</span>是用户的操作系统用户名。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNPCC4472"></a><div class="props_rev_3"><a id="GUID-2EEAF760-9921-4308-9417-32E1AAB618F8" name="GUID-2EEAF760-9921-4308-9417-32E1AAB618F8"></a><h5 id="LNPCC-GUID-2EEAF760-9921-4308-9417-32E1AAB618F8" class="sect5"><span class="enumeration_section">19.5.2.2</span> INTYPE</h5>
                     <div>
                        <div class="section">
                           <p><code class="codeph">INTYPE</code>参数指定从中读取对象类型规范列表的文件的名称。OTT翻译列表中的每种类型。此参数的语法是</p><pre class="oac_no_warn" dir="ltr">INTYPE = <span class="italic">文件名</span></pre><p></p>
                           <p>如果USERID和<code class="codeph">INTYPE</code>是前两个参数，则可以省略“ <code class="codeph">INTYPE=</code> ”，并且省略“USERID =”。如果未指定<code class="codeph">INTYPE</code> ，则将翻译用户架构中的所有类型。
                           </p><pre class="oac_no_warn" dir="ltr">OTT <span class="italic">用户名</span> / <span class="italic">密码文件名...</span></pre><p></p>
                           <p><code class="codeph">INTYPE</code>文件可以被认为是类型声明的makefile。它列出了需要C struct声明的类型。
                           </p>
                           <p>如果命令行或<code class="codeph">INTYPE</code>文件中的文件名不包含扩展名，则将添加特定于平台的扩展名，例如“TYP”或“typ”。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="relinfo">
                           <p><strong>相关话题</strong></p>
                           <ul>
                              <li><a href="the-Object-type.html#GUID-D114064D-E05F-42DD-9DB9-EAEEE5A9619B">INTYPE文件的结构</a></li>
                           </ul>
                        </div>
                     </div>
                     
                  </div><a id="LNPCC4473"></a><div class="props_rev_3"><a id="GUID-EB8AEECA-6163-434D-82E2-A700294F3DD6" name="GUID-EB8AEECA-6163-434D-82E2-A700294F3DD6"></a><h5 id="LNPCC-GUID-EB8AEECA-6163-434D-82E2-A700294F3DD6" class="sect5"><span class="enumeration_section">19.5.2.3</span> OUTTYPE</h5>
                     <div>
                        <div class="section">
                           <p>OTT将为其处理的所有对象数据类型写入类型信息的文件的名称。这包括在<code class="codeph">INTYPE</code>文件中显式命名的所有类型，并且可能包括已转换的其他类型（如果TRANSITIVE = TRUE），因为它们用于需要转换的其他类型的声明中。在将来调用OTT时，此文件可用作<code class="codeph">INTYPE</code>文件。</p><pre class="oac_no_warn" dir="ltr">OUTTYPE = <span class="italic">文件名</span></pre><p></p>
                           <p>如果<code class="codeph">INTYPE</code>和<code class="codeph">OUTTYPE</code>参数引用同一文件，则新的<code class="codeph">INTYPE</code>信息将替换<code class="codeph">INTYPE</code>文件中的旧信息。这为在更改类型，生成类型声明，编辑源代码，预编译，编译和调试的循环中重复使用相同的<code class="codeph">INTYPE</code>文件提供了一种便捷的方法。
                           </p>
                           <p>必须指定<code class="codeph">OUTTYPE</code> 。
                           </p>
                           <p>如果命令行或<code class="codeph">INTYPE</code>文件中的文件名不包含扩展名，则将添加特定于平台的扩展名，例如“TYP”或“typ”。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNPCC4474"></a><div class="props_rev_3"><a id="GUID-2578968D-3BEC-45D7-A67A-7C874F4C880D" name="GUID-2578968D-3BEC-45D7-A67A-7C874F4C880D"></a><h5 id="LNPCC-GUID-2578968D-3BEC-45D7-A67A-7C874F4C880D" class="sect5"><span class="enumeration_section">19.5.2.4</span>代码</h5>
                     <div>
                        <div class="section"><pre class="oac_no_warn" dir="ltr">CODE = C | KR_C | ANSI_C</pre><p></p>
                           <p>这是OTT输出所需的主机语言，可以指定为<code class="codeph">CODE=C</code> ， <code class="codeph">CODE=KR_C</code>或<code class="codeph">CODE=ANSI_C</code> 。 “ <code class="codeph">CODE=C</code> ”相当于“ <code class="codeph">CODE=ANSI_C</code> ”。
                           </p>
                           <p>此参数没有默认值;必须提供。</p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNPCC4475"></a><div class="props_rev_3"><a id="GUID-F1D10F95-0D9B-4E13-8B7C-08062F52BA7E" name="GUID-F1D10F95-0D9B-4E13-8B7C-08062F52BA7E"></a><h5 id="LNPCC-GUID-F1D10F95-0D9B-4E13-8B7C-08062F52BA7E" class="sect5"><span class="enumeration_section">19.5.2.5</span> INITFILE</h5>
                     <div>
                        <div class="section">
                           <p><code class="codeph">INITFILE</code>参数指定要写入OTT生成的初始化文件的文件的名称。如果省略此参数，OTT不会生成初始化函数。
                           </p>
                           <p>对于Pro * C / C ++程序， <code class="codeph">INITFILE</code>不是必需的，因为SQLLIB运行时库执行必要的初始化。OCI程序用户必须编译和链接<code class="codeph">INITFILE</code>文件，并且必须在创建环境句柄时调用初始化函数。
                           </p>
                           <p>如果一个的文件名<code class="codeph">INITFILE</code>在命令行上或在<code class="codeph">INTYPE</code>文件不包括扩展名，一个平台特定的扩展名，如“C”或“.c”的将被添加。
                           </p><pre class="oac_no_warn" dir="ltr">INITFILE = <span class="italic">文件名</span></pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNPCC4476"></a><div class="props_rev_3"><a id="GUID-ABEA2169-03BB-47AE-AC80-9F17D5964C53" name="GUID-ABEA2169-03BB-47AE-AC80-9F17D5964C53"></a><h5 id="LNPCC-GUID-ABEA2169-03BB-47AE-AC80-9F17D5964C53" class="sect5"><span class="enumeration_section">19.5.2.6</span> INITFUNC</h5>
                     <div>
                        <div class="section">
                           <p><code class="codeph">INITFUNC</code>参数仅用于OCI程序。它指定OTT生成的初始化函数的名称。如果省略此参数，则初始化函数的名称<code class="codeph">INITFILE</code>的名称<code class="codeph">INITFILE</code> 。</p><pre class="oac_no_warn" dir="ltr">INITFUNC = <span class="italic">文件名</span></pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNPCC4477"></a><div class="props_rev_3"><a id="GUID-5AFEC55F-6040-4BBC-80A0-1E48CD78C5E2" name="GUID-5AFEC55F-6040-4BBC-80A0-1E48CD78C5E2"></a><h5 id="LNPCC-GUID-5AFEC55F-6040-4BBC-80A0-1E48CD78C5E2" class="sect5"><span class="enumeration_section">19.5.2.7</span> HFILE</h5>
                     <div>
                        <div class="section">
                           <p>OTT为<code class="codeph">INTYPE</code>文件中提到但未在其中指定包含文件的类型声明生成的include（.h）文件的名称。除非在<code class="codeph">INTYPE</code>文件中单独指定每种类型的包含文件，否则此参数是必需的。如果必须生成<code class="codeph">INTYPE</code>文件中未提及的类型，因为其他类型需要它（如果TRANSITIVE = TRUE），并且这些其他类型在两个或多个不同的文件中声明，则也需要此参数。
                           </p>
                           <p>如果一个的文件名<code class="codeph">HFILE</code>在命令行上或在<code class="codeph">INTYPE</code>文件不包括扩展名，一个平台特定的扩展名，如“H”或“·H”将被添加。
                           </p><pre class="oac_no_warn" dir="ltr">HFILE = <span class="italic">文件名</span></pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNPCC4478"></a><div class="props_rev_3"><a id="GUID-C78C0E91-B984-4F93-9396-B84EEE350438" name="GUID-C78C0E91-B984-4F93-9396-B84EEE350438"></a><h5 id="LNPCC-GUID-C78C0E91-B984-4F93-9396-B84EEE350438" class="sect5"><span class="enumeration_section">19.5.2.8</span>配置</h5>
                     <div>
                        <div class="section">
                           <p>CONFIG参数指定OTT配置文件的名称，该文件列出了常用的参数规范。还从平台相关位置的系统配置文件中读取参数规范。所有剩余的参数规范必须出现在命令行或<code class="codeph">INTYPE</code>文件中。
                           </p><pre class="oac_no_warn" dir="ltr">CONFIG = <span class="italic">文件名</span> </pre><p></p>
                           <p><span class="bold">注意</span> ：CONFIG文件中不允许使用CONFIG参数。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNPCC4479"></a><div class="props_rev_3"><a id="GUID-A81E2A5A-F5A5-47FB-A866-C89E1AE39D12" name="GUID-A81E2A5A-F5A5-47FB-A866-C89E1AE39D12"></a><h5 id="LNPCC-GUID-A81E2A5A-F5A5-47FB-A866-C89E1AE39D12" class="sect5"><span class="enumeration_section">19.5.2.9</span> ERRTYPE</h5>
                     <div>
                        <div class="section">
                           <p>如果提供此参数， <code class="codeph">INTYPE</code>将<code class="codeph">INTYPE</code>文件的列表以及所有信息和错误消息写入ERRTYPE文件。无论是否指定了ERRTYPE，都会将信息和错误消息发送到标准输出。
                           </p>
                           <p>从本质上讲，ERRTYPE文件是复印件<code class="codeph">INTYPE</code>添加了错误信息的文件。在大多数情况下，错误消息将包含指向导致错误的文本的指针。
                           </p>
                           <p>如果命令行或<code class="codeph">INTYPE</code>文件中的<code class="codeph">INTYPE</code>文件名不包含扩展名，则将添加特定于平台的扩展名，例如“TLS”或“tls”。
                           </p><pre class="oac_no_warn" dir="ltr">ERRTYPE = <span class="italic">文件名</span></pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNPCC4480"></a><div class="props_rev_3"><a id="GUID-2910B3D2-50E0-4E3F-93B4-A20ED287CCE9" name="GUID-2910B3D2-50E0-4E3F-93B4-A20ED287CCE9"></a><h5 id="LNPCC-GUID-2910B3D2-50E0-4E3F-93B4-A20ED287CCE9" class="sect5"><span class="enumeration_section">19.5.2.10</span>案例</h5>
                     <div>
                        <div class="section">
                           <p>此参数影响OTT生成的某些C标识符的大小写。 <code class="codeph">CASE</code>的可能值是<code class="codeph">SAME</code> ， <code class="codeph">LOWER</code> ， <code class="codeph">UPPER</code>和<code class="codeph">OPPOSITE</code> 。如果<code class="codeph">CASE = SAME</code> ，则在将数据库类型和属性名称转换为C标识符时，不会更改字母大小写。如果<code class="codeph">CASE=LOWER</code> ，则所有大写字母都将转换为小写。如果<code class="codeph">CASE=UPPER</code> ，则所有小写字母都将转换为大写。如果<code class="codeph">CASE=OPPOSITE</code> ，则所有大写字母都将转换为小写字母，反之亦然。
                           </p><pre class="oac_no_warn" dir="ltr">CASE = [SAME | LOWER | UPPER | OPPOSITE]</pre><p></p>
                           <p>此参数仅影响<code class="codeph">INTYPE</code>文件中未提及的那些标识符（未明确列出的属性或类型）。在生成合法标识符之后进行大小写转换。
                           </p>
                           <div class="infoboxnote" id="GUID-2910B3D2-50E0-4E3F-93B4-A20ED287CCE9__GUID-4B6A137A-AB5C-4CF7-BBAE-44EB7751CA25">
                              <p class="notep1">注意：</p>
                              <p><code class="codeph">INTYPE</code>特别提到的类型的C结构标识符的情况与<code class="codeph">INTYPE</code>文件中的情况相同。例如，如果<code class="codeph">INTYPE</code>文件包含以下行</p>
                           </div><pre class="oac_no_warn" dir="ltr">TYPE工人</pre><p>然后OTT将生成</p><pre class="oac_no_warn" dir="ltr">struct Worker {...};</pre><p>另一方面，如果<code class="codeph">INTYPE</code>文件被写为</p><pre class="oac_no_warn" dir="ltr">类型wOrKeR</pre><p>OTT会产生</p><pre class="oac_no_warn" dir="ltr">struct wOrKeR {...};</pre><p>遵循<code class="codeph">INTYPE</code>文件的情况。
                           </p>
                           <p>如果<code class="codeph">CASE=SAME</code> ， <code class="codeph">INTYPE</code>文件中未提及的不区分大小写的SQL标识符将以大写形式显示，如果<code class="codeph">CASE=OPPOSITE</code> ， <code class="codeph">INTYPE</code>显示。如果SQL标识符在声明时未引用，则该标识符不区分大小写。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNPCC4481"></a><div class="props_rev_3"><a id="GUID-4569FAD8-2629-46DD-BC96-86D32AF0F27C" name="GUID-4569FAD8-2629-46DD-BC96-86D32AF0F27C"></a><h5 id="LNPCC-GUID-4569FAD8-2629-46DD-BC96-86D32AF0F27C" class="sect5"><span class="enumeration_section">19.5.2.11</span> SCHEMA_NAMES</h5>
                     <div>
                        <div class="section">
                           <p>此参数提供控制，以使用<code class="codeph">OUTTYPE</code>文件中的模式名称从默认模式限定类型的数据库名称。OTT生成的<code class="codeph">OUTTYPE</code>文件包含有关OTT处理的类型的信息，包括类型名称。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="relinfo">
                           <p><strong>相关话题</strong></p>
                           <ul>
                              <li><a href="the-Object-type.html#GUID-E21D4C5F-FB6D-4573-9703-3D2B5863382E">SCHEMA_NAMES用法</a></li>
                           </ul>
                        </div>
                     </div>
                     
                  </div><a id="LNPCC4482"></a><div class="props_rev_3"><a id="GUID-07AB8BBD-35A4-4BCA-B522-10BB7F9049E7" name="GUID-07AB8BBD-35A4-4BCA-B522-10BB7F9049E7"></a><h5 id="LNPCC-GUID-07AB8BBD-35A4-4BCA-B522-10BB7F9049E7" class="sect5"><span class="enumeration_section">19.5.2.12传统</span></h5>
                     <div>
                        <div class="section">
                           <p>取值为TRUE（默认值）或FALSE。指示是否要转换<code class="codeph">INTYPE</code>文件中未明确列出的类型依赖项。如果指定传递性= FALSE时，则在<span class="italic">未</span>提及类型<code class="codeph">INTYPE</code>文件不生成。即使它们被用作其他生成类型的属性类型，也是如此。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="LNPCC4483"></a><div class="props_rev_3"><a id="GUID-104B9584-F2A9-405A-9E29-7C945219CF46" name="GUID-104B9584-F2A9-405A-9E29-7C945219CF46"></a><h4 id="LNPCC-GUID-104B9584-F2A9-405A-9E29-7C945219CF46" class="sect4"><span class="enumeration_section">19.5.3</span>可以出现OTT参数的地方</h4>
                  <div>
                     <p>在命令行，命令行上指定的CONFIG文件或两者中提供OTT参数。<code class="codeph">INTYPE</code>文件中也允许使用某些参数。
                     </p>
                     <p>OTT的调用如下：</p>
                     <p>OTT <span class="italic">用户名/密码</span>参数</p>
                     <p>如果命令行中的一个参数是</p>
                     <p>CONFIG = <span class="italic">文件名</span></p>
                     <p>从名为<span class="italic">filename</span>的配置文件中读取其他参数。
                     </p>
                     <p>此外，还从平台相关位置的默认配置文件中读取参数。此文件必须存在，但可以为空。配置中的每一行可能包含一个参数，行上没有空格。</p>
                     <p>如果在没有任何参数的情况下执行OTT，则会显示在线参数引用。</p>
                     <p>要转换的OTT的类型在<code class="codeph">INTYPE</code>参数指定的文件中命名。参数<code class="codeph">CASE</code> ， <code class="codeph">INITFILE</code> ， <code class="codeph">INITFUNC</code>和<code class="codeph">HFILE</code>也可能出现在<code class="codeph">INTYPE</code>文件中。OTT生成的<code class="codeph">OUTTYPE</code>文件包括<code class="codeph">CASE</code>参数，如果生成了初始化文件，则包括<code class="codeph">INITFILE</code>和<code class="codeph">INITFUNC</code>参数。<code class="codeph">OUTTYPE</code>文件为每种类型单独指定<code class="codeph">HFILE</code> 。
                     </p>
                     <p>OTT命令的情况与平台有关。</p>
                  </div>
               </div><a id="LNPCC4484"></a><div class="props_rev_3"><a id="GUID-D114064D-E05F-42DD-9DB9-EAEEE5A9619B" name="GUID-D114064D-E05F-42DD-9DB9-EAEEE5A9619B"></a><h4 id="LNPCC-GUID-D114064D-E05F-42DD-9DB9-EAEEE5A9619B" class="sect4"><span class="enumeration_section">19.5.4</span> INTYPE文件的结构</h4>
                  <div>
                     <p><code class="codeph">INTYPE</code>和<code class="codeph">OUTTYPE</code>文件<a id="d101336e3308" class="indexterm-anchor"></a><a id="d101336e3310" class="indexterm-anchor"></a><a id="d101336e3312" class="indexterm-anchor"></a>列出OTT翻译的类型，并提供确定如何将类型或属性名称转换为合法C标识符所需的所有信息。这些文件包含一个或多个类型规范。这些文件还可能包含以下选项的规范：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">案件</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">HFILE</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">INITFILE</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">INITFUNC</code></p>
                        </li>
                     </ul>
                     <p>如果存在<code class="codeph">CASE</code> ， <code class="codeph">INITFILE</code>或<code class="codeph">INITFUNC</code>选项，则它们必须位于任何类型规范之前。如果这些选项同时出现在命令行和<code class="codeph">INTYPE</code>文件中，则使用命令行上的值。
                     </p>
                     <p>有关简单的用户定义的<code class="codeph">INTYPE</code>文件以及OTT从中生成的完整<code class="codeph">OUTTYPE</code>文件的<code class="codeph">OUTTYPE</code> ，请参阅<span class="q">“ <a href="the-Object-type.html#GUID-A9A00891-FD32-4B0A-813A-4064DF43557B">类型继承的OTT支持</a> ”</span> 。
                     </p>
                  </div><a id="LNPCC4485"></a><div class="props_rev_3"><a id="GUID-9C2727A2-8E43-4CB3-B2A2-BE676C7083AC" name="GUID-9C2727A2-8E43-4CB3-B2A2-BE676C7083AC"></a><h5 id="LNPCC-GUID-9C2727A2-8E43-4CB3-B2A2-BE676C7083AC" class="sect5"><span class="enumeration_section">19.5.4.1</span> INTYPE文件类型规范</h5>
                     <div>
                        <p><code class="codeph">INTYPE</code>中的类型规范命名要转换的对象数据类型。以下是用户创建的<code class="codeph">INTYPE</code>文件的示例：</p><pre class="oac_no_warn" dir="ltr">TYPE员工TRANSLATE SALARY $ AS薪水DEPTNO AS部门类型地址类型PURCHASE_ORDER作为p_o</pre><p>类型规范的结构如下：</p><pre class="oac_no_warn" dir="ltr">TYPE type_name [AS type_identifier] [VERSION [=] version_string] [HFILE [=] hfile_name] [TRANSLATE {member_name [AS identifier]} ...]
</pre><p><span class="italic">type_name</span>的语法是：</p><pre class="oac_no_warn" dir="ltr">[模式名。] TYPE_NAME</pre><p>其中， <span class="italic">schema_name</span>是拥有给定对象数据类型的模式的名称， <span class="italic">type_name</span>是该类型的名称。默认架构是运行OTT的用户的架构。默认数据库是本地数据库。
                        </p>
                        <p>类型规范的组件是：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><span class="italic">type name</span>是对象数据类型的名称。
                              </p>
                           </li>
                           <li>
                              <p><span class="italic">type identifier</span>是用于表示类型的C标识符。如果省略，将使用默认名称映射算法。
                              </p>
                           </li>
                           <li>
                              <p><span class="italic">version string</span>是上次调用OTT生成代码时使用的类型的版本字符串。版本字符串由OTT生成并写入<code class="codeph">OUTTYPE</code>文件，稍后可在稍后执行OTT时用作<code class="codeph">INTYPE</code>文件。版本字符串不会影响OTT的操作，但最终将用于选择应在正在运行的程序中使用哪个版本的对象数据类型。
                              </p>
                           </li>
                           <li>
                              <p><span class="italic">hfile name</span>是头文件的名称，其中出现或将出现相应结构或类的声明。如果省略<span class="italic">hfile名称</span> ，则在生成声明时将使用命令行<code class="codeph">HFILE</code>参数指定的文件。
                              </p>
                           </li>
                           <li>
                              <p><span class="italic">成员名称</span>是要转换为以下<span class="italic">标识符</span>的属性（数据成员）的名称。
                              </p>
                           </li>
                           <li>
                              <p><span class="italic">identifier</span>是用于表示用户程序中的属性的C标识符。您可以通过这种方式为任意数量的属性指定标识符。默认名称映射算法将用于未提及的属性。
                              </p>
                           </li>
                        </ul>
                        <p>可能需要转换对象数据类型，原因有两个：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>它出现在<code class="codeph">INTYPE</code>文件中。
                              </p>
                           </li>
                           <li>
                              <p>需要声明另一个必须翻译的类型，并且TRANSITIVE = TRUE。</p>
                           </li>
                        </ul>
                        <p>如果在一个文件中声明的类型需要未明确提及的类型，则所需类型的转换将写入与需要它的显式声明类型相同的文件。</p>
                        <p>如果在两个或多个不同文件中声明的类型需要未明确提及的类型，则将所需类型的转换写入全局<code class="codeph">HFILE</code>文件。
                        </p>
                     </div>
                     <div>
                        <div class="relinfo">
                           <p><strong>相关话题</strong></p>
                           <ul>
                              <li><a href="the-Object-type.html#GUID-825D5648-2443-490D-90F0-C5748F915A29">默认名称映射</a></li>
                           </ul>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="LNPCC4486"></a><div class="props_rev_3"><a id="GUID-585A7EBC-989C-4A19-8884-9CFCB303D04A" name="GUID-585A7EBC-989C-4A19-8884-9CFCB303D04A"></a><h4 id="LNPCC-GUID-585A7EBC-989C-4A19-8884-9CFCB303D04A" class="sect4"><span class="enumeration_section">19.5.5</span>嵌套#include文件生成</h4>
                  <div>
                     <p>OTT <code class="codeph">#includes</code>生成的每个<code class="codeph">HFILE</code>都<code class="codeph">HFILE</code>其他必要的文件和<code class="codeph">#defines</code> <code class="codeph"> </code>从文件名构造的符号，可用于确定是否已包含<code class="codeph">HFILE</code> 。例如，考虑具有以下类型的数据库：</p><pre class="oac_no_warn" dir="ltr">create type px1 AS OBJECT（col1 number，col2 integer）;创建类型px2 AS OBJECT（col1 px1）;创建类型px3 AS OBJECT（col1 px1）;</pre><p><code class="codeph">INTYPE</code>文件包含的位置：</p><pre class="oac_no_warn" dir="ltr">CASE =低级类型pxl hfile tott95a.h类型px3 hfile tott95b.h</pre><p>如果我们调用OTT</p><pre class="oac_no_warn" dir="ltr">ott scott / tiger tott95i.typ outtype = tott95o.typ code = c</pre><p>然后它将生成以下两个头文件。</p>
                     <p>文件tott95b.h是：</p><pre class="oac_no_warn" dir="ltr">#ifndef TOTT95B_ORACLE #define TOTT95B_ORACLE #ifndef OCI_ORACLE #include &lt;oci.h&gt; #endif #ifndef TOTT95A_ORACLE #include“tott95a.h”#endif typedef OCIRef px3_ref; struct px3 {struct px1 col1; }; typedef struct px3 px3; struct px3_ind {OCIInd _atomic; struct px1_ind col1}; typedef struct px3_ind px3_ind; ＃万一</pre><p>文件tott95a.h是：</p><pre class="oac_no_warn" dir="ltr">#ifndef TOTT95A_ORACLE #define TOTT95A_ORACLE #ifndef OCI_ORACLE #include &lt;oci.h&gt; #endif typedef OCIRef px1_ref; struct px1 {OCINumber col1; OCINumber col2; } typedef struct px1 px1; struct px1_ind {OCIInd _atomic; OCIInd col1; OCIInd col2; } typedef struct px1_ind px1_ind; ＃万一</pre><p>在此文件中，首先定义符号TOTT95B_ORACLE，以便程序员可以有条件地包含<code class="codeph">tott95b.h</code>而不必担心是否<span class="italic"> </span> <code class="codeph">tott95b.h</code>依赖于使用以下构造的include文件：</p><pre class="oac_no_warn" dir="ltr">#ifndef TOTT95B_ORACLE #include“tott95b.h”#endif</pre><p>使用这种技术，您可以在某个文件中包含“tott95b.h”，比如说“foo.h”，而不必知道“foo.h”中包含的其他文件是否也包含“tott95b.h”。</p>
                     <p>在定义符号TOTT95B_ORACLE之后，文件<code class="codeph">oci.h</code>是<code class="codeph">#includ</code> ed。OTT生成的每个<code class="codeph">HFILE</code>包含<code class="codeph">oci.h</code> ，它包含Pro * C / C ++或OCI程序员认为有用的类型和函数声明。这是OTT在<code class="codeph">#include</code>使用尖括号的唯一情况。
                     </p>
                     <p>接下来，包含文件<code class="codeph">tott95a.h</code> ，因为它包含<code class="codeph">tott95b.h</code>所需的“struct px1”声明。当<code class="codeph">INTYPE</code>文件请求将类型声明写入多个文件时，OTT将确定每个<code class="codeph">HFILE</code>必须包含哪些其他文件，并将生成必要的<code class="codeph">#includes</code> 。
                     </p>
                     <p>请注意，OTT在此<code class="codeph">#include</code>使用引号。当编译包含<code class="codeph">tott95b.h</code>的程序时，搜索<code class="codeph">tott95a.h</code>从找到源程序的<code class="codeph">tott95a.h</code>开始，然后将遵循实现定义的搜索规则。如果无法以这种方式找到<code class="codeph">tott95a.h</code> ，则应在<code class="codeph">INTYPE</code>文件中使用完整的文件名（例如，以/开头的UNIX绝对路径名）来指定<code class="codeph">tott95a.h</code>的位置。
                     </p>
                  </div>
               </div><a id="LNPCC4488"></a><a id="LNPCC4487"></a><div class="props_rev_3"><a id="GUID-E21D4C5F-FB6D-4573-9703-3D2B5863382E" name="GUID-E21D4C5F-FB6D-4573-9703-3D2B5863382E"></a><h4 id="LNPCC-GUID-E21D4C5F-FB6D-4573-9703-3D2B5863382E" class="sect4"><span class="enumeration_section">19.5.6</span> SCHEMA_NAMES用法</h4>
                  <div>
                     <p>此参数会影响OTT所连接的默认架构中的类型名称是否使用<code class="codeph">OUTTYPE</code>文件中的架构名称进行<code class="codeph">OUTTYPE</code> 。
                     </p>
                     <p>来自其他模式的类型的名称，默认模式始终使用<code class="codeph">OUTTYPE</code>文件中的模式名称进行<code class="codeph">OUTTYPE</code> 。
                     </p>
                     <p>模式名称或其缺席确定在程序执行期间在哪个模式中找到类型。</p>
                     <p>有三种设置：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>SCHEMA_NAMES = ALWAYS（默认）</p>
                           <p><code class="codeph">OUTTYPE</code>文件中的所有类型名称都使用模式名称限定。
                           </p>
                        </li>
                        <li>
                           <p>SCHEMA_NAMES = IF_NEEDED</p>
                           <p><code class="codeph">OUTTYPE</code>文件中属于默认架构的类型名称不使用架构名称限定。与往常一样，属于其他模式的类型名称使用模式名称限定。
                           </p>
                        </li>
                        <li>
                           <p>SCHEMA_NAMES = FROM_INTYPE</p>
                           <p>在提到A型<code class="codeph">INTYPE</code>文件在合格与架构名称<code class="codeph">OUTTYPE</code>文件，当且仅当，它与在模式名修饰<code class="codeph">INTYPE</code>文件。默认模式中的类型在<code class="codeph">INTYPE</code>文件中未提及但由于类型依赖性而必须生成的类型仅在OTT遇到的依赖于它的第一个类型使用模式名称编写时才使用模式名称编写。但是，不在OTT所连接的默认架构中的类型始终使用显式架构名称编写。
                           </p>
                        </li>
                     </ul>
                     <p>OTT生成的<code class="codeph">OUTTYPE</code>文件是Pro * C / C ++ <code class="codeph">INTYPE</code>文件。此文件将数据库类型名称与C结构名称匹配。在运行时使用此信息以确保在结构中选择了正确的数据库类型。如果在<code class="codeph">OUTTYPE</code>文件（Pro * C / C ++ <code class="codeph">INTYPE</code>文件）中显示带有模式名称的类型，则在程序执行期间将在命名模式中找到该类型。如果类型显示没有模式名称，则类型将在程序连接的默认模式中找到，这可能与使用的默认模式OTT不同。
                     </p>
                     <div class="section">
                        <p class="subhead3" id="GUID-E21D4C5F-FB6D-4573-9703-3D2B5863382E__GUID-9F5E42F1-1CD5-445C-BCB7-19E44C761B1C">一个例子</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>如果<code class="codeph">SCHEMA_NAMES</code>设置为<code class="codeph">FROM_INTYPE</code> ，则<code class="codeph">INTYPE</code>文件显示为：</p><pre class="oac_no_warn" dir="ltr">TYPE Person TYPE乔。部门类型山姆。公司</pre><p>那么使用OTT生成的结构的Pro * C / C ++应用程序将使用<span class="italic">sam类型<span class="italic">。公司，乔。部门和人。没有模式的名称的人</span>指的是在该申请被连接架构中的人类型。
                        </p>
                        <p>如果OTT和应用程序都连接到schema joe，则应用程序将使用相同的类型（joe。OTT使用的人。如果OTT连接到架构<span class="italic">joe</span>但应用程序连接到架构mary，则应用程序将使用类型mary。人。仅当在schema joe和schema mary中执行了相同的“CREATE TYPE Person”语句时，此行为才适用。
                        </p>
                        <p>另一方面，应用程序将使用类型joe。无论应用程序连接到哪个架构，都要部署。如果这是您想要的行为，请确保在<code class="codeph">INTYPE</code>文件中包含带有类型名称的模式名称。
                        </p>
                        <p>在某些情况下，OTT会转换用户未明确命名的类型。例如，请考虑以下SQL声明：</p><pre class="oac_no_warn" dir="ltr">CREATE TYPE地址AS OBJECT（街道VARCHAR2（40），城市VARCHAR（30），州CHAR（2），zip_code CHAR（10））; CREATE TYPE Person AS OBJECT（名称CHAR（20），年龄NUMBER，地址ADDRESS）;</pre><p>现在假设OTT连接到schema joe，指定了<code class="codeph">SCHEMA_NAMES=FROM_INTYPE</code> ，并且用户的<code class="codeph">INTYPE</code>文件包含</p><pre class="oac_no_warn" dir="ltr">TYPE Person或TYPE joe。人</pre><p>但是不要提及乔的类型。Address，用作类型为<span class="italic">joe的嵌套对象类型<span class="italic">。人</span>如果“TYPE乔。人“出现在<code class="codeph">INTYPE</code>文件中”，TYPE乔。人“和”TYPE乔。地址“将出现在<code class="codeph">OUTTYPE</code>文件中。如果<code class="codeph">INTYPE</code>文件中出现“Type Person”，则“TYPE Person”和“TYPE Address”将出现在<code class="codeph">OUTTYPE</code>文件中。
                        </p>
                        <p>如果是<span class="italic">乔。Addres</span>的类型嵌入了由OTT翻译的几种类型，但是在<code class="codeph">INTYPE</code>文件中没有明确提到，是否使用模式名称的决定是在OTT第一次遇到嵌入的<span class="italic">joe时做出的<span class="italic">。地址</span>类型。如果由于某种原因，用户想要键入<span class="italic">joe。要具有模式名称但不希望类型为<span class="italic">Person的</span> 地址</span> ，必须显式请求</p><pre class="oac_no_warn" dir="ltr">TYPE乔。地址</pre><p>在<code class="codeph">INTYPE</code>文件中。</p>
                        <p>在通常情况下，在单个模式中声明每个类型，最安全的是使用<code class="codeph">INTYPE</code>文件中的模式名称限定所有类型名称。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCC4489"></a><div class="props_rev_3"><a id="GUID-825D5648-2443-490D-90F0-C5748F915A29" name="GUID-825D5648-2443-490D-90F0-C5748F915A29"></a><h4 id="LNPCC-GUID-825D5648-2443-490D-90F0-C5748F915A29" class="sect4"><span class="enumeration_section">19.5.7</span>默认名称映射</h4>
                  <div>
                     <p>当OTT为对象类型或属性创建C标识符名称时，它会将名称从数据库字符集转换为合法的C标识符。首先，名称从数据库字符集转换为OTT使用的字符集。接下来，如果在<code class="codeph">INTYPE</code>文件中提供了结果名称的翻译，则使用该翻译。否则，OTT将字符逐字符转换为编译器字符集，并应用<code class="codeph">CASE</code>选项。以下更详细地描述了这一点。
                     </p>
                     <p>当OTT读取数据库实体的名称时，该名称将自动从数据库字符集转换为OTT使用的字符集。为了使OTT成功读取数据库实体的名称，必须在OTT字符集中找到名称的所有字符，尽管字符在两个字符集中可能具有不同的编码。</p>
                     <p>保证OTT使用的字符集包含所有必需字符的最简单方法是使其与数据库字符集相同。但请注意，OTT字符集必须是编译器字符集的超集。也就是说，如果编译器字符集是7位ASCII，则OTT字符集必须包含7位ASCII作为子集，如果编译器字符集是7位EBCDIC，则OTT字符集必须包含7位EBCDIC作为一个子集。用户通过设置NLS_LANG环境变量或某些其他特定于平台的机制来指定OTT使用的字符集。</p>
                     <p>一旦OTT读取了数据库实体的名称，它就会将名称从OTT使用的字符集转换为编译器的字符集。如果名称的翻译出现在<code class="codeph">INTYPE</code>文件中，则OTT使用该翻译。
                     </p>
                     <p>否则，OTT会尝试将名称翻译如下：</p>
                     <ol>
                        <li>
                           <p>首先，如果OTT字符集是多字节字符集，则名称中具有单字节等效字符的所有多字节字符都将转换为那些单字节等效字符。</p>
                        </li>
                        <li>
                           <p>接下来，将名称从OTT字符集转换为编译器字符集。编译器字符集是单字节字符集，例如US7ASCII。</p>
                        </li>
                        <li>
                           <p>最后，根据有效的<code class="codeph">CASE</code>选项设置字母<code class="codeph">CASE</code> ，并且任何在C标识符中不合法或在编译器字符集中没有翻译的字符都将被下划线替换。如果至少有一个字符被下划线替换，OTT会发出警告消息。如果名称中的所有字符都被下划线替换，OTT会给出错误消息。
                           </p>
                        </li>
                     </ol>
                     <p>逐个字符的名称转换不会改变编译器字符集中出现的下划线，数字或单字节字母，因此不会更改合法的C标识符。</p>
                     <p>例如，名称翻译可以将重音单字节字符（例如带有变音符号的“o”或带有重音符号的“a”翻译为“o”或“a”），并且可以将多字节字母翻译成其单字节等效字符。如果名称包含缺少单字节等效字符的多字节字符，则名称转换通常会失败。在这种情况下，用户必须在<code class="codeph">INTYPE</code>文件中指定名称翻译。
                     </p>
                     <p>OTT不会检测由两个或多个数据库标识符映射到同一C名称引起的命名冲突，也不会检测数据库标识符映射到C关键字的命名问题。</p>
                  </div>
               </div><a id="LNPCC4490"></a><div class="props_rev_3"><a id="GUID-C1EB0F45-A82F-4555-9662-B5A1F821E212" name="GUID-C1EB0F45-A82F-4555-9662-B5A1F821E212"></a><h4 id="LNPCC-GUID-C1EB0F45-A82F-4555-9662-B5A1F821E212" class="sect4"><span class="enumeration_section">19.5.8</span>限制</h4>
                  <div>
                     <p>以下限制会影响OTT的使用。</p>
                  </div><a id="LNPCC4491"></a><div class="props_rev_3"><a id="GUID-4274113F-7216-4B8F-97C5-9031B273F9B9" name="GUID-4274113F-7216-4B8F-97C5-9031B273F9B9"></a><h5 id="LNPCC-GUID-4274113F-7216-4B8F-97C5-9031B273F9B9" class="sect5"><span class="enumeration_section">19.5.8.1</span>文件名比较</h5>
                     <div>
                        <p>目前，OTT通过比较用户在命令行或<code class="codeph">INTYPE</code>文件中提供的文件名来确定两个文件是否相同。但是当OTT需要知道两个文件名是否引用同一文件时，可能会出现一个潜在的问题。例如，如果OTT生成的文件foo.h需要写入foo1.h的类型声明，以及写入/private/smith/foo1.h的另一个类型声明，如果两个文件相同，OTT应生成一个<code class="codeph">#include</code> ，如果文件不同，则有两个<code class="codeph">#includes</code> 。但实际上，它得出的结论是两个文件不同，并生成两个<code class="codeph">#includes</code> ，如下所示：</p><pre class="oac_no_warn" dir="ltr">#ifndef FOO1_ORACLE #include“foo1.h”#endif #ifndef FOO1_ORACLE #include“/private/smith/foo1.h”#endif</pre><p>如果foo1.h和/private/smith/foo1.h是不同的文件，则只包含第一个文件。如果foo1.h和/private/smith/foo1.h是同一个文件，则会写入冗余的<code class="codeph">#include</code> 。
                        </p>
                        <p>因此，如果在命令行或<code class="codeph">INTYPE</code>文件中多次提到文件，则每次提及该文件时应使用完全相同的文件名。
                        </p>
                     </div>
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>