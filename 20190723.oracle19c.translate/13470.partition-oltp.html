<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <meta name="abstract" content="Partitioning features are very useful for OLTP systems."></meta>
      <meta name="description" content="Partitioning features are very useful for OLTP systems."></meta>
      <title>在联机事务处理环境中使用分区</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="VLDB and Partitioning Guide"></meta>
      <meta property="og:description" content="Partitioning features are very useful for OLTP systems."></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="VLDB and Partitioning Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="vldb-and-partitioning-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-04-23T18:05:22-07:00"></meta>
      <meta name="dcterms.title" content="VLDB and Partitioning Guide"></meta>
      <meta name="dcterms.dateCopyrighted" content="2008, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96199-03"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="partition-warehouse.html" title="Previous" type="text/html"></link>
      <link rel="next" href="using-parallel.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.isVersionOf" content="VLDBG"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="partition-warehouse.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="using-parallel.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">VLDB和分区指南</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">在联机事务处理环境中使用分区</li>
            </ol>
            <a id="GUID-2C1ABA68-5671-410A-8F81-D4E4BB5F7137" name="GUID-2C1ABA68-5671-410A-8F81-D4E4BB5F7137"></a><a id="VLDBG006"></a>
            
            <h2 id="VLDBG-GUID-2C1ABA68-5671-410A-8F81-D4E4BB5F7137" class="sect2"><span class="enumeration_chapter">7</span>在联机事务处理环境中使用分区</h2>
         </header>
         <div class="ind">
            <div>
               <p>分区功能对OLTP系统非常有用。</p>
               <p>由于在线事务处理（OLTP）系统及其用户群的爆炸式增长，除了数据仓库环境之外，分区对OLTP系统特别有用</p>
               <p>分区通常用于OLTP系统，以减少争用，同时支持非常大的用户群。它还有助于解决OLTP系统面临的法规要求，包括以经济有效的方式存储大量数据。</p>
               <p>本章包含以下部分：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="partition-oltp.html#GUID-0BC75680-5BD4-43A9-826F-CD8837D30EB2" title="在线事务处理（OLTP）系统是当今企业中常见的数据处理系统。OLTP系统的典型示例是订单输入，零售销售和金融交易系统。">什么是在线交易处理系统？</a></p>
                  </li>
                  <li>
                     <p><a href="partition-oltp.html#GUID-03522F8E-BC30-4694-80D7-D9B6DE065C37" title="OLTP环境中的性能很大程度上依赖于有效的索引访问，因此选择最合适的索引策略变得至关重要。">在线事务处理环境中的性能</a></p>
                  </li>
                  <li>
                     <p><a href="partition-oltp.html#GUID-8E68D33E-2A09-47A6-94BF-AF036AAE6659" title="除了性能优势之外，分区还可以为OLTP环境中的大型对象提供最佳数据管理。">在线事务处理环境中的可管理性</a></p>
                  </li>
               </ul>
            </div><a id="VLDBG1367"></a><div class="props_rev_3"><a id="GUID-0BC75680-5BD4-43A9-826F-CD8837D30EB2" name="GUID-0BC75680-5BD4-43A9-826F-CD8837D30EB2"></a><h3 id="VLDBG-GUID-0BC75680-5BD4-43A9-826F-CD8837D30EB2" class="sect3">什么是在线交易处理系统？</h3>
               <div>
                  <p>在线事务处理（OLTP）系统是当今企业中常见的数据处理系统。OLTP系统的典型示例是订单输入，零售销售和金融交易系统。</p>
                  <p>OLTP系统主要通过与数据仓库环境不同的特定数据使用来表征，但是一些特征（例如，具有大量数据和与生命周期相关的数据使用和重要性）是相同的。</p>
                  <p>OLTP环境的主要特征是：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>响应时间短</p>
                        <p>OLTP环境的性质主要是任何类型的交互式临时使用，例如电话推销员输入电话调查结果。OLTP系统需要较短的响应时间，以便用户保持高效。</p>
                     </li>
                     <li>
                        <p>小额交易</p>
                        <p>OLTP系统通常读取和操作高选择性的少量数据;数据处理大多是简单的，复杂的连接比较少见。始终存在混合的查询和DML工作负载。例如，许多呼叫中心员工中的一个检索每个呼叫的客户详细信息并在查看过去与客户的通信时输入客户投诉。</p>
                     </li>
                     <li>
                        <p>数据维护操作</p>
                        <p>拥有必须定期或临时运行的报告程序和数据更新程序并不罕见。这些程序在用户继续处理其他任务时在后台运行，可能需要大量的数据密集型计算。例如，大学可以开始批量工作，将学生分配到课程，而学生仍然可以在线注册课程。</p>
                     </li>
                     <li>
                        <p>用户人数众多</p>
                        <p>OLTP系统可能具有非常大的用户群，其中许多用户试图同时访问相同的数据。例如，在线拍卖网站可以有数十万（如果不是数百万）用户同时访问其网站上的数据。</p>
                     </li>
                     <li>
                        <p>高并发性</p>
                        <p>由于用户数量大，响应时间短，交易量小，OLTP环境中的并发性非常高。对数千个并发用户的要求并不罕见。</p>
                     </li>
                     <li>
                        <p>大数据量</p>
                        <p>OLTP系统可能会变得非常大，具体取决于应用程序类型，用户群和数据保留时间。例如，银行的每个客户都可以访问在线银行系统，该系统显示过去12个月的所有交易。</p>
                     </li>
                     <li>
                        <p>高可用性</p>
                        <p>OLTP系统的可用性要求通常非常高。不可用的OLTP系统可能会影响非常大的用户群，如果OLTP系统不可用，组织可能会遭受重大损失。例如，证券交易系统在交易时间内具有极高的可用性要求。</p>
                     </li>
                     <li>
                        <p>与生命周期相关的数据使用</p>
                        <p>与数据仓库环境类似，OLTP系统通常会经历不同的数据访问模式。例如，在月末，计算每个活动帐户的月利息。</p>
                     </li>
                  </ul>
                  <p>以下是OLTP环境分区的好处：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>支持更大的数据库</p>
                        <p>作为高可用性策略的一部分，备份和恢复可以在较低的粒度级别上执行，以有效地管理数据库的大小。OLTP系统通常在备份期间保持联机状态，用户可以在备份运行时继续访问系统。备份过程不应对在线用户造成重大性能下降。</p>
                        <p>分区有助于减少OLTP系统的空间需求，因为数据库对象的一部分可以压缩存储，而其他部分可以保持未压缩。针对未压缩行更新事务比压缩数据更新更有效。</p>
                        <p>分区可以将数据透明地存储在不同的存储层上，以降低保留大量数据的成本。</p>
                     </li>
                     <li>
                        <p>用于数据维护的分区维护操作（而不是DML）</p>
                        <p>对于数据维护操作（清除是最常见的操作），您可以利用Oracle数据库在线索引维护功能来利用分区维护操作。分区管理操作生成的重做次数少于等效的DML操作。</p>
                     </li>
                     <li>
                        <p>通过消除热点可能获得更高的并发性</p>
                        <p>OLTP环境的一个常见场景是单调增加索引值，用于强制执行主键约束，从而创建高并发和潜在争用的区域：每个新插入尝试更新同一组索引块。分区索引，特别是散列分区索引，可以帮助缓解这种情况。</p>
                     </li>
                  </ul>
               </div>
            </div><a id="VLDBG1368"></a><div class="props_rev_3"><a id="GUID-03522F8E-BC30-4694-80D7-D9B6DE065C37" name="GUID-03522F8E-BC30-4694-80D7-D9B6DE065C37"></a><h3 id="VLDBG-GUID-03522F8E-BC30-4694-80D7-D9B6DE065C37" class="sect3">在线事务处理环境中的性能</h3>
               <div>
                  <p>OLTP环境中的性能很大程度上依赖于有效的索引访问，因此选择最合适的索引策略变得至关重要。</p>
                  <p>以下部分讨论了决定是否在OLTP环境中对索引进行分区的最佳实践。</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="partition-oltp.html#GUID-F9597715-E1C0-4986-B83E-99363D59214E" title="由于查询的选择性和OLTP应用程序的高并发性，正确的索引策略的选择无疑是在OLTP环境中使用分区的重要决策。通过较少的争用，应用程序可以支持更大的用户群。">决定是否分区索引</a></p>
                     </li>
                     <li>
                        <p><a href="partition-oltp.html#GUID-E45059AC-AA45-462E-8054-EF50CA37D69C" title="当您的工作负载适合使用索引组织表时，您必须考虑如何在索引组织表和任何二级索引上使用分区。">如何在索引组织表上使用分区</a></p>
                     </li>
                  </ul>
               </div><a id="VLDBG14082"></a><a id="VLDBG1369"></a><div class="props_rev_3"><a id="GUID-F9597715-E1C0-4986-B83E-99363D59214E" name="GUID-F9597715-E1C0-4986-B83E-99363D59214E"></a><h4 id="VLDBG-GUID-F9597715-E1C0-4986-B83E-99363D59214E" class="sect4">决定是否分区索引</h4>
                  <div>
                     <p>由于查询的选择性和OLTP应用程序的高并发性，正确的索引策略的选择无疑是在OLTP环境中使用分区的重要决策。通过较少的争用，应用程序可以支持更大的用户群。</p>
                     <p>以下基本规则解释了各种可能的索引结构的主要优点和权衡：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>如果选择了索引访问路径，则非分区索引虽然大于单个分区索引段，但总是会导致单个索引探测（或扫描）;表只有一个段。对于分区表和非分区表，数据访问时间和正在访问的块数是相同的。</p>
                           <p>非分区索引不提供分区自治，并且需要对影响rowid的每个分区维护操作执行索引维护操作（例如，删除，截断，移动，合并，合并或拆分操作）。</p>
                        </li>
                        <li>
                           <p>使用分区索引时，始终存在多个段。只要Oracle数据库无法修剪到单个索引段，数据库就必须访问多个段。这可能会导致更高的I / O要求（与非分区索引的一个探测相比， <span class="italic">n个</span>索引段探测）并且可能对运行时性能产生影响（可测量或不可测量）。对于所有分区索引都是如此。
                           </p>
                           <p>分区索引可以是本地分区索引或全局分区索引。本地分区索引始终从表继承分区键，并与表分区完全对齐。因此，任何类型的分区维护操作都几乎不需要索引维护工作。例如，删除或截断分区不会产生任何可衡量的索引维护开销;本地索引分区被删除或截断。</p>
                           <p>未与表对齐的分区索引称为全局分区索引。与本地索引不同，表和索引分区之间没有关系。全局分区索引可以灵活地选择最适合有效分区索引访问的分区键。分区维护操作通常会影响全局分区索引的更多（如果不是全部）分区，具体取决于索引的操作和分区键。</p>
                        </li>
                        <li>
                           <p>在某些情况下，为索引创建多个段可能有利于提高性能。在OLTP环境中使用序列来创建人工密钥是很常见的。因此，您创建单调递增的键值，这会导致许多插入过程竞争相同的索引块。引入全局分区索引（例如，在键列上使用全局散列分区）可以缓解这种情况。例如，如果您有这样一个索引的四个哈希分区，那么您现在有四个要插入数据的索引段，从而将插入过程中这些段的并发性降低了四倍。</p>
                        </li>
                     </ul>
                     <p>强制唯一性是OLTP环境的重要数据库功能。可以使用非分区索引和分区索引强制实施唯一性。但是，由于分区索引提供了分区自治，因此必须满足以下要求才能实现唯一索引：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>非分区索引可以强制任何给定列或列组合的唯一性。与非分区表相比，分区表的非分区索引的行为没有区别。</p>
                        </li>
                        <li>
                           <p>分区索引的每个分区都被视为自治段。要强制执行这些段的自治，您始终必须将分区键列包含为唯一键定义的子集。</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>全局分区索引必须始终至少以索引列的第一个前导列（分区全局索引的分区列）为前缀。</p>
                              </li>
                              <li>
                                 <p>唯一本地索引必须将表的分区键作为唯一键定义的子集。</p>
                              </li>
                           </ul>
                        </li>
                     </ul>
                     <p><a href="partition-oltp.html#GUID-F9597715-E1C0-4986-B83E-99363D59214E__BABJFAFG">例7-1</a>显示了在<code class="codeph">orders_oltp</code>表的<code class="codeph">order_id</code>列上创建唯一索引。使用序列号填充OLTP应用程序中的<code class="codeph">order_id</code> 。唯一索引使用散列分区来减少对单调递增的<code class="codeph">order_id</code>值的争用。然后使用唯一键来创建主键约束。
                     </p>
                     <div class="example" id="GUID-F9597715-E1C0-4986-B83E-99363D59214E__BABJFAFG">
                        <p class="titleinexample">示例7-1创建唯一索引和主键约束</p><pre class="oac_no_warn" dir="ltr">创建独特的索引orders_pk ON orders_oltp（order_id）全局分区哈希（order_id）（分区p1表格tbs1，分区p2表格tbs2，分区p3表格tbs3，分区p4表格tbs4）NOLOGGING; ALTER TABLE orders_oltp ADD CONSTRAINT orders_pk PRIMARY KEY（order_id）USING INDEX;</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="VLDBG1370"></a><div class="props_rev_3"><a id="GUID-E45059AC-AA45-462E-8054-EF50CA37D69C" name="GUID-E45059AC-AA45-462E-8054-EF50CA37D69C"></a><h4 id="VLDBG-GUID-E45059AC-AA45-462E-8054-EF50CA37D69C" class="sect4">如何在索引组织表上使用分区</h4>
                  <div>
                     <p>当您的工作负载适合使用索引组织表时，您必须考虑如何在索引组织表和任何二级索引上使用分区。</p>
                     <p>您必须根据与常规堆表上的索引相同的注意事项来决定是否对索引组织表上的二级索引进行分区。您可以对索引组织表进行分区，但分区键必须是主键的子集。对索引组织表进行分区的一个常见原因是减少争用;这通常使用散列分区来实现。</p>
                     <p>对索引组织表进行分区的另一个原因是能够基于主键列物理地分离数据集。例如，应用程序托管公司可以通过对公司标识符进行列表分区来物理地为不同客户分离应用程序实例。在这种情况下查询通常可以利用索引分区修剪，缩短索引扫描的时间。具有索引组织表和分区的ILM方案不太常见，因为它们需要日期列作为主键的一部分。</p>
                     <p>有关如何创建分区索引组织表的更多信息，请参阅<a href="partition-admin.html#GUID-F2C99CFA-1090-4A62-B452-D4E116A40A34" title="使用分区表和索引时，分区管理是一项重要任务。">分区管理</a> 。
                     </p>
                     <div class="infoboxnotealso" id="GUID-E45059AC-AA45-462E-8054-EF50CA37D69C__GUID-C27EB6FD-676E-49FC-9E7F-080CA8DC9EBD">
                        <p class="notep1">也可以看看：</p>
                        <p>有关索引组织表的详细信息，请参见<a href="../admin/managing-tables.html#ADMIN01506" target="_blank"><span><cite>“Oracle数据库管理员指南”</cite></span></a></p>
                     </div>
                  </div>
               </div>
            </div><a id="VLDBG1371"></a><div class="props_rev_3"><a id="GUID-8E68D33E-2A09-47A6-94BF-AF036AAE6659" name="GUID-8E68D33E-2A09-47A6-94BF-AF036AAE6659"></a><h3 id="VLDBG-GUID-8E68D33E-2A09-47A6-94BF-AF036AAE6659" class="sect3">在线事务处理环境中的可管理性</h3>
               <div>
                  <p>除了性能优势之外，分区还可以为OLTP环境中的大型对象提供最佳数据管理。</p>
                  <p>Oracle数据库中的每个分区维护操作都可以扩展为原子地包括全局和本地索引维护，从而可以执行任何分区维护操作，而不会影响OLTP环境的24x7可用性。</p>
                  <p>由于ILM方案，OLTP系统中的分区维护操作经常发生。在这些场景中，[range | interval]分区表，或[range | interval]  -  *复合分区表，很常见。</p>
                  <p>分区维护操作的一些业务案例包括围绕应用程序数据分离的场景。例如，零售公司在单个模式中为多个分支运行相同的应用程序。根据分支收入，应用程序（作为单独的分区）存储在更高效的存储上。列表分区或list- * composite partitioning是此类业务案例的常见分区策略。</p>
                  <p>您可以在OLTP系统中使用散列分区或表的哈希子分区，以获得与数据仓库环境中实现的性能优势类似的性能优势。每日OLTP工作负载的大部分由相对较小的操作组成，并且是串行执行的。但是，定期批处理操作可以并行执行，并受益于散列分区和子分区可以为分区连接提供的分发改进。例如，可以并行执行月末利息计算以在夜间批处理窗口内完成。</p>
                  <p>本节包含以下主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="partition-oltp.html#GUID-61F68DF0-78AC-4680-8AB7-4F8A43199EE9" title="发生分区维护操作时，Oracle数据库会锁定受影响的表分区以进行任何DML操作，但ONLINE MOVE除外。">分区维护操作对具有本地索引的分区表的影响</a></p>
                     </li>
                     <li>
                        <p><a href="partition-oltp.html#GUID-A22047D9-61D1-4C00-8C1C-0F7E5C7D4F5B" title="每当在分区或非分区表上定义全局索引时，不同的表分区和索引之间就没有相关性。因此，任何分区维护操作都会影响所有全局索引或索引分区。">分区维护操作对全局索引的影响</a></p>
                     </li>
                     <li>
                        <p><a href="partition-oltp.html#GUID-3540CE58-1D0F-47E2-B98C-F0213E3A2AFD" title="两种最常见的分区维护操作是删除数据以及将数据重定位到成本较低的存储层设备上。">OLTP环境中的通用分区维护操作</a></p>
                     </li>
                  </ul>
                  <p>有关分区性能优势的更多信息，请参阅<a href="partition-availability.html#GUID-FA29787B-8700-49EA-B80D-54D667CF2752" title="分区可实现可用性，可管理性和性能。">可用性，可管理性和性能分区</a> 。
                  </p>
               </div><a id="VLDBG1372"></a><div class="props_rev_3"><a id="GUID-61F68DF0-78AC-4680-8AB7-4F8A43199EE9" name="GUID-61F68DF0-78AC-4680-8AB7-4F8A43199EE9"></a><h4 id="VLDBG-GUID-61F68DF0-78AC-4680-8AB7-4F8A43199EE9" class="sect4">分区维护操作对具有本地索引的分区表的影响</h4>
                  <div>
                     <p>发生分区维护操作时，Oracle数据库会锁定受影响的表分区以进行任何DML操作，但<code class="codeph">ONLINE</code> <code class="codeph">MOVE</code>除外。</p>
                     <p>除<code class="codeph">DROP</code>或<code class="codeph">TRUNCATE</code>操作外，受影响分区中的数据仍可完全访问任何<code class="codeph">SELECT</code>操作。由于本地索引在逻辑上与表（数据）分区耦合，因此只有受影响的表分区的本地索引分区必须作为分区维护操作的一部分进行维护，从而实现索引维护的最佳处理。
                     </p>
                     <p>例如，使用<code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">MOVE</code> <code class="codeph">ONLINE</code>功能将旧分区从高端存储层移动到低成本存储层时，数据和索引始终可用于<code class="codeph">SELECT</code>和DML操作;必要的索引维护是更新现有索引分区以反映数据的新物理位置。如果在归档后删除旧分区，则其本地索引分区也会被删除，对于全局索引，已删除已删除分区的孤立条目，从而启用仅影响数据字典的分秒分区维护操作。
                     </p>
                  </div>
               </div><a id="VLDBG1373"></a><div class="props_rev_3"><a id="GUID-A22047D9-61D1-4C00-8C1C-0F7E5C7D4F5B" name="GUID-A22047D9-61D1-4C00-8C1C-0F7E5C7D4F5B"></a><h4 id="VLDBG-GUID-A22047D9-61D1-4C00-8C1C-0F7E5C7D4F5B" class="sect4">分区维护操作对全局索引的影响</h4>
                  <div>
                     <p>每当在分区或非分区表上定义全局索引时，不同的表分区和索引之间就没有相关性。因此，任何分区维护操作都会影响所有全局索引或索引分区。</p>
                     <p>包含本地索引的表的分区将被锁定，以防止针对影响表分区的DML操作，但<code class="codeph">ONLINE</code> <code class="codeph">MOVE</code>操作除外。但是，与本地索引的索引维护不同，任何全局索引仍可完全用于DML操作，并且不会影响OLTP系统的联机可用性。
                     </p>
                     <p>从概念上和技术上讲，分区维护操作的全局索引的索引维护与语义相同的DML操作所需的索引维护相当，但<code class="codeph">DROP</code>和<code class="codeph">TRUNCATE</code>除外，其中全局索引维护延迟到稍后的时间点。有关管理全局索引的更多信息，请参阅<a href="index-partitioning.html#GUID-63785C41-80E1-4224-8CA5-D0A815B43FCF" title="全球分区索引的管理带来了一些挑战。">全局分区索引管理</a> 。
                     </p>
                     <p>例如，删除旧分区在语义上等同于使用SQL <code class="codeph">DELETE</code>语句<code class="codeph">DELETE</code>旧分区的所有记录。在DML情况下，必须从任何全局索引中删除已删除数据集的所有索引条目作为标准索引维护操作，这不会影响<code class="codeph">SELECT</code>和DML操作的索引的可用性。
                     </p>
                     <p><code class="codeph">DROP</code> <code class="codeph">PARTITION</code>也不会影响索引可用性，但可以使必要的索引维护与初始数据删除分离，而不会影响全局索引的可用性。在这种情况下，丢弃操作表示最佳方法：数据被移除而没有传统<code class="codeph">DELETE</code>操作的开销，并且全局索引以非侵入方式维护。
                     </p>
                  </div>
               </div><a id="VLDBG1374"></a><div class="props_rev_3"><a id="GUID-3540CE58-1D0F-47E2-B98C-F0213E3A2AFD" name="GUID-3540CE58-1D0F-47E2-B98C-F0213E3A2AFD"></a><h4 id="VLDBG-GUID-3540CE58-1D0F-47E2-B98C-F0213E3A2AFD" class="sect4">OLTP环境中的通用分区维护操作</h4>
                  <div>
                     <p>两种最常见的分区维护操作是删除数据以及将数据重定位到成本较低的存储层设备上。</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="partition-oltp.html#GUID-AE66EA32-E8F4-47D1-80F0-A955CA326E08" title="使用DROP或TRUNCATE操作会根据分区键标准删除旧数据。">删除（清除）旧数据</a></p>
                        </li>
                        <li>
                           <p><a href="partition-oltp.html#GUID-FB5897E5-FB6D-441B-8906-2A8D3DE7A5CB" title="使用MOVE或MERGE操作作为信息生命周期管理（ILM）策略的一部分，您可以将旧分区重新定位到最具成本效益的存储层。">将较旧的分区移动或合并到低成本存储层设备</a></p>
                        </li>
                     </ul>
                  </div><a id="VLDBG1375"></a><div class="props_rev_3"><a id="GUID-AE66EA32-E8F4-47D1-80F0-A955CA326E08" name="GUID-AE66EA32-E8F4-47D1-80F0-A955CA326E08"></a><h5 id="VLDBG-GUID-AE66EA32-E8F4-47D1-80F0-A955CA326E08" class="sect5">删除（清除）旧数据</h5>
                     <div>
                        <p>使用<code class="codeph">DROP</code>或<code class="codeph">TRUNCATE</code>操作会根据分区键标准删除旧数据。
                        </p>
                        <p>删除操作会删除数据和分区元数据，而<code class="codeph">TRUNCATE</code>操作仅删除数据但保留元数据。将分别删除所有本地索引分区，并将其截断。异步全局索引维护是针对分区或非分区全局索引完成的，并且完全可用于select和DML操作。
                        </p>
                        <p>以下示例从<code class="codeph">orders_oltp</code>表中删除早于2006年1月的所有数据。作为drop语句的一部分，将执行<code class="codeph">UPDATE GLOBAL INDEXES</code>语句，以便全局索引在整个维护操作中保持可用。作为此操作的一部分，将删除任何本地索引分区。
                        </p><pre class="oac_no_warn" dir="ltr">ALTER TABLE orders_oltp DROP PARTITION p_before_jan_2006 UPDATE GLOBAL INDEXES;</pre></div>
                  </div><a id="VLDBG1376"></a><div class="props_rev_3"><a id="GUID-FB5897E5-FB6D-441B-8906-2A8D3DE7A5CB" name="GUID-FB5897E5-FB6D-441B-8906-2A8D3DE7A5CB"></a><h5 id="VLDBG-GUID-FB5897E5-FB6D-441B-8906-2A8D3DE7A5CB" class="sect5">将较旧的分区移动或合并到低成本存储层设备</h5>
                     <div>
                        <p>使用<code class="codeph">MOVE</code>或<code class="codeph">MERGE</code>操作作为信息生命周期管理（ILM）策略的一部分，您可以将旧分区重新定位到最具成本效益的存储层。
                        </p>
                        <p>使用<code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">ONLINE</code> <code class="codeph">MOVE</code>功能可以使数据同时用于查询和DML操作。维护本地索引并可能作为合并或移动操作的一部分重新定位。标准索引维护是针对分区或非分区全局索引完成的，并且完全可用于select和DML操作。
                        </p>
                        <p>以下示例显示如何在<code class="codeph">orders_oltp</code>表中合并2006年1月和2006年2月的分区，并将它们存储在不同的表空间中。作为此操作的一部分，任何本地索引分区也会移动到<code class="codeph">ts_low_cost</code>表空间。<code class="codeph">UPDATE INDEXES</code>子句确保所有索引在操作的整个过程中和操作后都可用，无需额外的重建。
                        </p><pre class="oac_no_warn" dir="ltr">ALTER TABLE orders_oltp MERGE PARTITIONS p_2006_jan，p_2006_feb INTO PARTITION p_before_mar_2006 COMPRESS TABLESPACE ts_low_cost UPDATE INDEXES;</pre><p>有关信息生命周期管理的分区维护操作的好处的更多信息，请参阅<a href="time-based-info.html#GUID-0193CE0F-4D9A-4D6F-8B19-E471DE94107C" title="Oracle数据库提供了基于时间管理和维护数据的策略。">管理和维护基于时间的信息</a> 。
                        </p>
                     </div>
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>