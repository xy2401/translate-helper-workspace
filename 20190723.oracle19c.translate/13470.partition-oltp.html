<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html xml:lang="en-us" lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta name="abstract" content="Partitioning features are very useful for OLTP systems.">
      <meta name="description" content="Partitioning features are very useful for OLTP systems.">
      <title>Using Partitioning in an Online Transaction Processing Environment</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="VLDB and Partitioning Guide">
      <meta property="og:description" content="Partitioning features are very useful for OLTP systems.">
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="VLDB and Partitioning Guide">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="vldb-and-partitioning-guide.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2019-04-23T18:05:22-07:00">
      <meta name="dcterms.title" content="VLDB and Partitioning Guide">
      <meta name="dcterms.dateCopyrighted" content="2008, 2019">
      <meta name="dcterms.category" content="database">
      <meta name="dcterms.identifier" content="E96199-03">
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19">
      
      <link rel="prev" href="partition-warehouse.html" title="Previous" type="text/html">
      <link rel="next" href="using-parallel.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.isVersionOf" content="VLDBG">
    <meta name="dcterms.release" content="Release 19">
  </head>
   <body>
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="partition-warehouse.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>Previous</a>
         <a href="using-parallel.html" class="pull-right">Next<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a>
         <span class="fa fa-exclamation-triangle" aria-hidden="true"></span> JavaScript must be enabled to correctly display this content
        
      </div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">VLDB and Partitioning Guide</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">Using Partitioning in an Online Transaction Processing Environment</li>
            </ol>
            <a id="GUID-2C1ABA68-5671-410A-8F81-D4E4BB5F7137" name="GUID-2C1ABA68-5671-410A-8F81-D4E4BB5F7137"></a><a id="VLDBG006"></a>
            
            <h2 id="VLDBG-GUID-2C1ABA68-5671-410A-8F81-D4E4BB5F7137" class="sect2"><span class="enumeration_chapter">7 </span>Using Partitioning in an Online Transaction Processing Environment
            </h2>
         </header>
         <div class="ind">
            <div>
               <p>Partitioning features are very useful for OLTP systems.</p>
               <p>Due to the explosive growth of online transaction processing (OLTP) systems and their user populations, partitioning is particularly useful for OLTP systems in addition to data warehousing environments</p>
               <p>Partitioning is often used for OLTP systems to reduce contention while supporting a very large user population. It also helps to address regulatory requirements facing OLTP systems, including storing larger amounts of data in a cost-effective manner.</p>
               <p>This chapter contains the following sections:</p>
               <ul style="list-style-type: disc;">
                  <li>
                     <p><a href="partition-oltp.html#GUID-0BC75680-5BD4-43A9-826F-CD8837D30EB2" title="An Online Transaction Processing (OLTP) system is a common data processing system in today's enterprises. Classic examples of OLTP systems are order entry, retail sales, and financial transaction systems.">What Is an Online Transaction Processing System?</a></p>
                  </li>
                  <li>
                     <p><a href="partition-oltp.html#GUID-03522F8E-BC30-4694-80D7-D9B6DE065C37" title="Performance in OLTP environments heavily relies on efficient index access, thus the choice of the most appropriate index strategy becomes crucial.">Performance in an Online Transaction Processing Environment</a></p>
                  </li>
                  <li>
                     <p><a href="partition-oltp.html#GUID-8E68D33E-2A09-47A6-94BF-AF036AAE6659" title="In addition to the performance benefits, partitioning also enables the optimal data management for large objects in an OLTP environment.">Manageability in an Online Transaction Processing Environment</a></p>
                  </li>
               </ul>
            </div><a id="VLDBG1367"></a><div class="props_rev_3"><a id="GUID-0BC75680-5BD4-43A9-826F-CD8837D30EB2" name="GUID-0BC75680-5BD4-43A9-826F-CD8837D30EB2"></a><h3 id="VLDBG-GUID-0BC75680-5BD4-43A9-826F-CD8837D30EB2" class="sect3">What Is an Online Transaction Processing System?</h3>
               <div>
                  <p>An Online Transaction Processing (OLTP) system is a common data processing system in today's enterprises. Classic examples of OLTP systems are order entry, retail sales, and financial transaction systems.</p>
                  <p>OLTP systems are primarily characterized through a specific data usage that is different from data warehouse environments, yet some characteristics, such as having large volumes of data and lifecycle-related data usage and importance, are identical.</p>
                  <p>The main characteristics of an OLTP environment are:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>Short response time</p>
                        <p>The nature of OLTP environments is predominantly any kind of interactive ad hoc usage, such as telemarketers entering telephone survey results. OLTP systems require short response times in order for users to remain productive. </p>
                     </li>
                     <li>
                        <p>Small transactions</p>
                        <p>OLTP systems typically read and manipulate highly selective, small amounts of data; the data processing is mostly simple and complex joins are relatively rare. There is always a mix of queries and DML workload. For example, one of many call center employees retrieves customer details for every call and enters customer complaints while reviewing past communications with the customer.</p>
                     </li>
                     <li>
                        <p>Data maintenance operations</p>
                        <p>It is not uncommon to have reporting programs and data updating programs that must run either periodically or on an ad hoc basis. These programs, which run in the background while users continue to work on other tasks, may require a large number of data-intensive computations. For example, a university may start batch jobs assigning students to classes while students can still sign up online for classes themselves.</p>
                     </li>
                     <li>
                        <p>Large user populations</p>
                        <p>OLTP systems can have enormously large user populations where many users are trying to access the same data at the same time. For example, an online auction website can have hundreds of thousands (if not millions) of users accessing data on its website at the same time. </p>
                     </li>
                     <li>
                        <p>High concurrency</p>
                        <p>Due to the large user population, the short response times, and small transactions, the concurrency in OLTP environments is very high. A requirement for thousands of concurrent users is not uncommon.</p>
                     </li>
                     <li>
                        <p>Large data volumes</p>
                        <p>Depending on the application type, the user population, and the data retention time, OLTP systems can become very large. For example, every customer of a bank could have access to the online banking system which shows all their transactions for the last 12 months.</p>
                     </li>
                     <li>
                        <p>High availability</p>
                        <p>The availability requirements for OLTP systems are often extremely high. An unavailable OLTP system can impact a very large user population, and organizations can suffer major losses if OLTP systems are unavailable. For example, a stock exchange system has extremely high availability requirements during trading hours.</p>
                     </li>
                     <li>
                        <p>Lifecycle-related data usage</p>
                        <p>Similar to data warehousing environments, OLTP systems often experience different data access patterns over time. For example, at the end of the month, monthly interest is calculated for every active account.</p>
                     </li>
                  </ul>
                  <p>The following are benefits of partitioning for OLTP environments:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>Support for bigger databases</p>
                        <p>Backup and recovery, as part of a high availability strategy, can be performed on a low level of granularity to efficiently manage the size of the database. OLTP systems usually remain online during backups and users may continue to access the system while the backup is running. The backup process should not introduce major performance degradation for the online users.</p>
                        <p>Partitioning helps to reduce the space requirements for the OLTP system because part of a database object can be stored compressed while other parts can remain uncompressed. Update transactions against uncompressed rows are more efficient than updates on compressed data.</p>
                        <p>Partitioning can store data transparently on different storage tiers to lower the cost of retaining vast amounts of data.</p>
                     </li>
                     <li>
                        <p>Partition maintenance operations for data maintenance (instead of DML)</p>
                        <p>For data maintenance operations (purging being the most common operation), you can leverage partition maintenance operations with the Oracle Database capability of online index maintenance. A partition management operation generates less redo than the equivalent DML operations.</p>
                     </li>
                     <li>
                        <p>Potential higher concurrency through elimination of hot spots</p>
                        <p>A common scenario for OLTP environments is to have monotonically increasing index values that are used to enforce primary key constraints, thus creating areas of high concurrency and potential contention: every new insert tries to update the same set of index blocks. Partitioned indexes, in particular hash partitioned indexes, can help alleviate this situation.</p>
                     </li>
                  </ul>
               </div>
            </div><a id="VLDBG1368"></a><div class="props_rev_3"><a id="GUID-03522F8E-BC30-4694-80D7-D9B6DE065C37" name="GUID-03522F8E-BC30-4694-80D7-D9B6DE065C37"></a><h3 id="VLDBG-GUID-03522F8E-BC30-4694-80D7-D9B6DE065C37" class="sect3">Performance in an Online Transaction Processing Environment</h3>
               <div>
                  <p>Performance in OLTP environments heavily relies on efficient index access, thus the choice of the most appropriate index strategy becomes crucial.</p>
                  <p>The following sections discuss best practices for deciding whether to partition indexes in an OLTP environment.</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="partition-oltp.html#GUID-F9597715-E1C0-4986-B83E-99363D59214E" title="Due to the selectivity of queries and high concurrency of OLTP applications, the choice of the right index strategy is indisputably an important decision for the use of partitioning in an OLTP environment. With less contention, the application can support a larger user population.">Deciding Whether to Partition Indexes</a></p>
                     </li>
                     <li>
                        <p><a href="partition-oltp.html#GUID-E45059AC-AA45-462E-8054-EF50CA37D69C" title="When your workload fits the use of index-organized tables, then you must consider how to use partitioning on your index-organized table and on any secondary indexes.">How to Use Partitioning on Index-Organized Tables</a></p>
                     </li>
                  </ul>
               </div><a id="VLDBG14082"></a><a id="VLDBG1369"></a><div class="props_rev_3"><a id="GUID-F9597715-E1C0-4986-B83E-99363D59214E" name="GUID-F9597715-E1C0-4986-B83E-99363D59214E"></a><h4 id="VLDBG-GUID-F9597715-E1C0-4986-B83E-99363D59214E" class="sect4">Deciding Whether to Partition Indexes</h4>
                  <div>
                     <p>Due to the selectivity of queries and high concurrency of OLTP applications, the choice of the right index strategy is indisputably an important decision for the use of partitioning in an OLTP environment. With less contention, the application can support a larger user population. </p>
                     <p>The following basic rules explain the main benefits and trade-offs for the various possible index structures:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>A nonpartitioned index, while larger than individual partitioned index segments, always leads to a single index probe (or scan) if an index access path is chosen; there is only one segment for a table. The data access time and number of blocks being accessed are identical for both a partitioned and a nonpartitioned table.</p>
                           <p>A nonpartitioned index does not provide partition autonomy and requires an index maintenance operation for every partition maintenance operation that affects rowids (for example, drop, truncate, move, merge, coalesce, or split operations).</p>
                        </li>
                        <li>
                           <p>With partitioned indexes, there are always multiple segments. Whenever Oracle Database cannot prune down to a single index segment, the database has to access multiple segments. This potentially leads to higher I/O requirements (<span class="italic">n</span> index segment probes compared with one probe for a nonpartitioned index) and can have an impact (measurable or not) on the run-time performance. This is true for all partitioned indexes.
                           </p>
                           <p>Partitioned indexes can either be local partitioned indexes or global partitioned indexes. Local partitioned indexes always inherit the partitioning key from the table and are fully aligned with the table partitions. Consequently, any kind of partition maintenance operation requires little to no index maintenance work. For example, dropping or truncating a partition does not incur any measurable overhead for index maintenance; the local index partitions are either dropped or truncated.</p>
                           <p>Partitioned indexes that are not aligned with the table are called global partitioned indexes. Unlike local indexes, there is no relation between a table and an index partition. Global partitioned indexes give the flexibility to choose a partitioning key that is optimal for an efficient partition index access. Partition maintenance operations normally affect more (if not all) partitions of a global partitioned index, depending on the operation and partitioning key of the index.</p>
                        </li>
                        <li>
                           <p>Under some circumstances, having multiple segments for an index can be beneficial for performance. It is very common in OLTP environments to use sequences to create artificial keys. Consequently, you create key values that are monotonically increasing, which results in many insertion processes competing for the same index blocks. Introducing a global partitioned index (for example, using global hash partitioning on the key column) can alleviate this situation. If you have, for example, four hash partitions for such an index, then you now have four index segments into which you are inserting data, reducing the concurrency on these segments by a factor of four for the insertion processes.</p>
                        </li>
                     </ul>
                     <p>Enforcing uniqueness is important database functionality for OLTP environments. Uniqueness can be enforced with nonpartitioned and partitioned indexes. However, because partitioned indexes provide partition autonomy, the following requirements must be met to implement unique indexes:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>A nonpartitioned index can enforce uniqueness for any given column or combination of columns. The behavior of a nonpartitioned index is no different for a partitioned table compared to a nonpartitioned table.</p>
                        </li>
                        <li>
                           <p>Each partition of a partitioned index is considered an autonomous segment. To enforce the autonomy of these segments, you always have to include the partitioning key columns as a subset of the unique key definition.</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>Global partitioned indexes must always be prefixed with at least the first leading column of the index column (the partitioning column of the partitioned global index).</p>
                              </li>
                              <li>
                                 <p>Unique local indexes must have the partitioning key of the table as a subset of the unique key definition.</p>
                              </li>
                           </ul>
                        </li>
                     </ul>
                     <p><a href="partition-oltp.html#GUID-F9597715-E1C0-4986-B83E-99363D59214E__BABJFAFG">Example 7-1</a> shows the creation of a unique index on the <code class="codeph">order_id</code> column of the <code class="codeph">orders_oltp</code> table. The <code class="codeph">order_id</code> in the OLTP application is filled using a sequence number. The unique index uses hash partitioning to reduce contention for the monotonically increasing <code class="codeph">order_id</code> values. The unique key is then used to create the primary key constraint.
                     </p>
                     <div class="example" id="GUID-F9597715-E1C0-4986-B83E-99363D59214E__BABJFAFG">
                        <p class="titleinexample">Example 7-1 Creating a unique index and primary key constraint</p><pre class="oac_no_warn" dir="ltr">CREATE UNIQUE INDEX orders_pk
  ON orders_oltp(order_id)
  GLOBAL PARTITION BY HASH (order_id)
  ( PARTITION p1 TABLESPACE tbs1
   , PARTITION p2 TABLESPACE tbs2
   , PARTITION p3 TABLESPACE tbs3
   , PARTITION p4 TABLESPACE tbs4
  ) NOLOGGING;

ALTER TABLE orders_oltp ADD CONSTRAINT orders_pk
  PRIMARY KEY (order_id)
  USING INDEX;
</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="VLDBG1370"></a><div class="props_rev_3"><a id="GUID-E45059AC-AA45-462E-8054-EF50CA37D69C" name="GUID-E45059AC-AA45-462E-8054-EF50CA37D69C"></a><h4 id="VLDBG-GUID-E45059AC-AA45-462E-8054-EF50CA37D69C" class="sect4">How to Use Partitioning on Index-Organized Tables</h4>
                  <div>
                     <p>When your workload fits the use of index-organized tables, then you must consider how to use partitioning on your index-organized table and on any secondary indexes.</p>
                     <p>You must decide whether to partition secondary indexes on index-organized tables based on the same considerations as indexes on regular heap tables. You can partition an index-organized table, but the partitioning key must be a subset of the primary key. A common reason to partition an index-organized table is to reduce contention; this is typically achieved using hash partitioning.</p>
                     <p>Another reason to partition an index-organized table is to be able to physically separate data sets based on a primary key column. For example, an application-hosting company can physically separate application instances for different customers by list partitioning on the company identifier. Queries in such a scenario can often take advantage of index partition pruning, shortening the time for the index scan. ILM scenarios with index-organized tables and partitioning are less common because they require a date column to be part of the primary key.</p>
                     <p>For more information about how to create partitioned index-organized tables, refer to <a href="partition-admin.html#GUID-F2C99CFA-1090-4A62-B452-D4E116A40A34" title="Partition administration is an important task when working with partitioned tables and indexes.">Partition Administration</a>.
                     </p>
                     <div class="infoboxnotealso" id="GUID-E45059AC-AA45-462E-8054-EF50CA37D69C__GUID-C27EB6FD-676E-49FC-9E7F-080CA8DC9EBD">
                        <p class="notep1">See Also:</p>
                        <p><a href="../admin/managing-tables.html#ADMIN01506" target="_blank"><span><cite>Oracle Database Administrator’s Guide</cite></span></a> for more information about index-organized tables
                        </p>
                     </div>
                  </div>
               </div>
            </div><a id="VLDBG1371"></a><div class="props_rev_3"><a id="GUID-8E68D33E-2A09-47A6-94BF-AF036AAE6659" name="GUID-8E68D33E-2A09-47A6-94BF-AF036AAE6659"></a><h3 id="VLDBG-GUID-8E68D33E-2A09-47A6-94BF-AF036AAE6659" class="sect3">Manageability in an Online Transaction Processing Environment</h3>
               <div>
                  <p>In addition to the performance benefits, partitioning also enables the optimal data management for large objects in an OLTP environment. </p>
                  <p>Every partition maintenance operation in Oracle Database can be extended to atomically include global and local index maintenance, enabling the execution of any partition maintenance operation without affecting the 24x7 availability of an OLTP environment.</p>
                  <p>Partition maintenance operations in OLTP systems occur often because of ILM scenarios. In these scenarios, [range | interval] partitioned tables, or [range | interval]-* composite partitioned tables, are common.</p>
                  <p>Some business cases for partition maintenance operations include scenarios surrounding the separation of application data. For example, a retail company runs the same application for multiple branches in a single schema. Depending on the branch revenues, the application (as separate partitions) is stored on more efficient storage. List partitioning, or list-* composite partitioning, is a common partitioning strategy for this type of business case.</p>
                  <p>You can use hash partitioning, or hash subpartitioning for tables, in OLTP systems to obtain similar performance benefits to the performance benefits achieved in data warehouse environments. The majority of the daily OLTP workload consists of relatively small operations, executed serially. Periodic batch operations, however, may execute in parallel and benefit from the distribution improvements that hash partitioning and subpartitioning can provide for partition-wise joins. For example, end-of-the-month interest calculations may be executed in parallel to complete within a nightly batch window.</p>
                  <p>This section contains the following topics:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="partition-oltp.html#GUID-61F68DF0-78AC-4680-8AB7-4F8A43199EE9" title="When a partition maintenance operation takes place, Oracle Database locks the affected table partitions for any DML operation, except in the case of an ONLINE MOVE.">Impact of a Partition Maintenance Operation on a Partitioned Table with Local Indexes</a></p>
                     </li>
                     <li>
                        <p><a href="partition-oltp.html#GUID-A22047D9-61D1-4C00-8C1C-0F7E5C7D4F5B" title="Whenever a global index is defined on a partitioned or nonpartitioned table, there is no correlation between a distinct table partition and the index. Consequently, any partition maintenance operation affects all global indexes or index partitions.">Impact of a Partition Maintenance Operation on Global Indexes</a></p>
                     </li>
                     <li>
                        <p><a href="partition-oltp.html#GUID-3540CE58-1D0F-47E2-B98C-F0213E3A2AFD" title="The two most common partition maintenance operations are the removal of data and the relocation of data onto lower-cost storage tier devices.">Common Partition Maintenance Operations in OLTP Environments</a></p>
                     </li>
                  </ul>
                  <p>For more information about the performance benefits of partitioning, refer to <a href="partition-availability.html#GUID-FA29787B-8700-49EA-B80D-54D667CF2752" title="Partitioning enables availability, manageability, and performance.">Partitioning for Availability, Manageability, and Performance</a>.
                  </p>
               </div><a id="VLDBG1372"></a><div class="props_rev_3"><a id="GUID-61F68DF0-78AC-4680-8AB7-4F8A43199EE9" name="GUID-61F68DF0-78AC-4680-8AB7-4F8A43199EE9"></a><h4 id="VLDBG-GUID-61F68DF0-78AC-4680-8AB7-4F8A43199EE9" class="sect4">Impact of a Partition Maintenance Operation on a Partitioned Table with Local Indexes</h4>
                  <div>
                     <p>When a partition maintenance operation takes place, Oracle Database locks the affected table partitions for any DML operation, except in the case of an <code class="codeph">ONLINE</code> <code class="codeph">MOVE</code>. 
                     </p>
                     <p>Data in the affected partitions, except a <code class="codeph">DROP</code> or <code class="codeph">TRUNCATE</code> operation, is still fully accessible for any <code class="codeph">SELECT</code> operation. Because local indexes are logically coupled with the table (data) partitions, only the local index partitions of the affected table partitions have to be maintained as part of a partition maintenance operation, enabling optimal processing for the index maintenance.
                     </p>
                     <p>For example, when you move an older partition from a high-end storage tier to a low-cost storage tier using the <code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">MOVE</code> <code class="codeph">ONLINE</code> functionality, the data and the index are always available for <code class="codeph">SELECT</code> and DML operations; the necessary index maintenance is to update the existing index partition to reflect the new physical location of the data. If you drop an older partition after you have archived it, then its local index partitions get dropped as well, and for global indexes the orphaned entries for the removed partitions get marked, enabling a split-second partition maintenance operation that affects only the data dictionary.
                     </p>
                  </div>
               </div><a id="VLDBG1373"></a><div class="props_rev_3"><a id="GUID-A22047D9-61D1-4C00-8C1C-0F7E5C7D4F5B" name="GUID-A22047D9-61D1-4C00-8C1C-0F7E5C7D4F5B"></a><h4 id="VLDBG-GUID-A22047D9-61D1-4C00-8C1C-0F7E5C7D4F5B" class="sect4">Impact of a Partition Maintenance Operation on Global Indexes</h4>
                  <div>
                     <p>Whenever a global index is defined on a partitioned or nonpartitioned table, there is no correlation between a distinct table partition and the index. Consequently, any partition maintenance operation affects all global indexes or index partitions. </p>
                     <p>The partitions of tables containing local indexes are locked to prevent DML operations against the affect table partitions, except for an <code class="codeph">ONLINE</code> <code class="codeph">MOVE</code> operation. However, unlike the index maintenance for local indexes, any global index is still fully available for DML operations and does not affect the online availability of the OLTP system.
                     </p>
                     <p>Conceptually and technically, the index maintenance for global indexes for a partition maintenance operation is comparable to the index maintenance that would become necessary for a semantically identical DML operation, except for <code class="codeph">DROP</code> and <code class="codeph">TRUNCATE</code> where the global index maintenance gets delayed to a later point in time. For more information about managing global indexes, refer to <a href="index-partitioning.html#GUID-63785C41-80E1-4224-8CA5-D0A815B43FCF" title="Management of global partitioned indexes presents several challenges.">Management of Global Partitioned Indexes</a>.
                     </p>
                     <p>For example, dropping an old partition is semantically equivalent to deleting all the records of the old partition using the SQL <code class="codeph">DELETE</code> statement. In the DML case, all index entries of the deleted data set have to be removed from any global index as a standard index maintenance operation, which does not affect the availability of an index for <code class="codeph">SELECT</code> and DML operations. 
                     </p>
                     <p>The <code class="codeph">DROP</code> <code class="codeph">PARTITION</code> also does not affect the index availability, but enables you to decouple the necessary index maintenance from the initial data removal without affecting the availability of the global indexes. In this scenario, a drop operation represents the optimal approach: data is removed without the overhead of a conventional <code class="codeph">DELETE</code> operation and the global indexes are maintained in a nonintrusive manner.
                     </p>
                  </div>
               </div><a id="VLDBG1374"></a><div class="props_rev_3"><a id="GUID-3540CE58-1D0F-47E2-B98C-F0213E3A2AFD" name="GUID-3540CE58-1D0F-47E2-B98C-F0213E3A2AFD"></a><h4 id="VLDBG-GUID-3540CE58-1D0F-47E2-B98C-F0213E3A2AFD" class="sect4">Common Partition Maintenance Operations in OLTP Environments</h4>
                  <div>
                     <p>The two most common partition maintenance operations are the removal of data and the relocation of data onto lower-cost storage tier devices.</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="partition-oltp.html#GUID-AE66EA32-E8F4-47D1-80F0-A955CA326E08" title="Using either a DROP or TRUNCATE operation removes older data based on the partitioning key criteria.">Removing (Purging) Old Data</a></p>
                        </li>
                        <li>
                           <p><a href="partition-oltp.html#GUID-FB5897E5-FB6D-441B-8906-2A8D3DE7A5CB" title="Using a MOVE or MERGE operation as part of an Information Lifecycle Management (ILM) strategy, you can relocate older partitions to the most cost-effective storage tier.">Moving or Merging Older Partitions to a Low-Cost Storage Tier Device</a></p>
                        </li>
                     </ul>
                  </div><a id="VLDBG1375"></a><div class="props_rev_3"><a id="GUID-AE66EA32-E8F4-47D1-80F0-A955CA326E08" name="GUID-AE66EA32-E8F4-47D1-80F0-A955CA326E08"></a><h5 id="VLDBG-GUID-AE66EA32-E8F4-47D1-80F0-A955CA326E08" class="sect5">Removing (Purging) Old Data</h5>
                     <div>
                        <p>Using either a <code class="codeph">DROP</code> or <code class="codeph">TRUNCATE</code> operation removes older data based on the partitioning key criteria.
                        </p>
                        <p>The drop operation removes the data and the partition metadata, while a <code class="codeph">TRUNCATE</code> operation removes only the data but preserve the metadata. All local index partitions are dropped respectively, and truncated. Asynchronous global index maintenance is done for partitioned or nonpartitioned global indexes and is fully available for select and DML operations.
                        </p>
                        <p>The following example drops all data older than January 2006 from the <code class="codeph">orders_oltp</code> table. As part of the drop statement, an <code class="codeph">UPDATE GLOBAL INDEXES</code> statement is executed, so that the global index remains usable throughout the maintenance operation. Any local index partitions are dropped as part of this operation.
                        </p><pre class="oac_no_warn" dir="ltr">ALTER TABLE orders_oltp DROP PARTITION p_before_jan_2006
 UPDATE GLOBAL INDEXES;</pre></div>
                  </div><a id="VLDBG1376"></a><div class="props_rev_3"><a id="GUID-FB5897E5-FB6D-441B-8906-2A8D3DE7A5CB" name="GUID-FB5897E5-FB6D-441B-8906-2A8D3DE7A5CB"></a><h5 id="VLDBG-GUID-FB5897E5-FB6D-441B-8906-2A8D3DE7A5CB" class="sect5">Moving or Merging Older Partitions to a Low-Cost Storage Tier Device</h5>
                     <div>
                        <p>Using a <code class="codeph">MOVE</code> or <code class="codeph">MERGE</code> operation as part of an Information Lifecycle Management (ILM) strategy, you can relocate older partitions to the most cost-effective storage tier. 
                        </p>
                        <p>Using the <code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">ONLINE</code> <code class="codeph">MOVE</code> functionality enables the data to be available for both queries and DML operations. Local indexes are maintained and likely relocated as part of the merge or move operation. The standard index maintenance is done for partitioned or nonpartitioned global indexes and is fully available for select and DML operations.
                        </p>
                        <p>The following example shows how to merge the January 2006 and February 2006 partitions in the <code class="codeph">orders_oltp</code> table, and store them in a different tablespace. Any local index partitions are also moved to the <code class="codeph">ts_low_cost</code> tablespace as part of this operation. The <code class="codeph">UPDATE INDEXES</code> clause ensures that all indexes remain usable throughout and after the operation, without additional rebuilds.
                        </p><pre class="oac_no_warn" dir="ltr">ALTER TABLE orders_oltp
  MERGE PARTITIONS p_2006_jan,p_2006_feb
  INTO PARTITION p_before_mar_2006 COMPRESS
  TABLESPACE ts_low_cost
  UPDATE INDEXES;
</pre><p>For more information about the benefits of partition maintenance operations for Information Lifecycle Management, see <a href="time-based-info.html#GUID-0193CE0F-4D9A-4D6F-8B19-E471DE94107C" title="Oracle Database provides strategies to manage and maintain data based on time.">Managing and Maintaining Time-Based Information</a>.
                        </p>
                     </div>
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>