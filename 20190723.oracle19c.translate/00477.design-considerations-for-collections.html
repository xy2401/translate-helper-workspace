<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <title>集合的设计注意事项</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Object-Relational Developer&#39;s Guide "></meta>
      <meta property="og:description" content=""></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Object-Relational Developer&#39;s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="object-relational-developers-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-11T02:05:10-08:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="1996, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96436-01"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="design-considerations-for-REFs.html" title="Previous" type="text/html"></link>
      <link rel="next" href="design-considerations-for-methods.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Object-Relational Developer&#39;s Guide"></meta>
    <meta name="dcterms.isVersionOf" content="ADOBJ"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="design-considerations-for-REFs.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="design-considerations-for-methods.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">对象关系开发人员指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="design-considerations-for-oracle-objects.html" property="item" typeof="WebPage"><span property="name">Oracle Objects的设计注意事项</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">集合的设计注意事项</li>
            </ol>
            <a id="GUID-F3904AFE-E6E3-48E9-9482-5DB98D1CD03F" name="GUID-F3904AFE-E6E3-48E9-9482-5DB98D1CD03F"></a><a id="ADOBJ00807"></a>
            
            <h2 id="ADOBJ-GUID-F3904AFE-E6E3-48E9-9482-5DB98D1CD03F" class="sect2"><span class="enumeration_section">9.4</span>集合的设计注意事项</h2>
         </header>
         <div class="ind">
            <div>
               <p>使用集合时需要考虑一些注意事项。</p>
               <p>话题：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p>
                        <a href="design-considerations-for-collections.html#GUID-CD77D40B-CCAC-4F38-9BD9-C904F35618DA" title="您可以根据刚创建的home_phones（）函数查询人员及其家庭电话号码列表。">使用Unnesting查询以关系形式查看对象数据</a></p>
                  </li>
                  <li>
                     
                     <p>
                        <a href="design-considerations-for-collections.html#GUID-92C119FE-CB10-485F-B3E9-C6DE56594650">Varrays的存储注意事项</a></p>
                     
                  </li>
                  <li>
                     <p>
                        <a href="design-considerations-for-collections.html#GUID-BEE41686-942F-4709-A359-EFF5426EA5AE">Varrays与嵌套表的性能</a></p>
                     
                  </li>
                  <li>
                     <p>
                        <a href="design-considerations-for-collections.html#GUID-75F19B20-952E-46B5-B814-938E76FF716B">嵌套表的设计注意事项</a></p>
                  </li>
                  <li>
                     
                     <p>
                        <a href="design-considerations-for-collections.html#GUID-C50A1468-81D3-4C85-BAAF-AC83F4C2A10D" title="您可以嵌套集合类型以创建真正的多级集合。">多级集合的设计注意事项</a></p>
                  </li>
               </ul>
            </div><a id="ADOBJ7445"></a><a id="ADOBJ7444"></a><div class="props_rev_3"><a id="GUID-CD77D40B-CCAC-4F38-9BD9-C904F35618DA" name="GUID-CD77D40B-CCAC-4F38-9BD9-C904F35618DA"></a><h3 id="ADOBJ-GUID-CD77D40B-CCAC-4F38-9BD9-C904F35618DA" class="sect3"><span class="enumeration_section">9.4.1</span>使用Unnesting查询以关系形式查看对象数据</h3>
               <div>
                  <div class="section">
                     <p>对集合的不需要的查询允许以平面（关系）形式查看数据。</p>
                     <p>您可以在单级和。上执行不需要的查询<a id="d34147e164" class="indexterm-anchor"></a><a id="d34147e168" class="indexterm-anchor"></a>嵌套表或varrays的多级集合。
                     </p>
                     <p>使用<code class="codeph">TABLE</code>语法可以为查询取消嵌套表，如下例所示：</p>
                  </div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-CD77D40B-CCAC-4F38-9BD9-C904F35618DA__GUID-9E879858-C6E3-45B8-8528-331E1DE9251C">
                     <p class="titleinexample">示例9-4使用TABLE函数解嵌嵌套表</p><pre class="oac_no_warn" dir="ltr">SELECT p.name_obj，n.num FROM people_reltab p，TABLE（p.phones_ntab）n;</pre></div>
                  <!-- class="example" -->
                  <div class="section">
                     <p>这里， <code class="codeph">phones_ntab</code>指定了<code class="codeph">phones_ntab</code>嵌套表的属性。要检索没有子行的父行（在这种情况下没有电话号码），请使用外部联接语法和<code class="codeph">+</code> 。例如：</p><pre class="oac_no_warn" dir="ltr">SELECT p.name_obj，n.num FROM people_reltab p，TABLE（p.phones_ntab）（+）n;</pre><p>如果查询的<code class="codeph">SELECT</code>列表未引用除嵌套表列之外的父表中的任何列，则查询将优化为仅针对嵌套表的存储表执行。
                     </p>
                     <p>对于varrays而言，不需要的查询语法与嵌套表相同。例如，假设<code class="codeph">phones_ntab</code>嵌套表是一个名为<code class="codeph">phones_var</code> 。以下示例显示如何使用<code class="codeph">TABLE</code>语法查询varray：</p><pre class="pre codeblock"><code>SELECT p.name_obj，v.num FROM people_reltab p，TABLE（p.phones_var）v;</code></pre></div>
                  <!-- class="section" -->
               </div><a id="ADOBJ7447"></a><a id="ADOBJ7446"></a><div class="props_rev_3"><a id="GUID-14A861C3-E6F9-4D05-88C3-0EF915AE7932" name="GUID-14A861C3-E6F9-4D05-88C3-0EF915AE7932"></a><h4 id="ADOBJ-GUID-14A861C3-E6F9-4D05-88C3-0EF915AE7932" class="sect4"><span class="enumeration_section">9.4.1.1</span>创建程序和函数以统一查询</h4>
                  <div>
                     <div class="section">
                        <p>您可以创建可以执行的过程和函数来执行不需要的查询。例如，您可以创建一个名为<code class="codeph">home_phones()</code>的函数，该函数仅返回<code class="codeph">location</code>为<code class="codeph">home</code>的电话号码。要创建<code class="codeph">home_phones()</code>函数，请输入如下代码：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-14A861C3-E6F9-4D05-88C3-0EF915AE7932__GUID-F21C96C9-0AA3-42B8-9DC7-29BFC52BA566">
                        <p class="titleinexample">示例9-5创建home_phones功能</p><pre class="oac_no_warn" dir="ltr">创建或替换功能home_phones（all phone in phone_ntabtyp）RETURN phone_ntabtyp IS homephones phone_ntabtyp：= phone_ntabtyp（）; indx1号码; indx2数字：= 0;开始为indx1 IN 1 ..allphones.count LOOP如果所有电话（indx1）.location ='home'那么homephones.extend; - 扩展本地集合indx2：= indx2 + 1; homephones（indx2）：= allphones（indx1）;万一;结束循环;返回家庭电话;结束; /</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="ADOBJ7448"></a><div class="props_rev_3"><a id="GUID-23FF7B9D-2789-42F9-A6A6-516DA66C480D" name="GUID-23FF7B9D-2789-42F9-A6A6-516DA66C480D"></a><h4 id="ADOBJ-GUID-23FF7B9D-2789-42F9-A6A6-516DA66C480D" class="sect4"><span class="enumeration_section">9.4.1.2</span>查询TABLE函数到Unnest数据</h4>
                  <div>
                     <p>您可以根据刚刚创建的<code class="codeph">home_phones()</code>函数查询人员及其家庭电话号码列表。
                     </p>
                     <div class="example" id="GUID-23FF7B9D-2789-42F9-A6A6-516DA66C480D__GUID-EEF0E0EB-4A90-4E5D-9DC0-E81DD8BB61EE">
                        <p class="titleinexample">例9-6查询电话号码</p>
                        <p>见<a href="design-considerations-for-collections.html#GUID-14A861C3-E6F9-4D05-88C3-0EF915AE7932__GUID-F21C96C9-0AA3-42B8-9DC7-29BFC52BA566">例9-5</a></p><pre class="oac_no_warn" dir="ltr">SELECT p.name_obj，n.num FROM people_reltab p，TABLE（CAST（ <span class="bold">home_phones</span> （p.phones_ntab）AS phone_ntabtyp））n;</pre><p>要查询人员及其家庭电话号码列表（包括未列出家庭电话号码的人员），请输入以下内容：</p><pre class="oac_no_warn" dir="ltr">SELECT p.name_obj，n.num FROM people_reltab p，TABLE（CAST（home_phones（p.phones_ntab）AS phone_ntabtyp））（+）n;</pre><div class="infoboxnotealso" id="GUID-23FF7B9D-2789-42F9-A6A6-516DA66C480D__GUID-F291FD21-3BA8-45A8-9DF6-EA1E06265B52">
                           <p class="notep1">也可以看看：</p>
                           <p>有关<code class="codeph">TABLE</code>函数的更多信息，请<a href="../sqlrf/Introduction-to-Oracle-SQL.html#SQLRF001" target="_blank"><span class="italic">参见Oracle数据库SQL语言参考</span></a>和<a href="../addci/using-pipelined-and-parallel-table-functions.html#ADDCI2140" target="_blank"><span class="italic">Oracle数据库数据盒开发人员指南</span></a></p>
                        </div>
                     </div>
                     <!-- class="example" -->
                  </div>
               </div>
            </div><a id="ADOBJ7449"></a><div class="props_rev_3"><a id="GUID-92C119FE-CB10-485F-B3E9-C6DE56594650" name="GUID-92C119FE-CB10-485F-B3E9-C6DE56594650"></a><h3 id="ADOBJ-GUID-92C119FE-CB10-485F-B3E9-C6DE56594650" class="sect3"><span class="enumeration_section">9.4.2</span> Varrays的存储注意事项</h3>
               <div>
                  <p>存储的varray的大小仅取决于varray中元素数量的当前计数，而不取决于它可以容纳的最大元素数。</p>
                  <p>由于varrays的存储会产生一些开销，例如null信息，因此存储的varray的大小可能略大于元素的大小乘以count。</p>
                  <p>Varrays作为原始值或<code class="codeph">LOB</code>存储在列中。Oracle根据使用声明的varray的<code class="codeph">LIMIT</code>计算的varray的最大可能大小，决定在定义varray时如何存储varray。如果大小超过大约4000字节，那么varray存储在<code class="codeph">LOB</code> 。否则，varray作为原始值存储在列本身中。此外，Oracle支持内联LOB，这意味着适合大型varray的前4000个字节的元素，以及为LOB定位符保留的一些字节，都存储在行的列中。另请参见<a href="../adlob/introduction-to-large-objects.html#ADLOB001" target="_blank"><span class="italic">Oracle Database SecureFiles和Large Objects Developer's Guide</span></a> 。
                  </p>
               </div><a id="ADOBJ7450"></a><div class="props_rev_3"><a id="GUID-9EA1444F-A46A-4230-B0E3-FD6A57B246C1" name="GUID-9EA1444F-A46A-4230-B0E3-FD6A57B246C1"></a><h4 id="ADOBJ-GUID-9EA1444F-A46A-4230-B0E3-FD6A57B246C1" class="sect4"><span class="enumeration_section">9.4.2.1</span>关于传播VARRAY大小更改</h4>
                  <div>
                     <p>更改<code class="codeph">VARRAY</code>类型的大小时，会为从属类型生成新类型的版本。
                     </p>
                     <p>当<code class="codeph">VARRAY</code>列未显式存储为LOB且其最大大小最初小于4000字节时，请务必注意这一点。如果增加后大小大于或等于4000字节，则<code class="codeph">VARRAY</code>列必须存储为LOB。这需要额外的操作来升级<code class="codeph">VARRAY</code>列的元数据，以便设置必要的LOB元数据信息，包括LOB段和LOB索引。
                     </p>
                     <p><code class="codeph">ALTER</code> <code class="codeph">TYPE</code>语句中的<code class="codeph">CASCADE</code>选项将<code class="codeph">VARRAY</code>大小更改传播到其依赖类型和表。为每个有效的依赖类型生成新版本，并且相应地基于先前描述的不同情况场景更新依赖表元数据。如果<code class="codeph">VARRAY</code>列位于群集表中，则带有<code class="codeph">CASCADE</code>选项的<code class="codeph">ALTER</code> <code class="codeph">TYPE</code>语句将失败，因为群集表不支持LOB。</p>
                     <p><code class="codeph">ALTER</code> <code class="codeph">TYPE</code>语句中的<code class="codeph">CASCADE</code>选项还提供<code class="codeph">[NOT]</code> <code class="codeph">INCLUDING</code> <code class="codeph">TABLE</code> <code class="codeph">DATA</code>选项。<code class="codeph">NOT</code> <code class="codeph">INCLUDING</code> <code class="codeph">TABLE</code> <code class="codeph">DATA</code>选项仅更新<code class="codeph">TABLE</code>的元数据，但不转换数据映像。要将<code class="codeph">VARRAY</code>映像转换为最新版本格式，可以在<code class="codeph">ALTER</code> <code class="codeph">TYPE</code> <code class="codeph">CASCADE</code>语句中显式指定<code class="codeph">INCLUDING</code> <code class="codeph">TABLE</code> <code class="codeph">DATA</code> ，也可以发出<code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">UPGRADE</code>语句。
                     </p>
                  </div>
               </div>
            </div><a id="ADOBJ7452"></a><a id="ADOBJ7453"></a><a id="ADOBJ7451"></a><div class="props_rev_3"><a id="GUID-BEE41686-942F-4709-A359-EFF5426EA5AE" name="GUID-BEE41686-942F-4709-A359-EFF5426EA5AE"></a><h3 id="ADOBJ-GUID-BEE41686-942F-4709-A359-EFF5426EA5AE" class="sect3"><span class="enumeration_section">9.4.3</span>变量与嵌套表的性能</h3>
               <div>
                  <p>如果将整个集合作为应用程序中的单个单元进行操作，则varrays的执行效果要比嵌套表好得多。与嵌套表不同，varray是打包存储的，不需要连接来检索数据。</p>
                  <div class="section">
                     <p class="subhead2" id="GUID-BEE41686-942F-4709-A359-EFF5426EA5AE__GUID-19A4E9E7-9E11-4BCC-83E1-9031B12B2F68">Varray查询</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p>可以使用不需要的语法来访问varray列，类似于用于访问嵌套表的方式。有关详细信息，请参阅<span class="q">“ <a href="design-considerations-for-collections.html#GUID-CD77D40B-CCAC-4F38-9BD9-C904F35618DA" title="您可以根据刚创建的home_phones（）函数查询人员及其家庭电话号码列表。">使用Unnesting查询以关系形式查看对象数据</a> ”</span> 。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-BEE41686-942F-4709-A359-EFF5426EA5AE__GUID-09BE72C4-88F3-4BB9-A85B-E36F06233B8B">Varray更新</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p>不支持分段更新varray值。因此，当更新varray时，整个旧集合将被新集合替换。</p>
                  </div>
                  <!-- class="section" -->
               </div>
            </div><a id="ADOBJ7454"></a><div class="props_rev_3"><a id="GUID-75F19B20-952E-46B5-B814-938E76FF716B" name="GUID-75F19B20-952E-46B5-B814-938E76FF716B"></a><h3 id="ADOBJ-GUID-75F19B20-952E-46B5-B814-938E76FF716B" class="sect3"><span class="enumeration_section">9.4.4</span>嵌套表的设计注意事项</h3>
               <div>
                  <p>话题：</p>
                  <p>使用嵌套表有几个设计注意事项。</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="design-considerations-for-collections.html#GUID-474BD701-F7A2-435B-AE93-00B5B3AD974B">嵌套表存储</a></p>
                     </li>
                     <li>
                        <p><a href="design-considerations-for-collections.html#GUID-1DA271C6-48E6-4FD7-B250-C54A9146F168">嵌套表索引</a></p>
                     </li>
                     <li>
                        <p><a href="design-considerations-for-collections.html#GUID-1CCB041E-AE30-4732-B39B-695E3291DC57">嵌套表定位器</a></p>
                     </li>
                     <li>
                        <p><a href="design-considerations-for-collections.html#GUID-12CE90BB-B224-4730-9851-8A6935A0AAEC">设置会员资格查询优化</a></p>
                     </li>
                  </ul>
               </div><a id="ADOBJ7456"></a><a id="ADOBJ7455"></a><div class="props_rev_3"><a id="GUID-474BD701-F7A2-435B-AE93-00B5B3AD974B" name="GUID-474BD701-F7A2-435B-AE93-00B5B3AD974B"></a><h4 id="ADOBJ-GUID-474BD701-F7A2-435B-AE93-00B5B3AD974B" class="sect4"><span class="enumeration_section">9.4.4.1</span>嵌套表存储</h4>
                  <div>
                     <p>Oracle将嵌套表的行存储在单独的存储表中。系统生成的<code class="codeph">NESTED_TABLE_ID</code> （长度为16个字节）将父行与其相应存储表中的行相关联。
                     </p>
                     <p><a href="design-considerations-for-collections.html#GUID-474BD701-F7A2-435B-AE93-00B5B3AD974B__I445616">图9-2</a>显示了存储表的工作原理。存储表包含嵌套表列中每个嵌套表的每个值。每个值占用存储表中的一行。存储表使用<code class="codeph">NESTED_TABLE_ID</code>来跟踪每个值的嵌套表。因此，在<a href="design-considerations-for-collections.html#GUID-474BD701-F7A2-435B-AE93-00B5B3AD974B__I445616">图9-2中</a> ，标识了属于嵌套表<code class="codeph">A</code>的所有值，标识了属于嵌套表<code class="codeph">B</code>所有值，依此类推。
                     </p>
                     <div class="figure" id="GUID-474BD701-F7A2-435B-AE93-00B5B3AD974B__I445616">
                        <p class="titleinfigure">图9-2嵌套表存储</p><img src="img/adobj021.gif" width="496" alt="下面是图9-2的描述" title="下面是图9-2的描述" longdesc="img_text/adobj021.html"><br><a href="img_text/adobj021.html">“图9-2嵌套表存储”的描述</a></div>
                     <!-- class="figure" -->
                  </div>
               </div><a id="ADOBJ7460"></a><div class="props_rev_3"><a id="GUID-1DA271C6-48E6-4FD7-B250-C54A9146F168" name="GUID-1DA271C6-48E6-4FD7-B250-C54A9146F168"></a><h4 id="ADOBJ-GUID-1DA271C6-48E6-4FD7-B250-C54A9146F168" class="sect4"><span class="enumeration_section">9.4.4.2</span>嵌套表索引</h4>
                  <div>
                     <p>创建存储在堆表中的嵌套表时，Oracle数据库会自动在存储表的<code class="codeph">NESTED_TABLE_ID</code>列上创建索引，并在父表的相应ID列上创建索引。
                     </p>
                     <p>在<code class="codeph">NESTED_TABLE_ID</code>列上创建索引使数据库能够更有效地访问嵌套表的子行，因为数据库必须使用<code class="codeph">NESTED_TABLE_ID</code>列在父表和嵌套表之间执行连接。
                     </p>
                  </div>
               </div><a id="ADOBJ7461"></a><div class="props_rev_3"><a id="GUID-1CCB041E-AE30-4732-B39B-695E3291DC57" name="GUID-1CCB041E-AE30-4732-B39B-695E3291DC57"></a><h4 id="ADOBJ-GUID-1CCB041E-AE30-4732-B39B-695E3291DC57" class="sect4"><span class="enumeration_section">9.4.4.3</span>嵌套表定位器</h4>
                  <div>
                     <p>对于大型子集，可以返回父行和子集的定位器，以便可以按需访问子行;子集也可以过滤。使用嵌套表定位器可以避免为每个父项不必要地传输子行。</p>
                     <p>您可以使用嵌套表定位器执行以下任一操作来访问子行：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>调用OCI集合函数。当您在客户端代码（例如<span class="italic"><code class="codeph">OCIColl*</code></span>函数）中访问集合的元素时，将隐式执行此操作。在第一次访问时隐式检索整个集合。
                           </p>
                           <div class="infoboxnotealso" id="GUID-1CCB041E-AE30-4732-B39B-695E3291DC57__GUID-6AFD5C6E-309F-4295-B525-06F396C2B73E">
                              <p class="notep1">也可以看看：</p>
                              <p>有关OCI收集功能的更多信息，请参阅<a href="../lnoci/oci-collection-and-iterator-functions.html#LNOCI181" target="_blank"><span class="italic">Oracle Call Interface Programmer's Guide</span></a> 。
                              </p>
                           </div>
                        </li>
                        <li>
                           <p>使用SQL检索与嵌套表对应的行。</p>
                        </li>
                     </ul>
                     <p>在多级集合中，您可以在任何嵌套级别使用具有指定集合的定位器。</p>
                     <p>以下主题指定可以将集合作为定位器检索的方式：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="design-considerations-for-collections.html#GUID-FA901FF7-1847-4A38-9FDC-E2649C5BB5C4">在表创建时间</a></p>
                        </li>
                        <li>
                           <p><a href="design-considerations-for-collections.html#GUID-8CDEBFAB-6C05-4C0D-84AA-3A917E98CC36">作为检索期间的提示</a></p>
                        </li>
                     </ul>
                  </div><a id="ADOBJ7463"></a><a id="ADOBJ7462"></a><div class="props_rev_3"><a id="GUID-FA901FF7-1847-4A38-9FDC-E2649C5BB5C4" name="GUID-FA901FF7-1847-4A38-9FDC-E2649C5BB5C4"></a><h5 id="ADOBJ-GUID-FA901FF7-1847-4A38-9FDC-E2649C5BB5C4" class="sect5"><span class="enumeration_section">9.4.4.3.1</span>表创建时间</h5>
                     <div>
                        <div class="section">
                           <p>当集合类型用作列类型并使用<code class="codeph">NESTED</code> <code class="codeph">TABLE</code>存储子句时，可以使用<code class="codeph">RETURN</code> <code class="codeph">AS</code> <code class="codeph">LOCATOR</code>子句指定要将特定集合作为定位器进行检索。
                           </p>
                           <p>例如，假设<code class="codeph">inner_table</code>是一个由三层嵌套表组成的集合类型。在以下示例中， <code class="codeph">RETURN</code> <code class="codeph">AS</code> <code class="codeph">LOCATOR</code>子句指定始终将第三级嵌套表作为定位器进行检索。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-FA901FF7-1847-4A38-9FDC-E2649C5BB5C4__GUID-D1AC8C04-C0A4-4DD6-B17C-30EDD8D44323">
                           <p class="titleinexample">例9-7使用RETURN AS LOCATOR子句</p><pre class="oac_no_warn" dir="ltr">CREATE TYPE inner_table AS TABLEBER; / CREATE TYPE middle_table AS table of inner_table; / CREATE TYPE outer_table AS TABLE of middle_table; / CREATE TABLE tab1（col1 NUMBER，col2 outer_table）NESTED TABLE col2 STORE AS col2_ntab（NESTED TABLE COLUMN_VALUE STORE as cval1_ntab （NESTED TABLE COLUMN_VALUE STORE as cval2_ntab <span class="bold">RETURN</span> as <span class="bold">LOCATOR</span> ））;</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="ADOBJ7464"></a><div class="props_rev_3"><a id="GUID-8CDEBFAB-6C05-4C0D-84AA-3A917E98CC36" name="GUID-8CDEBFAB-6C05-4C0D-84AA-3A917E98CC36"></a><h5 id="ADOBJ-GUID-8CDEBFAB-6C05-4C0D-84AA-3A917E98CC36" class="sect5"><span class="enumeration_section">9.4.4.3.2</span>作为检索期间的提示</h5>
                     <div>
                        <div class="section">
                           <p>查询可以通过提示<code class="codeph">NESTED_TABLE_GET_REFS</code>将集合检索为定位器。以下是从表<code class="codeph">tab1</code>中检索列<code class="codeph">col2</code>作为定位器的示例：</p><pre class="oac_no_warn" dir="ltr">SELECT <span class="bold">/ * + NESTED_TABLE_GET_REFS + * /</span> col2 FROM tab1 WHERE col1 = 2;</pre><p>但是，与<code class="codeph">RETURN</code> <code class="codeph">AS</code> <code class="codeph">LOCATOR</code>子句不同，在使用提示时，不能指定要作为定位器返回的特定内部集合。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="ADOBJ7465"></a><div class="props_rev_3"><a id="GUID-12CE90BB-B224-4730-9851-8A6935A0AAEC" name="GUID-12CE90BB-B224-4730-9851-8A6935A0AAEC"></a><h4 id="ADOBJ-GUID-12CE90BB-B224-4730-9851-8A6935A0AAEC" class="sect4"><span class="enumeration_section">9.4.4.4</span>设置成员资格查询优化</h4>
                  <div>
                     <p>当您要在嵌套表中搜索特定项时，设置成员资格查询非常有用。</p>
                     <p>以下查询测试子集中的成员资格;具体来说，位置<code class="codeph">home</code>是否位于嵌套表<code class="codeph">phones_ntab</code> ，该表位于父表<code class="codeph">people_reltab</code> ：</p><pre class="oac_no_warn" dir="ltr">SELECT * FROM people_reltab p WHERE'home'IN（SELECT location FROM TABLE（p.phones_ntab））;</pre><p>Oracle可以通过将内部转换为半连接来执行更有效地测试子集中成员资格的查询。但是，仅在设置了<code class="codeph">ALWAYS_SEMI_JOIN</code>初始化参数时才会发生此优化。如果要执行semijoins，则此参数的有效值为<code class="codeph">MERGE</code>和<code class="codeph">HASH</code> ;这些参数值指示要使用的连接方法。
                     </p>
                     <div class="infoboxnote" id="GUID-12CE90BB-B224-4730-9851-8A6935A0AAEC__GUID-0CB4F886-590A-4EA7-8447-89BC1BE2337F">
                        <p class="notep1">注意：</p>
                        <p>在前面的示例中， <code class="codeph">home</code>和<code class="codeph">location</code>是子集元素。如果子集元素是对象类型，则它们必须具有映射或顺序方法才能执行集合成员资格查询。
                        </p>
                     </div>
                  </div>
               </div>
            </div><a id="ADOBJ7468"></a><a id="ADOBJ7470"></a><a id="ADOBJ7467"></a><a id="ADOBJ7469"></a><a id="ADOBJ7471"></a><a id="ADOBJ7472"></a><a id="ADOBJ7466"></a><div class="props_rev_3"><a id="GUID-C50A1468-81D3-4C85-BAAF-AC83F4C2A10D" name="GUID-C50A1468-81D3-4C85-BAAF-AC83F4C2A10D"></a><h3 id="ADOBJ-GUID-C50A1468-81D3-4C85-BAAF-AC83F4C2A10D" class="sect3"><span class="enumeration_section">9.4.5</span>多级集合的设计注意事项</h3>
               <div>
                  <p>您可以嵌套集合类型以创建真正的多级集合。</p>
                  <p><a href="support-for-collection-data-types.html#GUID-0EF7C6B0-B68A-4671-A7B6-857D8F6F3DA8">对集合数据类型的支持</a>描述了如何嵌套集合类型，例如嵌套表的嵌套表，嵌套的varrays表，嵌套表的varray，或者具有集合类型属性的对象类型的varray或嵌套表。这些创建了真正的多级集合。
                  </p>
                  <p>您还可以使用<code class="codeph">REF</code>间接嵌套集合。例如，您可以创建对象类型的嵌套表，该表具有引用具有嵌套表或varray属性的对象的属性。如果您实际上不需要访问多级集合的所有元素，那么使用<code class="codeph">REF</code>嵌套集合可以提供更好的性能，因为只需要加载<code class="codeph">REF</code> ，而不是元素本身。
                  </p>
                  <p>真正的多级集合（特别是多级嵌套表）对访问集合的各个元素的查询执行得更好。如果您不需要访问所有元素，则使用嵌套表定位器可以提高编程访问的性能。</p>
                  <p>一系列示例演示了这种类型的设计。</p>
                  <p>话题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="design-considerations-for-collections.html#GUID-4178F558-7E27-44EF-9123-97360F0C126A" title="您可以使用多级集合创建对象表。">使用多级集合创建对象表</a></p>
                     </li>
                     <li>
                        <p><a href="design-considerations-for-collections.html#GUID-B33E4084-34ED-4B5D-AEF6-F566AFEE9A2D" title="您可以使用REF创建对象表">使用REF创建对象表</a></p>
                     </li>
                     <li>
                        <p>我<a href="design-considerations-for-collections.html#GUID-F2696EEE-87A7-4FBE-94C9-F8D56FD33541" title="创建对象表后，可以在其中插入值。">将值插入到对象表中</a></p>
                     </li>
                  </ul>
               </div>
               <div class="sect3"><a id="GUID-4178F558-7E27-44EF-9123-97360F0C126A" name="GUID-4178F558-7E27-44EF-9123-97360F0C126A"></a><h4 id="ADOBJ-GUID-4178F558-7E27-44EF-9123-97360F0C126A" class="sect4"><span class="enumeration_section">9.4.5.1</span>使用多级集合创建对象表</h4>
                  <div>
                     <p>您可以使用多级集合创建对象表。</p>
                     <div class="section">
                        <p>要创建使用<code class="codeph">REF</code>嵌套另一个集合的集合示例，请使用提供的对象类型创建名为<code class="codeph">person_objtyp</code>的新对象类型： <code class="codeph">name_objtyp</code> ， <code class="codeph">address_objtyp</code>和<code class="codeph">phone_ntabtyp</code> 。请记住， <code class="codeph">phone_ntabtyp</code>对象类型是嵌套表，因为每个人可能有多个电话号码。
                        </p>
                        <p>要创建<code class="codeph">person_objtyp</code>对象类型，称为对象表<code class="codeph">people_objtab</code>的<code class="codeph">person_objtyp</code>对象类型，发出以下SQL语句：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-4178F558-7E27-44EF-9123-97360F0C126A__GUID-DFB7633B-827E-4C4D-A6D4-8DFE4AA4A1C7">
                        <p class="titleinexample">示例9-8使用多级集合创建对象表</p><pre class="oac_no_warn" dir="ltr">CREATE TYPE person_objtyp AS OBJECT（id NUMBER（4），name_obj name_objtyp，address_obj address_objtyp，phones_ntab phone_ntabtyp）; /</pre><pre class="oac_no_warn" dir="ltr">CREATE TABLE <span class="bold">people_objtab of</span> person_objtyp（id PRIMARY KEY）NESTED TABLE phones_ntab STORE AS phones_store_ntab;</pre><p>该<code class="codeph">people_objtab</code>表具有相同的属性<code class="codeph">people_reltab</code>表。不同之处在于， <code class="codeph">people_objtab</code>是具有行对象的对象表，而<code class="codeph">people_reltab</code>表是具有列对象的关系表，如<span class="q">“ <a href="general-storage-considerations-for-objects.html#GUID-58E2E291-67B1-4B30-809A-609A8FF07CBA" title="列对象存储类似于共同构成对象的等效标量列集的存储。">关系表中的列对象存储</a> ”中所示</span> 。
                        </p>
                        <div class="figure" id="GUID-4178F558-7E27-44EF-9123-97360F0C126A__GUID-5756F856-F7CB-4829-9A96-412A7EFCEDBB">
                           <p class="titleinfigure">图9-3 people_objtab对象表的对象关系表示</p><img src="img/adobj015.gif" alt="下面是图9-3的描述" title="下面是图9-3的描述" longdesc="img_text/adobj015.html"><br><a href="img_text/adobj015.html">“图9-3 people_objtab对象表的对象关系表示”的描述</a></div>
                        <!-- class="figure" -->
                        <p>您可以从其他表中引用<code class="codeph">people_objtab</code>对象表中的行对象。例如，假设您要创建一个包含以下内容的<code class="codeph">projects_objtab</code>表：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>每个项目的项目标识号。</p>
                           </li>
                           <li>
                              <p>每个项目的标题。</p>
                           </li>
                           <li>
                              <p>每个项目的项目负责人。</p>
                           </li>
                           <li>
                              <p>每个项目的描述。</p>
                           </li>
                           <li>
                              <p>分配给每个项目的人员团队的嵌套表集合。</p>
                           </li>
                        </ul>
                        <p>您可以在<code class="codeph">people_objtab</code>使用<code class="codeph">REF</code>作为项目线索，并且可以为团队使用<code class="codeph">REF</code>的嵌套表集合。首先，创建一个名为嵌套表对象类型<code class="codeph">personref_ntabtyp</code>基础上， <code class="codeph">person_objtyp</code>对象类型：</p><pre class="oac_no_warn" dir="ltr">CREATE TYPE personref_ntabtyp AS TABLE of REF person_objtyp; /</pre><p>您现在已设置为创建以创建对象表，如<a href="design-considerations-for-collections.html#GUID-B33E4084-34ED-4B5D-AEF6-F566AFEE9A2D" title="您可以使用REF创建对象表">使用REF创建</a>对象表中所示。
                        </p>
                     </div>
                     <!-- class="example" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-B33E4084-34ED-4B5D-AEF6-F566AFEE9A2D" name="GUID-B33E4084-34ED-4B5D-AEF6-F566AFEE9A2D"></a><h4 id="ADOBJ-GUID-B33E4084-34ED-4B5D-AEF6-F566AFEE9A2D" class="sect4"><span class="enumeration_section">9.4.5.2</span>使用REF创建对象表</h4>
                  <div>
                     <p>您可以使用REF创建对象表</p>
                     <div class="section">
                        <p>创建人员对象表后，在<a href="design-considerations-for-collections.html#GUID-4178F558-7E27-44EF-9123-97360F0C126A" title="您可以使用多级集合创建对象表。">使用多级集合创建对象表中</a> ，您就可以创建项目对象表<code class="codeph">projects_objtab</code> 。首先，创建对象类型<code class="codeph">projects_objtyp</code> ，然后基于<code class="codeph">projects_objtab</code>创建对象表<code class="codeph">projects_objtyp</code> 。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-B33E4084-34ED-4B5D-AEF6-F566AFEE9A2D__CJADDCJI">
                        <p class="titleinexample">示例9-9使用REF创建对象表</p><pre class="oac_no_warn" dir="ltr">CREATE TYPE projects_objtyp AS OBJECT（id NUMBER（4），title VARCHAR2（15），projlead_ref REF person_objtyp，description CLOB，team_ntab personref_ntabtyp）; / CREATE TABLE projects_objtab OF projects_objtyp（id PRIMARY KEY）NESTED TABLE team_ntab STORE AS team_store_ntab;</pre><div class="figure" id="GUID-B33E4084-34ED-4B5D-AEF6-F566AFEE9A2D__GUID-B5137BC7-D4A4-4CE7-A438-C3FEB0ADB076">
                           <p class="titleinfigure">图9-4 projects_objtab对象表的对象关系表示</p><img src="img/adobj016.gif" alt="下面是图9-4的描述" title="下面是图9-4的描述" longdesc="img_text/adobj016.html"><br><a href="img_text/adobj016.html">“图9-4 projects_objtab对象表的对象关系表示”的描述</a></div>
                        <!-- class="figure" -->
                        <p>在<code class="codeph">people_objtab</code>对象表和<code class="codeph">projects_objtab</code>对象表就位后，您间接拥有嵌套集合。也就是说， <code class="codeph">projects_objtab</code>表包含指向<code class="codeph">people_objtab</code>表中人员的<code class="codeph">REF</code>的嵌套表集合， <code class="codeph">people_objtab</code>表中的<code class="codeph">people_objtab</code>具有电话号码的嵌套表集合。
                        </p>
                        <p>您现在设置为插入值，如图所示<a href="design-considerations-for-collections.html#GUID-F2696EEE-87A7-4FBE-94C9-F8D56FD33541" title="创建对象表后，可以在其中插入值。">将值插入对象表</a> 。
                        </p>
                     </div>
                     <!-- class="example" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-F2696EEE-87A7-4FBE-94C9-F8D56FD33541" name="GUID-F2696EEE-87A7-4FBE-94C9-F8D56FD33541"></a><h4 id="ADOBJ-GUID-F2696EEE-87A7-4FBE-94C9-F8D56FD33541" class="sect4"><span class="enumeration_section">9.4.5.3</span>将值插入PEOPLE_OBJTAB对象表</h4>
                  <div>
                     <p>创建对象表后，可以在其中插入值。</p>
                     <div class="section">
                        <p>您可以在<code class="codeph">people_objtab</code>表中插入值，如本例所示。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-F2696EEE-87A7-4FBE-94C9-F8D56FD33541__CJAJHHJB">
                        <p class="titleinexample">示例9-10将值插入people_objtab对象表</p><pre class="oac_no_warn" dir="ltr">INSERT INTO people_objtab VALUES（0001，name_objtyp（'JOHN'，'JACOB'，'SCHMIDT'），address_objtyp（'1252 Maple Road'，'Fairfax'，'VA'，'22033'），phone_ntabtyp（phone_objtyp（'home'） ，'650.555.0141'），phone_objtyp（'work'，'510.555.0122'）））; INSERT INTO people_objtab VALUES（0002，name_objtyp（'MARY'，'ELLEN'，'MILLER'），address_objtyp（'33 Spruce Street'，'McKees Rocks'，'PA'，'15136'），phone_ntabtyp（phone_objtyp（'home '，'415.555.0143'），phone_objtyp（'work'，'650.555.0192'）））; INSERT INTO people_objtab VALUES（0003，name_objtyp（'SARAH'，'MARIE'，'SINGER'），address_objtyp（'525 Pine Avenue'，'San Mateo'，'CA'，'94403'），phone_ntabtyp（phone_objtyp（'home '，'510.555.0101'），phone_objtyp（'work'，'650.555.0178'），phone_objtyp（'cell'，'650.555.0143'）））;</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-F2696EEE-87A7-4FBE-94C9-F8D56FD33541__GUID-38044152-BB32-43BB-8E6F-DA8333BD9682">
                        <p class="titleinexample">示例9-11将值插入到projects_objtab对象表中</p>
                        <p>然后，您可以通过使用<code class="codeph">REF</code>运算符从<code class="codeph">people_objtab</code>对象表中进行选择来插入到<code class="codeph">projects_objtab</code>关系表中，如下所示。
                        </p><pre class="oac_no_warn" dir="ltr">INSERT INTO projects_objtab VALUES（1101，'Demo Product'，（SELECT REF（p）FROM people_objtab p WHERE id = 0001），'演示产品，显示所有强大功能。'，personref_ntabtyp（（SELECT REF（p）FROM people_objtab p WHERE id = 0001），（SELECT REF（p）FROM people_objtab p WHERE id = 0002），（SELECT REF（p）FROM people_objtab p WHERE id = 0003））） ; INSERT INTO projects_objtab VALUES（1102，'创建PRODDB'，（SELECT REF（p）FROM people_objtab p WHERE id = 0002），'创建我们产品的数据库。'，personref_ntabtyp（（SELECT REF（p）FROM people_objtab p WHERE id = 0002），（SELECT REF（p）FROM people_objtab p WHERE id = 0003）））;</pre></div>
                     <!-- class="example" -->
                     <div class="section">
                        <div class="infoboxnote" id="GUID-F2696EEE-87A7-4FBE-94C9-F8D56FD33541__GUID-DFC2FE0E-DB41-4496-85DF-2C62B9D2A73D">
                           <p class="notep1">注意：</p>
                           <p>此示例使用嵌套表来存储<code class="codeph">REF</code> ，但您也可以将<code class="codeph">REF</code>存储在varrays中。也就是说，你可以有一个<code class="codeph">REF</code>的varray。
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>