<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <meta name="abstract" content="Oracle XML DB provides features for generating (constructing) XML data from relational data in the database. There are both SQL/XML standard functions and Oracle-specific functions and packages for generating XML data from relational content."></meta>
      <meta name="description" content="Oracle XML DB provides features for generating (constructing) XML data from relational data in the database. There are both SQL/XML standard functions and Oracle-specific functions and packages for generating XML data from relational content."></meta>
      <title>从关系数据生成XML数据</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Developer&#39;s Guide "></meta>
      <meta property="og:description" content="Oracle XML DB provides features for generating (constructing) XML data from relational data in the database. There are both SQL/XML standard functions and Oracle-specific functions and packages for generating XML data from relational content."></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Developer&#39;s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="xml-db-developers-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-03-30T12:32:42-07:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="2002, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96222-03"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="relational-data-to-and-from-XML-data.html" title="Previous" type="text/html"></link>
      <link rel="next" href="relational-views-over-XML-data.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="XML DB Developer&#39;s Guide"></meta>
    <meta name="dcterms.isVersionOf" content="ADXDB"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="relational-data-to-and-from-XML-data.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="relational-views-over-XML-data.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">开发人员指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="relational-data-to-and-from-XML-data.html" property="item" typeof="WebPage"><span property="name">与XML数据之间的关系数据</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">从关系数据生成XML数据</li>
            </ol>
            <a id="GUID-3BEB9A88-8B44-4AA3-89F4-8CBF6F8FA686" name="GUID-3BEB9A88-8B44-4AA3-89F4-8CBF6F8FA686"></a><a id="ADXDB1600"></a>
            
            <h2 id="ADXDB-GUID-3BEB9A88-8B44-4AA3-89F4-8CBF6F8FA686" class="sect2"><span class="enumeration_chapter">8</span>从关系数据生成XML数据</h2>
         </header>
         <div class="ind"><script type="text/javascript">window.name='generation-of-XML-data-from-relational-data'</script><script type="text/javascript">
    function footdisplay(footnum,footnote) {
    var msg = window.open('about:blank', 'NewWindow' + footnum,
        'directories=no,height=100,location=no,menubar=no,resizable=yes,' +
        'scrollbars=yes,status=no,toolbar=no,width=598');
    msg.document.open('text/html');
    msg.document.write('<!DOCTYPE html ');
    msg.document.write('PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" ');
    msg.document.write('"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">'); 
    msg.document.write('<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us" dir="ltr"><head><title>');
   
    msg.document.write('Footnote&nbsp; ' + footnum);
    msg.document.write('<\/title><meta http-equiv="Content-Type" ');
    msg.document.write('content="text/html; charset=utf-8" />');
    msg.document.write('<meta http-equiv="Content-Script-Type" ');
    msg.document.write('content="text/javascript" />');
    msg.document.write('<style type="text/css"> <![CDATA[ ');
    msg.document.write('h1 {text-align: center; font-size: 14pt;}');
    msg.document.write('fieldset {border: none;}');
    msg.document.write('form {text-align: center;}');
    msg.document.write(' ]]u003e </style>');
    msg.document.write('<\/head><body><div id="footnote"><h1>Footnote&nbsp; ' + footnum + '<\/h1><p>');
    msg.document.write(footnote);
    msg.document.write('<\/p><form action="" method="post"><fieldset>');
    msg.document.write('<input type="button" value="OK" ');
    msg.document.write('onclick="window.close();" />');
    msg.document.write('<\/fieldset><\/form><\/div><\/body><\/html>');
    msg.document.close();
    setTimeout(function() {
        var height = msg.document.getElementById('footnote').offsetHeight;
        msg.resizeTo(598, height + 100);
    }
    , 100);
    msg.focus();
}
            </script><noscript>
               <p>此页面上的脚本内容仅用于导航目的，不会以任何方式更改内容。</p>
            </noscript>
            <div>
               <p>Oracle XML DB提供了从数据库中的关系数据生成（构造）XML数据的功能。有SQL / XML标准函数和Oracle特定的函数和包，用于从关系内容生成XML数据。</p>
            </div>
            <div>
               <ul class="ullinks">
                  <li class="ulchildlink"><a href="generation-of-XML-data-from-relational-data.html#GUID-C14202BB-4D31-4983-B39E-2C1471CC0B9F">生成XML数据概述</a><br>您可以使用Oracle XML DB使用标准SQL / XML函数，Oracle特定的SQL函数， <code class="codeph">DBMS_XMLGEN</code>包中的PL / SQL子程序或<code class="codeph">DBURIType</code>生成XML数据。
                  </li>
                  <li class="ulchildlink"><a href="generation-of-XML-data-from-relational-data.html#GUID-0B4F8285-CB3B-42D1-94AC-7397BBAFC967">使用SQL函数生成XML数据</a><br>Oracle XML DB提供了可用于构造XML数据的SQL函数。其中大多数都属于SQL / XML标准。
                  </li>
                  <li class="ulchildlink"><a href="generation-of-XML-data-from-relational-data.html#GUID-1490DB76-5832-4023-8F0B-28427901C912">使用DBMS_XMLGEN生成XML数据</a><br>PL / SQL包<code class="codeph">DBMS_XMLGEN</code>从SQL查询结果创建XML文档。它将XML文档检索为<code class="codeph">CLOB</code>或<code class="codeph">XMLType</code>值。
                  </li>
                  <li class="ulchildlink"><a href="generation-of-XML-data-from-relational-data.html#GUID-C41C08F9-28F2-4E74-9BD6-A5F9F7A80E42">SYS_XMLAGG Oracle SQL函数</a><br>Oracle SQL函数<code class="codeph">sys_XMLAgg</code>聚合表达式表示的所有XML文档或片段，从中生成单个XML文档。它将表达式的结果包装在名为<code class="codeph">ROWSET</code>的新元素中（默认情况下）。
                  </li>
                  <li class="ulchildlink"><a href="generation-of-XML-data-from-relational-data.html#GUID-B4E10016-8B10-4B6A-92B9-5ABC31BAF130">在聚合之前对查询结果进行排序，使用XMLAGG ORDER BY子句</a><br>要在聚合之前使用<code class="codeph">XMLAgg ORDER BY</code>子句，请在第一个<code class="codeph">XMLAGG</code>参数后面指定<code class="codeph">ORDER BY</code>子句。
                  </li>
                  <li class="ulchildlink"><a href="generation-of-XML-data-from-relational-data.html#GUID-F7FCE095-C64F-4055-8EB1-DEF4BC93D384">使用XMLTABLE返回行集</a><br>您可以使用标准SQL / XML函数<code class="codeph">XMLTable</code>返回行集，其中文档的相关部分被提取为多行。
                  </li>
               </ul>
               <div class="infoboxnotealso" id="GUID-3BEB9A88-8B44-4AA3-89F4-8CBF6F8FA686__GUID-52EE5CDD-75CF-48B8-88F5-055B8A1B4116">
                  <p class="notep1">也可以看看：</p>
                  <p><a href="xquery-and-XML-DB.html#GUID-4F83A835-C94B-4D62-999B-111AB5E8A8F1" title="XQuery语言是您与Oracle XML DB中的XML数据交互的主要方式之一。对该语言的支持包括SQL * Plus commandXQUERY和SQL / XML函数XMLQuery，XMLTable，XMLExists和XMLCast。">XQuery和Oracle XML DB，</a>用于获取有关使用SQL / XML函数<code class="codeph">XMLQuery</code>和<code class="codeph">XMLTable</code>构造XML数据的信息</p>
               </div>
               <div class="familylinks">
                  <div class="parentlink">
                     <p><strong>父主题：</strong> <a href="relational-data-to-and-from-XML-data.html#GUID-52910135-EC23-41B2-97EC-116790BF6A3C" title="您可以通过多种方式将现有关系数据视为XML数据。">与XML数据相关的关系数据</a></p>
                  </div>
               </div>
            </div>
            <a id="ADXDB4987"></a><div class="props_rev_3"><a id="GUID-C14202BB-4D31-4983-B39E-2C1471CC0B9F" name="GUID-C14202BB-4D31-4983-B39E-2C1471CC0B9F"></a><h3 id="ADXDB-GUID-C14202BB-4D31-4983-B39E-2C1471CC0B9F" class="sect3"><span class="enumeration_section">8.1</span>生成XML数据概述</h3>
               <div>
                  <p>您可以使用Oracle XML DB使用标准SQL / XML函数，Oracle特定的SQL函数， <code class="codeph">DBMS_XMLGEN</code>包中的PL / SQL子程序或<code class="codeph">DBURIType</code>生成XML数据。
                  </p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>使用标准的SQL / XML函数。请参阅<a href="generation-of-XML-data-from-relational-data.html#GUID-0B4F8285-CB3B-42D1-94AC-7397BBAFC967" title="Oracle XML DB提供了可用于构造XML数据的SQL函数。其中大多数都属于SQL / XML标准。">使用SQL函数生成XML数据</a> 。
                        </p>
                     </li>
                     <li>
                        <p>使用Oracle SQL函数。请参阅以下部分：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="generation-of-XML-data-from-relational-data.html#GUID-F643284F-A6AF-47A9-AF2C-58EF7E88C87F" title="Oracle SQL函数XMLColAttVal生成一个包含传入参数值的XML列元素林。此函数是SQL / XML ANSI-ISO标准函数的Oracle扩展。">XMLCOLATTVAL Oracle SQL函数</a> 
                              </p>
                           </li>
                           <li>
                              <p><a href="generation-of-XML-data-from-relational-data.html#GUID-A5A2E32B-A5DD-4A49-8C74-FD83F029F130" title="您使用Oracle SQL函数XMLCDATA生成XML CDATA部分。">XMLCDATA Oracle SQL函数</a></p>
                           </li>
                           <li>
                              <p><a href="generation-of-XML-data-from-relational-data.html#GUID-C41C08F9-28F2-4E74-9BD6-A5F9F7A80E42" title="Oracle SQL函数sys_XMLAgg聚合表达式表示的所有XML文档或片段，从中生成单个XML文档。它将表达式的结果包装在名为ROWSET的新元素中（默认情况下）。">SYS_XMLAGG Oracle SQL函数</a> 。它对行组进行操作，将多个XML文档聚合为一个。
                              </p>
                           </li>
                        </ul>
                     </li>
                     <li>
                        <p>使用PL / SQL包<code class="codeph">DBMS_XMLGEN</code> 。请参阅<a href="generation-of-XML-data-from-relational-data.html#GUID-1490DB76-5832-4023-8F0B-28427901C912" title="PL / SQL包DBMS_XMLGEN从SQL查询结果创建XML文档。它将XML文档检索为CLOB或XMLType值。">使用DBMS_XMLGEN生成XML数据</a> 。</p>
                     </li>
                     <li>
                        <p>使用<code class="codeph">DBURIType</code>实例从数据库数据构造XML文档。请参阅<a href="data-access-using-URIs.html#GUID-0F5F6D4C-0C27-4EC0-926C-CDCC0C1F9798" title="您可以在数据库中生成和存储URI，并使用它们来检索它们所针对的数据库数据。您可以使用这种方式使用三种URI：DBUris，XDBUris和HTTPUris。">使用URI进行数据访问</a> 。</p>
                     </li>
                  </ul>
               </div>
               <div>
                  <div class="infoboxnotealso" id="GUID-C14202BB-4D31-4983-B39E-2C1471CC0B9F__GUID-5682D9D5-603D-4EC6-9030-AB6EC2E99703">
                     <p class="notep1">也可以看看：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="how-to-use-XML-DB.html#GUID-757B4470-851B-47B7-AB78-81F47ECE5398" title="介绍了使用Oracle XML DB的各种方法的概述。">如何使用Oracle XML DB概述</a></p>
                        </li>
                        <li>
                           <p><a href="transformation-and-validation-of-XMLType-data.html#GUID-EC4E2212-67EF-425C-AB5E-D48E62EAB9A7" title="有几个Oracle SQL函数和XMLType API，用于使用XSLT样式表转换XMLType数据，以及根据XML模式验证XMLType实例。">XMLType数据的转换和验证</a></p>
                        </li>
                        <li>
                           <p><a href="PLSQL-APIs-for-XMLType.html#GUID-2D5B2D47-9CFF-49D0-9BD8-114BBE48A289" title="有几个PL / SQL包为XMLType提供API。">XMLType的PL / SQL API</a></p>
                        </li>
                        <li>
                           <p><a href="Java-DOM-API-for-XMLType.html#GUID-4C510052-8A31-4917-8567-0E2825927C54" title="XMLType的Java DOM API允许您使用DOM操作XMLType实例。您可以使用它来操作Java中的XML数据，包括通过Java数据库连接（JDBC）获取它。">用于XMLType的Java DOM API</a></p>
                        </li>
                     </ul>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="generation-of-XML-data-from-relational-data.html#GUID-3BEB9A88-8B44-4AA3-89F4-8CBF6F8FA686" title="Oracle XML DB提供了从数据库中的关系数据生成（构造）XML数据的功能。有SQL / XML标准函数和Oracle特定的函数和包，用于从关系内容生成XML数据。">从关系数据生成XML数据</a></p>
                     </div>
                  </div>
               </div>
               
            </div><a id="ADXDB1620"></a><div class="props_rev_3"><a id="GUID-0B4F8285-CB3B-42D1-94AC-7397BBAFC967" name="GUID-0B4F8285-CB3B-42D1-94AC-7397BBAFC967"></a><h3 id="ADXDB-GUID-0B4F8285-CB3B-42D1-94AC-7397BBAFC967" class="sect3"><span class="enumeration_section">8.2</span>使用SQL函数生成XML数据</h3>
               <div>
                  <p>Oracle XML DB提供了可用于构造XML数据的SQL函数。其中大多数都属于SQL / XML标准。</p>
                  <p>标准的XML生成函数也称为SQL / XML <strong class="term">发布</strong>或<strong class="term">生成</strong>函数。
                  </p>
                  <p>SQL / XML函数<code class="codeph">XMLQuery</code>的使用不仅限于生成（发布）XML数据。函数<code class="codeph">XMLQuery</code>非常通用，在本书中称为SQL / XML <strong class="term">查询和更新</strong>函数。
                  </p>
                  <p>以下生成XML的SQL函数是特定于Oracle的（不是SQL / XML标准的一部分）：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="generation-of-XML-data-from-relational-data.html#GUID-F643284F-A6AF-47A9-AF2C-58EF7E88C87F" title="Oracle SQL函数XMLColAttVal生成一个包含传入参数值的XML列元素林。此函数是SQL / XML ANSI-ISO标准函数的Oracle扩展。">XMLCOLATTVAL Oracle SQL函数</a> 。
                        </p>
                     </li>
                     <li>
                        <p><a href="generation-of-XML-data-from-relational-data.html#GUID-A5A2E32B-A5DD-4A49-8C74-FD83F029F130" title="您使用Oracle SQL函数XMLCDATA生成XML CDATA部分。">XMLCDATA Oracle SQL函数</a> 。
                        </p>
                     </li>
                     <li>
                        <p><a href="generation-of-XML-data-from-relational-data.html#GUID-C41C08F9-28F2-4E74-9BD6-A5F9F7A80E42" title="Oracle SQL函数sys_XMLAgg聚合表达式表示的所有XML文档或片段，从中生成单个XML文档。它将表达式的结果包装在名为ROWSET的新元素中（默认情况下）。">SYS_XMLAGG Oracle SQL函数</a> 。它对关系行组进行操作，将多个XML文档聚合为一个。
                        </p>
                     </li>
                  </ul>
                  <p>所有XML生成SQL函数都将标量和用户定义的数据类型实例转换为其规范的XML格式。在此规范映射中，用户定义的数据类型属性映射到XML元素。</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="generation-of-XML-data-from-relational-data.html#GUID-868E591C-19A1-4E4A-BC2A-013181071B77">XMLELEMENT和XMLATTRIBUTES SQL / XML函数</a><br>SQL / XML标准函数<code class="codeph">XMLElement</code>根据关系数据构造XML元素。SQL / XML标准函数<code class="codeph">XMLAttributes</code>可与<code class="codeph">XMLElement</code>一起使用，以指定生成的元素的属性。
                     </li>
                     <li class="ulchildlink"><a href="generation-of-XML-data-from-relational-data.html#GUID-D9666485-0383-4AF6-B352-B9A90AE1DCFB">XMLFOREST SQL / XML函数</a><br>您使用SQL / XML标准函数<code class="codeph">XMLForest</code>来构造XML元素的林。
                     </li>
                     <li class="ulchildlink"><a href="generation-of-XML-data-from-relational-data.html#GUID-3806853D-2AAA-4D2D-AD98-3E0941F7BE17">XMLCONCAT SQL / XML函数</a><br>您可以使用SQL / XML标准函数<code class="codeph">XMLConcat</code>通过连接多个<code class="codeph">XMLType</code>实例来构造XML片段。
                     </li>
                     <li class="ulchildlink"><a href="generation-of-XML-data-from-relational-data.html#GUID-971232BA-B52E-44CB-86DA-E182AF7E2ACB">XMLAGG SQL / XML函数</a><br>您使用SQL / XML标准函数<code class="codeph">XMLAgg</code>从XML元素集合构造XML元素林 - 它是一个聚合函数。
                     </li>
                     <li class="ulchildlink"><a href="generation-of-XML-data-from-relational-data.html#GUID-43A6EF19-9A0D-4AA8-B73E-21A46BFFA81C">XMLPI SQL / XML函数</a><br>您使用SQL / XML标准函数<code class="codeph">XMLPI</code>来构造XML处理指令（PI）。
                     </li>
                     <li class="ulchildlink"><a href="generation-of-XML-data-from-relational-data.html#GUID-CEE20C19-F599-4154-ABFA-B2D062C4F915">XMLCOMMENT SQL / XML函数</a><br>您使用SQL / XML标准函数<code class="codeph">XMLComment</code>来构造XML注释。
                     </li>
                     <li class="ulchildlink"><a href="generation-of-XML-data-from-relational-data.html#GUID-55FE9CED-5B25-4DA2-9F9E-921DF8276EB8">XMLSERIALIZE SQL / XML函数</a><br>您使用SQL / XML标准函数<code class="codeph">XMLSerialize</code>来获取XML数据的字符串或LOB表示。
                     </li>
                     <li class="ulchildlink"><a href="generation-of-XML-data-from-relational-data.html#GUID-8BABF906-A641-49D9-9CED-8B039A6D272C">XMLPARSE SQL / XML函数</a><br>您使用SQL / XML标准函数<code class="codeph">XMLParse</code>来解析包含XML数据的字符串并构造相应的<code class="codeph">XMLType</code>实例。
                     </li>
                     <li class="ulchildlink"><a href="generation-of-XML-data-from-relational-data.html#GUID-F643284F-A6AF-47A9-AF2C-58EF7E88C87F">XMLCOLATTVAL Oracle SQL函数</a><br>Oracle SQL函数<code class="codeph">XMLColAttVal</code>生成一个包含传入参数值的XML <code class="codeph">column</code>元素林。此函数是SQL / XML ANSI-ISO标准函数的Oracle扩展。
                     </li>
                     <li class="ulchildlink"><a href="generation-of-XML-data-from-relational-data.html#GUID-A5A2E32B-A5DD-4A49-8C74-FD83F029F130">XMLCDATA Oracle SQL函数</a><br>您使用Oracle SQL函数<code class="codeph">XMLCDATA</code>生成XML <code class="codeph">CDATA</code>部分。
                     </li>
                  </ul>
                  <div class="infoboxnotealso" id="GUID-0B4F8285-CB3B-42D1-94AC-7397BBAFC967__GUID-6F3CA72A-669C-4BEE-9B68-FC2E2EEC3032">
                     <p class="notep1">也可以看看：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>有关使用SQL / XML函数<code class="codeph">XMLQuery</code>构造XML数据的信息，请参阅<a href="xquery-and-XML-DB.html#GUID-4F83A835-C94B-4D62-999B-111AB5E8A8F1" title="XQuery语言是您与Oracle XML DB中的XML数据交互的主要方式之一。对该语言的支持包括SQL * Plus commandXQUERY和SQL / XML函数XMLQuery，XMLTable，XMLExists和XMLCast。">XQuery和Oracle XML DB</a></p>
                        </li>
                        <li>
                           <p>有关Oracle对SQL / XML标准的支持的信息，请<a href="../sqlrf/Oracle-Compliance-with-SQLXML2011.html#SQLRF55529" target="_blank"><span><cite>参见Oracle数据库SQL语言参考</cite></span></a></p>
                        </li>
                     </ul>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="generation-of-XML-data-from-relational-data.html#GUID-3BEB9A88-8B44-4AA3-89F4-8CBF6F8FA686" title="Oracle XML DB提供了从数据库中的关系数据生成（构造）XML数据的功能。有SQL / XML标准函数和Oracle特定的函数和包，用于从关系内容生成XML数据。">从关系数据生成XML数据</a></p>
                     </div>
                  </div>
               </div>
               <a id="ADXDB4995"></a><a id="ADXDB4996"></a><a id="ADXDB4994"></a><div class="props_rev_3"><a id="GUID-868E591C-19A1-4E4A-BC2A-013181071B77" name="GUID-868E591C-19A1-4E4A-BC2A-013181071B77"></a><h4 id="ADXDB-GUID-868E591C-19A1-4E4A-BC2A-013181071B77" class="sect4"><span class="enumeration_section">8.2.1</span> XMLELEMENT和XMLATTRIBUTES SQL / XML函数</h4>
                  <div>
                     <p>SQL / XML标准函数<code class="codeph">XMLElement</code>根据关系数据构造XML元素。SQL / XML标准函数<code class="codeph">XMLAttributes</code>可与<code class="codeph">XMLElement</code>一起使用，以指定生成的元素的属性。
                     </p>
                     <div class="section">
                        <p>SQL / XML标准函数<code class="codeph">XMLElement</code>将XML元素名称，元素的可选属性集合以及构成元素内容的零个或多个其他参数作为参数。它返回一个<code class="codeph">XMLType</code>实例。
                        </p>
                        <div class="figure" id="GUID-868E591C-19A1-4E4A-BC2A-013181071B77__I1030781">
                           <p class="titleinfigure">图8-1 XMLELEMENT语法</p><img src="img/xmlelement.gif" width="502" alt="下面是图8-1的描述" title="下面是图8-1的描述" longdesc="img_text/xmlelement.html"><br><a href="img_text/xmlelement.html">“图8-1 XMLELEMENT语法”的说明</a></div>
                        <!-- class="figure" -->
                        <p>有关关键字<code class="codeph">ENTITYESCAPING</code>和<code class="codeph">NOENTITYESCAPING</code>的说明，请参阅<a href="generation-of-XML-data-from-relational-data.html#GUID-5BE09A7D-80D8-4734-B9AF-4A61F27FA9B2" title="根据SQL / XML标准的规定，显式标识符中的字符不会以任何方式进行转义 - 由您来确保使用有效的XML名称。这适用于所有SQL / XML函数。">生成的XML数据中的字符转义</a> 。这些关键字是标准SQL / XML函数<code class="codeph">XMLElement</code>和<code class="codeph">XMLAttributes</code> Oracle扩展。
                        </p>
                        <p>函数<code class="codeph">XMLElement</code>的第一个参数定义了一个标识符，用于命名要创建的<span class="italic">根</span> XML元素。可以使用文字标识符（ <a href="generation-of-XML-data-from-relational-data.html#GUID-868E591C-19A1-4E4A-BC2A-013181071B77__I1030781">图8-1中的</a> <span class="italic"><code class="codeph">identifier</code></span> ）或<code class="codeph">EVALNAME</code>后跟表达式（ <span class="italic"><code class="codeph">value_expr</code></span> ）来定义根元素标识符参数，该表达式计算为标识符。无论如何定义，标识符不能为<code class="codeph">NULL</code> ，否则会引发错误。使用<code class="codeph">EVALNAME</code>的可能性是标准SQL / XML函数<code class="codeph">XMLElement</code>的Oracle扩展。
                        </p>
                        <p>函数<code class="codeph">XMLElement</code>的可选<span class="italic"><code class="codeph">XML-attributes-clause</code></span>参数指定要生成的根元素的属性。<a href="generation-of-XML-data-from-relational-data.html#GUID-868E591C-19A1-4E4A-BC2A-013181071B77__BABBDEJF">图8-2</a>显示了该参数的语法。
                        </p>
                        <p>除了可选的<span class="italic"><code class="codeph">XML-attributes-clause</code></span>参数之外，函数<code class="codeph">XMLElement</code>接受零个或多个<span class="italic"><code class="codeph">value_expr</code></span>参数， <span class="italic"><code class="codeph">value_expr</code></span>参数构成根元素的<span class="italic">内容</span> （子元素和文本内容）。如果还存在<span class="italic"><code class="codeph">XML-attributes-clause</code></span>参数，则这些内容参数必须遵循<span class="italic"><code class="codeph">XML-attributes-clause</code></span>参数。评估每个内容参数表达式，并将结果转换为XML格式。如果value参数的计算结果为<code class="codeph">NULL</code> ，则不会为该参数创建任何内容。
                        </p>
                        <div class="infoboxnote" id="GUID-868E591C-19A1-4E4A-BC2A-013181071B77__GUID-228026D6-5437-408D-98D4-2B68F90098BE">
                           <p class="notep1">注意：</p>
                           <p>别名（ <span class="italic"><code class="codeph">c_alias</code></span> ）之前的<code class="codeph">AS</code>是SQL / XML标准所必需的，但对于Oracle是可选的。
                           </p>
                        </div>
                        <p>可选的<span class="italic"><code class="codeph">XML-attributes-clause</code></span>参数使用SQL / XML标准函数<code class="codeph">XMLAttributes</code>来指定根元素的<span class="italic">属性</span> 。函数<code class="codeph">XMLAttributes</code> <span class="italic">只能</span>在对函数<code class="codeph">XMLElement</code>的调用中<code class="codeph">XMLElement</code> 。它不能单独使用。
                        </p>
                        <div class="figure" id="GUID-868E591C-19A1-4E4A-BC2A-013181071B77__BABBDEJF">
                           <p class="titleinfigure">图8-2 XMLAttributes子句语法（XMLATTRIBUTES）</p><img src="img/xml_attributes_clause.gif" width="369" alt="下面是图8-2的描述" title="下面是图8-2的描述" longdesc="img_text/xml_attributes_clause.html"><br><a href="img_text/xml_attributes_clause.html">“图8-2 XMLAttributes子句语法（XMLATTRIBUTES）”的说明</a></div>
                        <!-- class="figure" -->
                        <p>有关关键字<code class="codeph">ENTITYESCAPING</code>和<code class="codeph">NOENTITYESCAPING</code>的说明，请参阅<a href="generation-of-XML-data-from-relational-data.html#GUID-5BE09A7D-80D8-4734-B9AF-4A61F27FA9B2" title="根据SQL / XML标准的规定，显式标识符中的字符不会以任何方式进行转义 - 由您来确保使用有效的XML名称。这适用于所有SQL / XML函数。">生成的XML数据中的字符转义</a> 。这些关键字是标准SQL / XML函数<code class="codeph">XMLElement</code>和<code class="codeph">XMLAttributes</code> Oracle扩展。
                        </p>
                        <p>关键字<code class="codeph">SCHEMACHECK</code>和<code class="codeph">NOSCHEMACHECK</code>确定是否对生成的属性进行运行时检查，以查看它们中是否有任何一个指定了与Oracle XML DB注册的XML模式相对应的模式位置，如果是，则指定尝试相应地生成基于XML模式的XML数据。默认行为是由<code class="codeph">NOSCHEMACHECK</code>提供的：不进行检查。在12c版本1（12.1）之前的版本中，默认行为是执行检查。关键字<code class="codeph">SCHEMACHECK</code>可用于获得向后兼容性。
                        </p>
                        <p>无论是否存在<code class="codeph">NOSCHEMACHECK</code> ， <span class="italic">总是</span>在<span class="italic">编译</span>时进行类似的检查。这尤其意味着，如果使用字符串文字指定XML模式位置属性值，则进行（编译时）检查，并在适当时生成相应的基于XML模式的数据。
                        </p>
                        <p>关键字<code class="codeph">SCHEMACHECK</code>和<code class="codeph">NOSCHEMACHECK</code>是标准SQL / XML函数<code class="codeph">XMLAttributes</code> Oracle扩展。
                        </p>
                        <div class="infoboxnote" id="GUID-868E591C-19A1-4E4A-BC2A-013181071B77__GUID-416A016B-0D0B-4BC7-8C0A-73286E22EC20">
                           <p class="notep1">注意：</p>
                           <p>如果创建视图以生成XML数据，则函数<code class="codeph">XMLAttributes</code>用于添加XML模式位置引用，并且目标XML模式尚未向Oracle XML DB注册，则生成的XML数据不是基于XML模式的。如果随后注册了XML模式，则此后生成的XML数据<span class="italic">也不</span>是基于XML模式的。要创建基于XML模式的数据，必须重新编译视图。
                           </p>
                        </div>
                        <p>参数<span class="italic"><code class="codeph">XML-attributes-clause</code></span>本身包含一个或多个<span class="italic"><code class="codeph">value_expr</code></span>表达式作为函数<code class="codeph">XMLAttributes</code>参数。评估它们以获取根元素的属性的值。（不要混淆这些<span class="italic"><code class="codeph">value_expr</code></span>参数的功能<code class="codeph">XMLAttributes</code>与<span class="italic"><code class="codeph">value_expr</code></span>参数功能<code class="codeph">XMLElement</code> ，其中指定根元素的内容。）每个<span class="italic"><code class="codeph">value_expr</code></span>的可选<code class="codeph">AS</code> <span class="italic"><code class="codeph">c_alias</code></span>子句指定属性名称为<span class="italic"><code class="codeph">c_alias</code></span> ，它可以是字符串文字或<code class="codeph">EVALNAME</code>后跟一个计算结果为字符串文字的表达式。
                        </p>
                        <div class="infoboxnote" id="GUID-868E591C-19A1-4E4A-BC2A-013181071B77__GUID-87072A08-898A-4FD1-A257-7C67307B7786">
                           <p class="notep1">注意：</p>
                           <p>以下是标准SQL / XML语法的Oracle扩展：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>使用<code class="codeph">EVALNAME</code>的可能性。</p>
                              </li>
                              <li>
                                 <p>别名（ <span class="italic"><code class="codeph">c_alias</code></span> ）之前的<code class="codeph">AS</code>是可选的。
                                 </p>
                              </li>
                           </ul>
                        </div>
                        <p>如果属性值表达式的计算结果为<code class="codeph">NULL</code> ，则不会创建相应的属性。属性值表达式的数据类型不能是对象类型或集合。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="generation-of-XML-data-from-relational-data.html#GUID-5BE09A7D-80D8-4734-B9AF-4A61F27FA9B2">生成的XML数据中字符的转义</a><br>根据SQL / XML标准的规定，显式<span class="italic">标识符</span>中的字符<span class="italic">不会</span>以任何方式进行转义 - 由您来确保使用有效的XML名称。这适用于所有SQL / XML函数。
                        </li>
                        <li class="ulchildlink"><a href="generation-of-XML-data-from-relational-data.html#GUID-18DC2329-2C1D-4A23-9321-82519AAC4527">格式化XML日期和时间戳</a><br>XML Schema标准指定XML数据中的日期和时间戳采用标准格式。Oracle XML DB中的XML生成函数根据此标准生成XML日期和时间戳。
                        </li>
                        <li class="ulchildlink"><a href="generation-of-XML-data-from-relational-data.html#GUID-49E8774C-E240-47BA-966B-60B28DD50774">XMLElement示例</a><br>这里的示例说明了使用SQL / XML函数<code class="codeph">XMLElement</code> 。
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="generation-of-XML-data-from-relational-data.html#GUID-0B4F8285-CB3B-42D1-94AC-7397BBAFC967" title="Oracle XML DB提供了可用于构造XML数据的SQL函数。其中大多数都属于SQL / XML标准。">使用SQL函数生成XML数据</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="ADXDB4997"></a><div class="props_rev_3"><a id="GUID-5BE09A7D-80D8-4734-B9AF-4A61F27FA9B2" name="GUID-5BE09A7D-80D8-4734-B9AF-4A61F27FA9B2"></a><h5 id="ADXDB-GUID-5BE09A7D-80D8-4734-B9AF-4A61F27FA9B2" class="sect5"><span class="enumeration_section">8.2.1.1</span>生成的XML数据中字符的转义</h5>
                     <div>
                        <p>根据SQL / XML标准的规定，显式<span class="italic">标识符</span>中的字符<span class="italic">不会</span>以任何方式进行转义 - 由您来确保使用有效的XML名称。这适用于所有SQL / XML函数。
                        </p>
                        <p>特别地，它适用于根元素标识符<code class="codeph">XMLElement</code> （ <span class="italic"><code class="codeph">identifier</code></span> ，在<a href="generation-of-XML-data-from-relational-data.html#GUID-868E591C-19A1-4E4A-BC2A-013181071B77__I1030781">图8-1</a> ）和属性与名为标识符别名<code class="codeph">AS</code>的条款<code class="codeph">XMLAttributes</code> （参见<a href="generation-of-XML-data-from-relational-data.html#GUID-868E591C-19A1-4E4A-BC2A-013181071B77__BABBDEJF">图8-2</a> ）。
                        </p>
                        <p>然而，产生其他的XML数据被<span class="italic">转义</span> ，默认情况下，以确保只有合法的XML <code class="codeph">NameChar</code>字符生成。作为从SQL标识符生成有效XML元素或属性名称的一部分，XML名称中不允许的每个字符都替换为下划线字符（ <code class="codeph">_</code> ），后跟原始字符的十六进制Unicode表示，后跟第二个字符强调性格。例如，冒号（ <code class="codeph">:</code> ）通过与替换它转义<code class="codeph">_003A_</code> ，其中003A是十六进制Unicode表示。
                        </p>
                        <p>转义适用于<span class="italic">所有</span> SQL / XML函数的计算值<span class="italic"><code class="codeph">value_expr</code></span>参数中的字符，包括<code class="codeph">XMLElement</code>和<code class="codeph">XMLAttributes</code> 。它还适用于<span class="italic">从未</span>跟随<code class="codeph">AS</code>子句的<code class="codeph">XMLAttributes</code>属性值表达式隐式定义的属性标识符的字符：SQL列名称的转义形式用作属性的名称。
                        </p>
                        <p>在某些情况下，您可能不需要或希望字符转义。例如，如果您知道生成的XML数据格式正确，那么您可以通过禁止转义来节省一些处理时间。您可以通过为SQL / XML函数<code class="codeph">XMLElement</code>和<code class="codeph">XMLAttributes</code>指定关键字<code class="codeph">NOENTITYESCAPING</code>来实现。关键字<code class="codeph">ENTITYESCAPING</code>强制转义，这是默认行为。关键字<code class="codeph">NOENTITYESCAPING</code>和<code class="codeph">ENTITYESCAPING</code>是标准SQL / XML函数<code class="codeph">XMLElement</code>和<code class="codeph">XMLAttributes</code> Oracle扩展。
                        </p>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="generation-of-XML-data-from-relational-data.html#GUID-868E591C-19A1-4E4A-BC2A-013181071B77" title="SQL / XML标准函数XMLElement根据关系数据构造XML元素。SQL / XML标准函数XMLAttributes可与XMLElement一起使用，以指定生成的元素的属性。">XMLELEMENT和XMLATTRIBUTES SQL / XML函数</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="ADXDB4998"></a><div class="props_rev_3"><a id="GUID-18DC2329-2C1D-4A23-9321-82519AAC4527" name="GUID-18DC2329-2C1D-4A23-9321-82519AAC4527"></a><h5 id="ADXDB-GUID-18DC2329-2C1D-4A23-9321-82519AAC4527" class="sect5"><span class="enumeration_section">8.2.1.2</span> XML日期和时间戳的格式</h5>
                     <div>
                        <p>XML Schema标准指定XML数据中的日期和时间戳采用标准格式。Oracle XML DB中的XML生成函数根据此标准生成XML日期和时间戳。</p>
                        <p>在Oracle Database 10g第2版之前的版本中，日期和时间戳格式的数据库设置（而不是XML Schema标准格式）用于XML。您可以通过设置数据库事件19119，级别0x8来重现此<span class="italic">先前的</span>行为，如下所示：</p><pre class="pre codeblock"><code>ALTER SESSION SET EVENTS'19119 TRACE NAME CONTEXT FOREVER，LEVEL 0x8';</code></pre><p>如果必须生成非标准XML日期或时间戳，请使用SQL函数<code class="codeph">to_char</code> - 请参见<a href="generation-of-XML-data-from-relational-data.html#GUID-49E8774C-E240-47BA-966B-60B28DD50774__CHDGFEIF">例8-1</a> 。
                        </p>
                     </div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-18DC2329-2C1D-4A23-9321-82519AAC4527__GUID-ADBDB093-4AF5-4520-BCCA-40E86EFABD61">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/adxdb&amp;id=w3_org_xschema_isoformats" target="_blank">XML Schema第2部分：数据类型，D。ISO 8601</a> XML <a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/adxdb&amp;id=w3_org_xschema_isoformats" target="_blank">日期和时间格式</a>的XML Schema规范的日期和时间格式</p>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="generation-of-XML-data-from-relational-data.html#GUID-868E591C-19A1-4E4A-BC2A-013181071B77" title="SQL / XML标准函数XMLElement根据关系数据构造XML元素。SQL / XML标准函数XMLAttributes可与XMLElement一起使用，以指定生成的元素的属性。">XMLELEMENT和XMLATTRIBUTES SQL / XML函数</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="ADXDB5000"></a><a id="ADXDB5001"></a><a id="ADXDB5002"></a><a id="ADXDB5003"></a><a id="ADXDB5895"></a><a id="ADXDB5004"></a><a id="ADXDB5005"></a><a id="ADXDB4999"></a><div class="props_rev_3"><a id="GUID-49E8774C-E240-47BA-966B-60B28DD50774" name="GUID-49E8774C-E240-47BA-966B-60B28DD50774"></a><h5 id="ADXDB-GUID-49E8774C-E240-47BA-966B-60B28DD50774" class="sect5"><span class="enumeration_section">8.2.1.3</span> XMLElement示例</h5>
                     <div>
                        <p>这里的示例说明了使用SQL / XML函数<code class="codeph">XMLElement</code> 。
                        </p>
                        <div class="section">
                           <p><a href="generation-of-XML-data-from-relational-data.html#GUID-49E8774C-E240-47BA-966B-60B28DD50774__CHDGFEIF">例8-1</a>使用<code class="codeph">XMLElement</code>生成格式与XML Schema标准日期格式不同的XML日期。
                           </p>
                           <p><a href="generation-of-XML-data-from-relational-data.html#GUID-49E8774C-E240-47BA-966B-60B28DD50774__CHEGBHCC">示例8-2</a>使用<code class="codeph">XMLElement</code>为每个员工生成<code class="codeph">Emp</code>元素，并将员工姓名作为内容。
                           </p>
                           <p><a href="generation-of-XML-data-from-relational-data.html#GUID-49E8774C-E240-47BA-966B-60B28DD50774__CHEGGIGG">示例8-3</a>使用<code class="codeph">XMLElement</code>为每个员工生成一个<code class="codeph">Emp</code>元素，其子元素提供员工姓名和雇用日期。
                           </p>
                           <p><a href="generation-of-XML-data-from-relational-data.html#GUID-49E8774C-E240-47BA-966B-60B28DD50774__CHEDFACF">示例8-4</a>使用<code class="codeph">XMLElement</code>为每个员工生成一个<code class="codeph">Emp</code>元素，其中包含属性<code class="codeph">id</code>和<code class="codeph">name</code> 。
                           </p>
                           <p>如<a href="generation-of-XML-data-from-relational-data.html#GUID-5BE09A7D-80D8-4734-B9AF-4A61F27FA9B2" title="As specified by the SQL/XML standard, characters in explicit identifiers are not escaped in any way – it is up to you to ensure that valid XML names are used. This applies to all SQL/XML functions.">生成的XML数据</a>中的字符<a href="generation-of-XML-data-from-relational-data.html#GUID-5BE09A7D-80D8-4734-B9AF-4A61F27FA9B2" title="根据SQL / XML标准的规定，显式标识符中的字符不会以任何方式进行转义 - 由您来确保使用有效的XML名称。这适用于所有SQL / XML函数。">转义</a>中所述，根元素名称中的字符和<code class="codeph">AS</code>子句定义的任何属性的名称<span class="italic">不会被</span>转义。仅当从评估表达式（例如列引用）创建名称时，才会转义标识符名称中的字符。
                           </p>
                           <p><a href="generation-of-XML-data-from-relational-data.html#GUID-49E8774C-E240-47BA-966B-60B28DD50774__CHEIEAJH">例8-5</a>显示，使用<code class="codeph">XMLElement</code>构造XML数据时，根元素名称和属性名称<span class="italic">不会被</span>转义。生成的XML无效，因为XML元素和属性名称中不允许使用大于号（ <code class="codeph">&gt;</code> ）和逗号（ <code class="codeph">,</code> ）。
                           </p>
                           <p>SQL / XML标准中包含字符转义的完整描述。</p>
                           <p><a href="generation-of-XML-data-from-relational-data.html#GUID-49E8774C-E240-47BA-966B-60B28DD50774__CHEHAGJJ">例8-6</a>说明了使用命名空间来创建基于XML模式的文档。假设存在XML模式“ <code class="codeph">http://www.oracle.com/Employee.xsd</code> ”并且没有目标名称空间， <a href="generation-of-XML-data-from-relational-data.html#GUID-49E8774C-E240-47BA-966B-60B28DD50774__CHEHAGJJ">示例8-6中</a>的查询将创建符合该模式的<code class="codeph">XMLType</code>实例：</p>
                           <p><a href="generation-of-XML-data-from-relational-data.html#GUID-49E8774C-E240-47BA-966B-60B28DD50774__CHDFGFJC">示例8-7</a>使用<code class="codeph">XMLElement</code>生成包含员工和部门信息的XML文档，使用示例数据库模式表<code class="codeph">hr.departments</code> 。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-49E8774C-E240-47BA-966B-60B28DD50774__CHDGFEIF">
                           <p class="titleinexample">例8-1 XMLELEMENT：格式化日期</p><pre class="oac_no_warn" dir="ltr">- 使用标准XML日期格式：SELECT XMLElement（“Date”，hire_date）FROM hr.employees WHERE employee_id = 203; XMLELEMENT（“DATE”，HIRE_DATE）---------------------------- &lt;Date&gt; 2002-06-07 &lt;/ Date&gt; 1行选择。- 使用备用日期格式：SELECT XMLElement（“Date”， <span class="bold">to_char</span> （hire_date））FROM hr.employees WHERE employee_id = 203; XMLELEMENT（“DATE”，TO_CHAR（HIRE_DATE））------------------------------------- &lt;Date &gt; <span class="bold">07-JUN-02</span> &lt;/ Date&gt;选择1行。
</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-49E8774C-E240-47BA-966B-60B28DD50774__CHEGBHCC">
                           <p class="titleinexample">示例8-2 XMLELEMENT：为每个员工生成一个元素</p><pre class="oac_no_warn" dir="ltr">SELECT e.employee_id，XMLELEMENT（“Emp”，e.first_name ||''|| e.last_name）AS“RESULT”FROM hr.employees e WHERE employee_id&gt; 200;</pre><p>此查询产生以下典型结果：</p><pre class="oac_no_warn" dir="ltr">EMPLOYEE_ID结果----------- ----------------------------------- 201 &lt; Emp&gt; Michael Hartstein &lt;/ Emp&gt; 202 &lt;Emp&gt; Pat Fay &lt;/ Emp&gt; 203 &lt;Emp&gt; Susan Mavris &lt;/ Emp&gt; 204 &lt;Emp&gt; Hermann Baer &lt;/ Emp&gt; 205 &lt;Emp&gt; Shelley Higgins &lt;/ Emp&gt; 206 &lt; Emp&gt; William Gietz &lt;/ Emp&gt;选择了6行。
</pre><p>SQL / XML函数<code class="codeph">XMLElement</code>也可以嵌套，以生成具有嵌套结构的XML数据。
                           </p>
                        </div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-49E8774C-E240-47BA-966B-60B28DD50774__CHEGGIGG">
                           <p class="titleinexample">例8-3 XMLELEMENT：生成嵌套XML</p><pre class="oac_no_warn" dir="ltr">SELECT XMLElement（“Emp”，XMLElement（“name”，e.first_name ||''|| e.last_name），XMLElement（“hiredate”，e.hire_date））AS“RESULT”来自hr.employees e WHERE employee_id&gt; 200;</pre><p>此查询生成以下典型的XML结果：</p><pre class="oac_no_warn" dir="ltr">结果------------------------------------------------- ---------------------- &lt;Emp&gt; &lt;name&gt; Michael Hartstein &lt;/ name&gt; &lt;hiredate&gt; 2004-02-17 &lt;/ hiredate&gt; &lt;/ Emp&gt; &lt;Emp&gt; &lt;name&gt; Pat Fay &lt;/ name&gt; &lt;hiredate&gt; 2005-08-17 &lt;/ hiredate&gt; &lt;/ Emp&gt; &lt;Emp&gt; &lt;name&gt; Susan Mavris &lt;/ name&gt; &lt;hiredate&gt; 2002-06-07 &lt;/ hiredate&gt; &lt;/ Emp&gt; &lt;Emp&gt; &lt;name&gt; Hermann Baer &lt;/ name&gt; &lt;hiredate&gt; 2002-06-07 &lt;/ hiredate&gt; &lt;/ Emp&gt; &lt;Emp&gt; &lt;name&gt; Shelley Higgins &lt;/ name&gt; &lt;hiredate&gt; 2002 -06-07 &lt;/ hiredate&gt; &lt;/ Emp&gt; &lt;Emp&gt; &lt;name&gt; William Gietz &lt;/ name&gt; &lt;hiredate&gt; 2002-06-07 &lt;/ hiredate&gt; &lt;/ Emp&gt;选择了6行。
</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-49E8774C-E240-47BA-966B-60B28DD50774__CHEDFACF">
                           <p class="titleinexample">示例8-4 XMLELEMENT：使用属性ID和名称生成员工元素</p><pre class="oac_no_warn" dir="ltr">SELECT XMLElement（“Emp”，XMLAttributes（e.employee_id as“ID”，e.first_name ||''|| e.last_name AS“name”））AS“RESULT”FROM hr.employees e WHERE employee_id&gt; 200;</pre><p>此查询生成以下典型的XML结果片段：</p><pre class="oac_no_warn" dir="ltr">结果----------------------------------------------- &lt;Emp ID =“201”name =“Michael Hartstein”&gt; &lt;/ Emp&gt; &lt;Emp ID =“202”name =“Pat Fay”&gt; &lt;/ Emp&gt; &lt;Emp ID =“203”name =“Susan Mavris”&gt; &lt;/ Emp&gt; &lt;Emp ID =“204”name =“Hermann Baer”&gt; &lt;/ Emp&gt; &lt;Emp ID =“205”name =“Shelley Higgins”&gt; &lt;/ Emp&gt; &lt;Emp ID =“206”name =“William Gietz “&gt; &lt;/ Emp&gt;选择了6行。
</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-49E8774C-E240-47BA-966B-60B28DD50774__CHEIEAJH">
                           <p class="titleinexample">示例8-5 XMLELEMENT：生成的XML数据中的字符未被转义</p><pre class="oac_no_warn" dir="ltr">SELECT XMLElement（“Emp- <span class="bold">&gt;</span> Special”，XMLAttributes（e.last_name ||'，'|| e.first_name AS“Last <span class="bold">，</span> First”））AS“RESULT”FROM hr.employees e WHERE employee_id = 201;</pre><p>此查询生成以下结果，该结果<span class="italic">不是</span>格式良好的XML：</p><pre class="oac_no_warn" dir="ltr">结果------------------------------------------------- ------------------- &lt;Emp- <span class="bold">&gt;</span> Special Last <span class="bold">，</span> First =“Hartstein，Michael”&gt; &lt;/ Emp- <span class="bold">&gt;</span> Special&gt;选择1行。
</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-49E8774C-E240-47BA-966B-60B28DD50774__CHEHAGJJ">
                           <p class="titleinexample">示例8-6使用带有命名空间的XMLELEMENT创建基于模式的XML文档</p><pre class="oac_no_warn" dir="ltr">SELECT XMLElement（“Employee”，XMLAttributes（'http://www.w3.org/2001/XMLSchema'AS"xmlns：xsi“，'http：//www.oracle.com/Employee.xsd'AS”xsi： nonamespaceSchemaLocation“），XMLForest（employee_id，last_name，salary））AS”RESULT“FROM hr.employees WHERE department_id = 10;</pre><p>这将创建符合XML模式<code class="codeph">Employee.xsd</code>的以下XML文档。（为清楚起见，此处显示的结果非常清晰。）
                           </p><pre class="oac_no_warn" dir="ltr">结果------------------------------------------------- ---------------------------- &lt;Employee xmlns：xsi =“http://www.w3.org/2001/XMLSchema”xsi ：nonamespaceSchemaLocation =“http://www.oracle.com/Employee.xsd”&gt; &lt;EMPLOYEE_ID&gt; 200 &lt;/ EMPLOYEE_ID&gt; &lt;LAST_NAME&gt; Whalen &lt;/ LAST_NAME&gt; &lt;SALARY&gt; 4400 &lt;/ SALARY&gt; &lt;/ Employee&gt;选择了1行。
</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-49E8774C-E240-47BA-966B-60B28DD50774__CHDFGFJC">
                           <p class="titleinexample">例8-7 XMLELEMENT：从用户定义的数据类型实例生成元素</p><pre class="oac_no_warn" dir="ltr">创建或替换类型emp_t AS OBJECT（“@ EMPNO”NUMBER（4），ENAME VARCHAR2（10））;创建或替换类型emplist_t AS表格emp_t;创建或替换类型dept_t AS OBJECT（“@DEPTNO”NUMBER（2），DNAME VARCHAR2（14），EMP_LIST emplist_t）; SELECT XMLElement（“Department”，dept_t（department_id，department_name，cast（MULTISET（SELECT employee_id，last_name FROM hr.employees e WHERE e.department_id = d.department_id）AS emplist_t）））AS deptxml FROM hr.departments d WHERE d。 department_id = 10;</pre><p>这将生成一个XML文档，其中包含<code class="codeph">Department</code>元素和<code class="codeph">dept_t</code>类型的规范映射。
                           </p><pre class="oac_no_warn" dir="ltr">DEPTXML ------------- &lt;部门&gt; &lt;DEPT_T DEPTNO =“10”&gt; &lt;DNAME&gt;会计&lt;/ DNAME&gt; &lt;EMPLIST&gt; &lt;EMP_T EMPNO =“7782”&gt; &lt;ENAME&gt; CLARK &lt;/ ENAME&gt; &lt;/ EMP_T&gt; &lt;EMP_T EMPNO =“7839”&gt; &lt;ENAME&gt; KING &lt;/ ENAME&gt; &lt;/ EMP_T&gt; &lt;EMP_T EMPNO =“7934”&gt; &lt;ENAME&gt; MILLER &lt;/ ENAME&gt; &lt;/ EMP_T&gt; &lt;/ EMPLIST&gt; &lt;/ DEPT_T&gt; &lt;/ Department&gt;选择了1行。</pre></div>
                        <!-- class="example" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="generation-of-XML-data-from-relational-data.html#GUID-868E591C-19A1-4E4A-BC2A-013181071B77" title="SQL / XML标准函数XMLElement根据关系数据构造XML元素。SQL / XML标准函数XMLAttributes可与XMLElement一起使用，以指定生成的元素的属性。">XMLELEMENT和XMLATTRIBUTES SQL / XML函数</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="ADXDB5007"></a><a id="ADXDB5008"></a><a id="ADXDB5009"></a><a id="ADXDB5006"></a><div class="props_rev_3"><a id="GUID-D9666485-0383-4AF6-B352-B9A90AE1DCFB" name="GUID-D9666485-0383-4AF6-B352-B9A90AE1DCFB"></a><h4 id="ADXDB-GUID-D9666485-0383-4AF6-B352-B9A90AE1DCFB" class="sect4"><span class="enumeration_section">8.2.2</span> XMLFOREST SQL / XML函数</h4>
                  <div>
                     <p>您使用SQL / XML标准函数<code class="codeph">XMLForest</code>来构造XML元素的林。
                     </p>
                     <div class="section">
                        <p>它的参数是要评估的表达式，带有可选的别名。<a href="generation-of-XML-data-from-relational-data.html#GUID-D9666485-0383-4AF6-B352-B9A90AE1DCFB__I1030830">图8-3</a>描述了<code class="codeph">XMLForest</code>语法。
                        </p>
                        <div class="figure" id="GUID-D9666485-0383-4AF6-B352-B9A90AE1DCFB__I1030830">
                           <p class="titleinfigure">图8-3 XMLFOREST语法</p><img src="img/xmlforest.gif" width="444" alt="下面是图8-3的描述" title="下面是图8-3的描述" longdesc="img_text/xmlforest.html"><br><a href="img_text/xmlforest.html">“图8-3 XMLFOREST语法”的说明</a></div>
                        <!-- class="figure" -->
                        <p>每个值表达式（ <a href="generation-of-XML-data-from-relational-data.html#GUID-D9666485-0383-4AF6-B352-B9A90AE1DCFB__I1030830">图8-3中的</a> <span class="italic"><code class="codeph">value_expr</code></span> ）都转换为XML格式，并且可选地，标识符<span class="italic"><code class="codeph">c_alias</code></span>用作属性标识符（ <span class="italic"><code class="codeph">c_alias</code></span>可以是字符串文字或<code class="codeph">EVALNAME</code>后跟表达式，其值为字符串文字）。使用<code class="codeph">EVALNAME</code>的可能性是标准SQL / XML函数<code class="codeph">XMLForest</code>的Oracle扩展。</p>
                        <p>对于对象类型或集合， <code class="codeph">AS</code>子句是必需的。对于其他类型， <code class="codeph">AS</code>子句是可选的。对于给定的表达式，如果省略了<code class="codeph">AS</code>子句，则会对已计算的值表达式中的字符进行<span class="italic">转义，</span>以形成该元素的封闭标记的名称。转义是<a href="generation-of-XML-data-from-relational-data.html#GUID-5BE09A7D-80D8-4734-B9AF-4A61F27FA9B2" title="根据SQL / XML标准的规定，显式标识符中的字符不会以任何方式进行转义 - 由您来确保使用有效的XML名称。这适用于所有SQL / XML函数。">在生成的XML数据中的字符</a>转义中定义的。如果值表达式的计算结果为<code class="codeph">NULL</code> ，则不会为该表达式创建任何元素。
                        </p>
                        <p><a href="generation-of-XML-data-from-relational-data.html#GUID-D9666485-0383-4AF6-B352-B9A90AE1DCFB__CHDBJDAG">示例8-8</a>使用<code class="codeph">XMLElement</code>和<code class="codeph">XMLForest</code>为每个员工生成一个<code class="codeph">Emp</code>元素，其中包含<code class="codeph">name</code>属性以及包含员工雇用日期和部门作为内容的子元素。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-D9666485-0383-4AF6-B352-B9A90AE1DCFB__CHDBJDAG">
                        <p class="titleinexample">例8-8 XMLFOREST：使用属性和子元素生成元素</p><pre class="oac_no_warn" dir="ltr">SELECT XMLElement（“Emp”，XMLAttributes（e.first_name ||''|| e.last_name AS“name”），XMLForest（e.hire_date，e.department AS“department”））AS“RESULT”来自员工e WHERE e.department_id = 20;</pre><p>（这里使用<code class="codeph">WHERE</code>子句来保持示例简短。）此查询生成以下XML结果：</p><pre class="oac_no_warn" dir="ltr">结果------------------------------------- &lt;Emp name =“Michael Hartstein”&gt; &lt;HIRE_DATE&gt; 2004-02-17 &lt;/ HIRE_DATE&gt; &lt;department&gt; 20 &lt;/ department&gt; &lt;/ Emp&gt; &lt;Emp name =“Pat Fay”&gt; &lt;HIRE_DATE&gt; 2005-08-17 &lt;/ HIRE_DATE&gt; &lt;department&gt; 20 &lt;/ department&gt; &lt;/ Emp&gt;选择了2行。</pre></div>
                     <!-- class="example" -->
                     <div class="section">
                        <div class="infoboxnotealso" id="GUID-D9666485-0383-4AF6-B352-B9A90AE1DCFB__GUID-6B7023B4-A0A7-4D43-AA24-92C36CEC1EB1">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="generation-of-XML-data-from-relational-data.html#GUID-F643284F-A6AF-47A9-AF2C-58EF7E88C87F__CHDBEBGD">例8-19</a></p>
                        </div>
                        <p><a href="generation-of-XML-data-from-relational-data.html#GUID-D9666485-0383-4AF6-B352-B9A90AE1DCFB__CHEFIJFD">例8-9</a>使用<code class="codeph">XMLForest</code>从用户定义的数据类型实例生成分层XML数据。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-D9666485-0383-4AF6-B352-B9A90AE1DCFB__CHEFIJFD">
                        <p class="titleinexample">示例8-9 XMLFOREST：从用户定义的数据类型实例生成元素</p><pre class="oac_no_warn" dir="ltr">SELECT XMLForest（dept_t（department_id，department_name，cast（MULTISET（SELECT employee_id，last_name FROM hr.employees e WHERE e.department_id = d.department_id）AS emplist_t））AS“Department”）AS deptxml FROM hr.departments d WHERE department_id = 10;</pre></div>
                     <!-- class="example" -->
                     <div class="section">
                        <p>这将生成一个XML文档，其元素<code class="codeph">Department</code>包含属性<code class="codeph">DEPTNO</code>和子元素<code class="codeph">DNAME</code> 。</p><pre class="oac_no_warn" dir="ltr">DEPTXML --------------------------------- &lt;Department DEPTNO =“10”&gt; &lt;DNAME&gt;管理&lt;/ DNAME&gt; &lt;EMP_LIST&gt; &lt;EMP_T EMPNO =“200”&gt; &lt;ENAME&gt; Whalen &lt;/ ENAME&gt; &lt;/ EMP_T&gt; &lt;/ EMP_LIST&gt; &lt;/ Department&gt;选择了1行。
</pre><p>您可能希望将此示例与<a href="generation-of-XML-data-from-relational-data.html#GUID-49E8774C-E240-47BA-966B-60B28DD50774__CHDFGFJC">示例8-7</a>和<a href="generation-of-XML-data-from-relational-data.html#GUID-7AF139F8-FD60-4113-AD10-1C404FF62B45__I1025801">示例8-24</a>进行比较。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="generation-of-XML-data-from-relational-data.html#GUID-0B4F8285-CB3B-42D1-94AC-7397BBAFC967" title="Oracle XML DB提供了可用于构造XML数据的SQL函数。其中大多数都属于SQL / XML标准。">使用SQL函数生成XML数据</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB5017"></a><a id="ADXDB5018"></a><a id="ADXDB5019"></a><a id="ADXDB5016"></a><div class="props_rev_3"><a id="GUID-3806853D-2AAA-4D2D-AD98-3E0941F7BE17" name="GUID-3806853D-2AAA-4D2D-AD98-3E0941F7BE17"></a><h4 id="ADXDB-GUID-3806853D-2AAA-4D2D-AD98-3E0941F7BE17" class="sect4"><span class="enumeration_section">8.2.3</span> XMLCONCAT SQL / XML函数</h4>
                  <div>
                     <p>您可以使用SQL / XML标准函数<code class="codeph">XMLConcat</code>通过连接多个<code class="codeph">XMLType</code>实例来构造XML片段。
                     </p>
                     <div class="section">
                        <p><a href="generation-of-XML-data-from-relational-data.html#GUID-3806853D-2AAA-4D2D-AD98-3E0941F7BE17__I1032783">图8-4</a>显示了<code class="codeph">XMLConcat</code>语法。函数<code class="codeph">XMLConcat</code>有两种形式：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>第一种形式将<code class="codeph">XMLSequenceType</code>值作为参数，该值是<code class="codeph">XMLType</code>实例的varray，并返回单个<code class="codeph">XMLType</code>实例，该实例是varray的所有元素的串联。此表单对于将<code class="codeph">XMLType</code>实例列表折叠到单个实例中非常有用。
                              </p>
                           </li>
                           <li>
                              <p>第二种形式采用任意数量的<code class="codeph">XMLType</code>实例并将它们连接在一起。如果其中一个值为<code class="codeph">NULL</code> ，则在结果中忽略它。如果所有值都为<code class="codeph">NULL</code> ，则结果为<code class="codeph">NULL</code> 。此表单用于连接同一行中的任意数量的<code class="codeph">XMLType</code>实例。函数<code class="codeph">XMLAgg</code>可用于<code class="codeph">XMLAgg</code>连接<code class="codeph">XMLType</code>实例。
                              </p>
                           </li>
                        </ul>
                        <div class="figure" id="GUID-3806853D-2AAA-4D2D-AD98-3E0941F7BE17__I1032783">
                           <p class="titleinfigure">图8-4 XMLCONCAT语法</p><img src="img/xmlconcat.gif" width="256" alt="下面是图8-4的描述" title="下面是图8-4的描述" longdesc="img_text/xmlconcat.html"><br><a href="img_text/xmlconcat.html">“图8-4 XMLCONCAT语法”的说明</a></div>
                        <!-- class="figure" -->
                        <p><a href="generation-of-XML-data-from-relational-data.html#GUID-3806853D-2AAA-4D2D-AD98-3E0941F7BE17__CHECFIGF">实施例8-10</a>使用SQL / XML功能<code class="codeph">XMLConcat</code>返回的级联<code class="codeph">XMLType</code>从实例<code class="codeph">XMLSequenceType</code>值（的VARRAY <code class="codeph">XMLType</code>实例）。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-3806853D-2AAA-4D2D-AD98-3E0941F7BE17__CHECFIGF">
                        <p class="titleinexample">示例8-10 XMLCONCAT：从序列中连接XMLType实例</p><pre class="oac_no_warn" dir="ltr">SELECT XMLSerialize（CONTENT XMLConcat（XMLSequenceType（XMLType（'&lt;PartNo&gt; 1236 &lt;/ PartNo&gt;'），XMLType（'&lt;PartName&gt; Widget &lt;/ PartName&gt;'），XMLType（'&lt;PartPrice&gt; 29.99 &lt;/ PartPrice&gt;'）） ）AS CLOB）来自DUAL的“结果”;</pre><p>此查询返回单个XML片段。（为清楚起见，此处显示的结果非常清晰。）</p><pre class="oac_no_warn" dir="ltr">RESULT --------------- &lt;PartNo&gt; 1236 &lt;/ PartNo&gt; &lt;PartName&gt; Widget &lt;/ PartName&gt; &lt;PartPrice&gt; 29.99 &lt;/ PartPrice&gt;选择了1行。
</pre></div>
                     <!-- class="example" -->
                     <div class="section">
                        <p><a href="generation-of-XML-data-from-relational-data.html#GUID-3806853D-2AAA-4D2D-AD98-3E0941F7BE17__CHECFCJG">示例8-11</a>使用<code class="codeph">XMLConcat</code>为员工姓氏和姓氏创建和连接XML元素。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-3806853D-2AAA-4D2D-AD98-3E0941F7BE17__CHECFCJG">
                        <p class="titleinexample">示例8-11 XMLCONCAT：连接XML元素</p><pre class="oac_no_warn" dir="ltr">SELECT XMLConcat（XMLElement（“first”，e.first_name），XMLElement（“last”，e.last_name））AS“RESULT”FROM employees e;</pre><p>此查询生成以下XML片段：</p><pre class="oac_no_warn" dir="ltr">RESULT -------------------------------------------- &lt;first&gt; Den &lt; / first&gt; &lt;last&gt; Raphaely &lt;/ last&gt; &lt;first&gt; Alexander &lt;/ first&gt; &lt;last&gt; Khoo &lt;/ last&gt; &lt;first&gt; Shelli &lt;/ first&gt; &lt;last&gt; Baida &lt;/ last&gt; &lt;first&gt; Sigal &lt;/ first &gt; &lt;last&gt; Tobias &lt;/ last&gt; &lt;first&gt; Guy &lt;/ first&gt; &lt;last&gt; Himuro &lt;/ last&gt; &lt;first&gt; Karen &lt;/ first&gt; &lt;last&gt; Colmenares &lt;/ last&gt;选择了6行。</pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="generation-of-XML-data-from-relational-data.html#GUID-0B4F8285-CB3B-42D1-94AC-7397BBAFC967" title="Oracle XML DB提供了可用于构造XML数据的SQL函数。其中大多数都属于SQL / XML标准。">使用SQL函数生成XML数据</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB5021"></a><a id="ADXDB5022"></a><a id="ADXDB5896"></a><a id="ADXDB5023"></a><a id="ADXDB5020"></a><div class="props_rev_3"><a id="GUID-971232BA-B52E-44CB-86DA-E182AF7E2ACB" name="GUID-971232BA-B52E-44CB-86DA-E182AF7E2ACB"></a><h4 id="ADXDB-GUID-971232BA-B52E-44CB-86DA-E182AF7E2ACB" class="sect4"><span class="enumeration_section">8.2.4</span> XMLAGG SQL / XML函数</h4>
                  <div>
                     <p>您使用SQL / XML标准函数<code class="codeph">XMLAgg</code>从XML元素集合构造XML元素林 - 它是一个聚合函数。
                     </p>
                     <div class="section">
                        <p><a href="generation-of-XML-data-from-relational-data.html#GUID-971232BA-B52E-44CB-86DA-E182AF7E2ACB__I1032735">图8-5</a>描述了<code class="codeph">XMLAgg</code>语法。
                        </p>
                        <div class="figure" id="GUID-971232BA-B52E-44CB-86DA-E182AF7E2ACB__I1032735">
                           <p class="titleinfigure">图8-5 XMLAGG语法</p><img src="img/xmlagg.gif" width="335" alt="下面是图8-5的描述" title="下面是图8-5的描述" longdesc="img_text/xmlagg.html"><br><a href="img_text/xmlagg.html">“图8-5 XMLAGG语法”的说明</a></div>
                        <!-- class="figure" -->
                        <p><code class="codeph">order_by_clause</code>如下：</p><pre class="oac_no_warn" dir="ltr">ORDER BY [list of：expr [ASC | DESC] [NULLS {FIRST | LAST}]]</pre><p>数字文字<span class="italic">不会被</span>解释为列位置。例如， <code class="codeph">ORDER BY 1</code>并不意味着第一列的顺序。相反，数字文字被解释为任何其他文字。
                        </p>
                        <p>与SQL / XML函数<code class="codeph">XMLConcat</code> ，从结果中删除任何值为<code class="codeph">NULL</code>参数。SQL / XML函数<code class="codeph">XMLAgg</code>类似于Oracle SQL函数<code class="codeph">sys_XMLAgg</code> ，但<code class="codeph">XMLAgg</code>返回一个节点林，它不接受<code class="codeph">XMLFormat</code>参数。
                        </p>
                        <p>SQL / XML函数<code class="codeph">XMLAgg</code>可用于跨<span class="italic">多行</span>连接<code class="codeph">XMLType</code>实例。它还接受可选的<code class="codeph">ORDER BY</code>子句，以便对聚合的XML值进行排序。函数<code class="codeph">XMLAgg</code>为每个组生成一个聚合XML结果。如果查询中没有指定group，则它将为查询的所有行返回单个聚合XML结果。
                        </p>
                        <p><a href="generation-of-XML-data-from-relational-data.html#GUID-971232BA-B52E-44CB-86DA-E182AF7E2ACB__CHEJIFCD">示例8-12</a>使用SQL / XML函数<code class="codeph">XMLAgg</code>和<code class="codeph">XMLElement</code>构造一个<code class="codeph">Department</code>元素，该元素包含具有员工作业ID和姓氏作为其内容的<code class="codeph">Employee</code>元素。它还按员工姓氏对部门中的<code class="codeph">Employee</code>元素进行排序。（为清楚起见，结果显示为漂亮的。）
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-971232BA-B52E-44CB-86DA-E182AF7E2ACB__CHEJIFCD">
                        <p class="titleinexample">示例8-12 XMLAGG：使用子Employee元素生成Department元素</p><pre class="oac_no_warn" dir="ltr">SELECT XMLElement（“Department”，XMLAgg（XMLElement（“Employee”，e.job_id ||''|| e.last_name）ORDER BY e.last_name））AS“Dept_list”FROM hr.employees e WHERE e.department_id = 30或e.department_id = 40; Dept_list ------------------ &lt;部门&gt; &lt;员工&gt; PU_CLERK百大&lt;/员工&gt; &lt;员工&gt; PU_CLERK Colmenares &lt;/ Employee&gt; &lt;员工&gt; PU_CLERK Himuro &lt;/ Employee&gt; &lt;员工&gt; PU_CLERK Khoo &lt;/员工&gt; &lt;员工&gt; HR_REP Mavris &lt;/员工&gt; &lt;员工&gt; PU_MAN Raphaely &lt;/ Employee&gt; &lt;员工&gt; PU_CLERK Tobias &lt;/ Employee&gt; &lt;/ Department&gt;选择<span class="bold">1</span>行。
</pre></div>
                     <!-- class="example" -->
                     <div class="section">
                        <p>结果是<span class="italic">单行</span> ，因为<code class="codeph">XMLAgg</code>聚合了员工行。
                        </p>
                        <p><a href="generation-of-XML-data-from-relational-data.html#GUID-971232BA-B52E-44CB-86DA-E182AF7E2ACB__CHEEEACD">例8-13</a>显示了如何使用<code class="codeph">GROUP</code> <code class="codeph">BY</code>子句将返回的行集分组为多个组，形成多个<code class="codeph">Department</code>元素。（为清楚起见，此处显示的结果非常清晰。）
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-971232BA-B52E-44CB-86DA-E182AF7E2ACB__CHEEEACD">
                        <p class="titleinexample">示例8-13 XMLAGG：使用GROUP BY生成多个部门元素</p><pre class="oac_no_warn" dir="ltr">SELECT XMLElement（“Department”，XMLAttributes（department_id AS“deptno”），XMLAgg（XMLElement（“Employee”，e.job_id ||''|| e.last_name）））AS“Dept_list”FROM hr.employees e <span class="bold">GROUP BY e.department_id;</span> Dept_list ------------------ &lt;部门deptno =“ <span class="bold">30</span> ”&gt; &lt;员工&gt; PU_MAN Raphaely &lt;/ Employee&gt; &lt;员工&gt; PU_CLERK Colmenares &lt;/ Employee&gt; &lt;Employee&gt; PU_CLERK Himuro &lt;/ Employee&gt; &lt;Employee&gt; PU_CLERK Tobias &lt;/ Employee&gt; &lt;Employee&gt; PU_CLERK Baida &lt;/ Employee&gt; &lt;Employee&gt; PU_CLERK Khoo &lt;/ Employee&gt; &lt;/ Department&gt; &lt;Department deptno =“ <span class="bold">40</span> ”&gt; &lt;Employee&gt; HR_REP Mavris &lt;/员工&gt; &lt;/ Department&gt;选择了<span class="bold">2</span>行。
</pre></div>
                     <!-- class="example" -->
                     <div class="section">
                        <p>您可以使用<code class="codeph">XMLAgg</code>表达式中的<code class="codeph">ORDER BY</code>子句对每个部门中的员工进行<code class="codeph">XMLAgg</code> 。
                        </p>
                        <div class="infoboxnote" id="GUID-971232BA-B52E-44CB-86DA-E182AF7E2ACB__GUID-1591AAE9-4479-4F45-906D-B1E9A732D6CF">
                           <p class="notep1">注意：</p>
                           <p>在<code class="codeph">ORDER BY</code>子句中，Oracle数据库不会将数字文字解释为列位置，就像在该子句的其他用途中一样。
                           </p>
                        </div>
                        <p>函数<code class="codeph">XMLAgg</code>可用于反映表中存在的某些关系的层次结构特性。<a href="generation-of-XML-data-from-relational-data.html#GUID-971232BA-B52E-44CB-86DA-E182AF7E2ACB__CHEHHCJI">例8-14</a>为部门30生成部门元素。在该元素内是该部门的每个雇员的子元素<code class="codeph">emp</code> 。在每个employee元素中，是该员工的每个依赖项的<code class="codeph">dependent</code>元素。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-971232BA-B52E-44CB-86DA-E182AF7E2ACB__CHEHHCJI">
                        <p class="titleinexample">例8-14 XMLAGG：生成嵌套元素</p><pre class="oac_no_warn" dir="ltr">SELECT last_name，employee_id FROM employees WHERE department_id = 30; LAST_NAME EMPLOYEE_ID ------------------------- ----------- Raphaely 114 Khoo 115 Baida 116 Tobias 117 Himuro 118 Colmenares 119选择了6行。
 </pre><p><code class="codeph">dependents</code>表持有每位员工的家属。
                        </p><pre class="oac_no_warn" dir="ltr">CREATE TABLE hr.dependents（id NUMBER（4）PRIMARY KEY，employee_id NUMBER（4），name VARCHAR2（10））;表创建。INSERT INTO依赖VALUE（1,114，'MARK'）;已创建1行。INSERT INTO依赖VALUE（2,114，'JACK'）;已创建1行。插入家属（3,115，'JANE'）;已创建1行。插入家属（4,116，'海伦'）;已创建1行。插入家属（5,116，'FRANK'）;已创建1行。承诺;提交完成。
 </pre><p>以下查询为包含依赖项信息的部门生成XML数据。（为清楚起见，此处显示的结果非常清晰。）</p><pre class="oac_no_warn" dir="ltr">SELECT XMLElement（“Department”，XMLAttributes（d.department_name AS“name”），（SELECT XMLAgg（XMLElement（“emp”，XMLAttributes（e.last_name AS name），（SELECT XMLAgg（XMLElement（“dependent”，XMLAttributes（de） .name AS“name”）））FROM dependents de WHERE de.employee_id = e.employee_id）））FROM employees e WHERE e.department_id = d.department_id））AS“dept_list”FROM departments d WHERE department_id = 30; dept_list ------------------------------------------------- ------------------------------- &lt;部门名称=“采购”&gt; &lt;emp NAME =“Raphaely”&gt; &lt;依赖名称=“MARK”&gt; &lt;/ dependent&gt; &lt;dependent name =“JACK”&gt; &lt;/ dependent&gt; &lt;/ emp&gt; &lt;emp NAME =“Khoo”&gt; &lt;dependent name =“JANE”&gt; &lt;/ dependent&gt; &lt;/ emp&gt; &lt; emp NAME =“Baida”&gt; &lt;dependent name =“HELEN”&gt; &lt;/ dependent&gt; &lt;dependent name =“FRANK”&gt; &lt;/ dependent&gt; &lt;/ emp&gt; &lt;emp NAME =“Tobias”&gt; &lt;/ emp&gt; &lt;emp NAME =“Himuro”&gt; &lt;/ emp&gt; &lt;emp NAME =“Colmenares”&gt; &lt;/ emp&gt; &lt;/ Department&gt;选择1行。</pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="generation-of-XML-data-from-relational-data.html#GUID-0B4F8285-CB3B-42D1-94AC-7397BBAFC967" title="Oracle XML DB提供了可用于构造XML数据的SQL函数。其中大多数都属于SQL / XML标准。">使用SQL函数生成XML数据</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB5025"></a><a id="ADXDB5026"></a><a id="ADXDB5024"></a><div class="props_rev_3"><a id="GUID-43A6EF19-9A0D-4AA8-B73E-21A46BFFA81C" name="GUID-43A6EF19-9A0D-4AA8-B73E-21A46BFFA81C"></a><h4 id="ADXDB-GUID-43A6EF19-9A0D-4AA8-B73E-21A46BFFA81C" class="sect4"><span class="enumeration_section">8.2.5</span> XMLPI SQL / XML函数</h4>
                  <div>
                     <p>您使用SQL / XML标准函数<code class="codeph">XMLPI</code>来构造XML处理指令（PI）。
                     </p>
                     <div class="section">
                        <p><a href="generation-of-XML-data-from-relational-data.html#GUID-43A6EF19-9A0D-4AA8-B73E-21A46BFFA81C__CHDIAAEJ">图8-6</a>显示了语法：</p>
                        <div class="figure" id="GUID-43A6EF19-9A0D-4AA8-B73E-21A46BFFA81C__CHDIAAEJ">
                           <p class="titleinfigure">图8-6 XMLPI语法</p><img src="img/xmlpi.gif" width="388" alt="下面是图8-6的描述" title="下面是图8-6的描述" longdesc="img_text/xmlpi.html"><br><a href="img_text/xmlpi.html">“图8-6 XMLPI语法”的说明</a></div>
                        <!-- class="figure" -->
                        <p>计算参数<span class="italic"><code class="codeph">value_expr</code></span> ，并将字符串结果附加到可选标识符（ <span class="italic"><code class="codeph">identifier</code></span> ），用空格分隔。这个连接被包含在<code class="codeph">"&lt;?"</code>和<code class="codeph">"?&gt;</code> “创建处理指令。也就是说，如果<span class="italic"><code class="codeph">string-result</code></span>是评估<span class="italic"><code class="codeph">value_expr</code></span>的结果，那么生成的处理指令是<code class="codeph">&lt;?</code><span class="italic"><code class="codeph">identifier</code></span> <span class="italic"><code class="codeph">string-result?&gt;</code></span> 。如果<span class="italic"><code class="codeph">string-result</code></span>是空字符串<code class="codeph">''</code> ，那么函数返回<code class="codeph">&lt;?</code><span class="italic"><code class="codeph">identifier</code></span> <span class="italic"><code class="codeph">?&gt;</code></span> 。
                        </p>
                        <p>作为使用关键字<code class="codeph">NAME</code>后跟<span class="italic">文字</span>字符串<span class="italic"><code class="codeph">identifier</code></span>的替代方法，您可以使用关键字<code class="codeph">EVALNAME</code>后跟一个表达式，该表达式计算为要用作标识符的字符串。使用<code class="codeph">EVALNAME</code>的可能性是标准SQL / XML函数<code class="codeph">XMLPI</code>的Oracle扩展。</p>
                        <p>如果构造的XML不是合法的XML处理指令，则会引发错误。特别是：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><span class="italic"><code class="codeph">identifier</code></span> <span class="italic">不能</span>是单词“ <code class="codeph">xml</code> ”（大写，小写或大小写混合）。
                              </p>
                           </li>
                           <li>
                              <p><span class="italic"><code class="codeph">string-result</code></span> <span class="italic">不能</span>包含字符序列“ <code class="codeph">?&gt;</code> “。
                              </p>
                           </li>
                        </ul>
                        <p>函数<code class="codeph">XMLPI</code>返回<code class="codeph">XMLType</code>的实例。如果<span class="italic"><code class="codeph">string-result</code></span>为<code class="codeph">NULL</code> ，则返回<code class="codeph">NULL</code> 。</p>
                        <p><a href="generation-of-XML-data-from-relational-data.html#GUID-43A6EF19-9A0D-4AA8-B73E-21A46BFFA81C__CHEFBGFC">例8-15</a>使用<code class="codeph">XMLPI</code>生成一个简单的处理指令。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-43A6EF19-9A0D-4AA8-B73E-21A46BFFA81C__CHEFBGFC">
                        <p class="titleinexample">示例8-15使用SQL / XML函数XMLPI</p><pre class="pre codeblock"><code>SELECT XMLPI（名称“OrderAnalysisComp”，“导入，重新配置，反汇编”）AS pi FROM DUAL;</code></pre><p>这导致以下输出：</p><pre class="pre codeblock"><code>PI ------------------------------------------------- --------- &lt;？OrderAnalysisComp导入，重新配置，反汇编？&gt;选择了1行。</code></pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="generation-of-XML-data-from-relational-data.html#GUID-0B4F8285-CB3B-42D1-94AC-7397BBAFC967" title="Oracle XML DB提供了可用于构造XML数据的SQL函数。其中大多数都属于SQL / XML标准。">使用SQL函数生成XML数据</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB5028"></a><a id="ADXDB5029"></a><a id="ADXDB5027"></a><div class="props_rev_3"><a id="GUID-CEE20C19-F599-4154-ABFA-B2D062C4F915" name="GUID-CEE20C19-F599-4154-ABFA-B2D062C4F915"></a><h4 id="ADXDB-GUID-CEE20C19-F599-4154-ABFA-B2D062C4F915" class="sect4"><span class="enumeration_section">8.2.6</span> XMLCOMMENT SQL / XML函数</h4>
                  <div>
                     <p>您使用SQL / XML标准函数<code class="codeph">XMLComment</code>来构造XML注释。
                     </p>
                     <div class="section">
                        <p><a href="generation-of-XML-data-from-relational-data.html#GUID-CEE20C19-F599-4154-ABFA-B2D062C4F915__CHDFIFFI">图8-7</a>显示了语法：</p>
                        <div class="figure" id="GUID-CEE20C19-F599-4154-ABFA-B2D062C4F915__CHDFIFFI">
                           <p class="titleinfigure">图8-7 XMLComment语法</p><img src="img/xmlcomment.gif" width="208" alt="下面是图8-7的描述" title="下面是图8-7的描述" longdesc="img_text/xmlcomment.html"><br><a href="img_text/xmlcomment.html">“图8-7 XMLComment语法”的说明</a></div>
                        <!-- class="figure" -->
                        <p>参数<span class="italic"><code class="codeph">value_expr</code></span>被计算为字符串，结果用作生成的XML注释的主体。结果是<code class="codeph">&lt;!--</code> <span class="italic"><code class="codeph">string-result</code></span> <code class="codeph">--&gt;</code> ，其中<span class="italic"><code class="codeph">string-result</code></span>是评估<span class="italic"><code class="codeph">value_expr</code></span>的字符串结果。如果<span class="italic"><code class="codeph">string-result</code></span>是空字符串，则注释为空： <code class="codeph">&lt;!----&gt;</code> 。
                        </p>
                        <p>如果构造的XML不是合法的XML注释，则会引发错误。特别是， <span class="italic"><code class="codeph">string-result</code></span> <span class="italic">不能</span>包含两个连续的连字符（ <code class="codeph">-</code> ）：“ <code class="codeph">--</code> ”。
                        </p>
                        <p>函数<code class="codeph">XMLComment</code>返回<code class="codeph">XMLType</code>的实例。如果<span class="italic"><code class="codeph">string-result</code></span>为<code class="codeph">NULL</code> ，则该函数返回<code class="codeph">NULL</code> 。</p>
                        <p><a href="generation-of-XML-data-from-relational-data.html#GUID-CEE20C19-F599-4154-ABFA-B2D062C4F915__CHECEGCI">例8-16</a>使用<code class="codeph">XMLComment</code>生成简单的XML注释。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-CEE20C19-F599-4154-ABFA-B2D062C4F915__CHECEGCI">
                        <p class="titleinexample">示例8-16使用SQL / XML函数XMLCOMMENT</p><pre class="pre codeblock"><code>SELECT XMLComment（'这是注释'）AS cmnt FROM DUAL;</code></pre><p>此查询将产生以下输出：</p><pre class="pre codeblock"><code>CMNT -------------------------- &lt;！ - 这是评论 - &gt;</code></pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="generation-of-XML-data-from-relational-data.html#GUID-0B4F8285-CB3B-42D1-94AC-7397BBAFC967" title="Oracle XML DB提供了可用于构造XML数据的SQL函数。其中大多数都属于SQL / XML标准。">使用SQL函数生成XML数据</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB5034"></a><a id="ADXDB5035"></a><a id="ADXDB5033"></a><div class="props_rev_3"><a id="GUID-55FE9CED-5B25-4DA2-9F9E-921DF8276EB8" name="GUID-55FE9CED-5B25-4DA2-9F9E-921DF8276EB8"></a><h4 id="ADXDB-GUID-55FE9CED-5B25-4DA2-9F9E-921DF8276EB8" class="sect4"><span class="enumeration_section">8.2.7</span> XMLSERIALIZE SQL / XML函数</h4>
                  <div>
                     <p>您使用SQL / XML标准函数<code class="codeph">XMLSerialize</code>来获取XML数据的字符串或LOB表示。
                     </p>
                     <div class="section">
                        <p><a href="generation-of-XML-data-from-relational-data.html#GUID-55FE9CED-5B25-4DA2-9F9E-921DF8276EB8__CHDBGEEH">图8-8</a>显示了<code class="codeph">XMLSerialize</code>的语法：</p>
                        <div class="figure" id="GUID-55FE9CED-5B25-4DA2-9F9E-921DF8276EB8__CHDBGEEH">
                           <p class="titleinfigure">图8-8 XMLSerialize语法</p><img src="img/xmlserialize.gif" width="474" alt="下面是图8-8的描述" title="下面是图8-8的描述" longdesc="img_text/xmlserialize.html"><br><a href="img_text/xmlserialize.html">“图8-8 XMLSerialize语法”的说明</a></div>
                        <!-- class="figure" -->
                        <p>计算参数<span class="italic"><code class="codeph">value_expr</code></span> ，并生成<code class="codeph">XMLType</code>实例以生成所创建的字符串或LOB的内容。如果存在<a id="fn_1" name="fn_1" href="#fn_1" the="" sql="" /xml="" standard="" requires="" argument="" data-type="" to="" be="" present,="" but="" it="" is="" optional="" in="" oracle="" xml&nbsp;db="" implementation="" of="" standard,="" for="" ease="" use=")" ="" onclick="footdisplay(1, "><sup>Foot 1</sup></a> ，则指定的<span class="italic"><code class="codeph">datatype</code></span>必须是以下之一（默认数据类型为<code class="codeph">CLOB</code> ）：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">VARCHAR2(</code> <span class="italic"><code class="codeph">N</code></span> <code class="codeph">)</code> ，其中<span class="italic"><code class="codeph">N</code></span>是以字节为单位的大小<a id="fn_2" name="fn_2" href="#fn_2" value="" the="" limit="" is="" 32767="" or="" 4000="" bytes,="" depending="" on="" of="" initialization="" parameter="" max_string_size. ="" see="" oracle="" database="" pl="" /sql="" packages="" and="" types="" reference=")" ="" onclick="footdisplay(2, "><sup>2</sup></a></p>
                           </li>
                           <li>
                              <p><code class="codeph">CLOB</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">BLOB</code></p>
                           </li>
                        </ul>
                        <p>如果指定<code class="codeph">DOCUMENT</code> ，则评估<span class="italic"><code class="codeph">value_expr</code></span>的结果必须是格式正确的文档。特别是，它必须有一个根。如果结果不是格式良好的文档，则会引发错误。但是，如果指定<code class="codeph">CONTENT</code> ，则<span class="italic">不会</span>检查<span class="italic"><code class="codeph">value_expr</code></span>的结果是否格式正确。
                        </p>
                        <p>如果<span class="italic"><code class="codeph">value_expr</code></span>计算为<code class="codeph">NULL</code>或空字符串（ <code class="codeph">''</code> ），则函数<code class="codeph">XMLSerialize</code>返回<code class="codeph">NULL</code> 。</p>
                        <p><code class="codeph">ENCODING</code>子句指定序列化为<code class="codeph">BLOB</code>实例的XML数据的字符编码。 <span class="italic"><code class="codeph">xml_encoding_spec</code></span>是XML编码声明（ <code class="codeph">encoding="..."</code> ）。如果<span class="italic"><code class="codeph">datatype</code></span>是<code class="codeph">BLOB</code>并且您指定了<code class="codeph">ENCODING</code>子句，则输出将按指定进行编码，并将<span class="italic"><code class="codeph">xml_encoding_spec</code></span>添加到prolog以指示<code class="codeph">BLOB</code>编码。如果指定的<span class="italic"><code class="codeph">datatype</code></span>不是<code class="codeph">BLOB</code>的<code class="codeph">ENCODING</code>子句，则会引发错误。对于UTF-16字符， <span class="italic"><code class="codeph">xml_encoding_spec</code></span>必须是以下之一：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">encoding=UTF-16BE</code> -  Big-endian UTF-16编码</p>
                           </li>
                           <li>
                              <p><code class="codeph">encoding=UTF-16LE</code> -  Little-endian UTF-16编码</p>
                           </li>
                        </ul>
                        <p>如果指定<code class="codeph">VERSION</code>则在XML声明中使用指定的版本（ <code class="codeph">&lt;?xml version =“...”......？&gt;</code> ）。
                        </p>
                        <p>如果指定<code class="codeph">NO INDENT</code> ，则会剥离所有无效的空格，以使其不显示在输出中。如果指定<code class="codeph">INDENT SIZE =</code> <span class="italic"><code class="codeph">N</code></span> ，其中<span class="italic"><code class="codeph">N</code></span>是整数，则使用<span class="italic"><code class="codeph">N</code></span>空格的相对缩进对输出进行<span class="italic">漂亮打印</span> 。如果<span class="italic"><code class="codeph">N</code></span>为<code class="codeph">0</code> ，则漂亮打印在每个元素后面插入一个换行符，将每个元素单独放在一行上，但输出中没有其他无关紧要的空格。如果指定不带<code class="codeph">SIZE</code>规范的<code class="codeph">INDENT</code> ，则使用2空格缩进。如果既未指定<code class="codeph">NO INDENT</code>也未指定<code class="codeph">INDENT</code> ，则行为（漂亮打印与否）是不确定的。
                        </p>
                        <p><code class="codeph">HIDE DEFAULTS</code>和<code class="codeph">SHOW DEFAULTS</code>仅适用于基于XML模式的数据。如果指定<code class="codeph">SHOW DEFAULTS</code>并且输入数据缺少XML架构为其定义默认值的任何可选元素或属性，则这些元素或属性将以其默认值包含在输出中。如果指定<code class="codeph">HIDE DEFAULTS</code> ，则输出中不包含此类元素或属性。<code class="codeph">HIDE DEFAULTS</code>是默认行为。
                        </p>
                        <p><a href="generation-of-XML-data-from-relational-data.html#GUID-55FE9CED-5B25-4DA2-9F9E-921DF8276EB8__CHEHCEAA">例8-17</a>使用<code class="codeph">XMLSerialize</code>生成包含序列化XML数据的<code class="codeph">CLOB</code>实例。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-55FE9CED-5B25-4DA2-9F9E-921DF8276EB8__CHEHCEAA">
                        <p class="titleinexample">示例8-17使用SQL / XML函数XMLSERIALIZE</p><pre class="pre codeblock"><code>SELECT XMLSerialize（DOCUMENT XMLType（'&lt;poid&gt; 143598 &lt;/ poid&gt;'）AS CLOB）AS xmlserialize_doc FROM DUAL;</code></pre><p>这导致以下输出：</p><pre class="oac_no_warn" dir="ltr">XMLSERIALIZE_DOC ------------------- &lt;poid&gt; 143598 &lt;/ poid&gt;</pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="generation-of-XML-data-from-relational-data.html#GUID-0B4F8285-CB3B-42D1-94AC-7397BBAFC967" title="Oracle XML DB提供了可用于构造XML数据的SQL函数。其中大多数都属于SQL / XML标准。">使用SQL函数生成XML数据</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB5037"></a><a id="ADXDB5038"></a><a id="ADXDB5036"></a><div class="props_rev_3"><a id="GUID-8BABF906-A641-49D9-9CED-8B039A6D272C" name="GUID-8BABF906-A641-49D9-9CED-8B039A6D272C"></a><h4 id="ADXDB-GUID-8BABF906-A641-49D9-9CED-8B039A6D272C" class="sect4"><span class="enumeration_section">8.2.8</span> XMLPARSE SQL / XML函数</h4>
                  <div>
                     <p>您使用SQL / XML标准函数<code class="codeph">XMLParse</code>来解析包含XML数据的字符串并构造相应的<code class="codeph">XMLType</code>实例。
                     </p>
                     <div class="section">
                        <p> <a href="generation-of-XML-data-from-relational-data.html#GUID-8BABF906-A641-49D9-9CED-8B039A6D272C__CHDBGIJH">图8-9</a>显示了语法：</p>
                        <div class="figure" id="GUID-8BABF906-A641-49D9-9CED-8B039A6D272C__CHDBGIJH">
                           <p class="titleinfigure">图8-9 XMLParse语法</p><img src="img/xmlparse.gif" width="404" alt="下面是图8-9的描述" title="下面是图8-9的描述" longdesc="img_text/xmlparse.html"><br><a href="img_text/xmlparse.html">“图8-9 XMLParse语法”的说明</a></div>
                        <!-- class="figure" -->
                        <p>计算参数<span class="italic"><code class="codeph">value_expr</code></span>以生成解析的字符串。如果指定<code class="codeph">DOCUMENT</code> ，则<span class="italic"><code class="codeph">value_expr</code></span>必须对应于<span class="italic">单根</span> ，格式良好的XML文档。如果指定<code class="codeph">CONTENT</code> ，则<span class="italic"><code class="codeph">value_expr</code></span>只需要对应于格式良好的XML片段（不需要单独生成）。
                        </p>
                        <p>关键字<code class="codeph">WELLFORMED</code>是SQL / XML标准的Oracle XML DB扩展。当你指定<code class="codeph">WELLFORMED</code>你是通知参数解析器<span class="italic"><code class="codeph">value_expr</code></span>是良好的，所以Oracle XML DB <span class="italic">不</span>检查，以确保它是良好的。
                        </p>
                        <p>函数<code class="codeph">XMLParse</code>返回<code class="codeph">XMLType</code>的实例。如果<span class="italic"><code class="codeph">value_expr</code></span>计算为<code class="codeph">NULL</code> ，则该函数返回<code class="codeph">NULL</code> 。</p>
                        <p><a href="generation-of-XML-data-from-relational-data.html#GUID-8BABF906-A641-49D9-9CED-8B039A6D272C__CHECCHJG">例8-18</a>使用<code class="codeph">XMLParse</code>来解析XML代码字符串并生成<code class="codeph">XMLType</code>实例。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-8BABF906-A641-49D9-9CED-8B039A6D272C__CHECCHJG">
                        <p class="titleinexample">示例8-18使用SQL / XML函数XMLPARSE</p><pre class="pre codeblock"><code>SELECT XMLParse（CONTENT'124 &lt;purchaseOrder poNo =“12435”&gt; &lt;customerName&gt; Acme Enterprises &lt;/ customerName&gt; &lt;itemNo&gt; 32987457 &lt;/ itemNo&gt; &lt;/ purchaseOrder&gt;'WELLFORMED）AS po FROM DUAL d;</code></pre><p>这导致以下输出：</p><pre class="pre codeblock"><code>PO ----------------------------------------------- 124 &lt; purchaseOrder poNo =“12435”&gt; &lt;customerName&gt; Acme Enterprises &lt;/ customerName&gt; &lt;itemNo&gt; 32987457 &lt;/ itemNo&gt; &lt;/ purchaseOrder&gt;</code></pre></div>
                     <!-- class="example" -->
                     <div class="section"></div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-8BABF906-A641-49D9-9CED-8B039A6D272C__GUID-04E98AA6-68F4-4304-8052-74E8B3659078">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/adxdb&amp;id=w3_org_tr_rec_xml" target="_blank"><span class="italic">可扩展标记语言（XML）1.0，</span></a>用于定义格式良好的XML文档和片段</p>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="generation-of-XML-data-from-relational-data.html#GUID-0B4F8285-CB3B-42D1-94AC-7397BBAFC967" title="Oracle XML DB提供了可用于构造XML数据的SQL函数。其中大多数都属于SQL / XML标准。">使用SQL函数生成XML数据</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB5042"></a><a id="ADXDB5043"></a><a id="ADXDB5041"></a><div class="props_rev_3"><a id="GUID-F643284F-A6AF-47A9-AF2C-58EF7E88C87F" name="GUID-F643284F-A6AF-47A9-AF2C-58EF7E88C87F"></a><h4 id="ADXDB-GUID-F643284F-A6AF-47A9-AF2C-58EF7E88C87F" class="sect4"><span class="enumeration_section">8.2.9</span> XMLCOLATTVAL Oracle SQL函数</h4>
                  <div>
                     <p>Oracle SQL函数<code class="codeph">XMLColAttVal</code>生成一个包含传入参数值的XML <code class="codeph">column</code>元素林。此函数是SQL / XML ANSI-ISO标准函数的Oracle扩展。
                     </p>
                     <div class="section">
                        <p><a href="generation-of-XML-data-from-relational-data.html#GUID-F643284F-A6AF-47A9-AF2C-58EF7E88C87F__I1032066">图8-10</a>显示了<code class="codeph">XMLColAttVal</code>语法。
                        </p>
                        <div class="figure" id="GUID-F643284F-A6AF-47A9-AF2C-58EF7E88C87F__I1032066">
                           <p class="titleinfigure">图8-10 XMLCOLATTVAL语法</p><img src="img/xmlcolattval.gif" width="460" alt="下面是图8-10的描述" title="下面是图8-10的描述" longdesc="img_text/xmlcolattval.html"><br><a href="img_text/xmlcolattval.html">“图8-10 XMLCOLATTVAL语法”的说明</a></div>
                        <!-- class="figure" -->
                        <p>参数用作<code class="codeph">column</code>元素的<code class="codeph">name</code>属性的值。<span class="italic"><code class="codeph">c_alias</code></span>值用作属性标识符。
                        </p>
                        <p>作为使用关键字<code class="codeph">AS</code>后跟<span class="italic">文字</span>字符串<span class="italic"><code class="codeph">c_alias</code></span> ，您可以使用<code class="codeph">AS EVALNAME</code>后跟一个表达式，该表达式求值为要用作属性标识符的字符串。
                        </p>
                        <p>由于参数值<span class="italic"><code class="codeph">value_expr</code></span>只用作属性<span class="italic">值</span> ，它们<span class="italic">不需要</span>以任何方式逃脱。这与函数<code class="codeph">XMLForest</code>形成对比。这意味着您可以使用<code class="codeph">XMLColAttVal</code>传输SQL列和值而无需转义。
                        </p>
                        <p><a href="generation-of-XML-data-from-relational-data.html#GUID-F643284F-A6AF-47A9-AF2C-58EF7E88C87F__CHDBEBGD">示例8-19</a>使用<code class="codeph">XMLColAttVal</code>为每个员工生成一个<code class="codeph">Emp</code>元素，其中包含<code class="codeph">name</code>属性，以及具有雇员雇用日期和部门作为内容的<code class="codeph">column</code>元素。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-F643284F-A6AF-47A9-AF2C-58EF7E88C87F__CHDBEBGD">
                        <p class="titleinexample">示例8-19 XMLCOLATTVAL：使用属性和子元素生成元素</p><pre class="oac_no_warn" dir="ltr">SELECT XMLElement（“Emp”，XMLAttributes（e.first_name ||''|| e.last_name AS“fullname”），XMLColAttVal（e.hire_date，e.department_id AS“department”））AS“RESULT”来自hr.employees e WHERE e.department_id = 30;</pre><p>此查询生成以下XML结果。（为清楚起见，此处显示的结果非常清晰。）</p><pre class="oac_no_warn" dir="ltr">结果------------------------------------------------- ---------- &lt;Emp fullname =“Den Raphaely”&gt; &lt;column name =“HIRE_DATE”&gt; 2002-12-07 &lt;/ column&gt; &lt;column name =“department”&gt; 30 &lt;/ column&gt; &lt; / Emp&gt; &lt;Emp fullname =“Alexander Khoo”&gt; &lt;column name =“HIRE_DATE”&gt; 2003-05-18 &lt;/ column&gt; &lt;column name =“department”&gt; 30 &lt;/ column&gt; &lt;/ Emp&gt; &lt;Emp fullname = “Shelli Baida”&gt; &lt;column name =“HIRE_DATE”&gt; 2005-12-24 &lt;/ column&gt; &lt;column name =“department”&gt; 30 &lt;/ column&gt; &lt;/ Emp&gt; &lt;Emp fullname =“Sigal Tobias”&gt; &lt;column name =“HIRE_DATE”&gt; 2005-07-24 &lt;/ column&gt; &lt;column name =“department”&gt; 30 &lt;/ column&gt; &lt;/ Emp&gt; &lt;Emp fullname =“Guy Himuro”&gt; &lt;column name =“HIRE_DATE”&gt; 2006 -11-15 &lt;/ column&gt; &lt;column name =“department”&gt; 30 &lt;/ column&gt; &lt;/ Emp&gt; &lt;Emp fullname =“Karen Colmenares”&gt; &lt;column name =“HIRE_DATE”&gt; 2007-08-10 &lt;/ column &gt; &lt;column name =“department”&gt; 30 &lt;/ column&gt; &lt;/ Emp&gt;选择了6行。</pre></div>
                     <!-- class="example" -->
                     <div class="section"></div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-F643284F-A6AF-47A9-AF2C-58EF7E88C87F__GUID-7F5A3F48-C1D6-4917-9D7C-189CC87BC835">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="generation-of-XML-data-from-relational-data.html#GUID-D9666485-0383-4AF6-B352-B9A90AE1DCFB__CHDBJDAG">例8-8</a></p>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="generation-of-XML-data-from-relational-data.html#GUID-0B4F8285-CB3B-42D1-94AC-7397BBAFC967" title="Oracle XML DB提供了可用于构造XML数据的SQL函数。其中大多数都属于SQL / XML标准。">使用SQL函数生成XML数据</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB5045"></a><a id="ADXDB5046"></a><a id="ADXDB5044"></a><div class="props_rev_3"><a id="GUID-A5A2E32B-A5DD-4A49-8C74-FD83F029F130" name="GUID-A5A2E32B-A5DD-4A49-8C74-FD83F029F130"></a><h4 id="ADXDB-GUID-A5A2E32B-A5DD-4A49-8C74-FD83F029F130" class="sect4"><span class="enumeration_section">8.2.10</span> XMLCDATA的Oracle SQL函数</h4>
                  <div>
                     <p>您使用Oracle SQL函数<code class="codeph">XMLCDATA</code>生成XML <code class="codeph">CDATA</code>部分。
                     </p>
                     <div class="section">
                        <p><a href="generation-of-XML-data-from-relational-data.html#GUID-A5A2E32B-A5DD-4A49-8C74-FD83F029F130__CHDFIDBF">图8-11</a>显示了语法：</p>
                        <div class="figure" id="GUID-A5A2E32B-A5DD-4A49-8C74-FD83F029F130__CHDFIDBF">
                           <p class="titleinfigure">图8-11 XMLCDATA语法</p><img src="img/xmlcdata.gif" width="192" alt="下面是图8-11的描述" title="下面是图8-11的描述" longdesc="img_text/xmlcdata.html"><br><a href="img_text/xmlcdata.html">“图8-11 XMLCDATA语法”的说明</a></div>
                        <!-- class="figure" -->
                        <p>参数<span class="italic"><code class="codeph">value_expr</code></span>被计算为一个字符串，结果用作生成的XML <code class="codeph">CDATA</code>部分的主体， <code class="codeph">&lt;![CDATA[</code> <span class="italic"><code class="codeph">string-result</code></span> <code class="codeph">]]&gt;</code> ，其中<span class="italic"><code class="codeph">string-result</code></span>是评估<span class="italic"><code class="codeph">value_expr</code></span>的结果。如果<span class="italic"><code class="codeph">string-result</code></span>是空字符串，则<code class="codeph">CDATA</code>部分为空： <code class="codeph">&lt;![CDATA[]]&gt;</code> 。
                        </p>
                        <p>如果构造的XML不是合法的XML <code class="codeph">CDATA</code>部分，则会引发错误。特别是， <span class="italic"><code class="codeph">string-result</code></span> <span class="italic">不能</span>包含两个连续的右括号（ <code class="codeph">]</code> ）：“ <code class="codeph">]]</code> ”。
                        </p>
                        <p>函数<code class="codeph">XMLCDATA</code>返回<code class="codeph">XMLType</code>的实例。如果<span class="italic"><code class="codeph">string-result</code></span>为<code class="codeph">NULL</code> ，则该函数返回<code class="codeph">NULL</code> 。</p>
                        <p><a href="generation-of-XML-data-from-relational-data.html#GUID-A5A2E32B-A5DD-4A49-8C74-FD83F029F130__CHEHADIH">例8-20</a>使用<code class="codeph">XMLCDATA</code>生成XML <code class="codeph">CDATA</code>部分。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-A5A2E32B-A5DD-4A49-8C74-FD83F029F130__CHEHADIH">
                        <p class="titleinexample">示例8-20使用Oracle SQL函数XMLCDATA</p><pre class="pre codeblock"><code>SELECT XMLElement（“PurchaseOrder”，XMLElement（“Address”，XMLCDATA（'100 Pennsylvania Ave.'），XMLElement（“City”，“Washington，DC”）））来自DUAL的结果;</code></pre><p>这导致以下输出。（为清楚起见，此处显示的结果非常清晰。）</p><pre class="pre codeblock"><code>结果-------------------------- &lt;PurchaseOrder&gt; &lt;地址&gt; &lt;！[CDATA [100 Pennsylvania Ave。]]&gt; &lt;城市&gt;华盛顿特区&lt;/ City&gt; &lt;/ Address&gt; &lt;/ PurchaseOrder&gt;</code></pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="generation-of-XML-data-from-relational-data.html#GUID-0B4F8285-CB3B-42D1-94AC-7397BBAFC967" title="Oracle XML DB提供了可用于构造XML数据的SQL函数。其中大多数都属于SQL / XML标准。">使用SQL函数生成XML数据</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div><a id="ADXDB5047"></a><div class="props_rev_3"><a id="GUID-1490DB76-5832-4023-8F0B-28427901C912" name="GUID-1490DB76-5832-4023-8F0B-28427901C912"></a><h3 id="ADXDB-GUID-1490DB76-5832-4023-8F0B-28427901C912" class="sect3"><span class="enumeration_section">8.3</span>使用DBMS_XMLGEN生成XML数据</h3>
               <div>
                  <p>PL / SQL包<code class="codeph">DBMS_XMLGEN</code>从SQL查询结果创建XML文档。它将XML文档检索为<code class="codeph">CLOB</code>或<code class="codeph">XMLType</code>值。
                  </p>
                  <p>它提供了一个<span class="italic">fetch</span>接口，您可以指定要检索的最大行数和要跳过的行数。例如，第一次提取可以检索最多十行，跳过前四行。这对Web应用程序中的分页要求特别有用。
                  </p>
                  <p>包<code class="codeph">DBMS_XMLGEN</code>还提供了更改<code class="codeph">ROW</code> ， <code class="codeph">ROWSET</code>标记名称的选项。包的参数可以限制检索的行数和封闭的标记名称。
                  </p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="generation-of-XML-data-from-relational-data.html#GUID-CC973B3D-762D-4D44-87D4-F31C134F19DC">使用PL / SQL包DBMS_XMLGEN</a><br>您可以使用包<code class="codeph">DBMS_XMLGEN</code>从关系数据生成XML数据。
                     </li>
                     <li class="ulchildlink"><a href="generation-of-XML-data-from-relational-data.html#GUID-458675AB-E020-4BFF-8CA9-34D309186F62">包DBMS_XMLGEN的功能和过程</a><br>PL / SQL包<code class="codeph">DBMS_XMLGEN</code>提供了从关系数据生成XML数据的功能和过程。
                     </li>
                     <li class="ulchildlink"><a href="generation-of-XML-data-from-relational-data.html#GUID-7AF139F8-FD60-4113-AD10-1C404FF62B45">DBMS_XMLGEN示例</a><br>这里的示例说明了PL / SQL包<code class="codeph">DBMS_XMLGEN</code> 。</li>
                  </ul>
                  <div class="infoboxnotealso" id="GUID-1490DB76-5832-4023-8F0B-28427901C912__GUID-D632695B-2D11-4F88-8760-EB332942519E">
                     <p class="notep1">也可以看看：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="../arpls/DBMS_XMLGEN.html#ARPLS374" target="_blank"><span><cite>Oracle数据库PL / SQL包和类型参考</cite></span></a></p>
                        </li>
                        <li>
                           <p><a href="../adxdk/using-XML-SQL-utility.html#ADXDK070" target="_blank"><span><cite>Oracle XML Developer's Kit程序员指南</cite></span></a> （将<code class="codeph">OracleXMLQuery</code>与<code class="codeph">DBMS_XMLGEN</code>进行比较）</p>
                        </li>
                     </ul>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="generation-of-XML-data-from-relational-data.html#GUID-3BEB9A88-8B44-4AA3-89F4-8CBF6F8FA686" title="Oracle XML DB提供了从数据库中的关系数据生成（构造）XML数据的功能。有SQL / XML标准函数和Oracle特定的函数和包，用于从关系内容生成XML数据。">从关系数据生成XML数据</a></p>
                     </div>
                  </div>
               </div>
               <a id="ADXDB5049"></a><a id="ADXDB5048"></a><div class="props_rev_3"><a id="GUID-CC973B3D-762D-4D44-87D4-F31C134F19DC" name="GUID-CC973B3D-762D-4D44-87D4-F31C134F19DC"></a><h4 id="ADXDB-GUID-CC973B3D-762D-4D44-87D4-F31C134F19DC" class="sect4"><span class="enumeration_section">8.3.1</span>使用PL / SQL包DBMS_XMLGEN</h4>
                  <div>
                     <p>您可以使用包<code class="codeph">DBMS_XMLGEN</code>从关系数据生成XML数据。
                     </p>
                     <div class="section">
                        <p><a href="generation-of-XML-data-from-relational-data.html#GUID-CC973B3D-762D-4D44-87D4-F31C134F19DC__I1025437">图8-12</a>说明了如何使用包<code class="codeph">DBMS_XMLGEN</code> 。步骤如下：</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>通过提供SQL查询并调用PL / SQL函数<code class="codeph">newContext</code>从包中获取上下文。</span><div></div>
                        </li>
                        <li class="stepexpand"><span>将上下文传递给包中的所有过程或函数以设置各种选项。例如，要设置<code class="codeph">ROW</code>元素名称，请使用<code class="codeph">setRowTag(ctx)</code> ，其中<code class="codeph">ctx</code>是从前一个<code class="codeph">newContext</code>调用获得的上下文。</span><div></div>
                        </li>
                        <li class="stepexpand"><span>使用PL / SQL函数<code class="codeph">getXML</code>或<code class="codeph">getXMLType</code>获取XML结果。通过使用PL / SQL过程<code class="codeph">setMaxRows</code>设置要为每次提取检索的最大行数，可以重复调用这些函数中的任何一个，检索每个调用的最大行数。这些函数返回XML数据（分别作为<code class="codeph">CLOB</code>值和<code class="codeph">XMLType</code>的实例），除非没有检索到行。在这种情况下，这些函数返回<code class="codeph">NULL</code> 。要确定检索的行数，请使用PL / SQL函数<code class="codeph">getNumRowsProcessed</code> 。</span><div></div>
                        </li>
                        <li class="stepexpand"><span>您可以重置查询以重新开始并重复步骤3。</span><div></div>
                        </li>
                        <li class="stepexpand"><span>调用PL / SQL过程<code class="codeph">closeContext</code>以释放任何先前分配的资源。</span></li>
                     </ol>
                     <div class="section">
                        <div class="figure" id="GUID-CC973B3D-762D-4D44-87D4-F31C134F19DC__I1025437">
                           <p class="titleinfigure">图8-12使用PL / SQL包DBMS_XMLGEN</p><img src="img/adxdb054.gif" width="611" alt="下面是图8-12的描述" title="下面是图8-12的描述" longdesc="img_text/adxdb054.html"><br><a href="img_text/adxdb054.html">“图8-12使用PL / SQL包DBMS_XMLGEN”的描述</a></div>
                        <!-- class="figure" -->
                        <p>结合SQL查询，PL / SQL方法<code class="codeph">DBMS_XMLGEN.getXML()</code>通常返回类似于以下内容的结果，作为<code class="codeph">CLOB</code>值：</p><pre class="oac_no_warn" dir="ltr">&lt;？xml版本=“1.0”？&gt; &lt;ROWSET&gt; &lt;ROW&gt; &lt;EMPLOYEE_ID&gt; 100 &lt;/ EMPLOYEE_ID&gt; &lt;FIRST_NAME&gt; Steven &lt;/ FIRST_NAME&gt; &lt;LAST_NAME&gt;国王&lt;/ LAST_NAME&gt; &lt;EMAIL&gt; SKING &lt;/ EMAIL&gt; &lt;PHONE_NUMBER&gt; 515.123.4567 &lt;/ PHONE_NUMBER&gt; &lt; HIRE_DATE&gt; 17-JUN-87 &lt;/ HIRE_DATE&gt; &lt;JOB_ID&gt; AD_PRES &lt;/ JOB_ID&gt; &lt;SALARY&gt; 24000 &lt;/ SALARY&gt; &lt;DEPARTMENT_ID&gt; 90 &lt;/ DEPARTMENT_ID&gt; &lt;/ ROW&gt; &lt;ROW&gt; &lt;EMPLOYEE_ID&gt; 101 &lt;/ EMPLOYEE_ID&gt; &lt;FIRST_NAME&gt; Neena &lt;/ FIRST_NAME&gt; &lt;LAST_NAME&gt; Kochhar &lt;/ LAST_NAME&gt; &lt;EMAIL&gt; NKOCHHAR &lt;/ EMAIL&gt; &lt;PHONE_NUMBER&gt; 515.123.4568 &lt;/ PHONE_NUMBER&gt; &lt;HIRE_DATE&gt; 21-SEP-89 &lt;/ HIRE_DATE&gt; &lt;JOB_ID&gt; AD_VP &lt;/ JOB_ID&gt; &lt;SALARY&gt; 17000 &lt;/ SALARY&gt; &lt;MANAGER_ID&gt; 100 &lt;/ MANAGER_ID&gt; &lt;DEPARTMENT_ID&gt; 90 &lt;/ DEPARTMENT_ID&gt; &lt;/ ROW&gt; &lt;/ ROWSET&gt;</pre><p>关系数据和XML数据之间的默认映射如下：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>SQL查询返回的每一行都映射到具有默认元素名称<code class="codeph">ROW</code>的XML元素。</p>
                           </li>
                           <li>
                              <p>SQL查询返回的每个列都映射到<code class="codeph">ROW</code>元素的子元素。
                              </p>
                           </li>
                           <li>
                              <p>整个结果包含在<code class="codeph">ROWSET</code>元素中。
                              </p>
                           </li>
                           <li>
                              <p>二进制数据转换为十六进制表示。</p>
                           </li>
                        </ul>
                        <p>元素名称<code class="codeph">ROW</code>和<code class="codeph">ROWSET</code>可以用您选择的名称替换，分别使用<code class="codeph">DBMS_XMLGEN</code>过程<code class="codeph">setRowTagName</code>和<code class="codeph">setRowSetTagName</code> 。
                        </p>
                        <p><code class="codeph">getXML</code>返回的<code class="codeph">CLOB</code>值与数据库字符集具有相同的编码。如果数据库字符集是SHIFTJIS，则返回的XML文档也是SHIFTJIS。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="generation-of-XML-data-from-relational-data.html#GUID-1490DB76-5832-4023-8F0B-28427901C912" title="PL / SQL包DBMS_XMLGEN从SQL查询结果创建XML文档。它将XML文档检索为CLOB或XMLType值。">使用DBMS_XMLGEN生成XML数据</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB5051"></a><a id="ADXDB5050"></a><div class="props_rev_3"><a id="GUID-458675AB-E020-4BFF-8CA9-34D309186F62" name="GUID-458675AB-E020-4BFF-8CA9-34D309186F62"></a><h4 id="ADXDB-GUID-458675AB-E020-4BFF-8CA9-34D309186F62" class="sect4"><span class="enumeration_section">8.3.2</span>包DBMS_XMLGEN的功能和过程</h4>
                  <div>
                     <p>PL / SQL包<code class="codeph">DBMS_XMLGEN</code>提供了从关系数据生成XML数据的功能和过程。
                     </p>
                     <div class="section">
                        <p><a href="generation-of-XML-data-from-relational-data.html#GUID-458675AB-E020-4BFF-8CA9-34D309186F62__G1033764" title="该表描述了DBMS_XMLGEN的功能和过程。">表8-1</a>描述了<code class="codeph">DBMS_XMLGEN</code>包的功能和过程。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="tblformalwide" id="GUID-458675AB-E020-4BFF-8CA9-34D309186F62__G1033764">
                        <p class="titleintable">表8-1 DBMS_XMLGEN函数和过程</p>
                        <table cellpadding="4" cellspacing="0" class="FormalWide" title="DBMS_XMLGEN函数和过程" width="100%" border="1" summary="This table describes DBMS_XMLGEN functions and procedures." frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="41%" id="d55429e3458">功能或程序</th>
                                 <th align="left" valign="bottom" width="59%" id="d55429e3461">描述</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="41%" id="d55429e3466" headers="d55429e3458 "><pre class="pre codeblock"><code>SUBTYPE ctxHandle是NUMBER</code></pre></td>
                                 <td align="left" valign="top" width="59%" headers="d55429e3466 d55429e3461 ">
                                    <p>所有函数使用的上下文句柄。</p>
                                    <p>文档类型定义（DTD）或模式规范：</p>
                                    <p><code class="codeph">无常数：= 0;</code></p>
                                    <p><code class="codeph">DTD常数：= 1;</code> 
                                    </p>
                                    <p><code class="codeph">SCHEMA常数：= 2;</code></p>
                                    <p>可以在函数<code class="codeph">getXML</code>用于指定是生成DTD还是XML架构，或者两者都不生成（ <code class="codeph">NONE</code> ）。仅支持<code class="codeph">NONE</code>规范。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="41%" id="d55429e3496" headers="d55429e3458 "><pre class="pre codeblock"><code>newContext（）</code></pre></td>
                                 <td align="left" valign="top" width="59%" headers="d55429e3496 d55429e3461 ">
                                    <p>给定查询字符串，生成要在后续函数中使用的新上下文句柄。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="41%" id="d55429e3503" headers="d55429e3458 "><pre class="pre codeblock"><code>newContext（queryString IN VARCHAR2）</code></pre></td>
                                 <td align="left" valign="top" width="59%" headers="d55429e3503 d55429e3461 ">
                                    <p>返回一个新的上下文</p>
                                    <p><span class="italic">参数：</span> <code class="codeph">queryString</code> <code class="codeph">(IN)</code> - 查询字符串，其结果必须转换为XML</p>
                                    <p><span class="italic">返回：</span>上下文句柄。首先调用此函数以获取可在<code class="codeph">getXML</code>和其他函数中使用的句柄，以从结果中获取XML。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="41%" id="d55429e3527" headers="d55429e3458 "><pre class="pre codeblock"><code>newContext（queryString IN SYS_REFCURSOR）RETURN ctxHandle;</code></pre></td>
                                 <td align="left" valign="top" width="59%" headers="d55429e3527 d55429e3461 ">
                                    <p>从PL / SQL游标变量创建新的上下文句柄。上下文句柄可用于其余功能。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="41%" id="d55429e3534" headers="d55429e3458 "><pre class="pre codeblock"><code>newContextFromHierarchy（queryString IN VARCHAR2）RETURN ctxHandle;</code></pre></td>
                                 <td align="left" valign="top" width="59%" headers="d55429e3534 d55429e3461 ">
                                    <p><span class="italic">参数：</span> <code class="codeph">queryString (IN)</code> - 查询字符串，其结果必须转换为XML。查询是通常使用<code class="codeph">CONNECT BY</code>子句形成的分层查询，结果必须与<code class="codeph">CONNECT BY</code>查询生成的结果集具有相同的属性。结果集必须只有两列，级别编号和XML值。级别号用于确定结果XML文档中XML值的层次结构位置。
                                    </p>
                                    <p><span class="italic">返回：</span>上下文句柄。首先调用此函数以获取可在<code class="codeph">getXML</code>和其他函数中使用的句柄，以从结果中获取具有递归元素的分层XML。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="41%" id="d55429e3559" headers="d55429e3458 "><pre class="pre codeblock"><code>setRowTag（）</code></pre></td>
                                 <td align="left" valign="top" width="59%" headers="d55429e3559 d55429e3461 ">
                                    <p>设置分隔所有行的元素的名称。默认名称为<code class="codeph">ROW</code> 。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="41%" id="d55429e3569" headers="d55429e3458 "><pre class="pre codeblock"><code>setRowTag（ctx IN ctxHandle，rowTag IN VARCHAR2）;</code></pre></td>
                                 <td align="left" valign="top" width="59%" headers="d55429e3569 d55429e3461 ">
                                    <p><span class="italic">参数：</span> 
                                    </p>
                                    <p><code class="codeph">ctx(IN)</code> - 从<code class="codeph">newContext</code>调用获得的上下文句柄。
                                    </p>
                                    <p><code class="codeph">rowTag(IN)</code> - <code class="codeph">ROW</code>元素的名称。<code class="codeph">rowTag</code>的<code class="codeph">NULL</code>值表示您不希望存在<code class="codeph">ROW</code>元素。
                                    </p>
                                    <p>如果您不希望显示默认的<code class="codeph">ROW</code>名称，请调用此过程以设置<code class="codeph">ROW</code>元素的名称。您还可以将<code class="codeph">rowTag</code>设置为<code class="codeph">NULL</code>以抑制<code class="codeph">ROW</code>元素本身。
                                    </p>
                                    <p>但是，由于函数<code class="codeph">getXML</code>返回完整的XML文档而不是XML片段，因此必须有（单个）根元素。因此，如果<code class="codeph">rowTag</code>值和<code class="codeph">rowSetTag</code>值（请参阅<code class="codeph">setRowSetTag</code> ，next）都为<code class="codeph">NULL</code>并且输出中有多个列或行，则会引发错误。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="41%" id="d55429e3635" headers="d55429e3458 "><pre class="pre codeblock"><code>setRowSetTag（）</code></pre></td>
                                 <td align="left" valign="top" width="59%" headers="d55429e3635 d55429e3461 ">
                                    <p>设置文档根元素的名称。默认名称为<code class="codeph">ROWSET</code> 
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="41%" id="d55429e3645" headers="d55429e3458 "><pre class="pre codeblock"><code>setRowSetTag（ctx IN ctxHandle，rowSetTag IN VARCHAR2）;</code></pre></td>
                                 <td align="left" valign="top" width="59%" headers="d55429e3645 d55429e3461 ">
                                    <p><span class="italic">参数：</span></p>
                                    <p><code class="codeph">ctx(IN)</code> - 从<code class="codeph">newContext</code>调用获得的上下文句柄。
                                    </p>
                                    <p><code class="codeph">rowSetTag(IN)</code> - 要在输出中使用的文档根元素的名称。<code class="codeph">rowSetTag</code>的<code class="codeph">NULL</code>值表示您<span class="italic">不</span>希望存在<code class="codeph">ROWSET</code>元素。
                                    </p>
                                    <p>如果您不希望使用默认名称<code class="codeph">ROWSET</code> ，请调用此过程以设置文档根元素的名称。您可以将<code class="codeph">rowSetTag</code>设置为<code class="codeph">NULL</code>以禁止打印文档根元素。
                                    </p>
                                    <p>但是，由于函数<code class="codeph">getXML</code>返回完整的XML文档而不是XML片段，因此必须有（单个）根元素。因此，如果<code class="codeph">rowTag</code>值和<code class="codeph">rowSetTag</code>值（请参阅<code class="codeph">setRowTag</code> ，previous）都为<code class="codeph">NULL</code>并且输出中有多个列或行，或者<code class="codeph">rowSetTag</code>值为<code class="codeph">NULL</code>并且有多个行，则会引发错误在输出中。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="41%" id="d55429e3711" headers="d55429e3458 "><pre class="pre codeblock"><code>的getXML（）</code></pre></td>
                                 <td align="left" valign="top" width="59%" headers="d55429e3711 d55429e3461 ">
                                    <p>通过获取指定的最大行数来获取XML文档。它将XML文档附加到传入的<code class="codeph">CLOB</code>中。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="41%" id="d55429e3721" headers="d55429e3458 "><pre class="pre codeblock"><code>getXML（ctx IN ctxHandle，clobval IN OUT NCOPY clob，dtdOrSchema IN number：= NONE）;</code></pre></td>
                                 <td align="left" valign="top" width="59%" headers="d55429e3721 d55429e3461 ">
                                    <p><span class="italic">参数：</span> 
                                    </p>
                                    <p><code class="codeph">ctx(IN)</code> - 从调用<code class="codeph">newContext</code>获得的上下文句柄。
                                    </p>
                                    <p><code class="codeph">clobval(IN/OUT)</code> - 要附加XML文档的<code class="codeph">CLOB</code> ，</p>
                                    <p><code class="codeph">dtdOrSchema(IN)</code> - 是否应该生成DTD或Schema。不支持此参数。
                                    </p>
                                    <p>使用此版本的函数<code class="codeph">getXML</code> ，以避免任何额外的<code class="codeph">CLOB</code>副本，以及是否要为后续调用重用相同的<code class="codeph">CLOB</code> 。这个<code class="codeph">getXML</code>调用比下一个调用更有效，但这涉及到你创建LOB定位器。生成XML时，将跳过<code class="codeph">setSkipRows</code>调用指示的行数，然后获取<code class="codeph">setMaxRows</code>调用指定的最大行数（如果未指定则指定整个结果）并将其转换为XML。使用<code class="codeph">getNumRowsProcessed</code>函数检查是否检索到任何行。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="41%" id="d55429e3773" headers="d55429e3458 "><pre class="pre codeblock"><code>的getXML（）</code></pre></td>
                                 <td align="left" valign="top" width="59%" headers="d55429e3773 d55429e3461 ">
                                    <p>生成XML文档并将其作为<code class="codeph">CLOB</code>返回。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="41%" id="d55429e3783" headers="d55429e3458 "><pre class="pre codeblock"><code>getXML（ctx IN ctxHandle，dtdOrSchema IN number：= NONE）RETURN clob;</code></pre></td>
                                 <td align="left" valign="top" width="59%" headers="d55429e3783 d55429e3461 ">
                                    <p><span class="italic">参数：</span></p>
                                    <p><code class="codeph">ctx(IN)</code> - 从调用<code class="codeph">newContext</code>获得的上下文句柄。
                                    </p>
                                    <p><code class="codeph">dtdOrSchema(IN)</code> - 是否生成DTD或XML模式。<span class="italic">不</span>支持此参数。
                                    </p>
                                    <p><span class="italic">返回：</span>包含文档的临时<code class="codeph">CLOB</code> 。使用<code class="codeph">DBMS_LOB.freeTemporary</code>调用释放从此函数获取的临时<code class="codeph">CLOB</code> 。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="41%" id="d55429e3818" headers="d55429e3458 "><pre class="pre codeblock"><code>getXMLType（ctx IN ctxHandle，dtdOrSchema IN number：= NONE）RETURN XMLType;</code></pre></td>
                                 <td align="left" valign="top" width="59%" headers="d55429e3818 d55429e3461 ">
                                    <p><span class="italic">参数：</span></p>
                                    <p><code class="codeph">ctx(IN)</code> - 从调用<code class="codeph">newContext</code>获得的上下文句柄。
                                    </p>
                                    <p><code class="codeph">dtdOrSchema(IN)</code> - 是否生成DTD或XML模式。<span class="italic">不</span>支持此参数。
                                    </p>
                                    <p><span class="italic">返回：</span>包含文档的<code class="codeph">XMLType</code>实例。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="41%" id="d55429e3847" headers="d55429e3458 "><pre class="pre codeblock"><code>getXML（sqlQuery IN VARCHAR2，dtdOrSchema IN NUMBER：= NONE）RETURN CLOB;</code></pre></td>
                                 <td align="left" valign="top" width="59%" headers="d55429e3847 d55429e3461 ">
                                    <p>将查询结果从SQL查询字符串<code class="codeph">sqlQuery</code>为XML格式。
                                    </p>
                                    <p><span class="italic">返回：</span> <code class="codeph">CLOB</code>实例。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="41%" id="d55429e3864" headers="d55429e3458 "><pre class="pre codeblock"><code>getXMLType（sqlQuery IN VARCHAR2，dtdOrSchema IN NUMBER：= NONE）RETURN XMLType;</code></pre></td>
                                 <td align="left" valign="top" width="59%" headers="d55429e3864 d55429e3461 ">
                                    <p>将查询结果从SQL查询字符串<code class="codeph">sqlQuery</code>为XML格式。
                                    </p>
                                    <p><span class="italic">返回：</span> <code class="codeph">XMLType</code>实例。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="41%" id="d55429e3881" headers="d55429e3458 "><pre class="pre codeblock"><code>getNumRowsProcessed（）</code></pre></td>
                                 <td align="left" valign="top" width="59%" headers="d55429e3881 d55429e3461 ">
                                    <p>获取使用函数<code class="codeph">getXML</code>生成XML数据时处理的SQL行数。此计数不包括生成XML数据之前<span class="italic">跳过</span>的行数。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="41%" id="d55429e3894" headers="d55429e3458 "><pre class="pre codeblock"><code>getNumRowsProcessed（ctx IN ctxHandle）RETURN编号;</code></pre></td>
                                 <td align="left" valign="top" width="59%" headers="d55429e3894 d55429e3461 ">
                                    <p><span class="italic">参数：</span> <code class="codeph">queryString(IN)</code> - 查询字符串，其结果必须转换为XML</p>
                                    <p><span class="italic">返回：</span>上次调用<code class="codeph">getXML</code>处理的SQL行数。</p>
                                    <p>您可以调用它来查明是否已达到结果集的结尾。这不包括生成XML数据之前<span class="italic">跳过</span>的行数。如果在循环中调用<code class="codeph">getXML</code> ，请使用此函数确定终止条件。即使没有行存在， <code class="codeph">getXML</code>始终生成XML文档。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="41%" id="d55429e3924" headers="d55429e3458 "><pre class="pre codeblock"><code>setMaxRows（）</code></pre></td>
                                 <td align="left" valign="top" width="59%" headers="d55429e3924 d55429e3461 ">
                                    <p>设置每次调用<code class="codeph">getXML</code>调用时从SQL查询结果中获取的最大行数。在函数<code class="codeph">newContextFromHierarchy</code>创建的上下文句柄上调用此函数是错误的。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="41%" id="d55429e3937" headers="d55429e3458 "><pre class="pre codeblock"><code>setMaxRows（ctx IN ctxHandle，maxRows IN NUMBER）;</code></pre></td>
                                 <td align="left" valign="top" width="59%" headers="d55429e3937 d55429e3461 ">
                                    <p><span class="italic">参数：</span></p>
                                    <p><code class="codeph">ctx(IN)</code> - 与执行的查询对应的上下文句柄，</p>
                                    <p><code class="codeph">maxRows(IN)</code> - 每次调用<code class="codeph">getXML</code>获得的最大行数。</p>
                                    <p>使用此实用程序生成分页结果时，可以使用<code class="codeph">maxRows</code>参数。例如，在生成XML或HTML数据页面时，您可以限制转换为XML的行数，然后在后续调用中，您可以获取下一组行，依此类推。这也可以提供更快的响应时间。在函数<code class="codeph">newContextFromHierarchy</code>创建的上下文句柄上调用此过程是错误的。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="41%" id="d55429e3964" headers="d55429e3458 "><pre class="pre codeblock"><code>setSkipRows（）</code></pre></td>
                                 <td align="left" valign="top" width="59%" headers="d55429e3964 d55429e3461 ">
                                    <p>在为每次调用<code class="codeph">getXML</code>生成XML输出之前，跳过给定数量的行。在函数<code class="codeph">newContextFromHierarchy</code>创建的上下文句柄上调用此函数是错误的。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="41%" id="d55429e3977" headers="d55429e3458 "><pre class="pre codeblock"><code>setSkipRows（ctx IN ctxHandle，skipRows IN NUMBER）;</code></pre></td>
                                 <td align="left" valign="top" width="59%" headers="d55429e3977 d55429e3461 ">
                                    <p><span class="italic">参数：</span></p>
                                    <p><code class="codeph">ctx(IN)</code> - 与执行的查询对应的上下文句柄，</p>
                                    <p><code class="codeph">skipRows(IN)</code> - 每次调用<code class="codeph">getXML</code>要跳过的行数。</p>
                                    <p>使用此实用程序为无状态网页生成分页结果时，可以使用<code class="codeph">skipRows</code>参数。例如，在生成XML或HTML数据的第一页时，您可以将<code class="codeph">skipRows</code>设置为零。对于下一组，您可以将<code class="codeph">skipRows</code>设置为第一种情况下获得的行数。在函数<code class="codeph">newContextFromHierarchy</code>创建的上下文句柄上调用此函数是错误的。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="41%" id="d55429e4011" headers="d55429e3458 "><pre class="pre codeblock"><code>setConvertSpecialChars（）</code></pre></td>
                                 <td align="left" valign="top" width="59%" headers="d55429e4011 d55429e3461 ">
                                    <p>确定是否必须将XML数据中的特殊字符转换为其转义的XML等效项。例如， <code class="codeph">&lt;</code>符号被转换为<code class="codeph">&amp;lt;</code> 。默认行为是执行转义转换。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="41%" id="d55429e4024" headers="d55429e3458 "><pre class="pre codeblock"><code>setConvertSpecialChars（ctx IN ctxHandle，conv IN BOOLEAN）;</code></pre></td>
                                 <td align="left" valign="top" width="59%" headers="d55429e4024 d55429e3461 ">
                                    <p><span class="italic">参数：</span></p>
                                    <p><code class="codeph">ctx(IN)</code> - 要使用的上下文句柄，</p>
                                    <p><code class="codeph">conv(IN)</code> -  true表示需要转换。
                                    </p>
                                    <p>只要您确定输入数据不能包含任何特殊字符（如<span class="bold"><code class="codeph">&lt;</code></span> ， <span class="bold"><code class="codeph">&gt;</code></span> ， <span class="bold"><code class="codeph">"</code></span> ， <span class="bold"><code class="codeph">'</code></span> ，您必须使用此函数来加速XML处理，这些特殊字符必须以转义字符开头。扫描字符数据以替换特殊字符是很昂贵的，特别是如果它涉及大量数据。因此，在数据是XML安全的情况下，可以调用此函数来提高性能。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="41%" id="d55429e4058" headers="d55429e3458 "><pre class="pre codeblock"><code>useItemTagsForColl（）</code></pre></td>
                                 <td align="left" valign="top" width="59%" headers="d55429e4058 d55429e3461 ">
                                    <p>设置集合元素的名称。集合元素的默认名称是类型名称本身。您可以使用此函数覆盖它以使用附加了<code class="codeph">_ITEM</code>标记的列的名称。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="41%" id="d55429e4068" headers="d55429e3458 "><pre class="pre codeblock"><code>useItemTagsForColl（ctx IN ctxHandle）;</code></pre></td>
                                 <td align="left" valign="top" width="59%" headers="d55429e4068 d55429e3461 ">
                                    <p><span class="italic">参数：</span> <code class="codeph">ctx(IN)</code> - 上下文句柄。
                                    </p>
                                    <p>例如，如果您有<code class="codeph">NUMBER</code>的集合，则集合元素的默认标记名称为<code class="codeph">NUMBER</code> 。您可以通过调用此过程来覆盖此操作并生成附加了<code class="codeph">_ITEM</code>标记的集合列名称。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="41%" id="d55429e4091" headers="d55429e3458 "><pre class="pre codeblock"><code>restartQuery（）</code></pre></td>
                                 <td align="left" valign="top" width="59%" headers="d55429e4091 d55429e3461 ">
                                    <p>重新启动查询并再次从第一行生成XML。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="41%" id="d55429e4098" headers="d55429e3458 "><pre class="pre codeblock"><code>restartQuery（ctx IN ctxHandle）;</code></pre></td>
                                 <td align="left" valign="top" width="59%" headers="d55429e4098 d55429e3461 ">
                                    <p><span class="italic">参数：</span> <code class="codeph">ctx(IN)</code> - 与当前查询对应的上下文句柄。您可以调用它来重新开始执行查询，而无需创建新的上下文。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="41%" id="d55429e4110" headers="d55429e3458 "><pre class="pre codeblock"><code>closeContext（）</code></pre></td>
                                 <td align="left" valign="top" width="59%" headers="d55429e4110 d55429e3461 ">
                                    <p>关闭给定上下文并释放与该上下文关联的所有资源，包括SQL游标和绑定和定义缓冲区等。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="41%" id="d55429e4117" headers="d55429e3458 "><pre class="pre codeblock"><code>closeContext（ctx IN ctxHandle）;</code></pre></td>
                                 <td align="left" valign="top" width="59%" headers="d55429e4117 d55429e3461 ">
                                    <p><span class="italic">参数：</span> <code class="codeph">ctx(IN)</code> - 要关闭的上下文句柄。关闭与此句柄关联的所有资源。在此之后，您无法将句柄用于任何其他<code class="codeph">DBMS_XMLGEN</code>函数调用。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="41%" id="d55429e4132" headers="d55429e3458 ">
                                    <p><span class="italic">转换功能</span></p><pre class="pre codeblock"><code>convert（xmlData IN varchar2，flag IN NUMBER：= ENTITY_ENCODE）RETURN VARCHAR2;</code></pre></td>
                                 <td align="left" valign="top" width="59%" headers="d55429e4132 d55429e3461 ">
                                    <p>对XML数据字符串参数进行编码或解码。</p>
                                    <ul style="list-style-type:disc">
                                       <li>
                                          <p>编码是指将实体引用（例如<code class="codeph">&lt;</code>替换为它们的转义等价物，例如<code class="codeph">&amp;lt;</code> 。
                                          </p>
                                       </li>
                                       <li>
                                          <p>解码是指反向转换。</p>
                                       </li>
                                    </ul>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="41%" id="d55429e4155" headers="d55429e3458 "><pre class="pre codeblock"><code>convert（xmlData IN CLOB，flag IN NUMBER：= ENTITY_ENCODE）RETURN CLOB;</code></pre></td>
                                 <td align="left" valign="top" width="59%" headers="d55429e4155 d55429e3461 ">
                                    <p>对传入的XML <code class="codeph">CLOB</code>数据进行编码或解码。
                                    </p>
                                    <ul style="list-style-type:disc">
                                       <li>
                                          <p>编码是指将实体引用（例如<code class="codeph">&lt;</code>替换为它们的转义等价物，例如<code class="codeph">&amp;lt;</code> 。
                                          </p>
                                       </li>
                                       <li>
                                          <p>解码是指反向转换。</p>
                                       </li>
                                    </ul>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="41%" id="d55429e4178" headers="d55429e3458 ">
                                    <p><span class="italic">NULL处理</span></p><pre class="pre codeblock"><code>setNullHandling（ctx IN ctxHandle，flag IN NUMBER）;</code></pre></td>
                                 <td align="left" valign="top" width="59%" headers="d55429e4178 d55429e3461 ">
                                    <p><code class="codeph">setNullHandling</code>标志值为：</p>
                                    <ul style="list-style-type:disc">
                                       <li>
                                          <p><code class="codeph">DROP_NULLS常数：= 0;</code> 
                                          </p>
                                          <p>这是默认设置，并省略了<code class="codeph">NULL</code>元素的标记。
                                          </p>
                                       </li>
                                       <li>
                                          <p><code class="codeph">NULL_ATTR CONSTANT NUMBER：= 1;</code> 
                                          </p>
                                          <p>这设置了<code class="codeph">xsi:nil = "true"</code> 。
                                          </p>
                                       </li>
                                       <li>
                                          <p><code class="codeph">EMPTY_TAG常数：= 2;</code> 
                                          </p>
                                          <p>例如，这设置为<code class="codeph">&lt;foo/&gt;</code> 。
                                          </p>
                                       </li>
                                    </ul>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="41%" id="d55429e4223" headers="d55429e3458 "><pre class="pre codeblock"><code>useNullAttributeIndicator（ctx IN ctxHandle，attrind IN BOOLEAN：= TRUE）;</code></pre></td>
                                 <td align="left" valign="top" width="59%" headers="d55429e4223 d55429e3461 ">
                                    <p><code class="codeph">useNullAttributeIndicator</code>是<code class="codeph">setNullHandling(ctx, NULL_ATTR)</code>的快捷方式。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="41%" id="d55429e4235" headers="d55429e3458 "><pre class="pre codeblock"><code>setBindValue（ctx IN ctxHandle，bindVariableName IN VARCHAR2，bindValue IN VARCHAR2）;</code></pre></td>
                                 <td align="left" valign="top" width="59%" headers="d55429e4235 d55429e3461 ">
                                    <p>设置出现在与上下文句柄关联的查询字符串中的绑定变量的绑定值。在使用<code class="codeph">setBindValue</code>设置所有绑定变量之前，不能执行带有绑定变量的查询字符串。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="41%" id="d55429e4245" headers="d55429e3458 "><pre class="pre codeblock"><code>clearBindValue（ctx IN ctxHandle）;</code></pre></td>
                                 <td align="left" valign="top" width="59%" headers="d55429e4245 d55429e3461 ">
                                    <p>清除与上下文句柄关联的查询字符串中出现的所有绑定变量的所有绑定值。之后，所有绑定变量都必须使用<code class="codeph">setBindValue</code>重新绑定新值。
                                    </p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="generation-of-XML-data-from-relational-data.html#GUID-1490DB76-5832-4023-8F0B-28427901C912" title="PL / SQL包DBMS_XMLGEN从SQL查询结果创建XML文档。它将XML文档检索为CLOB或XMLType值。">使用DBMS_XMLGEN生成XML数据</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB5053"></a><a id="ADXDB5054"></a><a id="ADXDB5055"></a><a id="ADXDB5056"></a><a id="ADXDB5057"></a><a id="ADXDB5058"></a><a id="ADXDB5059"></a><a id="ADXDB5060"></a><a id="ADXDB5061"></a><a id="ADXDB5052"></a><div class="props_rev_3"><a id="GUID-7AF139F8-FD60-4113-AD10-1C404FF62B45" name="GUID-7AF139F8-FD60-4113-AD10-1C404FF62B45"></a><h4 id="ADXDB-GUID-7AF139F8-FD60-4113-AD10-1C404FF62B45" class="sect4"><span class="enumeration_section">8.3.3</span> DBMS_XMLGEN示例</h4>
                  <div>
                     <p>这里的示例说明了PL / SQL包<code class="codeph">DBMS_XMLGEN</code> 。</p>
                     <div class="section">
                        <p><a href="generation-of-XML-data-from-relational-data.html#GUID-7AF139F8-FD60-4113-AD10-1C404FF62B45__I1025636">示例8-21</a>使用<code class="codeph">DBMS_XMLGEN</code>通过从对象关系表中选择员工数据并将生成的<code class="codeph">CLOB</code>值放入表中来创建XML文档。
                        </p>
                        <p>您可以使用程序包<code class="codeph">DBMS_XMLGEN</code>的fetch接口每次检索固定数量的行，而不是为所有行生成所有XML数据。这可以加快响应时间，并有助于扩展在生成的XML上需要文档对象模型（DOM）应用程序接口（API）的应用程序，特别是在行数很大的情况下。
                        </p>
                        <p><a href="generation-of-XML-data-from-relational-data.html#GUID-7AF139F8-FD60-4113-AD10-1C404FF62B45__I1025688">例8-22</a>使用<code class="codeph">DBMS_XMLGEN</code>从表<code class="codeph">HR.employees</code>检索结果：</p>
                        <p><a href="generation-of-XML-data-from-relational-data.html#GUID-7AF139F8-FD60-4113-AD10-1C404FF62B45__BABFCBFF">示例8-23</a>使用<code class="codeph">DBMS_XMLGEN</code>和对象类型来表示嵌套结构。
                        </p>
                        <p>对于关系数据，结果是没有嵌套元素的XML文档。要获取嵌套的XML结构，可以使用对象关系数据，其中映射如下：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p><span class="italic">对象类型</span>映射到XML元素 - 请参阅<a href="XML-Schema-and-query-basic.html#GUID-C09824C1-6B02-4556-A265-B1749DEE8DE1" title="XML Schema是用于描述XML文档的内容和结构的标准。您可以注册，更新和删除与Oracle XML DB一起使用的XML架构。您可以定义用于基于XML模式的数据的存储结构，并将XML模式数据类型映射到SQL数据类型。">XML架构存储和查询：基本</a> 。
                              </p>
                           </li>
                           <li>
                              <p><span class="italic">类型的属性</span>映射到父元素的子元素</p>
                              <div class="infoboxnote" id="GUID-7AF139F8-FD60-4113-AD10-1C404FF62B45__GUID-49DF9813-DEF6-420C-A51F-1D19FB56E4E8">
                                 <p class="notep1">注意：</p>
                                 <p>可以通过使用对象类型并创建对象视图或对象表来获得复杂结构。规范映射用于将对象实例映射到XML。</p>
                                 <p>在列名或属性名中使用时，at符号（ <code class="codeph">@</code> ）将转换为映射中封闭XML元素的属性。
                                 </p>
                              </div>
                           </li>
                        </ul>
                        <p>向<code class="codeph">DBMS_XMLGEN</code>函数提供用户定义的数据类型实例时，使用规范映射将用户定义的数据类型实例映射到XML文档：用户定义的数据类型的<span class="italic">属性</span>映射到XML <span class="italic">元素</span> 。名称以起始符号（ <code class="codeph">@</code> ）开头的属性将映射到前一个元素的属性。
                        </p>
                        <p>用户定义的数据类型实例可用于在生成的XML文档中进行嵌套。</p>
                        <p>例如，考虑<a href="generation-of-XML-data-from-relational-data.html#GUID-7AF139F8-FD60-4113-AD10-1C404FF62B45__I1025801">例8-24中</a>定义的表<code class="codeph">emp</code>和<code class="codeph">dept</code> 。为了生成数据的分层视图，即部门及其员工， <a href="generation-of-XML-data-from-relational-data.html#GUID-7AF139F8-FD60-4113-AD10-1C404FF62B45__I1025801">示例8-24</a>定义了合适的对象类型，以在数据库内创建结构。
                        </p>
                        <p>默认名称<code class="codeph">ROW</code>不存在，因为它已设置为<code class="codeph">NULL</code> 。 <code class="codeph">deptno</code>和<code class="codeph">empno</code>已成为封闭元素的属性。
                        </p>
                        <p><a href="generation-of-XML-data-from-relational-data.html#GUID-7AF139F8-FD60-4113-AD10-1C404FF62B45__I1032455">示例8-25</a>使用<code class="codeph">DBMS_XMLGEN.getXMLType</code>使用对象视图生成XML格式的采购订单文档。
                        </p>
                        <p><a href="generation-of-XML-data-from-relational-data.html#GUID-7AF139F8-FD60-4113-AD10-1C404FF62B45__CHEEGHEC">例8-26</a>显示了如何打开查询的游标变量，并使用该游标变量为<code class="codeph">DBMS_XMLGEN</code>创建新的上下文句柄。</p>
                        <div class="infoboxnotealso" id="GUID-7AF139F8-FD60-4113-AD10-1C404FF62B45__GUID-FF45D59E-95C4-422A-8FB3-473410F46631">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="../lnpls/cursor-variable-declaration.html#LNPLS01312" target="_blank"><span><cite>Oracle Database PL / SQL语言参考</cite></span></a>有关游标变量的更多信息（ <code class="codeph">REF CURSOR</code> ）</p>
                        </div>
                        <p><a href="generation-of-XML-data-from-relational-data.html#GUID-7AF139F8-FD60-4113-AD10-1C404FF62B45__CHEHDBFI">例8-27</a>显示了在使用<code class="codeph">DBMS_XMLGEN</code>时如何指定<code class="codeph">NULL</code>处理。</p>
                        <p>函数<code class="codeph">DBMS_XMLGEN.newContextFromHierarchy</code>将分层查询字符串作为参数，通常使用<code class="codeph">CONNECT BY</code>子句表示。它返回一个上下文，可用于生成带有递归元素的分层XML文档。
                        </p>
                        <p>分层查询返回两列，级别编号（ <code class="codeph">CONNECT BY</code>查询生成的伪列）和<code class="codeph">XMLType</code>实例。该级别用于确定<code class="codeph">XMLType</code>值在结果XML文档的层次结构中的位置。
                        </p>
                        <p>为使用<code class="codeph">newContextFromHierarchy</code>创建的上下文设置跳过行数或最大行数是错误的。
                        </p>
                        <p><a href="generation-of-XML-data-from-relational-data.html#GUID-7AF139F8-FD60-4113-AD10-1C404FF62B45__CHECHBFE">示例8-28</a>使用<code class="codeph">DBMS_ XMLGEN.newContextFromHierarchy</code>生成经理 - 员工层次结构。
                        </p>
                        <p>如果用于创建上下文的查询字符串包含主机变量，则可以使用PL / SQL方法<code class="codeph">setBindValue()</code>在查询执行之前提供变量值。<a href="generation-of-XML-data-from-relational-data.html#GUID-7AF139F8-FD60-4113-AD10-1C404FF62B45__CHEHABDH">例8-29</a>说明了这一点。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-7AF139F8-FD60-4113-AD10-1C404FF62B45__I1025636">
                        <p class="titleinexample">示例8-21 DBMS_XMLGEN：生成简单XML</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE temp_clob_tab（结果CLOB）; DECLARE qryCtx DBMS_XMLGEN.ctxHandle;结果CLOB; BEGIN qryCtx：= DBMS_XMLGEN.newContext（'SELECT * FROM hr.employees WHERE employee_id = 101'）; - 将行标题设置为EMPLOYEE DBMS_XMLGEN.setRowTag（qryCtx，'EMPLOYEE'）; - 获得结果结果：= DBMS_XMLGEN.getXML（qryCtx）; INSERT INTO temp_clob_tab VALUES（结果）; - 关闭上下文DBMS_XMLGEN.closeContext（qryCtx）;结束; /</pre><p>这会生成以下XML文档：</p><pre class="oac_no_warn" dir="ltr">SELECT * FROM temp_clob_tab;结果------------------------------------------------- ------ &lt;？xml版本=“1.0”？&gt; &lt;ROWSET&gt; &lt;EMPLOYEE&gt; &lt;EMPLOYEE_ID&gt; 101 &lt;/ EMPLOYEE_ID&gt; &lt;FIRST_NAME&gt; Neena &lt;/ FIRST_NAME&gt; &lt;LAST_NAME&gt; Kochhar &lt;/ LAST_NAME&gt; &lt;EMAIL&gt; NKOCHHAR &lt;/ EMAIL&gt; &lt;PHONE_NUMBER&gt; 515.123.4568 &lt;/ PHONE_NUMBER&gt; &lt; HIRE_DATE&gt; 21-SEP-05 &lt;/ HIRE_DATE&gt; &lt;JOB_ID&gt; AD_VP &lt;/ JOB_ID&gt; &lt;SALARY&gt; 17000 &lt;/ SALARY&gt; &lt;MANAGER_ID&gt; 100 &lt;/ MANAGER_ID&gt; &lt;DEPARTMENT_ID&gt; 90 &lt;/ DEPARTMENT_ID&gt; &lt;/ EMPLOYEE&gt; &lt;/ ROWSET &gt;选择了1行。
</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-7AF139F8-FD60-4113-AD10-1C404FF62B45__I1025688">
                        <p class="titleinexample">示例8-22 DBMS_XMLGEN：使用分页生成简单XML（获取）</p><pre class="oac_no_warn" dir="ltr">- 创建一个表来保存结果CREATE TABLE temp_clob_tab（result clob）; DECLARE qryCtx DBMS_XMLGEN.ctxHandle;结果CLOB; BEGIN  - 获取查询上下文; qryCtx：= DBMS_XMLGEN.newContext（'SELECT * FROM hr.employees'）; - 将最大行数设置为2 DBMS_XMLGEN。 <span class="bold">setMaxRows</span> （qryCtx，2）; LOOP  - 获得结果结果：= DBMS_XMLGEN.getXML（qryCtx）; - 如果没有处理任何行，则退出EXIT WHEN DBMS_XMLGEN.getNumRowsProcessed（qryCtx）= 0; - 使用lob数据进行一些处理 - 将结果插入表中。- 您可以打印输出，输出到流， - 将其放入队列，或进行任何其他处理。INSERT INTO temp_clob_tab VALUES（结果）;结束循环; --close context DBMS_XMLGEN.closeContext（qryCtx）;结束; / SELECT * FROM temp_clob_tab WHERE rownum &lt;3;结果------------------------------------------------- --------- &lt;？xml版本=“1.0”？&gt; &lt;ROWSET&gt; &lt;ROW&gt; &lt;EMPLOYEE_ID&gt; 100 &lt;/ EMPLOYEE_ID&gt; &lt;FIRST_NAME&gt; Steven &lt;/ FIRST_NAME&gt; &lt;LAST_NAME&gt; King &lt;/ LAST_NAME&gt; &lt;EMAIL&gt; SKING &lt;/ EMAIL&gt; &lt;PHONE_NUMBER&gt; 515.123.4567 &lt;/ PHONE_NUMBER&gt; &lt; HIRE_DATE&gt; 17-JUN-03 &lt;/ HIRE_DATE&gt; &lt;JOB_ID&gt; AD_PRES &lt;/ JOB_ID&gt; &lt;SALARY&gt; 24000 &lt;/ SALARY&gt; &lt;DEPARTMENT_ID&gt; 90 &lt;/ DEPARTMENT_ID&gt; &lt;/ ROW&gt; &lt;ROW&gt; &lt;EMPLOYEE_ID&gt; 101 &lt;/ EMPLOYEE_ID&gt; &lt;FIRST_NAME&gt; Neena &lt;/ FIRST_NAME&gt; &lt;LAST_NAME&gt; Kochhar &lt;/ LAST_NAME&gt; &lt;EMAIL&gt; NKOCHHAR &lt;/ EMAIL&gt; &lt;PHONE_NUMBER&gt; 515.123.4568 &lt;/ PHONE_NUMBER&gt; &lt;HIRE_DATE&gt; 21-SEP-05 &lt;/ HIRE_DATE&gt; &lt;JOB_ID&gt; AD_VP &lt;/ JOB_ID&gt; &lt;SALARY&gt; 17000 &lt;/ SALARY&gt; &lt;MANAGER_ID&gt; 100 &lt;/ MANAGER_ID&gt; &lt;DEPARTMENT_ID&gt; 90 &lt;/ DEPARTMENT_ID&gt; &lt;/ ROW&gt; &lt;/ ROWSET&gt; &lt;？xml版本=“1.0”？&gt; &lt;ROWSET&gt; &lt;ROW&gt; &lt;EMPLOYEE_ID&gt; 102 &lt;/ EMPLOYEE_ID&gt; &lt;FIRST_NAME&gt; Lex &lt;/ FIRST_NAME&gt; &lt;LAST_NAME&gt; De Haan &lt;/ LAST_NAME&gt; &lt;EMAIL&gt; LDEHAAN &lt;/ EMAIL&gt; &lt;PHONE_NUMBER&gt; 515.123.4569 &lt;/ PHONE_NUMBER&gt; &lt;HIRE_DATE&gt; 13-JAN-01 &lt;/ HIRE_DATE&gt; &lt;JOB_ID&gt; AD_VP &lt;/ JOB_ID&gt; &lt;SALARY&gt; 17000 &lt;/ SALARY&gt; &lt;MANAGER_ID&gt; 100 &lt;/ MANAGER_ID&gt; &lt;DEPARTMENT_ID&gt; 90 &lt;/ DEPARTMENT_ID&gt; &lt;/ ROW&gt; &lt;ROW &gt; &lt;EMPLOYEE_ID&gt; 103 &lt;/ EMPLOYEE_ID&gt; &lt;FIRST_NAME&gt; Alexander &lt;/ FIRST_NAME&gt; &lt;LAST_NAME&gt; Hunold &lt;/ LAST_NAME&gt; &lt;EMAIL&gt; AHUNOLD &lt;/ EMAIL&gt; &lt;PHONE_NUMBER&gt; 590.423.4567 &lt;/ PHONE_NUMBER&gt; &lt;HIRE_DATE&gt; 03-JAN- 06 &lt;/ HIRE_DATE&gt; &lt;JOB_ID&gt; IT_PROG &lt;/ JOB_ID&gt; &lt;SALARY&gt; 9000 &lt;/ SALARY&gt; &lt;MANAGER_ID&gt; 102 &lt;/ MANAGER_ID&gt; &lt;DEPARTMENT_ID&gt; 60 &lt;/ DEPARTMENT_ID&gt; &lt;/ ROW&gt; &lt;/ ROWSET&gt;选择了2行。
</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-7AF139F8-FD60-4113-AD10-1C404FF62B45__BABFCBFF">
                        <p class="titleinexample">示例8-23 DBMS_XMLGEN：使用对象类型生成XML</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE new_departments（department_id NUMBER PRIMARY KEY，department_name VARCHAR2（20））; CREATE TABLE new_employees（employee_id NUMBER PRIMARY KEY，last_name VARCHAR2（20），department_id NUMBER REFERENCES new_departments）; CREATE TYPE emp_t AS OBJECT（“@ employee_id”NUMBER，last_name VARCHAR2（20））; / INSERT INTO new_departments VALUES（10，'SALES'）; INSERT INTO new_departments VALUES（20，'ACCOUNTING'）; INSERT INTO new_employees VALUES（30，'Scott'，10）; INSERT INTO new_employees VALUES（31，'Mary'，10）; INSERT INTO new_employees VALUES（40，'John'，20）; INSERT INTO new_employees VALUES（41，'Jerry'，20）;承诺; CREATE TYPE emplist_t AS TABLE OF emp_t; / CREATE TYPE dept_t AS OBJECT（“@ department_id”NUMBER，department_name VARCHAR2（20），emplist emplist_t）; / CREATE TABLE temp_clob_tab（结果CLOB）; DECLARE qryCtx DBMS_XMLGEN.ctxHandle;结果CLOB; BEGIN DBMS_XMLGEN.setRowTag（qryCtx，NULL）; qryCtx：= DBMS_XMLGEN.newContext（'SELECT dept_t（department_id，department_name，cast（MULTISET（SELECT e.employee_id，e.last_name FROM new_employees e WHERE e.department_id = d.department_id）AS emplist_t））AS deptxml FROM new_departments d'） ; - 现在得到结果结果：= DBMS_XMLGEN.getXML（qryCtx）; INSERT INTO temp_clob_tab VALUES（结果）; - 关闭上下文DBMS_XMLGEN.closeContext（qryCtx）;结束; / SELECT * FROM temp_clob_tab;</pre><p>以下是生成的XML：</p><pre class="oac_no_warn" dir="ltr">RESULT -------------------------------------------- &lt;？xml版本=“1.0”？&gt; &lt;ROWSET&gt; &lt;ROW&gt; &lt;DEPTXML department_id =“10”&gt; &lt;DEPARTMENT_NAME&gt; SALES &lt;/ DEPARTMENT_NAME&gt; &lt;EMPLIST&gt; &lt;EMP_T employee_id =“30”&gt; &lt;LAST_NAME&gt; Scott &lt;/ LAST_NAME&gt; &lt;/ EMP_T&gt; &lt;EMP_T employee_id = “31”&gt; &lt;LAST_NAME&gt; Mary &lt;/ LAST_NAME&gt; &lt;/ EMP_T&gt; &lt;/ EMPLIST&gt; &lt;/ DEPTXML&gt; &lt;/ ROW&gt; &lt;ROW&gt; &lt;DEPTXML department_id =“20”&gt; &lt;DEPARTMENT_NAME&gt;会计&lt;/ DEPARTMENT_NAME&gt; &lt;EMPLIST&gt; &lt;EMP_T employee_id =“40”&gt; &lt;LAST_NAME&gt; John &lt;/ LAST_NAME&gt; &lt;/ EMP_T&gt; &lt;EMP_T employee_id =“41”&gt; &lt;LAST_NAME&gt; Jerry &lt;/ LAST_NAME&gt; &lt;/ EMP_T&gt; &lt;/ EMPLIST&gt; &lt;/ DEPTXML&gt; &lt;/ ROW&gt; &lt;/ ROWSET&gt;选择了1行。
</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-7AF139F8-FD60-4113-AD10-1C404FF62B45__I1025801">
                        <p class="titleinexample">示例8-24 DBMS_XMLGEN：使用用户定义的数据类型实例生成XML</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE dept（deptno NUMBER PRIMARY KEY，dname VARCHAR2（20））; CREATE TABLE emp（empno NUMBER PRIMARY KEY，ename VARCHAR2（20），deptno NUMBER REFERENCES dept）;</pre><pre class="oac_no_warn" dir="ltr">-  empno前面有一个at符号（@），表示必须将其映射为封闭的Employee元素的属性。CREATE TYPE emp_t AS OBJECT（“@ empno”NUMBER， -  empno定义为属性ename VARCHAR2（20））; /插入部门价值（10，'体育'）;插入部门价值（20，'会计'）;插入EMP价值观（200，'John'，10）;插入EMP VALUES（300，'Jack'，10）;插入EMP VALUES（400，'Mary'，20）;插入EMP VALUES（500，'Jerry'，20）;承诺; CREATE TYPE emplist_t AS TABLE OF emp_t; / CREATE TYPE dept_t AS OBJECT（“@ deptno”NUMBER，dname VARCHAR2（20），emplist emplist_t）; /  - 部门类型dept_t包含员工列表。- 您现在可以查询employee和department表并将结果作为XML文档获取，如下所示：CREATE TABLE temp_clob_tab（result CLOB）; DECLARE qryCtx DBMS_XMLGEN.ctxHandle;结果CLOB; BEGIN  - 获取查询上下文qryCtx：= DBMS_XMLGEN.newContext（'SELECT <span class="bold">dept_t</span> （deptno，dname， <span class="bold">cast</span> （ <span class="bold">MULTISET</span> （SELECT empno，ename FROM emp e WHERE e.deptno = d.deptno）AS <span class="bold">emplist_t</span> ））AS deptxml FROM dept d “）; - 将最大行数设置为5 DBMS_XMLGEN.setMaxRows（qryCtx，5）; - 为此结果设置无行标记，因为只有一个ADT列DBMS_XMLGEN。 <span class="bold">setRowTag</span> （qryCtx， <span class="bold">NULL</span> ）; LOOP  - 获得结果结果：= DBMS_XMLGEN.getXML（qryCtx）; - 如果没有处理任何行，则退出EXIT WHEN DBMS_XMLGEN.getNumRowsProcessed（qryCtx）= 0; - 对结果执行某些操作INSERT INTO temp_clob_tab VALUES（result）;结束循环;结束; /</pre><p>该<code class="codeph">MULTISET</code>为Oracle SQL函数关键字<code class="codeph">cast</code>对待该部门作为一个列表，其中工作的员工<code class="codeph">cast</code>分配给适当的集合类型。使用构造函数<code class="codeph">dept_t</code>创建部门实例，并且<code class="codeph">DBMS_XMLGEN</code>例程为对象实例创建XML数据。
                        </p><pre class="oac_no_warn" dir="ltr">SELECT * FROM temp_clob_tab;结果--------------------------------- &lt;？xml版本=“1.0”？&gt; &lt;ROWSET&gt; &lt;DEPTXML deptno =“10”&gt; &lt;DNAME&gt;体育&lt;/ DNAME&gt; &lt;EMPLIST&gt; &lt;EMP_T empno =“200”&gt; &lt;ENAME&gt; John &lt;/ ENAME&gt; &lt;/ EMP_T&gt; &lt;EMP_T empno =“300” &gt; &lt;ENAME&gt;杰克&lt;/ ENAME&gt; &lt;/ EMP_T&gt; &lt;/ EMPLIST&gt; &lt;/ DEPTXML&gt; &lt;DEPTXML deptno =“20”&gt; &lt;DNAME&gt;会计&lt;/ DNAME&gt; &lt;EMPLIST&gt; &lt;EMP_T empno =“400”&gt; &lt;ENAME &gt; Mary &lt;/ ENAME&gt; &lt;/ EMP_T&gt; &lt;EMP_T empno =“500”&gt; &lt;ENAME&gt; Jerry &lt;/ ENAME&gt; &lt;/ EMP_T&gt; &lt;/ EMPLIST&gt; &lt;/ DEPTXML&gt; &lt;/ ROWSET&gt;选择了1行。
</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-7AF139F8-FD60-4113-AD10-1C404FF62B45__I1032455">
                        <p class="titleinexample">示例8-25 DBMS_XMLGEN：生成XML采购订单</p><pre class="oac_no_warn" dir="ltr">- 创建关系模式并定义对象视图 -  DBMS_XMLGEN映射用户定义的数据类型属性名称 - 使用at符号（@）到XML属性 - 采购订单对象视图模型 -  PhoneList varray对象类型CREATE TYPE phonelist_vartyp AS VARRAY（10）OF VARCHAR2（20）/  - 地址对象类型CREATE TYPE address_typ AS OBJECT（Street VARCHAR2（200），City VARCHAR2（200），State CHAR（2），Zip VARCHAR2（20））/  -  - 客户对象类型CREATE TYPE customer_typ AS OBJECT（CustNo NUMBER，CustName VARCHAR2（200），Address address_typ，PhoneList phonelist_vartyp）/  -  StockItem对象类型CREATE TYPE stockitem_typ AS OBJECT（“@ StockNo”NUMBER，Price NUMBER，TaxRate NUMBER）/ -  LineItems对象类型CREATE TYPE lineitem_typ AS OBJECT（“@ LineItemNo”NUMBER，Item stockitem_typ，Quantity NUMBER，Discount NUMBER）/  -  LineItems有序集合表CREATE TYPE lineitems_ntabtyp AS TABLE OF lineitem_typ /  -  Purchase Order对象类型CREATE TYPE po_typ AUTHID CURRENT_USER作为对象（P ONO NUMBER，Cust_ref REF customer_typ，OrderDate DATE，ShipDate TIMESTAMP，LineItems_ntab lineitems_ntabtyp，ShipToAddr address_typ）/  - 创建采购订单关系模型表 - 客户表CREATE TABLE customer_tab（CustNo NUMBER NOT NULL，CustName VARCHAR2（200），Street VARCHAR2（ 200），City VARCHAR2（200），State CHAR（2），Zip VARCHAR2（20），Phone1 VARCHAR2（20），Phone2 VARCHAR2（20），Phone3 VARCHAR2（20），CONSTRAINT cust_pk PRIMARY KEY（CustNo））; - 采购订单表CREATE TABLE po_tab（PONo NUMBER，/ *采购订单编号* / Custno NUMBER / *外部KEY引用客户* / CONSTRAINT po_cust_fk REFERENCES customer_tab，OrderDate DATE，/ *订单日期* / ShipDate TIMESTAMP，/ * date要发货* / ToStreet VARCHAR2（200），/ * shipto地址* / ToCity VARCHAR2（200），ToState CHAR（2），ToZip VARCHAR2（20），CONSTRAINT po_pk PRIMARY KEY（PONo））; - 库存表CREATE TABLE stock_tab（StockNo NUMBER CONSTRAINT stock_uk UNIQUE，Price NUMBER，TaxRate NUMBER）; --Line Items表CREATE TABLE lineitems_tab（LineItemNo NUMBER，PONo NUMBER CONSTRAINT li_po_fk REFERENCES po_tab，StockNo NUMBER，Quantity NUMBER，Discount NUMBER，CONSTRAINT li_pk PRIMARY KEY（PONo，LineItemNo））; - 创建对象视图 - 客户对象视图CREATIVE或REPLACE VIEW customer OF customer_typ WITH OBJECT IDENTIFIER（CustNo）AS SELECT c.custno，c.custname，address_typ（c.street，c.city，c.state，c.zip ），phonelist_vartyp（phone1，phone2，phone3）FROM customer_tab c; - 购买订单视图创建或替换视图po po_typ WITH OBJECT IDENTIFIER（PONO）AS SELECT p.pono，make_ref（Customer，P.Custno），p.orderdate，p.shipdate，cast（MULTISET（SELECT lineitem_typ（l。）。 lineitemno，stockitem_typ（l.stockno，s.price，s.taxrate），l.quantity，l.discount）FROM lineitems_tab l，stock_tab s WHERE l.pono = p.pono AND s.stockno = l.stockno）AS lineitems_ntabtyp ），address_typ（p.tostreet，p.tocity，p.tostate，p.tozip）FROM po_tab p; - 使用XMLType列创建表以XML格式存储采购订单CREATE TABLE po_xml_tab（poid NUMBER，podoc XMLType）/  - 填充数据-------------------  - 建立库存INSERT INTO stock_tab VALUES（1004,6750.00,2）;插入stock_tab VALUES（1011,4500.23,2）; INSERT INTO stock_tab VALUES（1534,2234.00,2）;插入stock_tab VALUES（1535,356.23,2）; - 注册客户INSERT INTO customer_tab VALUES（1，'Jean Nance'，'2 Avocet Drive'，'Redwood Shores'，'CA'，'95054'，'415-555-1212'，NULL，NULL）; INSERT INTO customer_tab VALUES（2，'John Nike'，'323 College Drive'，'Edison'，'NJ'，'08820'，'609-555-1212'，'201-555-1212'，NULL）; - 下订单INSERT INTO po_tab VALUES（1001,1，'10 -APR-1997'，'10 -MAY-1997'，NULL，NULL，NULL，NULL）; INSERT INTO po_tab VALUES（2001,2，' -  20-APR-1997'，'20 -MAY-1997'，'55 Madison Ave'，'Madison'，'WI'，'53715'）; - 详细信息行项目INSERT INTO lineitems_tab VALUES（01,1001,1534,12,0）; INSERT INTO lineitems_tab VALUES（02,1001,1535,10,10）; INSERT INTO lineitems_tab VALUES（01,2001,1004,1,0）; INSERT INTO lineitems_tab VALUES（02,2001,1011,2,1）; - 使用包DBMS_XMLGEN以XML格式生成采购订单 - 并将XMLType存储在表po_xml DECLARE qryCtx DBMS_XMLGEN.ctxHandle中; pxml XMLType; cxml CLOB; BEGIN  - 获取查询上下文; qryCtx：= DBMS_XMLGEN.newContext（'SELECT pono，deref（cust_ref）customer，p.orderdate，p.shipdate，lineitems_ntab lineitems，shiptoaddr FROM po p'）; - 将最大行数设置为1，DBMS_XMLGEN.setMaxRows（qryCtx，1）; - 将ROWSET标记设置为NULL，将ROW标记设置为PurchaseOrder DBMS_XMLGEN。 <span class="bold">setRowSetTag</span> （qryCtx， <span class="bold">NULL</span> ）; DBMS_XMLGEN。 <span class="bold">setRowTag</span> （qryCtx，' <span class="bold">PurchaseOrder</span> '）; LOOP  - 以XML格式获取采购订单pxml：= DBMS_XMLGEN.getXMLType（qryCtx）; - 如果没有处理任何行，则退出EXIT WHEN DBMS_XMLGEN.getNumRowsProcessed（qryCtx）= 0; - 将XMLType po存储在po_xml表中（获取pono）INSERT INTO po_xml_tab（poid，poDoc）VALUES（XMLCast（XMLQuery（'// PONO / text（）'PASSING pxml RETURNING CONTENT）AS NUMBER），pxml）;结束循环;结束; /</pre><p>然后，此查询将生成两个XML采购订单文档：</p><pre class="oac_no_warn" dir="ltr">SELECT XMLSerialize（DOCUMENT x.podoc AS CLOB）xpo FROM po_xml_tab x; XPO ------------------------------------------------- -  &lt;PurchaseOrder&gt; &lt;PONO&gt; 1001 &lt;/ PONO&gt; &lt;CUSTOMER&gt; &lt;CUSTNO&gt; 1 &lt;/ CUSTNO&gt; &lt;CUSTNAME&gt; Jean Nance &lt;/ CUSTNAME&gt; &lt;ADDRESS&gt; &lt;STREET&gt; 2 Avocet Drive &lt;/ STREET&gt; &lt;CITY&gt; Redwood海岸&lt;/ CITY&gt; &lt;STATE&gt; CA &lt;/ STATE&gt; &lt;ZIP&gt; 95054 &lt;/ ZIP&gt; &lt;/ ADDRESS&gt; &lt;PHONELIST&gt; &lt;VARCHAR2&gt; 415-555-1212 &lt;/ VARCHAR2&gt; &lt;/ PHONELIST&gt; &lt;/ CUSTOMER&gt; &lt;ORDERDATE &gt; 10-APR-97 &lt;/ ORDERDATE&gt; &lt;SHIPDATE&gt; 10-MAY-97 12.00.00.000000 AM &lt;/ SHIPDATE&gt; &lt;LINEITEMS&gt; &lt;LINEITEM_TYP LineItemNo =“1”&gt; &lt;ITEM StockNo =“1534”&gt; &lt;PRICE&gt; 2234 &lt; / PRICE&gt; &lt;TAXRATE&gt; 2 &lt;/ TAXRATE&gt; &lt;/ ITEM&gt; &lt;QUANTITY&gt; 12 &lt;/ QUANTITY&gt; &lt;DISCOUNT&gt; 0 &lt;/ DISCOUNT&gt; &lt;/ LINEITEM_TYP&gt; &lt;LINEITEM_TYP LineItemNo =“2”&gt; &lt;ITEM StockNo =“1535” &gt; &lt;PRICE&gt; 3456.23 &lt;/ PRICE&gt; &lt;TAXRATE&gt; 2 &lt;/ TAXRATE&gt; &lt;/ ITEM&gt; &lt;QUANTITY&gt; 10 &lt;/ QUANTITY&gt; &lt;DISCOUNT&gt; 10 &lt;/ DISCOUNT&gt; &lt;/ LINEITEM_TYP&gt; &lt;/ LINEITEMS&gt; &lt;SHIPTOADDR /&gt; &lt; / PurchaseOrder&gt; &lt;PurchaseOrder&gt; &lt;PONO&gt; 2001 &lt;/ PONO&gt; &lt;CUSTOMER&gt; &lt;CUSTNO&gt; 2 &lt;/ CUSTNO&gt; &lt;CUSTNAME&gt; John Nike &lt;/ CUSTNAME&gt; &lt;ADDRESS&gt; &lt;STREET&gt; 323 College Drive &lt;/ STREET&gt; &lt;CITY&gt;爱迪生&lt;/ CITY&gt; &lt;STATE&gt; NJ &lt;/ STATE&gt; &lt;ZIP&gt; 08820 &lt;/ ZIP&gt; &lt;/ ADDRESS&gt; &lt;PHONELIST&gt; &lt;VARCHAR2&gt; 609-555-1212 &lt;/ VARCHAR2&gt; &lt;VARCHAR2&gt; 201-555-1212 &lt;/ VARCHAR2&gt; &lt;/ PHONELIST&gt; &lt;/ CUSTOMER&gt; &lt;ORDERDATE&gt; 20-APR-97 &lt; / ORDERDATE&gt; &lt;SHIPDATE&gt; 20-MAY-97 12.00.00.000000 AM &lt;/ SHIPDATE&gt; &lt;LINEITEMS&gt; &lt;LINEITEM_TYP LineItemNo =“1”&gt; &lt;ITEM StockNo =“1004”&gt; &lt;PRICE&gt; 6750 &lt;/ PRICE&gt; &lt;TAXRATE&gt; 2 &lt;/ TAXRATE&gt; &lt;/ ITEM&gt; &lt;QUANTITY&gt; 1 &lt;/ QUANTITY&gt; &lt;DISCOUNT&gt; 0 &lt;/ DISCOUNT&gt; &lt;/ LINEITEM_TYP&gt; &lt;LINEITEM_TYP LineItemNo =“2”&gt; &lt;ITEM StockNo =“1011”&gt; &lt;PRICE&gt; 4500.23 &lt;/价格&gt; &lt;TAXRATE&gt; 2 &lt;/ TAXRATE&gt; &lt;/ ITEM&gt; &lt;QUANTITY&gt; 2 &lt;/ QUANTITY&gt; &lt;折扣&gt; 1 &lt;/折扣&gt; &lt;/ LINEITEM_TYP&gt; &lt;/ LINEITEMS&gt; &lt;SHIPTOADDR&gt; &lt;STREET&gt; 55 Madison Ave &lt;/ STREET &gt; &lt;CITY&gt;麦迪逊&lt;/ CITY&gt; &lt;STATE&gt; WI &lt;/ STATE&gt; &lt;ZIP&gt; 53715 &lt;/ ZIP&gt; &lt;/ SHIPTOADDR&gt; &lt;/ PurchaseOrder&gt;选择了2行。
</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-7AF139F8-FD60-4113-AD10-1C404FF62B45__CHEEGHEC">
                        <p class="titleinexample">示例8-26 DBMS_XMLGEN：从REF游标生成新的上下文句柄</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE emp_tab（emp_id NUMBER PRIMARY KEY，名称VARCHAR2（20），dept_id NUMBER）;表创建。INSERT INTO emp_tab VALUES（122，'Scott'，301）;已创建1行。INSERT INTO emp_tab VALUES（123，'Mary'，472）;已创建1行。INSERT INTO emp_tab VALUES（124，'John'，93）;已创建1行。INSERT INTO emp_tab VALUES（125，'Howard'，488）;已创建1行。INSERT INTO emp_tab VALUES（126，'Sue'，16）;已创建1行。承诺; DECLARE ctx NUMBER; maxrow NUMBER; xmldoc CLOB; refcur SYS_REFCURSOR; BEGIN DBMS_LOB.createtemporary（xmldoc，TRUE）; maxrow：= 3; OPEN refcur FOR'SELECT * FROM emp_tab WHERE ROWNUM &lt;=：1'使用maxrow; ctx：= DBMS_XMLGEN.newContext（refcur）; -  xmldoc将有3行DBMS_XMLGEN.getXML（ctx，xmldoc，DBMS_XMLGEN.NONE）; DBMS_OUTPUT.PUT_LINE（xmlDoc中）; DBMS_LOB.freetemporary（xmlDoc中）;关闭反复; DBMS_XMLGEN.closeContext（CTX）;结束; / &lt;？xml版本=“1.0”？&gt; &lt;ROWSET&gt; &lt;ROW&gt; &lt;EMP_ID&gt; 122 &lt;/ EMP_ID&gt; &lt;NAME&gt; Scott &lt;/ NAME&gt; &lt;DEPT_ID&gt; 301 &lt;/ DEPT_ID&gt; &lt;/ ROW&gt; &lt;ROW&gt; &lt;EMP_ID&gt; 123 &lt;/ EMP_ID&gt; &lt;NAME&gt; Mary &lt;/ NAME&gt; &lt;DEPT_ID&gt; 472 &lt;/ DEPT_ID&gt; &lt;/ ROW&gt; &lt;ROW&gt; &lt;EMP_ID&gt; 124 &lt;/ EMP_ID&gt; &lt;NAME&gt; John &lt;/ NAME&gt; &lt;DEPT_ID&gt; 93 &lt;/ DEPT_ID&gt; &lt;/ ROW&gt; &lt;/ ROWSET &gt; PL / SQL过程成功完成。</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-7AF139F8-FD60-4113-AD10-1C404FF62B45__CHEHDBFI">
                        <p class="titleinexample">示例8-27 DBMS_XMLGEN：指定NULL处理</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE emp_tab（emp_id NUMBER PRIMARY KEY，名称VARCHAR2（20），dept_id NUMBER）;表创建。INSERT INTO emp_tab VALUES（30，'Scott'，NULL）;已创建1行。INSERT INTO emp_tab VALUES（31，'Mary'，NULL）;已创建1行。INSERT INTO emp_tab VALUES（40，'John'，NULL）;已创建1行。承诺; CREATE TABLE temp_clob_tab（结果CLOB）;表创建。DECLARE qryCtx DBMS_XMLGEN.ctxHandle;结果CLOB; BEGIN qryCtx：= DBMS_XMLGEN.newContext（'SELECT * FROM emp_tab where name =：NAME'）; - 将行标题设置为EMPLOYEE DBMS_XMLGEN.setRowTag（qryCtx，'EMPLOYEE'）; - 删除空值DBMS_XMLGEN.setBindValue（qryCtx，'NAME'，'Scott'）; DBMS_XMLGEN.setNullHandling（qryCtx，DBMS_XMLGEN.DROP_NULLS）;结果：= DBMS_XMLGEN.getXML（qryCtx）; INSERT INTO temp_clob_tab VALUES（结果）; - 空属性DBMS_XMLGEN.setBindValue（qryCtx，'NAME'，'Mary'）; DBMS_XMLGEN.setNullHandling（qryCtx，DBMS_XMLGEN.NULL_ATTR）;结果：= DBMS_XMLGEN.getXML（qryCtx）; INSERT INTO temp_clob_tab VALUES（结果）; - 空标记DBMS_XMLGEN.setBindValue（qryCtx，'NAME'，'John'）; DBMS_XMLGEN.setNullHandling（qryCtx，DBMS_XMLGEN.EMPTY_TAG）;结果：= DBMS_XMLGEN.getXML（qryCtx）; INSERT INTO temp_clob_tab VALUES（结果）; - 关闭上下文DBMS_XMLGEN.closeContext（qryCtx）;结束; / PL / SQL过程成功完成。SELECT * FROM temp_clob_tab;结果------------------------------------------- &lt;？xml版本=“1.0”？&gt; &lt;ROWSET&gt; &lt;EMPLOYEE&gt; &lt;EMP_ID&gt; 30 &lt;/ EMP_ID&gt; &lt;NAME&gt; Scott &lt;/ NAME&gt; &lt;/ EMPLOYEE&gt; &lt;/ ROWSET&gt; &lt;？xml版本=“1.0”？&gt; &lt;ROWSET xmlns：xsi =“http://www.w3.org/2001/XMLSchema-instance”&gt; &lt;EMPLOYEE&gt; &lt;EMP_ID&gt; 31 &lt;/ EMP_ID&gt; &lt;NAME&gt; Mary &lt;/ NAME&gt; &lt;DEPT_ID xsi：nil = “true”/&gt; &lt;/ EMPLOYEE&gt; &lt;/ ROWSET&gt; &lt;？xml版本=“1.0”？&gt; &lt;ROWSET&gt; &lt;EMPLOYEE&gt; &lt;EMP_ID&gt; 40 &lt;/ EMP_ID&gt; &lt;NAME&gt; John &lt;/ NAME&gt; &lt;DEPT_ID /&gt; &lt;/ EMPLOYEE&gt; &lt;/ ROWSET&gt;选择3行。
</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-7AF139F8-FD60-4113-AD10-1C404FF62B45__CHECHBFE">
                        <p class="titleinexample">示例8-28 DBMS_XMLGEN：使用分层查询生成递归XML</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE sqlx_display（id NUMBER，xmldoc XMLType）;表创建。DECLARE qryctx DBMS_XMLGEN.ctxhandle;结果XMLType; BEGIN qryctx：= DBMS_XMLGEN。 <span class="bold">newContextFromHierarchy</span> （'SELECT level，XMLElement（“employees”，XMLElement（“enumber”，employee_id），XMLElement（“name”，last_name），XMLElement（“Salary”，salary），XMLElement（“Hiredate”，hire_date））FROM hr .employees START WITH last_name =''De Haan''CONNECT BY PRIOR employee_id = manager_id ORDER SIBLINGS BY hire_date'）;结果：= DBMS_XMLGEN.getxmltype（qryctx）; DBMS_OUTPUT.put_line（' <span class="bold">&lt;result num rows&gt;</span> '）; DBMS_OUTPUT.put_line（ <span class="bold">to_char（DBMS_XMLGEN.getNumRowsProcessed（qryctx））</span> ）; DBMS_OUTPUT.put_line（' <span class="bold">&lt;/ result num rows&gt;</span> '）; INSERT INTO sqlx_display VALUES（2，result）;承诺; DBMS_XMLGEN.closecontext（qryctx）;结束; / <span class="bold">&lt;result num rows&gt;</span> <span class="bold">6</span> <span class="bold">&lt;/ result num rows&gt;</span> PL / SQL过程成功完成。SELECT xmldoc FROM sqlx_display WHERE id = 2; XMLDOC ------------------------------------------------- ---- &lt;？xml版本=“1.0”？&gt; &lt;employees&gt; &lt;enumber&gt; 102 &lt;/ enumber&gt; &lt;name&gt; De Haan &lt;/ name&gt; &lt;薪水&gt; 17000 &lt;/薪水&gt; &lt;Hiredate&gt; 2001-01-13 &lt;/ Hiredate&gt; &lt;employees&gt; &lt;enumber&gt; 103 &lt;/ enumber&gt; &lt;name&gt; Hunold &lt;/ name&gt; &lt;薪水&gt; 9000 &lt;/薪水&gt; &lt;Hiredate&gt; 2006-01-03 &lt;/ Hiredate&gt; &lt;employees&gt; &lt;enumber&gt; 105 &lt;/ enumber&gt; &lt;name&gt; Austin &lt;/ name&gt; &lt;薪资&gt; 4800 &lt;/薪水&gt; &lt;Hiredate&gt; 2005-06-25 &lt;/ Hiredate&gt; &lt;/ employees&gt; &lt;employees&gt; &lt;enumber&gt; 106 &lt;/ enumber&gt; &lt;name&gt; Pataballa &lt;/ name&gt; &lt;薪水&gt; 4800 &lt;/薪水&gt; &lt;Hiredate&gt; 2006-02-05 &lt;/ Hiredate&gt; &lt;/ employees&gt; &lt;employees&gt; &lt;enumber&gt; 107 &lt;/ enumber&gt; &lt;name&gt; Lorentz &lt;/ name&gt; &lt;Salary&gt; 4200 &lt;/ Salary&gt; &lt;Hiredate&gt; 2007-02- 07 &lt;/ Hiredate&gt; &lt;/ employees&gt; &lt;employees&gt; &lt;enumber&gt; 104 &lt;/ enumber&gt; &lt;name&gt; Ernst &lt;/ name&gt; &lt;薪水&gt; 6000 &lt;/薪水&gt; &lt;Hiredate&gt; 2007-05-21 &lt;/ Hiredate&gt; &lt;/员工&gt; &lt;/ employees&gt; &lt;/ employees&gt;选择1行。
</pre><p>默认情况下， <code class="codeph">ROWSET</code>标记为<code class="codeph">NULL</code> ：没有用于包含XML结果的默认<code class="codeph">ROWSET</code>标记。但是，您可以使用过程<code class="codeph">setRowSetTag</code>显式设置<code class="codeph">ROWSET</code>标记，如下所示：</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE gg（x XMLType）;表创建。DECLARE qryctx DBMS_XMLGEN.ctxhandle;结果CLOB; BEGIN qryctx：= DBMS_XMLGEN.newContextFromHierarchy（'SELECT level，XMLElement（“NAME”，last_name）AS myname FROM hr.employees CONNECT BY PRIOR employee_id = manager_id START WITH employee_id = 102'）; DBMS_XMLGEN。 <span class="bold">setRowSetTag</span> （qryctx，' <span class="bold">mynum_hierarchy</span> '）;结果：= DBMS_XMLGEN.getxml（qryctx）; DBMS_OUTPUT.put_line（'&lt;result num rows&gt;'）; DBMS_OUTPUT.PUT_LINE（TO_CHAR（DBMS_XMLGEN.getNumRowsProcessed（qryctx）））; DBMS_OUTPUT.put_line（'&lt;/ result num rows&gt;'）; INSERT INTO gg VALUES（XMLType（result））;承诺; DBMS_XMLGEN.closecontext（qryctx）;结束; / &lt;result num rows&gt; 6 &lt;/ result num rows&gt; PL / SQL过程成功完成。SELECT * FROM gg; X  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  - - --------- &lt;？xml版本=“1.0”？&gt; <span class="bold">&lt;mynum_hierarchy&gt;</span> &lt;NAME&gt; De Haan &lt;NAME&gt; Hunold &lt;NAME&gt;恩斯特&lt;/ NAME&gt; &lt;NAME&gt;奥斯汀&lt;/ NAME&gt; &lt;NAME&gt; Pataballa &lt;/ NAME&gt; &lt;NAME&gt; Lorentz &lt;/ NAME&gt; &lt;/ NAME&gt; &lt; / NAME&gt; <span class="bold">&lt;/ mynum_hierarchy&gt;</span>选择了1行。
</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-7AF139F8-FD60-4113-AD10-1C404FF62B45__CHEHABDH">
                        <p class="titleinexample">示例8-29 DBMS_XMLGEN：使用SETBINDVALUE（）绑定查询变量</p><pre class="oac_no_warn" dir="ltr">- <span class="bold">绑定一个变量</span> DECLARE ctx NUMBER; xmldoc CLOB; BEGIN ctx：= DBMS_XMLGEN.newContext（'SELECT * FROM employees WHERE employee_id = <span class="bold">：NO</span> '）; DBMS_XMLGEN。 <span class="bold">setBindValue</span> （ctx，' <span class="bold">NO</span> '，' <span class="bold">145</span> '）; xmldoc：= DBMS_XMLGEN.getXML（ctx）; DBMS_OUTPUT.PUT_LINE（xmlDoc中）; DBMS_XMLGEN.closeContext（CTX）;除了DBMS_XMLGEN.closeContext（ctx）之外的其他事项;提高;结束; / &lt;？xml版本=“1.0”？&gt; &lt;ROWSET&gt; &lt;ROW&gt; &lt;EMPLOYEE_ID&gt; <span class="bold">145</span> &lt;/ EMPLOYEE_ID&gt; &lt;FIRST_NAME&gt; John &lt;/ FIRST_NAME&gt; &lt;LAST_NAME&gt; Russell &lt;/ LAST_NAME&gt; &lt;EMAIL&gt; JRUSSEL &lt;/ EMAIL&gt; &lt;PHONE_NUMBER&gt; 011.44.1344.429268 &lt;/ PHONE_NUMBER&gt; &lt; HIRE_DATE&gt; 01-OCT-04 &lt;/ HIRE_DATE&gt; &lt;JOB_ID&gt; SA_MAN &lt;/ JOB_ID&gt; &lt;SALARY&gt; 14000 &lt;/ SALARY&gt; &lt;COMMISSION_PCT&gt; .4 &lt;/ COMMISSION_PCT&gt; &lt;MANAGER_ID&gt; 100 &lt;/ MANAGER_ID&gt; &lt;DEPARTMENT_ID&gt; 80 &lt;/ DEPARTMENT_ID&gt; &lt;/ ROW&gt; &lt;/ ROWSET&gt; PL / SQL过程已成功完成。
</pre><pre class="oac_no_warn" dir="ltr">- <span class="bold">使用不同的值将一个变量绑定两次</span> DECLARE ctx NUMBER; xmldoc CLOB; BEGIN ctx：= DBMS_XMLGEN.newContext（'SELECT * FROM employees WHERE hire_date = <span class="bold">：MDATE</span> '）; DBMS_XMLGEN.setBindValue（ctx，' <span class="bold">MDATE</span> '，' <span class="bold">01-OCT-04</span> '）; xmldoc：= DBMS_XMLGEN.getXML（ctx）; DBMS_OUTPUT.PUT_LINE（xmlDoc中）; DBMS_XMLGEN.setBindValue（ctx，' <span class="bold">MDATE</span> '，' <span class="bold">10-MAR-05</span> '）; xmldoc：= DBMS_XMLGEN.getXML（ctx）; DBMS_OUTPUT.PUT_LINE（xmlDoc中）; DBMS_XMLGEN.closeContext（CTX）;除了DBMS_XMLGEN.closeContext（ctx）之外的其他事项;提高;结束; / &lt;？xml版本=“1.0”？&gt; &lt;ROWSET&gt; &lt;ROW&gt; &lt;EMPLOYEE_ID&gt; 145 &lt;/ EMPLOYEE_ID&gt; &lt;FIRST_NAME&gt; John &lt;/ FIRST_NAME&gt; &lt;LAST_NAME&gt; Russell &lt;/ LAST_NAME&gt; &lt;EMAIL&gt; JRUSSEL &lt;/ EMAIL&gt; &lt;PHONE_NUMBER&gt; 011.44.1344.429268 &lt;/ PHONE_NUMBER&gt; &lt; HIRE_DATE&gt; <span class="bold">01-OCT-04</span> &lt;/ HIRE_DATE&gt; &lt;JOB_ID&gt; SA_MAN &lt;/ JOB_ID&gt; &lt;SALARY&gt; 14000 &lt;/ SALARY&gt; &lt;COMMISSION_PCT&gt; .4 &lt;/ COMMISSION_PCT&gt; &lt;MANAGER_ID&gt; 100 &lt;/ MANAGER_ID&gt; &lt;DEPARTMENT_ID&gt; 80 &lt;/ DEPARTMENT_ID&gt; &lt;/ ROW&gt; &lt;/ ROWSET&gt; &lt;？xml版本=“1.0”？&gt; &lt;ROWSET&gt; &lt;ROW&gt; &lt;EMPLOYEE_ID&gt; 147 &lt;/ EMPLOYEE_ID&gt; &lt;FIRST_NAME&gt; Alberto &lt;/ FIRST_NAME&gt; &lt;LAST_NAME&gt; Errazuriz &lt;/ LAST_NAME&gt; &lt;EMAIL&gt; AERRAZUR &lt;/ EMAIL&gt; &lt;PHONE_NUMBER&gt; 011.44.1344.429278 &lt;/ PHONE_NUMBER&gt; &lt; HIRE_DATE&gt; <span class="bold">10-MAR-05</span> &lt;/ HIRE_DATE&gt; &lt;JOB_ID&gt; SA_MAN &lt;/ JOB_ID&gt; &lt;SALARY&gt; 12000 &lt;/ SALARY&gt; &lt;COMMISSION_PCT&gt; .3 &lt;/ COMMISSION_PCT&gt; &lt;MANAGER_ID&gt; 100 &lt;/ MANAGER_ID&gt; &lt;DEPARTMENT_ID&gt; 80 &lt;/ DEPARTMENT_ID&gt; &lt;/ ROW&gt; &lt;ROW&gt; &lt;EMPLOYEE_ID&gt; 159 &lt;/ EMPLOYEE_ID&gt; &lt;FIRST_NAME&gt; Lindsey &lt;/ FIRST_NAME&gt; &lt;LAST_NAME&gt; Smith &lt;/ LAST_NAME&gt; &lt;EMAIL&gt; LSMITH &lt;/ EMAIL&gt; &lt;PHONE_NUMBER&gt; 011.44.1345.729268 &lt;/ PHONE_NUMBER &gt; &lt;HIRE_DATE&gt; <span class="bold">10-MAR-97</span> &lt;/ HIRE_DATE&gt; &lt;JOB_ID&gt; SA_REP &lt;/ JOB_ID&gt; &lt;SALARY&gt; 8000 &lt;/ SALARY&gt; &lt;COMMISSION_PCT&gt; .3 &lt;/ COMMISSION_PCT&gt; &lt;MANAGER_ID&gt; 146 &lt;/ MANAGER_ID&gt; &lt;DEPARTMENT_ID&gt; 80 &lt;/ DEPARTMENT_ID&gt; &lt;/ ROW&gt; &lt;/ ROWSET&gt; PL / SQL过程成功完成。</pre><pre class="oac_no_warn" dir="ltr">- <span class="bold">绑定两个变量</span> DECLARE ctx NUMBER; xmldoc CLOB; BEGIN ctx：= DBMS_XMLGEN.newContext（'SELECT * FROM employees WHERE employee_id = <span class="bold">：NO</span> AND hire_date = <span class="bold">：MDATE</span> '）; DBMS_XMLGEN.setBindValue（ctx，' <span class="bold">NO</span> '，' <span class="bold">145</span> '）; DBMS_XMLGEN.setBindValue（ctx，' <span class="bold">MDATE</span> '，' <span class="bold">01-OCT-04</span> '）; xmldoc：= DBMS_XMLGEN.getXML（ctx）; DBMS_OUTPUT.PUT_LINE（xmlDoc中）; DBMS_XMLGEN.closeContext（CTX）;除了DBMS_XMLGEN.closeContext（ctx）之外的其他事项;提高;结束; / &lt;？xml版本=“1.0”？&gt; &lt;ROWSET&gt; &lt;ROW&gt; &lt;EMPLOYEE_ID&gt; <span class="bold">145</span> &lt;/ EMPLOYEE_ID&gt; &lt;FIRST_NAME&gt; John &lt;/ FIRST_NAME&gt; &lt;LAST_NAME&gt; Russell &lt;/ LAST_NAME&gt; &lt;EMAIL&gt; JRUSSEL &lt;/ EMAIL&gt; &lt;PHONE_NUMBER&gt; 011.44.1344.429268 &lt;/ PHONE_NUMBER&gt; &lt; HIRE_DATE&gt; <span class="bold">01-OCT-04</span> &lt;/ HIRE_DATE&gt; &lt;JOB_ID&gt; SA_MAN &lt;/ JOB_ID&gt; &lt;SALARY&gt; 14000 &lt;/ SALARY&gt; &lt;COMMISSION_PCT&gt; .4 &lt;/ COMMISSION_PCT&gt; &lt;MANAGER_ID&gt; 100 &lt;/ MANAGER_ID&gt; &lt;DEPARTMENT_ID&gt; 80 &lt;/ DEPARTMENT_ID&gt; &lt;/ ROW&gt; &lt;/ ROWSET&gt; PL / SQL过程已成功完成。</pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="generation-of-XML-data-from-relational-data.html#GUID-1490DB76-5832-4023-8F0B-28427901C912" title="PL / SQL包DBMS_XMLGEN从SQL查询结果创建XML文档。它将XML文档检索为CLOB或XMLType值。">使用DBMS_XMLGEN生成XML数据</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div><a id="ADXDB5077"></a><a id="ADXDB5076"></a><div class="props_rev_3"><a id="GUID-C41C08F9-28F2-4E74-9BD6-A5F9F7A80E42" name="GUID-C41C08F9-28F2-4E74-9BD6-A5F9F7A80E42"></a><h3 id="ADXDB-GUID-C41C08F9-28F2-4E74-9BD6-A5F9F7A80E42" class="sect3"><span class="enumeration_section">8.4</span> SYS_XMLAGG Oracle SQL函数</h3>
               <div>
                  <p>Oracle SQL函数<code class="codeph">sys_XMLAgg</code>聚合表达式表示的所有XML文档或片段，从中生成单个XML文档。它将表达式的结果包装在名为<code class="codeph">ROWSET</code>的新元素中（默认情况下）。
                  </p>
                  <div class="section">
                     <p>Oracle函数<code class="codeph">sys_XMLAgg</code>类似于标准SQL / XML函数<code class="codeph">XMLAgg</code> ，但<code class="codeph">sys_XMLAgg</code>返回单个节点，它接受<code class="codeph">XMLFormat</code>参数。您可以使用该参数以各种方式格式化生成的XML文档。
                     </p>
                     <div class="figure" id="GUID-C41C08F9-28F2-4E74-9BD6-A5F9F7A80E42__GUID-44EF0E58-5359-4AE0-B6BF-14DAE9668D71">
                        <p class="titleinfigure">图8-13 SYS_XMLAGG语法</p><img src="img/sys_xmlagg.gif" width="269" alt="下面是图8-13的描述" title="下面是图8-13的描述" longdesc="img_text/sys_xmlagg.html"><br><a href="img_text/sys_xmlagg.html">“图8-13 SYS_XMLAGG语法”的说明</a></div>
                     <!-- class="figure" -->
                  </div>
                  <!-- class="section" -->
               </div>
               <div>
                  <div class="infoboxnotealso" id="GUID-C41C08F9-28F2-4E74-9BD6-A5F9F7A80E42__GUID-B288356C-F8AA-42FB-941B-5F450F25C773">
                     <p class="notep1">也可以看看：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>有关<code class="codeph">sys_XMLAgg</code>信息，请<code class="codeph">sys_XMLAgg</code> <a href="../sqlrf/SYS_XMLAGG.html#SQLRF51840" target="_blank"><span><cite>Oracle数据库SQL语言参考</cite></span></a></p>
                        </li>
                        <li>
                           <p>有关<code class="codeph">XMLFormat</code>参数的信息， <code class="codeph">XMLFormat</code> <a href="../sqlrf/Format-Models.html#SQLRF51092" target="_blank"><span><cite>参见Oracle数据库SQL语言参考</cite></span></a></p>
                        </li>
                     </ul>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="generation-of-XML-data-from-relational-data.html#GUID-3BEB9A88-8B44-4AA3-89F4-8CBF6F8FA686" title="Oracle XML DB提供了从数据库中的关系数据生成（构造）XML数据的功能。有SQL / XML标准函数和Oracle特定的函数和包，用于从关系内容生成XML数据。">从关系数据生成XML数据</a></p>
                     </div>
                  </div>
               </div>
               
            </div><a id="ADXDB5085"></a><a id="ADXDB5084"></a><div class="props_rev_3"><a id="GUID-B4E10016-8B10-4B6A-92B9-5ABC31BAF130" name="GUID-B4E10016-8B10-4B6A-92B9-5ABC31BAF130"></a><h3 id="ADXDB-GUID-B4E10016-8B10-4B6A-92B9-5ABC31BAF130" class="sect3"><span class="enumeration_section">8.5</span>在聚合之前订购查询结果，使用XMLAGG ORDER BY子句</h3>
               <div>
                  <p>要在聚合之前使用<code class="codeph">XMLAgg ORDER BY</code>子句，请在第一个<code class="codeph">XMLAGG</code>参数后面指定<code class="codeph">ORDER BY</code>子句。
                  </p>
                  <div class="section">
                     <p>这在<a href="generation-of-XML-data-from-relational-data.html#GUID-B4E10016-8B10-4B6A-92B9-5ABC31BAF130__CHEEJJDE">例8-30中</a>说明。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-B4E10016-8B10-4B6A-92B9-5ABC31BAF130__CHEEJJDE">
                     <p class="titleinexample">示例8-30使用XMLAGG ORDER BY子句</p><pre class="pre codeblock"><code>CREATE TABLE dev_tab（dev NUMBER，dev_total NUMBER，devname VARCHAR2（20））;表创建。INSERT INTO dev_tab VALUES（16,5，'Alexis'）;已创建1行。插入dev_tab VALUES（2,14，'Han'）;已创建1行。INSERT INTO dev_tab VALUES（1,2，'Jess'）;已创建1行。插入dev_tab VALUES（9,88，'Kurt'）;已创建1行。承诺;</code></pre><p>以下查询的结果将根据<code class="codeph">dev</code>列的顺序进行聚合。（为清楚起见，此处显示的结果非常清晰。）
                     </p><pre class="pre codeblock"><code>SELECT XMLAgg（XMLElement（“Dev”，XMLAttributes（dev AS“id”，dev_total AS“total”），devname）ORDER BY dev）FROM dev_tab dev_total; XMLAGG（XMLELEMENT（“DEV”，XMLATTRIBUTES（DEVAS“ID”，DEV_TOTALAS“TOTAL”），DEVNAME）ORDE -------------------------- -------------------------------------------------- ---- &lt;Dev id =“ <span class="bold">1</span> ”total =“2”&gt; Jess &lt;/ Dev&gt; &lt;Dev id =“ <span class="bold">2</span> ”total =“14”&gt; Han &lt;/ Dev&gt; &lt;Dev id =“ <span class="bold">9</span> ”total =“ 88“&gt; Kurt &lt;/ Dev&gt; &lt;Dev id =” <span class="bold">16</span> “total =”5“&gt; Alexis &lt;/ Dev&gt;选择了1行。</code></pre></div>
                  <!-- class="example" -->
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="generation-of-XML-data-from-relational-data.html#GUID-3BEB9A88-8B44-4AA3-89F4-8CBF6F8FA686" title="Oracle XML DB提供了从数据库中的关系数据生成（构造）XML数据的功能。有SQL / XML标准函数和Oracle特定的函数和包，用于从关系内容生成XML数据。">从关系数据生成XML数据</a></p>
                     </div>
                  </div>
               </div>
               
            </div><a id="ADXDB5087"></a><a id="ADXDB5086"></a><div class="props_rev_3"><a id="GUID-F7FCE095-C64F-4055-8EB1-DEF4BC93D384" name="GUID-F7FCE095-C64F-4055-8EB1-DEF4BC93D384"></a><h3 id="ADXDB-GUID-F7FCE095-C64F-4055-8EB1-DEF4BC93D384" class="sect3"><span class="enumeration_section">8.6</span>使用XMLTABLE返回行集</h3>
               <div>
                  <p>您可以使用标准SQL / XML函数<code class="codeph">XMLTable</code>返回行集，其中文档的相关部分被提取为多行。
                  </p>
                  <div class="section">
                     <p>这在<a href="generation-of-XML-data-from-relational-data.html#GUID-F7FCE095-C64F-4055-8EB1-DEF4BC93D384__CHDGBFFC">例8-31中显示</a> 。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-F7FCE095-C64F-4055-8EB1-DEF4BC93D384__CHDGBFFC">
                     <p class="titleinexample">示例8-31使用XMLTABLE返回行集</p><pre class="pre codeblock"><code>CONNECT oe输入密码： <span class="italic">密码</span>已连接。SELECT item.descr，item.partid FROM purchaseorder，XMLTable（'$ p / PurchaseOrder / LineItems / LineItem'PASSING OBJECT_VALUE COLUMNS descr VARCHAR2（256）PATH'Description'，partid VARCHAR2（14）PATH'Part / @ Id'）item WHERE item.partid ='715515012027'OR item.partid ='715515011921'ORDER BY partid;</code></pre><p>这将返回一个行集，其中仅包含按部件ID排序的描述和部件ID。</p><pre class="pre codeblock"><code>DESCR -------------- PARTID --------------我的男人Godfrey 715515011921 My Man Godfrey 715515011921 My Man Godfrey 715515011921 My Man Godfrey 715515011921 My Man Godfrey 715515011921我的男人戈弗雷715515011921我的男人戈弗雷715515011921蒙娜丽莎715515012027蒙娜丽莎715515012027蒙娜丽莎715515012027蒙娜丽莎715515012027蒙娜丽莎715515012027蒙娜丽莎715515012027蒙娜丽莎715515012027蒙娜丽莎715515012027蒙娜丽莎715515012027 16行选择。</code></pre></div>
                  <!-- class="example" -->
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="generation-of-XML-data-from-relational-data.html#GUID-3BEB9A88-8B44-4AA3-89F4-8CBF6F8FA686" title="Oracle XML DB提供了从数据库中的关系数据生成（构造）XML数据的功能。有SQL / XML标准函数和Oracle特定的函数和包，用于从关系内容生成XML数据。">从关系数据生成XML数据</a></p>
                     </div>
                  </div>
               </div>
               
            </div>
            <hr><br><p style="text-decoration:underline">脚注图例</p>脚注1：<p>SQL / XML标准要求存在参数<span class="italic"><code class="codeph">data-type</code></span> ，但为了易于使用，它在标准的Oracle XML DB实现中是<span class="italic">可选</span>的。
            </p><br>脚注2：<p>限制为32767或4000字节，具体取决于初始化参数<code class="codeph">MAX_STRING_SIZE</code>的值。请参见<a href="../sqlrf/Data-Types.html#SQLRF55623" target="_blank"><span><cite>Oracle Database PL / SQL包和类型参考</cite></span></a> 。
            </p><br></div>
      </article>
   </body>
</html>