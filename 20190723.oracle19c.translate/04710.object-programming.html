<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <title>对象编程</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Programmer&#39;s Guide "></meta>
      <meta property="og:description" content=""></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Programmer&#39;s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="oracle-c-call-interface-programmers-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-03-06T02:31:59-08:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="1999, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96205-02"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="accessing-oracle-database-using-cplusplus.html" title="Previous" type="text/html"></link>
      <link rel="next" href="data-types.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Oracle C++ Call Interface Programmer&#39;s Guide"></meta>
    <meta name="dcterms.isVersionOf" content="LNCPP"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="accessing-oracle-database-using-cplusplus.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="data-types.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">程序员指南</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">对象编程</li>
            </ol>
            <a id="GUID-DC6B80E7-BFBD-41FD-9241-2AAD96A7B997" name="GUID-DC6B80E7-BFBD-41FD-9241-2AAD96A7B997"></a><a id="LNCPP004"></a>
            
            <h2 id="LNCPP-GUID-DC6B80E7-BFBD-41FD-9241-2AAD96A7B997" class="sect2"><span class="enumeration_chapter">4</span>对象编程</h2>
         </header>
         <div class="ind">
            <div>
               <p>本章提供有关如何使用Oracle C ++调用接口（OCCI）实现对象关系编程的信息。</p>
               <p>本章包含以下主题：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="object-programming.html#GUID-02DE3189-4708-4F1B-87F4-8E90BE42043A">对象编程概述</a></p>
                  </li>
                  <li>
                     <p><a href="object-programming.html#GUID-74BB17CB-2C5A-4BD4-BE04-284EFCF60CD0">关于使用OCCI使用C ++中的对象</a></p>
                  </li>
                  <li>
                     <p><a href="object-programming.html#GUID-2BB39E6B-E03F-4293-A7C4-24CFEB0B63C9">关于在C ++应用程序中表示对象</a></p>
                  </li>
                  <li>
                     <p><a href="object-programming.html#GUID-9E9D5AB5-3311-4B94-AFE1-2F67BA6E4CFF">关于使用OCCI开发C ++应用程序</a></p>
                  </li>
                  <li>
                     <p><a href="object-programming.html#GUID-AF75D8AD-391B-4E7F-983A-EAEE9B9383E3">使用OCCI将C ++应用程序迁移到Oracle</a></p>
                  </li>
                  <li>
                     <p><a href="object-programming.html#GUID-2E5F6826-403F-4925-8775-47D6849F555F">关联访问概述</a></p>
                  </li>
                  <li>
                     <p><a href="object-programming.html#GUID-08991D90-AD38-4436-9B94-EA5AE02B5869">导航访问概述</a></p>
                  </li>
                  <li>
                     <p><a href="object-programming.html#GUID-DDA38EF4-E971-4ECF-B565-4BB43CE8B8BC">复杂对象检索概述</a></p>
                  </li>
                  <li>
                     <p><a href="object-programming.html#GUID-09287489-EE28-42C3-A6D7-1EA9B616DAAC">使用集合</a></p>
                  </li>
                  <li>
                     <p><a href="object-programming.html#GUID-E3D9E110-7335-4E84-9452-7FE689550FB7">关于使用对象引用</a></p>
                  </li>
                  <li>
                     <p><a href="object-programming.html#GUID-C7C82B8B-2056-4692-9BA0-C123902C6268">关于从数据库中删除对象</a></p>
                  </li>
                  <li>
                     <p><a href="object-programming.html#GUID-43D835F1-F7E4-4EA5-8F32-F50393162132">关于类型继承</a></p>
                  </li>
                  <li>
                     <p><a href="object-programming.html#GUID-6E6AA436-1CBB-4571-A738-AEF47FF29598">OCCI申请样本</a></p>
                  </li>
               </ul>
            </div><a id="LNCPP20143"></a><div class="props_rev_3"><a id="GUID-02DE3189-4708-4F1B-87F4-8E90BE42043A" name="GUID-02DE3189-4708-4F1B-87F4-8E90BE42043A"></a><h3 id="LNCPP-GUID-02DE3189-4708-4F1B-87F4-8E90BE42043A" class="sect3"><span class="enumeration_section">4.1</span>对象编程概述</h3>
               <div>
                  <p>OCCI支持数据访问的关联和导航风格。传统上，第三代语言（3GL）程序通过使用基于关系数据库表组织的关联的<span class="bold">关联访问</span>来操纵存储在数据库中的数据。在关联访问中，通过执行SQL语句和PL / SQL过程来操纵数据。OCCI支持对对象的关联访问，使您的应用程序能够在数据库服务器上执行SQL语句和PL / SQL过程，而不会产生将数据传输到客户端的成本。
                  </p>
                  <p>使用OCCI的面向对象程序也可以使用<span class="bold">导航访问</span> ，这是该编程范例的一个关键方面。对象之间的对象关系实现为引用（ <code class="codeph">REF</code> ）。通常，使用导航访问的对象应用程序首先通过发出将<code class="codeph">REF</code>返回到这些对象的SQL语句从数据库服务器检索一个或多个对象。然后，应用程序使用这些<code class="codeph">REF</code>遍历相关对象，并根据需要对这些其他对象执行计算。除了获取初始对象集的引用之外，导航访问不涉及执行SQL语句。通过使用OCCI API进行导航访问，您的应用程序可以在Oracle对象上执行以下功能：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>创建，访问，锁定，删除，复制和刷新对象</p>
                     </li>
                     <li>
                        <p>获取对象的引用并浏览引用</p>
                     </li>
                  </ul>
                  <p>本章提供的示例向您展示如何创建持久对象，访问对象，修改对象以及如何刷新对数据库服务器的更改。它讨论了如何使用导航和关联方法访问对象。</p>
               </div>
            </div><a id="LNCPP20144"></a><div class="props_rev_3"><a id="GUID-74BB17CB-2C5A-4BD4-BE04-284EFCF60CD0" name="GUID-74BB17CB-2C5A-4BD4-BE04-284EFCF60CD0"></a><h3 id="LNCPP-GUID-74BB17CB-2C5A-4BD4-BE04-284EFCF60CD0" class="sect3"><span class="enumeration_section">4.2</span>关于使用OCCI在C ++中使用对象</h3>
               <div>
                  <p>管理关系OCCI应用程序的许多编程原则对于对象关系应用程序是相同的。对象关系应用程序使用标准OCCI调用来建立数据库连接并处理SQL语句。不同之处在于发出的SQL语句检索对象引用，然后可以使用OCCI对象函数对其进行操作。对象也可以直接作为值进行操作（不使用其对象引用）。</p>
                  <p>Oracle类型的实例根据其生命周期分为<span class="bold">持久对象</span>和<span class="bold">瞬态对象</span> 。持久对象的实例可以进一步划分为<span class="bold">独立对象</span>和<span class="bold">嵌入对象，</span>这取决于它们是否通过对象标识符引用。
                  </p>
                  <p>本节讨论以下主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="object-programming.html#GUID-20FC9BD5-04FA-4E05-935E-3A87DF777C4D">关于持久对象</a></p>
                     </li>
                     <li>
                        <p><a href="object-programming.html#GUID-6D47B29B-B21A-4709-B3F3-F791ECB312E5">关于瞬态对象</a></p>
                     </li>
                     <li>
                        <p><a href="object-programming.html#GUID-16789D51-136F-45D7-AABE-A59B0765C78B">关于价值观</a></p>
                     </li>
                  </ul>
               </div><a id="LNCPP20146"></a><a id="LNCPP20147"></a><a id="LNCPP20145"></a><div class="props_rev_3"><a id="GUID-20FC9BD5-04FA-4E05-935E-3A87DF777C4D" name="GUID-20FC9BD5-04FA-4E05-935E-3A87DF777C4D"></a><h4 id="LNCPP-GUID-20FC9BD5-04FA-4E05-935E-3A87DF777C4D" class="sect4"><span class="enumeration_section">4.2.1</span>关于持久对象</h4>
                  <div>
                     <p><span class="bold">持久对象</span>是存储在Oracle数据库中的对象。它可以被提取到对象缓存中并由OCCI应用程序修改。持久对象的生命周期可能超过访问它的应用程序的生命周期。有两种类型的持久对象：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><span class="bold">独立实例</span>存储在数据库表行中，并具有唯一的对象标识符。OCCI应用程序可以检索对独立对象的引用，固定对象，并从固定对象导航到其他相关对象。独立对象也可以称为可<span class="bold">引用对象</span> 。
                           </p>
                           <p>也可以选择一个持久对象，在这种情况下，您可以<span class="italic">按值</span>获取对象<span class="italic">，</span>而不是通过引用获取它。
                           </p>
                        </li>
                        <li>
                           <p><span class="bold">嵌入式实例</span>不存储在数据库表行中，而是嵌入在另一个对象中。嵌入对象的示例是作为另一个对象的属性的对象，或者存在于数据库表的对象列中的对象。嵌入式对象没有对象标识符，OCCI应用程序无法将<code class="codeph">REF</code>为嵌入式实例。
                           </p>
                           <p>嵌入对象也可以称为不可引用<span class="bold">对象</span>或<span class="bold">值实例</span> 。您有时可能会将它们称为<span class="bold">值</span> ，这些值不会与标量数据值混淆。上下文应该明确含义。
                           </p>
                        </li>
                     </ul>
                     <p>用户不必显式删除通过引用实现的持久对象。</p>
                     <p>用户应该在回滚事务时删除应用程序创建的持久对象</p>
                     <p>SQL示例（ <a href="object-programming.html#GUID-20FC9BD5-04FA-4E05-935E-3A87DF777C4D__BEICJAAH">示例4-1</a>和<a href="object-programming.html#GUID-20FC9BD5-04FA-4E05-935E-3A87DF777C4D__BEIIABGC">示例4-2</a> ）演示了这两种类型的持久对象之间的区别。
                     </p>
                     <div class="example" id="GUID-20FC9BD5-04FA-4E05-935E-3A87DF777C4D__BEICJAAH">
                        <p class="titleinexample">示例4-1创建独立对象</p>
                        <p>存储在对象表<code class="codeph">person_tab</code>中的对象是独立对象。它们具有对象标识符，可以引用。它们可以固定在OCCI应用程序中。
                        </p><pre class="oac_no_warn" dir="ltr">CREATE TYPE person_t AS OBJECT（名称varchar2（30），年龄数（3））; CREATE TABLE person_tab OF person_t;</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-20FC9BD5-04FA-4E05-935E-3A87DF777C4D__BEIIABGC">
                        <p class="titleinexample">示例4-2创建嵌入对象</p>
                        <p>存储在<code class="codeph">department</code>表的<code class="codeph">manager</code>列中的对象是嵌入对象。它们没有对象标识符，也无法引用它们。因此，它们不能固定在OCCI应用程序中，也永远不必取消固定。它们始终<span class="italic">按值</span>检索到对象缓存中。
                        </p><pre class="oac_no_warn" dir="ltr">CREATE TABLE部门（deptno number，deptname varchar2（30），manager person_t）;</pre><p>数组引脚功能允许在一次往返中取消引用引用向量以返回相应对象的向量。一个新的全局方法<code class="codeph">pinVectorOfRefs()</code>采用<code class="codeph">Ref</code>的向量并在一次往返中填充<code class="codeph">PObject</code>的向量，从而节省了在<code class="codeph">n-1</code>次往返中固定<code class="codeph">n-1</code>引用的成本。
                        </p>
                     </div>
                     <!-- class="example" -->
                  </div>
               </div><a id="LNCPP20149"></a><a id="LNCPP20150"></a><a id="LNCPP20151"></a><a id="LNCPP20148"></a><div class="props_rev_3"><a id="GUID-6D47B29B-B21A-4709-B3F3-F791ECB312E5" name="GUID-6D47B29B-B21A-4709-B3F3-F791ECB312E5"></a><h4 id="LNCPP-GUID-6D47B29B-B21A-4709-B3F3-F791ECB312E5" class="sect4"><span class="enumeration_section">4.2.2</span>关于瞬态对象</h4>
                  <div>
                     <p>瞬态对象是对象类型的实例。它的寿命不能超过应用程序的寿命。应用程序还可以随时删除瞬态对象。</p>
                     <p>对象类型转换器（OTT）实用程序为每个C ++类生成两个<code class="codeph">operator new</code>方法，如<a href="object-programming.html#GUID-6D47B29B-B21A-4709-B3F3-F791ECB312E5__BEIDGFBH">例4-3</a> <a href="object-programming.html#GUID-6D47B29B-B21A-4709-B3F3-F791ECB312E5__BEIDGFBH">示例4-3所示</a> ：</p>
                     <p><a href="object-programming.html#GUID-6D47B29B-B21A-4709-B3F3-F791ECB312E5__BEICGCBD">示例4-4</a>演示了如何动态创建瞬态对象。瞬态对象无法转换为持久对象。他们的角色在实例化时被修复，你有责任通过删除瞬态对象来释放内存。
                     </p>
                     <p>也可以在堆栈上创建一个瞬态对象作为局部变量，如<a href="object-programming.html#GUID-6D47B29B-B21A-4709-B3F3-F791ECB312E5__BEIGDIHD">例4-5所示</a> 。后一种方法保证当变量的范围结束时瞬态对象被破坏。
                     </p>
                     <div class="infoboxnotealso" id="GUID-6D47B29B-B21A-4709-B3F3-F791ECB312E5__GUID-C495804E-9A59-441E-A144-B6E0E7C51204">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="../cncpt/tables-and-table-clusters.html#CNCPT88817" target="_blank"><span><cite>Oracle Database Concepts</cite></span></a>有关对象的更多信息</p>
                           </li>
                        </ul>
                     </div>
                     <div class="example" id="GUID-6D47B29B-B21A-4709-B3F3-F791ECB312E5__BEIDGFBH">
                        <p class="titleinexample">示例4-3对象类型转换器实用程序中的operator new（）的两种方法</p><pre class="oac_no_warn" dir="ltr">class Person：public PObject {...public：dvoid * operator new（size_t size）; //创建瞬态实例dvoid * operator new（size_t size，Connection＆conn，string table）; //创建持久化实例}</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-6D47B29B-B21A-4709-B3F3-F791ECB312E5__BEICGCBD">
                        <p class="titleinexample">示例4-4如何动态创建瞬态对象</p><pre class="oac_no_warn" dir="ltr">人* p =新人（）;</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-6D47B29B-B21A-4709-B3F3-F791ECB312E5__BEIGDIHD">
                        <p class="titleinexample">示例4-5如何将瞬态对象创建为局部变量</p><pre class="oac_no_warn" dir="ltr">人p;</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="LNCPP20152"></a><div class="props_rev_3"><a id="GUID-16789D51-136F-45D7-AABE-A59B0765C78B" name="GUID-16789D51-136F-45D7-AABE-A59B0765C78B"></a><h4 id="LNCPP-GUID-16789D51-136F-45D7-AABE-A59B0765C78B" class="sect4"><span class="enumeration_section">4.2.3</span>关于值</h4>
                  <div>
                     <p>在本手册中， <span class="bold">值</span>指的是：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>标量值，存储在数据库表的非对象列中。OCCI应用程序可以通过发出SQL语句从数据库中获取值。</p>
                        </li>
                        <li>
                           <p>嵌入的（不可引用的）对象。</p>
                        </li>
                     </ul>
                     <p>上下文应该清楚表明意图是什么意思。</p>
                     <p>可以将可引用对象<code class="codeph">SELECT</code>到对象缓存中，而不是固定它，在这种情况下，您可以<span class="italic">按值</span>获取对象<span class="italic">，</span>而不是通过引用获取它。
                     </p>
                  </div>
               </div>
            </div><a id="LNCPP20153"></a><div class="props_rev_3"><a id="GUID-2BB39E6B-E03F-4293-A7C4-24CFEB0B63C9" name="GUID-2BB39E6B-E03F-4293-A7C4-24CFEB0B63C9"></a><h3 id="LNCPP-GUID-2BB39E6B-E03F-4293-A7C4-24CFEB0B63C9" class="sect3"><span class="enumeration_section">4.3</span>关于在C ++应用程序中表示对象</h3>
               <div>
                  <p>在OCCI应用程序可以使用对象类型之前，这些类型必须存在于数据库中。通常，您使用SQL DDL语句创建类型，例如<code class="codeph">CREATE</code> <code class="codeph">TYPE</code> 。</p>
                  <p>本节讨论以下主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="object-programming.html#GUID-FC898442-8C5E-4CBC-9D57-4F93386C29B6">创建持久和瞬态对象</a></p>
                     </li>
                     <li>
                        <p><a href="object-programming.html#GUID-429F4D92-51D7-47F0-B637-D9F103CFE718">使用OTT实用程序创建对象表示</a></p>
                     </li>
                  </ul>
               </div><a id="LNCPP20155"></a><a id="LNCPP20156"></a><a id="LNCPP20154"></a><div class="props_rev_3"><a id="GUID-FC898442-8C5E-4CBC-9D57-4F93386C29B6" name="GUID-FC898442-8C5E-4CBC-9D57-4F93386C29B6"></a><h4 id="LNCPP-GUID-FC898442-8C5E-4CBC-9D57-4F93386C29B6" class="sect4"><span class="enumeration_section">4.3.1</span>创建持久和瞬态对象</h4>
                  <div>
                     <div class="section">
                        <p>本节讨论如何创建持久对象和临时对象。</p>
                        <p>在创建持久对象之前，必须已创建环境并打开连接。</p>
                        <p>仅当发生以下任一情况时，才在数据库中创建持久对象：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">Connection::commit()</code>事务（ <code class="codeph">Connection::commit()</code> ）</p>
                           </li>
                           <li>
                              <p>刷新对象缓存（ <code class="codeph">Connection::flushCache()</code> ）</p>
                           </li>
                           <li>
                              <p>对象本身被刷新（ <code class="codeph">PObject::flush()</code> ）</p>
                           </li>
                        </ul>
                        <p><a href="object-programming.html#GUID-FC898442-8C5E-4CBC-9D57-4F93386C29B6__BEIJIHDH">例4-6</a>显示了如何在数据库表<code class="codeph">addr_tab</code>创建持久对象<code class="codeph">addr</code> 。
                        </p>
                        <p><a href="object-programming.html#GUID-FC898442-8C5E-4CBC-9D57-4F93386C29B6__BEIFGGJJ">例4-7</a>显示了创建瞬态对象<code class="codeph">ADDRESS</code>的实例的热点。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-FC898442-8C5E-4CBC-9D57-4F93386C29B6__BEIJIHDH">
                        <p class="titleinexample">示例4-6如何创建持久对象</p><pre class="oac_no_warn" dir="ltr">CREATE TYPE ADDRESS AS OBJECT（状态CHAR（2），zip_code CHAR（5））; ADDRESS的CREATE TABLE ADDR_TAB; ADDRESS * addr = new（conn，“ADDR_TAB”）ADDRESS（“CA”，“94065”）;</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-FC898442-8C5E-4CBC-9D57-4F93386C29B6__BEIFGGJJ">
                        <p class="titleinexample">示例4-7如何创建瞬态对象</p><pre class="oac_no_warn" dir="ltr">ADDRESS * addr_trans = new ADDRESS（“MD”，“94111”）;</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="LNCPP21904"></a><a id="LNCPP20157"></a><div class="props_rev_3"><a id="GUID-429F4D92-51D7-47F0-B637-D9F103CFE718" name="GUID-429F4D92-51D7-47F0-B637-D9F103CFE718"></a><h4 id="LNCPP-GUID-429F4D92-51D7-47F0-B637-D9F103CFE718" class="sect4"><span class="enumeration_section">4.3.2</span>使用OTT实用程序创建对象表示</h4>
                  <div>
                     <div class="section">
                        <p>当C ++应用程序从数据库中检索对象类型的实例时，它必须具有对象的客户端表示。对象类型转换器（OTT）实用程序为您生成数据库对象类型的C ++类表示。<a href="object-programming.html#GUID-429F4D92-51D7-47F0-B637-D9F103CFE718__BEIGDFED">例4-8</a>显示了数据库中自定义类型的声明，以及OTT实用程序生成的相应C ++类。
                        </p>
                        <p><a href="object-programming.html#GUID-429F4D92-51D7-47F0-B637-D9F103CFE718__BEIGDFED">例4-8</a>中的这些类声明由OTT自动写入您命名的头文件。此头文件包含在应用程序的源文件中，以提供对对象的访问。<code class="codeph">PObject</code>实例（以及从<code class="codeph">PObject</code>派生的类的实例）可以是瞬态的也可以是持久的。方法<code class="codeph">writeSQL()</code>和<code class="codeph">readSQL()</code>由OCCI对象高速缓存在内部使用，以线性化和去线化对象，OCCI客户端不使用或修改它们。
                        </p>
                        <div class="infoboxnotealso" id="GUID-429F4D92-51D7-47F0-B637-D9F103CFE718__GUID-7B44A730-E0A0-4366-B310-680B42BBF38B">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="object-type-translator-utility.html#GUID-72088FFE-4A01-4296-B207-10F2D3550318">对象类型转换实用程序</a> ，以获取有关OTT实用<a href="object-type-translator-utility.html#GUID-72088FFE-4A01-4296-B207-10F2D3550318">程序</a>的更多信息</p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-429F4D92-51D7-47F0-B637-D9F103CFE718__BEIGDFED">
                        <p class="titleinexample">示例4-8如何在数据库中声明自定义类型</p><pre class="oac_no_warn" dir="ltr">CREATE TYPE地址AS OBJECT（状态CHAR（2），zip_code CHAR（5））;</pre><p>OTT实用程序生成以下C ++类：</p><pre class="oac_no_warn" dir="ltr">class ADDRESS：public PObject {protected：string state;拉链; public：void * operator new（size_t size）; void * operator new（size_t size，const Connection * conn，const string＆table）; string getSQLTypeName（）const; void getSQLTypeName（oracle :: occi :: Environment * env，void ** schemaName，unsigned int＆schemaNameLen，void ** typeName，unsigned int＆typeNameLen）const; ADDRESS（void * ctx）：PObject（ctx）{}; static void * readSQL（void * ctx）; virtual void readSQL（AnyData＆stream）; static void writeSQL（void * obj，void * ctx）; virtual void writeSQL（AnyData＆stream）; }</pre></div>
                     <!-- class="example" -->
                  </div>
               </div>
            </div><a id="LNCPP20158"></a><div class="props_rev_3"><a id="GUID-9E9D5AB5-3311-4B94-AFE1-2F67BA6E4CFF" name="GUID-9E9D5AB5-3311-4B94-AFE1-2F67BA6E4CFF"></a><h3 id="LNCPP-GUID-9E9D5AB5-3311-4B94-AFE1-2F67BA6E4CFF" class="sect3"><span class="enumeration_section">4.4</span>关于使用OCCI开发C ++应用程序</h3>
               <div>
                  <p>本节讨论开发基本OCCI对象应用程序所涉及的步骤。</p>
                  <p>本节讨论以下主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="object-programming.html#GUID-5DF13983-6CDD-401A-8175-6E735288DEC6">开发基础对象程序结构</a></p>
                     </li>
                     <li>
                        <p><a href="object-programming.html#GUID-70A77A98-A3C7-42D7-90B0-8AE9DF0FEFBE">关于基本对象操作流程</a></p>
                     </li>
                  </ul>
               </div><a id="LNCPP20159"></a><div class="props_rev_3"><a id="GUID-5DF13983-6CDD-401A-8175-6E735288DEC6" name="GUID-5DF13983-6CDD-401A-8175-6E735288DEC6"></a><h4 id="LNCPP-GUID-5DF13983-6CDD-401A-8175-6E735288DEC6" class="sect4"><span class="enumeration_section">4.4.1</span>开发基本对象程序结构</h4>
                  <div>
                     <div class="section">
                        <p>使用对象的OCCI应用程序的基本结构类似于关系OCCI应用程序，不同之处在于对象功能。OCCI对象程序涉及的步骤包括：</p>
                        <ol>
                           <li>
                              <p>初始化<code class="codeph">Environment</code> 。在对象模式下初始化OCCI编程环境。您的应用程序必须在头文件中包含数据库对象的C ++类表示。您可以使用对象类型转换器（OTT）实用程序创建这些类，如<a href="object-type-translator-utility.html#GUID-72088FFE-4A01-4296-B207-10F2D3550318">对象类型转换器实用程序中所述</a> 。
                              </p>
                           </li>
                           <li>
                              <p>建立连接。使用环境句柄建立与数据库服务器的连接。</p>
                           </li>
                           <li>
                              <p>准备SQL语句。这是本地（客户端）步骤，可能包括绑定占位符。在对象关系应用程序中，此SQL语句应该向对象返回引用（ <code class="codeph">REF</code> ）。
                              </p>
                           </li>
                           <li>
                              <p>访问该对象。</p>
                              <ol type="a">
                                 <li>
                                    <p>将准备好的语句与数据库服务器关联，然后执行该语句。</p>
                                 </li>
                                 <li>
                                    <p>通过使用导航访问，从数据库服务器检索对象引用（ <code class="codeph">REF</code> ）并固定对象。然后，您可以执行以下部分或全部操作：</p>
                                    <ul style="list-style-type:disc">
                                       <li>
                                          <p>操纵对象的属性并将其标记为<span class="bold">脏</span> （已修改）</p>
                                       </li>
                                       <li>
                                          <p>遵循对另一个对象或一系列对象的引用</p>
                                       </li>
                                       <li>
                                          <p>访问类型和属性信息</p>
                                       </li>
                                       <li>
                                          <p>导航复杂的对象检索图</p>
                                       </li>
                                       <li>
                                          <p>将修改后的对象刷新到数据库服务器</p>
                                       </li>
                                    </ul>
                                 </li>
                                 <li>
                                    <p>通过使用关联访问，您可以使用SQL <span class="italic">按值</span>获取整个对象。或者，您可以选择嵌入（不可引用）对象。然后，您可以执行以下部分或全部操作：</p>
                                    <ul style="list-style-type:disc">
                                       <li>
                                          <p>将值插入表中</p>
                                       </li>
                                       <li>
                                          <p>修改现有值</p>
                                       </li>
                                    </ul>
                                 </li>
                              </ol>
                           </li>
                           <li>
                              <p>提交交易。此步骤将所有已修改的对象隐式写入数据库服务器并提交更改。</p>
                           </li>
                           <li>
                              <p>免费声明和句柄;不应再使用或执行准备好的语句。</p>
                              <div class="infoboxnotealso" id="GUID-5DF13983-6CDD-401A-8175-6E735288DEC6__GUID-D4A12C80-CC9E-4CE9-8AE8-827F78948C5C">
                                 <p class="notep1">也可以看看：</p>
                                 <ul style="list-style-type:disc">
                                    <li>
                                       <p><a href="accessing-oracle-database-using-cplusplus.html#GUID-3BE057FD-2205-4009-9710-FFDC601F438B">访问Oracle数据库使用C ++</a>获取有关使用OCCI连接到数据库服务器，处理SQL语句和分配句柄的信息</p>
                                    </li>
                                    <li>
                                       <p><a href="object-type-translator-utility.html#GUID-72088FFE-4A01-4296-B207-10F2D3550318">对象类型转换器实用程序，</a>用于有关OTT实用<a href="object-type-translator-utility.html#GUID-72088FFE-4A01-4296-B207-10F2D3550318">程序</a>的信息</p>
                                    </li>
                                    <li>
                                       <p><a href="occi-application-programing-interface.html#GUID-3C824380-073E-4F32-AA6E-928A18D52F4B">OCCI应用程序编程接口，</a>用于描述OCCI关系函数和<code class="codeph">Connect</code>类以及<code class="codeph">getMetaData()</code>方法</p>
                                    </li>
                                 </ul>
                              </div>
                           </li>
                        </ol>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNCPP20161"></a><a id="LNCPP20160"></a><div class="props_rev_3"><a id="GUID-70A77A98-A3C7-42D7-90B0-8AE9DF0FEFBE" name="GUID-70A77A98-A3C7-42D7-90B0-8AE9DF0FEFBE"></a><h4 id="LNCPP-GUID-70A77A98-A3C7-42D7-90B0-8AE9DF0FEFBE" class="sect4"><span class="enumeration_section">4.4.2</span>关于基本对象操作流程</h4>
                  <div>
                     <p>图4-1显示了应用程序如何使用对象的简单程序逻辑流程。为简单起见，省略了一些必需的步骤。</p>
                     <div class="figure" id="GUID-70A77A98-A3C7-42D7-90B0-8AE9DF0FEFBE__GUID-6152359D-EBA9-46FF-B347-2DF11EEB4971">
                        <p class="titleinfigure">图4-1基本对象操作流程</p><img src="img/object_operational_flow.gif" alt="下面是图4-1的描述" title="下面是图4-1的描述" longdesc="img_text/object_operational_flow.html"><br><a href="img_text/object_operational_flow.html">“图4-1基本对象操作流程”的描述</a></div>
                     <!-- class="figure" -->
                     <div class="p">以下各节将讨论图4-1中所示的步骤：<ul style="list-style-type:disc">
                           <li>
                              <p><a href="object-programming.html#GUID-3FB1A9D9-581F-4D71-8AEE-DC913D0BE2C0">关于在对象模式下初始化OCCI</a></p>
                           </li>
                           <li>
                              <p><a href="object-programming.html#GUID-BC5DE1FE-60CE-43E0-8037-8882C676CAE2">关于固定对象</a></p>
                           </li>
                           <li>
                              <p><a href="object-programming.html#GUID-176A06E7-50D7-4507-B797-5380CF9CF9C7">关于在缓存中的对象上操作</a></p>
                           </li>
                           <li>
                              <p><a href="object-programming.html#GUID-FFB20D3D-A2B1-43F3-B510-AFF9358BED65">关于刷新对象的更改</a></p>
                           </li>
                           <li>
                              <p><a href="object-programming.html#GUID-DC6E2210-E1A2-4F56-8C59-6967FC441677">关于删除对象</a></p>
                           </li>
                        </ul>
                     </div>
                  </div><a id="LNCPP20162"></a><div class="props_rev_3"><a id="GUID-3FB1A9D9-581F-4D71-8AEE-DC913D0BE2C0" name="GUID-3FB1A9D9-581F-4D71-8AEE-DC913D0BE2C0"></a><h5 id="LNCPP-GUID-3FB1A9D9-581F-4D71-8AEE-DC913D0BE2C0" class="sect5"><span class="enumeration_section">4.4.2.1</span>关于在对象模式下初始化OCCI</h5>
                     <div>
                        <p>如果您的OCCI应用程序访问和操作对象，则必须为<code class="codeph">createEnvironment()</code>方法的<code class="codeph">mode</code>参数指定<code class="codeph">OBJECT</code>值，这是任何OCCI应用程序中的第一个调用。为<code class="codeph">mode</code>指定此值表示OCCI您的应用程序使用对象。此通知具有以下重要影响：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>建立了对象运行时环境。</p>
                           </li>
                           <li>
                              <p>设置了对象缓存。</p>
                           </li>
                        </ul>
                        <p>请注意， <code class="codeph">mode</code>参数未设置为<code class="codeph">OBJECT</code> ，任何使用对象相关函数的尝试都会导致错误。
                        </p>
                        <p>以下代码示例演示如何在创建OCCI环境时指定<code class="codeph">OBJECT</code> <code class="codeph">mode</code> ：</p><pre class="oac_no_warn" dir="ltr">环境*环境;连接* con;声明* stmt; env = Environment :: createEnvironment（Environment :: OBJECT）; con = Connection（userName，password，connectString）;</pre><p>当数据库对象加载到对象缓存中时，您的应用程序不必分配内存。对象缓存为数据库对象提供透明且高效的内存管理。将数据库对象加载到对象缓存中时，它们会透明地映射到宿主语言（C ++）表示中。</p>
                        <p>对象缓存<a id="d18836e1526" class="indexterm-anchor"></a>维护对象缓存中的对象副本与相应的数据库对象之间的关联。<code class="codeph">commit</code> ，对对象缓存中对象副本所做的更改将自动传播回数据库。
                        </p>
                        <p>对象缓存维护一个查找表，用于映射对象的引用。当应用程序取消引用对象的引用并且相应的对象尚未缓存在对象缓存中时，对象缓存会自动向数据库服务器发送请求以从数据库中获取对象并将其加载到对象缓存中。相同引用的后续解引用更快，因为它们是对象缓存本身并且不会导致数据库服务器的往返。</p>
                        <p>随后从缓存中取消引用相同的引用，而不是要求往返。例外情况是在提交之后发生的解除引用操作。在这种情况下，将返回服务器的最新对象副本。这可确保在每次事务后缓存数据库中的最新对象。</p>
                        <p>对象缓存维护对象缓存中每个持久对象的引脚数。当应用程序取消引用对象的引用时，对象的引脚数会递增。随后取消引用对象的相同引用不会更改引脚数。在对对象的引用超出范围之前，对象继续固定在对象缓存中并且可由OCCI客户端访问。</p>
                        <p>引脚数用作对象的引用计数。仅当没有更多引用引用此对象时，对象的引脚数才变为零（ <code class="codeph">0</code> ），在此期间对象符合垃圾回收的条件。对象缓存使用最近最少使用的算法来管理对象缓存的大小。当对象缓存达到最大大小时，此算法释放引脚数为0的对象。
                        </p>
                     </div>
                  </div><a id="LNCPP20163"></a><div class="props_rev_3"><a id="GUID-BC5DE1FE-60CE-43E0-8037-8882C676CAE2" name="GUID-BC5DE1FE-60CE-43E0-8037-8882C676CAE2"></a><h5 id="LNCPP-GUID-BC5DE1FE-60CE-43E0-8037-8882C676CAE2" class="sect5"><span class="enumeration_section">4.4.2.2</span>关于固定对象</h5>
                     <div>
                        <p>在大多数情况下，OCCI用户不必明确地固定或取消固定对象，因为对象缓存会自动跟踪缓存中所有对象的引脚数。如前所述，当引用指向对象时，对象高速缓存会增加引脚数，当引用超出范围或不再指向对象时，对象高速缓存会减小引脚数。</p>
                        <p>但有一个例外。如果OCCI应用程序使用<code class="codeph">Ref&lt;T&gt;::ptr()</code>方法获取指向对象的指针，那么应用程序可以使用<code class="codeph">PObject</code>类的<code class="codeph">pin</code>和<code class="codeph">unpin</code>方法来控制对象中对象的<code class="codeph">unpin</code>和<code class="codeph">unpin</code>缓存。
                        </p>
                     </div>
                  </div><a id="LNCPP20164"></a><div class="props_rev_3"><a id="GUID-176A06E7-50D7-4507-B797-5380CF9CF9C7" name="GUID-176A06E7-50D7-4507-B797-5380CF9CF9C7"></a><h5 id="LNCPP-GUID-176A06E7-50D7-4507-B797-5380CF9CF9C7" class="sect5"><span class="enumeration_section">4.4.2.3</span>关于对缓存中对象的操作</h5>
                     <div>
                        <p>请注意，对象缓存不管理对象副本的内容;它不会自动刷新对象副本。您的应用程序必须确保对象副本的有效性和一致性。</p>
                     </div>
                  </div><a id="LNCPP20165"></a><div class="props_rev_3"><a id="GUID-FFB20D3D-A2B1-43F3-B510-AFF9358BED65" name="GUID-FFB20D3D-A2B1-43F3-B510-AFF9358BED65"></a><h5 id="LNCPP-GUID-FFB20D3D-A2B1-43F3-B510-AFF9358BED65" class="sect5"><span class="enumeration_section">4.4.2.4</span>关于<span class="enumeration_section">刷新</span>对象的更改</h5>
                     <div>
                        <p>每当对象缓存中的对象副本进行更改时，应用程序都负责将更改的对象刷新到数据库。</p>
                        <p>当对象加载到对象缓存中时，按需分配对象缓存的内存。</p>
                        <p>客户端对象缓存在程序的进程空间中分配。此对象缓存是已从数据库服务器检索并可供应用程序使用的对象的内存。</p>
                        <p>如果在对象模式下初始化OCCI环境，则应用程序会为对象缓存分配内存，无论应用程序是否实际使用对象调用。</p>
                        <p>每个OCCI环境只分配了一个对象缓存。通过环境中的不同连接检索或创建的所有对象使用相同的物理对象缓存。每个连接都有自己的逻辑对象缓存。</p>
                     </div>
                  </div><a id="LNCPP20166"></a><div class="props_rev_3"><a id="GUID-DC6E2210-E1A2-4F56-8C59-6967FC441677" name="GUID-DC6E2210-E1A2-4F56-8C59-6967FC441677"></a><h5 id="LNCPP-GUID-DC6E2210-E1A2-4F56-8C59-6967FC441677" class="sect5"><span class="enumeration_section">4.4.2.5</span>关于删除对象</h5>
                     <div>
                        <p>对于通过取消引用引用而检索到缓存中的对象，不应执行显式删除。对于此类对象，引脚计数在第一次取消引用时递增，而在引用超出范围时递减。当对象的引脚数变为<code class="codeph">0</code> ，表示对该对象的所有引用都超出范围，该对象自动符合垃圾回收的条件，随后从缓存中删除。
                        </p>
                        <p>对于通过调用<code class="codeph">new</code>运算符创建的持久对象，如果不提交事务，则必须调用<code class="codeph">delete</code> 。否则，在提交后对象被垃圾收集。这是因为当使用<code class="codeph">new</code>创建这样的对象时，其引脚数最初为<code class="codeph">0</code> 。但是，因为对象是脏的，它仍然在缓存中。提交后，它不再是脏的，因此垃圾收集。因此，不需要删除。
                        </p>
                        <p>如果未执行提交，则必须显式调用<code class="codeph">delete</code>以销毁该对象。如果没有对该对象的引用，则可以执行此操作。对于临时对象，必须明确删除以销毁对象。
                        </p>
                        <p>您不应该在持久对象上调用delete运算符。当引脚数为0时，垃圾收集器将释放未标记/脏的持久对象。但是，对于临时对象，必须明确删除以销毁对象。</p>
                     </div>
                  </div>
               </div>
            </div><a id="LNCPP20167"></a><div class="props_rev_3"><a id="GUID-AF75D8AD-391B-4E7F-983A-EAEE9B9383E3" name="GUID-AF75D8AD-391B-4E7F-983A-EAEE9B9383E3"></a><h3 id="LNCPP-GUID-AF75D8AD-391B-4E7F-983A-EAEE9B9383E3" class="sect3"><span class="enumeration_section">4.5</span>使用OCCI将C ++应用程序迁移到Oracle</h3>
               <div>
                  <div class="section">
                     <p>本节介绍如何使用OCCI迁移现有C ++应用程序。</p>
                     <p>迁移的步骤是：</p>
                  </div>
                  <!-- class="section" -->
                  <ol>
                     <li><span>确定对象模型和类层次结构</span></li>
                     <li><span>使用JDeveloper9 <span class="italic">i</span>映射到Oracle对象模式</span></li>
                     <li><span>使用Oracle Type Translator生成C ++头文件</span></li>
                     <li><span>根据需要修改旧的C ++访问类以使用新的对象类型定义</span></li>
                     <li><span>根据需要添加瞬态和持久对象管理功能。</span></li>
                  </ol>
               </div>
            </div><a id="LNCPP20169"></a><div class="props_rev_3"><a id="GUID-2E5F6826-403F-4925-8775-47D6849F555F" name="GUID-2E5F6826-403F-4925-8775-47D6849F555F"></a><h3 id="LNCPP-GUID-2E5F6826-403F-4925-8775-47D6849F555F" class="sect3"><span class="enumeration_section">4.6</span>关联访问概述</h3>
               <div>
                  <p>您可以在OCCI中使用SQL来检索对象，以及执行DML操作。</p>
                  <p>本节讨论以下主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="object-programming.html#GUID-91E34FB9-8769-415E-9221-B281F0F08D09">使用SQL访问对象</a></p>
                     </li>
                     <li>
                        <p><a href="object-programming.html#GUID-88BEB0C3-0137-466D-AEC2-025590FE82B5">插入和修改值</a></p>
                        <div class="infoboxnotealso" id="GUID-2E5F6826-403F-4925-8775-47D6849F555F__GUID-C414457E-E810-4345-9364-C717EF10562C">
                           <p class="notep1">也可以看看：</p>
                           <p>完整的演示程序代码清单</p>
                        </div>
                     </li>
                  </ul>
               </div><a id="LNCPP20170"></a><div class="props_rev_3"><a id="GUID-91E34FB9-8769-415E-9221-B281F0F08D09" name="GUID-91E34FB9-8769-415E-9221-B281F0F08D09"></a><h4 id="LNCPP-GUID-91E34FB9-8769-415E-9221-B281F0F08D09" class="sect4"><span class="enumeration_section">4.6.1</span>使用SQL访问对象</h4>
                  <div>
                     <div class="section">
                        <p>在前面的部分中，我们讨论了导航访问，其中SQL仅用于获取初始对象集的引用，然后从它们导航到其他对象。这里我们讨论如何使用SQL获取对象。</p>
                        <p>下面的示例演示如何使用<code class="codeph">ResultSet::getObject()</code>方法通过关联访问来获取对象，其中使用SQL从表<code class="codeph">addr_tab</code>获取每个对象：</p><pre class="oac_no_warn" dir="ltr">string sel_addr_val =“SELECT VALUE（address）FROM ADDR_TAB address”; ResultSet * rs = stmt-&gt; executeQuery（sel_addr_val）; while（rs-&gt; next（））{ADDRESS * addr_val = rs-&gt; getObject（1）; cout &lt;&lt;“state：”&lt;&lt; addr_val-&gt; getState（）; }</pre><p>通过关联访问获取的对象称为值实例，它们的行为就像瞬态对象。<code class="codeph">markModified()</code> ， <code class="codeph">flush()</code>和<code class="codeph">markDeleted()</code>等方法仅适用于持久对象。
                        </p>
                        <p>对这些对象所做的任何更改都不会反映在数据库中。</p>
                        <p>由于返回的对象是值实例，因此用户有责任通过删除对象指针来释放内存。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNCPP20171"></a><div class="props_rev_3"><a id="GUID-88BEB0C3-0137-466D-AEC2-025590FE82B5" name="GUID-88BEB0C3-0137-466D-AEC2-025590FE82B5"></a><h4 id="LNCPP-GUID-88BEB0C3-0137-466D-AEC2-025590FE82B5" class="sect4"><span class="enumeration_section">4.6.2</span>插入和修改值</h4>
                  <div>
                     <div class="section">
                        <p>我们刚刚看到了如何使用SQL来访问对象。OCCI还提供了使用SQL通过<code class="codeph">Statement::setObject</code>方法接口插入新对象或修改数据库服务器中现有对象的功能。
                        </p>
                        <p><a id="d18836e2222" class="indexterm-anchor"></a>以下示例创建一个临时对象<code class="codeph">Address</code>并将其插入到数据库表<code class="codeph">addr_tab</code> ：</p><pre class="oac_no_warn" dir="ltr">ADDRESS * addr_val =新地址（“NV”，“12563”）; //新建一个瞬态实例stmt-&gt; setSQL（“INSERT INTO ADDR_TAB values（：1）”）; stmt-&gt; setObject（1，addr_val）; stmt-&gt;执行（）;</pre></div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="LNCPP20172"></a><div class="props_rev_3"><a id="GUID-08991D90-AD38-4436-9B94-EA5AE02B5869" name="GUID-08991D90-AD38-4436-9B94-EA5AE02B5869"></a><h3 id="LNCPP-GUID-08991D90-AD38-4436-9B94-EA5AE02B5869" class="sect3"><span class="enumeration_section">4.7</span>导航访问概述</h3>
               <div>
                  <p>通过使用导航访问，您可以进行一系列操作。</p>
                  <p>本节讨论以下主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="object-programming.html#GUID-F6B35295-FF36-492B-BE81-ED363471303C">从数据库服务器检索对象引用（REF）</a></p>
                     </li>
                     <li>
                        <p><a href="object-programming.html#GUID-90246B2E-FB10-47AC-A3AD-2B9EE7858259">固定一个对象</a></p>
                     </li>
                     <li>
                        <p><a href="object-programming.html#GUID-2CA4F5EB-D646-4797-8AB7-B4CF0DFD5FE5">操纵对象属性</a></p>
                     </li>
                     <li>
                        <p><a href="object-programming.html#GUID-EE3EFD28-7BCB-491D-ABC8-659DDDDFDD96">关于标记对象和刷新更改</a></p>
                     </li>
                     <li>
                        <p><a href="object-programming.html#GUID-452627F0-6A11-4141-9271-B1F813131E3A">将对象标记为已修改（脏）</a></p>
                     </li>
                     <li>
                        <p><a href="object-programming.html#GUID-B6AEA4E0-2A1F-4B5C-AD8A-0BA95BD19477">关于记录数据库中的更改</a></p>
                     </li>
                     <li>
                        <p><a href="object-programming.html#GUID-9ED70097-5409-4E0C-905F-F8404C724690">在对象缓存中收集垃圾</a></p>
                     </li>
                     <li>
                        <p><a href="object-programming.html#GUID-85D81D09-85AF-4072-92F5-97E7CF194B52">关于确保参考文献的事务一致性</a></p>
                        <div class="infoboxnotealso" id="GUID-08991D90-AD38-4436-9B94-EA5AE02B5869__GUID-FDADB1F8-6A1E-44FB-9452-A500318F085F">
                           <p class="notep1">也可以看看：</p>
                           <p>完整的演示程序代码清单</p>
                        </div>
                     </li>
                  </ul>
               </div><a id="LNCPP20173"></a><div class="props_rev_3"><a id="GUID-F6B35295-FF36-492B-BE81-ED363471303C" name="GUID-F6B35295-FF36-492B-BE81-ED363471303C"></a><h4 id="LNCPP-GUID-F6B35295-FF36-492B-BE81-ED363471303C" class="sect4"><span class="enumeration_section">4.7.1</span>从数据库服务器检索对象引用（REF）</h4>
                  <div>
                     <div class="section">
                        <p>要使用对象，应用程序必须首先从数据库服务器检索一个或多个对象。您可以通过发出一个将引用（ <code class="codeph">REF</code> ）返回给一个或多个对象的SQL语句来实现此目的。
                        </p>
                        <p>SQL语句也可以从数据库中获取值实例而不是<code class="codeph">REF</code> 。
                        </p>
                        <p>以下SQL语句从数据库表<code class="codeph">addr_tab</code>检索单个对象<code class="codeph">address</code>的<code class="codeph">REF</code> ：</p><pre class="oac_no_warn" dir="ltr">string sel_addr =“SELECT REF（address）FROM addr_tab address WHERE zip_code ='94065'”;</pre><p>以下代码示例说明了如何执行查询并从结果集中获取<code class="codeph">REF</code> 。
                        </p><pre class="oac_no_warn" dir="ltr">ResultSet * rs = stmt-&gt; executeQuery（sel_addr）; RS-&gt;下（）; Ref &lt;address&gt; addr_ref = rs-&gt; getRef（1）;</pre><p>此时，您可以使用对象引用来访问和操作数据库中的对象。</p>
                        <div class="infoboxnotealso" id="GUID-F6B35295-FF36-492B-BE81-ED363471303C__GUID-6118A903-900D-4CC5-B606-591F473B0D94">
                           <p class="notep1">也可以看看：</p>
                           <p><span class="q">“ <a href="accessing-oracle-database-using-cplusplus.html#GUID-7B55181E-FC07-4E3D-B91C-25E4288D4B7B">关于执行SQL DDL和DML语句</a> ”</span>有关准备和执行SQL语句的一般信息</p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNCPP20174"></a><div class="props_rev_3"><a id="GUID-90246B2E-FB10-47AC-A3AD-2B9EE7858259" name="GUID-90246B2E-FB10-47AC-A3AD-2B9EE7858259"></a><h4 id="LNCPP-GUID-90246B2E-FB10-47AC-A3AD-2B9EE7858259" class="sect4"><span class="enumeration_section">4.7.2</span>固定对象</h4>
                  <div>
                     <div class="section">
                        <p>本节介绍一次涉及单个对象的简单引脚操作。有关通过复杂对象检索检索多个对象的信息，请参阅复杂对象检索<a href="object-programming.html#GUID-DDA38EF4-E971-4ECF-B565-4BB43CE8B8BC">概述</a>部分。
                        </p>
                        <p>完成获取步骤后，您的应用程序将具有对象的<code class="codeph">REF</code> 。目前无法使用实际对象。在操作对象之前，必须将其<span class="bold">固定</span> 。固定对象会将对象加载到对象缓存中，并使您能够访问和修改对象的属性，并遵循该对象对其他对象的引用。您的应用程序还控制何时将修改后的对象写回数据库服务器。
                        </p>
                        <p>OCCI只要求您取消引用<code class="codeph">REF</code> ，就像取消引用任何C ++指针一样。解除引用<code class="codeph">REF</code>透明地将对象实现为C ++类实例。
                        </p>
                        <p>继续上一节中的<code class="codeph">Address</code>类示例，假设用户添加了以下方法：</p><pre class="oac_no_warn" dir="ltr">string Address :: getState（）{return state; }</pre><p>要取消引用此<code class="codeph">REF</code>并访问对象的属性和方法：</p><pre class="oac_no_warn" dir="ltr">string state = addr_ref-&gt; getState（）; //  - &gt;固定对象</pre><p>第一次取消引用<code class="codeph">Ref&lt;T&gt;</code> <code class="codeph">(addr_ref)</code> ，该对象被固定，也就是说它从数据库服务器加载到对象缓存中。从那时起，operator <code class="codeph">Ref&lt;T&gt;</code> <code class="codeph">-&gt;</code>对<code class="codeph">Ref&lt;T&gt;</code>的行为就像任何C ++指针<code class="codeph">(T *)</code> 。对象保留在对象缓存中，直到<code class="codeph">REF</code> <code class="codeph">(addr_ref)</code>超出范围。然后它有资格进行垃圾收集。
                        </p>
                        <p>现在该对象已被固定，您的应用程序可以修改该对象。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNCPP20175"></a><div class="props_rev_3"><a id="GUID-2CA4F5EB-D646-4797-8AB7-B4CF0DFD5FE5" name="GUID-2CA4F5EB-D646-4797-8AB7-B4CF0DFD5FE5"></a><h4 id="LNCPP-GUID-2CA4F5EB-D646-4797-8AB7-B4CF0DFD5FE5" class="sect4"><span class="enumeration_section">4.7.3</span>操作对象属性</h4>
                  <div>
                     <div class="section">
                        <p>操作对象属性与访问它们没有区别，如上一节所示。我们假设<code class="codeph">Address</code>类具有以下用户定义的方法，该方法将<code class="codeph">state</code>属性设置为输入值：</p><pre class="oac_no_warn" dir="ltr">void Address :: setState（string new_state）{state = new_state; }</pre><p>以下示例显示如何修改对象的状态属性<code class="codeph">addr</code> ：</p><pre class="oac_no_warn" dir="ltr">addr_ref-&gt;的setState（ “PA”）;</pre><p>如前所述，如果对象不在对象缓存中，则第一次调用运算符<code class="codeph">-&gt;</code>在<code class="codeph">Ref&lt;T&gt;</code>加载对象。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNCPP20176"></a><div class="props_rev_3"><a id="GUID-EE3EFD28-7BCB-491D-ABC8-659DDDDFDD96" name="GUID-EE3EFD28-7BCB-491D-ABC8-659DDDDFDD96"></a><h4 id="LNCPP-GUID-EE3EFD28-7BCB-491D-ABC8-659DDDDFDD96" class="sect4"><span class="enumeration_section">4.7.4</span>关于标记对象和刷新更改</h4>
                  <div>
                     <p>在上一节的示例中，对象的属性已更改。此更改仅存在于客户端缓存中;您必须实现特定的编程步骤才能将更改写入数据库。</p>
                  </div>
               </div><a id="LNCPP20177"></a><div class="props_rev_3"><a id="GUID-452627F0-6A11-4141-9271-B1F813131E3A" name="GUID-452627F0-6A11-4141-9271-B1F813131E3A"></a><h4 id="LNCPP-GUID-452627F0-6A11-4141-9271-B1F813131E3A" class="sect4"><span class="enumeration_section">4.7.5</span>将对象标记为已修改（脏）</h4>
                  <div>
                     <div class="section">
                        <p>第一步是指示对象已被修改。这是通过在对象上调用<code class="codeph">markModified()</code>方法（ <code class="codeph">PObject</code>派生方法）来完成的。此方法将对象标记为<span class="bold">脏</span> （已修改）。
                        </p>
                        <p>继续前面的示例，在操作对象属性之后， <code class="codeph">addr_ref</code>引用的对象可以标记为脏，如下所示：</p><pre class="oac_no_warn" dir="ltr">addr_ref-&gt; markModified（）;</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNCPP20178"></a><div class="props_rev_3"><a id="GUID-B6AEA4E0-2A1F-4B5C-AD8A-0BA95BD19477" name="GUID-B6AEA4E0-2A1F-4B5C-AD8A-0BA95BD19477"></a><h4 id="LNCPP-GUID-B6AEA4E0-2A1F-4B5C-AD8A-0BA95BD19477" class="sect4"><span class="enumeration_section">4.7.6</span>关于记录数据库中的更改</h4>
                  <div>
                     <p>必须将已设置脏标志的对象刷新到数据库服务器，以便将更改记录在数据库中。这可以通过三种方式完成：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>通过调用方法<code class="codeph">flush</code> （一种<code class="codeph">PObject</code>的派生方法）来<code class="codeph">flush</code>标记为脏的单个对象。
                           </p>
                        </li>
                        <li>
                           <p>使用<code class="codeph">Connection::flushCache()</code>方法刷新整个对象缓存。在这种情况下，OCCI遍历由对象缓存维护的脏列表并刷新所有脏对象。
                           </p>
                        </li>
                        <li>
                           <p>通过调用<code class="codeph">Connection::commit()</code>方法提交事务。这样做也会遍历脏列表并将对象刷新到数据库服务器。脏列表包括新创建的持久对象。
                           </p>
                        </li>
                     </ul>
                  </div>
               </div><a id="LNCPP20179"></a><div class="props_rev_3"><a id="GUID-9ED70097-5409-4E0C-905F-F8404C724690" name="GUID-9ED70097-5409-4E0C-905F-F8404C724690"></a><h4 id="LNCPP-GUID-9ED70097-5409-4E0C-905F-F8404C724690" class="sect4"><span class="enumeration_section">4.7.7</span>在对象缓存中收集垃圾</h4>
                  <div>
                     <div class="section">
                        <p>对象缓存有两个重要的相关参数：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p>最大缓存大小百分比</p>
                           </li>
                           <li>
                              <p>最佳缓存大小</p>
                           </li>
                        </ul>
                        <p>这些参数指的是高速缓存内存使用的级别，它们有助于确定高速缓存何时自动“老化”符合条件的对象以释放内存。</p>
                        <p>如果当前在高速缓存中的对象占用的内存达到或超过最大高速缓存大小，则高速缓存自动开始释放（或老化）具有针数为零的未标记对象。缓存继续释放这些对象，直到缓存中的内存使用达到最佳大小，或者直到它用完了可以释放的对象为止。请注意，缓存可能会超出指定的最大缓存大小。</p>
                        <p>最大对象缓存大小（以字节为单位）的计算方法是将最佳缓存大小（ <code class="codeph">optimal_size</code> ）按最大缓存大小百分比（ <code class="codeph">max_size_percentage</code> ）递增，如下所示：</p><pre class="oac_no_warn" dir="ltr">最大缓存大小= optimal_size + optimal_size * max_size_percentage / 100;</pre><p>最大缓存大小百分比的默认值为10％。最佳高速缓存大小的默认值为8MB。当通过重载的<code class="codeph">PObject::new()</code>运算符创建持久对象时，新创建的对象标记为脏，其引脚数设置为<code class="codeph">0</code> 。
                        </p>
                        <p>可以使用Environment类的以下成员函数设置或检索这些参数：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">void setCacheMaxSize（unsigned int maxSize）;</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">unsigned int getCacheMaxSize（）const;</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">void setCacheOptSize（unsigned int OptSize）;</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">unsigned int getCacheOptSize（）const;</code></p>
                           </li>
                        </ul>
                        <p><span class="q">“ <a href="object-programming.html#GUID-BC5DE1FE-60CE-43E0-8037-8882C676CAE2">关于固定anObject</a> ”</span>描述了对象的引脚数如何用作引用计数以及具有<code class="codeph">0</code>引脚数的未标记对象如何可以用于垃圾收集。对于新创建的持久对象，在提交或中止事务之后，如果对象具有<code class="codeph">0</code>引脚计数，则对象未标记。因为没有任何东西引用这个对象，它就成了老化的候选者。
                        </p>
                        <p>如果您正在使用具有大量字符串或集合属性的多个对象，则大多数内存都是从C ++堆中分配的;这是因为OCCI使用STL。因此，您应该将缓存大小设置为较低的值，以避免在垃圾收集激活之前使用大量内存。</p>
                        <div class="infoboxnotealso" id="GUID-9ED70097-5409-4E0C-905F-F8404C724690__GUID-BC28D90A-FE64-43CA-A3A9-2E8F195274D3">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="occi-application-programing-interface.html#GUID-3C824380-073E-4F32-AA6E-928A18D52F4B">OCCI应用程序编程接口</a>了解详情。
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNCPP20180"></a><div class="props_rev_3"><a id="GUID-85D81D09-85AF-4072-92F5-97E7CF194B52" name="GUID-85D81D09-85AF-4072-92F5-97E7CF194B52"></a><h4 id="LNCPP-GUID-85D81D09-85AF-4072-92F5-97E7CF194B52" class="sect4"><span class="enumeration_section">4.7.8</span>关于确保引用的事务一致性</h4>
                  <div>
                     <p>如上一节所述，首次取消引用<code class="codeph">Ref&lt;T&gt;</code>导致对象从数据库服务器加载到对象缓存中。从那时起，operator <code class="codeph">Ref&lt;T&gt;</code> <code class="codeph">-&gt;</code> on <code class="codeph">Ref&lt;T&gt;</code>的行为等于任何C ++指针，并且它提供对缓存中对象副本的访问。但是当事务提交或中止时，缓存中的对象副本不再有效，因为它可以被任何其他客户端修改。因此，在事务结束后，再次取消引用<code class="codeph">Ref&lt;T&gt;</code>时，对象缓存会识别该对象不再有效的事实，并从数据库服务器获取最新的副本。
                     </p>
                  </div>
               </div>
            </div><a id="LNCPP20181"></a><div class="props_rev_3"><a id="GUID-DDA38EF4-E971-4ECF-B565-4BB43CE8B8BC" name="GUID-DDA38EF4-E971-4ECF-B565-4BB43CE8B8BC"></a><h3 id="LNCPP-GUID-DDA38EF4-E971-4ECF-B565-4BB43CE8B8BC" class="sect3"><span class="enumeration_section">4.8</span>复杂对象检索概述</h3>
               <div>
                  <p>在前面讨论的示例中，一次只提取或固定一个对象。在这些情况下，每个引脚操作都涉及一个单独的数据库服务器往返以检索对象。</p>
                  <p>面向对象的应用程序通常将其问题建模为一组形成对象图形的相互关联的对象。这些应用程序通过从一些初始对象集开始，然后使用这些对象中的引用来遍历其余对象来处理对象。在客户端/服务器设置中，这些遍历中的每一个都可能导致昂贵的网络往返以获取对象。</p>
                  <p>通过<span class="bold">复杂的对象检索</span> （COR）可以提高这些应用程序的性能。这是一种预取机制，其中应用程序指定用于在单个网络往返中检索一组链接对象的一些标准（内容和边界）。使用COR并不意味着这些预取的对象被固定。它们被提取到对象缓存中，以便后续的引脚调用是本地操作。
                  </p>
                  <p><span class="bold">复杂对象</span>是一组逻辑上相关的对象，包括根对象和一组对象，每个对象都基于给定的深度级别被预取。显式提取或固定<span class="bold">根</span>对象。<span class="bold">深度</span> <span class="bold">级别</span>是必须从根对象遍历到复杂对象中的给定预取对象的最短引用数。
                  </p>
                  <p>应用程序通过描述其内容和边界来指定复杂对象。复制对象的获取受到环境的<span class="bold">预取限制的限制</span> ，即对象缓存中可用于预取对象的内存量。
                  </p>
                  <p>使用复杂的对象检索不会增加功能;它只能提高性能，因此它的使用是可选的。</p>
                  <p>本节讨论以下主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="object-programming.html#GUID-828F603E-8872-44FF-8EC8-CED8423B3ED4">检索复杂对象</a></p>
                     </li>
                     <li>
                        <p><a href="object-programming.html#GUID-7D36C66E-C2F7-48BE-8CB7-42EC80B740B0">关于预取复杂对象</a></p>
                        <div class="infoboxnotealso" id="GUID-DDA38EF4-E971-4ECF-B565-4BB43CE8B8BC__GUID-4CFCDDED-78A9-4E2B-BC6A-C302DA1219B5">
                           <p class="notep1">也可以看看：</p>
                           <p>完整的演示程序代码清单</p>
                        </div>
                     </li>
                  </ul>
               </div><a id="LNCPP20182"></a><div class="props_rev_3"><a id="GUID-828F603E-8872-44FF-8EC8-CED8423B3ED4" name="GUID-828F603E-8872-44FF-8EC8-CED8423B3ED4"></a><h4 id="LNCPP-GUID-828F603E-8872-44FF-8EC8-CED8423B3ED4" class="sect4"><span class="enumeration_section">4.8.1</span>检索复杂对象</h4>
                  <div>
                     <div class="section">
                        <p>OCCI应用程序可以通过在使用以下方法解除引用之前设置<code class="codeph">Ref&lt;T&gt;</code>的适当属性来实现COR：</p><pre class="oac_no_warn" dir="ltr">//预取指定类型名称的属性，直到指定的深度Ref &lt;T&gt; :: setPrefetch（const string＆typeName，unsigned int depth）; //预取所有属性类型，直到达到指定的深度。Ref &lt;T&gt; :: setPrefetch（unsigned int depth）;</pre><p>应用程序还可以选择通过REF（传递闭包）获取从根对象可到达的所有对象到某个深度。为此，请将level参数设置为所需的深度。对于前两个示例，应用程序还可以分别指定<code class="codeph">(PO object REF, OCCI_MAX_PREFETCH_DEPTH)</code>和<code class="codeph">(PO object REF, 1)</code>以预取所需对象。这样做会导致许多无关的提取，但指定非常简单，并且只需要一个数据库服务器往返。
                        </p>
                        <p>作为此讨论的示例，请考虑以下类型声明：</p><pre class="oac_no_warn" dir="ltr">CREATE TYPE客户（...）; CREATE TYPE line_item（...）; CREATE TYPE line_item_varray为REF line_item的VARRAY（100）; CREATE TYPE purchase_order AS OBJECT（po_number NUMBER，cust REF customer，related_orders REF purchase_order，line_items line_item_varray）;</pre><p>该<code class="codeph">purchase_order</code>类型包含标量值<code class="codeph">po_number</code> ，一个<code class="codeph">VARRAY</code>的<code class="codeph">line_items</code>和两个引用。第一个是<code class="codeph">customer</code>类型，第二个是<code class="codeph">purchase_order</code>类型，表示此类型可以实现为链接列表。
                        </p>
                        <p>在获取复杂对象时，应用程序必须指定以下内容：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p>对所需根对象的引用</p>
                           </li>
                           <li>
                              <p>一对或多对类型和深度信息，用于指定复杂对象的边界。类型信息指示COR应遵循哪些<code class="codeph">REF</code>属性，深度级别指示应遵循这些链接的深度级别。
                              </p>
                           </li>
                        </ul>
                        <p>对于前面示例中的<code class="codeph">purchase_order</code>对象，应用程序必须指定以下内容：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>对根<code class="codeph">purchase_order</code>对象的引用</p>
                           </li>
                           <li>
                              <p><code class="codeph">customer</code> ， <code class="codeph">purchase_order</code>或<code class="codeph">line_item</code>一对或多对类型和深度信息</p>
                           </li>
                        </ul>
                        <p>预取采购订单的应用程序需要访问该采购订单的客户信息。使用简单导航，这将需要两个数据库服务器访问来检索这两个对象。</p>
                        <p>通过复杂的对象检索，当应用程序固定<code class="codeph">purchase_order</code>对象时，可以预取<code class="codeph">customer</code> 。在这种情况下，复杂对象将由<code class="codeph">purchase_order</code>对象及其引用的<code class="codeph">customer</code>对象组成。
                        </p>
                        <p>在前面的示例中，如果应用程序想要预取采购订单和相关的客户信息，则应用程序将指定<code class="codeph">purchase_order</code>对象并指示<code class="codeph">customer</code>应遵循深度级别1，如下所示：</p><pre class="oac_no_warn" dir="ltr">参考&lt;PURCHASE_ORDER&gt; poref; poref.setPrefetch（ “客户”，1）;</pre><p>如果应用程序想要预取<code class="codeph">purchase order</code>及其包含的对象图中的所有对象，则应用程序将指定<code class="codeph">purchase_order</code>对象，并指示<code class="codeph">customer</code>和<code class="codeph">purchase_order</code>应遵循可能的最大深度级别，如下所示：</p><pre class="oac_no_warn" dir="ltr">参考&lt;PURCHASE_ORDER&gt; poref; poref.setPrefetch（“CUSTOMER”，OCCI_MAX_PREFETCH_DEPTH）; poref.setPrefetch（“PURCHASE_ORDER”，OCCI_MAX_PREFETCH_DEPTH）;</pre><p>其中<code class="codeph">OCCI_MAX_PREFETCH_DEPTH</code>指定应预取通过根对象的引用可到达的指定类型的所有对象。
                        </p>
                        <p>如果应用程序想要预取采购订单以及与之关联的所有行项目，则应用程序将指定<code class="codeph">purchase_order</code>对象并指示<code class="codeph">line_items</code>应遵循可能的最大深度级别，如下所示：</p><pre class="oac_no_warn" dir="ltr">参考&lt;PURCHASE_ORDER&gt; poref; poref.setPrefetch（“LINE_ITEM”，1）;</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNCPP20183"></a><div class="props_rev_3"><a id="GUID-7D36C66E-C2F7-48BE-8CB7-42EC80B740B0" name="GUID-7D36C66E-C2F7-48BE-8CB7-42EC80B740B0"></a><h4 id="LNCPP-GUID-7D36C66E-C2F7-48BE-8CB7-42EC80B740B0" class="sect4"><span class="enumeration_section">4.8.2</span>关于预取复杂对象</h4>
                  <div>
                     <p>在指定和获取复杂对象之后，复杂对象中包含的对象的后续提取不会产生网络往返的成本，因为这些对象已经被预取并且在对象高速缓存中。请记住，过度预取对象可能会导致对象缓存泛滥。反过来，这种泛滥可能会强制应用程序固定的其他对象，从而导致性能下降而不是性能提升。</p>
                     <p>请注意，如果对象缓存中没有足够的内存来容纳所有预取对象，则可能无法预取某些对象。然后，当稍后访问这些对象时，应用程序会进行网络往返。</p>
                     <p>您必须具有所有预取对象的<code class="codeph">READ</code>或<code class="codeph">SELECT</code>权限。无法预取应用程序没有<code class="codeph">READ</code>或<code class="codeph">SELECT</code>权限的复杂对象中的对象。
                     </p>
                     <p>通过使用<a href="connection-class.html#GUID-412D06D3-7636-4A32-AF24-534099F989D0">Connection Class</a>的全局<a href="connection-class.html#GUID-D98EBFBE-3B25-4BD6-B228-F79E5A56AA7C">pinVectorOfRefs（）</a>方法，可以在单个往返中将<code class="codeph">Ref</code> s的整个向量预取到对象缓存中。该方法将<code class="codeph">Ref</code> s的<code class="codeph">n</code>尺寸矢量的往返次数从<code class="codeph">n</code>到<code class="codeph">1</code> ，并通过<code class="codeph">OUT</code>参数矢量跟踪新固定的对象。
                     </p>
                  </div>
               </div>
            </div><a id="LNCPP21905"></a><a id="LNCPP20184"></a><div class="props_rev_3"><a id="GUID-09287489-EE28-42C3-A6D7-1EA9B616DAAC" name="GUID-09287489-EE28-42C3-A6D7-1EA9B616DAAC"></a><h3 id="LNCPP-GUID-09287489-EE28-42C3-A6D7-1EA9B616DAAC" class="sect3"><span class="enumeration_section">4.9</span>使用集合</h3>
               <div>
                  <div class="section">
                     <p>Oracle支持两种集合 - 可变长度数组（有序集合）和嵌套表（无序集合）。OCCI将它们映射到标准模板库（STL）向量容器，为您提供访问和操作集合元素的STL向量的全部功能，灵活性和速度。<a href="object-programming.html#GUID-09287489-EE28-42C3-A6D7-1EA9B616DAAC__BEIJBAIA">例4-9</a>显示了用于创建<code class="codeph">VARRAY</code>的SQL DDL和一个包含<code class="codeph">VARRAY</code>类型属性的对象，以及OTT生成的结果C ++声明。
                     </p>
                     <div class="infoboxnotealso" id="GUID-09287489-EE28-42C3-A6D7-1EA9B616DAAC__GUID-AAF77C80-C955-46CA-8B88-C6E6BA4E1F5C">
                        <p class="notep1">也可以看看：</p>
                        <p>完整的演示程序代码清单</p>
                     </div>
                  </div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-09287489-EE28-42C3-A6D7-1EA9B616DAAC__BEIJBAIA">
                     <p class="titleinexample">示例4-9如何创建VARRAY集合</p><pre class="oac_no_warn" dir="ltr">创建类型ADDR_LIST作为REF地址的变量（3）; CREATE TYPE PERSON AS OBJECT（名称VARCHAR2（20），addr_l ADDR_LIST）;</pre><p>这是OTT生成的C ++类声明：</p><pre class="oac_no_warn" dir="ltr">class PERSON：public PObject {protected：string name; vector &lt;Ref &lt;ADDRESS&gt;&gt; addr_1; public：void * operator new（size_t size）; void * operator new（size_t size，const Connection * conn，const string＆table）; string getSQLTypeName（）const; void getSQLTypeName（oracle :: occi :: Environment * env，void ** schemaName，unsigned int＆schemaNameLen，void ** typeName，unsigned int＆typeNameLen）const; PERSON（void * ctx）：PObject（ctx）{}; static void * readSQL（void * ctx）; virtual void readSQL（AnyData＆stream）; static void writeSQL（void * obj，void * ctx）; virtual void writeSQL（AnyData＆stream）; }</pre></div>
                  <!-- class="example" -->
                  <div class="section">本节包括以下主题：<ul style="list-style-type:disc">
                        <li>
                           <p><a href="object-programming.html#GUID-F6A817C8-C321-420F-93C9-96EEEA95CDB9">获取嵌入的对象</a></p>
                        </li>
                        <li>
                           <p><a href="object-programming.html#GUID-0C5EA67E-4FAC-49D8-B8E6-DA07A201B7B0">关于Nullness</a></p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
               </div><a id="LNCPP20185"></a><div class="props_rev_3"><a id="GUID-F6A817C8-C321-420F-93C9-96EEEA95CDB9" name="GUID-F6A817C8-C321-420F-93C9-96EEEA95CDB9"></a><h4 id="LNCPP-GUID-F6A817C8-C321-420F-93C9-96EEEA95CDB9" class="sect4"><span class="enumeration_section">4.9.1</span>获取嵌入的对象</h4>
                  <div>
                     <div class="section">
                        <p>如果您的应用程序必须获取嵌入对象（即存储在常规表的列而不是对象表中的对象），则不能使用<code class="codeph">REF</code>检索机制。嵌入式实例没有对象标识符，因此无法获取对它们的引用。因此，它们不能作为对象导航的基础。但是，仍然存在许多应用程序获取嵌入式实例的情况。
                        </p>
                        <p>例如，假设已创建<code class="codeph">address</code>类型。
                        </p><pre class="oac_no_warn" dir="ltr">CREATE TYPE地址AS OBJECT（street1 varchar2（50），street2 varchar2（50），city varchar2（30），state char（2），zip number（5））;</pre><p>然后，您可以将该类型用作另一个表中列的数据类型：</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE客户端（名称varchar2（40），addr地址）;</pre><p>然后，您的OCCI应用程序可以发出以下SQL语句：</p><pre class="oac_no_warn" dir="ltr">SELECT addr FROM clients WHERE name ='BEAR BYTE DATA MANAGEMENT';</pre><p>此语句将从<code class="codeph">clients</code>表返回一个嵌入的<code class="codeph">address</code>对象。然后，应用程序可以使用此对象的属性中的值进行其他处理。应用程序应该执行语句并以<span class="q">“ <a href="object-programming.html#GUID-2E5F6826-403F-4925-8775-47D6849F555F">关联访问概述</a> ”</span>部分中描述的相同方式获取对象。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNCPP20186"></a><div class="props_rev_3"><a id="GUID-0C5EA67E-4FAC-49D8-B8E6-DA07A201B7B0" name="GUID-0C5EA67E-4FAC-49D8-B8E6-DA07A201B7B0"></a><h4 id="LNCPP-GUID-0C5EA67E-4FAC-49D8-B8E6-DA07A201B7B0" class="sect4"><span class="enumeration_section">4.9.2</span>关于无效</h4>
                  <div>
                     <p>如果数据库表的行中的列没有值，则该列称为<code class="codeph">NULL</code> ，或者包含<code class="codeph">NULL</code> 。两种不同类型的<code class="codeph">NULL</code>可以应用于对象：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>对象的任何属性都可以具有<code class="codeph">NULL</code>值。这表示该对象的该属性的值未知。
                           </p>
                        </li>
                        <li>
                           <p>对象可以是<span class="bold">原子NULL</span> 。因此，整个对象的值是未知的。
                           </p>
                        </li>
                     </ul>
                     <p>原子<code class="codeph">NULL</code>内斯是不存在的，从不同的。原子<code class="codeph">NULL</code>对象仍然存在，其值不知道。它可以被认为是没有数据的现有对象。
                     </p>
                     <p>对于每种类型的对象属性，OCCI提供相应的类。例如， <code class="codeph">NUMBER</code>属性类型映射到<code class="codeph">Number</code>类， <code class="codeph">REF</code>映射到<code class="codeph">RefAny</code> ，依此类推。表示数据类型的每个OCCI类都提供两种方法：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">isNull()</code> - 返回对象是否为<code class="codeph">NULL</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">setNull()</code> - 将对象设置为<code class="codeph">NULL</code></p>
                        </li>
                     </ul>
                     <p>类似地，这些方法由所有对象从<code class="codeph">PObject</code>类继承，并可用于访问和设置有关它们的原子<code class="codeph">NULL</code>信息。
                     </p>
                  </div>
               </div>
            </div><a id="LNCPP20187"></a><div class="props_rev_3"><a id="GUID-E3D9E110-7335-4E84-9452-7FE689550FB7" name="GUID-E3D9E110-7335-4E84-9452-7FE689550FB7"></a><h3 id="LNCPP-GUID-E3D9E110-7335-4E84-9452-7FE689550FB7" class="sect3"><span class="enumeration_section">4.10</span>关于使用对象引用</h3>
               <div>
                  <p>OCCI为应用程序提供了使用指针或引用访问对象内容的灵活性。OCCI提供<code class="codeph">PObject::getRef()</code>方法以返回对持久对象的引用。此调用仅对持久对象有效。
                  </p>
               </div>
            </div><a id="LNCPP20188"></a><div class="props_rev_3"><a id="GUID-C7C82B8B-2056-4692-9BA0-C123902C6268" name="GUID-C7C82B8B-2056-4692-9BA0-C123902C6268"></a><h3 id="LNCPP-GUID-C7C82B8B-2056-4692-9BA0-C123902C6268" class="sect3"><span class="enumeration_section">4.11</span>关于从数据库中删除对象</h3>
               <div>
                  <p>OCCI用户可以使用重载的<code class="codeph">PObject::operator</code> <code class="codeph">new()</code>来创建持久对象。但是，要从数据库服务器中删除对象，最好调用<code class="codeph">ref</code> 。 <a href="pobject-class.html#GUID-AF071A80-A628-45B3-BEC6-92B28820A516">markDelete（）</a>直接在<code class="codeph">Ref</code> ;这可以防止对象进入客户端缓存。如果对象在客户端缓存中，则可以通过<code class="codeph">obj</code>删除它。 <a href="pobject-class.html#GUID-AF071A80-A628-45B3-BEC6-92B28820A516">markDelete（）</a>调用该对象。标记为删除的对象在事务提交时被永久删除。
                  </p>
               </div>
            </div><a id="LNCPP20189"></a><div class="props_rev_3"><a id="GUID-43D835F1-F7E4-4EA5-8F32-F50393162132" name="GUID-43D835F1-F7E4-4EA5-8F32-F50393162132"></a><h3 id="LNCPP-GUID-43D835F1-F7E4-4EA5-8F32-F50393162132" class="sect3"><span class="enumeration_section">4.12</span>关于类型继承</h3>
               <div>
                  <p>对象的类型继承与C ++和Java中的继承有许多相似之处。您可以将对象类型创建为现有对象类型的子类型。据说子类型继承了超类型的所有属性和方法（成员函数和过程），这是原始类型。仅支持单继承;一个对象不能有多个超类型。子类型可以向其继承的属性和方法添加新属性和方法。它还可以覆盖（重新定义其任何继承方法的实现）。据说子类型扩展（即继承）其超类型。</p>
                  <div class="infoboxnotealso" id="GUID-43D835F1-F7E4-4EA5-8F32-F50393162132__GUID-4D386922-5E66-45D9-B0B0-0208A4CD8097">
                     <p class="notep1">也可以看看：</p>
                     <p><a href="../adobj/key-features-object-relational-model.html#ADOBJ7054" target="_blank"><span><cite>Oracle数据库对象关系开发人员指南，</cite></span></a>用于更完整地讨论该主题</p>
                  </div>
                  <p>例如，类型<code class="codeph">Person_t</code>可以具有子类型<code class="codeph">Student_t</code>和子类型<code class="codeph">Employee_t</code> 。反过来， <code class="codeph">Student_t</code>可以有自己的子类型<code class="codeph">PartTimeStudent_t</code> 。类型声明必须具有<code class="codeph">NOT FINAL</code>标志，以便它可以具有子类型。默认值为<code class="codeph">FINAL</code> ，表示该类型不具有子类型。
                  </p>
                  <p>本章到目前为止讨论的所有类型都是<code class="codeph">FINAL</code> 。在Oracle Database 8.1.7之前开发的应用程序中的所有类型都是<code class="codeph">FINAL</code> 。 <code class="codeph">FINAL</code>的类型可以更改为<code class="codeph">NOT FINAL</code> 。没有子类型的<code class="codeph">NOT FINAL</code>类型可以更改为<code class="codeph">FINAL</code> 。对于我们的示例， <code class="codeph">Person_ t</code>被声明为<code class="codeph">NOT FINAL</code> ：</p><pre class="oac_no_warn" dir="ltr">CREATE TYPE Person_t AS OBJECT（ssn NUMBER，名称VARCAHR2（30），地址VARCHAR2（100））NOT FINAL;</pre><p>子类型继承其超类型中声明的所有属性和方法。它还可以声明新的属性和方法，这些属性和方法必须具有与超类型不同的名称。关键字<code class="codeph">UNDER</code>标识超类型，如下所示：</p><pre class="oac_no_warn" dir="ltr">CREATE TYPE Student_t UNDER Person_t（deptid NUMBER，major VARCHAR2（30））NOT FINAL;</pre><p>新声明的属性<code class="codeph">deptid</code>和<code class="codeph">major</code>属于子类型<code class="codeph">Student_t</code> 。子类型<code class="codeph">Employee_t</code>被声明为，例如：</p><pre class="oac_no_warn" dir="ltr">CREATE TYPE Employee_t UNDER Person_t（empid NUMBER，mgr VARCHAR2（30））;</pre><div class="infoboxnotealso" id="GUID-43D835F1-F7E4-4EA5-8F32-F50393162132__GUID-0733D9EF-AD7A-4F6B-98A5-7CFCD25ED442">
                     <p class="notep1">也可以看看：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><span class="q"><a href="object-programming.html#GUID-BF3C57CE-ACB4-48DA-A196-53A9CA730659">关于</a></span>此示例的OTT生成的类的<span class="q">“ <a href="object-programming.html#GUID-BF3C57CE-ACB4-48DA-A196-53A9CA730659">关于类型继承的OTT支持</a> ”</span> 。
                           </p>
                        </li>
                     </ul>
                  </div>
                  <p>子类型<code class="codeph">Student_t</code>可以有自己的子类型，例如<code class="codeph">PartTimeStudent_t</code> ：</p><pre class="oac_no_warn" dir="ltr">创建类型PartTimeStuden_t UNDER Student_t（numhours NUMBER）;</pre><div class="p">本节包括以下主题：<ul style="list-style-type:disc">
                        <li>
                           <p><a href="object-programming.html#GUID-3C109E93-974F-4549-8EE7-61FEE1A6A2C3">关于替代性</a></p>
                        </li>
                        <li>
                           <p><a href="object-programming.html#GUID-F5BAB79A-A7FB-48ED-A768-C6BFDDE3A8E0">声明NOT INSTANTIABLE类型和方法</a></p>
                        </li>
                        <li>
                           <p><a href="object-programming.html#GUID-6D841D5E-B559-4074-8311-6DA4B853BB7E">关于OCCI对类型继承的支持</a></p>
                        </li>
                        <li>
                           <p><a href="object-programming.html#GUID-BF3C57CE-ACB4-48DA-A196-53A9CA730659">关于类型继承的OTT支持</a></p>
                        </li>
                     </ul>
                  </div>
               </div><a id="LNCPP20190"></a><div class="props_rev_3"><a id="GUID-3C109E93-974F-4549-8EE7-61FEE1A6A2C3" name="GUID-3C109E93-974F-4549-8EE7-61FEE1A6A2C3"></a><h4 id="LNCPP-GUID-3C109E93-974F-4549-8EE7-61FEE1A6A2C3" class="sect4"><span class="enumeration_section">4.12.1</span>关于替代性</h4>
                  <div>
                     <p>多态性的好处部分源于财产的可替代性。可替代性允许最初为超类型编写的代码使用某些子类型的值，而不需要事先知道子类型的任何特定知识。子类型值就像超类型的值一样对周围的代码起作用，即使它可能在其特化方法中使用不同的机制。</p>
                     <p>实例可替代性是指在根据超类型声明的上下文中使用子类型的对象值的能力。<code class="codeph">REF</code>可替代性是指将<code class="codeph">REF</code>用于根据<code class="codeph">REF</code>对超类型声明的上下文中的子类型的能力。
                     </p>
                     <p><code class="codeph">REF</code>类型属性是可替换的，即，定义为<code class="codeph">REF T</code>的属性可以将<code class="codeph">REF</code>保存到<code class="codeph">T</code>的实例或其任何子类型。
                     </p>
                     <p>对象类型的属性是可取代的，即，定义为的属性（对象）类型<code class="codeph">T</code>可容纳的实例<code class="codeph">T</code>或其任何亚型。
                     </p>
                     <p>集合元素类型是可替换的，也就是说，如果我们定义类型为<code class="codeph">T</code>的元素的集合，那么它可以保存类型为<code class="codeph">T</code>实例及其任何子类型。以下是对象属性可替换性的示例：</p><pre class="oac_no_warn" dir="ltr">CREATE TYPE Book_t AS OBJECT（标题VARCHAR2（30），作者Person_t / * substitutable * /）;</pre><p>因此， <code class="codeph">Book_t</code>实例可以通过指定一个标题字符串和一个创建<code class="codeph">Person_t</code> （或任何亚型<code class="codeph">Person_t</code> ）对象：</p><pre class="oac_no_warn" dir="ltr">Book_t（'我的Oracle体验'，Employee_t（12345，'Joe'，'SF'，1111，NULL））</pre></div>
               </div><a id="LNCPP20191"></a><div class="props_rev_3"><a id="GUID-F5BAB79A-A7FB-48ED-A768-C6BFDDE3A8E0" name="GUID-F5BAB79A-A7FB-48ED-A768-C6BFDDE3A8E0"></a><h4 id="LNCPP-GUID-F5BAB79A-A7FB-48ED-A768-C6BFDDE3A8E0" class="sect4"><span class="enumeration_section">4.12.2</span>声明NOT INSTANTIABLE类型和方法</h4>
                  <div>
                     <div class="section">
                        <p>类型可以声明为<code class="codeph">NOT INSTANTIABLE</code> ，这意味着该类型没有构造函数（默认或用户定义）。因此，不可能构造这种类型的实例。典型的用法是为这种类型定义可实例化的子类型。以下是此属性的使用方式：</p><pre class="oac_no_warn" dir="ltr">CREATE TYPE Address_t AS OBJECT（...）不可能不是最终的; CREATE TYPE USAddress_t UNDER Address_t（...）; CREATE TYPE IntlAddress_t UNDER Address_t（...）;</pre><p>可以将类型的方法声明为<code class="codeph">NOT INSTANTIABLE</code> 。将方法声明为<code class="codeph">NOT INSTANTIABLE</code>意味着该类型未提供该方法的实现。此外，必须将包含任何<code class="codeph">NOT INSTANTIABLE</code>方法的类型声明为<code class="codeph">NOT INSTANTIABLE</code> 。例如：</p><pre class="oac_no_warn" dir="ltr">创建类型T作为对象（x数字，不是不可用的成员函数func1（）返回数字）不可用;</pre><p><code class="codeph">NOT INSTANTIABLE</code>的子类型可以覆盖超类型的任何<code class="codeph">NOT INSTANTIABLE</code>方法并提供具体实现。如果剩余任何<code class="codeph">NOT INSTANTIABLE</code>方法，则子类型也必须声明为<code class="codeph">NOT INSTANTIABLE</code> 。</p>
                        <p>可以在可实例化的超类型下定义<code class="codeph">NOT INSTANTIABLE</code>子类型。将<code class="codeph">NOT INSTANTIABLE</code>类型声明为<code class="codeph">FINAL</code>是没有用的，是不允许的。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNCPP20192"></a><div class="props_rev_3"><a id="GUID-6D841D5E-B559-4074-8311-6DA4B853BB7E" name="GUID-6D841D5E-B559-4074-8311-6DA4B853BB7E"></a><h4 id="LNCPP-GUID-6D841D5E-B559-4074-8311-6DA4B853BB7E" class="sect4"><span class="enumeration_section">4.12.3</span>关于OCCI对类型继承的支持</h4>
                  <div>
                     <div class="p">以下调用支持类型继承：<ul style="list-style-type:disc">
                           <li>
                              <p><a href="object-programming.html#GUID-8432951E-4B49-48A4-BCD0-CD65D1B50B73">关于Connection :: getMetaData（）</a></p>
                           </li>
                           <li>
                              <p><a href="object-programming.html#GUID-D0BAE493-FDCD-4EBF-B89A-C1CF1BBD2648">关于绑定和定义函数</a></p>
                           </li>
                        </ul>
                     </div>
                  </div><a id="LNCPP20193"></a><div class="props_rev_3"><a id="GUID-8432951E-4B49-48A4-BCD0-CD65D1B50B73" name="GUID-8432951E-4B49-48A4-BCD0-CD65D1B50B73"></a><h5 id="LNCPP-GUID-8432951E-4B49-48A4-BCD0-CD65D1B50B73" class="sect5"><span class="enumeration_section">4.12.3.1</span>关于Connection :: getMetaData（）</h5>
                     <div>
                        <p>此方法提供特定于继承类型的信息。已为继承类型的属性添加了其他属性。例如，您可以获取类型的超类型。</p>
                     </div>
                  </div><a id="LNCPP20194"></a><div class="props_rev_3"><a id="GUID-D0BAE493-FDCD-4EBF-B89A-C1CF1BBD2648" name="GUID-D0BAE493-FDCD-4EBF-B89A-C1CF1BBD2648"></a><h5 id="LNCPP-GUID-D0BAE493-FDCD-4EBF-B89A-C1CF1BBD2648" class="sect5"><span class="enumeration_section">4.12.3.2</span>关于绑定和定义函数</h5>
                     <div>
                        <p><code class="codeph">Statement</code>类的<code class="codeph">setRef()</code> ， <code class="codeph">setObject()</code>和<code class="codeph">setVector()</code>方法分别用于绑定<code class="codeph">REF</code> ，对象和集合。所有这些函数都支持<code class="codeph">REF</code> ，实例和集合元素的可替代性。同样，获取数据的相应<code class="codeph">get</code> <span class="italic"><code class="codeph">xxx</code></span> <code class="codeph">()</code>方法也支持可替代性。
                        </p>
                     </div>
                  </div>
               </div><a id="LNCPP20196"></a><a id="LNCPP20195"></a><div class="props_rev_3"><a id="GUID-BF3C57CE-ACB4-48DA-A196-53A9CA730659" name="GUID-BF3C57CE-ACB4-48DA-A196-53A9CA730659"></a><h4 id="LNCPP-GUID-BF3C57CE-ACB4-48DA-A196-53A9CA730659" class="sect4"><span class="enumeration_section">4.12.4</span>关于类型继承的OTT支持</h4>
                  <div>
                     <p>具有继承的对象的类声明类似于简单对象声明，除了该类派生自父类型类，并且仅包括与不在父类中的属性对应的字段。<a href="object-programming.html#GUID-BF3C57CE-ACB4-48DA-A196-53A9CA730659__CIHFBACF">例4-10中</a>列出了这些声明的结构：</p>
                     <p>在这种结构中，所有变量都与简单对象的情况相同。 <code class="codeph">parentTypename</code>是指父类型的名称，即typename继承的类型的类名。
                     </p>
                     <div class="example" id="GUID-BF3C57CE-ACB4-48DA-A196-53A9CA730659__CIHFBACF">
                        <p class="titleinexample">例4-10 OTT支持继承</p><pre class="oac_no_warn" dir="ltr">class &lt;typename&gt;：public &lt;parentTypename&gt; {protected：&lt;OCCItype1&gt; &lt;attributename1&gt;; ...&lt;OCCItypen&gt; &lt;attributenamen&gt;; public：void * operator new（size_t size）; void * operator new（size_t size，const Connection * conn，const string＆table）; string getSQLTypeName（）const; void getSQLTypeName（oracle :: occi :: Environment * env，void ** schemaName，unsigned int＆schemaNameLen，void ** typeName，unsigned int＆typeNameLen）const; &lt;typename&gt;（void * ctx）：&lt;parentTypename&gt;（ctx）{}; static void * readSQL（void * ctx）; virtual void readSQL（AnyData＆stream）; static void writeSQL（void * obj，void * ctx）; virtual void writeSQL（AnyData＆stream）; }</pre></div>
                     <!-- class="example" -->
                  </div>
               </div>
            </div><a id="LNCPP20198"></a><a id="LNCPP20199"></a><a id="LNCPP20200"></a><a id="LNCPP20201"></a><a id="LNCPP20202"></a><a id="LNCPP20203"></a><a id="LNCPP20204"></a><a id="LNCPP20205"></a><a id="LNCPP20206"></a><a id="LNCPP20207"></a><a id="LNCPP20197"></a><div class="props_rev_3"><a id="GUID-6E6AA436-1CBB-4571-A738-AEF47FF29598" name="GUID-6E6AA436-1CBB-4571-A738-AEF47FF29598"></a><h3 id="LNCPP-GUID-6E6AA436-1CBB-4571-A738-AEF47FF29598" class="sect3"><span class="enumeration_section">4.13</span> OCCI申请样本</h3>
               <div>
                  <div class="section">
                     <p>本节描述了一个OCCI应用程序示例，它使用了本章中讨论的一些功能。</p>
                  </div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-6E6AA436-1CBB-4571-A738-AEF47FF29598__GUID-D7B1BB61-8C4A-4E56-B167-3ECB3C2FAD4A">
                     <p class="titleinexample">示例4-11示例OCCI应用程序的demo2.sql列表</p><pre class="oac_no_warn" dir="ltr">drop table ADDR_TAB / drop table PERSON_TAB / drop type STUDENT / drop type PERSON / drop type ADDRESS_TAB / drop type ADDRESS / drop type FULLNAME / CREATE TYPE FULLNAME AS OBJECT（first_name CHAR（20），last_name CHAR（20））/ CREATE TYPE ADDRESS AS OBJECT（状态CHAR（20），zip CHAR（20））/ CREATE TYPE ADDRESS_TAB AS VARRAY（3）REF ADDRESS / CREATE TYPE PERSON AS OBJECT（id NUMBER，name FULLNAME，curr_addr REF ADDRESS，prev_addr_l ADDRESS_TAB）NOT FINAL /在人之下创建类型学生（school_name CHAR（20））/创建地址ADDR_TAB地址/创建表PERSON_TAB OF PERSON /</pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-6E6AA436-1CBB-4571-A738-AEF47FF29598__CIHEEFFI">
                     <p class="titleinexample">例4-12示例OCCI应用程序的demo2.typ列表</p><pre class="oac_no_warn" dir="ltr">TYPE FULLNAME生成CFullName为MyFullName TYPE ADDRESS GENERATE CAddress as MyAddress TYPE PERSON GENERATE CPerson as MyPerson TYPE STUDENT GENERATE CStudent as MyStudent</pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-6E6AA436-1CBB-4571-A738-AEF47FF29598__GUID-791AD8E7-188B-40A3-B6D1-89E5388522E0">
                     <p class="titleinexample">例4-13为示例OCCI应用程序生成文件的OTT命令列表</p>
                     <p>OTT尝试连接用户名<code class="codeph">demousr</code> ;系统提示输入密码。
                     </p><pre class="oac_no_warn" dir="ltr">ott userid = demousr intype = demo2.typ code = cpp hfile = demo2.h cppfile = demo2.cpp mapfile = mappings.cpp attraccess = private</pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-6E6AA436-1CBB-4571-A738-AEF47FF29598__GUID-CB32D2C6-B2A6-48B2-8638-194D7862D32F">
                     <p class="titleinexample">示例4-14示例OCCI应用程序的mappings.h列表</p><pre class="oac_no_warn" dir="ltr">#ifndef MAPPINGS_ORACLE #define MAPPINGS_ORACLE #ifndef OCCI_ORACLE #include &lt;occi.h&gt; #endif #ifndef DEMO2_ORACLE #include“demo2.h”#endif void mappings（oracle :: occi :: Environment * envOCCI_）; ＃万一</pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-6E6AA436-1CBB-4571-A738-AEF47FF29598__GUID-0D9FE4F4-4B1A-462E-8C71-E2D43BA80770">
                     <p class="titleinexample">示例4-15示例OCCI应用程序的mappings.cpp列表</p><pre class="oac_no_warn" dir="ltr">#ifndef MAPPINGS_ORACLE #include“mappings.h”#endif void mappings（oracle :: occi :: Environment * envOCCI_）{oracle :: occi :: Map * mapOCCI_ = envOCCI _-&gt; getMap（）; mapOCCI _-&gt; put（“HR.FULLNAME”，＆CFullName :: readSQL，＆CFullName :: writeSQL）; mapOCCI _-&gt; put（“HR.ADDRESS”，＆CAddress :: readSQL，＆CAddress :: writeSQL）; mapOCCI _-&gt; put（“HR.PERSON”，＆CPerson :: readSQL，＆CPerson :: writeSQL）; mapOCCI _-&gt; put（“HR.STUDENT”，＆CStudent :: readSQL，＆CStudent :: writeSQL）; }</pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-6E6AA436-1CBB-4571-A738-AEF47FF29598__GUID-164C7CCD-9950-4E4A-8D6C-9872D19F111F">
                     <p class="titleinexample">例4-16示例OCCI应用程序的demo2.h列表</p><pre class="oac_no_warn" dir="ltr">#ifndef DEMO2_ORACLE #define DEMO2_ORACLE #ifndef OCCI_ORACLE #include &lt;occi.h&gt; #endif using namespace std; using namespace oracle :: occi; class MyFullName; class MyAddress; MyPerson; / *更改在此结束* / / *全字符对象类型的生成声明。 * / class CFullName：public oracle :: occi :: PObject {private：OCCI_STD_NAMESPACE :: string FIRST_NAME; OCCI_STD_NAMESPACE :: string LAST_NAME; public：OCCI_STD_NAMESPACE :: string getFirst_name（）const; void setFirst_name（const OCCI_STD_NAMESPACE :: string＆value）; OCCI_STD_NAMESPACE :: string getLast_name（）const; void setLast_name（const OCCI_STD_NAMESPACE :: string＆value）; void * operator new（size_t size）; void * operator new（size_t size，const oracle :: occi :: Connection * sess，const OCCI_STD_NAMESPACE :: string＆table）; void * operator new（size_t，void * ctxOCCI_）; void * operator new（size_t size，const oracle :: occi :: Connection * sess，const OCCI_STD_NAMESPACE :: string＆tableName，const OCCI_STD_NAMESPACE :: string＆typeName，const OCCI_STD_NAMESPACE :: string＆tableSchema，const OCCI_STD_NAMESPACE :: string＆typeSchema）; string getSQLTypeName（）const; void getSQLTypeName（oracle :: occi :: Environment * env，void ** schemaName，unsigned int＆schemaNameLen，void ** typeName，unsigned int＆typeNameLen）const; CFullName（）; CFullName（void * ctxOCCI_）：oracle :: occi :: PObject（ctxOCCI_）{}; static void * readSQL（void * ctxOCCI_）; virtual void readSQL（oracle :: occi :: AnyData＆streamOCCI_）; static void writeSQL（void * objOCCI_，void * ctxOCCI_）; virtual void writeSQL（oracle :: occi :: AnyData＆streamOCCI_）; 〜CFullName（）; }; / *针对地址对象类型生成的声明。 * / class CAddress：public oracle :: occi :: PObject {private：OCCI_STD_NAMESPACE :: string STATE; OCCI_STD_NAMESPACE :: string ZIP; public：OCCI_STD_NAMESPACE :: string getState（）const; void setState（const OCCI_STD_NAMESPACE :: string＆value）; OCCI_STD_NAMESPACE :: string getZip（）const; void setZip（const OCCI_STD_NAMESPACE :: string＆value）; void * operator new（size_t size）; void * operator new（size_t size，const oracle :: occi :: Connection * sess，const OCCI_STD_NAMESPACE :: string＆table）; void * operator new（size_t，void * ctxOCCI_）; void * operator new（size_t size，const oracle :: occi :: Connection * sess，const OCCI_STD_NAMESPACE :: string＆tableName，const OCCI_STD_NAMESPACE :: string＆typeName，const OCCI_STD_NAMESPACE :: string＆tableSchema，const OCCI_STD_NAMESPACE :: string＆typeSchema）; string getSQLTypeName（）const; void getSQLTypeName（oracle :: occi :: Environment * env，void ** schemaName，unsigned int＆schemaNameLen，void ** typeName，unsigned int＆typeNameLen）const; CAddress（）; CAddress（void * ctxOCCI_）：oracle :: occi :: PObject（ctxOCCI_）{}; static void * readSQL（void * ctxOCCI_）; virtual void readSQL（oracle :: occi :: AnyData＆streamOCCI_）; static void writeSQL（void * objOCCI_，void * ctxOCCI_）; virtual void writeSQL（oracle :: occi :: AnyData＆streamOCCI_）; 〜CAddress（）; }; / *生成的对象类型的声明。 * / class CPerson：public oracle :: occi :: PObject {private：oracle :: occi :: Number ID; MyFullName * NAME; oracle :: occi :: Ref &lt;MyAddress&gt; CURR_ADDR; OCCI_STD_NAMESPACE :: vector &lt;oracle :: occi :: Ref &lt;MyAddress &gt;&gt; PREV_ADDR_L; public：oracle :: occi :: Number getId（）const; void setId（const oracle :: occi :: Number＆value）; MyFullName * getName（）const; void setName（MyFullName * value）; oracle :: occi :: Ref &lt;MyAddress&gt; getCurr_addr（）const; void setCurr_addr（const oracle :: occi :: Ref &lt;MyAddress&gt;＆value）; OCCI_STD_NAMESPACE :: vector &lt;oracle :: occi :: Ref &lt;MyAddress &gt;&gt;＆getPrev_addr_l（）; const OCCI_STD_NAMESPACE :: vector &lt;oracle :: occi :: Ref &lt;MyAddress &gt;&gt;＆getPrev_addr_l（）const; void setPrev_addr_l（const OCCI_STD_NAMESPACE :: vector &lt;oracle :: occi :: Ref &lt;MyAddress &gt;&gt;＆value）; void * operator new（size_t size）; void * operator new（size_t size，const oracle :: occi :: Connection * sess，const OCCI_STD_NAMESPACE :: string＆table）; void * operator new（size_t，void * ctxOCCI_）; void * operator new（size_t size，const oracle :: occi :: Connection * sess，const OCCI_STD_NAMESPACE :: string＆tableName，const OCCI_STD_NAMESPACE :: string＆typeName，const OCCI_STD_NAMESPACE :: string＆tableSchema，const OCCI_STD_NAMESPACE :: string＆typeSchema）; string getSQLTypeName（）const; void getSQLTypeName（oracle :: occi :: Environment * env，void ** schemaName，unsigned int＆schemaNameLen，void ** typeName，unsigned int＆typeNameLen）const; CPerson（）; CPerson（void * ctxOCCI_）：oracle :: occi :: PObject（ctxOCCI_）{}; static void * readSQL（void * ctxOCCI_）; virtual void readSQL（oracle :: occi :: AnyData＆streamOCCI_）; static void writeSQL（void * objOCCI_，void * ctxOCCI_）; virtual void writeSQL（oracle :: occi :: AnyData＆streamOCCI_）; 〜CPerson（）; }; / *生成的学生对象类型的声明。 * / / *更改生成的文件 -  MyPerson类的声明。* / class MyPerson：public CPerson {public：MyPerson（Number id_i，MyFullName * name_i，const Ref &lt;MyAddress&gt;＆addr_i）; MyPerson（void * ctxOCCI_）; void move（const Ref &lt;MyAddress&gt;＆new_addr）; void displayInfo（）; MyPerson（）; }; / *更改结束此处* / class CStudent：public MyPerson {private：OCCI_STD_NAMESPACE :: string SCHOOL_NAME; public：OCCI_STD_NAMESPACE :: string getSchool_name（）const; void setSchool_name（const OCCI_STD_NAMESPACE :: string＆value）; \ void * operator new（size_t size）; void * operator new（size_t size，const oracle :: occi :: Connection * sess，\ const OCCI_STD_NAMESPACE :: string＆table）; void * operator new（size_t，void * ctxOCCI_）; void * operator new（size_t size，const oracle :: occi :: Connection * sess，const OCCI_STD_NAMESPACE :: string＆tableName，const OCCI_STD_NAMESPACE :: string＆typeName，const OCCI_STD_NAMESPACE :: string＆tableSchema，const OCCI_STD_NAMESPACE :: string＆typeSchema）; string getSQLTypeName（）const; void getSQLTypeName（oracle :: occi :: Environment * env，void ** schemaName，unsigned int＆schemaNameLen，void ** typeName，unsigned int＆typeNameLen）const; CStudent（）; CStudent（void * ctxOCCI_）：MyPerson（ctxOCCI_）{}; static void * readSQL（void * ctxOCCI_）; virtual void readSQL（oracle :: occi :: AnyData＆streamOCCI_）; static void writeSQL（void * objOCCI_，void * ctxOCCI_）; virtual void writeSQL（oracle :: occi :: AnyData＆streamOCCI_）; 〜CStudent（）; }; / *对MyFullName类生成的文件* / / *声明所做的更改。* / class MyFullName：public CFullName {public：MyFullName（string first_name，string last_name）; void displayInfo（）; MyFullName（void * ctxOCCI_）; }; // MyAddress类的声明。class MyAddress：public CAddress {public：MyAddress（string state_i，string zip_i）; void displayInfo（）; MyAddress（void * ctxOCCI_）; }; class MyStudent：public CStudent {public：MyStudent（void * ctxOCCI_）; }; / *更改在此结束* / #endif</pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-6E6AA436-1CBB-4571-A738-AEF47FF29598__GUID-D70B55AF-E5B2-4397-8CB2-D6C6E7A2781A">
                     <p class="titleinexample">示例4-17示例OCCI应用程序的demo2.cpp列表</p><pre class="oac_no_warn" dir="ltr">#ifndef DEMO2_ORACLE #include“demo2.h”#endif / * FULLNAME OBJECT TYPE的生成方法实现。 * / OCCI_STD_NAMESPACE :: string CFullName :: getFirst_name（）const {return FIRST_NAME; void CFullName :: setFirst_name（const OCCI_STD_NAMESPACE :: string＆value）{FIRST_NAME = value; } OCCI_STD_NAMESPACE :: string CFullName :: getLast_name（）const {return LAST_NAME; void CFullName :: setLast_name（const OCCI_STD_NAMESPACE :: string＆value）{LAST_NAME = value; } void * CFullName :: operator new（size_t size）{return oracle :: occi :: PObject :: operator new（size）; } void * CFullName :: operator new（size_t size，const oracle :: occi :: Connection * sess，const OCCI_STD_NAMESPACE :: string＆table）{return oracle :: occi :: PObject :: operator new（size，sess，table， （char *）“HR.FULLNAME”）; } void * CFullName :: operator new（size_t size，void * ctxOCCI_）{return oracle :: occi :: PObject :: operator new（size，ctxOCCI_）; } void * CFullName :: operator new（size_t size，const oracle :: occi :: Connection * sess，const OCCI_STD_NAMESPACE :: string＆tableName，const OCCI_STD_NAMESPACE :: string＆typeName，const OCCI_STD_NAMESPACE :: string＆tableSchema，const OCCI_STD_NAMESPACE :: string＆typeSchema ）{return oracle :: occi :: PObject :: operator new（size，sess，tableName，typeName，tableSchema，typeSchema）; } OCCI_STD_NAMESPACE :: string CFullName :: getSQLTypeName（）const {return OCCI_STD_NAMESPACE :: string（“HR.FULLNAME”）; void CFullName :: getSQLTypeName（oracle :: occi :: Environment * env，void ** schemaName，unsigned int＆schemaNameLen，void ** typeName，unsigned int＆typeNameLen）const {PObject :: getSQLTypeName（env，＆CFullName :: readSQL，schemaName ，schemaNameLen，typeName，typeNameLen）; } CFullName :: CFullName（）{} void * CFullName :: readSQL（void * ctxOCCI_）{MyFullName * objOCCI_ = new（ctxOCCI_）MyFullName（ctxOCCI_）; oracle :: occi :: AnyData streamOCCI_（ctxOCCI_）; try {if（streamOCCI_.isNull（））objOCCI _-&gt; setNull（）; else objOCCI _-&gt; readSQL（streamOCCI_）; } catch（oracle :: occi :: SQLException＆excep）{delete objOCCI_; excep.setErrorCtx（ctxOCCI_）; return（void *）NULL; } return（void *）objOCCI_; void CFullName :: readSQL（oracle :: occi :: AnyData＆streamOCCI_）{FIRST_NAME = streamOCCI_.getString（）; LAST_NAME = streamOCCI_.getString（）; void CFullName :: writeSQL（void * objectOCCI_，void * ctxOCCI _）{CFullName * objOCCI_ =（CFullName *）objectOCCI_; oracle :: occi :: AnyData streamOCCI_（ctxOCCI_）; try {if（objOCCI _-&gt; isNull（））streamOCCI_.setNull（）; else objOCCI _-&gt; writeSQL（streamOCCI_）; } catch（oracle :: occi :: SQLException＆excep）{excep.setErrorCtx（ctxOCCI_）; } return; void CFullName :: writeSQL（oracle :: occi :: AnyData＆streamOCCI_）{streamOCCI_.setString（FIRST_NAME）; streamOCCI_.setString（LAST_NAME）; } CFullName :: ~CFullName（）{int i; } / *地址对象类型的生成方法实现。 * / OCCI_STD_NAMESPACE :: string CAddress :: getState（）const {return STATE; void CAddress :: setState（const OCCI_STD_NAMESPACE :: string＆value）{STATE = value; } OCCI_STD_NAMESPACE :: string CAddress :: getZip（）const {return ZIP; void CAddress :: setZip（const OCCI_STD_NAMESPACE :: string＆value）{ZIP = value; } void * CAddress :: operator new（size_t size）{return oracle :: occi :: PObject :: operator new（size）; } void * CAddress :: operator new（size_t size，const oracle :: occi :: Connection * sess，const OCCI_STD_NAMESPACE :: string＆table）{return oracle :: occi :: PObject :: operator new（size，sess，table， （char *）“HR.ADDRESS”）; } void * CAddress :: operator new（size_t size，void * ctxOCCI_）{return oracle :: occi :: PObject :: operator new（size，ctxOCCI_）; } void * CAddress :: operator new（size_t size，const oracle :: occi :: Connection * sess，const OCCI_STD_NAMESPACE :: string＆tableName，const OCCI_STD_NAMESPACE :: string＆typeName，const OCCI_STD_NAMESPACE :: string＆tableSchema，const OCCI_STD_NAMESPACE :: string＆typeSchema ）{return oracle :: occi :: PObject :: operator new（size，sess，tableName，typeName，tableSchema，typeSchema）; } OCCI_STD_NAMESPACE :: string CAddress :: getSQLTypeName（）const {return OCCI_STD_NAMESPACE :: string（“HR.ADDRESS”）; void CAddress :: getSQLTypeName（oracle :: occi :: Environment * env，void ** schemaName，unsigned int＆schemaNameLen，void ** typeName，unsigned int＆typeNameLen）const {PObject :: getSQLTypeName（env，＆CAddress :: readSQL，schemaName ，schemaNameLen，typeName，typeNameLen）; } CAddress :: CAddress（）{} void * CAddress :: readSQL（void * ctxOCCI_）{MyAddress * objOCCI_ = new（ctxOCCI_）MyAddress（ctxOCCI_）; oracle :: occi :: AnyData streamOCCI_（ctxOCCI_）; try {if（streamOCCI_.isNull（））objOCCI _-&gt; setNull（）; else objOCCI _-&gt; readSQL（streamOCCI_）; } catch（oracle :: occi :: SQLException＆excep）{delete objOCCI_; excep.setErrorCtx（ctxOCCI_）; return（void *）NULL; } return（void *）objOCCI_; void CAddress :: readSQL（oracle :: occi :: AnyData＆streamOCCI_）{STATE = streamOCCI_.getString（）; ZIP = streamOCCI_.getString（）; void CAddress :: writeSQL（void * objectOCCI_，void * ctxOCCI_）{CAddress * objOCCI_ =（CAddress *）objectOCCI_; oracle :: occi :: AnyData streamOCCI_（ctxOCCI_）; try {if（objOCCI _-&gt; isNull（））streamOCCI_.setNull（）; else objOCCI _-&gt; writeSQL（streamOCCI_）; } catch（oracle :: occi :: SQLException＆excep）{excep.setErrorCtx（ctxOCCI_）; } return; void CAddress :: writeSQL（oracle :: occi :: AnyData＆streamOCCI_）{streamOCCI_.setString（STATE）; streamOCCI_.setString（ZIP）; CAddress :: ~CAddress（）{int i; } / *生成对象类型的方法实现。 * / oracle :: occi :: Number CPerson :: getId（）const {return ID; void CPerson :: setId（const oracle :: occi :: Number＆value）{ID = value; } MyFullName * CPerson :: getName（）const {return NAME; } void CPerson :: setName（MyFullName * value）{NAME = value; } oracle :: occi :: Ref &lt;MyAddress&gt; CPerson :: getCurr_addr（）const {return CURR_ADDR; void CPerson :: setCurr_addr（const oracle :: occi :: Ref &lt;MyAddress&gt;＆value）{CURR_ADDR = value; } OCCI_STD_NAMESPACE :: vector &lt;oracle :: occi :: Ref &lt;MyAddress &gt;&gt;＆CPerson :: getPrev_addr_l（）{return PREV_ADDR_L; } const OCCI_STD_NAMESPACE :: vector &lt;oracle :: occi :: Ref &lt;MyAddress &gt;&gt;＆CPerson :: getPrev_addr_l（）const {return PREV_ADDR_L; void CPerson :: setPrev_addr_l（const OCCI_STD_NAMESPACE :: vector &lt;oracle :: occi :: Ref &lt;MyAddress &gt;&gt;＆value）{PREV_ADDR_L = value; } void * CPerson :: operator new（size_t size）{return oracle :: occi :: PObject :: operator new（size）; } void * CPerson :: operator new（size_t size，const oracle :: occi :: Connection * sess，const OCCI_STD_NAMESPACE :: string＆table）{return oracle :: occi :: PObject :: operator new（size，sess，table， （char *）“HR.PERSON”）; } void * CPerson :: operator new（size_t size，void * ctxOCCI_）{return oracle :: occi :: PObject :: operator new（size，ctxOCCI_）; } void * CPerson :: operator new（size_t size，const oracle :: occi :: Connection * sess，const OCCI_STD_NAMESPACE :: string＆tableName，const OCCI_STD_NAMESPACE :: string＆typeName，const OCCI_STD_NAMESPACE :: string＆tableSchema，const OCCI_STD_NAMESPACE :: string＆typeSchema ）{return oracle :: occi :: PObject :: operator new（size，sess，tableName，typeName，tableSchema，typeSchema）; } OCCI_STD_NAMESPACE :: string CPerson :: getSQLTypeName（）const {return OCCI_STD_NAMESPACE :: string（“HR.PERSON”）; void CPerson :: getSQLTypeName（oracle :: occi :: Environment * env，void ** schemaName，unsigned int＆schemaNameLen，void ** typeName，unsigned int＆typeNameLen）const {PObject :: getSQLTypeName（env，＆CPerson :: readSQL，schemaName ，schemaNameLen，typeName，typeNameLen）; } CPerson :: CPerson（）{NAME =（MyFullName *）0; } void * CPerson :: readSQL（void * ctxOCCI_）{MyPerson * objOCCI_ = new（ctxOCCI_）MyPerson（ctxOCCI_）; oracle :: occi :: AnyData streamOCCI_（ctxOCCI_）; try {if（streamOCCI_.isNull（））objOCCI _-&gt; setNull（）; else objOCCI _-&gt; readSQL（streamOCCI_）; } catch（oracle :: occi :: SQLException＆excep）{delete objOCCI_; excep.setErrorCtx（ctxOCCI_）; return（void *）NULL; } return（void *）objOCCI_; void CPerson :: readSQL（oracle :: occi :: AnyData＆streamOCCI_）{ID = streamOCCI_.getNumber（）; NAME =（MyFullName *）streamOCCI_.getObject（＆MyFullName :: readSQL）; CURR_ADDR = streamOCCI_.getRef（）; oracle :: occi :: getVectorOfRefs（streamOCCI_，PREV_ADDR_L）; void CPerson :: writeSQL（void * objectOCCI_，void * ctxOCCI_）{CPerson * objOCCI_ =（CPerson *）objectOCCI_; oracle :: occi :: AnyData streamOCCI_（ctxOCCI_）; try {if（objOCCI _-&gt; isNull（））streamOCCI_.setNull（）; else objOCCI _-&gt; writeSQL（streamOCCI_）; } catch（oracle :: occi :: SQLException＆excep）{excep.setErrorCtx（ctxOCCI_）; } return; void CPerson :: writeSQL（oracle :: occi :: AnyData＆streamOCCI_）{streamOCCI_.setNumber（ID）; streamOCCI_.setObject（NAME）; streamOCCI_.setRef（CURR_ADDR）; oracle :: occi :: setVectorOfRefs（streamOCCI_，PREV_ADDR_L）; } CPerson :: ~CPerson（）{int i;删除NAME; } / *生成对象类型的生成方法实现。 * / OCCI_STD_NAMESPACE :: string CStudent :: getSchool_name（）const {return SCHOOL_NAME; void CStudent :: setSchool_name（const OCCI_STD_NAMESPACE :: string＆value）{SCHOOL_NAME = value; } void * CStudent :: operator new（size_t size）{return oracle :: occi :: PObject :: operator new（size）; } void * CStudent :: operator new（size_t size，const oracle :: occi :: Connection * sess，const OCCI_STD_NAMESPACE :: string＆table）{return oracle :: occi :: PObject :: operator new（size，sess，table， （char *）“HR.STUDENT”）; } void * CStudent :: operator new（size_t size，void * ctxOCCI_）{return oracle :: occi :: PObject :: operator new（size，ctxOCCI_）; } void * CStudent :: operator new（size_t size，const oracle :: occi :: Connection * sess，const OCCI_STD_NAMESPACE :: string＆tableName，const OCCI_STD_NAMESPACE :: string＆typeName，const OCCI_STD_NAMESPACE :: string＆tableSchema，const OCCI_STD_NAMESPACE :: string＆typeSchema ）{return oracle :: occi :: PObject :: operator new（size，sess，tableName，typeName，tableSchema，typeSchema）; } OCCI_STD_NAMESPACE :: string CStudent :: getSQLTypeName（）const {return OCCI_STD_NAMESPACE :: string（“HR.STUDENT”）; void CStudent :: getSQLTypeName（oracle :: occi :: Environment * env，void ** schemaName，unsigned int＆schemaNameLen，void ** typeName，unsigned int＆typeNameLen）const {PObject :: getSQLTypeName（env，＆CStudent :: readSQL，schemaName） ，schemaNameLen，typeName，typeNameLen）; } CStudent :: CStudent（）{} void * CStudent :: readSQL（void * ctxOCCI_）{MyStudent * objOCCI_ = new（ctxOCCI_）MyStudent（ctxOCCI_）; oracle :: occi :: AnyData streamOCCI_（ctxOCCI_）; try {if（streamOCCI_.isNull（））objOCCI _-&gt; setNull（）; else objOCCI _-&gt; readSQL（streamOCCI_）; } catch（oracle :: occi :: SQLException＆excep）{delete objOCCI_; excep.setErrorCtx（ctxOCCI_）; return（void *）NULL; } return（void *）objOCCI_; void CStudent :: readSQL（oracle :: occi :: AnyData＆streamOCCI_）{CPerson :: readSQL（streamOCCI_）; SCHOOL_NAME = streamOCCI_.getString（）; void CStudent :: writeSQL（void * objectOCCI_，void * ctxOCCI_）{CStudent * objOCCI_ =（CStudent *）objectOCCI_; oracle :: occi :: AnyData streamOCCI_（ctxOCCI_）; try {if（objOCCI _-&gt; isNull（））streamOCCI_.setNull（）; else objOCCI _-&gt; writeSQL（streamOCCI_）; } catch（oracle :: occi :: SQLException＆excep）{excep.setErrorCtx（ctxOCCI_）; } return; void CStudent :: writeSQL（oracle :: occi :: AnyData＆streamOCCI_）{CPerson :: writeSQL（streamOCCI_）; streamOCCI_.setString（SCHOOL_NAME）; } CStudent :: ~CStudent（）{int i; }</pre></div>
                  <!-- class="example" -->
                  <div class="section">
                     <p>让我们假设OTT在<code class="codeph">demo2.h</code>生成<code class="codeph">FULL_NAME</code> ， <code class="codeph">ADDRSESS</code> ， <code class="codeph">PERSON</code>和<code class="codeph">PFGRFDENT</code>类声明。以下示例OCCI应用程序扩展了OTT生成的类，如<a href="object-programming.html#GUID-6E6AA436-1CBB-4571-A738-AEF47FF29598__CIHEEFFI">示例4-12</a>中的<code class="codeph">demo2.typ</code>文件中所指定，并添加了一些用户定义的方法。请注意，这些类声明已合并到<code class="codeph">demo2.h</code>以确保正确编译。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-6E6AA436-1CBB-4571-A738-AEF47FF29598__GUID-D9279E5A-488D-4B76-9AD8-1DC4BA3156CF">
                     <p class="titleinexample">示例4-18示例OCCI应用程序的myDemo.h列表</p><pre class="oac_no_warn" dir="ltr">#ifndef MYDEMO_ORACLE #define MYDEMO_ORACLE #include &lt;string&gt; #ifndef DEMO2_ORACLE #include &lt;demo2.h&gt; #endif using namespace std; using namespace oracle :: occi; // MyFullName类的声明。class MyFullName：public CFullName {public：MyFullName（string first_name，string last_name）; void displayInfo（）; }; // MyAddress类的声明。class MyAddress：public CAddress {public：MyAddress（string state_i，string zip_i）; void displayInfo（）; }; // MyPerson类的声明。class MyPerson：public CPerson {public：MyPerson（Number id_i，MyFullname * name_i，const Ref &lt;MyAddress&gt;＆addr_i）; void move（const Ref &lt;MyAddress&gt;＆new_addr）; void displayInfo（）; }; ＃万一</pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-6E6AA436-1CBB-4571-A738-AEF47FF29598__GUID-6D956542-265C-4643-A9F1-3F7723419839">
                     <p class="titleinexample">示例4-19示例OCCI应用程序的myDemo.cpp列表</p><pre class="oac_no_warn" dir="ltr">#ifndef DEMO2_ORACLE #include &lt;demo2.h&gt; #endif using namespace std; / * initialize MyFullName * / MyFullName :: MyFullName（string first_name，string last_name）{setFirst_name（first_name）; setLast_name（姓氏）; } / *显示MyFullName中的所有信息* / void MyFullName :: displayInfo（）{cout &lt;&lt;“FIRST NAME is”&lt;&lt; getFirst_name（）&lt;&lt; endl; cout &lt;&lt;“最后一个名字是”&lt;&lt; getLast_name（）&lt;&lt; endl; MyFullName :: MyFullName（void * ctxOCCI _）：CFullName（ctxOCCI_）{} / * MyAddress CLASS的方法实现。 * / / *初始化MyAddress * / MyAddress :: MyAddress（字符串state_i，字符串zip_i）{setState（state_i）; setZip（zip_i）; } / *显示MyAddress中的所有信息* / void MyAddress :: displayInfo（）{cout &lt;&lt;“STATE is”&lt;&lt; getState（）&lt;&lt; endl; cout &lt;&lt;“ZIP is”&lt;&lt; getZip（）&lt;&lt; endl; MyAddress :: MyAddress（void * ctxOCCI_）：CAddress（ctxOCCI_）{} / * MyPerson CLASS的方法实现。 * / / *初始化MyPerson * / MyPerson :: MyPerson（Number id_i，MyFullName * name_i，const Ref &lt;MyAddress&gt;＆addr_i）{setId（id_i）;的setName（name_i）; setCurr_addr（ADDR_i区域）; } MyPerson :: MyPerson（void * ctxOCCI_）：CPerson（ctxOCCI_）{} / *将人从curr_addr移动到new_addr * / void MyPerson :: move（const Ref &lt;MyAddress&gt;＆new_addr）{//将curr_addr附加到向量/ / getPrev_addr_l（）。push_back（getCurr_addr（））; setCurr_addr（new_addr）; //将对象标记为脏this-&gt; markModified（）; } / *显示MyPerson的所有信息* / void MyPerson :: displayInfo（）{cout &lt;&lt;“ID is”&lt;&lt;（int）getId（）&lt;&lt; endl;的getName（） - &gt; displayInfo（）; //使用 - &gt;运算符getCurr_addr（） - &gt; displayInfo（）;取消引用Ref属性; cout &lt;&lt;“Prev Addr List：”&lt;&lt; endl; for（int i = 0; i &lt;getPrev_addr_l（）。size（）; i ++）{//使用[]运算符访问集合元素（getPrev_addr_l（））[i]  - &gt; displayInfo（）; MyPerson :: MyPerson（）{} MyStudent :: MyStudent（void * ctxOCCI_）：CStudent（ctxOCCI_）{}</pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-6E6AA436-1CBB-4571-A738-AEF47FF29598__GUID-8822A641-749E-498E-8111-12B519060507">
                     <p class="titleinexample">示例4-20示例OCCI应用程序的main.cpp列表</p><pre class="oac_no_warn" dir="ltr">#ifndef DEMO2_ORACLE #include &lt;demo2.h&gt; #endif #ifndef MAPPINGS_ORACLE #include &lt;mappings.h&gt; #endif #include &lt;iostream&gt; using namespace std;使用namespace :: oracle; int main（）{Environment * env = Environment :: createEnvironment（Environment :: OBJECT）;映射（ENV）;尝试{Connection * conn = Connection（“HR”， <span class="italic">“password</span> ”）; / *调用OTT生成的函数来注册映射* / / *在数据库表中创建ADDRESS类型的持久对象，ADDR_TAB * / MyAddress * addr1 = new（conn，“ADDR_TAB”）MyAddress（“CA”，“94065 “）; conn-&gt;提交（）; Statement * st = conn-&gt; createStatement（“从addr_tab a中选择ref（a）”）; ResultSet * rs = st-&gt; executeQuery（）;参考&lt;MyAddress&gt; r1; if（rs-&gt; next（））r1 = rs-&gt; getRef（1）; ST-&gt; closeResultSet（RS）; conn-&gt; terminateStatement（ST）; MyFullName * name1 = new MyFullName（“Joe”，“Black”）; / *在数据库表中创建Person类型的持久对象PERSON_TAB * / MyPerson * person1 = new（conn，“PERSON_TAB”）MyPerson（1，name1，r1）; conn-&gt;提交（）; / *选择插入的信息* / Statement * stmt = conn-&gt; createStatement（）; ResultSet * resultSet = stmt-&gt; executeQuery（“SELECT_F（a）from person_tab a where id = 1”）; if（resultSet-&gt; next（））{Ref &lt;MyPerson&gt; joe_ref =（Ref &lt;MyPerson&gt;）resultSet-&gt; getRef（1）; joe_ref-&gt; displayInfo（）; / *在数据库表中创建ADDRESS类型的持久对象ADDR_TAB * / MyAddress * new_addr1 = new（conn，“ADDR_TAB”）MyAddress（“PA”，“92140”）; joe_ref-&gt;移动（new_addr1-&gt; getRef（））; joe_ref-&gt; displayInfo（）; } / *提交导致新创建的对象new_addr的事务，并将脏对象joe刷新到服务器。请注意，joe在move（）中标记为脏。* / conn-&gt; commit（）; conn-&gt; terminateStatement（语句）; env-&gt; terminateConnection（conn）;在} catch（exception＆x）{cout &lt;&lt; x.what（）&lt;&lt; endl; } Environment :: terminateEnvironment（env）;返回0; }</pre></div>
                  <!-- class="example" -->
               </div>
            </div>
         </div>
      </article>
   </body>
</html>