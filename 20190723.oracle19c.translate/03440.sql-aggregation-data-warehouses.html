<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <title>用于数据仓库中的聚合的SQL</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Data Warehousing Guide"></meta>
      <meta property="og:description" content=""></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Data Warehousing Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="database-data-warehousing-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-09T00:20:13-08:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="2001, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96243-01"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="sql-analysis-reporting-data-warehouses.html" title="Previous" type="text/html"></link>
      <link rel="next" href="sql-pattern-matching-data-warehouses.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Database Data Warehousing Guide"></meta>
    <meta name="dcterms.isVersionOf" content="DWHSG"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="sql-analysis-reporting-data-warehouses.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="sql-pattern-matching-data-warehouses.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">数据仓库指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="part-relational-analytics.html" property="item" typeof="WebPage"><span property="name">关系分析</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">用于数据仓库中的聚合的SQL</li>
            </ol>
            <a id="GUID-E051A04E-0C53-491D-9B16-B71BA00B80C2" name="GUID-E051A04E-0C53-491D-9B16-B71BA00B80C2"></a>
            
            <h2 id="DWHSG-GUID-E051A04E-0C53-491D-9B16-B71BA00B80C2" class="sect2"><span class="enumeration_chapter">20</span> SQL用于数据仓库中的聚合</h2>
         </header>
         <div class="ind">
            <div>
               <p>本章讨论SQL的聚合，这是数据仓库的一个基本方面。它包含以下主题：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="sql-aggregation-data-warehouses.html#GUID-72549B30-5BB7-42E6-A910-5716CB1713EA">数据仓库中聚合的SQL概述</a></p>
                  </li>
                  <li>
                     <p><a href="sql-aggregation-data-warehouses.html#GUID-01BBD582-E149-47D7-A4F8-F50C1AAC66AA">ROLLUP扩展到GROUP BY</a></p>
                  </li>
                  <li>
                     <p><a href="sql-aggregation-data-warehouses.html#GUID-C5FDD050-DCE0-4FE1-9741-420E2F970A36">CUBE扩展到GROUP BY</a></p>
                  </li>
                  <li>
                     <p><a href="sql-aggregation-data-warehouses.html#GUID-E4251C0F-8AD7-4826-BE35-845E5CE6C818">分组功能</a></p>
                  </li>
                  <li>
                     <p><a href="sql-aggregation-data-warehouses.html#GUID-166E1BFC-51C6-4BB5-B10B-A8EB63472E49">分组集表达式</a></p>
                  </li>
                  <li>
                     <p><a href="sql-aggregation-data-warehouses.html#GUID-FC174F30-F8AA-4169-A6E0-68CF3DD60DF4">关于复合列和分组</a></p>
                  </li>
                  <li>
                     <p><a href="sql-aggregation-data-warehouses.html#GUID-75B860E5-3AE6-4E62-8837-A4497D8207CF">连锁分组和数据聚合</a></p>
                  </li>
                  <li>
                     <p><a href="sql-aggregation-data-warehouses.html#GUID-F33D5E19-33B8-424F-A717-D30EDA3D08D6">在数据仓库中使用聚合时的注意事项</a></p>
                  </li>
                  <li>
                     <p><a href="sql-aggregation-data-warehouses.html#GUID-9D821BF6-A3A0-43BC-9C90-C476734E5905">使用WITH子句计算</a></p>
                  </li>
                  <li>
                     <p><a href="sql-aggregation-data-warehouses.html#GUID-FB000241-BE8E-43F4-9789-24A0472AB193">在SQL中使用分层多维数据集</a></p>
                  </li>
               </ul>
            </div><a id="DWHSG8600"></a><div class="props_rev_3"><a id="GUID-72549B30-5BB7-42E6-A910-5716CB1713EA" name="GUID-72549B30-5BB7-42E6-A910-5716CB1713EA"></a><h3 id="DWHSG-GUID-72549B30-5BB7-42E6-A910-5716CB1713EA" class="sect3"><span class="enumeration_section">20.1</span>数据仓库中聚合的SQL概述</h3>
               <div>
                  <p>聚合是数据仓库的基础部分。为了提高仓库中的聚合性能，Oracle数据库提供以下功能：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><code class="codeph">GROUP</code> <code class="codeph">BY</code>子句的<code class="codeph">CUBE</code>和<code class="codeph">ROLLUP</code>扩展</p>
                     </li>
                     <li>
                        <p>三个<code class="codeph">GROUPING</code>功能</p>
                     </li>
                     <li>
                        <p><code class="codeph">GROUPING</code> <code class="codeph">SETS</code>表达式</p>
                     </li>
                     <li>
                        <p>透视操作</p>
                     </li>
                  </ul>
                  <p>SQL的<code class="codeph">CUBE</code> ， <code class="codeph">ROLLUP</code>和<code class="codeph">GROUPING</code> <code class="codeph">SETS</code>扩展使查询和报告更容易，更快捷。<code class="codeph">CUBE</code> ， <code class="codeph">ROLLUP</code>和分组集生成单个结果集，该结果集等同于<code class="codeph">UNION</code> <code class="codeph">ALL</code>的不同分组行。<code class="codeph">ROLLUP</code>在增加的聚合级别（从最详细到总计）计算聚合，例如<code class="codeph">SUM</code> ， <code class="codeph">COUNT</code> ， <code class="codeph">MAX</code> ， <code class="codeph">MIN</code>和<code class="codeph">AVG</code> 。<code class="codeph">CUBE</code>是类似于<code class="codeph">ROLLUP</code>的扩展，允许单个语句计算所有可能的聚合组合。<code class="codeph">CUBE</code> ， <code class="codeph">ROLLUP</code>和<code class="codeph">GROUPING</code> <code class="codeph">SETS</code>扩展允许您仅指定<code class="codeph">GROUP</code> <code class="codeph">BY</code>子句中所需的分组。这允许跨多个维度有效的分析而不执行<code class="codeph">CUBE</code>操作。计算<code class="codeph">CUBE</code>会产生繁重的处理负载，因此使用分组集替换多维数据集可以显着提高性能。
                  </p>
                  <p>为了提高性能，可以并行化<code class="codeph">CUBE</code> ， <code class="codeph">ROLLUP</code>和<code class="codeph">GROUPING</code> <code class="codeph">SETS</code> ：多个进程可以同时执行所有这些语句。这些功能使聚合计算更有效，从而提高了数据库性能和可伸缩性。
                  </p>
                  <p>三个<code class="codeph">GROUPING</code>函数可帮助您识别每行所属的组，并启用排序小计行和过滤结果。
                  </p>
                  <p>本节包含以下主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="sql-aggregation-data-warehouses.html#GUID-CA29BB5D-90F5-4DCC-A0B4-99738E9C95D5">关于跨多个维度的分析</a></p>
                     </li>
                     <li>
                        <p><a href="sql-aggregation-data-warehouses.html#GUID-C70DDA78-57D4-480A-AFDD-33EDFC1C15AE">关于优化聚合性能</a></p>
                     </li>
                     <li>
                        <p><a href="sql-aggregation-data-warehouses.html#GUID-8BD77311-23F9-4400-9D36-323326C73597">数据仓库：聚合方案</a></p>
                     </li>
                  </ul>
               </div><a id="DWHSG8602"></a><a id="DWHSG8601"></a><div class="props_rev_3"><a id="GUID-CA29BB5D-90F5-4DCC-A0B4-99738E9C95D5" name="GUID-CA29BB5D-90F5-4DCC-A0B4-99738E9C95D5"></a><h4 id="DWHSG-GUID-CA29BB5D-90F5-4DCC-A0B4-99738E9C95D5" class="sect4"><span class="enumeration_section">20.1.1</span>关于跨多维分析</h4>
                  <div>
                     <p><a id="d74861e261" class="indexterm-anchor"></a><a id="d74861e265" class="indexterm-anchor"></a>决策支持系统的关键概念之一是多维分析：从所有必要的维度组合中检查企业。术语<a href="glossary.html#GUID-51168741-F40B-41B8-83DE-F159BEB2DE75"><span class="xrefglossterm">维度</span></a>用于表示用于指定问题的任何类别。最常见的维度包括时间，地理，产品，部门和分销渠道，但潜在的维度与企业活动的多样性一样无穷无尽。与特定维度值集相关联的事件或实体通常称为事实。事实可能是以单位或当地货币，利润，客户数量，产量或任何其他值得追踪的销售额。
                     </p>
                     <p>以下是多维请求的一些示例：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>显示所有产品的总销售额，从1999年到2000年，从一个州到另一个国家/地区，地理范围的聚合级别不断增加。</p>
                        </li>
                        <li>
                           <p>对我们的业务进行跨表格分析，显示1999年和2000年南美洲地区的开支。包括所有可能的小计。</p>
                        </li>
                        <li>
                           <p>根据2000年汽车产品销售收入列出亚洲十大销售代表，并对其佣金进行排名。</p>
                        </li>
                     </ul>
                     <p>所有这些要求涉及多个方面。许多多维问题需要汇总数据和数据集比较，通常跨时间，地理或预算。</p>
                     <p>为了可视化具有多个维度的数据，分析人员通常使用数据立方体的类比，即事实存储在n维交叉处的空间。<a href="sql-aggregation-data-warehouses.html#GUID-CA29BB5D-90F5-4DCC-A0B4-99738E9C95D5__I1012453">图20-1</a>显示了一个数据立方体以及各种组如何以不同方式使用它。多维数据集存储按产品，市场，销售和时间维度组织的销售数据。请注意，这只是一个比喻：实际数据实际存储在普通表中。多维数据集数据由详细信息和聚合数据组成。
                     </p>
                     <div class="figure" id="GUID-CA29BB5D-90F5-4DCC-A0B4-99738E9C95D5__I1012453">
                        <p class="titleinfigure">图20-1不同用户的逻辑多维数据集和视图</p><img src="img/dwhsg087.gif" alt="下面是图20-1的描述" title="下面是图20-1的描述" longdesc="img_text/dwhsg087.html"><br><a href="img_text/dwhsg087.html">“图20-1不同用户的逻辑立方体和视图”的描述</a></div>
                     <!-- class="figure" -->
                     <p>您可以从多维数据集中检索数据切片。这些对应于跨表格报告，如<a href="sql-aggregation-data-warehouses.html#GUID-8BD77311-23F9-4400-9D36-323326C73597__G1014032" title="这说明了一个带小计的简单交叉表格报告">表20-1中</a>所示。区域经理可以通过比较适用于不同市场的立方体切片来研究数据。相比之下，产品经理可能会比较适用于不同产品的切片。临时用户可能在子集多维数据集中使用各种约束。
                     </p>
                     <p>回答多维问题通常涉及访问和查询大量数据，有时数百万行。由于大型组织生成的大量详细数据无法在最低级别进行解释，因此信息的汇总视图至关重要。多维度的汇总（例如总和和计数）对于多维分析至关重要。因此，分析任务需要方便有效的数据聚合。</p>
                  </div>
               </div><a id="DWHSG8603"></a><div class="props_rev_3"><a id="GUID-C70DDA78-57D4-480A-AFDD-33EDFC1C15AE" name="GUID-C70DDA78-57D4-480A-AFDD-33EDFC1C15AE"></a><h4 id="DWHSG-GUID-C70DDA78-57D4-480A-AFDD-33EDFC1C15AE" class="sect4"><span class="enumeration_section">20.1.2</span>关于优化聚合性能</h4>
                  <div>
                     <p>不仅是多维问题，而且所有类型的处理都可以从增强的聚合设施中受益。交易处理，财务和制造系统 - 所有这些都会产生大量需要大量系统资源的生产报告。创建这些报告时提高效率将减少系统负载。事实上，任何将数据从细节聚合到更高级别的计算机进程都将受益于优化的聚合性能。</p>
                     <p>这些扩展提供聚合功能并带来许多好处，包括：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>简化的编程需要较少的SQL代码来完成许多任务。</p>
                        </li>
                        <li>
                           <p>更快，更高效的查询处理。</p>
                        </li>
                        <li>
                           <p>减少客户端处理负载和网络流量，因为聚合工作转移到服务器。</p>
                        </li>
                        <li>
                           <p>缓存聚合的机会，因为类似的查询可以利用现有的工作。</p>
                        </li>
                     </ul>
                  </div>
               </div><a id="DWHSG8606"></a><a id="DWHSG8604"></a><div class="props_rev_3"><a id="GUID-8BD77311-23F9-4400-9D36-323326C73597" name="GUID-8BD77311-23F9-4400-9D36-323326C73597"></a><h4 id="DWHSG-GUID-8BD77311-23F9-4400-9D36-323326C73597" class="sect4"><span class="enumeration_section">20.1.3</span>数据仓库：聚合场景</h4>
                  <div>
                     <p>为了说明<code class="codeph">GROUP</code> <code class="codeph">BY</code>扩展的使用，本章使用示例模式的<code class="codeph">sh</code>数据。所有示例均引用此方案中的数据。这家假想的公司在全球范围内销售，并通过美元和数量信息跟踪销售情况。由于存在许多行数据，因此此处显示的查询通常对其<code class="codeph">WHERE</code>子句具有严格限制，以将结果限制为少量行。
                     </p>
                     <p><a href="sql-aggregation-data-warehouses.html#GUID-8BD77311-23F9-4400-9D36-323326C73597__G1014032" title="这说明了一个带小计的简单交叉表格报告">表20-1</a>是一个跨表格的报告示例，显示了2000年9月美国和法国通过互联网和直接销售的<code class="codeph">country_id</code>和<code class="codeph">channel_desc</code>的总销售额。
                     </p>
                     <div class="tblformal" id="GUID-8BD77311-23F9-4400-9D36-323326C73597__G1014032">
                        <p class="titleintable">表20-1带小计的简单跨表报告</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="带小计的简单跨表报告" width="100%" border="1" summary="This illustrates a simple cross-tabular report with subtotals" frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="19%" id="d74861e403">渠道</th>
                                 <th align="left" valign="bottom" width="29%" id="d74861e406">法国</th>
                                 <th align="left" valign="bottom" width="26%" id="d74861e409">我们</th>
                                 <th align="left" valign="bottom" width="26%" id="d74861e411">总</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="19%" id="d74861e415" headers="d74861e403 ">
                                    <p>互联网</p>
                                 </td>
                                 <td align="left" valign="top" width="29%" headers="d74861e415 d74861e406 ">
                                    <p>9597</p>
                                 </td>
                                 <td align="left" valign="top" width="26%" headers="d74861e415 d74861e409 ">
                                    <p>124,224</p>
                                 </td>
                                 <td align="left" valign="top" width="26%" headers="d74861e415 d74861e411 ">
                                    <p>133821</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="19%" id="d74861e428" headers="d74861e403 ">
                                    <p>直销</p>
                                 </td>
                                 <td align="left" valign="top" width="29%" headers="d74861e428 d74861e406 ">
                                    <p>61202</p>
                                 </td>
                                 <td align="left" valign="top" width="26%" headers="d74861e428 d74861e409 ">
                                    <p>638201</p>
                                 </td>
                                 <td align="left" valign="top" width="26%" headers="d74861e428 d74861e411 ">
                                    <p>699403</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="19%" id="d74861e441" headers="d74861e403 ">
                                    <p>总</p>
                                 </td>
                                 <td align="left" valign="top" width="29%" headers="d74861e441 d74861e406 ">
                                    <p>70799</p>
                                 </td>
                                 <td align="left" valign="top" width="26%" headers="d74861e441 d74861e409 ">
                                    <p>762425</p>
                                 </td>
                                 <td align="left" valign="top" width="26%" headers="d74861e441 d74861e411 ">
                                    <p>833224</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <p>考虑一下，即使像这样的简单报告，其网格中只有九个值，也会生成四个小计和总计。此报告所需的一半值不会使用请求<code class="codeph">SUM(amount_sold)</code>的查询计算并执行<code class="codeph">GROUP BY(channel_desc, country_id)</code> 。要获得更高级别的聚合，需要额外的查询。提供改进的小计计算的数据库命令为查询，报告和分析操作带来了重大好处。
                     </p><pre class="oac_no_warn" dir="ltr">SELECT channels.channel_desc，countries.country_iso_code，TO_CHAR（SUM（amount_sold），'9,999,999,999'）SALES $ FROM sales，customers，times，channels，countries WHERE sales.time_id = times.time_id AND sales.cust_id = customers.cust_id AND sales .channel_id = channels.channel_id AND channels.channel_desc IN（'Direct Sales'，'Internet'）AND times.calendar_month_desc ='2000-09'AND customers.country_id = countries.country_id AND countries.country_iso_code IN（'US'，' FR'）GROUP BY CUBE（channels.channel_desc，countries.country_iso_code）; CHANNEL_DESC CO SALES $ --------------------  -  -------------- 833,224 FR 70,799 US 762,425 Internet 133,821 Internet FR 9,597互联网美国124,224直接销售699,403直销FR 61,202直接销售US 638,201</pre><div class="section" id="GUID-8BD77311-23F9-4400-9D36-323326C73597__BCGGFFGF">
                        <p class="subhead3" id="GUID-8BD77311-23F9-4400-9D36-323326C73597__GUID-81C494A1-B349-45B5-805A-66C9E8A060BD">解释聚合示例中的NULL</p>
                        <p><code class="codeph">GROUP</code> <code class="codeph">BY</code>扩展返回的<code class="codeph">NULLs</code>并不总是传统的null含义值unknown。相反， <code class="codeph">NULL</code>可以指示其行是小计。为避免在数据库系统中引入另一个非值，这些小计值不会被赋予特殊标记。
                        </p>
                        <div class="infoboxnotealso" id="GUID-8BD77311-23F9-4400-9D36-323326C73597__GUID-0D7BCD80-9637-4142-AD00-433419F965E2">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="sql-aggregation-data-warehouses.html#GUID-E4251C0F-8AD7-4826-BE35-845E5CE6C818">GROUPING函数</a> ，详细说明如何将表示小计的空值与存储在数据中的空值区分开来</p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="DWHSG8608"></a><div class="props_rev_3"><a id="GUID-01BBD582-E149-47D7-A4F8-F50C1AAC66AA" name="GUID-01BBD582-E149-47D7-A4F8-F50C1AAC66AA"></a><h3 id="DWHSG-GUID-01BBD582-E149-47D7-A4F8-F50C1AAC66AA" class="sect3"><span class="enumeration_section">20.2</span> ROLLUP扩展到GROUP BY</h3>
               <div>
                  <div class="section">
                     <p><a id="d74861e506" class="indexterm-anchor"></a> <code class="codeph">ROLLUP</code>使<code class="codeph">SELECT</code>语句能够计算指定维度组的多个小计级别。它还计算总计。<code class="codeph">ROLLUP</code>是<code class="codeph">GROUP</code> <code class="codeph">BY</code>子句的简单扩展，因此其语法非常易于使用。<code class="codeph">ROLLUP</code>扩展非常高效，为查询增加了最小的开销。
                     </p>
                     <p><code class="codeph">ROLLUP</code>的操作很简单：它根据<code class="codeph">ROLLUP</code>子句中指定的分组列表创建从最详细级别汇总到总计的小计。<code class="codeph">ROLLUP</code>将分组列的有序列表作为其参数。首先，它计算<code class="codeph">GROUP</code> <code class="codeph">BY</code>子句中指定的标准聚合值。然后，它会逐步创建更高级别的小计，从右到左通过分组列列表。最后，它创造了一个总计。
                     </p>
                     <p><code class="codeph">ROLLUP</code>在n + 1级创建小计，其中n是分组列的数量。例如，如果查询在对<code class="codeph">time</code> ， <code class="codeph">region</code>和<code class="codeph">department(n=3)</code>列进行分组时指定<code class="codeph">ROLLUP</code> ，则结果集将包括四个聚合级别的行。
                     </p>
                     <p>您可能希望在使用<code class="codeph">ROLLUP</code>时压缩数据。当旧分区的更新很少时，这尤其有用。
                     </p>
                     <p>本节包含以下主题：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="sql-aggregation-data-warehouses.html#GUID-8692A003-526D-4D80-BF73-B81899A91D50">何时使用ROLLUP</a></p>
                        </li>
                        <li>
                           <p><a href="sql-aggregation-data-warehouses.html#GUID-9E931694-4AA8-464A-B8E7-19E568C5BFC8">ROLLUP语法</a></p>
                        </li>
                        <li>
                           <p><a href="sql-aggregation-data-warehouses.html#GUID-60430684-FD7B-4C2A-813A-99769D6E19FE">部分汇总</a></p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
               </div><a id="DWHSG8609"></a><div class="props_rev_3"><a id="GUID-8692A003-526D-4D80-BF73-B81899A91D50" name="GUID-8692A003-526D-4D80-BF73-B81899A91D50"></a><h4 id="DWHSG-GUID-8692A003-526D-4D80-BF73-B81899A91D50" class="sect4"><span class="enumeration_section">20.2.1</span>何时使用ROLLUP</h4>
                  <div>
                     <p><a id="d74861e603" class="indexterm-anchor"></a>在涉及小计的任务中使用<code class="codeph">ROLLUP</code>扩展。
                     </p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>沿着等级维度（如时间或地理位置）进行小计非常有用。例如，查询可以指定<code class="codeph">ROLLUP(y,</code> <code class="codeph">m,</code> <code class="codeph">day)</code>或<code class="codeph">ROLLUP(country,</code> <code class="codeph">state,</code> <code class="codeph">city)</code> 。
                           </p>
                        </li>
                        <li>
                           <p>对于使用汇总表的数据仓库管理员， <code class="codeph">ROLLUP</code>可以简化和加快汇总表的维护。
                           </p>
                        </li>
                     </ul>
                  </div>
               </div><a id="DWHSG8611"></a><a id="DWHSG8610"></a><div class="props_rev_3"><a id="GUID-9E931694-4AA8-464A-B8E7-19E568C5BFC8" name="GUID-9E931694-4AA8-464A-B8E7-19E568C5BFC8"></a><h4 id="DWHSG-GUID-9E931694-4AA8-464A-B8E7-19E568C5BFC8" class="sect4"><span class="enumeration_section">20.2.2</span> ROLLUP语法</h4>
                  <div>
                     <div class="section">
                        <p><code class="codeph">ROLLUP</code>出现在<code class="codeph">SELECT</code>语句的<code class="codeph">GROUP</code> <code class="codeph">BY</code>子句中。它的形式是：</p><pre class="oac_no_warn" dir="ltr">SELECT ... GROUP BY ROLLUP（grouping_column_reference_list）</pre></div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-9E931694-4AA8-464A-B8E7-19E568C5BFC8__GUID-79C48D5E-8013-4A57-BF12-AD30BE658B31">
                        <p class="titleinexample">例20-1 ROLLUP</p>
                        <p>此示例使用<code class="codeph">sh</code>示例架构数据中的数据，该数据与<a href="sql-aggregation-data-warehouses.html#GUID-CA29BB5D-90F5-4DCC-A0B4-99738E9C95D5__I1012453">图20-1中</a>使用的数据相同。<code class="codeph">ROLLUP</code>跨越三个维度。
                        </p><pre class="oac_no_warn" dir="ltr">SELECT channels.channel_desc，calendar_month_desc，countries.country_iso_code，TO_CHAR（SUM（amount_sold），'9,999,999,999'）SALES $ FROM sales，customers，times，channels，countries WHERE sales.time_id = times.time_id AND sales.cust_id = customers.cust_id AND customers.country_id = countries.country_id AND sales.channel_id = channels.channel_id AND channels.channel_desc IN（'Direct Sales'，'Internet'）AND times.calendar_month_desc IN（'2000-09'，'2000-10'）AND countries.country_iso_code IN（'GB'，'US'）GROUP BY ROLLUP（channels.channel_desc，calendar_month_desc，countries.country_iso_code）; CHANNEL_DESC CALENDAR CO SALES $ -------------------- --------  -  -------------- Internet 2000-09 GB 16,569 Internet 2000-09 US 124,224 Internet 2000-09 140,793 Internet 2000-10 GB 14,539 Internet 2000-10 US 137,054 Internet 2000-10 151,593 Internet 292,387 Direct Sales 2000-09 GB 85,223 Direct Sales 2000-09 US 638,201 Direct销售2000-09 723,424直销2000-10 GB 91,925直销2000-10美国682,297直销2000-10 774,222直销1,497,646 1,790,032</pre><p>请注意，由于四舍五入，结果并不总是相加。</p>
                        <p>此查询返回以下行集：</p>
                     </div>
                     <!-- class="example" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">GROUP</code> <code class="codeph">BY</code>生成的常规聚合行，不使用<code class="codeph">ROLLUP</code> 。</p>
                           </li>
                           <li>
                              <p>对于<code class="codeph">channel_desc</code>和<code class="codeph">calendar_month</code>每个组合，跨<code class="codeph">country_id</code>聚合的第一级小计。
                              </p>
                           </li>
                           <li>
                              <p>对于每个<code class="codeph">channel_desc</code>值，在<code class="codeph">calendar_month_desc</code>和<code class="codeph">country_id</code>之间聚合的二级小计。
                              </p>
                           </li>
                           <li>
                              <p>总排。</p>
                           </li>
                        </ul>
                        <div class="infoboxnote" id="GUID-9E931694-4AA8-464A-B8E7-19E568C5BFC8__GUID-E6E49E43-66E4-43FD-99D3-C6A47CDBAECB">
                           <p class="notep1">实时SQL：</p>
                           <p>在<a href="https://livesql.oracle.com/apex/livesql/docs/dwhsg/sql-analytics/rollup.html" target="_blank">Oracle LiveSQL</a>上查看并运行Oracle Live SQL的相关示例<a href="https://livesql.oracle.com/apex/livesql/docs/dwhsg/sql-analytics/rollup.html" target="_blank">：使用GROUP BY进行ROLLUP</a></p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="DWHSG8613"></a><a id="DWHSG8612"></a><div class="props_rev_3"><a id="GUID-60430684-FD7B-4C2A-813A-99769D6E19FE" name="GUID-60430684-FD7B-4C2A-813A-99769D6E19FE"></a><h4 id="DWHSG-GUID-60430684-FD7B-4C2A-813A-99769D6E19FE" class="sect4"><span class="enumeration_section">20.2.3</span>部分汇总</h4>
                  <div>
                     <div class="section">
                        <p><a id="d74861e767" class="indexterm-anchor"></a>您也可以汇总，以便只包含部分小计。此部分汇总使用以下语法：</p><pre class="oac_no_warn" dir="ltr">GROUP BY expr1，ROLLUP（expr2，expr3）;</pre><p>在这种情况下， <code class="codeph">GROUP</code> <code class="codeph">BY</code>子句在（2 + 1 = 3）聚合级别创建小计。即，在级别（ <code class="codeph">expr1</code> ， <code class="codeph">expr2</code> ， <code class="codeph">expr3</code> ），（ <code class="codeph">expr1</code> ， <code class="codeph">expr2</code> ）和（ <code class="codeph">expr1</code> ）。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-60430684-FD7B-4C2A-813A-99769D6E19FE__CHDHHCEA">
                        <p class="titleinexample">例20-2部分ROLLUP</p><pre class="oac_no_warn" dir="ltr">SELECT channel_desc，calendar_month_desc，countries.country_iso_code，TO_CHAR（SUM（amount_sold），'9,999,999,999'）SALES $ FROM sales，customers，times，channels，countries WHERE sales.time_id = times.time_id AND sales.cust_id = customers.cust_id AND customers .country_id = countries.country_id AND sales.channel_id = channels.channel_id AND channels.channel_desc IN（'Direct Sales'，'Internet'）AND times.calendar_month_desc IN（'2000-09'，'2000-10'）AND countries。 country_iso_code IN（'GB'，'US'）GROUP BY channel_desc，ROLLUP（calendar_month_desc，countries.country_iso_code）; CHANNEL_DESC CALENDAR CO SALES $ -------------------- --------  -  -------------- Internet 2000-09 GB 16,569 Internet 2000-09 US 124,224 Internet 2000-09 140,793 Internet 2000-10 GB 14,539 Internet 2000-10 US 137,054 Internet 2000-10 151,593 Internet 292,387 Direct Sales 2000-09 GB 85,223 Direct Sales 2000-09 US 638,201 Direct销售2000-09 723,424直销2000-10 GB 91,925直销2000-10美国682,297直销2000-10 774,222直销1,497,646</pre><p>此查询返回以下行集：</p>
                     </div>
                     <!-- class="example" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">GROUP</code> <code class="codeph">BY</code>生成的常规聚合行，不使用<code class="codeph">ROLLUP</code> 。</p>
                           </li>
                           <li>
                              <p>对于<code class="codeph">channel_desc</code>和<code class="codeph">calendar_month_desc</code>每个组合，跨<code class="codeph">country_id</code>聚合的第一级小计。
                              </p>
                           </li>
                           <li>
                              <p>对于每个<code class="codeph">channel_desc</code>值，在<code class="codeph">calendar_month_desc</code>和<code class="codeph">country_id</code>之间聚合的二级小计。
                              </p>
                           </li>
                           <li>
                              <p>它不会产生总排。</p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="DWHSG8614"></a><div class="props_rev_3"><a id="GUID-C5FDD050-DCE0-4FE1-9741-420E2F970A36" name="GUID-C5FDD050-DCE0-4FE1-9741-420E2F970A36"></a><h3 id="DWHSG-GUID-C5FDD050-DCE0-4FE1-9741-420E2F970A36" class="sect3"><span class="enumeration_section">20.3</span> CUBE扩展到GROUP BY</h3>
               <div>
                  <div class="section">
                     <p><a id="d74861e872" class="indexterm-anchor"></a> <code class="codeph">CUBE</code>采用一组指定的分组列，并为所有可能的组合创建小计。在多维分析方面， <code class="codeph">CUBE</code>生成可以为具有指定尺寸的数据立方体计算的所有小计。如果已指定<code class="codeph">CUBE(time</code> ， <code class="codeph">region</code> ， <code class="codeph">department)</code> ，则结果集将包括将包含在等效<code class="codeph">ROLLUP</code>语句中的所有值以及其他组合。例如，在<a href="sql-aggregation-data-warehouses.html#GUID-CA29BB5D-90F5-4DCC-A0B4-99738E9C95D5__I1012453">图20-1中</a> ，跨区域的部门总数（279,000和319,000）不会由<code class="codeph">ROLLUP(time</code> ， <code class="codeph">region</code> ， <code class="codeph">department)</code>条款计算，但它们将由<code class="codeph">CUBE(time</code>计算<code class="codeph">CUBE(time</code> ， <code class="codeph">region</code> ， <code class="codeph">department)</code>条款。如果为<code class="codeph">CUBE</code>指定了<span class="italic">n</span>列，则返回的<span class="italic">n</span>个小计组合将有2 <span class="italic">个</span> 。<a href="sql-aggregation-data-warehouses.html#GUID-7EF5334B-4A84-48AC-85A1-01EC814C5AFD">CUBE语法</a>提供了一个三维立方体的示例。
                     </p>
                     <div class="infoboxnotealso" id="GUID-C5FDD050-DCE0-4FE1-9741-420E2F970A36__GUID-A6DADDBE-A246-4D3E-9547-A739A7C8D9A0">
                        <p class="notep1">也可以看看：</p>
                        <p>有关语法和限制的<a href="../sqlrf/SELECT.html#SQLRF55332" target="_blank"><span class="italic">Oracle数据库SQL语言参考</span></a></p>
                     </div>
                     <p>本节包含以下主题：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="sql-aggregation-data-warehouses.html#GUID-51EC58D7-6AA1-40C9-801A-0D1D12C4880E">何时使用CUBE</a></p>
                        </li>
                        <li>
                           <p><a href="sql-aggregation-data-warehouses.html#GUID-7EF5334B-4A84-48AC-85A1-01EC814C5AFD">CUBE语法</a></p>
                        </li>
                        <li>
                           <p><a href="sql-aggregation-data-warehouses.html#GUID-BBC76574-0B15-46CB-B989-2F9E0230CD16">部分多维数据集</a></p>
                        </li>
                        <li>
                           <p><a href="sql-aggregation-data-warehouses.html#GUID-4EEA566F-FCB2-4BCC-9195-933A19EF0197">在没有CUBE的情况下计算小计</a></p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
               </div><a id="DWHSG8615"></a><div class="props_rev_3"><a id="GUID-51EC58D7-6AA1-40C9-801A-0D1D12C4880E" name="GUID-51EC58D7-6AA1-40C9-801A-0D1D12C4880E"></a><h4 id="DWHSG-GUID-51EC58D7-6AA1-40C9-801A-0D1D12C4880E" class="sect4"><span class="enumeration_section">20.3.1</span>何时使用CUBE</h4>
                  <div>
                     <p>考虑<a id="d74861e978" class="indexterm-anchor"></a>在任何需要跨表格报告的情况下使用<code class="codeph">CUBE</code> 。可以使用<code class="codeph">CUBE</code>使用单个<code class="codeph">SELECT</code>生成跨表格报告所需的数据。与<code class="codeph">ROLLUP</code>一样， <code class="codeph">CUBE</code>可以帮助生成汇总表。请注意，如果<code class="codeph">CUBE</code>查询并行执行，则汇总表的数量会更快。
                     </p>
                     <p><code class="codeph">CUBE</code>通常最适合使用来自多个维度的列的查询，而不是表示单个维度的不同级别的列。例如，通常请求的交叉制表可能需要针对月，州和产品的所有组合的小计。这些是三个独立的维度，并且对所有可能的小计组合的分析是常见的。相反，显示年，月和日的所有可能组合的交叉表将具有几个有限兴趣值，因为时间维度中存在自然层次结构。在大多数分析中，不需要按月汇总的利润等小计。相对较少的用户需要询问“全年每月16日的总销售额是多少？“有关处理汇总计算的示例，请参阅<span class="q">” <a href="sql-aggregation-data-warehouses.html#GUID-FB38E890-A91B-4645-9422-792E1C9BC238">ROLLUP和CUBE中的层次结构处理</a> “</span> 。
                     </p>
                  </div>
               </div><a id="DWHSG8617"></a><a id="DWHSG8616"></a><div class="props_rev_3"><a id="GUID-7EF5334B-4A84-48AC-85A1-01EC814C5AFD" name="GUID-7EF5334B-4A84-48AC-85A1-01EC814C5AFD"></a><h4 id="DWHSG-GUID-7EF5334B-4A84-48AC-85A1-01EC814C5AFD" class="sect4"><span class="enumeration_section">20.3.2</span> CUBE语法</h4>
                  <div>
                     <div class="section">
                        <p><code class="codeph">CUBE</code>出现在<code class="codeph">SELECT</code>语句的<code class="codeph">GROUP</code> <code class="codeph">BY</code>子句中。它的形式是：</p><pre class="oac_no_warn" dir="ltr">SELECT ... GROUP BY CUBE（grouping_column_reference_list）</pre></div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-7EF5334B-4A84-48AC-85A1-01EC814C5AFD__i1011609">
                        <p class="titleinexample">示例20-3查询中的CUBE关键字</p><pre class="oac_no_warn" dir="ltr">SELECT channel_desc，calendar_month_desc，countries.country_iso_code，TO_CHAR（SUM（amount_sold），'9,999,999,999'）SALES $ FROM sales，customers，times，channels，countries WHERE sales.time_id = times.time_id AND sales.cust_id = customers.cust_id AND sales .channel_id = channels.channel_id AND customers.country_id = countries.country_id AND channels.channel_desc IN（'Direct Sales'，'Internet'）AND times.calendar_month_desc IN（'2000-09'，'2000-10'）AND countries。 country_iso_code IN（'GB'，'US'）GROUP BY CUBE（channel_desc，calendar_month_desc，countries.country_iso_code）; CHANNEL_DESC CALENDAR CO SALES $ -------------------- ---------- -------------- 1,790,032 GB 208,257 US 1,581,775 2000-09 864,217 2000-09 GB 101,792 2000-09 US 762,425 2000-10 925,815 2000-10 GB 106,465 2000-10 US 819,351 Internet 292,387 Internet GB 31,109 Internet US 261,278 Internet 2000-09 140,793 Internet 2000-09 GB 16,569 Internet 2000-09 US 124,224 Internet 2000-10 151,593 Internet 2000-10 GB 14,539 Internet 2000-10 US 137,054直接销售1,497,646直接销售GB 177,148直接销售美国1,320,497直销2000-09 723,424直销2000-09 GB 85,223直销2000-09美国638,201直销2000-10 774,222直销2000-10 GB 91,925直销2000-10美国682,297</pre><p>此查询说明了三维的<code class="codeph">CUBE</code>聚合。
                        </p>
                     </div>
                     <!-- class="example" -->
                  </div>
               </div><a id="DWHSG8619"></a><a id="DWHSG8618"></a><div class="props_rev_3"><a id="GUID-BBC76574-0B15-46CB-B989-2F9E0230CD16" name="GUID-BBC76574-0B15-46CB-B989-2F9E0230CD16"></a><h4 id="DWHSG-GUID-BBC76574-0B15-46CB-B989-2F9E0230CD16" class="sect4"><span class="enumeration_section">20.3.3</span>部分立方体</h4>
                  <div>
                     <p><a id="d74861e1081" class="indexterm-anchor"></a>部分<code class="codeph">CUBE</code>类似于部分<code class="codeph">ROLLUP</code> ，因为您可以将其限制为某些维度，并在其前面加上<code class="codeph">CUBE</code>运算符之外的列。在这种情况下，所有可能组合的小计都限于多维数据集列表中的维度（括号中），并且它们与<code class="codeph">GROUP</code> <code class="codeph">BY</code>列表中的前一项组合。
                     </p>
                     <p>部分<code class="codeph">CUBE</code>的语法如下：</p><pre class="oac_no_warn" dir="ltr">GROUP BY expr1，CUBE（expr2，expr3）</pre><p>此语法示例计算2 * 2或4个小计。那是：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>（ <code class="codeph">expr1</code> ， <code class="codeph">expr2</code> ， <code class="codeph">expr3</code> ）</p>
                        </li>
                        <li>
                           <p>（ <code class="codeph">expr1</code> ， <code class="codeph">expr2</code> ）</p>
                        </li>
                        <li>
                           <p>（ <code class="codeph">expr1</code> ， <code class="codeph">expr3</code> ）</p>
                        </li>
                        <li>
                           <p>（ <code class="codeph">expr1</code> ）</p>
                        </li>
                     </ul>
                     <div class="example" id="GUID-BBC76574-0B15-46CB-B989-2F9E0230CD16__GUID-0050FA62-8EEE-4C22-A0AA-02AD7AEFE7CF">
                        <p class="titleinexample">示例20-4查询中的部分多维数据集</p>
                        <p>使用<code class="codeph">sales</code>数据库，您可以发出以下语句：</p><pre class="oac_no_warn" dir="ltr">SELECT channel_desc，calendar_month_desc，countries.country_iso_code，TO_CHAR（SUM（amount_sold），'9,999,999,999'）SALES $ FROM sales，customers，times，channels，countries WHERE sales.time_id = times.time_id AND sales.cust_id = customers.cust_id AND customers .country_id = countries.country_id AND sales.channel_id = channels.channel_id AND channels.channel_desc IN（'Direct Sales'，'Internet'）AND times.calendar_month_desc IN（'2000-09'，'2000-10'）AND countries。 country_iso_code IN（'GB'，'US'）GROUP BY channel_desc，CUBE（calendar_month_desc，countries.country_iso_code）; CHANNEL_DESC CALENDAR CO SALES $ -------------------- --------  -  -------------- Internet 292,387互联网GB 31,109互联网美国261,278互联网2000-09 140,793互联网2000-09 GB 16,569互联网2000-09美国124,224互联网2000-10 151,593互联网2000-10英国14,539互联网2000-10美国137,054直接销售1,497,646直接销售GB 177,148直销美国1,320,497直销2000-09 723,424直销2000-09 GB 85,223直销2000-09美国638,201直销2000-10 774,222直销2000-10 GB 91,925直销2000-10 US 682,297</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="DWHSG8620"></a><div class="props_rev_3"><a id="GUID-4EEA566F-FCB2-4BCC-9195-933A19EF0197" name="GUID-4EEA566F-FCB2-4BCC-9195-933A19EF0197"></a><h4 id="DWHSG-GUID-4EEA566F-FCB2-4BCC-9195-933A19EF0197" class="sect4"><span class="enumeration_section">20.3.4在</span>没有CUBE的<span class="enumeration_section">情况下</span>计算小计</h4>
                  <div>
                     <p>与<code class="codeph">ROLLUP</code> ，多个<code class="codeph">SELECT</code>语句与<code class="codeph">UNION</code> <code class="codeph">ALL</code>语句结合使用可以提供通过<code class="codeph">CUBE</code>收集的相同信息。但是，这可能需要许多<code class="codeph">SELECT</code>语句。对于n维立方体，需要2到<span class="italic">n个</span> <code class="codeph">SELECT</code>语句。在三维示例中，这将意味着发出与<code class="codeph">UNION</code> <code class="codeph">ALL</code>链接的<code class="codeph">SELECT</code>语句。如此多的<code class="codeph">SELECT</code>语句会产生低效的处理和非常冗长的SQL。</p>
                     <p>考虑在计算所有可能的组合时仅添加一个维度的影响： <code class="codeph">SELECT</code>语句的数量将加倍到16。<code class="codeph">CUBE</code>子句中使用的列越多，与<code class="codeph">UNION</code> <code class="codeph">ALL</code>方法相比节省的越多。
                     </p>
                  </div>
               </div>
            </div><a id="DWHSG8621"></a><div class="props_rev_3"><a id="GUID-E4251C0F-8AD7-4826-BE35-845E5CE6C818" name="GUID-E4251C0F-8AD7-4826-BE35-845E5CE6C818"></a><h3 id="DWHSG-GUID-E4251C0F-8AD7-4826-BE35-845E5CE6C818" class="sect3"><span class="enumeration_section">20.4</span>分组功能</h3>
               <div>
                  <p><a id="d74861e1252" class="indexterm-anchor"></a><a id="d74861e1254" class="indexterm-anchor"></a>使用<code class="codeph">ROLLUP</code>和<code class="codeph">CUBE</code>产生两个挑战。首先，如何以编程方式确定哪些结果集行是小计，以及如何找到给定小计的确切聚合级别？您经常需要在计算中使用小计，例如总计百分比，因此您需要一种简单的方法来确定哪些行是小计。第二，如果查询结果包含存储的<code class="codeph">NULL</code>值和<code class="codeph">ROLLUP</code>或<code class="codeph">CUBE</code>创建的“NULL”值，会发生什么？你怎么能区分这两者？本节讨论其中一些情况。
                  </p>
                  <div class="infoboxnotealso" id="GUID-E4251C0F-8AD7-4826-BE35-845E5CE6C818__GUID-66CC9AC2-2309-4B99-9F35-9A0566D73342">
                     <p class="notep1">也可以看看：</p>
                     <p>有关语法和限制的<a href="../sqlrf/SELECT.html#SQLRF20038" target="_blank"><span class="italic">Oracle数据库SQL语言参考</span></a></p>
                  </div>
                  <p>本节包含以下主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="sql-aggregation-data-warehouses.html#GUID-23FC1FDA-A7DA-44A5-AA3F-632B2CDBACE5">分组功能</a></p>
                     </li>
                     <li>
                        <p><a href="sql-aggregation-data-warehouses.html#GUID-F80858F3-45B3-4D46-B712-1B55CB8DA2F4">何时使用GROUPING</a></p>
                     </li>
                     <li>
                        <p><a href="sql-aggregation-data-warehouses.html#GUID-DC7E0B24-EF05-4240-8D49-32D9AC6083B1">GROUPING_ID函数</a></p>
                     </li>
                     <li>
                        <p><a href="sql-aggregation-data-warehouses.html#GUID-6FF4725F-6608-4C29-9917-706BCE885678">GROUP_ID功能</a></p>
                     </li>
                  </ul>
               </div><a id="DWHSG8623"></a><a id="DWHSG8624"></a><a id="DWHSG8622"></a><div class="props_rev_3"><a id="GUID-23FC1FDA-A7DA-44A5-AA3F-632B2CDBACE5" name="GUID-23FC1FDA-A7DA-44A5-AA3F-632B2CDBACE5"></a><h4 id="DWHSG-GUID-23FC1FDA-A7DA-44A5-AA3F-632B2CDBACE5" class="sect4"><span class="enumeration_section">20.4.1分组</span>功能</h4>
                  <div>
                     <div class="section">
                        <p><code class="codeph">GROUPING</code>处理这些问题。使用单个列作为参数， <code class="codeph">GROUPING</code>在遇到由<code class="codeph">ROLLUP</code>或<code class="codeph">CUBE</code>操作创建的<code class="codeph">NULL</code>值时返回1。也就是说，如果<code class="codeph">NULL</code>表示该行是小计，则<code class="codeph">GROUPING</code>返回1。任何其他类型的值（包括存储的<code class="codeph">NULL</code> ）都返回0。
                        </p>
                        <p><code class="codeph">GROUPING</code>出现在<code class="codeph">SELECT</code>语句的选择列表部分中。它的形式是：</p><pre class="oac_no_warn" dir="ltr">SELECT ... [GROUPING（dimension_column）...] ... GROUP BY ... {CUBE | ROLLUP | GROUPING SETS}（dimension_column）</pre></div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-23FC1FDA-A7DA-44A5-AA3F-632B2CDBACE5__GUID-16D9DECF-124A-44A5-81E2-1CAB602F5910">
                        <p class="titleinexample">示例20-5分组到掩码列</p>
                        <p>此示例使用<code class="codeph">GROUPING</code>为<a href="sql-aggregation-data-warehouses.html#GUID-60430684-FD7B-4C2A-813A-99769D6E19FE__CHDHHCEA">示例20-2中</a>显示的结果集创建一组掩码列。掩码列易于以编程方式分析。
                        </p><pre class="oac_no_warn" dir="ltr">SELECT channel_desc，calendar_month_desc，country_iso_code，TO_CHAR（SUM（amount_sold），'9,999,999,999'）SALES $，GROUPING（channel_desc）AS Ch，GROUPING（calendar_month_desc）AS Mo，GROUPING（country_iso_code）AS Co FROM销售，客户，时间，渠道， countries WHERE sales.time_id = times.time_id AND sales.cust_id = customers.cust_id AND customers.country_id = countries.country_id AND sales.channel_id = channels.channel_id AND channels.channel_desc IN（'Direct Sales'，'Internet'）AND times .calendar_month_desc IN（'2000-09'，'2000-10'）AND countries.country_iso_code IN（'GB'，'US'）GROUP BY ROLLUP（channel_desc，calendar_month_desc，countries.country_iso_code）; CHANNEL_DESC CALENDAR CO SALES $ CH MO CO -------------------- --------  -  ------------ -  ---------- ---------- ---------- Internet 2000-09 GB 16,569 0 0 0 Internet 2000-09 US 124,224 0 0 0 Internet 2000-09 140,793 0 0 1 Internet 2000-10 GB 14,539 0 0 0 Internet 2000-10 US 137,054 0 0 0 Internet 2000-10 151,593 0 0 1 Internet 292,387 0 1 1直接销售2000-09 GB 85,223 0 0 0直接销售2000-09美国638,201 0 0 0直接销售2000-09 723,424 0 0 1直接销售2000-10 GB 91,925 0 0 0直销2000-10 US 682,297 0 0 0直销2000-10 774,222 0 0 1直销1,497,646 0 1 1 1,790,032 1 1 1</pre><p>程序可以通过T，R和D列上的“0 0 0”掩码轻松识别细节行。第一级小计行具有掩码“0 0 1”，第二级小计行具有掩码“0 1 1”，并且总总行具有掩码“1 1 1”。</p>
                        <p>您可以使用<code class="codeph">GROUPING</code>和<code class="codeph">DECODE</code>函数来提高结果集的可读性，如<a href="sql-aggregation-data-warehouses.html#GUID-23FC1FDA-A7DA-44A5-AA3F-632B2CDBACE5__i1006669">例20-6</a>所示。
                        </p>
                     </div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-23FC1FDA-A7DA-44A5-AA3F-632B2CDBACE5__i1006669">
                        <p class="titleinexample">例20-6 GROUPING的可读性</p><pre class="oac_no_warn" dir="ltr">SELECT DECODE（GROUPING（channel_desc），1，'多通道和'，channel_desc）AS通道，DECODE（GROUPING（country_iso_code），1，'多国家和'，country_iso_code）AS国家，TO_CHAR（SUM（amount_sold）， '9,999,999,999'）销售，客户，时间，渠道，国家/地区销售额$ sales.stime_id = times.time_id AND sales.cust_id = customers.cust_id AND customers.country_id = countries.country_id AND sales.channel_id = channels.channel_id AND渠道.channel_desc IN（'Direct Sales'，'Internet'）AND times.calendar_month_desc ='2000-09'AND country_iso_code IN（'GB'，'US'）GROUP BY CUBE（channel_desc，country_iso_code）; CHANNEL COUNTRY SALES $ -------------------- ----------------- --------- -----多渠道和多国总和864,217多渠道总和GB 101,792多渠道和美国762,425互联网多国家总和140,793互联网GB 16,569互联网美国124,224直销多国723,424直销GB 85,223直接销售额US 638,201</pre><p>要理解前面的语句，请注意其第一个列规范，它处理channel_desc列。考虑前一个陈述的第一行：</p><pre class="oac_no_warn" dir="ltr">SELECT DECODE（GROUPING（channel_desc），1，'多通道和'，channel_desc）AS通道</pre><p>在此， <code class="codeph">channel_desc</code>值由包含<code class="codeph">GROUPING</code>函数的<code class="codeph">DECODE</code>函数确定。如果行值是由<code class="codeph">ROLLUP</code>或<code class="codeph">CUBE</code>创建的聚合，则<code class="codeph">GROUPING</code>函数返回1，否则返回0。然后<code class="codeph">DECODE</code>函数对<code class="codeph">GROUPING</code>函数的结果进行操作。如果收到1，则返回文本“All Channels”，如果收到0，则返回数据库中的<code class="codeph">channel_desc</code>值。来自数据库的值将是实际值，例如“Internet”或存储的<code class="codeph">NULL</code> 。显示<code class="codeph">country_id</code>的第二列规范以相同的方式工作。
                        </p>
                     </div>
                     <!-- class="example" -->
                  </div>
               </div><a id="DWHSG8626"></a><a id="DWHSG8625"></a><div class="props_rev_3"><a id="GUID-F80858F3-45B3-4D46-B712-1B55CB8DA2F4" name="GUID-F80858F3-45B3-4D46-B712-1B55CB8DA2F4"></a><h4 id="DWHSG-GUID-F80858F3-45B3-4D46-B712-1B55CB8DA2F4" class="sect4"><span class="enumeration_section">20.4.2</span>何时使用GROUPING</h4>
                  <div>
                     <p><a id="d74861e1454" class="indexterm-anchor"></a> <code class="codeph">GROUPING</code>函数不仅可用于标识<code class="codeph">NULLs</code> ，还可以对小计行和过滤结果进行排序。在<a href="sql-aggregation-data-warehouses.html#GUID-F80858F3-45B3-4D46-B712-1B55CB8DA2F4__i1006706">例20-7</a> ，您检索通过创建分类汇总的一个子集<code class="codeph">CUBE</code>的基层聚合的，没有。<code class="codeph">HAVING</code>子句约束使用<code class="codeph">GROUPING</code>函数的列。
                     </p>
                     <div class="example" id="GUID-F80858F3-45B3-4D46-B712-1B55CB8DA2F4__i1006706">
                        <p class="titleinexample">例20-7分组与HAVING相结合</p><pre class="oac_no_warn" dir="ltr">SELECT channel_desc，calendar_month_desc，country_iso_code，TO_CHAR（SUM（amount_sold），'9,999,999,999'）SALES $，GROUPING（channel_desc）CH，GROUPING（calendar_month_desc）MO，GROUPING（country_iso_code）CO FROM销售，客户，时间，渠道，国家/地区销售.time_id = times.time_id AND sales.cust_id = customers.cust_id AND customers.country_id = countries.country_id AND sales.channel_id = channels.channel_id AND channels.channel_desc IN（'Direct Sales'，'Internet'）AND times.calendar_month_desc IN （'2000-09'，'2000-10'）AND country_iso_code IN（'GB'，'US'）GROUP BY CUBE（channel_desc，calendar_month_desc，country_iso_code）HAVING（GROUPING（channel_desc）= 1 AND GROUPING（calendar_month_desc）= 1 AND GROUPING（country_iso_code）= 1）OR（GROUPING（channel_desc）= 1 AND GROUPING（calendar_month_desc）= 1）OR（GROUPING（country_iso_code）= 1 AND GROUPING（calendar_month_desc）= 1）; CHANNEL_DESC C CO SALES $ CH MO CO --------------------  -   -  -------------- ----- ----- ---------- ---------- US 1,581,775 1 1 0 GB 208,257 1 1 0直接销售1,497,646 0 1 1互联网292,387 0 1 1 1,790,032 1 1 1</pre><p>将<a href="sql-aggregation-data-warehouses.html#GUID-F80858F3-45B3-4D46-B712-1B55CB8DA2F4__i1006706">示例20-7</a>的结果集与<a href="sql-aggregation-data-warehouses.html#GUID-60430684-FD7B-4C2A-813A-99769D6E19FE__CHDHHCEA">示例20-2中</a>的结果集进行比较，以查看<a href="sql-aggregation-data-warehouses.html#GUID-F80858F3-45B3-4D46-B712-1B55CB8DA2F4__i1006706">示例20-7</a>如何是精确指定的组：它仅包含年度总计，随时间和部门汇总的区域总计以及总计。
                        </p>
                     </div>
                     <!-- class="example" -->
                  </div>
               </div><a id="DWHSG8628"></a><a id="DWHSG8627"></a><div class="props_rev_3"><a id="GUID-DC7E0B24-EF05-4240-8D49-32D9AC6083B1" name="GUID-DC7E0B24-EF05-4240-8D49-32D9AC6083B1"></a><h4 id="DWHSG-GUID-DC7E0B24-EF05-4240-8D49-32D9AC6083B1" class="sect4"><span class="enumeration_section">20.4.3</span> GROUPING_ID函数</h4>
                  <div>
                     <div class="section">
                        <p>要查找特定行的<code class="codeph">GROUP</code> <code class="codeph">BY</code>级别，查询必须为每个<code class="codeph">GROUP</code> <code class="codeph">BY</code>列返回<code class="codeph">GROUPING</code>函数信息。如果使用<code class="codeph">GROUPING</code>函数执行此操作，则每个<code class="codeph">GROUP</code> <code class="codeph">BY</code>列都需要使用<code class="codeph">GROUPING</code>函数的另一列。例如，必须使用四个<code class="codeph">GROUPING</code>函数分析四列<code class="codeph">GROUP</code> <code class="codeph">BY</code>子句。这在SQL中编写并增加查询所需的列数很不方便。如果要将查询结果集存储在表中，与物化视图一样，额外的列会浪费存储空间。
                        </p>
                        <p>要解决这些问题，可以使用<code class="codeph">GROUPING_ID</code>函数。<code class="codeph">GROUPING_ID</code>返回一个数字，使您可以确定准确的<code class="codeph">GROUP</code> <code class="codeph">BY</code>级别。对于每一行， <code class="codeph">GROUPING_ID</code>是以设置如果使用适当的将要生成1和0的<code class="codeph">GROUPING</code>功能和连接它们，形成一个位向量。位向量被视为二进制数，并且<code class="codeph">GROUPING_ID</code>函数返回数字的base-10值。例如，如果使用表达式<code class="codeph">CUBE(a</code> ， <code class="codeph">b)</code>进行分组，则可能的值如<a href="sql-aggregation-data-warehouses.html#GUID-DC7E0B24-EF05-4240-8D49-32D9AC6083B1__g1014093" title="GROUPING_ID CUBE示例（a，b）">表20-2</a>所示。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="tblformal" id="GUID-DC7E0B24-EF05-4240-8D49-32D9AC6083B1__g1014093">
                        <p class="titleintable">表20-2 CUBE（a，b）的GROUPING_ID示例</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="GROUPING_ID CUBE示例（a，b）" width="100%" border="1" summary="GROUPING_ID Example for CUBE(a, b)" frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="31%" id="d74861e1607">聚合级别</th>
                                 <th align="left" valign="bottom" width="33%" id="d74861e1610">位向量</th>
                                 <th align="left" valign="bottom" width="36%" id="d74861e1613">GROUPING_ID</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d74861e1618" headers="d74861e1607 ">
                                    <p>a，b</p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d74861e1618 d74861e1610 ">
                                    <p>0 0</p>
                                 </td>
                                 <td align="left" valign="top" width="36%" headers="d74861e1618 d74861e1613 ">
                                    <p>0</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d74861e1628" headers="d74861e1607 ">
                                    <p>一个</p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d74861e1628 d74861e1610 ">
                                    <p>0 1</p>
                                 </td>
                                 <td align="left" valign="top" width="36%" headers="d74861e1628 d74861e1613 ">
                                    <p>1</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d74861e1638" headers="d74861e1607 ">
                                    <p>b</p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d74861e1638 d74861e1610 ">
                                    <p>1 0</p>
                                 </td>
                                 <td align="left" valign="top" width="36%" headers="d74861e1638 d74861e1613 ">
                                    <p>2</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d74861e1648" headers="d74861e1607 ">
                                    <p>累计</p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d74861e1648 d74861e1610 ">
                                    <p>1 1</p>
                                 </td>
                                 <td align="left" valign="top" width="36%" headers="d74861e1648 d74861e1613 ">
                                    <p>3</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <div class="section">
                        <p><code class="codeph">GROUPING_ID</code>清楚地区分通过分组集规范创建的分组，并且在物化视图的刷新和重写期间非常有用。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="DWHSG8630"></a><a id="DWHSG8629"></a><div class="props_rev_3"><a id="GUID-6FF4725F-6608-4C29-9917-706BCE885678" name="GUID-6FF4725F-6608-4C29-9917-706BCE885678"></a><h4 id="DWHSG-GUID-6FF4725F-6608-4C29-9917-706BCE885678" class="sect4"><span class="enumeration_section">20.4.4</span> GROUP_ID函数</h4>
                  <div>
                     <div class="section">
                        <p>而<a id="d74861e1686" class="indexterm-anchor"></a><a id="d74861e1688" class="indexterm-anchor"></a> <code class="codeph">GROUP</code> <code class="codeph">BY</code>的扩展提供了强大的功能和灵活性，它们还允许包含重复分组的复杂结果集。<code class="codeph">GROUP_ID</code>函数可以区分重复的分组。如果为给定级别计算了多组行，则<code class="codeph">GROUP_ID</code>将值0分配给第一组中的所有行。特定分组的所有其他重复行集都将分配更高的值，从1开始。例如，请考虑以下查询，该查询生成重复的分组：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-6FF4725F-6608-4C29-9917-706BCE885678__GUID-7CAADF72-D35F-44E5-9130-5FCB09F8292C">
                        <p class="titleinexample">示例20-8查询中的GROUP_ID</p><pre class="oac_no_warn" dir="ltr">SELECT country_iso_code，SUBSTR（cust_state_province，1,12），SUM（amount_sold），GROUPING_ID（country_iso_code，cust_state_province）GROUPING_ID，GROUP_ID（）FROM sales，customers，times，countries WHERE sales.time_id = times.time_id AND sales.cust_id = customers .cust_id AND customers.country_id = countries.country_id AND times.time_id = '30 -OCT-00'AND country_iso_code IN（'FR'，'ES'）GROUP BY GROUPING SETS（country_iso_code，ROLLUP（country_iso_code，cust_state_province））; CO SUBSTR（CUST_ SUM（AMOUNT_SOLD）GROUPING_ID GROUP_ID（） -  ------------ ---------------- -------- --- ---------- ES Alicante 135.32 0 0 ES Valencia 4133.56 0 0 ES Barcelona 24.22 0 0 FR Center 74.3 0 0 FR Aquitaine 231.97 0 0 FR Rhtne-Alpes 1624.69 0 0 FR Ile-de- Franc 1860.59 0 0 FR Languedoc-Ro 4287.4 0 0 12372.05 3 0 ES 4293.1 1 0 FR 8078.95 1 0 ES 4293.1 1 1 FR 8078.95 1 1</pre><p>此查询生成以下分组：（ <code class="codeph">country_id</code> ， <code class="codeph">cust_state_province</code> ），（ <code class="codeph">country_id</code> ），（ <code class="codeph">country_id</code> ）和（）。请注意，分组（ <code class="codeph">country_id</code> ）重复两次。<code class="codeph">GROUPING</code> <code class="codeph">SETS</code>的语法在<span class="q">“ <a href="sql-aggregation-data-warehouses.html#GUID-166E1BFC-51C6-4BB5-B10B-A8EB63472E49">GROUPING SETS Expression</a> ”中进行了</span>解释。
                        </p>
                        <p>此功能可帮助您从结果中筛选出重复的分组。例如，您可以通过向查询添加<code class="codeph">HAVING</code>子句条件<code class="codeph">GROUP_ID()=0</code>来过滤掉上一个示例中的重复（ <code class="codeph">region</code> ）分组。
                        </p>
                     </div>
                     <!-- class="example" -->
                  </div>
               </div>
            </div><a id="DWHSG8631"></a><div class="props_rev_3"><a id="GUID-166E1BFC-51C6-4BB5-B10B-A8EB63472E49" name="GUID-166E1BFC-51C6-4BB5-B10B-A8EB63472E49"></a><h3 id="DWHSG-GUID-166E1BFC-51C6-4BB5-B10B-A8EB63472E49" class="sect3"><span class="enumeration_section">20.5</span>分组集表达式</h3>
               <div>
                  <div class="section">
                     <p>您可以使用<code class="codeph">GROUP</code> <code class="codeph">BY</code>子句中的<code class="codeph">GROUPING</code> <code class="codeph">SETS</code>表达式选择性地指定要创建的组的集合。这允许跨多个维度进行精确指定，而无需计算整个<code class="codeph">CUBE</code> 。 <span class="q">“ <a href="sql-aggregation-data-warehouses.html#GUID-C063BB2C-ACF8-4878-92F6-59A2913A1449">GROUPING SETS语法</a> ”</span>包含<code class="codeph">GROUPING SETS</code>语法。
                     </p>
                     <p>例如，您可以说：</p><pre class="oac_no_warn" dir="ltr">SELECT channel_desc，calendar_month_desc，country_iso_code，TO_CHAR（SUM（amount_sold），'9,999,999,999'）SALES $ FROM sales，customers，times，channels，countries WHERE sales.time_id = times.time_id AND sales.cust_id = customers.cust_id AND sales.channel_id = channels.channel_id AND channels.channel_desc IN（'Direct Sales'，'Internet'）AND times.calendar_month_desc IN（'2000-09'，'2000-10'）AND country_iso_code IN（'GB'，'US'）GROUP BY GROUPING SETS（（channel_desc，calendar_month_desc，country_iso_code），（channel_desc，country_iso_code），（calendar_month_desc，country_iso_code））;</pre><p>请注意，此语句使用复合列，如<span class="q">“ <a href="sql-aggregation-data-warehouses.html#GUID-FC174F30-F8AA-4169-A6E0-68CF3DD60DF4">关于复合列和分组</a> ”中所述</span> 。此语句计算三个分组的聚合：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">（channel_desc，calendar_month_desc，country_iso_code）</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">（channel_desc，country_iso_code）</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">（calendar_month_desc，country_iso_code）</code></p>
                        </li>
                     </ul>
                     <p>将前面的语句与以下替代方法进行比较，后者使用<code class="codeph">CUBE</code>操作和<code class="codeph">GROUPING_ID</code>函数返回所需的行：</p><pre class="oac_no_warn" dir="ltr">SELECT channel_desc，calendar_month_desc，country_iso_code，TO_CHAR（SUM（amount_sold），'9,999,999,999'）SALES $，GROUPING_ID（channel_desc，calendar_month_desc，country_iso_code）gid FROM sales，customers，times，channels，countries WHERE sales.time_id = times.time_id AND sales .cust_id = customers.cust_id AND sales.channel_id = channels.channel_id AND channels.channel_desc IN（'Direct Sales'，'Internet'）AND times.calendar_month_desc IN（'2000-09'，'2000-10'）AND country_iso_code IN （'GB'，'US'）GROUP BY CUBE（channel_desc，calendar_month_desc，country_iso_code）HAVING GROUPING_ID（channel_desc，calendar_month_desc，country_iso_code）= 0 OR GROUPING_ID（channel_desc，calendar_month_desc，country_iso_code）= 2 OR GROUPING_ID（channel_desc，calendar_month_desc，country_iso_code） = 4;</pre><p>此语句计算所有8（2 * 2 * 2）个分组，但只有前3个组对您感兴趣。</p>
                     <p>另一种选择是以下陈述，由于几个工会，这个陈述很长。此语句需要对基表进行三次扫描，从而使其效率低下。可以将<code class="codeph">CUBE</code>和<code class="codeph">ROLLUP</code>视为具有非常特定语义的分组集。例如，请考虑以下语句：</p><pre class="oac_no_warn" dir="ltr">CUBE（a，b，c）</pre><p>该陈述相当于：</p><pre class="oac_no_warn" dir="ltr">分组集（（a，b，c），（a，b），（a，c），（b，c），（a），（b），（c），（））ROLLUP（a，b， C）</pre><p>这句话相当于：</p><pre class="oac_no_warn" dir="ltr">分组集（（a，b，c），（a，b），（））</pre></div>
                  <!-- class="section" -->
               </div><a id="DWHSG8633"></a><a id="DWHSG8632"></a><div class="props_rev_3"><a id="GUID-C063BB2C-ACF8-4878-92F6-59A2913A1449" name="GUID-C063BB2C-ACF8-4878-92F6-59A2913A1449"></a><h4 id="DWHSG-GUID-C063BB2C-ACF8-4878-92F6-59A2913A1449" class="sect4"><span class="enumeration_section">20.5.1</span> GROUPING SETS语法</h4>
                  <div>
                     <div class="section">
                        <p><code class="codeph">GROUPING</code> <code class="codeph">SETS</code>语法允许您在同一查询中定义多个分组。<code class="codeph">GROUP</code> <code class="codeph">BY</code>计算指定的所有分组，并将它们与<code class="codeph">UNION</code> <code class="codeph">ALL</code> 。例如，请考虑以下语句：</p><pre class="oac_no_warn" dir="ltr">GROUP BY GROUPING集（channel_desc，calendar_month_desc，country_id）</pre><p>该陈述相当于：</p><pre class="oac_no_warn" dir="ltr">GROUP BY channel_desc UNION ALL GROUP BY calendar_month_desc UNION ALL GROUP BY country_id</pre><p><a href="sql-aggregation-data-warehouses.html#GUID-C063BB2C-ACF8-4878-92F6-59A2913A1449__g1014117" title="GROUPING_SETS语句和等效GROUP BY">表20-3</a>显示了分组集规范和等效的<code class="codeph">GROUP</code> <code class="codeph">BY</code>规范。请注意，某些示例使用复合列。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="tblformal" id="GUID-C063BB2C-ACF8-4878-92F6-59A2913A1449__g1014117">
                        <p class="titleintable">表20-3 GROUPING SETS语句和等效GROUP BY</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="GROUPING SETS语句和等效GROUP BY" width="100%" border="1" summary="GROUPING_SETS Statements and Equivalent GROUP BY" frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="44%" id="d74861e1924">GROUPING SETS声明</th>
                                 <th align="left" valign="bottom" width="56%" id="d74861e1927">等效GROUP BY语句</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="44%" id="d74861e1932" headers="d74861e1924 ">
                                    <p><code class="codeph">GROUP BY GROUPING SETS（a，b，c）</code></p>
                                 </td>
                                 <td align="left" valign="top" width="56%" headers="d74861e1932 d74861e1927 ">
                                    <p><code class="codeph">GROUP BY UNION ALL GROUP BY b UNION ALL GROUP BY c</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="44%" id="d74861e1941" headers="d74861e1924 ">
                                    <p><code class="codeph">GROUP BY GROUPING SETS（a，b，（b，c））</code></p>
                                 </td>
                                 <td align="left" valign="top" width="56%" headers="d74861e1941 d74861e1927 ">
                                    <p><code class="codeph">GROUP BY UNION ALL GROUP BY b UNION ALL GROUP BY b，c</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="44%" id="d74861e1950" headers="d74861e1924 ">
                                    <p><code class="codeph">GROUP BY GROUPING SETS（（a，b，c））</code></p>
                                 </td>
                                 <td align="left" valign="top" width="56%" headers="d74861e1950 d74861e1927 ">
                                    <p><code class="codeph">GROUP BY a，b，c</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="44%" id="d74861e1959" headers="d74861e1924 ">
                                    <p><code class="codeph">GROUP BY GROUPING SETS（a，（b），（））</code></p>
                                 </td>
                                 <td align="left" valign="top" width="56%" headers="d74861e1959 d74861e1927 ">
                                    <p><code class="codeph">GROUP BY UNION ALL GROUP BY b UNION ALL GROUP BY（）</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="44%" id="d74861e1968" headers="d74861e1924 ">
                                    <p><code class="codeph">GROUP BY GROUPING SETS（a，ROLLUP（b，c））</code></p>
                                 </td>
                                 <td align="left" valign="top" width="56%" headers="d74861e1968 d74861e1927 ">
                                    <p><code class="codeph">由一个UNION ALL GROUP BY ROLLUP分组（b，c）</code></p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <div class="section">
                        <p>如果没有优化器查看查询块以生成执行计划，则基于<code class="codeph">UNION</code>的查询将需要对基表sales进行多次扫描。这可能是非常低效的，因为事实表通常是巨大的。使用<code class="codeph">GROUPING</code> <code class="codeph">SETS</code>语句，所有感兴趣的分组在同一查询块中可用。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="DWHSG8635"></a><a id="DWHSG8634"></a><div class="props_rev_3"><a id="GUID-FC174F30-F8AA-4169-A6E0-68CF3DD60DF4" name="GUID-FC174F30-F8AA-4169-A6E0-68CF3DD60DF4"></a><h3 id="DWHSG-GUID-FC174F30-F8AA-4169-A6E0-68CF3DD60DF4" class="sect3"><span class="enumeration_section">20.6</span>关于复合列和分组</h3>
               <div>
                  <p>复合材料<a id="d74861e2012" class="indexterm-anchor"></a> column是在计算分组期间被视为一个单元的列的集合。您可以在括号中指定列，如以下语句中所示：</p><pre class="oac_no_warn" dir="ltr">ROLLUP（年，（季，月），日）</pre><p>在此声明中，数据不会在年份和季度中汇总，而是等同于<code class="codeph">UNION</code> <code class="codeph">ALL</code>的以下分组：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>（ <code class="codeph">year</code> ， <code class="codeph">quarter</code> ， <code class="codeph">month</code> ， <code class="codeph">day</code> ），</p>
                     </li>
                     <li>
                        <p>（ <code class="codeph">year</code> ， <code class="codeph">quarter</code> ， <code class="codeph">month</code> ），</p>
                     </li>
                     <li>
                        <p>（ <code class="codeph">year</code> ）</p>
                     </li>
                     <li>
                        <p>（）</p>
                     </li>
                  </ul>
                  <p>这里，（ <code class="codeph">quarter</code> ， <code class="codeph">month</code> ）形成一个复合列，并作为一个单元处理。通常，复合列在<code class="codeph">ROLLUP</code> ， <code class="codeph">CUBE</code> ， <code class="codeph">GROUPING</code> <code class="codeph">SETS</code>和连接分组中很有用。例如，在<code class="codeph">CUBE</code>或<code class="codeph">ROLLUP</code> ，复合列意味着跳过某些级别的聚合。也就是说，以下声明：</p><pre class="oac_no_warn" dir="ltr">GROUP BY ROLLUP（a，（b，c））</pre><p>这相当于：</p><pre class="oac_no_warn" dir="ltr">GROUP BY a，b，c UNION ALL GROUP by UNION ALL GROUP BY（）</pre><p>这里， <code class="codeph">(b</code> ， <code class="codeph">c)</code>被视为一个单元，并且不会在<code class="codeph">(b</code> ， <code class="codeph">c)</code>之间应用汇总。就好像你有<code class="codeph">(b</code> ， <code class="codeph">c)</code>的别名，例如z， <code class="codeph">GROUP</code> <code class="codeph">BY</code>表达式减少为<code class="codeph">GROUP</code> <code class="codeph">BY</code> <code class="codeph">ROLLUP(a</code> ， <code class="codeph">z)</code> 。将其与正常汇总进行比较，如下所示：</p><pre class="oac_no_warn" dir="ltr">GROUP BY ROLLUP（a，b，c）</pre><p>这将是以下内容：</p><pre class="oac_no_warn" dir="ltr">GROUP BY a，b，c UNION ALL GROUP BY a，b UNION ALL GROUP by UNION ALL GROUP BY（）。
</pre><p>同样，以下语句相当于四个<code class="codeph">GROUP</code> <code class="codeph">BY</code> ：</p><pre class="oac_no_warn" dir="ltr">GROUP BY CUBE（（a，b），c）GROUP BY a，b，c UNION ALL GROUP BY a，b UNION ALL GROUP BY c UNION ALL GROUP By（）</pre><p>在<code class="codeph">GROUPING</code> <code class="codeph">SETS</code> ，复合列用于表示<code class="codeph">GROUP</code> <code class="codeph">BY</code>的特定级别。有关复合柱的更多示例，请参阅<a href="sql-aggregation-data-warehouses.html#GUID-C063BB2C-ACF8-4878-92F6-59A2913A1449__g1014117" title="GROUPING_SETS语句和等效GROUP BY">表20-3</a> 。
                  </p>
                  <div class="example" id="GUID-FC174F30-F8AA-4169-A6E0-68CF3DD60DF4__GUID-7E1D9987-C87A-4746-9183-84A15BF16D50">
                     <p class="titleinexample">例20-9复合列</p>
                     <p>您无法完全控制<code class="codeph">CUBE</code>和<code class="codeph">ROLLUP</code>聚合级别。例如，请考虑以下语句：</p><pre class="oac_no_warn" dir="ltr">SELECT channel_desc，calendar_month_desc，country_iso_code，TO_CHAR（SUM（amount_sold），'9,999,999,999'）SALES $ FROM sales，customers，times，channels，countries WHERE sales.time_id = times.time_id AND sales.cust_id = customers.cust_id AND customers.country_id = countries.country_id AND sales.channel_id = channels.channel_id AND channels.channel_desc IN（'Direct Sales'，'Internet'）AND times.calendar_month_desc IN（'2000-09'，'2000-10'）AND country_iso_code IN（' GB'，'US'）GROUP BY ROLLUP（channel_desc，calendar_month_desc，country_iso_code）;</pre><p>此语句导致Oracle计算以下分组：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">（channel_desc，calendar_month_desc，country_iso_code）</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">（channel_desc，calendar_month_desc）</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">（channel_desc）</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">（）</code></p>
                        </li>
                     </ul>
                     <p>如果您只对这些分组中的第一个，第三个和第四个感兴趣，则不能在不使用复合列的情况下将计算限制为这些分组。对于复合列，可以通过在汇总时将月份和国家/地区视为一个单元来实现。括号中的列在计算<code class="codeph">CUBE</code>和<code class="codeph">ROLLUP</code>时被视为一个单元。因此，你会说：</p><pre class="oac_no_warn" dir="ltr">SELECT channel_desc，calendar_month_desc，country_iso_code，TO_CHAR（SUM（amount_sold），'9,999,999,999'）SALES $ FROM sales，customers，times，channels，countries WHERE sales.time_id = times.time_id AND sales.cust_id = customers.cust_id AND sales.channel_id = channels.channel_id AND channels.channel_desc IN（'Direct Sales'，'Internet'）AND times.calendar_month_desc IN（'2000-09'，'2000-10'）AND country_iso_code IN（'GB'，'US'）GROUP BY ROLLUP（channel_desc，（calendar_month_desc，country_iso_code））; CHANNEL_DESC CALENDAR CO SALES $ -------------------- --------  -  -------------- Internet 2000-09 GB 228,241 Internet 2000-09 US 228,241 Internet 2000-10 GB 239,236 Internet 2000-10 US 239,236 Internet 934,955 Direct Sales 2000-09 GB 1,217,808 Direct Sales 2000-09 US 1,217,808 Direct Sales 2000-10 GB 1,225,584 Direct Sales 2000- 10美国1,225,584直接销售4,886,784 5,821,739</pre></div>
                  <!-- class="example" -->
               </div>
            </div><a id="DWHSG8637"></a><a id="DWHSG8638"></a><a id="DWHSG8636"></a><div class="props_rev_3"><a id="GUID-75B860E5-3AE6-4E62-8837-A4497D8207CF" name="GUID-75B860E5-3AE6-4E62-8837-A4497D8207CF"></a><h3 id="DWHSG-GUID-75B860E5-3AE6-4E62-8837-A4497D8207CF" class="sect3"><span class="enumeration_section">20.7</span>连锁分组和数据聚合</h3>
               <div>
                  <p>级联<a id="d74861e2239" class="indexterm-anchor"></a>分组提供了一种简洁的方法来生成有用的分组组合。使用连接分组指定的分组产生每个分组集的分组的交叉乘积。跨产品操作甚至可以使少量连接分组生成大量最终组。通过列出多个分组集，多维数据集和汇总，并使用逗号分隔它们来指定连接分组。以下是连接分组集的示例：</p><pre class="oac_no_warn" dir="ltr">GROUP BY GROUPING SETS（a，b），GROUPING SETS（c，d）</pre><p>此SQL定义以下分组：</p><pre class="oac_no_warn" dir="ltr">（a，c），（a，d），（b，c），（b，d）</pre><p>由于以下原因，分组集的连接非常有用：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>易于查询开发</p>
                        <p>您无需手动枚举所有分组。</p>
                     </li>
                     <li>
                        <p>由应用程序使用</p>
                        <p>分析应用程序生成的SQL通常涉及分组集的连接，每个分组集定义维所需的分组。</p>
                     </li>
                  </ul>
                  <div class="example" id="GUID-75B860E5-3AE6-4E62-8837-A4497D8207CF__GUID-B9D01A95-626F-4A86-9D8C-3C4F47B88A21">
                     <p class="titleinexample">例20-10连接分组</p>
                     <p>您还可以在<code class="codeph">GROUP</code> <code class="codeph">BY</code>子句中指定多个分组。例如，如果您希望在<code class="codeph">time</code>维度（ <code class="codeph">year</code> ， <code class="codeph">month</code>和<code class="codeph">day</code> ）以及<code class="codeph">geography</code>维度（ <code class="codeph">region</code> ）中的所有级别上汇总的每个产品的汇总销售值，则可以发出以下语句：</p><pre class="oac_no_warn" dir="ltr">SELECT channel_desc，calendar_year，calendar_quarter_desc，country_iso_code，cust_state_province，TO_CHAR（SUM（amount_sold），'9,999,999,999'）SALES $ FROM sales，customers，times，channels，countries WHERE sales.time_id = times.time_id AND sales.cust_id = customers.cust_id AND sales.channel_id = channels.channel_id AND countries.country_id = customers.country_id AND channels.channel_desc IN（'Direct Sales'，'Internet'）AND times.calendar_month_desc IN（'2000-09'，'2000-10'）AND countries.country_iso_code IN（'GB'，'FR'）GROUP BY channel_desc，GROUPING SETS（ROLLUP（calendar_year，calendar_quarter_desc），ROLLUP（country_iso_code，cust_state_province））;</pre><p>这导致以下分组：</p>
                  </div>
                  <!-- class="example" -->
                  <ul style="list-style-type:disc">
                     <li>
                        <p>（ <code class="codeph">channel_desc</code> ， <code class="codeph">calendar_year</code> ， <code class="codeph">calendar_quarter_desc</code> ）</p>
                     </li>
                     <li>
                        <p>（ <code class="codeph">channel_desc</code> ， <code class="codeph">calendar_year</code> ）</p>
                     </li>
                     <li>
                        <p>（ <code class="codeph">channel_desc</code> ）</p>
                     </li>
                     <li>
                        <p>（ <code class="codeph">channel_desc</code> ， <code class="codeph">country_iso_code</code> ， <code class="codeph">cust_state_province</code> ）</p>
                     </li>
                     <li>
                        <p>（ <code class="codeph">channel_desc</code> ， <code class="codeph">country_iso_code</code> ）</p>
                     </li>
                     <li>
                        <p>（ <code class="codeph">channel_desc</code> ）</p>
                     </li>
                  </ul>
                  <p>这是以下的交叉产品：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>表达式<code class="codeph">channel_desc</code></p>
                     </li>
                     <li>
                        <p><code class="codeph">ROLLUP</code> （ <code class="codeph">calendar_year</code> ， <code class="codeph">calendar_quarter_desc</code> ），相当于（（ <code class="codeph">calendar_year</code> ， <code class="codeph">calendar_quarter_desc</code> ），（ <code class="codeph">calendar_year</code> ），（））</p>
                     </li>
                     <li>
                        <p><code class="codeph">ROLLUP(country_iso_code, cust_state_province)</code> ，相当于（（ <code class="codeph">country_iso_code</code> ， <code class="codeph">cust_state_province</code> ），（ <code class="codeph">country_iso_code</code> ），（））</p>
                     </li>
                  </ul>
                  <p>请注意，输出包含两次出现的（ <code class="codeph">channel_desc</code> ）组。要过滤掉extra（ <code class="codeph">channel_desc</code> ）组，查询可以使用<code class="codeph">GROUP_ID</code>函数。
                  </p>
                  <p>另一个连接的连接示例是<a href="sql-aggregation-data-warehouses.html#GUID-75B860E5-3AE6-4E62-8837-A4497D8207CF__CHDJHEJJ">示例20-11</a> ，显示了两个分组集的叉积。
                  </p>
                  <div class="example" id="GUID-75B860E5-3AE6-4E62-8837-A4497D8207CF__CHDJHEJJ">
                     <p class="titleinexample">例20-11连接分组（两个分组集的交叉乘积）</p><pre class="oac_no_warn" dir="ltr">SELECT country_iso_code，cust_state_province，calendar_year，calendar_quarter_desc，TO_CHAR（SUM（amount_sold），'9,999,999,999'）SALES $ FROM sales，customers，times，channels，countries WHERE sales.time_id = times.time_id AND sales.cust_id = customers.cust_id AND countries .country_id = customers.country_id AND sales.channel_id = channels.channel_id AND channels.channel_desc IN（'Direct Sales'，'Internet'）AND times.calendar_month_desc IN（'2000-09'，'2000-10'）AND country_iso_code IN （'GB'，'FR'）GROUP BY GROUPING SETS（country_iso_code，cust_state_province），GROUPING SETS（calendar_year，calendar_quarter_desc）;</pre><p>该语句导致分组的计算：</p>
                  </div>
                  <!-- class="example" -->
                  <ul style="list-style-type:disc">
                     <li>
                        <p>（ <code class="codeph">country_iso_code</code> ， <code class="codeph">year</code> ），（ <code class="codeph">country_iso_code</code> ， <code class="codeph">calendar_quarter_desc</code> ），（ <code class="codeph">cust_state_province</code> ， <code class="codeph">year</code> ）和（ <code class="codeph">cust_state_province</code> ， <code class="codeph">calendar_quarter_desc</code> ）</p>
                     </li>
                  </ul>
               </div><a id="DWHSG8640"></a><a id="DWHSG8641"></a><a id="DWHSG8639"></a><div class="props_rev_3"><a id="GUID-C26D0B17-7931-4D18-AA29-C7DB45ED2AB8" name="GUID-C26D0B17-7931-4D18-AA29-C7DB45ED2AB8"></a><h4 id="DWHSG-GUID-C26D0B17-7931-4D18-AA29-C7DB45ED2AB8" class="sect4"><span class="enumeration_section">20.7.1</span>连续分组和分层数据立方体</h4>
                  <div>
                     <p>连接分组最重要的用途之一是生成分层多维数据集所需的聚合。分层多维数据集是一种数据集，其中数据沿着每个维度的汇总层次聚合，并且这些聚合跨维度组合。它包括商业智能查询所需的典型聚合集。通过使用连接分组，您可以生成分层多维数据集所需的所有聚合，只需<span class="italic">n个</span> <code class="codeph">ROLLUP</code> （其中<span class="italic">n</span>是维数），并避免生成不需要的聚合。
                     </p>
                     <p>仅考虑<code class="codeph">sh</code>示例模式数据集中的三个维度，每个维度都具有多级层次结构：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>时间： <code class="codeph">year</code> ， <code class="codeph">quarter</code> ， <code class="codeph">month</code> ， <code class="codeph">day</code> （ <code class="codeph">week</code>是单独的层次结构）</p>
                        </li>
                        <li>
                           <p>产品： <code class="codeph">category</code> ， <code class="codeph">subcategory</code> ， <code class="codeph">prod_name</code></p>
                        </li>
                        <li>
                           <p>地理： <code class="codeph">region</code> ， <code class="codeph">subregion</code> ， <code class="codeph">country</code> ， <code class="codeph">state</code> ， <code class="codeph">city</code></p>
                        </li>
                     </ul>
                     <p>此数据使用每个层次结构的列表示，为维度创建总共12列，以及包含销售数字的列。</p>
                     <p>为了满足您的商业智能需求，您希望计算和存储各种维度组合的某些聚合。在<a href="sql-aggregation-data-warehouses.html#GUID-C26D0B17-7931-4D18-AA29-C7DB45ED2AB8__i1007098">例20-12中</a> ，您为所有级别创建聚合，但“day”除外，这将创建太多行。特别是，您希望在每个维度中使用<code class="codeph">ROLLUP</code>来生成有用的聚合。在每个维度中拥有基于<code class="codeph">ROLLUP</code>的聚合后，您需要将它们与其他维度组合在一起。这将生成分层多维数据集。请注意，这是不是在所有相同的<code class="codeph">CUBE</code>使用维列的所有十二：将创造2的12次方（4096）汇聚组，其中只需要一小部分。连接分组集可以轻松生成所需的聚合。<a href="sql-aggregation-data-warehouses.html#GUID-C26D0B17-7931-4D18-AA29-C7DB45ED2AB8__i1007098">例20-12</a>显示了需要<code class="codeph">GROUP</code> <code class="codeph">BY</code>子句的位置。
                     </p>
                     <div class="example" id="GUID-C26D0B17-7931-4D18-AA29-C7DB45ED2AB8__i1007098">
                        <p class="titleinexample">示例20-12连续分组和分层多维数据集</p><pre class="oac_no_warn" dir="ltr">SELECT calendar_year，calendar_quarter_desc，calendar_month_desc，country_region，country_subregion，countries.country_iso_code，cust_state_province，cust_city，prod_category_desc，prod_subcategory_desc，prod_name，TO_CHAR（SUM（amount_sold），'9,999,999,999'）销售额，客户，时间，渠道，国家/地区，产品销售额WHERE sales.time_id = times.time_id AND sales.cust_id = customers.cust_id AND sales.channel_id = channels.channel_id AND sales.prod_id = products.prod_id AND customers.country_id = countries.country_id AND channels.channel_desc IN（'Direct Sales' ，'互联网'）AND times.calendar_month_desc IN（'2000-09'，'2000-10'）AND prod_name IN（'Envoy Ambassador'，'Mouse Pad'）AND countries.country_iso_code IN（'GB'，'US' ）GROUP BY ROLLUP（calendar_year，calendar_quarter_desc，calendar_month_desc），ROLLUP（country_region，country_subregion，countries.country_iso_code，cust_state_province，cust_city），ROLLUP（prod_category_desc，prod_subcategory_desc，prod_name）;</pre><p><code class="codeph">GROUP</code> <code class="codeph">BY</code>规范中的汇总生成以下组，每个维度四个。
                        </p>
                     </div>
                     <!-- class="example" -->
                     <div class="tblformalwide" id="GUID-C26D0B17-7931-4D18-AA29-C7DB45ED2AB8__BABEHGHD">
                        <p class="titleintable">表20-4分层多维数据集示例</p>
                        <table cellpadding="4" cellspacing="0" class="FormalWide" title="分层多维数据集示例" width="100%" border="1" summary="Hierarchical CUBE Examples" frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="26%" id="d74861e2582">按时间滚动</th>
                                 <th align="left" valign="bottom" width="31%" id="d74861e2585">ROLLUP按产品分类</th>
                                 <th align="left" valign="bottom" width="44%" id="d74861e2588">ROLLUP按地理位置</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="26%" id="d74861e2593" headers="d74861e2582 ">
                                    <p><code class="codeph">年，季度，月份</code></p>
                                 </td>
                                 <td align="left" valign="top" width="31%" headers="d74861e2593 d74861e2585 ">
                                    <p><code class="codeph">类别，子类别，名称</code></p>
                                 </td>
                                 <td align="left" valign="top" width="44%" headers="d74861e2593 d74861e2588 ">
                                    <p><code class="codeph">地区，次区域，国家，州，城市</code></p>
                                    <p><code class="codeph">地区，次区域，国家，国家</code></p>
                                    <p><code class="codeph">地区，次区域，国家</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="26%" id="d74861e2612" headers="d74861e2582 ">
                                    <p><code class="codeph">一年，季度</code></p>
                                 </td>
                                 <td align="left" valign="top" width="31%" headers="d74861e2612 d74861e2585 ">
                                    <p><code class="codeph">类别，子类别</code></p>
                                 </td>
                                 <td align="left" valign="top" width="44%" headers="d74861e2612 d74861e2588 ">
                                    <p><code class="codeph">地区，次区域</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="26%" id="d74861e2625" headers="d74861e2582 ">
                                    <p><code class="codeph">年</code></p>
                                 </td>
                                 <td align="left" valign="top" width="31%" headers="d74861e2625 d74861e2585 ">
                                    <p><code class="codeph">类别</code></p>
                                 </td>
                                 <td align="left" valign="top" width="44%" headers="d74861e2625 d74861e2588 ">
                                    <p><code class="codeph">区域</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="26%" id="d74861e2638" headers="d74861e2582 ">
                                    <p><code class="codeph">一直</code></p>
                                 </td>
                                 <td align="left" valign="top" width="31%" headers="d74861e2638 d74861e2585 ">
                                    <p><code class="codeph">所有产品</code></p>
                                 </td>
                                 <td align="left" valign="top" width="44%" headers="d74861e2638 d74861e2588 ">
                                    <p><code class="codeph">所有地理位置</code></p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <p>在先前的SQL中指定的连接分组集将采用表中列出的<code class="codeph">ROLLUP</code>聚合并对它们执行交叉产品。交叉产品将创建数据的分层多维数据集所需的96（4x4x6）聚合组。使用三个<code class="codeph">ROLLUP</code>表达式替换原本需要96个分组集表达式的主要优点是：简洁的SQL不易出错，易于维护，并且可以实现更好的查询优化。您可以想象具有更多维度和更多级别的多维数据集如何使连接分组的使用更加有利。
                     </p>
                     <p>有关分层多维数据集的详细信息，请参阅<span class="q">“ <a href="sql-aggregation-data-warehouses.html#GUID-FB000241-BE8E-43F4-9789-24A0472AB193">在SQL中使用分层多维</a></span>数据集”。
                     </p>
                  </div>
               </div>
            </div><a id="DWHSG8642"></a><div class="props_rev_3"><a id="GUID-F33D5E19-33B8-424F-A717-D30EDA3D08D6" name="GUID-F33D5E19-33B8-424F-A717-D30EDA3D08D6"></a><h3 id="DWHSG-GUID-F33D5E19-33B8-424F-A717-D30EDA3D08D6" class="sect3"><span class="enumeration_section">20.8</span>在数据仓库中使用聚合时的注意事项</h3>
               <div>
                  <p>本节讨论以下主题。</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="sql-aggregation-data-warehouses.html#GUID-FB38E890-A91B-4645-9422-792E1C9BC238">ROLLUP和CUBE中的层次结构处理</a></p>
                     </li>
                     <li>
                        <p><a href="sql-aggregation-data-warehouses.html#GUID-D4CEA4CE-3890-4440-AFC7-3634EA01FAFA">ROLLUP和CUBE中的列容量</a></p>
                     </li>
                     <li>
                        <p><a href="sql-aggregation-data-warehouses.html#GUID-66EBA3D0-211F-4A57-BA95-1A8A93D77360">HADING子句与GROUP BY Extensions一起使用</a></p>
                     </li>
                     <li>
                        <p><a href="sql-aggregation-data-warehouses.html#GUID-496C3409-51FA-4DE5-BF5F-6DF793E322F7">ORDER BY子句与GROUP BY Extensions一起使用</a></p>
                     </li>
                     <li>
                        <p><a href="sql-aggregation-data-warehouses.html#GUID-DDCF4BCB-A56B-4C14-9056-75452022F43B">使用ROLLUP和CUBE的其他聚合函数</a></p>
                     </li>
                     <li>
                        <p><a href="sql-aggregation-data-warehouses.html#GUID-82F7AE38-4527-44C4-A140-234BFC9AFFD1">使用内存中聚合</a></p>
                     </li>
                  </ul>
               </div><a id="DWHSG8644"></a><a id="DWHSG8643"></a><div class="props_rev_3"><a id="GUID-FB38E890-A91B-4645-9422-792E1C9BC238" name="GUID-FB38E890-A91B-4645-9422-792E1C9BC238"></a><h4 id="DWHSG-GUID-FB38E890-A91B-4645-9422-792E1C9BC238" class="sect4"><span class="enumeration_section">20.8.1</span> ROLLUP和CUBE中的层次结构处理</h4>
                  <div>
                     <p><code class="codeph">ROLLUP</code>和<code class="codeph">CUBE</code>扩展独立于系统中的任何层次结构元数据。它们的计算完全基于它们出现的<code class="codeph">SELECT</code>语句中指定的列。无论层次结构元数据是否可用，此方法都可以使用<code class="codeph">CUBE</code>和<code class="codeph">ROLLUP</code> 。处理层次维度中的级别的最简单方法是使用<code class="codeph">ROLLUP</code>扩展并通过单独的列显式指示级别。下面的代码显示了一个简单的例子，其中几个月累计到季度和季度累计达数年。
                     </p>
                     <div class="example" id="GUID-FB38E890-A91B-4645-9422-792E1C9BC238__GUID-AFCD8C7F-019B-48E6-BC2E-357E8C2E91CD">
                        <p class="titleinexample">示例20-13 ROLLUP和CUBE层次结构处理</p><pre class="oac_no_warn" dir="ltr">SELECT calendar_year，calendar_quarter_number，calendar_month_number，SUM（amount_sold）FROM sales，times，products，customers，countries WHERE sales.time_id = times.time_id AND sales.prod_id = products.prod_id AND customers.country_id = countries.country_id AND sales.cust_id = customers.cust_id AND prod_name IN（'Envoy Ambassador'，'Mouse Pad'）AND country_iso_code ='GB'AND calendar_year = 1999 GROUP BY ROLLUP（calendar_year，calendar_quarter_number，calendar_month_number）; CALENDAR_YEAR CALENDAR_QUARTER_NUMBER CALENDAR_MONTH_NUMBER SUM（AMOUNT_SOLD）------------- ----------------------- ------- -------------- ---------------- 1999 1 1 5521.34 1999 1 2 22232.95 1999 1 3 10672.63 1999 1 38426.92 1999 2 4 23658.05 1999 2 5 5766.31 1999 2 6 23939.32 1999 2 53363.68 1999 3 7 12132.18 1999 3 8 13128.96 1999 3 9 19571.96 1999 3 44833.1 1999 4 10 15752.18 1999 4 11 7011.21 1999 4 12 14257.5 1999 4 37020.89 1999 173644.59 173644.59</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="DWHSG8645"></a><div class="props_rev_3"><a id="GUID-D4CEA4CE-3890-4440-AFC7-3634EA01FAFA" name="GUID-D4CEA4CE-3890-4440-AFC7-3634EA01FAFA"></a><h4 id="DWHSG-GUID-D4CEA4CE-3890-4440-AFC7-3634EA01FAFA" class="sect4"><span class="enumeration_section">20.8.2</span> ROLLUP和CUBE中的列容量</h4>
                  <div>
                     <p><code class="codeph">CUBE</code> ， <code class="codeph">ROLLUP</code>和<code class="codeph">GROUPING</code> <code class="codeph">SETS</code>不限制<code class="codeph">GROUP</code> <code class="codeph">BY</code>子句列容量。<code class="codeph">GROUP</code> <code class="codeph">BY</code>子句（带或不带扩展名）最多可以使用255列。但是， <code class="codeph">CUBE</code>的组合爆炸使得使用<code class="codeph">CUBE</code>扩展名指定大量列是不明智的。考虑到<code class="codeph">CUBE</code>的20列列表将在结果集中为20个组合创建2个。一个非常大的<code class="codeph">CUBE</code>列表可能会使系统资源紧张，因此必须仔细测试任何此类查询的性能及其对系统的负载。
                     </p>
                  </div>
               </div><a id="DWHSG8646"></a><div class="props_rev_3"><a id="GUID-66EBA3D0-211F-4A57-BA95-1A8A93D77360" name="GUID-66EBA3D0-211F-4A57-BA95-1A8A93D77360"></a><h4 id="DWHSG-GUID-66EBA3D0-211F-4A57-BA95-1A8A93D77360" class="sect4"><span class="enumeration_section">20.8.3</span>具有与GROUP BY扩展一起使用的子句</h4>
                  <div>
                     <p><code class="codeph">SELECT</code>语句的<code class="codeph">HAVING</code>子句不受<code class="codeph">GROUP</code> <code class="codeph">BY</code>的使用影响。请注意， <code class="codeph">HAVING</code>子句中指定的条件适用于结果集的小计和非小计行。在某些情况下，查询可能需要从<code class="codeph">HAVING</code>子句中排除小计行或非小计行。这可以通过将<code class="codeph">GROUPING</code>或<code class="codeph">GROUPING_ID</code>函数与<code class="codeph">HAVING</code>子句一起使用来实现。有关<a href="sql-aggregation-data-warehouses.html#GUID-F80858F3-45B3-4D46-B712-1B55CB8DA2F4__i1006706">示例</a> ，请参见<a href="sql-aggregation-data-warehouses.html#GUID-F80858F3-45B3-4D46-B712-1B55CB8DA2F4__i1006706">示例20-7</a>及其关联的SQL语句。
                     </p>
                  </div>
               </div><a id="DWHSG8647"></a><div class="props_rev_3"><a id="GUID-496C3409-51FA-4DE5-BF5F-6DF793E322F7" name="GUID-496C3409-51FA-4DE5-BF5F-6DF793E322F7"></a><h4 id="DWHSG-GUID-496C3409-51FA-4DE5-BF5F-6DF793E322F7" class="sect4"><span class="enumeration_section">20.8.4</span> ORDER BY子句与GROUP BY Extensions一起使用</h4>
                  <div>
                     <p>在许多情况下，查询必须以某种方式对行进行排序，这是通过<code class="codeph">ORDER</code> <code class="codeph">BY</code>子句完成的。<code class="codeph">SELECT</code>语句的<code class="codeph">ORDER</code> <code class="codeph">BY</code>子句不受<code class="codeph">GROUP</code> <code class="codeph">BY</code> ，因为在<code class="codeph">GROUP</code> <code class="codeph">BY</code>计算完成后应用<code class="codeph">ORDER</code> <code class="codeph">BY</code>子句。
                     </p>
                     <p>请注意， <code class="codeph">ORDER</code> <code class="codeph">BY</code>规范不区分结果集的聚合行和非聚合行。例如，您可能希望按递减顺序列出销售数据，但仍然在每个组的末尾都有小计。简单地按降序排序销售数据是不够的，因为这会将小计（最大值）放在每个组的开头。因此， <code class="codeph">ORDER</code> <code class="codeph">BY</code>子句中的列必须包含区分聚合列和非聚合列的列。此要求意味着使用<code class="codeph">ORDER</code> <code class="codeph">BY</code>查询以及<code class="codeph">GROUP</code> <code class="codeph">BY</code>聚合扩展通常需要使用一个或多个<code class="codeph">GROUPING</code>函数。
                     </p>
                  </div>
               </div><a id="DWHSG8648"></a><div class="props_rev_3"><a id="GUID-DDCF4BCB-A56B-4C14-9056-75452022F43B" name="GUID-DDCF4BCB-A56B-4C14-9056-75452022F43B"></a><h4 id="DWHSG-GUID-DDCF4BCB-A56B-4C14-9056-75452022F43B" class="sect4"><span class="enumeration_section">20.8.5</span>使用ROLLUP和CUBE的其他聚合函数</h4>
                  <div>
                     <p>本章中的示例显示了与<code class="codeph">SUM</code>函数一起使用的<code class="codeph">ROLLUP</code>和<code class="codeph">CUBE</code> 。虽然这是最常见的聚合类型，但这些扩展也可以与<code class="codeph">GROUP</code> <code class="codeph">BY</code>子句可用的所有其他函数一起使用，例如<code class="codeph">COUNT</code> ， <code class="codeph">AVG</code> ， <code class="codeph">MIN</code> ， <code class="codeph">MAX</code> ， <code class="codeph">STDDEV</code>和<code class="codeph">VARIANCE</code> 。在表格式分析中经常需要的<code class="codeph">COUNT</code>可能是第二常用功能。
                     </p>
                  </div>
               </div><a id="DWHSG9336"></a><a id="DWHSG9337"></a><a id="DWHSG9335"></a><div class="props_rev_3"><a id="GUID-82F7AE38-4527-44C4-A140-234BFC9AFFD1" name="GUID-82F7AE38-4527-44C4-A140-234BFC9AFFD1"></a><h4 id="DWHSG-GUID-82F7AE38-4527-44C4-A140-234BFC9AFFD1" class="sect4"><span class="enumeration_section">20.8.6</span>使用内存中聚合</h4>
                  <div>
                     <div class="section">
                        <p>分析查询通常通过对数据执行复杂聚合来尝试查找模式和趋势。内存中聚合使用<code class="codeph">KEY VECTOR</code>和<code class="codeph">VECTOR GROUP BY</code>操作来优化涉及从单个大表到多个小表的聚合和连接的查询块，例如在典型的星型查询中。这些操作使用高效的内存数组进行连接和聚合，并且在基础表存储在内存中列存储（IM列存储）中时尤其有效。
                        </p>
                        <p><code class="codeph">VECTOR GROUP BY</code>转换是一种优化转换，可实现高效的基于内存阵列的聚合。它在表扫描期间将聚合值累积到内存数组中。这样可以提高连接和连接以及聚合的性能。
                        </p>
                        <p><code class="codeph">VECTOR GROUP BY</code>转换是一个由两部分组成的过程，类似于星形转换，包括以下步骤：</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>扫描维度表并应用任何<code class="codeph">WHERE</code>子句谓词。基于这些扫描的结果创建称为关键向量的新数据结构。</span><div>
                              <p>关键向量类似于布隆过滤器，因为它允许在事实表的扫描期间将连接谓词应用为附加过滤器谓词，但它还使Oracle数据库能够在事实表的扫描期间执行<code class="codeph">GROUP BY</code>或聚合而不是之后必须这样做。
                              </p>
                           </div>
                        </li>
                        <li class="stepexpand"><span>事实表扫描的结果将连接回作为密钥向量创建的一部分创建的临时表。</span></li>
                     </ol>
                     <div class="section">
                        <p>这两个阶段的组合极大地提高了具有复杂聚合的多表连接的效率。这两个阶段都在查询的执行计划中可见。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-82F7AE38-4527-44C4-A140-234BFC9AFFD1__GUID-10E1B395-5DC0-4DCB-94C7-BC81162940A0">
                        <p class="titleinexample">例20-14示例：使用VECTOR GROUP BY转换进行聚合</p>
                        <p>请考虑以下将<code class="codeph">products</code> ， <code class="codeph">customers</code>和<code class="codeph">times</code>维度与<code class="codeph">sales</code>事实表相关联的查询：</p><pre class="oac_no_warn" dir="ltr">SELECT p.department_name，c.customer_id，t.fiscal_year，SUM（sales）FROM PRODUCTS p，CUSTOMERS c，TIMES t，SALES s WHERE p.product_id = s.product_id AND c.customer_id = s.customer_id AND t.time_id = s.time_id GROUP BY p.department_name，c.customer_id，t.fiscal_year;</pre><p>配置IM列存储时，优化程序会重写此查询以使用向量连接和<code class="codeph">VECTOR GROUP BY</code>聚合。<a href="sql-aggregation-data-warehouses.html#GUID-82F7AE38-4527-44C4-A140-234BFC9AFFD1__BCGEIDGA">图20-2</a>描述了如何使用<code class="codeph">VECTOR GROUP BY</code>执行聚合。维度表<code class="codeph">PRODUCTS</code> ， <code class="codeph">CUSTOMERS</code>和<code class="codeph">TIMES</code>上的谓词将转换为事实表<code class="codeph">SALES</code>上的过滤器。 <code class="codeph">GROUP BY</code>通过使用内存数组与<code class="codeph">SALES</code>表的扫描同时执行。
                        </p>
                        <div class="figure" id="GUID-82F7AE38-4527-44C4-A140-234BFC9AFFD1__BCGEIDGA">
                           <p class="titleinfigure">图20-2使用Oracle内存中列存储的矢量组</p><img src="img/in_mem_vector_aggr.gif" alt="下面是图20-2的描述" title="下面是图20-2的描述" longdesc="img_text/in_mem_vector_aggr.html"><br><a href="img_text/in_mem_vector_aggr.html">“图20-2使用Oracle内存中列存储的矢量组”的描述</a></div>
                        <!-- class="figure" -->
                     </div>
                     <!-- class="example" -->
                  </div>
               </div>
            </div><a id="DWHSG8650"></a><a id="DWHSG8649"></a><div class="props_rev_3"><a id="GUID-9D821BF6-A3A0-43BC-9C90-C476734E5905" name="GUID-9D821BF6-A3A0-43BC-9C90-C476734E5905"></a><h3 id="DWHSG-GUID-9D821BF6-A3A0-43BC-9C90-C476734E5905" class="sect3"><span class="enumeration_section">20.9</span>使用WITH子句进行计算</h3>
               <div>
                  <p></p>
                  <p><code class="codeph">WITH</code>子句（正式名称为<code class="codeph">subquery_factoring_clause</code> ）使您可以在复杂查询中多次出现时在<code class="codeph">SELECT</code>语句中重用相同的查询块。<code class="codeph">WITH</code>是SQL-99标准的一部分。当查询具有对同一查询块的多个引用并且存在联接和聚合时，这尤其有用。使用<code class="codeph">WITH</code>子句，Oracle检索查询块的结果并将它们存储在用户的临时表空间中。根据系统的配置方式，结果可能存储在共享临时表空间或本地临时表空间中。请注意，Oracle数据库不支持递归使用<code class="codeph">WITH</code>子句。请注意，Oracle数据库支持递归使用<code class="codeph">WITH</code>子句，该子句可用于与物料清单一起使用或将父子层次结构扩展到父子层次结构的查询。有关更多信息，请参见<a href="../sqlrf/CREATE-MATERIALIZED-VIEW-LOG.html#SQLRF54208" target="_blank"><span class="italic">Oracle数据库SQL语言参考</span></a> 。
                  </p>
                  <div class="infoboxnote" id="GUID-9D821BF6-A3A0-43BC-9C90-C476734E5905__GUID-35763747-1984-4D8E-8479-D9521F1D4BF3">
                     <p class="notep1">注意：</p>
                     <p>在以前的版本中，术语<span class="italic">临时表空间</span>引用了现在称为<span class="italic">共享临时表空间的内容</span> 。
                     </p>
                  </div>
                  <p>以下查询是使用<code class="codeph">WITH</code>子句可以提高性能和更简单地编写SQL的示例。查询计算每个渠道的销售总额，并将其保存在名称<code class="codeph">channel_summary</code> 。然后，它检查每个渠道的销售总额，以查看任何渠道的销售额是否超过总销售额的三分之一。通过使用<code class="codeph">WITH</code>子句， <code class="codeph">channel_summary</code>数据只计算一次，从而避免了对大型销售表的额外扫描。
                  </p>
                  <div class="example" id="GUID-9D821BF6-A3A0-43BC-9C90-C476734E5905__GUID-C87D4E27-A805-41F7-BDF3-A4F95EF48890">
                     <p class="titleinexample">例20-15 with子句</p><pre class="oac_no_warn" dir="ltr">WITH channel_summary AS（SELECT channels.channel_desc，SUM（amount_sold）AS channel_total FROM sales，channels WHERE sales.channel_id = channels.channel_id GROUP BY channels.channel_desc）SELECT channel_desc，channel_total FROM channel_summary WHERE channel_total&gt;（SELECT SUM（channel_total）* 1 / 3 FROM channel_summary）; CHANNEL_DESC CHANNEL_TOTAL -------------------- -------------直接销售57875260.6</pre><p>请注意，也可以使用<a href="sql-analysis-reporting-data-warehouses.html#GUID-20EFBF1E-F79D-4E4A-906C-6E496EECA684" title="使用返回近似结果的SQL函数计算近似聚合。它们主要用于数据探索查询，其中不需要精确值，并且可以接受近似值。LISTAGG函数根据ORDER BY子句对每个组中的数据进行排序，然后连接度量列的值。Oracle数据库提供了一组返回近似百分位数结果的SQL函数。这些功能可用于监控质量，跟踪社交媒体活动，监控性能以及搜索数据集中的异常值。">SQL for Analysis and Reporting中</a>描述的报告聚合函数有效地执行此示例。
                     </p>
                  </div>
                  <!-- class="example" -->
               </div>
            </div><a id="DWHSG8651"></a><div class="props_rev_3"><a id="GUID-FB000241-BE8E-43F4-9789-24A0472AB193" name="GUID-FB000241-BE8E-43F4-9789-24A0472AB193"></a><h3 id="DWHSG-GUID-FB000241-BE8E-43F4-9789-24A0472AB193" class="sect3"><span class="enumeration_section">20.10</span>在SQL中使用分层多维数据集</h3>
               <div>
                  <p>本节说明<a id="d74861e3276" class="indexterm-anchor"></a>使用分层多维数据集的示例。它包含以下主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="sql-aggregation-data-warehouses.html#GUID-571478D7-A536-4574-896D-05ACDBD6AB4B">在SQL中指定分层多维数据集</a></p>
                     </li>
                     <li>
                        <p><a href="sql-aggregation-data-warehouses.html#GUID-3C47666C-D660-4562-AA3E-8518D5EC8BA6">在SQL中查询分层多维数据集</a></p>
                     </li>
                  </ul>
               </div><a id="DWHSG8653"></a><a id="DWHSG8652"></a><div class="props_rev_3"><a id="GUID-571478D7-A536-4574-896D-05ACDBD6AB4B" name="GUID-571478D7-A536-4574-896D-05ACDBD6AB4B"></a><h4 id="DWHSG-GUID-571478D7-A536-4574-896D-05ACDBD6AB4B" class="sect4"><span class="enumeration_section">20.10.1</span>在SQL中指定分层多维数据集</h4>
                  <div>
                     <div class="section">
                        <p>神谕<a id="d74861e3316" class="indexterm-anchor"></a>数据库可以在简单有效的SQL查询中指定分层多维数据集。这些分层多维数据集表示许多分析SQL产品中引用的逻辑多维数据集。要以分层多维数据集的形式指定数据，可以使用<code class="codeph">GROUP</code> <code class="codeph">BY</code>子句的一个扩展（连接分组集）来生成分层多维数据集所需的聚合。通过使用连续汇总（沿着每个维度的层次结构向上滚动，然后跨多个维度连接它们），您可以生成分层多维数据集所需的所有聚合。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-571478D7-A536-4574-896D-05ACDBD6AB4B__GUID-BFBACA15-30BC-498F-8502-D7EC8528F543">
                        <p class="titleinexample">例20-16连接的ROLLUP</p>
                        <p>下列<a id="d74861e3330" class="indexterm-anchor"></a><a id="d74861e3332" class="indexterm-anchor"></a>显示为类似于<a href="sql-aggregation-data-warehouses.html#GUID-C26D0B17-7931-4D18-AA29-C7DB45ED2AB8__i1007098">示例20-12</a>的二维示例创建分层多维数据集所需的<code class="codeph">GROUP</code> <code class="codeph">BY</code>子句。以下简单语法执行连续汇总：</p><pre class="oac_no_warn" dir="ltr">GROUP BY ROLLUP（年，季，月），ROLLUP（分部，品牌，项目）</pre><p>此连锁汇总采用类似于上一节<a href="sql-aggregation-data-warehouses.html#GUID-C26D0B17-7931-4D18-AA29-C7DB45ED2AB8__BABEHGHD" title="分层多维数据集示例">中表20-4</a>中列出的<code class="codeph">ROLLUP</code>聚合，并对它们执行交叉产品。交叉产品将创建数据的分层多维数据集所需的16（4x4）个聚合组。
                        </p>
                     </div>
                     <!-- class="example" -->
                  </div>
               </div><a id="DWHSG8655"></a><a id="DWHSG8654"></a><div class="props_rev_3"><a id="GUID-3C47666C-D660-4562-AA3E-8518D5EC8BA6" name="GUID-3C47666C-D660-4562-AA3E-8518D5EC8BA6"></a><h4 id="DWHSG-GUID-3C47666C-D660-4562-AA3E-8518D5EC8BA6" class="sect4"><span class="enumeration_section">20.10.2</span>在SQL中查询分层多维数据集</h4>
                  <div>
                     <div class="section">
                        <p>分析应用程序将数据视为多维数据集，但它们只需要多维数据集的某些切片和区域。连续汇总（分层多维数据集）使关系数据可以被视为多维数据集。要处理复杂的分析查询，基本技术是在外部查询中包含分层多维数据集查询，以指定多维数据集所需的确切切片。Oracle数据库优化嵌套在切片查询中的分层多维数据集的处理。通过应用许多强大的算法，可以以前所未有的速度和规模处理这些查询。这使SQL分析工具和应用程序能够使用一致的查询样式来处理最复杂的问题。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-3C47666C-D660-4562-AA3E-8518D5EC8BA6__GUID-012DD16E-5AA3-43D9-A823-CE3C12E1DF75">
                        <p class="titleinexample">示例20-17分层多维数据集查询</p>
                        <p>请考虑以下分析查询。它由嵌套在切片查询中的分层多维数据集查询组成。</p><pre class="oac_no_warn" dir="ltr">SELECT month，division，sum_sales FROM（SELECT年份，季度，月份，部门，品牌，项目，SUM（销售）sum_sales，GROUPING_ID（ <span class="italic">分组列</span> ）gid FROM销售，产品，时间WHERE <span class="italic">join-condition</span> GROUP BY ROLLUP（年，季度，月份），ROLLUP（分部，品牌，项目））WHERE division = 25 AND month = 200201 AND gid = <span class="italic">gid-for-Division-Month</span> ;</pre><p>指定的内部分层立方体定义了一个简单的立方体，每个维度有两个维度和四个级别。它将生成16组（4个时间级别* 4个产品级别）。查询中的<code class="codeph">GROUPING_ID</code>函数根据其参数中<span class="italic">分组列</span>的聚合级别标识每行所属的特定组。
                        </p>
                        <p>外部查询应用我们的特定查询所需的约束，将Division限制为值25，将Month限制为值200201（在本例中表示2002年1月）。在概念上，它从多维数据集中切割出一小块数据。外部查询对<code class="codeph">GID</code>列的约束（在<span class="italic">gid-for-division-month</span>查询中指示）将是一个键的值，表示数据被分组为<code class="codeph">division</code>和<code class="codeph">month</code>的组合。<code class="codeph">GID</code>约束仅选择在<code class="codeph">GROUP</code> <code class="codeph">BY</code> month，division子句级别聚合的那些行。
                        </p>
                        <p>Oracle数据库根据外部查询条件从查询处理中删除不需要的聚合组。上一个查询的外部条件将结果集限制为单个组聚合<code class="codeph">division</code>和<code class="codeph">month</code> 。此处不需要涉及<code class="codeph">year</code> ， <code class="codeph">month</code> ， <code class="codeph">brand</code>和<code class="codeph">item</code>任何其他组。组修剪优化可识别此并将查询转换为：</p><pre class="oac_no_warn" dir="ltr">SELECT month，division，sum_sales FROM（SELECT <span class="bold">null</span> ， <span class="bold">null</span> ，month，division， <span class="bold">null</span> ， <span class="bold">null</span> ，SUM（sales）sum_sales，GROUPING_ID（ <span class="italic">grouping-columns</span> ）gid FROM sales，products，time WHERE <span class="italic">join-condition</span> <span class="bold">GROUP BY month</span> ， <span class="bold">division</span> ）分区= 25 AND month = 200201 AND gid = <span class="italic">gid-for-Division-Month</span> ;</pre><p>粗体项突出显示已更改的SQL。内部查询现在有一个简单的<code class="codeph">GROUP</code> <code class="codeph">BY</code>子句<code class="codeph">month</code> ， <code class="codeph">division</code> 。列<code class="codeph">year</code> ， <code class="codeph">quarter</code> ， <code class="codeph">brand</code>和<code class="codeph">item</code>已转换为null以匹配简化的<code class="codeph">GROUP</code> <code class="codeph">BY</code>子句。因为查询现在只请求一个组，所以从处理中删除了十六个组中的十五个，大大减少了工作量。对于具有更多维度和更多级别的多维数据集，通过组修剪可能节省的成本可能更高。请注意，组修剪转换适用于所有<code class="codeph">GROUP</code> <code class="codeph">BY</code>扩展： <code class="codeph">ROLLUP</code> ， <code class="codeph">CUBE</code>和<code class="codeph">GROUPING</code> <code class="codeph">SETS</code> 。</p>
                        <p>虽然优化器已将先前的查询简化为简单的<code class="codeph">GROUP</code> <code class="codeph">BY</code> ，但如果组已预先计算并存储在物化视图中，则可以实现更快的响应时间。因为在线分析查询可以要求立方体的任何切片，所以许多组可能需要预先计算并存储在物化视图中。这将在下一节中讨论。
                        </p>
                        <p>本节包含以下主题：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="sql-aggregation-data-warehouses.html#GUID-DBAC103D-EB18-48B7-BA19-2C6CF5A5356C">用于创建物化视图以存储分层多维数据集的SQL</a></p>
                           </li>
                           <li>
                              <p><a href="sql-aggregation-data-warehouses.html#GUID-7E6BC903-3368-41F3-A427-C38B42D3A5C0">分层多维数据集物化视图的示例</a></p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="example" -->
                  </div><a id="DWHSG8656"></a><div class="props_rev_3"><a id="GUID-DBAC103D-EB18-48B7-BA19-2C6CF5A5356C" name="GUID-DBAC103D-EB18-48B7-BA19-2C6CF5A5356C"></a><h5 id="DWHSG-GUID-DBAC103D-EB18-48B7-BA19-2C6CF5A5356C" class="sect5"><span class="enumeration_section">20.10.2.1</span>用于创建物化视图以存储分层多维数据<span class="enumeration_section">集的</span> SQL</h5>
                     <div>
                        <p>分析SQL需要多个用户的快速响应时间，这反过来又要求多维数据集的重要部分预先计算并保存在物化视图中。</p>
                        <p>数据仓库设计人员可以准确选择要实现的数据量。数据仓库可以实现完整的分层多维数据集。虽然这将占用最多的存储空间，但它可确保快速响应多维数据集中的任何查询。或者，数据仓库可以只是部分实现，节省存储空间，但只允许以最高速度回答可能查询的子集。如果查询涵盖其数据集中可能的所有聚合分组，则最好实现整个分层多维数据集。</p>
                        <p>这意味着每个维度的聚合层次结构都与其他每个维度一起预先计算。当然，预先计算完整的分层多维数据集需要比一小组聚合组更多的磁盘空间和更高的创建和刷新时间。在决定创建它之前，必须考虑处理时间和磁盘空间与查询性能之间的权衡。您可以考虑的另一种可能性是使用数据压缩来减少磁盘空间需求。</p>
                        <div class="infoboxnotealso" id="GUID-DBAC103D-EB18-48B7-BA19-2C6CF5A5356C__GUID-463A8500-2A64-442D-A8BE-CA714346481A">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>用于表压缩语法和限制的<a href="../sqlrf/CREATE-TABLE.html#SQLRF54484" target="_blank"><span class="italic">Oracle数据库SQL语言参考</span></a></p>
                              </li>
                              <li>
                                 <p>有关表压缩的更多详细信息，请参见<a href="../admin/managing-tables.html#ADMIN13948" target="_blank"><span class="italic">Oracle数据库管理员指南</span></a></p>
                              </li>
                              <li>
                                 <p>有关表压缩的详细信息，请参阅<span class="q">“ <a href="basic-materialized-views.html#GUID-E75B9A93-BEFB-42A7-B9CB-38FA48EBB266">关于物化视图的存储和表压缩</a> ”</span></p>
                              </li>
                           </ul>
                        </div>
                     </div>
                  </div><a id="DWHSG8658"></a><a id="DWHSG8657"></a><div class="props_rev_3"><a id="GUID-7E6BC903-3368-41F3-A427-C38B42D3A5C0" name="GUID-7E6BC903-3368-41F3-A427-C38B42D3A5C0"></a><h5 id="DWHSG-GUID-7E6BC903-3368-41F3-A427-C38B42D3A5C0" class="sect5"><span class="enumeration_section">20.10.2.2</span>分层多维数据集物化视图的示例</h5>
                     <div>
                        <div class="section">
                           <p>此部分显示完整和部分分层多维数据集物化视图。许多示例旨在说明功能，而不是实际运行。</p>
                           <p>在滚动窗口场景非常常见的数据仓库中，建议您将分层多维数据集存储在多个物化视图中 - 每个您感兴趣的时间段都存储一个。因此，完整的分层多维数据集将存储在四个物化视图中： <code class="codeph">sales_hierarchical_mon_cube_mv</code> ， <code class="codeph">sales_hierarchical_qtr_cube_mv</code> ， <code class="codeph">sales_hierarchical_yr_cube_mv</code>和<code class="codeph">sales_hierarchical_all_cube_mv</code> 。</p>
                           <p>以下语句创建一个完整的分层多维数据集，存储在一组三个复合分区和一个列表分区的物化视图中。</p>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-7E6BC903-3368-41F3-A427-C38B42D3A5C0__GUID-7FCB46BE-7A74-42F4-971E-501BDCEB4A44">
                           <p class="titleinexample">示例20-18完整的分层多维数据集物化视图</p><pre class="oac_no_warn" dir="ltr">CREATE MATERIALIZED VIEW sales_hierarchical_mon_cube_mv PARTITION BY RANGE（星期一）按列表排序（gid）快速按需购买REERY REWRITE作为选择calendar_year yr，calendar_quarter_desc qtr，calendar_month_desc mon，country_id，cust_state_province，cust_city，prod_category，prod_subcategory，prod_name，GROUPING_ID（calendar_year， calendar_quarter_desc，calendar_month_desc，country_id，cust_state_province，cust_city，prod_category，prod_subcategory，prod_name）gid，SUM（amount_sold）s_sales，COUNT（amount_sold）c_sales，COUNT（*）c_star FROM sales s，products p，customers c，times t WHERE s。 cust_id = c.cust_id AND s.prod_id = p.prod_id AND s.time_id = t.time_id GROUP BY calendar_year，calendar_quarter_desc，calendar_month_desc，ROLLUP（country_id，cust_state_province，cust_city），ROLLUP（prod_category，prod_subcategory，prod_name），...; CREATE MATERIALIZED VIEW sales_hierarchical_qtr_cube_mv REFRESH FAST ON DEMAND ENABLE查询重写AS SELECT calendar_year年，calendar_quarter_desc QTR，COUNTRY_ID，cust_state_province两个，cust_city，prod_category，prod_subcategory，PROD_NAME，GROUPING_ID（calendar_year，calendar_quarter_desc，COUNTRY_ID，cust_state_province两个，cust_city，prod_category，prod_subcategory，PROD_NAME）GID ，SUM（amount_sold）s_sales，COUNT（amount_sold）c_sales，COUNT（*）c_star FROM sales s，products p，customers c，times t WHERE s.cust_id = c.cust_id AND s.prod_id = p.prod_id AND s.time_id = t.time_id GROUP BY calendar_year，calendar_quarter_desc，ROLLUP（country_id，cust_state_province，cust_city），ROLLUP（prod_category，prod_subcategory，prod_name），PARTITION BY RANGE（qtr）按列表排序（gid）...;创建物化视图sales_hierarchical_yr_cube_mv按范围划分（年）按列表划分的子项（gid）按要求快速刷新启用QUERY REWRITE作为选项calendar_year yr，country_id，cust_state_province，cust_city，prod_category，prod_subcategory，prod_name，GROUPING_ID（calendar_year，country_id，cust_state_province，cust_city， prod_category，prod_subcategory，prod_name）gid，SUM（amount_sold）s_sales，COUNT（amount_sold）c_sales，COUNT（*）c_star FROM sales s，products p，customers c，times t WHERE s.cust_id = c.cust_id AND s.prod_id = p.prod_id AND s.time_id = t.time_id GROUP BY calendar_year，ROLLUP（country_id，cust_state_province，cust_city），ROLLUP（prod_category，prod_subcategory，prod_name），...; CREATE MATERIALIZED VIEW sales_hierarchical_all_cube_mv REFRESH FAST ON DERMAND ENABLE QUERY REWRITE as SELECT country_id，cust_state_province，cust_city，prod_category，prod_subcategory，prod_name，GROUPING_ID（country_id，cust_state_province，cust_city，prod_category，prod_subcategory，prod_name）gid，SUM（amount_sold）s_sales，COUNT（amount_sold ）c_sales，COUNT（*）c_star FROM sales s，products p，customers c，times t WHERE s.cust_id = c.cust_id AND s.prod_id = p.prod_id AND s.time_id = t.time_id GROUP BY ROLLUP（country_id， cust_state_province，cust_city），ROLLUP（prod_category，prod_subcategory，prod_name），PARTITION BY LIST（gid）......;</pre><p>这允许在物化视图<code class="codeph">sales_hierarchical_mon_cube_mv</code> ， <code class="codeph">sales_hierarchical_qtr_cube_mv</code>和<code class="codeph">sales_hierarchical_yr_cube_mv</code>上对销售表的分区维护操作使用PCT刷新。当基表发生重大变化时，也可以使用PCT刷新，并且估计基于日志的快速刷新比PCT刷新慢。您可以将方法指定为force（ <code class="codeph">method =&gt;</code> ' <code class="codeph">?</code>'）用于刷新<code class="codeph">DBMS_MVIEW</code>包中的<code class="codeph">DBMS_MVIEW</code> ，Oracle Database将选择最佳的刷新方法。有关PCT刷新的详细信息，请参阅<span class="q">“ <a href="refreshing-materialized-views.html#GUID-FE65EDEB-56AF-43CB-A7C2-06E74553E0CD">关于物化视图的分区更改跟踪（PCT）刷新</a> ”</span> 。
                           </p>
                           <p>由于<code class="codeph">sales_hierarchical_qtr_cube_mv</code>不包含任何列<code class="codeph">times</code>表，PCT刷新是不是就可以启用。但是，您仍然可以使用方法强制调用<code class="codeph">DBMS_MVIEW</code>包中的刷新子程序（ <code class="codeph">method =&gt;</code> ' <code class="codeph">?</code>'）和Oracle数据库将选择最好的刷新方法。
                           </p>
                           <p>如果您对部分多维数据集感兴趣（即，完整多维数据集中的分组子集），则Oracle建议将多维数据集存储为“联合多维数据集”。联合立方体将每个感兴趣的分组存储在单独的物化视图中。</p><pre class="oac_no_warn" dir="ltr">CREATE MATERIALIZED VIEW sales_mon_city_prod_mv按范围划分（星期一）...使用受信任的约束快速建立需求的快速刷新使用QUERY REWRITE作为选项calendar_month_desc mon，cust_city，prod_name，SUM（amount_sold）s_sales，COUNT（amount_sold）c_sales，COUNT（*）c_star FROM sales s，products p，customers c，times t WHERE s.cust_id = c.cust_id AND s.prod_id = p.prod_id AND s.time_id = t.time_id GROUP BY calendar_month_desc，cust_city，prod_name; CREATE MATERIALIZED VIEW sales_qtr_city_prod_mv PARTITION BY RANGE（qtr）...使用受信任约束快速建立需求的快速刷新使用QUERY REWRITE作为选项calendar_quarter_desc qtr，cust_city，prod_name，SUM（amount_sold）s_sales，COUNT（amount_sold）c_sales，COUNT（*）c_star FROM sales s，products p，customers c，times t WHERE s.cust_id = c.cust_id AND s.prod_id = p.prod_id AND s.time_id = t.time_id GROUP BY calendar_quarter_desc，cust_city，prod_name; CREATE MATERIALIZED VIEW sales_yr_city_prod_mv按范围划分（年）...使用受信任的约束快速建立需求的快速刷新使用QUERY REWRITE作为选择calendar_year yr，cust_city，prod_name，SUM（amount_sold）s_sales，COUNT（amount_sold）c_sales，COUNT（*）c_star FROM sales s，products p，customers c，times t WHERE s.cust_id = c.cust_id AND s.prod_id = p.prod_id AND s.time_id = t.time_id GROUP BY calendar_year，cust_city，prod_name; CREATE MATERIALIZED VIEW sales_mon_city_scat_mv按范围划分（星期一）...使用受信任约束快速建立需求的快速刷新使用QUERY REWRITE作为选项calendar_month_desc mon，cust_city，prod_subcategory，SUM（amount_sold）s_sales，COUNT（amount_sold）c_sales，COUNT（*）c_star FROM sales s，products p，customers c，times t WHERE s.cust_id = c.cust_id AND s.prod_id = p.prod_id AND s.time_id = t.time_id GROUP BY calendar_month_desc，cust_city，prod_subcategory; CREATE MATERIALIZED VIEW sales_qtr_city_cat_mv按范围划分（qtr）...使用受信任的约束快速建立需求的快速刷新使用QUERY REWRITE作为选项calendar_quarter_desc qtr，cust_city，prod_category cat，SUM（amount_sold）s_sales，COUNT（amount_sold）c_sales，COUNT（*）c_star FROM sales s，products p，customers c，times t WHERE s.cust_id = c.cust_id AND s.prod_id = p.prod_id AND s.time_id = t.time_id GROUP BY calendar_quarter_desc，cust_city，prod_category; CREATE MATERIALIZED VIEW sales_yr_city_all_mv按范围划分（年）...使用受信任的约束快速建立需求的快速刷新使用QUERY REWRITE作为选择calendar_year yr，cust_city，SUM（amount_sold）s_sales，COUNT（amount_sold）c_sales，COUNT（*）c_star FROM sales s，products p，customers c，times t WHERE s .cust_id = c.cust_id AND s.prod_id = p.prod_id AND s.time_id = t.time_id GROUP BY calendar_year，cust_city;</pre><p>这些物化视图可以创建为<code class="codeph">BUILD</code> <code class="codeph">DEFERRED</code> ，然后，您可以执行<code class="codeph">DBMS_MVIEW.REFRESH_DEPENDENT(number_of_failures, 'SALES', 'C' ...)</code>以便详细表<code class="codeph">sales</code>定义的每个物化视图的完整刷新以最有效的顺序安排。有关详细信息，请参阅<span class="q">“ <a href="refreshing-materialized-views.html#GUID-18BA80A4-C156-4884-96C0-6ECEC4BB6B8A">计划物化视图的刷新</a> ”</span> 。
                           </p>
                           <p>由于这些物化视图中的每一个都在<code class="codeph">SELECT</code>列表中存在的时间级别（月，季度或年）上进行了分区，因此PCT在每个<code class="codeph">sales</code>表上都启用了，从而提供了应用PCT刷新方法的机会。 <code class="codeph">FAST</code>和<code class="codeph">COMPLETE</code>刷新方法。
                           </p>
                        </div>
                        <!-- class="example" -->
                     </div>
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>