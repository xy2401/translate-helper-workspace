<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html xml:lang="en-us" lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta name="abstract" content="An understanding of these concepts will help you to successfully manage a logical standby database.">
      <meta name="description" content="An understanding of these concepts will help you to successfully manage a logical standby database.">
      <title>Managing a Logical Standby Database</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="Concepts and Administration ">
      <meta property="og:description" content="An understanding of these concepts will help you to successfully manage a logical standby database.">
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="Concepts and Administration">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="data-guard-concepts-and-administration.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2019-02-12T10:50:21-08:00">
      
      <meta name="dcterms.dateCopyrighted" content="1999, 2019">
      <meta name="dcterms.category" content="database">
      <meta name="dcterms.identifier" content="E96244-02">
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19">
      
      <link rel="prev" href="managing-oracle-data-guard-physical-standby-databases.html" title="Previous" type="text/html">
      <link rel="next" href="using-RMAN-in-oracle-data-guard-configurations.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Data Guard Concepts and Administration">
    <meta name="dcterms.isVersionOf" content="SBYDB">
    <meta name="dcterms.release" content="Release 19">
  </head>
   <body>
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="managing-oracle-data-guard-physical-standby-databases.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>Previous</a>
         <a href="using-RMAN-in-oracle-data-guard-configurations.html" class="pull-right">Next<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a>
         <span class="fa fa-exclamation-triangle" aria-hidden="true"></span> JavaScript must be enabled to correctly display this content
        
      </div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">Concepts and Administration </span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="oracle-data-guard-concepts.html" property="item" typeof="WebPage"><span property="name">  Concepts and Administration </span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem"> Managing a Logical Standby Database</li>
            </ol>
            <a id="GUID-4177C717-4244-4E33-ACE7-15D53EAB2443" name="GUID-4177C717-4244-4E33-ACE7-15D53EAB2443"></a><a id="SBYDB00800"></a>
            
            <h2 id="SBYDB-GUID-4177C717-4244-4E33-ACE7-15D53EAB2443" class="sect2"><span class="enumeration_chapter">11 </span> Managing a Logical Standby Database
            </h2>
         </header>
         <div class="ind">
            <div>
               <p>An understanding of these concepts will help you to successfully manage a logical standby database.</p>
               <ul style="list-style-type: disc;">
                  <li>
                     <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-735EED44-DFDB-43B8-ADBC-F1A3A62E7D93" title="SQL Apply uses a collection of background processes to apply changes from the primary database to the logical standby database.">Overview of the SQL Apply Architecture</a></p>
                  </li>
                  <li>
                     <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-572B9755-69F5-4BD7-9DFF-1F7EB1DE3771" title="The SQL ALTER DATABASE GUARD statement controls user access to tables in a logical standby database.">Controlling User Access to Tables in a Logical Standby Database</a></p>
                  </li>
                  <li>
                     <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-D6636F76-CD66-49A8-B052-503991190FBF" title="You can use performance views to monitor the behavior of SQL Apply maintaining a logical standby database.">Views Related to Managing and Monitoring a Logical Standby Database</a></p>
                  </li>
                  <li>
                     <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-B0181E97-7A79-4E92-9B84-42DF8AF24FE0" title="When working with logical standby databases, you can monitor SQL Apply progress, and also the automatic deletion of log files.">Monitoring a Logical Standby Database</a></p>
                  </li>
                  <li>
                     <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-88211E8E-28BF-45AC-9230-F85B606D8987" title="A logical standby database can be customized in several ways, including logging of events, preventing changes to specific schema objects, and adding or re-creating tables.">Customizing a Logical Standby Database</a></p>
                  </li>
                  <li>
                     <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-6B8A9BA8-AEF5-4F87-9B1D-67D1A32955D0" title="You can manage specific workloads in the context of a logical standby.">Managing Specific Workloads In the Context of a Logical Standby Database</a></p>
                  </li>
                  <li>
                     <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-8808747E-825D-4E0C-BD26-4E18F40574F8" title="These topics provide information about various ways to tune logical standby databases.">Tuning a Logical Standby Database</a></p>
                  </li>
                  <li>
                     <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-4A691CE0-7424-4547-800E-0C9D606F0607" title="You can back up your logical standby database using the traditional methods available and then recover it by restoring the database backup and performing media recovery on the archived logs, in conjunction with the backup.">Backup and Recovery in the Context of a Logical Standby Database</a></p>
                  </li>
               </ul>
            </div><a id="SBYDB5042"></a><a id="SBYDB4804"></a><div class="props_rev_3"><a id="GUID-735EED44-DFDB-43B8-ADBC-F1A3A62E7D93" name="GUID-735EED44-DFDB-43B8-ADBC-F1A3A62E7D93"></a><h3 id="SBYDB-GUID-735EED44-DFDB-43B8-ADBC-F1A3A62E7D93" class="sect3"><span class="enumeration_section">11.1 </span>Overview of the SQL Apply Architecture
               </h3>
               <div>
                  <p>SQL Apply uses a collection of background processes to apply changes from the primary database to the logical standby database.</p>
                  <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-735EED44-DFDB-43B8-ADBC-F1A3A62E7D93__I1039995">Figure 11-1</a> shows the flow of information and the role that each process performs.
                  </p>
                  <div class="figure" id="GUID-735EED44-DFDB-43B8-ADBC-F1A3A62E7D93__I1039995">
                     <p class="titleinfigure">Figure 11-1 SQL Apply Processing</p><img src="img/sbydb055.gif" width="615" alt="Description of Figure 11-1 follows" title="Description of Figure 11-1 follows" longdesc="img_text/sbydb055.html"><br><a href="img_text/sbydb055.html">Description of "Figure 11-1 SQL Apply Processing"</a></div>
                  <!-- class="figure" -->
                  <p>The different processes involved and their functions during log mining and apply processing are as follows:</p>
                  <p>During log mining:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>The <code class="codeph">READER</code> process reads redo records from the archived redo log files or standby redo log files.
                        </p>
                     </li>
                     <li>
                        <p>The <code class="codeph">PREPARER</code> process converts block changes contained in redo records into logical change records (LCRs). Multiple <code class="codeph">PREPARER</code> processes can be active for a given redo log file. The LCRs are staged in the <a id="d26509e241" class="indexterm-anchor"></a><a id="d26509e245" class="indexterm-anchor"></a><a id="d26509e249" class="indexterm-anchor"></a>system global area (SGA), known as the <span class="italic">LCR cache</span>.
                        </p>
                     </li>
                     <li>
                        <p>The <code class="codeph">BUILDER</code> process groups LCRs into transactions, and performs other tasks, such as memory management in the LCR cache, checkpointing related to SQL Apply restart and filtering out of uninteresting changes. 
                        </p>
                     </li>
                  </ul>
                  <p>During apply processing:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>The <code class="codeph">ANALYZER</code> process identifies dependencies between different transactions.
                        </p>
                     </li>
                     <li>
                        <p>The <code class="codeph">COORDINATOR</code> process <a id="d26509e278" class="indexterm-anchor"></a><a id="d26509e282" class="indexterm-anchor"></a><a id="d26509e286" class="indexterm-anchor"></a><a id="d26509e290" class="indexterm-anchor"></a>(LSP) assigns transactions to different appliers and coordinates among them to ensure that dependencies between transactions are honored.
                        </p>
                     </li>
                     <li>
                        <p>The <code class="codeph">APPLIER</code> processes applies transactions to the logical standby database under the supervision of the coordinator process.
                        </p>
                     </li>
                  </ul>
                  <p>You can query the <code class="codeph">V$LOGSTDBY_PROCESS</code> view to examine the activity of the SQL Apply processes. Another view that provides information about current activity is the <code class="codeph">V$LOGSTDBY_STATS</code> view that displays statistics, current state, and status information for the logical standby database during SQL Apply activities. These and other relevant views are discussed in more detail in <a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-D6636F76-CD66-49A8-B052-503991190FBF" title="You can use performance views to monitor the behavior of SQL Apply maintaining a logical standby database.">Views Related to Managing and Monitoring a Logical Standby Database</a>.
                  </p>
                  <div class="infoboxnote" id="GUID-735EED44-DFDB-43B8-ADBC-F1A3A62E7D93__GUID-80960FAF-B556-4C59-A028-32D125305B5B">
                     <p class="notep1">Note:</p>
                     <p>All SQL Apply processes (including the coordinator process <code class="codeph">lsp0</code>) are true background processes. They are not regulated by resource manager. Therefore, creating resource groups at the logical standby database does not affect the SQL Apply processes.
                     </p>
                  </div>
               </div><a id="SBYDB4805"></a><div class="props_rev_3"><a id="GUID-81ABDF55-F808-4E41-ACBF-694DBE40E68C" name="GUID-81ABDF55-F808-4E41-ACBF-694DBE40E68C"></a><h4 id="SBYDB-GUID-81ABDF55-F808-4E41-ACBF-694DBE40E68C" class="sect4"><span class="enumeration_section">11.1.1 </span>Various Considerations for SQL Apply
                  </h4>
                  <div>
                     <p>Understanding these concepts about transaction size, pageouts, restarts, DML Apply, and password verification will help you to manage logical standbys to their best advantage.</p>
                     <p>See the following:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-344AF03D-88A6-4DE1-8650-D5F1B9781FC3" title="SQL Apply categorizes transactions into two classes: small and large.">Transaction Size Considerations</a></p>
                        </li>
                        <li>
                           <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-E3ADF4B7-F08A-4F2B-A1CD-FB897ECCF534" title="Pageouts occur in the context of SQL Apply when memory in the LCR cache is exhausted and space needs to be released for SQL Apply to make progress.">Pageout Considerations</a></p>
                        </li>
                        <li>
                           <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-F0FDEEF3-B4EA-40F3-BF7B-2167D33D91C8" title="Modifications made to the logical standby database do not become persistent until the commit record of the transaction is mined from the redo log files and applied to the logical standby database.">Restart Considerations</a></p>
                        </li>
                        <li>
                           <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-97797605-D5BB-49B7-8E9D-D3E7C56A767C">DML Apply Considerations</a></p>
                        </li>
                        <li>
                           <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-1BBCF0C2-E189-47EF-B7D1-805BF552E4DB">DDL Apply Considerations</a></p>
                        </li>
                        <li>
                           <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-1F7593FA-8EDD-4DF2-8CE0-1EDCDAA81402" title="Password verification functions that check for the complexity of passwords must be created in the SYS schema.">Password Verification Functions</a></p>
                        </li>
                     </ul>
                  </div><a id="SBYDB4806"></a><div class="props_rev_3"><a id="GUID-344AF03D-88A6-4DE1-8650-D5F1B9781FC3" name="GUID-344AF03D-88A6-4DE1-8650-D5F1B9781FC3"></a><h5 id="SBYDB-GUID-344AF03D-88A6-4DE1-8650-D5F1B9781FC3" class="sect5"><span class="enumeration_section">11.1.1.1 </span>Transaction Size Considerations
                     </h5>
                     <div>
                        <p>SQL Apply categorizes transactions into two classes: small and large.</p>
                        <p>Definitions of each class are as follows:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Small transactions—SQL Apply starts applying LCRs belonging to a small transaction once it has encountered the commit record for the transaction in the redo log files.</p>
                           </li>
                           <li>
                              <p>Large transactions—SQL Apply breaks large transactions into smaller pieces called <span class="italic">transaction chunks</span>, and starts applying the chunks before the commit record for the large transaction is seen in the redo log files. This is done to reduce memory pressure on the LCR cache and to reduce the overall failover time.
                              </p>
                              <p>For example, without breaking into smaller pieces, a SQL*Loader load of ten million rows, each 100 bytes in size, would use more than 1 GB of memory in the LCR cache. If the memory allocated to the LCR cache was less than 1 GB, it would result in pageouts from the LCR cache. </p>
                              <p>Apart from the memory considerations, if SQL Apply did not start applying the changes related to the ten million row SQL*Loader load until it encountered the <code class="codeph">COMMIT</code> record for the transaction, it could stall a role transition. A switchover or a failover that is initiated after the transaction commit cannot finish until SQL Apply has applied the transaction on the logical standby database.
                              </p>
                              <p>Despite the use of transaction chunks, SQL Apply performance may degrade when processing transactions that modify more than eight million rows. For transactions larger than 8 million rows, SQL Apply uses the temporary segment to stage some of the internal metadata required to process the transaction. Be sure to allocate enough space in your temporary segment for SQL Apply to successfully process transactions larger than 8 million rows.</p>
                           </li>
                        </ul>
                        <p>All transactions start out categorized as small transactions. Depending on the amount of memory available for the LCR cache and the amount of memory consumed by LCRs belonging to a transaction, SQL Apply determines when to recategorize a transaction as a large transaction.</p>
                     </div>
                  </div><a id="SBYDB4807"></a><div class="props_rev_3"><a id="GUID-E3ADF4B7-F08A-4F2B-A1CD-FB897ECCF534" name="GUID-E3ADF4B7-F08A-4F2B-A1CD-FB897ECCF534"></a><h5 id="SBYDB-GUID-E3ADF4B7-F08A-4F2B-A1CD-FB897ECCF534" class="sect5"><span class="enumeration_section">11.1.1.2 </span>Pageout Considerations
                     </h5>
                     <div>
                        <p>Pageouts occur in the context of SQL Apply when memory in the LCR cache is exhausted and space needs to be released for SQL Apply to make progress.</p>
                        <p>For example, assume the memory allocated to the LCR cache is 100 MB and SQL Apply encounters an <code class="codeph">INSERT</code> transaction to a table with a <code class="codeph">LONG</code> column of size 300 MB. In this case, the log-mining component pages out the first part of the <code class="codeph">LONG</code> data to read the later part of the column modification. In a well-tuned logical standby database, pageout activities occur occasionally and should not affect the overall throughput of the system. 
                        </p>
                        <div class="infoboxnotealso" id="GUID-E3ADF4B7-F08A-4F2B-A1CD-FB897ECCF534__GUID-57EEDF29-F86F-4BB0-90EF-4B30CAC038A1">
                           <p class="notep1">See Also:</p>
                           <p>See <a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-88211E8E-28BF-45AC-9230-F85B606D8987" title="A logical standby database can be customized in several ways, including logging of events, preventing changes to specific schema objects, and adding or re-creating tables.">Customizing a Logical Standby Database</a> for more information about how to identify problematic pageouts and perform corrective actions
                           </p>
                        </div>
                     </div>
                  </div><a id="SBYDB4808"></a><div class="props_rev_3"><a id="GUID-F0FDEEF3-B4EA-40F3-BF7B-2167D33D91C8" name="GUID-F0FDEEF3-B4EA-40F3-BF7B-2167D33D91C8"></a><h5 id="SBYDB-GUID-F0FDEEF3-B4EA-40F3-BF7B-2167D33D91C8" class="sect5"><span class="enumeration_section">11.1.1.3 </span>Restart Considerations
                     </h5>
                     <div>
                        <p>Modifications made to the logical standby database do not become persistent until the commit record of the transaction is mined from the redo log files and applied to the logical standby database. </p>
                        <p>Thus, every time SQL Apply is stopped, whether as a result of a user directive or because of a system failure, SQL Apply must go back and mine the earliest uncommitted transaction again.</p>
                        <p>In cases where a transaction does little work but remains open for a long period of time, restarting SQL Apply from the start could be prohibitively costly because SQL Apply would have to mine a large number of archived redo log files again, just to read the redo data for a few uncommitted transactions. To mitigate this, SQL Apply periodically checkpoints old uncommitted data. The SCN at which the checkpoint is taken is reflected in the <code class="codeph">RESTART_SCN</code> column of <a id="d26509e758" class="indexterm-anchor"></a><a id="d26509e762" class="indexterm-anchor"></a><code class="codeph">V$LOGSTDBY_PROGRESS</code> view. Upon restarting, SQL Apply starts mining redo records that are generated at an SCN greater than value shown by the <code class="codeph">RESTART_SCN</code> column. Archived redo log files that are not needed for restart are automatically deleted by SQL Apply.
                        </p>
                        <p>Certain workloads, such as large DDL transactions, parallel DML statements (PDML)<a id="d26509e774" class="indexterm-anchor"></a><a id="d26509e778" class="indexterm-anchor"></a>, and direct-path loads, prevent the <code class="codeph">RESTART_SCN</code> from advancing for the duration of the workload.
                        </p>
                     </div>
                  </div><a id="SBYDB4809"></a><div class="props_rev_3"><a id="GUID-97797605-D5BB-49B7-8E9D-D3E7C56A767C" name="GUID-97797605-D5BB-49B7-8E9D-D3E7C56A767C"></a><h5 id="SBYDB-GUID-97797605-D5BB-49B7-8E9D-D3E7C56A767C" class="sect5"><span class="enumeration_section">11.1.1.4 </span>DML Apply Considerations
                     </h5>
                     <div>
                        <p>SQL Apply has the following characteristics when applying DML transactions that affect the <a id="d26509e868" class="indexterm-anchor"></a><a id="d26509e872" class="indexterm-anchor"></a><a id="d26509e876" class="indexterm-anchor"></a>throughput and latency on the logical standby database:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Batch updates<a id="d26509e885" class="indexterm-anchor"></a><a id="d26509e889" class="indexterm-anchor"></a> or deletes done on the primary database, where a single statement results in multiple rows being modified, are applied as individual row modifications on the logical standby database. Thus, it is imperative for each maintained table to have a unique<a id="d26509e894" class="indexterm-anchor"></a><a id="d26509e898" class="indexterm-anchor"></a><a id="d26509e902" class="indexterm-anchor"></a> index or a primary key. See <a href="creating-oracle-data-guard-logical-standby.html#GUID-C238335E-8383-43F1-B5B1-709A2A619C30" title="The ROWIDs contained in the redo records generated by the primary database cannot be used to identify the corresponding row in the logical standby database.">Ensure Table Rows in the Primary Database Can Be Uniquely Identified</a> for more information.
                              </p>
                           </li>
                           <li>
                              <p><a id="d26509e916" class="indexterm-anchor"></a>Direct path inserts performed on the primary database are applied using a conventional <code class="codeph">INSERT</code> statement on the logical standby database.
                              </p>
                           </li>
                           <li>
                              <p><a id="d26509e926" class="indexterm-anchor"></a><a id="d26509e930" class="indexterm-anchor"></a>Parallel DML (PDML) transactions are not executed in parallel on the logical standby database.
                              </p>
                           </li>
                        </ul>
                     </div>
                  </div><a id="SBYDB4810"></a><div class="props_rev_3"><a id="GUID-1BBCF0C2-E189-47EF-B7D1-805BF552E4DB" name="GUID-1BBCF0C2-E189-47EF-B7D1-805BF552E4DB"></a><h5 id="SBYDB-GUID-1BBCF0C2-E189-47EF-B7D1-805BF552E4DB" class="sect5"><span class="enumeration_section">11.1.1.5 </span>DDL Apply Considerations
                     </h5>
                     <div>
                        <p>SQL Apply has the following characteristics when applying DDL transactions that affect the thr<a id="d26509e1019" class="indexterm-anchor"></a><a id="d26509e1023" class="indexterm-anchor"></a><a id="d26509e1027" class="indexterm-anchor"></a>oughput and latency on the logical standby database:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><a id="d26509e1035" class="indexterm-anchor"></a><a id="d26509e1039" class="indexterm-anchor"></a>DDL transactions are applied serially on the logical standby database. Thus, DDL transactions applied concurrently on the primary database are applied one at a time on the logical standby database.
                              </p>
                           </li>
                           <li>
                              <p><a id="d26509e1046" class="indexterm-anchor"></a><a id="d26509e1050" class="indexterm-anchor"></a><code class="codeph">CREATE TABLE AS SELECT</code> (CTAS) statements are executed such that the DML activities (that are part of the CTAS statement) are suppressed on the logical standby database. The rows inserted in the newly created table as part of the CTAS statement are mined from the redo log files and applied to the logical standby database using <code class="codeph">INSERT</code> statements.
                              </p>
                           </li>
                           <li>
                              <p>SQL Apply reissues the DDL that was performed at the primary database, and ensures that DMLs that occur within the same transaction on the same object that is the target of the DDL operation are not replicated at the logical standby database. Thus, the following two cases cause the primary and standby sites to diverge from each other:</p>
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p>The DDL contains a non-literal value that is derived from the state at the primary database. An example of such a DDL is: </p><pre class="oac_no_warn" dir="ltr">ALTER TABLE hr.employees ADD (start_date date default sysdate);
</pre><p>Because SQL Apply reissues the same DDL at the logical standby, the function <code class="codeph">sysdate()</code> is reevaluated at the logical standby. Thus, the column <code class="codeph">start_date</code> is created with a different default value than at the primary database.
                                    </p>
                                 </li>
                                 <li>
                                    <p>The DDL fires DML triggers defined on the target table. Since the triggered DMLs occur in the same transaction as the DDL, and operate on the table that is the target of the DDL, these triggered DMLs are not replicated at the logical standby.</p>
                                    <p>For example, assume you create a table as follows:</p><pre class="oac_no_warn" dir="ltr"> create table HR.TEMP_EMPLOYEES (
 emp_id       number primary key,
 first_name   varchar2(64),
 last_name    varchar2(64),
 modify_date  timestamp);
</pre><p>Assume you then create a trigger on the table such that any time the table is updated the <code class="codeph">modify_date</code> is updated to reflect the time of change:
                                    </p><pre class="oac_no_warn" dir="ltr"> CREATE OR REPLACE TRIGGER TRG_TEST_MOD_DT  BEFORE UPDATE ON HR.TEST_EMPLOYEES
 REFERENCING  
 NEW  AS NEW_ROW  FOR EACH ROW
 BEGIN  
 :NEW_ROW.MODIFY_DATE:= SYSTIMESTAMP;  
 END;
/
</pre><p>This table is maintained correctly under the usual DML/DDL workload. However if you add a column with the default value to the table, the <code class="codeph">ADD COLUMN</code> DDL fires this update trigger and changes the <code class="codeph">MODIFY_DATE</code> column of all rows in the table to a new timestamp. These changes to the <code class="codeph">MODIFY_DATE</code> column are not replicated at the logical standby database. Subsequent DMLs to the table stop SQL Apply because the <code class="codeph">MODIFY_DATE</code> column data recorded in the redo stream does not match the data that exists at the logical standby database. 
                                    </p>
                                 </li>
                              </ul>
                           </li>
                        </ul>
                     </div>
                  </div><a id="SBYDB4811"></a><div class="props_rev_3"><a id="GUID-1F7593FA-8EDD-4DF2-8CE0-1EDCDAA81402" name="GUID-1F7593FA-8EDD-4DF2-8CE0-1EDCDAA81402"></a><h5 id="SBYDB-GUID-1F7593FA-8EDD-4DF2-8CE0-1EDCDAA81402" class="sect5"><span class="enumeration_section">11.1.1.6 </span>Password Verification Functions
                     </h5>
                     <div>
                        <p>Password verification functions that check for the complexity of passwords must be created in the <code class="codeph">SYS</code> schema.
                        </p>
                        <p> Because SQL Apply does not replicate objects created in the <code class="codeph">SYS</code> schema, such verification functions are not replicated to the logical standby database. You must create the password verification function manually at the logical standby database, and associate it with the appropriate profiles.
                        </p>
                     </div>
                  </div>
               </div>
            </div><a id="SBYDB4812"></a><div class="props_rev_3"><a id="GUID-572B9755-69F5-4BD7-9DFF-1F7EB1DE3771" name="GUID-572B9755-69F5-4BD7-9DFF-1F7EB1DE3771"></a><h3 id="SBYDB-GUID-572B9755-69F5-4BD7-9DFF-1F7EB1DE3771" class="sect3"><span class="enumeration_section">11.2 </span>Controlling User Access to Tables in a Logical Standby Database
               </h3>
               <div>
                  <p>The SQL <code class="codeph">ALTER DATABASE GUARD</code> statement controls user access to tables in a logical standby database. 
                  </p>
                  <div class="section">
                     <p>The database guard is set to <code class="codeph">ALL</code> by default on a logical standby database.
                     </p>
                     <p>The <code class="codeph">ALTER DATABASE GUARD</code> statement allows the following keywords:
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><code class="codeph">ALL</code></p>
                           <p> Specify <code class="codeph">ALL</code> to prevent all users, other than <code class="codeph">SYS</code>, from making changes to any data in the logical standby database.
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">STANDBY</code></p>
                           <p>Specify <code class="codeph">STANDBY</code> to prevent all users, other than <code class="codeph">SYS</code>, from making DML and DDL changes to any table or sequence being maintained through SQL Apply.
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">NONE</code></p>
                           <p>Specify <code class="codeph">NONE</code> to use typical security for all data in the database.
                           </p>
                        </li>
                     </ul>
                     <p>For example, use the following statement to enable users to modify tables not maintained by SQL Apply:</p><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER DATABASE GUARD STANDBY;
</pre><p>Privileged users can temporarily turn the database guard off and on for the current session using the <code class="codeph">ALTER SESSION DISABLE GUARD</code> and <code class="codeph">ALTER SESSION ENABLE GUARD</code> statements, respectively. This statement replaces the <code class="codeph">DBMS_LOGSTDBY.GUARD_BYPASS</code> PL/SQL procedure that performed the same function in Oracle9i. The <code class="codeph">ALTER SESSION [ENABLE|DISABLE] GUARD</code> statement is useful when you want to temporarily disable the database guard to make changes to the database, as described in <a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-43971CB9-3337-4575-B4EF-D591878982F1" title="Logical standby databases can be used for reporting activities, even while SQL statements are being applied.">Modifying a Logical Standby Database</a>.
                     </p>
                     <div class="infoboxnote" id="GUID-572B9755-69F5-4BD7-9DFF-1F7EB1DE3771__GUID-4C32DDF1-5425-4CF7-9514-925B96119B02">
                        <p class="notep1">Note:</p>
                        <p>Do not let the primary and logical standby databases diverge while the database guard is disabled.</p>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div>
            </div><a id="SBYDB4813"></a><div class="props_rev_3"><a id="GUID-D6636F76-CD66-49A8-B052-503991190FBF" name="GUID-D6636F76-CD66-49A8-B052-503991190FBF"></a><h3 id="SBYDB-GUID-D6636F76-CD66-49A8-B052-503991190FBF" class="sect3"><span class="enumeration_section">11.3 </span>Views Related to Managing and Monitoring a Logical Standby Database
               </h3>
               <div>
                  <p>You can use performance views to monitor the behavior of SQL Apply maintaining a logical standby database.</p>
                  <p>The following topics describe the key views that can be used to monitor a logical standby database:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-BEF12BA7-9397-4156-9ED3-BAC7935D7D96" title="The DBA_LOGSTDBY_EVENTS view records interesting events that occurred during the operation of SQL Apply.">DBA_LOGSTDBY_EVENTS View</a></p>
                     </li>
                     <li>
                        <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-646D305C-21C3-4590-8A6B-B2D02F90E8F2" title="The DBA_LOGSTDBY_LOG view provides dynamic information about archived logs being processed by SQL Apply.">DBA_LOGSTDBY_LOG View</a></p>
                     </li>
                     <li>
                        <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-76033857-52EC-41B2-B130-CC9083F3FA99">V$DATAGUARD_STATS View</a></p>
                     </li>
                     <li>
                        <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-7E8E779A-E0EC-4C9D-8B77-1E80A60C077D">V$LOGSTDBY_PROCESS View</a></p>
                     </li>
                     <li>
                        <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-DAF00126-1FDA-4980-AD24-1360472ADB49">V$LOGSTDBY_PROGRESS View</a></p>
                     </li>
                     <li>
                        <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-9E8AFFE3-E4C2-46EB-A733-B48793DB4F1F">V$LOGSTDBY_STATE View</a></p>
                     </li>
                     <li>
                        <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-C72DA5B7-7FDD-46C8-9242-CD7D88DCDDB7">V$LOGSTDBY_STATS View</a></p>
                     </li>
                  </ul>
                  <div class="infoboxnotealso" id="GUID-D6636F76-CD66-49A8-B052-503991190FBF__GUID-74814E29-064B-4083-8C3C-89EC7A8574AE">
                     <p class="notep1">See Also:</p>
                     <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sbydb&amp;id=REFRN002" target="_blank">Oracle Database Reference</a> for complete reference information about views
                     </p>
                  </div>
               </div><a id="SBYDB4814"></a><div class="props_rev_3"><a id="GUID-BEF12BA7-9397-4156-9ED3-BAC7935D7D96" name="GUID-BEF12BA7-9397-4156-9ED3-BAC7935D7D96"></a><h4 id="SBYDB-GUID-BEF12BA7-9397-4156-9ED3-BAC7935D7D96" class="sect4"><span class="enumeration_section">11.3.1 </span>DBA_LOGSTDBY_EVENTS View
                  </h4>
                  <div>
                     <p>The <code class="codeph">DBA_LOGSTDBY_EVENTS</code> view records interesting events that occurred during the operation of SQL Apply.
                     </p>
                     <div class="section">
                        <p> By default, the view records the most recent 10,000 events. However, you can change the number of recorded events by calling <code class="codeph">DBMS_LOGSTDBY.APPLY_SET()</code> PL/SQL procedure. If SQL Apply stops unexpectedly, the reason for the problem is also recorded in this view.
                        </p>
                        <div class="infoboxnote" id="GUID-BEF12BA7-9397-4156-9ED3-BAC7935D7D96__GUID-C576E399-F655-419E-BEB6-A3D56BAA3546">
                           <p class="notep1">Note:</p>
                           <p>Errors that cause SQL Apply to stop are recorded in the events table These events are put into the <code class="codeph">ALERT.LOG</code> file as well, with the <code class="codeph">LOGSTDBY</code> keyword included in the text. When querying the view, select the columns in order by <code class="codeph">EVENT_TIME_STAMP</code>, <code class="codeph">COMMIT_SCN</code>, and <code class="codeph">CURRENT_SCN</code> to ensure the desired ordering of events.
                           </p>
                        </div>
                        <p>The view can be customized to contain other information, such as which DDL transactions were applied and which were skipped. For example:</p><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER SESSION SET NLS_DATE_FORMAT  = 'DD-MON-YY HH24:MI:SS';
Session altered.
SQL&gt; COLUMN STATUS FORMAT A60
SQL&gt; SELECT EVENT_TIME, STATUS, EVENT FROM DBA_LOGSTDBY_EVENTS -
&gt; ORDER BY EVENT_TIMESTAMP, COMMIT_SCN, CURRENT_SCN;

EVENT_TIME         STATUS
------------------------------------------------------------------------------
EVENT
-------------------------------------------------------------------------------
23-JUL-02 18:20:12 ORA-16111: log mining and apply setting up
23-JUL-02 18:25:12 ORA-16128: User initiated shut down successfully completed
23-JUL-02 18:27:12 ORA-16112: log mining and apply stopping
23-JUL-02 18:55:12 ORA-16128: User initiated shut down successfully completed
23-JUL-02 18:57:09 ORA-16111: log mining and apply setting up
23-JUL-02 20:21:47 ORA-16204: DDL successfully applied
create table hr.test_emp (empno number, ename varchar2(64))
23-JUL-02 20:22:55 ORA-16205: DDL skipped due to skip setting 
create database link link_to_boston connect to system identified by change_on_inst
7 rows selected.
</pre><p>This query shows that SQL Apply was started and stopped a few times. It also shows what DDL was applied and skipped.</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="SBYDB4815"></a><div class="props_rev_3"><a id="GUID-646D305C-21C3-4590-8A6B-B2D02F90E8F2" name="GUID-646D305C-21C3-4590-8A6B-B2D02F90E8F2"></a><h4 id="SBYDB-GUID-646D305C-21C3-4590-8A6B-B2D02F90E8F2" class="sect4"><span class="enumeration_section">11.3.2 </span>DBA_LOGSTDBY_LOG View
                  </h4>
                  <div>
                     <p>The <code class="codeph">DBA_LOGSTDBY_LOG</code> view provides dynamic information about archived logs being processed by SQL Apply. 
                     </p>
                     <div class="section">
                        <p>For example:</p><pre class="oac_no_warn" dir="ltr">SQL&gt; COLUMN DICT_BEGIN FORMAT A10;
SQL&gt; SET NUMF 99999999;
SQL&gt; SELECT FILE_NAME, SEQUENCE# AS SEQ#, FIRST_CHANGE# AS F_SCN#, -
&gt;  NEXT_CHANGE# AS N_SCN#, TIMESTAMP, -
&gt;  DICT_BEGIN AS BEG, DICT_END AS END, -
&gt;  THREAD# AS THR#, APPLIED FROM DBA_LOGSTDBY_LOG -
&gt;  ORDER BY SEQUENCE#;

FILE_NAME                 SEQ# F_SCN    N_SCN TIMESTAM BEG END THR# APPLIED
------------------------- ---- ------- ------- -------- --- --- --- ---------
/oracle/dbs/hq_nyc_2.log  2     101579  101588 11:02:58 NO  NO  1     YES
/oracle/dbs/hq_nyc_3.log  3     101588  142065 11:02:02 NO  NO  1     YES
/oracle/dbs/hq_nyc_4.log  4     142065  142307 11:02:10 NO  NO  1     YES
/oracle/dbs/hq_nyc_5.log  5     142307  142739 11:02:48 YES YES 1     YES
/oracle/dbs/hq_nyc_6.log  6     142739  143973 12:02:10 NO  NO  1     YES
/oracle/dbs/hq_nyc_7.log  7     143973  144042 01:02:11 NO  NO  1     YES
/oracle/dbs/hq_nyc_8.log  8     144042  144051 01:02:01 NO  NO  1     YES
/oracle/dbs/hq_nyc_9.log  9     144051  144054 01:02:16 NO  NO  1     YES
/oracle/dbs/hq_nyc_10.log 10    144054  144057 01:02:21 NO  NO  1     YES
/oracle/dbs/hq_nyc_11.log 11    144057  144060 01:02:26 NO  NO  1  CURRENT
/oracle/dbs/hq_nyc_12.log 12    144060  144089 01:02:30 NO  NO  1  CURRENT
/oracle/dbs/hq_nyc_13.log 13    144089  144147 01:02:41 NO  NO  1       NO
</pre><p>The <code class="codeph">YES</code> entries in the <code class="codeph">BEG</code> and <code class="codeph">END</code> columns indicate that a LogMiner dictionary build starts at log file sequence number 5. The most recent archived redo log file is sequence number 13, and it was received at the logical standby database at 01:02:41.The <code class="codeph">APPLIED</code> column indicates that SQL Apply has applied all redo before SCN 144057. Since transactions can span multiple archived log files, multiple archived log files may show the value <code class="codeph">CURRENT</code> in the <code class="codeph">APPLIED</code> column.
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="SBYDB4816"></a><div class="props_rev_3"><a id="GUID-76033857-52EC-41B2-B130-CC9083F3FA99" name="GUID-76033857-52EC-41B2-B130-CC9083F3FA99"></a><h4 id="SBYDB-GUID-76033857-52EC-41B2-B130-CC9083F3FA99" class="sect4"><span class="enumeration_section">11.3.3 </span>V$DATAGUARD_STATS View
                  </h4>
                  <div>
                     <div class="section">
                        <p>This view provides information related to the failover characteristics of the logical standby database, including:</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>The time to failover (<code class="codeph">apply finish time</code>)
                              </p>
                           </li>
                           <li>
                              <p>How current is the committed data in the logical standby database (<code class="codeph">apply lag</code>)
                              </p>
                           </li>
                           <li>
                              <p>What the potential data loss will be in the event of a disaster (<code class="codeph">transport lag</code>). 
                              </p>
                           </li>
                        </ul>
                        <p>For example:</p><pre class="oac_no_warn" dir="ltr">SQL&gt; COL NAME FORMAT A20
SQL&gt; COL VALUE FORMAT A12
SQL&gt; COL UNIT FORMAT A30
SQL&gt; SELECT NAME, VALUE, UNIT FROM V$DATAGUARD_STATS;
 
NAME                 VALUE        UNIT
-------------------- ------------ ------------------------------
apply finish time    +00 00:00:00 day(2) to second(1) interval
apply lag            +00 00:00:00 day(2) to second(0) interval
transport lag        +00 00:00:00 day(2) to second(0) interval
</pre><p>This output is from a logical standby database that has received and applied all redo generated from the primary database.</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="SBYDB4817"></a><div class="props_rev_3"><a id="GUID-7E8E779A-E0EC-4C9D-8B77-1E80A60C077D" name="GUID-7E8E779A-E0EC-4C9D-8B77-1E80A60C077D"></a><h4 id="SBYDB-GUID-7E8E779A-E0EC-4C9D-8B77-1E80A60C077D" class="sect4"><span class="enumeration_section">11.3.4 </span>V$LOGSTDBY_PROCESS View
                  </h4>
                  <div>
                     <div class="section">
                        <p>This view provides information about the current state of the various processes involved with SQL Apply, including;</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Identifying information (<code class="codeph">sid</code> | <code class="codeph">serial#</code> | <code class="codeph">spid</code>)
                              </p>
                           </li>
                           <li>
                              <p>SQL Apply process: <code class="codeph">COORDINATOR</code>, <code class="codeph">READER</code>, <code class="codeph">BUILDER</code>, <code class="codeph">PREPARER</code>, <code class="codeph">ANALYZER</code>, or <code class="codeph">APPLIER</code> (<code class="codeph">type</code>)
                              </p>
                           </li>
                           <li>
                              <p>Status of the process's current activity (<code class="codeph">status_code</code> | <code class="codeph">status</code>)
                              </p>
                           </li>
                           <li>
                              <p>Highest redo record processed by this process (<code class="codeph">high_scn</code>)
                              </p>
                           </li>
                        </ul>
                        <p>For example:</p><pre class="oac_no_warn" dir="ltr">SQL&gt; COLUMN SERIAL# FORMAT 9999
SQL&gt; COLUMN SID FORMAT 9999
SQL&gt; SELECT SID, SERIAL#, SPID, TYPE, HIGH_SCN FROM V$LOGSTDBY_PROCESS;
 
  SID   SERIAL#   SPID         TYPE            HIGH_SCN
  ----- -------   ----------- ---------------- ----------
   48        6    11074        COORDINATOR     7178242899
   56       56    10858        READER          7178243497
   46        1    10860        BUILDER         7178242901
   45        1    10862        PREPARER        7178243295
   37        1    10864        ANALYZER        7178242900
   36        1    10866        APPLIER         7178239467
   35        3    10868        APPLIER         7178239463
   34        7    10870        APPLIER         7178239461
   33        1    10872        APPLIER         7178239472
 
9 rows selected.
</pre><p>The <code class="codeph">HIGH_SCN</code> column shows that the reader process is ahead of all other processes, and the <code class="codeph">PREPARER</code> and <code class="codeph">BUILDER</code> process ahead of the rest.
                        </p><pre class="oac_no_warn" dir="ltr">SQL&gt; COLUMN STATUS FORMAT A40
SQL&gt; SELECT TYPE, STATUS_CODE, STATUS FROM V$LOGSTDBY_PROCESS<a id="d26509e1963" class="indexterm-anchor"></a>;
 
TYPE             STATUS_CODE STATUS
---------------- ----------- -----------------------------------------
COORDINATOR            16117 ORA-16117: processing
READER                 16127 ORA-16127: stalled waiting for additional
                             transactions to be applied
BUILDER                16116 ORA-16116: no work available
PREPARER               16116 ORA-16117: processing
ANALYZER               16120 ORA-16120: dependencies being computed for
                             transaction at SCN 0x0001.abdb440a
APPLIER                16124 ORA-16124: transaction 1 13 1427 is waiting
                             on another transaction
APPLIER                16121 ORA-16121: applying transaction with commit
                             SCN 0x0001.abdb4390
APPLIER                16123 ORA-16123: transaction 1 23  1231 is waiting
                             for commit approval
APPLIER                16116 ORA-16116: no work available
</pre><p>The output shows a snapshot of SQL Apply running. On the mining side, the <code class="codeph">READER</code> process is waiting for additional memory to become available before it can read more, the <code class="codeph">PREPARER</code> process is processing redo records, and the <code class="codeph">BUILDER</code> process has no work available. On the apply side, the <code class="codeph">COORDINATOR</code> is assigning more transactions to <code class="codeph">APPLIER</code> processes, the <code class="codeph">ANALYZER</code> is computing dependencies at SCN 7178241034, one <code class="codeph">APPLIER</code> has no work available, while two have outstanding dependencies that are not yet satisfied.
                        </p>
                        <div class="infoboxnotealso" id="GUID-7E8E779A-E0EC-4C9D-8B77-1E80A60C077D__GUID-4A8978F2-5224-4AC8-9A29-121AB654019B">
                           <p class="notep1">See Also:</p>
                           <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-5BD79860-B3B8-4E0D-9F55-2E9918B93292" title="SQL Apply can be in any of six states of progress: initializing SQL Apply, waiting for dictionary logs, loading the LogMiner dictionary, applying (redo data), waiting for an archive gap to be resolved, and idle.">Monitoring SQL Apply Progress</a> for example output
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="SBYDB4818"></a><div class="props_rev_3"><a id="GUID-DAF00126-1FDA-4980-AD24-1360472ADB49" name="GUID-DAF00126-1FDA-4980-AD24-1360472ADB49"></a><h4 id="SBYDB-GUID-DAF00126-1FDA-4980-AD24-1360472ADB49" class="sect4"><span class="enumeration_section">11.3.5 </span>V$LOGSTDBY_PROGRESS View
                  </h4>
                  <div>
                     <div class="section">
                        <p>This view provides detailed information regarding progress made by SQL Apply, including:</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>SCN and time at which all transactions that have been committed on the primary database have been applied to the logical standby database (<code class="codeph">applied_scn</code>,  <code class="codeph">applied_time</code>)
                              </p>
                           </li>
                           <li>
                              <p>SCN and time at which SQL Apply would begin reading redo records (<code class="codeph">restart_scn</code>, <code class="codeph">restart_time</code>) on restart
                              </p>
                           </li>
                           <li>
                              <p>SCN and time of the latest redo record received on the logical standby database (<code class="codeph">latest_scn</code>, <code class="codeph">latest_time</code>)
                              </p>
                           </li>
                           <li>
                              <p>SCN and time of the latest record processed by the <code class="codeph">BUILDER</code> process (<code class="codeph">mining_scn</code>,  <code class="codeph">mining_time</code>)
                              </p>
                           </li>
                        </ul>
                        <p>For example:</p><pre class="oac_no_warn" dir="ltr">SQL&gt; SELECT APPLIED_SCN, LATEST_SCN, MINING_SCN, RESTART_SCN -
&gt; FROM V$LOGSTDBY_PROGRESS;
 
APPLIED_SCN  LATEST_SCN MINING_SCN RESTART_SCN
----------- ----------- ---------- -----------
 7178240496  7178240507 7178240507  7178219805
</pre><p>According to the output:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>SQL Apply has applied all transactions committed on or before SCN of 7178240496</p>
                           </li>
                           <li>
                              <p>The latest redo record received at the logical standby database was generated at SCN 7178240507</p>
                           </li>
                           <li>
                              <p>The mining component has processed all redo records generate on or before SCN 7178240507</p>
                           </li>
                           <li>
                              <p>If SQL Apply stops and restarts for any reason, it will start mining redo records generated on or after SCN 7178219805</p>
                           </li>
                        </ul><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER SESSION SET NLS_DATE_FORMAT='yy-mm-dd hh24:mi:ss';
Session altered
 
SQL&gt; SELECT APPLIED_TIME, LATEST_TIME, MINING_TIME, RESTART_TIME - 
&gt; FROM V$LOGSTDBY_PROGRESS;
 
APPLIED_TIME      LATEST_TIME       MINING_TIME       RESTART_TIME     
----------------- ----------------- ----------------- -----------------
05-05-12 10:38:21 05-05-12 10:41:53 05-05-12 10:41:21 05-05-12 10:09:30
</pre><p>According to the output:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>SQL Apply has applied all transactions committed on or before the time 05-05-12 10:38:21 (<code class="codeph">APPLIED_TIME</code>)
                              </p>
                           </li>
                           <li>
                              <p>The last redo was generated at time 05-05-12 10:41:53 at the primary database (<code class="codeph">LATEST_TIME</code>)
                              </p>
                           </li>
                           <li>
                              <p>The mining engine has processed all redo records generated on or before 05-05-12 10:41:21 (<code class="codeph">MINING_TIME</code>)
                              </p>
                           </li>
                           <li>
                              <p>In the event of a restart, SQL Apply will start mining redo records generated after the time 05-05-12 10:09:30</p>
                           </li>
                        </ul>
                        <div class="infoboxnotealso" id="GUID-DAF00126-1FDA-4980-AD24-1360472ADB49__GUID-35C92B00-0351-4799-9BBF-566D083AFF87">
                           <p class="notep1">See Also:</p>
                           <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-5BD79860-B3B8-4E0D-9F55-2E9918B93292" title="SQL Apply can be in any of six states of progress: initializing SQL Apply, waiting for dictionary logs, loading the LogMiner dictionary, applying (redo data), waiting for an archive gap to be resolved, and idle.">Monitoring SQL Apply Progress</a> for example output
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="SBYDB4819"></a><div class="props_rev_3"><a id="GUID-9E8AFFE3-E4C2-46EB-A733-B48793DB4F1F" name="GUID-9E8AFFE3-E4C2-46EB-A733-B48793DB4F1F"></a><h4 id="SBYDB-GUID-9E8AFFE3-E4C2-46EB-A733-B48793DB4F1F" class="sect4"><span class="enumeration_section">11.3.6 </span>V$LOGSTDBY_STATE View
                  </h4>
                  <div>
                     <div class="section">
                        <p>This view provides a synopsis of the current state of SQL Apply, including:</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>The DBID of the primary database (<code class="codeph">primary_dbid</code>).
                              </p>
                           </li>
                           <li>
                              <p>The LogMiner session ID allocated to SQL Apply (<code class="codeph">session_id</code>).
                              </p>
                           </li>
                           <li>
                              <p>Whether or not SQL Apply is applying in real time (<code class="codeph">realtime_apply</code>).
                              </p>
                           </li>
                        </ul>
                        <p>For example:</p><pre class="oac_no_warn" dir="ltr">SQL&gt; COLUMN REALTIME_APPLY FORMAT a15
SQL&gt; COLUMN STATE FORMAT a16
SQL&gt; SELECT * FROM V$LOGSTDBY_STATE;

PRIMARY_DBID SESSION_ID REALTIME_APPLY  STATE
------------ ---------- --------------- ----------------
  1562626987          1 Y               APPLYING
</pre><p>The output shows that SQL Apply is running in the real-time apply mode and is currently applying redo data received from the primary database, the primary database's <code class="codeph">DBID</code> is 1562626987 and the LogMiner session identifier associated the SQL Apply session is 1.
                        </p>
                        <div class="infoboxnotealso" id="GUID-9E8AFFE3-E4C2-46EB-A733-B48793DB4F1F__GUID-51C3E9CB-A493-41B8-B680-721F9D310CC9">
                           <p class="notep1">See Also:</p>
                           <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-5BD79860-B3B8-4E0D-9F55-2E9918B93292" title="SQL Apply can be in any of six states of progress: initializing SQL Apply, waiting for dictionary logs, loading the LogMiner dictionary, applying (redo data), waiting for an archive gap to be resolved, and idle.">Monitoring SQL Apply Progress</a> for example output
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="SBYDB4820"></a><div class="props_rev_3"><a id="GUID-C72DA5B7-7FDD-46C8-9242-CD7D88DCDDB7" name="GUID-C72DA5B7-7FDD-46C8-9242-CD7D88DCDDB7"></a><h4 id="SBYDB-GUID-C72DA5B7-7FDD-46C8-9242-CD7D88DCDDB7" class="sect4"><span class="enumeration_section">11.3.7 </span>V$LOGSTDBY_STATS View
                  </h4>
                  <div>
                     <div class="section">
                        <p>The <code class="codeph">V$LOGSTDBY_STATS</code> view displays statistics, current state, and status information related to SQL Apply. No rows are returned from this view when SQL Apply is not running. This view is only meaningful in the context of a logical standby database.
                        </p>
                        <p>For example:</p><pre class="oac_no_warn" dir="ltr"> SQL&gt; ALTER SESSION SET NLS_DATE_FORMAT='dd-mm-yyyy hh24:mi:ss';
 Session altered

 SQL&gt; SELECT SUBSTR(name, 1, 40) AS NAME, SUBSTR(value,1,32) AS VALUE FROM V$LOGSTDBY_STATS;
 
 NAME                                     VALUE
 ---------------------------------------- --------------------------------
 logminer session id                      1
 number of preparers                      1
 number of appliers                       5
 server processes in use                  9
 maximum SGA for LCR cache (MB)           30
 maximum events recorded                  10000
 preserve commit order                    TRUE
 transaction consistency                  FULL
 record skipped errors                    Y
 record skipped DDLs                      Y
 record applied DDLs                      N
 record unsupported operations            N
 realtime apply                           Y
 apply delay (minutes)                    0
 coordinator state                        APPLYING
 coordinator startup time                 19-06-2007 09:55:47
 coordinator uptime (seconds)             3593
 txns received from logminer              56
 txns assigned to apply                   23
 txns applied                             22
 txns discarded during restart            33
 large txns waiting to be assigned        2
 rolled back txns mined                   4
 DDL txns mined                           40
 CTAS txns mined                          0
 bytes of redo mined                      60164040
 bytes paged out                          0
 pageout time (seconds)                   0
 bytes checkpointed                       4845
 checkpoint time (seconds)                0
 system idle time (seconds)               2921
 standby redo logs mined                  0
 archived logs mined                      5
 gap fetched logs mined                   0
 standby redo log reuse detected          1
 logfile open failures                    0
 current logfile wait (seconds)           0
 total logfile wait (seconds)             2910
 thread enable mined                      0
 thread disable mined                     0
 .
 40 rows selected. </pre></div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="SBYDB4821"></a><div class="props_rev_3"><a id="GUID-B0181E97-7A79-4E92-9B84-42DF8AF24FE0" name="GUID-B0181E97-7A79-4E92-9B84-42DF8AF24FE0"></a><h3 id="SBYDB-GUID-B0181E97-7A79-4E92-9B84-42DF8AF24FE0" class="sect3"><span class="enumeration_section">11.4 </span>Monitoring a Logical Standby Database
               </h3>
               <div>
                  <p>When working with logical standby databases, you can monitor SQL Apply progress, and also the automatic deletion of log files.</p>
                  <p>See the following topics:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-5BD79860-B3B8-4E0D-9F55-2E9918B93292" title="SQL Apply can be in any of six states of progress: initializing SQL Apply, waiting for dictionary logs, loading the LogMiner dictionary, applying (redo data), waiting for an archive gap to be resolved, and idle.">Monitoring SQL Apply Progress</a></p>
                     </li>
                     <li>
                        <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-893B304C-123F-4DCA-ACA2-96BB74E7A8A6" title="Foreign archived logs contain redo that was shipped from the primary database.">Automatic Deletion of Log Files</a></p>
                     </li>
                  </ul>
               </div><a id="SBYDB5043"></a><a id="SBYDB5044"></a><a id="SBYDB5045"></a><a id="SBYDB5046"></a><a id="SBYDB5047"></a><a id="SBYDB5048"></a><a id="SBYDB5049"></a><a id="SBYDB4822"></a><div class="props_rev_3"><a id="GUID-5BD79860-B3B8-4E0D-9F55-2E9918B93292" name="GUID-5BD79860-B3B8-4E0D-9F55-2E9918B93292"></a><h4 id="SBYDB-GUID-5BD79860-B3B8-4E0D-9F55-2E9918B93292" class="sect4"><span class="enumeration_section">11.4.1 </span>Monitoring SQL Apply Progress
                  </h4>
                  <div>
                     <p>SQL Apply can be in any of six states of progress: initializing SQL Apply, waiting for dictionary logs, loading the LogMiner dictionary, applying (redo data), waiting for an archive gap to be resolved, and idle.</p>
                     <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-5BD79860-B3B8-4E0D-9F55-2E9918B93292__CHDJFHAG">Figure 11-2</a> shows the flow of these states.
                     </p>
                     <div class="figure" id="GUID-5BD79860-B3B8-4E0D-9F55-2E9918B93292__CHDJFHAG">
                        <p class="titleinfigure">Figure 11-2 Progress States During SQL Apply Processing</p><img src="img/sbydb031.gif" alt="Description of Figure 11-2 follows" title="Description of Figure 11-2 follows" longdesc="img_text/sbydb031.html"><br><a href="img_text/sbydb031.html">Description of "Figure 11-2 Progress States During SQL Apply Processing"</a></div>
                     <!-- class="figure" -->
                     <p>The following subsections describe each state in more detail.</p>
                     <div class="section">
                        <p class="subhead3" id="GUID-5BD79860-B3B8-4E0D-9F55-2E9918B93292__GUID-4764F424-47B4-42CB-B44A-F234376BB6D5">Initializing State</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>When you start SQL Apply by issuing an <code class="codeph">ALTER DATABASE START LOGICAL STANDBY APPLY</code> statement, it goes into the <span class="italic">initializing</span> state.
                        </p>
                        <p>To determine the current state of SQL Apply, query the <code class="codeph">V$LOGSTDBY_STATE</code> view<a id="d26509e2619" class="indexterm-anchor"></a>. For example:
                        </p><pre class="oac_no_warn" dir="ltr">SQL&gt; SELECT SESSION_ID, STATE FROM V$LOGSTDBY_STATE;

SESSION_ID    STATE
----------    -------------
1             INITIALIZING
</pre><p>The <code class="codeph">SESSION_ID</code> column identifies the persistent LogMiner session created by SQL Apply to mine the archived redo log files generated by the primary database.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-5BD79860-B3B8-4E0D-9F55-2E9918B93292__GUID-C7B596AA-4244-40A4-B5B3-FEA7593261A5">Waiting for Dictionary Logs</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>The first time the SQL Apply is started, it needs to load the LogMiner dictionary captured in the redo log files. SQL Apply stays in the <a id="d26509e2635" class="indexterm-anchor"></a><code class="codeph">WAITING FOR DICTIONARY LOGS</code> state until it has received all redo data required to load the LogMiner dictionary.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-5BD79860-B3B8-4E0D-9F55-2E9918B93292__GUID-E6B876F0-2298-4322-93DD-62F608873F04">Loading Dictionary State</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>This <a id="d26509e2646" class="indexterm-anchor"></a><a id="d26509e2648" class="indexterm-anchor"></a><span class="italic">loading dictionary</span> state can persist for a while. Loading the LogMiner dictionary on a large database can take a long time. Querying the <code class="codeph">V$LOGSTDBY_STATE</code> view returns the following output when loading the dictionary:
                        </p><pre class="oac_no_warn" dir="ltr">SQL&gt; SELECT SESSION_ID, STATE FROM V$LOGSTDBY_STATE;

SESSION_ID    STATE
----------    ------------------
1             LOADING DICTIONARY
</pre><p>Only the <code class="codeph">COORDINATOR</code> process and the mining processes are spawned until the LogMiner dictionary is fully loaded. Therefore, if you query the <code class="codeph">V$LOGSTDBY_PROCESS</code><a id="d26509e2669" class="indexterm-anchor"></a> at this point, you do not see any of the <code class="codeph">APPLIER</code> processes. For example:
                        </p><pre class="oac_no_warn" dir="ltr">SQL&gt; SELECT SID, SERIAL#, SPID, TYPE FROM V$LOGSTDBY_PROCESS;

SID     SERIAL#     SPID       TYPE
------  ---------   ---------  ---------------------
47      3           11438      COORDINATOR
50      7           11334      READER
45      1           11336      BUILDER
44      2           11338      PREPARER
43      2           11340      PREPARER
</pre><p>You can get more detailed information about the progress in loading the dictionary by querying the <code class="codeph">V$LOGMNR_DICTIONARY_LOAD</code> view. The dictionary load happens in three phases: 
                        </p>
                        <ol>
                           <li>
                              <p>The relevant archived redo log files or standby redo logs files are mined to gather the redo changes relevant to load the LogMiner dictionary.</p>
                           </li>
                           <li>
                              <p>The changes are processed and loaded in staging tables inside the database.</p>
                           </li>
                           <li>
                              <p>The LogMiner dictionary tables are loaded by issuing a series of DDL statements.</p>
                           </li>
                        </ol>
                        <p>For example:</p><pre class="oac_no_warn" dir="ltr">SQL&gt; SELECT PERCENT_DONE, COMMAND -
&gt; FROM V$LOGMNR_DICTIONARY_LOAD -
&gt; WHERE SESSION_ID = (SELECT SESSION_ID FROM V$LOGSTDBY_STATE);

PERCENT_DONE     COMMAND
-------------    -------------------------------
40               alter table SYSTEM.LOGMNR_CCOL$ exchange partition 
                 P101 with table SYS.LOGMNRLT_101_CCOL$ excluding
                 indexes without validation
</pre><p>If the <code class="codeph">PERCENT_DONE</code> or the <code class="codeph">COMMAND</code> column does not change for a long time, query the <code class="codeph">V$SESSION_LONGOPS</code> view to monitor the progress of the DDL transaction in question.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-5BD79860-B3B8-4E0D-9F55-2E9918B93292__GUID-A7AAAC4A-253B-413A-A41F-4AA63BC7920F">Applying State</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>In this state, SQL Apply has successfully loaded the initial snapshot of the LogMiner dictionary, and is currently applying redo data to the logical standby database.</p>
                        <p>For detailed information about the SQL Apply progress, query the <code class="codeph">V$LOGSTDBY_PROGRESS</code> view:
                        </p><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER SESSION SET NLS_DATE_FORMAT = 'DD-MON-YYYY HH24:MI:SS';
SQL&gt; SELECT APPLIED_TIME, APPLIED_SCN, MINING_TIME, MINING_SCN -
&gt; FROM V$LOGSTDBY_PROGRESS;

APPLIED_TIME            APPLIED_SCN   MINING_TIME           MINING_SCN
--------------------    -----------   --------------------  -----------
10-JAN-2005 12:00:05    346791023     10-JAN-2005 12:10:05  3468810134
</pre><p>All committed transactions seen at or before <code class="codeph">APPLIED_SCN</code> (or <code class="codeph">APPLIED_TIME</code>) on the primary database have been applied to the logical standby database. The mining engine has processed all redo records generated at or before <code class="codeph">MINING_SCN</code> (and <code class="codeph">MINING_TIME</code>) on the primary database. At steady state, the value of <code class="codeph">MINING_SCN</code> (and <code class="codeph">MINING_TIME</code>) is always ahead of <code class="codeph">APPLIED_SCN</code> (and <code class="codeph">APPLIED_TIME</code>).
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-5BD79860-B3B8-4E0D-9F55-2E9918B93292__GUID-549DF95E-2FC7-4579-9776-73FE3B8F07DB">Waiting On Gap State</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>This state occurs when SQL Apply has mined and applied all available redo records, and is waiting for a new log file (or a missing log file) to be archived by the RFS process.</p><pre class="oac_no_warn" dir="ltr">SQL&gt; SELECT STATUS FROM V$LOGSTDBY_PROCESS WHERE TYPE = 'READER';

STATUS
------------------------------------------------------------------------
ORA-16240: waiting for log file (thread# 1, sequence# 99)</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-5BD79860-B3B8-4E0D-9F55-2E9918B93292__GUID-3272C1A0-5C5F-408A-8590-0AEF576C1641">Idle State</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>SQL Apply enters this state once it has applied all redo generated by the primary database.</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="SBYDB00810"></a><div class="props_rev_3"><a id="GUID-893B304C-123F-4DCA-ACA2-96BB74E7A8A6" name="GUID-893B304C-123F-4DCA-ACA2-96BB74E7A8A6"></a><h4 id="SBYDB-GUID-893B304C-123F-4DCA-ACA2-96BB74E7A8A6" class="sect4"><span class="enumeration_section">11.4.2 </span>Automatic Deletion of Log Files
                  </h4>
                  <div>
                     <p>Foreign archived logs contain redo that was shipped from the primary database. </p>
                     <p>There are two ways to store foreign archive logs:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>In the fast recovery area</p>
                        </li>
                        <li>
                           <p>In a directory outside of the fast recovery area</p>
                        </li>
                     </ul>
                     <p>Foreign archived logs stored in the fast recovery area are always managed by SQL Apply. After all redo records contained in the log have been applied at the logical standby database, they are retained for the time period specified by the <code class="codeph">DB_FLASHBACK_RETENTION_TARGET</code> parameter (or for 1440 minutes if <code class="codeph">DB_FLASHBACK_RETENTION_TARGET</code> is not specified). You cannot override automatic management of foreign archived logs that are stored in the fast recovery area.
                     </p>
                     <p>Foreign archived logs that are not stored in fast recovery area are by default managed by SQL Apply. Under automatic management, foreign archived logs that are not stored in the fast recovery area are retained for the time period specified by the <code class="codeph">LOG_AUTO_DEL_RETENTION_TARGET</code> parameter once all redo records contained in the log have been applied at the logical standby database. You can override automatic management of foreign archived logs not stored in fast recovery area by executing the following PL/SQL procedure:
                     </p><pre class="oac_no_warn" dir="ltr">SQL&gt; EXECUTE DBMS_LOGSTDBY.APPLY_SET('LOG_AUTO_DELETE', 'FALSE');
</pre><div class="infoboxnote" id="GUID-893B304C-123F-4DCA-ACA2-96BB74E7A8A6__GUID-39B195C4-D36B-40ED-BEE7-5F55692F1972">
                        <p class="notep1">Note:</p>
                        <p>Use the <code class="codeph">DBMS_LOGTSDBY.APPLY_SET</code> procedure to set this parameter. If you do not specify <code class="codeph">LOG_AUTO_DEL_RETENTION_TARGET</code> explicitly, it defaults to <code class="codeph">DB_FLASHBACK_RETENTION_TARGET</code> set in the logical standby database, or to 1440 minutes in case <code class="codeph">DB_FLASHBACK_RETENTION_TARGET</code> is not set.
                        </p>
                     </div>
                     <p>If you are overriding the default automatic log deletion capability, periodically perform the following steps to identify and delete archived redo log files that are no longer needed by SQL Apply:</p>
                     <ol>
                        <li>
                           <p>To purge the logical standby session of metadata that is no longer needed, enter the following PL/SQL statement:</p><pre class="oac_no_warn" dir="ltr">SQL&gt; EXECUTE DBMS_LOGSTDBY.PURGE_SESSION;
</pre><p>This statement also updates the <code class="codeph">DBA_LOGMNR_PURGED_LOG</code> view that displays the archived redo log files that are no longer needed.
                           </p>
                        </li>
                        <li>
                           <p>Query the <code class="codeph">DBA_LOGMNR_PURGED_LOG</code> view to list the archived redo log files that can be removed:
                           </p><pre class="oac_no_warn" dir="ltr">SQL&gt; SELECT * FROM DBA_LOGMNR_PURGED_LOG;

   FILE_NAME
   ------------------------------------
   /boston/arc_dest/arc_1_40_509538672.log
   /boston/arc_dest/arc_1_41_509538672.log
   /boston/arc_dest/arc_1_42_509538672.log
   /boston/arc_dest/arc_1_43_509538672.log
   /boston/arc_dest/arc_1_44_509538672.log
   /boston/arc_dest/arc_1_45_509538672.log
   /boston/arc_dest/arc_1_46_509538672.log
   /boston/arc_dest/arc_1_47_509538672.log
</pre></li>
                        <li>
                           <p>Use an operating system-specific command to delete the archived redo log files listed by the query.</p>
                        </li>
                     </ol>
                  </div>
               </div>
            </div><a id="SBYDB4823"></a><div class="props_rev_3"><a id="GUID-88211E8E-28BF-45AC-9230-F85B606D8987" name="GUID-88211E8E-28BF-45AC-9230-F85B606D8987"></a><h3 id="SBYDB-GUID-88211E8E-28BF-45AC-9230-F85B606D8987" class="sect3"><span class="enumeration_section">11.5 </span>Customizing a Logical Standby Database
               </h3>
               <div>
                  <p>A logical standby database can be customized in several ways, including logging of events, preventing changes to specific schema objects, and adding or re-creating tables.</p>
                  <p>See the following topics:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-D6EEF87A-211C-476C-9CBC-126858F7026A" title="The DBA_LOGSTDBY_EVENTS view can be thought of as a circular log containing the most recent interesting events that occurred in the context of SQL Apply.">Customizing Logging of Events in the DBA_LOGSTDBY_EVENTS View</a></p>
                     </li>
                     <li>
                        <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-B976F237-1888-46D3-A901-F28FE362ACBC" title="By default, all supported tables in the primary database are replicated in the logical standby database.">Using DBMS_LOGSTDBY.SKIP to Prevent Changes to Specific Schema Objects</a></p>
                     </li>
                     <li>
                        <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-28EB46A0-696D-426E-B596-225443867604" title="You can create a procedure to intercept certain DDL statements and replace the original DDL statement with a different one.">Setting up a Skip Handler for a DDL Statement</a></p>
                     </li>
                     <li>
                        <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-43971CB9-3337-4575-B4EF-D591878982F1" title="Logical standby databases can be used for reporting activities, even while SQL statements are being applied.">Modifying a Logical Standby Database</a></p>
                     </li>
                     <li>
                        <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-DD88E3D6-D6DB-4175-BB59-F048B9A87BAA" title="Typically, you use the DBMS_LOGSTDBY.INSTANTIATE_TABLE procedure to re-create a table after an unrecoverable operation.">Adding or Re-Creating Tables On a Logical Standby Database</a></p>
                        <div class="infoboxnotealso" id="GUID-88211E8E-28BF-45AC-9230-F85B606D8987__GUID-C5BD391E-AA41-4485-9BB7-1F66197DC6BF">
                           <p class="notep1">See Also:</p>
                           <p>The <code class="codeph">DBMS_LOGSTDBY</code> package in<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sbydb&amp;id=ARPLS363" target="_blank"><span class="italic"> Oracle Database PL/SQL Packages and Types Reference</span></a></p>
                        </div>
                     </li>
                  </ul>
               </div><a id="SBYDB5466"></a><a id="SBYDB5467"></a><a id="SBYDB4824"></a><div class="props_rev_3"><a id="GUID-D6EEF87A-211C-476C-9CBC-126858F7026A" name="GUID-D6EEF87A-211C-476C-9CBC-126858F7026A"></a><h4 id="SBYDB-GUID-D6EEF87A-211C-476C-9CBC-126858F7026A" class="sect4"><span class="enumeration_section">11.5.1 </span>Customizing Logging of Events in the DBA_LOGSTDBY_EVENTS View
                  </h4>
                  <div>
                     <p>The <code class="codeph">DBA_LOGSTDBY_EVENTS</code> view can be thought of as a circular log containing the most recent interesting events that occurred in the context of SQL Apply.
                     </p>
                     <div class="section">
                        <p>By default the last 10,000 events are remembered in the event view. You can change the number of events logged by invoking the <code class="codeph">DBMS_LOGSTDBY.APPLY_SET</code> procedure. For example, to ensure that the last 100,000 events are recorded, you can issue the following statement:
                        </p><pre class="oac_no_warn" dir="ltr">SQL&gt; EXECUTE DBMS_LOGSTDBY.APPLY_SET ('MAX_EVENTS_RECORDED', '100000');
</pre><p>Errors that cause SQL Apply to stop are always recorded in the <code class="codeph">DBA_LOGSTDBY_EVENTS</code> view (unless there is insufficient space in the <code class="codeph">SYSTEM</code> tablespace). These events are always put into the alert file as well, with the keyword <code class="codeph">LOGSTDBY</code> included in the text. When querying the view, select the columns in order by <code class="codeph">EVENT_TIME</code>, <code class="codeph">COMMIT_SCN</code>, and <code class="codeph">CURRENT_SCN</code>. This ordering ensures a shutdown failure appears last in the view.
                        </p>
                        <p>The following examples show <code class="codeph">DBMS_LOGSTDBY</code> subprograms that specify events to be recorded in the view.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-D6EEF87A-211C-476C-9CBC-126858F7026A__GUID-DC537CD1-F13C-4FB9-BDBA-804CA5D6A035">Example 1: Determining if DDL Statements Have Been Applied</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>For example, to record applied DDL transactions to the <code class="codeph">DBA_LOGSTDBY_EVENTS</code> view, issue the following statement:
                        </p><pre class="oac_no_warn" dir="ltr">SQL&gt; EXECUTE DBMS_LOGSTDBY.APPLY_SET ('RECORD_APPLIED_DDL', 'TRUE');</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-D6EEF87A-211C-476C-9CBC-126858F7026A__GUID-A22C8A08-9156-4A15-8AD7-7585BFDCCC38">Example 2: Checking the DBA_LOGSTDBY_EVENTS View for Unsupported Operations</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>To capture information about transactions running on the primary database that are not supported by a logical standby database, issue the following statements: </p><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER DATABASE STOP LOGICAL STANDBY APPLY;SQL&gt; EXEC DBMS_LOGSTDBY.APPLY_SET('RECORD_UNSUPPORTED_OPERATIONS', 'TRUE');SQL&gt; ALTER DATABASE START LOGICAL STANDBY APPLY IMMEDIATE; 
</pre><p>Then, check the <code class="codeph">DBA_LOGSTDBY_EVENTS</code> view for any unsupported operations. Usually, an operation on an unsupported table is silently ignored by SQL Apply. However, during rolling upgrade (while the standby database is at a higher version and mining redo generated by a lower versioned primary database), if you performed an unsupported operation on the primary database, the logical standby database may not be the one to which you want to perform a switchover. Oracle Data Guard logs at least one unsupported operation per table in the <code class="codeph">DBA_LOGSTDBY_EVENTS</code> view.   <a href="using-sql-apply-to-perform-rolling-upgrade.html#GUID-290F632F-5295-47F3-AEF1-2D37C69C00D7" title="You can use a logical standby database to perform a rolling upgrade of Oracle Database software."> Using SQL Apply to Upgrade the Oracle Database </a> provides detailed information about rolling upgrades. 
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="SBYDB4825"></a><div class="props_rev_3"><a id="GUID-B976F237-1888-46D3-A901-F28FE362ACBC" name="GUID-B976F237-1888-46D3-A901-F28FE362ACBC"></a><h4 id="SBYDB-GUID-B976F237-1888-46D3-A901-F28FE362ACBC" class="sect4"><span class="enumeration_section">11.5.2 </span>Using DBMS_LOGSTDBY.SKIP to Prevent Changes to Specific Schema Objects
                  </h4>
                  <div>
                     <p>By default, all supported tables in the primary database are replicated in the logical standby database. </p>
                     <div class="section">
                        <p>You can change the default behavior by specifying rules to skip applying modifications to specific tables. For example, to omit changes to the <code class="codeph">HR.EMPLOYEES</code> table, you can specify rules to prevent application of DML and DDL changes to the specific table. For example:
                        </p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>Stop SQL Apply:</span><div><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER DATABASE STOP LOGICAL STANDBY APPLY;
</pre></div>
                        </li>
                        <li class="stepexpand"><span>Register the <code class="codeph">SKIP</code> rules:</span><div><pre class="oac_no_warn" dir="ltr">SQL&gt; EXECUTE DBMS_LOGSTDBY.SKIP (stmt =&gt; 'DML', schema_name =&gt; 'HR', -
&gt; object_name =&gt; 'EMPLOYEES');

SQL&gt; EXECUTE DBMS_LOGSTDBY.SKIP (stmt =&gt; 'SCHEMA_DDL', schema_name =&gt; 'HR', -
&gt; object_name =&gt; 'EMPLOYEES');
</pre></div>
                        </li>
                        <li class="stepexpand"><span>Start SQL Apply:</span><div><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER DATABASE START LOGICAL STANDBY APPLY IMMEDIATE;</pre></div>
                        </li>
                     </ol>
                  </div>
               </div><a id="SBYDB4826"></a><div class="props_rev_3"><a id="GUID-28EB46A0-696D-426E-B596-225443867604" name="GUID-28EB46A0-696D-426E-B596-225443867604"></a><h4 id="SBYDB-GUID-28EB46A0-696D-426E-B596-225443867604" class="sect4"><span class="enumeration_section">11.5.3 </span>Setting up a Skip Handler for a DDL Statement
                  </h4>
                  <div>
                     <p>You can create a procedure to intercept certain DDL statements and replace the original DDL statement with a different one.</p>
                     <div class="section">
                        <p>For example, if the file system organization in the logical standby database is different than that in the primary database, you can write a <code class="codeph">DBMS_LOGSTDBY.SKIP</code> procedure to transparently handle DDL transactions with file specifications.
                        </p>
                        <p>The following procedure can handle different file system organization between the primary database and standby database, as long as you use a specific naming convention for your file-specification string.</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>Create the skip procedure to handle tablespace DDL transactions:</span><div><pre class="oac_no_warn" dir="ltr">CREATE OR REPLACE PROCEDURE SYS.HANDLE_TBS_DDL ( 
  OLD_STMT  IN  VARCHAR2, 
  STMT_TYP  IN  VARCHAR2, 
  SCHEMA    IN  VARCHAR2, 
  NAME      IN  VARCHAR2, 
  XIDUSN    IN  NUMBER, 
  XIDSLT    IN  NUMBER, 
  XIDSQN    IN  NUMBER, 
  ACTION    OUT NUMBER, 
  NEW_STMT  OUT VARCHAR2 
) AS 
BEGIN 
  
-- All primary file specification that contains a directory 
-- /usr/orcl/primary/dbs 
-- should go to /usr/orcl/stdby directory specification
 
 
  NEW_STMT := REPLACE(OLD_STMT, 
                     '/usr/orcl/primary/dbs', 
                     '/usr/orcl/stdby');
 
  ACTION := DBMS_LOGSTDBY.SKIP_ACTION_REPLACE;
 
EXCEPTION
  WHEN OTHERS THEN
    ACTION := DBMS_LOGSTDBY.SKIP_ACTION_ERROR;
    NEW_STMT := NULL;
END HANDLE_TBS_DDL; 
</pre></div>
                        </li>
                        <li class="stepexpand"><span>Stop SQL Apply:</span><div><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER DATABASE STOP LOGICAL STANDBY APPLY;
</pre></div>
                        </li>
                        <li class="stepexpand"><span>Register the skip procedure with SQL Apply:</span><div><pre class="oac_no_warn" dir="ltr">SQL&gt; EXECUTE DBMS_LOGSTDBY.SKIP (stmt =&gt; 'TABLESPACE', -
&gt; proc_name =&gt; 'sys.handle_tbs_ddl');
</pre></div>
                        </li>
                        <li class="stepexpand"><span>Start SQL Apply:</span><div><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER DATABASE START LOGICAL STANDBY APPLY IMMEDIATE;</pre></div>
                        </li>
                     </ol>
                  </div>
               </div><a id="SBYDB4827"></a><div class="props_rev_3"><a id="GUID-43971CB9-3337-4575-B4EF-D591878982F1" name="GUID-43971CB9-3337-4575-B4EF-D591878982F1"></a><h4 id="SBYDB-GUID-43971CB9-3337-4575-B4EF-D591878982F1" class="sect4"><span class="enumeration_section">11.5.4 </span>Modifying a Logical Standby Database
                  </h4>
                  <div>
                     <p>Logical standby databases can be used for reporting activities, even while SQL statements are being applied.</p>
                     <p>The <span class="italic">database guard</span> controls user access to tables in a logical standby database, and the <code class="codeph">ALTER SESSION DISABLE GUARD</code> statement is used to bypass the database guard and allow modifications to the tables in the logical standby database.
                     </p>
                     <div class="infoboxnote" id="GUID-43971CB9-3337-4575-B4EF-D591878982F1__GUID-34935874-4E98-4B04-BD66-F03E13F8B9B4">
                        <p class="notep1">Note:</p>
                        <p>To use a logical standby database to host other applications that process data being replicated from the primary database while creating other tables of their own, the database guard must be set to <code class="codeph">STANDBY</code>. For such applications to work seamlessly, make sure that you are running with <code class="codeph">PRESERVE_COMMIT_ORDER</code> set to <code class="codeph">TRUE</code> (the default setting for SQL Apply). (See <a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sbydb&amp;id=ARPLS66830" target="_blank"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for information about the <code class="codeph">PRESERVE_COMMIT_ORDER</code> parameter in the <code class="codeph">DBMS_LOGSTDBY</code> PL/SQL package.)
                        </p>
                        <p>Issue the following SQL statement to set the database guard to <code class="codeph">STANDBY</code>:
                        </p><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER DATABASE GUARD STANDBY;</pre><p>Under this guard setting, tables being replicated from the primary database are protected from user modifications, but tables created on the standby database can be modified by the applications running on the logical standby.</p>
                     </div>
                     <p>By default, a logical standby database operates with the database guard set to <code class="codeph">ALL</code>, which is its most restrictive setting, and does not allow any user changes to be performed to the database. You can override the database guard to allow changes to the logical standby database by executing the <code class="codeph">ALTER SESSION DISABLE GUARD</code> statement. Privileged users can issue this statement to turn the database guard off for the current session.
                     </p>
                     <p>The following sections provide some examples. The discussions in these sections assume that the database guard is set to <code class="codeph">ALL</code> or <code class="codeph">STANDBY</code>.
                     </p>
                  </div><a id="SBYDB4828"></a><div class="props_rev_3"><a id="GUID-FB0ABA4B-4EA4-458E-9223-B3BEE00A581A" name="GUID-FB0ABA4B-4EA4-458E-9223-B3BEE00A581A"></a><h5 id="SBYDB-GUID-FB0ABA4B-4EA4-458E-9223-B3BEE00A581A" class="sect5"><span class="enumeration_section">11.5.4.1 </span>Performing DDL on a Logical Standby Database
                     </h5>
                     <div>
                        <p>You can add a constraint to a table maintained through SQL Apply.</p>
                        <div class="section">
                           <p></p>
                           <p>By default, only accounts with <code class="codeph">SYS</code> privileges can modify the database while the database guard is set to ALL or STANDBY. If you are logged in as <code class="codeph">SYSDG</code>, <code class="codeph">SYSTEM</code>, or another privileged account, you cannot issue DDL statements on the logical standby database without first bypassing the database guard for the session.
                           </p>
                           <p>The following example shows how to stop SQL Apply, bypass the database guard, execute SQL statements on the logical standby database, and then reenable the guard. In this example, a soundex index is added to the surname column of <code class="codeph">SCOTT.EMP</code> to speed up partial match queries. A soundex index could be prohibitive to maintain on the primary server.
                           </p><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER DATABASE STOP LOGICAL STANDBY APPLY;
Database altered.

SQL&gt; ALTER SESSION DISABLE GUARD;
PL/SQL procedure successfully completed.

SQL&gt; CREATE INDEX EMP_SOUNDEX ON SCOTT.EMP(SOUNDEX(ENAME));
Table altered.

SQL&gt; ALTER SESSION ENABLE GUARD;
PL/SQL procedure successfully completed.

SQL&gt; ALTER DATABASE START LOGICAL STANDBY APPLY IMMEDIATE;
Database altered.

SQL&gt; SELECT ENAME,MGR FROM SCOTT.EMP WHERE SOUNDEX(ENAME) = SOUNDEX('CLARKE');

ENAME            MGR
----------       ----------
CLARK             7839
</pre><p>Oracle recommends that you do not perform DML operations on tables maintained by SQL Apply while the database guard bypass is enabled. Doing so introduces deviations between the primary and standby databases that make it impossible for the logical standby database to be maintained.</p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="SBYDB4829"></a><div class="props_rev_3"><a id="GUID-2050159A-C52F-49C2-80D2-457E62879462" name="GUID-2050159A-C52F-49C2-80D2-457E62879462"></a><h5 id="SBYDB-GUID-2050159A-C52F-49C2-80D2-457E62879462" class="sect5"><span class="enumeration_section">11.5.4.2 </span>Modifying Tables That Are Not Maintained by SQL Apply
                     </h5>
                     <div>
                        <div>Sometimes, a reporting application must collect summary results and store them temporarily or track the number of times a report was run. Although the main purpose of the application is to perform reporting activities, the application might need to issue DML (insert, update, and delete) operations on a logical standby database. It might even need to create or drop tables.  <span>You can set up the database guard to allow reporting operations to modify data as long as the data is not being maintained through SQL Apply.</span></div>
                        <div class="section">
                           <p></p>
                           <p>To do this, you must:</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>Specify the set of tables on the logical standby database to which an application can write data by executing the <code class="codeph">DBMS_LOGSTDBY.SKIP</code> procedure. Skipped tables are not maintained through SQL Apply.
                                 </p>
                              </li>
                              <li>
                                 <p>Set the database guard to protect only standby tables.</p>
                              </li>
                           </ul>
                           <p>In the following example, it is assumed that the tables to which the report is writing are also on the primary database. </p>
                           <p>The example stops SQL Apply, skips the tables, and then restarts SQL Apply. The reporting application writes to <code class="codeph">TESTEMP%</code> in <code class="codeph">HR</code>. The tables are no longer maintained through SQL Apply.
                           </p><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER DATABASE STOP LOGICAL STANDBY APPLY;
Database altered.

SQL&gt; EXECUTE DBMS_LOGSTDBY.SKIP(stmt =&gt; 'SCHEMA_DDL',-
     schema_name =&gt; 'HR', -
     object_name =&gt; 'TESTEMP%');
PL/SQL procedure successfully completed.

SQL&gt; EXECUTE DBMS_LOGSTDBY.SKIP('DML','HR','TESTEMP%');
PL/SQL procedure successfully completed.

SQL&gt; ALTER DATABASE START LOGICAL STANDBY APPLY IMMEDIATE;
Database altered.
</pre><p>Once SQL Apply starts, it needs to update metadata on the standby database for the newly specified tables added in the skip rules. Attempts to modify the newly skipped table until SQL Apply has had a chance to update the metadata fail. You can find out if SQL Apply has successfully taken into account the <code class="codeph">SKIP</code> rule you just added by issuing the following query:
                           </p><pre class="oac_no_warn" dir="ltr">SQL&gt; SELECT VALUE FROM SYSTEM.LOGSTDBY$PARAMETERS WHERE NAME = 'GUARD_STANDBY';

VALUE
---------------
Ready  
</pre><p>When the <code class="codeph">VALUE</code> column displays <code class="codeph">Ready</code>, SQL Apply has successfully updated all relevant metadata for the skipped table, and it is safe to modify the table.
                           </p>
                           <div class="infoboxnotealso" id="GUID-2050159A-C52F-49C2-80D2-457E62879462__GUID-46AC92D3-3103-4D19-AF0D-211A4EDABFF4">
                              <p class="notep1">See Also:</p>
                              <p><a href="data-type-ddl-support-on-logical-standby-databases.html#GUID-1595A660-6790-436A-BB84-D74C9187D8AE" title="The DBMS_LOGSTDBY.SKIP procedure has several optional keywords.">DDL Statements Supported by a Logical Standby Database</a> and the <a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sbydb&amp;id=ARPLS363" target="_blank"><code class="codeph">DBMS_LOGSTDBY</code></a> package in <a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sbydb&amp;id=ARPLS363" target="_blank"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a></p>
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="SBYDB4830"></a><div class="props_rev_3"><a id="GUID-DD88E3D6-D6DB-4175-BB59-F048B9A87BAA" name="GUID-DD88E3D6-D6DB-4175-BB59-F048B9A87BAA"></a><h4 id="SBYDB-GUID-DD88E3D6-D6DB-4175-BB59-F048B9A87BAA" class="sect4"><span class="enumeration_section">11.5.5 </span>Adding or Re-Creating Tables On a Logical Standby Database
                  </h4>
                  <div>
                     <p>Typically, you use the <code class="codeph">DBMS_LOGSTDBY.INSTANTIATE_TABLE</code> procedure to re-create a table after an unrecoverable operation. 
                     </p>
                     <div class="section">
                        <p>You can also use this procedure to enable SQL Apply on a table that was formerly skipped.</p>
                        <p>Before you can create a table, it must meet the requirements described in <a href="creating-oracle-data-guard-logical-standby.html#GUID-C238335E-8383-43F1-B5B1-709A2A619C30" title="The ROWIDs contained in the redo records generated by the primary database cannot be used to identify the corresponding row in the logical standby database.">Ensure Table Rows in the Primary Database Can Be Uniquely Identified</a>. Then, you can use the following steps to re-create a table named <code class="codeph">HR.EMPLOYEES</code> and resume SQL Apply. The directions assume that there is already a database link <code class="codeph">BOSTON</code> defined to access the primary database.
                        </p>
                        <p>The following list shows how to re-create a table and restart SQL Apply on that table:</p>
                        <ol>
                           <li>
                              <p>Stop SQL Apply:</p><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER DATABASE STOP LOGICAL STANDBY APPLY;
</pre></li>
                           <li>
                              <p>Ensure no operations are being skipped for the table in question by querying the <code class="codeph">DBA_LOGSTDBY_SKIP</code> view:
                              </p><pre class="oac_no_warn" dir="ltr">SQL&gt; SELECT * FROM DBA_LOGSTDBY_SKIP;

ERROR  STATEMENT_OPT        OWNER          NAME                PROC
-----  -------------------  -------------  ----------------    -----
N      SCHEMA_DDL           HR             EMPLOYEES
N      DML                  HR             EMPLOYEES
N      SCHEMA_DDL           OE             TEST_ORDER
N      DML                  OE             TEST_ORDER
</pre><p>Because you already have skip rules associated with the table that you want to re-create on the logical standby database, you must first delete those rules. You can accomplish that by calling the <code class="codeph">DBMS_LOGSTDBY.UNSKIP</code> procedure. For example:
                              </p><pre class="oac_no_warn" dir="ltr">SQL&gt; EXECUTE DBMS_LOGSTDBY.UNSKIP(stmt =&gt; 'DML', -
&gt; schema_name =&gt; 'HR', -
&gt; object_name =&gt; 'EMPLOYEES');
</pre><pre class="oac_no_warn" dir="ltr">SQL&gt; EXECUTE DBMS_LOGSTDBY.UNSKIP(stmt =&gt; 'SCHEMA_DDL', -
&gt; schema_name =&gt; 'HR', -
&gt; object_name =&gt; 'EMPLOYEES');
</pre></li>
                           <li>
                              <p>Re-create the table <code class="codeph">HR.EMPLOYEES</code> with all its data in the logical standby database by using the <code class="codeph">DBMS_LOGSTDBY.INSTANTIATE_TABLE</code><a id="d26509e3978" class="indexterm-anchor"></a><a id="d26509e3982" class="indexterm-anchor"></a> procedure. For example:
                              </p><pre class="oac_no_warn" dir="ltr">SQL&gt; EXECUTE DBMS_LOGSTDBY.INSTANTIATE_TABLE(schema_name =&gt; 'HR', -
&gt; table_name =&gt; 'EMPLOYEES', -
&gt; dblink =&gt; 'BOSTON');
</pre></li>
                           <li>
                              <p>Start SQL Apply:</p><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER DATABASE START LOGICAL STANDBY APPLY IMMEDIATE;
</pre><div class="infoboxnotealso" id="GUID-DD88E3D6-D6DB-4175-BB59-F048B9A87BAA__GUID-22C93637-3F30-4B1C-A919-4A7945555CD0">
                                 <p class="notep1">See Also:</p>
                                 <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sbydb&amp;id=ARPLS363" target="_blank"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for information about the <code class="codeph">DBMS_LOGSTDBY.UNSKIP</code> and the <code class="codeph">DBMS_LOGSTDBY.INSTANTIATE_TABLE</code> procedures
                                 </p>
                              </div>
                           </li>
                        </ol>
                        <p>To ensure a consistent view across the newly instantiated table and the rest of the database, wait for SQL Apply to catch up with the primary database before querying this table. You can do this by performing the following steps:</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>On the primary database, determine the current SCN by querying the <code class="codeph">V$DATABASE</code> view:</span><div><pre class="oac_no_warn" dir="ltr">SQL&gt; SELECT CURRENT_SCN FROM V$DATABASE@BOSTON;

CURRENT_SCN
---------------------
345162788
</pre></div>
                        </li>
                        <li class="stepexpand"><span>Make sure SQL Apply has applied all transactions committed before the <code class="codeph">CURRENT_SCN</code> returned in the previous query:</span><div><pre class="oac_no_warn" dir="ltr">SQL&gt; SELECT APPLIED_SCN FROM V$LOGSTDBY_PROGRESS;

APPLIED_SCN
--------------------------
345161345
</pre><p>When the <code class="codeph">APPLIED_SCN</code> returned in this query is greater than the <code class="codeph">CURRENT_SCN</code> returned in the first query, it is safe to query the newly re-created table.
                              </p>
                           </div>
                        </li>
                     </ol>
                  </div>
               </div>
            </div><a id="SBYDB4831"></a><div class="props_rev_3"><a id="GUID-6B8A9BA8-AEF5-4F87-9B1D-67D1A32955D0" name="GUID-6B8A9BA8-AEF5-4F87-9B1D-67D1A32955D0"></a><h3 id="SBYDB-GUID-6B8A9BA8-AEF5-4F87-9B1D-67D1A32955D0" class="sect3"><span class="enumeration_section">11.6 </span>Managing Specific Workloads In the Context of a Logical Standby Database
               </h3>
               <div>
                  <p>You can manage specific workloads in the context of a logical standby.</p>
                  <p>See the following:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-9B6FFB16-3A39-48E6-946F-98931D2E4449" title="A transportable tablespace can be imported to a primary database.">Importing a Transportable Tablespace to the Primary Database</a></p>
                     </li>
                     <li>
                        <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-37E6E6F2-15F0-4F16-B9E5-5EA7B28D6FB3" title="Logical standby automatically skips DDL statements related to materialized views.">Using Materialized Views</a></p>
                     </li>
                     <li>
                        <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-50903261-075E-44F4-80F2-E5ED7C165F0D" title="By default, triggers and constraints are automatically enabled and handled on logical standby databases.">How Triggers and Constraints Are Handled on a Logical Standby Database</a></p>
                     </li>
                     <li>
                        <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-3DA5C15C-C275-45D5-A6DA-75ED5878D7FB" title="DML triggers created on a table have their DBMS_DDL.SET_TRIGGER_FIRING_PROPERTY fire_once parameter set to TRUE by default.">Using Triggers to Replicate Unsupported Tables</a></p>
                     </li>
                     <li>
                        <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-44D7C275-A991-4B6F-84A2-D76085E00367" title="When a logical standby database receives a new branch of redo data, SQL Apply automatically takes the new branch of redo data.">Recovering Through the Point-in-Time Recovery Performed at the Primary</a></p>
                     </li>
                     <li>
                        <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-DD1C8B1D-0F1A-448E-B193-124DD8FD65E9" title="You can run an Oracle Streams capture process on a logical standby database to capture changes from any table that exists on the logical standby database (whether it is a local table or a maintained table that is being replicated from the primary database).">Running an Oracle Streams Capture Process on a Logical Standby Database</a></p>
                     </li>
                  </ul>
               </div><a id="SBYDB4832"></a><div class="props_rev_3"><a id="GUID-9B6FFB16-3A39-48E6-946F-98931D2E4449" name="GUID-9B6FFB16-3A39-48E6-946F-98931D2E4449"></a><h4 id="SBYDB-GUID-9B6FFB16-3A39-48E6-946F-98931D2E4449" class="sect4"><span class="enumeration_section">11.6.1 </span>Importing a Transportable Tablespace to the Primary Database
                  </h4>
                  <div>
                     <p>A transportable tablespace can be imported to a primary database.</p>
                     <div class="section">
                        <p>Perform the following steps:</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>Disable the guard setting so that you can modify the logical standby database:</span><div><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER DATABASE GUARD STANDBY;
</pre></div>
                        </li>
                        <li class="stepexpand"><span>Import the tablespace at the logical standby database.</span></li>
                        <li class="stepexpand"><span>Enable the database guard setting:</span><div><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER DATABASE GUARD ALL;
</pre></div>
                        </li>
                        <li class="stepexpand"><span>Import the tablespace at the primary database.</span></li>
                     </ol>
                  </div>
               </div><a id="SBYDB4833"></a><div class="props_rev_3"><a id="GUID-37E6E6F2-15F0-4F16-B9E5-5EA7B28D6FB3" name="GUID-37E6E6F2-15F0-4F16-B9E5-5EA7B28D6FB3"></a><h4 id="SBYDB-GUID-37E6E6F2-15F0-4F16-B9E5-5EA7B28D6FB3" class="sect4"><span class="enumeration_section">11.6.2 </span>Using Materialized Views
                  </h4>
                  <div>
                     <p>Logical standby automatically skips DDL statements related to materialized views.</p>
                     <p>For example, logical standby skips the following statements:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><code class="codeph">CREATE</code>, <code class="codeph">ALTER</code>, or <code class="codeph">DROP MATERIALIZED VIEW</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">CREATE</code>, <code class="codeph">ALTER</code> or <code class="codeph">DROP MATERIALIZED VIEW LOG</code></p>
                        </li>
                     </ul>
                     <p>New materialized views that are created, altered, or dropped on the primary database after the logical standby database has been created are not created on the logical standby database. However, materialized views created on the primary database prior to the logical standby database being created are present on the logical standby database.</p>
                     <p>Logical Standby supports the creation and maintenance of new materialized views locally on the logical standby database in addition to other kinds of auxiliary data structure. For example, online transaction processing (OLTP) systems frequently use highly normalized tables for update performance but these can lead to slower response times for complex decision support queries. Materialized views that denormalize the replicated data for more efficient query support on the logical standby database can be created, as follows (connect as user <code class="codeph">SYS</code> before issuing these statements):
                     </p><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER SESSION DISABLE GUARD; 
 
SQL&gt; CREATE MATERIALIZED VIEW LOG ON SCOTT.EMP -
&gt;  WITH ROWID (EMPNO, ENAME, MGR, DEPTNO) INCLUDING NEW VALUES;

SQL&gt; CREATE MATERIALIZED VIEW LOG ON SCOTT.DEPT -
&gt;  WITH ROWID (DEPTNO, DNAME) INCLUDING NEW VALUES;

SQL&gt; CREATE MATERIALIZED VIEW SCOTT.MANAGED_BY -
&gt;  REFRESH ON DEMAND -
&gt;  ENABLE QUERY REWRITE -
&gt;  AS SELECT  E.ENAME, M.ENAME AS MANAGER -
&gt;  FROM SCOTT.EMP E, SCOTT.EMP M WHERE E.MGR=M.EMPNO;

SQL&gt; CREATE MATERIALIZED VIEW SCOTT.IN_DEPT -
&gt;  REFRESH FAST ON COMMIT -
&gt;  ENABLE QUERY REWRITE -
&gt;  AS SELECT E.ROWID AS ERID, D.ROWID AS DRID, E.ENAME, D.DNAME -
&gt;  FROM SCOTT.EMP E, SCOTT.DEPT D WHERE E.DEPTNO=D.DEPTNO;
</pre><p>On a logical standby database:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>An ON-COMMIT materialized view is refreshed automatically on the logical standby database when the transaction commit occurs.</p>
                        </li>
                        <li>
                           <p>An ON-DEMAND materialized view is not automatically refreshed: the <code class="codeph">DBMS_MVIEW.REFRESH</code> procedure must be executed to refresh it.
                           </p>
                        </li>
                     </ul>
                     <p>For example, issuing the following command would refresh the ON-DEMAND materialized view created in the previous example:</p><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER SESSION DISABLE GUARD; 
 
SQL&gt; EXECUTE DBMS_MVIEW.REFRESH (LIST =&gt; 'SCOTT.MANAGED_BY', METHOD =&gt; 'C');
</pre><p>If <code class="codeph">DBMS_SCHEDULER</code> jobs are being used to periodically refresh on-demand materialized views, the database guard must be set to <code class="codeph">STANDBY</code>. (It is not possible to use the <code class="codeph">ALTER SESSION DISABLE GUARD</code> statement inside a PL/SQL block and have it take effect.)
                     </p>
                  </div>
               </div><a id="SBYDB4834"></a><div class="props_rev_3"><a id="GUID-50903261-075E-44F4-80F2-E5ED7C165F0D" name="GUID-50903261-075E-44F4-80F2-E5ED7C165F0D"></a><h4 id="SBYDB-GUID-50903261-075E-44F4-80F2-E5ED7C165F0D" class="sect4"><span class="enumeration_section">11.6.3 </span>How Triggers and Constraints Are Handled on a Logical Standby Database
                  </h4>
                  <div>
                     <p>By default, triggers and constraints are automatically enabled and handled on logical standby databases. </p>
                     <p>For triggers and constraints on tables <span class="italic">maintained</span> by SQL Apply:
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Constraints — Check constraints are evaluated on the primary database and do not need to be re-evaluated on the logical standby database.</p>
                        </li>
                        <li>
                           <p>Triggers — The effects of the triggers executed on the primary database are logged and applied on the standby database.</p>
                        </li>
                     </ul>
                     <p>For triggers and constraints on tables <span class="italic">not</span> <span class="italic">maintained</span> by SQL Apply:
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Constraints are evaluated</p>
                        </li>
                        <li>
                           <p>Triggers are fired</p>
                        </li>
                     </ul>
                  </div>
               </div><a id="SBYDB4835"></a><div class="props_rev_3"><a id="GUID-3DA5C15C-C275-45D5-A6DA-75ED5878D7FB" name="GUID-3DA5C15C-C275-45D5-A6DA-75ED5878D7FB"></a><h4 id="SBYDB-GUID-3DA5C15C-C275-45D5-A6DA-75ED5878D7FB" class="sect4"><span class="enumeration_section">11.6.4 </span>Using Triggers to Replicate Unsupported Tables
                  </h4>
                  <div>
                     <p>DML triggers created on a table have their <code class="codeph">DBMS_DDL.SET_TRIGGER_FIRING_PROPERTY</code> <code class="codeph">fire_once</code> parameter set to <code class="codeph">TRUE</code> by default. 
                     </p>
                     <p>The triggers fire only when the table is modified by a user process. They are automatically disabled inside SQL Apply processes, and thus do not fire when a SQL Apply process modifies the table. There are two ways to fire a trigger as a result of SQL Apply process making a change to a maintained table:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Set the <code class="codeph">fire_once</code> parameter of a trigger to <code class="codeph">FALSE</code>, which allows it to fire in either the context of a user process or a SQL Apply process
                           </p>
                        </li>
                        <li>
                           <p>Set the <code class="codeph">apply_server_only</code> parameter to <code class="codeph">TRUE</code> which results in the trigger firing only in the context of a SQL Apply process and not in the context of a user process
                           </p>
                        </li>
                     </ul>
                     <div class="tblformal" id="GUID-3DA5C15C-C275-45D5-A6DA-75ED5878D7FB__GUID-E51BED5A-8FBE-4840-8D34-45AECD58DA2C">
                        <table cellpadding="4" cellspacing="0" class="Formal" title="" summary="This 3 column table shows the effect of DML Triggers. Column 1 is the fire_once parameter setting. Column 1 is the apply_server_only parameter setting. Column 3 describes the effects. " width="100%" frame="hsides" border="1" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="14%" id="d26509e4614">fire_once</th>
                                 <th align="left" valign="bottom" width="26%" id="d26509e4617">apply_server_only</th>
                                 <th align="left" valign="bottom" width="60%" id="d26509e4620">description</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="14%" id="d26509e4625" headers="d26509e4614 ">
                                    <p><code class="codeph">TRUE</code></p>
                                 </td>
                                 <td align="left" valign="top" width="26%" headers="d26509e4625 d26509e4617 ">
                                    <p><code class="codeph">FALSE</code></p>
                                 </td>
                                 <td align="left" valign="top" width="60%" headers="d26509e4625 d26509e4620 ">
                                    <p>This is the default property setting for a DML trigger. The trigger fires only when a user process modifies the base table.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="14%" id="d26509e4637" headers="d26509e4614 ">
                                    <p><code class="codeph">FALSE</code></p>
                                 </td>
                                 <td align="left" valign="top" width="26%" headers="d26509e4637 d26509e4617 ">
                                    <p><code class="codeph">FALSE</code></p>
                                 </td>
                                 <td align="left" valign="top" width="60%" headers="d26509e4637 d26509e4620 ">
                                    <p>The trigger fires in the context of a user process and in the context of a SQL Apply process modifying the base table. You can distinguish the two contexts by using the <code class="codeph">DBMS_LOGSTDBY.IS_APPLY_SERVER</code> function.
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="14%" id="d26509e4652" headers="d26509e4614 ">
                                    <p><code class="codeph">TRUE</code>/<code class="codeph">FALSE</code></p>
                                 </td>
                                 <td align="left" valign="top" width="26%" headers="d26509e4652 d26509e4617 ">
                                    <p><code class="codeph">TRUE</code></p>
                                 </td>
                                 <td align="left" valign="top" width="60%" headers="d26509e4652 d26509e4620 ">
                                    <p>The trigger only fires when a SQL Apply process modifies the base table. The trigger does not fire when a user process modifies the base table. Thus, the <code class="codeph">apply_server_only</code> property overrides the <code class="codeph">fire_once</code> parameter of a trigger.
                                    </p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <p>Tables that are unsupported due to simple object type columns can be replicated by creating triggers that fire in the context of a SQL Apply process (either by setting the <code class="codeph">fire_once</code> parameter of such a trigger to <code class="codeph">FALSE</code> or by setting the apply_server_only parameter of such a trigger to <code class="codeph">TRUE</code>). A regular DML trigger can be used on the primary database to flatten the object type into a table that can be supported. The trigger that fires in the context of a SQL Apply process on the logical standby reconstitutes the object type and updates the unsupported table in a transactional manner.
                     </p>
                     <div class="infoboxnotealso" id="GUID-3DA5C15C-C275-45D5-A6DA-75ED5878D7FB__GUID-AC849AE5-38AA-4B70-90C4-6F76431D62CA">
                        <p class="notep1">See Also:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><a href="../arpls/DBMS_DDL.html#ARPLS008" target="_blank"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for descriptions of the <code class="codeph">DBMS_DDL.SET_TRIGGER_FIRING_PROPERTY</code> procedure and the <code class="codeph">DBMS_LOGSTDBY.IS_APPLY_SERVER</code> function
                              </p>
                           </li>
                        </ul>
                     </div>
                     <p>The following example shows how a table with a simple object type could be replicated using triggers. This example shows how to handle inserts; the same principle can be applied to updating and deleting. Nested tables and <code class="codeph">VARRAY</code>s can also be replicated using this technique with the additional step of a loop to normalize the nested data.
                     </p><pre class="oac_no_warn" dir="ltr">-- simple object type
create or replace type Person as object
(
  FirstName    varchar2(50),
  LastName     varchar2(50),
  BirthDate    Date
)
 
-- unsupported object table
create table employees
(
  IdNumber     varchar2(10) ,
  Department   varchar2(50),
  Info         Person
)
 
-- supported table populated via trigger
create table employees_transfer
(
  t_IdNumber   varchar2(10),
  t_Department varchar2(50),
  t_FirstName  varchar2(50),
  t_LastName   varchar2(50),
  t_BirthDate  Date
)
--
-- create this trigger to flatten object table on the primary
-- this trigger will not fire on the standby
--
create or replace trigger flatten_employees
  after insert on employees for each row
declare
begin
  insert into employees_transfer
    (t_IdNumber, t_Department, t_FirstName, t_LastName, t_BirthDate)
  values
    (:new.IdNumber, :new.Department,
 :new.Info.FirstName,:new.Info.LastName, :new.Info.BirthDate);
end
 
--
-- Option#1 (Better Option: Create a trigger and 
-- set its apply-server-only property to TRUE)
-- create this trigger at the logical standby database
-- to populate object table on the standby
-- this trigger only fires when apply replicates rows 
-- to the standby
--
create or replace trigger reconstruct_employees_aso
  after insert on employees_transfer for each row
begin
  
    insert into employees (IdNumber, Department, Info)
    values (:new.t_IdNumber, :new.t_Department,
Person(:new.t_FirstName, :new.t_LastName,  :new.t_BirthDate));
  
end
 
-- set this trigger to fire from the apply server
execute dbms_ddl.set_trigger_firing_property( -
trig_owner =&gt; 'scott', -
trig_name  =&gt; 'reconstruct_employees_aso', 
property =&gt; dbms_ddl.apply_server_only,
setting =&gt; TRUE);
 
--
-- Option#2 (Create a trigger and set 
--           its fire-once property to FALSE)
-- create this trigger at the logical standby database
-- to populate object table on the standby
-- this trigger will fire when apply replicates rows to -- the standby, but we will need to make sure we are
-- are executing inside a SQL Apply process by invoking
-- dbms_logstdby.is_apply_server function
--
create or replace trigger reconstruct_employees_nfo
  after insert on employees_transfer for each row
begin
  if dbms_logstdby.is_apply_server() then
    insert into employees (IdNumber, Department, Info)
    values (:new.t_IdNumber, :new.t_Department,
Person(:new.t_FirstName, :new.t_LastName,  :new.t_BirthDate));
  end if;
end
 
-- set this trigger to fire from the apply server
execute dbms_ddl.set_trigger_firing_property( -
trig_owner =&gt; 'scott', -
trig_name  =&gt; 'reconstruct_employees_nfo', 
property =&gt; dbms_ddl.fire_once,
setting =&gt; FALSE);</pre></div>
               </div><a id="SBYDB4836"></a><div class="props_rev_3"><a id="GUID-44D7C275-A991-4B6F-84A2-D76085E00367" name="GUID-44D7C275-A991-4B6F-84A2-D76085E00367"></a><h4 id="SBYDB-GUID-44D7C275-A991-4B6F-84A2-D76085E00367" class="sect4"><span class="enumeration_section">11.6.5 </span>Recovering Through the Point-in-Time Recovery Performed at the Primary
                  </h4>
                  <div>
                     <p>When a logical standby database receives a new branch of redo data, SQL Apply automatically takes the new branch of redo data. </p>
                     <div class="section">
                        <p>For logical standby databases, no manual intervention is required if the standby database did not apply redo data past the new resetlogs SCN (past the start of the new branch of redo data)</p>
                        <p>The following table describes how to resynchronize the standby database with the primary database branch.</p>
                        <div class="tblformalwide" id="GUID-44D7C275-A991-4B6F-84A2-D76085E00367__GUID-7474462F-5AF2-47BF-9E1B-681ED03EC9D7">
                           <table cellpadding="4" cellspacing="0" class="FormalWide" title="" summary="This 3column table describes how to resynchronize the standby database with the primary database branch after you issue an OPEN RESETLOGS statement." width="100%" frame="hsides" border="1" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="32%" id="d26509e4816">If the standby database.  .  .    </th>
                                    <th align="left" valign="bottom" width="27%" id="d26509e4819">Then.  .  .   </th>
                                    <th align="left" valign="bottom" width="41%" id="d26509e4822">Perform these steps.  .  .   </th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="32%" id="d26509e4827" headers="d26509e4816 ">
                                       <p>Has not applied redo data past the new resetlogs SCN (past the start of the new branch of redo data)</p>
                                    </td>
                                    <td align="left" valign="top" width="27%" headers="d26509e4827 d26509e4819 ">
                                       <p>SQL Apply automatically takes the new branch of redo data.</p>
                                    </td>
                                    <td align="left" valign="top" width="41%" headers="d26509e4827 d26509e4822 ">
                                       <p>No manual intervention is necessary. SQL Apply automatically resynchronizes the standby database with the new branch of redo data.</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="32%" id="d26509e4837" headers="d26509e4816 ">
                                       <p>Has applied redo data past the new resetlogs SCN (past the start of the new branch of redo data) and Flashback Database is enabled on the standby database</p>
                                    </td>
                                    <td align="left" valign="top" width="27%" headers="d26509e4837 d26509e4819 ">
                                       <p>The standby database is recovered <span class="italic">in the future </span>of the new branch of redo data.
                                       </p>
                                    </td>
                                    <td align="left" valign="top" width="41%" headers="d26509e4837 d26509e4822 ">
                                       <ol>
                                          <li>
                                             <p>Follow the procedure in <a href="examples-of-using-oracle-data-guard.html#GUID-A2191DBB-AA91-4C42-8F01-7B7E9529F465" title="These steps describe how to avoid re-creating a logical standby database after you have flashed back the primary database and opened it by issuing an OPEN RESETLOGS statement.">Flashing Back a Logical Standby Database to a Specific Point-in-Time</a> to flash back a logical standby database.
                                             </p>
                                          </li>
                                          <li>
                                             <p>Restart SQL Apply to continue application of redo onto the new reset logs branch. </p>
                                          </li>
                                       </ol>
                                       <p>SQL Apply automatically resynchronizes the standby database with the new branch.</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="32%" id="d26509e4867" headers="d26509e4816 ">
                                       <p>Has applied redo data past the new resetlogs SCN (past the start of the new branch of redo data) and Flashback Database is not enabled on the standby database</p>
                                    </td>
                                    <td align="left" valign="top" width="27%" headers="d26509e4867 d26509e4819 ">
                                       <p>The primary database has diverged from the standby on the indicated primary database branch.</p>
                                    </td>
                                    <td align="left" valign="top" width="41%" headers="d26509e4867 d26509e4822 ">
                                       <p>Re-create the logical standby database following the procedures in <a href="creating-oracle-data-guard-logical-standby.html#GUID-3666CA35-D993-44B6-8D70-A2B8B9EC8B2E" title="There are a number of steps involved in creating a logical standby database, including prerequisites and post-creation tasks."> Creating a Logical Standby Database </a>.
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="32%" id="d26509e4884" headers="d26509e4816 ">
                                       <p>Is missing archived redo log files from the end of the previous branch of redo data</p>
                                    </td>
                                    <td align="left" valign="top" width="27%" headers="d26509e4884 d26509e4819 ">
                                       <p>SQL Apply cannot continue until the missing log files are retrieved. </p>
                                    </td>
                                    <td align="left" valign="top" width="41%" headers="d26509e4884 d26509e4822 ">
                                       <p>Locate and register missing archived redo log files from the previous branch.</p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <p>See <a href="../bradv/rman-performing-flashback-dbpitr.html#BRADV89752" target="_blank"><span class="italic">Oracle Database Backup and Recovery User's Guide</span></a> for more information about database incarnations, recovering through an <code class="codeph">OPEN RESETLOGS</code> operation, and Flashback Database.
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="SBYDB4837"></a><div class="props_rev_3"><a id="GUID-DD1C8B1D-0F1A-448E-B193-124DD8FD65E9" name="GUID-DD1C8B1D-0F1A-448E-B193-124DD8FD65E9"></a><h4 id="SBYDB-GUID-DD1C8B1D-0F1A-448E-B193-124DD8FD65E9" class="sect4"><span class="enumeration_section">11.6.6 </span>Running an Oracle Streams Capture Process on a Logical Standby Database
                  </h4>
                  <div>
                     <p>You can run an Oracle Streams capture process on a logical standby database to capture changes from any table that exists on the logical standby database (whether it is a local table or a maintained table that is being replicated from the primary database).</p>
                     <p> When changes are captured to a maintained table, there is additional latency as compared to running an Oracle Streams capture process at the primary database. The additional latency is because of the fact that when you are running at a logical standby, the Oracle Streams capture process must wait for the changes to be shipped from the primary to the logical standby and applied by SQL Apply. In most cases, if you are running real time apply, it is no more than a few seconds.</p>
                     <p>The Oracle Streams capture process is associated with the database where it was created; the role of the database is irrelevant. For example, suppose you have a primary database named <code class="codeph">Boston</code> and a logical standby named <code class="codeph">London</code>. You cannot move the Oracle Streams capture process from one database to the other as you go through role transitions. For instance, if you created an Oracle Streams capture process on <code class="codeph">London</code> when it was a logical standby, then it remains on <code class="codeph">London</code> even when <code class="codeph">London</code> becomes the primary as a result of a role transition operation such as a switchover or failover. For the Oracle Streams capture process to continue working after a role transition, you must write a role transition trigger such as the following:
                     </p><pre class="oac_no_warn" dir="ltr">create or replace trigger streams_aq_job_role_change1 
after DB_ROLE_CHANGE on database 
declare
cursor capture_aq_jobs is 
  select job_name, database_role 
   from dba_scheduler_job_roles 
   where job_name like 'AQ_JOB%'; 
u capture_aq_jobs%ROWTYPE; 
my_db_role  varchar2(16); 
begin 
 
  if (dbms_logstdby.db_is_logstdby() = 1) then my_db_role := 'LOGICAL STANDBY';
  else my_db_role := 'PRIMARY';
  end if; 
 
 open capture_aq_jobs; 
 loop 
   fetch capture_aq_jobs into u; 
   exit when capture_aq_jobs%NOTFOUND; 
 
   if (u.database_role != my_db_role) then 
     dbms_scheduler.set_attribute(u.job_name, 
              'database_role', 
               my_db_role); 
 
   end if; 
 end loop; 
 close capture_aq_jobs; 
 
exception
 when others then 
 begin 
   raise; 
 end;  
end;</pre></div>
               </div>
            </div><a id="SBYDB4838"></a><div class="props_rev_3"><a id="GUID-8808747E-825D-4E0C-BD26-4E18F40574F8" name="GUID-8808747E-825D-4E0C-BD26-4E18F40574F8"></a><h3 id="SBYDB-GUID-8808747E-825D-4E0C-BD26-4E18F40574F8" class="sect3"><span class="enumeration_section">11.7 </span>Tuning a Logical Standby Database
               </h3>
               <div>
                  <p>These topics provide information about various ways to tune logical standby databases.</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-10287018-12F8-4727-AB2D-C720571AF4B6" title="On the primary database, if a table does not have a primary key or a unique index and you are certain the rows are unique, then create a primary key RELY constraint.">Create a Primary Key RELY Constraint</a></p>
                     </li>
                     <li>
                        <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-4DDC26F5-29CC-435E-9996-8887DA653032" title="Statistics should be gathered on the standby database because the cost-based optimizer (CBO) uses them to determine the optimal query execution path.">Gather Statistics for the Cost-Based Optimizer</a></p>
                     </li>
                     <li>
                        <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-8EFFAC57-9E1A-419E-AEAE-E5931D2845CB" title="There are three parameters that can be modified to control the number of processes allocated to SQL Apply: MAX_SERVERS, APPLY_SERVERS, and PREPARE_SERVERS.">Adjust the Number of Processes</a></p>
                     </li>
                     <li>
                        <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-E856251B-C6AD-480A-9D9B-278BBF66688F" title="For some workloads, SQL Apply may use a large number of pageout operations, thereby reducing the overall throughput of the system. Increasing memory allocated to the LCR cache may help.">Adjust the Memory Used for LCR Cache</a></p>
                     </li>
                     <li>
                        <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-486200D3-C7A5-4B21-9C81-FC654AD405DD" title="By default, transactions are applied on the logical standby database in the exact order in which they were committed on the primary database.">Adjust How Transactions are Applied On the Logical Standby Database</a></p>
                     </li>
                  </ul>
               </div><a id="SBYDB4839"></a><div class="props_rev_3"><a id="GUID-10287018-12F8-4727-AB2D-C720571AF4B6" name="GUID-10287018-12F8-4727-AB2D-C720571AF4B6"></a><h4 id="SBYDB-GUID-10287018-12F8-4727-AB2D-C720571AF4B6" class="sect4"><span class="enumeration_section">11.7.1 </span>Create a Primary Key RELY Constraint
                  </h4>
                  <div>
                     <p>On the primary database, if a table does not have a primary key or a unique index and you are certain the rows are unique, then create a primary key <code class="codeph">RELY</code> constraint. 
                     </p>
                     <div class="section">
                        <p>On the logical standby database, create an index on the columns that make up the primary key. The following query generates a list of tables with no index information that can be used by a logical standby database to apply to uniquely identify rows. By creating an index on the following tables, performance can be improved significantly.</p><pre class="oac_no_warn" dir="ltr">SQL&gt; SELECT OWNER, TABLE_NAME FROM DBA_TABLES -
&gt; WHERE OWNER NOT IN (SELECT OWNER FROM DBA_LOGSTDBY_SKIP -
&gt; WHERE STATEMENT_OPT = 'INTERNAL SCHEMA') -
&gt; MINUS -
&gt; SELECT DISTINCT TABLE_OWNER, TABLE_NAME FROM DBA_INDEXES -
&gt; WHERE INDEX_TYPE NOT LIKE ('FUNCTION-BASED%') -
&gt; MINUS -
&gt; SELECT OWNER, TABLE_NAME FROM DBA_LOGSTDBY_UNSUPPORTED;</pre><pre class="oac_no_warn" dir="ltr"></pre><p>You can add a rely primary key constraint to a table on the primary database, as follows:</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>Add the primary key rely constraint at the primary database:</span><div><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER TABLE HR.TEST_EMPLOYEES ADD PRIMARY KEY (EMPNO) RELY DISABLE;
</pre><p>This ensures that the <code class="codeph">EMPNO</code> column, which can be used to uniquely identify the rows in <code class="codeph">HR.TEST_EMPLOYEES</code> table, is supplementally logged as part of any updates done on that table.
                              </p>
                              <p>Note that the <code class="codeph">HR.TEST_EMPLOYEES</code> table still does not have any unique index specified on the logical standby database. This may cause <code class="codeph">UPDATE</code> statements to do full table scans on the logical standby database. You can remedy that by adding a unique index on the <code class="codeph">EMPNO</code> column on the logical standby database.See <a href="creating-oracle-data-guard-logical-standby.html#GUID-C238335E-8383-43F1-B5B1-709A2A619C30" title="The ROWIDs contained in the redo records generated by the primary database cannot be used to identify the corresponding row in the logical standby database.">Ensure Table Rows in the Primary Database Can Be Uniquely Identified</a> and <a href="../sqlrf/constraint.html#SQLRF52223" target="_blank"><span class="italic">Oracle Database SQL Language Reference</span></a> for more information about <code class="codeph">RELY</code> constraints.
                              </p>
                              <p>Perform the remaining steps on the logical standby database.</p>
                           </div>
                        </li>
                        <li class="stepexpand"><span>Stop SQL Apply:</span><div><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER DATABASE STOP LOGICAL STANDBY APPLY;
</pre></div>
                        </li>
                        <li class="stepexpand"><span>Disable the guard so that you can modify a maintained table on the logical standby database:</span><div><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER SESSION DISABLE GUARD;
</pre></div>
                        </li>
                        <li class="stepexpand"><span>Add a unique index on <code class="codeph">EMPNO</code> column:</span><div><pre class="oac_no_warn" dir="ltr">SQL&gt; CREATE UNIQUE INDEX UI_TEST_EMP ON HR.TEST_EMPLOYEES (EMPNO);
</pre></div>
                        </li>
                        <li class="stepexpand"><span>Enable the guard:</span><div><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER SESSION ENABLE GUARD;
</pre></div>
                        </li>
                        <li class="stepexpand"><span>Start SQL Apply:</span><div><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER DATABASE START LOGICAL STANDBY APPLY IMMEDIATE;</pre></div>
                        </li>
                     </ol>
                  </div>
               </div><a id="SBYDB4840"></a><div class="props_rev_3"><a id="GUID-4DDC26F5-29CC-435E-9996-8887DA653032" name="GUID-4DDC26F5-29CC-435E-9996-8887DA653032"></a><h4 id="SBYDB-GUID-4DDC26F5-29CC-435E-9996-8887DA653032" class="sect4"><span class="enumeration_section">11.7.2 </span>Gather Statistics for the Cost-Based Optimizer
                  </h4>
                  <div>
                     <p>Statistics should be gathered on the standby database because the cost-based optimizer (CBO) uses them to determine the optimal query execution path.</p>
                     <p>New statistics should be gathered after the data or structure of a schema object is modified in ways that make the previous statistics inaccurate. For example, after inserting or deleting a significant number of rows into a table, collect new statistics on the number of rows.</p>
                     <p>Statistics should be gathered on the standby database because DML and DDL operations on the primary database are executed as a function of the workload. While the standby database is logically equivalent to the primary database, SQL Apply might execute the workload in a different way. This is why using the STATS pack on the logical standby database and the <code class="codeph">V$SYSSTAT</code> view can be useful in determining which tables are consuming the most resources and table scans.
                     </p>
                     <div class="infoboxnotealso" id="GUID-4DDC26F5-29CC-435E-9996-8887DA653032__GUID-D9C801C3-A87B-4A80-9B27-5F2EC5C3A401">
                        <p class="notep1">See Also:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><a href="creating-oracle-data-guard-logical-standby.html#GUID-C238335E-8383-43F1-B5B1-709A2A619C30" title="The ROWIDs contained in the redo records generated by the primary database cannot be used to identify the corresponding row in the logical standby database.">Ensure Table Rows in the Primary Database Can Be Uniquely Identified</a></p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="SBYDB4841"></a><div class="props_rev_3"><a id="GUID-8EFFAC57-9E1A-419E-AEAE-E5931D2845CB" name="GUID-8EFFAC57-9E1A-419E-AEAE-E5931D2845CB"></a><h4 id="SBYDB-GUID-8EFFAC57-9E1A-419E-AEAE-E5931D2845CB" class="sect4"><span class="enumeration_section">11.7.3 </span>Adjust the Number of Processes
                  </h4>
                  <div>
                     <p>There are three parameters that can be modified to control the number of processes allocated to SQL Apply: <code class="codeph">MAX_SERVERS</code>, <code class="codeph">APPLY_SERVERS</code>, and <code class="codeph">PREPARE_SERVERS</code>.
                     </p>
                     <p>The following relationships must always hold true:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><code class="codeph">APPLY_SERVERS + P</code><code class="codeph">REPARE_SERVERS =</code> <code class="codeph">MAX_SERVERS - 3</code></p>
                           <p>This is because SQL Apply always allocates one process for the <code class="codeph">READER</code>, <code class="codeph">BUILDER</code>, and <code class="codeph">ANALYZER</code> roles.
                           </p>
                        </li>
                        <li>
                           <p>By default, <code class="codeph">MAX_SERVERS</code> is set to 9, <code class="codeph">PREPARE_SERVERS</code> is set to 1, and <code class="codeph">APPLY_SERVERS</code> is set to 5.
                           </p>
                        </li>
                        <li>
                           <p>Oracle recommends that you only change the <code class="codeph">MAX_SERVERS</code> parameter through the <code class="codeph">DBMS_LOGSTDBY.APPLY_SET</code> procedure, and allow SQL Apply to distribute the server processes appropriately between prepare and apply processes.
                           </p>
                        </li>
                        <li>
                           <p>SQL Apply uses a process allocation algorithm that allocates 1 <code class="codeph">PREPARE_SERVER</code> for every 20 server processes allocated to SQL Apply as specified by <code class="codeph">MAX_SERVER</code> and limits the number of <code class="codeph">PREPARE_SERVERS</code> to 5. Thus, if you set <code class="codeph">MAX_SERVERS</code> to any value between 1 and 20, SQL Apply allocates 1 server process to act as a <code class="codeph">PREPARER</code>, and allocates the rest of the processes as <code class="codeph">APPLIERS</code> while satisfying the relationship previously described. Similarly, if you set <code class="codeph">MAX_SERVERS</code> to a value between 21 and 40, SQL Apply allocates 2 server processes to act as <code class="codeph">PREPARERS</code> and the rest as <code class="codeph">APPLIERS</code>, while satisfying the relationship previously described. You can override this internal process allocation algorithm by setting <code class="codeph">APPLY_SERVERS</code> and <code class="codeph">PREPARE_SERVERS</code> directly, provided that the previously described relationship is satisfied.
                           </p>
                        </li>
                     </ul>
                     <p>The following sections describe:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-F105E232-364E-4F40-ADCE-E13EB3566A2E" title="Before adjusting the number of APPLIER processes, you should determine whether doing so will help you achieve greater throughput.">Adjusting the Number of APPLIER Processes</a></p>
                        </li>
                        <li>
                           <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-97300F48-66C4-4F9E-888D-DEFC0DDC10C8" title="It is rare that you will need to adjust the number of PREPARER processes. Before increasing their number, you must ensure that certain conditions are true.">Adjusting the Number of PREPARER Processes</a></p>
                        </li>
                     </ul>
                  </div><a id="SBYDB4842"></a><div class="props_rev_3"><a id="GUID-F105E232-364E-4F40-ADCE-E13EB3566A2E" name="GUID-F105E232-364E-4F40-ADCE-E13EB3566A2E"></a><h5 id="SBYDB-GUID-F105E232-364E-4F40-ADCE-E13EB3566A2E" class="sect5"><span class="enumeration_section">11.7.3.1 </span>Adjusting the Number of APPLIER Processes
                     </h5>
                     <div>
                        <p>Before adjusting the number of <code class="codeph">APPLIER</code> processes, you should determine whether doing so will help you achieve greater throughput.
                        </p>
                        <div class="section">
                           <p>To determine this, perform the following steps:</p>
                        </div>
                        <!-- class="section" -->
                        <ol>
                           <li class="stepexpand"><span>Check whether <code class="codeph">APPLIER</code> processes are busy by issuing the following query:</span><div><pre class="oac_no_warn" dir="ltr">SQL&gt; SELECT COUNT(*) AS IDLE_APPLIER -
&gt; FROM V$LOGSTDBY_PROCESS -
&gt; WHERE TYPE = 'APPLIER' and status_code = 16116;

IDLE_APPLIER
-------------------------
0
</pre></div>
                           </li>
                           <li class="stepexpand"><span>Once you are sure there are no idle <code class="codeph">APPLIER</code> processes, issue the following query to ensure there is enough work available for additional <code class="codeph">APPLIER</code> processes if you choose to adjust the number of <code class="codeph">APPLIERS</code>:</span><div><pre class="oac_no_warn" dir="ltr">SELECT NAME, VALUE FROM V$LOGSTDBY_STATS WHERE NAME = 'txns applied' OR NAME = 'distinct txns in queue';
</pre><p>These two statistics keep a cumulative total of transactions that are ready to be applied by the <code class="codeph">APPLIER</code> processes and the number of transactions that have already been applied.
                                 </p>
                                 <p>If the number (<code class="codeph">distinct txns in queue - txns applied</code>) is higher than twice the number of <code class="codeph">APPLIER</code> processes available, an improvement in throughput is possible if you increase the number of <code class="codeph">APPLIER</code> processes.
                                 </p>
                                 <div class="infoboxnote" id="GUID-F105E232-364E-4F40-ADCE-E13EB3566A2E__GUID-E26A3F6A-77FA-4CD9-BD1B-CBBCAAF487F7">
                                    <p class="notep1">Note:</p>
                                    <p>The number is a rough measure of ready work. The workload may be such that an interdependency between ready transactions prevents additional available <code class="codeph">APPLIER</code> processes from applying them. For instance, if the majority of the transactions that are ready to be applied are DDL transactions, then adding more <code class="codeph">APPLIER</code> processes does not result in a higher throughput.
                                    </p>
                                 </div>
                                 <p>Suppose you want to adjust the number of <code class="codeph">APPLIER</code> processes to 20 from the default value of 5, while keeping the number of <code class="codeph">PREPARER</code> processes to 1. Because you must satisfy the following equation:
                                 </p><pre class="oac_no_warn" dir="ltr">APPLY_SERVERS + PREPARE_SERVERS = MAX_SERVERS - 3
</pre><p>you must first set <code class="codeph">MAX_SERVERS</code> to 24. Once you have done that, you can set the number of <code class="codeph">APPLY_SERVERS</code> to 20, as follows:
                                 </p><pre class="oac_no_warn" dir="ltr">SQL&gt; EXECUTE DBMS_LOGSTDBY.APPLY_SET('MAX_SERVERS', 24);
SQL&gt; EXECUTE DBMS_LOGSTDBY.APPLY_SET('APPLY_SERVERS', 20);</pre></div>
                           </li>
                        </ol>
                     </div>
                  </div><a id="SBYDB4843"></a><div class="props_rev_3"><a id="GUID-97300F48-66C4-4F9E-888D-DEFC0DDC10C8" name="GUID-97300F48-66C4-4F9E-888D-DEFC0DDC10C8"></a><h5 id="SBYDB-GUID-97300F48-66C4-4F9E-888D-DEFC0DDC10C8" class="sect5"><span class="enumeration_section">11.7.3.2 </span>Adjusting the Number of PREPARER Processes
                     </h5>
                     <div>
                        <p>It is rare that you will need to adjust the number of <code class="codeph">PREPARER</code> processes. Before increasing their number, you must ensure that certain conditions are true.
                        </p>
                        <div class="section">
                           <p>The conditions that must be true are as follows:</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>All <code class="codeph">PREPARER</code> processes are busy
                                 </p>
                              </li>
                              <li>
                                 <p>The number of transactions ready to be applied is less than the number of <code class="codeph">APPLIER</code> processes available
                                 </p>
                              </li>
                              <li>
                                 <p>There are idle <code class="codeph">APPLIER</code> processes
                                 </p>
                              </li>
                           </ul>
                           <p>The following steps show how to determine these conditions are true:</p>
                        </div>
                        <!-- class="section" -->
                        <ol>
                           <li class="stepexpand"><span>Ensure all <code class="codeph">PREPARER</code> processes are busy<a id="d26509e5824" class="indexterm-anchor"></a>:</span><div><pre class="oac_no_warn" dir="ltr">SQL&gt; SELECT COUNT(*) AS IDLE_PREPARER -
&gt; FROM V$LOGSTDBY_PROCESS -
&gt; WHERE TYPE = 'PREPARER' and status_code = 16116;

IDLE_PREPARER
-------------
0
</pre></div>
                           </li>
                           <li class="stepexpand"><span>Ensure the number of transactions ready to be applied is less than the number of <code class="codeph">APPLIER</code> processes:</span><div><pre class="oac_no_warn" dir="ltr">SQL&gt; SELECT NAME, VALUE FROM V$LOGSTDBY_STATS WHERE NAME = 'txns applied' OR - &gt; NAME = 'distinct txns in queue';

NAME                          VALUE
---------------------         -------
txns applied                   27892
distinct txns in queue         12896
</pre><pre class="oac_no_warn" dir="ltr">SQL&gt; SELECT COUNT(*) AS APPLIER_COUNT -
&gt; FROM V$LOGSTDBY_PROCESS WHERE TYPE = 'APPLIER';

APPLIER_COUNT
-------------
20
</pre><p>Note: Issue this query several times to ensure this is not a transient event.</p>
                              </div>
                           </li>
                           <li class="stepexpand"><span>Ensure there are idle <code class="codeph">APPLIER</code> processes:</span><div><pre class="oac_no_warn" dir="ltr">SQL&gt; SELECT COUNT(*) AS IDLE_APPLIER -
&gt; FROM V$LOGSTDBY_PROCESS -
&gt; WHERE TYPE = 'APPLIER' and status_code = 16116;

IDLE_APPLIER
-------------------------
19
</pre></div>
                           </li>
                        </ol>
                        <div class="section">
                           <p>In the example, all three conditions necessary for increasing the number of <code class="codeph">PREPARER</code> processes have been satisfied. Suppose you want to keep the number of <code class="codeph">APPLIER</code> processes set to 20, and increase the number of <code class="codeph">PREPARER</code> processes from 1 to 3. Because you always have to satisfy the following equation:
                           </p><pre class="oac_no_warn" dir="ltr">APPLY_SERVERS + PREPARE_SERVERS = MAX_SERVERS - 3
</pre><p>you first need to increase the number <code class="codeph">MAX_SERVERS</code> from 24 to 26 to accommodate the increased number of preparers. You can then increase the number of <code class="codeph">PREPARER</code> processes, as follows:
                           </p><pre class="oac_no_warn" dir="ltr">SQL&gt; EXECUTE DBMS_LOGSTDBY.APPLY_SET('MAX_SERVERS', 26);
SQL&gt; EXECUTE DBMS_LOGSTDBY.APPLY_SET('PREPARE_SERVERS', 3);</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="SBYDB4844"></a><div class="props_rev_3"><a id="GUID-E856251B-C6AD-480A-9D9B-278BBF66688F" name="GUID-E856251B-C6AD-480A-9D9B-278BBF66688F"></a><h4 id="SBYDB-GUID-E856251B-C6AD-480A-9D9B-278BBF66688F" class="sect4"><span class="enumeration_section">11.7.4 </span>Adjust the Memory Used for LCR Cache
                  </h4>
                  <div>
                     <p>For some workloads, SQL Apply may use a large number of pageout operations, thereby reducing the overall throughput of the system. Increasing memory allocated to the LCR cache may help.</p>
                     <div class="section">
                        <p>To determine whether increasing memory allocated to the LCR cache would be beneficial, perform the following steps:</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>Issue the following query to obtain a snapshot of pageout activity:</span><div><pre class="oac_no_warn" dir="ltr">SQL&gt; SELECT NAME, VALUE FROM V$LOGSTDBY_STATS WHERE NAME LIKE '%page%' -
&gt; OR NAME LIKE '%uptime%' OR NAME LIKE '%idle%';
</pre><pre class="oac_no_warn" dir="ltr">NAME                             VALUE
----------------------------     --------------
coordinator uptime (seconds)             894856
bytes paged out                           20000
pageout time (seconds)                        2
system idle time (seconds)                 1000
</pre></div>
                        </li>
                        <li class="stepexpand"><span>Issue the query again in 5 minutes:</span><div><pre class="oac_no_warn" dir="ltr">SQL&gt; SELECT NAME, VALUE FROM V$LOGSTDBY_STATS WHERE NAME LIKE '%page%' -
&gt; OR NAME LIKE '%uptime%' OR NAME LIKE '%idle%';
</pre><pre class="oac_no_warn" dir="ltr">NAME                             VALUE
----------------------------     --------------
coordinator uptime (seconds)             895156
bytes paged out                         1020000
pageout time (seconds)                      100
system idle time (seconds)                 1000
</pre></div>
                        </li>
                        <li class="stepexpand"><span>Compute the normalized pageout activity. For example:</span><div><pre class="oac_no_warn" dir="ltr">Change in coordinator uptime (C)= (895156 &#x2013; 894856) = 300 secs
Amount of additional idle time (I)= (1000 &#x2013; 1000) = 0
Change in time spent in pageout (P) = (100 &#x2013; 2) = 98 secs
Pageout time in comparison to uptime = P/(C-I) = 98/300 ~ 32.67%
</pre></div>
                        </li>
                     </ol>
                     <div class="section">
                        <p>Ideally, the pageout activity should not consume more than 5 percent of the total uptime. If you continue to take snapshots over an extended interval and you find the pageout activities continue to consume a significant portion of the apply time, increasing the memory size may provide some benefits. You can increase the memory allocated to SQL Apply by setting the memory allocated to LCR cache (for this example, the SGA is set to 1 GB):</p><pre class="oac_no_warn" dir="ltr">SQL&gt; EXECUTE DBMS_LOGSTDBY.APPLY_SET('MAX_SGA', 1024);
PL/SQL procedure successfully completed</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="SBYDB4845"></a><div class="props_rev_3"><a id="GUID-486200D3-C7A5-4B21-9C81-FC654AD405DD" name="GUID-486200D3-C7A5-4B21-9C81-FC654AD405DD"></a><h4 id="SBYDB-GUID-486200D3-C7A5-4B21-9C81-FC654AD405DD" class="sect4"><span class="enumeration_section">11.7.5 </span>Adjust How Transactions are Applied On the Logical Standby Database
                  </h4>
                  <div>
                     <p>By default, transactions are applied on the logical standby database in the exact order in which they were committed on the primary database.</p>
                     <div class="section">
                        <p>The strict default order of committing transactions allows any application to run transparently on the logical standby database.</p>
                        <p>However, many applications do not require such strict ordering among all transactions. Such applications do not require transactions containing non-overlapping sets of rows to be committed in the same order that they were committed at the primary database. This less strict ordering typically results in higher apply rates at the logical standby database. You can change the default order of committing transactions by performing the following steps:</p>
                        <ol>
                           <li>
                              <p>Stop SQL Apply:</p><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER DATABASE STOP LOGICAL STANDBY APPLY;
Database altered
</pre></li>
                           <li>
                              <p>Issue the following to allow transactions to be applied out of order from how they were committed on the primary databases:</p><pre class="oac_no_warn" dir="ltr">SQL&gt; EXECUTE DBMS_LOGSTDBY.APPLY_SET('PRESERVE_COMMIT_ORDER', 'FALSE');
PL/SQL procedure successfully completed
</pre></li>
                           <li>
                              <p>Start SQL Apply:</p><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER DATABASE START LOGICAL STANDBY APPLY IMMEDIATE;
Database altered
</pre></li>
                        </ol>
                        <p>You can change back the apply mode as follows:</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>Stop SQL Apply:</span><div><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER DATABASE STOP LOGICAL STANDBY APPLY;
Database altered
</pre></div>
                        </li>
                        <li class="stepexpand"><span>Restore the default value for the <code class="codeph">PRESERVE_COMMIT_ORDER</code> parameter:</span><div><pre class="oac_no_warn" dir="ltr">SQL&gt; EXECUTE DBMS_LOGSTDBY.APPLY_UNSET('PRESERVE_COMMIT_ORDER');
PL/SQL procedure successfully completed
</pre></div>
                        </li>
                        <li class="stepexpand"><span>Start SQL Apply:</span><div><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER DATABASE START LOGICAL STANDBY APPLY IMMEDIATE;
Database altered
</pre><p>For a typical online transaction processing (OLTP) workload, the nondefault mode can provide a 50 percent or better throughput improvement over the default apply mode.</p>
                           </div>
                        </li>
                     </ol>
                  </div>
               </div>
            </div><a id="SBYDB5050"></a><a id="SBYDB5051"></a><a id="SBYDB5052"></a><a id="SBYDB5053"></a><a id="SBYDB4846"></a><div class="props_rev_3"><a id="GUID-4A691CE0-7424-4547-800E-0C9D606F0607" name="GUID-4A691CE0-7424-4547-800E-0C9D606F0607"></a><h3 id="SBYDB-GUID-4A691CE0-7424-4547-800E-0C9D606F0607" class="sect3"><span class="enumeration_section">11.8 </span>Backup and Recovery in the Context of a Logical Standby Database
               </h3>
               <div>
                  <p>You can back up your logical standby database using the traditional methods available and then recover it by restoring the database backup and performing media recovery on the archived logs, in conjunction with the backup.</p>
                  <p>The following items are relevant in the context of a logical standby database.</p>
                  <div class="section">
                     <p class="subhead2" id="GUID-4A691CE0-7424-4547-800E-0C9D606F0607__GUID-6DDCD88E-7245-4995-9DDC-DDC93FBBFA4B">Considerations When Creating and Using a Local RMAN Recovery Catalog</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p>If you plan to create the RMAN recovery catalog or perform any RMAN activity that modifies the catalog, you must be running with <code class="codeph">GUARD</code> set to <code class="codeph">STANDBY</code> at the logical standby database.
                     </p>
                     <p>You can leave <code class="codeph">GUARD</code> set to <code class="codeph">ALL</code>, if the local recovery catalog is kept only in the logical standby control file.
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-4A691CE0-7424-4547-800E-0C9D606F0607__GUID-0FBF01B3-2B27-446E-8860-C69FBE8B608B">Considerations For Control File Backup</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p>Oracle recommends that you take a control file backup immediately after instantiating a logical standby database. </p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-4A691CE0-7424-4547-800E-0C9D606F0607__GUID-99B62329-B7D2-4B0A-A1E8-95506049B107">Considerations For Point-in-Time Recovery</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p>When SQL Apply is started for the first time following point-in-time recovery, it must be able to either find the required archived logs on the local system or to fetch them from the primary database. Use the <code class="codeph">V$LOGSTDBY_PROCESS</code> view to determine if any archived logs need to be restored on the primary database.
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-4A691CE0-7424-4547-800E-0C9D606F0607__GUID-9D5B3032-D8AB-4889-BA73-B0DB1A478B95">Considerations For Tablespace Point-in-Time Recovery</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p>If you perform point-in-time recovery for a tablespace in a logical standby database, you must ensure one of the following:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>The tablespace contains no tables or partitions that are being maintained by the SQL Apply process</p>
                        </li>
                        <li>
                           <p>If the tablespace contains tables or partitions that are being maintained by the SQL Apply process, then either use the <code class="codeph">DBMS_LOGSTDBY.INSTANTIATE_TABL</code>E procedure to reinstantiate all of the maintained tables contained in the recovered tablespace at the logical standby database, or use <code class="codeph">DBMS_LOGSTDBY.SKIP</code> procedure to register all tables contained in the recovered tablespace to be skipped from the maintained table list at the logical standby database.
                           </p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
               </div>
            </div>
         </div>
      </article>
   </body>
</html>