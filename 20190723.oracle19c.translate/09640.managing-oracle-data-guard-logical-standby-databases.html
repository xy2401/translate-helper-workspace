<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <meta name="abstract" content="An understanding of these concepts will help you to successfully manage a logical standby database."></meta>
      <meta name="description" content="An understanding of these concepts will help you to successfully manage a logical standby database."></meta>
      <title>管理逻辑备用数据库</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Concepts and Administration "></meta>
      <meta property="og:description" content="An understanding of these concepts will help you to successfully manage a logical standby database."></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Concepts and Administration"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="data-guard-concepts-and-administration.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-02-12T10:50:21-08:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="1999, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96244-02"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="managing-oracle-data-guard-physical-standby-databases.html" title="Previous" type="text/html"></link>
      <link rel="next" href="using-RMAN-in-oracle-data-guard-configurations.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Data Guard Concepts and Administration"></meta>
    <meta name="dcterms.isVersionOf" content="SBYDB"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="managing-oracle-data-guard-physical-standby-databases.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="using-RMAN-in-oracle-data-guard-configurations.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">概念和管理</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="oracle-data-guard-concepts.html" property="item" typeof="WebPage"><span property="name">概念和管理</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">管理逻辑备用数据库</li>
            </ol>
            <a id="GUID-4177C717-4244-4E33-ACE7-15D53EAB2443" name="GUID-4177C717-4244-4E33-ACE7-15D53EAB2443"></a><a id="SBYDB00800"></a>
            
            <h2 id="SBYDB-GUID-4177C717-4244-4E33-ACE7-15D53EAB2443" class="sect2"><span class="enumeration_chapter">11</span>管理逻辑备用数据库</h2>
         </header>
         <div class="ind">
            <div>
               <p>了解这些概念将有助于您成功管理逻辑备用数据库。</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-735EED44-DFDB-43B8-ADBC-F1A3A62E7D93" title="SQL Apply使用一组后台进程将更改从主数据库应用于逻辑备用数据库。">SQL应用程序体系结构概述</a></p>
                  </li>
                  <li>
                     <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-572B9755-69F5-4BD7-9DFF-1F7EB1DE3771" title="SQL ALTER DATABASE GUARD语句控制用户对逻辑备用数据库中表的访问。">控制用户对逻辑备用数据库中表的访问</a></p>
                  </li>
                  <li>
                     <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-D6636F76-CD66-49A8-B052-503991190FBF" title="您可以使用性能视图来监视SQL Apply维护逻辑备用数据库的行为。">与管理和监视逻辑备用数据库相关的视图</a></p>
                  </li>
                  <li>
                     <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-B0181E97-7A79-4E92-9B84-42DF8AF24FE0" title="使用逻辑备用数据库时，可以监视SQL Apply进度，还可以自动删除日志文件。">监视逻辑备用数据库</a></p>
                  </li>
                  <li>
                     <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-88211E8E-28BF-45AC-9230-F85B606D8987" title="可以通过多种方式自定义逻辑备用数据库，包括记录事件，防止更改特定架构对象，以及添加或重新创建表。">自定义逻辑备用数据库</a></p>
                  </li>
                  <li>
                     <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-6B8A9BA8-AEF5-4F87-9B1D-67D1A32955D0" title="您可以在逻辑备用数据库的上下文中管理特定工作负载。">在逻辑备用数据库的上下文中管理特定工作负载</a></p>
                  </li>
                  <li>
                     <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-8808747E-825D-4E0C-BD26-4E18F40574F8" title="这些主题提供有关调整逻辑备用数据库的各种方法的信息。">调整逻辑备用数据库</a></p>
                  </li>
                  <li>
                     <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-4A691CE0-7424-4547-800E-0C9D606F0607" title="您可以使用可用的传统方法备份逻辑备用数据库，然后通过还原数据库备份并在归档日志上执行介质恢复以及备份来恢复它。">逻辑备用数据库环境下的备份和恢复</a></p>
                  </li>
               </ul>
            </div><a id="SBYDB5042"></a><a id="SBYDB4804"></a><div class="props_rev_3"><a id="GUID-735EED44-DFDB-43B8-ADBC-F1A3A62E7D93" name="GUID-735EED44-DFDB-43B8-ADBC-F1A3A62E7D93"></a><h3 id="SBYDB-GUID-735EED44-DFDB-43B8-ADBC-F1A3A62E7D93" class="sect3"><span class="enumeration_section">11.1</span> SQL Apply体系结构概述</h3>
               <div>
                  <p>SQL Apply使用一组后台进程将更改从主数据库应用于逻辑备用数据库。</p>
                  <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-735EED44-DFDB-43B8-ADBC-F1A3A62E7D93__I1039995">图11-1</a>显示了信息流以及每个流程执行的角色。
                  </p>
                  <div class="figure" id="GUID-735EED44-DFDB-43B8-ADBC-F1A3A62E7D93__I1039995">
                     <p class="titleinfigure">图11-1 SQL应用处理</p><img src="img/sbydb055.gif" width="615" alt="下面是图11-1的描述" title="下面是图11-1的描述" longdesc="img_text/sbydb055.html"><br><a href="img_text/sbydb055.html">“图11-1 SQL应用处理”的说明</a></div>
                  <!-- class="figure" -->
                  <p>在日志挖掘和应用处理期间涉及的不同过程及其功能如下：</p>
                  <p>在日志挖掘期间：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><code class="codeph">READER</code>进程从归档的重做日志文件或备用重做日志文件中读取重做记录。
                        </p>
                     </li>
                     <li>
                        <p><code class="codeph">PREPARER</code>进程将重做记录中包含的块更改转换为逻辑更改记录（LCR）。对于给定的重做日志文件，可以激活多个<code class="codeph">PREPARER</code>进程。LCR正在上演<a id="d26509e241" class="indexterm-anchor"></a><a id="d26509e245" class="indexterm-anchor"></a><a id="d26509e249" class="indexterm-anchor"></a>系统全局区域（SGA），称为<span class="italic">LCR缓存</span> 。
                        </p>
                     </li>
                     <li>
                        <p><code class="codeph">BUILDER</code>进程将LCR分组为事务，并执行其他任务，例如LCR缓存中的内存管理，与SQL Apply重新启动相关的检查点以及过滤掉不感兴趣的更改。
                        </p>
                     </li>
                  </ul>
                  <p>申请处理期间：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><code class="codeph">ANALYZER</code>进程识别不同事务之间的依赖关系。
                        </p>
                     </li>
                     <li>
                        <p><code class="codeph">COORDINATOR</code>过程<a id="d26509e278" class="indexterm-anchor"></a><a id="d26509e282" class="indexterm-anchor"></a><a id="d26509e286" class="indexterm-anchor"></a><a id="d26509e290" class="indexterm-anchor"></a> （LSP）将事务分配给不同的应用程序并在它们之间进行协调，以确保事务之间的依赖关系得到遵守。
                        </p>
                     </li>
                     <li>
                        <p><code class="codeph">APPLIER</code>进程在协调进程的监督下将事务应用于逻辑备用数据库。
                        </p>
                     </li>
                  </ul>
                  <p>您可以查询<code class="codeph">V$LOGSTDBY_PROCESS</code>视图以检查SQL Apply进程的活动。另一个提供有关当前活动信息的视图是<code class="codeph">V$LOGSTDBY_STATS</code>视图，该视图在SQL Apply活动期间显示逻辑备用数据库的统计信息，当前状态和状态信息。在<a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-D6636F76-CD66-49A8-B052-503991190FBF" title="您可以使用性能视图来监视SQL Apply维护逻辑备用数据库的行为。">与管理和监视逻辑备用数据库</a>相关的视图中更详细地讨论了这些和其他相关视图。
                  </p>
                  <div class="infoboxnote" id="GUID-735EED44-DFDB-43B8-ADBC-F1A3A62E7D93__GUID-80960FAF-B556-4C59-A028-32D125305B5B">
                     <p class="notep1">注意：</p>
                     <p>所有SQL Apply进程（包括协调程序进程<code class="codeph">lsp0</code> ）都是真正的后台进程。它们不受资源管理者的监管。因此，在逻辑备用数据库中创建资源组不会影响SQL Apply进程。
                     </p>
                  </div>
               </div><a id="SBYDB4805"></a><div class="props_rev_3"><a id="GUID-81ABDF55-F808-4E41-ACBF-694DBE40E68C" name="GUID-81ABDF55-F808-4E41-ACBF-694DBE40E68C"></a><h4 id="SBYDB-GUID-81ABDF55-F808-4E41-ACBF-694DBE40E68C" class="sect4"><span class="enumeration_section">11.1.1</span> SQL Apply的各种注意事项</h4>
                  <div>
                     <p>了解有关事务大小，页面调整，重新启动，DML应用和密码验证的这些概念将帮助您最大限度地管理逻辑备用数据库。</p>
                     <p>请参阅以下内容：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-344AF03D-88A6-4DE1-8650-D5F1B9781FC3" title="SQL Apply将事务分为两类：小型和大型。">交易规模考虑因素</a></p>
                        </li>
                        <li>
                           <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-E3ADF4B7-F08A-4F2B-A1CD-FB897ECCF534" title="当LCR缓存中的内存耗尽并且需要为SQL Apply释放空间以进行进度时，页面超出发生在SQL Apply的上下文中。">Pageout注意事项</a></p>
                        </li>
                        <li>
                           <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-F0FDEEF3-B4EA-40F3-BF7B-2167D33D91C8" title="在从重做日志文件挖掘并应用于逻辑备用数据库的事务的提交记录之前，对逻辑备用数据库所做的修改不会持久。">重启注意事项</a></p>
                        </li>
                        <li>
                           <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-97797605-D5BB-49B7-8E9D-D3E7C56A767C">DML应用注意事项</a></p>
                        </li>
                        <li>
                           <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-1BBCF0C2-E189-47EF-B7D1-805BF552E4DB">DDL应用注意事项</a></p>
                        </li>
                        <li>
                           <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-1F7593FA-8EDD-4DF2-8CE0-1EDCDAA81402" title="必须在SYS模式中创建用于检查密码复杂性的密码验证功能。">密码验证功能</a></p>
                        </li>
                     </ul>
                  </div><a id="SBYDB4806"></a><div class="props_rev_3"><a id="GUID-344AF03D-88A6-4DE1-8650-D5F1B9781FC3" name="GUID-344AF03D-88A6-4DE1-8650-D5F1B9781FC3"></a><h5 id="SBYDB-GUID-344AF03D-88A6-4DE1-8650-D5F1B9781FC3" class="sect5"><span class="enumeration_section">11.1.1.1</span>交易规模考虑因素</h5>
                     <div>
                        <p>SQL Apply将事务分为两类：小型和大型。</p>
                        <p>每个类的定义如下：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>小事务 - 一旦在重做日志文件中遇到事务的提交记录，SQL Apply就会开始应用属于小事务的LCR。</p>
                           </li>
                           <li>
                              <p>大型事务-SQL Apply将大型事务分解为称为<span class="italic">事务块的</span>较小部分，并在重做日志文件中看到大事务的提交记录之前开始应用块。这样做是为了减少LCR缓存上的内存压力并减少整体故障转移时间。
                              </p>
                              <p>例如，在没有分成小块的情况下，SQL * Loader加载1000万行（每个100字节大小）将在LCR缓存中使用超过1 GB的内存。如果分配给LCR缓存的内存小于1 GB，则会导致LCR缓存中的页面输出。</p>
                              <p>除了内存考虑因素，如果SQL Apply没有开始应用与千万行SQL * Loader加载相关的更改，直到它遇到事务的<code class="codeph">COMMIT</code>记录，它可能会停止角色转换。在SQL Apply在逻辑备用数据库上应用事务之前，在事务提交之后启动的切换或故障转移无法完成。
                              </p>
                              <p>尽管使用了事务块，但在处理修改超过800万行的事务时，SQL Apply性能可能会降低。对于大于800万行的事务，SQL Apply使用临时段来暂存处理事务所需的一些内部元数据。确保在临时段中为SQL Apply分配足够的空间，以成功处理大于800万行的事务。</p>
                           </li>
                        </ul>
                        <p>所有交易都开始归类为小型交易。根据可用于LCR高速缓存的内存量以及属于事务的LCR消耗的内存量，SQL Apply确定何时将事务重新分类为大事务。</p>
                     </div>
                  </div><a id="SBYDB4807"></a><div class="props_rev_3"><a id="GUID-E3ADF4B7-F08A-4F2B-A1CD-FB897ECCF534" name="GUID-E3ADF4B7-F08A-4F2B-A1CD-FB897ECCF534"></a><h5 id="SBYDB-GUID-E3ADF4B7-F08A-4F2B-A1CD-FB897ECCF534" class="sect5"><span class="enumeration_section">11.1.1.2</span>寻呼注意事项</h5>
                     <div>
                        <p>当LCR缓存中的内存耗尽并且需要为SQL Apply释放空间以进行进度时，页面超出发生在SQL Apply的上下文中。</p>
                        <p>例如，假设分配给LCR高速缓存的内存为100 MB，并且SQL Apply遇到<code class="codeph">INSERT</code>事务到具有大小为300 MB的<code class="codeph">LONG</code>列的表。在这种情况下，日志挖掘组件将<code class="codeph">LONG</code>数据的第一部分分页，以读取列修改的后半部分。在经过良好调整的逻辑备用数据库中，页面调度活动偶尔会发生，不应影响系统的整体吞吐量。
                        </p>
                        <div class="infoboxnotealso" id="GUID-E3ADF4B7-F08A-4F2B-A1CD-FB897ECCF534__GUID-57EEDF29-F86F-4BB0-90EF-4B30CAC038A1">
                           <p class="notep1">也可以看看：</p>
                           <p>有关如何识别有问题的页面输出和执行更正操作的详细信息，请参阅<a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-88211E8E-28BF-45AC-9230-F85B606D8987" title="可以通过多种方式自定义逻辑备用数据库，包括记录事件，防止更改特定架构对象，以及添加或重新创建表。">自定义逻辑备用数据库</a></p>
                        </div>
                     </div>
                  </div><a id="SBYDB4808"></a><div class="props_rev_3"><a id="GUID-F0FDEEF3-B4EA-40F3-BF7B-2167D33D91C8" name="GUID-F0FDEEF3-B4EA-40F3-BF7B-2167D33D91C8"></a><h5 id="SBYDB-GUID-F0FDEEF3-B4EA-40F3-BF7B-2167D33D91C8" class="sect5"><span class="enumeration_section">11.1.1.3</span>重启注意事项</h5>
                     <div>
                        <p>在从重做日志文件挖掘并应用于逻辑备用数据库的事务的提交记录之前，对逻辑备用数据库所做的修改不会持久。</p>
                        <p>因此，每次SQL Apply停止时，无论是由于用户指令还是由于系统故障，SQL Apply都必须返回并再次挖掘最早的未提交事务。</p>
                        <p>如果事务很少工作但长时间保持打开状态，从一开始就重新启动SQL Apply可能会非常昂贵，因为SQL Apply必须再次挖掘大量的归档重做日志文件，只是为了阅读重做一些未提交的交易的数据。为了缓解这种情况，SQL Apply定期检查旧的未提交数据。获取检查点的SCN反映在<code class="codeph">RESTART_SCN</code>列中<a id="d26509e758" class="indexterm-anchor"></a><a id="d26509e762" class="indexterm-anchor"></a> <code class="codeph">V$LOGSTDBY_PROGRESS</code>视图。重新启动后，SQL Apply将开始挖掘在SCN大于<code class="codeph">RESTART_SCN</code>列所示值的情况下生成的重做记录。SQL Apply会自动删除重新启动时不需要的存档重做日志文件。
                        </p>
                        <p>某些工作负载，例如大型DDL事务，并行DML语句（PDML） <a id="d26509e774" class="indexterm-anchor"></a><a id="d26509e778" class="indexterm-anchor"></a>和直接路径加载，防止<code class="codeph">RESTART_SCN</code>在工作负载期间前进。
                        </p>
                     </div>
                  </div><a id="SBYDB4809"></a><div class="props_rev_3"><a id="GUID-97797605-D5BB-49B7-8E9D-D3E7C56A767C" name="GUID-97797605-D5BB-49B7-8E9D-D3E7C56A767C"></a><h5 id="SBYDB-GUID-97797605-D5BB-49B7-8E9D-D3E7C56A767C" class="sect5"><span class="enumeration_section">11.1.1.4</span> DML应用注意事项</h5>
                     <div>
                        <p>应用影响的DML事务时，SQL Apply具有以下特征<a id="d26509e868" class="indexterm-anchor"></a><a id="d26509e872" class="indexterm-anchor"></a><a id="d26509e876" class="indexterm-anchor"></a>逻辑备用数据库上的吞吐量和延迟：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>批量更新<a id="d26509e885" class="indexterm-anchor"></a><a id="d26509e889" class="indexterm-anchor"></a>或删除在主数据库上执行的操作，其中单个语句导致多行被修改，作为逻辑备用数据库上的单独行修改应用。因此，每个维护的表必须具有唯一性<a id="d26509e894" class="indexterm-anchor"></a><a id="d26509e898" class="indexterm-anchor"></a><a id="d26509e902" class="indexterm-anchor"></a>索引或主键。有关详细信息，请参阅<a href="creating-oracle-data-guard-logical-standby.html#GUID-C238335E-8383-43F1-B5B1-709A2A619C30" title="主数据库生成的重做记录中包含的ROWID不能用于标识逻辑备用数据库中的相应行。">确保可以唯一标识主数据库中的表行</a> 。
                              </p>
                           </li>
                           <li>
                              <p><a id="d26509e916" class="indexterm-anchor"></a>使用逻辑备用数据库上的常规<code class="codeph">INSERT</code>语句应用在主数据库上执行的直接路径插入。
                              </p>
                           </li>
                           <li>
                              <p><a id="d26509e926" class="indexterm-anchor"></a><a id="d26509e930" class="indexterm-anchor"></a>并行DML（PDML）事务不在逻辑备用数据库上并行执行。
                              </p>
                           </li>
                        </ul>
                     </div>
                  </div><a id="SBYDB4810"></a><div class="props_rev_3"><a id="GUID-1BBCF0C2-E189-47EF-B7D1-805BF552E4DB" name="GUID-1BBCF0C2-E189-47EF-B7D1-805BF552E4DB"></a><h5 id="SBYDB-GUID-1BBCF0C2-E189-47EF-B7D1-805BF552E4DB" class="sect5"><span class="enumeration_section">11.1.1.5</span> DDL应用注意事项</h5>
                     <div>
                        <p>应用影响逻辑备用数据库上的through和延迟的DDL事务时，SQL Apply具有以下特征：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a id="d26509e1035" class="indexterm-anchor"></a><a id="d26509e1039" class="indexterm-anchor"></a> DDL事务在逻辑备用数据库上串行应用。因此，在主数据库上并发应用的DDL事务在逻辑备用数据库上一次应用一个。
                              </p>
                           </li>
                           <li>
                              <p><a id="d26509e1046" class="indexterm-anchor"></a><a id="d26509e1050" class="indexterm-anchor"></a> <code class="codeph">CREATE TABLE AS SELECT</code> （CTAS）语句，以便在逻辑备用数据库上抑制DML活动（属于CTAS语句的一部分）。作为CTAS语句的一部分插入新创建的表中的行是从重做日志文件中挖掘出来的，并使用<code class="codeph">INSERT</code>语句应用于逻辑备用数据库。
                              </p>
                           </li>
                           <li>
                              <p>SQL Apply重新发出在主数据库中执行的DDL，并确保在逻辑备用数据库中不复制作为DDL操作目标的同一对象上的同一事务中发生的DML。因此，以下两种情况会导致主站点和备用站点相互分离：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>DDL包含从主数据库中的状态派生的非文字值。这种DDL的一个例子是：</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE hr.employees ADD（start_date date default sysdate）;</pre><p>因为SQL Apply在逻辑备用数据库上重新发出相同的DDL，所以在逻辑备用数据库中重新评估函数<code class="codeph">sysdate()</code> 。因此，使用与主数据库不同的默认值创建列<code class="codeph">start_date</code> 。
                                    </p>
                                 </li>
                                 <li>
                                    <p>DDL触发目标表上定义的DML触发器。由于触发的DML发生在与DDL相同的事务中，并且在作为DDL目标的表上运行，因此不会在逻辑备用数据库中复制这些触发的DML。</p>
                                    <p>例如，假设您创建一个表，如下所示：</p><pre class="oac_no_warn" dir="ltr">create table HR.TEMP_EMPLOYEES（emp_id number primary key，first_name varchar2（64），last_name varchar2（64），modify_date timestamp）;</pre><p>假设您然后在表上创建一个触发器，这样<code class="codeph">modify_date</code>更新表时， <code class="codeph">modify_date</code>都会更新以反映更改的时间：</p><pre class="oac_no_warn" dir="ltr">在更新HR.TEST_EMPLOYEES之前创建或替换TRIGGER TRG_TEST_MOD_DT将每个行的NEW_ROW引用为新行开始：NEW_ROW.MODIFY_DATE：= SYSTIMESTAMP;结束; /</pre><p>在通常的DML / DDL工作负载下正确维护此表。但是，如果向表中添加具有默认值的列，则<code class="codeph">ADD COLUMN</code> DDL将触发此更新触发器，并将表中所有行的<code class="codeph">MODIFY_DATE</code>列更改为新的时间戳。对<code class="codeph">MODIFY_DATE</code>列的这些更改不会在逻辑备用数据库中复制。对表的后续DML将停止SQL Apply，因为重做流中记录的<code class="codeph">MODIFY_DATE</code>列数据与逻辑备用数据库中存在的数据不匹配。
                                    </p>
                                 </li>
                              </ul>
                           </li>
                        </ul>
                     </div>
                  </div><a id="SBYDB4811"></a><div class="props_rev_3"><a id="GUID-1F7593FA-8EDD-4DF2-8CE0-1EDCDAA81402" name="GUID-1F7593FA-8EDD-4DF2-8CE0-1EDCDAA81402"></a><h5 id="SBYDB-GUID-1F7593FA-8EDD-4DF2-8CE0-1EDCDAA81402" class="sect5"><span class="enumeration_section">11.1.1.6</span>密码验证功能</h5>
                     <div>
                        <p>必须在<code class="codeph">SYS</code>模式中创建用于检查密码复杂性的密码验证功能。
                        </p>
                        <p>由于SQL Apply不复制在<code class="codeph">SYS</code>模式中创建的对象，因此此类验证功能不会复制到逻辑备用数据库。您必须在逻辑备用数据库中手动创建密码验证功能，并将其与相应的配置文件相关联。
                        </p>
                     </div>
                  </div>
               </div>
            </div><a id="SBYDB4812"></a><div class="props_rev_3"><a id="GUID-572B9755-69F5-4BD7-9DFF-1F7EB1DE3771" name="GUID-572B9755-69F5-4BD7-9DFF-1F7EB1DE3771"></a><h3 id="SBYDB-GUID-572B9755-69F5-4BD7-9DFF-1F7EB1DE3771" class="sect3"><span class="enumeration_section">11.2</span>控制用户对逻辑备用数据库中表的访问</h3>
               <div>
                  <p>SQL <code class="codeph">ALTER DATABASE GUARD</code>语句控制用户对逻辑备用数据库中表的访问。
                  </p>
                  <div class="section">
                     <p>默认情况下，逻辑备用数据库上的数据库防护设置为<code class="codeph">ALL</code> 。
                     </p>
                     <p><code class="codeph">ALTER DATABASE GUARD</code>语句允许以下关键字：</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">所有</code></p>
                           <p>指定<code class="codeph">ALL</code>以防止除<code class="codeph">SYS</code>之外的所有用户更改逻辑备用数据库中的任何数据。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">支持</code></p>
                           <p>指定<code class="codeph">STANDBY</code>以防止除<code class="codeph">SYS</code>之外的所有用户对通过SQL Apply维护的任何表或序列进行DML和DDL更改。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">没有</code></p>
                           <p>指定<code class="codeph">NONE</code>以对数据库中的所有数据使用典型安全性。
                           </p>
                        </li>
                     </ul>
                     <p>例如，使用以下语句使用户能够修改不由SQL Apply维护的表：</p><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER DATABASE GUARD STANDBY;</pre><p>特权用户可以分别使用<code class="codeph">ALTER SESSION DISABLE GUARD</code>和<code class="codeph">ALTER SESSION ENABLE GUARD</code>语句暂时关闭和打开当前会话的数据库保护。此语句替换在Oracle9i中执行相同功能的<code class="codeph">DBMS_LOGSTDBY.GUARD_BYPASS</code> PL / SQL过程。如果要暂时禁用数据库防护以对数据库进行更改，则<code class="codeph">ALTER SESSION [ENABLE|DISABLE] GUARD</code>语句非常有用，如<a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-43971CB9-3337-4575-B4EF-D591878982F1" title="即使在应用SQL语句时，逻辑备用数据库也可用于报告活动。">修改逻辑备用数据库中所述</a> 。
                     </p>
                     <div class="infoboxnote" id="GUID-572B9755-69F5-4BD7-9DFF-1F7EB1DE3771__GUID-4C32DDF1-5425-4CF7-9514-925B96119B02">
                        <p class="notep1">注意：</p>
                        <p>禁用数据库防护时，不要让主数据库和逻辑备用数据库发生分歧。</p>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div>
            </div><a id="SBYDB4813"></a><div class="props_rev_3"><a id="GUID-D6636F76-CD66-49A8-B052-503991190FBF" name="GUID-D6636F76-CD66-49A8-B052-503991190FBF"></a><h3 id="SBYDB-GUID-D6636F76-CD66-49A8-B052-503991190FBF" class="sect3"><span class="enumeration_section">11.3</span>与管理和监视逻辑备用数据库相关的视图</h3>
               <div>
                  <p>您可以使用性能视图来监视SQL Apply维护逻辑备用数据库的行为。</p>
                  <p>以下主题描述了可用于监视逻辑备用数据库的关键视图：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-BEF12BA7-9397-4156-9ED3-BAC7935D7D96" title="DBA_LOGSTDBY_EVENTS视图记录在SQL Apply操作期间发生的有趣事件。">DBA_LOGSTDBY_EVENTS查看</a></p>
                     </li>
                     <li>
                        <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-646D305C-21C3-4590-8A6B-B2D02F90E8F2" title="DBA_LOGSTDBY_LOG视图提供有关SQL Apply正在处理的归档日志的动态信息。">DBA_LOGSTDBY_LOG查看</a></p>
                     </li>
                     <li>
                        <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-76033857-52EC-41B2-B130-CC9083F3FA99">V $ DATAGUARD_STATS查看</a></p>
                     </li>
                     <li>
                        <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-7E8E779A-E0EC-4C9D-8B77-1E80A60C077D">V $ LOGSTDBY_PROCESS查看</a></p>
                     </li>
                     <li>
                        <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-DAF00126-1FDA-4980-AD24-1360472ADB49">V $ LOGSTDBY_PROGRESS查看</a></p>
                     </li>
                     <li>
                        <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-9E8AFFE3-E4C2-46EB-A733-B48793DB4F1F">V $ LOGSTDBY_STATE查看</a></p>
                     </li>
                     <li>
                        <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-C72DA5B7-7FDD-46C8-9242-CD7D88DCDDB7">V $ LOGSTDBY_STATS查看</a></p>
                     </li>
                  </ul>
                  <div class="infoboxnotealso" id="GUID-D6636F76-CD66-49A8-B052-503991190FBF__GUID-74814E29-064B-4083-8C3C-89EC7A8574AE">
                     <p class="notep1">也可以看看：</p>
                     <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sbydb&amp;id=REFRN002" target="_blank">Oracle数据库参考</a>有关视图的完整参考信息</p>
                  </div>
               </div><a id="SBYDB4814"></a><div class="props_rev_3"><a id="GUID-BEF12BA7-9397-4156-9ED3-BAC7935D7D96" name="GUID-BEF12BA7-9397-4156-9ED3-BAC7935D7D96"></a><h4 id="SBYDB-GUID-BEF12BA7-9397-4156-9ED3-BAC7935D7D96" class="sect4"><span class="enumeration_section">11.3.1</span> DBA_LOGSTDBY_EVENTS视图</h4>
                  <div>
                     <p><code class="codeph">DBA_LOGSTDBY_EVENTS</code>视图记录在SQL Apply操作期间发生的有趣事件。
                     </p>
                     <div class="section">
                        <p>默认情况下，视图记录最近的10,000个事件。但是，您可以通过调用<code class="codeph">DBMS_LOGSTDBY.APPLY_SET()</code> PL / SQL过程来更改记录事件的数量。如果SQL Apply意外停止，则问题的原因也会记录在此视图中。
                        </p>
                        <div class="infoboxnote" id="GUID-BEF12BA7-9397-4156-9ED3-BAC7935D7D96__GUID-C576E399-F655-419E-BEB6-A3D56BAA3546">
                           <p class="notep1">注意：</p>
                           <p>导致SQL Apply停止的错误记录在事件表中。这些事件也被放入<code class="codeph">ALERT.LOG</code>文件中，文本中包含<code class="codeph">LOGSTDBY</code>关键字。查询视图时，按<code class="codeph">EVENT_TIME_STAMP</code> ， <code class="codeph">COMMIT_SCN</code>和<code class="codeph">CURRENT_SCN</code>顺序选择列，以确保所需的事件顺序。
                           </p>
                        </div>
                        <p>可以自定义视图以包含其他信息，例如应用了哪些DDL事务以及哪些事务已被跳过。例如：</p><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER SESSION SET NLS_DATE_FORMAT ='DD-MON-YY HH24：MI：SS';会话改变了。SQL&gt; COLUMN STATUS FORMAT A60 SQL&gt; SELECT EVENT_TIME，STATUS，EVENT FROM DBA_LOGSTDBY_EVENTS  - &gt; ORDER BY EVENT_TIMESTAMP，COMMIT_SCN，CURRENT_SCN; EVENT_TIME STATUS ------------------------------------------------ ------------------------------ EVENT ------------------- -------------------------------------------------- ---------- 23-JUL-02 18:20:12 ORA-16111：日志挖掘和应用设置23-JUL-02 18:25:12 ORA-16128：用户启动关闭成功完成23-JUL-02 18:27:12 ORA-16112：日志挖掘并应用停止23-JUL-02 18:55:12 ORA-16128：用户启动关闭成功完成23-JUL-02 18:57:09 ORA -16111：日志挖掘和应用设置23-JUL-02 20:21:47 ORA-16204：DDL成功应用create table hr.test_emp（empno number，ename varchar2（64））23-JUL-02 20:22： 55 ORA-16205：由于跳过设置而跳过DDL创建数据库链接link_to_boston连接到由change_on_inst标识的系统选择7行。
</pre><p>此查询显示SQL Apply已启动和停止几次。它还显示了应用和跳过的DDL。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="SBYDB4815"></a><div class="props_rev_3"><a id="GUID-646D305C-21C3-4590-8A6B-B2D02F90E8F2" name="GUID-646D305C-21C3-4590-8A6B-B2D02F90E8F2"></a><h4 id="SBYDB-GUID-646D305C-21C3-4590-8A6B-B2D02F90E8F2" class="sect4"><span class="enumeration_section">11.3.2</span> DBA_LOGSTDBY_LOG视图</h4>
                  <div>
                     <p><code class="codeph">DBA_LOGSTDBY_LOG</code>视图提供有关SQL Apply正在处理的归档日志的动态信息。
                     </p>
                     <div class="section">
                        <p>例如：</p><pre class="oac_no_warn" dir="ltr">SQL&gt; COLUMN DICT_BEGIN格式A10; SQL&gt; SET NUMF 99999999; SQL&gt; SELECT FILE_NAME，SEQUENCE＃AS SEQ＃，FIRST_CHANGE＃AS F_SCN＃， - &gt; NEXT_CHANGE＃AS N_SCN＃，TIMESTAMP， - &gt; DICT_BEGIN AS BEG，DICT_END为结束， - &gt; THREAD＃AS THR＃，应用于DBA_LOGSTDBY_LOG  - &gt;按顺序排序＃; FILE_NAME SEQ＃F_SCN N_SCN TIMESTAM BEG END THR＃APPLIED ------------------------- ---- ------- --- ---- -------- --- --- --- --------- / oracle / dbs / hq_nyc_2.log 2 101579 101588 11:02:58 NO NO 1 YES /oracle/dbs/hq_nyc_3.log 3 101588 142065 11:02:02 NO NO 1是/oracle/dbs/hq_nyc_4.log 4 142065 142307 11:02:10 NO NO 1是/oracle/dbs/hq_nyc_5.log 5 142307 142739 11:02:48是是1是/oracle/dbs/hq_nyc_6.log 6 142739 143973 12:02:10否否1是/oracle/dbs/hq_nyc_7.log 7 143973 144042 01:02:11否是1是/oracle/dbs/hq_nyc_8.log 8 144042 144051 01:02:01 NO NO 1是/oracle/dbs/hq_nyc_9.log 9 144051 144054 01:02:16 NO NO 1是/oracle/dbs/hq_nyc_10.log 10 144054 144057 01:02:21 NO NO 1是/oracle/dbs/hq_nyc_11.log 11 144057 144060 01:02:26 NO NO 1 CURRENT /oracle/dbs/hq_nyc_12.log 12 144060 144089 01:02:30 NO NO 1 CURRENT /oracle/dbs/hq_nyc_13.log 13 144089 144147 01:02:41 NO NO NO NO</pre><p><code class="codeph">BEG</code>和<code class="codeph">END</code>列中的<code class="codeph">YES</code>条目表示LogMiner字典构建从日志文件序列号5开始。最新的归档重做日志文件是序列号13，它是在01:02:41在逻辑备用数据库中接收的。<code class="codeph">APPLIED</code>列表示SQL Apply已在SCN 144057之前应用了所有重做。由于事务可以跨多个归档日志文件，因此多个归档日志文件可能会在<code class="codeph">APPLIED</code>列中显示值<code class="codeph">CURRENT</code> 。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="SBYDB4816"></a><div class="props_rev_3"><a id="GUID-76033857-52EC-41B2-B130-CC9083F3FA99" name="GUID-76033857-52EC-41B2-B130-CC9083F3FA99"></a><h4 id="SBYDB-GUID-76033857-52EC-41B2-B130-CC9083F3FA99" class="sect4"><span class="enumeration_section">11.3.3</span> V $ DATAGUARD_STATS查看</h4>
                  <div>
                     <div class="section">
                        <p>此视图提供与逻辑备用数据库的故障转移特征相关的信息，包括：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p>故障转移的时间（ <code class="codeph">apply finish time</code> ）</p>
                           </li>
                           <li>
                              <p>逻辑备用数据库中的已提交数据的当前时间（ <code class="codeph">apply lag</code> ）</p>
                           </li>
                           <li>
                              <p>灾难发生时潜在的数据丢失（ <code class="codeph">transport lag</code> ）。
                              </p>
                           </li>
                        </ul>
                        <p>例如：</p><pre class="oac_no_warn" dir="ltr">SQL&gt; COL NAME FORMAT A20 SQL&gt; COL VALUE FORMAT A12 SQL&gt; COL UNIT FORMAT A30 SQL&gt; SELECT NAME，VALUE，UNIT FROM V $ DATAGUARD_STATS; NAME VALUE UNIT -------------------- ------------ --------------- ---------------申请结束时间+00 00:00:00 day（2）to second（1）interval apply application +00 00:00:00 day（2）to second （0）间隔传输滞后+00 00:00:00天（2）到第二（0）间隔</pre><p>此输出来自逻辑备用数据库，该数据库已接收并应用从主数据库生成的所有重做。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="SBYDB4817"></a><div class="props_rev_3"><a id="GUID-7E8E779A-E0EC-4C9D-8B77-1E80A60C077D" name="GUID-7E8E779A-E0EC-4C9D-8B77-1E80A60C077D"></a><h4 id="SBYDB-GUID-7E8E779A-E0EC-4C9D-8B77-1E80A60C077D" class="sect4"><span class="enumeration_section">11.3.4</span> V $ LOGSTDBY_PROCESS视图</h4>
                  <div>
                     <div class="section">
                        <p>此视图提供有关SQL Apply涉及的各种进程的当前状态的信息，包括：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p>识别信息（ <code class="codeph">sid</code> | <code class="codeph">serial#</code> | <code class="codeph">spid</code> ）</p>
                           </li>
                           <li>
                              <p>SQL应用程序： <code class="codeph">COORDINATOR</code> ， <code class="codeph">READER</code> ， <code class="codeph">BUILDER</code> ， <code class="codeph">PREPARER</code> ， <code class="codeph">ANALYZER</code>或<code class="codeph">APPLIER</code> （ <code class="codeph">type</code> ）</p>
                           </li>
                           <li>
                              <p>流程当前活动的<code class="codeph">status</code> （ <code class="codeph">status_code</code> | <code class="codeph">status</code> ）</p>
                           </li>
                           <li>
                              <p>此过程处理的最高重做记录（ <code class="codeph">high_scn</code> ）</p>
                           </li>
                        </ul>
                        <p>例如：</p><pre class="oac_no_warn" dir="ltr">SQL&gt; COLUMN SERIAL #FORMAT 9999 SQL&gt; COLUMN SID FORMAT 9999 SQL&gt; SELECT SID，SERIAL＃，SPID，TYPE，HIGH_SCN FROM V $ LOGSTDBY_PROCESS; SID SERIAL #SPID TYPE HIGH_SCN ----- ------- ----------- ---------------- ----- ----- 48 6 11074 COORDINATOR 7178242899 56 56 10858 READER 7178243497 46 1 10860 BUILDER 7178242901 45 1 10862 PREPARER 7178243295 37 1 10864 ANALYZER 7178242900 36 1 10866 APPLIER 7178239467 35 3 10868 APPLIER 7178239463 34 7 10870 APPLIER 7178239461 33 1 10872 APPLIER 7178239472选择了9行。
</pre><p><code class="codeph">HIGH_SCN</code>列显示读取器进程<code class="codeph">HIGH_SCN</code>于所有其他进程，而<code class="codeph">PREPARER</code>和<code class="codeph">BUILDER</code>进程<code class="codeph">PREPARER</code>于其他进程。</p><pre class="oac_no_warn" dir="ltr">SQL&gt; COLUMN STATUS FORMAT A40 SQL&gt; SELECT TYPE，STATUS_CODE，STATUS FROM V $ LOGSTDBY_PROCESS <a id="d26509e1963" class="indexterm-anchor"></a> ; TYPE STATUS_CODE STATUS ---------------- ----------- -------------------- --------------------- COORDINATOR 16117 ORA-16117：处理读者16127 ORA-16127：停止等待应用其他交易BUILDER 16116 ORA-16116：没有工作可用PREPARER 16116 ORA-16117：处理ANALYZER 16120 ORA-16120：为SCN上的事务计算依赖关系0x0001.abdb440a APPLIER 16124 ORA-16124：事务1 13 1427正在等待另一个事务APPLIER 16121 ORA-16121：使用提交SCN应用事务0x0001.abdb4390 APPLIER 16123 ORA-16123：事务1 23 1231正在等待提交批准APPLIER 16116 ORA-16116：没有可用的工作</pre><p>输出显示正在运行的SQL Apply的快照。在挖掘方面， <code class="codeph">READER</code>进程在可以读取更多内容之前等待额外的内存可用， <code class="codeph">PREPARER</code>进程正在处理重做记录，而<code class="codeph">BUILDER</code>进程没有可用的工作。在应用方面， <code class="codeph">COORDINATOR</code>正在为<code class="codeph">APPLIER</code>进程分配更多事务， <code class="codeph">ANALYZER</code>在SCN 7178241034处计算依赖性，一个<code class="codeph">APPLIER</code>没有可用的工作，而两个具有尚未满足的未完成依赖性。
                        </p>
                        <div class="infoboxnotealso" id="GUID-7E8E779A-E0EC-4C9D-8B77-1E80A60C077D__GUID-4A8978F2-5224-4AC8-9A29-121AB654019B">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-5BD79860-B3B8-4E0D-9F55-2E9918B93292" title="SQL Apply可以处于以下六种状态中的任何一种：初始化SQL Apply，等待字典日志，加载LogMiner字典，应用（重做数据），等待存档间隙得到解决，以及空闲。">监视SQL Apply Progress</a>以获取示例输出</p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="SBYDB4818"></a><div class="props_rev_3"><a id="GUID-DAF00126-1FDA-4980-AD24-1360472ADB49" name="GUID-DAF00126-1FDA-4980-AD24-1360472ADB49"></a><h4 id="SBYDB-GUID-DAF00126-1FDA-4980-AD24-1360472ADB49" class="sect4"><span class="enumeration_section">11.3.5</span> V $ LOGSTDBY_PROGRESS视图</h4>
                  <div>
                     <div class="section">
                        <p>此视图提供有关SQL Apply所取得进展的详细信息，包括：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p>SCN和已在主数据库上提交的所有事务已应用于逻辑备用数据库的时间（ <code class="codeph">applied_scn</code> ， <code class="codeph">applied_time</code> ）</p>
                           </li>
                           <li>
                              <p>SCN和SQL Apply在重新启动时开始读取重做记录（ <code class="codeph">restart_scn</code> ， <code class="codeph">restart_time</code> ）的时间</p>
                           </li>
                           <li>
                              <p>在逻辑备用数据库上收到的最新重做记录的SCN和时间（ <code class="codeph">latest_scn</code> ， <code class="codeph">latest_time</code> ）</p>
                           </li>
                           <li>
                              <p>SCN和<code class="codeph">BUILDER</code>流程处理的最新记录的时间（ <code class="codeph">mining_scn</code> ， <code class="codeph">mining_time</code> ）</p>
                           </li>
                        </ul>
                        <p>例如：</p><pre class="oac_no_warn" dir="ltr">SQL&gt; SELECT APPLIED_SCN，LATEST_SCN，MINING_SCN，RESTART_SCN  - &gt; FROM V $ LOGSTDBY_PROGRESS; APPLIED_SCN LATEST_SCN MINING_SCN RESTART_SCN ----------- ----------- ---------- ----------- 7178240496 7178240507 7178240507 7178219805</pre><p>根据输出：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>SQL Apply已应用在SCN 7178240496之前或之前提交的所有事务</p>
                           </li>
                           <li>
                              <p>在逻辑备用数据库收到的最新重做记录在SCN 7178240507生成</p>
                           </li>
                           <li>
                              <p>挖掘组件已处理在SCN 7178240507上或之前生成的所有重做记录</p>
                           </li>
                           <li>
                              <p>如果SQL Apply因任何原因停止并重新启动，它将开始挖掘在SCN 7178219805上或之后生成的重做记录</p>
                           </li>
                        </ul><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER SESSION SET NLS_DATE_FORMAT ='yy-mm-dd hh24：mi：ss';会话改变了SQL&gt; SELECT APPLIED_TIME，LATEST_TIME，MINING_TIME，RESTART_TIME  - &gt; FROM V $ LOGSTDBY_PROGRESS; APPLIED_TIME LATEST_TIME MINING_TIME RESTART_TIME ----------------- ----------------- ------------ ----- ----------------- 05-05-12 10:38:21 05-05-12 10:41:53 05-05-12 10:41 ：21 05-05-12 10:09:30</pre><p>根据输出：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>SQL Apply已应用05-05-12 10:38:21（ <code class="codeph">APPLIED_TIME</code> ）之前或之前提交的所有事务</p>
                           </li>
                           <li>
                              <p>最后一次重做是在主数据库（ <code class="codeph">LATEST_TIME</code> ）的05-05-12 10:41:53时生成的</p>
                           </li>
                           <li>
                              <p>挖掘引擎处理了05-05-12 10:41:21（ <code class="codeph">MINING_TIME</code> ）之前或之前生成的所有重做记录</p>
                           </li>
                           <li>
                              <p>如果重新启动，SQL Apply将开始挖掘05-05-12 10:09:30之后生成的重做记录</p>
                           </li>
                        </ul>
                        <div class="infoboxnotealso" id="GUID-DAF00126-1FDA-4980-AD24-1360472ADB49__GUID-35C92B00-0351-4799-9BBF-566D083AFF87">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-5BD79860-B3B8-4E0D-9F55-2E9918B93292" title="SQL Apply可以处于以下六种状态中的任何一种：初始化SQL Apply，等待字典日志，加载LogMiner字典，应用（重做数据），等待存档间隙得到解决，以及空闲。">监视SQL Apply Progress</a>以获取示例输出</p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="SBYDB4819"></a><div class="props_rev_3"><a id="GUID-9E8AFFE3-E4C2-46EB-A733-B48793DB4F1F" name="GUID-9E8AFFE3-E4C2-46EB-A733-B48793DB4F1F"></a><h4 id="SBYDB-GUID-9E8AFFE3-E4C2-46EB-A733-B48793DB4F1F" class="sect4"><span class="enumeration_section">11.3.6</span> V $ LOGSTDBY_STATE查看</h4>
                  <div>
                     <div class="section">
                        <p>此视图提供了SQL Apply当前状态的概要，包括：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p>主数据库的DBID（ <code class="codeph">primary_dbid</code> ）。
                              </p>
                           </li>
                           <li>
                              <p>分配给SQL Apply（ <code class="codeph">session_id</code> ）的LogMiner会话ID。
                              </p>
                           </li>
                           <li>
                              <p>SQL Apply是否<code class="codeph">realtime_apply</code>应用（ <code class="codeph">realtime_apply</code> ）。
                              </p>
                           </li>
                        </ul>
                        <p>例如：</p><pre class="oac_no_warn" dir="ltr">SQL&gt; COLUMN REALTIME_APPLY FORMAT a15 SQL&gt;列状态格式a16 SQL&gt; SELECT * FROM V $ LOGSTDBY_STATE; PRIMARY_DBID SESSION_ID REALTIME_APPLY STATE ------------ ---------- --------------- --------- ------- 1562626987 1 Y申请</pre><p>输出显示SQL Apply正在实时应用模式下运行，并且当前正在应用从主数据库接收的重做数据，主数据库的<code class="codeph">DBID</code>为1562626987，与SQL Apply会话关联的LogMiner会话标识符为1。
                        </p>
                        <div class="infoboxnotealso" id="GUID-9E8AFFE3-E4C2-46EB-A733-B48793DB4F1F__GUID-51C3E9CB-A493-41B8-B680-721F9D310CC9">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-5BD79860-B3B8-4E0D-9F55-2E9918B93292" title="SQL Apply可以处于以下六种状态中的任何一种：初始化SQL Apply，等待字典日志，加载LogMiner字典，应用（重做数据），等待存档间隙得到解决，以及空闲。">监视SQL Apply Progress</a>以获取示例输出</p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="SBYDB4820"></a><div class="props_rev_3"><a id="GUID-C72DA5B7-7FDD-46C8-9242-CD7D88DCDDB7" name="GUID-C72DA5B7-7FDD-46C8-9242-CD7D88DCDDB7"></a><h4 id="SBYDB-GUID-C72DA5B7-7FDD-46C8-9242-CD7D88DCDDB7" class="sect4"><span class="enumeration_section">11.3.7</span> V $ LOGSTDBY_STATS视图</h4>
                  <div>
                     <div class="section">
                        <p><code class="codeph">V$LOGSTDBY_STATS</code>视图显示与SQL Apply相关的统计信息，当前状态和状态信息。SQL Apply未运行时，此视图不返回任何行。此视图仅在逻辑备用数据库的上下文中有意义。
                        </p>
                        <p>例如：</p><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER SESSION SET NLS_DATE_FORMAT ='dd-mm-yyyy hh24：mi：ss';会话已更改SQL&gt; SELECT SUBSTR（name，1,40）AS NAME，SUBSTR（value，1,32）AS V值来自V $ LOGSTDBY_STATS; NAME VALUE ---------------------------------------- -------- ------------------------ logminer session id 1个编制者1个应用程序数量5个正在使用的服务器进程9 LCR缓存的最大SGA（MB）30记录的最大事件10000保留提交顺序TRUE事务一致性FULL记录跳过错误Y记录跳过DDLs Y记录应用DDLs N记录不支持的操作N实时应用Y应用延迟（分钟）0协调器状态APPLYING协调器启动时间19-06-2007 09:55 ：47协调器正常运行时间（秒）从logminer收到3593 txns 56 txns分配给应用23 txns应用22 txns在重启期间丢弃33大txns等待分配2回滚txns挖掘4 DDL txns挖掘40 CTAS txns挖掘0字节重做60164040字节寻呼0页面输出时间（秒）0字节检查点4845检查点时间（秒）0系统空闲时间（秒）2921备用重做日志已开采0存档日志已开采5间隙获取日志已开始0备用重做日志重用de tected 1 logfile open failures 0 current logfile wait（seconds）0 total logfile wait（seconds）2910 thread enable mined 0 thread disable mined 0。选择了40行。</pre></div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="SBYDB4821"></a><div class="props_rev_3"><a id="GUID-B0181E97-7A79-4E92-9B84-42DF8AF24FE0" name="GUID-B0181E97-7A79-4E92-9B84-42DF8AF24FE0"></a><h3 id="SBYDB-GUID-B0181E97-7A79-4E92-9B84-42DF8AF24FE0" class="sect3"><span class="enumeration_section">11.4</span>监控逻辑备用数据库</h3>
               <div>
                  <p>使用逻辑备用数据库时，可以监视SQL Apply进度，还可以自动删除日志文件。</p>
                  <p>请参阅以下主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-5BD79860-B3B8-4E0D-9F55-2E9918B93292" title="SQL Apply可以处于以下六种状态中的任何一种：初始化SQL Apply，等待字典日志，加载LogMiner字典，应用（重做数据），等待存档间隙得到解决，以及空闲。">监视SQL应用进度</a></p>
                     </li>
                     <li>
                        <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-893B304C-123F-4DCA-ACA2-96BB74E7A8A6" title="外部归档日志包含从主数据库发送的重做。">自动删除日志文件</a></p>
                     </li>
                  </ul>
               </div><a id="SBYDB5043"></a><a id="SBYDB5044"></a><a id="SBYDB5045"></a><a id="SBYDB5046"></a><a id="SBYDB5047"></a><a id="SBYDB5048"></a><a id="SBYDB5049"></a><a id="SBYDB4822"></a><div class="props_rev_3"><a id="GUID-5BD79860-B3B8-4E0D-9F55-2E9918B93292" name="GUID-5BD79860-B3B8-4E0D-9F55-2E9918B93292"></a><h4 id="SBYDB-GUID-5BD79860-B3B8-4E0D-9F55-2E9918B93292" class="sect4"><span class="enumeration_section">11.4.1</span>监控SQL应用进度</h4>
                  <div>
                     <p>SQL Apply可以处于以下六种状态中的任何一种：初始化SQL Apply，等待字典日志，加载LogMiner字典，应用（重做数据），等待存档间隙得到解决，以及空闲。</p>
                     <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-5BD79860-B3B8-4E0D-9F55-2E9918B93292__CHDJFHAG">图11-2</a>显示了这些状态的流程。
                     </p>
                     <div class="figure" id="GUID-5BD79860-B3B8-4E0D-9F55-2E9918B93292__CHDJFHAG">
                        <p class="titleinfigure">图11-2 SQL应用处理期间的进度状态</p><img src="img/sbydb031.gif" alt="下面是图11-2的描述" title="下面是图11-2的描述" longdesc="img_text/sbydb031.html"><br><a href="img_text/sbydb031.html">“图11-2 SQL应用处理期间的进度状态”的说明</a></div>
                     <!-- class="figure" -->
                     <p>以下小节更详细地描述了每个州。</p>
                     <div class="section">
                        <p class="subhead3" id="GUID-5BD79860-B3B8-4E0D-9F55-2E9918B93292__GUID-4764F424-47B4-42CB-B44A-F234376BB6D5">初始化国家</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>当您通过发出<code class="codeph">ALTER DATABASE START LOGICAL STANDBY APPLY</code>语句启动SQL Apply时，它将进入<span class="italic">初始化</span>状态。
                        </p>
                        <p>要确定SQL Apply的当前状态，请查询<code class="codeph">V$LOGSTDBY_STATE</code>视图<a id="d26509e2619" class="indexterm-anchor"></a> 。例如：</p><pre class="oac_no_warn" dir="ltr">SQL&gt; SELECT SESSION_ID，STATE FROM V $ LOGSTDBY_STATE; SESSION_ID STATE ---------- ------------- 1 INITIALIZING</pre><p><code class="codeph">SESSION_ID</code>列标识由SQL Apply创建的持久LogMiner会话，以挖掘主数据库生成的归档重做日志文件。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-5BD79860-B3B8-4E0D-9F55-2E9918B93292__GUID-C7B596AA-4244-40A4-B5B3-FEA7593261A5">等待字典日志</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>第一次启动SQL Apply时，它需要加载在重做日志文件中捕获的LogMiner字典。SQL Apply保留在<a id="d26509e2635" class="indexterm-anchor"></a> <code class="codeph">WAITING FOR DICTIONARY LOGS</code>状态，直到它收到加载LogMiner字典所需的所有重做数据。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-5BD79860-B3B8-4E0D-9F55-2E9918B93292__GUID-E6B876F0-2298-4322-93DD-62F608873F04">加载字典状态</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>这个<a id="d26509e2646" class="indexterm-anchor"></a><a id="d26509e2648" class="indexterm-anchor"></a> <span class="italic">加载字典</span>状态可以持续一段时间。在大型数据库上加载LogMiner字典可能需要很长时间。加载字典时，查询<code class="codeph">V$LOGSTDBY_STATE</code>视图会返回以下输出：</p><pre class="oac_no_warn" dir="ltr">SQL&gt; SELECT SESSION_ID，STATE FROM V $ LOGSTDBY_STATE; SESSION_ID状态---------- ------------------ 1加载字典</pre><p>只有<code class="codeph">COORDINATOR</code>进程和挖掘进程才会生成，直到LogMiner字典完全加载为止。因此，如果查询<code class="codeph">V$LOGSTDBY_PROCESS</code> <a id="d26509e2669" class="indexterm-anchor"></a>此时，您没有看到任何<code class="codeph">APPLIER</code>进程。例如：</p><pre class="oac_no_warn" dir="ltr">SQL&gt; SELECT SID，SERIAL＃，SPID，TYPE FROM V $ LOGSTDBY_PROCESS; SID SERIAL #SPID TYPE ------ --------- --------- --------------------- 47 3 11438 COORDINATOR 50 7 11334 READER 45 1 11336 BUILDER 44 2 11338 PREPARER 43 2 11340准备工作</pre><p>您可以通过查询<code class="codeph">V$LOGMNR_DICTIONARY_LOAD</code>视图获取有关加载字典的进度的更多详细信息。字典加载分三个阶段：</p>
                        <ol>
                           <li>
                              <p>挖掘相关的归档重做日志文件或备用重做日志文件，以收集与加载LogMiner字典相关的重做更改。</p>
                           </li>
                           <li>
                              <p>更改将在数据库内的临时表中处理和加载。</p>
                           </li>
                           <li>
                              <p>通过发出一系列DDL语句来加载LogMiner字典表。</p>
                           </li>
                        </ol>
                        <p>例如：</p><pre class="oac_no_warn" dir="ltr">SQL&gt; SELECT PERCENT_DONE，COMMAND  - &gt; FROM V $ LOGMNR_DICTIONARY_LOAD  - &gt; WHERE SESSION_ID =（从V $ LOGSTDBY_STATE中选择SESSION_ID）; PERCENT_DONE COMMAND ------------- ------------------------------- 40 alter table SYSTEM .LOGMNR_CCOL $交换分区P101与表SYS.LOGMNRLT_101_CCOL $不包括索引而没有验证</pre><p>如果<code class="codeph">PERCENT_DONE</code>或<code class="codeph">COMMAND</code>列长时间未更改，请查询<code class="codeph">V$SESSION_LONGOPS</code>视图以监视相关DDL事务的进度。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-5BD79860-B3B8-4E0D-9F55-2E9918B93292__GUID-A7AAAC4A-253B-413A-A41F-4AA63BC7920F">适用国家</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>在此状态下，SQL Apply已成功加载LogMiner字典的初始快照，并且当前正在将重做数据应用于逻辑备用数据库。</p>
                        <p>有关SQL Apply进度的详细信息，请查询<code class="codeph">V$LOGSTDBY_PROGRESS</code>视图：</p><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER SESSION SET NLS_DATE_FORMAT ='DD-MON-YYYY HH24：MI：SS'; SQL&gt; SELECT APPLIED_TIME，APPLIED_SCN，MINING_TIME，MINING_SCN  - &gt; FROM V $ LOGSTDBY_PROGRESS; APPLIED_TIME APPLIED_SCN MINING_TIME MINING_SCN -------------------- ----------- --------------- ----- ----------- 10-JAN-2005 12:00:05 346791023 10-JAN-2005 12:10:05 3468810134</pre><p>在主数据库上<code class="codeph">APPLIED_SCN</code> （或<code class="codeph">APPLIED_TIME</code> ）处或之前看到的所有已提交事务已应用于逻辑备用数据库。挖掘引擎已处理在主数据库上<code class="codeph">MINING_SCN</code> （和<code class="codeph">MINING_TIME</code> ）之前或之前生成的所有重做记录。在稳定状态下， <code class="codeph">MINING_SCN</code> （和<code class="codeph">MINING_TIME</code> ）的值始终位于<code class="codeph">APPLIED_SCN</code> （和<code class="codeph">APPLIED_TIME</code> ）之前。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-5BD79860-B3B8-4E0D-9F55-2E9918B93292__GUID-549DF95E-2FC7-4579-9776-73FE3B8F07DB">等待差距状态</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>当SQL Apply已经挖掘并应用了所有可用的重做记录，并且正在等待RFS进程存档新的日志文件（或缺少的日志文件）时，会出现此状态。</p><pre class="oac_no_warn" dir="ltr">SQL&gt; SELECT STATUS FROM V $ LOGSTDBY_PROCESS WHERE TYPE ='READER';状态  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  - - ----------------------- ORA-16240：等待日志文件（线程＃1，序列＃99）</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-5BD79860-B3B8-4E0D-9F55-2E9918B93292__GUID-3272C1A0-5C5F-408A-8590-0AEF576C1641">空闲状态</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>一旦应用了主数据库生成的所有重做，SQL Apply就会进入此状态。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="SBYDB00810"></a><div class="props_rev_3"><a id="GUID-893B304C-123F-4DCA-ACA2-96BB74E7A8A6" name="GUID-893B304C-123F-4DCA-ACA2-96BB74E7A8A6"></a><h4 id="SBYDB-GUID-893B304C-123F-4DCA-ACA2-96BB74E7A8A6" class="sect4"><span class="enumeration_section">11.4.2</span>自动删除日志文件</h4>
                  <div>
                     <p>外部归档日志包含从主数据库发送的重做。</p>
                     <p>存储外部存档日志有两种方法：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>在快速恢复区</p>
                        </li>
                        <li>
                           <p>在快速恢复区域之外的目录中</p>
                        </li>
                     </ul>
                     <p>存储在快速恢复区域中的外部归档日志始终由SQL Apply管理。在逻辑备用数据库中应用了日志中包含的所有重做记录之后，它们将保留<code class="codeph">DB_FLASHBACK_RETENTION_TARGET</code>参数指定的时间段（如果未指定<code class="codeph">DB_FLASHBACK_RETENTION_TARGET</code> ，则保留1440分钟）。您无法覆盖存储在快速恢复区域中的外部存档日志的自动管理。
                     </p>
                     <p>未存储在快速恢复区域中的外部归档日志默认由SQL Apply管理。在自动管理下，一旦在逻辑备用数据库中应用了日志中包含的所有重做记录，则存储在快速恢复区域中的外部归档日志将保留<code class="codeph">LOG_AUTO_DEL_RETENTION_TARGET</code>参数指定的时间段。您可以通过执行以下PL / SQL过程来覆盖未存储在快速恢复区域中的外部归档日志的自动管理：</p><pre class="oac_no_warn" dir="ltr">SQL&gt; EXECUTE DBMS_LOGSTDBY.APPLY_SET（'LOG_AUTO_DELETE'，'FALSE'）;</pre><div class="infoboxnote" id="GUID-893B304C-123F-4DCA-ACA2-96BB74E7A8A6__GUID-39B195C4-D36B-40ED-BEE7-5F55692F1972">
                        <p class="notep1">注意：</p>
                        <p>使用<code class="codeph">DBMS_LOGTSDBY.APPLY_SET</code>过程设置此参数。如果未明确指定<code class="codeph">LOG_AUTO_DEL_RETENTION_TARGET</code> ，则默认为在逻辑备用数据库中设置的<code class="codeph">DB_FLASHBACK_RETENTION_TARGET</code> ，或者在未设置<code class="codeph">DB_FLASHBACK_RETENTION_TARGET</code>情况下为1440分钟。
                        </p>
                     </div>
                     <p>如果要覆盖默认的自动日志删除功能，请定期执行以下步骤以标识和删除SQL Apply不再需要的归档重做日志文件：</p>
                     <ol>
                        <li>
                           <p>要清除不再需要的元数据的逻辑备用会话，请输入以下PL / SQL语句：</p><pre class="oac_no_warn" dir="ltr">SQL&gt; EXECUTE DBMS_LOGSTDBY.PURGE_SESSION;</pre><p>此语句还会更新<code class="codeph">DBA_LOGMNR_PURGED_LOG</code>视图，该视图显示不再需要的归档重做日志文件。
                           </p>
                        </li>
                        <li>
                           <p>查询<code class="codeph">DBA_LOGMNR_PURGED_LOG</code>视图以列出可以删除的归档重做日志文件：</p><pre class="oac_no_warn" dir="ltr">SQL&gt; SELECT * FROM DBA_LOGMNR_PURGED_LOG; FILE_NAME ------------------------------------ /boston/arc_dest/arc_1_40_509538672.log / boston / arc_dest / arc_1_41_509538672.log /boston/arc_dest/arc_1_42_509538672.log /boston/arc_dest/arc_1_43_509538672.log /boston/arc_dest/arc_1_44_509538672.log /boston/arc_dest/arc_1_45_509538672.log /boston/arc_dest/arc_1_46_509538672.log / boston / arc_dest / arc_1_47_509538672。日志</pre></li>
                        <li>
                           <p>使用特定于操作系统的命令删除查询列出的归档重做日志文件。</p>
                        </li>
                     </ol>
                  </div>
               </div>
            </div><a id="SBYDB4823"></a><div class="props_rev_3"><a id="GUID-88211E8E-28BF-45AC-9230-F85B606D8987" name="GUID-88211E8E-28BF-45AC-9230-F85B606D8987"></a><h3 id="SBYDB-GUID-88211E8E-28BF-45AC-9230-F85B606D8987" class="sect3"><span class="enumeration_section">11.5</span>自定义逻辑备用数据库</h3>
               <div>
                  <p>可以通过多种方式自定义逻辑备用数据库，包括记录事件，防止更改特定架构对象，以及添加或重新创建表。</p>
                  <p>请参阅以下主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-D6EEF87A-211C-476C-9CBC-126858F7026A" title="可以将DBA_LOGSTDBY_EVENTS视图视为包含SQL Apply上下文中发生的最新有趣事件的循环日志。">在DBA_LOGSTDBY_EVENTS视图中自定义事件记录</a></p>
                     </li>
                     <li>
                        <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-B976F237-1888-46D3-A901-F28FE362ACBC" title="默认情况下，主数据库中的所有受支持的表都将复制到逻辑备用数据库中。">使用DBMS_LOGSTDBY.SKIP来防止对特定架构对象的更改</a></p>
                     </li>
                     <li>
                        <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-28EB46A0-696D-426E-B596-225443867604" title="您可以创建一个过程来拦截某些DDL语句，并用不同的DDL语句替换原始的DDL语句。">为DDL语句设置跳过处理程序</a></p>
                     </li>
                     <li>
                        <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-43971CB9-3337-4575-B4EF-D591878982F1" title="即使在应用SQL语句时，逻辑备用数据库也可用于报告活动。">修改逻辑备用数据库</a></p>
                     </li>
                     <li>
                        <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-DD88E3D6-D6DB-4175-BB59-F048B9A87BAA" title="通常，您使用DBMS_LOGSTDBY.INSTANTIATE_TABLE过程在不可恢复的操作后重新创建表。">在逻辑备用数据库上添加或重新创建表</a></p>
                        <div class="infoboxnotealso" id="GUID-88211E8E-28BF-45AC-9230-F85B606D8987__GUID-C5BD391E-AA41-4485-9BB7-1F66197DC6BF">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sbydb&amp;id=ARPLS363" target="_blank"><span class="italic">Oracle Database PL / SQL包和类型参考中</span></a>的<code class="codeph">DBMS_LOGSTDBY</code>包</p>
                        </div>
                     </li>
                  </ul>
               </div><a id="SBYDB5466"></a><a id="SBYDB5467"></a><a id="SBYDB4824"></a><div class="props_rev_3"><a id="GUID-D6EEF87A-211C-476C-9CBC-126858F7026A" name="GUID-D6EEF87A-211C-476C-9CBC-126858F7026A"></a><h4 id="SBYDB-GUID-D6EEF87A-211C-476C-9CBC-126858F7026A" class="sect4"><span class="enumeration_section">11.5.1</span>在DBA_LOGSTDBY_EVENTS视图中自定义事件记录</h4>
                  <div>
                     <p>可以将<code class="codeph">DBA_LOGSTDBY_EVENTS</code>视图视为包含SQL Apply上下文中发生的最新有趣事件的循环日志。
                     </p>
                     <div class="section">
                        <p>默认情况下，在事件视图中记住最后10,000个事件。您可以通过调用<code class="codeph">DBMS_LOGSTDBY.APPLY_SET</code>过程来更改记录的事件数。例如，要确保记录最后100,000个事件，可以发出以下语句：</p><pre class="oac_no_warn" dir="ltr">SQL&gt; EXECUTE DBMS_LOGSTDBY.APPLY_SET（'MAX_EVENTS_RECORDED'，'100000'）;</pre><p>导致SQL Apply停止的错误始终记录在<code class="codeph">DBA_LOGSTDBY_EVENTS</code>视图中（除非<code class="codeph">SYSTEM</code>表空间中没有足够的空间）。这些事件也始终放入警报文件中，文本中包含关键字<code class="codeph">LOGSTDBY</code> 。查询视图时，按<code class="codeph">EVENT_TIME</code> ， <code class="codeph">COMMIT_SCN</code>和<code class="codeph">CURRENT_SCN</code>顺序选择列。此排序可确保视图中最后出现关闭故障。
                        </p>
                        <p>以下示例显示了<code class="codeph">DBMS_LOGSTDBY</code>子程序，这些子程序指定要在视图中记录的事件。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-D6EEF87A-211C-476C-9CBC-126858F7026A__GUID-DC537CD1-F13C-4FB9-BDBA-804CA5D6A035">示例1：确定是否已应用DDL语句</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>例如，要将已应用的DDL事务记录到<code class="codeph">DBA_LOGSTDBY_EVENTS</code>视图，请发出以下语句：</p><pre class="oac_no_warn" dir="ltr">SQL&gt; EXECUTE DBMS_LOGSTDBY.APPLY_SET（'RECORD_APPLIED_DDL'，'TRUE'）;</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-D6EEF87A-211C-476C-9CBC-126858F7026A__GUID-A22C8A08-9156-4A15-8AD7-7585BFDCCC38">示例2：检查不受支持的操作的DBA_LOGSTDBY_EVENTS视图</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>要捕获有关逻辑备用数据库不支持的主数据库上运行的事务的信息，请发出以下语句：</p><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER DATABASE STOP LOGICAL STANDBY APPLY; SQL&gt; EXEC DBMS_LOGSTDBY.APPLY_SET（'RECORD_UNSUPPORTED_OPERATIONS'，'TRUE'）; SQL&gt; ALTER DATABASE START LOGICAL STANDBY立即申请;</pre><p>然后，检查<code class="codeph">DBA_LOGSTDBY_EVENTS</code>视图是否有任何不受支持的操作。通常，SQL Apply会以静默方式忽略对不受支持的表的操作。但是，在滚动升级期间（备用数据库处于较高版本并且由较低版本的主数据库生成的挖掘重做），如果在主数据库上执行了不受支持的操作，则逻辑备用数据库可能不是您所在的数据库想要进行转换。Oracle Data Guard在<code class="codeph">DBA_LOGSTDBY_EVENTS</code>视图中为每个表记录至少一个不受支持的操作。 <a href="using-sql-apply-to-perform-rolling-upgrade.html#GUID-290F632F-5295-47F3-AEF1-2D37C69C00D7" title="您可以使用逻辑备用数据库执行Oracle数据库软件的滚动升级。"> 使用SQL Apply升级Oracle数据库</a>可提供有关滚动升级的详细信息。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="SBYDB4825"></a><div class="props_rev_3"><a id="GUID-B976F237-1888-46D3-A901-F28FE362ACBC" name="GUID-B976F237-1888-46D3-A901-F28FE362ACBC"></a><h4 id="SBYDB-GUID-B976F237-1888-46D3-A901-F28FE362ACBC" class="sect4"><span class="enumeration_section">11.5.2</span>使用DBMS_LOGSTDBY.SKIP防止对特定模式对象的更改</h4>
                  <div>
                     <p>默认情况下，主数据库中的所有受支持的表都将复制到逻辑备用数据库中。</p>
                     <div class="section">
                        <p>您可以通过指定规则来更改默认行为，以跳过对特定表应用修改。例如，要省略对<code class="codeph">HR.EMPLOYEES</code>表的更改，可以指定规则以防止将DML和DDL更改应用于特定表。例如：</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>停止SQL应用：</span><div><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER DATABASE STOP LOGICAL STANDBY APPLY;</pre></div>
                        </li>
                        <li class="stepexpand"><span>注册<code class="codeph">SKIP</code>规则：</span><div><pre class="oac_no_warn" dir="ltr">SQL&gt; EXECUTE DBMS_LOGSTDBY.SKIP（stmt =&gt;'DML'，schema_name =&gt;'HR'， - &gt; object_name =&gt;'EMPLOYEES'）; SQL&gt; EXECUTE DBMS_LOGSTDBY.SKIP（stmt =&gt;'SCHEMA_DDL'，schema_name =&gt;'HR'， - &gt; object_name =&gt;'EMPLOYEES'）;</pre></div>
                        </li>
                        <li class="stepexpand"><span>启动SQL Apply：</span><div><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER DATABASE START LOGICAL STANDBY立即申请;</pre></div>
                        </li>
                     </ol>
                  </div>
               </div><a id="SBYDB4826"></a><div class="props_rev_3"><a id="GUID-28EB46A0-696D-426E-B596-225443867604" name="GUID-28EB46A0-696D-426E-B596-225443867604"></a><h4 id="SBYDB-GUID-28EB46A0-696D-426E-B596-225443867604" class="sect4"><span class="enumeration_section">11.5.3</span>为DDL语句设置跳过处理程序</h4>
                  <div>
                     <p>您可以创建一个过程来拦截某些DDL语句，并用不同的DDL语句替换原始的DDL语句。</p>
                     <div class="section">
                        <p>例如，如果逻辑备用数据库中的文件系统组织与主数据库中的文件系统组织不同，则可以编写<code class="codeph">DBMS_LOGSTDBY.SKIP</code>过程以透明地处理具有文件规范的DDL事务。
                        </p>
                        <p>只要对文件规范字符串使用特定的命名约定，以下过程就可以处理主数据库和备用数据库之间的不同文件系统组织。</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>创建跳过程序以处理表空间DDL事务：</span><div><pre class="oac_no_warn" dir="ltr">创建或替换过程SYS.HANDLE_TBS_DDL（VARCHAR2中的OLD_STMT，VARCHAR2中的STMT_TYP，VARCHAR2中的模式，VARCHAR2中的名称，数字中的XIDUSN，数字中的XIDSLN，数字中的XIDSQN，操作数字，NEW_STMT输出VARCHAR2）AS BEGIN  - 所有主要包含目录的文件规范 -  / usr / orcl / primary / dbs  - 应该转到/ usr / orcl / stdby目录规范NEW_STMT：= REPLACE（OLD_STMT，'/ usr / orcl / primary / dbs'，'/ usr / ORCL / STDBY'）;行动：= DBMS_LOGSTDBY.SKIP_ACTION_REPLACE;除了其他行动之外的例外：= DBMS_LOGSTDBY.SKIP_ACTION_ERROR; NEW_STMT：= NULL; END HANDLE_TBS_DDL;</pre></div>
                        </li>
                        <li class="stepexpand"><span>停止SQL应用：</span><div><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER DATABASE STOP LOGICAL STANDBY APPLY;</pre></div>
                        </li>
                        <li class="stepexpand"><span>使用SQL Apply注册跳过程序：</span><div><pre class="oac_no_warn" dir="ltr">SQL&gt; EXECUTE DBMS_LOGSTDBY.SKIP（stmt =&gt;'TABLESPACE'， - &gt; proc_name =&gt;'sys.handle_tbs_ddl'）;</pre></div>
                        </li>
                        <li class="stepexpand"><span>启动SQL Apply：</span><div><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER DATABASE START LOGICAL STANDBY立即申请;</pre></div>
                        </li>
                     </ol>
                  </div>
               </div><a id="SBYDB4827"></a><div class="props_rev_3"><a id="GUID-43971CB9-3337-4575-B4EF-D591878982F1" name="GUID-43971CB9-3337-4575-B4EF-D591878982F1"></a><h4 id="SBYDB-GUID-43971CB9-3337-4575-B4EF-D591878982F1" class="sect4"><span class="enumeration_section">11.5.4</span>修改逻辑备用数据库</h4>
                  <div>
                     <p>即使在应用SQL语句时，逻辑备用数据库也可用于报告活动。</p>
                     <p><span class="italic">数据库保护</span>控制用户对逻辑备用数据库中表的访问， <code class="codeph">ALTER SESSION DISABLE GUARD</code>语句用于绕过数据库保护并允许修改逻辑备用数据库中的表。
                     </p>
                     <div class="infoboxnote" id="GUID-43971CB9-3337-4575-B4EF-D591878982F1__GUID-34935874-4E98-4B04-BD66-F03E13F8B9B4">
                        <p class="notep1">注意：</p>
                        <p>要使用逻辑备用数据库来托管处理从主数据库复制的数据的其他应用程序，同时创建自己的其他表，则必须将数据库防护设置为<code class="codeph">STANDBY</code> 。要使这些应用程序无缝工作，请确保在<code class="codeph">PRESERVE_COMMIT_ORDER</code>设置为<code class="codeph">TRUE</code> （SQL Apply的默认设置）的情况下运行。（有关<code class="codeph">DBMS_LOGSTDBY</code> PL / SQL包中<code class="codeph">PRESERVE_COMMIT_ORDER</code>参数的信息，请参阅<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sbydb&amp;id=ARPLS66830" target="_blank"><span class="italic">Oracle Database PL / SQL包和类型参考</span></a> 。）
                        </p>
                        <p>发出以下SQL语句以将数据库防护设置为<code class="codeph">STANDBY</code> ：</p><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER DATABASE GUARD STANDBY;</pre><p>在此保护设置下，从主数据库复制的表受到保护而不受用户修改，但在备用数据库上创建的表可由逻辑备用数据库上运行的应用程序修改。</p>
                     </div>
                     <p>默认情况下，逻辑备用数据库在数据库保护设置为<code class="codeph">ALL</code> ，这是其最严格的设置，并且不允许对数据库执行任何用户更改。您可以通过执行<code class="codeph">ALTER SESSION DISABLE GUARD</code>语句来覆盖数据库防护以允许更改逻辑备用数据库。特权用户可以发出此语句以关闭当前会话的数据库保护。
                     </p>
                     <p>以下部分提供了一些示例。这些部分中的讨论假定数据库防护设置为<code class="codeph">ALL</code>或<code class="codeph">STANDBY</code> 。</p>
                  </div><a id="SBYDB4828"></a><div class="props_rev_3"><a id="GUID-FB0ABA4B-4EA4-458E-9223-B3BEE00A581A" name="GUID-FB0ABA4B-4EA4-458E-9223-B3BEE00A581A"></a><h5 id="SBYDB-GUID-FB0ABA4B-4EA4-458E-9223-B3BEE00A581A" class="sect5"><span class="enumeration_section">11.5.4.1</span>在逻辑备用数据库上执行DDL</h5>
                     <div>
                        <p>您可以向通过SQL Apply维护的表添加约束。</p>
                        <div class="section">
                           <p></p>
                           <p>默认情况下，只有具有<code class="codeph">SYS</code>权限的帐户才能在数据库防护设置为ALL或STANDBY时修改数据库。如果以<code class="codeph">SYSDG</code> ， <code class="codeph">SYSTEM</code>或其他特权帐户登录，则无法在未先绕过会话的数据库保护的情况下在逻辑备用数据库上发出DDL语句。
                           </p>
                           <p>以下示例说明如何停止SQL Apply，绕过数据库防护，在逻辑备用数据库上执行SQL语句，然后重新启用防护。在此示例中，soundex索引被添加到<code class="codeph">SCOTT.EMP</code>的姓氏列以加速部分匹配查询。soundex索引可能无法在主服务器上维护。
                           </p><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER DATABASE STOP LOGICAL STANDBY APPLY;数据库改变了SQL&gt; ALTER SESSION DISABLE GUARD; PL / SQL过程成功完成。SQL&gt; CREATE INDEX EMP_SOUNDEX ON SCOTT.EMP（SOUNDEX（ENAME））;表改变了。SQL&gt; ALTER SESSION ENABLE GUARD; PL / SQL过程成功完成。SQL&gt; ALTER DATABASE START LOGICAL STANDBY立即申请;数据库改变了SQL&gt; SELECT ENAME，MGR FROM SCOTT.EMP WHERE SOUNDEX（ENAME）= SOUNDEX（'CLARKE'）; ENAME MGR ---------- ---------- CLARK 7839</pre><p>Oracle建议您在启用数据库保护旁路时不对SQL Apply维护的表执行DML操作。这样做会引入主数据库和备用数据库之间的偏差，从而无法维护逻辑备用数据库。</p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="SBYDB4829"></a><div class="props_rev_3"><a id="GUID-2050159A-C52F-49C2-80D2-457E62879462" name="GUID-2050159A-C52F-49C2-80D2-457E62879462"></a><h5 id="SBYDB-GUID-2050159A-C52F-49C2-80D2-457E62879462" class="sect5"><span class="enumeration_section">11.5.4.2</span>修改SQL Apply不维护的表</h5>
                     <div>
                        <div>有时，报告应用程序必须收集摘要结果并临时存储它们或跟踪报告的运行次数。虽然应用程序的主要目的是执行报告活动，但应用程序可能需要在逻辑备用数据库上发出DML（插入，更新和删除）操作。它甚至可能需要创建或删除表。<span>只要不通过SQL Apply维护数据，您就可以设置数据库防护以允许报告操作修改数据。</span></div>
                        <div class="section">
                           <p></p>
                           <p>要做到这一点，你必须：</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>在逻辑备用数据库上指定一组表，应用程序可以通过执行<code class="codeph">DBMS_LOGSTDBY.SKIP</code>过程将数据写入该表。不通过SQL Apply维护跳过的表。
                                 </p>
                              </li>
                              <li>
                                 <p>设置数据库防护以仅保护备用表。</p>
                              </li>
                           </ul>
                           <p>在以下示例中，假定报告所写的表也位于主数据库中。</p>
                           <p>该示例停止SQL Apply，跳过表，然后重新启动SQL Apply。报告应用程序在<code class="codeph">HR</code>写入<code class="codeph">TESTEMP%</code> 。不再通过SQL Apply维护这些表。
                           </p><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER DATABASE STOP LOGICAL STANDBY APPLY;数据库改变了SQL&gt; EXECUTE DBMS_LOGSTDBY.SKIP（stmt =&gt;'SCHEMA_DDL'， -  schema_name =&gt;'HR'， -  object_name =&gt;'TESTEMP％'）; PL / SQL过程成功完成。SQL&gt; EXECUTE DBMS_LOGSTDBY.SKIP（'DML'，'HR'，'TESTEMP％'）; PL / SQL过程成功完成。SQL&gt; ALTER DATABASE START LOGICAL STANDBY立即申请;数据库改变了
</pre><p>SQL Apply启动后，需要更新备用数据库上的元数据，以便在跳过规则中添加新指定的表。尝试修改新跳过的表，直到SQL Apply有机会更新元数据失败。您可以通过发出以下查询来确定SQL Apply是否已成功考虑您刚刚添加的<code class="codeph">SKIP</code>规则：</p><pre class="oac_no_warn" dir="ltr">SQL&gt; SELECT VALUE FROM SYSTEM.LOGSTDBY $ PARAMETERS WHERE NAME ='GUARD_STANDBY'; VALUE ---------------准备好了</pre><p>当<code class="codeph">VALUE</code>列显示<code class="codeph">Ready</code> ，SQL Apply已成功更新跳过的表的所有相关元数据，并且可以安全地修改表。
                           </p>
                           <div class="infoboxnotealso" id="GUID-2050159A-C52F-49C2-80D2-457E62879462__GUID-46AC92D3-3103-4D19-AF0D-211A4EDABFF4">
                              <p class="notep1">也可以看看：</p>
                              <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sbydb&amp;id=ARPLS363" target="_blank"><span class="italic">Oracle数据库PL / SQL包和类型参考中</span></a> <a href="data-type-ddl-support-on-logical-standby-databases.html#GUID-1595A660-6790-436A-BB84-D74C9187D8AE" title="The DBMS_LOGSTDBY.SKIP procedure has several optional keywords.">的逻辑备用数据库</a>和<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sbydb&amp;id=ARPLS363" target="_blank"><code class="codeph">DBMS_LOGSTDBY</code></a>包<a href="data-type-ddl-support-on-logical-standby-databases.html#GUID-1595A660-6790-436A-BB84-D74C9187D8AE" title="DBMS_LOGSTDBY.SKIP过程有几个可选的关键字。">支持的DDL语句</a></p>
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="SBYDB4830"></a><div class="props_rev_3"><a id="GUID-DD88E3D6-D6DB-4175-BB59-F048B9A87BAA" name="GUID-DD88E3D6-D6DB-4175-BB59-F048B9A87BAA"></a><h4 id="SBYDB-GUID-DD88E3D6-D6DB-4175-BB59-F048B9A87BAA" class="sect4"><span class="enumeration_section">11.5.5</span>在逻辑备用数据库上添加或重新创建表</h4>
                  <div>
                     <p>通常，您使用<code class="codeph">DBMS_LOGSTDBY.INSTANTIATE_TABLE</code>过程在不可恢复的操作后重新创建表。
                     </p>
                     <div class="section">
                        <p>您还可以使用此过程在以前跳过的表上启用SQL Apply。</p>
                        <p>在创建表之前，它必须满足<a href="creating-oracle-data-guard-logical-standby.html#GUID-C238335E-8383-43F1-B5B1-709A2A619C30" title="主数据库生成的重做记录中包含的ROWID不能用于标识逻辑备用数据库中的相应行。">确保可以唯一标识主数据库中的表行中所述</a>的要求。然后，您可以使用以下步骤重新创建名为<code class="codeph">HR.EMPLOYEES</code>的表并恢复SQL Apply。方向假定已经定义了一个数据库链接<code class="codeph">BOSTON</code>来访问主数据库。
                        </p>
                        <p>以下列表显示如何重新创建表并在该表上重新启动SQL Apply：</p>
                        <ol>
                           <li>
                              <p>停止SQL应用：</p><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER DATABASE STOP LOGICAL STANDBY APPLY;</pre></li>
                           <li>
                              <p>通过查询<code class="codeph">DBA_LOGSTDBY_SKIP</code>视图，确保没有为相关表跳过任何操作：</p><pre class="oac_no_warn" dir="ltr">SQL&gt; SELECT * FROM DBA_LOGSTDBY_SKIP; ERROR STATEMENT_OPT所有者名称PROC ----- ------------------- ------------- -------- -------- ----- N SCHEMA_DDL HR员工N DML HR员工N SCHEMA_DDL OEE TEST_ORDER N DML OE TEST_ORDER</pre><p>由于您已经有与要在逻辑备用数据库上重新创建的表关联的跳过规则，因此必须先删除这些规则。您可以通过调用<code class="codeph">DBMS_LOGSTDBY.UNSKIP</code>过程来完成此操作。例如：</p><pre class="oac_no_warn" dir="ltr">SQL&gt; EXECUTE DBMS_LOGSTDBY.UNSKIP（stmt =&gt;'DML'， - &gt; schema_name =&gt;'HR'， - &gt; object_name =&gt;'EMPLOYEES'）;</pre><pre class="oac_no_warn" dir="ltr">SQL&gt; EXECUTE DBMS_LOGSTDBY.UNSKIP（stmt =&gt;'SCHEMA_DDL'， - &gt; schema_name =&gt;'HR'， - &gt; object_name =&gt;'EMPLOYEES'）;</pre></li>
                           <li>
                              <p>使用<code class="codeph">DBMS_LOGSTDBY.INSTANTIATE_TABLE</code>在逻辑备用数据库中重新创建表<code class="codeph">HR.EMPLOYEES</code>及其所有数据<a id="d26509e3978" class="indexterm-anchor"></a><a id="d26509e3982" class="indexterm-anchor"></a>程序。例如：</p><pre class="oac_no_warn" dir="ltr">SQL&gt; EXECUTE DBMS_LOGSTDBY.INSTANTIATE_TABLE（schema_name =&gt;'HR'， - &gt; table_name =&gt;'EMPLOYEES'， - &gt; dblink =&gt;'BOSTON'）;</pre></li>
                           <li>
                              <p>启动SQL Apply：</p><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER DATABASE START LOGICAL STANDBY立即申请;</pre><div class="infoboxnotealso" id="GUID-DD88E3D6-D6DB-4175-BB59-F048B9A87BAA__GUID-22C93637-3F30-4B1C-A919-4A7945555CD0">
                                 <p class="notep1">也可以看看：</p>
                                 <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sbydb&amp;id=ARPLS363" target="_blank"><span class="italic">Oracle Database PL / SQL包和类型参考</span></a>有关<code class="codeph">DBMS_LOGSTDBY.UNSKIP</code>和<code class="codeph">DBMS_LOGSTDBY.INSTANTIATE_TABLE</code>过程的信息</p>
                              </div>
                           </li>
                        </ol>
                        <p>要确保在新实例化的表和数据库的其余部分之间保持一致的视图，请在查询此表之前等待SQL Apply赶上主数据库。您可以通过执行以下步骤来执行此操作：</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>在主数据库上，通过查询<code class="codeph">V$DATABASE</code>视图确定当前SCN：</span><div><pre class="oac_no_warn" dir="ltr">SQL&gt; SELECT CURRENT_SCN来自V $ DATABASE @ BOSTON; CURRENT_SCN --------------------- 345162788</pre></div>
                        </li>
                        <li class="stepexpand"><span>确保SQL Apply已应用在上一个查询中返回的<code class="codeph">CURRENT_SCN</code>之前提交的所有事务：</span><div><pre class="oac_no_warn" dir="ltr">SQL&gt; SELECT APPLIED_SCN FROM V $ LOGSTDBY_PROGRESS; APPLIED_SCN -------------------------- 345161345</pre><p>当此查询中返回的<code class="codeph">APPLIED_SCN</code>大于第一个查询中返回的<code class="codeph">CURRENT_SCN</code> ，查询新重新创建的表是安全的。
                              </p>
                           </div>
                        </li>
                     </ol>
                  </div>
               </div>
            </div><a id="SBYDB4831"></a><div class="props_rev_3"><a id="GUID-6B8A9BA8-AEF5-4F87-9B1D-67D1A32955D0" name="GUID-6B8A9BA8-AEF5-4F87-9B1D-67D1A32955D0"></a><h3 id="SBYDB-GUID-6B8A9BA8-AEF5-4F87-9B1D-67D1A32955D0" class="sect3"><span class="enumeration_section">11.6</span>在逻辑备用数据库的上下文中管理特定工作负载</h3>
               <div>
                  <p>您可以在逻辑备用数据库的上下文中管理特定工作负载。</p>
                  <p>请参阅以下内容：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-9B6FFB16-3A39-48E6-946F-98931D2E4449" title="可传输表空间可以导入主数据库。">将可传输表空间导入主数据库</a></p>
                     </li>
                     <li>
                        <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-37E6E6F2-15F0-4F16-B9E5-5EA7B28D6FB3" title="逻辑备用数据库会自动跳过与物化视图相关的DDL语句。">使用物化视图</a></p>
                     </li>
                     <li>
                        <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-50903261-075E-44F4-80F2-E5ED7C165F0D" title="默认情况下，会在逻辑备用数据库上自动启用和处理触发器和约束。">如何在逻辑备用数据库上处理触发器和约束</a></p>
                     </li>
                     <li>
                        <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-3DA5C15C-C275-45D5-A6DA-75ED5878D7FB" title="在表上创建的DML触发器默认情况下将其DBMS_DDL.SET_TRIGGER_FIRING_PROPERTY fire_once参数设置为TRUE。">使用触发器复制不支持的表</a></p>
                     </li>
                     <li>
                        <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-44D7C275-A991-4B6F-84A2-D76085E00367" title="当逻辑备用数据库收到重做数据的新分支时，SQL Apply会自动获取重做数据的新分支。">通过在主要时间执行的时间点恢复来恢复</a></p>
                     </li>
                     <li>
                        <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-DD1C8B1D-0F1A-448E-B193-124DD8FD65E9" title="您可以在逻辑备用数据库上运行Oracle Streams捕获进程，以捕获逻辑备用数据库上存在的任何表（无论是本地表还是从主数据库复制的维护表）中的更改。">在逻辑备用数据库上运行Oracle Streams Capture进程</a></p>
                     </li>
                  </ul>
               </div><a id="SBYDB4832"></a><div class="props_rev_3"><a id="GUID-9B6FFB16-3A39-48E6-946F-98931D2E4449" name="GUID-9B6FFB16-3A39-48E6-946F-98931D2E4449"></a><h4 id="SBYDB-GUID-9B6FFB16-3A39-48E6-946F-98931D2E4449" class="sect4"><span class="enumeration_section">11.6.1</span>将可传输表空间导入主数据库</h4>
                  <div>
                     <p>可传输表空间可以导入主数据库。</p>
                     <div class="section">
                        <p>执行以下步骤：</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>禁用保护设置，以便您可以修改逻辑备用数据库：</span><div><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER DATABASE GUARD STANDBY;</pre></div>
                        </li>
                        <li class="stepexpand"><span>在逻辑备用数据库中导入表空间。</span></li>
                        <li class="stepexpand"><span>启用数据库防护设置：</span><div><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER DATABASE GUARD ALL;</pre></div>
                        </li>
                        <li class="stepexpand"><span>在主数据库中导入表空间。</span></li>
                     </ol>
                  </div>
               </div><a id="SBYDB4833"></a><div class="props_rev_3"><a id="GUID-37E6E6F2-15F0-4F16-B9E5-5EA7B28D6FB3" name="GUID-37E6E6F2-15F0-4F16-B9E5-5EA7B28D6FB3"></a><h4 id="SBYDB-GUID-37E6E6F2-15F0-4F16-B9E5-5EA7B28D6FB3" class="sect4"><span class="enumeration_section">11.6.2</span>使用物化视图</h4>
                  <div>
                     <p>逻辑备用数据库会自动跳过与物化视图相关的DDL语句。</p>
                     <p>例如，逻辑备用数据库会跳过以下语句：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">CREATE</code> ， <code class="codeph">ALTER</code>或<code class="codeph">DROP MATERIALIZED VIEW</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">CREATE</code> ， <code class="codeph">ALTER</code>或<code class="codeph">DROP MATERIALIZED VIEW LOG</code></p>
                        </li>
                     </ul>
                     <p>在逻辑备用数据库上不会创建在创建逻辑备用数据库之后在主数据库上创建，更改或删除的新物化视图。但是，在创建逻辑备用数据库之前在主数据库上创建的物化视图存在于逻辑备用数据库上。</p>
                     <p>除了其他类型的辅助数据结构之外，Logical Standby还支持在逻辑备用数据库上本地创建和维护新的物化视图。例如，联机事务处理（OLTP）系统经常使用高度规范化的表来获得更新性能，但这些可能导致复杂决策支持查询的响应时间变慢。可以创建对复制数据进行非规范化以实现逻辑备用数据库上更高效查询支持的物化视图，如下所示（在发出这些语句之前以用户<code class="codeph">SYS</code>身份连接）：</p><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER SESSION DISABLE GUARD; SQL&gt; CREATE MATERIALIZED VIEW LOG ON SCOTT.EMP  - &gt; WITH ROWID（EMPNO，ENAME，MGR，DEPTNO）包括新的值; SQL&gt; CREATE MATERIALIZED VIEW LOG ON SCOTT.DEPT  - &gt; WITH ROWID（DEPTNO，DNAME）包括新值; SQL&gt; CREATE MATERIALIZED VIEW SCOTT.MANAGED_BY  - &gt; REFRESH ON DEMAND  - &gt; ENABLE QUERY REWRITE  - &gt; AS SELECT E.ENAME，M.ENAME AS MANAGER  - &gt; FROM SCOTT.EMP E，SCOTT.EMP M WHERE E.MGR = M. EMPNO; SQL&gt; CREATE MATERIALIZED VIEW SCOTT.IN_DEPT  - &gt;刷新快速执行 - &gt;启用QUERY REWRITE  - &gt;选择E.ROWID作为ERID，D.ROWID作为DRID，E.ENAME，D.DNAME  - &gt; FROM SCOTT.EMP E， SCOTT.DEPT D WHERE E.DEPTNO = D.DEPTNO;</pre><p>在逻辑备用数据库上：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>发生事务提交时，会在逻辑备用数据库上自动刷新ON-COMMIT物化视图。</p>
                        </li>
                        <li>
                           <p>ON-DEMAND物化视图不会自动刷新：必须执行<code class="codeph">DBMS_MVIEW.REFRESH</code>过程才能刷新它。
                           </p>
                        </li>
                     </ul>
                     <p>例如，发出以下命令将刷新在上一个示例中创建的ON-DEMAND物化视图：</p><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER SESSION DISABLE GUARD; SQL&gt; EXECUTE DBMS_MVIEW.REFRESH（LIST =&gt;'SCOTT.MANAGED_BY'，METHOD =&gt;'C'）;</pre><p>如果使用<code class="codeph">DBMS_SCHEDULER</code>作业定期刷新按需实例化视图，则必须将数据库防护设置为<code class="codeph">STANDBY</code> 。 （无法在PL / SQL块中使用<code class="codeph">ALTER SESSION DISABLE GUARD</code>语句并使其生效。）
                     </p>
                  </div>
               </div><a id="SBYDB4834"></a><div class="props_rev_3"><a id="GUID-50903261-075E-44F4-80F2-E5ED7C165F0D" name="GUID-50903261-075E-44F4-80F2-E5ED7C165F0D"></a><h4 id="SBYDB-GUID-50903261-075E-44F4-80F2-E5ED7C165F0D" class="sect4"><span class="enumeration_section">11.6.3</span>如何在逻辑备用数据库上处理触发器和约束</h4>
                  <div>
                     <p>默认情况下，会在逻辑备用数据库上自动启用和处理触发器和约束。</p>
                     <p>对于SQL Apply <span class="italic">维护</span>的表的触发器和约束：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>约束 - 检查约束在主数据库上进行评估，不需要在逻辑备用数据库上重新评估。</p>
                        </li>
                        <li>
                           <p>触发器 - 记录在主数据库上执行的触发器的影响并将其应用于备用数据库。</p>
                        </li>
                     </ul>
                     <p>对于<span class="italic">不由</span> SQL Apply <span class="italic">维护</span>的表的触发器和约束：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>评估约束</p>
                        </li>
                        <li>
                           <p>触发器被触发</p>
                        </li>
                     </ul>
                  </div>
               </div><a id="SBYDB4835"></a><div class="props_rev_3"><a id="GUID-3DA5C15C-C275-45D5-A6DA-75ED5878D7FB" name="GUID-3DA5C15C-C275-45D5-A6DA-75ED5878D7FB"></a><h4 id="SBYDB-GUID-3DA5C15C-C275-45D5-A6DA-75ED5878D7FB" class="sect4"><span class="enumeration_section">11.6.4</span>使用触发器复制不支持的表</h4>
                  <div>
                     <p>在表上创建的DML触发器默认情况下将其<code class="codeph">DBMS_DDL.SET_TRIGGER_FIRING_PROPERTY</code> <code class="codeph">fire_once</code>参数设置为<code class="codeph">TRUE</code> 。
                     </p>
                     <p>仅当用户进程修改表时触发器才会触发。它们在SQL Apply进程中自动禁用，因此在SQL Apply进程修改表时不会触发它们。由于SQL Apply进程对维护的表进行了更改，因此有两种方法可以触发触发器：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>将触发器的<code class="codeph">fire_once</code>参数设置为<code class="codeph">FALSE</code> ，这允许它在用户进程的上下文或SQL Apply进程中触发</p>
                        </li>
                        <li>
                           <p>将<code class="codeph">apply_server_only</code>参数设置为<code class="codeph">TRUE</code> ，这会导致触发器仅在SQL Apply进程的上下文中触发，而不是在用户进程的上下文中触发</p>
                        </li>
                     </ul>
                     <div class="tblformal" id="GUID-3DA5C15C-C275-45D5-A6DA-75ED5878D7FB__GUID-E51BED5A-8FBE-4840-8D34-45AECD58DA2C">
                        <table cellpadding="4" cellspacing="0" class="Formal" title="" width="100%" border="1" summary="This 3 column table shows the effect of DML Triggers. Column 1 is the fire_once parameter setting. Column 1 is the apply_server_only parameter setting. Column 3 describes the effects. " frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="14%" id="d26509e4614">fire_once</th>
                                 <th align="left" valign="bottom" width="26%" id="d26509e4617">apply_server_only</th>
                                 <th align="left" valign="bottom" width="60%" id="d26509e4620">描述</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="14%" id="d26509e4625" headers="d26509e4614 ">
                                    <p><code class="codeph">真正</code></p>
                                 </td>
                                 <td align="left" valign="top" width="26%" headers="d26509e4625 d26509e4617 ">
                                    <p><code class="codeph">假</code></p>
                                 </td>
                                 <td align="left" valign="top" width="60%" headers="d26509e4625 d26509e4620 ">
                                    <p>这是DML触发器的默认属性设置。仅当用户进程修改基表时才会触发该触发器。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="14%" id="d26509e4637" headers="d26509e4614 ">
                                    <p><code class="codeph">假</code></p>
                                 </td>
                                 <td align="left" valign="top" width="26%" headers="d26509e4637 d26509e4617 ">
                                    <p><code class="codeph">假</code></p>
                                 </td>
                                 <td align="left" valign="top" width="60%" headers="d26509e4637 d26509e4620 ">
                                    <p>触发器在用户进程的上下文中以及在修改基表的SQL Apply进程的上下文中触发。您可以使用<code class="codeph">DBMS_LOGSTDBY.IS_APPLY_SERVER</code>函数区分这两个上下文。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="14%" id="d26509e4652" headers="d26509e4614 ">
                                    <p><code class="codeph">TRUE</code> / <code class="codeph">FALSE</code></p>
                                 </td>
                                 <td align="left" valign="top" width="26%" headers="d26509e4652 d26509e4617 ">
                                    <p><code class="codeph">真正</code></p>
                                 </td>
                                 <td align="left" valign="top" width="60%" headers="d26509e4652 d26509e4620 ">
                                    <p>触发器仅在SQL Apply进程修改基表时触发。当用户进程修改基表时，触发器不会触发。因此， <code class="codeph">apply_server_only</code>属性会覆盖触发器的<code class="codeph">fire_once</code>参数。
                                    </p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <p>由于简单的对象类型列的表是不受支持可以通过创建触发在SQL应用过程的上下文中的触发器被复制（或者通过设定<code class="codeph">fire_once</code>这样的触发的参数到<code class="codeph">FALSE</code>或由这样的触发器的apply_server_only参数设置为<code class="codeph">TRUE</code> 。可以在主数据库上使用常规DML触发器将对象类型展平为可以支持的表。在逻辑备用数据库上的SQL Apply进程的上下文中触发的触发器将重构对象类型并以事务方式更新不支持的表。
                     </p>
                     <div class="infoboxnotealso" id="GUID-3DA5C15C-C275-45D5-A6DA-75ED5878D7FB__GUID-AC849AE5-38AA-4B70-90C4-6F76431D62CA">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="../arpls/DBMS_DDL.html#ARPLS008" target="_blank"><span class="italic">Oracle数据库PL / SQL包和类型参考</span></a>的的描述<code class="codeph">DBMS_DDL.SET_TRIGGER_FIRING_PROPERTY</code>程序和<code class="codeph">DBMS_LOGSTDBY.IS_APPLY_SERVER</code>功能</p>
                           </li>
                        </ul>
                     </div>
                     <p>以下示例显示如何使用触发器复制具有简单对象类型的表。此示例显示如何处理插入;相同的原则可以应用于更新和删除。嵌套表和<code class="codeph">VARRAY</code>也可以使用此技术进行复制，并使用循环的附加步骤来规范化嵌套数据。
                     </p><pre class="oac_no_warn" dir="ltr">- 简单对象类型创建或替换类型Person作为对象（FirstName varchar2（50），LastName varchar2（50），BirthDate Date） - 不支持的对象表创建表employees（IdNumber varchar2（10），Department varchar2（50），Info Person） - 通过触发器填充支持的表创建表employees_transfer（t_IdNumber varchar2（10），t_Department varchar2（50），t_FirstName varchar2（50），t_LastName varchar2（50），t_BirthDate Date） - 创建此触发器以展平对象primary上的表 - 此触发器不会在备用数据库上触发 - 在每个行上插入员工后创建或替换触发器flatten_employees声明开始插入employees_transfer（t_IdNumber，t_Department，t_FirstName，t_LastName，t_BirthDate）值（：new。IdNumber，：新的。部门：新的。Info.FirstName，新。Info.LastName，：new。Info.BirthDate）;结束 -   - 选项＃1（更好的选项：创建触发器 - 并将其apply-server-only属性设置为TRUE） - 在逻辑备用数据库中创建此触发器 - 在备用数据库上填充对象表 - 此触发器仅在应用复制行时触发 - 到备用 - 创建或替换触发器reconstruct_employees_aso在employees_transfer上插入后，每行开始插入员工（IdNumber，Department，Info）值（：new.t_IdNumber，：new.t_Department， Person（：new.t_FirstName，：new.t_LastName，：new.t_BirthDate））; end  - 将此触发器设置为从应用服务器执行dbms_ddl.set_trigger_firing_property（ -  trig_owner =&gt;'scott'， -  trig_name =&gt;'reconstruct_employees_aso'，property =&gt; dbms_ddl.apply_server_only，setting =&gt; TRUE）; -   - 选项＃2（创建一个触发器并设置 - 其fire-once属性为FALSE） - 在逻辑备用数据库中创建此触发器 - 在备用数据库上填充对象表 - 此触发器将在应用时触发将行复制到 - 备用数据库，但是我们需要确保我们 - 通过调用在SQL Apply进程内执行 -  dbms_logstdby.is_apply_server函数 - 在employees_transfer上插入后，为每行开始创建或替换触发器reconstruct_employees_nfo dbms_logstdby.is_apply_server（）然后插入员工（IdNumber，Department，Info）值（：new.t_IdNumber，：new.t_Department，Person（：new.t_FirstName，：new.t_LastName，：new.t_BirthDate））;万一; end  - 将此触发器设置为从应用服务器执行dbms_ddl.set_trigger_firing_property（ -  trig_owner =&gt;'scott'， -  trig_name =&gt;'reconstruct_employees_nfo'，property =&gt; dbms_ddl.fire_once，setting =&gt; FALSE）;</pre></div>
               </div><a id="SBYDB4836"></a><div class="props_rev_3"><a id="GUID-44D7C275-A991-4B6F-84A2-D76085E00367" name="GUID-44D7C275-A991-4B6F-84A2-D76085E00367"></a><h4 id="SBYDB-GUID-44D7C275-A991-4B6F-84A2-D76085E00367" class="sect4"><span class="enumeration_section">11.6.5</span>通过主<span class="enumeration_section">节点</span>执行的时间点恢复进行恢复</h4>
                  <div>
                     <p>当逻辑备用数据库收到重做数据的新分支时，SQL Apply会自动获取重做数据的新分支。</p>
                     <div class="section">
                        <p>对于逻辑备用数据库，如果备用数据库未通过新的重置日志SCN（超过重做数据的新分支的开始）应用重做数据，则不需要手动干预</p>
                        <p>下表描述了如何将备用数据库与主数据库分支重新同步。</p>
                        <div class="tblformalwide" id="GUID-44D7C275-A991-4B6F-84A2-D76085E00367__GUID-7474462F-5AF2-47BF-9E1B-681ED03EC9D7">
                           <table cellpadding="4" cellspacing="0" class="FormalWide" title="" width="100%" border="1" summary="This 3column table describes how to resynchronize the standby database with the primary database branch after you issue an OPEN RESETLOGS statement." frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="32%" id="d26509e4816">如果是备用数据库。 。 。</th>
                                    <th align="left" valign="bottom" width="27%" id="d26509e4819">然后。 。 。</th>
                                    <th align="left" valign="bottom" width="41%" id="d26509e4822">执行这些步骤。 。 。</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="32%" id="d26509e4827" headers="d26509e4816 ">
                                       <p>尚未将重做数据应用于新的重置日志SCN（通过重做数据的新分支的开始）</p>
                                    </td>
                                    <td align="left" valign="top" width="27%" headers="d26509e4827 d26509e4819 ">
                                       <p>SQL Apply自动获取重做数据的新分支。</p>
                                    </td>
                                    <td align="left" valign="top" width="41%" headers="d26509e4827 d26509e4822 ">
                                       <p>无需人工干预。SQL Apply自动将备用数据库与重做数据的新分支重新同步。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="32%" id="d26509e4837" headers="d26509e4816 ">
                                       <p>已经将重做数据应用于新的重置日志SCN（通过重做数据的新分支的开始）并且在备用数据库上启用了闪回数据库</p>
                                    </td>
                                    <td align="left" valign="top" width="27%" headers="d26509e4837 d26509e4819 ">
                                       <p>备用数据库将<span class="italic">在</span>重做数据的新分支<span class="italic">的未来</span>中恢复。
                                       </p>
                                    </td>
                                    <td align="left" valign="top" width="41%" headers="d26509e4837 d26509e4822 ">
                                       <ol>
                                          <li>
                                             <p>按照将<a href="examples-of-using-oracle-data-guard.html#GUID-A2191DBB-AA91-4C42-8F01-7B7E9529F465" title="这些步骤描述了在闪回主数据库并通过发出OPEN RESETLOGS语句打开它之后如何避免重新创建逻辑备用数据库。">逻辑备用数据库闪回到特定时间点的过程，</a>以闪回逻辑备用数据库。
                                             </p>
                                          </li>
                                          <li>
                                             <p>重新启动SQL Apply以继续将重做应用到新的重置日志分支。</p>
                                          </li>
                                       </ol>
                                       <p>SQL Apply自动将备用数据库与新分支重新同步。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="32%" id="d26509e4867" headers="d26509e4816 ">
                                       <p>已将重做数据应用于新的重置日志SCN（通过重做数据的新分支的开始）并且备用数据库上未启用闪回数据库</p>
                                    </td>
                                    <td align="left" valign="top" width="27%" headers="d26509e4867 d26509e4819 ">
                                       <p>主数据库已在指定的主数据库分支上与备用数据库分离。</p>
                                    </td>
                                    <td align="left" valign="top" width="41%" headers="d26509e4867 d26509e4822 ">
                                       <p>按照创建逻辑备用数据库中的过程重新<a href="creating-oracle-data-guard-logical-standby.html#GUID-3666CA35-D993-44B6-8D70-A2B8B9EC8B2E" title="创建逻辑备用数据库涉及许多步骤，包括先决条件和创建后任务。">创建逻辑备用数据库</a> 。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="32%" id="d26509e4884" headers="d26509e4816 ">
                                       <p>缺少从上一个重做数据分支末尾的归档重做日志文件</p>
                                    </td>
                                    <td align="left" valign="top" width="27%" headers="d26509e4884 d26509e4819 ">
                                       <p>在检索丢失的日志文件之前，SQL Apply无法继续。</p>
                                    </td>
                                    <td align="left" valign="top" width="41%" headers="d26509e4884 d26509e4822 ">
                                       <p>从上一个分支中找到并注册缺少的归档重做日志文件。</p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <p>有关数据库化身，通过<code class="codeph">OPEN RESETLOGS</code>操作进行恢复以及闪回数据库的详细信息，请参阅“ <a href="../bradv/rman-performing-flashback-dbpitr.html#BRADV89752" target="_blank"><span class="italic">Oracle数据库备份和恢复用户指南”</span></a> 。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="SBYDB4837"></a><div class="props_rev_3"><a id="GUID-DD1C8B1D-0F1A-448E-B193-124DD8FD65E9" name="GUID-DD1C8B1D-0F1A-448E-B193-124DD8FD65E9"></a><h4 id="SBYDB-GUID-DD1C8B1D-0F1A-448E-B193-124DD8FD65E9" class="sect4"><span class="enumeration_section">11.6.6</span>在逻辑备用数据库上运行Oracle Streams Capture进程</h4>
                  <div>
                     <p>您可以在逻辑备用数据库上运行Oracle Streams捕获进程，以捕获逻辑备用数据库上存在的任何表（无论是本地表还是从主数据库复制的维护表）中的更改。</p>
                     <p>将更改捕获到维护的表时，与在主数据库上运行Oracle Streams捕获进程相比，存在额外的延迟。额外延迟是因为当您在逻辑备用数据库上运行时，Oracle Streams捕获进程必须等待更改从主数据库发送到逻辑备用数据库并由SQL Apply应用。在大多数情况下，如果您正在运行实时应用，则不会超过几秒钟。</p>
                     <p>Oracle Streams捕获进程与创建它的数据库相关联;数据库的作用是无关紧要的。例如，假设您有一个名为<code class="codeph">Boston</code>的主数据库和一个名为<code class="codeph">London</code>的逻辑备用数据库。在进行角色转换时，无法将Oracle Streams捕获过程从一个数据库移动到另一个数据库。例如，如果您在<code class="codeph">London</code>成为逻辑备用数据库时创建了Oracle Streams捕获进程，那么即使<code class="codeph">London</code>因角色转换操作（例如切换或故障转移）而成为主要进程，它仍会保留在<code class="codeph">London</code> 。要使Oracle Streams捕获过程在角色转换后继续工作，您必须编写角色转换触发器，如下所示：</p><pre class="oac_no_warn" dir="ltr">在DB_ROLE_CHANGE上创建或替换触发器streams_aq_job_role_change1数据库声明游标capture_aq_jobs是select job_name，database_role来自dba_scheduler_job_roles，其中job_name类似'AQ_JOB％';你capture_aq_jobs％ROWTYPE; my_db_role varchar2（16）;如果（dbms_logstdby.db_is_logstdby（）= 1）则开始，然后my_db_role：='LOGICAL STANDBY';否则my_db_role：='PRIMARY';万一;打开capture_aq_jobs;循环获取capture_aq_jobs到u;在capture_aq_jobs％NOTFOUND时退出; if（u.database_role！= my_db_role）然后是dbms_scheduler.set_attribute（u.job_name，'database_role'，my_db_role）;万一;结束循环; close capture_aq_jobs;当别人开始加薪时的例外;结束;结束;</pre></div>
               </div>
            </div><a id="SBYDB4838"></a><div class="props_rev_3"><a id="GUID-8808747E-825D-4E0C-BD26-4E18F40574F8" name="GUID-8808747E-825D-4E0C-BD26-4E18F40574F8"></a><h3 id="SBYDB-GUID-8808747E-825D-4E0C-BD26-4E18F40574F8" class="sect3"><span class="enumeration_section">11.7</span>调整逻辑备用数据库</h3>
               <div>
                  <p>这些主题提供有关调整逻辑备用数据库的各种方法的信息。</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-10287018-12F8-4727-AB2D-C720571AF4B6" title="在主数据库上，如果表没有主键或唯一索引，并且您确定行是唯一的，则创建主键RELY约束。">创建主键RELY约束</a></p>
                     </li>
                     <li>
                        <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-4DDC26F5-29CC-435E-9996-8887DA653032" title="应在备用数据库上收集统计信息，因为基于成本的优化器（CBO）使用它们来确定最佳查询执行路径。">收集基于成本的优化程序的统计信息</a></p>
                     </li>
                     <li>
                        <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-8EFFAC57-9E1A-419E-AEAE-E5931D2845CB" title="可以修改三个参数来控制分配给SQL Apply的进程数：MAX_SERVERS，APPLY_SERVERS和PREPARE_SERVERS。">调整进程数</a></p>
                     </li>
                     <li>
                        <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-E856251B-C6AD-480A-9D9B-278BBF66688F" title="对于某些工作负载，SQL Apply可能会使用大量的pageout操作，从而降低了系统的整体吞吐量。增加分配给LCR缓存的内存可能会有所帮助。">调整用于LCR缓存的内存</a></p>
                     </li>
                     <li>
                        <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-486200D3-C7A5-4B21-9C81-FC654AD405DD" title="默认情况下，事务将按照它们在主数据库上提交的确切顺序应用于逻辑备用数据库。">调整如何在逻辑备用数据库上应用事务</a></p>
                     </li>
                  </ul>
               </div><a id="SBYDB4839"></a><div class="props_rev_3"><a id="GUID-10287018-12F8-4727-AB2D-C720571AF4B6" name="GUID-10287018-12F8-4727-AB2D-C720571AF4B6"></a><h4 id="SBYDB-GUID-10287018-12F8-4727-AB2D-C720571AF4B6" class="sect4"><span class="enumeration_section">11.7.1</span>创建主键RELY约束</h4>
                  <div>
                     <p>在主数据库上，如果表没有主键或唯一索引，并且您确定行是唯一的，则创建主键<code class="codeph">RELY</code>约束。
                     </p>
                     <div class="section">
                        <p>在逻辑备用数据库上，在构成主键的列上创建索引。以下查询生成一个表列表，其中没有索引信息，逻辑备用数据库可以使用这些表来应用于唯一标识行。通过在下表中创建索引，可以显着提高性能。</p><pre class="oac_no_warn" dir="ltr">SQL&gt; SELECT OWNER，TABLE_NAME FROM DBA_TABLES  - &gt; WHERE OWNER NOT IN（从DBA_LOGSTDBY_SKIP中选择所有者 - &gt; WHERE STATEMENT_OPT ='内部模式'） - &gt; MINUS  - &gt; SELECT DISTINCT TABLE_OWNER，TABLE_NAME FROM DBA_INDEXES  - &gt; WHERE INDEX_TYPE NOT LIKE（'FUNCTION -BASED％'） - &gt; MINUS  - &gt; SELECT OWNER，TABLE_NAME FROM DBA_LOGSTDBY_UNSUPPORTED;</pre><pre class="oac_no_warn" dir="ltr"></pre><p>您可以将依赖主键约束添加到主数据库上的表，如下所示：</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>在主数据库中添加主键依赖约束：</span><div><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER TABLE HR.TEST_EMPLOYEES添加主键（EMPNO）依赖禁用;</pre><p>这确保了可以用于唯一标识<code class="codeph">HR.TEST_EMPLOYEES</code>表中的行的<code class="codeph">EMPNO</code>列作为对该表执行的任何更新的一部分进行补充记录。
                              </p>
                              <p>请注意， <code class="codeph">HR.TEST_EMPLOYEES</code>表仍然没有在逻辑备用数据库上指定任何唯一索引。这可能导致<code class="codeph">UPDATE</code>语句对逻辑备用数据库执行全表扫描。您可以通过在逻辑备用数据库上的<code class="codeph">EMPNO</code>列上添加唯一索引来解决此问题。有关<code class="codeph">RELY</code>约束的详细信息，请参阅<a href="creating-oracle-data-guard-logical-standby.html#GUID-C238335E-8383-43F1-B5B1-709A2A619C30" title="主数据库生成的重做记录中包含的ROWID不能用于标识逻辑备用数据库中的相应行。">确保可以唯一标识主数据库中的表行</a>和<a href="../sqlrf/constraint.html#SQLRF52223" target="_blank"><span class="italic">Oracle数据库SQL语言参考</span></a> 。
                              </p>
                              <p>执行逻辑备用数据库上的其余步骤。</p>
                           </div>
                        </li>
                        <li class="stepexpand"><span>停止SQL应用：</span><div><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER DATABASE STOP LOGICAL STANDBY APPLY;</pre></div>
                        </li>
                        <li class="stepexpand"><span>禁用警卫，以便您可以修改逻辑备用数据库上的已维护表：</span><div><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER SESSION DISABLE GUARD;</pre></div>
                        </li>
                        <li class="stepexpand"><span>在<code class="codeph">EMPNO</code>列上添加唯一索引：</span><div><pre class="oac_no_warn" dir="ltr">SQL&gt; CREATE UNIQUE INDEX UI_TEST_EMP ON HR.TEST_EMPLOYEES（EMPNO）;</pre></div>
                        </li>
                        <li class="stepexpand"><span>启用警卫：</span><div><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER SESSION ENABLE GUARD;</pre></div>
                        </li>
                        <li class="stepexpand"><span>启动SQL Apply：</span><div><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER DATABASE START LOGICAL STANDBY立即申请;</pre></div>
                        </li>
                     </ol>
                  </div>
               </div><a id="SBYDB4840"></a><div class="props_rev_3"><a id="GUID-4DDC26F5-29CC-435E-9996-8887DA653032" name="GUID-4DDC26F5-29CC-435E-9996-8887DA653032"></a><h4 id="SBYDB-GUID-4DDC26F5-29CC-435E-9996-8887DA653032" class="sect4"><span class="enumeration_section">11.7.2</span>收集基于成本的优化器的统计信息</h4>
                  <div>
                     <p>应在备用数据库上收集统计信息，因为基于成本的优化器（CBO）使用它们来确定最佳查询执行路径。</p>
                     <p>在以先前统计信息不准确的方式修改模式对象的数据或结构之后，应收集新的统计信息。例如，在将大量行插入或删除到表中后，收集有关行数的新统计信息。</p>
                     <p>应在备用数据库上收集统计信息，因为主数据库上的DML和DDL操作是根据工作负载执行的。虽然备用数据库在逻辑上等同于主数据库，但SQL Apply可能以不同的方式执行工作负载。这就是在逻辑备用数据库上使用STATS包并且<code class="codeph">V$SYSSTAT</code>视图可用于确定哪些表占用最多资源和表扫描的原因。
                     </p>
                     <div class="infoboxnotealso" id="GUID-4DDC26F5-29CC-435E-9996-8887DA653032__GUID-D9C801C3-A87B-4A80-9B27-5F2EC5C3A401">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="creating-oracle-data-guard-logical-standby.html#GUID-C238335E-8383-43F1-B5B1-709A2A619C30" title="主数据库生成的重做记录中包含的ROWID不能用于标识逻辑备用数据库中的相应行。">确保可以唯一标识主数据库中的表行</a></p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="SBYDB4841"></a><div class="props_rev_3"><a id="GUID-8EFFAC57-9E1A-419E-AEAE-E5931D2845CB" name="GUID-8EFFAC57-9E1A-419E-AEAE-E5931D2845CB"></a><h4 id="SBYDB-GUID-8EFFAC57-9E1A-419E-AEAE-E5931D2845CB" class="sect4"><span class="enumeration_section">11.7.3</span>调整进程数</h4>
                  <div>
                     <p>可以修改三个参数来控制分配给SQL Apply的进程数： <code class="codeph">MAX_SERVERS</code> ， <code class="codeph">APPLY_SERVERS</code>和<code class="codeph">PREPARE_SERVERS</code> 。</p>
                     <p>以下关系必须始终成立：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">APPLY_SERVERS + P</code> <code class="codeph">REPARE_SERVERS =</code> <code class="codeph">MAX_SERVERS - 3</code></p>
                           <p>这是因为SQL Apply始终为<code class="codeph">READER</code> ， <code class="codeph">BUILDER</code>和<code class="codeph">ANALYZER</code>角色分配一个进程。
                           </p>
                        </li>
                        <li>
                           <p>默认情况下， <code class="codeph">MAX_SERVERS</code>设置为9， <code class="codeph">PREPARE_SERVERS</code>设置为1， <code class="codeph">APPLY_SERVERS</code>设置为5。
                           </p>
                        </li>
                        <li>
                           <p>Oracle建议您只更改<code class="codeph">MAX_SERVERS</code>通过参数<code class="codeph">DBMS_LOGSTDBY.APPLY_SET</code>程序，并允许SQL应用准备和应用进程之间适当地分配服务器进程。
                           </p>
                        </li>
                        <li>
                           <p>SQL应用使用该分配1个的处理分配算法<code class="codeph">PREPARE_SERVER</code>分配给SQL作为由指定的应用，每20个服务器进程<code class="codeph">MAX_SERVER</code>并限制的数量<code class="codeph">PREPARE_SERVERS</code>至5。因此，如果将<code class="codeph">MAX_SERVERS</code>设置为1到20之间的任何值，则SQL Apply将分配1个服务器进程作为<code class="codeph">PREPARER</code> ，并在满足前面描述的关系的同时将其余进程分配为<code class="codeph">APPLIERS</code> 。同样，如果将<code class="codeph">MAX_SERVERS</code>设置为21到40之间的值，则SQL Apply将分配2个服务器进程作为<code class="codeph">PREPARERS</code> ，其余部分作为<code class="codeph">APPLIERS</code> ，同时满足前面描述的关系。您可以通过直接设置<code class="codeph">APPLY_SERVERS</code>和<code class="codeph">PREPARE_SERVERS</code>来覆盖此内部进程分配算法，前提是满足前面描述的关系。
                           </p>
                        </li>
                     </ul>
                     <p>以下部分描述：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-F105E232-364E-4F40-ADCE-E13EB3566A2E" title="在调整APPLIER进程数之前，应确定这样做是否有助于实现更高的吞吐量。">调整APPLIER进程数</a></p>
                        </li>
                        <li>
                           <p><a href="managing-oracle-data-guard-logical-standby-databases.html#GUID-97300F48-66C4-4F9E-888D-DEFC0DDC10C8" title="您很少需要调整PREPARER进程的数量。在增加数量之前，您必须确保某些条件成立。">调整PREPARER进程数</a></p>
                        </li>
                     </ul>
                  </div><a id="SBYDB4842"></a><div class="props_rev_3"><a id="GUID-F105E232-364E-4F40-ADCE-E13EB3566A2E" name="GUID-F105E232-364E-4F40-ADCE-E13EB3566A2E"></a><h5 id="SBYDB-GUID-F105E232-364E-4F40-ADCE-E13EB3566A2E" class="sect5"><span class="enumeration_section">11.7.3.1</span>调整APPLIER进程数</h5>
                     <div>
                        <p>在调整<code class="codeph">APPLIER</code>进程数之前，应确定这样做是否有助于实现更高的吞吐量。
                        </p>
                        <div class="section">
                           <p>要确定此问题，请执行以下步骤：</p>
                        </div>
                        <!-- class="section" -->
                        <ol>
                           <li class="stepexpand"><span>通过发出以下查询来检查<code class="codeph">APPLIER</code>进程是否繁忙：</span><div><pre class="oac_no_warn" dir="ltr">SQL&gt; SELECT COUNT（*）AS IDLE_APPLIER  - &gt; FROM V $ LOGSTDBY_PROCESS  - &gt; WHERE TYPE ='APPLIER'和status_code = 16116; IDLE_APPLIER ------------------------- 0</pre></div>
                           </li>
                           <li class="stepexpand"><span>一旦确定没有空闲的<code class="codeph">APPLIER</code>进程，请发出以下查询以确保如果您选择调整<code class="codeph">APPLIERS</code>的数量，则有足够的工作可用于其他<code class="codeph">APPLIER</code>进程：</span><div><pre class="oac_no_warn" dir="ltr">SELECT NAME，VALUE FROM V $ LOGSTDBY_STATS WHERE NAME ='txns applied'或NAME ='distinct txns in queue';</pre><p>这两个统计信息保留了<code class="codeph">APPLIER</code>流程准备应用的累计事务总数以及已应用的事务数。
                                 </p>
                                 <p>如果数字（ <code class="codeph">distinct txns in queue - txns applied</code> ）高于可用<code class="codeph">APPLIER</code>进程数的两倍，则如果增加<code class="codeph">APPLIER</code>进程数，则可以提高吞吐量。
                                 </p>
                                 <div class="infoboxnote" id="GUID-F105E232-364E-4F40-ADCE-E13EB3566A2E__GUID-E26A3F6A-77FA-4CD9-BD1B-CBBCAAF487F7">
                                    <p class="notep1">注意：</p>
                                    <p>这个数字是对现成工作的粗略衡量。工作负载可能使得就绪事务之间的相互依赖性阻止了额外的可用<code class="codeph">APPLIER</code>进程应用它们。例如，如果准备应用的大多数事务是DDL事务，则添加更多<code class="codeph">APPLIER</code>进程不会导致更高的吞吐量。
                                    </p>
                                 </div>
                                 <p>假设您要将<code class="codeph">APPLIER</code>进程数从默认值5调整为20，同时将<code class="codeph">PREPARER</code>进程数保持为1。因为您必须满足以下等式：</p><pre class="oac_no_warn" dir="ltr">APPLY_SERVERS + PREPARE_SERVERS = MAX_SERVERS  -  3</pre><p>您必须先将<code class="codeph">MAX_SERVERS</code>设置为24。完成后，您可以将<code class="codeph">APPLY_SERVERS</code>的数量设置为20，如下所示：</p><pre class="oac_no_warn" dir="ltr">SQL&gt; EXECUTE DBMS_LOGSTDBY.APPLY_SET（'MAX_SERVERS'，24）; SQL&gt; EXECUTE DBMS_LOGSTDBY.APPLY_SET（'APPLY_SERVERS'，20）;</pre></div>
                           </li>
                        </ol>
                     </div>
                  </div><a id="SBYDB4843"></a><div class="props_rev_3"><a id="GUID-97300F48-66C4-4F9E-888D-DEFC0DDC10C8" name="GUID-97300F48-66C4-4F9E-888D-DEFC0DDC10C8"></a><h5 id="SBYDB-GUID-97300F48-66C4-4F9E-888D-DEFC0DDC10C8" class="sect5"><span class="enumeration_section">11.7.3.2</span>调整PREPARER进程数</h5>
                     <div>
                        <p>您很少需要调整<code class="codeph">PREPARER</code>进程的数量。在增加数量之前，您必须确保某些条件成立。
                        </p>
                        <div class="section">
                           <p>必须符合的条件如下：</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>所有<code class="codeph">PREPARER</code>流程都很忙</p>
                              </li>
                              <li>
                                 <p>准备应用的事务数小于可用的<code class="codeph">APPLIER</code>进程数</p>
                              </li>
                              <li>
                                 <p>有空闲的<code class="codeph">APPLIER</code>进程</p>
                              </li>
                           </ul>
                           <p>以下步骤说明如何确定这些条件为真：</p>
                        </div>
                        <!-- class="section" -->
                        <ol>
                           <li class="stepexpand"><span>确保所有<code class="codeph">PREPARER</code>进程都忙<a id="d26509e5824" class="indexterm-anchor"></a> ：</span><div><pre class="oac_no_warn" dir="ltr">SQL&gt; SELECT COUNT（*）AS IDLE_PREPARER  - &gt; FROM V $ LOGSTDBY_PROCESS  - &gt; WHERE TYPE ='PREPARER'和status_code = 16116; IDLE_PREPARER ------------- 0</pre></div>
                           </li>
                           <li class="stepexpand"><span>确保准备应用的事务数小于<code class="codeph">APPLIER</code>进程数：</span><div><pre class="oac_no_warn" dir="ltr">SQL&gt; SELECT NAME，VALUE FROM V $ LOGSTDBY_STATS WHERE NAME ='txns applied'OR  - &gt; NAME ='distinct txns in queue'; NAME VALUE --------------------- ------- txns在队列12896中应用了27892个不同的txns</pre><pre class="oac_no_warn" dir="ltr">SQL&gt; SELECT COUNT（*）AS APPLIER_COUNT  - &gt; FROM V $ LOGSTDBY_PROCESS WHERE TYPE ='APPLIER'; APPLIER_COUNT ------------- 20</pre><p>注意：多次发出此查询以确保这不是瞬态事件。</p>
                              </div>
                           </li>
                           <li class="stepexpand"><span>确保有空闲的<code class="codeph">APPLIER</code>进程：</span><div><pre class="oac_no_warn" dir="ltr">SQL&gt; SELECT COUNT（*）AS IDLE_APPLIER  - &gt; FROM V $ LOGSTDBY_PROCESS  - &gt; WHERE TYPE ='APPLIER'和status_code = 16116; IDLE_APPLIER ------------------------- 19</pre></div>
                           </li>
                        </ol>
                        <div class="section">
                           <p>在该示例中，已经满足增加<code class="codeph">PREPARER</code>过程数量所需的所有三个条件。假设您要将<code class="codeph">APPLIER</code>进程数设置为20，并将<code class="codeph">PREPARER</code>进程数从1增加到3。因为您总是必须满足以下等式：</p><pre class="oac_no_warn" dir="ltr">APPLY_SERVERS + PREPARE_SERVERS = MAX_SERVERS  -  3</pre><p>首先需要将<code class="codeph">MAX_SERVERS</code>的数量从24增加到26，以适应增加的编制者数量。然后，您可以增加<code class="codeph">PREPARER</code>进程的数量，如下所示：</p><pre class="oac_no_warn" dir="ltr">SQL&gt; EXECUTE DBMS_LOGSTDBY.APPLY_SET（'MAX_SERVERS'，26）; SQL&gt; EXECUTE DBMS_LOGSTDBY.APPLY_SET（'PREPARE_SERVERS'，3）;</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="SBYDB4844"></a><div class="props_rev_3"><a id="GUID-E856251B-C6AD-480A-9D9B-278BBF66688F" name="GUID-E856251B-C6AD-480A-9D9B-278BBF66688F"></a><h4 id="SBYDB-GUID-E856251B-C6AD-480A-9D9B-278BBF66688F" class="sect4"><span class="enumeration_section">11.7.4</span>调整用于LCR Cache的内存</h4>
                  <div>
                     <p>对于某些工作负载，SQL Apply可能会使用大量的pageout操作，从而降低了系统的整体吞吐量。增加分配给LCR缓存的内存可能会有所帮助。</p>
                     <div class="section">
                        <p>要确定分配给LCR缓存的增加内存是否有益，请执行以下步骤：</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>发出以下查询以获取pageout活动的快照：</span><div><pre class="oac_no_warn" dir="ltr">SQL&gt; SELECT NAME，VALUE FROM V $ LOGSTDBY_STATS WHERE NAME LIKE'％page％' - &gt; OR NAME LIKE'％uptime％'或NAME LIKE'％idle％';</pre><pre class="oac_no_warn" dir="ltr">NAME VALUE ---------------------------- -------------- coordinator uptime（seconds）894856页面调出20000页面时间（秒）2系统空闲时间（秒）1000</pre></div>
                        </li>
                        <li class="stepexpand"><span>在5分钟内再次发出查询：</span><div><pre class="oac_no_warn" dir="ltr">SQL&gt; SELECT NAME，VALUE FROM V $ LOGSTDBY_STATS WHERE NAME LIKE'％page％' - &gt; OR NAME LIKE'％uptime％'或NAME LIKE'％idle％';</pre><pre class="oac_no_warn" dir="ltr">NAME VALUE ---------------------------- -------------- coordinator uptime（seconds）895156页面调出1020000页面时间（秒）100系统空闲时间（秒）1000</pre></div>
                        </li>
                        <li class="stepexpand"><span>计算规范化的分页活动。例如：</span><div><pre class="oac_no_warn" dir="ltr">协调器正常运行时间的变化（C）=（895156  -  894856）= 300秒附加空闲时间的数量（I）=（1000  -  1000）= 0在页面输出中花费的时间的变化（P）=（100  -  2）= 98秒与正常运行时间相比的Pageout时间= P /（CI）= 98 / 300~32.67％</pre></div>
                        </li>
                     </ol>
                     <div class="section">
                        <p>理想情况下，页面输出活动不应占用总运行时间的5％以上。如果您继续在延长的时间间隔内拍摄快照，并且发现页面输出活动继续占用应用时间的很大一部分，则增加内存大小可能会带来一些好处。您可以通过设置分配给LCR缓存的内存来增加分配给SQL Apply的内存（对于此示例，SGA设置为1 GB）：</p><pre class="oac_no_warn" dir="ltr">SQL&gt; EXECUTE DBMS_LOGSTDBY.APPLY_SET（'MAX_SGA'，1024）; PL / SQL过程成功完成</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="SBYDB4845"></a><div class="props_rev_3"><a id="GUID-486200D3-C7A5-4B21-9C81-FC654AD405DD" name="GUID-486200D3-C7A5-4B21-9C81-FC654AD405DD"></a><h4 id="SBYDB-GUID-486200D3-C7A5-4B21-9C81-FC654AD405DD" class="sect4"><span class="enumeration_section">11.7.5</span>调整如何在逻辑备用数据库上应用事务</h4>
                  <div>
                     <p>默认情况下，事务将按照它们在主数据库上提交的确切顺序应用于逻辑备用数据库。</p>
                     <div class="section">
                        <p>提交事务的严格默认顺序允许任何应用程序在逻辑备用数据库上透明地运行。</p>
                        <p>但是，许多应用程序不需要在所有事务中进行如此严格的排序。此类应用程序不需要以与在主数据库中提交的顺序相同的顺序提交包含非重叠行集的事务。这种不太严格的排序通常会导致逻辑备用数据库的应用率更高。您可以通过执行以下步骤来更改提交事务的默认顺序：</p>
                        <ol>
                           <li>
                              <p>停止SQL应用：</p><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER DATABASE STOP LOGICAL STANDBY APPLY;数据库改变了</pre></li>
                           <li>
                              <p>发出以下命令以允许事务从主数据库上的提交方式中不按顺序应用：</p><pre class="oac_no_warn" dir="ltr">SQL&gt; EXECUTE DBMS_LOGSTDBY.APPLY_SET（'PRESERVE_COMMIT_ORDER'，'FALSE'）; PL / SQL过程成功完成</pre></li>
                           <li>
                              <p>启动SQL Apply：</p><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER DATABASE START LOGICAL STANDBY立即申请;数据库改变了</pre></li>
                        </ol>
                        <p>您可以按如下方式更改应用模式：</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>停止SQL应用：</span><div><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER DATABASE STOP LOGICAL STANDBY APPLY;数据库改变了</pre></div>
                        </li>
                        <li class="stepexpand"><span>恢复<code class="codeph">PRESERVE_COMMIT_ORDER</code>参数的默认值：</span><div><pre class="oac_no_warn" dir="ltr">SQL&gt; EXECUTE DBMS_LOGSTDBY.APPLY_UNSET（'PRESERVE_COMMIT_ORDER'）; PL / SQL过程成功完成</pre></div>
                        </li>
                        <li class="stepexpand"><span>启动SQL Apply：</span><div><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER DATABASE START LOGICAL STANDBY立即申请;数据库改变了</pre><p>对于典型的联机事务处理（OLTP）工作负载，非默认模式可以提供比默认应用模式高50％或更高的吞吐量改进。</p>
                           </div>
                        </li>
                     </ol>
                  </div>
               </div>
            </div><a id="SBYDB5050"></a><a id="SBYDB5051"></a><a id="SBYDB5052"></a><a id="SBYDB5053"></a><a id="SBYDB4846"></a><div class="props_rev_3"><a id="GUID-4A691CE0-7424-4547-800E-0C9D606F0607" name="GUID-4A691CE0-7424-4547-800E-0C9D606F0607"></a><h3 id="SBYDB-GUID-4A691CE0-7424-4547-800E-0C9D606F0607" class="sect3"><span class="enumeration_section">11.8</span>逻辑备用数据库环境中的备份和恢复</h3>
               <div>
                  <p>您可以使用可用的传统方法备份逻辑备用数据库，然后通过还原数据库备份并在归档日志上执行介质恢复以及备份来恢复它。</p>
                  <p>以下各项与逻辑备用数据库的上下文相关。</p>
                  <div class="section">
                     <p class="subhead2" id="GUID-4A691CE0-7424-4547-800E-0C9D606F0607__GUID-6DDCD88E-7245-4995-9DDC-DDC93FBBFA4B">创建和使用本地RMAN恢复目录时的注意事项</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p>如果计划创建RMAN恢复目录或执行修改目录的任何RMAN活动，则必须在逻辑备用数据库中将<code class="codeph">GUARD</code>设置为<code class="codeph">STANDBY</code>运行。
                     </p>
                     <p>如果本地恢复目录仅保留在逻辑备用控制文件中，则可以将<code class="codeph">GUARD</code>设置为<code class="codeph">ALL</code> 。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-4A691CE0-7424-4547-800E-0C9D606F0607__GUID-0FBF01B3-2B27-446E-8860-C69FBE8B608B">控制文件备份的注意事项</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p>Oracle建议您在实例化逻辑备用数据库后立即进行控制文件备份。</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-4A691CE0-7424-4547-800E-0C9D606F0607__GUID-99B62329-B7D2-4B0A-A1E8-95506049B107">时间点恢复的注意事项</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p>在时间点恢复之后第一次启动SQL Apply时，它必须能够在本地系统上查找所需的存档日志或从主数据库中获取它们。使用<code class="codeph">V$LOGSTDBY_PROCESS</code>视图确定是否需要在主数据库上还原任何已归档日志。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-4A691CE0-7424-4547-800E-0C9D606F0607__GUID-9D5B3032-D8AB-4889-BA73-B0DB1A478B95">表空间时间点恢复的注意事项</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p>如果对逻辑备用数据库中的表空间执行时间点恢复，则必须确保满足以下条件之一：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>表空间不包含SQL Apply进程正在维护的表或分区</p>
                        </li>
                        <li>
                           <p>如果表空间包含由SQL Apply进程维护的表或分区，则使用<code class="codeph">DBMS_LOGSTDBY.INSTANTIATE_TABL</code> E过程重新实例化逻辑备用数据库中恢复的表空间中包含的所有维护表，或使用<code class="codeph">DBMS_LOGSTDBY.SKIP</code>过程注册要从逻辑备用数据库的维护表列表中跳过的已恢复表空间中包含的所有表。
                           </p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
               </div>
            </div>
         </div>
      </article>
   </body>
</html>