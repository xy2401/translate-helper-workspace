<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <title>高级主题</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Programmer&#39;s Guide"></meta>
      <meta property="og:description" content=""></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Programmer&#39;s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="c-c-programmers-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-11T03:52:01-08:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="1996, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96467-01"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="datatypes-and-host-variables.html" title="Previous" type="text/html"></link>
      <link rel="next" href="embedded-SQL.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Pro*C/C++ Programmer&#39;s Guide"></meta>
    <meta name="dcterms.isVersionOf" content="LNPCC"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="datatypes-and-host-variables.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="embedded-SQL.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">程序员指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="introduction-and-concepts.html" property="item" typeof="WebPage"><span property="name">介绍和概念</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">高级主题</li>
            </ol>
            <a id="GUID-51D6F725-4F87-4A9E-84FF-EC0A6D90F9A5" name="GUID-51D6F725-4F87-4A9E-84FF-EC0A6D90F9A5"></a><a id="LNPCC3253"></a>
            
            <h2 id="LNPCC-GUID-51D6F725-4F87-4A9E-84FF-EC0A6D90F9A5" class="sect2"><span class="enumeration_chapter">5</span>高级主题</h2>
         </header>
         <div class="ind">
            <div>
               <p>本章讨论Pro * C / C ++中的高级技术，包含以下主题：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="advanced-topics.html#GUID-EA7AF005-2D83-45C4-B248-CDD631D6F616">人物数据</a></p>
                  </li>
                  <li>
                     <p><a href="advanced-topics.html#GUID-84120650-DFD4-4623-B1ED-722CC4563DAC">数据类型转换</a></p>
                  </li>
                  <li>
                     <p><a href="advanced-topics.html#GUID-3D21E7F4-A0D0-4961-9669-ABF8A2739A90">数据类型等价</a></p>
                  </li>
                  <li>
                     <p><a href="advanced-topics.html#GUID-6E07C0B8-8C43-440D-A0C1-D30B5A58C2B2">C预处理器</a></p>
                  </li>
                  <li>
                     <p><a href="advanced-topics.html#GUID-C2EE702D-5EC9-4522-ABC9-43C85A984D3B">预编译的头文件</a></p>
                  </li>
                  <li>
                     <p><a href="advanced-topics.html#GUID-D4E3B927-B812-4BAB-BAA3-F9543F151F89">Oracle预处理器</a></p>
                  </li>
                  <li>
                     <p><a href="advanced-topics.html#GUID-1C948990-B5FF-411D-BAC3-930E2FE82972">数值常数的评估</a></p>
                  </li>
                  <li>
                     <p><a href="advanced-topics.html#GUID-5A1F44A6-4B41-4610-B265-C56C85261379">用于OCI版本8互操作性的SQLLIB扩展</a></p>
                  </li>
                  <li>
                     <p><a href="advanced-topics.html#GUID-06CCA89B-2D4C-4540-AC72-CFE65735EB58">与OCI版本8的接口</a></p>
                  </li>
                  <li>
                     <p><a href="advanced-topics.html#GUID-B98BBAC5-9F84-4705-8802-16BA852B4B45">嵌入式OCI第7版电话</a></p>
                  </li>
                  <li>
                     <p><a href="advanced-topics.html#GUID-3B79020D-735A-47A9-84DA-401D86E8F712">SQLLIB公共函数的新名称</a></p>
                  </li>
                  <li>
                     <p><a href="advanced-topics.html#GUID-A05AE487-C0BA-43DB-B8DE-DFFEE7E60207">X / Open应用程序开发</a></p>
                  </li>
               </ul>
            </div><a id="LNPCC3254"></a><div class="props_rev_3"><a id="GUID-EA7AF005-2D83-45C4-B248-CDD631D6F616" name="GUID-EA7AF005-2D83-45C4-B248-CDD631D6F616"></a><h3 id="LNPCC-GUID-EA7AF005-2D83-45C4-B248-CDD631D6F616" class="sect3"><span class="enumeration_section">5.1</span>字符数据</h3>
               <div>
                  <p>本节介绍Pro * C / C ++预编译器如何处理字符主机变量。有四种主机变量字符类型：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>字符数组</p>
                     </li>
                     <li>
                        <p>指向字符串的指针</p>
                     </li>
                     <li>
                        <p>VARCHAR变量</p>
                     </li>
                     <li>
                        <p>指向VARCHAR的指针</p>
                     </li>
                  </ul>
                  <p>不要将VARCHAR（预编译器提供的主机变量数据结构）与VARCHAR2（可变长度字符串的Oracle内部数据类型）混淆。</p>
               </div><a id="LNPCC3256"></a><a id="LNPCC3255"></a><div class="props_rev_3"><a id="GUID-B1D5E862-13FA-429B-9492-40785377256E" name="GUID-B1D5E862-13FA-429B-9492-40785377256E"></a><h4 id="LNPCC-GUID-B1D5E862-13FA-429B-9492-40785377256E" class="sect4"><span class="enumeration_section">5.1.1</span>预编译器选项CHAR_MAP</h4>
                  <div>
                     <p>CHAR_MAP预编译器选项可用于指定char [n]和char主机变量的默认映射。Oracle将它们映射到CHARZ。 CHARZ实现ANSI固定字符格式。字符串是固定长度，空白填充和空终止。VARCHAR2值（包括空值）始终是固定长度和空白填充。<a href="advanced-topics.html#GUID-B1D5E862-13FA-429B-9492-40785377256E__BABIDDHA" title="CHAR_MAP设置">表5-1</a>显示了CHAR_MAP的可能设置：</p>
                     <div class="tblformal" id="GUID-B1D5E862-13FA-429B-9492-40785377256E__BABIDDHA">
                        <p class="titleintable">表5-1 CHAR_MAP设置</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="CHAR_MAP设置" width="100%" border="1" summary="CHAR_MAP Settings" frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="29%" id="d24171e137">CHAR_MAP设置</th>
                                 <th align="left" valign="bottom" width="23%" id="d24171e140">是默认的</th>
                                 <th align="left" valign="bottom" width="48%" id="d24171e143">描述</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d24171e148" headers="d24171e137 ">
                                    <p>VARCHAR2</p>
                                 </td>
                                 <td align="left" valign="top" width="23%" headers="d24171e148 d24171e140 ">
                                    <p>-</p>
                                 </td>
                                 <td align="left" valign="top" width="48%" headers="d24171e148 d24171e143 ">
                                    <p>所有值（包括null）都是固定长度的空白填充。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d24171e158" headers="d24171e137 ">
                                    <p>CHARZ</p>
                                 </td>
                                 <td align="left" valign="top" width="23%" headers="d24171e158 d24171e140 ">
                                    <p>DBMS = V7，DBMS = V8</p>
                                 </td>
                                 <td align="left" valign="top" width="48%" headers="d24171e158 d24171e143 ">
                                    <p>固定长度空白填充，然后空终止。符合ANSI固定字符类型。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d24171e168" headers="d24171e137 ">
                                    <p>串</p>
                                 </td>
                                 <td align="left" valign="top" width="23%" headers="d24171e168 d24171e140 ">
                                    <p>新格式</p>
                                 </td>
                                 <td align="left" valign="top" width="48%" headers="d24171e168 d24171e143 ">
                                    <p>空值终止。符合C程序中使用的ASCII格式。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d24171e178" headers="d24171e137 ">
                                    <p>CHARF</p>
                                 </td>
                                 <td align="left" valign="top" width="23%" headers="d24171e178 d24171e140 ">
                                    <p>以前，只能通过VAR或TYPE声明。</p>
                                 </td>
                                 <td align="left" valign="top" width="48%" headers="d24171e178 d24171e143 ">
                                    <p>定长空白填充。 null保持未填充状态。</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <p>默认映射是CHAR_MAP = CHARZ，这是以前版本的Pro * C / C ++中的情况。</p>
                     <p>使用CHAR_MAP = VARCHAR2而不是旧的DBMS = V6_CHAR，这是过时的。</p>
                  </div>
               </div><a id="LNPCC3257"></a><div class="props_rev_3"><a id="GUID-ECE7E41D-74BA-40A5-BBB5-B041E2825EBF" name="GUID-ECE7E41D-74BA-40A5-BBB5-B041E2825EBF"></a><h4 id="LNPCC-GUID-ECE7E41D-74BA-40A5-BBB5-B041E2825EBF" class="sect4"><span class="enumeration_section">5.1.2</span> CHAR_MAP选项的内联使用</h4>
                  <div>
                     <p>除非您另外声明了char或char [n]变量，否则内联CHAR_MAP选项将确定其映射。以下代码片段说明了在Pro * C / C ++中内联设置此选项的结果：</p><pre class="oac_no_warn" dir="ltr">char ch_array [5]; strncpy（ch_array，“12345”，5）; / * char_map = charz是Oracle7和Oracle8 * / EXEC ORACLE OPTION（char_map = charz）中的默认值; / * select从数据库* / SQL SELECT中检索字符串“AB”...INTO：ch_array FROM ...在哪里......; / * ch_array == {'A'，'B'，''，''，'\ 0'} * / strncpy（ch_array，“12345”，5）; EXEC ORACLE OPTION（char_map = string）; / * select从数据库中检索字符串“AB”* / EXEC SQL SELECT ...INTO：ch_array FROM ...在哪里......; / * ch_array == {'A'，'B'，'\ 0'，'4'，'5'} * / strncpy（ch_array，“12345”，5）; EXEC ORACLE OPTION（char_map = charf）; / * select从数据库中检索字符串“AB”* / EXEC SQL SELECT ...INTO：ch_array FROM ...在哪里......; / * ch_array == {'A'，'B'，''，''，''} * /</pre></div>
               </div><a id="LNPCC3258"></a><div class="props_rev_3"><a id="GUID-496E3205-71A3-44D6-91A5-0523903E24B9" name="GUID-496E3205-71A3-44D6-91A5-0523903E24B9"></a><h4 id="LNPCC-GUID-496E3205-71A3-44D6-91A5-0523903E24B9" class="sect4"><span class="enumeration_section">5.1.3</span> DBMS和CHAR_MAP选项的影响</h4>
                  <div>
                     <p>DBMS和CHAR_MAP选项确定Pro * C / C ++如何处理字符数组和字符串中的数据。这些选项允许程序观察与ANSI固定长度字符串的兼容性，或保持与使用可变长度字符串的Oracle和Pro * C / C ++的早期版本的兼容性。</p>
                     <p>DBMS选项会影响输入（从主机变量到Oracle表）和输出（从Oracle表到主变量）的字符数据。</p>
                     <p><span class="bold">字符数组和CHAR_MAP选项</span></p>
                     <p>字符数组的映射也可以由CHAR_MAP选项设置，与DBMS选项无关。DBMS = V7或DBMS = V8都使用CHAR_MAP = CHARZ，可以通过指定CHAR_MAP = VARCHAR2或STRING或CHARF来覆盖它。</p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="precompiler-options.html#GUID-43E60380-8B54-4528-A76F-5A78A46F05D4">预编译器选项</a></li>
                        </ul>
                     </div>
                  </div>
                  <a id="LNPCC3260"></a><a id="LNPCC3261"></a><a id="LNPCC3259"></a><div class="props_rev_3"><a id="GUID-AD81DAAD-6F68-4B82-AAAA-A7B918B2077E" name="GUID-AD81DAAD-6F68-4B82-AAAA-A7B918B2077E"></a><h5 id="LNPCC-GUID-AD81DAAD-6F68-4B82-AAAA-A7B918B2077E" class="sect5"><span class="enumeration_section">5.1.3.1</span>输入</h5>
                     <div>
                        <div class="section">
                           <p class="subhead3" id="GUID-AD81DAAD-6F68-4B82-AAAA-A7B918B2077E__GUID-9619F88A-1CA4-46BB-B1B2-893A2777F9BF">字符数组</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p>在输入时，DBMS选项确定主机变量字符数组在程序中必须具有的格式。当CHAR_MAP = VARCHAR2时，主机变量字符数组必须为空白填充，并且不应以空值终止。当DBMS = V7或V8时，字符数组必须以空值终止（'\ 0'）。</p>
                           <p>当CHAR_MAP选项设置为VARCHAR2时，在将值发送到数据库之前，将删除尾随空白到第一个非空白字符。未初始化的字符数组可以包含空字符。要确保未将空值插入表中，必须将字符数组空白填充到其长度。例如，如果执行语句：</p><pre class="oac_no_warn" dir="ltr">char emp_name [10]; ...strcpy（emp_name，“MILLER”）; / *错了！注意没有空白填充* / EXEC SQL INSERT INTO emp（empno，ename，deptno）VALUES（1234，：emp_name，20）;</pre><p>你会发现字符串“MILLER”被插入为“MILLER \ 0 \ 0 \ 0 \ 0”（附加了四个空字节）。此值不符合以下搜索条件：</p><pre class="oac_no_warn" dir="ltr">。 。 。在哪里ename ='MILLER';</pre><p>要在CHAR_MAP设置为VARCHAR2时插入字符数组，应执行语句</p><pre class="oac_no_warn" dir="ltr">strncpy（emp_name，“MILLER”，10）; / * 4个尾随空格* / EXEC SQL INSERT INTO emp（empno，ename，deptno）VALUES（1234，：emp_name，20）;</pre><p>当DBMS = V7或V8时，字符数组中的输入数据必须以空值终止。因此，请确保您的数据以null结尾。</p><pre class="oac_no_warn" dir="ltr">char emp_name [11]; / *注意：比列大小大10 * / ...strcpy（emp_name，“MILLER”）; / *不需要空格填充* / EXEC SQL INSERT INTO \ temp（empno，ename，deptno）VALUES（1234，：emp_name，20）;</pre></div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-AD81DAAD-6F68-4B82-AAAA-A7B918B2077E__GUID-AD18EF65-F221-4168-A596-A4056EA834F6">字符指针</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p>指针必须寻址一个足以容纳输入数据的空终止缓冲区。您的程序必须分配足够的内存来执行此操作。</p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNPCC3262"></a><div class="props_rev_3"><a id="GUID-F2549581-5156-42B6-BA00-5D8F8DD50E7B" name="GUID-F2549581-5156-42B6-BA00-5D8F8DD50E7B"></a><h5 id="LNPCC-GUID-F2549581-5156-42B6-BA00-5D8F8DD50E7B" class="sect5"><span class="enumeration_section">5.1.3.2</span>输入</h5>
                     <div>
                        <p>以下示例说明了CHAR_MAP选项设置对从数据库检索到的值到字符数组的影响的所有可能组合。</p>
                        <p>假设一个数据库</p><pre class="oac_no_warn" dir="ltr">TABLE strdbase（...，strval VARCHAR2（6））;</pre><p>其中包含strage列中的以下字符串：</p><pre class="oac_no_warn" dir="ltr">“” - 长度为0“AB”的字符串 - 长度为2的字符串“KING” - 长度为4的字符串“QUEEN” - 长度为5“MILLER”的字符串 - 长度为6的字符串</pre><p>在Pro * C / C ++程序中，使用“X”字符初始化5个字符的主机数组<span class="italic">str</span> ，并用于检索列strval中的所有值：</p><pre class="oac_no_warn" dir="ltr">char str [5] = {'X'，'X'，'X'，'X'，'X'};短str_ind; ...EXEC SQL SELECT strval INTO：str：str_ind WHERE ...;</pre><p>对于数组，str和指示符变量str_ind的结果如下，因为CHAR_MAP设置为VARCHAR2，CHARF，CHARZ和STRING：</p><pre class="oac_no_warn" dir="ltr">strval =“”“AB”“KING”“QUEEN”“MILLER”---------------------------------- ----------------------------- VARCHAR2“”-1“AB”0“KING”0“QUEEN”0“MILLE”6 CHARF“XXXXX”-1“AB”0“KING”0“QUEEN”0“MILLE”6 CHARZ“0”-1“AB 0”0“KING0”0“QUEE0”5“MILL0”6 STRING“0XXXX” - 1“AB0XX”0“KING0”0“QUEE0”5“MILL0”6</pre><p>其中0代表空字符'\ 0'。</p>
                     </div>
                  </div><a id="LNPCC3264"></a><a id="LNPCC3265"></a><a id="LNPCC3263"></a><div class="props_rev_3"><a id="GUID-F16E2C92-C93B-403E-8B14-EE32781B441C" name="GUID-F16E2C92-C93B-403E-8B14-EE32781B441C"></a><h5 id="LNPCC-GUID-F16E2C92-C93B-403E-8B14-EE32781B441C" class="sect5"><span class="enumeration_section">5.1.3.3</span>关于输出</h5>
                     <div>
                        <div class="section">
                           <p class="subhead3" id="GUID-F16E2C92-C93B-403E-8B14-EE32781B441C__GUID-FE2AFA92-4A3A-40EB-84D8-F19B146A4F48">字符数组</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p>在输出时，DBMS和CHAR_MAP选项确定主机变量字符数组在程序中将具有的格式。当CHAR_MAP = VARCHAR2时，主机变量字符数组空白填充到数组的长度，但从不以空值终止。当DBMS = V7或V8（或CHAR_MAP = CHARZ）时，字符数组为空白填充，然后在数组的最终位置以空值终止。</p>
                           <p>请考虑以下字符输出示例：</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE test_char（C_col CHAR（10），V_col VARCHAR2（10））; INSERT INTO test_char VALUES（'MILLER'，'KING'）;</pre><p>从该表中选择的预编译器程序包含以下嵌入式SQL：</p><pre class="oac_no_warn" dir="ltr">...char name1 [10]; char name2 [10]; ...EXEC SQL SELECT C_col，V_col INTO：name1，：name2 FROM test_char;</pre><p>如果使用CHAR_MAP = VARCHAR2预编译程序，则<span class="italic">name1</span>将包含：</p><pre class="oac_no_warn" dir="ltr">“磨坊主＃＃＃＃”</pre><p>也就是说，名称“MILLER”后跟4个空格，没有空终止。（如果声明<span class="italic">name1</span>的大小为15，则名称后面会有9个空格。）
                           </p>
                           <p><span class="italic">name2</span>将包含：</p><pre class="oac_no_warn" dir="ltr">“KING ######”/ * 6尾随空白* /</pre><p>如果使用DBMS = V7或V8预编译程序，则<span class="italic">name1</span>将包含：</p><pre class="oac_no_warn" dir="ltr">“MILLER ### \ 0”/ * 3尾随空白，然后是空终止符* /</pre><p>也就是说，一个包含名称的字符串，空白填充到列的长度，后跟一个空终止符。 <span class="italic">name2</span>将包含：</p><pre class="oac_no_warn" dir="ltr">“KING ##### \ 0”</pre><p>总之，如果CHAR_MAP = VARCHAR2，则CHARACTER列或VARCHAR2列的输出将填充为主变量数组的长度。如果DBMS = V7或V8，则输出字符串始终以空值终止。</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-F16E2C92-C93B-403E-8B14-EE32781B441C__GUID-78A881CA-6481-4B5D-B858-8AF5EF703E1C">字符指针</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p>DBMS和CHAR_MAP选项不会影响字符数据输出到指针主机变量的方式。</p>
                           <p>当您将数据输出到字符指针主变量时，指针必须指向足够大的缓冲区来保存表的输出，再加上一个额外的字节来保存空终止符。</p>
                           <p>预编译器运行时环境调用<code class="codeph">strlen()</code>来确定输出缓冲区的大小，因此请确保缓冲区不包含任何嵌入的空值（'\ 0'）。在获取数据之前，使用“\ 0”以外的某个值填充已分配的缓冲区，然后对缓冲区进行空终止。
                           </p>
                           <div class="infoboxnote" id="GUID-F16E2C92-C93B-403E-8B14-EE32781B441C__GUID-4A7CF79C-EDFE-4DBE-AC07-B0D5E80EB2B9">
                              <p class="notep1">注意：</p>
                              <p>C指针可以在Pro * C / C ++程序中使用，该程序使用DBMS = V7或V8和MODE = ANSI进行预编译。但是，指针在SQL标准兼容程序中不是合法的主机变量类型。如果您使用指针作为主变量，FIPS标记器会发出警告。<a id="d24171e380" class="indexterm-anchor"></a></p>
                           </div>
                           <p>以下代码片段使用上一节中定义的列和表，并显示如何声明和SELECT到字符指针主机变量：</p><pre class="oac_no_warn" dir="ltr">...char * p_name1; char * p_name2; ...p_name1 =（char *）malloc（11）; p_name2 =（char *）malloc（11）; strcpy（p_name1，“”）; strcpy（p_name2，“0123456789”）; EXEC SQL SELECT C_col，V_col INTO：p_name1，：p_name2 FROM test_char;</pre><p>当使用任何DBMS或CHAR_MAP设置执行前面提到的SELECT语句时，获取的值为：</p><pre class="oac_no_warn" dir="ltr">“MILLER #### \ 0”/ * 4尾随空白和空终结符* /“KING ###### \ 0”/ * 6空白和null * /</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="LNPCC3266"></a><div class="props_rev_3"><a id="GUID-6601390B-56D8-47DA-AEA1-982AEFA8E498" name="GUID-6601390B-56D8-47DA-AEA1-982AEFA8E498"></a><h4 id="LNPCC-GUID-6601390B-56D8-47DA-AEA1-982AEFA8E498" class="sect4"><span class="enumeration_section">5.1.4</span> VARCHAR变量和指针</h4>
                  <div>
                     <p>以下示例显示如何声明VARCHAR主机变量：<a id="d24171e403" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">VARCHAR emp_name1 [10]; / * VARCHAR变量* / VARCHAR * emp_name2; / *指向VARCHAR的指针* /</pre></div><a id="LNPCC3268"></a><a id="LNPCC3269"></a><a id="LNPCC3267"></a><div class="props_rev_3"><a id="GUID-FDC22564-2421-459E-A27A-35574AF36566" name="GUID-FDC22564-2421-459E-A27A-35574AF36566"></a><h5 id="LNPCC-GUID-FDC22564-2421-459E-A27A-35574AF36566" class="sect5"><span class="enumeration_section">5.1.4.1</span>输入</h5>
                     <div>
                        <div class="section">
                           <p class="subhead3" id="GUID-FDC22564-2421-459E-A27A-35574AF36566__GUID-12731BD2-E774-49C6-8CFC-7064D689DE48">VARCHAR变量</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p>当您使用VARCHAR变量作为输入主变量时，您的程序只需要将所需的字符串放在展开的VARCHAR声明的数组成员中（在我们的示例中为<span class="italic">emp_name1.arr</span> ）并设置length成员（ <span class="italic">emp_name1.len</span> ）。无需对数组进行空白填充。确切地将<span class="italic">emp_name1.len</span>字符发送到Oracle，计算任何空白和空值。在以下示例中，将<span class="italic">emp_name1.len</span>设置为8：</p><pre class="oac_no_warn" dir="ltr">strcpy（（char *）emp_name1.arr，“VAN HORN”）; emp_name1.len = strlen（（char *）emp_name1.arr）;</pre></div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-FDC22564-2421-459E-A27A-35574AF36566__GUID-2BBF9C9D-4BBA-4343-A082-FA91E3B4955E">指向VARCHAR的指针</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p>使用指向VARCHAR的指针作为输入主机变量时，必须为扩展的VARCHAR声明分配足够的内存。然后，您必须将所需的字符串放在数组成员中并设置length成员，如以下示例所示：</p><pre class="oac_no_warn" dir="ltr">emp_name2 = malloc（sizeof（short）+ 10）/ * len + arr * / strcpy（（char *）emp_name2-&gt; arr，“MILLER”）; emp_name2-&gt; len = strlen（（char *）emp_name2-&gt; arr）;</pre><p>或者，要使<span class="italic">emp_name2</span>指向现有的VARCHAR（在本例中为<span class="italic">emp_name1</span> ），您可以对赋值进行编码</p><pre class="oac_no_warn" dir="ltr">emp_name2 =＆emp_name1;</pre><p>然后以通常的方式使用VARCHAR指针，如</p><pre class="oac_no_warn" dir="ltr">EXEC SQL INSERT INTO EMP（EMPNO，ENAME，DEPTNO）VALUES（：emp_number，：emp_name2，：dept_number）;</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNPCC3271"></a><a id="LNPCC3272"></a><a id="LNPCC3270"></a><div class="props_rev_3"><a id="GUID-E00C6F83-3C2E-4A64-BB45-C047AFB41599" name="GUID-E00C6F83-3C2E-4A64-BB45-C047AFB41599"></a><h5 id="LNPCC-GUID-E00C6F83-3C2E-4A64-BB45-C047AFB41599" class="sect5"><span class="enumeration_section">5.1.4.2</span>关于输出</h5>
                     <div>
                        <div class="section">
                           <p class="subhead3" id="GUID-E00C6F83-3C2E-4A64-BB45-C047AFB41599__GUID-8D0CADBB-34A7-4E52-84B1-6F37FDAD1C14">VARCHAR变量</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p>当使用VARCHAR变量作为输出主变量，程序接口设置长度部件但<span class="italic">不</span>空终止阵列成员。与字符数组，程序可以将它传递给函数，如之前用空字符结束一个VARCHAR变量的<span class="italic">ARR</span>构件<code class="codeph">printf()</code>或<code class="codeph">strlen()</code>一个例子如下：</p><pre class="oac_no_warn" dir="ltr">emp_name1.arr [emp_name1.len] ='\ 0'; printf（“％s”，emp_name1.arr）;</pre><p>或者，您可以使用length成员来限制字符串的打印，如下所示：</p><pre class="oac_no_warn" dir="ltr">printf（“％。* s”，emp_name1.len，emp_name1.arr）;</pre><p>VARCHAR变量优于字符数组的一个优点是Oracle返回的值的长度可立即获得。对于字符数组，您可能需要自己去除尾随空白以获取字符串的实际长度。 <a id="d24171e499" class="indexterm-anchor"></a> 
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-E00C6F83-3C2E-4A64-BB45-C047AFB41599__GUID-3DBF4759-843F-405E-BB15-8CD1AFFBCEA0">VARCHAR指针</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p>当您使用指向VARCHAR的指针作为输出主机变量时，程序接口通过检查length成员（在我们的示例中为<span class="italic">emp_name2-&gt; len</span> ）来确定变量的最大长度。因此，您的程序必须在<span class="italic">每次</span>获取之前设置此成员。然后，fetch将length成员设置为返回的实际字符数，如以下示例所示：</p><pre class="oac_no_warn" dir="ltr">emp_name2-&gt; len = 10; / *设置缓冲区的最大长度。* / EXEC SQL SELECT ENAME INTO：emp_name2 WHERE EMPNO = 7934; printf（“％d个字符返回emp_name2”，emp_name2-&gt; len）;</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="LNPCC3273"></a><div class="props_rev_3"><a id="GUID-D0A4D9AF-7D6B-4B1C-AEA1-373B9CE6A1D3" name="GUID-D0A4D9AF-7D6B-4B1C-AEA1-373B9CE6A1D3"></a><h4 id="LNPCC-GUID-D0A4D9AF-7D6B-4B1C-AEA1-373B9CE6A1D3" class="sect4"><span class="enumeration_section">5.1.5</span> Unicode变量</h4>
                  <div>
                     <p>Pro * C / C ++允许在主机<code class="codeph">char</code>变量中使用固定宽度的Unicode数据（字符集Unicode标准版本3.0，简称为UCS-16）。UCS-16为每个字符使用2个字节，因此它是无符号的2字节数据类型。尚不支持UCS-16中的SQL语句文本。
                     </p>
                     <p>在以下示例代码中，Unicode类型<span class="italic">utext</span>的主机变量<code class="codeph">employee</code>被声明为<span class="italic">长度</span>为20个Unicode字符。创建一个表<code class="codeph">emp</code> ，其中包含60个字节长的列<code class="codeph">ename</code> ，因此将支持亚洲语言中的数据库字符集，其中多字节字符长达三个字节。
                     </p><pre class="oac_no_warn" dir="ltr">utext员工[20]; / * Unicode主变量* / EXEC SQL CREATE TABLE \ temp（ename CHAR（60））; / * ename是当前数据库中的字符集* / EXEC SQL INSERT INTO \ temp（ename）VALUES（'test'）; / *'test'在NLS_LANG编码中转换为数据库字符集* / EXEC SQL SELECT * INTO：employee FROM emp; / *数据库字符集转换为Unicode * /</pre><p>公共头文件sqlucs2.h必须包含在应用程序代码中。它执行以下操作：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>包含声明：</p>
                        </li>
                     </ul><pre class="oac_no_warn" dir="ltr">#include &lt;oratypes.h&gt;</pre><ul style="list-style-type:disc">
                        <li>
                           <p>将“Unicode varchar”定义为uvarchar，如下所示：</p>
                        </li>
                     </ul><pre class="oac_no_warn" dir="ltr">struct uvarchar {ub2 len; utext arr [1]; }; typedef struct uvarchar uvarchar;</pre><ul style="list-style-type:disc">
                        <li>
                           <p>定义“Unicode long varchar”，ulong_varchar，如下所示：</p>
                        </li>
                     </ul><pre class="oac_no_warn" dir="ltr">struct ulong_varchar {ub4 len; utext arr [1]; } typedef struct ulong_varchar ulong_varchar;</pre><p>utext的默认数据类型与任何字符变量CHARZ的默认数据类型相同，CHARZ是空白填充和以空值终止的。</p>
                     <p>使用CHAR_MAP预编译器选项更改默认数据类型，如下所示：</p><pre class="oac_no_warn" dir="ltr">#include &lt;sqlca.h&gt; #include &lt;sqlucs2.h&gt; main（）{utext employee1 [20]; / *更改为STRING数据类型：* / EXEC ORACLE OPTION（CHAR_MAP = STRING）; utext employee2 [20]; EXEC SQL CREATE TABLE \ temp（ename CHAR（60））; .../ ******************* **********初始化employee1或employee2是依赖于编译器的。************************************************** ******** / EXEC SQL INSERT INTO \ temp（ename）VALUES（：employee1）; ...EXEC SQL SELECT ename INTO：employee2 FROM emp; / * employee2现在不是空白填充，并且以null结尾* / ...</pre></div><a id="LNPCC3274"></a><div class="props_rev_3"><a id="GUID-621A2720-9724-400D-94DD-A42A08C10955" name="GUID-621A2720-9724-400D-94DD-A42A08C10955"></a><h5 id="LNPCC-GUID-621A2720-9724-400D-94DD-A42A08C10955" class="sect5"><span class="enumeration_section">5.1.5.1</span> Unicode变量用法的限制</h5>
                     <div>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>静态和动态SQL不能在SQL语句文本中包含Unicode。以下是<span class="italic">不允许</span>的：</p>
                           </li>
                        </ul><pre class="oac_no_warn" dir="ltr">#include oratypes.h utext sqlstmt [100]; .../ *如果sqlstmt包含SQL语句：* / EXEC SQL PREPARE s1 FROM：sqlstmt; EXEC SQL EXECUTE IMMEDIATE：sqlstmt; ...
</pre><ul style="list-style-type:disc">
                           <li>
                              <p>您不能对utext变量使用类型等效。下面的代码是<span class="italic">不允许</span>的：</p>
                           </li>
                        </ul><pre class="oac_no_warn" dir="ltr">typedef utext utext_5; EXEC SQL TYPE utext_5 IS STRING;</pre><ul style="list-style-type:disc">
                           <li>
                              <p>CONVBUFSZ不能用作转换缓冲区大小。请改用CHAR_MAP选项。</p>
                           </li>
                           <li>
                              <p>Oracle动态SQL方法4不支持Unicode。</p>
                           </li>
                           <li>
                              <p>对象类型不支持Unicode。</p>
                           </li>
                        </ul>
                     </div>
                     <div>
                        <div class="relinfo">
                           <p><strong>相关话题</strong></p>
                           <ul>
                              <li><a href="datatypes-and-host-variables.html#GUID-DDBD9085-0981-444E-8F3F-EFF46E67284D">VAR中的CONVBUFSZ条款</a></li>
                              <li><a href="ANSI-dynamic-SQL.html#GUID-BF450DA3-B05F-403E-B5DF-C967A20524BF">ANSI动态SQL</a></li>
                              <li><a href="about-Objects.html#GUID-0C106FBC-C023-4B86-817A-1867A69388F7">对象</a></li>
                           </ul>
                        </div>
                     </div>
                     
                  </div>
               </div>
            </div><a id="LNPCC3275"></a><div class="props_rev_3"><a id="GUID-84120650-DFD4-4623-B1ED-722CC4563DAC" name="GUID-84120650-DFD4-4623-B1ED-722CC4563DAC"></a><h3 id="LNPCC-GUID-84120650-DFD4-4623-B1ED-722CC4563DAC" class="sect3"><span class="enumeration_section">5.2</span>数据类型转换</h3>
               <div>
                  <p>在预编译时，为每个主机变量分配默认的外部数据类型。例如，预编译器将INTEGER外部数据类型分配给类型为<span class="bold">short int</span>和<span class="bold">int的</span>主机变量。
                  </p>
                  <p>在运行时，SQL语句中使用的每个主机变量的数据类型代码都将传递给Oracle。Oracle使用代码在内部和外部数据类型之间进行转换。</p>
                  <p>在将SELECTed列（或伪列）值分配给输出主机变量之前，Oracle必须将源列的内部数据类型转换为主机变量的数据类型。同样，在将输入主机变量的值分配或比较到列之前，Oracle必须将主机变量的外部数据类型转换为目标列的内部数据类型。 <a id="d24171e664" class="indexterm-anchor"></a> 
                  </p>
                  <p>内部和外部数据类型之间的转换遵循通常的数据转换规则。例如，您可以将CHAR值“1234”转换为C <span class="italic">短</span>值。您不能将CHAR值“65543”（数字太大）或“10F”（数字不是十进制）转换为C <span class="italic">短</span>值。同样，您不能将包含任何字母字符的<code class="codeph">char[n]</code>值转换为NUMBER值。
                  </p>
               </div>
            </div><a id="LNPCC3276"></a><div class="props_rev_3"><a id="GUID-3D21E7F4-A0D0-4961-9669-ABF8A2739A90" name="GUID-3D21E7F4-A0D0-4961-9669-ABF8A2739A90"></a><h3 id="LNPCC-GUID-3D21E7F4-A0D0-4961-9669-ABF8A2739A90" class="sect3"><span class="enumeration_section">5.3</span>数据类型等价</h3>
               <div>
                  <p>数据类型等效可让您控制Oracle解释输入数据的方式，以及Oracle格式化输出数据的方式。它提供了覆盖预编译器分配的默认外部数据类型的功能。在逐个变量的基础上，您可以将支持的C主机变量数据类型映射（或等效）到Oracle外部数据类型。您还可以将用户定义的数据类型映射到Oracle外部数据类型。</p>
               </div><a id="LNPCC3278"></a><a id="LNPCC3277"></a><div class="props_rev_3"><a id="GUID-68F55764-855D-4549-B587-980F0534EFF6" name="GUID-68F55764-855D-4549-B587-980F0534EFF6"></a><h4 id="LNPCC-GUID-68F55764-855D-4549-B587-980F0534EFF6" class="sect4"><span class="enumeration_section">5.3.1</span>主机变量等价</h4>
                  <div>
                     <p>默认情况下，Pro * C / C ++预编译器为每个主机变量分配特定的外部数据类型。</p>
                     <p><a href="advanced-topics.html#GUID-68F55764-855D-4549-B587-980F0534EFF6__G449968" title="默认类型分配">表5-2</a>列出了默认分配：</p>
                     <div class="tblformal" id="GUID-68F55764-855D-4549-B587-980F0534EFF6__G449968">
                        <p class="titleintable">表5-2默认类型分配</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="默认类型分配" width="100%" border="1" summary="Default Type Assignments" frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="35%" id="d24171e727">C类型或假型</th>
                                 <th align="left" valign="bottom" width="26%" id="d24171e730">Oracle外部类型</th>
                                 <th align="left" valign="bottom" width="38%" id="d24171e733">笔记</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="35%" id="d24171e738" headers="d24171e727 ">
                                    <p>烧焦</p>
                                    <p>炭[n]的</p>
                                    <p>字符*</p>
                                 </td>
                                 <td align="left" valign="top" width="26%" headers="d24171e738 d24171e730 ">
                                    <p>VARCHAR2</p>
                                    <p>CHARZ</p>
                                    <p>串</p>
                                    <p>CHARF</p>
                                 </td>
                                 <td align="left" valign="top" width="38%" headers="d24171e738 d24171e733 ">
                                    <p>（CHAR_MAP = VARCHAR2）</p>
                                    <p>（DBMS = V7，V8默认）</p>
                                    <p>（CHAR_MAP = STRING）</p>
                                    <p>（CHAR_MAP = CHARF）</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="35%" id="d24171e764" headers="d24171e727 ">
                                    <p>int，int *</p>
                                 </td>
                                 <td align="left" valign="top" width="26%" headers="d24171e764 d24171e730 ">
                                    <p>整数</p>
                                 </td>
                                 <td align="left" valign="top" width="38%" headers="d24171e764 d24171e733 ">
                                    <p>-</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="35%" id="d24171e774" headers="d24171e727 ">
                                    <p>短，短*</p>
                                 </td>
                                 <td align="left" valign="top" width="26%" headers="d24171e774 d24171e730 ">
                                    <p>整数</p>
                                 </td>
                                 <td align="left" valign="top" width="38%" headers="d24171e774 d24171e733 ">
                                    <p>-</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="35%" id="d24171e784" headers="d24171e727 ">
                                    <p>长，长*</p>
                                 </td>
                                 <td align="left" valign="top" width="26%" headers="d24171e784 d24171e730 ">
                                    <p>整数</p>
                                 </td>
                                 <td align="left" valign="top" width="38%" headers="d24171e784 d24171e733 ">
                                    <p>-</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="35%" id="d24171e794" headers="d24171e727 ">
                                    <p>长，长很长*</p>
                                 </td>
                                 <td align="left" valign="top" width="26%" headers="d24171e794 d24171e730 ">
                                    <p>整数</p>
                                 </td>
                                 <td align="left" valign="top" width="38%" headers="d24171e794 d24171e733 ">
                                    <p>-</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="35%" id="d24171e804" headers="d24171e727 ">
                                    <p>漂浮，漂浮*</p>
                                 </td>
                                 <td align="left" valign="top" width="26%" headers="d24171e804 d24171e730 ">
                                    <p>浮动</p>
                                 </td>
                                 <td align="left" valign="top" width="38%" headers="d24171e804 d24171e733 ">
                                    <p>-</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="35%" id="d24171e814" headers="d24171e727 ">
                                    <p>双，双*</p>
                                 </td>
                                 <td align="left" valign="top" width="26%" headers="d24171e814 d24171e730 ">
                                    <p>浮动</p>
                                 </td>
                                 <td align="left" valign="top" width="38%" headers="d24171e814 d24171e733 ">
                                    <p>-</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="35%" id="d24171e824" headers="d24171e727 ">
                                    <p>VARCHAR *，VARCHAR [n]</p>
                                 </td>
                                 <td align="left" valign="top" width="26%" headers="d24171e824 d24171e730 ">
                                    <p>VARCHAR</p>
                                 </td>
                                 <td align="left" valign="top" width="38%" headers="d24171e824 d24171e733 ">
                                    <p>-</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <p>使用VAR语句，您可以通过将主机变量等同于Oracle外部数据类型来覆盖默认分配。您使用的语法是<a id="d24171e835" class="indexterm-anchor"></a> 
                     </p><pre class="oac_no_warn" dir="ltr">EXEC SQL VAR host_variable IS type_name [（length）];</pre><p>其中<span class="italic">host_variable</span>是先前声明的输入或输出主机变量（或主机数组）， <span class="italic">type_name</span>是有效外部数据类型的名称， <span class="italic">length</span>是指定有效长度（以字节为单位）的整数文字。
                     </p>
                     <p>主机变量等效在几个方面很有用。例如，假设您要从EMP表中选择员工姓名，然后将其传递给期望以空字符结尾的字符串的例程。您无需显式空终止名称。简单地将主变量等同于STRING外部数据类型，如下所示：</p><pre class="oac_no_warn" dir="ltr">...char emp_name [11]; EXEC SQL VAR emp_name IS STRING（11）;</pre><p>EMP表中ENAME列的长度为10个字符，因此您要分配新的<span class="italic">emp_name</span> 11个字符以容纳空终止符。当您将ENAME列中的值选择为<span class="italic">emp_name时</span> ，程序接口将为您终止值。
                     </p>
                     <p>您可以使用除NUMBER之外的任何外部数据类型（例如，VARNUM）。</p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="datatypes-and-host-variables.html#GUID-D1A89D46-9C1E-4A50-A6D6-B8FA9F784952">外部数据类型</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div><a id="LNPCC3279"></a><div class="props_rev_3"><a id="GUID-F62EEF33-4BCC-472C-B812-5C257333FE50" name="GUID-F62EEF33-4BCC-472C-B812-5C257333FE50"></a><h4 id="LNPCC-GUID-F62EEF33-4BCC-472C-B812-5C257333FE50" class="sect4"><span class="enumeration_section">5.3.2</span>用户定义的类型等价</h4>
                  <div>
                     <p>您还可以将用户定义的数据类型映射（或等效）到Oracle外部数据类型。首先，定义一个新的数据类型，其结构类似于适合您需要的外部数据类型。然后，使用TYPE语句将新数据类型映射到外部数据类型。</p>
                     <p>使用TYPE语句，可以将Oracle外部数据类型分配给整类主机变量。您使用的语法是： <a id="d24171e889" class="indexterm-anchor"></a> 
                     </p><pre class="oac_no_warn" dir="ltr">EXEC SQL TYPE user_type IS type_name [（length）] [REFERENCE];</pre><p>假设您需要一个可变长度的字符串数据类型来保存图形字符。首先，声明一个具有<span class="bold">短</span>长度组件的结构，后跟一个65533字节的数据组件。其次，使用<span class="bold">typedef</span>基于struct定义新的数据类型。然后，将新的用户定义数据类型与VARRAW外部数据类型等效，如以下示例所示：</p><pre class="oac_no_warn" dir="ltr">struct screen {short len; char buff [4000]; }; typedef struct screen graphics; EXEC SQL TYPE图形IS VARRAW（4000）;图形crt; - 图形类型的主变量...
</pre><p>为新<span class="italic">图形</span>类型指定4000字节的长度，因为这是结构中数据组件的最大长度。预编译器在将长度发送到Oracle服务器时允许<span class="italic">len</span>组件（以及任何填充）。
                     </p>
                  </div><a id="LNPCC3280"></a><div class="props_rev_3"><a id="GUID-406E4486-1ADF-4090-BE20-F53185EC7C85" name="GUID-406E4486-1ADF-4090-BE20-F53185EC7C85"></a><h5 id="LNPCC-GUID-406E4486-1ADF-4090-BE20-F53185EC7C85" class="sect5"><span class="enumeration_section">5.3.2.1</span>参考条款</h5>
                     <div>
                        <p>您可以将用户定义的类型声明为指针，显式地，作为指向标量或结构类型的指针，或隐式地，作为数组，并在EXEC SQL TYPE语句中使用此类型。在这种情况下，必须在语句末尾使用REFERENCE子句，如以下示例所示：<a id="d24171e925" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">typedef unsigned char * my_raw; EXEC SQL TYPE my_raw IS VARRAW（4000）REFERENCE; my_raw graphics_buffer; ...graphics_buffer =（my_raw）malloc（4004）;</pre><p>在此示例中，您在类型长度（4000）上分配了额外的内存。这是必要的，因为预编译器还返回长度（ <span class="italic">短</span>的大小），并且由于系统上的字对齐限制，可以在长度之后添加填充。如果您不知道系统上的对齐方法，请确保为长度和填充分配足够的额外字节（9通常应该足够）。
                        </p>
                     </div>
                     <div>
                        <div class="relinfo">
                           <p><strong>相关话题</strong></p>
                           <ul>
                              <li><a href="datatypes-and-host-variables.html#GUID-FA7D1173-C17F-4740-8E96-CB087D29394F">示例程序：使用sqlvcp（）</a></li>
                           </ul>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="LNPCC3281"></a><div class="props_rev_3"><a id="GUID-CF008CE0-B82A-4BCA-99FC-E2493A9CCE47" name="GUID-CF008CE0-B82A-4BCA-99FC-E2493A9CCE47"></a><h4 id="LNPCC-GUID-CF008CE0-B82A-4BCA-99FC-E2493A9CCE47" class="sect4"><span class="enumeration_section">5.3.3</span> CHARF外部数据类型</h4>
                  <div>
                     <p><a id="d24171e956" class="indexterm-anchor"></a> CHARF是一个固定长度的字符串。无论DBMS或CHAR_MAP选项的设置如何，您都可以在VAR和TYPE语句中将此数据类型用于等效C数据类型到固定长度的SQL标准数据类型CHAR。
                     </p>
                     <p>当DBMS = V7或V8时，在VAR或TYPE语句中指定外部数据类型CHARACTER会使C数据类型等同于固定长度数据类型CHAR（数据类型代码96）。但是，当CHAR_MAP = VARCHAR2时，C数据类型等同于可变长度数据类型VARCHAR2（代码1）。<a id="d24171e961" class="indexterm-anchor"></a><a id="d24171e963" class="indexterm-anchor"></a></p>
                     <p>现在，通过使用VAR或TYPE语句中的CHARF数据类型，您始终可以将等效C数据类型转换为固定长度的SQL标准类型CHARACTER。使用CHARF时，无论DBMS或CHAR_MAP选项的设置如何，始终等效于固定长度字符类型。</p>
                  </div>
               </div><a id="LNPCC3282"></a><div class="props_rev_3"><a id="GUID-E3596E74-4425-40CD-8C06-F6891E1534C0" name="GUID-E3596E74-4425-40CD-8C06-F6891E1534C0"></a><h4 id="LNPCC-GUID-E3596E74-4425-40CD-8C06-F6891E1534C0" class="sect4"><span class="enumeration_section">5.3.4</span> EXEC SQL VAR和TYPE指令</h4>
                  <div>
                     <p>您可以在程序的任何位置编写EXEC SQL VAR ...或EXEC SQL TYPE ...语句。这些语句被视为可执行语句，可以将TYPE或VAR语句所指向的任何受其影响的变量的数据类型更改为变量范围的末尾。如果使用MODE = ANSI进行预编译，则必须使用Declare Sections。在这种情况下，TYPE或VAR语句必须位于Declare Section中。 <a id="d24171e978" class="indexterm-anchor"></a> 
                     </p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="embedded-SQL-statements-and-directives.html#GUID-ADB0F592-9859-42A7-B89A-F6BB6E7BC6BA">TYPE（Oracle嵌入式SQL指令）</a></li>
                           <li><a href="embedded-SQL-statements-and-directives.html#GUID-E8C91676-9AED-4D25-99F2-C3A38E4D0129">VAR（Oracle嵌入式SQL指令）</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div><a id="LNPCC3283"></a><div class="props_rev_3"><a id="GUID-7B0A9586-6B11-4009-8904-7DEAEBB06789" name="GUID-7B0A9586-6B11-4009-8904-7DEAEBB06789"></a><h4 id="LNPCC-GUID-7B0A9586-6B11-4009-8904-7DEAEBB06789" class="sect4"><span class="enumeration_section">5.3.5</span>示例：数据类型等价（sample4.pc）：</h4>
                  <div>
                     <p>本节中的演示程序向您展示了如何在Pro * C / C ++程序中使用数据类型等效。该程序在<code class="codeph">dem</code> o目录中以<code class="codeph">sample4.pc</code>形式提供。它演示了如何使用LONG VARRAW外部数据类型进行类型等效。为了提供可跨不同系统移植的有用示例，程序将二进制文件插入到数据库中并从中检索它们。
                     </p>
                     <p>该程序使用LOB嵌入式SQL语句。</p>
                     <p>请阅读介绍性意见，以获得该计划目的的解释。</p><pre class="oac_no_warn" dir="ltr">/ ******************* ************** sample4.pc该程序演示了如何使用LONG VARRAW外部数据类型进行类型等效。为了提供可跨不同系统移植的有用示例，程序将二进制文件插入到数据库中并从中检索它们。例如，假设您在当前目录中有一个名为“hello”的文件。您可以通过编译以下源代码来创建此文件：#include &lt;stdio.h&gt; int main（）{printf（“Hello World！\ n“）;}当这个程序运行时，我们得到：$ hello Hello World！以下是一系列sample4的一些示例输出：$ sample4已连接。您想创建（或重新创建）EXECUTABLES表（y / n）吗？y EXECUTABLES表成功删除。现在创建新表...EXECUTABLES表已创建。样本4菜单。您是否愿意：（I）将新的可执行文件插入数据库（R），从数据库中获取可执行文件（L）存储在数据库中的可执行文件（D）从数据库中获取可执行文件（Q）uit程序输入i，r，l或q：l可执行文件长度（字节）-------------------- --------------总计可执行文件：0样本4菜单。您是否愿意：（I）将新的可执行文件插入数据库（R），从数据库中获取可执行文件（L），存储在数据库中的可执行文件（D）从数据库中获取可执行文件（Q）uit程序输入i，r，l或q：i输入要插入此可执行文件的密钥：hello输入要在“hello”键下插入的文件名。如果文件不在当前目录中，请输入完整路径：hello在'hello'键下插入文件'hello'...插入。样本4菜单。您是否愿意：（I）将新的可执行文件插入数据库（R），从数据库中获取可执行文件（L），存储在数据库中的可执行文件（D）从数据库中获取可执行文件（Q）uit程序输入i，r，l或q：l可执行文件长度（字节）-------------------- --------------你好5508总可执行文件：1个样本4菜单。您是否愿意：（I）将新的可执行文件插入数据库（R），从数据库中获取可执行文件（L），存储在数据库中的可执行文件（D）从数据库中获取可执行文件（Q）uit程序输入i，r，l或q：r输入要检索的可执行文件的密钥：hello输入文件以将密钥hello下存储的可执行文件写入。如果您不想在当前目录中输入文件，请输入完整路径：h1检索存储在“hello”键下的可执行文件到文件“h1”...检索。样本4菜单。您是否愿意：（I）将新的可执行文件插入数据库（R），从数据库中获取可执行文件（L），存储在数据库中的可执行文件（D）从数据库中获取可执行文件（Q）uit程序输入i，r，l或q：q我们现在创建了二进制文件'h1'，我们可以运行它：$ h1 Hello World！************************************************** ************* / #include &lt;oci.h&gt; #include &lt;string.h&gt; #include &lt;stdio.h&gt; #include &lt;sqlca.h&gt; #include &lt;stdlib.h&gt;＃ include &lt;sqlcpr.h&gt; / *'表或视图不存在'的Oracle错误代码。* / #define NON_EXISTENT -942 #define NOT_FOUND 1403 / *这是long varraw结构的定义。*请注意，第一个字段len是long而不是short。这是因为前4 *个字节包含长度，而不是前2个字节。* / typedef struct long_varraw {ub4 len; text buf [1]; } long_varraw; / *键入等效long_varraw到LONG VARRAW。 *文件中此点* on的long_varraw类型的所有变量都将具有与之关联的外部类型95（LONG VARRAW）*。* / EXEC SQL TYPE long_varraw是LONG VARRAW REFERENCE; / *此程序的函数已声明。* / #if defined（__ STDC__）void do_connect（void）; void create_table（void）; void sql_error（char *）; void list_executables（void）; void print_menu（void）; void do_insert（varchar *，char *）; void do_retrieve（varchar *，char *）; void do_delete（varchar *）; ub4 read_file（char *，OCIBlobLocator *）; void write_file（char *，OCIBlobLocator *）; #else void do_connect（/ * _ void _ * /）; void create_table（/ * _ void _ * /）; void sql_error（/ * _ char * _ * /）; void list_executables（/ * _ void _ * /）; void print_menu（/ * _ void _ * /）; void do_insert（/ * _ varchar *，char * _ * /）; void do_retrieve（/ * _ varchar *，char * _ * /）; void do_delete（/ * _ varchar * _ * /）; ub4 read_file（/ * _ char *，OCIBlobLocator * _ * /）; void write_file（/ * _ char *，OCIBlobLocator * _ * /）; #endif void main（）{char reply [20]，filename [100]; varchar key [20]; short ok = 1; / *连接到数据库。* / do_connect（）; printf（“你想创建（或重新创建）EXECUTABLES表（是/否）？“）;获取（回复）; if（（回复[0] =='y'）||（回复[0] =='Y'））create_table（）; / *打印菜单，并读入用户的选择。* / print_menu（）;得到（回复）; while（ok）{switch（reply [0]）{case'I'：case'i'：/ * User selected insert  - 获取密钥和文件名。* / printf（“输入您将插入此可执行文件的密钥：”）; key.len = strlen（gets（（char *）key.arr））; printf（“输入要在键'％。* s'下插入的文件名。\ n”，key.len，key.arr）; printf（“如果文件不在当前目录中，请输入完整的\ n”）; printf（“path：”）;得到（文件名）; do_insert（（varchar *）＆key，filename）;打破; case'R'：case'r'：/ *用户选择了retrieve  - 获取密钥和文件名。* / printf（“输入您要检索的可执行文件的密钥：”）; key.len = strlen（gets（（char *）key.arr））; printf（“输入文件以写入存储在密钥下的可执行文件”）; printf（“％。* s into。如果你\ n“，key.len，key.arr）; printf（”不想让当前目录中的文件输入\ n“）; printf（”full path：“）; gets（filename）; do_retrieve（（varchar *）＆key，filename）; break; case'L'：case'l'：/ *用户选择列表 - 只需调用列表例程。* / list_executables（）;打破;案例'D'：案例'd'：/ *用户选择删除 - 获取要删除的可执行文件的密钥。* / printf（“输入您要删除的可执行文件的密钥：”）; key.len = strlen（gets（（char *）key.arr））; do_delete（（varchar *）＆key）;打破; case'Q'：case'q'：/ *用户选择退出 - 只是结束循环。* / ok = 0;打破;默认值：/ *选择无效。* / printf（“选择无效。\ n”）;打破; } if（ok）{/ *再次打印菜单。* / print_menu（）;得到（回复）; EXEC SQL COMMIT WORK RELEASE; } / *连接到数据库。* / void do_connect（）{/ *注意这个声明：uid是一个char *指针，因此Oracle会在运行时对它执行strlen（）来确定长度。* / char * uid =“scott / tiger”;执行SQL WHENEVER SQLERROR DO sql_error（“do_connect（）：CONNECT”）; EXEC SQL CONNECT：uid;的printf（ “连接\ n”）; } / *创建可执行文件表。* / void create_table（）{/ *我们将自己检查此语句的错误。* / EXEC SQL WHENEVER SQLERROR CONTINUE; EXEC SQL DROP TABLE EXECUTABLES; if（sqlca.sqlcode == 0）{printf（“EXECUTABLES表成功删除。”）; printf（“现在创建新表... \ n”）; } else if（sqlca.sqlcode == NON_EXISTENT）{printf（“EXECUTABLES表不存在。”）; printf（“现在创建新表... \ n”）; } else sql_error（“create_table（）”）; / *重置错误处理程序。* / EXEC SQL WHENEVER SQLERROR DO sql_error（“create_table（）：CREATE TABLE”）; EXEC SQL CREATE TABLE EXECUTABLES（名称VARCHAR2（30），长度NUMBER（10），二进制BLOB）; printf（“EXECUTABLES表创建。\ n”）; } / *打开由'filename'标识的二进制文件进行读取，并将其写入二进制LOB。返回读取文件的实际长度。* / ub4 read_file（filename，blob）char * filename; OCIBlobLocator * blob; {long_varraw * lvr; ub4 bufsize; ub4 amt; ub4 filelen，remainder，nbytes; ub4 offset = 1; boolean last = FALSE; FILE * in_fd; / *打开文件进行阅读。* / in_fd = fopen（filename，“r”）; if（in_fd ==（FILE *）0）return（ub4）0; / *确定总文件长度 - 写入BLOB的总金额* /（void）fseek（in_fd，0L，SEEK_END）; amt = filelen =（ub4）ftell（in_fd）; / *确定缓冲区大小并分配LONG VARRAW对象* / bufsize = 2048; lvr =（long_varraw *）malloc（sizeof（ub4）+ bufsize）; nbytes =（filelen&gt; bufsize）？bufsize：filelen; / *重置文件指针并执行初始读取* /（void）fseek（in_fd，0L，SEEK_SET）; lvr-&gt; len = fread（（void *）lvr-&gt; buf，（size_t）1，（size_t）nbytes，in_fd）; remainder = filelen  -  nbytes;执行SQL WHENEVER SQLERROR DO sql_error（“read_file（）：WRITE”）; if（remainder == 0）{/ *将BLOB写入单件* / EXEC SQL LOB WRITE ONE：amt FROM：lvr WITH LENGTH：nbytes INTO：blob AT：offset; } else {/ *使用标准轮询* / EXEC SQL LOB WRITE FIRST在多个片段中写入BLOB：amt FROM：lvr WITH LENGTH：nbytes INTO：blob AT：offset; do {if（remainder&gt; bufsize）nbytes = bufsize; else {nbytes = remainder; last = TRUE; } if（（lvr-&gt; len = fread（（void *）lvr-&gt; buf，（size_t）1，（size_t）nbytes，in_fd））！= nbytes）last = TRUE; if（last）{/ *写下Final Piece * / EXEC SQL LOB WRITE LAST：amt FROM：lvr with LENGTH：nbytes INTO：blob; } else {/ *写一篇临时文章 - 还有更多写* / EXEC SQL LOB写下：amt FROM：lvr with LENGTH：nbytes INTO：blob; } remainder  -  = nbytes;而（！最后&amp;&amp;！FEOF（in_fd））; } / *关闭文件，并返回总文件大小。* / fclose（in_fd）;自由（LVR）; return filelen; } / *通用错误处理程序。'routine'参数应包含发生错误时执行的例程的名称。这将在'EXEC SQL WHENEVER SQLERROR DO sql_error（）'语句中指定。* / void sql_error（routine）char * routine; {char message_buffer [512]; size_t buffer_size; size_t message_length; / *关闭对sql_error（）的调用以避免可能的无限循环* / EXEC SQL WHENEVER SQLERROR CONTINUE; printf（执行％s时出现“\ nOracle错误！\ n“，例程）; / *使用sqlglm（）获取错误消息的全文。* / buffer_size = sizeof（message_buffer）; sqlglm（message_buffer，＆buffer_size，＆message_length）; printf（“％。* s \ n”，message_length，message_buffer）; EXEC SQL ROLLBACK工作版;出口（1）; } / *打开由'filename'标识的二进制文件进行写入，并将二进制LOB的内容复制到其中。* / void write_file（filename，blob）char * filename; OCIBlobLocator * blob; {FILE * out_fd; / *输出文件的文件描述符* / ub4 amt; ub4 bufsize; long_varraw * lvr; / *确定缓冲区大小并分配LONG VARRAW对象* / bufsize = 2048; lvr =（long_varraw *）malloc（sizeof（ub4）+ bufsize）; / *打开输出文件进行写入* / out_fd = fopen（文件名，“w”）; if（out_fd ==（FILE *）0）返回; amt = 0; / *初始化标准轮询（可能）* / lvr-&gt; len = bufsize; / *设置缓冲区长度* / EXEC SQL WHENEVER SQLERROR DO sql_error（“write_file（）：READ”）; / *使用标准轮询循环读取BLOB * / EXEC SQL WHENEVER NOT FOUND DO break; while（TRUE）{EXEC SQL LOB READ：amt FROM：blob INTO：lvr WITH LENGTH：bufsize; （void）fwrite（（void *）lvr-&gt; buf，（size_t）1，（size_t）lvr-&gt; len，out_fd）; } EXEC SQL WHENEVER NOT FOUND CONTINUE; / *写下最终作品（如果没有轮询，则为第一张和第一张）* /（void）fwrite（（void *）lvr-&gt; buf，（size_t）lvr-&gt; len，（size_t）1，out_fd）; / *关闭输出文件并返回* / fclose（out_fd）;自由（LVR）;返回; / *将由file标识的二进制文件插入由key标识的* executables表中。* / void do_insert（key，file）varchar * key; char *文件; {OCIBlobLocator * blob; ub4 loblen，fillen; EXEC SQL ALLOCATE：blob;执行SQL WHENEVER SQLERROR DO sql_error（“do_insert（）：INSERT / SELECT”）; EXEC SQL SAVEPOINT PREINSERT; EXEC SQL INSERT INTO可执行文件（名称，长度，二进制）VALUES（：key，0，empty_blob（））; EXEC SQL SELECT二进制INTO：blob FROM可执行文件WHERE name =：key FOR UPDATE; printf（“在'％。* s'... \ n'键下插入文件'％s'，文件，key-&gt; len，key-&gt; arr）; fillen = read_file（file，blob）; EXEC SQL LOB DESCRIBE：blob GET LENGTH INTO：loblen; if（（fillen == 0）||（fillen！= loblen））{printf（“问题读取文件'％s'\ n”，文件）;执行SQL ROLLBACK到SAVEPOINT PREINSERT; EXEC SQL FREE：blob;返回;执行SQL WHENEVER SQLERROR DO sql_error（“do_insert（）：UPDATE”）; EXEC SQL UPDATE可执行文件SET length =：loblen，binary =：blob WHERE name =：key; EXEC SQL COMMIT WORK; EXEC SQL FREE：blob; EXEC SQL COMMIT;的printf（ “插入\ n”）; / *将由key标识的可执行文件检索到文件中* / void do_retrieve（key，file）varchar * key; char *文件; {OCIBlobLocator * blob; printf（“将存储在密钥'％。* s'下的可执行文件检索到文件'％s'... \ n”，key-&gt; len，key-&gt; arr，file）; EXEC SQL ALLOCATE：blob; EXEC SQL WHENEVER NOT FOUND继续; EXEC SQL SELECT二进制INTO：blob FROM可执行文件WHERE name =：key; if（sqlca.sqlcode == NOT_FOUND）printf（“找不到键'％。* s'！\ n“，key-&gt; len，key-&gt; arr）; else {write_file（file，blob）; printf（”Retrieved。\ n“）;} EXEC SQL FREE：blob;} / *从数据库中删除可执行文件* / void do_delete（key）varchar * key; {EXEC SQL WHENEVER SQLERROR DO sql_error（“do_delete（）：DELETE”）; EXEC SQL DELETE FROM executables WHERE name =：key; if（sqlca.sqlcode == NOT_FOUND）printf（ “找不到键'％。* s'！\ n“，key-&gt; len，key-&gt; arr）; else printf（”Deleted。\ n“）;} / *列出当前存储在数据库中的所有可执行文件* / void list_executables（）{char key [21]; ub4 length; EXEC SQL WHENEVER SQLERROR DO sql_error（“list_executables”）; EXEC SQL DECLARE key_cursor CURSOR FOR SELECT name，length FROM executables; EXEC SQL OPEN key_cursor; printf（“\ n Executables Length（bytes）\ n”）; printf（“ -------------------- -------------- \ n“）; EXEC SQL WHENEVER NOT FOUND DO break; while（1 ）{EXEC SQL FETCH key_cursor INTO：key，：length; printf（“％s％10d \ n”，key，length）;} EXEC SQL WHENEVER NOT FOUND CONTINUE; EXEC SQL CLOSE key_cursor; printf（“\ nTotal Executables：％ d \ n“，sqlca.sqlerrd [2]）;} / *打印菜单选项。* / void print_menu（）{printf（“\ nSample 4 Menu。您是否愿意：\ n“）; printf（”（I）将新的可执行文件插入数据库\ n“）; printf（”（R）从数据库中获取可执行文件\ n“）; printf（”（L ）ist存储在数据库中的可执行文件\ n“）; printf（”（D）从数据库中获取可执行文件\ n“）; printf（”（Q）uit the program \ n \ n“）; printf（”Enter“ i，r，l或q：“）;}</pre></div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="about-LOBs.html#GUID-DEBB0C35-161B-4725-BE0D-A209B64B98A2">的LOB</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div>
            </div><a id="LNPCC3284"></a><div class="props_rev_3"><a id="GUID-6E07C0B8-8C43-440D-A0C1-D30B5A58C2B2" name="GUID-6E07C0B8-8C43-440D-A0C1-D30B5A58C2B2"></a><h3 id="LNPCC-GUID-6E07C0B8-8C43-440D-A0C1-D30B5A58C2B2" class="sect3"><span class="enumeration_section">5.4</span> C预处理器</h3>
               <div>
                  <p>Pro * C / C ++支持大多数C预处理程序指令。使用Pro * C / C ++预处理器可以执行的一些操作是：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>使用<span class="bold">#define</span>指令定义常量和宏，并使用定义的实体参数化Pro * C / C ++数据类型声明，例如VARCHAR</p>
                     </li>
                     <li>
                        <p>使用<span class="bold">#include</span>指令读取预编译器所需的文件，例如<code class="codeph">sqlca.h</code></p>
                     </li>
                     <li>
                        <p>在单独的文件中定义常量和宏，并让预编译器使用<span class="bold">#include</span>指令读取此文件</p>
                     </li>
                  </ul>
               </div><a id="LNPCC3285"></a><div class="props_rev_3"><a id="GUID-54DCF9BD-6A3D-4D65-80DA-6D9BA0484A60" name="GUID-54DCF9BD-6A3D-4D65-80DA-6D9BA0484A60"></a><h4 id="LNPCC-GUID-54DCF9BD-6A3D-4D65-80DA-6D9BA0484A60" class="sect4"><span class="enumeration_section">5.4.1</span> Pro * C / C ++预处理器的工作原理</h4>
                  <div>
                     <p>Pro * C / C ++预处理器可识别大多数C预处理器命令，并有效执行所需的宏替换，文件包含和条件源文本包含或排除。Pro * C / C ++预处理器使用从预处理获得的值，并更改源输出文本（生成的<code class="codeph">.c</code>输出文件）。
                     </p>
                     <p>一个例子应该澄清这一点。考虑以下程序片段：<a id="d24171e1095" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">#include“my_header.h”......VARCHAR名称[VC_LEN]; / * Pro * C提供的数据类型* / char another_name [VC_LEN]; / *一个纯C数据类型* / ...
</pre><p>假设当前目录中的文件<code class="codeph">my_header.h</code>包含该行以及其他内容</p><pre class="oac_no_warn" dir="ltr">#define VC_LEN 20</pre><p>预编译器读取文件<code class="codeph">my_header.h</code> ，并使用VC_LEN（20）的定义值，将<span class="italic">name</span>的结构声明为VARCHAR [20]。
                     </p>
                     <p><span class="bold">char</span>是本机类型。预编译器不会在another_name [VC_LEN]的声明中替换20。
                     </p>
                     <p>这没关系，因为预编译器不需要处理C数据类型的声明，即使它们被用作主变量也是如此。由C编译器的预处理器实际包含文件<code class="codeph">my_header.h</code> ，并在<span class="italic">another_name</span>的声明中对VC_LEN执行20的替换。 <a id="d24171e1128" class="indexterm-anchor"></a> 
                     </p>
                  </div>
               </div><a id="LNPCC3286"></a><div class="props_rev_3"><a id="GUID-09BFCE49-1DC1-4892-9BAC-D1FEC33442C9" name="GUID-09BFCE49-1DC1-4892-9BAC-D1FEC33442C9"></a><h4 id="LNPCC-GUID-09BFCE49-1DC1-4892-9BAC-D1FEC33442C9" class="sect4"><span class="enumeration_section">5.4.2</span>预处理器指令</h4>
                  <div>
                     <p>Pro * C / C ++支持的预处理程序指令是：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><span class="bold">#define</span> ，用于创建供预编译器和C或C ++编译器使用的宏</p>
                        </li>
                        <li>
                           <p><span class="bold">#include</span> ，读取预编译器使用的其他源文件</p>
                        </li>
                        <li>
                           <p><span class="bold">#if</span> ，根据常量表达式的计算结果预编译和编译源文本为0</p>
                        </li>
                        <li>
                           <p><span class="bold">#ifdef</span> ，根据已定义常量的存在，有条件地预编译和编译源文本</p>
                        </li>
                        <li>
                           <p><span class="bold">#ifndef</span> ，有条件地排除源文本</p>
                        </li>
                        <li>
                           <p><span class="bold">#endif</span> ，结束<span class="bold">#if</span>或<span class="bold">#ifdef</span>或<span class="bold">#ifndef</span>命令</p>
                        </li>
                        <li>
                           <p><span class="bold">#else</span> ，选择要预编译和编译的源文本的替代主体，以防<span class="bold">#if</span>或<span class="bold">#ifdef</span>或<span class="bold">#ifndef</span>条件不满足</p>
                        </li>
                        <li>
                           <p><span class="bold">#elif</span> ，选择要预编译和编译的源文本的替代主体，具体取决于常量或宏参数的值</p>
                        </li>
                     </ul>
                  </div><a id="LNPCC3287"></a><div class="props_rev_3"><a id="GUID-BEBEFFDB-7BDB-46B5-9E05-C502FC5F0C0D" name="GUID-BEBEFFDB-7BDB-46B5-9E05-C502FC5F0C0D"></a><h5 id="LNPCC-GUID-BEBEFFDB-7BDB-46B5-9E05-C502FC5F0C0D" class="sect5"><span class="enumeration_section">5.4.2.1</span>忽略指令</h5>
                     <div>
                        <p>Pro * C / C ++预处理器不使用某些C预处理程序指令。这些指令中的大多数与预编译器无关。例如， <span class="bold">＃pragma</span>是C编译器的指令 - 预编译器不处理它。预编译器未处理的C预处理程序指令是： <a id="d24171e1217" class="indexterm-anchor"></a> 
                        </p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><span class="bold">＃</span> ，将预处理器宏参数转换为字符串常量</p>
                           </li>
                           <li>
                              <p><span class="bold">##</span> ，在宏定义中合并两个预处理程序标记</p>
                           </li>
                           <li>
                              <p><span class="bold">#error</span> ，生成编译时错误消息</p>
                           </li>
                           <li>
                              <p><span class="bold">#pragma</span> ，将与实现相关的信息传递给C编译器</p>
                           </li>
                           <li>
                              <p><span class="bold">#line</span> ，为C编译器消息提供行号</p>
                           </li>
                        </ul>
                        <p>虽然您的C编译器预处理器可能支持这些指令，但Pro * C / C ++不使用它们。预编译器不使用大多数这些指令。如果编译器支持这些指令，则可以在Pro * C / C ++程序中使用这些指令，但仅限于C或C ++代码，而不能使用嵌入式SQL语句或使用预编译器提供的数据类型的变量声明，例如VARCHAR。</p>
                     </div>
                  </div>
               </div><a id="LNPCC3288"></a><div class="props_rev_3"><a id="GUID-631ED2D1-CA2A-449E-999B-F5EC7CD401AE" name="GUID-631ED2D1-CA2A-449E-999B-F5EC7CD401AE"></a><h4 id="LNPCC-GUID-631ED2D1-CA2A-449E-999B-F5EC7CD401AE" class="sect4"><span class="enumeration_section">5.4.3</span> ORA_PROC宏</h4>
                  <div>
                     <p>Pro * C / C ++预定义了一个名为ORA_PROC的C预处理器宏，您可以使用它来避免预编译器处理不必要或不相关的代码段。某些应用程序包括大型头文件，这些文件提供了预编译时不必要的信息。通过有条件地排除基于ORA_PROC宏的头文件，预编译器永远不会读取该文件。</p>
                     <p>以下示例使用ORA_PROC宏来排除<code class="codeph">irrelevant.h</code>的.h文件：</p><pre class="oac_no_warn" dir="ltr">#ifndef ORA_PROC #include &lt;irrelevant.h&gt; #endif</pre><p>由于ORA_PROC是预编译过程中定义的， <code class="codeph">irrelevant.h</code>文件永远不会包括在内。
                     </p>
                     <p>ORA_PROC宏仅适用于C预处理程序指令，例如<span class="bold">#ifdef</span>或<span class="bold">#ifndef</span> 。该EXEC ORACLE条件语句<span class="italic">不</span>共享相同的命名空间的C预处理宏。因此，以下示例中的条件<span class="italic">不</span>使用预定义的ORA_PROC宏：</p><pre class="oac_no_warn" dir="ltr">EXEC ORACLE IFNDEF ORA_PROC; &lt;要忽略的代码段&gt; EXEC ORACLE ENDIF;</pre><p>在这种情况下，必须使用DEFINE选项或EXEC ORACLE DEFINE语句设置ORA_PROC，以使此条件代码片段正常工作。</p>
                  </div>
               </div><a id="LNPCC3289"></a><div class="props_rev_3"><a id="GUID-4449B41B-8421-4983-A1E3-06B4126BCCCB" name="GUID-4449B41B-8421-4983-A1E3-06B4126BCCCB"></a><h4 id="LNPCC-GUID-4449B41B-8421-4983-A1E3-06B4126BCCCB" class="sect4"><span class="enumeration_section">5.4.4</span>头文件规范的位置</h4>
                  <div>
                     <p>每个系统的Pro * C / C ++预编译器假定预处理器读取头文件的标准位置，例如<code class="codeph">sqlca.h</code> ， <code class="codeph">oraca.h</code>和<code class="codeph">sqlda.h</code> 。例如，在大多数UNIX系统上，标准位置是<code class="codeph">$ORACLE_HOME/precomp/public</code> 。有关系统上的默认位置，请参阅特定于系统的Oracle文档。如果您需要包含的头文件不在默认位置，则必须在命令行上使用INCLUDE =选项或作为EXEC ORACLE选项。
                     </p>
                     <p>要指定系统头文件的位置，例如<code class="codeph">stdio.h</code>或<code class="codeph">iostream.h</code> ，其位置可能与硬编码到Pro * C / C ++中的位置不同，请使用SYS_INCLUDE预编译器选项。
                     </p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="precompiler-options.html#GUID-43E60380-8B54-4528-A76F-5A78A46F05D4">预编译器选项</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div><a id="LNPCC3290"></a><div class="props_rev_3"><a id="GUID-E351DB2E-0DF3-4102-84BA-D1B19AE2FDEF" name="GUID-E351DB2E-0DF3-4102-84BA-D1B19AE2FDEF"></a><h4 id="LNPCC-GUID-E351DB2E-0DF3-4102-84BA-D1B19AE2FDEF" class="sect4"><span class="enumeration_section">5.4.5</span>一些预处理器示例</h4>
                  <div>
                     <p>您可以使用<span class="bold">#define</span>命令创建命名常量，并使用它们代替源代码中的“幻数”。您可以将<span class="bold">#define</span> d常量用于预编译器所需的声明，例如VARCHAR [const]。例如，而不是带有错误的代码，例如：</p><pre class="oac_no_warn" dir="ltr">...VARCHAR emp_name [10]; VARCHAR dept_loc [14]; ....../ *很晚以后的代码......* / f42（）{/ *你还记得正确的尺寸吗？* / VARCHAR new_dept_loc [10]; ...}</pre><p>你可以编码：</p><pre class="oac_no_warn" dir="ltr">#define ENAME_LEN 10 #define LOCATION_LEN 14 VARCHAR new_emp_name [ENAME_LEN]; .../ *很晚以后的代码......* / f42（）{VARCHAR new_dept_loc [LOCATION_LEN]; ...}</pre><p>您可以将预处理器宏与预编译器必须处理的对象的参数一起使用，就像对C对象一样。例如：</p><pre class="oac_no_warn" dir="ltr">#define ENAME_LEN 10 #define LOCATION_LEN 14 #define MAX（A，B）（（A）&gt;（B）？（A）:( B））......f43（）{/ *需要声明一个临时变量来保存员工姓名或部门位置* / VARCHAR name_loc_temp [MAX（ENAME_LEN，LOCATION_LEN）]; ...}</pre><p>您可以使用<span class="bold">＃include</span> ， <span class="bold">＃iff</span>和<span class="bold">#endif</span>预处理程序指令有条件地包含预编译器所需的文件。例如：</p><pre class="oac_no_warn" dir="ltr">#ifdef ORACLE_MODE #include &lt;sqlca.h&gt; #else long SQLCODE; ＃万一</pre></div><a id="LNPCC3291"></a><div class="props_rev_3"><a id="GUID-6FC64962-6CEF-4C62-A320-ABF483AF3BB7" name="GUID-6FC64962-6CEF-4C62-A320-ABF483AF3BB7"></a><h5 id="LNPCC-GUID-6FC64962-6CEF-4C62-A320-ABF483AF3BB7" class="sect5"><span class="enumeration_section">5.4.5.1</span>关于使用#define</h5>
                     <div>
                        <p>在Pro * C / C ++中使用<span class="bold">#define</span>预处理程序指令有一些限制您不能使用<span class="bold">#define</span>指令来创建用于<span class="italic">可执行</span> SQL语句的符号常量。以下<span class="italic">无效</span>示例演示了这一点：<a id="d24171e1395" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">#define RESEARCH_DEPT 40 ...EXEC SQL SELECT empno，sal INTO：emp_number，：salary / * host arrays * / FROM emp WHERE deptno = RESEARCH_DEPT; / *无效！* /</pre><p>您可以合法使用<span class="bold">#define</span> d宏的唯一声明性SQL语句是TYPE和VAR语句。因此，例如，在Pro * C / C ++中，宏的以下用法是合法的</p><pre class="oac_no_warn" dir="ltr">#define STR_LEN 40 ...typedef char asciiz [STR_LEN]; ...EXEC SQL TYPE asciiz IS STRING（STR_LEN）REFERENCE; ...EXEC SQL VAR密码IS STRING（STR_LEN）;</pre></div>
                  </div><a id="LNPCC3292"></a><div class="props_rev_3"><a id="GUID-8D8D4AC3-F0D4-43C7-A53C-C7C3A4227C5A" name="GUID-8D8D4AC3-F0D4-43C7-A53C-C7C3A4227C5A"></a><h5 id="LNPCC-GUID-8D8D4AC3-F0D4-43C7-A53C-C7C3A4227C5A" class="sect5"><span class="enumeration_section">5.4.5.2</span>其他预处理器限制</h5>
                     <div>
                        <p>预处理器忽略指令<span class="bold">＃</span>和<span class="bold">##</span>以创建预编译器必须识别的令牌。您可以在预编译器不必处理的纯C代码中使用这些命令（如果您的编译器支持它们）。使用预处理指令<span class="bold">##</span> <span class="italic">无效</span>在这个例子：</p><pre class="oac_no_warn" dir="ltr">#define MAKE_COL_NAME（A）col ## A ...EXEC SQL SELECT MAKE_COL_NAME（1），MAKE_COL_NAME（2）INTO：x，：y FROM table1;</pre><p>该示例不正确，因为预编译器忽略<span class="bold">##</span> 。
                        </p>
                     </div>
                  </div>
               </div><a id="LNPCC3293"></a><div class="props_rev_3"><a id="GUID-9C3B3349-99CE-45B5-968A-280CC1953E7C" name="GUID-9C3B3349-99CE-45B5-968A-280CC1953E7C"></a><h4 id="LNPCC-GUID-9C3B3349-99CE-45B5-968A-280CC1953E7C" class="sect4"><span class="enumeration_section">5.4.6</span> #include中不允许使用SQL语句</h4>
                  <div>
                     <p>由于Pro * C / C ++预处理器处理<span class="bold">#include</span>指令的方式，如上一节所述，您不能使用<span class="bold">#include</span>指令来包含包含嵌入式SQL语句的文件。您使用<span class="bold">#include</span>包含包含纯声明性语句和指令的文件;例如，＃ <span class="bold">define</span>和预编译器所需的变量和结构的声明，例如在<code class="codeph">sqlca.h</code> 。
                     </p>
                  </div>
               </div><a id="LNPCC3294"></a><div class="props_rev_3"><a id="GUID-900E98EA-4CCF-4AA9-9B4C-EAC865D2B2A6" name="GUID-900E98EA-4CCF-4AA9-9B4C-EAC865D2B2A6"></a><h4 id="LNPCC-GUID-900E98EA-4CCF-4AA9-9B4C-EAC865D2B2A6" class="sect4"><span class="enumeration_section">5.4.7</span>包括SQLCA，ORACA和SQLDA</h4>
                  <div>
                     <p>您可以使用C / C ++预处理器<span class="bold">#include</span>命令或预编译器EXEC SQL INCLUDE命令在Pro * C / C ++程序中包含<code class="codeph">sqlca.h</code> ， <code class="codeph">oraca.h</code>和<code class="codeph">sqlda.h</code>声明头文件。例如，使用以下语句通过EXEC SQL选项在程序中包含SQL通信区域结构（SQLCA）：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL INCLUDE sqlca;</pre><p>要使用C / C ++预处理程序指令包含SQLCA，请添加以下代码：</p><pre class="oac_no_warn" dir="ltr">#include &lt;sqlca.h&gt;</pre><p>使用预处理器<span class="bold">#include</span>指令时，必须指定文件扩展名（例如<code class="codeph">.h</code> ）。
                     </p>
                     <div class="infoboxnote" id="GUID-900E98EA-4CCF-4AA9-9B4C-EAC865D2B2A6__GUID-C5D977AC-80FF-4B16-B86E-0AF5811F3BBA">
                        <p class="notep1">注意：</p>
                        <p>如果需要在多个位置包含SQLCA，使用<span class="bold">#include</span>指令，则应在<span class="bold">#include</span>之前加上指令<span class="bold">#undef</span> SQLCA。这是因为<code class="codeph">sqlca.h</code>以行开头</p><pre class="oac_no_warn" dir="ltr">#ifndef SQLCA #define SQLCA 1</pre><p>然后仅在未定义SQLCA的情况下声明SQLCA结构。<a id="d24171e1521" class="indexterm-anchor"></a></p>
                     </div>
                     <p>当您预编译包含<span class="bold">#include</span>指令或EXEC SQL INCLUDE语句的文件时，您必须告诉预编译器要包含的所有文件的位置。您可以在命令行，系统配置文件或用户配置文件中使用INCLUDE =选项。
                     </p>
                     <p>标准预处理器头文件的默认位置（例如<code class="codeph">sqlca.h</code> ， <code class="codeph">oraca.h</code>和<code class="codeph">sqlda.h</code> ）在预编译器中预设。位置因系统而异。有关系统上的默认位置，请参阅特定于系统的Oracle文档。
                     </p>
                     <p>编译Pro * C / C ++生成的<code class="codeph">.c</code>输出文件时，必须使用编译器和操作系统提供的选项来标识包含文件的位置。
                     </p>
                     <p>例如，在大多数UNIX系统上，您可以使用该命令编译生成的C源文件</p><pre class="oac_no_warn" dir="ltr">cc -o progname -I $ ORACLE_HOME / sqllib / public ... filename.c ...
</pre><p>在VAX / OPENVMS系统上，您将include目录路径预先挂起到逻辑VAXC $ INCLUDE中的值。 <a id="d24171e1553" class="indexterm-anchor"></a> 
                     </p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="handling-run-time-errors.html#GUID-1ADFD2EB-B332-4362-9A85-F56FEDD4F72A">处理运行时错误</a></li>
                           <li><a href="precompiler-options.html#GUID-43E60380-8B54-4528-A76F-5A78A46F05D4">预编译器选项</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div><a id="LNPCC3295"></a><div class="props_rev_3"><a id="GUID-468CEFF5-7442-4CC8-939E-0DEE91D6D017" name="GUID-468CEFF5-7442-4CC8-939E-0DEE91D6D017"></a><h4 id="LNPCC-GUID-468CEFF5-7442-4CC8-939E-0DEE91D6D017" class="sect4"><span class="enumeration_section">5.4.8</span> EXEC SQL INCLUDE和#include摘要</h4>
                  <div>
                     <p>在程序中使用EXEC SQL INCLUDE语句时，预编译器会在输出（ <code class="codeph">.c</code> ）文件中包含源文本。因此，您可以在使用EXEC SQL INCLUDE包含的文件中包含声明性和可执行的嵌入式SQL语句。 <a id="d24171e1587" class="indexterm-anchor"></a> 
                     </p>
                     <p>当您使用<span class="bold">#include</span>包含文件时，预编译器仅读取文件，并跟踪<span class="bold">#define</span> d宏。
                     </p>
                     <div class="infoboxnote" id="GUID-468CEFF5-7442-4CC8-939E-0DEE91D6D017__GUID-37CDAC69-FBF8-4BFF-AC90-AC7E19C9C1C2">
                        <p class="notep1">注意：</p>
                        <p>VARCHAR声明和SQL语句中包含（ <span class="italic">不允许</span> <code class="codeph">#include</code> ）文件。因此，您不能在使用Pro * C / C ++预处理程序<code class="codeph">#include</code>指令包含的文件中使用SQL语句。
                        </p>
                     </div>
                  </div>
               </div><a id="LNPCC3296"></a><div class="props_rev_3"><a id="GUID-05080E2F-508F-40D9-A1EC-BFF638221B41" name="GUID-05080E2F-508F-40D9-A1EC-BFF638221B41"></a><h4 id="LNPCC-GUID-05080E2F-508F-40D9-A1EC-BFF638221B41" class="sect4"><span class="enumeration_section">5.4.9</span>定义的宏</h4>
                  <div>
                     <p>如果在C编译器的命令行上定义宏，则可能还必须在预编译器命令行上定义这些宏，具体取决于应用程序的要求。例如，如果使用UNIX等命令行进行编译<a id="d24171e1624" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">cc -DDEBUG ......
</pre><p>你应该使用DEFINE =选项进行预编译，即</p><pre class="oac_no_warn" dir="ltr">proc DEFINE = DEBUG ......</pre></div>
               </div><a id="LNPCC3297"></a><div class="props_rev_3"><a id="GUID-A25F1F15-0F02-4B37-A3D0-D2F58890FC83" name="GUID-A25F1F15-0F02-4B37-A3D0-D2F58890FC83"></a><h4 id="LNPCC-GUID-A25F1F15-0F02-4B37-A3D0-D2F58890FC83" class="sect4"><span class="enumeration_section">5.4.10</span>包含文件</h4>
                  <div>
                     <p>必须在命令行或配置文件中指定需要预编译的所有包含文件的位置。</p>
                     <p>例如，如果您在UNIX下进行开发，并且您的应用程序包含目录<code class="codeph">/home/project42/include</code> ，则必须在Pro * C / C ++命令行和<code class="codeph">cc</code>命令行上指定此目录。您使用以下命令：</p><pre class="oac_no_warn" dir="ltr">proc iname = my_app.pc include = / home / project42 / include ...cc -I / home / project42 / include ... my_app.c</pre><p>或者在<span class="italic">makefile中</span>包含适当的宏。有关编译和链接Pro * C / C ++应用程序的完整信息，请参阅特定于系统的Oracle文档。
                     </p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="precompiler-options.html#GUID-08EDB388-0406-4F03-9D9F-E0AAA8ADB2B5">包括</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div>
            </div><a id="LNPCC3298"></a><div class="props_rev_3"><a id="GUID-C2EE702D-5EC9-4522-ABC9-43C85A984D3B" name="GUID-C2EE702D-5EC9-4522-ABC9-43C85A984D3B"></a><h3 id="LNPCC-GUID-C2EE702D-5EC9-4522-ABC9-43C85A984D3B" class="sect3"><span class="enumeration_section">5.5</span>预编译的头文件</h3>
               <div>
                  <p>预编译头文件通过预编译包含许多<code class="codeph">#include</code>语句的头文件来节省时间和资源。使用此功能的两个步骤是：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>首先创建预编译的头文件，</p>
                     </li>
                     <li>
                        <p>然后，预编译头将自动用于应用程序的后续预编译。</p>
                     </li>
                  </ul>
                  <p>将此功能用于具有许多模块的大型应用程序。</p>
                  <p>预编译器选项HEADER = <code class="codeph">hdr</code>指定</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>要使用预编译的头文件，<a id="d24171e1711" class="indexterm-anchor"></a></p>
                     </li>
                     <li>
                        <p>要生成的输出文件的文件扩展名是<code class="codeph">hdr</code> 。
                        </p>
                     </li>
                  </ul>
                  <p>此选项只能在配置文件或命令行中输入。HEADER没有默认值，但输入标头必须具有<code class="codeph">.h</code>扩展名。
                  </p>
               </div><a id="LNPCC3299"></a><div class="props_rev_3"><a id="GUID-15815DE2-4933-466B-BD04-188D6FCAEA0A" name="GUID-15815DE2-4933-466B-BD04-188D6FCAEA0A"></a><h4 id="LNPCC-GUID-15815DE2-4933-466B-BD04-188D6FCAEA0A" class="sect4"><span class="enumeration_section">5.5.1</span>预编译头文件创建</h4>
                  <div>
                     <p>假设您有一个名为<code class="codeph">top.h.</code>的头文件。然后你可以预编译它，指定HEADER = <code class="codeph">hdr</code> ：</p><pre class="oac_no_warn" dir="ltr">proc HEADER = hdr INAME = top.h</pre><div class="infoboxnote" id="GUID-15815DE2-4933-466B-BD04-188D6FCAEA0A__GUID-4D95932E-3B9D-48A1-BC69-4BAAADA2D37A">
                        <p class="notep1">注意：</p>
                        <p>您必须提供“.h”扩展名。您不能在INAME值中使用绝对路径元素或相对路径元素，如“/”，“..”等。</p>
                     </div>
                     <p>Pro * C / C ++预编译给定的输入文件<code class="codeph">top.h</code> ，并在同一目录中生成一个新的预编译头文件<code class="codeph">top.hdr</code> 。输出文件<code class="codeph">top.hdr</code>可以移动到<code class="codeph">#include</code>语句将导致搜索的目录。
                     </p>
                     <div class="infoboxnote" id="GUID-15815DE2-4933-466B-BD04-188D6FCAEA0A__GUID-684056B7-EDCB-4F99-97D8-7B8ADC4912C4">
                        <p class="notep1">注意：</p>
                        <p>不要使用ONAME选项来命名输出文件;与HEADER一起使用时会被忽略。</p>
                     </div>
                  </div>
               </div><a id="LNPCC3300"></a><div class="props_rev_3"><a id="GUID-13BCC1B3-FB9E-47D0-8553-5BA7B6EED2D4" name="GUID-13BCC1B3-FB9E-47D0-8553-5BA7B6EED2D4"></a><h4 id="LNPCC-GUID-13BCC1B3-FB9E-47D0-8553-5BA7B6EED2D4" class="sect4"><span class="enumeration_section">5.5.2</span>使用预编译的头文件</h4>
                  <div>
                     <p>将HEADER选项的相同值与要预编译的应用程序文件一起使用。如果simple.pc包含：</p><pre class="oac_no_warn" dir="ltr">#include &lt;top.h&gt; ...
</pre><p>和top.h包含：</p><pre class="oac_no_warn" dir="ltr">#include &lt;ah&gt; #include &lt;bh&gt; #include &lt;ch&gt; ...
</pre><p>然后以这种方式预编译：</p><pre class="oac_no_warn" dir="ltr">proc HEADER = hdr INAME = simple.pc</pre><p>当Pro * C / C ++读取<code class="codeph">#include top.h</code>语句时，它将搜索相应的“top.hdr”文件，并从该文件中实例化数据，而不是再次预编译“top.h”。
                     </p>
                     <div class="infoboxnote" id="GUID-13BCC1B3-FB9E-47D0-8553-5BA7B6EED2D4__GUID-0BFE1EFA-9304-4C3A-8D3C-4EED53E3FEEF">
                        <p class="notep1">注意：</p>
                        <p>即使输入（ <code class="codeph">.h</code> ）文件首先出现在include目录的标准搜索层次结构中，也将始终使用预编译的头文件而不是其输入头文件。
                        </p>
                     </div>
                  </div>
               </div><a id="LNPCC3301"></a><div class="props_rev_3"><a id="GUID-F3E14B60-02D3-4805-B1AF-F3341611D247" name="GUID-F3E14B60-02D3-4805-B1AF-F3341611D247"></a><h4 id="LNPCC-GUID-F3E14B60-02D3-4805-B1AF-F3341611D247" class="sect4"><span class="enumeration_section">5.5.3</span>示例</h4>
                  <div>
                     <p>本节包括演示几种不同情况的示例。</p>
                  </div><a id="LNPCC3302"></a><div class="props_rev_3"><a id="GUID-C8669179-16CE-4269-8571-A6B71329CB57" name="GUID-C8669179-16CE-4269-8571-A6B71329CB57"></a><h5 id="LNPCC-GUID-C8669179-16CE-4269-8571-A6B71329CB57" class="sect5"><span class="enumeration_section">5.5.3.1</span>冗余文件包含</h5>
                     <div>
                        <p>以下两种情况说明了冗余文件包含的两种可能性。</p>
                     </div><a id="LNPCC3303"></a><div class="props_rev_3"><a id="GUID-77541D93-9989-415A-8FBB-E4341F59C083" name="GUID-77541D93-9989-415A-8FBB-E4341F59C083"></a><h6 id="LNPCC-GUID-77541D93-9989-415A-8FBB-E4341F59C083" class="sect6"><span class="enumeration_section">5.5.3.1.1</span>案例1：顶级头文件包含</h6>
                        <div>
                           <p></p>
                           <p>无论使用#include指令包含多少次文件，预编译头文件都只会被实例化一次。</p>
                           <p>假设我们预先编译了一个顶级头文件top.h，并将HEADER的值设置为'hdr'。接下来，我们在程序中为该头文件编写多个#include指令：</p><pre class="oac_no_warn" dir="ltr">#include &lt;top.h&gt; #include &lt;top.h&gt; main（）{}</pre><p>当遇到top.h的第一个#include时，将实例化预编译的头文件top.hdr。第二个包含相同的头文件将是多余的，因此将被忽略。</p>
                        </div>
                     </div><a id="LNPCC3304"></a><div class="props_rev_3"><a id="GUID-65FEF4E3-1934-4159-868E-82006E03503A" name="GUID-65FEF4E3-1934-4159-868E-82006E03503A"></a><h6 id="LNPCC-GUID-65FEF4E3-1934-4159-868E-82006E03503A" class="sect6"><span class="enumeration_section">5.5.3.1.2</span>案例2：嵌套头文件包含</h6>
                        <div>
                           <p></p>
                           <p>假设文件啊包含以下语句：</p><pre class="oac_no_warn" dir="ltr">#include &lt;bh&gt;</pre><p>并且我们像以前一样预编译指定HEADER的头文件。Pro * C / C ++将预编译ah和bh，从而生成a.hdr。</p>
                           <p>现在假设我们预编译了这个Pro * C / C ++程序：</p><pre class="oac_no_warn" dir="ltr">#include &lt;ah&gt; #include &lt;bh&gt; main（）{}</pre><p>当遇到#include for ah时，将实例化a.hdr预编译头文件，而不是再次预编译啊。此实例化还将包含bh的全部内容</p>
                           <p>现在，因为bh被包含在ah的预编译中，并且a.hdr被实例化，所以我们程序中的后续#include bh是多余的，因此将被忽略。</p>
                        </div>
                     </div>
                  </div><a id="LNPCC3305"></a><div class="props_rev_3"><a id="GUID-5C049314-3F84-4349-92F7-2496716C7C5D" name="GUID-5C049314-3F84-4349-92F7-2496716C7C5D"></a><h5 id="LNPCC-GUID-5C049314-3F84-4349-92F7-2496716C7C5D" class="sect5"><span class="enumeration_section">5.5.3.2</span>多个预编译头文件</h5>
                     <div>
                        <p>Pro * C / C ++能够在单个预编译中实例化多个不同的预编译头文件。但是，当两个或多个预编译头文件共享公共头文件时，需要避免一个陷阱。</p>
                        <p>例如，假设topA.h包含以下行：</p><pre class="oac_no_warn" dir="ltr">#include &lt;ah&gt; #include &lt;ch&gt;</pre><p>并且topB.h包含以下行：</p><pre class="oac_no_warn" dir="ltr">#include &lt;bh&gt; #include &lt;ch&gt;</pre><p>注意topA.h和topB.h如何包含相同的公共头文件ch使用相同的HEADER值预编译topA.h和topB.h将产生topA.hdr和topB.hdr。但是，两者都将包含ch的全部内容</p>
                        <p>现在假设我们有一个Pro * C / C ++程序：</p><pre class="oac_no_warn" dir="ltr">#include &lt;topA.h&gt; #include &lt;topB.h&gt; main（）{}</pre><p>预编译的头文件topA.hdr和topB.hdr都将像以前一样实例化。但是，因为每个共享公共头文件ch，所以该文件的内容将被实例化两次。</p>
                        <p>Pro * C / C ++无法确定预编译头文件中何时出现这种共性。尝试让每个预编译的头文件包含一组唯一的包含头。应尽可能避免共享标头，因为它最终会减慢预编译并利用更多内存，从而破坏了使用预编译头文件的基本意图。</p>
                     </div>
                  </div>
               </div><a id="LNPCC3307"></a><a id="LNPCC3306"></a><div class="props_rev_3"><a id="GUID-F263953E-099E-471D-9A90-82C820149D76" name="GUID-F263953E-099E-471D-9A90-82C820149D76"></a><h4 id="LNPCC-GUID-F263953E-099E-471D-9A90-82C820149D76" class="sect4"><span class="enumeration_section">5.5.4</span>头文件列表</h4>
                  <div>
                     <div class="section">
                        <p><span class="italic"><code class="codeph">ORACLE_BASE\ORACLE_HOME</code></span> <code class="codeph">\precomp\public</code>目录包含Pro * C / C ++头文件。<a href="advanced-topics.html#GUID-F263953E-099E-471D-9A90-82C820149D76__g1008185" title="头文件表">表5-3</a>列出并描述了头文件。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="tblformalwide" id="GUID-F263953E-099E-471D-9A90-82C820149D76__g1008185">
                        <p class="titleintable">表5-3头文件</p>
                        <table cellpadding="4" cellspacing="0" class="FormalWide" title="头文件" width="100%" border="1" summary="Header files table" frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="25%" id="d24171e1933">头文件</th>
                                 <th align="left" valign="bottom" width="75%" id="d24171e1936">描述</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="25%" id="d24171e1941" headers="d24171e1933 ">
                                    <p><code class="codeph">oraca.h</code></p>
                                 </td>
                                 <td align="left" valign="top" width="75%" headers="d24171e1941 d24171e1936 ">
                                    <p>包含Oracle通信区域（ORACA），可帮助您诊断运行时错误并监视程序对各种Oracle数据库<span class="italic">10g</span>资源的使用。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="25%" id="d24171e1952" headers="d24171e1933 ">
                                    <p><code class="codeph">sql2oci.h</code></p>
                                 </td>
                                 <td align="left" valign="top" width="75%" headers="d24171e1952 d24171e1936 ">
                                    <p>包含SQLLIB函数，这些函数支持在Pro * C / C ++应用程序中获取Oracle调用接口（OCI）环境句柄和OCI服务上下文。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="25%" id="d24171e1960" headers="d24171e1933 ">
                                    <p><code class="codeph">sqlapr.h</code></p>
                                 </td>
                                 <td align="left" valign="top" width="75%" headers="d24171e1960 d24171e1936 ">
                                    <p>包含可与OCI结合使用的外部化函数的ANSI原型。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="25%" id="d24171e1968" headers="d24171e1933 ">
                                    <p><code class="codeph">sqlca.h中</code></p>
                                 </td>
                                 <td align="left" valign="top" width="75%" headers="d24171e1968 d24171e1936 ">
                                    <p>包含SQL通信区域（SQLCA），可帮助您诊断运行时错误。在每个可执行的SQL语句之后更新SQLCA。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="25%" id="d24171e1976" headers="d24171e1933 ">
                                    <p><code class="codeph">sqlcpr.h</code></p>
                                 </td>
                                 <td align="left" valign="top" width="75%" headers="d24171e1976 d24171e1936 ">
                                    <p>包含由Pro * C / C ++生成的SQLLIB函数的特定于平台的ANSI原型。默认情况下，Pro * C / C ++不支持SQL编程调用的全功能原型。如果需要此功能，请在应用程序源文件中的任何EXEC SQL语句之前包含<code class="codeph">sqlcpr.h</code> 。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="25%" id="d24171e1987" headers="d24171e1933 ">
                                    <p><code class="codeph">oraca.h</code></p>
                                 </td>
                                 <td align="left" valign="top" width="75%" headers="d24171e1987 d24171e1936 ">
                                    <p>包含Oracle通信区域（ORACA），可帮助您诊断运行时错误并监视程序对各种Oracle数据库<span class="italic">10g</span>资源的使用。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="25%" id="d24171e1998" headers="d24171e1933 ">
                                    <p><code class="codeph">sql2oci.h</code></p>
                                 </td>
                                 <td align="left" valign="top" width="75%" headers="d24171e1998 d24171e1936 ">
                                    <p>包含SQLLIB函数，这些函数支持在Pro * C / C ++应用程序中获取Oracle调用接口（OCI）环境句柄和OCI服务上下文。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="25%" id="d24171e2006" headers="d24171e1933 ">
                                    <p><code class="codeph">sqlapr.h</code></p>
                                 </td>
                                 <td align="left" valign="top" width="75%" headers="d24171e2006 d24171e1936 ">
                                    <p>包含可与OCI结合使用的外部化函数的ANSI原型。</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                  </div>
               </div><a id="LNPCC3308"></a><div class="props_rev_3"><a id="GUID-7AB8B31F-8EF3-4DE3-85A2-CFA0A4198E86" name="GUID-7AB8B31F-8EF3-4DE3-85A2-CFA0A4198E86"></a><h4 id="LNPCC-GUID-7AB8B31F-8EF3-4DE3-85A2-CFA0A4198E86" class="sect4"><span class="enumeration_section">5.5.5</span>期权的影响</h4>
                  <div>
                     <p>以下预编译器选项与应用程序的预编译一起使用。</p>
                  </div><a id="LNPCC3309"></a><div class="props_rev_3"><a id="GUID-3DADC20B-4718-43DD-BD13-340351FD34E8" name="GUID-3DADC20B-4718-43DD-BD13-340351FD34E8"></a><h5 id="LNPCC-GUID-3DADC20B-4718-43DD-BD13-340351FD34E8" class="sect5"><span class="enumeration_section">5.5.5.1</span>定义和包含选项</h5>
                     <div>
                        <p>在使用预编译头进行任何预编译期间，必须使用与创建预编译头文件时相同的DEFINE和INCLUDE值。如果DEFINE或INCLUDE的值发生更改，则必须重新创建预编译的头文件。</p>
                        <p>如果开发环境发生更改，则还必须重新创建预编译的头文件。</p>
                     </div><a id="LNPCC3310"></a><div class="props_rev_3"><a id="GUID-7AE3898A-3DF2-47B2-85A8-2C3F5B185E1E" name="GUID-7AE3898A-3DF2-47B2-85A8-2C3F5B185E1E"></a><h6 id="LNPCC-GUID-7AE3898A-3DF2-47B2-85A8-2C3F5B185E1E" class="sect6"><span class="enumeration_section">5.5.5.1.1</span>单用户场景</h6>
                        <div>
                           <p></p>
                           <p>考虑一个用户。如果要更改DEFINE或INCLUDE选项的值，则预编译头文件的内容可能不再适用于后续Pro * C / C ++预编译。</p>
                           <p>因为DEFINE和INCLUDE的值; DEFINE或INCLUDE选项已更改，如果正常处理#include指令中的相应.h文件，则预编译头文件的内容可能不再与标准预编译所导致的内容一致。</p>
                           <p>简而言之，如果DEFINE和INCLUDE的值; DEFINE或INCLUDE选项更改，必须重新创建任何预编译的头文件，并重新预编译使用它们的Pro * C / C ++程序。</p>
                        </div>
                        <div>
                           <div class="relinfo">
                              <p><strong>相关话题</strong></p>
                              <ul>
                                 <li><a href="precompiler-options.html#GUID-FB3D98E5-EDA9-4518-9C25-B7145476BF00">限定</a></li>
                                 <li><a href="precompiler-options.html#GUID-08EDB388-0406-4F03-9D9F-E0AAA8ADB2B5">包括</a></li>
                              </ul>
                           </div>
                        </div>
                        
                     </div><a id="LNPCC3311"></a><div class="props_rev_3"><a id="GUID-2241A146-D8F2-4C12-BC9C-00427971B125" name="GUID-2241A146-D8F2-4C12-BC9C-00427971B125"></a><h6 id="LNPCC-GUID-2241A146-D8F2-4C12-BC9C-00427971B125" class="sect6"><span class="enumeration_section">5.5.5.1.2</span>多用户场景</h6>
                        <div>
                           <p></p>
                           <p>考虑两个用户A和B，他们在完全独立的环境中开发，因此他们的DEFINE和INCLUDE选项具有完全不同的值。</p>
                           <p>用户A预编译公共头文件common.h，创建预编译头文件common.hdrA。用户B还预编译创建common.hdrB的相同头文件。但是，鉴于两个环境不同，特别是两个用户使用的DEFINE和INCLUDE选项的值，不能保证用户A和B的common.hdr版本都是相同的。</p>
                           <p>总结一下</p><pre class="oac_no_warn" dir="ltr">A&gt; proc HEADER = hdrA DEFINE = &lt;A宏&gt; INCLUDE = &lt;A dirs&gt; common.h B&gt; proc HEADER = hdrB DEFINE = &lt;B宏&gt; INCLUDE = &lt;B dirs&gt; common.h</pre><p>生成的预编译头文件common.hdrA可能与common.hdrB不同，因为它们创建的环境不同。这意味着用户A和用户B都不能保证使用由其他用户创建的common.hdr将导致在各自的开发环境中正确预编译Pro * C / C ++程序。</p>
                           <p>因此，在不同用户和不同用户的开发环境之间共享或交换预编译头文件时应该小心。</p>
                        </div>
                     </div>
                  </div><a id="LNPCC3312"></a><div class="props_rev_3"><a id="GUID-FB4BDFD5-E0DB-41CC-AC6C-B061E8BB08D3" name="GUID-FB4BDFD5-E0DB-41CC-AC6C-B061E8BB08D3"></a><h5 id="LNPCC-GUID-FB4BDFD5-E0DB-41CC-AC6C-B061E8BB08D3" class="sect5"><span class="enumeration_section">5.5.5.2</span> CODE和PARSE选项</h5>
                     <div>
                        <p>Pro * C / C ++不会搜索带有<code class="codeph">hpp</code>或<code class="codeph">h++</code>等扩展名的C ++头文件。所以在预编译头文件时不要使用CODE = CPP。只要源代码仅包含<code class="codeph">.h</code>头文件，您就可以在预编译应用程序时使用CPP值。
                        </p>
                        <p>在创建预编译头文件时，或者在预编译模块时，您只能将值FULL或PARTIAL用于PARSE选项。值FULL被认为具有比PARTIAL更高的值。在预编译模块时，使用的PARSE值应与创建预编译头文件时的值相同或更低。</p>
                        <div class="infoboxnote" id="GUID-FB4BDFD5-E0DB-41CC-AC6C-B061E8BB08D3__GUID-1EC735D8-5E63-41B2-B7D1-FD200CFAB6A5">
                           <p class="notep1">注意：</p>
                           <p>使用PARSE = FULL预编译预编译头文件，然后使用PARSE = PARTIAL预编译模块，需要在Declare Section中声明主变量。只有在PARSE = PARTIAL时才能理解C ++代码。</p>
                        </div>
                        <p>假设我们预编译PARSE设置为PARTIAL的头文件，如下所示：</p><pre class="oac_no_warn" dir="ltr">proc HEADER = hdr PARSE = PARTIAL file.h</pre><p>然后尝试使用PARSE设置为FULL预编译包含该头文件的程序：</p><pre class="oac_no_warn" dir="ltr">proc HEADER = hdr PARSE = FULL program.pc</pre><p>因为file.h是使用PARSE选项的PARTIAL设置进行预编译的，所以不会处理所有头文件。因此，如果对未处理部分中的某些内容进行了引用，则在Pro * C / C ++程序的预编译期间可能会发生错误。</p>
                        <p>为了说明，假设file.h包含以下代码：</p><pre class="oac_no_warn" dir="ltr">#define LENGTH 10 typedef int myint;</pre><p>并且我们的program.pc包含以下简短程序：</p><pre class="oac_no_warn" dir="ltr">#include &lt;file.h&gt; main（）{VARCHAR ename [LENGTH]; myint empno = ...; EXEC SQL SELECT ename INTO：ename WHERE JOB =：empno; }</pre><p>因为在预编译file.h时PARSE被设置为PARTIAL，所以只处理LENGTH宏而不显示typedef。</p>
                        <p>VARCHAR声明和后续用作主变量将成功。但是，使用empno主变量不会，因为Pro * C / C ++永远不会处理<code class="codeph">myint</code>类型声明。
                        </p>
                        <p>在PARSE选项设置为FULL的情况下预编译头文件，然后在PARSE设置为PARTIAL的情况下预编译程序将起作用。但是，主变量必须在显式DECLARE SECTION中声明。</p>
                     </div>
                     <div>
                        <div class="relinfo">
                           <p><strong>相关话题</strong></p>
                           <ul>
                              <li><a href="C-Plus-Plus-Applications.html#GUID-EDDF500B-2973-4D1B-AC10-4952AE29E44D">关于解析代码</a></li>
                              <li><a href="precompiler-options.html#GUID-EA4E8928-3B92-4A29-BC1B-C726BFE4B79A">码</a></li>
                              <li><a href="precompiler-options.html#GUID-20415049-4CCA-4D5F-AA7D-794511D5FDD6">PARSE</a></li>
                           </ul>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="LNPCC3313"></a><div class="props_rev_3"><a id="GUID-61C3B28A-3FD9-437B-91B2-2B11B5568F85" name="GUID-61C3B28A-3FD9-437B-91B2-2B11B5568F85"></a><h4 id="LNPCC-GUID-61C3B28A-3FD9-437B-91B2-2B11B5568F85" class="sect4"><span class="enumeration_section">5.5.6</span>使用说明</h4>
                  <div>
                     <p>预编译头的生成输出文件的文件格式不保证从一个版本到下一个版本保持固定。Pro * C / C ++无法确定使用哪个版本的预编译器来生成预编译的头文件输出。</p>
                     <p>因此，强烈建议为了避免在使用预编译头文件的预编译期间出现错误或其他奇怪行为的可能性，通过在升级到Pro的较新版本时重新预编译相应的头文件来重新生成这些文件。 * C / C ++。</p>
                     <p>从头文件的预编译生成的输出是完全不可移植的。这意味着您无法将输出文件从头文件的预编译从一个平台传输到另一个平台，并在随后的另一个头文件或Pro * C / C ++程序的预编译期间使用该文件。</p>
                  </div>
               </div>
            </div><a id="LNPCC3314"></a><div class="props_rev_3"><a id="GUID-D4E3B927-B812-4BAB-BAA3-F9543F151F89" name="GUID-D4E3B927-B812-4BAB-BAA3-F9543F151F89"></a><h3 id="LNPCC-GUID-D4E3B927-B812-4BAB-BAA3-F9543F151F89" class="sect3"><span class="enumeration_section">5.6</span> Oracle预处理器</h3>
               <div>
                  <p>代码的条件部分由EXEC ORACLE指令标记，这些指令定义了要采取的环境和操作。您可以在这些部分中编写C语句以及嵌入式SQL语句和指令。以下EXEC ORACLE指令允许您对预编译执行条件控制：<a id="d24171e2216" class="indexterm-anchor"></a><a id="d24171e2218" class="indexterm-anchor"></a><a id="d24171e2220" class="indexterm-anchor"></a><a id="d24171e2222" class="indexterm-anchor"></a><a id="d24171e2224" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">EXEC ORACLE DEFINE符号; - 定义符号EXEC ORACLE IFDEF符号; - 如果符号定义为EXEC ORACLE IFNDEF符号; - 如果符号未定义EXEC ORACLE ELSE; - 否则EXEC ORACLE ENDIF; - 结束这个街区</pre><p>所有EXEC ORACLE语句必须以分号结束。</p>
               </div><a id="LNPCC3315"></a><div class="props_rev_3"><a id="GUID-669E0976-D842-4E69-89ED-461BF8D40842" name="GUID-669E0976-D842-4E69-89ED-461BF8D40842"></a><h4 id="LNPCC-GUID-669E0976-D842-4E69-89ED-461BF8D40842" class="sect4"><span class="enumeration_section">5.6.1</span>符号定义</h4>
                  <div>
                     <p>您可以通过两种方式定义符号。要么包括声明<a id="d24171e2241" class="indexterm-anchor"></a> ：</p><pre class="oac_no_warn" dir="ltr">EXEC ORACLE DEFINE符号;</pre><p>在您的主机程序中或使用语法在命令行上定义符号</p><pre class="oac_no_warn" dir="ltr">...INAME =文件名...DEFINE =符号</pre><p><span class="italic">符号</span>不区分大小写。
                     </p>
                     <div class="infoboxnote" id="GUID-669E0976-D842-4E69-89ED-461BF8D40842__GUID-94C56D63-B000-4237-B93C-435129DFDB71">
                        <p class="notep1">注意：</p>
                        <p><code class="codeph">#define</code>预处理程序指令与EXEC ORACLE DEFINE命令不同。
                        </p>
                     </div>
                     <p>在系统上安装Pro * C / C ++预编译器时，会为您预定义某些特定于端口的符号。</p>
                  </div>
               </div><a id="LNPCC3316"></a><div class="props_rev_3"><a id="GUID-751EDDFD-0343-4B2E-9A6F-4D3F8D7B5752" name="GUID-751EDDFD-0343-4B2E-9A6F-4D3F8D7B5752"></a><h4 id="LNPCC-GUID-751EDDFD-0343-4B2E-9A6F-4D3F8D7B5752" class="sect4"><span class="enumeration_section">5.6.2</span> Oracle预处理器示例</h4>
                  <div>
                     <p>在以下示例中，仅在定义符号<span class="italic">site2</span>时才预编译SELECT语句：<a id="d24171e2285" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">EXEC ORACLE IFDEF site2; EXEC SQL SELECT DNAME INTO：dept_name FROM DEPT WHERE DEPTNO =：dept_number; EXEC ORACLE ENDIF;</pre><p>条件块可以嵌套，如以下示例所示：</p><pre class="oac_no_warn" dir="ltr">EXEC ORACLE IFDEF外部; EXEC ORACLE IFDEF内部; ...EXEC ORACLE ENDIF; EXEC ORACLE ENDIF;</pre><p>您可以通过将它放在IFDEF和ENDIF之间而<span class="italic">不是</span>定义符号来“注释掉”C或嵌入式SQL代码。
                     </p>
                  </div>
               </div>
            </div><a id="LNPCC3317"></a><div class="props_rev_3"><a id="GUID-1C948990-B5FF-411D-BAC3-930E2FE82972" name="GUID-1C948990-B5FF-411D-BAC3-930E2FE82972"></a><h3 id="LNPCC-GUID-1C948990-B5FF-411D-BAC3-930E2FE82972" class="sect3"><span class="enumeration_section">5.7</span>数值常数的评估</h3>
               <div>
                  <p>以前，在声明主变量（例如<code class="codeph">char</code>或<code class="codeph">VARCHAR</code> ）的大小时，Pro * C / C ++只允许使用数字文字和涉及数字文字的简单常量表达式，如以下示例所示：</p><pre class="oac_no_warn" dir="ltr">#define LENGTH 10 VARCHAR v [LENGTH]; char c [LENGTH + 1];</pre><p>您现在还可以使用数字常量声明，例如：</p><pre class="oac_no_warn" dir="ltr">const int length = 10; VARCHAR v [length]; char c [length + 1];</pre><p>这是非常需要的，特别是对于使用支持这种常量声明的ANSI或C ++编译器的程序员。</p>
                  <p>Pro * C / C ++总是确定可以计算的常量表达式的值，但它从未允许在任何常量表达式中使用数值常量声明。</p>
                  <p>Pro * C / C ++支持在使用普通数字文字或宏的任何地方使用数字常量声明，因为宏扩展为某些数字文字。</p>
                  <p>这主要用于声明要在SQL语句中使用的绑定变量的数组大小。</p>
               </div><a id="LNPCC3318"></a><div class="props_rev_3"><a id="GUID-386F33E3-570E-4895-B1D6-BAB7CBAD3875" name="GUID-386F33E3-570E-4895-B1D6-BAB7CBAD3875"></a><h4 id="LNPCC-GUID-386F33E3-570E-4895-B1D6-BAB7CBAD3875" class="sect4"><span class="enumeration_section">5.7.1</span> Pro * C / C ++中的数字常量</h4>
                  <div>
                     <p>在Pro * C / C ++中，常规C作用域规则用于查找和定位数字常量声明的声明。</p><pre class="oac_no_warn" dir="ltr">const int g = 30; / * function_1（）和function_2（）的全局声明* / void function_1（）{const int a = 10; / *仅对function_1（）* / char x [a]进行本地声明; exec sql select ename into：x from emp where job ='PRESIDENT'; } void function_2（）{const int a = 20; / *仅对function_2（）* / VARCHAR v [a]进行本地声明; exec sql select ename into：v from emp where job ='PRESIDENT'; } void main（）{char m [g]; / *全局g * / exec sql选择ename into：m from emp where job ='PRESIDENT'; }</pre></div>
               </div><a id="LNPCC3319"></a><div class="props_rev_3"><a id="GUID-9273AFA8-247C-4E3C-8CC4-5B967E514040" name="GUID-9273AFA8-247C-4E3C-8CC4-5B967E514040"></a><h4 id="LNPCC-GUID-9273AFA8-247C-4E3C-8CC4-5B967E514040" class="sect4"><span class="enumeration_section">5.7.2</span>数值常量规则和示例</h4>
                  <div>
                     <p>具有特定静态类型的变量需要使用<span class="bold">静态</span>和初始化来定义。在Pro * C / C ++中声明数字常量时，必须牢记以下规则：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>声明常量时必须使用<span class="bold">const</span>限定符<a id="d24171e2365" class="indexterm-anchor"></a></p>
                        </li>
                        <li>
                           <p>必须使用初始值设定项来初始化常量的值。此初始化程序必须是预编译时可评估的。</p>
                        </li>
                     </ul>
                     <p>任何尝试使用未解析为具有有效初始化程序的常量声明的标识符都被视为错误。</p>
                     <p>以下显示了不允许的内容和原因的示例：</p><pre class="oac_no_warn" dir="ltr">int a; int b = 10;挥发性的;挥发性d = 10;常数; const f = b; VARCHAR v1 [a]; / *没有const限定符，缺少初始化程序* / VARCHAR v2 [b]; / *没有const限定符* / VARCHAR v3 [c]; / *不是常数，缺少初始化器* / VARCHAR v4 [d]; / *不是常数* / VARCHAR v5 [e]; / *缺少初始化程序* / VARCHAR v6 [f]; / *错误的初始化程序.. b不是常量* /</pre></div>
               </div>
            </div><a id="LNPCC3320"></a><div class="props_rev_3"><a id="GUID-5A1F44A6-4B41-4610-B265-C56C85261379" name="GUID-5A1F44A6-4B41-4610-B265-C56C85261379"></a><h3 id="LNPCC-GUID-5A1F44A6-4B41-4610-B265-C56C85261379" class="sect3"><span class="enumeration_section">5.8</span>针对OCI Release 8互操作性的SQLLIB扩展</h3>
               <div>
                  <p>OCI环境句柄将与Pro * C / C ++运行时上下文绑定，后者属于<span class="italic">sql_context</span>类型。也就是说，SQLLIB在应用程序执行期间维护的一个Pro * C / C ++运行时上下文将与最多一个OCI环境句柄相关联。每个Pro * C / C ++运行时上下文允许多个数据库连接，这些连接将与运行时上下文的OCI环境句柄相关联。
                  </p>
                  <div class="infoboxnote" id="GUID-5A1F44A6-4B41-4610-B265-C56C85261379__GUID-F220704B-4020-4471-91C5-4BD570C28EBA">
                     <p class="notep1">注意：</p>
                     <p>预编译器应用程序可以提取OCI句柄并直接调用OCI函数。但是，不支持非阻塞模式，因为预编译器无法处理可能返回的“仍在执行”的错误。</p>
                  </div>
               </div><a id="LNPCC3321"></a><div class="props_rev_3"><a id="GUID-D7AD0AC1-3E2C-42A1-B9F8-43D9A48954EE" name="GUID-D7AD0AC1-3E2C-42A1-B9F8-43D9A48954EE"></a><h4 id="LNPCC-GUID-D7AD0AC1-3E2C-42A1-B9F8-43D9A48954EE" class="sect4"><span class="enumeration_section">5.8.1</span> OCI Release 8环境中的运行时上下文</h4>
                  <div>
                     <p>EXEC SQL CONTEXT USE语句指定要在Pro * C / C ++程序中使用的运行时上下文。此上下文适用于在给定Pro * C / C ++文件中位于其后的所有可执行SQL语句，直到发生另一个EXEC SQL CONTEXT USE语句。如果源文件中没有出现EXEC SQL CONTEXT USE，则假定使用默认的“全局”上下文。因此，当前运行时上下文以及当前OCI环境句柄在程序中的任何点都是已知的。</p>
                     <p>在Pro * C / C ++中使用EXEC SQL CONNECT执行数据库登录时，将初始化运行时上下文及其关联的OCI环境句柄。</p>
                     <p>使用EXEC SQL CONTEXT FREE语句释放Pro * C / C ++运行时上下文时，将终止关联的OCI环境句柄，并取消分配其所有资源，例如为各种OCI句柄和LOB定位符分配的空间。此命令释放与Pro * C / C ++运行时上下文关联的所有其他内存。为默认“全局”运行时建立的OCI环境句柄将保持分配，直到Pro * C / C ++程序终止。</p>
                  </div>
               </div><a id="LNPCC3322"></a><div class="props_rev_3"><a id="GUID-16D7605D-0629-4345-AD0A-085BFE9214E7" name="GUID-16D7605D-0629-4345-AD0A-085BFE9214E7"></a><h4 id="LNPCC-GUID-16D7605D-0629-4345-AD0A-085BFE9214E7" class="sect4"><span class="enumeration_section">5.8.2</span> OCI Release 8环境句柄中的参数</h4>
                  <div>
                     <p>通过Pro * C / C ++建立的OCI环境将使用以下参数：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>环境用于分配内存，释放内存，写入文本文件以及刷新输出缓冲区的回调函数将是调用malloc（），free（），fprintf（stderr，...）和fflush的简单函数。 （stderr）分别。</p>
                        </li>
                        <li>
                           <p>该语言将从全球化支持变量NLS_LANG获得。</p>
                        </li>
                        <li>
                           <p>错误消息缓冲区将在特定于线程的存储中分配。</p>
                        </li>
                     </ul>
                  </div>
               </div>
            </div><a id="LNPCC3323"></a><div class="props_rev_3"><a id="GUID-06CCA89B-2D4C-4540-AC72-CFE65735EB58" name="GUID-06CCA89B-2D4C-4540-AC72-CFE65735EB58"></a><h3 id="LNPCC-GUID-06CCA89B-2D4C-4540-AC72-CFE65735EB58" class="sect3"><span class="enumeration_section">5.9</span>与OCI版本8的接口</h3>
               <div>
                  <p>SQLLIB库提供例程来获取通过Pro * C / C ++程序建立的数据库连接的OCI环境和服务上下文句柄。一旦获得OCI句柄，用户就可以调用各种OCI例程，例如，执行客户端DATE算法，对对象执行导航操作等。这些SQLLIB函数将在后面描述，它们的原型可以在公共头文件<code class="codeph">sql2oci.h</code> 。
                  </p>
                  <p>在其他Oracle编程接口中混合嵌入式SQL和调用的Pro * C / C ++用户必须谨慎行事。例如，如果用户使用OCI接口直接终止连接，则SQLLIB状态不同步;在这种情况下，Pro * C / C ++程序中后续SQL语句的行为是不确定的。</p>
                  <div class="infoboxnote" id="GUID-06CCA89B-2D4C-4540-AC72-CFE65735EB58__GUID-5D2FDEED-5499-4916-BF56-29DA0ED6DB4B">
                     <p class="notep1">注意：</p>
                     <p>Pro * C / C ++，Oracle调用接口（OCI）版本8和XA <span class="italic">不</span>兼容。
                     </p>
                  </div>
                  <p>提供与Oracle OCI的互操作性的新SQLLIB函数在头文件<code class="codeph">sql2oci.h</code>中声明：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><code class="codeph">SQLEnvGet()</code> ，返回指向与给定SQLLIB运行时上下文关联的OCI环境句柄的指针。用于单一和共享服务器环境。
                        </p>
                     </li>
                     <li>
                        <p><code class="codeph">SQLSvcCtxGet()</code> ，用于返回Pro * C / C ++数据库连接的OCI服务上下文句柄。用于单一和共享服务器环境。
                        </p>
                     </li>
                     <li>
                        <p><a id="d24171e2510" class="indexterm-anchor"></a>当使用单线程运行时上下文时，在包含sql2oci.h时，将常量<code class="codeph">SQL_SINGLE_RCTX</code> （定义为<code class="codeph">(dvoid *)0</code>作为任一函数中的第一个参数传递。
                        </p>
                     </li>
                  </ul>
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="about-Objects.html#GUID-0C106FBC-C023-4B86-817A-1867A69388F7">对象</a></li>
                     </ul>
                  </div>
               </div>
               <a id="LNPCC3324"></a><div class="props_rev_3"><a id="GUID-62D0DA6E-EC6F-47FC-A651-F175D7E8CB64" name="GUID-62D0DA6E-EC6F-47FC-A651-F175D7E8CB64"></a><h4 id="LNPCC-GUID-62D0DA6E-EC6F-47FC-A651-F175D7E8CB64" class="sect4"><span class="enumeration_section">5.9.1</span> SQLEnvGet（）</h4>
                  <div>
                     <p>SQLLIB库函数<code class="codeph">SQLEnvGet()</code> （SQLLIB OCI Environment Get）返回指向与给定SQLLIB运行时上下文关联的OCI环境句柄的指针。该功能的原型是：</p><pre class="oac_no_warn" dir="ltr">剑SQLEnvGet（dvoid * rctx，OCIEnv ** oeh）;</pre><p>哪里：</p>
                     <div class="tblformal" id="GUID-62D0DA6E-EC6F-47FC-A651-F175D7E8CB64__GUID-5BA39C5C-A99D-4186-8CB7-6A038CEDFD52">
                        <table cellpadding="4" cellspacing="0" class="Formal" title="" width="100%" border="1" summary="Terms" frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="29%" id="d24171e2564">条款</th>
                                 <th align="left" valign="bottom" width="71%" id="d24171e2567">描述</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d24171e2572" headers="d24171e2564 ">
                                    <p>描述</p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d24171e2572 d24171e2567 ">
                                    <p>设置<span class="italic">OEH</span>的OCIEnv对应的运行时环境</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d24171e2582" headers="d24171e2564 ">
                                    <p>参数</p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d24171e2582 d24171e2567 ">
                                    <p><span class="italic">rctx</span> （IN）指向SQLLIB运行时上下文的指针</p>
                                    <p><span class="italic">oeh</span> （OUT）指向OCIEnv的指针</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d24171e2595" headers="d24171e2564 ">
                                    <p>返回</p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d24171e2595 d24171e2567 ">
                                    <p>SQL_SUCCESS成功</p>
                                    <p>SQL_ERROR失败</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d24171e2604" headers="d24171e2564 ">
                                    <p>笔记</p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d24171e2604 d24171e2567 ">
                                    <p>Pro * C / C ++中常见的错误状态变量（如SQLCA和SQLSTATE）不会受到对此函数的调用的影响</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                  </div>
               </div><a id="LNPCC3325"></a><div class="props_rev_3"><a id="GUID-B5BE914E-0F89-4A98-8379-CE8A856936BE" name="GUID-B5BE914E-0F89-4A98-8379-CE8A856936BE"></a><h4 id="LNPCC-GUID-B5BE914E-0F89-4A98-8379-CE8A856936BE" class="sect4"><span class="enumeration_section">5.9.2</span> SQLSvcCtxGet（）</h4>
                  <div>
                     <p>SQLLIB库函数<code class="codeph">SQLSvcCtxGet()</code> （SQLLIB OCI服务上下文Get）返回Pro * C / C ++数据库连接的OCI服务上下文。然后可以将OCI服务上下文用于对OCI功能的直接调用。该功能的原型是：</p><pre class="oac_no_warn" dir="ltr">剑SQLSvcCtxGet（dvoid * rctx，text * dbname，sb4 dbnamelen，OCISvcCtx ** svc）;</pre><p>哪里：</p>
                     <div class="tblformal" id="GUID-B5BE914E-0F89-4A98-8379-CE8A856936BE__GUID-F5F7B899-4F95-4542-8AB0-9C98760D7B8C">
                        <table cellpadding="4" cellspacing="0" class="Formal" title="" width="100%" border="1" summary="Terms" frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="29%" id="d24171e2645">条款</th>
                                 <th align="left" valign="bottom" width="71%" id="d24171e2648">描述</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d24171e2653" headers="d24171e2645 ">
                                    <p>描述</p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d24171e2653 d24171e2648 ">
                                    <p>将<span class="italic">svc</span>设置为与运行时上下文对应的OCI服务上下文</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d24171e2663" headers="d24171e2645 ">
                                    <p>参数</p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d24171e2663 d24171e2648 ">
                                    <p><span class="italic">rctx</span> （IN）=指向SQLLIB运行时上下文的指针</p>
                                    <p><span class="italic">dbname</span> （IN）=包含此连接的“逻辑”名称的缓冲区</p>
                                    <p><span class="italic">dbnamelen</span> （IN）= dbname缓冲区的长度</p>
                                    <p><span class="italic">svc</span> （OUT）= OCISvcCtx指针的地址</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d24171e2684" headers="d24171e2645 ">
                                    <p>返回</p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d24171e2684 d24171e2648 ">
                                    <p>SQL_SUCCESS成功</p>
                                    <p>SQL_ERROR失败</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d24171e2693" headers="d24171e2645 ">
                                    <p>笔记</p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d24171e2693 d24171e2648 ">
                                    <p>1。Pro * C / C ++中常见的错误状态变量（如SQLCA和SQLSTATE）不会受到对此函数的调用的影响</p>
                                    <p><span class="italic">2. dbname</span>是嵌入式SQL语句中AT子句中使用的相同标识符。
                                    </p>
                                    <p>3。如果<span class="italic">dbname</span>是空指针或<span class="italic">dbnamelen</span>为0，则假定为缺省数据库连接，如在没有AT子句的SQL语句中。
                                    </p>
                                    <p>4。<span class="italic">dbnamelen的</span>值为-1表示<span class="italic">dbname</span>是以零结尾的字符串。
                                    </p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                  </div>
               </div><a id="LNPCC3326"></a><div class="props_rev_3"><a id="GUID-2C5F531E-BF2B-4B13-B906-8C8FA388FC34" name="GUID-2C5F531E-BF2B-4B13-B906-8C8FA388FC34"></a><h4 id="LNPCC-GUID-2C5F531E-BF2B-4B13-B906-8C8FA388FC34" class="sect4"><span class="enumeration_section">5.9.3</span>嵌入式OCI版本8呼叫</h4>
                  <div>
                     <div class="section">
                        <p>要在Pro * C / C ++程序中嵌入OCI版本8调用：</p>
                        <p>1。包括公共头sql2oci.h</p>
                        <p>2。在Pro * C / C ++程序中声明一个环境句柄（类型OCIEnv *）：</p><pre class="oac_no_warn" dir="ltr">OCIEnv * oeh;</pre><p>3。（可选）如果要调用的OCI函数需要服务上下文句柄，则在Pro * C / C ++程序中声明服务上下文句柄（键入OCISvcCtx *）。</p><pre class="oac_no_warn" dir="ltr">OCISvcCtx * svc;</pre><p>4。在Pro * C / C ++程序中声明错误句柄（类型OCIError *）：</p><pre class="oac_no_warn" dir="ltr">OCIError *错误;</pre><p>5。使用嵌入式SQL语句CONNECT连接到Oracle。不要使用OCI连接。</p><pre class="oac_no_warn" dir="ltr">EXEC SQL CONNECT ...
</pre><p>6。使用SQLEnvGet函数获取与所需运行时上下文关联的OCI Environment句柄。</p>
                        <p>对于单线程应用程序：</p><pre class="oac_no_warn" dir="ltr">retcode = SQLEnvGet（SQL_SINGLE_RCTX，＆oeh）;</pre><p>或者共享服务器应用程序：</p><pre class="oac_no_warn" dir="ltr">sql_context ctx1; ...EXEC SQL语境分配：ctx1; EXEC SQL语境使用：ctx1; ...EXEC SQL CONNECT：uid IDENTIFIED BY：pwd; ...retcode = SQLEnvGet（ctx1，＆oeh）;</pre><p>7。使用检索到的环境句柄分配OCI错误句柄：</p><pre class="oac_no_warn" dir="ltr">retcode = OCIHandleAlloc（（dvoid *）oeh，（dvoid **）＆err，（ub4）OCI_HTYPE_ERROR，（ub4）0，（dvoid **）0）;</pre><p>8。（可选）如果您使用的OCI调用需要，请使用SQLSvcCtxGet调用获取OCIServiceContext句柄：</p>
                        <p>对于单线程应用程序：</p><pre class="oac_no_warn" dir="ltr">retcode = SQLSvcCtxGet（SQL_SINGLE_RCTX，（text *）dbname，（ub4）dbnlen，＆svc）;</pre><p>或者，对于共享服务器环境应用程序</p><pre class="oac_no_warn" dir="ltr">sql_context ctx1; ...EXEC SQL ALLOCATE：ctx1; EXEC SQL语境使用：ctx1; ...EXEC SQL CONNECT：uid IDENTIFIED BY：pwd AT：dbname USING：hst; ...retcode = SQLSvcCtxGet（ctx1，（text *）dbname，（ub4）strlen（dbname），＆svc）;</pre><div class="infoboxnote" id="GUID-2C5F531E-BF2B-4B13-B906-8C8FA388FC34__GUID-58C2A81E-628B-4196-B62C-6A36E9404D27">
                           <p class="notep1">注意：</p>
                           <p>如果Pro * C / C ++连接未使用AT子句命名，则可以将空指针作为<span class="italic">dbname</span>传递。
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="LNPCC3327"></a><div class="props_rev_3"><a id="GUID-B98BBAC5-9F84-4705-8802-16BA852B4B45" name="GUID-B98BBAC5-9F84-4705-8802-16BA852B4B45"></a><h3 id="LNPCC-GUID-B98BBAC5-9F84-4705-8802-16BA852B4B45" class="sect3"><span class="enumeration_section">5.10</span>嵌入式OCI版本7呼叫</h3>
               <div>
                  <div class="infoboxnote" id="GUID-B98BBAC5-9F84-4705-8802-16BA852B4B45__GUID-79338607-F1E9-4EBD-B40D-09DDE8A7A6B7">
                     <p class="notep1">注意：</p>
                     <p><span class="italic">不再支持</span>登录数据区（LDA）。不支持在Pro * C / C ++程序中嵌入OCI Release 7调用的功能。
                     </p>
                  </div>
                  <p>要在Pro * C / C ++程序中嵌入OCI版本7调用，请执行以下步骤：<a id="d24171e2810" class="indexterm-anchor"></a><a id="d24171e2814" class="indexterm-anchor"></a><a id="d24171e2816" class="indexterm-anchor"></a></p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>在Pro * C / C ++程序中声明OCI登录数据区（LDA）（如果使用MODE = ANSI预编译，则在声明部分之外）。LDA是OCI头文件<code class="codeph">oci.h</code>定义的结构。有关详细信息，请参阅Oracle Call Interface程序员版本7的指南。<span class="italic"></span></p>
                     </li>
                     <li>
                        <p>使用嵌入式SQL语句CONNECT，而不是OCI连接到Oracle <code class="codeph">orlon()</code>或<code class="codeph">onblon()</code>的调用。<a id="d24171e2835" class="indexterm-anchor"></a><a id="d24171e2839" class="indexterm-anchor"></a></p>
                     </li>
                     <li>
                        <p>调用SQLLIB运行时库函数<code class="codeph">sqllda(</code> ）来设置LDA.SQLLIB函数</p>
                     </li>
                  </ul>
                  <p>这样，Pro * C / C ++预编译器和OCI“知道”他们正在一起工作。但是，没有共享Oracle游标。</p>
                  <p>您无需担心声明OCI主机数据区（HDA），因为Oracle运行时库管理连接并为您维护HDA。</p>
               </div><a id="LNPCC3328"></a><div class="props_rev_3"><a id="GUID-AA0B9FDE-E982-4751-B350-CC93B1006D1C" name="GUID-AA0B9FDE-E982-4751-B350-CC93B1006D1C"></a><h4 id="LNPCC-GUID-AA0B9FDE-E982-4751-B350-CC93B1006D1C" class="sect4"><span class="enumeration_section">5.10.1</span>设置LDA</h4>
                  <div>
                     <p>您通过发出OCI呼叫来设置LDA</p><pre class="oac_no_warn" dir="ltr">sqllda（LDA）;</pre><p>其中<span class="italic">lda</span>标识LDA数据结构。
                     </p>
                     <p>如果安装失败，则<span class="italic">lda中</span>的<span class="italic">lda_rc</span>字段设置为1012以指示错误。
                     </p>
                  </div>
               </div><a id="LNPCC3329"></a><div class="props_rev_3"><a id="GUID-032607D3-8000-469F-9CBA-249CAF45EC53" name="GUID-032607D3-8000-469F-9CBA-249CAF45EC53"></a><h4 id="LNPCC-GUID-032607D3-8000-469F-9CBA-249CAF45EC53" class="sect4"><span class="enumeration_section">5.10.2</span>远程和多连接</h4>
                  <div>
                     <p>对<code class="codeph">sqllda()</code>调用为最近执行的SQL语句使用的连接设置LDA。要设置其他连接所需的不同LDA， <span class="italic">必须</span>在每个CONNECT之后<span class="italic">立即</span>使用不同的LDA调用<code class="codeph">sqllda()</code> 。在以下示例中，您同时连接到两个非默认数据库：</p><pre class="oac_no_warn" dir="ltr">#include &lt;ocidfn.h&gt; Lda_Def lda1; Lda_Def lda2; char username [10]，password [10]，db_string1 [20]，dbstring2 [20]; ...strcpy（用户名，“scott”）; strcpy（密码，“老虎”）; strcpy（db_string1，“NYNON”）; strcpy（db_string2，“CHINON”）; / *为每个数据库连接提供唯一的名称* / EXEC SQL DECLARE DB_NAME1 DATABASE; EXEC SQL DECLARE DB_NAME2 DATABASE; / *连接到第一个非默认数据库* / EXEC SQL CONNECT：username IDENTIFIED BY：password; AT DB_NAME1使用：db_string1; / *设置第一个LDA * / sqllda（＆lda1）; / *连接到第二个非默认数据库* / EXEC SQL CONNECT：username IDENTIFIED BY：password; AT DB_NAME2使用：db_string2; / *设置第二个LDA * / sqllda（＆lda2）;</pre><p>DB_NAME1和DB_NAME2 <span class="italic">不是</span> C变量;它们是SQL标识符。您仅使用它们来命名两个非默认节点上的默认数据库，以便以后的SQL语句可以按名称引用数据库。
                     </p>
                  </div>
               </div>
            </div><a id="LNPCC3331"></a><a id="LNPCC3330"></a><div class="props_rev_3"><a id="GUID-3B79020D-735A-47A9-84DA-401D86E8F712" name="GUID-3B79020D-735A-47A9-84DA-401D86E8F712"></a><h3 id="LNPCC-GUID-3B79020D-735A-47A9-84DA-401D86E8F712" class="sect3"><span class="enumeration_section">5.11</span> SQLLIB公共函数的新名称</h3>
               <div>
                  <p><a href="advanced-topics.html#GUID-3B79020D-735A-47A9-84DA-401D86E8F712__G450022" title="TSQLLIB公共功能 - 新名称">表5-4</a>中列出了SQLLIB函数的名称。您可以将这些SQLLIB函数用于线程和非线程应用程序。以前，例如， <code class="codeph">sqlglm()</code>被记录为此函数的非线程或默认上下文版本，而<code class="codeph">sqlglmt()</code>是线程或非默认上下文版本，上下文作为第一个参数。名称<code class="codeph">sqlglm()</code>和<code class="codeph">sqlglmt()</code>仍然可用。新函数<code class="codeph">SQLErrorGetText()</code>需要与<code class="codeph">sqlglmt()</code>相同的参数。对于非线程或默认上下文应用程序，传递定义的常量<a id="d24171e2963" class="indexterm-anchor"></a> SQL_SINGLE_RCTX作为上下文。
                  </p>
                  <p>每个标准SQLLIB公共函数都是线程安全的，并接受运行时上下文作为第一个参数。例如， <code class="codeph">SQLErrorGetText()</code>的语法是：</p><pre class="oac_no_warn" dir="ltr">void SQLErrorGetText（dvoid * context，char * message_buffer，size_t * buffer_size，size_t * message_length）;</pre><p>总之，旧的函数名称将继续在现有的应用程序中工作。您可以在要编写的新应用程序中使用新的函数名称。</p>
                  <p><a href="advanced-topics.html#GUID-3B79020D-735A-47A9-84DA-401D86E8F712__G450022" title="TSQLLIB公共功能 - 新名称">表5-4</a>列出了所有SQLLIB公共函数及其相应的语法。提供了对非线程或默认上下文用法的交叉引用，以帮助您找到更完整的描述。
                  </p>
                  <div class="tblformalwide" id="GUID-3B79020D-735A-47A9-84DA-401D86E8F712__G450022">
                     <p class="titleintable">表5-4 SQLLIB公共函数 - 新名称</p>
                     <table cellpadding="4" cellspacing="0" class="FormalWide" title="SQLLIB公共函数 - 新名称" width="100%" border="1" summary="TSQLLIB Public Funcitons - New Names" frame="hsides" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="25%" id="d24171e2994">旧名</th>
                              <th align="left" valign="bottom" width="37%" id="d24171e2997">新功能原型</th>
                              <th align="left" valign="bottom" width="37%" id="d24171e3000">交叉引用</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="25%" id="d24171e3005" headers="d24171e2994 ">
                                 <p><code class="codeph">sqlaldt（）</code></p>
                              </td>
                              <td align="left" valign="top" width="37%" headers="d24171e3005 d24171e2997 "><pre class="oac_no_warn" dir="ltr">struct SQLDA * SQLSQLDAAlloc（dvoid * context，unsigned int maximum_variables，unsigned int maximum_name_length，unsigned int maximum_ind_name_length）;<a id="d24171e3012" class="indexterm-anchor"></a><a id="d24171e3016" class="indexterm-anchor"></a><a id="d24171e3018" class="indexterm-anchor"></a></pre></td>
                              <td align="left" valign="top" width="37%" headers="d24171e3005 d24171e3000 ">
                                 <p>另请参阅<span class="q">“ <a href="Oracle-dynamic-SQL-method-4.html#GUID-0523C053-0F0C-40B2-A22E-4D2860001A8A">分配SQLDA</a> ”</span> 。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="25%" id="d24171e3031" headers="d24171e2994 ">
                                 <p><code class="codeph">sqlcdat（）</code></p>
                              </td>
                              <td align="left" valign="top" width="37%" headers="d24171e3031 d24171e2997 "><pre class="oac_no_warn" dir="ltr">void SQLCDAFromResultSetCursor（dvoid * context，Cda_Def * cda，void * cursor，sword * return_value）;<a id="d24171e3038" class="indexterm-anchor"></a><a id="d24171e3042" class="indexterm-anchor"></a><a id="d24171e3044" class="indexterm-anchor"></a></pre></td>
                              <td align="left" valign="top" width="37%" headers="d24171e3031 d24171e3000 ">
                                 <p>另请参见<span class="q">“ <a href="datatypes-and-host-variables.html#GUID-86514859-8929-47EA-AE78-9D8831BB5838">使用OCI的光标变量（仅限第7版）</a> ”</span> 。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="25%" id="d24171e3059" headers="d24171e2994 ">
                                 <p><code class="codeph">sqlclut（）</code></p>
                              </td>
                              <td align="left" valign="top" width="37%" headers="d24171e3059 d24171e2997 "><pre class="oac_no_warn" dir="ltr">void SQLSQLDAFree（dvoid * context，struct SQLDA * descriptor_name）;<a id="d24171e3066" class="indexterm-anchor"></a><a id="d24171e3070" class="indexterm-anchor"></a><a id="d24171e3072" class="indexterm-anchor"></a></pre></td>
                              <td align="left" valign="top" width="37%" headers="d24171e3059 d24171e3000 ">
                                 <p>另请参阅<span class="q">“ <a href="Oracle-dynamic-SQL-method-4.html#GUID-25AAA0D6-7513-431C-A035-99A5D973E775">取消分配存储</a> ”</span> 。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="25%" id="d24171e3085" headers="d24171e2994 ">
                                 <p><code class="codeph">sqlcurt（）</code></p>
                              </td>
                              <td align="left" valign="top" width="37%" headers="d24171e3085 d24171e2997 "><pre class="oac_no_warn" dir="ltr">void SQLCDAToResultSetCursor（dvoid * context，void * cursor，Cda_Def * cda，sword * return_value）<a id="d24171e3092" class="indexterm-anchor"></a><a id="d24171e3096" class="indexterm-anchor"></a><a id="d24171e3098" class="indexterm-anchor"></a></pre></td>
                              <td align="left" valign="top" width="37%" headers="d24171e3085 d24171e3000 ">
                                 <p>另请参见<span class="q">“ <a href="datatypes-and-host-variables.html#GUID-86514859-8929-47EA-AE78-9D8831BB5838">使用OCI的光标变量（仅限第7版）</a> ”</span> 。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="25%" id="d24171e3111" headers="d24171e2994 ">
                                 <p><code class="codeph">sqlglmt（）</code></p>
                              </td>
                              <td align="left" valign="top" width="37%" headers="d24171e3111 d24171e2997 "><pre class="oac_no_warn" dir="ltr">void SQLErrorGetText（dvoid * context，unsigned char * message_buffer，size_t * buffer_size，size_t * message_length）;<a id="d24171e3118" class="indexterm-anchor"></a><a id="d24171e3122" class="indexterm-anchor"></a><a id="d24171e3126" class="indexterm-anchor"></a></pre></td>
                              <td align="left" valign="top" width="37%" headers="d24171e3111 d24171e3000 ">
                                 <p>另请参阅<span class="q">“ <a href="handling-run-time-errors.html#GUID-5E9B1F0B-8F5D-43F2-8485-650F27EEE8BC">关于获取错误消息的全文</a> ”</span> 。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="25%" id="d24171e3137" headers="d24171e2994 ">
                                 <p><code class="codeph">sqlglst（）</code></p>
                              </td>
                              <td align="left" valign="top" width="37%" headers="d24171e3137 d24171e2997 "><pre class="oac_no_warn" dir="ltr">void SQLStmtGetText（dvoid * context，char * statement_buffer，size_t * statement_length，size_t * sqlfc）;<a id="d24171e3144" class="indexterm-anchor"></a><a id="d24171e3146" class="indexterm-anchor"></a><a id="d24171e3150" class="indexterm-anchor"></a></pre></td>
                              <td align="left" valign="top" width="37%" headers="d24171e3137 d24171e3000 ">
                                 <p>另请参阅<span class="q">“ <a href="handling-run-time-errors.html#GUID-0760D27A-BEB8-4576-AC09-1D2B04E2522B">关于获取SQL语句的文本</a> ”</span> 。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="25%" id="d24171e3163" headers="d24171e2994 ">
                                 <p><code class="codeph">sqlld2t（）</code></p>
                              </td>
                              <td align="left" valign="top" width="37%" headers="d24171e3163 d24171e2997 "><pre class="oac_no_warn" dir="ltr">void SQLLDAGetName（dvoid * context，Lda_Def * lda，text * cname，int * cname_length）;<a id="d24171e3170" class="indexterm-anchor"></a><a id="d24171e3174" class="indexterm-anchor"></a><a id="d24171e3176" class="indexterm-anchor"></a></pre></td>
                              <td align="left" valign="top" width="37%" headers="d24171e3163 d24171e3000 ">
                                 <p>另请参阅<span class="q">“ <a href="advanced-topics.html#GUID-72807525-DF42-47EA-AB69-17E8356D7DD3">OCI呼叫（仅限第7版）</a> ”</span></p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="25%" id="d24171e3188" headers="d24171e2994 ">
                                 <p><code class="codeph">sqlldat（）</code></p>
                              </td>
                              <td align="left" valign="top" width="37%" headers="d24171e3188 d24171e2997 "><pre class="oac_no_warn" dir="ltr">void SQLLDAGetCurrent（dvoid * context，Lda_Def * lda）;<a id="d24171e3195" class="indexterm-anchor"></a><a id="d24171e3199" class="indexterm-anchor"></a><a id="d24171e3203" class="indexterm-anchor"></a></pre></td>
                              <td align="left" valign="top" width="37%" headers="d24171e3188 d24171e3000 ">
                                 <p>另请参见<span class="q">“ <a href="advanced-topics.html#GUID-032607D3-8000-469F-9CBA-249CAF45EC53">远程和多个连接</a> ”</span> 。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="25%" id="d24171e3214" headers="d24171e2994 ">
                                 <p><code class="codeph">sqlnult（）</code></p>
                              </td>
                              <td align="left" valign="top" width="37%" headers="d24171e3214 d24171e2997 "><pre class="oac_no_warn" dir="ltr">void SQLColumnNullCheck（dvoid * context，unsigned short * value_type，unsigned short * type_code，int * null_status）;<a id="d24171e3221" class="indexterm-anchor"></a><a id="d24171e3225" class="indexterm-anchor"></a></pre></td>
                              <td align="left" valign="top" width="37%" headers="d24171e3214 d24171e3000 ">
                                 <p>另请参见<span class="q">“ <a href="Oracle-dynamic-SQL-method-4.html#GUID-E8EB0987-EA56-40C4-94D6-0CDC4BF51188">处理NULL /非NULL数据类型</a> ”</span> 。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="25%" id="d24171e3238" headers="d24171e2994 ">
                                 <p><code class="codeph">sqlprct（）</code></p>
                              </td>
                              <td align="left" valign="top" width="37%" headers="d24171e3238 d24171e2997 "><pre class="oac_no_warn" dir="ltr">void SQLNumberPrecV6（dvoid * context，unsigned long * length，int * precision，int * scale）;<a id="d24171e3245" class="indexterm-anchor"></a><a id="d24171e3249" class="indexterm-anchor"></a><a id="d24171e3253" class="indexterm-anchor"></a></pre></td>
                              <td align="left" valign="top" width="37%" headers="d24171e3238 d24171e3000 ">
                                 <p>另请参阅<span class="q">“ <a href="Oracle-dynamic-SQL-method-4.html#GUID-0A53AE88-FB46-41C0-B582-C2A505BC2079">提取精度和比例</a> ”</span> 。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="25%" id="d24171e3264" headers="d24171e2994 ">
                                 <p><code class="codeph">sqlpr2t（）</code></p>
                              </td>
                              <td align="left" valign="top" width="37%" headers="d24171e3264 d24171e2997 "><pre class="oac_no_warn" dir="ltr">void SQLNumberPrecV7（dvoid * context，unsigned long * length，int * precision，int * scale）;<a id="d24171e3271" class="indexterm-anchor"></a><a id="d24171e3275" class="indexterm-anchor"></a><a id="d24171e3279" class="indexterm-anchor"></a></pre></td>
                              <td align="left" valign="top" width="37%" headers="d24171e3264 d24171e3000 ">
                                 <p>另请参阅<span class="q">“ <a href="Oracle-dynamic-SQL-method-4.html#GUID-0A53AE88-FB46-41C0-B582-C2A505BC2079">提取精度和比例</a> ”</span> 。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="25%" id="d24171e3291" headers="d24171e2994 ">
                                 <p><code class="codeph">sqlvcpt（）</code></p>
                              </td>
                              <td align="left" valign="top" width="37%" headers="d24171e3291 d24171e2997 "><pre class="oac_no_warn" dir="ltr">void SQLVarcharGetLength（dvoid * context，unsigned long * data_length，unsigned long * total_length）;<a id="d24171e3298" class="indexterm-anchor"></a><a id="d24171e3302" class="indexterm-anchor"></a><a id="d24171e3304" class="indexterm-anchor"></a></pre></td>
                              <td align="left" valign="top" width="37%" headers="d24171e3291 d24171e3000 ">
                                 <p>另请参见<span class="q">“ <a href="datatypes-and-host-variables.html#GUID-621F729B-EAF3-4117-9DF5-B64E420EADE5">查找VARCHAR数组组件的长度</a> ”</span> 。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="25%" id="d24171e3317" headers="d24171e2994 ">
                                 <p><code class="codeph">N / A</code></p>
                              </td>
                              <td align="left" valign="top" width="37%" headers="d24171e3317 d24171e2997 "><pre class="oac_no_warn" dir="ltr">剑<a id="d24171e3324" class="indexterm-anchor"></a><a id="d24171e3326" class="indexterm-anchor"></a> SQLEnvGet（dvoid * context，OCIEnv ** oeh）;</pre></td>
                              <td align="left" valign="top" width="37%" headers="d24171e3317 d24171e3000 ">
                                 <p>请参见<span class="q">“ <a href="advanced-topics.html#GUID-62D0DA6E-EC6F-47FC-A651-F175D7E8CB64">SQLEnvGet（）</a> ”</span> 。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="25%" id="d24171e3340" headers="d24171e2994 ">
                                 <p><code class="codeph">N / A</code></p>
                              </td>
                              <td align="left" valign="top" width="37%" headers="d24171e3340 d24171e2997 "><pre class="oac_no_warn" dir="ltr">剑<a id="d24171e3347" class="indexterm-anchor"></a><a id="d24171e3349" class="indexterm-anchor"></a> SQLSvcCtxGet（dvoid * context，text * dbname，int dbnamelen，OCISvcCtx ** svc）;</pre></td>
                              <td align="left" valign="top" width="37%" headers="d24171e3340 d24171e3000 ">
                                 <p>请参见<span class="q">“ <a href="advanced-topics.html#GUID-B5BE914E-0F89-4A98-8379-CE8A856936BE">SQLSvcCtxGet（）</a> ”</span> 。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="25%" id="d24171e3363" headers="d24171e2994 ">
                                 <p><code class="codeph">N / A</code></p>
                              </td>
                              <td align="left" valign="top" width="37%" headers="d24171e3363 d24171e2997 "><pre class="oac_no_warn" dir="ltr">空虚<a id="d24171e3370" class="indexterm-anchor"></a><a id="d24171e3372" class="indexterm-anchor"></a> SQLRowidGet（dvoid * context，OCIRowid ** urid）;</pre></td>
                              <td align="left" valign="top" width="37%" headers="d24171e3363 d24171e3000 ">
                                 <p>请参见<span class="q">“ <a href="datatypes-and-host-variables.html#GUID-019031ED-BC2F-4C9F-B5EF-FEFF6707C910">SQLRowidGet（）</a> ”</span> 。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="25%" id="d24171e3386" headers="d24171e2994 ">
                                 <p><code class="codeph">N / A</code></p>
                              </td>
                              <td align="left" valign="top" width="37%" headers="d24171e3386 d24171e2997 "><pre class="oac_no_warn" dir="ltr">空虚<a id="d24171e3393" class="indexterm-anchor"></a><a id="d24171e3395" class="indexterm-anchor"></a> SQLExtProcError（dvoid * context，char * msg，size_t msglen）;</pre></td>
                              <td align="left" valign="top" width="37%" headers="d24171e3386 d24171e3000 ">
                                 <p>有关其在外部过程中的使用的讨论，请参见<span class="q">“ <a href="embedded-PL-SQL.html#GUID-A7A53E22-3218-4261-8FAF-C369BDAEB2EF">SQLExtProcError（）</a> ”</span> 。
                                 </p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
                  <div class="infoboxnote" id="GUID-3B79020D-735A-47A9-84DA-401D86E8F712__GUID-85BC0CB9-C1A0-426E-8DD8-2616A8110507">
                     <p class="notep1">注意：</p>
                     <p>有关这些函数的参数列表中使用的特定数据类型，请参阅<code class="codeph">sqlcpr.h</code>头文件的特定于平台的版本。
                     </p>
                  </div>
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="advanced-topics.html#GUID-06CCA89B-2D4C-4540-AC72-CFE65735EB58">与OCI版本8的接口</a></li>
                     </ul>
                  </div>
               </div>
               
            </div><a id="LNPCC3333"></a><a id="LNPCC3332"></a><div class="props_rev_3"><a id="GUID-A05AE487-C0BA-43DB-B8DE-DFFEE7E60207" name="GUID-A05AE487-C0BA-43DB-B8DE-DFFEE7E60207"></a><h3 id="LNPCC-GUID-A05AE487-C0BA-43DB-B8DE-DFFEE7E60207" class="sect3"><span class="enumeration_section">5.12</span> X / Open应用程序开发</h3>
               <div>
                  <p><a id="d24171e3435" class="indexterm-anchor"></a><a id="d24171e3439" class="indexterm-anchor"></a><a id="d24171e3441" class="indexterm-anchor"></a> X / Open应用程序在分布式事务处理（DTP）环境中运行。在抽象模型中，X / Open应用程序调用<span class="italic">资源管理器</span> （RM）以提供各种服务。例如，数据库资源管理器提供对数据库中数据的访问。资源管理器与<span class="italic">事务管理器</span> （TM）交互， <span class="italic">事务管理器</span> （TM）控制应用程序的所有事务。
                  </p>
                  <div class="figure" id="GUID-A05AE487-C0BA-43DB-B8DE-DFFEE7E60207__I421811">
                     <p class="titleinfigure">图5-1假设的DTP模型</p><img src="img/lnpcc005.gif" width="516" alt="下面是图5-1的描述" title="下面是图5-1的描述" longdesc="img_text/lnpcc005.html"><br><a href="img_text/lnpcc005.html">“图5-1假设DTP模型”的描述</a></div>
                  <!-- class="figure" -->
                  <p><a href="advanced-topics.html#GUID-A05AE487-C0BA-43DB-B8DE-DFFEE7E60207__I421811">图5-1</a>显示了DTP模型的组件可以交互以提供对Oracle数据库中数据的高效访问的一种方式。DTP模型指定资源管理器和事务管理器之间的<span class="italic">XA接口</span> 。Oracle提供符合XA的库，您必须将其链接到X / Open应用程序。此外，您必须在应用程序和资源管理器之间指定本<span class="italic">机接口</span> 。<a id="d24171e3464" class="indexterm-anchor"></a><a id="d24171e3466" class="indexterm-anchor"></a><a id="d24171e3468" class="indexterm-anchor"></a><a id="d24171e3470" class="indexterm-anchor"></a><a id="d24171e3474" class="indexterm-anchor"></a></p>
                  <p>在X / Open指南<span class="italic">分布式事务处理参考模型</span>和相关出版物中描述了指定事务管理器和资源管理器如何与应用程序交互的DTP模型，您可以通过写入<a id="d24171e3483" class="indexterm-anchor"></a></p>
                  <ul class="simple" style="list-style-type:none;padding-left:0">
                     <li>开放组织</li>
                     <li>1010 El Camino Real，Suite 380</li>
                     <li>Menlo Park，CA 94025-4345 USA</li>
                     <li></li>
                     <li><a href="http://www.opennc.org/" target="_blank">http://www.opennc.org/</a></li>
                     <li></li>
                  </ul>
                  <p>有关使用XA界面的说明，请参阅“事务处理（TP）监视器”用户指南。</p>
               </div><a id="LNPCC3334"></a><div class="props_rev_3"><a id="GUID-5E18183F-64AF-4A14-8413-ED273E3C7B4E" name="GUID-5E18183F-64AF-4A14-8413-ED273E3C7B4E"></a><h4 id="LNPCC-GUID-5E18183F-64AF-4A14-8413-ED273E3C7B4E" class="sect4"><span class="enumeration_section">5.12.1</span> Oracle特定问题</h4>
                  <div>
                     <p>您可以使用预编译器开发符合X / Open标准的应用程序。但是，您必须满足以下要求。</p>
                  </div><a id="LNPCC3335"></a><div class="props_rev_3"><a id="GUID-6CCAE5B4-7F41-4F41-A1DF-48E9DA56629F" name="GUID-6CCAE5B4-7F41-4F41-A1DF-48E9DA56629F"></a><h5 id="LNPCC-GUID-6CCAE5B4-7F41-4F41-A1DF-48E9DA56629F" class="sect5"><span class="enumeration_section">5.12.1.1</span>连接到Oracle</h5>
                     <div>
                        <p>X / Open应用程序不建立和维护与数据库的连接。相反，Oracle提供的事务管理器和XA接口透明地处理数据库连接和断开连接。因此，通常X / Open兼容的应用程序不执行CONNECT语句。</p>
                     </div>
                  </div><a id="LNPCC3336"></a><div class="props_rev_3"><a id="GUID-19CF9AE6-7BE4-4234-A82C-FCFD04A425D9" name="GUID-19CF9AE6-7BE4-4234-A82C-FCFD04A425D9"></a><h5 id="LNPCC-GUID-19CF9AE6-7BE4-4234-A82C-FCFD04A425D9" class="sect5"><span class="enumeration_section">5.12.1.2</span>交易控制</h5>
                     <div>
                        <p>X / Open应用程序不得执行影响全局事务状态的语句，如COMMIT，ROLLBACK，SAVEPOINT和SET TRANSACTION。例如，应用程序不能执行COMMIT语句，因为事务管理器处理提交。此外，应用程序不能执行SQL数据定义语句，如CREATE，ALTER和RENAME，因为它们发出隐式COMMIT。</p>
                        <p>如果应用程序检测到阻止进一步SQL操作的错误，则可以执行内部ROLLBACK语句。但是，这可能会在以后的XA接口版本中发生变化。</p>
                     </div>
                  </div><a id="LNPCC3337"></a><div class="props_rev_3"><a id="GUID-72807525-DF42-47EA-AB69-17E8356D7DD3" name="GUID-72807525-DF42-47EA-AB69-17E8356D7DD3"></a><h5 id="LNPCC-GUID-72807525-DF42-47EA-AB69-17E8356D7DD3" class="sect5"><span class="enumeration_section">5.12.1.3</span> OCI呼叫（仅限第7版）</h5>
                     <div>
                        <p>不再支持OCI Calls Release 7。</p>
                        <div class="infoboxnote" id="GUID-72807525-DF42-47EA-AB69-17E8356D7DD3__GUID-5866A82C-9602-4878-96D3-67B69DF9032F">
                           <p class="notep1">注意：</p>
                           <p>Oracle9 <span class="italic">i</span> <span class="italic">不再支持</span>登录数据区（LDA）。在Pro * C / C ++程序中嵌入OCI Release 7调用的能力将在下一个主要的Oracle版本中逐步淘汰。
                           </p>
                        </div>
                        <p>如果希望X / Open应用程序发出OCI调用，则必须使用运行时库例程<code class="codeph">sqlld2()</code> ，该例程为通过XA接口建立的指定连接设置LDA。有关<code class="codeph">sqlld2()</code>调用的说明，请参阅Oracle调用接口程序员指南（适用于第7版） <span class="italic">。</span></p>
                        <p>X / Open应用程序无法发出以下OCI调用：OCOM，OCON，OCOF，ONBLON，ORLON，OLON，OLOGOF。</p>
                     </div>
                     <div>
                        <div class="relinfo">
                           <p><strong>相关话题</strong></p>
                           <ul>
                              <li><a href="advanced-topics.html#GUID-06CCA89B-2D4C-4540-AC72-CFE65735EB58">与OCI版本8的接口</a></li>
                           </ul>
                        </div>
                     </div>
                  </div><a id="LNPCC3338"></a><div class="props_rev_3"><a id="GUID-1918B6EA-5D65-488C-8532-8344D6A4F7D3" name="GUID-1918B6EA-5D65-488C-8532-8344D6A4F7D3"></a><h5 id="LNPCC-GUID-1918B6EA-5D65-488C-8532-8344D6A4F7D3" class="sect5"><span class="enumeration_section">5.12.1.4</span>链接</h5>
                     <div>
                        <p>要获得XA功能，必须将XA库链接到X / Open应用程序对象模块。有关说明，请参阅特定于系统的Oracle文档。<a id="d24171e3584" class="indexterm-anchor"></a></p>
                     </div>
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>