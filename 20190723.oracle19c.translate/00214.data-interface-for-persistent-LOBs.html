<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <title>持久LOB的数据接口</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Database SecureFiles and Large Objects Developer&#39;s Guide"></meta>
      <meta property="og:description" content=""></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Database SecureFiles and Large Objects Developer&#39;s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="securefiles-and-large-objects-developers-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-02-12T02:58:18-08:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="1996, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96333-01"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="PLSQL-semantics-for-LOBs.html" title="Previous" type="text/html"></link>
      <link rel="next" href="reference-semantics-LOBs.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="SecureFiles and Large Objects Developer&#39;s Guide"></meta>
    <meta name="dcterms.isVersionOf" content="ADLOB"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="PLSQL-semantics-for-LOBs.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="reference-semantics-LOBs.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">Database SecureFiles和Large Objects Developer's Guide</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="value-semantic-LOBs.html" property="item" typeof="WebPage"><span property="name">值语义LOB</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">持久LOB的数据接口</li>
            </ol>
            <a id="GUID-4BFDD493-F3FE-451C-9B03-21669D635586" name="GUID-4BFDD493-F3FE-451C-9B03-21669D635586"></a><a id="ADLOB1300"></a>
            
            <h2 id="ADLOB-GUID-4BFDD493-F3FE-451C-9B03-21669D635586" class="sect2"><span class="enumeration_chapter">9</span>持久LOB的数据接口</h2>
         </header>
         <div class="ind">
            <div>
               <p><a id="d27394e61" class="indexterm-anchor"></a>数据接口是一个通用术语，指的是正在使用的任何接口，查询数据库或更新数据库。
               </p>
               <p>话题：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="data-interface-for-persistent-LOBs.html#GUID-E6A304F3-8A56-44EA-8ADE-1E785BE0E7AC">持久性LOB的数据接口概述</a></p>
                  </li>
                  <li>
                     <p><a href="data-interface-for-persistent-LOBs.html#GUID-4810EB6F-A51E-49B5-92C1-DFF47F22167F">为持久性LOB使用数据接口的好处</a></p>
                  </li>
                  <li>
                     <p><a href="data-interface-for-persistent-LOBs.html#GUID-F630AC8B-B5A3-4B63-BDA8-146CFF8ED8F3">在PL / SQL中使用持久LOB的数据接口</a></p>
                  </li>
                  <li>
                     <p><a href="data-interface-for-persistent-LOBs.html#GUID-FC81B19E-F282-4F46-8F81-E111D5F7CE26">用于OCI中持久LOB的数据接口</a></p>
                  </li>
                  <li>
                     <p><a href="data-interface-for-persistent-LOBs.html#GUID-0DA4D3D4-3E2B-4E21-AB08-6308253DF339">数据接口与Java中的持久性LOB一起使用</a></p>
                  </li>
                  <li>
                     <p><a href="data-interface-for-persistent-LOBs.html#GUID-8EC0212A-BFB6-441B-AEAE-976FDDD11EAB">与远程LOB一起使用的数据接口</a></p>
                  </li>
               </ul>
            </div><a id="ADLOB45643"></a><a id="ADLOB45644"></a><a id="ADLOB45642"></a><div class="props_rev_3"><a id="GUID-E6A304F3-8A56-44EA-8ADE-1E785BE0E7AC" name="GUID-E6A304F3-8A56-44EA-8ADE-1E785BE0E7AC"></a><h3 id="ADLOB-GUID-E6A304F3-8A56-44EA-8ADE-1E785BE0E7AC" class="sect3">持久性LOB的数据接口概述</h3>
               <div>
                  <p>持久性LOB的数据接口包括一组Java，PL / SQL和OCI API，它们被扩展为与LOB数据类型一起使用。</p>
                  <p>这些API最初设计用于遗留数据类型（如<code class="codeph">LONG</code> ， <code class="codeph">LONG</code> <code class="codeph">RAW</code>和<code class="codeph">VARCHAR2</code> ，也可以与<a href="data-interface-for-persistent-LOBs.html#GUID-E6A304F3-8A56-44EA-8ADE-1E785BE0E7AC__g1020364" title="该表在前面的文本中描述">表9-1</a>和<a href="data-interface-for-persistent-LOBs.html#GUID-E6A304F3-8A56-44EA-8ADE-1E785BE0E7AC__g1020324" title="该表在前面的文本中描述">表9-2中</a>显示的相应LOB数据类型一起使用。这些表显示了<span class="italic">绑定或定义类型</span>列中的旧数据类型以及<span class="italic">LOB列类型</span>列中相应的受支持LOB数据类型。您可以使用LOB的数据接口在LOB列中存储和操作字符数据和二进制数据，就像它存储在相应的旧数据类型中一样。
                  </p>
                  <div class="infoboxnote" id="GUID-E6A304F3-8A56-44EA-8ADE-1E785BE0E7AC__GUID-0960EE0F-D2C1-44AC-83DA-9593491DD1DC">
                     <p class="notep1">注意：</p>
                     <p>数据接口适用于LOB列和作为对象属性的LOB。在本章中， <span class="italic">LOB列</span>表示LOB列和LOB属性。
                     </p>
                     <p>您可以使用数组绑定和定义接口在一次往返中插入和选择多行。</p>
                  </div>
                  <p>虽然本讨论的大部分内容都集中在字符数据类型上，但相同的概念适用于<a href="data-interface-for-persistent-LOBs.html#GUID-E6A304F3-8A56-44EA-8ADE-1E785BE0E7AC__g1020364" title="该表在前面的文本中描述">表9-1</a>和<a href="data-interface-for-persistent-LOBs.html#GUID-E6A304F3-8A56-44EA-8ADE-1E785BE0E7AC__g1020324" title="该表在前面的文本中描述">表9-2中</a>列出的完整字符和二进制数据类型。<code class="codeph">CLOB</code>在这些表中也表示<code class="codeph">NCLOB</code> 。
                  </p>
                  <div class="tblformal" id="GUID-E6A304F3-8A56-44EA-8ADE-1E785BE0E7AC__g1020364">
                     <p class="titleintable">表9-1 SQL和PL / SQL中对应的LONG和LOB数据类型</p>
                     <table cellpadding="4" cellspacing="0" class="Formal" title="SQL和PL / SQL中对应的LONG和LOB数据类型" width="100%" border="1" summary="This table is described in the preceding text" frame="hsides" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="33%" id="d27394e231">绑定或定义类型</th>
                              <th align="left" valign="bottom" width="33%" id="d27394e234">LOB列类型</th>
                              <th align="left" valign="bottom" width="33%" id="d27394e237">用于存储</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="33%" id="d27394e242" headers="d27394e231 ">
                                 <p><code class="codeph">CHAR</code></p>
                              </td>
                              <td align="left" valign="top" width="33%" headers="d27394e242 d27394e234 ">
                                 <p><code class="codeph">CLOB</code></p>
                              </td>
                              <td align="left" valign="top" width="33%" headers="d27394e242 d27394e237 ">
                                 <p>人物数据</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="33%" id="d27394e254" headers="d27394e231 ">
                                 <p><code class="codeph">长</code></p>
                              </td>
                              <td align="left" valign="top" width="33%" headers="d27394e254 d27394e234 ">
                                 <p><code class="codeph">CLOB</code></p>
                              </td>
                              <td align="left" valign="top" width="33%" headers="d27394e254 d27394e237 ">
                                 <p>人物数据</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="33%" id="d27394e266" headers="d27394e231 ">
                                 <p><code class="codeph">VARCHAR2</code></p>
                              </td>
                              <td align="left" valign="top" width="33%" headers="d27394e266 d27394e234 ">
                                 <p><code class="codeph">CLOB</code></p>
                              </td>
                              <td align="left" valign="top" width="33%" headers="d27394e266 d27394e237 ">
                                 <p>人物数据</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="33%" id="d27394e278" headers="d27394e231 ">
                                 <p><code class="codeph">LONG RAW</code></p>
                              </td>
                              <td align="left" valign="top" width="33%" headers="d27394e278 d27394e234 ">
                                 <p><code class="codeph">BLOB</code></p>
                              </td>
                              <td align="left" valign="top" width="33%" headers="d27394e278 d27394e237 ">
                                 <p>二进制数据</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="33%" id="d27394e290" headers="d27394e231 ">
                                 <p><code class="codeph">生的</code></p>
                              </td>
                              <td align="left" valign="top" width="33%" headers="d27394e290 d27394e234 ">
                                 <p><code class="codeph">BLOB</code></p>
                              </td>
                              <td align="left" valign="top" width="33%" headers="d27394e290 d27394e237 ">
                                 <p>二进制数据</p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
                  <div class="tblformal" id="GUID-E6A304F3-8A56-44EA-8ADE-1E785BE0E7AC__g1020324">
                     <p class="titleintable">表9-2 OCI中对应的LONG和LOB数据类型</p>
                     <table cellpadding="4" cellspacing="0" class="Formal" title="OCI中相应的LONG和LOB数据类型" width="100%" border="1" summary="This table is described in the preceding text" frame="hsides" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="33%" id="d27394e312">绑定或定义类型</th>
                              <th align="left" valign="bottom" width="33%" id="d27394e315">LOB列类型</th>
                              <th align="left" valign="bottom" width="33%" id="d27394e318">用于存储</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="33%" id="d27394e323" headers="d27394e312 ">
                                 <p><code class="codeph">SQLT_AFC（N）</code></p>
                              </td>
                              <td align="left" valign="top" width="33%" headers="d27394e323 d27394e315 ">
                                 <p><code class="codeph">CLOB</code></p>
                              </td>
                              <td align="left" valign="top" width="33%" headers="d27394e323 d27394e318 ">
                                 <p>人物数据</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="33%" id="d27394e335" headers="d27394e312 ">
                                 <p><code class="codeph">SQLT_CHR</code></p>
                              </td>
                              <td align="left" valign="top" width="33%" headers="d27394e335 d27394e315 ">
                                 <p><code class="codeph">CLOB</code></p>
                              </td>
                              <td align="left" valign="top" width="33%" headers="d27394e335 d27394e318 ">
                                 <p>人物数据</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="33%" id="d27394e347" headers="d27394e312 ">
                                 <p><code class="codeph">SQLT_LNG</code></p>
                              </td>
                              <td align="left" valign="top" width="33%" headers="d27394e347 d27394e315 ">
                                 <p><code class="codeph">CLOB</code></p>
                              </td>
                              <td align="left" valign="top" width="33%" headers="d27394e347 d27394e318 ">
                                 <p>人物数据</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="33%" id="d27394e359" headers="d27394e312 ">
                                 <p><code class="codeph">SQLT_VCS</code></p>
                              </td>
                              <td align="left" valign="top" width="33%" headers="d27394e359 d27394e315 ">
                                 <p><code class="codeph">CLOB</code></p>
                              </td>
                              <td align="left" valign="top" width="33%" headers="d27394e359 d27394e318 ">
                                 <p>人物数据</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="33%" id="d27394e371" headers="d27394e312 ">
                                 <p><code class="codeph">SQLT_BIN</code></p>
                              </td>
                              <td align="left" valign="top" width="33%" headers="d27394e371 d27394e315 ">
                                 <p><code class="codeph">BLOB</code></p>
                              </td>
                              <td align="left" valign="top" width="33%" headers="d27394e371 d27394e318 ">
                                 <p>二进制数据</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="33%" id="d27394e383" headers="d27394e312 ">
                                 <p><code class="codeph">SQLT_LBI</code></p>
                              </td>
                              <td align="left" valign="top" width="33%" headers="d27394e383 d27394e315 ">
                                 <p><code class="codeph">BLOB</code></p>
                              </td>
                              <td align="left" valign="top" width="33%" headers="d27394e383 d27394e318 ">
                                 <p>二进制数据</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="33%" id="d27394e395" headers="d27394e312 ">
                                 <p><code class="codeph">SQLT_LVB</code></p>
                              </td>
                              <td align="left" valign="top" width="33%" headers="d27394e395 d27394e315 ">
                                 <p><code class="codeph">BLOB</code></p>
                              </td>
                              <td align="left" valign="top" width="33%" headers="d27394e395 d27394e318 ">
                                 <p>二进制数据</p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
               </div>
            </div><a id="ADLOB45645"></a><div class="props_rev_3"><a id="GUID-4810EB6F-A51E-49B5-92C1-DFF47F22167F" name="GUID-4810EB6F-A51E-49B5-92C1-DFF47F22167F"></a><h3 id="ADLOB-GUID-4810EB6F-A51E-49B5-92C1-DFF47F22167F" class="sect3">为持久性LOB使用数据接口的好处</h3>
               <div>
                  <p>使用持久LOB的数据接口具有以下好处：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>如果您的应用程序使用<code class="codeph">LONG</code>数据类型，那么您可以使用具有LOB数据类型的相同应用程序，而几乎不需要修改现有应用程序。为此，只需将表中的<code class="codeph">LONG</code>录音带列转换为LOB录音带列，如将<code class="codeph">LONG</code>列<a href="migrating-columns-from-LONGs-to-LOBs.html#GUID-C6FC4583-4E71-4BDA-97CB-709EBC707773">迁移到LOB中所述</a> 。
                        </p>
                     </li>
                     <li>
                        <p>对于使用顺序访问技术的OCI应用程序，性能更好。使用数据接口的分段<code class="codeph">INSERT</code>或fetch具有与使用OCI函数（如<code class="codeph">OCILobRead2()</code>和<code class="codeph">OCILobWrite2()</code>相当的性能。由于数据接口允许在单个OCI调用中将超过4K字节的数据插入LOB，因此可以节省到服务器的往返。
                        </p>
                     </li>
                     <li>
                        <p>您可以在一次<code class="codeph">OCIStmtFetch()</code>调用中读取LOB数据，而不是先获取LOB定位符然后再调用<code class="codeph">OCILobRead2()</code> 。当您想要从头开始读取LOB数据时，这可以提高性能。
                        </p>
                     </li>
                     <li>
                        <p>您可以使用数组绑定和定义接口在一个往返中插入和选择具有LOB的多个行。</p>
                     </li>
                  </ul>
               </div>
            </div><a id="ADLOB45646"></a><div class="props_rev_3"><a id="GUID-F630AC8B-B5A3-4B63-BDA8-146CFF8ED8F3" name="GUID-F630AC8B-B5A3-4B63-BDA8-146CFF8ED8F3"></a><h3 id="ADLOB-GUID-F630AC8B-B5A3-4B63-BDA8-146CFF8ED8F3" class="sect3">在PL / SQL中使用持久LOB的数据接口</h3>
               <div>
                  <p>使用数据接口，您可以使用<a href="data-interface-for-persistent-LOBs.html#GUID-E6A304F3-8A56-44EA-8ADE-1E785BE0E7AC__g1020364" title="该表在前面的文本中描述">表9-1中</a>列出的<code class="codeph">LONG</code>和LOB数据类型在PL / SQL中执行以下操作：</p>
               </div>
               <div class="props_rev_3"><a id="GUID-09B73C9E-A41B-42C2-9FFF-A239FB23A068" name="GUID-09B73C9E-A41B-42C2-9FFF-A239FB23A068"></a><h4 id="ADLOB-GUID-09B73C9E-A41B-42C2-9FFF-A239FB23A068" class="sect4">关于在PL / SQL中为持久性LOB使用数据接口</h4>
                  <div>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>将存储在数据类型（如<code class="codeph">VARCHAR2</code> ， <code class="codeph">CHAR</code>或<code class="codeph">LONG</code>字符数据<code class="codeph">INSERT</code>或<code class="codeph">UPDATE</code>到<code class="codeph">CLOB</code>列中。
                           </p>
                        </li>
                        <li>
                           <p>将存储在数据类型（如<code class="codeph">RAW</code>或<code class="codeph">LONG</code> <code class="codeph">RAW</code>二进制数据<code class="codeph">INSERT</code>或<code class="codeph">UPDATE</code>到<code class="codeph">BLOB</code>列中。
                           </p>
                        </li>
                        <li>
                           <p>在<code class="codeph">CLOB</code>列上使用<code class="codeph">SELECT</code>语句将数据选择到字符缓冲区变量（如<code class="codeph">CHAR</code> ， <code class="codeph">LONG</code>或<code class="codeph">VARCHAR2</code> 。
                           </p>
                        </li>
                        <li>
                           <p>使用<code class="codeph">BLOB</code>列上的<code class="codeph">SELECT</code>语句将数据选择为二进制缓冲区变量，如<code class="codeph">RAW</code>和<code class="codeph">LONG</code> <code class="codeph">RAW</code> 。</p>
                        </li>
                        <li>
                           <p>在<code class="codeph">CLOB</code>和<code class="codeph">VARCHAR2</code> ， <code class="codeph">CHAR</code>或<code class="codeph">LONG</code>变量之间进行跨类型分配（隐式类型转换）。
                           </p>
                        </li>
                        <li>
                           <p>在<code class="codeph">BLOB</code>和<code class="codeph">RAW</code>或<code class="codeph">LONG</code> <code class="codeph">RAW</code>变量之间进行跨类型分配（隐式类型转换）。
                           </p>
                        </li>
                        <li>
                           <p>将LOB数据类型传递给定义为接受<code class="codeph">LONG</code>数据类型的函数，或将<code class="codeph">LONG</code>数据类型传递给定义为接受LOB数据类型的函数。例如，您可以将<code class="codeph">CLOB</code>实例传递给定义为接受另一种字符类型的函数，例如<code class="codeph">VARCHAR2</code> ， <code class="codeph">CHAR</code>或<code class="codeph">LONG</code> 。</p>
                        </li>
                        <li>
                           <p>将<code class="codeph">CLOB</code>与其他PL / SQL函数和接受<code class="codeph">VARCHAR2</code>参数的运算符（如<code class="codeph">INSTR</code>和<code class="codeph">SUBSTR</code> 。</p>
                           <div class="infoboxnote" id="GUID-09B73C9E-A41B-42C2-9FFF-A239FB23A068__GUID-B2A1391C-F028-4EF5-9C13-38A92A7E7713">
                              <p class="notep1">注意：</p>
                              <p>在PL / SQL中使用带有<code class="codeph">SELECT</code>语句的LOB数据接口时，无法指定要读取的数量。您只能指定缓冲区的缓冲区长度。如果缓冲区长度小于LOB数据长度，则数据库将引发异常。
                              </p>
                           </div>
                           <div class="infoboxnotealso" id="GUID-09B73C9E-A41B-42C2-9FFF-A239FB23A068__GUID-A1D4A9EE-3785-4DDA-BBC7-55A2511AFDE8">
                              <p class="notep1">也可以看看：</p>
                              <p></p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p><a href="SQL-semantics-and-LOBs.html#GUID-47B94072-7782-40DD-BFD7-7D3D8A65B502" title="LOB支持各种SQL语义。">SQL语义和LOB</a>有关SQL语句中LOB支持的详细信息</p>
                                 </li>
                                 <li>
                                    <p><a href="migrating-columns-from-LONGs-to-LOBs.html#GUID-97D40D64-B271-45F3-96F6-AD1D20B478A9">LOB数据类型不支持某些隐式转换</a></p>
                                 </li>
                                 <li>
                                    <p><a href="data-interface-for-persistent-LOBs.html#GUID-B49558D6-E75F-443A-ADD0-786E6D63AE60">将CLOB传递给SQL和PL / SQL内置</a>函数，以获取接受<code class="codeph">VARCHAR2</code>参数的完整函数列表，例如<code class="codeph">INSTR</code>和<code class="codeph">SUBSTR</code></p>
                                 </li>
                              </ul>
                           </div>
                        </li>
                     </ul>
                  </div>
               </div><a id="ADLOB45647"></a><div class="props_rev_3"><a id="GUID-7F4D7C0F-8D8A-4DF0-8E4B-47F88612589F" name="GUID-7F4D7C0F-8D8A-4DF0-8E4B-47F88612589F"></a><h4 id="ADLOB-GUID-7F4D7C0F-8D8A-4DF0-8E4B-47F88612589F" class="sect4">使用SQL和PL / SQL中的数据接口访问LOB列的准则</h4>
                  <div>
                     <p>本节介绍用于使用持久LOB的数据接口访问LOB列或属性的技术。</p>
                     <p>来自<code class="codeph">CLOB</code>和<code class="codeph">BLOB</code>列或属性的数据可以由常规SQL语句引用，例如<code class="codeph">INSERT</code> ， <code class="codeph">UPDATE</code>和<code class="codeph">SELECT</code> 。</p>
                     <p>PL / SQL中没有分段<code class="codeph">INSERT</code> ， <code class="codeph">UPDATE</code>或fetch例程。因此，可以从LOB列或属性访问的数据量受最大字符缓冲区大小的限制。PL / SQL支持最大32KB  -  1（32767字节）的字符缓冲区大小。因此，PL / SQL应用程序只能使用持久LOB的数据接口访问大小小于32K字节的LOB。
                     </p>
                     <p>如果必须使用数据接口访问超过32KB -1，则必须从PL / SQL代码进行OCI调用，以使用API进行分段插入和获取。</p>
                     <p>使用以下准则使用数据接口访问LOB列或属性：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">INSERT</code>操作</p>
                           <p>您可以使用<code class="codeph">VALUES</code>子句中的常规<code class="codeph">INSERT</code>语句<code class="codeph">INSERT</code>到包含LOB列或属性的表中。LOB列的字段可以是文字，字符数据类型，二进制数据类型或LOB定位符。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">UPDATE</code>操作</p>
                           <p>LOB列或属性可以通过<code class="codeph">UPDATE</code>整体<code class="codeph">UPDATE</code> ...<code class="codeph">SET</code>语句。在<code class="codeph">SET</code>子句中，新值可以是文字，字符数据类型，二进制数据类型或LOB定位器。
                           </p>
                        </li>
                        <li>
                           <p>十六进制到原始和原始到十六进制转换的4000字节限制</p>
                           <p>数据库不会对大于4000字节的数据执行<code class="codeph">RAW</code>或<code class="codeph">RAW</code>到十六进制转换的隐式十六进制。您不能将字符数据的缓冲区绑定到二进制数据类型列，如果缓冲区的大小超过4000字节，则无法将二进制数据的缓冲区绑定到字符数据类型列。尝试这样做会导致列数据被截断为4000字节。
                           </p>
                           <p>例如，如果缓冲区的大小超过4000个字节，则无法将<code class="codeph">VARCHAR2</code>缓冲区绑定到<code class="codeph">LONG</code> <code class="codeph">RAW</code>或<code class="codeph">BLOB</code>列。同样，如果缓冲区大小超过4000字节，则无法将<code class="codeph">RAW</code>缓冲区绑定到<code class="codeph">LONG</code>或<code class="codeph">CLOB</code>列。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">SELECT</code>操作</p>
                           <p>可以在PL / SQL中将LOB列或属性选择为字符或二进制缓冲区。如果LOB列或属性长于缓冲区大小，则会引发异常，而不会使用任何数据填充缓冲区。LOB列或属性也可以选择到LOB定位器中。</p>
                        </li>
                     </ul>
                  </div>
               </div><a id="ADLOB45648"></a><div class="props_rev_3"><a id="GUID-6928AA5E-3128-4710-9A7E-DBFF36D43C30" name="GUID-6928AA5E-3128-4710-9A7E-DBFF36D43C30"></a><h4 id="ADLOB-GUID-6928AA5E-3128-4710-9A7E-DBFF36D43C30" class="sect4">隐式赋值和参数传递</h4>
                  <div>
                     <p><a id="d27394e1055" class="indexterm-anchor"></a> LOB列支持隐式赋值和参数传递。
                     </p>
                     <p>对于<a href="data-interface-for-persistent-LOBs.html#GUID-E6A304F3-8A56-44EA-8ADE-1E785BE0E7AC__g1020364" title="该表在前面的文本中描述">表9-1</a>和<a href="data-interface-for-persistent-LOBs.html#GUID-E6A304F3-8A56-44EA-8ADE-1E785BE0E7AC__g1020324" title="该表在前面的文本中描述">表9-2中</a>列出的数据类型，您可以使用永久LOB的数据接口将任何字符类型传递或分配给任何其他字符类型，或任何二进制类型传递给任何其他二进制类型。
                     </p>
                     <p>隐式赋值适用于显式声明的变量，以及通过使用<code class="codeph">%TYPE</code>属性引用现有列类型声明的变量，如以下示例所示。此示例假定表<code class="codeph">t</code>中的列<code class="codeph">long_col</code>已从<code class="codeph">LONG</code>列迁移到<code class="codeph">CLOB</code>列。
                     </p><pre class="oac_no_warn" dir="ltr">CREATE TABLE t（long_col LONG）; - 更改此表以将LONG列更改为LOB DECLARE VARCHAR2（100）; b t.long_col％type; - 此变量从LONG变为CLOB BEGIN SELECT * INTO b FROM t; a：= b; - 这从“VARCHAR2：= LONG变为VARCHAR2：= CLOB b：= a;  - 从”LONG：= VARCHAR2变为CLOB：= VARCHAR2 END;</pre><p>函数和过程之间允许隐式参数传递。例如，您可以将<code class="codeph">CLOB</code>传递给函数或过程，其中形式参数定义为<code class="codeph">VARCHAR2</code> 。
                     </p>
                     <div class="infoboxnote" id="GUID-6928AA5E-3128-4710-9A7E-DBFF36D43C30__GUID-15CEBD8A-E573-4DF7-B10C-2AA19CCDE46D">
                        <p class="notep1">注意：</p>
                        <p>将<code class="codeph">VARCHAR2</code>缓冲区分配给LOB变量的效率低于将<code class="codeph">VARCHAR2</code>分配给<code class="codeph">LONG</code>变量的效率，因为前者涉及创建临时LOB。因此，PL / SQL用户的应用程序性能略有下降。
                        </p>
                     </div>
                  </div>
               </div><a id="ADLOB45649"></a><div class="props_rev_3"><a id="GUID-B49558D6-E75F-443A-ADD0-786E6D63AE60" name="GUID-B49558D6-E75F-443A-ADD0-786E6D63AE60"></a><h4 id="ADLOB-GUID-B49558D6-E75F-443A-ADD0-786E6D63AE60" class="sect4">将CLOB传递给SQL和PL / SQL内置函数</h4>
                  <div>
                     <p>接受字符数据的内置PL / SQL函数也支持隐式参数传递。例如， <code class="codeph">INSTR</code>可以接受<code class="codeph">CLOB</code>和其他字符数据。
                     </p>
                     <p>任何接受<code class="codeph">VARCHAR2</code> SQL或PL / SQL内置函数都可以接受<code class="codeph">CLOB</code>作为参数。类似地， <code class="codeph">VARCHAR2</code>变量可以传递给任何带有LOB定位符的参数的<code class="codeph">DBMS_LOB</code> API。
                     </p>
                     <div class="infoboxnotealso" id="GUID-B49558D6-E75F-443A-ADD0-786E6D63AE60__GUID-DAE4EAA9-B69B-4075-AEF0-774942D3A36B">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="SQL-semantics-and-LOBs.html#GUID-47B94072-7782-40DD-BFD7-7D3D8A65B502" title="LOB支持各种SQL语义。">SQL语义和LOB</a></p>
                     </div>
                  </div>
               </div><a id="ADLOB45650"></a><div class="props_rev_3"><a id="GUID-A2D03293-C089-43EF-87E5-DFF17D0BDC50" name="GUID-A2D03293-C089-43EF-87E5-DFF17D0BDC50"></a><h4 id="ADLOB-GUID-A2D03293-C089-43EF-87E5-DFF17D0BDC50" class="sect4">显式转换函数</h4>
                  <div>
                     <p>在PL / SQL中，这些显式转换函数将其他数据类型转换为<code class="codeph">CLOB</code>和<code class="codeph">BLOB</code>数据类型，如下所示：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">TO_CLOB()</code>将<code class="codeph">LONG</code> ， <code class="codeph">VARCHAR2</code>和<code class="codeph">CHAR</code>转换为<code class="codeph">CLOB</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">TO_BLOB()</code>将<code class="codeph">LONG RAW</code>和<code class="codeph">RAW</code>转换为<code class="codeph">BLOB</code></p>
                        </li>
                     </ul>
                     <p>另请注意，转换函数<code class="codeph">TO_CHAR()</code>可以将<code class="codeph">CLOB</code>转换为<code class="codeph">CHAR</code>类型。
                     </p>
                  </div>
               </div><a id="ADLOB45651"></a><div class="props_rev_3"><a id="GUID-FB5CE71B-CCCF-4CB3-B82C-9925D633DEE2" name="GUID-FB5CE71B-CCCF-4CB3-B82C-9925D633DEE2"></a><h4 id="ADLOB-GUID-FB5CE71B-CCCF-4CB3-B82C-9925D633DEE2" class="sect4">从SQL调用PL / SQL和C过程</h4>
                  <div>
                     <p>从SQL调用PL / SQL或C过程时，不允许使用超过4000字节数据的缓冲区。</p>
                  </div>
               </div><a id="ADLOB45652"></a><div class="props_rev_3"><a id="GUID-1D453E6D-BDB0-4A6A-9A5C-E82897C24760" name="GUID-1D453E6D-BDB0-4A6A-9A5C-E82897C24760"></a><h4 id="ADLOB-GUID-1D453E6D-BDB0-4A6A-9A5C-E82897C24760" class="sect4">从PL / SQL调用PL / SQL和C过程</h4>
                  <div>
                     <div class="section">
                        <p>您可以从PL / SQL调用PL / SQL或C过程。您可以将<code class="codeph">CLOB</code>作为实际参数传递，其中<code class="codeph">CHR</code>是形式参数，反之亦然。<code class="codeph">BLOB</code>和<code class="codeph">RAW</code> 。
                        </p>
                        <p>可能出现这些情况的一个示例是，当正式参数或实际参数是锚定类型时，即使用<span class="italic"><code class="codeph">table_name.column_name</code></span> <code class="codeph">%type</code>语法声明变量。
                        </p>
                        <p>PL / SQL过程或函数可以接受<code class="codeph">CLOB</code>或<code class="codeph">VARCHAR2</code>作为形式参数。例如，PL / SQL过程可以是以下之一：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p>当形式参数是<code class="codeph">CLOB</code> ：</p><pre class="oac_no_warn" dir="ltr">创建或替换过程get_lob（table_name IN VARCHAR2，lob INOUT CLOB）AS ...开始 ...结束; /</pre></li>
                           <li>
                              <p>当形式参数是<code class="codeph">VARCHAR2</code> ：</p><pre class="oac_no_warn" dir="ltr">创建或替换过程get_lob（table_name IN VARCHAR2，lob INOUT VARCHAR2）AS ...开始 ...结束; /</pre></li>
                        </ul>
                        <p>调用函数可以是以下任何类型：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>当实际参数是CHR时：</p><pre class="oac_no_warn" dir="ltr">创建程序......声明c VARCHAR2 [200]; BEGIN get_lob（'table_name'，c）;结束;</pre></li>
                           <li>
                              <p>当实际参数是<code class="codeph">CLOB</code> ：</p><pre class="oac_no_warn" dir="ltr">创建程序......声明c CLOB; BEGIN get_lob（'table_name'，c）;结束;</pre></li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ADLOB45653"></a><div class="props_rev_3"><a id="GUID-5E2B4119-184C-4FE9-839D-3619CC23D9B7" name="GUID-5E2B4119-184C-4FE9-839D-3619CC23D9B7"></a><h4 id="ADLOB-GUID-5E2B4119-184C-4FE9-839D-3619CC23D9B7" class="sect4">INSERT和UPDATE操作中的所有大小的绑定</h4>
                  <div>
                     <p>LOB列上的<code class="codeph">INSERT</code>和<code class="codeph">UPDATE</code>操作支持所有大小的绑定。在单个<code class="codeph">INSERT</code>或<code class="codeph">UPDATE</code>语句中允许多个任何大小的绑定。
                     </p>
                     <div class="infoboxnote" id="GUID-5E2B4119-184C-4FE9-839D-3619CC23D9B7__GUID-E423B9EE-938F-4BB1-B79C-DEAFDE3F09C0">
                        <p class="notep1">注意：</p>
                        <p>创建表时，为任何LOB列指定的默认值的长度限制为4000个字节。</p>
                     </div>
                  </div>
               </div><a id="ADLOB45654"></a><div class="props_rev_3"><a id="GUID-66B9E883-6045-4B54-A741-FAFBB0D0DF0D" name="GUID-66B9E883-6045-4B54-A741-FAFBB0D0DF0D"></a><h4 id="ADLOB-GUID-66B9E883-6045-4B54-A741-FAFBB0D0DF0D" class="sect4">SQL运算符结果的4000字节限制</h4>
                  <div>
                     <p>如果将超过4000个字节的数据绑定到<code class="codeph">BLOB</code>或<code class="codeph">CLOB</code> ，并且数据由SQL运算符组成，则Oracle数据库会将结果的大小限制为最多4000个字节。
                     </p>
                     <p>以下语句仅插入4000个字节，因为<code class="codeph">LPAD</code>的结果限制为4000个字节：</p><pre class="oac_no_warn" dir="ltr">INSERT INTO print_media（ad_sourcetext）VALUES（lpad（'a'，5000，'a'））;</pre><p>以下语句仅插入2000个字节，因为<code class="codeph">LPAD</code>的结果限制为4000个字节，隐式十六进制到原始转换将其转换为2000个字节的<code class="codeph">RAW</code>数据：</p><pre class="oac_no_warn" dir="ltr">INSERT INTO print_media（ad_photo）VALUES（lpad（'a'，5000，'a'））;</pre></div>
               </div><a id="ADLOB45655"></a><div class="props_rev_3"><a id="GUID-D0C584EC-CA94-4166-99ED-F630EB655A76" name="GUID-D0C584EC-CA94-4166-99ED-F630EB655A76"></a><h4 id="ADLOB-GUID-D0C584EC-CA94-4166-99ED-F630EB655A76" class="sect4">SQL运算符的4000字节结果限制示例</h4>
                  <div>
                     <p>此示例说明了SQL运算符的结果如何限制为4000个字节。</p><pre class="oac_no_warn" dir="ltr">/ *以下命令仅插入4000个字节，因为* LPAD的结果限制为4000字节* / INSERT INTO print_media（product_id，ad_id，ad_sourcetext）VALUES（2004,5，lpad（'a'，5000，'a'） ）; SELECT LENGTH（ad_sourcetext）FROM print_media WHERE product_id = 2004 AND ad_id = 5; ROLLBACK; / *以下命令仅插入2000个字节，因为* LPAD的结果限制为4000个字节，隐式的十六进制到原始转换*将其转换为2000个字节的RAW数据。* / INSERT INTO print_media（product_id，ad_id，ad_composite）VALUES（2004,5，lpad（'a'，5000，'a'））;来自print_media的SELECT LENGTH（ad_composite）WHERE product_id = 2004 AND ad_id = 5; ROLLBAACK;</pre></div>
               </div><a id="ADLOB45656"></a><div class="props_rev_3"><a id="GUID-DF8BA907-9B89-440B-A93B-E3D9027CBA01" name="GUID-DF8BA907-9B89-440B-A93B-E3D9027CBA01"></a><h4 id="ADLOB-GUID-DF8BA907-9B89-440B-A93B-E3D9027CBA01" class="sect4">对超过4000字节的约束的限制</h4>
                  <div>
                     <p>绑定超过4000字节的限制：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>如果表同时具有<code class="codeph">LONG</code>和LOB列，则可以将超过4000个字节的数据绑定到<code class="codeph">LONG</code>或LOB列，但不能将两个数据绑定到同一语句中。
                           </p>
                        </li>
                        <li>
                           <p>在<code class="codeph">INSERT</code> <code class="codeph">AS</code> <code class="codeph">SELECT</code>操作中，不允许将任何长度数据绑定到LOB列。
                           </p>
                        </li>
                     </ul>
                  </div>
               </div><a id="ADLOB1306"></a><div class="props_rev_3"><a id="GUID-6011EE96-FE71-46C1-9914-70412A98C2E2" name="GUID-6011EE96-FE71-46C1-9914-70412A98C2E2"></a><h4 id="ADLOB-GUID-6011EE96-FE71-46C1-9914-70412A98C2E2" class="sect4">并行DML（PDML）支持LOB</h4>
                  <div>
                     <p>当在具有SecureFiles LOB或BasicFiles LOB的分区表和仅具有SecureFiles LOB的非分区表上执行时，Oracle支持并行执行大多数以下DML操作：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">插入</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">INSERT AS SELECT</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">CREATE TABLE AS SELECT</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">删除</code> 
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">UPDATE</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">MERGE</code> （条件<code class="codeph">UPDATE</code>和<code class="codeph">INSERT</code> ）</p>
                        </li>
                        <li>
                           <p>多表<code class="codeph">INSERT</code></p>
                        </li>
                        <li>
                           <p>SQL Loader</p>
                        </li>
                        <li>
                           <p>进出口</p>
                        </li>
                     </ul>
                     <p>从版本12 <span class="italic">c</span>开始，对并行DML的增强支持包括以下内容：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>LOB列作为SecureFiles LOB存储在非分区表中。（以前的版本已包含分区表）</p>
                        </li>
                        <li>
                           <p>对SecureFiles LOB列的直接加载支持，这些列具有在其上定义的上下文索引。</p>
                        </li>
                     </ul>
                     <p><span class="bold">限制</span></p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>如果表除了SecureFiles LOB列之外还具有BasicFiles LOB列，则禁用并行插入直接加载（PIDL）。</p>
                        </li>
                        <li>
                           <p>一些域索引实现可能由于其设计而限制负载分布并降低性能。</p>
                        </li>
                        <li>
                           <p>必须仅为顶级非分区表指定并行性。</p>
                        </li>
                     </ul>
                     <div class="infoboxnotealso" id="GUID-6011EE96-FE71-46C1-9914-70412A98C2E2__GUID-A4CF8295-988F-40E7-BBB7-446F86957C39">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="../admin/managing-processes.html#ADMIN11186" target="_blank"><span class="italic">Oracle数据库管理员指南</span></a>部分“管理并行SQL执行的进程”</p>
                     </div>
                  </div>
               </div><a id="ADLOB45657"></a><div class="props_rev_3"><a id="GUID-C1D59473-DA5D-42FC-900F-27C1D02DCF2D" name="GUID-C1D59473-DA5D-42FC-900F-27C1D02DCF2D"></a><h4 id="ADLOB-GUID-C1D59473-DA5D-42FC-900F-27C1D02DCF2D" class="sect4">示例：PL / SQL  - 在INSERT和UPDATE中使用超过4000字节的绑定</h4>
                  <div>
                     <div class="section">
                        <p>此示例演示了在<code class="codeph">INSERT</code>和<code class="codeph">UPDATE</code>操作中使用大于4000字节的绑定。
                        </p><pre class="oac_no_warn" dir="ltr">DECLARE bigtext VARCHAR2（32767）; smalltext VARCHAR2（2000）; bigraw RAW（32767）; BEGIN bigtext：= LPAD（'a'，32767，'a'）; smalltext：= LPAD（'a'，2000，'a'）; bigraw：= utl_raw.cast_to_raw（bigtext）; / * INSERT允许LOB列的多个长绑定：* / INSERT INTO print_media（product_id，ad_id，ad_sourcetext，ad_composite）VALUES（2004,1，bigtext，bigraw）; / * INSERT允许LOB列的单长绑定：* / INSERT INTO print_media（product_id，ad_id，ad_sourcetext）VALUES（2005,2，smalltext）; bigtext：= LPAD（'b'，32767，'b'）; smalltext：= LPAD（'b'，20，'a'）; bigraw：= utl_raw.cast_to_raw（bigtext）; / *允许LOB列的多个长绑定用于UPDATE：* / UPDATE print_media SET ad_sourcetext = bigtext，ad_composite = bigraw，ad_finaltext = smalltext; / * LOD列的单长绑定允许UPDATE：* / UPDATE print_media SET ad_sourcetext = smalltext，ad_finaltext = bigtext; / *以下是不允许的，因为我们试图在LONG和LOB列中插入超过4000个字节的数据：* / INSERT INTO print_media（product_id，ad_id，ad_sourcetext，press_release）VALUES（2030,3，bigtext，bigtext ）; / *允许将数据插入LOB属性* / INSERT INTO print_media（product_id，ad_id，ad_header）VALUES（2049,4，adheader_typ（null，null，null，bigraw））; / *以下是不允许的，因为我们尝试执行INSERT AS SELECT数据INTO LOB * / INSERT INTO print_media（product_id，ad_id，ad_sourcetext）SELECT 2056,5，bigtext FROM dual;结束; /</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ADLOB45658"></a><div class="props_rev_3"><a id="GUID-F808592E-C7AA-44C7-8178-8359F21C6814" name="GUID-F808592E-C7AA-44C7-8178-8359F21C6814"></a><h4 id="ADLOB-GUID-F808592E-C7AA-44C7-8178-8359F21C6814" class="sect4">使用INSERT，UPDATE和SELECT操作的LOB数据接口</h4>
                  <div>
                     <div class="section">
                        <p>LOB上的<code class="codeph">INSERT</code>和<code class="codeph">UPDATE</code>语句的使用方式与<code class="codeph">LONG</code>上的相同。例如：</p><pre class="oac_no_warn" dir="ltr">DECLARE ad_buffer VARCHAR2（100）; BEGIN INSERT INTO print_media（product_id，ad_id，ad_sourcetext）VALUES（2004,5，'广告来源1'）; UPDATE print_media SET ad_sourcetext ='广告来源2'WHERE product_id = 2004 AND ad_id = 5; / *如果它最多100个字节，则检索LOB列，否则它*引发异常* / SELECT ad_sourcetext INTO ad_buffer FROM print_media WHERE product_id = 2004 AND ad_id = 5;结束; /</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ADLOB45659"></a><div class="props_rev_3"><a id="GUID-792A55FF-E311-4AB9-A37E-E9BF79CE6A9B" name="GUID-792A55FF-E311-4AB9-A37E-E9BF79CE6A9B"></a><h4 id="ADLOB-GUID-792A55FF-E311-4AB9-A37E-E9BF79CE6A9B" class="sect4">在赋值和参数传递中使用LOB的数据接口</h4>
                  <div>
                     <div class="section">
                        <p>LOB的数据接口支持隐式赋值和参数传递，如以下示例所示：</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE t（clob_col CLOB，blob_col BLOB）;插入价值观（'abcdefg'，'aaaaaa'）; DECLARE var_buf VARCHAR2（100）; clob_buf CLOB; raw_buf RAW（100）; blob_buf BLOB; BEGIN SELECT * INTO clob_buf，blob_buf FROM t; var_buf：= clob_buf; clob_buf：= var_buf; raw_buf：= blob_buf; blob_buf：= raw_buf;结束; /创建或更换程序FOO（一个IN OUT CLOB）开始 - 任何程序体a：='abc';结束; /创建或替换程序栏（b输出VARCHAR2）开始 - 任何程序体b：='xyz';结束; / DECLARE VARCHAR2（100）：='1234567'; b CLOB; BEGIN FOO（a）; SELECT clob_col INTO b FROM t; BAR（b）中;结束; /</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ADLOB45660"></a><div class="props_rev_3"><a id="GUID-69B6EC1F-1B07-4F86-805D-EB98C9248B2C" name="GUID-69B6EC1F-1B07-4F86-805D-EB98C9248B2C"></a><h4 id="ADLOB-GUID-69B6EC1F-1B07-4F86-805D-EB98C9248B2C" class="sect4">使用带有PL / SQL内置函数的LOB数据接口</h4>
                  <div>
                     <div class="section">
                        <p>此示例说明了在PL / SQL内置函数中使用<code class="codeph">CLOB</code> ，使用LOB的数据接口：</p><pre class="oac_no_warn" dir="ltr">DECLARE my_ad CLOB; revised_ad CLOB; myGist VARCHAR2（100）：='这是我的要点。“; modifiedGist VARCHAR2（100）; BEGIN INSERT INTO print_media（product_id，ad_id，ad_sourcetext）VALUES（2004,5，'广告来源1'）; - 选择一个CLOB列到CLOB变量中SELECT ad_sourcetext INTO my_ad FROM print_media WHERE product_id = 2004 AND ad_id = 5; - 对CLOB变量执行VARCHAR2操作：revised_ad：= UPPER（SUBSTR（my_ad，1,20））; -  revised_ad是一个临时LOB  - 在CLOB的末尾Concat a VARCHAR2：modified_ad：= revised_ad || myGist; - 如果my_ad是 - 超过100个字节，则以下语句引发错误myGist：= my_ad;结束; /</pre></div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="ADLOB45661"></a><div class="props_rev_3"><a id="GUID-FC81B19E-F282-4F46-8F81-E111D5F7CE26" name="GUID-FC81B19E-F282-4F46-8F81-E111D5F7CE26"></a><h3 id="ADLOB-GUID-FC81B19E-F282-4F46-8F81-E111D5F7CE26" class="sect3">用于OCI中持久LOB的数据接口</h3>
               <div>
                  <p>本节讨论包含在持久LOB的数据接口中的OCI函数。这些OCI函数对LOB数据类型的工作方式与对<code class="codeph">LONG</code>数据类型的工作方式完全相同。使用这些函数，您可以使用与存储字符或二进制数据的其他数据类型相同的技术，在LOB上的OCI中执行<code class="codeph">INSERT</code> ， <code class="codeph">UPDATE</code> ，fetch，bind和define操作。
                  </p>
                  <div class="infoboxnote" id="GUID-FC81B19E-F282-4F46-8F81-E111D5F7CE26__GUID-72B9F551-C82D-46E2-9383-5ABE7FC4AA7A">
                     <p class="notep1">注意：</p>
                     <p>您可以使用数组绑定和定义接口在一个往返中插入和选择具有LOB的多个行。</p>
                  </div>
                  <div class="infoboxnotealso" id="GUID-FC81B19E-F282-4F46-8F81-E111D5F7CE26__GUID-F4746FFA-C968-4645-BAF6-D96A31C2B22E">
                     <p class="notep1">也可以看看：</p>
                     <p><a href="../lnoci/binding-and-defining-in-oci.html#LNOCI059" target="_blank"><span class="italic">Oracle调用接口程序员指南</span></a> <span class="italic">，</span> “OCI中的运行时数据分配和分段操作”部分</p>
                  </div>
               </div><a id="ADLOB45662"></a><div class="props_rev_3"><a id="GUID-440FBDD9-016D-482E-B4E2-D94753709D9B" name="GUID-440FBDD9-016D-482E-B4E2-D94753709D9B"></a><h4 id="ADLOB-GUID-440FBDD9-016D-482E-B4E2-D94753709D9B" class="sect4">OCI中绑定的LOB数据类型</h4>
                  <div>
                     <p>您可以在以下操作中绑定LOB数据类型：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>常规，分段和回调绑定<code class="codeph">INSERT</code>和<code class="codeph">UPDATE</code>操作</p>
                        </li>
                        <li>
                           <p>数组绑定<code class="codeph">INSERT</code>和<code class="codeph">UPDATE</code>操作</p>
                        </li>
                        <li>
                           <p>参数传递到PL / SQL和OCI边界</p>
                        </li>
                     </ul>
                     <p>可以通过轮询或提供回调来执行分段操作。为了支持这些操作，以下OCI函数接受<a href="data-interface-for-persistent-LOBs.html#GUID-E6A304F3-8A56-44EA-8ADE-1E785BE0E7AC__g1020324" title="该表在前面的文本中描述">表9-2中</a>列出的<code class="codeph">LONG</code>和LOB数据类型。
                     </p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">OCIBindByName()</code>和<code class="codeph">OCIBindByPos()</code> 
                           </p>
                           <p>这些函数在SQL语句中的程序变量和占位符之间创建关联，或者在<code class="codeph">INSERT</code>和<code class="codeph">UPDATE</code>操作的PL / SQL块中创建关联。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">OCIBindDynamic（）</code></p>
                           <p>您可以使用此调用为<code class="codeph">INSERT</code>和<code class="codeph">UPDATE</code>操作的动态数据分配注册回调</p>
                        </li>
                        <li>
                           <p><code class="codeph">OCIStmtGetPieceInfo()</code>和<code class="codeph">OCIStmtSetPieceInfo()</code> 
                           </p>
                           <p>这些调用用于获取或设置分段操作的片段信息。</p>
                        </li>
                     </ul>
                  </div>
               </div><a id="ADLOB45663"></a><div class="props_rev_3"><a id="GUID-1D08A343-F384-4C17-8468-0B50AB4869A9" name="GUID-1D08A343-F384-4C17-8468-0B50AB4869A9"></a><h4 id="ADLOB-GUID-1D08A343-F384-4C17-8468-0B50AB4869A9" class="sect4">OCI中定义的LOB数据类型</h4>
                  <div>
                     <p>持久性LOB的数据接口允许以下OCI函数接受<a href="data-interface-for-persistent-LOBs.html#GUID-E6A304F3-8A56-44EA-8ADE-1E785BE0E7AC__g1020324" title="该表在前面的文本中描述">表9-2中</a>列出的LONG和LOB数据类型。
                     </p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">OCIDefineByPos（）</code> 
                           </p>
                           <p>此调用将<code class="codeph">SELECT</code>列表中的项与类型和输出数据缓冲区相关联。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">OCIDefineDynamic（）</code></p>
                           <p>如果在<code class="codeph">OCIDefineByPos()</code>函数调用中选择了<code class="codeph">OCI_DYNAMIC_FETCH</code>模式，则此调用将注册<code class="codeph">SELECT</code>操作的用户回调。
                           </p>
                        </li>
                     </ul>
                     <p>将这些函数与LOB类型一起使用时，LOB数据（而非定位器）将被选择到缓冲区中。请注意，在OCI中，您无法使用LOB的数据接口指定要读取的数量。您只能指定缓冲区的缓冲区长度。数据库只读取适合缓冲区的数量，数据被截断。</p>
                  </div>
               </div><a id="ADLOB45664"></a><div class="props_rev_3"><a id="GUID-E203AC55-C089-4A29-93EE-648BF26EE9B1" name="GUID-E203AC55-C089-4A29-93EE-648BF26EE9B1"></a><h4 id="ADLOB-GUID-E203AC55-C089-4A29-93EE-648BF26EE9B1" class="sect4">OCI中使用的多字节字符集与LOB的数据接口</h4>
                  <div>
                     <p>当客户端字符集采用多字节格式时，数据接口中包含的函数与LOB数据类型的操作方式与LONG数据类型的操作方式相同，如下所示：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>对于多字节字符集中的<span class="italic">分段</span>提取，可以在中间剪切多字节字符，在一个缓冲区的末尾有一些字节，在下一个缓冲区中有剩余的字节。
                           </p>
                        </li>
                        <li>
                           <p>对于<span class="italic">常规</span>提取，如果缓冲区不能保存最后一个字符的所有字节，则Oracle返回适合缓冲区的字节数，从而返回部分字符。
                           </p>
                        </li>
                     </ul>
                  </div>
               </div><a id="ADLOB45665"></a><div class="props_rev_3"><a id="GUID-DAC248A9-BB2A-4FA5-A190-00B16DA0999E" name="GUID-DAC248A9-BB2A-4FA5-A190-00B16DA0999E"></a><h4 id="ADLOB-GUID-DAC248A9-BB2A-4FA5-A190-00B16DA0999E" class="sect4">用于在LOB列上执行INSERT或UPDATE的OCI函数</h4>
                  <div>
                     <p>本节讨论可用于使用数据接口对LOB列或属性执行<code class="codeph">INSERT</code>或<code class="codeph">UPDATE</code>操作的各种技术。本节中描述的操作假定您已初始化OCI环境并分配了所有必需的句柄。
                     </p>
                  </div><a id="ADLOB45666"></a><div class="props_rev_3"><a id="GUID-37EC2BA1-4AF4-4214-8BE4-6972FE5D1E24" name="GUID-37EC2BA1-4AF4-4214-8BE4-6972FE5D1E24"></a><h5 id="ADLOB-GUID-37EC2BA1-4AF4-4214-8BE4-6972FE5D1E24" class="sect5">在海贼王中执行简单的INSERT或UPDATE</h5>
                     <div>
                        <div class="section">
                           <p>要使用持久性LOB的数据接口以单件形式执行简单的<code class="codeph">INSERT</code>或<code class="codeph">UPDATE</code>操作，请执行以下步骤：</p>
                        </div>
                        <!-- class="section" -->
                        <ol>
                           <li><span>调用<code class="codeph">OCIStmtPrepare()</code>以<code class="codeph">OCI_DEFAULT</code>模式准备语句。</span></li>
                           <li><span>在<code class="codeph">OCI_DEFAULT</code>模式下调用<code class="codeph">OCIBindByName()</code>或<code class="codeph">OCIBindbyPos()</code>以将LOB的占位符绑定为字符数据或二进制数据。</span></li>
                           <li><span>调用<code class="codeph">OCIStmtExecute()</code>来执行实际的<code class="codeph">INSERT</code>或<code class="codeph">UPDATE</code>操作。</span></li>
                        </ol>
                     </div>
                  </div><a id="ADLOB45667"></a><div class="props_rev_3"><a id="GUID-E86276C6-CBAE-4BA1-ADCF-C0A6D6B6D311" name="GUID-E86276C6-CBAE-4BA1-ADCF-C0A6D6B6D311"></a><h5 id="ADLOB-GUID-E86276C6-CBAE-4BA1-ADCF-C0A6D6B6D311" class="sect5">使用分段INSERT和UPDATE与轮询</h5>
                     <div>
                        <div class="section">
                           <p>要使用持久性LOB的数据接口进行轮询来执行分段<code class="codeph">INSERT</code>或<code class="codeph">UPDATE</code>操作，请执行以下步骤：</p>
                        </div>
                        <!-- class="section" -->
                        <ol>
                           <li class="stepexpand"><span>调用<code class="codeph">OCIStmtPrepare()</code>以<code class="codeph">OCI_DEFAULT</code>模式准备语句。</span></li>
                           <li class="stepexpand"><span>在<code class="codeph">OCI_DATA_AT_EXEC</code>模式下调用<code class="codeph">OCIBindByName()</code>或<code class="codeph">OCIBindbyPos()</code>以将LOB绑定为字符数据或二进制数据。</span></li>
                           <li class="stepexpand"><span>在默认模式下调用<code class="codeph">OCIStmtExecute()</code> 。从<code class="codeph">OCIStmtExecute()</code>返回的值为<code class="codeph">OCIStmtExecute()</code>时，在循环中执行以下每个<code class="codeph">OCI_NEED_DATA</code> 。终止你的循环，当从返回的值<code class="codeph">OCIStmtExecute()</code>是<code class="codeph">OCI_SUCCESS</code> 。</span><div>
                                 <ul style="list-style-type:disc">
                                    <li>
                                       <p>调用<code class="codeph">OCIStmtGetPieceInfo()</code>以检索有关要插入的片段的信息。
                                       </p>
                                    </li>
                                    <li>
                                       <p>调用<code class="codeph">OCIStmtSetPieceInfo()</code>来设置有关要插入的片段的信息。
                                       </p>
                                    </li>
                                 </ul>
                              </div>
                           </li>
                        </ol>
                     </div>
                  </div><a id="ADLOB45668"></a><div class="props_rev_3"><a id="GUID-FF8C8866-7C10-468E-93B2-94AC2F18A327" name="GUID-FF8C8866-7C10-468E-93B2-94AC2F18A327"></a><h5 id="ADLOB-GUID-FF8C8866-7C10-468E-93B2-94AC2F18A327" class="sect5">使用回调执行分段INSERT和UPDATE</h5>
                     <div>
                        <div class="section">
                           <p>要使用持久LOB的数据接口使用回调执行分段<code class="codeph">INSERT</code>或<code class="codeph">UPDATE</code>操作，请执行以下步骤：</p>
                        </div>
                        <!-- class="section" -->
                        <ol>
                           <li><span>调用<code class="codeph">OCIStmtPrepare()</code>以<code class="codeph">OCI_DEFAULT</code>模式准备语句。</span></li>
                           <li><span>在<code class="codeph">OCI_DATA_AT_EXEC</code>模式下调用<code class="codeph">OCIBindByName()</code>或<code class="codeph">OCIBindbyPos()</code>以将LOB列的占位符绑定为字符数据或二进制数据。</span></li>
                           <li><span>调用<code class="codeph">OCIBindDynamic()</code>以指定回调。</span></li>
                           <li><span>在默认模式下调用<code class="codeph">OCIStmtExecute()</code> 。</span></li>
                        </ol>
                     </div>
                  </div><a id="ADLOB45669"></a><div class="props_rev_3"><a id="GUID-886FD92D-CB99-4221-854B-04BFF06FF6CB" name="GUID-886FD92D-CB99-4221-854B-04BFF06FF6CB"></a><h5 id="ADLOB-GUID-886FD92D-CB99-4221-854B-04BFF06FF6CB" class="sect5">数组INSERT和UPDATE操作</h5>
                     <div>
                        <div class="section">
                           <p>要使用持久LOB的数据接口执行数组<code class="codeph">INSERT</code>或<code class="codeph">UPDATE</code>操作，请使用本节中结合<code class="codeph">OCIBindArrayOfStruct()</code>讨论的任何技术，或者指定迭代次数（ <span class="italic"><code class="codeph">iter</code></span> ）， <span class="italic"><code class="codeph">iter</code></span>值大于1，in <code class="codeph">OCIStmtExecute()</code>调用。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="ADLOB45670"></a><div class="props_rev_3"><a id="GUID-39B36A93-D43F-4B13-9266-3828C8F1B6BF" name="GUID-39B36A93-D43F-4B13-9266-3828C8F1B6BF"></a><h4 id="ADLOB-GUID-39B36A93-D43F-4B13-9266-3828C8F1B6BF" class="sect4">用于在OCI中获取LOB数据的数据接口</h4>
                  <div>
                     <p>本节讨论可以使用数据接口为持久性LOB从OCI列或OCI中的属性获取数据的技术。</p>
                  </div><a id="ADLOB45671"></a><div class="props_rev_3"><a id="GUID-FC93720E-7A33-467E-A260-56F4ADC1C1B7" name="GUID-FC93720E-7A33-467E-A260-56F4ADC1C1B7"></a><h5 id="ADLOB-GUID-FC93720E-7A33-467E-A260-56F4ADC1C1B7" class="sect5">简单的单件装</h5>
                     <div>
                        <div class="section">
                           <p>要使用持久性LOB的数据接口对LOB执行简单的提取操作，请执行以下操作：</p>
                        </div>
                        <!-- class="section" -->
                        <ol>
                           <li><span>调用<code class="codeph">OCIStmtPrepare()</code>以在<code class="codeph">OCI_DEFAULT</code>模式下准备<code class="codeph">SELECT</code>语句。</span></li>
                           <li><span>调用<code class="codeph">OCIDefineByPos()</code>以在<code class="codeph">OCI_DEFAULT</code>模式下定义选择列表位置，以将LOB定义为字符数据或二进制数据。</span></li>
                           <li><span>调用<code class="codeph">OCIStmtExecute()</code>以运行<code class="codeph">SELECT</code>语句。</span></li>
                           <li><span>调用<code class="codeph">OCIStmtFetch()</code>来执行实际的提取。</span></li>
                        </ol>
                     </div>
                  </div><a id="ADLOB45672"></a><div class="props_rev_3"><a id="GUID-254F3A11-F9CC-4DC2-B855-333C508D6622" name="GUID-254F3A11-F9CC-4DC2-B855-333C508D6622"></a><h5 id="ADLOB-GUID-254F3A11-F9CC-4DC2-B855-333C508D6622" class="sect5">使用轮询执行分段提取</h5>
                     <div>
                        <div class="section">
                           <p>要使用LOB的数据接口进行轮询，对LOB列执行分段提取操作，请执行以下步骤：</p>
                        </div>
                        <!-- class="section" -->
                        <ol>
                           <li class="stepexpand"><span>调用<code class="codeph">OCIStmtPrepare()</code>以在<code class="codeph">OCI_DEFAULT</code>模式下准备<code class="codeph">SELECT</code>语句。</span></li>
                           <li class="stepexpand"><span>调用<code class="codeph">OCIDefinebyPos()</code>以在<code class="codeph">OCI_DYNAMIC_FETCH</code>模式中定义选择列表位置，以将LOB列定义为字符数据或二进制数据。</span></li>
                           <li class="stepexpand"><span>调用<code class="codeph">OCIStmtExecute()</code>以运行<code class="codeph">SELECT</code>语句。</span></li>
                           <li class="stepexpand"><span>在默认模式下调用<code class="codeph">OCIStmtFetch()</code> 。从<code class="codeph">OCIStmtFetch()</code>返回的值为<code class="codeph">OCIStmtFetch()</code>时，在循环中执行以下每个<code class="codeph">OCI_NEED_DATA.</code>终止你的循环，当从返回的值<code class="codeph">OCIStmtFetch()</code>是<code class="codeph">OCI_SUCCESS</code> 。</span><div>
                                 <ul style="list-style-type:disc">
                                    <li>
                                       <p>调用<code class="codeph">OCIStmtGetPieceInfo()</code>以检索有关要获取的片段的信息。
                                       </p>
                                    </li>
                                    <li>
                                       <p>调用<code class="codeph">OCIStmtSetPieceInfo()</code>来设置有关要获取的片段的信息。
                                       </p>
                                    </li>
                                 </ul>
                              </div>
                           </li>
                        </ol>
                     </div>
                  </div><a id="ADLOB45673"></a><div class="props_rev_3"><a id="GUID-916BBF9D-5CFD-4F2B-89C4-59452AAB3140" name="GUID-916BBF9D-5CFD-4F2B-89C4-59452AAB3140"></a><h5 id="ADLOB-GUID-916BBF9D-5CFD-4F2B-89C4-59452AAB3140" class="sect5">使用回调执行分段</h5>
                     <div>
                        <div class="section">
                           <p>要使用持久性LOB的数据接口对带有回调的LOB列执行分段提取操作，请执行以下操作：</p>
                        </div>
                        <!-- class="section" -->
                        <ol>
                           <li><span>调用<code class="codeph">OCIStmtPrepare()</code>以<code class="codeph">OCI_DEFAULT</code>模式准备语句。</span></li>
                           <li><span>调用<code class="codeph">OCIDefinebyPos()</code>以在<code class="codeph">OCI_DYNAMIC_FETCH</code>模式中定义选择列表位置，以将LOB列定义为字符数据或二进制数据。</span></li>
                           <li><span>调用<code class="codeph">OCIStmtExecute()</code>以运行<code class="codeph">SELECT</code>语句。</span></li>
                           <li><span>调用<code class="codeph">OCIDefineDynamic()</code>以指定回调。</span></li>
                           <li><span>在默认模式下调用<code class="codeph">OCIStmtFetch()</code> 。</span></li>
                        </ol>
                     </div>
                  </div><a id="ADLOB45674"></a><div class="props_rev_3"><a id="GUID-C9658EA0-F9E4-4185-9631-8D9A35ED71B5" name="GUID-C9658EA0-F9E4-4185-9631-8D9A35ED71B5"></a><h5 id="ADLOB-GUID-C9658EA0-F9E4-4185-9631-8D9A35ED71B5" class="sect5">数组提取</h5>
                     <div>
                        <div class="section">
                           <p>要执行的阵列OCI取使用持久性的LOB的数据接口，可以使用任何的结合在本节中讨论的技术<code class="codeph">OCIDefineArrayOfStruct()</code>或者通过指定的迭代的数量（ <span class="italic"><code class="codeph">iter</code></span> ）中，用的值<span class="italic"><code class="codeph">iter</code></span>大于1 ，在<code class="codeph">OCIStmtExecute()</code>调用中。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="ADLOB45675"></a><div class="props_rev_3"><a id="GUID-34D56682-00EB-42DD-869A-9C5C4E288423" name="GUID-34D56682-00EB-42DD-869A-9C5C4E288423"></a><h4 id="ADLOB-GUID-34D56682-00EB-42DD-869A-9C5C4E288423" class="sect4">PL / SQL和C从OCI绑定</h4>
                  <div>
                     <div class="section">
                        <p>当您从OCI调用PL / SQL过程并具有<code class="codeph">IN</code>或<code class="codeph">OUT</code>或<code class="codeph">IN OUT</code>绑定时，您应该能够：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p>将变量绑定为<code class="codeph">SQLT_CHR</code>或<code class="codeph">SQLT_LNG</code> ，其中PL / SQL过程的形式参数为<code class="codeph">SQLT_CLOB</code> ，或者</p>
                           </li>
                           <li>
                              <p>将变量绑定为<code class="codeph">SQLT_BIN</code>或<code class="codeph">SQLT_LBI</code> ，其中形式参数为<code class="codeph">SQLT_BLOB</code></p>
                           </li>
                        </ul>
                        <p>以下两种情况有效：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-34D56682-00EB-42DD-869A-9C5C4E288423__GUID-3017AE1C-FB9E-4711-ABA7-0FEDBB70322B">在“begin foo（：1）; end;”中调用PL / SQL Out-binds方式</p>
                        <p>下面是在“begin foo（：1）; end;”中调用PL / SQL out-binds的示例。方式：</p><pre class="oac_no_warn" dir="ltr">text * sqlstmt =（text *）“BEGIN get_lob（：c）; END;”;</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-34D56682-00EB-42DD-869A-9C5C4E288423__GUID-E2BFEEBF-209F-4559-92A2-C4000BED9C61">在“call foo（：1）;”中调用PL / SQL Out-binds方式</p>
                        <p>这是在“call foo（：1）;”中调用PL / SQL out-binds的示例。方式：</p><pre class="oac_no_warn" dir="ltr">text * sqlstmt =（text *）“CALL get_lob（：c）;” ;</pre><p>在这两种情况下，程序的其余部分都有以下声明：</p><pre class="oac_no_warn" dir="ltr">OCIStmtPrepare（stmthp，errhp，sqlstmt，（ub4）strlen（（char *）sqlstmt），（ub4）OCI_NTV_SYNTAX，（ub4）OCI_DEFAULT）; curlen = 0; OCIBindByName（stmthp，＆bndhp [3]，errhp，（text *）“：c”，（sb4）strlen（（char *）“：c”），（dvoid *）buf5，（sb4）LONGLEN，SQLT_CHR，（dvoid） *）0，（ub2 *）0，（ub2 *）0，（ub4）1，（ub4 *）＆curlen，（ub4）OCI_DATA_AT_EXEC）;</pre><p>PL / SQL过程<code class="codeph">get_lob()</code>如下：</p><pre class="oac_no_warn" dir="ltr">过程get_lob（c INOUT CLOB）是 - 这可能是列％类型BEGIN .../ *程序体可以是PL / SQL或C * / END;</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ADLOB45678"></a><div class="props_rev_3"><a id="GUID-28B40747-D702-44FB-BF19-F7DC46C67722" name="GUID-28B40747-D702-44FB-BF19-F7DC46C67722"></a><h4 id="ADLOB-GUID-28B40747-D702-44FB-BF19-F7DC46C67722" class="sect4">示例：C（OCI） -  INSERT和UPDATE超过4000字节的绑定</h4>
                  <div>
                     <div class="section">
                        <p>对于<code class="codeph">INSERT</code>和<code class="codeph">UPDATE</code>操作，您可以使用超过4000个字节的绑定。
                        </p><pre class="oac_no_warn" dir="ltr">void insert3（）{/ *允许将数据插入LOB属性。* / ub1 buffer [8000]; text * insert_sql =（text *）“INSERT INTO Print_media（ad_header）\ VALUES（adheader_typ（NULL，NULL，NULL，：1））”; OCIStmtPrepare（stmthp，errhp，insert_sql，strlen（（char *）insert_sql），（ub4）OCI_NTV_SYNTAX，（ub4）OCI_DEFAULT）; OCIBindByPos（stmthp，＆bindhp [0]，errhp，1，（dvoid *）buffer，2000，SQLT_LNG，0,0,0,0,0（ub4）OCI_DEFAULT）; OCIStmtExecute（svchp，stmthp，errhp，1,0，（const OCISnapshot *）0，（OCISnapshot *）0，OCI_DEFAULT）; }</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ADLOB45679"></a><div class="props_rev_3"><a id="GUID-67A21099-37E9-4400-9D75-D86A106A4FC6" name="GUID-67A21099-37E9-4400-9D75-D86A106A4FC6"></a><h4 id="ADLOB-GUID-67A21099-37E9-4400-9D75-D86A106A4FC6" class="sect4">在PL / SQL中使用LOB的数据接口从LOB上的OCI绑定</h4>
                  <div>
                     <div class="section">
                        <p>LOB的数据接口允许来自OCI的LOB PL / SQL绑定工作。当您从OCI调用PL / SQL过程并具有<code class="codeph">IN</code>或<code class="codeph">OUT</code>或<code class="codeph">IN OUT</code>绑定时，您应该能够将变量绑定为<code class="codeph">SQLT_CHR</code> ，其中PL / SQL过程的形式参数是<code class="codeph">SQLT_CLOB</code> 。</p>
                        <div class="infoboxnote" id="GUID-67A21099-37E9-4400-9D75-D86A106A4FC6__GUID-09184C69-A045-4A00-AA79-8EC4A232E6E6">
                           <p class="notep1">注意：</p>
                           <p>C程序包含在PL / SQL存根中，因此OCI应用程序始终调用PL / SQL存根。</p>
                        </div>
                        <p>对于OCI呼叫计划，以下是可能的情况：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-67A21099-37E9-4400-9D75-D86A106A4FC6__GUID-CDC4A047-241F-4030-834F-DA5364DF516B">在“begin foo（：1）; end;”中调用PL / SQL Out-binds方式</p>
                        <p>例如：</p><pre class="oac_no_warn" dir="ltr">text * sqlstmt =（text *）“BEGIN PKG1。P5（：c）;结束; “;</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-67A21099-37E9-4400-9D75-D86A106A4FC6__GUID-97C50125-BA23-44FB-A5C4-45E6089F8911">在“call foo（：1）;”中调用PL / SQL Out-binds方式</p>
                        <p>例如：</p><pre class="oac_no_warn" dir="ltr">text * sqlstmt =（text *）“CALL PKG1。P5（：c）;“;</pre><p>在这两种情况下，该计划的其余部分如下：</p><pre class="oac_no_warn" dir="ltr">OCIStmtPrepare（stmthp，errhp，sqlstmt，（ub4）strlen（（char *）sqlstmt），（ub4）OCI_NTV_SYNTAX，（ub4）OCI_DEFAULT）; curlen = 0; OCIBindByName（stmthp，＆bndhp [3]，errhp，（text *）“：c4”，（sb4）strlen（（char *）“：c”），（dvoid *）buf5，（sb4）LONGLEN，SQLT_CHR，（dvoid） *）0，（ub2 *）0，（ub2 *）0，（ub4）1，（ub4 *）＆curlen，（ub4）OCI_DATA_AT_EXEC）; OCIStmtExecute（svchp，stmthp，errhp，（ub4）0，（ub4）0，（const OCISnapshot *）0，（OCISnapshot *）0，（ub4）OCI_DEFAULT）;</pre><p>PL / SQL过程<code class="codeph">PKG1.P5</code>如下：</p><pre class="oac_no_warn" dir="ltr">创建或更换包装体pkg1 AS ...过程p5（c OUT CLOB）是 - 这可能是表％rowtype（所以它现在是CLOB）BEGIN ...结束p5;结束pkg1;</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ADLOB45682"></a><div class="props_rev_3"><a id="GUID-FE40F37E-AC24-4098-AF37-08179B7F6AED" name="GUID-FE40F37E-AC24-4098-AF37-08179B7F6AED"></a><h4 id="ADLOB-GUID-FE40F37E-AC24-4098-AF37-08179B7F6AED" class="sect4">绑定大于4000字节的LOB列的LONG数据</h4>
                  <div>
                     <div class="section">
                        <p>此示例说明了LOB列的绑定字符数据：</p><pre class="oac_no_warn" dir="ltr">void simple_insert（）{word buflen; text buf [5000]; text * insstmt =（text *）“INSERT INTO Print_media（Product_id，Ad_id，\ Ad_sourcetext）VALUES（2004,1，：SRCTXT）”; OCIStmtPrepare（stmthp，errhp，insstmt，（ub4）strlen（（char *）insstmt），（ub4）OCI_NTV_SYNTAX，（ub4）OCI_DEFAULT）; OCIBindByName（stmthp，＆bndhp [0]，errhp，（text *）“：SRCTXT”，（sb4）strlen（（char *）“：SRCTXT”），（dvoid *）buf，（sb4）sizeof（buf），SQLT_CHR ，（dvoid *）0，（ub2 *）0，（ub2 *）0，（ub4）0，（ub4 *）0，（ub4）OCI_DEFAULT）; memset（（void *）buf，（int）'A'，（size_t）5000）; OCIStmtExecute（svchp，stmthp，errhp，（ub4）1，（ub4）0，（const OCISnapshot *）0，（OCISnapshot *）0，（ub4）OCI_DEFAULT）; }</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ADLOB45683"></a><div class="props_rev_3"><a id="GUID-4F79C855-71C0-4307-BD72-114889A9DFDE" name="GUID-4F79C855-71C0-4307-BD72-114889A9DFDE"></a><h4 id="ADLOB-GUID-4F79C855-71C0-4307-BD72-114889A9DFDE" class="sect4">使用具有轮询的分段INSERT将LONG数据绑定到LOB列</h4>
                  <div>
                     <div class="section">
                        <p>此示例说明了使用分段<code class="codeph">INSERT</code>和使用LOB的数据接口进行轮询。
                        </p><pre class="oac_no_warn" dir="ltr">void piecewise_insert（）{text * sqlstmt =（text *）“INSERT INTO Print_media（Product_id，Ad_id，\ Ad_sourcetext）VALUES（：1，：2，：3）”; ub2 rcode; ub1 piece，i; word product_id = 2004;单词ad_id = 2; ub4 buflen; char buf [5000]; OCIStmtPrepare（stmthp，errhp，sqlstmt，（ub4）strlen（（char *）sqlstmt），（ub4）OCI_NTV_SYNTAX，（ub4）OCI_DEFAULT）; OCIBindByPos（stmthp，＆bndhp [0]，errhp，（ub4）1，（dvoid *）＆product_id，（sb4）sizeof（product_id），SQLT_INT，（dvoid *）0，（ub2 *）0，（ub2 *）0， （ub4）0，（ub4 *）0，（ub4）OCI_DEFAULT）; OCIBindByPos（stmthp，＆bndhp [1]，errhp，（ub4）2，（dvoid *）＆ad_id，（sb4）sizeof（ad_id），SQLT_INT，（dvoid *）0，（ub2 *）0，（ub2 *）0， （ub4）0，（ub4 *）0，（ub4）OCI_DEFAULT）; OCIBindByPos（stmthp，＆bndhp [2]，errhp，（ub4）3，（dvoid *）0，（sb4）15000，SQLT_LNG，（dvoid *）0，（ub2 *）0，（ub2 *）0，（ub4） 0，（ub4 *）0，（ub4）OCI_DATA_AT_EXEC）; i = 0;而（1）{i ++; retval = OCIStmtExecute（svchp，stmthp，errhp，（ub4）1，（ub4）0，（CONST OCISnapshot *）0，（OCISnapshot *）0，（ub4）OCI_DEFAULT）; switch（retval）{case OCI_NEED_DATA：memset（（void *）buf，（int）'A'+ i，（size_t）5000）; buflen = 5000; if（i == 1）piece = OCI_FIRST_PIECE;否则if（i == 3）piece = OCI_LAST_PIECE; else piece = OCI_NEXT_PIECE; if（OCIStmtSetPieceInfo（（dvoid *）bndhp [2]，（ub4）OCI_HTYPE_BIND，errhp，（dvoid *）buf，＆buflen，piece，（dvoid *）0，＆rcode））{printf（“ERROR：OCIStmtSetPieceInfo：％d \ n“，retval）;打破;打破case OCI_SUCCESS：break; default：printf（“oci exec返回％d \ n”，retval）;的Report_Error（errhp）; retval = OCI_SUCCESS; } / * end switch * / if（retval == OCI_SUCCESS）break; } / * end while（1）* /}</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ADLOB45684"></a><div class="props_rev_3"><a id="GUID-2B962DD4-7D3B-44FC-9928-DB5B53241871" name="GUID-2B962DD4-7D3B-44FC-9928-DB5B53241871"></a><h4 id="ADLOB-GUID-2B962DD4-7D3B-44FC-9928-DB5B53241871" class="sect4">使用具有回调的分段INSERT将LONG数据绑定到LOB列</h4>
                  <div>
                     <div class="section">
                        <p>此示例说明了使用带回调的分段<code class="codeph">INSERT</code>将<code class="codeph">LONG</code>数据绑定到LOB列：</p><pre class="oac_no_warn" dir="ltr">void callback_insert（）{word buflen = 15000; word product_id = 2004;单词ad_id = 3; text * sqlstmt =（text *）“INSERT INTO Print_media（Product_id，Ad_id，\ Ad_sourcetext）VALUES（：1，：2，：3）”;字pos = 3; OCIStmtPrepare（stmthp，errhp，sqlstmt，（ub4）strlen（（char *）sqlstmt），（ub4）OCI_NTV_SYNTAX，（ub4）OCI_DEFAULT）OCIBindByPos（stmthp，＆bndhp [0]，errhp，（ub4）1，（dvoid *） ＆product_id，（sb4）sizeof（product_id），SQLT_INT，（dvoid *）0，（ub2 *）0，（ub2 *）0，（ub4）0，（ub4 *）0，（ub4）OCI_DEFAULT）; OCIBindByPos（stmthp，＆bndhp [1]，errhp，（ub4）2，（dvoid *）＆ad_id，（sb4）sizeof（ad_id），SQLT_INT，（dvoid *）0，（ub2 *）0，（ub2 *）0， （ub4）0，（ub4 *）0，（ub4）OCI_DEFAULT）; OCIBindByPos（stmthp，＆bndhp [2]，errhp，（ub4）3，（dvoid *）0，（sb4）buflen，SQLT_CHR，（dvoid *）0，（ub2 *）0，（ub2 *）0，（ub4） 0，（ub4 *）0，（ub4）OCI_DATA_AT_EXEC）; OCIBindDynamic（bndhp [2]，errhp，（dvoid *）（dvoid *）＆pos，insert_cbk，（dvoid *）0，（OCICallbackOutBind）0）; OCIStmtExecute（svchp，stmthp，errhp，（ub4）1，（ub4）0，（const OCISnapshot *）0，（OCISnapshot *）0，（ub4）OCI_DEFAULT）; } / * end insert_data（）* / / * Inbind回调以指定输入数据。* / static sb4 insert_cbk（dvoid * ctxp，OCIBind * bindp，ub4 iter，ub4 index，dvoid ** bufpp，ub4 * alenpp，ub1 * piecep，dvoid ** indpp）{static int a = 0;字j; ub4 inpos = *（（ub4 *）ctxp）; char buf [5000]; switch（inpos）{case 3：memset（（void *）buf，（int）'A'+ a，（size_t）5000）; * bufpp =（dvoid *）buf; * alenpp = 5000;一个++;打破;默认值：printf（“错误：无效位置编号：％d \ n”，inpos）; } * indpp =（dvoid *）0; * piecep = OCI_ONE_PIECE; if（inpos == 3）{if（a &lt;= 1）{* piecep = OCI_FIRST_PIECE; printf（“插入回调：第一部分\ n”）; } else if（a &lt;3）{* piecep = OCI_NEXT_PIECE; printf（“插入回调：％d'th \ n”，a）; } else {* piecep = OCI_LAST_PIECE; printf（“插入回调：％d'th \ n”，a）; a = 0;返回OCI_CONTINUE; }</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ADLOB45685"></a><div class="props_rev_3"><a id="GUID-9D4F118A-8F62-49C2-A6CF-23C07B56C6FE" name="GUID-9D4F118A-8F62-49C2-A6CF-23C07B56C6FE"></a><h4 id="ADLOB-GUID-9D4F118A-8F62-49C2-A6CF-23C07B56C6FE" class="sect4">使用数组INSERT将LONG数据绑定到LOB列</h4>
                  <div>
                     <div class="section">
                        <p>此示例说明使用数组<code class="codeph">INSERT</code>操作绑定LOB列的字符数据：</p><pre class="oac_no_warn" dir="ltr">void array_insert（）{ub4 i;字buflen;字arrbuf1 [5];单词arrbuf2 [5]; text arrbuf3 [5] [5000]; text * insstmt =（text *）“INSERT INTO Print_media（Product_id，Ad_id，\ Ad_sourcetext）VALUES（：PID，：AID，：SRCTXT）”; OCIStmtPrepare（stmthp，errhp，insstmt，（ub4）strlen（（char *）insstmt），（ub4）OCI_NTV_SYNTAX，（ub4）OCI_DEFAULT）; OCIBindByName（stmthp，＆bndhp [0]，errhp，（text *）“：PID”，（sb4）strlen（（char *）“：PID”），（dvoid *）＆arrbuf1 [0]，（sb4）sizeof（arrbuf1 [0]），SQLT_INT，（dvoid *）0，（ub2 *）0，（ub2 *）0，（ub4）0，（ub4 *）0，（ub4）OCI_DEFAULT）; OCIBindByName（stmthp，＆bndhp [1]，errhp，（text *）“：AID”，（sb4）strlen（（char *）“：AID”），（dvoid *）＆arrbuf2 [0]，（sb4）sizeof（arrbuf2 [0]），SQLT_INT，（dvoid *）0，（ub2 *）0，（ub2 *）0，（ub4）0，（ub4 *）0，（ub4）OCI_DEFAULT）; OCIBindByName（stmthp，＆bndhp [2]，errhp，（text *）“：SRCTXT”，（sb4）strlen（（char *）“：SRCTXT”），（dvoid *）arrbuf3 [0]，（sb4）sizeof（arrbuf3 [0]），SQLT_CHR，（dvoid *）0，（ub2 *）0，（ub2 *）0，（ub4）0，（ub4 *）0，（ub4）OCI_DEFAULT）; OCIBindArrayOfStruct（bndhp [0]，errhp sizeof（arrbuf1 [0]），indsk，rlsk，rcsk）; OCIBindArrayOfStruct（bndhp [1]，errhp，sizeof（arrbuf2 [0]），indsk，rlsk，rcsk）; OCIBindArrayOfStruct（bndhp [2]，errhp，sizeof（arrbuf3 [0]），indsk，rlsk，rcsk）; for（i = 0; i &lt;5; i ++）{arrbuf1 [i] = 2004; arrbuf2 [i] = i + 4; memset（（void *）arrbuf3 [i]，（int）'A'+ i，（size_t）5000）; } OCIStmtExecute（svchp，stmthp，errhp，（ub4）5，（ub4）0，（const OCISnapshot *）0，（OCISnapshot *）0，（ub4）OCI_DEFAULT）; }</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ADLOB45686"></a><div class="props_rev_3"><a id="GUID-F0D4D744-9933-446E-856B-70C8BC0B4D98" name="GUID-F0D4D744-9933-446E-856B-70C8BC0B4D98"></a><h4 id="ADLOB-GUID-F0D4D744-9933-446E-856B-70C8BC0B4D98" class="sect4">使用简单提取将LOB列选择为LONG缓冲区</h4>
                  <div>
                     <div class="section">
                        <p>此示例说明了使用简单提取选择LOB列：</p><pre class="oac_no_warn" dir="ltr">void simple_fetch（）{word retval; text buf [15000]; text * selstmt =（text *）“SELECT Ad_sourcetext FROM Print_media WHERE \ Product_id = 2004”; OCIStmtPrepare（stmthp，errhp，selstmt，（ub4）strlen（（char *）selstmt），（ub4）OCI_NTV_SYNTAX，（ub4）OCI_DEFAULT）; retval = OCIStmtExecute（svchp，stmthp，errhp，（ub4）0，（ub4）0，（const OCISnapshot *）0，（OCISnapshot *）0，（ub4）OCI_DEFAULT）; while（retval == OCI_SUCCESS || retval == OCI_SUCCESS_WITH_INFO）{OCIDefineByPos（stmthp，＆defhp，errhp，（ub4）1，（dvoid *）buf，（sb4）sizeof（buf），（ub2）SQLT_CHR，（dvoid *） 0，（ub2 *）0，（ub2 *）0，（ub4）OCI_DEFAULT）; retval = OCIStmtFetch（stmthp，errhp，（ub4）1，（ub4）OCI_FETCH_NEXT，（ub4）OCI_DEFAULT）; if（retval == OCI_SUCCESS || retval == OCI_SUCCESS_WITH_INFO）printf（“buf =％。* s \ n”，15000，buf）; }}</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ADLOB45687"></a><div class="props_rev_3"><a id="GUID-08D48F2D-D8DC-4402-B8C5-E80E741D6250" name="GUID-08D48F2D-D8DC-4402-B8C5-E80E741D6250"></a><h4 id="ADLOB-GUID-08D48F2D-D8DC-4402-B8C5-E80E741D6250" class="sect4">使用带轮询的分段提取选择LOB列到LONG缓冲区</h4>
                  <div>
                     <div class="section">
                        <p>此示例说明了使用带轮询的分段提取在<code class="codeph">LONG</code>缓冲区中选择LOB列：</p><pre class="oac_no_warn" dir="ltr">void piecewise_fetch（）{text buf [15000]; ub4 buflen = 5000;单词retval; text * selstmt =（text *）“SELECT Ad_sourcetext FROM Print_media WHERE Product_id = 2004 AND Ad_id = 2”; OCIStmtPrepare（stmthp，errhp，selstmt，（ub4）strlen（（char *）selstmt），（ub4）OCI_NTV_SYNTAX，（ub4）OCI_DEFAULT）; OCIDefineByPos（stmthp，＆dfnhp，errhp，（ub4）1，（dvoid *）NULL，（sb4）100000，SQLT_LNG，（dvoid *）0，（ub2 *）0，（ub2 *）0，（ub4）OCI_DYNAMIC_FETCH）; retval = OCIStmtExecute（svchp，stmthp，errhp，（ub4）0，（ub4）0，（CONST OCISnapshot *）0，（OCISnapshot *）0，（ub4）OCI_DEFAULT）; retval = OCIStmtFetch（stmthp，errhp，（ub4）1，（ub2）OCI_FETCH_NEXT，（ub4）OCI_DEFAULT）;而且（retval！= OCI_NO_DATA &amp;&amp; retval！= OCI_SUCCESS）{ub1 piece; ub4 iter; ub4 idx; genclr（（void *）buf，5000）; switch（retval）{case OCI_NEED_DATA：OCIStmtGetPieceInfo（stmthp，errhp，＆hdlptr，＆hdltype，＆in_out，＆iter，＆idx，＆piece）; buflen = 5000; OCIStmtSetPieceInfo（hdlptr，hdltype，errhp，（dvoid *）buf，＆buflen，piece，（CONST dvoid *）＆indp1，（ub2 *）0）; retval = OCI_NEED_DATA;打破; default：printf（“ERROR：分段提取，％d \ n”，retval）;返回; } / * end switch * / retval = OCIStmtFetch（stmthp，errhp，（ub4）1，（ub2）OCI_FETCH_NEXT，（ub4）OCI_DEFAULT）; printf（“数据：％。5000s \ n”，buf）; } / *结束时* /}</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ADLOB45688"></a><div class="props_rev_3"><a id="GUID-87674AA6-3741-4F57-A99B-A7A34B471A1D" name="GUID-87674AA6-3741-4F57-A99B-A7A34B471A1D"></a><h4 id="ADLOB-GUID-87674AA6-3741-4F57-A99B-A7A34B471A1D" class="sect4">使用带回调的分段提取选择LOB列到LONG缓冲区</h4>
                  <div>
                     <div class="section">
                        <p>此示例说明了在使用带回调的分段提取时选择<code class="codeph">LONG</code>列到LOB缓冲区：</p><pre class="oac_no_warn" dir="ltr">char buf [5000]; void callback_fetch（）{word outpos = 1; text * sqlstmt =（text *）“SELECT Ad_sourcetext FROM Print_media WHERE Product_id = 2004 AND Ad_id = 3”; OCIStmtPrepare（stmthp，errhp，sqlstmt，（ub4）strlen（（char *）sqlstmt），（ub4）OCI_NTV_SYNTAX，（ub4）OCI_DEFAULT）; OCIDefineByPos（stmthp，＆dfnhp [0]，errhp，（ub4）1，（dvoid *）0，（sb4）3 * sizeof（buf），SQLT_CHR，（dvoid *）0，（ub2 *）0，（ub2 *） 0，（ub4）OCI_DYNAMIC_FETCH）; OCIDefineDynamic（dfnhp [0]，errhp，（dvoid *）＆outpos，（OCICallbackDefine）fetch_cbk）; OCIStmtExecute（svchp，stmthp，errhp，（ub4）1，（ub4）0，（const OCISnapshot *）0，（OCISnapshot *）0，（ub4）OCI_DEFAULT）; buf [4999] ='\ 0'; printf（“选择回调：最后一块：％s \ n”，buf）; } / * ----------------------------------------------- --------------- * / / *获取回调以指定缓冲区。* / / * ---------------------------------------------- ---------------- * / static sb4 fetch_cbk（dvoid * ctxp，OCIDefine * dfnhp，ub4 iter，dvoid ** bufpp，ub4 ** alenpp，ub1 * piecep，dvoid ** indpp，ub2 ** rcpp）{static int a = 0; ub4 outpos = *（（ub4 *）ctxp）; ub4 len = 5000; switch（outpos）{case 1：a ++; * bufpp =（dvoid *）buf; * alenpp =＆len;打破;默认值：* bufpp =（dvoid *）0; * alenpp =（ub4 *）0; printf（“ERROR：无效的位置编号：％d \ n”，outpos）; } * indpp =（dvoid *）0; * rcpp =（ub2 *）0; buf [len] ='\ 0'; if（a &lt;= 1）{* piecep = OCI_FIRST_PIECE; printf（“选择回调：0件\ n”）; } else if（a &lt;3）{* piecep = OCI_NEXT_PIECE; printf（“Select callback：％d'th piece：％s \ n”，a-1，buf）; } else {* piecep = OCI_LAST_PIECE; printf（“Select callback：％d'th piece：％s \ n”，a-1，buf）; a = 0; } return OCI_CONTINUE; }</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ADLOB45689"></a><div class="props_rev_3"><a id="GUID-2BD7184B-174E-4003-AACA-B9E7EAB04075" name="GUID-2BD7184B-174E-4003-AACA-B9E7EAB04075"></a><h4 id="ADLOB-GUID-2BD7184B-174E-4003-AACA-B9E7EAB04075" class="sect4">使用数组提取选择LOB列到LONG缓冲区</h4>
                  <div>
                     <div class="section">
                        <p>此示例说明如何使用数组提取将LOB列选择到<code class="codeph">LONG</code>缓冲区中：</p><pre class="oac_no_warn" dir="ltr">void array_fetch（）{word i; text arrbuf [5] [5000]; text * selstmt =（text *）“SELECT Ad_sourcetext FROM Print_media WHERE Product_id = 2004 AND Ad_id&gt; = 4”; OCIStmtPrepare（stmthp，errhp，selstmt，（ub4）strlen（（char *）selstmt），（ub4）OCI_NTV_SYNTAX，（ub4）OCI_DEFAULT）; OCIStmtExecute（svchp，stmthp，errhp，（ub4）0，（ub4）0，（const OCISnapshot *）0，（OCISnapshot *）0，（ub4）OCI_DEFAULT）; OCIDefineByPos（stmthp，＆defhp1，errhp，（ub4）1，（dvoid *）arrbuf [0]，（sb4）sizeof（arrbuf [0]），（ub2）SQLT_CHR，（dvoid *）0，（ub2 *）0， （ub2 *）0，（ub4）OCI_DEFAULT）; OCIDefineArrayOfStruct（dfnhp1，errhp，sizeof（arrbuf [0]），indsk，rlsk，rcsk）; retval = OCIStmtFetch（stmthp，errhp，（ub4）5，（ub4）OCI_FETCH_NEXT，（ub4）OCI_DEFAULT）; if（retval == OCI_SUCCESS || retval == OCI_SUCCESS_WITH_INFO）{printf（“％。5000s \ n”，arrbuf [0]）; printf（“％。5000s \ n”，arrbuf [1]）; printf（“％。5000s \ n”，arrbuf [2]）; printf（“％。5000s \ n”，arrbuf [3]）; printf（“％。5000s \ n”，arrbuf [4]）; }}</pre></div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="ADLOB45690"></a><div class="props_rev_3"><a id="GUID-0DA4D3D4-3E2B-4E21-AB08-6308253DF339" name="GUID-0DA4D3D4-3E2B-4E21-AB08-6308253DF339"></a><h3 id="ADLOB-GUID-0DA4D3D4-3E2B-4E21-AB08-6308253DF339" class="sect3">数据接口与Java中的持久性LOB一起使用</h3>
               <div>
                  <div class="section">
                     <p>您还可以使用与<code class="codeph">LONG</code>和<code class="codeph">LONG</code> <code class="codeph">RAW</code>数据相同的流机制来读取和写入<code class="codeph">CLOB</code>和<code class="codeph">BLOB</code>数据。
                     </p>
                     <p>要阅读，请使用<code class="codeph">defineColumnType(nn, Types.LONGVARCHAR)</code>或<code class="codeph">defineColumnType(nn, Types.LONGVARBINARY)</code>在列上。这会在数据上生成直接流，就像它是<code class="codeph">LONG</code>或<code class="codeph">LONG</code> <code class="codeph">RAW</code>列一样。一种用于在输入<code class="codeph">PreparedStatement</code> ，可以使用<code class="codeph">setBinaryStream()</code> <code class="codeph">setCharacterStream()</code>或<code class="codeph">setAsciiStream()</code>为一个参数，该参数是一个<code class="codeph">BLOB</code>或<code class="codeph">CLOB</code> 。这些方法使用流接口根据流中的数据在数据库中创建LOB。如果已知数据的长度，为了获得更好的性能，请使用接受length参数的<span class="apiname" translate="no">setBinaryStream()</span>或<span class="apiname" translate="no">setCharacterStream</span>函数的版本。数据接口还支持标准JDBC方法，例如ResultSet和CallableStatement上的getString / getBytes以及PreparedStatement上的setString / setBytes来读取和写入LOB数据。使用这些API进行LOB访问更容易编码，并且在许多情况下更快。所有这些技术都可以减少数据库往返次数，并可能在某些情况下提高性能。有关适用的重要限制，请参阅Javadoc on stream数据， <a href="http://www.oracle.com/technology/" target="_blank"><code class="codeph">http://www.oracle.com/technology/</code></a>为<a href="http://www.oracle.com/technology/" target="_blank"><code class="codeph">http://www.oracle.com/technology/</code></a> 。</p>
                     <p>请参阅<span class="italic">JDBC Developer's Guide and Reference中的以下内容</span> ：</p>
                     <div class="infoboxnotealso" id="GUID-0DA4D3D4-3E2B-4E21-AB08-6308253DF339__GUID-289B2555-8963-4A41-8EC1-8908F6358229">
                        <p class="notep1">也可以看看：</p>
                        <p> </p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="../jjdbc/LOBs-and-BFiles.html#JJDBC28534" target="_blank"><span class="italic">Oracle数据库JDBC开发人员指南</span></a> ，“使用LOB和BFILE”，“LOB的数据接口”部分</p>
                           </li>
                           <li>
                              <p><a href="../jjdbc/JDBC-standards-support.html#JJDBC28082" target="_blank"><span class="italic">Oracle数据库JDBC开发人员指南</span></a> ，“JDBC标准支持”</p>
                           </li>
                        </ul>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div>
            </div><a id="ADLOB1323"></a><div class="sect2"><a id="GUID-8EC0212A-BFB6-441B-AEAE-976FDDD11EAB" name="GUID-8EC0212A-BFB6-441B-AEAE-976FDDD11EAB"></a><h3 id="ADLOB-GUID-8EC0212A-BFB6-441B-AEAE-976FDDD11EAB" class="sect3">与远程LOB一起使用的数据接口</h3>
               <div>
                  <p>在Oracle Database <span class="italic">10g</span>第2版之后，支持用于插入，更新和选择远程LOB（通过<code class="codeph">dblink</code>访问）的数据接口。
                  </p>
               </div>
               <div class="props_rev_3"><a id="GUID-23097695-09B0-4107-9720-FBE4D8283C0F" name="GUID-23097695-09B0-4107-9720-FBE4D8283C0F"></a><h4 id="ADLOB-GUID-23097695-09B0-4107-9720-FBE4D8283C0F" class="sect4">关于具有远程LOB的数据接口</h4>
                  <div>
                     <p>讨论的示例使用在两个模式中创建的<code class="codeph">print_media</code>表： <code class="codeph">dbs1</code>和<code class="codeph">dbs2</code> 。显示的示例中使用的该表的<code class="codeph">CLOB</code>列是<code class="codeph">ad_finaltext</code> 。为PL / SQL，OCI和Java提供的示例使用这一列的绑定和定义，但也可以访问多个列。以下是支持的功能及其局限性：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>您可以将<code class="codeph">CLOB</code>定义为<code class="codeph">CHAR</code>或<code class="codeph">NCHAR</code> ，将<code class="codeph">NCLOB</code>为<span>CHAR或NCHAR</span> 。 <code class="codeph">CLOB</code>和<code class="codeph">NCLOB</code>可以定义为<code class="codeph">LONG</code> 。 <code class="codeph">BLOB</code>可以定义为<code class="codeph">RAW</code>或<code class="codeph">LONG</code> <code class="codeph">RAW</code> 。</p>
                        </li>
                        <li>
                           <p>支持数组绑定和定义。</p>
                        </li>
                     </ul>
                     <div class="infoboxnotealso" id="GUID-23097695-09B0-4107-9720-FBE4D8283C0F__GUID-0742C293-8B42-47CC-9D30-ECADB24003F6">
                        <p class="notep1">也可以看看：</p>
                        <p><span class="q">“ <a href="data-interface-for-persistent-LOBs.html#GUID-B30F5FA6-4097-4A4B-BD5F-988195FF9A33">PL / SQL中的远程数据接口示例</a> ”</span>及其后的部分。
                        </p>
                     </div>
                  </div>
               </div><a id="ADLOB45691"></a><div class="props_rev_3"><a id="GUID-33C01903-5DB5-491C-970C-D27EC3FCC72E" name="GUID-33C01903-5DB5-491C-970C-D27EC3FCC72E"></a><h4 id="ADLOB-GUID-33C01903-5DB5-491C-970C-D27EC3FCC72E" class="sect4">不支持的语法</h4>
                  <div>
                     <p>远程LOB不支持某些语法。</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>不支持涉及多个数据库的查询：</p><pre class="oac_no_warn" dir="ltr">SELECT t1.lobcol，a2.lobcol FROM t1，t2.lobcol @ dbs2 a2 WHERE LENGTH（t1.lobcol）= LENGTH（a2.lobcol）;</pre><p>这个查询都不是（在PL / SQL块中）：</p><pre class="oac_no_warn" dir="ltr">SELECT t1.lobcol INTO varchar_buf1 FROM t1 @ dbs1 UNION ALL SELECT t2.lobcol INTO varchar_buf2 FROM t2 @ dbs2;</pre></li>
                        <li>
                           <p>仅支持进入远程持久LOB列的数据的绑定和定义，因此不允许在PL / SQL中传递为远程LOB绑定或定义<code class="codeph">CHAR</code>数据的参数，因为这可能会产生不受支持的远程临时LOB。这些陈述都会产生错误：</p><pre class="oac_no_warn" dir="ltr">SELECT foo（）INTO varchar_buf FROM table1 @ dbs2; -  foo返回LOB SELECT foo（）@ dbs INTO char_val FROM DUAL; -  foo返回LOB SELECT XMLType（）。getclobval INTO varchar_buf FROM table1 @ dbs2;</pre></li>
                        <li>
                           <p>如果远程对象是一个视图，如</p><pre class="oac_no_warn" dir="ltr">CREATE VIEW v AS SELECT foo（）a FROM ...; -  foo返回LOB / *然后本地数据库尝试获取CLOB数据并返回错误* / SELECT a INTO varchar_buf FROM v @ dbs2;</pre><p>这会返回错误，因为它会生成一个不受支持的远程临时LOB。</p>
                        </li>
                        <li>
                           <p><code class="codeph">RETURNING</code> <code class="codeph">INTO</code>不支持<code class="codeph">CHAR</code>和<code class="codeph">CLOB</code>之间的隐式转换。</p>
                        </li>
                        <li>
                           <p>如果实际参数是LOB类型且远程参数是<code class="codeph">VARCHAR2</code> ， <code class="codeph">NVARCHAR2</code> ， <code class="codeph">CHAR</code> ， <code class="codeph">NCHAR</code>或<code class="codeph">RAW</code> ，则不允许PL / SQL参数传递。</p>
                        </li>
                     </ul>
                  </div>
               </div><a id="ADLOB45692"></a><div class="props_rev_3"><a id="GUID-B30F5FA6-4097-4A4B-BD5F-988195FF9A33" name="GUID-B30F5FA6-4097-4A4B-BD5F-988195FF9A33"></a><h4 id="ADLOB-GUID-B30F5FA6-4097-4A4B-BD5F-988195FF9A33" class="sect4">PL / SQL中的远程数据接口示例</h4>
                  <div>
                     <p>数据接口仅支持PL / SQL中大小小于32KB的数据。以下代码段显示了一个PL / SQL示例：</p><pre class="oac_no_warn" dir="ltr">CONNECT pm声明my_ad <span class="bold">varchar（6000）</span> ：= lpad（'b'，6000，'b'）; BEGIN INSERT INTO <span class="bold">print_media @ dbs2</span> （product_id，ad_id，ad_finaltext）VALUES（10000,10，my_ad）; - 重置缓冲区值my_ad：='a'; SELECT ad_finaltext INTO my_ad FROM <span class="bold">print_media @ dbs2</span> WHERE product_id = 10000;结束; /</pre><p>如果<code class="codeph">ad_finaltext</code>是<code class="codeph">BLOB</code>列而不是<code class="codeph">CLOB</code> ，则<code class="codeph">my_ad</code>必须是<code class="codeph">RAW</code>类型。如果LOB大小超过32KB-1，则PL / SQL会引发截断错误，并且缓冲区的内容未定义。
                     </p>
                  </div>
               </div><a id="ADLOB45693"></a><div class="props_rev_3"><a id="GUID-0E65F171-0B92-4AC4-8929-B348481C7209" name="GUID-0E65F171-0B92-4AC4-8929-B348481C7209"></a><h4 id="ADLOB-GUID-0E65F171-0B92-4AC4-8929-B348481C7209" class="sect4">OCI中的远程数据接口示例</h4>
                  <div>
                     <p>对于OCI，数据接口仅支持大小小于<code class="codeph">2 GBytes</code> （可能是声明为<code class="codeph">sb4</code>的变量的最大值）的数据。以下伪代码可以增强为OCI程序的一部分：</p><pre class="oac_no_warn" dir="ltr">...text * sql =（text *）“insert into <span class="bold">print_media @ dbs2</span> （product_id，ad_id，ad_finaltext）values（：1，：2，：3）”; OCIStmtPrepare（...）; OCIBindByPos（...）; / *绑定位置1和2 *的数据，它们独立于LOB * / OCIBindByPos（stmthp，＆bndhp [2]，errhp，（ub4）3，（dvoid *）charbuf1，（sb4）len_charbuf1， <span class="bold">SQLT_CHR</span> ，（dvoid *） 0，（ub2 *）0，（ub2 *）0,0,0，OCI_DEFAULT）; OCIStmtExecute（...）; ...text * sql =（text *）“从<span class="bold">print_media @ dbs2</span>中选择ad_finaltext，其中product_id = 10000”; OCIStmtPrepare（...）; OCIDefineByPos（stmthp，＆dfnhp [2]，errhp，（ub4）1，（dvoid *）charbuf2，（sb4）len_charbuf2， <span class="bold">SQLT_CHR</span> ，（dvoid *）0，（ub2 *）0，（ub2 *）0，OCI_DEFAULT）; OCIStmtExecute（...）; ...
</pre><p>如果<code class="codeph">ad_finaltext</code>是<code class="codeph">BLOB</code>而不是<code class="codeph">CLOB</code> ，那么使用<code class="codeph">SQLT_BIN</code>类型绑定和定义。如果LOB大小超过2GB-1，则OCI会引发截断错误，并且缓冲区的内容未定义。
                     </p>
                  </div>
               </div><a id="ADLOB45694"></a><div class="props_rev_3"><a id="GUID-7C8CA747-6873-4679-A316-EA3F078D34AB" name="GUID-7C8CA747-6873-4679-A316-EA3F078D34AB"></a><h4 id="ADLOB-GUID-7C8CA747-6873-4679-A316-EA3F078D34AB" class="sect4">JDBC中的远程数据接口示例</h4>
                  <div>
                     <p>以下代码片段适用于所有三个JDBC驱动程序（数据库中的OCI，Thin和<code class="codeph">kprb</code> ）：</p>
                     <p><span class="bold">绑定：</span> 
                     </p>
                     <p>这适用于非流模式：</p><pre class="oac_no_warn" dir="ltr">...String sql =“insert into <span class="bold">print_media @ dbs2</span> （product_id，ad_id，ad_final_text）”+“values（：1，：2，：3）”; PreparedStatement pstmt = conn.prepareStatement（sql）; pstmt.setInt（1,2）; pstmt.setInt（2,20）; <span class="bold">pstmt.setString（3，“Java string”）;</span> int rows = pstmt.executeUpdate（）; ...
</pre><p>对于流模式，与前面的代码相同的代码，除了<code class="codeph">setString()</code>语句被以下之一替换：</p><pre class="oac_no_warn" dir="ltr">pstmt.setCharacterStream（3，new LabeledReader（），1000000）; pstmt.setAsciiStream（3，new LabeledAsciiInputStream（），1000000）;</pre><p>这里， <code class="codeph">LabeledReader()</code>和<code class="codeph">LabeledAsciiInputStream()</code>分别产生字符和ASCII流。如果<code class="codeph">ad_finaltext</code>是<code class="codeph">BLOB</code>列而不是<code class="codeph">CLOB</code> ，那么如果绑定的类型为<code class="codeph">RAW</code> ，前面的示例将起作用：</p><pre class="oac_no_warn" dir="ltr">pstmt.setBytes（3，&lt;some byte [] array&gt;）; pstmt.setBinaryStream（3，new LabeledInputStream（），1000000）;</pre><p>这里， <code class="codeph">LabeledInputStream()</code>生成二进制流。
                     </p>
                     <p><span class="bold">限定：</span> 
                     </p>
                     <p>对于非流模式：</p><pre class="oac_no_warn" dir="ltr">OracleStatement stmt =（OracleStatement）（conn.createStatement（））; stmt.defineColumnType（1，类型。<span class="bold">VARCHAR</span> ）; ResultSet rst = stmt.executeQuery（“从print_media @ dbs2中选择ad_finaltext”）; while（rst.next（））{String s = rst.getString（1）; System.out.println（s）; }</pre><p>对于流媒体模式：</p><pre class="oac_no_warn" dir="ltr">OracleStatement stmt =（OracleStatement）（conn.createStatement（））; stmt.defineColumnType（1，类型。<span class="bold">LONGVARCHAR</span> ）; ResultSet rst = stmt.executeQuery（“从print_media @ dbs2中选择ad_finaltext”）; while（rst.next（））{Reader reader = rst.getCharacterStream（1）; while（reader.ready（））{System.out.print（（char）（reader.next（）））; System.out.println（）; }</pre><p>如果<code class="codeph">ad_finaltext</code>是<code class="codeph">BLOB</code>列而不是<code class="codeph">CLOB</code> ，那么如果define的类型为<code class="codeph">LONGVARBINARY</code> ，则前面的示例有效：</p><pre class="oac_no_warn" dir="ltr">...OracleStatement stmt =（OracleStatement）conn.createStatement（）; stmt.defineColumnType（1，类型。整数 ）; stmt.defineColumnType（2，类型。LONGVARBINARY）; ResultSet rset = stmt.executeQuery（“SELECT ID，LOBCOL FROM LOBTAB @MYSELF”）; while（rset.next（））{/ * using getBytes（）* / / * byte [] b = rset.getBytes（“LOBCOL”）; System.out.println（“ID：”+ rset.getInt（“ID”）+“length：”+ b.length）; * / / *使用getBinaryStream（）* / InputStream byte_stream = rset.getBinaryStream（“LOBCOL”）; byte [] b =新字节[100000]; int b_len = byte_stream.read（b）; System.out.println（“ID：”+ rset.getInt（“ID”）+“length：”+ b_len）; byte_stream.close（）; } ...</pre><div class="infoboxnotealso" id="GUID-7C8CA747-6873-4679-A316-EA3F078D34AB__GUID-2EA17AA0-FC07-4D20-A18F-F949168714A8">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="../jjdbc/LOBs-and-BFiles.html#JJDBC15000" target="_blank"><span class="italic">Oracle数据库JDBC开发人员指南</span></a></p>
                     </div>
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>