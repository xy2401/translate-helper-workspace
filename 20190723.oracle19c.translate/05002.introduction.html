<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <title>介绍</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Programmer&#39;s Guide"></meta>
      <meta property="og:description" content=""></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Programmer&#39;s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="c-c-programmers-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-11T03:52:01-08:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="1996, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96467-01"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="introduction-and-concepts.html" title="Previous" type="text/html"></link>
      <link rel="next" href="precompiler-concepts.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Pro*C/C++ Programmer&#39;s Guide"></meta>
    <meta name="dcterms.isVersionOf" content="LNPCC"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="introduction-and-concepts.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="precompiler-concepts.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">程序员指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="introduction-and-concepts.html" property="item" typeof="WebPage"><span property="name">介绍和概念</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">介绍</li>
            </ol>
            <a id="GUID-20CBCC27-EC6B-4651-92CC-7E008BD73611" name="GUID-20CBCC27-EC6B-4651-92CC-7E008BD73611"></a><a id="LNPCC3028"></a>
            
            <h2 id="LNPCC-GUID-20CBCC27-EC6B-4651-92CC-7E008BD73611" class="sect2"><span class="enumeration_chapter">1</span>简介</h2>
         </header>
         <div class="ind">
            <div>
               <p>本章将向您介绍Oracle Pro * C / C ++预编译器。您将了解它在开发操作Oracle数据的应用程序中的作用，并了解它使您的应用程序能够执行的操作。本章包含以下主题：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="introduction.html#GUID-C847E5C3-31B8-43EF-9E78-A230A788A551">什么是Oracle预编译器？</a></p>
                  </li>
                  <li>
                     <p><a href="introduction.html#GUID-635871E1-F109-4F96-BE3A-F2D9F0AB936B">为什么使用Oracle Pro * C / C ++预编译器</a></p>
                  </li>
                  <li>
                     <p><a href="introduction.html#GUID-A8028E1B-281F-4FE3-9422-688C9028CD75">为什么使用SQL</a></p>
                  </li>
                  <li>
                     <p><a href="introduction.html#GUID-0F4F4F50-8116-416C-A981-DCCA9AAE3621">为什么使用PL / SQL</a></p>
                  </li>
                  <li>
                     <p><a href="introduction.html#GUID-92ED0348-8F02-4201-86ED-E67569BF4F63">Pro * C / C ++预编译器的好处</a></p>
                  </li>
                  <li>
                     <p><a href="introduction.html#GUID-858DEF48-750A-4E59-8470-649ED33CDEEF">经常问的问题</a></p>
                  </li>
               </ul>
            </div><a id="LNPCC3030"></a><a id="LNPCC3029"></a><div class="props_rev_3"><a id="GUID-C847E5C3-31B8-43EF-9E78-A230A788A551" name="GUID-C847E5C3-31B8-43EF-9E78-A230A788A551"></a><h3 id="LNPCC-GUID-C847E5C3-31B8-43EF-9E78-A230A788A551" class="sect3"><span class="enumeration_section">1.1</span>什么是Oracle预编译器？
               </h3>
               <div>
                  <p>Oracle预编译器是一种编程工具，使用户能够在高级源程序中嵌入SQL语句。<a href="introduction.html#GUID-C847E5C3-31B8-43EF-9E78-A230A788A551__I5359">如图1-1</a>所示，预编译器接受源程序作为输入，将嵌入式SQL语句转换为标准的Oracle运行时库调用，并生成可以通常方式编译，链接和执行的已修改源程序。
                  </p>
                  <div class="figure" id="GUID-C847E5C3-31B8-43EF-9E78-A230A788A551__I5359">
                     <p class="titleinfigure">图1-1嵌入式SQL程序开发</p><img src="img/lnpcc001.gif" alt="下面是图1-1的描述" title="下面是图1-1的描述" longdesc="img_text/lnpcc001.html"><br><a href="img_text/lnpcc001.html">“图1-1嵌入式SQL程序开发”的说明</a></div>
                  <!-- class="figure" -->
               </div>
            </div><a id="LNPCC3031"></a><div class="props_rev_3"><a id="GUID-635871E1-F109-4F96-BE3A-F2D9F0AB936B" name="GUID-635871E1-F109-4F96-BE3A-F2D9F0AB936B"></a><h3 id="LNPCC-GUID-635871E1-F109-4F96-BE3A-F2D9F0AB936B" class="sect3"><span class="enumeration_section">1.2</span>为什么使用Oracle Pro * C / C ++预编译器</h3>
               <div>
                  <p>Oracle Pro * C / C ++预编译器使您可以在应用程序中使用SQL的强大功能和灵活性。方便易用的界面使您的应用程序可以直接访问Oracle。</p>
                  <p>与许多应用程序开发工具不同，Pro * C / C ++允许您创建高度自定义的应用程序。例如，您可以创建包含最新窗口和鼠标技术的用户界面。您还可以创建在后台运行的应用程序，而无需用户交互。 <a id="d8301e72" class="indexterm-anchor"></a> 
                  </p>
                  <p>此外，Pro * C / C ++可帮助您微调应用程序。它允许密切监视资源使用，SQL语句执行和各种运行时指示器。使用此信息，您可以更改程序参数以获得最佳性能。</p>
                  <p>虽然预编译为应用程序开发过程增加了一个步骤，但它可以节省时间。预编译器（而不是您）将每个嵌入式SQL语句转换为对Oracle运行时库（SQLLIB）的调用。Pro * C / C ++预编译器还分析主机变量，定义结构到列的映射，并且使用SQLCHECK = FULL，对嵌入式SQL语句执行语义分析。</p>
               </div>
            </div><a id="LNPCC3032"></a><div class="props_rev_3"><a id="GUID-A8028E1B-281F-4FE3-9422-688C9028CD75" name="GUID-A8028E1B-281F-4FE3-9422-688C9028CD75"></a><h3 id="LNPCC-GUID-A8028E1B-281F-4FE3-9422-688C9028CD75" class="sect3"><span class="enumeration_section">1.3</span>为什么使用SQL</h3>
               <div>
                  <p>如果要访问和操作Oracle数据，则需要SQL。无论是通过SQL * Plus交互式使用SQL还是嵌入应用程序，都取决于手头的工作。如果作业需要C或C ++的程序处理能力，或者必须定期完成，请使用嵌入式SQL。 <a id="d8301e93" class="indexterm-anchor"></a><a id="d8301e97" class="indexterm-anchor"></a><a id="d8301e101" class="indexterm-anchor"></a><a id="d8301e105" class="indexterm-anchor"></a> 
                  </p>
                  <p>SQL已成为首选的数据库语言，因为它灵活，功能强大且易于学习。它是非过程性的，它允许您指定您想要的内容，而无需指定如何操作。一些类似英语的语句可以轻松地一次操作一行或多行Oracle数据。 <a id="d8301e112" class="indexterm-anchor"></a><a id="d8301e116" class="indexterm-anchor"></a> 
                  </p>
                  <p>您可以执行任何SQL（而不是SQL * Plus） <a id="d8301e123" class="indexterm-anchor"></a>来自应用程序的声明。例如，你可以</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>动态创建，更改和DROP数据库表</p>
                     </li>
                     <li>
                        <p>SELECT，INSERT，UPDATE和DELETE数据行</p>
                     </li>
                     <li>
                        <p>COMMIT或ROLLBACK事务</p>
                     </li>
                  </ul>
                  <p>在将SQL语句嵌入应用程序之前，可以使用SQL * Plus以交互方式测试它们。通常，从交互式SQL切换到嵌入式SQL只需要进行微小的更改。 <a id="d8301e138" class="indexterm-anchor"></a> 
                  </p>
               </div>
            </div><a id="LNPCC3033"></a><div class="props_rev_3"><a id="GUID-0F4F4F50-8116-416C-A981-DCCA9AAE3621" name="GUID-0F4F4F50-8116-416C-A981-DCCA9AAE3621"></a><h3 id="LNPCC-GUID-0F4F4F50-8116-416C-A981-DCCA9AAE3621" class="sect3"><span class="enumeration_section">1.4</span>为什么使用PL / SQL</h3>
               <div>
                  <p>作为SQL的扩展，PL / SQL是一种事务处理语言，支持过程构造，变量声明和强大的错误处理。在同一个PL / SQL块中，您可以使用SQL和所有PL / SQL扩展。 <a id="d8301e154" class="indexterm-anchor"></a><a id="d8301e156" class="indexterm-anchor"></a><a id="d8301e160" class="indexterm-anchor"></a> 
                  </p>
                  <p>嵌入式PL / SQL的主要优点是性能更好。与SQL不同，PL / SQL提供了逻辑分组SQL语句并将其以块的形式发送到Oracle而不是逐个发送到Oracle的能力。这减少了网络流量和处理开销。 <a id="d8301e167" class="indexterm-anchor"></a><a id="d8301e171" class="indexterm-anchor"></a> 
                  </p>
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="embedded-PL-SQL.html#GUID-BCE83EB3-88D8-4EA1-853F-D5B66D426654">嵌入式PL / SQL</a></li>
                     </ul>
                  </div>
               </div>
               
            </div><a id="LNPCC3035"></a><a id="LNPCC3034"></a><div class="props_rev_3"><a id="GUID-92ED0348-8F02-4201-86ED-E67569BF4F63" name="GUID-92ED0348-8F02-4201-86ED-E67569BF4F63"></a><h3 id="LNPCC-GUID-92ED0348-8F02-4201-86ED-E67569BF4F63" class="sect3"><span class="enumeration_section">1.5</span> Pro * C / C ++预编译器的好处</h3>
               <div>
                  <p><a href="introduction.html#GUID-92ED0348-8F02-4201-86ED-E67569BF4F63__I5373">如图1-2</a>所示，Pro * C / C ++提供了许多功能和优点，可帮助您开发有效，可靠的应用程序。
                  </p>
                  <div class="figure" id="GUID-92ED0348-8F02-4201-86ED-E67569BF4F63__I5373">
                     <p class="titleinfigure">图1-2特性和优点</p><img src="img/lnpcc002.gif" alt="下面是图1-2的描述" title="下面是图1-2的描述" longdesc="img_text/lnpcc002.html"><br><a href="img_text/lnpcc002.html">“图1-2特点和优点”的描述</a></div>
                  <!-- class="figure" -->
                  <p>Pro * C / C ++支持：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>用C或C ++编写应用程序。</p>
                     </li>
                     <li>
                        <p>遵循ANSI / ISO标准，以高级语言嵌入SQL语句。</p>
                     </li>
                     <li>
                        <p>利用动态SQL，这是一种高级编程技术，可让您的程序在运行时接受或构建任何有效的SQL语句。</p>
                     </li>
                     <li>
                        <p>设计和开发高度定制的应用程序。</p>
                     </li>
                     <li>
                        <p>编写共享服务器进程应用程</p>
                     </li>
                     <li>
                        <p>自动在Oracle内部数据类型和高级语言数据类型之间进行转换。</p>
                     </li>
                     <li>
                        <p>通过在应用程序中嵌入PL / SQL事务处理块来提高性能。</p>
                     </li>
                     <li>
                        <p>在内联和命令行中指定有用的预编译器选项，并在预编译期间更改它们的值。</p>
                     </li>
                     <li>
                        <p>使用数据类型等效来控制Oracle解释输入数据和格式化输出数据的方式。</p>
                     </li>
                     <li>
                        <p>单独预编译几个程序模块，然后将它们链接到一个可执行程序。</p>
                     </li>
                     <li>
                        <p>完整检查嵌入式SQL数据操作语句和PL / SQL块的语法和语义。</p>
                     </li>
                     <li>
                        <p>使用Oracle Net在多个节点上同时访问Oracle数据库。</p>
                     </li>
                     <li>
                        <p>使用数组作为输入和输出程序变量。</p>
                     </li>
                     <li>
                        <p>有条件地预编译主机程序中的代码段，以便它可以在不同的环境中运行。</p>
                     </li>
                     <li>
                        <p>通过使用以高级语言编写的用户出口与SQL * Forms直接接口。</p>
                     </li>
                     <li>
                        <p>使用SQL通信区域（SQLCA）和WHENEVER或DO语句处理错误和警告。</p>
                     </li>
                     <li>
                        <p>使用Oracle通信区域（ORACA）提供的增强型诊断集。</p>
                     </li>
                     <li>
                        <p>在数据库中使用用户定义的对象类型。</p>
                     </li>
                     <li>
                        <p>在数据库中使用集合（varrays和嵌套表）。</p>
                     </li>
                     <li>
                        <p>在数据库中使用LOB（大对象）。</p>
                     </li>
                     <li>
                        <p>使用存储在数据库中的国家字符集数据。</p>
                     </li>
                     <li>
                        <p>在您的程序中使用OCI（Oracle调用接口）函数。</p>
                     </li>
                     <li>
                        <p>使用多线程应用程序。</p>
                     </li>
                     <li>
                        <p>Microsoft Visual Studio .NET 2002/2003支持。</p>
                     </li>
                  </ul>
                  <p>Pro * C / C ++是一个功能齐全的工具，支持嵌入式SQL编程的专业方法。</p>
                  <div class="infoboxnote" id="GUID-92ED0348-8F02-4201-86ED-E67569BF4F63__GUID-6654BCA5-93CD-47F0-9E99-242686B78CB2">
                     <p class="notep1">注意：</p>
                     <p>Pro * C / C ++不支持16位代码生成。</p>
                  </div>
               </div>
            </div><a id="LNPCC3037"></a><a id="LNPCC3036"></a><div class="props_rev_3"><a id="GUID-DE359CDA-7ACC-43C2-B787-6D405C8EB08B" name="GUID-DE359CDA-7ACC-43C2-B787-6D405C8EB08B"></a><h3 id="LNPCC-GUID-DE359CDA-7ACC-43C2-B787-6D405C8EB08B" class="sect3"><span class="enumeration_section">1.6</span>目录结构</h3>
               <div>
                  <div class="section">
                     <p>安装Oracle软件时，会在硬盘驱动器上为Oracle产品创建目录结构。主Oracle目录包含运行Pro * C / C ++所必需的Oracle子目录和文件。</p>
                     <p>安装Pro * C / C ++时，Oracle Universal Installer会在<span class="italic"><code class="codeph">ORACLE_BASE</code></span> <code class="codeph">\</code> <span class="italic"><code class="codeph">ORACLE_HOME</code></span>目录中创建名为<code class="codeph">\precomp</code>的目录。<a id="d8301e318" class="indexterm-anchor"></a>该子目录包含<a href="introduction.html#GUID-DE359CDA-7ACC-43C2-B787-6D405C8EB08B__g1006057" title="Precomp目录结构">表1-1中</a>列出的Pro * C / C ++可执行文件，库文件和示例程序。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="tblformal" id="GUID-DE359CDA-7ACC-43C2-B787-6D405C8EB08B__g1006057">
                     <p class="titleintable">表1-1 precomp目录结构</p>
                     <table cellpadding="4" cellspacing="0" class="Formal" title="precomp目录结构" width="100%" border="1" summary="Precomp directory structure" frame="hsides" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="31%" id="d8301e338">目录名称</th>
                              <th align="left" valign="bottom" width="69%" id="d8301e341">内容</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d8301e346" headers="d8301e338 ">
                                 <p><code class="codeph">\ ADMIN</code></p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d8301e346 d8301e341 ">
                                 <p>配置文件</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d8301e354" headers="d8301e338 ">
                                 <p><code class="codeph">\演示\ PROC</code></p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d8301e354 d8301e341 ">
                                 <p>Pro * C / C ++的示例程序</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d8301e362" headers="d8301e338 ">
                                 <p><code class="codeph">\演示\ SQL</code></p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d8301e362 d8301e341 ">
                                 <p>示例程序的SQL脚本</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d8301e370" headers="d8301e338 ">
                                 <p><code class="codeph">\ DOC \ PROC</code></p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d8301e370 d8301e341 ">
                                 <p>Pro * C / C ++的自述文件</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d8301e378" headers="d8301e338 ">
                                 <p><code class="codeph">\ LIB \ MSVC</code></p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d8301e378 d8301e341 ">
                                 <p>Pro * C / C ++的库文件</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d8301e386" headers="d8301e338 ">
                                 <p><code class="codeph">\ MESG</code></p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d8301e386 d8301e341 ">
                                 <p>消息文件</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d8301e394" headers="d8301e338 ">
                                 <p><code class="codeph">\上市</code></p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d8301e394 d8301e341 ">
                                 <p>头文件</p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
                  <div class="section">
                     <div class="infoboxnote" id="GUID-DE359CDA-7ACC-43C2-B787-6D405C8EB08B__GUID-C0FF0ADE-9451-44A1-A4E6-2D413DB627F7">
                        <p class="notep1">注意：</p>
                        <p><code class="codeph">\precomp</code>目录可以包含其他产品的文件，例如Pro * COBOL。</p>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div><a id="LNPCC3038"></a><div class="props_rev_3"><a id="GUID-DEEA19EC-90ED-4D77-9C9D-EE06128216F1" name="GUID-DEEA19EC-90ED-4D77-9C9D-EE06128216F1"></a><h4 id="LNPCC-GUID-DEEA19EC-90ED-4D77-9C9D-EE06128216F1" class="sect4"><span class="enumeration_section">1.6.1</span>已知问题，限制和解决方法</h4>
                  <div>
                     <div class="section">
                        <p>虽然所有Windows操作系统都允许文件名和目录名中的空格，但Oracle Pro * C / C ++和Oracle Pro * COBOL预编译器不会预编译包含文件名或目录名中的空格的文件。例如，请勿使用以下格式：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">proc iname = test one.pc</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">proc iname = d：\ dir1 \ second dir \ sample1.pc</code></p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="LNPCC3039"></a><div class="props_rev_3"><a id="GUID-D9CD77BB-F827-4A0D-966C-3623480540C2" name="GUID-D9CD77BB-F827-4A0D-966C-3623480540C2"></a><h3 id="LNPCC-GUID-D9CD77BB-F827-4A0D-966C-3623480540C2" class="sect3"><span class="enumeration_section">1.7</span>库文件</h3>
               <div>
                  <div class="section">
                     <p>链接Pro * C / C ++应用程序时，使用库文件。Pro * C / C ++库文件安装如下：</p><pre class="oac_no_warn" dir="ltr">ORACLE_HOME \预补偿\ LIB \ orasql12.lib</pre><pre class="oac_no_warn" dir="ltr">ORACLE_HOME \预补偿\ LIB \ ottclasses.zip</pre><pre class="oac_no_warn" dir="ltr">ORACLE_HOME \预补偿\ LIB \ MSVC \ orasqx12.lib</pre><p>Pro * C / C ++应用程序接口（API）调用在Pro * C / C ++软件提供的DLL文件中实现。要使用DLL，必须将应用程序链接到与Pro * C / C ++ DLL对应的导入库（.lib文件）。此外，您必须确保在运行Pro * C / C ++应用程序的计算机上安装DLL文件。</p>
                     <p>Microsoft为您提供了三个库： <code class="codeph">libc.lib</code> ， <code class="codeph">libcmt.lib</code>和<code class="codeph">msvcrt.lib</code> 。Oracle DLL使用<a id="d8301e476" class="indexterm-anchor"></a> <code class="codeph">msvcrt.lib</code>运行时库。您必须使用<code class="codeph">msvcrt.lib</code>而不是其他两个Microsoft库链接应用程序。
                     </p>
                  </div>
                  <!-- class="section" -->
               </div>
            </div><a id="LNPCC3040"></a><div class="props_rev_3"><a id="GUID-858DEF48-750A-4E59-8470-649ED33CDEEF" name="GUID-858DEF48-750A-4E59-8470-649ED33CDEEF"></a><h3 id="LNPCC-GUID-858DEF48-750A-4E59-8470-649ED33CDEEF" class="sect3"><span class="enumeration_section">1.8</span>常见问题</h3>
               <div>
                  <p>本节介绍了一些常见的有关Pro * C / C ++以及与Pro * C / C ++相关的Oracle的问题。答案比本指南其余部分的文档更为非正式，但确实提供了可以找到参考资料的地方的参考。</p>
               </div><a id="LNPCC3041"></a><div class="props_rev_3"><a id="GUID-7CAEDDB0-8E4A-4DB7-9898-557D26920347" name="GUID-7CAEDDB0-8E4A-4DB7-9898-557D26920347"></a><h4 id="LNPCC-GUID-7CAEDDB0-8E4A-4DB7-9898-557D26920347" class="sect4"><span class="enumeration_section">1.8.1</span>什么是VARCHAR？
                  </h4>
                  <div>
                     <p>以下是VARCHAR的简短描述：</p>
                     <div class="tblformal" id="GUID-7CAEDDB0-8E4A-4DB7-9898-557D26920347__GUID-1F623526-BD5C-489F-9F43-FB9D5F942E8D">
                        <table cellpadding="4" cellspacing="0" class="Formal" title="" width="100%" border="1" summary="VARCHAR" frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="29%" id="d8301e520">VARCHAR</th>
                                 <th align="left" valign="bottom" width="71%" id="d8301e524">描述</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d8301e529" headers="d8301e520 ">
                                    <p>VARCHAR2</p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d8301e529 d8301e524 ">
                                    <p>数据库中的一种包含可变长度字符数据的列。这就是Oracle所谓的“内部数据类型”，因为它是一种可能的列类型。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d8301e536" headers="d8301e520 ">
                                    <p>VARCHAR</p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d8301e536 d8301e524 ">
                                    <p>Oracle“外部数据类型”（数据类型代码9）。只有在执行动态SQL方法4或数据类型等效时才使用此选项。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d8301e543" headers="d8301e520 ">
                                    <p>VARCHAR [n]的</p>
                                    <p>VARCHAR [n]的</p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d8301e543 d8301e524 ">
                                    <p>这是Pro * C / C ++“假型”，您可以在Pro * C / C ++程序中将其声明为主变量。它实际上是由Pro * C / C ++生成的结构，具有2字节长度的元素和[n]字节字符数组。</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="datatypes-and-host-variables.html#GUID-18395E0D-263A-49BF-9DAB-DA0C8775B9FC">数据类型和主机变量</a></li>
                           <li><a href="ANSI-dynamic-SQL.html#GUID-BF450DA3-B05F-403E-B5DF-C967A20524BF">ANSI动态SQL</a></li>
                           <li><a href="Oracle-dynamic-SQL-method-4.html#GUID-B516B7C8-1859-4A54-B15D-DF0C3D3C474D">Oracle动态SQL：方法4</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div><a id="LNPCC3042"></a><div class="props_rev_3"><a id="GUID-51750A5E-5689-4766-B321-EA32CA9F678C" name="GUID-51750A5E-5689-4766-B321-EA32CA9F678C"></a><h4 id="LNPCC-GUID-51750A5E-5689-4766-B321-EA32CA9F678C" class="sect4"><span class="enumeration_section">1.8.2</span> Pro * C / C ++是否会生成对Oracle调用接口的调用？
                  </h4>
                  <div>
                     <p>不.Pro * C / C ++生成数据结构并调用其运行时库：SQLLIB。</p>
                  </div>
               </div><a id="LNPCC3043"></a><div class="props_rev_3"><a id="GUID-4A2D9912-3C78-40EE-BA40-184DBBFC715A" name="GUID-4A2D9912-3C78-40EE-BA40-184DBBFC715A"></a><h4 id="LNPCC-GUID-4A2D9912-3C78-40EE-BA40-184DBBFC715A" class="sect4"><span class="enumeration_section">1.8.3</span>为什么不使用SQLLIB调用代码而不使用Pro * C / C ++？
                  </h4>
                  <div>
                     <p>SQLLIB没有外部记录，不受支持，并且可能在发行版之间发生变化。此外，Pro * C / C ++是符合ANSI / ISO标准的产品，符合嵌入式SQL的标准要求。</p>
                     <p>SQLLIB不是API。虽然它具有用户可调用的函数，但它主要是预编译器语言套件的运行时库。</p>
                     <p>如果需要对数据库进行API编码，请使用Oracle调用接口，Oracle RDBMS的客户端API，或混合使用OCI和Pro * C / C ++。</p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="advanced-topics.html#GUID-5A1F44A6-4B41-4610-B265-C56C85261379">用于OCI版本8互操作性的SQLLIB扩展</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div><a id="LNPCC3044"></a><div class="props_rev_3"><a id="GUID-1B78C553-8694-4EB0-AB2E-6F61424CF54B" name="GUID-1B78C553-8694-4EB0-AB2E-6F61424CF54B"></a><h4 id="LNPCC-GUID-1B78C553-8694-4EB0-AB2E-6F61424CF54B" class="sect4"><span class="enumeration_section">1.8.4</span>我可以从Pro * C / C ++程序调用PL / SQL存储过程吗？
                  </h4>
                  <div>
                     <p>当然。请参阅<a href="embedded-PL-SQL.html#GUID-BCE83EB3-88D8-4EA1-853F-D5B66D426654">嵌入式PL / SQL</a> 。有一个演示程序， <span class="q">“ <a href="embedded-PL-SQL.html#GUID-F20A70DA-AF53-41CB-82CA-D2DA5B77E4A5">关于调用存储的PL / SQL或Java子程序</a> ”</span> 。
                     </p>
                  </div>
               </div><a id="LNPCC3045"></a><div class="props_rev_3"><a id="GUID-EA610588-C286-4104-ABA3-BC23A57C1573" name="GUID-EA610588-C286-4104-ABA3-BC23A57C1573"></a><h4 id="LNPCC-GUID-EA610588-C286-4104-ABA3-BC23A57C1573" class="sect4"><span class="enumeration_section">1.8.5</span>我可以编写C ++代码，并使用Pro * C / C ++进行预编译吗？
                  </h4>
                  <div>
                     <p>是。请参阅<a href="C-Plus-Plus-Applications.html#GUID-320589F8-AE9F-4440-9551-1C52F449E486">C ++应用程序</a> 。
                     </p>
                  </div>
               </div><a id="LNPCC3046"></a><div class="props_rev_3"><a id="GUID-1E645F0C-082F-443F-B6D2-18EFC87AAA58" name="GUID-1E645F0C-082F-443F-B6D2-18EFC87AAA58"></a><h4 id="LNPCC-GUID-1E645F0C-082F-443F-B6D2-18EFC87AAA58" class="sect4"><span class="enumeration_section">1.8.6</span>我可以在SQL语句中的任何位置使用绑定变量吗？
                  </h4>
                  <div>
                     <p>例如，我希望能够在运行时在我的SQL语句中输入表的名称。但是当我使用主机变量时，我得到预编译错误。</p>
                     <p>通常，您可以在SQL或PL / SQL中允许表达式的语句中的任何位置使用宿主变量。</p>
                     <p>但是，以下SQL语句（其中<span class="italic">table_name</span>是主机变量）是<span class="italic">非法的</span> ：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL SELECT ename，sal INTO：name，：salary FROM：table_name;</pre><p>要解决您的问题，您需要使用动态SQL。有一个演示程序可以适应这样做， <span class="q">“ <a href="Oracle-dynamic-SQL.html#GUID-56E41F14-669F-4CFD-8672-601EE3EDAD62">示例程序：动态SQL方法1</a> ”</span> 。
                     </p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="datatypes-and-host-variables.html#GUID-60C0F646-92C0-4AB1-9E88-3B2677C3CF8B">主机变量引用</a></li>
                           <li><a href="Oracle-dynamic-SQL.html#GUID-3B9E253A-F03D-431D-A77E-84C02C43F494">Oracle动态SQL</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div><a id="LNPCC3047"></a><div class="props_rev_3"><a id="GUID-AAB156D4-5916-4C2C-BB9A-CE2269B6C483" name="GUID-AAB156D4-5916-4C2C-BB9A-CE2269B6C483"></a><h4 id="LNPCC-GUID-AAB156D4-5916-4C2C-BB9A-CE2269B6C483" class="sect4"><span class="enumeration_section">1.8.7</span> Pro * C / C ++中的字符处理使我感到困惑。
                  </h4>
                  <div>
                     <p>有很多选择，但我们可以简化。首先，如果您需要与以前的预编译器版本和Oracle7兼容，最安全的做法是使用VARCHAR [n]主机变量。</p>
                     <p>Pro * C / C ++中所有其他字符变量的默认数据类型是CHARZ。简而言之，这意味着您必须在输入时对字符串进行空值终止，并且它在输出时都是空白填充和空终止的。</p>
                     <p>在8.0版中，引入了CHAR_MAP预编译器选项以指定char变量的默认映射。</p>
                     <p>如果VARCHAR和CHARZ都不适用于您的应用程序，并且您需要完全类似C的行为（空终止，绝对没有空白填充），请使用TYPE命令和C <code class="codeph">typedef</code>语句，并使用数据类型等效将您的字符主机变量转换为串。有一个示例程序，显示如何使用TYPE命令从<span class="q">“ <a href="datatypes-and-host-variables.html#GUID-FA7D1173-C17F-4740-8E96-CB087D29394F">示例程序：使用sqlvcp（）</a> ”开始</span> 。
                     </p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="datatypes-and-host-variables.html#GUID-2CFEFD3E-61E4-4B86-92E7-35DCFAFFFA9D">VARCHAR变量声明</a></li>
                           <li><a href="datatypes-and-host-variables.html#GUID-BE81B381-7513-4F86-ACCF-84583A307251">CHARZ</a></li>
                           <li><a href="advanced-topics.html#GUID-B1D5E862-13FA-429B-9492-40785377256E">预编译器选项CHAR_MAP</a></li>
                           <li><a href="advanced-topics.html#GUID-F62EEF33-4BCC-472C-B812-5C257333FE50">用户定义的类型等价</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div><a id="LNPCC3048"></a><div class="props_rev_3"><a id="GUID-63342CAA-87DD-401A-8A19-A257332EB3F8" name="GUID-63342CAA-87DD-401A-8A19-A257332EB3F8"></a><h4 id="LNPCC-GUID-63342CAA-87DD-401A-8A19-A257332EB3F8" class="sect4"><span class="enumeration_section">1.8.8</span>字符指针有什么特别之处吗？
                  </h4>
                  <div>
                     <p>是。当Pro * C / C ++绑定输入或输出主变量时，它必须知道长度。当您使用VARCHAR [n]或声明char [n]类型的主机变量时，Pro * C / C ++知道声明的长度。但是当你使用字符指针作为主变量，并使用<code class="codeph">malloc()</code>来定义程序中的缓冲区时，Pro * C / C ++无法知道长度。
                     </p>
                     <p>在输出时，您不仅必须分配缓冲区，而且必须使用一些非空字符填充它，然后将其终止。在输入或输出时，Pro * C / C ++调用<code class="codeph">strlen()</code>来获取缓冲区的长度。
                     </p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="datatypes-and-host-variables.html#GUID-44E37B7E-C78E-4F3E-87D5-19152BDCE1B8">指针变量</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div><a id="LNPCC3049"></a><div class="props_rev_3"><a id="GUID-57D08848-103C-4109-BDD7-8FCD2944937D" name="GUID-57D08848-103C-4109-BDD7-8FCD2944937D"></a><h4 id="LNPCC-GUID-57D08848-103C-4109-BDD7-8FCD2944937D" class="sect4"><span class="enumeration_section">1.8.9</span>为什么SPOOL在Pro * C / C ++中不起作用？
                  </h4>
                  <div>
                     <p>SPOOL是SQL * Plus中使用的特殊命令。它不是嵌入式SQL命令。</p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="precompiler-concepts.html#GUID-D244197E-032F-4F23-81FF-F6985A80739C">嵌入式SQL编程的关键概念</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div><a id="LNPCC3050"></a><div class="props_rev_3"><a id="GUID-0EF7A49E-ECFF-45F2-A795-7E5548AAD8AE" name="GUID-0EF7A49E-ECFF-45F2-A795-7E5548AAD8AE"></a><h4 id="LNPCC-GUID-0EF7A49E-ECFF-45F2-A795-7E5548AAD8AE" class="sect4"><span class="enumeration_section">1.8.10</span>我在哪里可以找到示例程序的在线版本？
                  </h4>
                  <div>
                     <p>每个Oracle安装都应该有一个<code class="codeph">demo</code>目录。如果目录不存在，或者不包含示例程序，请咨询您的系统或数据库管理员。
                     </p>
                  </div>
               </div><a id="LNPCC3051"></a><div class="props_rev_3"><a id="GUID-5BADFB79-84DB-41D8-BA1F-759B84803F18" name="GUID-5BADFB79-84DB-41D8-BA1F-759B84803F18"></a><h4 id="LNPCC-GUID-5BADFB79-84DB-41D8-BA1F-759B84803F18" class="sect4"><span class="enumeration_section">1.8.11</span>如何编译和链接我的应用程序？
                  </h4>
                  <div>
                     <p>编译和链接是特定于平台的。系统特定的Oracle文档包含有关如何链接Pro * C / C ++应用程序的说明。在UNIX系统上， <code class="codeph">demo</code>目录中有一个名为<code class="codeph">demo_proc.mk</code>的makefile。要链接，比如演示程序sample1.pc，您可以输入命令行<a id="d8301e825" class="indexterm-anchor"></a><a id="d8301e829" class="indexterm-anchor"></a><a id="d8301e833" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">make -f demo_proc.mk sample1</pre><p>如果需要使用特殊的预编译器选项，可以单独运行Pro * C / C ++，然后执行make。或者，您可以创建自己的自定义makefile。例如，如果您的程序包含嵌入的PL / SQL代码，则可以输入</p><pre class="oac_no_warn" dir="ltr">proc cv_demo userid = <span class="italic">username</span> / <span class="italic">password</span> sqlcheck = semantics make -f demo_proc.mk build OBJS = sample1.o EXE = sample1</pre><p>在VMS系统上，有一个名为LNPROC的脚本，用于链接Pro * C / C ++应用程序。<a id="d8301e849" class="indexterm-anchor"></a><a id="d8301e853" class="indexterm-anchor"></a><a id="d8301e857" class="indexterm-anchor"></a></p>
                  </div>
               </div><a id="LNPCC3052"></a><div class="props_rev_3"><a id="GUID-0BB76298-7AC2-4099-982B-728AD8159846" name="GUID-0BB76298-7AC2-4099-982B-728AD8159846"></a><h4 id="LNPCC-GUID-0BB76298-7AC2-4099-982B-728AD8159846" class="sect4"><span class="enumeration_section">1.8.12</span> Pro * C / C ++现在支持使用结构作为主机变量吗？
                  </h4>
                  <div>
                     <p>这如何与数组接口一起使用？</p>
                     <p>您可以在单个结构中使用数组，也可以在阵列接口中使用结构数组。</p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="datatypes-and-host-variables.html#GUID-755B5F00-C7D7-4F3F-87FD-2AF5E5703D36">主机结构</a></li>
                           <li><a href="datatypes-and-host-variables.html#GUID-44E37B7E-C78E-4F3E-87D5-19152BDCE1B8">指针变量</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div><a id="LNPCC3053"></a><div class="props_rev_3"><a id="GUID-43487428-2A14-4D62-95EA-0F399209CF71" name="GUID-43487428-2A14-4D62-95EA-0F399209CF71"></a><h4 id="LNPCC-GUID-43487428-2A14-4D62-95EA-0F399209CF71" class="sect4"><span class="enumeration_section">1.8.13</span>如果在函数中使用嵌入式SQL，是否可以在Pro * C / C ++中使用递归函数？
                  </h4>
                  <div>
                     <p>是。但是，对于嵌入式SQL，必须使用游标变量。</p>
                  </div>
               </div><a id="LNPCC3054"></a><div class="props_rev_3"><a id="GUID-7D0FDBB2-0872-4E1C-815D-C5B7CA27BD4E" name="GUID-7D0FDBB2-0872-4E1C-815D-C5B7CA27BD4E"></a><h4 id="LNPCC-GUID-7D0FDBB2-0872-4E1C-815D-C5B7CA27BD4E" class="sect4"><span class="enumeration_section">1.8.14</span>我可以在任何版本的Oracle Server上使用任何版本的Pro * C / C ++吗？
                  </h4>
                  <div>
                     <p>当您针对数据库服务器运行预编译器或OCI应用程序时，Oracle建议数据库服务器软件的版本等于或高于客户端软件版本，但不严格要求此配置。例如，如果您的Oracle数据库客户端软件是8.1.7版，那么建议您的Oracle数据库服务器软件是8.1.7或更高版本，以便在客户端上针对服务器运行预编译器应用程序。</p>
                     <p>有关升级应用程序的更多信息，请参阅“ <a href="../upgrd/index.html" target="_blank"><span class="italic">Oracle数据库升级指南”</span></a> 。
                     </p>
                  </div>
               </div><a id="LNPCC3055"></a><div class="props_rev_3"><a id="GUID-13AB266E-2F7E-425B-9F93-31523495DCE0" name="GUID-13AB266E-2F7E-425B-9F93-31523495DCE0"></a><h4 id="LNPCC-GUID-13AB266E-2F7E-425B-9F93-31523495DCE0" class="sect4"><span class="enumeration_section">1.8.15</span>当我的应用程序运行时，我继续得到一个Ora-1405错误（提取的列值为NULL）。
                  </h4>
                  <div>
                     <p>您正在为没有关联指示符变量的主变量中选择NULL。这不符合ANSI / ISO标准，并从Oracle7开始改变。</p>
                     <p>如果可能，使用指标变量重写程序，并在将来的开发中使用指标。</p>
                     <p>或者，如果使用MODE = ORACLE和DBMS = V7或V8进行预编译，请在命令行上指定UNSAFE_NULL = YES以禁用ORA-01405消息。</p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="embedded-SQL.html#GUID-22C65C80-42A1-4C8B-B883-19EFDF7AA31C">指标变量</a></li>
                           <li><a href="precompiler-options.html#GUID-738C5830-5089-4218-8C37-2CED2004C4BA">UNSAFE_NULL</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div><a id="LNPCC3056"></a><div class="props_rev_3"><a id="GUID-01B348B7-51FF-4F9D-BA7B-01EB75116E63" name="GUID-01B348B7-51FF-4F9D-BA7B-01EB75116E63"></a><h4 id="LNPCC-GUID-01B348B7-51FF-4F9D-BA7B-01EB75116E63" class="sect4"><span class="enumeration_section">1.8.16</span>所有SQLLIB函数是否都是私有的？
                  </h4>
                  <div>
                     <p>不可以。您可以调用一些SQLLIB函数来获取有关您的程序或其数据的信息。SQLLIB公共函数如下所示：</p>
                     <div class="tblformal" id="GUID-01B348B7-51FF-4F9D-BA7B-01EB75116E63__GUID-C0E51167-F014-4FC8-A957-BCCC1E8992C9">
                        <table cellpadding="4" cellspacing="0" class="Formal" title="" width="100%" border="1" summary="SQLLIB" frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="29%" id="d8301e969">SQLLIB公共函数</th>
                                 <th align="left" valign="bottom" width="71%" id="d8301e972">描述</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d8301e977" headers="d8301e969 ">
                                    <p>SQLSQLDAAlloc（）</p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d8301e977 d8301e972 ">
                                    <p>用于为动态SQL方法4分配SQL描述符数组（SQLDA）。请参阅<span class="q">“ <a href="Oracle-dynamic-SQL-method-4.html#GUID-65F15694-C793-48E7-BD25-B59D8539DC79">SQLDA如何引用？</a>“</span> 。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d8301e989" headers="d8301e969 ">
                                    <p>SQLCDAFromResultSetCursor（）</p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d8301e989 d8301e972 ">
                                    <p>用于将Pro * C / C ++游标变量转换为OCI游标数据区域。请参见<span class="q">“ <a href="advanced-topics.html#GUID-3B79020D-735A-47A9-84DA-401D86E8F712">SQLLIB公共函数的新名称</a> ”</span> 。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d8301e1001" headers="d8301e969 ">
                                    <p>SQLSQLDAFree（）</p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d8301e1001 d8301e972 ">
                                    <p>用于释放使用<span class="italic">SQLSQLDAAlloc（）</span>分配的SQLDA <span class="italic">。</span>请参见<span class="q">“ <a href="advanced-topics.html#GUID-3B79020D-735A-47A9-84DA-401D86E8F712">SQLLIB公共函数的新名称</a> ”</span> 。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d8301e1016" headers="d8301e969 ">
                                    <p>SQLCDAToResultSetCursor（）</p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d8301e1016 d8301e972 ">
                                    <p>用于将OCI游标数据区域转换为Pro * C / C ++游标变量。请参见<span class="q">“ <a href="advanced-topics.html#GUID-3B79020D-735A-47A9-84DA-401D86E8F712">SQLLIB公共函数的新名称</a> ”</span> 。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d8301e1028" headers="d8301e969 ">
                                    <p>SQLErrorGetText（）</p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d8301e1028 d8301e972 ">
                                    <p>返回一条长错误消息。请参阅<span class="q">“ <a href="handling-run-time-errors.html#GUID-16BF9560-9F35-4565-ACE5-02EF244B0191">sqlerrm</a> ”</span> 。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d8301e1040" headers="d8301e969 ">
                                    <p>SQLStmtGetText（）</p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d8301e1040 d8301e972 ">
                                    <p>用于返回最近执行的SQL语句的文本。请参见<span class="q">“ <a href="handling-run-time-errors.html#GUID-0760D27A-BEB8-4576-AC09-1D2B04E2522B">关于获取SQL语句的文本</a> ”</span> 。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d8301e1052" headers="d8301e969 ">
                                    <p>SQLLDAGetNamed（）</p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d8301e1052 d8301e972 ">
                                    <p>当在Pro * C / C ++程序中使用OCI调用时，用于获取命名连接的有效登录数据区。请参见<span class="q">“ <a href="advanced-topics.html#GUID-3B79020D-735A-47A9-84DA-401D86E8F712">SQLLIB公共函数的新名称</a> ”</span> 。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d8301e1064" headers="d8301e969 ">
                                    <p>SQLLDAGetCurrent（）</p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d8301e1064 d8301e972 ">
                                    <p>当在Pro * C / C ++程序中使用OCI调用时，用于获取最新连接的有效登录数据区。请参见<span class="q">“ <a href="advanced-topics.html#GUID-3B79020D-735A-47A9-84DA-401D86E8F712">SQLLIB公共函数的新名称</a> ”</span> 。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d8301e1076" headers="d8301e969 ">
                                    <p>SQLColumnNullCheck（）</p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d8301e1076 d8301e972 ">
                                    <p>返回动态SQL方法4的NULL状态指示。请参见<span class="q">“ <a href="Oracle-dynamic-SQL-method-4.html#GUID-E8EB0987-EA56-40C4-94D6-0CDC4BF51188">处理NULL /非NULL数据类型</a> ”</span> 。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d8301e1088" headers="d8301e969 ">
                                    <p>SQLNumberPrecV6（）</p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d8301e1088 d8301e972 ">
                                    <p>返回数字的精度和比例。请参阅<span class="q">“ <a href="Oracle-dynamic-SQL-method-4.html#GUID-0A53AE88-FB46-41C0-B582-C2A505BC2079">提取精度和比例</a> ”</span> 。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d8301e1100" headers="d8301e969 ">
                                    <p>SQLNumberPrecV7（）</p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d8301e1100 d8301e972 ">
                                    <p><span class="italic">SQLNumberPrecV6（）的</span>变体。请参阅<span class="q">“ <a href="Oracle-dynamic-SQL-method-4.html#GUID-0A53AE88-FB46-41C0-B582-C2A505BC2079">提取精度和比例</a> ”</span> 。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d8301e1116" headers="d8301e969 ">
                                    <p>SQLVarcharGetLength（）</p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d8301e1116 d8301e972 ">
                                    <p>用于获取VARCHAR [n]的填充大小。请参阅<span class="q">“ <a href="datatypes-and-host-variables.html#GUID-621F729B-EAF3-4117-9DF5-B64E420EADE5">查找VARCHAR阵列组件的长度</a> ”</span> 。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d8301e1128" headers="d8301e969 ">
                                    <p>SQLEnvGet（）</p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d8301e1128 d8301e972 ">
                                    <p>返回给定SQLLIB运行时上下文的OCI环境句柄。请参见<span class="q">“ <a href="advanced-topics.html#GUID-62D0DA6E-EC6F-47FC-A651-F175D7E8CB64">SQLEnvGet（）</a> ”</span> 。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d8301e1140" headers="d8301e969 ">
                                    <p>SQLSvcCtxGet（）</p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d8301e1140 d8301e972 ">
                                    <p>返回数据库连接的OCI服务上下文。请参见<a href="advanced-topics.html#GUID-B5BE914E-0F89-4A98-8379-CE8A856936BE">SQLSvcCtxGet（）</a> 。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d8301e1151" headers="d8301e969 ">
                                    <p>SQLRowidGet（）</p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d8301e1151 d8301e972 ">
                                    <p>返回插入的最后一行的通用ROWID。请参见<span class="q">“ <a href="datatypes-and-host-variables.html#GUID-019031ED-BC2F-4C9F-B5EF-FEFF6707C910">SQLRowidGet（）</a> ”</span> 。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d8301e1163" headers="d8301e969 ">
                                    <p>SQLExtProcError（）</p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d8301e1163 d8301e972 ">
                                    <p>在外部C过程中发生错误时，将控制权返回给PL / SQL。请参见<span class="q">“ <a href="embedded-PL-SQL.html#GUID-A7A53E22-3218-4261-8FAF-C369BDAEB2EF">SQLExtProcError（）</a> ”</span> 。
                                    </p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <p>在前面的列表中，这些函数是线程安全的SQLLIB公共函数。在所有新应用程序中使用这些功能。有关这些线程安全公共函数（包括其旧名称）的更多信息，请参阅表<span class="q">“ <a href="advanced-topics.html#GUID-3B79020D-735A-47A9-84DA-401D86E8F712">SQLLIB公共函数的新名称</a> ”</span> 。
                     </p>
                  </div>
               </div><a id="LNPCC3057"></a><div class="props_rev_3"><a id="GUID-7083CE5B-0543-457E-8677-201876C32275" name="GUID-7083CE5B-0543-457E-8677-201876C32275"></a><h4 id="LNPCC-GUID-7083CE5B-0543-457E-8677-201876C32275" class="sect4"><span class="enumeration_section">1.8.17</span> Oracle如何支持新的对象类型？
                  </h4>
                  <div>
                     <p>有关如何在Pro * C / C ++应用程序中使用对象类型，请参阅<a href="about-Objects.html#GUID-0C106FBC-C023-4B86-817A-1867A69388F7">对象</a>和<a href="the-Object-type.html#GUID-502C3781-C88E-46B8-9EB2-9A93E0B4E7AE">对象类型转换器</a>章节。
                     </p>
                  </div>
               </div><a id="LNPCC3058"></a><div class="props_rev_3"><a id="GUID-95BDF181-A0CE-43CD-B56A-5624EB70D3CA" name="GUID-95BDF181-A0CE-43CD-B56A-5624EB70D3CA"></a><h4 id="LNPCC-GUID-95BDF181-A0CE-43CD-B56A-5624EB70D3CA" class="sect4"><span class="enumeration_section">1.8.18</span>兼容性，升级和迁移</h4>
                  <div>
                     <p>Pro * C / C ++对基于OCI的应用程序采用了类似的兼容性规则。这种兼容性受到OCI对向后兼容性的限制。</p>
                     <p>额外的“数组插入”和“数组选择”语法将有助于将DB2预编译器应用程序迁移到Pro * C / C ++应用程序。这是因为您不需要将DB2数组INSERT和SELECT语法更改为Oracle Pro * C / C ++的语法。</p>
                     <p>Pro * C / C ++支持的“隐式缓冲插入”功能可帮助您将DB2预编译器应用程序迁移到Pro * C / C ++应用程序，而无需使用Pro * C / C ++的数组语法来获得更好的性能。</p>
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>