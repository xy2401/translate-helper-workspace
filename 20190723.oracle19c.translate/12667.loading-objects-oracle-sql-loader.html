<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <meta name="abstract" content="You can use SQL*Loader to load column objects in various formats and to load object tables, REF columns, LOBs, and collections."></meta>
      <meta name="description" content="You can use SQL*Loader to load column objects in various formats and to load object tables, REF columns, LOBs, and collections."></meta>
      <title>加载对象，LOB和集合</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Utilities "></meta>
      <meta property="og:description" content="You can use SQL*Loader to load column objects in various formats and to load object tables, REF columns, LOBs, and collections."></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Utilities"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="database-utilities.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-04-23T19:07:17-07:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="2002, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96081-02"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="oracle-sql-loader-field-list-contents.html" title="Previous" type="text/html"></link>
      <link rel="next" href="oracle-sql-loader-conventional-and-direct-loads.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Database Utilities"></meta>
    <meta name="dcterms.isVersionOf" content="SUTIL"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="oracle-sql-loader-field-list-contents.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="oracle-sql-loader-conventional-and-direct-loads.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">公用事业</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="oracle-sql-loader.html" property="item" typeof="WebPage"><span property="name">使用SQL * Loader</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">加载对象，LOB和集合</li>
            </ol>
            <a id="GUID-A1828462-FD32-457C-976F-C85BA3A995DA" name="GUID-A1828462-FD32-457C-976F-C85BA3A995DA"></a><a id="SUTIL007"></a>
            
            <h2 id="SUTIL-GUID-A1828462-FD32-457C-976F-C85BA3A995DA" class="sect2"><span class="enumeration_chapter">11</span>加载对象，LOB和集合</h2>
         </header>
         <div class="ind">
            <div>
               <p>您可以使用SQL * Loader以各种格式加载列对象，并加载对象表，REF列，LOB和集合。</p>
            </div>
            <div>
               <ul class="ullinks">
                  <li class="ulchildlink"><a href="loading-objects-oracle-sql-loader.html#GUID-13D3C6B4-209C-46CA-B0CD-57FB3FA37776">加载列对象</a><br>控制文件中的列对象根据其属性进行描述。
                  </li>
                  <li class="ulchildlink"><a href="loading-objects-oracle-sql-loader.html#GUID-6BA4C022-77C8-4738-9AFD-E52252036DE7">加载对象表</a><br>加载对象表所需的控制文件语法几乎与用于加载典型关系表的语法相同。
                  </li>
                  <li class="ulchildlink"><a href="loading-objects-oracle-sql-loader.html#GUID-ABA3F185-2E5A-421D-9F1F-E175926950B8">加载REF列</a><br>SQL * Loader可以加载系统生成的OID <code class="codeph">REF</code>列，基于主键的<code class="codeph">REF</code>列和允许主键的未作用域<code class="codeph">REF</code>列。
                  </li>
                  <li class="ulchildlink"><a href="loading-objects-oracle-sql-loader.html#GUID-3637F462-436A-4F6B-B243-03FB3177CA80">加载LOB</a><br>该部分描述了加载LOB。
                  </li>
                  <li class="ulchildlink"><a href="loading-objects-oracle-sql-loader.html#GUID-CA3B8A38-0559-4E34-A8FB-B4627A2AAF40">加载BFILE列</a><br><code class="codeph">BFILE</code>数据类型将非结构化二进制数据存储在数据库外的操作系统文件中。
                  </li>
                  <li class="ulchildlink"><a href="loading-objects-oracle-sql-loader.html#GUID-B769A8EC-48F4-4E8E-8896-2D7A5463112C">加载集合（嵌套表和VARRAY）</a><br>与LOB一样，可以从主数据文件（数据内联）或辅助数据文件（数据脱机）加载集合。
                  </li>
                  <li class="ulchildlink"><a href="loading-objects-oracle-sql-loader.html#GUID-9474C838-E6BF-4D4D-9EDF-56DBE0219737">动态与静态SDF规格</a><br>您可以静态指定SDF（指定文件的实际名称）或动态指定（使用<code class="codeph">FILLER</code>字段作为文件名源）。
                  </li>
                  <li class="ulchildlink"><a href="loading-objects-oracle-sql-loader.html#GUID-2D079012-0733-4172-AD8B-E97690CDFA34">从子表中单独加载父表</a><br>加载包含嵌套表列的表时，可以从子表中单独加载父表。
                  </li>
               </ul>
               <div class="familylinks">
                  <div class="parentlink">
                     <p><strong>父主题：</strong> <a href="oracle-sql-loader.html#GUID-8D037494-07FA-4226-B507-E1B2ED10C144">SQL * Loader</a></p>
                  </div>
               </div>
            </div>
            <a id="SUTIL1247"></a><div class="props_rev_3"><a id="GUID-13D3C6B4-209C-46CA-B0CD-57FB3FA37776" name="GUID-13D3C6B4-209C-46CA-B0CD-57FB3FA37776"></a><h3 id="SUTIL-GUID-13D3C6B4-209C-46CA-B0CD-57FB3FA37776" class="sect3"><span class="enumeration_section">11.1</span>加载列对象</h3>
               <div>
                  <p>控制文件中的列对象根据其属性进行描述。</p>
                  <p>如果列对象所基于的对象类型被声明为非最终对象，则可以根据从基础对象类型派生的任何子类型的属性（包括派生和声明的属性）来描述控制文件中的列对象。在数据文件中，对应于列对象的每个属性的数据在与对应于简单关系列的数据字段类似的数据字段中。</p>
                  <div class="infoboxnote" id="GUID-13D3C6B4-209C-46CA-B0CD-57FB3FA37776__GUID-E2FBFA07-7E3E-40FD-9E52-C87001DF8292">
                     <p class="notep1">注意：</p>
                     <p>通过SQL * Loader支持复杂数据类型（如列对象），可能会出现控制文件中可能存在两个相同的字段名称，一个对应于列，另一个对应于列对象的属性。某些子句可以引用字段（例如， <code class="codeph">WHEN</code> ， <code class="codeph">NULLIF</code> ， <code class="codeph">DEFAULTIF</code> ， <code class="codeph">SID</code> ， <code class="codeph">OID</code> ， <code class="codeph">REF</code> ， <code class="codeph">BFILE</code>等），如果控制文件中存在相同名称的字段，则会导致命名冲突。
                     </p>
                     <p>因此，如果使用引用字段的子句，则必须指定全名。例如，如果字段<code class="codeph">fld1</code>指定为<code class="codeph">COLUMN</code> <code class="codeph">OBJECT</code>并且它包含字段<code class="codeph">fld2</code> ，那么当您在诸如<code class="codeph">NULLIF</code>的子句中指定<code class="codeph">fld2</code>时，必须使用完整字段名称<code class="codeph">fld1.fld2</code> 。
                     </p>
                  </div>
                  <p>以下部分显示了加载列对象的示例：</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="loading-objects-oracle-sql-loader.html#GUID-CB95C7C2-02B2-4E3C-80D0-26098ECE3B22">以流记录格式加载列对象</a><br>您可以以流记录格式加载列对象。
                     </li>
                     <li class="ulchildlink"><a href="loading-objects-oracle-sql-loader.html#GUID-6A23F378-18B9-4F60-848E-C367A9978166">以可变记录格式加载列对象</a><br>您可以以可变记录格式加载列对象。
                     </li>
                     <li class="ulchildlink"><a href="loading-objects-oracle-sql-loader.html#GUID-0F36C8CB-3434-42F0-9C38-36278D0B4E6D">加载嵌套列对象</a><br>您可以加载嵌套的列对象。
                     </li>
                     <li class="ulchildlink"><a href="loading-objects-oracle-sql-loader.html#GUID-1DAF5614-EDCB-44AB-AEEC-DFFB2D678270">使用派生子类型加载列对象</a><br>您可以使用派生的子类型加载列对象。
                     </li>
                     <li class="ulchildlink"><a href="loading-objects-oracle-sql-loader.html#GUID-C2940706-C809-4E42-886B-F13D35E54A43">指定对象的空值</a><br>您可以为对象指定空值。
                     </li>
                     <li class="ulchildlink"><a href="loading-objects-oracle-sql-loader.html#GUID-BB33C1CF-4EF5-40C8-8A2B-2A1DB9A213CB">使用用户定义的构造函数加载列对象</a><br>您可以使用用户定义的构造函数加载列对象。
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="loading-objects-oracle-sql-loader.html#GUID-A1828462-FD32-457C-976F-C85BA3A995DA" title="您可以使用SQL * Loader以各种格式加载列对象，并加载对象表，REF列，LOB和集合。">加载对象，LOB和集合</a></p>
                     </div>
                  </div>
               </div>
               <a id="SUTIL3356"></a><a id="SUTIL3355"></a><a id="SUTIL1248"></a><div class="props_rev_3"><a id="GUID-CB95C7C2-02B2-4E3C-80D0-26098ECE3B22" name="GUID-CB95C7C2-02B2-4E3C-80D0-26098ECE3B22"></a><h4 id="SUTIL-GUID-CB95C7C2-02B2-4E3C-80D0-26098ECE3B22" class="sect4"><span class="enumeration_section">11.1.1</span>以流记录格式加载列对象</h4>
                  <div>
                     <p>您可以以流记录格式加载列对象。</p>
                     <div class="section">
                        <p><a href="loading-objects-oracle-sql-loader.html#GUID-CB95C7C2-02B2-4E3C-80D0-26098ECE3B22__I1006483">例11-1</a>显示了数据处于预定大小字段的情况。换行符标志着物理记录的结束。您还可以使用操作系统文件处理子句（ <code class="codeph">os_file_proc_clause</code> ）中的自定义记录分隔符标记物理记录的结尾。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-CB95C7C2-02B2-4E3C-80D0-26098ECE3B22__I1006483">
                        <p class="titleinexample">示例11-1以流记录格式加载列对象</p>
                        <p>控制文件内容</p><pre class="oac_no_warn" dir="ltr">LOAD DATA INFILE'ample.dat'INTO TABLE departments（dept_no POSITION（01:03）CHAR，dept_name POSITION（05:15）CHAR， <span class="bold">1</span> dept_mgr COLUMN OBJECT（名称位置（17:33）CHAR，年龄位置（35:37） ）INTEGER EXTERNAL，emp_id POSITION（40:46）INTEGER EXTERNAL））</pre><p>数据文件（sample.dat）</p><pre class="oac_no_warn" dir="ltr">101数学Johny Quest 30 1024 237物理阿尔伯特爱因斯坦65 0000</pre><div class="infoboxnote" id="GUID-CB95C7C2-02B2-4E3C-80D0-26098ECE3B22__GUID-8C044CFD-5B1C-4E33-A5F2-890D8EC8B538">
                           <p class="notep1">注意：</p>
                           <p>示例左侧的粗体标注对应于以下注释：</p>
                           <ol>
                              <li>
                                 <p>可以递归地应用此类型的列对象规范来描述嵌套的列对象。</p>
                              </li>
                           </ol>
                        </div>
                     </div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="loading-objects-oracle-sql-loader.html#GUID-13D3C6B4-209C-46CA-B0CD-57FB3FA37776" title="控制文件中的列对象根据其属性进行描述。">加载列对象</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="SUTIL3358"></a><a id="SUTIL3357"></a><a id="SUTIL1249"></a><div class="props_rev_3"><a id="GUID-6A23F378-18B9-4F60-848E-C367A9978166" name="GUID-6A23F378-18B9-4F60-848E-C367A9978166"></a><h4 id="SUTIL-GUID-6A23F378-18B9-4F60-848E-C367A9978166" class="sect4"><span class="enumeration_section">11.1.2</span>以可变记录格式加载列对象</h4>
                  <div>
                     <p>您可以以可变记录格式加载列对象。</p>
                     <div class="section">
                        <p><a href="loading-objects-oracle-sql-loader.html#GUID-6A23F378-18B9-4F60-848E-C367A9978166__I1011524">例11-2</a>显示了数据在分隔字段中的情况。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-6A23F378-18B9-4F60-848E-C367A9978166__I1011524">
                        <p class="titleinexample">示例11-2以可变记录格式加载列对象</p>
                        <p>控制文件内容</p><pre class="oac_no_warn" dir="ltr">LOAD DATA <span class="bold">1</span> INFILE'meample.dat'“var 6”INTO TABLE部门字段由'，''选择性地包围''' <span class="bold">2</span> （dept_no dept_name，dept_mgr COLUMN OBJECT（名称CHAR（30），年龄INTEGER EXTERNAL（5）， emp_id INTEGER EXTERNAL（5）））</pre><p>数据文件（sample.dat）</p><pre class="oac_no_warn" dir="ltr"><span class="bold">3</span> <span class="italic">000034</span> 101，Mathematics，Johny Q.， <span class="italic">30,1024,000039237</span> ，Physics，“Albert Einstein”，65,0000，</pre><div class="infoboxnote" id="GUID-6A23F378-18B9-4F60-848E-C367A9978166__GUID-84AB0DEF-B2CC-4EE9-A998-47D7B90616D0">
                           <p class="notep1">注意：</p>
                           <p>示例左侧的粗体标注对应于以下注释：</p>
                           <ol>
                              <li>
                                 <p><code class="codeph">"var"</code>字符串包括每个记录开头的长度字段中的字节数（在本例中，数字为6）。如果未指定任何值，则默认值为5个字节。变量记录的最大大小为2 ^ 32-1。指定较大的值将导致错误。
                                 </p>
                              </li>
                              <li>
                                 <p>虽然没有给出位置规范，但是一般语法保持不变（列对象的名称后跟括在括号中的属性列表）。另请注意，省略的类型规范默认为长度为255的<code class="codeph">CHAR</code> 。
                                 </p>
                              </li>
                              <li>
                                 <p>前6个字节（斜体）指定即将到来的记录的长度。这些长度规范包括换行符，由于<code class="codeph">emp_id</code>字段之后的终结符而被忽略。
                                 </p>
                              </li>
                           </ol>
                        </div>
                     </div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="loading-objects-oracle-sql-loader.html#GUID-13D3C6B4-209C-46CA-B0CD-57FB3FA37776" title="控制文件中的列对象根据其属性进行描述。">加载列对象</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="SUTIL3360"></a><a id="SUTIL3359"></a><a id="SUTIL1250"></a><div class="props_rev_3"><a id="GUID-0F36C8CB-3434-42F0-9C38-36278D0B4E6D" name="GUID-0F36C8CB-3434-42F0-9C38-36278D0B4E6D"></a><h4 id="SUTIL-GUID-0F36C8CB-3434-42F0-9C38-36278D0B4E6D" class="sect4"><span class="enumeration_section">11.1.3</span>加载嵌套列对象</h4>
                  <div>
                     <p>您可以加载嵌套的列对象。</p>
                     <div class="section">
                        <p><a href="loading-objects-oracle-sql-loader.html#GUID-0F36C8CB-3434-42F0-9C38-36278D0B4E6D__I1006552">例11-3</a>显示了一个描述嵌套列对象的控制文件（一个列对象嵌套在另一个列对象中）。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-0F36C8CB-3434-42F0-9C38-36278D0B4E6D__I1006552">
                        <p class="titleinexample">示例11-3加载嵌套列对象</p>
                        <p>控制文件内容</p><pre class="oac_no_warn" dir="ltr">LOAD DATA INFILE`sample.dat'INTO TABLE departments_v2 FIELDS TERMINATED BY'，''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''' 3），emp_id INTEGER EXTERNAL（7）， <span class="bold">1</span> em_contact COLUMN OBJECT（名称CHAR（30），phone_num CHAR（20））））</pre><p>数据文件（sample.dat）</p><pre class="oac_no_warn" dir="ltr">101，Mathematics，Johny Q.，30,1024，“Barbie”，650-251-0010,237，Physics，“Albert Einstein”，65,0000，Wife Einstein，654-3210，</pre><div class="infoboxnote" id="GUID-0F36C8CB-3434-42F0-9C38-36278D0B4E6D__GUID-B0236F5A-4D48-45FB-BE77-68B077C39CEF">
                           <p class="notep1">注意：</p>
                           <p>示例左侧的粗体标注对应于以下注释：</p>
                           <ol>
                              <li>
                                 <p>此条目指定嵌套在列对象中的列对象。</p>
                              </li>
                           </ol>
                        </div>
                     </div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="loading-objects-oracle-sql-loader.html#GUID-13D3C6B4-209C-46CA-B0CD-57FB3FA37776" title="控制文件中的列对象根据其属性进行描述。">加载列对象</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="SUTIL3362"></a><a id="SUTIL3361"></a><a id="SUTIL1251"></a><div class="props_rev_3"><a id="GUID-1DAF5614-EDCB-44AB-AEEC-DFFB2D678270" name="GUID-1DAF5614-EDCB-44AB-AEEC-DFFB2D678270"></a><h4 id="SUTIL-GUID-1DAF5614-EDCB-44AB-AEEC-DFFB2D678270" class="sect4"><span class="enumeration_section">11.1.4</span>使用派生子类型加载列对象</h4>
                  <div>
                     <p>您可以使用派生的子类型加载列对象。</p>
                     <div class="section">
                        <p><a href="loading-objects-oracle-sql-loader.html#GUID-1DAF5614-EDCB-44AB-AEEC-DFFB2D678270__I1008205">例11-4</a>显示了一个案例，其中扩展了非最终基础对象类型以创建新的派生子类型。尽管表定义中的列对象声明为基础对象类型，但SQL * Loader允许将任何子类型加载到列对象中，前提是子类型是从基础对象类型派生的。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-1DAF5614-EDCB-44AB-AEEC-DFFB2D678270__I1008205">
                        <p class="titleinexample">示例11-4使用子类型加载列对象</p>
                        <p>对象类型定义</p><pre class="oac_no_warn" dir="ltr">CREATE TYPE person_type AS OBJECT（名称VARCHAR（30），ssn NUMBER（9））不是最终的; CREATE TYPE employee_type UNDER person_type（empid NUMBER（5））; CREATE TABLE人员（deptno NUMBER（3），deptname VARCHAR（30），person person_type）;</pre><p>控制文件内容</p><pre class="oac_no_warn" dir="ltr">LOAD DATA INFILE'ample.dat'INTO TABLE人员字段终止于'，'选择性封装'''（deptno INTEGER EXTERNAL（3），deptname CHAR， <span class="bold">1</span>人COLUMN OBJECT TREAT AS employee_type（姓名CHAR，ssn INTEGER EXTERNAL（9） ）， <span class="bold">2</span> empid INTEGER EXTERNAL（5）））</pre><p>数据文件（sample.dat）</p><pre class="oac_no_warn" dir="ltr">101，Mathematics，Johny Q.，301189453,10249,237，Physics，“Albert Einstein”，128606590,10030，</pre><div class="infoboxnote" id="GUID-1DAF5614-EDCB-44AB-AEEC-DFFB2D678270__GUID-F3D7F6D8-32B3-4C9C-908D-0AFD71F0BAB4">
                           <p class="notep1">注意：</p>
                           <p>示例左侧的粗体标注对应于以下注释：</p>
                           <ol>
                              <li>
                                 <p><code class="codeph">TREAT</code> <code class="codeph">AS</code>子句指示SQL * Loader应该将列对象<code class="codeph">person</code>视为声明为派生类型<code class="codeph">employee_type</code> ，而不是其实际声明的类型<code class="codeph">person_type</code> 。
                                 </p>
                              </li>
                              <li>
                                 <p>此处允许使用<code class="codeph">empid</code>属性，因为它是<code class="codeph">employee_type</code>的属性。如果尚未指定<code class="codeph">TREAT</code> <code class="codeph">AS</code>子句，则此属性将导致错误，因为它不是列声明类型的属性。
                                 </p>
                              </li>
                           </ol>
                        </div>
                     </div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="loading-objects-oracle-sql-loader.html#GUID-13D3C6B4-209C-46CA-B0CD-57FB3FA37776" title="控制文件中的列对象根据其属性进行描述。">加载列对象</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="SUTIL1252"></a><div class="props_rev_3"><a id="GUID-C2940706-C809-4E42-886B-F13D35E54A43" name="GUID-C2940706-C809-4E42-886B-F13D35E54A43"></a><h4 id="SUTIL-GUID-C2940706-C809-4E42-886B-F13D35E54A43" class="sect4"><span class="enumeration_section">11.1.5</span>指定对象的空值</h4>
                  <div>
                     <p>您可以为对象指定空值。</p>
                     <div class="section">
                        <p>为非标量数据类型指定空值比标量数据类型稍微复杂一些。对象可以使其属性的子集为null，它可以使其所有属性为null（属性为null的对象），或者它本身可以为null（原子空对象）。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="loading-objects-oracle-sql-loader.html#GUID-D2815897-D5DA-44EB-82DD-D5BC5817F357">指定属性空值</a><br>您可以指定属性null。
                        </li>
                        <li class="ulchildlink"><a href="loading-objects-oracle-sql-loader.html#GUID-48C45979-0030-4DCC-8591-BCD8D2654BB3">指定原子空间</a><br>您可以指定原子空值。
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="loading-objects-oracle-sql-loader.html#GUID-13D3C6B4-209C-46CA-B0CD-57FB3FA37776" title="控制文件中的列对象根据其属性进行描述。">加载列对象</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="SUTIL3364"></a><a id="SUTIL3363"></a><a id="SUTIL1253"></a><div class="props_rev_3"><a id="GUID-D2815897-D5DA-44EB-82DD-D5BC5817F357" name="GUID-D2815897-D5DA-44EB-82DD-D5BC5817F357"></a><h5 id="SUTIL-GUID-D2815897-D5DA-44EB-82DD-D5BC5817F357" class="sect5"><span class="enumeration_section">11.1.5.1</span>指定属性空值</h5>
                     <div>
                        <p>您可以指定属性null。</p>
                        <div class="section">
                           <p>在与列对象对应的字段中，可以使用<code class="codeph">NULLIF</code>子句指定应将特定属性初始化为<code class="codeph">NULL</code>的字段条件。 <a href="loading-objects-oracle-sql-loader.html#GUID-D2815897-D5DA-44EB-82DD-D5BC5817F357__I1006590">例11-5</a>说明了这一点。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-D2815897-D5DA-44EB-82DD-D5BC5817F357__I1006590">
                           <p class="titleinexample">示例11-5使用NULLIF子句指定属性空值</p>
                           <p>控制文件内容</p><pre class="oac_no_warn" dir="ltr">LOAD DATA INFILE'ample.dat'INTO TABLE departments（dept_no POSITION（01:03）CHAR，dept_name POSITION（05:15）CHAR NULLIF dept_name = BLANKS，dept_mgr COLUMN OBJECT <span class="bold">1</span> （name POSITION（17:33）CHAR NULLIF dept_mgr。 name = BLANKS， <span class="bold">1</span> age POSITION（35:37）INTEGER EXTERNAL NULLIF dept_mgr.age = BLANKS， <span class="bold">1</span> emp_id POSITION（40:46）INTEGER EXTERNAL NULLIF dept_mgr.empid = BLANKS））</pre><p>数据文件（sample.dat）</p><pre class="oac_no_warn" dir="ltr"><span class="bold">2</span> 101 Johny Quest 1024 237 Physics Albert Einstein 65 0000</pre><div class="infoboxnote" id="GUID-D2815897-D5DA-44EB-82DD-D5BC5817F357__GUID-9E838423-5CA3-4238-881B-8E4BD49EF0F0">
                              <p class="notep1">注意：</p>
                              <p>示例左侧的粗体标注对应于以下注释：</p>
                              <ol>
                                 <li>
                                    <p>与每个属性对应的<code class="codeph">NULLIF</code>子句指出属性值应为<code class="codeph">NULL</code></p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">dept_mgr</code>值的age属性为null。<code class="codeph">dept_name</code>值也为null。
                                    </p>
                                 </li>
                              </ol>
                           </div>
                        </div>
                        <!-- class="example" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="loading-objects-oracle-sql-loader.html#GUID-C2940706-C809-4E42-886B-F13D35E54A43" title="您可以为对象指定空值。">指定对象的空值</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="SUTIL3366"></a><a id="SUTIL3365"></a><a id="SUTIL1254"></a><div class="props_rev_3"><a id="GUID-48C45979-0030-4DCC-8591-BCD8D2654BB3" name="GUID-48C45979-0030-4DCC-8591-BCD8D2654BB3"></a><h5 id="SUTIL-GUID-48C45979-0030-4DCC-8591-BCD8D2654BB3" class="sect5"><span class="enumeration_section">11.1.5.2</span>指定原子空值</h5>
                     <div>
                        <p>您可以指定原子空值。</p>
                        <div class="section">
                           <p>要在控制文件中指定特定对象应采用空值（原子空值）的条件，必须使用基于任何映射字段的逻辑组合的<code class="codeph">NULLIF</code>子句跟随该对象的名称（例如，在<a href="loading-objects-oracle-sql-loader.html#GUID-D2815897-D5DA-44EB-82DD-D5BC5817F357__I1006590">示例中）在图11-5中</a> ，命名的映射字段将是<code class="codeph">dept_no</code> ， <code class="codeph">dept_name</code> ， <code class="codeph">name</code> ， <code class="codeph">age</code> ， <code class="codeph">emp_id</code> ，但是<code class="codeph">dept_mgr</code>将不是命名的映射字段，因为它不对应（未映射）数据文件中的任何字段）。
                           </p>
                           <p>尽管前面的内容是可行的，但是当对象应该采用null值的条件<span class="italic">独立于任何映射字段</span>时，它并不理想<span class="italic">。</span> 在这种情况下，您可以使用填充字段。
                           </p>
                           <p>您可以将填充字段映射到数据文件中的字段（指示特定对象是否在原子上为空），并在特定对象的<code class="codeph">NULLIF</code>子句的字段条件中使用填充字段。这在<a href="loading-objects-oracle-sql-loader.html#GUID-48C45979-0030-4DCC-8591-BCD8D2654BB3__I1006626">例11-6中显示</a> 。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-48C45979-0030-4DCC-8591-BCD8D2654BB3__I1006626">
                           <p class="titleinexample">示例11-6使用填充字段加载数据</p>
                           <p>控制文件内容</p><pre class="oac_no_warn" dir="ltr">LOAD DATA INFILE'meample.dat'INTO TABLE departments_v2 FIELDS TERMINATED BY'，'选项包含'''（dept_no CHAR（5），dept_name CHAR（30）， <span class="bold">1</span> is_null FILLER CHAR， <span class="bold">2</span> dept_mgr COLUMN OBJECT NULLIF is_null = BLANKS（ name CHAR（30）NULLIF dept_mgr.name = BLANKS，age INTEGER EXTERNAL（3）NULLIF dept_mgr.age = BLANKS，emp_id INTEGER EXTERNAL（7）NULLIF dept_mgr.emp_id = BLANKS，em_contact COLUMN OBJECT NULLIF is_null2 = BLANKS（name CHAR（30） ）NULLIF dept_mgr.em_contact.name = BLANKS，phone_num CHAR（20）NULLIF dept_mgr.em_contact.phone_num = BLANKS））， <span class="bold">1</span> is_null2 FILLER CHAR）</pre><p>数据文件（sample.dat）</p><pre class="oac_no_warn" dir="ltr">101，Mathematics，n，Johny Q。,, 1024，“Barbie”，608-251-0010 ,, 237，Physics，“Albert Einstein”，65,0000，650-654-3210，n，</pre><div class="infoboxnote" id="GUID-48C45979-0030-4DCC-8591-BCD8D2654BB3__GUID-2910EC31-5FC5-497B-9541-EE8BBDA98686">
                              <p class="notep1">注意：</p>
                              <p>示例左侧的粗体标注对应于以下注释：</p>
                              <ol>
                                 <li>
                                    <p>填充字段（映射的数据文件;没有对应的列）是<code class="codeph">CHAR</code>类型（因为它是分隔字段， <code class="codeph">CHAR</code>默认为<code class="codeph">CHAR(255)</code> ）。请注意， <code class="codeph">NULLIF</code>子句不适用于填充字段本身</p>
                                 </li>
                                 <li>
                                    <p>如果<code class="codeph">is_null</code>字段为空，则获取null（atomic null）的值。
                                    </p>
                                 </li>
                              </ol>
                           </div>
                        </div>
                        <!-- class="example" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="loading-objects-oracle-sql-loader.html#GUID-C2940706-C809-4E42-886B-F13D35E54A43" title="您可以为对象指定空值。">指定对象的空值</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="SUTIL3368"></a><a id="SUTIL3371"></a><a id="SUTIL3367"></a><a id="SUTIL3369"></a><a id="SUTIL3370"></a><a id="SUTIL1255"></a><div class="props_rev_3"><a id="GUID-BB33C1CF-4EF5-40C8-8A2B-2A1DB9A213CB" name="GUID-BB33C1CF-4EF5-40C8-8A2B-2A1DB9A213CB"></a><h4 id="SUTIL-GUID-BB33C1CF-4EF5-40C8-8A2B-2A1DB9A213CB" class="sect4"><span class="enumeration_section">11.1.6</span>使用用户定义的构造函数加载列对象</h4>
                  <div>
                     <p>您可以使用用户定义的构造函数加载列对象。</p>
                     <div class="section">
                        <p>Oracle数据库自动为每种对象类型提供默认构造函数。此构造函数要求在调用构造函数时将该类型的所有属性指定为参数。创建对象的新实例时，其属性将采用参数列表中的相应值。此构造函数称为属性值构造函数。加载列对象时，SQL * Loader默认使用属性值构造函数。</p>
                        <p>可以通过创建一个或多个用户定义的构造函数来覆盖属性值构造函数。创建用户定义的构造函数时，必须提供一个类型体，只要创建对象的新实例，该体就会执行用户定义的逻辑。用户定义的构造函数可以具有与属性值构造函数相同的参数列表，但其类型体实现的逻辑不同。</p>
                        <p>当用户定义的构造函数的参数列表与属性值构造函数的参数列表匹配时，传统路径和直接路径SQL * Loader之间的行为存在差异。常规路径模式导致对用户定义的构造函数的调用。直接路径模式导致对属性值构造函数的调用。<a href="loading-objects-oracle-sql-loader.html#GUID-BB33C1CF-4EF5-40C8-8A2B-2A1DB9A213CB__I1009648">例11-7</a>说明了这种差异。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-BB33C1CF-4EF5-40C8-8A2B-2A1DB9A213CB__I1009648">
                        <p class="titleinexample">示例11-7使用匹配的构造函数加载列对象</p>
                        <p>对象类型定义</p><pre class="oac_no_warn" dir="ltr">CREATE TYPE person_type AS OBJECT（名称VARCHAR（30），ssn NUMBER（9））不是最终的; CREATE TYPE employee_type UNDER person_type（empid NUMBER（5）， - 用户定义的构造函数，看起来像属性值构造函数CONSTRUCTOR FUNCTION employee_type（名称VARCHAR2，ssn NUMBER，empid NUMBER）RETURN SELF AS RESULT）; CREATE TYPE BODY employee_type AS CONSTRUCTOR FUNCTION employee_type（名称VARCHAR2，ssn NUMBER，empid NUMBER）RETURN SELF AS RESULT AS  - 用户定义的构造函数确保name属性为大写。BEGIN SELF.name：= UPPER（姓名）; SELF.ssn：= ssn; SELF.empid：= empid;返回;结束; CREATE TABLE人员（deptno NUMBER（3），deptname VARCHAR（30），employee employee_type）;</pre><p>控制文件内容</p><pre class="oac_no_warn" dir="ltr">负载数据传输*替换为表格人员字段，由'''选择性地封装'（'deptno INTEGER EXTERNAL（3），deptname CHAR，员工COLUMN OBJECT（名称CHAR，ssn INTEGER EXTERNAL（9），empid INTEGER EXTERNAL（5） ）））BEGINDATA <span class="bold">1</span> 101，Mathematics，Johny Q.，301189453,10249,237，Physics，“Albert Einstein”，128606590,10030，</pre><div class="infoboxnote" id="GUID-BB33C1CF-4EF5-40C8-8A2B-2A1DB9A213CB__GUID-443036F0-BC42-46A4-BA03-67BF5AFD39D2">
                           <p class="notep1">注意：</p>
                           <p>示例左侧的粗体标注对应于以下注释：</p>
                           <ol>
                              <li>
                                 <p>当此控制文件以常规路径模式运行时，名称字段<code class="codeph">Johny</code> <code class="codeph">Q.</code>和<code class="codeph">Albert</code> <code class="codeph">Einstein</code>都以大写形式加载。这是因为在此模式下调用了用户定义的构造函数。相反，当此控制文件以直接路径模式运行时，名称字段的加载方式与输入数据中显示的完全相同。这是因为在此模式下调用属性值构造函数。
                                 </p>
                              </li>
                           </ol>
                           <p>可以创建一个用户定义的构造函数，其参数列表与属性值构造函数的参数列表不匹配。在这种情况下，传统路径模式和直接路径模式都将导致对属性值构造函数的调用。考虑<a href="loading-objects-oracle-sql-loader.html#GUID-BB33C1CF-4EF5-40C8-8A2B-2A1DB9A213CB__I1009642">例11-8中</a>的定义。
                           </p>
                        </div>
                     </div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-BB33C1CF-4EF5-40C8-8A2B-2A1DB9A213CB__I1009642">
                        <p class="titleinexample">示例11-8使用不匹配的构造函数加载列对象</p>
                        <p>对象类型定义</p><pre class="oac_no_warn" dir="ltr">CREATE SEQUENCE employee_ids以1增加1000; CREATE TYPE person_type AS OBJECT（名称VARCHAR（30），ssn NUMBER（9））不是最终的; CREATE TYPE employee_type UNDER person_type（empid NUMBER（5）， - 用户定义的构造函数，看起来不像属性值 - 构造函数CONSTRUCTOR FUNCTION employee_type（name VARCHAR2，ssn NUMBER）RETURN SELF AS RESULT）; CREATE TYPE BODY employee_type AS CONSTRUCTOR FUNCTION employee_type（name VARCHAR2，ssn NUMBER）RETURN SELF AS RESULT AS  - 此用户定义的构造函数确保name属性为 - 小写，并根据序列分配员工标识符。nextid NUMBER; stmt VARCHAR2（64）; BEGIN stmt：='SELECT employee_ids.nextval FROM DUAL'; EXECUTE IMMEDIATE stmt INTO nextid; SELF.name：= LOWER（名字）; SELF.ssn：= ssn; SELF.empid：= nextid;返回;结束; CREATE TABLE人员（deptno NUMBER（3），deptname VARCHAR（30），employee employee_type）;</pre><p>如果将<a href="loading-objects-oracle-sql-loader.html#GUID-BB33C1CF-4EF5-40C8-8A2B-2A1DB9A213CB__I1009648">示例11-7中</a>描述的控制文件与这些定义一起使用，则名称字段的加载方式与输入数据中显示的完全相同（即大小写混合）。这是因为在常规和直接路径模式下都会调用属性值构造函数。
                        </p>
                        <p>通过在SQL表达式中显式引用用户定义的构造函数，仍然可以使用常规路径模式加载此表。<a href="loading-objects-oracle-sql-loader.html#GUID-BB33C1CF-4EF5-40C8-8A2B-2A1DB9A213CB__I1009753">例11-9</a>显示了如何做到这一点。
                        </p>
                     </div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-BB33C1CF-4EF5-40C8-8A2B-2A1DB9A213CB__I1009753">
                        <p class="titleinexample">示例11-9在构造函数不匹配时使用SQL加载列对象</p>
                        <p>控制文件内容</p><pre class="oac_no_warn" dir="ltr">LOAD DATA INFILE *替换为表格人员字段，由'''（由deptno INTEGER EXTERNAL（3），deptname CHAR，名字BOUNDFILLER CHAR，ssn BOUNDFILLER INTEGER EXTERNAL（9）， <span class="bold">1</span>名员工EXPRESSION“employee_type（： NAME，：SSN）“）BEGINDATA <span class="bold">1</span> 101，Mathematics，Johny Q.，301189453,237，Physics，”Albert Einstein“，128606590，</pre><div class="infoboxnote" id="GUID-BB33C1CF-4EF5-40C8-8A2B-2A1DB9A213CB__GUID-33CE2A54-788D-4ADC-ABDB-D12184DC4CBF">
                           <p class="notep1">注意：</p>
                           <p>示例左侧的粗体标注对应于以下注释：</p>
                           <ol>
                              <li>
                                 <p>当此控制文件以常规路径模式运行时，名称字段<code class="codeph">Johny</code> <code class="codeph">Q.</code>和<code class="codeph">Albert</code> <code class="codeph">Einstein</code>都以大写形式加载。这是因为在此模式下调用了用户定义的构造函数。相反，当此控制文件以直接路径模式运行时，名称字段的加载方式与输入数据中显示的完全相同。这是因为在此模式下调用属性值构造函数。
                                 </p>
                              </li>
                           </ol>
                        </div>
                     </div>
                     <!-- class="example" -->
                     <div class="section">
                        <p>如果在直接路径模式下使用<a href="loading-objects-oracle-sql-loader.html#GUID-BB33C1CF-4EF5-40C8-8A2B-2A1DB9A213CB__I1009753">示例11-9中</a>的控制文件，则报告以下错误：</p><pre class="oac_no_warn" dir="ltr">SQL * Loader-951：调用一次/加载初始化时出错ORA-26052：EMPLOYEE列上的SQL表达式不支持类型121。</pre></div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="loading-objects-oracle-sql-loader.html#GUID-13D3C6B4-209C-46CA-B0CD-57FB3FA37776" title="控制文件中的列对象根据其属性进行描述。">加载列对象</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div><a id="SUTIL3374"></a><a id="SUTIL3372"></a><a id="SUTIL3373"></a><a id="SUTIL1256"></a><div class="props_rev_3"><a id="GUID-6BA4C022-77C8-4738-9AFD-E52252036DE7" name="GUID-6BA4C022-77C8-4738-9AFD-E52252036DE7"></a><h3 id="SUTIL-GUID-6BA4C022-77C8-4738-9AFD-E52252036DE7" class="sect3"><span class="enumeration_section">11.2</span>加载对象表</h3>
               <div>
                  <p>加载对象表所需的控制文件语法几乎与用于加载典型关系表的语法相同。</p>
                  <div class="section">
                     <p><a href="loading-objects-oracle-sql-loader.html#GUID-6BA4C022-77C8-4738-9AFD-E52252036DE7__I1006678">例11-10</a>演示了如何使用基于主键的对象标识符（OID）加载对象表。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-6BA4C022-77C8-4738-9AFD-E52252036DE7__I1006678">
                     <p class="titleinexample">示例11-10使用主键OID加载对象表</p>
                     <p>控制文件内容</p><pre class="oac_no_warn" dir="ltr">LOAD DATA INFILE'meample.dat'DISCARDFILE'sample.dsc'BADFILE'sample.bad'REPLACE INTO TABLE员工字段终止于'，'选项封装'''（名称CHAR（30）NULLIF名称= BLANKS，年龄INTEGER EXTERNAL （3）NULLIF年龄= BLANKS，emp_id INTEGER EXTERNAL（5））</pre><p>数据文件（sample.dat）</p><pre class="oac_no_warn" dir="ltr">Johny Quest，18,007，Speed Racer，16,000，</pre><p>通过仅查看前面的控制文件，您可能无法确定正在加载的表是具有系统生成的OID的对象表，具有基于主键的OID的对象表还是关系表。</p>
                     <p>您可能希望加载已包含系统生成的OID的数据，并指定不应生成新的OID，而应使用数据文件中的现有OID。为此，您将遵循带有<code class="codeph">OID</code>子句的<code class="codeph">INTO</code> <code class="codeph">TABLE</code>子句：</p><pre class="oac_no_warn" dir="ltr">OID（ <span class="italic">字段名称</span> ）</pre><p>在此子句中， <span class="italic"><code class="codeph">fieldname</code></span>是字段规范列表中的一个字段（通常是填充字段）的名称，该字段映射到包含系统生成的OID的数据字段。SQL * Loader假定提供的OID格式正确，并且它们保留了OID全局唯一性。因此，为了确保唯一性，您应该使用Oracle OID生成器生成要加载的OID。
                     </p>
                     <p><code class="codeph">OID</code>子句只能用于系统生成的OID，而不能用于基于主键的OID。
                     </p>
                     <p><a href="loading-objects-oracle-sql-loader.html#GUID-6BA4C022-77C8-4738-9AFD-E52252036DE7__I1006710">例11-11</a>演示了如何使用行对象加载系统生成的OID。
                     </p>
                  </div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-6BA4C022-77C8-4738-9AFD-E52252036DE7__I1006710">
                     <p class="titleinexample">示例11-11加载OID</p>
                     <p>控制文件内容</p><pre class="oac_no_warn" dir="ltr">LOAD DATA INFILE'ample.dat'INTO TABLE employees_v2 <span class="bold">1</span> OID（s_oid）FIELDS终止于'，'选项封装'''（名称CHAR（30）NULLIF名称= BLANKS，年龄INTEGER EXTERNAL（3）NULLIF年龄= BLANKS， emp_id INTEGER EXTERNAL（5）， <span class="bold">2</span> s_oid FILLER CHAR（32））</pre><p>数据文件（sample.dat）</p><pre class="oac_no_warn" dir="ltr"><span class="bold">3</span> Johny Quest，18,007,21E978406D3E41FCE03400400B403BC3，Speed Racer，16,000,21E978406D4441FCE03400400B403BC3，</pre><div class="infoboxnote" id="GUID-6BA4C022-77C8-4738-9AFD-E52252036DE7__GUID-27E9E7A0-00BC-4899-A68B-224F13DA73DF">
                        <p class="notep1">注意：</p>
                        <p>示例左侧的粗体标注对应于以下注释：</p>
                        <ol>
                           <li>
                              <p><code class="codeph">OID</code>子句指定<code class="codeph">s_oid</code>加载程序字段包含OID。括号是必需的</p>
                           </li>
                           <li>
                              <p>如果<code class="codeph">s_oid</code>不包含有效的十六进制数，则拒绝特定记录。
                              </p>
                           </li>
                           <li>
                              <p>数据文件中的OID是字符串，并被解释为32位十六进制数。32位十六进制数后来转换为16字节<code class="codeph">RAW</code>并存储在对象表中。
                              </p>
                           </li>
                        </ol>
                     </div>
                  </div>
                  <!-- class="example" -->
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="loading-objects-oracle-sql-loader.html#GUID-FEBA5069-FB50-4662-8F14-ABFD7EB0D29E">使用子类型加载对象表</a><br>如果对象表的行对象基于非最终类型，则SQL * Loader允许将任何派生的子类型加载到对象表中。
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="loading-objects-oracle-sql-loader.html#GUID-A1828462-FD32-457C-976F-C85BA3A995DA" title="您可以使用SQL * Loader以各种格式加载列对象，并加载对象表，REF列，LOB和集合。">加载对象，LOB和集合</a></p>
                     </div>
                  </div>
               </div>
               <a id="SUTIL3376"></a><a id="SUTIL3375"></a><a id="SUTIL1257"></a><div class="props_rev_3"><a id="GUID-FEBA5069-FB50-4662-8F14-ABFD7EB0D29E" name="GUID-FEBA5069-FB50-4662-8F14-ABFD7EB0D29E"></a><h4 id="SUTIL-GUID-FEBA5069-FB50-4662-8F14-ABFD7EB0D29E" class="sect4"><span class="enumeration_section">11.2.1</span>使用子类型加载对象表</h4>
                  <div>
                     <p>如果对象表的行对象基于非最终类型，则SQL * Loader允许将任何派生的子类型加载到对象表中。</p>
                     <div class="section">
                        <p>如前所述，使用派生子类型加载对象表所需的语法几乎与用于典型关系表的语法相同。但是，在这种情况下，必须命名要使用的实际子类型，以便SQL * Loader可以确定它是否是对象表的有效子类型。<a href="loading-objects-oracle-sql-loader.html#GUID-FEBA5069-FB50-4662-8F14-ABFD7EB0D29E__I1010122">例11-12</a>说明了这个概念。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-FEBA5069-FB50-4662-8F14-ABFD7EB0D29E__I1010122">
                        <p class="titleinexample">示例11-12使用子类型加载对象表</p>
                        <p>对象类型定义</p><pre class="oac_no_warn" dir="ltr">CREATE TYPE employees_type AS OBJECT（名称VARCHAR2（30），年龄NUMBER（3），emp_id NUMBER（5））不是最终的; CREATE TYPE hourly_emps_type UNDER employees_type（小时NUMBER（3））; employee_type的CREATE TABLE employees_v3;</pre><p>控制文件内容</p><pre class="oac_no_warn" dir="ltr">LOAD DATA INFILE'ample.dat'INTO TABLE employees_v3 <span class="bold">1</span> TREAT AS hourly_emps_type FIELDS TERMINATED BY'，'（姓名CHAR（30），年龄INTEGER EXTERNAL（3），emp_id INTEGER EXTERNAL（5）， <span class="bold">2</span>小时INTEGER EXTERNAL（2））</pre><p>数据文件（sample.dat）</p><pre class="oac_no_warn" dir="ltr">Johny Quest，18,007,32，Speed Racer，16,000，20，</pre><div class="infoboxnote" id="GUID-FEBA5069-FB50-4662-8F14-ABFD7EB0D29E__GUID-1DDDD770-D862-4499-AD69-7B28D777E46F">
                           <p class="notep1">注意：</p>
                           <p>示例左侧的粗体标注对应于以下注释：</p>
                           <ol>
                              <li>
                                 <p><code class="codeph">TREAT</code> <code class="codeph">AS</code>子句指示SQL * Loader应该将对象表视为声明为类型为<code class="codeph">hourly_emps_type</code> ，而不是其实际声明的类型<code class="codeph">employee_type</code></p>
                              </li>
                              <li>
                                 <p>这里允许使用<code class="codeph">hours</code>属性，因为它是<code class="codeph">hourly_emps_type</code>的属性。如果尚未指定<code class="codeph">TREAT</code> <code class="codeph">AS</code>子句，则此属性将导致错误，因为它不是对象表的声明类型的属性。
                                 </p>
                              </li>
                           </ol>
                        </div>
                     </div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="loading-objects-oracle-sql-loader.html#GUID-6BA4C022-77C8-4738-9AFD-E52252036DE7" title="加载对象表所需的控制文件语法几乎与用于加载典型关系表的语法相同。">加载对象表</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div><a id="SUTIL1258"></a><div class="props_rev_3"><a id="GUID-ABA3F185-2E5A-421D-9F1F-E175926950B8" name="GUID-ABA3F185-2E5A-421D-9F1F-E175926950B8"></a><h3 id="SUTIL-GUID-ABA3F185-2E5A-421D-9F1F-E175926950B8" class="sect3"><span class="enumeration_section">11.3</span>加载REF列</h3>
               <div>
                  <p>SQL * Loader可以加载系统生成的OID <code class="codeph">REF</code>列，基于主键的<code class="codeph">REF</code>列和允许主键的未作用域<code class="codeph">REF</code>列。
                  </p>
                  <p>对于其中的每一个，指定表名的方式很重要，如以下部分所述。</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="loading-objects-oracle-sql-loader.html#GUID-F5275B5B-8C65-462D-BA4E-E7FBCB342E02">在REF子句中指定表名</a><br>您可以在REF子句中指定表名。
                     </li>
                     <li class="ulchildlink"><a href="loading-objects-oracle-sql-loader.html#GUID-1531532E-0BED-484D-A7C7-B6A3454EF48E">系统生成的OID REF列</a><br>在加载系统生成的<code class="codeph">REF</code>列时，SQL * Loader假定从中构造<code class="codeph">REF</code>列的实际OID位于包含其余数据的数据文件中。
                     </li>
                     <li class="ulchildlink"><a href="loading-objects-oracle-sql-loader.html#GUID-99A7B7BD-B555-4457-975C-C4E038632B54">主键REF列</a><br>要加载主键<code class="codeph">REF</code>列，SQL * Loader控制文件字段说明必须提供列名后跟<code class="codeph">REF</code>子句。
                     </li>
                     <li class="ulchildlink"><a href="loading-objects-oracle-sql-loader.html#GUID-DB61E2AF-7589-465F-92D7-A9A8A6492C8E">允许主键的无范围REF列</a><br>允许主键的无范围<code class="codeph">REF</code>列可以引用系统生成的和主键<code class="codeph">REF</code> 。
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="loading-objects-oracle-sql-loader.html#GUID-A1828462-FD32-457C-976F-C85BA3A995DA" title="您可以使用SQL * Loader以各种格式加载列对象，并加载对象表，REF列，LOB和集合。">加载对象，LOB和集合</a></p>
                     </div>
                  </div>
               </div>
               <a id="SUTIL1259"></a><div class="props_rev_3"><a id="GUID-F5275B5B-8C65-462D-BA4E-E7FBCB342E02" name="GUID-F5275B5B-8C65-462D-BA4E-E7FBCB342E02"></a><h4 id="SUTIL-GUID-F5275B5B-8C65-462D-BA4E-E7FBCB342E02" class="sect4"><span class="enumeration_section">11.3.1</span>在REF子句中指定表名</h4>
                  <div>
                     <p>您可以在REF子句中指定表名。</p>
                     <div class="section">
                        <div class="infoboxnote" id="GUID-F5275B5B-8C65-462D-BA4E-E7FBCB342E02__GUID-460B1246-3443-42E7-B86C-02669480DEDF">
                           <p class="notep1">注意：</p>
                           <p>本节中的信息仅适用于SQL * Loader和Oracle Database的发行版均为11 <span class="italic">g</span>版本1（11.1）或更高版本的环境。它不适用于SQL * Loader，Oracle数据库或两者都处于早期版本的环境。
                           </p>
                        </div>
                        <p>在SQL * Loader控制文件中，与<code class="codeph">REF</code>列对应的字段的描述由列名称后跟REF子句组成。REF子句将表名和适用于正在加载的<code class="codeph">REF</code>列类型的任何属性作为参数。表名可以动态指定（使用填充字段）或作为常量指定。也可以使用或不使用模式名称指定表名。
                        </p>
                        <p>无论REF子句中指定的表名是指定为常量还是使用填充字段，都将其解释为区分大小写。这可能会导致以下情况：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p>如果用户<code class="codeph">SCOTT</code>在表名周围创建了一个名为<code class="codeph">table2</code> ，而且没有引号，则可以通过以下任何方式在REF子句中使用它：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p><code class="codeph">REF（常数'TABLE2'，......）</code></p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">REF（常数'“TABLE2”'，......）</code></p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">REF（常量'SCOTT.TABLE2'，...）</code></p>
                                 </li>
                              </ul>
                           </li>
                           <li>
                              <p>如果用户<code class="codeph">SCOTT</code>使用混合大小写名称周围的引号创建名为<code class="codeph">"Table2"</code>的表，则可以通过以下任何方式在REF子句中使用它：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p><code class="codeph">REF（常数'Table2'，......）</code></p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">REF（常数'“表2”'，......）</code></p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">REF（常量'SCOTT.Table2'，...）</code></p>
                                 </li>
                              </ul>
                           </li>
                        </ul>
                        <p>在这两种情况下，如果使用填充字段替换<code class="codeph">constant</code> ，则如果将它们放在数据部分中，则示例中显示的相同值也将起作用。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="loading-objects-oracle-sql-loader.html#GUID-ABA3F185-2E5A-421D-9F1F-E175926950B8" title="SQL * Loader可以加载系统生成的OID REF列，基于主键的REF列和允许主键的未作用域REF列。">加载REF列</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="SUTIL3378"></a><a id="SUTIL3377"></a><a id="SUTIL1260"></a><div class="props_rev_3"><a id="GUID-1531532E-0BED-484D-A7C7-B6A3454EF48E" name="GUID-1531532E-0BED-484D-A7C7-B6A3454EF48E"></a><h4 id="SUTIL-GUID-1531532E-0BED-484D-A7C7-B6A3454EF48E" class="sect4"><span class="enumeration_section">11.3.2</span>系统生成的OID REF列</h4>
                  <div>
                     <p>在加载系统生成的<code class="codeph">REF</code>列时，SQL * Loader假定从中构造<code class="codeph">REF</code>列的实际OID位于包含其余数据的数据文件中。
                     </p>
                     <div class="section">
                        <p>对应于<code class="codeph">REF</code>列的字段的描述由列名称后跟<code class="codeph">REF</code>子句组成。
                        </p>
                        <p><code class="codeph">REF</code>子句将表名和OID作为参数。请注意，参数可以指定为常量或动态指定（使用填充字段）。请参阅<a href="oracle-sql-loader-syntax-diagrams.html#GUID-4BD87035-FE6D-4735-86A4-31C844ACC59A__BABJAGGH">ref_spec</a>以获取适当的语法。<a href="loading-objects-oracle-sql-loader.html#GUID-1531532E-0BED-484D-A7C7-B6A3454EF48E__I1006751">例11-13</a>演示了加载系统生成的OID <code class="codeph">REF</code>列。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-1531532E-0BED-484D-A7C7-B6A3454EF48E__I1006751">
                        <p class="titleinexample">例11-13加载系统生成的REF列</p>
                        <p>控制文件内容</p><pre class="oac_no_warn" dir="ltr">LOAD DATA INFILE'meample.dat'INTO TABLE departments_alt_v2 FIELDS TERMINATED BY'，'选项包含'''（dept_no CHAR（5），dept_name CHAR（30）， <span class="bold">1</span> dept_mgr REF（t_name，s_oid），s_oid FILLER CHAR（32 ），t_name FILLER CHAR（30））</pre><p>数据文件（sample.dat）</p><pre class="oac_no_warn" dir="ltr">22345，QuestWorld，21E978406D3E41FCE03400400B403BC3，EMPLOYEES_V2,23423，Geography，21E978406D4441FCE03400400B403BC3，EMPLOYEES_V2，</pre><div class="infoboxnote" id="GUID-1531532E-0BED-484D-A7C7-B6A3454EF48E__GUID-C7ABDD8B-A9B0-4B5D-8FC5-229D452C0EB9">
                           <p class="notep1">注意：</p>
                           <p>示例左侧的粗体标注对应于以下注释：</p>
                           <ol>
                              <li>
                                 <p>如果指定的表不存在，则拒绝该记录。<code class="codeph">dept_mgr</code>字段本身不映射到数据文件中的任何字段。
                                 </p>
                              </li>
                           </ol>
                        </div>
                     </div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="loading-objects-oracle-sql-loader.html#GUID-ABA3F185-2E5A-421D-9F1F-E175926950B8" title="SQL * Loader可以加载系统生成的OID REF列，基于主键的REF列和允许主键的未作用域REF列。">加载REF列</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="SUTIL3379"></a><a id="SUTIL1261"></a><div class="props_rev_3"><a id="GUID-99A7B7BD-B555-4457-975C-C4E038632B54" name="GUID-99A7B7BD-B555-4457-975C-C4E038632B54"></a><h4 id="SUTIL-GUID-99A7B7BD-B555-4457-975C-C4E038632B54" class="sect4"><span class="enumeration_section">11.3.3</span>主键REF列</h4>
                  <div>
                     <p>要加载主键<code class="codeph">REF</code>列，SQL * Loader控制文件字段说明必须提供列名后跟<code class="codeph">REF</code>子句。
                     </p>
                     <div class="section">
                        <p><code class="codeph">REF</code>子句为参数提供以逗号分隔的字段名称和常量值列表。第一个参数是表名，后跟参数，用于指定要加载的<code class="codeph">REF</code>列所基于的主键OID。请参阅<a href="oracle-sql-loader-syntax-diagrams.html#GUID-4BD87035-FE6D-4735-86A4-31C844ACC59A__BABJAGGH">ref_spec</a>以获取适当的语法。
                        </p>
                        <p>SQL * Loader假定参数的排序与构成引用表中主键OID的列的相对排序相匹配。<a href="loading-objects-oracle-sql-loader.html#GUID-99A7B7BD-B555-4457-975C-C4E038632B54__I1006786">例11-14</a>演示了加载主键<code class="codeph">REF</code>列。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-99A7B7BD-B555-4457-975C-C4E038632B54__I1006786">
                        <p class="titleinexample">示例11-14加载主键REF列</p>
                        <p>控制文件内容</p><pre class="oac_no_warn" dir="ltr">LOAD DATA INFILE'meample.dat'INTO TABLE departments_alt FIELDS TERMINATED BY'，'选项包含'''（dept_no CHAR（5），dept_name CHAR（30），dept_mgr REF（CONSTANT'EMPLOYEES'，emp_id），emp_id FILLER CHAR （32））</pre><p>数据文件（sample.dat）</p><pre class="oac_no_warn" dir="ltr">22345，QuestWorld，007,23423，Geography，000，</pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="loading-objects-oracle-sql-loader.html#GUID-ABA3F185-2E5A-421D-9F1F-E175926950B8" title="SQL * Loader可以加载系统生成的OID REF列，基于主键的REF列和允许主键的未作用域REF列。">加载REF列</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="SUTIL1262"></a><div class="props_rev_3"><a id="GUID-DB61E2AF-7589-465F-92D7-A9A8A6492C8E" name="GUID-DB61E2AF-7589-465F-92D7-A9A8A6492C8E"></a><h4 id="SUTIL-GUID-DB61E2AF-7589-465F-92D7-A9A8A6492C8E" class="sect4"><span class="enumeration_section">11.3.4</span>允许主键的无范围REF列</h4>
                  <div>
                     <p>允许主键的无范围<code class="codeph">REF</code>列可以引用系统生成的和主键<code class="codeph">REF</code> 。
                     </p>
                     <p>加载到此类<code class="codeph">REF</code>列的语法与加载到系统生成的OID <code class="codeph">REF</code>列或基于主键的<code class="codeph">REF</code>列中的语法相同。参见<a href="loading-objects-oracle-sql-loader.html#GUID-1531532E-0BED-484D-A7C7-B6A3454EF48E__I1006751">例11-13</a>和<a href="loading-objects-oracle-sql-loader.html#GUID-99A7B7BD-B555-4457-975C-C4E038632B54__I1006786">例11-14</a> 。
                     </p>
                     <p>加载到允许主键的未作用域<code class="codeph">REF</code>列时，以下限制适用：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>在单表加载期间，此列只能引用一种类型的<code class="codeph">REF</code> ，系统生成的或主键，但不能同时引用这两种<code class="codeph">REF</code> 。如果您尝试引用这两种类型，那么数据行将被拒绝，并显示一条错误消息，指出引用的表名无效。
                           </p>
                        </li>
                        <li>
                           <p>如果要将未作用域的主键<code class="codeph">REF</code>加载到此列，则在单表加载期间只能引用一个对象表。也就是说，要加载未扩展的主键<code class="codeph">REF</code> ，一些指向对象表X，一些指向对象表Y，则必须执行以下操作之一：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>执行两个单表加载。</p>
                              </li>
                              <li>
                                 <p>使用<code class="codeph">WHEN</code>子句关闭数据某些方面的多个<code class="codeph">INTO</code> <code class="codeph">TABLE</code>子句执行单个加载，例如未绑定的主键<code class="codeph">REF</code>的对象表名称。例如：</p><pre class="oac_no_warn" dir="ltr">当CUST_TBL =“CUSTOMERS_PK”字段以“，”（order_no position（1）char，cust_tbl FILLER char，cust_no FILLER char，cust REF（cust_tbl，cust_no））终止时，LOAD DATA INFILE'Data.dat'INTO TABLE orders_apk APPEND NULLIF order_no = '0'）INTO TABLE orders_apk APPEND当CUST_TBL =“CUSTOMERS_PK2”字段以“，”结束时（order_no position（1）char，cust_tbl FILLER char，cust_no FILLER char，cust REF（cust_tbl，cust_no）NULLIF order_no ='0'）</pre></li>
                           </ul>
                           <p>如果不使用这些方法中的任何一种，则数据行将被拒绝，并显示一条错误消息，指出引用的表名无效。</p>
                        </li>
                        <li>
                           <p>SQL * Loader不支持集合中的无范围主键<code class="codeph">REF</code> 。
                           </p>
                        </li>
                        <li>
                           <p>如果要将系统生成的<code class="codeph">REF</code>加载到此<code class="codeph">REF</code>列中，则<a href="loading-objects-oracle-sql-loader.html#GUID-1531532E-0BED-484D-A7C7-B6A3454EF48E" title="在加载系统生成的REF列时，SQL * Loader假定从中构造REF列的实际OID位于包含其余数据的数据文件中。">系统生成的OID REF列中</a>描述的任何限制也适用于此处。
                           </p>
                        </li>
                        <li>
                           <p>如果要将主键<code class="codeph">REF</code>加载到此<code class="codeph">REF</code>列中，则<a href="loading-objects-oracle-sql-loader.html#GUID-99A7B7BD-B555-4457-975C-C4E038632B54" title="要加载主键REF列，SQL * Loader控制文件字段说明必须提供列名后跟REF子句。">主键REF列中</a>描述的任何限制也适用于此处。
                           </p>
                           <div class="infoboxnote" id="GUID-DB61E2AF-7589-465F-92D7-A9A8A6492C8E__GUID-812DC3BE-E73D-468F-A047-6A7CAC5DC4A7">
                              <p class="notep1">注意：</p>
                              <p>对于允许主键的未作用域<code class="codeph">REF</code>列，SQL * Loader获取解析的第一个有效对象表（来自<code class="codeph">REF</code>指令或数据行）并使用该对象表的OID类型来确定可在其中引用的<code class="codeph">REF</code>类型单表负载。
                              </p>
                           </div>
                        </li>
                     </ul>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="loading-objects-oracle-sql-loader.html#GUID-ABA3F185-2E5A-421D-9F1F-E175926950B8" title="SQL * Loader可以加载系统生成的OID REF列，基于主键的REF列和允许主键的未作用域REF列。">加载REF列</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div><a id="SUTIL1263"></a><div class="props_rev_3"><a id="GUID-3637F462-436A-4F6B-B243-03FB3177CA80" name="GUID-3637F462-436A-4F6B-B243-03FB3177CA80"></a><h3 id="SUTIL-GUID-3637F462-436A-4F6B-B243-03FB3177CA80" class="sect3"><span class="enumeration_section">11.4</span>加载LOB</h3>
               <div>
                  <p>该部分描述了加载LOB。</p>
                  <p>LOB是一种<span class="italic">大型对象类型。</span> SQL * Loader支持以下类型的LOB：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><code class="codeph">BLOB</code> ：包含非结构化二进制数据的内部LOB</p>
                     </li>
                     <li>
                        <p><code class="codeph">CLOB</code> ：包含字符数据的内部LOB</p>
                     </li>
                     <li>
                        <p><code class="codeph">NCLOB</code> ：包含来自国家字符集的字符的内部LOB</p>
                     </li>
                     <li>
                        <p><code class="codeph">BFILE</code> ：存储在服务器端操作系统文件中的数据库表空间之外的<code class="codeph">BLOB</code></p>
                     </li>
                  </ul>
                  <p>LOB可以是列数据类型，除<code class="codeph">NCLOB</code> ，它们可以是对象的属性数据类型。LOB可以有实际值，它们可以为null，也可以为空。当存在要在LOB中存储的0长度字段时，SQL * Loader会创建一个空LOB。 （请注意，这与其他数据类型不同，其中SQL * Loader将任何0长度字符串的列设置为NULL。）这意味着将<span class="italic">NULL值加载到LOB列的唯一方法是使用NULLIF子句。</span></p>
                  <p><code class="codeph">XML</code>列是声明为<code class="codeph">SYS</code>类型的列。 <code class="codeph">XMLTYPE</code> 。 SQL * Loader将<code class="codeph">XML</code>列视为<code class="codeph">CLOB</code> 。以下各节中描述的用于从主数据文件或LOBFILE加载LOB数据的所有方法都适用于加载<code class="codeph">XML</code>列。
                  </p>
                  <div class="infoboxnote" id="GUID-3637F462-436A-4F6B-B243-03FB3177CA80__GUID-06840CCC-CAEF-418F-8AB7-BC1F35FA2F30">
                     <p class="notep1">注意：</p>
                     <p>您不能为LOB字段指定SQL字符串。即使您指定<code class="codeph">LOBFILE_spec</code>也是如此。
                     </p>
                  </div>
                  <p>由于LOB可能非常大，因此SQL * Loader可以从主数据文件（与其余数据一致）或从LOBFILE加载LOB数据，如以下部分所述：</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="loading-objects-oracle-sql-loader.html#GUID-32E1B379-E889-438E-BA76-A7ECBF17BAD9">从主数据文件加载LOB数据</a><br>您可以从主数据文件加载LOB列。
                     </li>
                     <li class="ulchildlink"><a href="loading-objects-oracle-sql-loader.html#GUID-E02C2828-ABD1-4B8D-9561-124D221B4BE3">从LOBFILE加载LOB数据</a><br>LOB数据可以足够长，因此从LOBFILE而不是从主数据文件加载它是有意义的。
                     </li>
                     <li class="ulchildlink"><a href="loading-objects-oracle-sql-loader.html#GUID-F1AEEF0A-5E89-421E-8128-4A9DA7E948AB">加载包含LLS字段的数据文件</a><br>如果数据文件中的字段是LOB位置说明符（LLS）字段，则可以使用<code class="codeph">LLS</code>子句指示此字段。
                     </li>
                  </ul>
                  <div class="infoboxnotealso" id="GUID-3637F462-436A-4F6B-B243-03FB3177CA80__GUID-C59A3A12-0A60-4069-BC84-B6107D75F3D6">
                     <p class="notep1">也可以看看：</p>
                     <p>有关大对象（LOB）数据类型的详细信息，请<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sutil&amp;id=SQLRF50994" target="_blank"><span class="italic">参见Oracle数据库SQL语言参考</span></a></p>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="loading-objects-oracle-sql-loader.html#GUID-A1828462-FD32-457C-976F-C85BA3A995DA" title="您可以使用SQL * Loader以各种格式加载列对象，并加载对象表，REF列，LOB和集合。">加载对象，LOB和集合</a></p>
                     </div>
                  </div>
               </div>
               <a id="SUTIL1264"></a><div class="props_rev_3"><a id="GUID-32E1B379-E889-438E-BA76-A7ECBF17BAD9" name="GUID-32E1B379-E889-438E-BA76-A7ECBF17BAD9"></a><h4 id="SUTIL-GUID-32E1B379-E889-438E-BA76-A7ECBF17BAD9" class="sect4"><span class="enumeration_section">11.4.1</span>从主数据文件加载LOB数据</h4>
                  <div>
                     <p>您可以从主数据文件加载LOB列。</p>
                     <p>要从主数据文件加载内部LOB（ <code class="codeph">BLOB</code> ， <code class="codeph">CLOB</code>和<code class="codeph">NCLOB</code> ）或<code class="codeph">XML</code>列，可以使用以下标准SQL * Loader格式：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>预定大小的字段</p>
                        </li>
                        <li>
                           <p>划界的字段</p>
                        </li>
                        <li>
                           <p>长度 - 值对字段</p>
                        </li>
                     </ul>
                     <p>以下各节介绍了这些格式中的每一种。</p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="loading-objects-oracle-sql-loader.html#GUID-F98F733A-E5D0-49A9-9042-FE39C9BF79C0">预定大小字段中的LOB数据</a><br>您可以将LOB数据加载到预定大小的字段中。
                        </li>
                        <li class="ulchildlink"><a href="loading-objects-oracle-sql-loader.html#GUID-DC800D62-FC91-4CF6-ADC5-1D9CF00621BB">分隔字段中的LOB数据</a><br>您可以将LOB数据加载到分隔字段中。
                        </li>
                        <li class="ulchildlink"><a href="loading-objects-oracle-sql-loader.html#GUID-CBC3D610-BDF7-44E9-9979-D0AEB15BA200">长度 - 值对字段中的LOB数据</a><br>您可以使用<code class="codeph">VARCHAR</code> ， <code class="codeph">VARCHARC</code>或<code class="codeph">VARRAW</code>数据类型来加载在长度 - 值对字段中组织的LOB数据。
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="loading-objects-oracle-sql-loader.html#GUID-3637F462-436A-4F6B-B243-03FB3177CA80" title="该部分描述了加载LOB。">加载LOB</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="SUTIL3381"></a><a id="SUTIL3380"></a><a id="SUTIL1265"></a><div class="props_rev_3"><a id="GUID-F98F733A-E5D0-49A9-9042-FE39C9BF79C0" name="GUID-F98F733A-E5D0-49A9-9042-FE39C9BF79C0"></a><h5 id="SUTIL-GUID-F98F733A-E5D0-49A9-9042-FE39C9BF79C0" class="sect5"><span class="enumeration_section">11.4.1.1</span>预定大小字段中的LOB数据</h5>
                     <div>
                        <p>您可以将LOB数据加载到预定大小的字段中。</p>
                        <div class="section">
                           <p>这是一种非常快速且概念上简单的格式，可以在其中加载LOB，如<a href="loading-objects-oracle-sql-loader.html#GUID-F98F733A-E5D0-49A9-9042-FE39C9BF79C0__I1006838">例11-15</a>所示。
                           </p>
                           <div class="infoboxnote" id="GUID-F98F733A-E5D0-49A9-9042-FE39C9BF79C0__GUID-C2207E1E-1554-40A4-BD9F-4DE696F36D9D">
                              <p class="notep1">注意：</p>
                              <p>由于您加载的LOB大小可能不同，因此您可以使用空格填充LOB数据，以使LOB在特定数据字段中的长度相等。</p>
                           </div>
                           <p>要使用此格式加载LOB，应使用<code class="codeph">CHAR</code>或<code class="codeph">RAW</code>作为加载数据类型。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-F98F733A-E5D0-49A9-9042-FE39C9BF79C0__I1006838">
                           <p class="titleinexample">示例11-15在预定大小字段中加载LOB数据</p>
                           <p>控制文件内容</p><pre class="oac_no_warn" dir="ltr">LOAD DATA INFILE'meample.dat'“fix 501”INTO TABLE person_table（名称POSITION（01:21）CHAR， <span class="bold">1</span> “RESUME”POSITION（23：500）CHAR DEFAULTIF“RESUME”= BLANKS）</pre><p>数据文件（sample.dat）</p><pre class="oac_no_warn" dir="ltr">Julia Nayer Julia Nayer 500示例Parkway jnayer@us.example.com ...</pre><div class="infoboxnote" id="GUID-F98F733A-E5D0-49A9-9042-FE39C9BF79C0__GUID-E336CB2A-06F4-4B14-B89D-D6E5AE6257F1">
                              <p class="notep1">注意：</p>
                              <p>示例左侧的粗体标注对应于以下注释：</p>
                              <ol>
                                 <li>
                                    <p>由于使用了<code class="codeph">DEFAULTIF</code>子句，如果包含resume的数据字段为空，则结果为空LOB而不是空LOB。但是，如果使用<code class="codeph">NULLIF</code>子句而不是<code class="codeph">DEFAULTIF</code> ，则空数据字段将为null。
                                    </p>
                                    <p>您可以使用<code class="codeph">CHAR</code>以外的SQL * Loader数据类型来加载LOB。例如，在加载<code class="codeph">BLOB</code> ，您可能希望使用<code class="codeph">RAW</code>数据类型。
                                    </p>
                                 </li>
                              </ol>
                           </div>
                        </div>
                        <!-- class="example" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="loading-objects-oracle-sql-loader.html#GUID-32E1B379-E889-438E-BA76-A7ECBF17BAD9" title="您可以从主数据文件加载LOB列。">从主数据文件加载LOB数据</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="SUTIL3383"></a><a id="SUTIL3382"></a><a id="SUTIL1266"></a><div class="props_rev_3"><a id="GUID-DC800D62-FC91-4CF6-ADC5-1D9CF00621BB" name="GUID-DC800D62-FC91-4CF6-ADC5-1D9CF00621BB"></a><h5 id="SUTIL-GUID-DC800D62-FC91-4CF6-ADC5-1D9CF00621BB" class="sect5"><span class="enumeration_section">11.4.1.2</span>分隔字段中的LOB数据</h5>
                     <div>
                        <p>您可以将LOB数据加载到分隔字段中。</p>
                        <p>此格式在同一列（数据文件字段）中处理不同大小的LOB而没有问题。但是，这种增加的灵活性会影响性能，因为SQL * Loader必须扫描数据，查找分隔符字符串。</p>
                        <p>与单字符分隔符一样，当您指定字符串分隔符时，应考虑数据文件的字符集。当数据文件的字符集与控制文件的字符集不同时，可以用十六进制表示法指定分隔符（即<span class="italic"><code class="codeph">X'hexadecimal</code></span> <span class="italic"><code class="codeph">string</code></span> <code class="codeph">'</code> ）。如果以十六进制表示法指定分隔符，则规范必须包含在输入数据文件的字符集中有效的字符。相反，如果未使用十六进制表示法，则定界符规范被认为是在客户端（即控制文件的）字符集中。在这种情况下，在SQL * Loader搜索数据文件中的分隔符之前，分隔符将转换为数据文件的字符集。
                        </p>
                        <p>请注意以下事项：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>字符串分隔符支持Stutter语法（也就是说，封闭的机箱分隔符可能是断断续续的）。</p>
                           </li>
                           <li>
                              <p>不允许在初始多字符机箱分隔符中使用前导空格。</p>
                           </li>
                           <li>
                              <p>如果<code class="codeph">WHITESPACE</code>终止某个字段，则会修剪前导空格。
                              </p>
                              <div class="infoboxnote" id="GUID-DC800D62-FC91-4CF6-ADC5-1D9CF00621BB__GUID-F57761C4-9E21-43DA-853D-881E7E4B5114">
                                 <p class="notep1">注意：</p>
                                 <p>移动<code class="codeph">CLOB</code>数据时，SQL * Loader默认为255个字节，但可以指定最多2千兆字节的值。对于分隔字段，如果指定了长度，则将该长度用作最大值。如果未指定maximum，则默认为255个字节。对于分隔且大于255个字节的<code class="codeph">CHAR</code>字段，必须指定最大长度。见<a href="oracle-sql-loader-field-list-contents.html#GUID-34A526C6-C2E6-4D17-8F53-D0CDEF38874B">CHAR</a>有关详细信息， <code class="codeph">CHAR</code>数据类型。
                                 </p>
                              </div>
                           </li>
                        </ul>
                        <p><a href="loading-objects-oracle-sql-loader.html#GUID-DC800D62-FC91-4CF6-ADC5-1D9CF00621BB__I1006874">例11-16</a>显示了在分隔字段中加载LOB数据的示例。
                        </p>
                        <div class="example" id="GUID-DC800D62-FC91-4CF6-ADC5-1D9CF00621BB__I1006874">
                           <p class="titleinexample">示例11-16在分隔字段中加载LOB数据</p>
                           <p>控制文件内容</p><pre class="oac_no_warn" dir="ltr">LOAD DATA INFILE'meample.dat'“str'|'”INTO TABLE person_table FIELDS TERMINATED BY'，'（name CHAR（25）， <span class="bold">1</span> “RESUME”CHAR（507）包含在'&lt;startlob&gt;'和'&lt;endlob&gt; “）</pre><p>数据文件（sample.dat）</p><pre class="oac_no_warn" dir="ltr">Julia Nayer，&lt;startlob&gt; Julia Nayer 500示例Parkway jnayer@us.example.com ... &lt;endlob&gt; <span class="bold">2</span> | Bruce Ernst，.......</pre><div class="infoboxnote" id="GUID-DC800D62-FC91-4CF6-ADC5-1D9CF00621BB__GUID-A951C3DE-B7F4-4785-951F-559B8B4A09FF">
                              <p class="notep1">注意：</p>
                              <p>示例左侧的粗体标注对应于以下注释：</p>
                              <ol>
                                 <li>
                                    <p><code class="codeph">&lt;startlob&gt;</code>和<code class="codeph">&lt;endlob&gt;</code>是机箱字符串。使用默认的字节长度语义，可以使用<code class="codeph">CHAR(507)</code>读取的LOB的最大长度为507个字节。如果使用了字符长度语义，则最大值为507个字符。请参阅<a href="oracle-sql-loader-control-file-contents.html#GUID-3DB632A7-BF43-40EF-AB2C-A1CC095854C2" title="字节长度语义是所有数据文件的默认值，除了使用UTF16字符集的默认值（默认情况下使用字符长度语义）。">字符长度语义</a></p>
                                 </li>
                                 <li>
                                    <p>如果记录分隔符<code class="codeph">'|'</code>已经被放置在<code class="codeph">&lt;endlob&gt;</code>并且跟着换行符，然后换行符将被解释为下<code class="codeph">&lt;endlob&gt;</code>记录的一部分。另一种方法是使记录分隔符的换行符部分（例如， <code class="codeph">'|\n'</code>或以十六进制表示法， <code class="codeph">X'7C0A'</code> ）。
                                    </p>
                                 </li>
                              </ol>
                           </div>
                        </div>
                        <!-- class="example" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="loading-objects-oracle-sql-loader.html#GUID-32E1B379-E889-438E-BA76-A7ECBF17BAD9" title="您可以从主数据文件加载LOB列。">从主数据文件加载LOB数据</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="SUTIL3385"></a><a id="SUTIL3384"></a><a id="SUTIL1267"></a><div class="props_rev_3"><a id="GUID-CBC3D610-BDF7-44E9-9979-D0AEB15BA200" name="GUID-CBC3D610-BDF7-44E9-9979-D0AEB15BA200"></a><h5 id="SUTIL-GUID-CBC3D610-BDF7-44E9-9979-D0AEB15BA200" class="sect5"><span class="enumeration_section">11.4.1.3</span>长度 - 值对字段中的LOB数据</h5>
                     <div>
                        <p>您可以使用<code class="codeph">VARCHAR</code> ， <code class="codeph">VARCHARC</code>或<code class="codeph">VARRAW</code>数据类型来加载在长度 - 值对字段中组织的LOB数据。
                        </p>
                        <p>这种加载方法提供了比使用分隔字段更好的性能，但可以降低灵活性（例如，您必须知道加载前每个LOB的LOB长度）。<a href="loading-objects-oracle-sql-loader.html#GUID-CBC3D610-BDF7-44E9-9979-D0AEB15BA200__I1006907">例11-17</a>演示了如何在长度 - 值对字段中加载LOB数据。
                        </p>
                        <div class="example" id="GUID-CBC3D610-BDF7-44E9-9979-D0AEB15BA200__I1006907">
                           <p class="titleinexample">例11-17在长度 - 值对字段中加载LOB数据</p>
                           <p>控制文件内容</p><pre class="oac_no_warn" dir="ltr">LOAD DATA <span class="bold">1</span> INFILE'ample.dat'“str'&lt;endrec&gt; \ n'”INTO TABLE person_table FIELDS TERMINATED BY'，'（名称CHAR（25）， <span class="bold">2</span> “RESUME”VARCHARC（3,500））</pre><p>数据文件（sample.dat）</p><pre class="oac_no_warn" dir="ltr">Julia Nayer，479 Julia Nayer 500示例Parkway jnayer@us.example.com ... &lt;endrec&gt; <span class="bold">3</span> Bruce Ernst，000 &lt;endrec&gt;</pre><div class="infoboxnote" id="GUID-CBC3D610-BDF7-44E9-9979-D0AEB15BA200__GUID-AEF0A144-BF31-49A5-9F67-40F8EF97BA98">
                              <p class="notep1">注意：</p>
                              <p>示例左侧的粗体标注对应于以下注释：</p>
                              <ol>
                                 <li>
                                    <p>如果不支持反斜杠转义字符，则示例中用作记录分隔符的字符串可以用十六进制表示法表示。</p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">"RESUME"</code>是对应于<code class="codeph">CLOB</code>列的字段。在控制文件中，它是<code class="codeph">VARCHARC</code> ，其长度字段长度为3个字节，其最大大小为500个字节（具有字节长度语义）。如果使用字符长度语义，则长度为3个字符，最大大小为500个字符。请参阅<a href="oracle-sql-loader-control-file-contents.html#GUID-3DB632A7-BF43-40EF-AB2C-A1CC095854C2" title="字节长度语义是所有数据文件的默认值，除了使用UTF16字符集的默认值（默认情况下使用字符长度语义）。">字符长度语义</a> 。
                                    </p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">VARCHARC</code>的长度子字段为0（值子字段为空）。因此，LOB实例初始化为空。
                                    </p>
                                 </li>
                              </ol>
                           </div>
                        </div>
                        <!-- class="example" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="loading-objects-oracle-sql-loader.html#GUID-32E1B379-E889-438E-BA76-A7ECBF17BAD9" title="您可以从主数据文件加载LOB列。">从主数据文件加载LOB数据</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="SUTIL1268"></a><div class="props_rev_3"><a id="GUID-E02C2828-ABD1-4B8D-9561-124D221B4BE3" name="GUID-E02C2828-ABD1-4B8D-9561-124D221B4BE3"></a><h4 id="SUTIL-GUID-E02C2828-ABD1-4B8D-9561-124D221B4BE3" class="sect4"><span class="enumeration_section">11.4.2</span>从LOBFILE加载LOB数据</h4>
                  <div>
                     <p>LOB数据可以足够长，因此从LOBFILE而不是从主数据文件加载它是有意义的。</p>
                     <p>在LOBFILE中，LOB数据实例仍被认为是在字段中（预定大小，分隔符，长度值），但这些字段没有组织成记录（LOBFILE中不存在记录的概念）。因此，避免了处理记录的处理开销。这种类型的数据组织是LOB加载的理想选择。</p>
                     <p>不要求LOBFILE中的LOB适合内存。SQL * Loader以64 KB块的形式读取LOBFILE。</p>
                     <p>在LOBFILE中，数据可以是以下任何类型的字段：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>单个LOB字段，可以读取文件的全部内容</p>
                        </li>
                        <li>
                           <p>预定大小字段（固定长度字段）</p>
                        </li>
                        <li>
                           <p>分隔字段（即<code class="codeph">TERMINATED</code> <code class="codeph">BY</code>或<code class="codeph">ENCLOSED</code> <code class="codeph">BY</code> ）</p>
                           <p><code class="codeph">PRESERVE</code> <code class="codeph">BLANKS</code>子句不适用于从LOBFILE读取的字段。</p>
                        </li>
                        <li>
                           <p>长度 - 值对字段（可变长度字段）</p>
                           <p>要从此类型的字段加载数据，请使用<code class="codeph">VARRAW</code> ， <code class="codeph">VARCHAR</code>或<code class="codeph">VARCHARC</code> SQL * Loader数据类型。
                           </p>
                        </li>
                     </ul>
                     <p>有关使用这些字段类型的示例，请参阅<a href="loading-objects-oracle-sql-loader.html#GUID-FE58EA0F-F3F9-443F-8C64-47F13C5A6475" title="本节包含从LOBFILE中的不同类型的字段加载数据的示例。">从LOBFILE加载LOB数据</a>的示例。所有前面提到的字段类型都可用于加载<code class="codeph">XML</code>列。
                     </p>
                     <p>有关LOBFILE语法，请参阅<a href="oracle-sql-loader-syntax-diagrams.html#GUID-4BD87035-FE6D-4735-86A4-31C844ACC59A__BABEHEID">lobfile_spec</a> 。
                     </p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="loading-objects-oracle-sql-loader.html#GUID-E488305F-90E5-4FE8-B122-A9341F99C450">动态与静态LOBFILE规格</a><br>您可以静态指定LOBFILE（文件的名称在控制文件中指定）或动态指定（ <code class="codeph">FILLER</code>字段用作文件名的来源）。
                        </li>
                        <li class="ulchildlink"><a href="loading-objects-oracle-sql-loader.html#GUID-FE58EA0F-F3F9-443F-8C64-47F13C5A6475">从LOBFILE加载LOB数据的示例</a><br>本节包含从LOBFILE中的不同类型的字段加载数据的示例。
                        </li>
                        <li class="ulchildlink"><a href="loading-objects-oracle-sql-loader.html#GUID-4BD4BA87-BD69-4FA9-A6A6-ECA5CE2B6A60">从LOBFILE加载LOB时的注意事项</a><br>从LOBFILE加载LOB时需要考虑的因素。
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="loading-objects-oracle-sql-loader.html#GUID-3637F462-436A-4F6B-B243-03FB3177CA80" title="该部分描述了加载LOB。">加载LOB</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="SUTIL1269"></a><div class="props_rev_3"><a id="GUID-E488305F-90E5-4FE8-B122-A9341F99C450" name="GUID-E488305F-90E5-4FE8-B122-A9341F99C450"></a><h5 id="SUTIL-GUID-E488305F-90E5-4FE8-B122-A9341F99C450" class="sect5"><span class="enumeration_section">11.4.2.1</span>动态与静态LOBFILE规范</h5>
                     <div>
                        <p>您可以静态指定LOBFILE（文件的名称在控制文件中指定）或动态指定（ <code class="codeph">FILLER</code>字段用作文件名的来源）。
                        </p>
                        <p>在任何一种情况下，如果LOBFILE <span class="italic">没有</span>被EOF终止，那么当到达LOBFILE的末尾时，文件被关闭并且进一步尝试从该文件读取数据产生的结果相当于从空字段读取数据。
                        </p>
                        <p>但是，如果您有一个由EOF终止的LOBFILE， <span class="italic">则</span>每次尝试从该文件读取数据时都会返回整个文件。
                        </p>
                        <p>您不应该指定与两个不同字段的源相同的LOBFILE。如果这样做，那么这两个字段通常会独立读取数据。</p>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="loading-objects-oracle-sql-loader.html#GUID-E02C2828-ABD1-4B8D-9561-124D221B4BE3" title="LOB数据可以足够长，因此从LOBFILE而不是从主数据文件加载它是有意义的。">从LOBFILE加载LOB数据</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="SUTIL1270"></a><div class="props_rev_3"><a id="GUID-FE58EA0F-F3F9-443F-8C64-47F13C5A6475" name="GUID-FE58EA0F-F3F9-443F-8C64-47F13C5A6475"></a><h5 id="SUTIL-GUID-FE58EA0F-F3F9-443F-8C64-47F13C5A6475" class="sect5"><span class="enumeration_section">11.4.2.2</span>从LOBFILE加载LOB数据的示例</h5>
                     <div>
                        <p>本节包含从LOBFILE中的不同类型的字段加载数据的示例。</p>
                     </div>
                     <div>
                        <ul class="ullinks">
                           <li class="ulchildlink"><a href="loading-objects-oracle-sql-loader.html#GUID-C8C0CC51-2638-4FAA-9CB1-9E9B20EB852E">每个文件一个LOB</a><br>每个LOBFILE在加载LOB数据时都是单个LOB的源。
                           </li>
                           <li class="ulchildlink"><a href="loading-objects-oracle-sql-loader.html#GUID-00E6ED60-8BE0-4315-9F40-82DC5C0656B6">预定尺寸LOB</a><br>您可以使用预定大小的LOB加载LOB数据。
                           </li>
                           <li class="ulchildlink"><a href="loading-objects-oracle-sql-loader.html#GUID-4AADD568-AB5C-4C56-8E3E-D497EF67DC84">定界LOB</a><br>您可以使用分隔的LOB加载LOB数据。
                           </li>
                           <li class="ulchildlink"><a href="loading-objects-oracle-sql-loader.html#GUID-C04366D7-247F-421E-BBFC-446A61C15258">长度值对指定的LOB</a><br>您可以使用指定长度值对的LOB加载LOB数据。
                           </li>
                        </ul>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="loading-objects-oracle-sql-loader.html#GUID-E02C2828-ABD1-4B8D-9561-124D221B4BE3" title="LOB数据可以足够长，因此从LOBFILE而不是从主数据文件加载它是有意义的。">从LOBFILE加载LOB数据</a></p>
                           </div>
                        </div>
                     </div>
                     <a id="SUTIL3387"></a><a id="SUTIL3386"></a><a id="SUTIL1271"></a><div class="props_rev_3"><a id="GUID-C8C0CC51-2638-4FAA-9CB1-9E9B20EB852E" name="GUID-C8C0CC51-2638-4FAA-9CB1-9E9B20EB852E"></a><h6 id="SUTIL-GUID-C8C0CC51-2638-4FAA-9CB1-9E9B20EB852E" class="sect6"><span class="enumeration_section">11.4.2.2.1</span>每个文件一个LOB</h6>
                        <div>
                           <p>每个LOBFILE在加载LOB数据时都是单个LOB的源。</p>
                           <div class="section">
                              <p>在<a href="loading-objects-oracle-sql-loader.html#GUID-C8C0CC51-2638-4FAA-9CB1-9E9B20EB852E__CEGHBDGD">例11-18中</a> ，每个LOBFILE是单个LOB的源。要加载以这种方式组织的LOB数据，列或字段名称后跟LOBFILE数据类型规范。
                              </p>
                           </div>
                           <!-- class="section" -->
                           <div class="example" id="GUID-C8C0CC51-2638-4FAA-9CB1-9E9B20EB852E__CEGHBDGD">
                              <p class="titleinexample">例11-18每个LOBFILE加载一个LOB的LOB数据</p>
                              <p>控制文件内容</p><pre class="oac_no_warn" dir="ltr">LOAD DATA INFILE'meample.dat'INTO TABLE person_table FIELDS TERMINATED BY'，'（名称CHAR（20）， <span class="bold">1</span> ext_fname FILLER CHAR（40）， <span class="bold">2</span> “RESUME”LOBFILE（ext_fname）由EOF终止）</pre><p>数据文件（sample.dat）</p><pre class="oac_no_warn" dir="ltr">Johny Quest，jqresume.txt，Speed Racer，'/ private / sracer / srresume.txt'，</pre><p>辅助数据文件（jqresume.txt）</p><pre class="oac_no_warn" dir="ltr">Johny Quest 500 Oracle Parkway ......</pre><p>辅助数据文件（srresume.txt）</p><pre class="oac_no_warn" dir="ltr">Speed Racer 400 Oracle Parkway ......</pre><div class="infoboxnote" id="GUID-C8C0CC51-2638-4FAA-9CB1-9E9B20EB852E__GUID-96CCBFC1-F848-4D9F-BF58-CDF14A9C878A">
                                 <p class="notep1">注意：</p>
                                 <p>示例左侧的粗体标注对应于以下注释：</p>
                                 <ol>
                                    <li>
                                       <p>填充字段映射到40字节数据字段，使用SQL * Loader <code class="codeph">CHAR</code>数据类型读取该数据字段。这假设使用默认的字节长度语义。如果使用了字符长度语义，则该字段将映射到40个字符的数据字段</p>
                                    </li>
                                    <li>
                                       <p>SQL * Loader从<code class="codeph">ext_fname</code>填充字段中获取LOBFILE名称。然后，它将LOBFILE（使用<code class="codeph">CHAR</code>数据类型）中的数据从第一个字节加载到EOF字符。如果未指定现有LOBFILE，则<code class="codeph">"RESUME"</code>字段初始化为空。
                                       </p>
                                    </li>
                                 </ol>
                              </div>
                           </div>
                           <!-- class="example" -->
                        </div>
                        <div>
                           <div class="familylinks">
                              <div class="parentlink">
                                 <p><strong>父主题：</strong> <a href="loading-objects-oracle-sql-loader.html#GUID-FE58EA0F-F3F9-443F-8C64-47F13C5A6475" title="本节包含从LOBFILE中的不同类型的字段加载数据的示例。">从LOBFILE加载LOB数据的示例</a></p>
                              </div>
                           </div>
                        </div>
                        
                     </div><a id="SUTIL3389"></a><a id="SUTIL3388"></a><a id="SUTIL1272"></a><div class="props_rev_3"><a id="GUID-00E6ED60-8BE0-4315-9F40-82DC5C0656B6" name="GUID-00E6ED60-8BE0-4315-9F40-82DC5C0656B6"></a><h6 id="SUTIL-GUID-00E6ED60-8BE0-4315-9F40-82DC5C0656B6" class="sect6"><span class="enumeration_section">11.4.2.2.2</span>预定大小的LOB</h6>
                        <div>
                           <p>您可以使用预定大小的LOB加载LOB数据。</p>
                           <div class="section">
                              <p>在<a href="loading-objects-oracle-sql-loader.html#GUID-00E6ED60-8BE0-4315-9F40-82DC5C0656B6__I1007065">例11-19中</a> ，指定要加载到控制文件中特定列的LOB的大小。在加载期间，SQL * Loader假定加载到该特定列的任何LOB数据都具有指定的大小。预定大小的字段允许数据解析器最佳地执行。但是，通常很难保证所有LOB的大小相同。
                              </p>
                           </div>
                           <!-- class="section" -->
                           <div class="example" id="GUID-00E6ED60-8BE0-4315-9F40-82DC5C0656B6__I1007065">
                              <p class="titleinexample">例11-19使用预定大小的LOB加载LOB数据</p>
                              <p>控制文件内容</p><pre class="oac_no_warn" dir="ltr">LOAD DATA INFILE'meample.dat'INTO TABLE person_table FIELDS TERMINATED BY'，'（name CHAR（20）， <span class="bold">1</span> “RESUME”LOBFILE（CONSTANT'/usr/private/jquest/jqresume.txt'）CHAR（2000））</pre><p>数据文件（sample.dat）</p><pre class="oac_no_warn" dir="ltr">Johny Quest，Speed Racer，</pre><p>辅助数据文件（jqresume.txt）</p><pre class="oac_no_warn" dir="ltr">Johny Quest 500 Oracle Parkway ......Speed Racer 400 Oracle Parkway ......</pre><div class="infoboxnote" id="GUID-00E6ED60-8BE0-4315-9F40-82DC5C0656B6__GUID-662CA784-A08B-4576-8C0E-34F3D066B87B">
                                 <p class="notep1">注意：</p>
                                 <p>示例左侧的粗体标注对应于以下注释：</p>
                                 <ol>
                                    <li>
                                       <p>此条目指定SQL * Loader使用<code class="codeph">CHAR</code>数据类型从<code class="codeph">jqresume.txt</code> LOBFILE加载2000字节的数据，从当前加载会话期间最后加载的字节之后的字节开始。这假定使用默认的字节长度语义。如果使用了字符长度语义，则SQL * Loader将从最后加载字符后的第一个字符开始加载2000个字符的数据。请参阅<a href="oracle-sql-loader-control-file-contents.html#GUID-3DB632A7-BF43-40EF-AB2C-A1CC095854C2" title="字节长度语义是所有数据文件的默认值，除了使用UTF16字符集的默认值（默认情况下使用字符长度语义）。">字符长度语义</a> 。
                                       </p>
                                    </li>
                                 </ol>
                              </div>
                           </div>
                           <!-- class="example" -->
                        </div>
                        <div>
                           <div class="familylinks">
                              <div class="parentlink">
                                 <p><strong>父主题：</strong> <a href="loading-objects-oracle-sql-loader.html#GUID-FE58EA0F-F3F9-443F-8C64-47F13C5A6475" title="本节包含从LOBFILE中的不同类型的字段加载数据的示例。">从LOBFILE加载LOB数据的示例</a></p>
                              </div>
                           </div>
                        </div>
                        
                     </div><a id="SUTIL3391"></a><a id="SUTIL3390"></a><a id="SUTIL1273"></a><div class="props_rev_3"><a id="GUID-4AADD568-AB5C-4C56-8E3E-D497EF67DC84" name="GUID-4AADD568-AB5C-4C56-8E3E-D497EF67DC84"></a><h6 id="SUTIL-GUID-4AADD568-AB5C-4C56-8E3E-D497EF67DC84" class="sect6"><span class="enumeration_section">11.4.2.2.3定界</span> LOB</h6>
                        <div>
                           <p>您可以使用分隔的LOB加载LOB数据。</p>
                           <div class="section">
                              <p>在<a href="loading-objects-oracle-sql-loader.html#GUID-4AADD568-AB5C-4C56-8E3E-D497EF67DC84__I1007097">例11-20中</a> ，LOBFILE中的LOB数据实例是分隔的。在这种格式中，将不同大小的LOB加载到同一列中不是问题。但是，这种增加的灵活性会影响性能，因为SQL * Loader必须扫描数据，查找分隔符字符串。
                              </p>
                           </div>
                           <!-- class="section" -->
                           <div class="example" id="GUID-4AADD568-AB5C-4C56-8E3E-D497EF67DC84__I1007097">
                              <p class="titleinexample">示例11-20使用分隔LOB加载LOB数据</p>
                              <p>控制文件内容</p><pre class="oac_no_warn" dir="ltr">LOAD DATA INFILE'meample.dat'INTO TABLE person_table FIELDS TERMINATED BY'，'（name CHAR（20）， <span class="bold">1</span> “RESUME”LOBFILE（CONSTANT'jqresume'）CHAR（2000）终止于“&lt;endlob&gt; \ n”）</pre><p>数据文件（sample.dat）</p><pre class="oac_no_warn" dir="ltr">Johny Quest，Speed Racer，</pre><p>辅助数据文件（jqresume.txt）</p><pre class="oac_no_warn" dir="ltr">Johny Quest 500 Oracle Parkway ... &lt;endlob&gt; Speed Racer 400 Oracle Parkway ... &lt;endlob&gt;</pre><div class="infoboxnote" id="GUID-4AADD568-AB5C-4C56-8E3E-D497EF67DC84__GUID-3471D8D4-23D6-4652-BCDA-08B9235DD881">
                                 <p class="notep1">注意：</p>
                                 <p>示例左侧的粗体标注对应于以下注释：</p>
                                 <ol>
                                    <li>
                                       <p>因为为<code class="codeph">CHAR</code>指定了最大长度2000，所以SQL * Loader知道期望什么作为字段的最大长度，这可能导致内存使用优化。<span class="italic">如果您选择指定最大长度，那么您应该确保不要低估其值。</span> <code class="codeph">TERMINATED</code> <code class="codeph">BY</code>子句指定终止LOB的字符串。或者，您可以使用<code class="codeph">ENCLOSED</code> <code class="codeph">BY</code>子句。<code class="codeph">ENCLOSED</code> <code class="codeph">BY</code>子句允许LOBFILE中LOB的相对定位更加灵活（LOBFILE中的LOB不需要是顺序的）。
                                       </p>
                                    </li>
                                 </ol>
                              </div>
                           </div>
                           <!-- class="example" -->
                        </div>
                        <div>
                           <div class="familylinks">
                              <div class="parentlink">
                                 <p><strong>父主题：</strong> <a href="loading-objects-oracle-sql-loader.html#GUID-FE58EA0F-F3F9-443F-8C64-47F13C5A6475" title="本节包含从LOBFILE中的不同类型的字段加载数据的示例。">从LOBFILE加载LOB数据的示例</a></p>
                              </div>
                           </div>
                        </div>
                        
                     </div><a id="SUTIL3393"></a><a id="SUTIL3392"></a><a id="SUTIL1274"></a><div class="props_rev_3"><a id="GUID-C04366D7-247F-421E-BBFC-446A61C15258" name="GUID-C04366D7-247F-421E-BBFC-446A61C15258"></a><h6 id="SUTIL-GUID-C04366D7-247F-421E-BBFC-446A61C15258" class="sect6"><span class="enumeration_section">11.4.2.2.4</span>长度 - 值对指定的LOB</h6>
                        <div>
                           <p>您可以使用指定长度值对的LOB加载LOB数据。</p>
                           <div class="section">
                              <p>在<a href="loading-objects-oracle-sql-loader.html#GUID-C04366D7-247F-421E-BBFC-446A61C15258__I1007136">例11-21</a>中，LOBFILE中的每个LOB都以其长度开头。您可以使用<code class="codeph">VARCHAR</code> ， <code class="codeph">VARCHARC</code>或<code class="codeph">VARRAW</code>数据类型来加载以这种方式组织的LOB数据。
                              </p>
                              <p>这种加载方法可以提供比分隔LOB更好的性能，但代价是有一定的灵活性（例如，在加载之前必须知道每个LOB的LOB长度）。</p>
                           </div>
                           <!-- class="section" -->
                           <div class="example" id="GUID-C04366D7-247F-421E-BBFC-446A61C15258__I1007136">
                              <p class="titleinexample">例11-21使用长度值对指定的LOB加载LOB数据</p>
                              <p>控制文件内容</p><pre class="oac_no_warn" dir="ltr">LOAD DATA INFILE'ample.dat'INTO TABLE person_table FIELDS TERMINATED BY'，'（name CHAR（20）， <span class="bold">1</span> “RESUME”LOBFILE（CONSTANT'jqresume'）VARCHARC（4,2000））</pre><p>数据文件（sample.dat）</p><pre class="oac_no_warn" dir="ltr">Johny Quest，Speed Racer，</pre><p>辅助数据文件（jqresume.txt）</p><pre class="oac_no_warn" dir="ltr"><span class="bold">2</span> 0501Johny Quest 500 Oracle Parkway ...
<span class="bold">3</span> 0000</pre><div class="infoboxnote" id="GUID-C04366D7-247F-421E-BBFC-446A61C15258__GUID-91E8ACBD-800D-42C4-AF59-26ACA2BB691C">
                                 <p class="notep1">注意：</p>
                                 <p>示例左侧的粗体标注对应于以下注释：</p>
                                 <ol>
                                    <li>
                                       <p>条目<code class="codeph">VARCHARC(4,2000)</code>告诉SQL * Loader LOBFILE中的LOB是长度 - 值对格式，前4个字节应该被解释为长度。<code class="codeph">2000</code>的值告诉SQL * Loader该字段的最大大小是2000字节。这假定使用默认的字节长度语义。如果使用了字符长度语义，则前4个字符将被解释为字符长度。字段的最大大小为2000个字符。请参阅<a href="oracle-sql-loader-control-file-contents.html#GUID-3DB632A7-BF43-40EF-AB2C-A1CC095854C2" title="字节长度语义是所有数据文件的默认值，除了使用UTF16字符集的默认值（默认情况下使用字符长度语义）。">字符长度语义</a> 。
                                       </p>
                                    </li>
                                    <li>
                                       <p><code class="codeph">Johny</code> <code class="codeph">Quest</code>之前的条目<code class="codeph">0501</code>告诉SQL * Loader LOB由接下来的501个字符组成。
                                       </p>
                                    </li>
                                    <li>
                                       <p>此条目指定空（非空）LOB。</p>
                                    </li>
                                 </ol>
                              </div>
                           </div>
                           <!-- class="example" -->
                        </div>
                        <div>
                           <div class="familylinks">
                              <div class="parentlink">
                                 <p><strong>父主题：</strong> <a href="loading-objects-oracle-sql-loader.html#GUID-FE58EA0F-F3F9-443F-8C64-47F13C5A6475" title="本节包含从LOBFILE中的不同类型的字段加载数据的示例。">从LOBFILE加载LOB数据的示例</a></p>
                              </div>
                           </div>
                        </div>
                        
                     </div>
                  </div><a id="SUTIL1275"></a><div class="props_rev_3"><a id="GUID-4BD4BA87-BD69-4FA9-A6A6-ECA5CE2B6A60" name="GUID-4BD4BA87-BD69-4FA9-A6A6-ECA5CE2B6A60"></a><h5 id="SUTIL-GUID-4BD4BA87-BD69-4FA9-A6A6-ECA5CE2B6A60" class="sect5"><span class="enumeration_section">11.4.2.3</span>从LOBFILE加载LOB时的注意事项</h5>
                     <div>
                        <p>从LOBFILE加载LOB时需要考虑的因素。</p>
                        <p>使用LOBFILE加载数据时请记住以下内容：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>只能从LOBFILE加载LOB和<code class="codeph">XML</code>列。
                              </p>
                           </li>
                           <li>
                              <p>加载特定LOB失败不会导致拒绝包含该LOB的记录。相反，您将拥有一个包含空LOB的记录。对于<code class="codeph">XML</code>列，如果加载LOB失败，将插入空值。</p>
                           </li>
                           <li>
                              <p>没有必要指定对应于LOB列的字段的最大长度。如果指定的最大<span class="italic">长度</span> ，则SQL * Loader使用它作为一个提示来优化存储器的使用。因此，重要的是最大长度规范不会低估真实的最大长度。
                              </p>
                           </li>
                           <li>
                              <p>从LOBFILE加载数据时，不能提供位置指定（ <code class="codeph">pos_spec</code> ）。</p>
                           </li>
                           <li>
                              <p><code class="codeph">NULLIF</code>或<code class="codeph">DEFAULTIF</code>字段条件不能基于从LOBFILE读取的字段。
                              </p>
                           </li>
                           <li>
                              <p>如果将不存在的LOBFILE指定为特定字段的数据源，则该字段将初始化为空。如果empty的概念不适用于特定字段类型，则该字段初始化为null。</p>
                           </li>
                           <li>
                              <p>表级别分隔符不会从从LOBFILE读取的字段继承。</p>
                           </li>
                           <li>
                              <p>在传统路径模式下加载<code class="codeph">XML</code>列或在SQL表达式中引用LOB列时，SQL * Loader必须将LOB数据作为临时LOB处理。要确保在这些情况下可能获得最佳负载性能，请参阅<a href="../adlob/performance-guidelines.html#ADLOB105" target="_blank"><span class="italic">Oracle Database SecureFiles和Large Objects Developer's Guide中</span></a>有关临时LOB性能<a href="../adlob/performance-guidelines.html#ADLOB105" target="_blank"><span class="italic">的指南</span></a> 。
                              </p>
                           </li>
                        </ul>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="loading-objects-oracle-sql-loader.html#GUID-E02C2828-ABD1-4B8D-9561-124D221B4BE3" title="LOB数据可以足够长，因此从LOBFILE而不是从主数据文件加载它是有意义的。">从LOBFILE加载LOB数据</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div>
               <div class="sect3"><a id="GUID-F1AEEF0A-5E89-421E-8128-4A9DA7E948AB" name="GUID-F1AEEF0A-5E89-421E-8128-4A9DA7E948AB"></a><h4 id="SUTIL-GUID-F1AEEF0A-5E89-421E-8128-4A9DA7E948AB" class="sect4"><span class="enumeration_section">11.4.3</span>加载包含LLS字段的数据文件</h4>
                  <div>
                     <p>如果数据文件中的字段是LOB位置说明符（LLS）字段，则可以使用<code class="codeph">LLS</code>子句指示此字段。
                     </p>
                     <p>LLS字段包含数据文件中LOB数据的文件名，偏移量和长度。SQL * Loader使用此信息读取LOB列的数据。</p>
                     <p><code class="codeph">LLS</code>子句的语法如下：</p>
                     <div class="figure" id="GUID-F1AEEF0A-5E89-421E-8128-4A9DA7E948AB__GUID-709D99CC-FAD6-40E0-B11A-2639252306AC"><img src="img/lls_field_spec.gif" alt="下面是lls_field_spec.eps的描述" title="下面是lls_field_spec.eps的描述" longdesc="img_text/lls_field_spec.html"><br><a href="img_text/lls_field_spec.html">说明lls_field_spec.eps的描述</a></div>
                     <!-- class="figure" -->
                     <p>LOB可以部分或全部加载，并且可以从任意位置开始并且任意长度。SQL Loader期望LLS字段的内容为<code class="codeph"><span class="variable" translate="no">filename.ext.nnn.mmm</span> /</code> ，其中每个元素定义如下：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph"><span class="variable" translate="no">filename.ext</span></code>是包含LOB的文件的名称。</p>
                        </li>
                        <li>
                           <p><code class="codeph"><span class="variable" translate="no">nnn</span></code>是文件中LOB的字节偏移量。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph"><span class="variable" translate="no">mmm</span></code>是LOB的长度，以字节为单位。值-1表示LOB为NULL。值0表示LOB存在，但为空。
                           </p>
                        </li>
                        <li>
                           <p>正斜杠（ <code class="codeph">/</code> ）终止该字段</p>
                        </li>
                     </ul>
                     <p>如果指定了SQL * Loader参数<code class="codeph">SDF_PREFIX</code> ，则SQL * Loader将查找<code class="codeph">SDF_PREFIX</code>指定的目录中的文件。否则，SQL * Loader将查找与数据文件相同的目录。
                     </p>
                     <p>如果满足以下任何条件，则报告错误并拒绝该行：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>文件名包含相对或绝对路径规范。</p>
                        </li>
                        <li>
                           <p>找不到文件，偏移量无效，或者长度超出文件末尾。</p>
                        </li>
                        <li>
                           <p>该字段的内容与预期的格式不匹配。</p>
                        </li>
                        <li>
                           <p>与LLS字段关联的列的数据类型不是<code class="codeph">CLOB</code> ， <code class="codeph">BLOB</code>或<code class="codeph">NCLOB</code> 。</p>
                        </li>
                     </ul>
                     <div class="section">
                        <p class="subhead3" id="GUID-F1AEEF0A-5E89-421E-8128-4A9DA7E948AB__GUID-A951F0F5-6447-4ED5-B219-9B2C0F5FE111">使用说明</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>如果控制文件中的任何其他字段（例如<code class="codeph">NULLIF</code>子句）的子句引用了LLS字段，则用于计算子句的值是数据文件中的字符串，而不是指向的文件中的数据。那个字符串。
                              </p>
                           </li>
                           <li>
                              <p>假定<code class="codeph">LLS</code>子句指向的文件中数据的字符集与数据文件的字符集相同。
                              </p>
                           </li>
                           <li>
                              <p>运行SQL * Loader的用户必须具有对数据文件的读访问权。</p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-F1AEEF0A-5E89-421E-8128-4A9DA7E948AB__GUID-000E3A66-BA5E-4ED5-B102-8F2B1860AC1C">
                        <p class="titleinexample">例11-22 LLS条款的示例规范</p>
                        <p>以下是包含<code class="codeph">LLS</code>子句的SQL * Loader控制文件的示例。请注意，列规范不需要数据类型，因为该列必须是<code class="codeph">LOB</code>类型。</p><pre class="pre codeblock"><code>LOAD DATA INFILE * TRUNCATE INTO tklglls FIELDS终止'，'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''</code></pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="loading-objects-oracle-sql-loader.html#GUID-3637F462-436A-4F6B-B243-03FB3177CA80" title="该部分描述了加载LOB。">加载LOB</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div><a id="SUTIL3395"></a><a id="SUTIL3397"></a><a id="SUTIL3394"></a><a id="SUTIL3396"></a><a id="SUTIL1276"></a><div class="props_rev_3"><a id="GUID-CA3B8A38-0559-4E34-A8FB-B4627A2AAF40" name="GUID-CA3B8A38-0559-4E34-A8FB-B4627A2AAF40"></a><h3 id="SUTIL-GUID-CA3B8A38-0559-4E34-A8FB-B4627A2AAF40" class="sect3"><span class="enumeration_section">11.5</span>加载BFILE列</h3>
               <div>
                  <p><code class="codeph">BFILE</code>数据类型将非结构化二进制数据存储在数据库外的操作系统文件中。
                  </p>
                  <p><code class="codeph">BFILE</code>列或属性存储指向包含数据的外部文件的文件定位器。在加载时不必存在要作为<code class="codeph">BFILE</code>加载的文件;它可以在以后创建。SQL * Loader假定已经创建了必要的目录对象（服务器文件系统上物理目录的逻辑别名）。有关更多信息，请参阅<a href="../adlob/managing-LOBs.html#ADLOB45157" target="_blank"><span class="italic">Oracle Database SecureFiles和Large Objects Developer's Guide</span></a> 。
                  </p>
                  <p>与<code class="codeph">BFILE</code>列对应的控制文件字段由列名后跟<code class="codeph">BFILE</code>子句组成。<code class="codeph">BFILE</code>子句将目录对象（server_directory别名）名称作为参数，后跟<code class="codeph">BFILE</code>名称。两个参数都可以作为字符串常量提供，也可以通过其他字段动态加载。有关更多信息，请参见<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sutil&amp;id=SQLRF50996" target="_blank"><span class="italic">Oracle数据库SQL语言参考</span></a> 。
                  </p>
                  <p>在接下来的两个加载<code class="codeph">BFILE</code>的例子中， <a href="loading-objects-oracle-sql-loader.html#GUID-CA3B8A38-0559-4E34-A8FB-B4627A2AAF40__I1010717">例11-23</a>只有动态指定的文件名，而<a href="loading-objects-oracle-sql-loader.html#GUID-CA3B8A38-0559-4E34-A8FB-B4627A2AAF40__I1010734">例11-24</a>演示了动态指定<code class="codeph">BFILE</code>和目录对象。
                  </p>
                  <div class="example" id="GUID-CA3B8A38-0559-4E34-A8FB-B4627A2AAF40__I1010717">
                     <p class="titleinexample">示例11-23使用BFILE加载数据：仅动态指定文件名</p>
                     <p>以下是控制文件内容。目录名<code class="codeph">scott_dir1</code>在引号中;因此，字符串按原样使用，并且不是大写的。
                     </p><pre class="oac_no_warn" dir="ltr">LOAD DATA INFILE sample.dat INTO TABLE行星FIELDS TERMINATED BY'，'（pl_id CHAR（3），pl_name CHAR（20），fname FILLER CHAR（30），pl_pict BFILE（CONSTANT“scott_dir1”，fname））</pre><p>以下是数据文件<code class="codeph">sample.dat</code>的内容。
                     </p><pre class="oac_no_warn" dir="ltr">1，Mercury，mercury.jpeg，2，Venus，venus.jpeg，3，Earth，earth.jpeg，</pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-CA3B8A38-0559-4E34-A8FB-B4627A2AAF40__I1010734">
                     <p class="titleinexample">示例11-24使用BFILE加载数据：动态指定的文件名和目录</p>
                     <p>以下是控制文件内容。请注意， <code class="codeph">dname</code>映射到数据文件字段，该字段包含与正在加载的文件对应的目录名称。
                     </p><pre class="oac_no_warn" dir="ltr">LOAD DATA INFILE sample.dat INTO TABLE行星FIELDS TERMINATED BY'，'选项包含'''（pl_id NUMBER（4），pl_name CHAR（20），fname FILLER CHAR（30），dname FILLER CHAR（20），pl_pict BFILE （dname，fname））</pre><p>以下是数据文件<code class="codeph">sample.dat</code>的内容。
                     </p><pre class="oac_no_warn" dir="ltr">1，Mercury，mercury.jpeg，scott_dir1,2，Venus，venus.jpeg，scott_dir1,3，Earth，earth.jpeg，scott_dir2，</pre></div>
                  <!-- class="example" -->
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="loading-objects-oracle-sql-loader.html#GUID-A1828462-FD32-457C-976F-C85BA3A995DA" title="您可以使用SQL * Loader以各种格式加载列对象，并加载对象表，REF列，LOB和集合。">加载对象，LOB和集合</a></p>
                     </div>
                  </div>
               </div>
               
            </div><a id="SUTIL1277"></a><div class="props_rev_3"><a id="GUID-B769A8EC-48F4-4E8E-8896-2D7A5463112C" name="GUID-B769A8EC-48F4-4E8E-8896-2D7A5463112C"></a><h3 id="SUTIL-GUID-B769A8EC-48F4-4E8E-8896-2D7A5463112C" class="sect3"><span class="enumeration_section">11.6</span>加载集合（嵌套表和VARRAY）</h3>
               <div>
                  <p>与LOB一样，可以从主数据文件（数据内联）或辅助数据文件（数据脱机）加载集合。</p>
                  <p>加载集合数据时，必须存在一种机制，SQL * Loader可以通过该机制判断属于特定集合实例的数据何时结束。您可以通过两种方式实现此目的：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>要指定要加载到每个嵌套表或<code class="codeph">VARRAY</code>实例中的行数或元素数，请使用DDL <code class="codeph">COUNT</code>函数。为<code class="codeph">COUNT</code>指定的值必须是数字或包含数字的字符串，并且必须先在<code class="codeph">COUNT</code>子句本身之前的控制文件中进行描述。此位置依赖性特定于<code class="codeph">COUNT</code>子句。<code class="codeph">COUNT(0)</code>或<code class="codeph">COUNT(cnt_field)</code> ，其中当前行的<code class="codeph">cnt_field</code>为0，导致空集合（非空），除非被<code class="codeph">NULLIF</code>子句覆盖。见<a href="oracle-sql-loader-syntax-diagrams.html#GUID-4BD87035-FE6D-4735-86A4-31C844ACC59A__BABIHJAH">count_spec</a> 。
                        </p>
                        <p>如果<code class="codeph">COUNT</code>子句指定控制文件中的字段，并且该字段对于当前行设置为null，则对于当前行，使用该计数的集合也将设置为空。
                        </p>
                     </li>
                     <li>
                        <p>使用<code class="codeph">TERMINATED</code> <code class="codeph">BY</code>和<code class="codeph">ENCLOSED</code> <code class="codeph">BY</code>子句指定唯一的集合分隔符。如果使用<code class="codeph">SDF</code>子句，则不能使用此方法。
                        </p>
                     </li>
                  </ul>
                  <p>在控制文件中，集合的描述与列对象类似。有一些差异：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>集合描述采用前面列表中讨论的两种机制。</p>
                     </li>
                     <li>
                        <p>集合描述可以包括辅助数据文件（SDF）规范。</p>
                     </li>
                     <li>
                        <p>除非子句位于同一SDF中的字段上，否则<code class="codeph">NULLIF</code>或<code class="codeph">DEFAULTIF</code>子句不能引用SDF中的字段。</p>
                     </li>
                     <li>
                        <p>将字段名称作为参数的子句不能使用集合中的字段名称，除非DDL规范适用于同一集合中的字段。</p>
                     </li>
                     <li>
                        <p>字段列表必须只包含一个非填充字段和任意数量的填充字段。如果<code class="codeph">VARRAY</code>是列对象的<code class="codeph">VARRAY</code> ，则每个列对象的属性将位于嵌套字段列表中。
                        </p>
                     </li>
                  </ul>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="loading-objects-oracle-sql-loader.html#GUID-0DD26C32-27F6-429B-A0BB-16AAE2E91553">嵌套表和VARRAY中的限制</a><br>嵌套表和<code class="codeph">VARRAY</code>有限制。
                     </li>
                     <li class="ulchildlink"><a href="loading-objects-oracle-sql-loader.html#GUID-EB6B23EE-B2AB-4AC2-9032-0F9798F539BC">辅助数据文件（SDF）</a><br>辅助数据文件（SDF）在概念上与主数据文件类似。
                     </li>
                  </ul>
                  <div class="infoboxnotealso" id="GUID-B769A8EC-48F4-4E8E-8896-2D7A5463112C__GUID-7F1193EF-765D-458B-8AC1-910D286B5985">
                     <p class="notep1">也可以看看：</p>
                     <p>有关SDF的详细信息，请参阅<a href="loading-objects-oracle-sql-loader.html#GUID-EB6B23EE-B2AB-4AC2-9032-0F9798F539BC" title="辅助数据文件（SDF）在概念上与主数据文件类似。">辅助数据文件（SDF）</a> 。
                     </p>
                     <p>有关加载列对象的详细信息，请参阅<a href="loading-objects-oracle-sql-loader.html#GUID-13D3C6B4-209C-46CA-B0CD-57FB3FA37776" title="控制文件中的列对象根据其属性进行描述。">加载列对象</a> 。
                     </p>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="loading-objects-oracle-sql-loader.html#GUID-A1828462-FD32-457C-976F-C85BA3A995DA" title="您可以使用SQL * Loader以各种格式加载列对象，并加载对象表，REF列，LOB和集合。">加载对象，LOB和集合</a></p>
                     </div>
                  </div>
               </div>
               <a id="SUTIL3398"></a><a id="SUTIL3399"></a><a id="SUTIL1278"></a><div class="props_rev_3"><a id="GUID-0DD26C32-27F6-429B-A0BB-16AAE2E91553" name="GUID-0DD26C32-27F6-429B-A0BB-16AAE2E91553"></a><h4 id="SUTIL-GUID-0DD26C32-27F6-429B-A0BB-16AAE2E91553" class="sect4"><span class="enumeration_section">11.6.1</span>嵌套表和VARRAY中的限制</h4>
                  <div>
                     <p>嵌套表和<code class="codeph">VARRAY</code>有限制。
                     </p>
                     <div class="section">
                        <p>嵌套表和<code class="codeph">VARRAY</code>存在以下限制：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">field_list</code>不能包含<code class="codeph">collection_fld_spec</code> 。
                              </p>
                           </li>
                           <li>
                              <p>嵌套在<code class="codeph">VARRAY</code> <code class="codeph">col_obj_spec</code>不能包含<code class="codeph">collection_fld_spec</code> 。
                              </p>
                           </li>
                           <li>
                              <p>指定为<code class="codeph">field_list</code>一部分的<code class="codeph">column_name</code>必须与<code class="codeph">VARRAY</code>参数之前的<code class="codeph">column_name</code>相同。
                              </p>
                           </li>
                        </ul>
                        <p>另外，请注意，如果要加载到包含嵌套表的表中，则SQL * Loader不会自动将加载拆分为多个加载并生成集ID。</p>
                        <p><a href="loading-objects-oracle-sql-loader.html#GUID-0DD26C32-27F6-429B-A0BB-16AAE2E91553__I1007222">例11-25</a>演示了如何加载<code class="codeph">VARRAY</code>和嵌套表。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-0DD26C32-27F6-429B-A0BB-16AAE2E91553__I1007222">
                        <p class="titleinexample">示例11-25加载VARRAY和嵌套表</p>
                        <p>控制文件内容</p><pre class="oac_no_warn" dir="ltr">LOAD DATA INFILE'meample.dat'“str'\ n'”INTO TABLE dept REPLACE FIELDS终止'，''选择性地包含'''（dept_no CHAR（3），dname CHAR（25）NULLIF dname = BLANKS， <span class="bold">1</span> emps VARRAY终止于'：'（emps COLUMN OBJECT（名称CHAR（30），年龄INTEGER EXTERNAL（3）， <span class="bold">2</span> emp_id CHAR（7）NULLIF emps.emps.emp_id = BLANKS））， <span class="bold">3</span> proj_cnt FILLER CHAR（3）， <span class="bold">4</span>项目NESTED TABLE SDF（CONSTANT“pr.txt”“fix 57”）COUNT（proj_cnt）（项目COLUMN OBJECT（project_id POSITION（1：5）INTEGER EXTERNAL（5），project_name POSITION（7:30）CHAR NULLIF projects.projects .project_name = BLANKS）））</pre><p>数据文件（sample.dat）</p><pre class="oac_no_warn" dir="ltr">101，MATH，“Napier”，28,2828，“Euclid”，123,9999：0 210，“拓扑变换”，：2</pre><p>辅助数据文件（SDF）（pr.txt）</p><pre class="oac_no_warn" dir="ltr">21034拓扑变换77777不可能证明</pre><div class="infoboxnote" id="GUID-0DD26C32-27F6-429B-A0BB-16AAE2E91553__GUID-5C1AA2C6-2295-42AE-A072-6B83086C2A14">
                           <p class="notep1">注意：</p>
                           <p>示例左侧的粗体标注对应于以下注释：</p>
                           <ol>
                              <li>
                                 <p><code class="codeph">TERMINATED</code> <code class="codeph">BY</code>子句指定<code class="codeph">VARRAY</code>实例终止符（请注意，不使用<code class="codeph">COUNT</code>子句）。
                                 </p>
                              </li>
                              <li>
                                 <p>全名字段引用（使用点表示法）解决由此填充字段的存在而创建的字段名称冲突。</p>
                              </li>
                              <li>
                                 <p><code class="codeph">proj_cnt</code>是一个填充字段，用作<code class="codeph">COUNT</code>子句的参数。
                                 </p>
                              </li>
                              <li>
                                 <div class="p">此条目指定以下内容：<ul style="list-style-type:disc">
                                       <li>
                                          <p>SDF叫做<code class="codeph">pr</code> 。 <code class="codeph">txt</code>作为数据源。它还在SDF中指定固定记录格式。</p>
                                       </li>
                                       <li>
                                          <p>如果<code class="codeph">COUNT</code>为0，则集合初始化为空。将集合初始化为空的另一种方法是使用<code class="codeph">DEFAULTIF</code>子句。与嵌套表字段描述相对应的主字段名称与其嵌套非填充字段的字段名称相同，具体地，列对象字段描述的名称。
                                          </p>
                                       </li>
                                    </ul>
                                 </div>
                              </li>
                           </ol>
                        </div>
                     </div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="loading-objects-oracle-sql-loader.html#GUID-B769A8EC-48F4-4E8E-8896-2D7A5463112C" title="与LOB一样，可以从主数据文件（数据内联）或辅助数据文件（数据脱机）加载集合。">加载集合（嵌套表和VARRAY）</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="SUTIL1279"></a><div class="props_rev_3"><a id="GUID-EB6B23EE-B2AB-4AC2-9032-0F9798F539BC" name="GUID-EB6B23EE-B2AB-4AC2-9032-0F9798F539BC"></a><h4 id="SUTIL-GUID-EB6B23EE-B2AB-4AC2-9032-0F9798F539BC" class="sect4"><span class="enumeration_section">11.6.2</span>辅助数据文件（SDF）</h4>
                  <div>
                     <p>辅助数据文件（SDF）在概念上与主数据文件类似。</p>
                     <p>与主数据文件一样，SDF是记录的集合，每个记录由字段组成。SDF是基于每个控制文件字段指定的。加载大型嵌套表和<code class="codeph">VARRAY</code>时它们很有用。
                     </p>
                     <div class="infoboxnote" id="GUID-EB6B23EE-B2AB-4AC2-9032-0F9798F539BC__GUID-7ECDA72B-2C94-4B04-9968-C5AE90296508">
                        <p class="notep1">注意：</p>
                        <p>只有<code class="codeph">collection_fld_spec</code>才能将SDF命名为其数据源。
                        </p>
                     </div>
                     <p>使用<code class="codeph">SDF</code>参数指定<code class="codeph">SDF</code> 。<code class="codeph">SDF</code>参数后面可以是文件规范字符串，也可以是映射到包含一个或多个文件规范字符串的数据字段的<code class="codeph">FILLER</code>字段。
                     </p>
                     <p>对于主数据文件，可以为每个SDF指定以下内容：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>记录格式（固定，流或变量）。此外，如果使用流记录格式，则可以指定记录分隔符。</p>
                        </li>
                        <li>
                           <p>记录大小。</p>
                        </li>
                        <li>
                           <p>可以使用<code class="codeph">CHARACTERSET</code>子句指定SDF的字符集（请参阅<a href="oracle-sql-loader-control-file-contents.html#GUID-E0D390F1-1078-4955-9B55-B19C971D616D" title="SQL * Loader支持不同的字符编码方案（称为字符集或代码页）。">处理不同的字符编码方案</a> ）。
                           </p>
                        </li>
                        <li>
                           <p>继承特定SDF规范的字段的默认分隔符（使用分隔符规范）（包含SDF规范的集合的所有成员字段或属性，包含其自己的LOBFILE规范的字段除外）。</p>
                        </li>
                     </ul>
                     <p>还要注意有关SDF的以下内容：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>如果将不存在的SDF指定为特定字段的数据源，则该字段将初始化为空。如果empty的概念不适用于特定字段类型，则该字段初始化为null。</p>
                        </li>
                        <li>
                           <p>表级别分隔符不是从SDF读取的字段继承的。</p>
                        </li>
                        <li>
                           <p>要加载大于64 KB的SDF，必须使用<code class="codeph">READSIZE</code>参数指定更大的物理记录大小。您可以从命令行或作为<code class="codeph">OPTIONS</code>子句的一部分指定<code class="codeph">READSIZE</code>参数。
                           </p>
                           <div class="infoboxnotealso" id="GUID-EB6B23EE-B2AB-4AC2-9032-0F9798F539BC__GUID-FA6BCAFD-3B2E-4DDC-86EF-D0CF9ECE84CA">
                              <p class="notep1">也可以看看：</p>
                              <p></p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p><a href="oracle-sql-loader-commands.html#GUID-846265A6-3B66-45FD-99AE-009EC9380490" title="如果您选择不使用默认值，则READSIZE SQL * Loader命令行参数指定（以字节为单位）读取缓冲区的大小。">READSIZE</a></p>
                                 </li>
                                 <li>
                                    <p><a href="oracle-sql-loader-control-file-contents.html#GUID-2BB41EA6-C94D-41C1-94DE-966B291943E6" title="可以使用OPTIONS子句指定以下命令行参数。">选项条款</a></p>
                                 </li>
                                 <li>
                                    <p><a href="oracle-sql-loader-syntax-diagrams.html#GUID-4BD87035-FE6D-4735-86A4-31C844ACC59A__BABHGFGG">sdf_spec</a></p>
                                 </li>
                              </ul>
                           </div>
                        </li>
                     </ul>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="loading-objects-oracle-sql-loader.html#GUID-B769A8EC-48F4-4E8E-8896-2D7A5463112C" title="与LOB一样，可以从主数据文件（数据内联）或辅助数据文件（数据脱机）加载集合。">加载集合（嵌套表和VARRAY）</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div><a id="SUTIL1280"></a><div class="props_rev_3"><a id="GUID-9474C838-E6BF-4D4D-9EDF-56DBE0219737" name="GUID-9474C838-E6BF-4D4D-9EDF-56DBE0219737"></a><h3 id="SUTIL-GUID-9474C838-E6BF-4D4D-9EDF-56DBE0219737" class="sect3"><span class="enumeration_section">11.7</span>动态与静态SDF规范</h3>
               <div>
                  <p>您可以静态指定SDF（指定文件的实际名称）或动态指定（使用<code class="codeph">FILLER</code>字段作为文件名源）。
                  </p>
                  <p>在任何一种情况下，当达到SDF的EOF时，文件被关闭，并且进一步尝试从该特定文件读取数据产生的结果等同于从空字段读取数据。</p>
                  <p>在动态辅助文件规范中，此行为略有不同。每当规范更改为引用新文件时，旧文件将关闭，并从新引用的文件的开头读取数据。</p>
                  <p>动态切换数据源文件具有重置效果。例如，当SQL * Loader从当前文件切换到先前打开的文件时，将重新打开先前打开的文件，并从文件的开头读取数据。</p>
                  <p>您不应指定与两个不同字段的源相同的SDF。如果这样做，那么这两个字段通常会独立读取数据。</p>
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="loading-objects-oracle-sql-loader.html#GUID-A1828462-FD32-457C-976F-C85BA3A995DA" title="您可以使用SQL * Loader以各种格式加载列对象，并加载对象表，REF列，LOB和集合。">加载对象，LOB和集合</a></p>
                     </div>
                  </div>
               </div>
               
            </div><a id="SUTIL3401"></a><a id="SUTIL3403"></a><a id="SUTIL3400"></a><a id="SUTIL3402"></a><a id="SUTIL1281"></a><div class="props_rev_3"><a id="GUID-2D079012-0733-4172-AD8B-E97690CDFA34" name="GUID-2D079012-0733-4172-AD8B-E97690CDFA34"></a><h3 id="SUTIL-GUID-2D079012-0733-4172-AD8B-E97690CDFA34" class="sect3"><span class="enumeration_section">11.8</span>从子表中单独加载父表</h3>
               <div>
                  <p>加载包含嵌套表列的表时，可以从子表中单独加载父表。</p>
                  <div class="section">
                     <p>如果在加载时已知SID（系统生成的或用户定义的）（即，SID在包含数据的数据文件中），则可以单独加载父表和子表。</p>
                     <p>以下示例说明如何使用用户提供的SID加载父表和子表。</p>
                  </div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-2D079012-0733-4172-AD8B-E97690CDFA34__I1008679">
                     <p class="titleinexample">示例11-26使用用户提供的SID加载父表</p>
                     <p>控制文件内容</p><pre class="oac_no_warn" dir="ltr">LOAD DATA INFILE'cample.dat'“str'| \ n'”INTO TABLE dept FIELDS TERMINATED by'，'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''' mysid FILLER CHAR（32）， <span class="bold">1</span>个项目SID（mysid））</pre><p>数据文件（sample.dat）</p><pre class="oac_no_warn" dir="ltr">101，数学，21E978407D4441FCE03400400B403BC3，| 210， “拓扑”，21E978408D4441FCE03400400B403BC3，|</pre><div class="infoboxnote" id="GUID-2D079012-0733-4172-AD8B-E97690CDFA34__GUID-E37DB40E-33DA-47D0-9FB9-E7B10BE54352">
                        <p class="notep1">注意：</p>
                        <p>示例左侧的粗体标注对应于以下注释：</p>
                        <ol>
                           <li>
                              <p><code class="codeph">mysid</code>是一个填充字段，映射到包含实际集ID的数据文件字段，并作为<code class="codeph">SID</code>子句的参数提供。
                              </p>
                           </li>
                        </ol>
                     </div>
                  </div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-2D079012-0733-4172-AD8B-E97690CDFA34__I1008683">
                     <p class="titleinexample">示例11-27使用用户提供的SID加载子表</p>
                     <p>控制文件内容</p><pre class="oac_no_warn" dir="ltr">LOAD DATA INFILE'meample.dat'INTO TABLE dept FIELDS TERMINATED'，'''TRAILING NULLCOLS <span class="bold">1</span> SID（sidsrc）（project_id INTEGER EXTERNAL（5），project_name CHAR（20）NULLIF project_name = BLANKS，sidsrc FILLER CHAR（32））</pre><p>数据文件（sample.dat）</p><pre class="oac_no_warn" dir="ltr">21034，“Topological Transforms”，21E978407D4441FCE03400400B403BC3,77777，“Impossible Proof”，21E978408D4441FCE03400400B403BC3，</pre><div class="infoboxnote" id="GUID-2D079012-0733-4172-AD8B-E97690CDFA34__GUID-76CE1F3E-1E6A-44B8-A2D8-69863679F18D">
                        <p class="notep1">注意：</p>
                        <p>示例左侧的粗体标注对应于以下注释：</p>
                        <ol>
                           <li>
                              <p>表级<code class="codeph">SID</code>子句告诉SQL * Loader它正在为嵌套表加载存储表。 <code class="codeph">sidsrc</code>是填充字段名称，它是真实集ID的来源。
                              </p>
                           </li>
                        </ol>
                     </div>
                  </div>
                  <!-- class="example" -->
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="loading-objects-oracle-sql-loader.html#GUID-199895FD-ADF8-4B17-8F86-B92F92DA68DA">加载VARRAY列时的内存问题</a><br>加载<code class="codeph">VARRAY</code>列时存在一些内存问题。
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="loading-objects-oracle-sql-loader.html#GUID-A1828462-FD32-457C-976F-C85BA3A995DA" title="您可以使用SQL * Loader以各种格式加载列对象，并加载对象表，REF列，LOB和集合。">加载对象，LOB和集合</a></p>
                     </div>
                  </div>
               </div>
               <a id="SUTIL1282"></a><div class="props_rev_3"><a id="GUID-199895FD-ADF8-4B17-8F86-B92F92DA68DA" name="GUID-199895FD-ADF8-4B17-8F86-B92F92DA68DA"></a><h4 id="SUTIL-GUID-199895FD-ADF8-4B17-8F86-B92F92DA68DA" class="sect4"><span class="enumeration_section">11.8.1</span>加载VARRAY列时的内存问题</h4>
                  <div>
                     <p>加载<code class="codeph">VARRAY</code>列时存在一些内存问题。
                     </p>
                     <p>以下列表描述了加载<code class="codeph">VARRAY</code>列时要记住的一些问题：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">VARRAY</code>在加载到数据库之前在客户端的内存中创建。<code class="codeph">VARRAY</code>每个元素在加载到数据库之前需要4个字节的客户端内存。因此，当您加载<code class="codeph">VARRAY</code>万千的元素，你将需要至少4000个字节为每个客户端存储的<code class="codeph">VARRAY</code>实例，然后才能加载<code class="codeph">VARRAY</code> S插入数据库。在许多情况下，SQL * Loader需要两到三倍的内存量才能成功构建和加载<code class="codeph">VARRAY</code> 。</p>
                        </li>
                        <li>
                           <p><code class="codeph">BINDSIZE</code>参数指定SQL * Loader为加载记录分配的内存量。给定为<code class="codeph">BINDSIZE</code>指定的值，SQL * Loader会考虑要加载的每个字段的大小，并确定它可以在一个事务中加载的行数。行数越多，事务越少，从而产生更好的性能。但是，如果系统上的内存量有限，那么以性能为代价，可以为<code class="codeph">ROWS</code>指定比SQL * Loader计算的值更低的值。
                           </p>
                        </li>
                        <li>
                           <p>加载非常大的<code class="codeph">VARRAY</code>或大量较小的<code class="codeph">VARRAY</code>可能会导致在加载期间内存不足。如果发生这种情况，请为<code class="codeph">BINDSIZE</code>或<code class="codeph">ROWS</code>指定较小的值，然后重试加载。
                           </p>
                        </li>
                     </ul>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="loading-objects-oracle-sql-loader.html#GUID-2D079012-0733-4172-AD8B-E97690CDFA34" title="加载包含嵌套表列的表时，可以从子表中单独加载父表。">从子表中单独加载父表</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div>
         </div>
      </article>
   </body>
</html>