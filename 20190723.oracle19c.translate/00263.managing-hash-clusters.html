<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <meta name="abstract" content="Hash clusters can improve the performance of data retrieval."></meta>
      <meta name="description" content="Hash clusters can improve the performance of data retrieval."></meta>
      <title>管理哈希集群</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Database Administrator’s Guide "></meta>
      <meta property="og:description" content="Hash clusters can improve the performance of data retrieval."></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Database Administrator’s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="database-administrators-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-03-14T11:02:35-07:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="1996, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96348-04"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="managing-clusters.html" title="Previous" type="text/html"></link>
      <link rel="next" href="managing-views-sequences-and-synonyms.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Database Administrator&#39;s Guide"></meta>
    <meta name="dcterms.isVersionOf" content="ADMIN"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="managing-clusters.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="managing-views-sequences-and-synonyms.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">数据库管理员指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="schema-objects.html" property="item" typeof="WebPage"><span property="name">架构对象</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">管理哈希集群</li>
            </ol>
            <a id="GUID-EC3F7A6F-3648-48AA-8737-FFCC6E4964CF" name="GUID-EC3F7A6F-3648-48AA-8737-FFCC6E4964CF"></a><a id="ADMIN019"></a>
            
            <h2 id="ADMIN-GUID-EC3F7A6F-3648-48AA-8737-FFCC6E4964CF" class="sect2"><span class="enumeration_chapter">23</span>管理哈希集群</h2>
         </header>
         <div class="ind">
            <p>散列簇可以提高数据检索的性能。</p>
            <div>
               <ul class="ullinks">
                  <li class="ulchildlink"><a href="managing-hash-clusters.html#GUID-B8FF91C1-CE3A-4A97-9498-8CF977F6E32B">关于Hash Clusters</a><br>在散列集群中存储表是提高数据检索性能的可选方法。散列集群提供了具有索引或索引集群的非集群表的替代方法。
                  </li>
                  <li class="ulchildlink"><a href="managing-hash-clusters.html#GUID-EBACE54A-B7B2-4E87-9DC8-6CD99F056CBA">何时使用Hash Clusters</a><br>您可以通过对比散列对没有优势的情况最有用的情况来决定何时使用散列簇。如果您发现您的决定是使用索引而不是散列，则应考虑是单独存储表还是作为群集的一部分存储。
                  </li>
                  <li class="ulchildlink"><a href="managing-hash-clusters.html#GUID-42A592DE-99BB-4200-A225-4042EA1C2EA8">创建不同类型的哈希集群</a><br>您可以将<code class="codeph">CREATE CLUSTER</code>语句与<code class="codeph">HASHKEYS</code>子句一起使用来创建不同类型的哈希簇。
                  </li>
                  <li class="ulchildlink"><a href="managing-hash-clusters.html#GUID-80B46F3F-BBCE-4174-A5A8-F502CEE1DA89">改变哈希集群</a><br>您可以使用<code class="codeph">ALTER CLUSTER</code>语句更改散列簇。
                  </li>
                  <li class="ulchildlink"><a href="managing-hash-clusters.html#GUID-CA07C2B5-9087-433A-8498-4E8CEE634FB7">删除哈希集群</a><br>您可以使用<code class="codeph">DROP CLUSTER</code>语句删除哈希集群。
                  </li>
                  <li class="ulchildlink"><a href="managing-hash-clusters.html#GUID-70D53BAD-35C5-431D-997D-19A3E10F826B">哈希集群数据字典视图</a><br>您可以查询一组数据字典视图，以获取有关散列簇的信息。
                  </li>
               </ul>
               <div class="familylinks">
                  <div class="parentlink">
                     <p><strong>父主题：</strong> <a href="schema-objects.html#GUID-2DA8C61C-58B0-4892-8E5D-E7A9120BC120" title="您可以在Oracle数据库中创建和管理架构对象。">模式对象</a></p>
                  </div>
               </div>
            </div>
            <a id="ADMIN11756"></a><div class="props_rev_3"><a id="GUID-B8FF91C1-CE3A-4A97-9498-8CF977F6E32B" name="GUID-B8FF91C1-CE3A-4A97-9498-8CF977F6E32B"></a><h3 id="ADMIN-GUID-B8FF91C1-CE3A-4A97-9498-8CF977F6E32B" class="sect3"><span class="enumeration_section">23.1</span>关于Hash集群</h3>
               <div>
                  <p>在散列集群中存储表是提高数据检索性能的可选方法。散列集群提供了具有索引或索引集群的非集群表的替代方法。</p>
                  <p>使用索引表或索引集群，Oracle数据库使用数据库存储在单独索引中的键值来定位表中的行。要使用散列，您需要创建散列簇并将表加载到其中。数据库将表的行物理存储在散列簇中，并根据<span class="bold">散列函数</span>的结果检索它们。
                  </p>
                  <p>Oracle数据库使用哈希函数生成基于特定群集键值的数值分布（称为<span class="bold">哈希</span>值）。散列集群的键（如索引集群的键）可以是单列或复合键（多列键）。要在散列集群中查找或存储行，数据库会将散列函数应用于行的集群键值。生成的哈希值对应于集群中的数据块，然后数据库代表已发出的语句读取或写入。
                  </p>
                  <p>要在索引表或集群中查找或存储行，必须至少执行两个（通常有更多）I / O：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>一个或多个I / O用于在索引中查找或存储键值</p>
                     </li>
                     <li>
                        <p>另一个用于读取或写入表或集群中的行的I / O.</p>
                     </li>
                  </ul>
                  <p>相反，数据库使用散列函数来定位散列簇中的行;不需要I / O.因此，在散列簇中读取或写入行至少需要一个I / O操作。</p>
               </div>
               <div>
                  <div class="infoboxnotealso" id="GUID-B8FF91C1-CE3A-4A97-9498-8CF977F6E32B__GUID-65AC332D-F49A-402F-AC78-A1ADC18EC015">
                     <p class="notep1">也可以看看：</p>
                     <p>在尝试本章所述的任务之前，建议您阅读<a href="managing-space-for-schema-objects.html#GUID-1950156D-DECC-4E76-84D9-2C2A3D8D6565" title="管理模式对象的空间涉及诸如管理表空间警报和空间分配，回收未使用的空间，删除未使用的对象存储，监视空间使用和容量规划等任务。">模式对象的空间</a> 。
                     </p>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="managing-hash-clusters.html#GUID-EC3F7A6F-3648-48AA-8737-FFCC6E4964CF" title="散列簇可以提高数据检索的性能。">管理哈希群集</a></p>
                     </div>
                  </div>
               </div>
               
            </div><a id="ADMIN11757"></a><div class="props_rev_3"><a id="GUID-EBACE54A-B7B2-4E87-9DC8-6CD99F056CBA" name="GUID-EBACE54A-B7B2-4E87-9DC8-6CD99F056CBA"></a><h3 id="ADMIN-GUID-EBACE54A-B7B2-4E87-9DC8-6CD99F056CBA" class="sect3"><span class="enumeration_section">23.2</span>何时使用散列簇</h3>
               <div>
                  <p>您可以通过对比散列对没有优势的情况最有用的情况来决定何时使用散列簇。如果您发现您的决定是使用索引而不是散列，则应考虑是单独存储表还是作为群集的一部分存储。</p>
                  <div class="infoboxnote" id="GUID-EBACE54A-B7B2-4E87-9DC8-6CD99F056CBA__GUID-56796186-5BB4-4191-B9CD-EE315F6D2831">
                     <p class="notep1">注意：</p>
                     <p>即使您决定使用散列，表仍然可以在任何列上具有单独的索引，包括群集键。</p>
                  </div>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="managing-hash-clusters.html#GUID-5BB31441-AFA6-4136-8355-2471B9CD6D45">哈希有用的情况</a><br>当大多数查询是对群集密钥的相等查询并且散列群集中的表主要是静态大小时，散列很有用。
                     </li>
                     <li class="ulchildlink"><a href="managing-hash-clusters.html#GUID-43CFF0AF-2FF4-49FD-B2FF-C5B5199B314C">哈希不利的情况</a><br>在某些情况下，散列是不利的。
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="managing-hash-clusters.html#GUID-EC3F7A6F-3648-48AA-8737-FFCC6E4964CF" title="散列簇可以提高数据检索的性能。">管理哈希群集</a></p>
                     </div>
                  </div>
               </div>
               <a id="ADMIN11758"></a><div class="props_rev_3"><a id="GUID-5BB31441-AFA6-4136-8355-2471B9CD6D45" name="GUID-5BB31441-AFA6-4136-8355-2471B9CD6D45"></a><h4 id="ADMIN-GUID-5BB31441-AFA6-4136-8355-2471B9CD6D45" class="sect4"><span class="enumeration_section">23.2.1</span>哈希有用的情况</h4>
                  <div>
                     <p>当大多数查询是对群集密钥的相等查询并且散列群集中的表主要是静态大小时，散列很有用。</p>
                     <p>当您具有以下条件时，哈希很有用：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>大多数查询是群集密钥上的相等查询：</p><pre class="oac_no_warn" dir="ltr">选择 ...WHERE cluster_key = ...;</pre><p>在这种情况下，对相等条件中的簇密钥进行散列，并且通常在单次读取时找到相应的散列密钥。相比之下，对于索引表，必须首先在索引中找到键值（通常是几次读取），然后从表中读取行（另一次读取）。</p>
                        </li>
                        <li>
                           <p>散列集群中的表主要是静态的，因此您可以确定集群中表所需的行数和空间量。如果散列簇中的表需要比集群的初始分配更多的空间，则性能降低可能很大，因为需要溢出块。</p>
                        </li>
                     </ul>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="managing-hash-clusters.html#GUID-EBACE54A-B7B2-4E87-9DC8-6CD99F056CBA" title="您可以通过对比散列对没有优势的情况最有用的情况来决定何时使用散列簇。如果您发现您的决定是使用索引而不是散列，则应考虑是单独存储表还是作为群集的一部分存储。">何时使用散列集群</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADMIN11759"></a><div class="props_rev_3"><a id="GUID-43CFF0AF-2FF4-49FD-B2FF-C5B5199B314C" name="GUID-43CFF0AF-2FF4-49FD-B2FF-C5B5199B314C"></a><h4 id="ADMIN-GUID-43CFF0AF-2FF4-49FD-B2FF-C5B5199B314C" class="sect4"><span class="enumeration_section">23.2.2</span>散列<span class="enumeration_section">不利的</span>情况</h4>
                  <div>
                     <p>在某些情况下，散列是不利的。</p>
                     <p>在以下情况下散列是不利的：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>表上的大多数查询都会检索一系列群集键值的行。例如，在全表扫描或诸如以下的查询中，使用散列函数<a id="d230676e301" class="indexterm-anchor"></a>不能用于确定特定哈希键的位置。相反，必须完成等效的全表扫描才能获取查询的行。
                           </p><pre class="oac_no_warn" dir="ltr">选择 。 。 。WHERE cluster_key &lt;。 。 。;</pre><p>使用索引，键值在索引中排序，因此可以使用相对较少的I / O找到满足查询的<code class="codeph">WHERE</code>子句的簇键值。
                           </p>
                        </li>
                        <li>
                           <p>该表不是静态的，而是在不断增长。如果表无限制地增长，则无法预先确定表（其集群）生命周期内所需的空间。</p>
                        </li>
                        <li>
                           <p>应用程序经常在表上执行全表扫描，并且表格填充稀疏。在这种情况下的全表扫描在散列下需要更长的时间。</p>
                        </li>
                        <li>
                           <p>您无法预先分配散列簇最终需要的空间。</p>
                        </li>
                     </ul>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="managing-hash-clusters.html#GUID-EBACE54A-B7B2-4E87-9DC8-6CD99F056CBA" title="您可以通过对比散列对没有优势的情况最有用的情况来决定何时使用散列簇。如果您发现您的决定是使用索引而不是散列，则应考虑是单独存储表还是作为群集的一部分存储。">何时使用散列集群</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div>
            <div class="sect2"><a id="GUID-42A592DE-99BB-4200-A225-4042EA1C2EA8" name="GUID-42A592DE-99BB-4200-A225-4042EA1C2EA8"></a><h3 id="ADMIN-GUID-42A592DE-99BB-4200-A225-4042EA1C2EA8" class="sect3"><span class="enumeration_section">23.3</span>创建不同类型的哈希集群</h3>
               <p>您可以将<code class="codeph">CREATE CLUSTER</code>语句与<code class="codeph">HASHKEYS</code>子句一起使用来创建不同类型的哈希簇。
               </p>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="managing-hash-clusters.html#GUID-F7888417-6AE4-4ABC-B345-3E02E7E109A6">创建哈希集群</a><br>您可以使用<code class="codeph">CREATE CLUSTER</code>语句创建哈希集群，但是您指定了<code class="codeph">HASHKEYS</code>子句。
                     </li>
                     <li class="ulchildlink"><a href="managing-hash-clusters.html#GUID-ADB821B7-70D2-4829-956A-F74436754BCF">创建排序的哈希群集</a><br><span class="bold">排序的散列集群</span>以这样的方式存储与散列函数的每个值相对应的行，使得数据库可以按排序的顺序有效地返回它们。对于始终按排序顺序使用数据的应用程序，排序的散列簇可以通过最小化逻辑I / O来更快地检索数据。
                     </li>
                     <li class="ulchildlink"><a href="managing-hash-clusters.html#GUID-16DD280E-9CB0-4016-8492-87946A0B5CB9">创建单表哈希群集</a><br>您可以创建<span class="bold">单表哈希集群</span> ，该<span class="bold">集群</span>提供对表中行的快速访问。但是，此表必须是散列簇中唯一的表。
                     </li>
                     <li class="ulchildlink"><a href="managing-hash-clusters.html#GUID-F0131DBF-8763-4D37-8579-1A6ACE5BA0D0">控制哈希群集中的空间使用</a><br>创建哈希集群时，正确选择集群密钥并设置<code class="codeph">HASH IS</code> ， <code class="codeph">SIZE</code>和<code class="codeph">HASHKEYS</code>参数非常重要，这样才能最佳地使用性能和空间。以下准则描述了如何设置这些参数。
                     </li>
                     <li class="ulchildlink"><a href="managing-hash-clusters.html#GUID-97F5097B-366A-4168-B137-106F17ECC714">估计哈希集群所需的大小</a><br>与索引集群一样，估计散列集群中数据所需的存储量非常重要。
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="managing-hash-clusters.html#GUID-EC3F7A6F-3648-48AA-8737-FFCC6E4964CF" title="散列簇可以提高数据检索的性能。">管理哈希群集</a></p>
                     </div>
                  </div>
               </div>
               <a id="ADMIN11760"></a><div class="props_rev_3"><a id="GUID-F7888417-6AE4-4ABC-B345-3E02E7E109A6" name="GUID-F7888417-6AE4-4ABC-B345-3E02E7E109A6"></a><h4 id="ADMIN-GUID-F7888417-6AE4-4ABC-B345-3E02E7E109A6" class="sect4"><span class="enumeration_section">23.3.1</span>创建哈希集群</h4>
                  <div>
                     <p>您可以使用<code class="codeph">CREATE CLUSTER</code>语句创建哈希集群，但是您指定了<code class="codeph">HASHKEYS</code>子句。
                     </p>
                     <div class="section">
                        <p>以下语句创建名为<code class="codeph">trial_cluster</code>集群，该集群由<code class="codeph">trialno</code>列（集群密钥）集群：</p><pre class="oac_no_warn" dir="ltr">CREATE CLUSTER trial_cluster（trialno NUMBER（5,0））TABLESPACE用户存储（初始250K下一个50K MINEXTENTS 1 MAXEXTENTS 3 PCTINCREASE 0）HASH IS trialno HASHKEYS 150;</pre><p>以下语句在<code class="codeph">trial_cluster</code>散列集群中创建<code class="codeph">trial</code>表<a id="d230676e509" class="indexterm-anchor"></a> ：</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE试用版（trialno NUMBER（5,0）PRIMARY KEY，...）CLUSTER trial_cluster（trialno）;</pre><p>与索引集群一样，散列集群的密钥可以是单个列或复合键（多列密钥）。在前面的示例中，键是<code class="codeph">trialno</code>列。
                        </p>
                        <p><code class="codeph">HASHKEYS</code>值（在本例中为<code class="codeph">150</code> ）指定并限制散列函数可以生成的唯一散列值的数量。数据库将指定的数字四舍五入到最接近的素数。
                        </p>
                        <p>如果未指定<code class="codeph">HASH IS</code>子句，则数据库使用内部哈希函数。如果群集密钥已经是在其范围内均匀分布的唯一标识符，则可以绕过内部哈希函数并将群集密钥指定为哈希值，如上例所示。您还可以使用<code class="codeph">HASH IS</code>子句指定用户定义的哈希函数。
                        </p>
                        <p>您无法在哈希群集上创建群集索引，也无需在哈希群集密钥上创建索引。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-F7888417-6AE4-4ABC-B345-3E02E7E109A6__GUID-4F73549E-66B3-4C28-83FD-993A7CCEA972">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="managing-clusters.html#GUID-2EB6D65C-3DD8-4C92-A8B4-C05197B6CF2D" title="使用群集可以提高性能并减少磁盘空间需求。">管理群集</a>以获取有关在群集中创建表的其他信息，有关设置索引和散列群集通用的<code class="codeph">CREATE CLUSTER</code>语句参数的准则以及创建任何群集所需的特权</p>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="managing-hash-clusters.html#GUID-42A592DE-99BB-4200-A225-4042EA1C2EA8" title="您可以将CREATE CLUSTER语句与HASHKEYS子句一起使用来创建不同类型的哈希簇。">创建不同类型的哈希群集</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADMIN13463"></a><a id="ADMIN13464"></a><a id="ADMIN01901"></a><div class="props_rev_3"><a id="GUID-ADB821B7-70D2-4829-956A-F74436754BCF" name="GUID-ADB821B7-70D2-4829-956A-F74436754BCF"></a><h4 id="ADMIN-GUID-ADB821B7-70D2-4829-956A-F74436754BCF" class="sect4"><span class="enumeration_section">23.3.2</span>创建排序的哈希群集</h4>
                  <div>
                     <p><span class="bold">排序的散列集群</span>以这样的方式存储与散列函数的每个值相对应的行，使得数据库可以按排序的顺序有效地返回它们。对于始终按排序顺序使用数据的应用程序，排序的散列簇可以通过最小化逻辑I / O来更快地检索数据。
                     </p>
                     <div class="section">
                        <p>假设电信公司通过电信交换机存储固定数量的始发电话号码的详细呼叫记录。从每个始发电话号码可以有无限数量的呼叫。</p>
                        <p>应用程序在调用时存储调用记录。每个呼叫都有一个由时间戳标识的详细呼叫记录。例如，应用程序存储时间戳为0的呼叫记录，然后是带有时间戳1的呼叫记录，依此类推。</p>
                        <p>当为每个始发电话号码生成账单时，应用程序以先进先出（FIFO）顺序处理它们。下表显示了三个始发电话号码的示例详细信息：</p>
                        <div class="tblformal" id="GUID-ADB821B7-70D2-4829-956A-F74436754BCF__GUID-FA1312D8-375F-43C0-8DC0-9D90EA48EF14">
                           <table cellpadding="4" cellspacing="0" class="Formal" title="" width="100%" border="1" summary="Column 1 lists some telephone numbers, column 2 list corresponding call records." frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="50%" id="d230676e619">电话号码</th>
                                    <th align="left" valign="bottom" width="50%" id="d230676e622">CALL_TIMESTAMP</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="50%" id="d230676e627" headers="d230676e619 ">
                                       <p>6505551212</p>
                                    </td>
                                    <td align="left" valign="top" width="50%" headers="d230676e627 d230676e622 ">
                                       <p>0,1,2,3,4 ......</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="50%" id="d230676e634" headers="d230676e619 ">
                                       <p>6505551213</p>
                                    </td>
                                    <td align="left" valign="top" width="50%" headers="d230676e634 d230676e622 ">
                                       <p>0,1,2,3,4 ......</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="50%" id="d230676e641" headers="d230676e619 ">
                                       <p>6505551214</p>
                                    </td>
                                    <td align="left" valign="top" width="50%" headers="d230676e641 d230676e622 ">
                                       <p>0,1,2,3,4 ......</p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <p>在以下SQL语句中， <code class="codeph">telephone_number</code>列是散列键。散列簇在<code class="codeph">call_timestamp</code>和<code class="codeph">call_duration</code>列上排序。该示例对表定义中的聚类和排序列使用与群集定义中相同的名称，但这不是必需的。散列键的数量基于10位电话号码。
                        </p><pre class="oac_no_warn" dir="ltr">CREATE CLUSTER call_detail_cluster（telephone_number NUMBER，call_timestamp NUMBER SORT，call_duration NUMBER SORT）HASHKEYS 10000 HASH IS telephone_number SIZE 256; CREATE TABLE call_detail（telephone_number NUMBER，call_timestamp NUMBER SORT，call_duration NUMBER SORT，other_info VARCHAR2（30））CLUSTER call_detail_cluster（telephone_number，call_timestamp，call_duration）;</pre></div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-ADB821B7-70D2-4829-956A-F74436754BCF__CEGFGHHC">
                        <p class="titleinexample">示例23-1按顺序插入的数据</p>
                        <p>假设您使用FIFO顺序对<code class="codeph">call_detail</code>表进行种子处理，如本例所示。
                        </p><pre class="oac_no_warn" dir="ltr">INSERT INTO call_detail VALUES（6505551212,0,9，'misc info'）; INSERT INTO call_detail VALUES（6505551212,1,17，'misc info'）; INSERT INTO call_detail VALUES（6505551212,2,5，'misc info'）; INSERT INTO call_detail VALUES（6505551212,3,90，'misc info'）; INSERT INTO call_detail VALUES（6505551213,0,35，'misc info'）; INSERT INTO call_detail VALUES（6505551213,1,6，'misc info'）; INSERT INTO call_detail VALUES（6505551213,2,4，'misc info'）; INSERT INTO call_detail VALUES（6505551213,3,4，'misc info'）; INSERT INTO call_detail VALUES（6505551214,0,15，'misc info'）; INSERT INTO call_detail VALUES（6505551214,1,20，'misc info'）; INSERT INTO call_detail VALUES（6505551214,2,1，'misc info'）; INSERT INTO call_detail VALUES（6505551214,3,25，'misc info'）;承诺;</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-ADB821B7-70D2-4829-956A-F74436754BCF__CEGFDHEC">
                        <p class="titleinexample">例23-2查询call_detail</p>
                        <p>在此示例中，您将<code class="codeph">SET AUTOTRACE ON</code> ，然后在<code class="codeph">call_detail</code>表中查询电话号码<code class="codeph">6505551212</code>的呼叫详细信息。
                        </p><pre class="oac_no_warn" dir="ltr">SQL&gt; SET AUTOTRACE ON; SQL&gt; SELECT * FROM call_detail WHERE telephone_number = 6505551212; TELEPHONE_NUMBER CALL_TIMESTAMP CALL_DURATION OTHER_INFO ---------------- -------------- ------------- --- --------------------------- 6505551212 0 9 misc info 6505551212 1 17 misc info 6505551212 2 5 misc info 6505551212 3 90 misc info执行计划 - -------------------------------------------------- -------计划哈希值：2118876266 -------------------------------------- -------------------------------- | Id |操作|名称|行|字节|成本（％CPU）| -------------------------------------------------- -------------------- | 0 |选择声明| | 1 | 56 | 0（0）| | * 1 | TABLE ACCESS HASH | CALL_DETAIL | 1 | 56 | | -------------------------------------------------- --------------------</pre><p>即使查询计划中没有排序，查询也会检索按时间戳排序的行。</p>
                        <p>假设您删除现有行并按顺序插入相同的行：</p><pre class="oac_no_warn" dir="ltr">从call_detail删除; INSERT INTO call_detail VALUES（6505551213,3,4，'misc info'）; INSERT INTO call_detail VALUES（6505551214,0,15，'misc info'）; INSERT INTO call_detail VALUES（6505551212,0,9，'misc info'）; INSERT INTO call_detail VALUES（6505551214,1,20，'misc info'）; INSERT INTO call_detail VALUES（6505551214,2,1，'misc info'）; INSERT INTO call_detail VALUES（6505551213,1,6，'misc info'）; INSERT INTO call_detail VALUES（6505551213,2,4，'misc info'）; INSERT INTO call_detail VALUES（6505551214,3,25，'misc info'）; INSERT INTO call_detail VALUES（6505551212,1,17，'misc info'）; INSERT INTO call_detail VALUES（6505551212,2,5，'misc info'）; INSERT INTO call_detail VALUES（6505551212,3,90，'misc info'）; INSERT INTO call_detail VALUES（6505551213,0,35，'misc info'）;承诺;</pre><p>如果重新运行<code class="codeph">call_detail</code>的相同查询，则即使未指定<code class="codeph">ORDER BY</code>子句，数据库<code class="codeph">call_detail</code>再次按排序顺序检索行。由于数据库执行内部排序，因此查询计划中不显示<code class="codeph">SORT ORDER BY</code>操作。
                        </p>
                        <p>现在假设您创建一个非<code class="codeph">call_detail_nonclustered</code>簇表<code class="codeph">call_detail_nonclustered</code> ，然后在<a href="managing-hash-clusters.html#GUID-ADB821B7-70D2-4829-956A-F74436754BCF__CEGFGHHC">示例23-1中</a>使用相同的示例值加载它。要按排序顺序检索数据，必须使用<code class="codeph">ORDER BY</code>子句，如下所示：</p><pre class="oac_no_warn" dir="ltr">SQL&gt; SELECT * FROM call_detail_nonclustered WHERE telephone_number = 6505551212 2 ORDER BY call_timestamp，call_duration; TELEPHONE_NUMBER CALL_TIMESTAMP CALL_DURATION OTHER_INFO ---------------- -------------- ------------- --- --------------------------- 6505551212 0 9 misc info 6505551212 1 17 misc info 6505551212 2 5 misc info 6505551212 3 90 misc info执行计划 - -------------------------------------------------- -------计划哈希值：2555750302 -------------------------------------- -------------------------------------------- | Id |操作|名称|行|字节|成本（％CPU）|时间| -------------------------------------------------- -------------------------------- | 0 |选择声明| | 4 | 224 | 4（25）| 00:00:01 | | 1 |排序顺序| | 4 | 224 | 4（25）| 00:00:01 | | * 2 |表访问完全| CALL_DETAIL_NONCLUSTERED | 4 | 224 | 3（0）| 00:00:01 | -------------------------------------------------- --------------------------------</pre><p>前面的计划显示，在非聚集的情况下，排序比集群情况更昂贵。对于未存储在已排序散列簇中的表，行，字节，成本和时间都更大。</p>
                     </div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="managing-hash-clusters.html#GUID-42A592DE-99BB-4200-A225-4042EA1C2EA8" title="您可以将CREATE CLUSTER语句与HASHKEYS子句一起使用来创建不同类型的哈希簇。">创建不同类型的哈希群集</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADMIN11761"></a><div class="props_rev_3"><a id="GUID-16DD280E-9CB0-4016-8492-87946A0B5CB9" name="GUID-16DD280E-9CB0-4016-8492-87946A0B5CB9"></a><h4 id="ADMIN-GUID-16DD280E-9CB0-4016-8492-87946A0B5CB9" class="sect4"><span class="enumeration_section">23.3.3</span>创建单表哈希集群</h4>
                  <div>
                     <p>您可以创建<span class="bold">单表哈希集群</span> ，该<span class="bold">集群</span>提供对表中行的快速访问。但是，此表必须是散列簇中唯一的表。
                     </p>
                     <div class="section">
                        <p>实质上，散列键和数据行之间必须存在一对一的映射。以下语句创建一个名为<code class="codeph">peanut</code>的单表哈希集群，其集群密钥<code class="codeph">variety</code>如下：</p><pre class="oac_no_warn" dir="ltr">CREATE CLUSTER花生（品种号）SIZE 512 SINGLE TABLE HASHKEYS 500;</pre><p>数据库将<code class="codeph">HASHKEYS</code>值<code class="codeph">HASHKEYS</code>入到最接近的素数，因此该集群最多具有503个散列键值，每个值大小为512字节。<code class="codeph">SINGLE TABLE</code>子句仅对散列簇有效。还必须指定<code class="codeph">HASHKEYS</code> 。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-16DD280E-9CB0-4016-8492-87946A0B5CB9__GUID-9417EB45-209F-436E-94AD-8AC97AFC3C43">
                        <p class="notep1">也可以看看：</p>
                        <p>有关<code class="codeph">CREATE CLUSTER</code>语句语法的<a href="../sqlrf/CREATE-CLUSTER.html#SQLRF01201" target="_blank"><span class="italic">Oracle Database SQL语言参考</span></a></p>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="managing-hash-clusters.html#GUID-42A592DE-99BB-4200-A225-4042EA1C2EA8" title="您可以将CREATE CLUSTER语句与HASHKEYS子句一起使用来创建不同类型的哈希簇。">创建不同类型的哈希群集</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADMIN11762"></a><div class="props_rev_3"><a id="GUID-F0131DBF-8763-4D37-8579-1A6ACE5BA0D0" name="GUID-F0131DBF-8763-4D37-8579-1A6ACE5BA0D0"></a><h4 id="ADMIN-GUID-F0131DBF-8763-4D37-8579-1A6ACE5BA0D0" class="sect4"><span class="enumeration_section">23.3.4</span>控制散列簇内的空间使用</h4>
                  <p>创建哈希集群时，正确选择集群密钥并设置<code class="codeph">HASH IS</code> ， <code class="codeph">SIZE</code>和<code class="codeph">HASHKEYS</code>参数非常重要，这样才能最佳地使用性能和空间。以下准则描述了如何设置这些参数。
                  </p>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="managing-hash-clusters.html#GUID-860E5BAC-70D4-4081-BE2E-0595F9992173">选择密钥</a><br>选择正确的群集密钥取决于针对群集表发出的最常见查询类型。
                        </li>
                        <li class="ulchildlink"><a href="managing-hash-clusters.html#GUID-C7DF959C-D473-45AD-9B0E-F472CDBE6722">设置HASH IS</a><br>仅当群集密钥是<code class="codeph">NUMBER</code>数据类型的单个列并且包含均匀分布的整数时，才指定<code class="codeph">HASH IS</code>参数。
                        </li>
                        <li class="ulchildlink"><a href="managing-hash-clusters.html#GUID-902F3CF3-20A6-458D-A666-B11A2BC7C837">设置尺寸</a><br>应将<code class="codeph">SIZE</code>设置为保存任何给定散列键的所有行所需的平均空间量。
                        </li>
                        <li class="ulchildlink"><a href="managing-hash-clusters.html#GUID-B70C0F2E-7093-49A3-B9AD-25B78D4321B5">设置HASHKEYS</a><br>指定<code class="codeph">HASHKEYS</code>子句以创建散列簇并指定散列簇的散列值数。
                        </li>
                        <li class="ulchildlink"><a href="managing-hash-clusters.html#GUID-30BDD6AA-C41C-44CC-BC20-932101F03F7D">控制Hash集群中的空间</a><br>示例说明如何正确选择群集密钥并设置<code class="codeph">HASH IS</code> ， <code class="codeph">SIZE</code>和<code class="codeph">HASHKEYS</code>参数。对于所有示例，假设数据块大小为2K，并且平均而言，每个块的1950字节是可用数据空间（块大小减去开销）。
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="managing-hash-clusters.html#GUID-42A592DE-99BB-4200-A225-4042EA1C2EA8" title="您可以将CREATE CLUSTER语句与HASHKEYS子句一起使用来创建不同类型的哈希簇。">创建不同类型的哈希群集</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="ADMIN11763"></a><div class="props_rev_3"><a id="GUID-860E5BAC-70D4-4081-BE2E-0595F9992173" name="GUID-860E5BAC-70D4-4081-BE2E-0595F9992173"></a><h5 id="ADMIN-GUID-860E5BAC-70D4-4081-BE2E-0595F9992173" class="sect5"><span class="enumeration_section">23.3.4.1</span>选择密钥</h5>
                     <div>
                        <p>选择正确的群集密钥取决于针对群集表发出的最常见查询类型。</p>
                        <p>例如，考虑哈希集群中的<code class="codeph">emp</code>表。如果查询通常按员工编号选择行，则<code class="codeph">empno</code>列应为群集密钥。如果查询通常按部门编号选择行，则<code class="codeph">deptno</code>列应为群集密钥。对于包含单个表的散列簇，群集密钥通常是包含的表的完整主键。
                        </p>
                        <p>散列集群的键（如索引集群的键）可以是单个列或复合键（多列键）。具有组合键的哈希集群必须使用数据库的内部哈希函数。</p>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="managing-hash-clusters.html#GUID-F0131DBF-8763-4D37-8579-1A6ACE5BA0D0" title="在创建哈希集群时，正确选择集群密钥并设置HASH IS，SIZE和HASHKEYS参数非常重要，这样才能最佳地使用性能和空间。以下准则描述了如何设置这些参数。">控制散列集群中的空间使用</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="ADMIN11764"></a><div class="props_rev_3"><a id="GUID-C7DF959C-D473-45AD-9B0E-F472CDBE6722" name="GUID-C7DF959C-D473-45AD-9B0E-F472CDBE6722"></a><h5 id="ADMIN-GUID-C7DF959C-D473-45AD-9B0E-F472CDBE6722" class="sect5"><span class="enumeration_section">23.3.4.2</span>设置HASH IS</h5>
                     <div>
                        <p>仅当群集密钥是<code class="codeph">NUMBER</code>数据类型的单个列并且包含均匀分布的整数时，才指定<code class="codeph">HASH IS</code>参数。
                        </p>
                        <p>如果这些条件适用，则可以在集群中分发行，以便每个唯一的集群键值散列，而不会发生冲突（两个集群键值具有相同的散列值），这是唯一的散列值。如果这些条件不适用，请省略此子句，以便使用内部哈希函数。</p>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="managing-hash-clusters.html#GUID-F0131DBF-8763-4D37-8579-1A6ACE5BA0D0" title="在创建哈希集群时，正确选择集群密钥并设置HASH IS，SIZE和HASHKEYS参数非常重要，这样才能最佳地使用性能和空间。以下准则描述了如何设置这些参数。">控制散列集群中的空间使用</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="ADMIN11765"></a><div class="props_rev_3"><a id="GUID-902F3CF3-20A6-458D-A666-B11A2BC7C837" name="GUID-902F3CF3-20A6-458D-A666-B11A2BC7C837"></a><h5 id="ADMIN-GUID-902F3CF3-20A6-458D-A666-B11A2BC7C837" class="sect5"><span class="enumeration_section">23.3.4.3</span>设置SIZE</h5>
                     <div>
                        <p>应将<code class="codeph">SIZE</code>设置为保存任何给定散列键的所有行所需的平均空间量。
                        </p>
                        <p>因此，要正确确定<code class="codeph">SIZE</code> ，您必须了解数据的特征：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>如果散列簇只包含一个表，并且该表中行的散列键值是唯一的（每个值一行），则可以将<code class="codeph">SIZE</code>设置为集群中的平均行大小。
                              </p>
                           </li>
                           <li>
                              <p>如果散列簇要包含多个表，则可以将<code class="codeph">SIZE</code>设置为保存与代表散列值关联的所有行所需的平均空间量。
                              </p>
                           </li>
                        </ul>
                        <p>此外，一旦确定了<code class="codeph">SIZE</code>的（初步）值，请考虑以下因素。如果<code class="codeph">SIZE</code>值很小（可以为每个数据块分配超过四个哈希键），则可以在<code class="codeph">CREATE CLUSTER</code>语句中将此值用于<code class="codeph">SIZE</code> 。但是，如果<code class="codeph">SIZE</code>的值很大（可以为每个数据块分配四个或更少的哈希键），那么您还应该考虑预期的冲突频率以及数据检索的性能或空间使用效率对您来说更重要。
                        </p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>如果散列簇不使用内部散列函数（如果您指定了<code class="codeph">HASH IS</code> ）并且您预计很少或没有碰撞，则可以使用<code class="codeph">SIZE</code>的初始值。不会发生碰撞，并尽可能高效地使用空间。
                              </p>
                           </li>
                           <li>
                              <p>如果期望插入频繁发生冲突，则溢出块分配给存储行的可能性很高。为了减少溢出阻塞的可能性并在频繁发生碰撞时最大限度地提高性能，您应该调整<code class="codeph">SIZE</code> ，如下图所示。
                              </p>
                              <div class="tblformal" id="GUID-902F3CF3-20A6-458D-A666-B11A2BC7C837__GUID-9B408034-B68B-49D8-8DC1-7AD9C9596F5C">
                                 <table cellpadding="4" cellspacing="0" class="Formal" title="" width="90%" border="1" summary="This table helps you calculate a value for the SIZE clause. Column 1 lists a value calculated by: available size for each block/calculated size. Column 2 lists the recommended setting for size." frame="hsides" rules="rows">
                                    <thead>
                                       <tr align="left" valign="top">
                                          <th align="left" valign="bottom" width="50%" id="d230676e1153">每个块/计算尺寸的可用空间</th>
                                          <th align="left" valign="bottom" width="50%" id="d230676e1156">设置SIZE</th>
                                       </tr>
                                    </thead>
                                    <tbody>
                                       <tr align="left" valign="top">
                                          <td align="left" valign="top" width="50%" id="d230676e1161" headers="d230676e1153 ">
                                             <p>1</p>
                                          </td>
                                          <td align="left" valign="top" width="50%" headers="d230676e1161 d230676e1156 ">
                                             <p><code class="codeph">尺寸</code> 
                                             </p>
                                          </td>
                                       </tr>
                                       <tr align="left" valign="top">
                                          <td align="left" valign="top" width="50%" id="d230676e1170" headers="d230676e1153 ">
                                             <p>2</p>
                                          </td>
                                          <td align="left" valign="top" width="50%" headers="d230676e1170 d230676e1156 ">
                                             <p><code class="codeph">SIZE</code> + 15％</p>
                                          </td>
                                       </tr>
                                       <tr align="left" valign="top">
                                          <td align="left" valign="top" width="50%" id="d230676e1179" headers="d230676e1153 ">
                                             <p>3</p>
                                          </td>
                                          <td align="left" valign="top" width="50%" headers="d230676e1179 d230676e1156 ">
                                             <p><code class="codeph">SIZE</code> + 12％</p>
                                          </td>
                                       </tr>
                                       <tr align="left" valign="top">
                                          <td align="left" valign="top" width="50%" id="d230676e1188" headers="d230676e1153 ">
                                             <p>4</p>
                                          </td>
                                          <td align="left" valign="top" width="50%" headers="d230676e1188 d230676e1156 ">
                                             <p><code class="codeph">SIZE</code> + 8％</p>
                                          </td>
                                       </tr>
                                       <tr align="left" valign="top">
                                          <td align="left" valign="top" width="50%" id="d230676e1197" headers="d230676e1153 ">
                                             <p>&gt; 4</p>
                                          </td>
                                          <td align="left" valign="top" width="50%" headers="d230676e1197 d230676e1156 ">
                                             <p><code class="codeph">尺寸</code> 
                                             </p>
                                          </td>
                                       </tr>
                                    </tbody>
                                 </table>
                              </div>
                              <!-- class="inftblhruleinformal" -->
                              <p>过高估计<code class="codeph">SIZE</code>的值会增加群集中未使用的空间量。如果空间效率比数据检索的性能更重要，则忽略上表中显示的调整并使用<code class="codeph">SIZE</code>的原始值。</p>
                           </li>
                        </ul>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="managing-hash-clusters.html#GUID-F0131DBF-8763-4D37-8579-1A6ACE5BA0D0" title="在创建哈希集群时，正确选择集群密钥并设置HASH IS，SIZE和HASHKEYS参数非常重要，这样才能最佳地使用性能和空间。以下准则描述了如何设置这些参数。">控制散列集群中的空间使用</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="ADMIN11766"></a><div class="props_rev_3"><a id="GUID-B70C0F2E-7093-49A3-B9AD-25B78D4321B5" name="GUID-B70C0F2E-7093-49A3-B9AD-25B78D4321B5"></a><h5 id="ADMIN-GUID-B70C0F2E-7093-49A3-B9AD-25B78D4321B5" class="sect5"><span class="enumeration_section">23.3.4.4</span>设置HASHKEYS</h5>
                     <div>
                        <p>指定<code class="codeph">HASHKEYS</code>子句以创建散列簇并指定散列簇的散列值数。
                        </p>
                        <p>为了最大限度地分配散列簇中的行，数据库将<code class="codeph">HASHKEYS</code>值<code class="codeph">HASHKEYS</code>入到最接近的素数。
                        </p>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="managing-hash-clusters.html#GUID-F0131DBF-8763-4D37-8579-1A6ACE5BA0D0" title="在创建哈希集群时，正确选择集群密钥并设置HASH IS，SIZE和HASHKEYS参数非常重要，这样才能最佳地使用性能和空间。以下准则描述了如何设置这些参数。">控制散列集群中的空间使用</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="ADMIN11767"></a><div class="props_rev_3"><a id="GUID-30BDD6AA-C41C-44CC-BC20-932101F03F7D" name="GUID-30BDD6AA-C41C-44CC-BC20-932101F03F7D"></a><h5 id="ADMIN-GUID-30BDD6AA-C41C-44CC-BC20-932101F03F7D" class="sect5"><span class="enumeration_section">23.3.4.5</span>控制哈希集群中的空间</h5>
                     <p>示例说明如何正确选择群集密钥并设置<code class="codeph">HASH IS</code> ， <code class="codeph">SIZE</code>和<code class="codeph">HASHKEYS</code>参数。对于所有示例，假设数据块大小为2K，并且平均而言，每个块的1950字节是可用数据空间（块大小减去开销）。
                     </p>
                     <div>
                        <ul class="ullinks">
                           <li class="ulchildlink"><a href="managing-hash-clusters.html#GUID-43C0AB44-E263-4D8A-83C7-DA2C5E2816CC">控制哈希集群中的空间：示例1</a><br>一个示例说明了控制散列簇中的空间。
                           </li>
                           <li class="ulchildlink"><a href="managing-hash-clusters.html#GUID-9575192B-35B8-47FA-B025-6F2DBF658A8B">控制哈希集群中的空间：示例2</a><br>一个示例说明了控制散列簇中的空间。
                           </li>
                        </ul>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="managing-hash-clusters.html#GUID-F0131DBF-8763-4D37-8579-1A6ACE5BA0D0" title="在创建哈希集群时，正确选择集群密钥并设置HASH IS，SIZE和HASHKEYS参数非常重要，这样才能最佳地使用性能和空间。以下准则描述了如何设置这些参数。">控制散列集群中的空间使用</a></p>
                           </div>
                        </div>
                     </div>
                     <a id="ADMIN11768"></a><div class="props_rev_3"><a id="GUID-43C0AB44-E263-4D8A-83C7-DA2C5E2816CC" name="GUID-43C0AB44-E263-4D8A-83C7-DA2C5E2816CC"></a><h6 id="ADMIN-GUID-43C0AB44-E263-4D8A-83C7-DA2C5E2816CC" class="sect6"><span class="enumeration_section">23.3.4.5.1</span>控制散列簇中的空间：示例1</h6>
                        <div>
                           <p>一个示例说明了控制散列簇中的空间。</p>
                           <div class="section">
                              <p>您决定将<code class="codeph">emp</code>表加载到散列簇中。大多数查询按员工编号检索员工记录。您估计在任何给定时间<code class="codeph">emp</code>表中的最大行数是10000，并且平均行大小是55个字节。
                              </p>
                              <p>在这种情况下， <code class="codeph">empno</code>应该是群集密钥。由于此列包含唯一的整数，因此可以绕过内部哈希函数。<code class="codeph">SIZE</code>可以设置为平均行大小，55个字节。注意，为每个数据块分配了34个散列密钥。<code class="codeph">HASHKEYS</code>可以设置为表中的行数，10000。数据库将此值四舍五入到下一个最高素数：10007。
                              </p><pre class="oac_no_warn" dir="ltr">CREATE CLUSTER emp_cluster（empno NUMBER）。 。 。SIZE 55 HASH IS empno HASHKEYS 10000;</pre></div>
                           <!-- class="section" -->
                        </div>
                        <div>
                           <div class="familylinks">
                              <div class="parentlink">
                                 <p><strong>父主题：</strong> <a href="managing-hash-clusters.html#GUID-30BDD6AA-C41C-44CC-BC20-932101F03F7D" title="示例说明如何正确选择群集密钥并设置HASH IS，SIZE和HASHKEYS参数。对于所有示例，假设数据块大小为2K，并且平均而言，每个块的1950字节是可用数据空间（块大小减去开销）。">控制散列集群中的空间</a></p>
                              </div>
                           </div>
                        </div>
                        
                     </div><a id="ADMIN11769"></a><div class="props_rev_3"><a id="GUID-9575192B-35B8-47FA-B025-6F2DBF658A8B" name="GUID-9575192B-35B8-47FA-B025-6F2DBF658A8B"></a><h6 id="ADMIN-GUID-9575192B-35B8-47FA-B025-6F2DBF658A8B" class="sect6"><span class="enumeration_section">23.3.4.5.2</span>控制散列簇中的空间：例2</h6>
                        <div>
                           <p>一个示例说明了控制散列簇中的空间。</p>
                           <div class="section">
                              <p>在此示例中，条件类似于<span class="q">“ <a href="managing-hash-clusters.html#GUID-43C0AB44-E263-4D8A-83C7-DA2C5E2816CC" title="An example illustrates controlling space in hash clusters.">控制散列集群中的空间：示例1</a> ”中的<a href="managing-hash-clusters.html#GUID-43C0AB44-E263-4D8A-83C7-DA2C5E2816CC" title="一个示例说明了控制散列簇中的空间。">示例</a></span> 。但是，在这种情况下，行通常按部门编号检索。每个部门最多有1000个部门，平均有10名员工。部门编号增加10（0,10,20,30，...）。
                              </p>
                              <p>在这种情况下， <code class="codeph">deptno</code>应该是群集密钥。由于此列包含均匀分布的整数，因此可以绕过内部哈希函数。<code class="codeph">SIZE</code>的初始值（保存每个部门所有行所需的平均空间量）为55字节* 10或550字节。将此值用于<code class="codeph">SIZE</code> ，只能为每个数据块分配三个哈希键。如果您希望发生一些冲突并希望获得最大的数据检索性能，请略微改变您的估计<code class="codeph">SIZE</code>以防止冲突需要溢出块。通过将<code class="codeph">SIZE</code>调整12％，调整为620字节（参见<span class="q">“ <a href="managing-hash-clusters.html#GUID-902F3CF3-20A6-458D-A666-B11A2BC7C837" title="应将SIZE设置为保存任何给定散列键的所有行所需的平均空间量。">设置大小</a> ”</span> ），可以从预期的冲突中获得更多的行空间。
                              </p>
                              <p><code class="codeph">HASHKEYS</code>可以设置为唯一的部门编号1000。数据库将此值四舍五入到下一个最高素数：1009。
                              </p><pre class="oac_no_warn" dir="ltr">CREATE CLUSTER emp_cluster（deptno NUMBER）。 。 。SIZE 620 HASH是deptno HASHKEYS 1000;</pre></div>
                           <!-- class="section" -->
                        </div>
                        <div>
                           <div class="familylinks">
                              <div class="parentlink">
                                 <p><strong>父主题：</strong> <a href="managing-hash-clusters.html#GUID-30BDD6AA-C41C-44CC-BC20-932101F03F7D" title="示例说明如何正确选择群集密钥并设置HASH IS，SIZE和HASHKEYS参数。对于所有示例，假设数据块大小为2K，并且平均而言，每个块的1950字节是可用数据空间（块大小减去开销）。">控制散列集群中的空间</a></p>
                              </div>
                           </div>
                        </div>
                        
                     </div>
                  </div>
               </div><a id="ADMIN11770"></a><div class="props_rev_3"><a id="GUID-97F5097B-366A-4168-B137-106F17ECC714" name="GUID-97F5097B-366A-4168-B137-106F17ECC714"></a><h4 id="ADMIN-GUID-97F5097B-366A-4168-B137-106F17ECC714" class="sect4"><span class="enumeration_section">23.3.5</span>估计哈希集群所需的大小</h4>
                  <div>
                     <p>与索引集群一样，估计散列集群中数据所需的存储量非常重要。</p>
                     <div class="section">
                        <p>Oracle数据库保证初始空间分配足以根据设置<code class="codeph">SIZE</code>和<code class="codeph">HASHKEYS</code>存储哈希表。如果存储参数<code class="codeph">INITIAL</code> ， <code class="codeph">NEXT</code>和<code class="codeph">MINEXTENTS</code>未考虑哈希表大小，则会分配增量（附加）范围，直到达到至少<code class="codeph">SIZE*HASHKEYS</code> 。例如，假设数据块大小为2K，每个块的可用数据空间大约为1900字节（数据块大小减去开销），并且在<code class="codeph">CREATE CLUSTER</code>语句中指定了<code class="codeph">STORAGE</code>和<code class="codeph">HASH</code>参数，如下所示：</p><pre class="oac_no_warn" dir="ltr">存储（初始100K下一个150K MINEXTENTS 1 PCTINCREASE 0）SIZE 1500 HASHKEYS 100</pre><p>在此示例中，只能为每个数据块分配一个散列密钥。因此，散列簇所需的初始空间至少为100 * 2K或200K。存储参数的设置不考虑此要求。因此，初始范围100K和第二范围150K被分配给散列簇。</p>
                        <p>或者，假设<code class="codeph">HASH</code>参数指定如下：</p><pre class="oac_no_warn" dir="ltr">SIZE 500 HASHKEYS 100</pre><p>在这种情况下，为每个数据块分配三个散列键。因此，散列簇所需的初始空间至少为34 * 2K或68K。存储参数的初始设置足以满足此要求（初始范围为100K分配给散列簇）。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="managing-hash-clusters.html#GUID-42A592DE-99BB-4200-A225-4042EA1C2EA8" title="您可以将CREATE CLUSTER语句与HASHKEYS子句一起使用来创建不同类型的哈希簇。">创建不同类型的哈希群集</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div><a id="ADMIN11771"></a><div class="props_rev_3"><a id="GUID-80B46F3F-BBCE-4174-A5A8-F502CEE1DA89" name="GUID-80B46F3F-BBCE-4174-A5A8-F502CEE1DA89"></a><h3 id="ADMIN-GUID-80B46F3F-BBCE-4174-A5A8-F502CEE1DA89" class="sect3"><span class="enumeration_section">23.4</span>改变哈希集群</h3>
               <div>
                  <p>您可以使用<code class="codeph">ALTER CLUSTER</code>语句更改散列簇。
                  </p>
                  <div class="section">
                     <p>例如，以下<code class="codeph">ALTER CLUSTER</code>语句更改<code class="codeph">emp_dept</code>集群：</p><pre class="oac_no_warn" dir="ltr">ALTER CLUSTER emp_dept。 。 。;</pre><p>更改散列簇的含义与更改索引簇的含义相同，如<span class="q">“ <a href="managing-clusters.html#GUID-5EF6F303-F1AD-444F-9ADD-7436CB182AAB" title="您可以使用ALTER CLUSTER语句更改集群。">更改群集</a> ”中所述</span> 。但是，无法在<code class="codeph">ALTER CLUSTER</code>语句中指定<code class="codeph">SIZE</code> ， <code class="codeph">HASHKEYS</code>和<code class="codeph">HASH IS</code>参数。要更改这些参数，必须重新创建群集，然后从原始群集中复制数据。
                     </p>
                  </div>
                  <!-- class="section" -->
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="managing-hash-clusters.html#GUID-EC3F7A6F-3648-48AA-8737-FFCC6E4964CF" title="散列簇可以提高数据检索的性能。">管理哈希群集</a></p>
                     </div>
                  </div>
               </div>
               
            </div><a id="ADMIN11772"></a><div class="props_rev_3"><a id="GUID-CA07C2B5-9087-433A-8498-4E8CEE634FB7" name="GUID-CA07C2B5-9087-433A-8498-4E8CEE634FB7"></a><h3 id="ADMIN-GUID-CA07C2B5-9087-433A-8498-4E8CEE634FB7" class="sect3"><span class="enumeration_section">23.5</span>删除哈希集群</h3>
               <div>
                  <p>您可以使用<code class="codeph">DROP CLUSTER</code>语句删除哈希集群。
                  </p>
                  <div class="section">
                     <p>例如，以下<code class="codeph">DROP CLUSTER</code>语句删除<code class="codeph">emp_dept</code>集群：</p><pre class="oac_no_warn" dir="ltr">DROP CLUSTER emp_dept;</pre><p>使用<code class="codeph">DROP TABLE</code>语句删除散列集群中的<code class="codeph">DROP TABLE</code> 。在散列簇中删除散列簇和表的含义与删除索引簇的含义相同。
                     </p>
                  </div>
                  <!-- class="section" -->
               </div>
               <div>
                  <div class="infoboxnotealso" id="GUID-CA07C2B5-9087-433A-8498-4E8CEE634FB7__GUID-369431CB-A278-49BF-905B-F1473D534732">
                     <p class="notep1">也可以看看：</p>
                     <p><span class="q">“ <a href="managing-clusters.html#GUID-3E027CE1-1056-4750-B4DC-29E4CB6D095D" title="您可以使用DROP CLUSTER语句删除集群。">掉落集群</a> ”</span></p>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="managing-hash-clusters.html#GUID-EC3F7A6F-3648-48AA-8737-FFCC6E4964CF" title="散列簇可以提高数据检索的性能。">管理哈希群集</a></p>
                     </div>
                  </div>
               </div>
               
            </div><a id="ADMIN11773"></a><div class="props_rev_3"><a id="GUID-70D53BAD-35C5-431D-997D-19A3E10F826B" name="GUID-70D53BAD-35C5-431D-997D-19A3E10F826B"></a><h3 id="ADMIN-GUID-70D53BAD-35C5-431D-997D-19A3E10F826B" class="sect3"><span class="enumeration_section">23.6</span> Hash Clusters数据字典视图</h3>
               <div>
                  <p>您可以查询一组数据字典视图，以获取有关散列簇的信息。</p>
                  <div class="section">
                     <p>以下视图显示有关散列簇的信息：</p>
                  </div>
                  <!-- class="section" -->
                  <div class="tblformal" id="GUID-70D53BAD-35C5-431D-997D-19A3E10F826B__GUID-87D14440-8B3B-4C6E-9E04-6DCC83B5BD86">
                     <table cellpadding="4" cellspacing="0" class="Formal" title="" width="100%" border="1" summary="Column 1 lists the views that display information about hash clusters, column 2 describes each view." frame="hsides" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="44%" id="d230676e1811">视图</th>
                              <th align="left" valign="bottom" width="56%" id="d230676e1814">描述</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="44%" id="d230676e1819" headers="d230676e1811 ">
                                 <p><code class="codeph"><a href="../refrn/DBA_CLUSTERS.html#REFRN23039" target="_blank">DBA_CLUSTERS</a></code> 
                                 </p>
                                 <p><code class="codeph"><a href="../refrn/ALL_CLUSTERS.html#REFRN20039" target="_blank">ALL_CLUSTERS</a></code> 
                                 </p>
                                 <p><code class="codeph"><a href="../refrn/USER_CLUSTERS.html#REFRN26039" target="_blank">USER_CLUSTERS</a></code></p>
                              </td>
                              <td align="left" valign="top" width="56%" headers="d230676e1819 d230676e1814 ">
                                 <p><code class="codeph">DBA</code>视图描述<code class="codeph">DBA</code>中的所有集群（包括散列集群）。<code class="codeph">ALL</code>视图描述了用户可访问的所有群集。<code class="codeph">USER</code>视图仅限于用户拥有的群集。这些视图中的某些列包含由<code class="codeph">DBMS_STATS</code>包或<code class="codeph">ANALYZE</code>语句生成的统计信息。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="44%" id="d230676e1855" headers="d230676e1811 ">
                                 <p><code class="codeph"><a href="../refrn/DBA_CLU_COLUMNS.html#REFRN23037" target="_blank">DBA_CLU_COLUMNS</a></code> 
                                 </p>
                                 <p><code class="codeph"><a href="../refrn/USER_CLU_COLUMNS.html#REFRN26037" target="_blank">USER_CLU_COLUMNS</a></code> 
                                 </p>
                              </td>
                              <td align="left" valign="top" width="56%" headers="d230676e1855 d230676e1814 ">
                                 <p>这些视图将表列映射到集群列。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="44%" id="d230676e1872" headers="d230676e1811 ">
                                 <p><code class="codeph"><a href="../refrn/DBA_CLUSTER_HASH_EXPRESSIONS.html#REFRN23038" target="_blank">DBA_CLUSTER_HASH_EXPRESSIONS</a></code> 
                                 </p>
                                 <p><code class="codeph"><a href="../refrn/ALL_CLUSTER_HASH_EXPRESSIONS.html#REFRN20038" target="_blank">ALL_CLUSTER_HASH_EXPRESSIONS</a></code> 
                                 </p>
                                 <p><code class="codeph"><a href="../refrn/USER_CLUSTER_HASH_EXPRESSIONS.html#REFRN26038" target="_blank">USER_CLUSTER_HASH_EXPRESSIONS</a></code> 
                                 </p>
                              </td>
                              <td align="left" valign="top" width="56%" headers="d230676e1872 d230676e1814 ">
                                 <p>这些视图列出了散列簇的散列函数。</p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="managing-hash-clusters.html#GUID-EC3F7A6F-3648-48AA-8737-FFCC6E4964CF" title="散列簇可以提高数据检索的性能。">管理哈希群集</a></p>
                     </div>
                  </div>
               </div>
               
            </div>
         </div>
      </article>
   </body>
</html>