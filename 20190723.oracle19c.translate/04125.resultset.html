<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <title>结果集</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="JDBC Developer&#39;s Guide"></meta>
      <meta property="og:description" content=""></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="JDBC Developer&#39;s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="jdbc-developers-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-02-13T13:20:37-08:00"></meta>
      <meta name="dcterms.title" content="JDBC Developer&#39;s Guide"></meta>
      <meta name="dcterms.dateCopyrighted" content="1999, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96471-02"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="Oracle-collections.html" title="Previous" type="text/html"></link>
      <link rel="next" href="JDBC-Rowsets.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.isVersionOf" content="JJDBC"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="Oracle-collections.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="JDBC-Rowsets.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">JDBC开发人员指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="data-access-and-manipulation.html" property="item" typeof="WebPage"><span property="name">数据访问和操作</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">结果集</li>
            </ol>
            <a id="GUID-16116A5C-1A33-4F65-B9DD-1BDCE925343B" name="GUID-16116A5C-1A33-4F65-B9DD-1BDCE925343B"></a><a id="JJDBC28611"></a>
            
            <h2 id="JJDBC-GUID-16116A5C-1A33-4F65-B9DD-1BDCE925343B" class="sect2"><span class="enumeration_chapter">17</span>结果集</h2>
         </header>
         <div class="ind">
            <div>
               <p>Java Development Kit（JDK）中的标准Java数据库连接（JDBC）功能包括对结果集功能的增强，例如向前或向后处理，相对或绝对定位，查看内部或外部数据库的更改，以及更新结果集数据和然后将更改复制到数据库。</p>
               <p>本章讨论以下主题：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="resultset.html#GUID-41D05006-5470-4C1C-ACA0-A4B487B4D1C0">结果集支持的Oracle JDBC实现概述</a></p>
                  </li>
                  <li>
                     <p><a href="resultset.html#GUID-8CF0B30D-6201-4A26-8635-0DDD4449B27A">结果集限制和降级规则</a></p>
                  </li>
                  <li>
                     <p><a href="resultset.html#GUID-EADCCA6E-E90A-4CA5-9F0A-D68DA3E4163A">关于避免更新冲突</a></p>
                  </li>
                  <li>
                     <p><a href="resultset.html#GUID-BD27B43E-525F-44C4-973F-18D2BB8BA007">行获取大小</a></p>
                  </li>
                  <li>
                     <p><a href="resultset.html#GUID-264DC004-D0F0-4BD4-935C-438FD46DB412">关于Refetching Rows</a></p>
                  </li>
                  <li>
                     <p><a href="resultset.html#GUID-8360DD85-DBCE-485A-9E22-F7B7A5904D63">关于查看内部和外部的数据库更改</a></p>
                  </li>
               </ul>
            </div><a id="JJDBC28613"></a><a id="JJDBC28614"></a><a id="JJDBC28612"></a><div class="props_rev_3"><a id="GUID-41D05006-5470-4C1C-ACA0-A4B487B4D1C0" name="GUID-41D05006-5470-4C1C-ACA0-A4B487B4D1C0"></a><h3 id="JJDBC-GUID-41D05006-5470-4C1C-ACA0-A4B487B4D1C0" class="sect3"><span class="enumeration_section">17.1</span>结果集支持的Oracle JDBC实现概述</h3>
               <div>
                  <div class="section">
                     <p>本节讨论Oracle JDBC实现结果集支持的关键方面，通过使用客户端缓存来实现可滚动性，以及通过使用<code class="codeph">ROWID</code>来实现可更新性。
                     </p>
                     <p>客户可以实现自己的客户端缓存机制，Oracle提供了一个用于这样做的接口。</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-41D05006-5470-4C1C-ACA0-A4B487B4D1C0__GUID-01AC5CB7-BB44-44CE-947C-3DFE27661ED9">结果集可滚动性的Oracle JDBC实现</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p>因为底层服务器<span class="italic">不</span>支持滚动游标，甲骨文JDBC必须在单独的层实现滚动性。
                     </p>
                     <p>重要的是要意识到这是通过使用客户端内存缓存来存储可滚动结果集的行来实现的。</p>
                     <div class="infoboxnote" id="GUID-41D05006-5470-4C1C-ACA0-A4B487B4D1C0__GUID-9B41789F-4F04-404B-9D40-24F16CA291B0">
                        <p class="notep1">注意：</p>
                        <p>由于任何可滚动结果集的所有行都存储在客户端缓存中，因此结果集包含许多行，多列或非常大的列的情况可能会导致客户端Java虚拟机（JVM）失败。不要为大型结果集指定可滚动性。</p>
                     </div>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-41D05006-5470-4C1C-ACA0-A4B487B4D1C0__GUID-08094B4D-2ED1-4FB7-B07C-D14D7C57DE50">结果集可更新性的Oracle JDBC实现</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p>为了支持可更新性，Oracle JDBC使用<code class="codeph">ROWID</code>唯一标识出现在结果集中的数据库行。对于可更新结果集的每个查询，Oracle JDBC驱动程序会自动检索<code class="codeph">ROWID</code>以及您选择的列。
                     </p>
                     <div class="infoboxnote" id="GUID-41D05006-5470-4C1C-ACA0-A4B487B4D1C0__GUID-DEECF8A1-5238-4BE3-BA09-9F8BD3119E4A">
                        <p class="notep1">注意：</p>
                        <p>可更新性本身不需要客户端缓存。特别是，只可向前更新的结果集不需要客户端缓存。</p>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div>
            </div><a id="JJDBC28616"></a><a id="JJDBC28617"></a><a id="JJDBC28618"></a><a id="JJDBC28619"></a><a id="JJDBC28615"></a><div class="props_rev_3"><a id="GUID-8CF0B30D-6201-4A26-8635-0DDD4449B27A" name="GUID-8CF0B30D-6201-4A26-8635-0DDD4449B27A"></a><h3 id="JJDBC-GUID-8CF0B30D-6201-4A26-8635-0DDD4449B27A" class="sect3"><span class="enumeration_section">17.2结果集</span>限制和降级规则</h3>
               <div>
                  <div class="section">
                     <p>某些类型的结果集对于某些类型的查询是不可行的。如果为运行的查询指定了不可行的结果集类型或并发类型，则JDBC驱动程序将遵循一组规则来确定要使用的最佳可行类型。</p>
                     <p>实际结果集类型和并发类型是在运行语句时确定的，如果所需的结果集类型或并发类型不可行，驱动程序会在语句对象上发出<code class="codeph">SQLWarning</code> 。<code class="codeph">SQLWarning</code>对象将包含所请求类型不可行的原因。检查警告以验证是否收到了您请求的结果集类型。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-8CF0B30D-6201-4A26-8635-0DDD4449B27A__GUID-BFDF8097-D345-45D6-B977-40CB39564C6B">结果集限制</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p>对增强结果集的查询存在以下限制。如果不遵循这些准则，JDBC驱动程序将选择替代结果集类型或并发类型。</p>
                     <p>要生成可更新的结果集：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>查询只能从单个表中进行选择，并且不能包含任何连接操作。</p>
                           <p>此外，为了使插入可行，查询必须选择所有不可为空的列和所有没有默认值的列。</p>
                        </li>
                        <li>
                           <p>查询不能使用<code class="codeph">SELECT *</code> 。
                           </p>
                           <p>但是，有一个解决方法。</p>
                        </li>
                        <li>
                           <p>查询必须仅选择表列。</p>
                           <p>它不能选择派生列或聚合，例如一组列的<code class="codeph">SUM</code>或<code class="codeph">MAX</code> 。
                           </p>
                        </li>
                     </ul>
                     <p>要生成scr oll敏感的结果集：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>查询不能使用<code class="codeph">SELECT *</code> 。
                           </p>
                           <p>但是，有一个解决方法。</p>
                        </li>
                        <li>
                           <p>查询只能从一个表中进行选择。</p>
                        </li>
                     </ul>
                     <p>可滚动和可更新的结果集不能将任何列作为<code class="codeph">Stream</code> 。当服务器必须获取<code class="codeph">Stream</code>列时，它会将获取大小减小为1并阻止<code class="codeph">Stream</code>列之后的所有列，直到读取<code class="codeph">Stream</code>列。因此，无法批量提取列并滚动浏览。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-8CF0B30D-6201-4A26-8635-0DDD4449B27A__GUID-030C5DF2-DA56-4091-8002-3077632C2645">解决方法</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p>作为<code class="codeph">SELECT *</code>限制的变通方法，您可以使用表别名，如以下示例所示：</p><pre class="oac_no_warn" dir="ltr">选择t。* FROM TABLE t ...
</pre><div class="infoboxnote" id="GUID-8CF0B30D-6201-4A26-8635-0DDD4449B27A__GUID-FCF14CE8-725D-4B3B-AE2F-FEC770374F2A">
                        <p class="notep1">注意：</p>
                        <p>有一种简单的方法可以确定您的查询是否可能产生滚动敏感或可更新的结果集：如果您可以合法地将<code class="codeph">ROWID</code>列添加到查询列表，那么查询可能适用于滚动敏感或可更新结果集。
                        </p>
                     </div>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-8CF0B30D-6201-4A26-8635-0DDD4449B27A__GUID-ECB4DFDF-038A-4594-B5E8-291836D0367D">结果集降级规则</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p>如果指定的结果集类型或并发类型不可行，则Oracle JDBC驱动程序在选择备用类型时使用以下规则：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>如果指定的结果集类型为<code class="codeph">TYPE_SCROLL_SENSITIVE</code> ，但JDBC驱动程序无法满足该请求，则驱动程序会尝试降级为<code class="codeph">TYPE_SCROLL_INSENSITIVE</code> 。</p>
                        </li>
                        <li>
                           <p>如果指定或降级的结果集类型为<code class="codeph">TYPE_SCROLL_INSENSITIVE</code> ，但JDBC驱动程序无法满足该请求，则驱动程序会尝试降级为<code class="codeph">TYPE_FORWARD_ONLY</code> 。</p>
                        </li>
                        <li>
                           <p>如果指定的并发类型为<code class="codeph">CONCUR_UPDATABLE</code> ，但JDBC驱动程序无法满足该请求，则JDBC驱动程序会尝试降级为<code class="codeph">CONCUR_READ_ONLY</code> 。</p>
                        </li>
                     </ul>
                     <div class="infoboxnote" id="GUID-8CF0B30D-6201-4A26-8635-0DDD4449B27A__GUID-421E8A9F-17AC-4F4E-96CE-FA8016FFE254">
                        <p class="notep1">注意：</p>
                        <p>JDBC驱动程序对结果集类型和并发类型的任何操作都是相互独立的。</p>
                     </div>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-8CF0B30D-6201-4A26-8635-0DDD4449B27A__GUID-938ED844-5BB8-4425-8D49-36C652EC6E8B">验证结果集类型和并发类型</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p>运行查询后，可以通过调用结果集对象上的方法来验证JDBC驱动程序实际使用的结果集类型和并发类型。</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">int getType（）抛出SQLException</code></p>
                           <p>此方法返回用于查询的结果集类型的<code class="codeph">int</code>值。<code class="codeph">结果集。TYPE_FORWARD_ONLY</code> ， <code class="codeph">ResultSet.TYPE_SCROLL_SENSITIVE</code>或<code class="codeph">ResultSet.TYPE_SCROLL_INSENSITIVE</code>是可能的值。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">int getConcurrency（）抛出SQLException</code></p>
                           <p>此方法返回用于查询的并发类型的<code class="codeph">int</code>值。<code class="codeph">结果集。CONCUR_READ_ONLY</code>或<code class="codeph">ResultSet.CONCUR_UPDATABLE</code>是可能的值。
                           </p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
               </div>
            </div><a id="JJDBC28620"></a><div class="props_rev_3"><a id="GUID-EADCCA6E-E90A-4CA5-9F0A-D68DA3E4163A" name="GUID-EADCCA6E-E90A-4CA5-9F0A-D68DA3E4163A"></a><h3 id="JJDBC-GUID-EADCCA6E-E90A-4CA5-9F0A-D68DA3E4163A" class="sect3"><span class="enumeration_section">17.3</span>关于避免更新冲突</h3>
               <div>
                  <p>了解有关JDBC驱动程序的可更新结果集的以下事实非常重要：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>驱动程序不会对可更新结果集强制执行写锁定。</p>
                     </li>
                     <li>
                        <p>驱动程序不检查与结果集<code class="codeph">DELETE</code>或<code class="codeph">UPDATE</code>操作的冲突。
                        </p>
                     </li>
                  </ul>
                  <p>如果您尝试对另一个已提交事务更新的行执行<code class="codeph">DELETE</code>或<code class="codeph">UPDATE</code>操作，则会发生冲突。
                  </p>
                  <p>Oracle JDBC驱动程序使用<code class="codeph">ROWID</code>唯一标识数据库表中的行。只要当驱动程序尝试向数据库发送<code class="codeph">UPDATE</code>或<code class="codeph">DELETE</code>操作时<code class="codeph">ROWID</code>有效，就会运行该操作。
                  </p>
                  <p>驱动程序不会报告另一个已提交事务所做的任何更改。任何冲突都会被忽略，您的更改将覆盖以前的更改。</p>
                  <p>要避免此类冲突，请在运行生成结果集的查询时使用Oracle <code class="codeph">FOR UPDATE</code>功能。这样可以避免冲突，但也会阻止同时访问数据。在数据项上只能同时保存一个写锁。
                  </p>
               </div>
            </div><a id="JJDBC28621"></a><div class="props_rev_3"><a id="GUID-BD27B43E-525F-44C4-973F-18D2BB8BA007" name="GUID-BD27B43E-525F-44C4-973F-18D2BB8BA007"></a><h3 id="JJDBC-GUID-BD27B43E-525F-44C4-973F-18D2BB8BA007" class="sect3"><span class="enumeration_section">17.4</span>行获取大小</h3>
               <div>
                  <p>默认情况下，当Oracle JDBC运行查询时，它会从数据库游标中一次检索10行的结果集。这是默认的Oracle行提取大小值。您可以通过更改行获取大小值来更改每次访问数据库游标时检索的行数。</p>
                  <p>标准JDBC还允许您指定查询时每个数据库往返提取的行数，此数字称为提取大小。在Oracle JDBC中，行预取值用作语句对象中的缺省提取大小。设置提取大小会覆盖row-prefetch设置，并影响通过该语句对象运行的后续查询。</p>
                  <p>获取大小也用于结果集。当语句对象运行查询时，语句对象的提取大小将传递给查询生成的结果集对象。但是，您还可以在结果集对象中设置提取大小，以覆盖传递给它的语句提取大小。</p>
                  <div class="infoboxnote" id="GUID-BD27B43E-525F-44C4-973F-18D2BB8BA007__GUID-D098C24F-D641-4BFE-A6F7-296D1B407A8A">
                     <p class="notep1">注意：</p>
                     <p>生成结果集后对语句对象的提取大小所做的更改将不会影响该结果集。</p>
                  </div>
                  <p>结果集获取大小（显式设置）或默认值等于传递给它的语句提取大小，确定在该结果集的任何后续数据库中检索的行数。这包括完成原始查询仍需要的任何行程，以及将数据重新添加到结果集中的任何行程。可以显式或隐式地重新获取数据，以更新滚动敏感或滚动不敏感/可更新的结果集。</p>
               </div><a id="JJDBC28622"></a><div class="props_rev_3"><a id="GUID-51BCFF01-EFB5-4134-9D08-93BFDDA10B40" name="GUID-51BCFF01-EFB5-4134-9D08-93BFDDA10B40"></a><h4 id="JJDBC-GUID-51BCFF01-EFB5-4134-9D08-93BFDDA10B40" class="sect4"><span class="enumeration_section">17.4.1</span>设置获取大小</h4>
                  <div>
                     <div class="section">
                        <p>所有<code class="codeph">Statement</code> ， <code class="codeph">PreparedStatement</code> ， <code class="codeph">CallableStatement</code>和<code class="codeph">ResultSet</code>对象中都提供了以下方法，用于设置和获取提取大小：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">void setFetchSize（int rows）抛出SQLException</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">int getFetchSize（）抛出SQLException</code></p>
                           </li>
                        </ul>
                        <p>要设置查询的提取大小，请在运行查询之前在语句对象上调用<code class="codeph">setFetchSize</code> 。如果将获取大小设置为N，则每次访问数据库时都会获取N行。
                        </p>
                        <p>运行查询后，可以在结果集对象上调用<code class="codeph">setFetchSize</code>以覆盖传递给它的语句对象提取大小。这将影响任何后续的数据库访问，以获取原始查询的更多行，以及影响以后任何行的重新获取。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JJDBC28623"></a><div class="props_rev_3"><a id="GUID-CDDECEC2-3005-4A66-B5F5-5707DC37981F" name="GUID-CDDECEC2-3005-4A66-B5F5-5707DC37981F"></a><h4 id="JJDBC-GUID-CDDECEC2-3005-4A66-B5F5-5707DC37981F" class="sect4"><span class="enumeration_section">17.4.2</span>预设取指方向</h4>
                  <div>
                     <div class="section">
                        <p>标准JDBC允许预先指定方向，称为获取方向，以用于处理结果集。这允许JDBC驱动程序优化其处理。指定了以下结果集方法：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">void setFetchDirection（int direction）抛出SQLException</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">int getFetchDirection（）抛出SQLException</code></p>
                           </li>
                        </ul>
                        <p>Oracle JDBC驱动程序仅支持前向预设值，您可以通过输入<code class="codeph">ResultSet.来指定该<code class="codeph">ResultSet.FETCH_FORWARD</code>静态常量值。
                        </p>
                        <p>值<code class="codeph">ResultSet.FETCH_REVERSE</code>和<code class="codeph">ResultSet.不支持FETCH_UNKNOWN</code> 。尝试指定它们会导致SQL警告，并忽略设置。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="JJDBC28624"></a><div class="props_rev_3"><a id="GUID-264DC004-D0F0-4BD4-935C-438FD46DB412" name="GUID-264DC004-D0F0-4BD4-935C-438FD46DB412"></a><h3 id="JJDBC-GUID-264DC004-D0F0-4BD4-935C-438FD46DB412" class="sect3"><span class="enumeration_section">17.5</span>关于重新创建行</h3>
               <div>
                  <p>对于用于重新获取数据的某些类型的结果集，支持结果集<code class="codeph">refreshRow</code>方法。这包括返回数据库以从当前行开始重新获取对应于结果集中<span class="italic">n</span>行的数据库行，其中<span class="italic">n</span>是获取大小。这使您可以查看在结果集之外创建的数据库的最新更新，具体取决于封闭事务的隔离级别。
                  </p>
                  <p>由于重新获取仅重新获取与结果集中已有的行相对应的行，因此它不会对自原始查询以来在数据库中插入或删除的行执行任何操作。它会忽略已插入的行，即使从数据库中删除了相应的行，行仍将保留在结果集中。当尝试重新获取已在数据库中删除的行时，结果集中的相应行将保持其原始值。</p>
                  <div class="infoboxnote" id="GUID-264DC004-D0F0-4BD4-935C-438FD46DB412__GUID-83992638-31D8-4BD9-A8F4-EAD2A9D17DE7">
                     <p class="notep1">注意：</p>
                     <p>如果基于具有特定条件的查询声明<code class="codeph">TYPE_SCROLL_SENSITIVE</code>结果集，然后从外部更新该行以使列值不再与查询条件匹配，则驱动程序的行为就像已从数据库中删除该行并且该行不是通过发出的查询检索。因此，在调用<code class="codeph">refreshRow</code>方法时，您看不到特定行的更新。
                     </p>
                  </div>
                  <p>以下是<code class="codeph">refreshRow</code>方法的签名：</p><pre class="oac_no_warn" dir="ltr">void refreshRow（）抛出SQLException</pre><p>调用此方法时，您必须位于有效的当前行，而不是在行边界之外，而不是在插入行。</p>
                  <p>以下结果集类别支持<code class="codeph">refreshRow</code>方法：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>滚动敏感/只读</p>
                     </li>
                     <li>
                        <p>滚动敏感/更新</p>
                     </li>
                     <li>
                        <p>滚动不敏感/更新</p>
                     </li>
                  </ul>
                  <div class="infoboxnote" id="GUID-264DC004-D0F0-4BD4-935C-438FD46DB412__GUID-C0D61A15-01DE-4B84-A661-8CE091327277">
                     <p class="notep1">注意：</p>
                     <p>滚动敏感的结果集功能是通过对<code class="codeph">refreshRow</code>隐式调用<code class="codeph">refreshRow</code> 。
                     </p>
                  </div>
               </div>
            </div><a id="JJDBC28625"></a><div class="props_rev_3"><a id="GUID-8360DD85-DBCE-485A-9E22-F7B7A5904D63" name="GUID-8360DD85-DBCE-485A-9E22-F7B7A5904D63"></a><h3 id="JJDBC-GUID-8360DD85-DBCE-485A-9E22-F7B7A5904D63" class="sect3"><span class="enumeration_section">17.6</span>关于查看内部和外部数据库更改</h3>
               <div>
                  <p>本节讨论结果集查看以下内容的能力：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>自己对结果集进行更改，称为内部更改</p>
                     </li>
                     <li>
                        <p>从其他地方进行的更改，来自您在结果集外部的自己的事务，或来自其他已提交的事务，称为外部更改</p>
                     </li>
                  </ul>
                  <div class="infoboxnote" id="GUID-8360DD85-DBCE-485A-9E22-F7B7A5904D63__GUID-C7EC35EF-7726-4B80-B399-82BB6F63C1E9">
                     <p class="notep1">注意：</p>
                     <p>外部更改在标准JDBC规范中称为其他更改。</p>
                  </div>
                  <p>本节包括以下主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="resultset.html#GUID-71728FB5-5112-4204-B563-A40D8C5FD783">可见性与外部变化的检测</a></p>
                     </li>
                     <li>
                        <p><a href="resultset.html#GUID-261E6F26-6213-409E-B8E0-BA03A0F3A0F7">内部和外部变化可见性摘要</a></p>
                     </li>
                     <li>
                        <p><a href="resultset.html#GUID-F29ED77D-7BD2-4044-94F2-F53A0739701F">Oracle滚动敏感结果集的实现</a></p>
                     </li>
                  </ul>
               </div><a id="JJDBC28626"></a><div class="props_rev_3"><a id="GUID-71728FB5-5112-4204-B563-A40D8C5FD783" name="GUID-71728FB5-5112-4204-B563-A40D8C5FD783"></a><h4 id="JJDBC-GUID-71728FB5-5112-4204-B563-A40D8C5FD783" class="sect4"><span class="enumeration_section">17.6.1</span>可见性与外部变化的检测</h4>
                  <div>
                     <p>关于外部源对底层数据库所做的更改，关于本地结果集中更改的可见性，有两个相似但不同的概念：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>变化的可见性</p>
                        </li>
                        <li>
                           <p>检测变化</p>
                        </li>
                     </ul>
                     <p>“可见”更改意味着当您查看结果集中的某一行时，您可以看到外部源所做更改的新数据值到数据库中的相应行。</p>
                     <p>但是，“检测到”更改意味着结果集意识到这是一个新值，因为首先填充结果集。</p>
                     <p>即使Oracle结果集看到新数据（如滚动敏感结果集中的外部<code class="codeph">UPDATE</code> ，也不会意识到自填充结果集以来此数据已更改。未检测到此类更改。
                     </p>
                  </div>
               </div><a id="JJDBC28628"></a><a id="JJDBC28627"></a><div class="props_rev_3"><a id="GUID-261E6F26-6213-409E-B8E0-BA03A0F3A0F7" name="GUID-261E6F26-6213-409E-B8E0-BA03A0F3A0F7"></a><h4 id="JJDBC-GUID-261E6F26-6213-409E-B8E0-BA03A0F3A0F7" class="sect4"><span class="enumeration_section">17.6.2</span>内部和外部变化可见性摘要</h4>
                  <div>
                     <div class="section">
                        <p><a href="resultset.html#GUID-261E6F26-6213-409E-B8E0-BA03A0F3A0F7__g1026797" title="表">表17-1</a>总结了Oracle JDBC实现中的结果集对象如何看到通过结果集本身在内部进行的更改，以及从事务中其他位置或其他已提交事务对基础数据库进行的外部更改。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="tblformal" id="GUID-261E6F26-6213-409E-B8E0-BA03A0F3A0F7__g1026797">
                        <p class="titleintable">表17-1 Oracle JDBC的内部和外部更改的可见性</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="Oracle JDBC的内部和外部更改的可见性" width="100%" border="1" summary="table" frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="21%" id="d60274e833">结果集类型</th>
                                 <th align="left" valign="bottom" width="13%" id="d60274e836">可以看到内部删除？</th>
                                 <th align="left" valign="bottom" width="13%" id="d60274e839">可以看到内部更新吗？</th>
                                 <th align="left" valign="bottom" width="13%" id="d60274e842">可以看到内部INSERT？</th>
                                 <th align="left" valign="bottom" width="13%" id="d60274e845">可以看到外部删除？</th>
                                 <th align="left" valign="bottom" width="14%" id="d60274e848">可以看到外部更新吗？</th>
                                 <th align="left" valign="bottom" width="14%" id="d60274e851">可以看到外部INSERT？</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="21%" id="d60274e856" headers="d60274e833 ">
                                    <p>只进</p>
                                 </td>
                                 <td align="left" valign="top" width="13%" headers="d60274e856 d60274e836 ">
                                    <p>没有</p>
                                 </td>
                                 <td align="left" valign="top" width="13%" headers="d60274e856 d60274e839 ">
                                    <p>是</p>
                                 </td>
                                 <td align="left" valign="top" width="13%" headers="d60274e856 d60274e842 ">
                                    <p>没有</p>
                                 </td>
                                 <td align="left" valign="top" width="13%" headers="d60274e856 d60274e845 ">
                                    <p>没有</p>
                                 </td>
                                 <td align="left" valign="top" width="14%" headers="d60274e856 d60274e848 ">
                                    <p>没有</p>
                                 </td>
                                 <td align="left" valign="top" width="14%" headers="d60274e856 d60274e851 ">
                                    <p>没有</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="21%" id="d60274e878" headers="d60274e833 ">
                                    <p>滚动敏感</p>
                                 </td>
                                 <td align="left" valign="top" width="13%" headers="d60274e878 d60274e836 ">
                                    <p>是</p>
                                 </td>
                                 <td align="left" valign="top" width="13%" headers="d60274e878 d60274e839 ">
                                    <p>是</p>
                                 </td>
                                 <td align="left" valign="top" width="13%" headers="d60274e878 d60274e842 ">
                                    <p>没有</p>
                                 </td>
                                 <td align="left" valign="top" width="13%" headers="d60274e878 d60274e845 ">
                                    <p>没有</p>
                                 </td>
                                 <td align="left" valign="top" width="14%" headers="d60274e878 d60274e848 ">
                                    <p>是</p>
                                 </td>
                                 <td align="left" valign="top" width="14%" headers="d60274e878 d60274e851 ">
                                    <p>没有</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="21%" id="d60274e900" headers="d60274e833 ">
                                    <p>滚动不敏感</p>
                                 </td>
                                 <td align="left" valign="top" width="13%" headers="d60274e900 d60274e836 ">
                                    <p>是</p>
                                 </td>
                                 <td align="left" valign="top" width="13%" headers="d60274e900 d60274e839 ">
                                    <p>是</p>
                                 </td>
                                 <td align="left" valign="top" width="13%" headers="d60274e900 d60274e842 ">
                                    <p>没有</p>
                                 </td>
                                 <td align="left" valign="top" width="13%" headers="d60274e900 d60274e845 ">
                                    <p>没有</p>
                                 </td>
                                 <td align="left" valign="top" width="14%" headers="d60274e900 d60274e848 ">
                                    <p>没有</p>
                                 </td>
                                 <td align="left" valign="top" width="14%" headers="d60274e900 d60274e851 ">
                                    <p>没有</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <div class="section">
                        <div class="infoboxnote" id="GUID-261E6F26-6213-409E-B8E0-BA03A0F3A0F7__GUID-D07BE092-0156-4028-A3B2-1D6B43A94419">
                           <p class="notep1">注意：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>请记住，显式使用<code class="codeph">refreshRow</code>方法不同于外部更改的可见性概念。
                                 </p>
                              </li>
                              <li>
                                 <p>请记住，即使外部更改可见，与滚动敏感结果集下的<code class="codeph">UPDATE</code>操作一样，也不会检测到它们。结果集<code class="codeph">rowDeleted</code> ， <code class="codeph">rowUpdated</code>和<code class="codeph">rowInserted</code>方法始终返回<code class="codeph">false</code> 。
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JJDBC28629"></a><div class="props_rev_3"><a id="GUID-F29ED77D-7BD2-4044-94F2-F53A0739701F" name="GUID-F29ED77D-7BD2-4044-94F2-F53A0739701F"></a><h4 id="JJDBC-GUID-F29ED77D-7BD2-4044-94F2-F53A0739701F" class="sect4"><span class="enumeration_section">17.6.3</span>滚动敏感结果集的Oracle实现</h4>
                  <div>
                     <p>滚动敏感结果集的Oracle实现涉及wind ow的概念，窗口大小基于获取大小。窗口大小会影响结果集中行的更新频率。
                     </p>
                     <p>通过移动到指定行建立当前行后，该窗口由结果集中以该行开头的<span class="italic">n</span>行组成，其中<span class="italic">n</span>是结果集使用的提取大小。请注意，首次创建结果集时，没有当前行，因此没有窗口。默认位置在第一行之前，该行不是有效的当前行。
                     </p>
                     <p>当您从一行移动到另一行时，只要当前行保持在该窗口内，窗口就保持不变。但是，一旦移动到窗口外的新当前行，就会将窗口重新定义为以新的当前行开头的N行。</p>
                     <p>每当重新定义窗口时，数据库中与新窗口中的行对应的N行将通过对<code class="codeph">refreshRow</code>方法的隐式调用自动重新获取，从而在整个新窗口中更新数据。
                     </p>
                     <p>因此，外部更新在滚动敏感的结果集中不会立即可见。它们仅在刚刚描述的自动重新获取后可见。</p>
                     <div class="infoboxnote" id="GUID-F29ED77D-7BD2-4044-94F2-F53A0739701F__GUID-23FE8EAC-CAB1-44A7-8883-81021FA544DD">
                        <p class="notep1">注意：</p>
                        <p>这种重新获取不是一种高效或优化的方法，它具有重要的性能问题。在使用当前实现的滚动敏感结果集之前，请仔细考虑。灵敏度和性能之间也存在显着的折衷。最敏感的结果集是提取大小为1的结果集，这将导致每次在行之间移动时都会重新获取新的当前行。但是，这会对应用程序的性能产生重大影响。</p>
                     </div>
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>