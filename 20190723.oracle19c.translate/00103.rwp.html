<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <meta name="abstract" content="When you design applications for real world performance, you should consider how code for bind variables, instrumentation, and set-based processing."></meta>
      <meta name="description" content="When you design applications for real world performance, you should consider how code for bind variables, instrumentation, and set-based processing."></meta>
      <title>为Oracle真实世界性能设计应用程序</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Database Development Guide"></meta>
      <meta property="og:description" content="When you design applications for real world performance, you should consider how code for bind variables, instrumentation, and set-based processing."></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Database Development Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="database-development-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-31T23:23:15-08:00"></meta>
      <meta name="dcterms.title" content="Database Development Guide"></meta>
      <meta name="dcterms.dateCopyrighted" content="1996, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96334-02"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="performance-and-scalability.html" title="Previous" type="text/html"></link>
      <link rel="next" href="security.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.isVersionOf" content="ADFNS"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="performance-and-scalability.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="security.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">数据库开发指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="fundamentals.html" property="item" typeof="WebPage"><span property="name">数据库开发基础</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">为Oracle真实世界性能设计应用程序</li>
            </ol>
            <a id="GUID-754328E1-2203-4B03-A21B-A91C3E548233" name="GUID-754328E1-2203-4B03-A21B-A91C3E548233"></a>
            
            <h2 id="ADFNS-GUID-754328E1-2203-4B03-A21B-A91C3E548233" class="sect2"><span class="enumeration_chapter">4</span>为Oracle真实世界性能设计应用程序</h2>
         </header>
         <div class="ind">
            <div>
               <p>在为实际性能设计应用程序时，应考虑绑定变量，检测和基于集合的处理的代码。</p>
               <p>话题：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="rwp.html#GUID-D95280DE-969D-4B83-825E-ECC872C111EA" title="SQL语句或PL / SQL块中的绑定变量占位符指示必须在运行时提供数据的位置。">使用绑定变量</a></p>
                  </li>
                  <li>
                     <p><a href="rwp.html#GUID-20D3F573-B043-42A7-867D-0C1C0A0067AD">使用仪器</a></p>
                  </li>
                  <li>
                     <p><a href="rwp.html#GUID-83C28F26-45AE-492C-B42A-8F4F20770C33" title="数据仓库环境中的数据库应用程序中的常见任务是查询或修改庞大的数据集。">使用基于集合的处理</a></p>
                  </li>
               </ul>
            </div><a id="ADFNS179"></a><div class="props_rev_3"><a id="GUID-D95280DE-969D-4B83-825E-ECC872C111EA" name="GUID-D95280DE-969D-4B83-825E-ECC872C111EA"></a><h3 id="ADFNS-GUID-D95280DE-969D-4B83-825E-ECC872C111EA" class="sect3">使用绑定变量</h3>
               <div>
                  <p>SQL语句或PL / SQL块中的绑定变量占位符指示必须在运行时提供数据的位置。</p>
                  <div class="section">
                     <p>假设您希望应用程序将数据插入使用此语句创建的表中：</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE test（x VARCHAR2（30），y VARCHAR2（30））;</pre><p>由于直到运行时才知道数据，因此必须使用动态SQL。</p>
                     <p>以下语句在表<code class="codeph">test</code>插入一行，连接列x和y的字符串文字：</p><pre class="oac_no_warn" dir="ltr">INSERT INTO test（x，y）VALUES（'''|| REPLACE（x，'''，'''''）||'''''，'''||替换（y，'''，'''''''|| '''）;</pre><p>以下语句使用绑定变量将一行插入表<code class="codeph">test</code> <code class="codeph">:x</code>和<code class="codeph">:y</code>用于列x和y：</p><pre class="oac_no_warn" dir="ltr">INSERT INTO test（x，y）VALUES（：x，：y）;</pre><p>使用绑定变量占位符的语句更容易编码。</p>
                     <p>现在考虑使用上述每种方法在表<code class="codeph">test</code>中插入1,000行的动态批量加载操作。
                     </p>
                     <p>连接字符串文字的方法使用1,000个<code class="codeph">INSERT</code>语句，每个语句都必须经过硬解析，限定，检查安全性，优化和编译。因为每个语句都是硬解析的，所以锁存器的数量会大大增加。锁存器是互斥锁定机制 - 序列化设备，它会抑制并发性。
                     </p>
                     <p>使用绑定变量占位符的方法仅使用一个<code class="codeph">INSERT</code>语句。该语句经过软解析，限定，检查安全性，优化，编译和缓存在共享池中。共享池中的已编译语句用于1000个插入中的每个插入。此语句缓存是使用绑定变量的一个非常重要的好处。
                     </p>
                     <p>使用绑定变量占位符的应用程序具有更高的可伸缩性，支持更多用户，需要的资源更少，运行速度比使用字符串连接的应用程序更快 - 并且不易受SQL注入攻击。如果SQL语句使用字符串连接，则最终用户可以修改该语句并使用该应用程序执行有害的操作。</p>
                     <p>您可以在<code class="codeph">DELETE</code> ， <code class="codeph">INSERT</code> ， <code class="codeph">SELECT</code>和<code class="codeph">UPDATE</code>语句中以及可以使用表达式或文字的PL / SQL块中的任何位置使用绑定变量占位符。在PL / SQL中，您还可以将绑定变量占位符用于输出变量。绑定用于非查询操作中的输入和输出变量。
                     </p>
                     <div class="infoboxnotealso" id="GUID-D95280DE-969D-4B83-825E-ECC872C111EA__GUID-2E87E1B6-B4F4-420C-B711-6D32260F78E3">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>有关使用绑定变量保护应用程序免受SQL注入的更多信息，请参阅<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/adfns&amp;id=LNPLS646" target="_blank"><span class="italic">Oracle数据库PL / SQL语言参考</span></a></p>
                           </li>
                           <li>
                              <p>有关在OCI中使用绑定变量占位符的更多信息，请参阅<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/adfns&amp;id=LNOCI16342" target="_blank"><span class="italic">“Oracle调用接口程序员指南”</span></a></p>
                           </li>
                        </ul>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div>
            </div><a id="ADFNS162"></a><div class="props_rev_3"><a id="GUID-20D3F573-B043-42A7-867D-0C1C0A0067AD" name="GUID-20D3F573-B043-42A7-867D-0C1C0A0067AD"></a><h3 id="ADFNS-GUID-20D3F573-B043-42A7-867D-0C1C0A0067AD" class="sect3">使用仪器</h3>
               <div>
                  <p>使用检测意味着在整个应用程序中添加调试代码。启用后，此代码将生成跟踪文件，其中包含可帮助您识别和查找问题的信息。在调试多层应用程序时，跟踪文件特别有用;它们可以帮助您识别有问题的层。</p>
                  <div class="infoboxnotealso" id="GUID-20D3F573-B043-42A7-867D-0C1C0A0067AD__GUID-BDBC727F-773A-4F07-9405-F8EF4CB3946C">
                     <p class="notep1">也可以看看：</p>
                     <p><a href="performance-and-scalability.html#GUID-C1AD0758-6D69-4D2F-80BB-30BA6DA2DCF2">SQL跟踪工具（SQL_TRACE）</a>以获取更多信息</p>
                  </div>
               </div>
            </div>
            <div class="sect2"><a id="GUID-83C28F26-45AE-492C-B42A-8F4F20770C33" name="GUID-83C28F26-45AE-492C-B42A-8F4F20770C33"></a><h3 id="ADFNS-GUID-83C28F26-45AE-492C-B42A-8F4F20770C33" class="sect3">使用基于集合的处理</h3>
               <div>
                  <p>数据仓库环境中的数据库应用程序中的常见任务是查询或修改庞大的数据集。</p>
                  <p>例如，应用程序可能会连接数千行的数据集，过滤一组条件，执行聚合，然后将结果显示给用户。或者，应用程序可能会根据指定的条件从十亿行表中过滤掉行，然后将匹配的行插入另一个表中。</p>
                  <p>应用程序开发人员面临的问题是如何在处理这些大型数据集时实现高性能。处理技术分为两类：迭代和基于集合。经过多年的测试，Oracle Real-World Performance小组发现，基于集合的处理技术可以更好地处理处理大型数据集的数据库应用程序。</p>
                  <p>话题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="rwp.html#GUID-16CD8271-4959-41C2-9332-4FE21F54BA83" title="迭代数据处理逐行处理数据，使用数组或使用手动并行处理。">迭代数据处理</a></p>
                     </li>
                     <li>
                        <p><a href="rwp.html#GUID-83C28F26-45AE-492C-B42A-8F4F20770C33" title="数据仓库环境中的数据库应用程序中的常见任务是查询或修改庞大的数据集。">使用基于集合的处理</a></p>
                     </li>
                  </ul>
               </div>
               <div class="sect3"><a id="GUID-16CD8271-4959-41C2-9332-4FE21F54BA83" name="GUID-16CD8271-4959-41C2-9332-4FE21F54BA83"></a><h4 id="ADFNS-GUID-16CD8271-4959-41C2-9332-4FE21F54BA83" class="sect4">迭代数据处理</h4>
                  <div>
                     <p>迭代数据处理逐行处理数据，使用数组或使用手动并行处理。</p>
                     <p>话题：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="rwp.html#GUID-587B101A-CA9D-4F9F-AC67-E128D67DEB59" title="在这种类型的处理中，应用程序使用条件逻辑来遍历一组行。">关于迭代数据处理</a></p>
                        </li>
                        <li>
                           <p><a href="rwp.html#GUID-014A1091-206B-4455-B6BF-2E010C5E4655" title="在迭代技术中，逐行处理是最常见的。">迭代数据处理：逐行</a></p>
                        </li>
                        <li>
                           <p><a href="rwp.html#GUID-5B427623-E329-4BD5-9D60-B58B0C61A7C9" title="数组处理与逐行处理相同，只是它在每次迭代中处理一组行而不是单行。">迭代数据处理：数组</a></p>
                        </li>
                        <li>
                           <p><a href="rwp.html#GUID-413B3E68-5590-4337-956B-B6CFC11FC2DD" title="手动并行使用与逐行和数组处理相同的迭代算法，但允许多个服务器进程同时处理作业。">迭代数据处理：手动并行</a></p>
                        </li>
                     </ul>
                  </div>
                  <div class="sect4"><a id="GUID-587B101A-CA9D-4F9F-AC67-E128D67DEB59" name="GUID-587B101A-CA9D-4F9F-AC67-E128D67DEB59"></a><h5 id="ADFNS-GUID-587B101A-CA9D-4F9F-AC67-E128D67DEB59" class="sect5">关于迭代数据处理</h5>
                     <div>
                        <p>在这种类型的处理中，应用程序使用条件逻辑来遍历一组行。</p>
                        <p>您可以使用PL / SQL，Java或任何其他过程或面向对象语言编写迭代应用程序。该技术是“迭代的”，因为它将行源分成包含一行或多行的子组，然后处理每个子组。单个进程可以遍历所有子组，或者多个进程可以并行遍历子组。</p>
                        <p>通常，尽管不一定，迭代处理使用客户端/服务器模型，如下所示：</p>
                        <ol>
                           <li>
                              <p>将一组行从数据库服务器传输到客户端应用程序。</p>
                           </li>
                           <li>
                              <p>在客户端应用程序中处理该组。</p>
                           </li>
                           <li>
                              <p>将已处理的组传回数据库服务器。</p>
                           </li>
                        </ol>
                        <p>您可以使用三种主要技术实现迭代算法：逐行处理，数组处理和手动并行。每种技术都获得相同的结果，但从性能的角度来看，每种技术都有其优点和缺点。</p>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-014A1091-206B-4455-B6BF-2E010C5E4655" name="GUID-014A1091-206B-4455-B6BF-2E010C5E4655"></a><h5 id="ADFNS-GUID-014A1091-206B-4455-B6BF-2E010C5E4655" class="sect5">迭代数据处理：逐行</h5>
                     <div>
                        <p>在迭代技术中，逐行处理是最常见的。</p>
                        <p>单个进程循环遍历数据集，并且一次在单行上运行。在典型的实现中，应用程序从数据库中检索每一行，在中间层处理它，然后将该行发送回数据库，该数据库执行DML并提交。</p>
                        <p>假设你的功能需求是查询命名为外部表<code class="codeph">ext_scan_events</code> ，然后将其行到一个堆组织的临时表命名<code class="codeph">stage1_scan_events</code> 。以下PL / SQL块使用逐行技术来满足此要求：</p><pre class="oac_no_warn" dir="ltr">声明光标c是从ext_scan_events s中选择s。*; RC％ROWTYPE;开始c;循环获取c到r; c％未发现时退出;插入stage1_scan_events d值r;承诺;结束循环;关闭c;结束;</pre><p>逐行代码使用游标循环来执行以下操作：</p>
                        <ol>
                           <li>
                              <p>从<code class="codeph">ext_scan_events</code>获取<code class="codeph">ext_scan_events</code>到客户端主机中运行的应用程序，如果不存在更多行，则退出程序。
                              </p>
                           </li>
                           <li>
                              <p>将行插入<code class="codeph">stage1_scan_events</code> 。
                              </p>
                           </li>
                           <li>
                              <p>提交前面的插入。</p>
                           </li>
                           <li>
                              <p>返回第1步。</p>
                           </li>
                        </ol>
                        <p>逐行技术具有以下优点：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>它在小型数据集上表现良好。假设<code class="codeph">ext_scan_events</code>包含10,000条记录。如果应用程序在1毫秒内处理每一行，则总处理时间为10秒。
                              </p>
                           </li>
                           <li>
                              <p>循环算法对所有专业开发人员来说都很熟悉，易于编写，易于理解。</p>
                           </li>
                        </ul>
                        <p>逐行技术具有以下缺点：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>对于大型数据集，处理时间可能长得令人无法接受。如果<code class="codeph">ext_scan_events</code>包含10亿行，并且如果应用程序平均处理每行1毫秒，则总处理时间为12天。处理万亿行表需要<span class="italic">32年</span> 。
                              </p>
                           </li>
                           <li>
                              <p>应用程序串行执行，因此无法利用在现代硬件上运行的Oracle数据库的本机并行处理功能。例如，逐行技术无法从多核计算机，Oracle RAC或Oracle Exadata计算机中受益。例如，如果数据库主机包含16个CPU和32个核心，则当唯一的数据库服务器进程读取或写入每一行时，31个核心将处于空闲状态。如果Oracle RAC部署中存在多个实例，则只有一个实例可以处理数据。</p>
                           </li>
                        </ul>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-5B427623-E329-4BD5-9D60-B58B0C61A7C9" name="GUID-5B427623-E329-4BD5-9D60-B58B0C61A7C9"></a><h5 id="ADFNS-GUID-5B427623-E329-4BD5-9D60-B58B0C61A7C9" class="sect5">迭代数据处理：数组</h5>
                     <div>
                        <p>数组处理与逐行处理相同，只是它在每次迭代中处理一组行而不是单行。</p>
                        <p>与逐行技术一样，数组处理是串行的，这意味着一次只有一个数据库服务器进程对一组行进行操作。在典型的数组实现中，应用程序从数据库中检索每组行，在中间层处理它，然后将组发送回数据库，该数据库为行组执行DML，然后提交。</p>
                        <p>假设你的功能需求是一样的，在<span>迭代数据处理</span>的例子<span>：行到行</span> ：查询命名为外部表<code class="codeph">ext_scan_events</code> ，然后将其行到一个堆组织的临时表命名<code class="codeph">stage1_scan_events</code> 。以下PL / SQL块（在SQL * Plus中与数据库服务器不同的主机上执行）使用数组技术来满足此要求：</p><pre class="oac_no_warn" dir="ltr">声明光标c是从ext_scan_events s中选择s。*; type t是binary_integer的c％rowtype index表;在; rows binary_integer：= 0;开始c; loop fetch c bulk collect into limit array_size;当a.count = 0时退出; foall i in 1..a.count insert into stage1_scan_events d values a（i）;承诺;结束循环;关闭c;结束;</pre><p>前面的代码与<code class="codeph">FETCH</code>语句中使用<code class="codeph">BULK COLLECT</code>运算符的等效逐行代码不同，后者受<code class="codeph">PLS_INTEGER</code>类型的array_size值的限制。例如，如果array_size设置为100，则应用程序将以100为一组获取行。
                        </p>
                        <p>游标循环执行以下操作序列：</p>
                        <ol>
                           <li>
                              <p>从ext_scan_events获取行数组到客户端主机中运行的应用程序，或者在循环计数器等于0时退出程序。</p>
                           </li>
                           <li>
                              <p>循环遍历行数组，并将每一行插入<code class="codeph">stage1_scan_events</code>表。
                              </p>
                           </li>
                           <li>
                              <p>提交前面的插入。</p>
                           </li>
                           <li>
                              <p>返回第1步。</p>
                           </li>
                        </ol>
                        <p>在PL / SQL中，数组代码与使用计数器而不是游标属性<code class="codeph">c%notfound</code>的逐行代码不同，以测试退出条件。原因是如果fetch收集表中的最后一组行，则<code class="codeph">c%notfound</code>强制循环退出，这是不希望的行为。使用计数器时，每次获取都会收集指定的行数，当集合为空时，程序将退出。
                        </p>
                        <p>与逐行技术相比，阵列技术具有以下优点：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>该阵列使应用程序能够同时处理一组行，这意味着它可以减少网络往返， <code class="codeph">COMMIT</code>时间以及客户端和服务器中的代码路径。当组合时，这些因素可以潜在地将总处理时间减少一个数量级</p>
                           </li>
                           <li>
                              <p>数据库更有效，因为服务器进程批量插入，并在每组插入之后而不是在每次插入之后提交。减少提交次数可减少I / O负载并降低日志同步等待事件的可能性。</p>
                           </li>
                        </ul>
                        <p>该技术的缺点与逐行处理相同。处理时间对于大型数据集来说是不可接受的。对于万亿行表，将处理时间从32年减少到3年仍然是不可接受的。此外，应用程序必须在单个CPU内核上串行运行，因此无法利用Oracle数据库的本机并行性。</p>
                        <div class="infoboxnotealso" id="GUID-5B427623-E329-4BD5-9D60-B58B0C61A7C9__NOTE-1412-CBE0106F">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="rwp.html#GUID-014A1091-206B-4455-B6BF-2E010C5E4655" title="在迭代技术中，逐行处理是最常见的。">迭代数据处理：逐行</a></p>
                        </div>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-413B3E68-5590-4337-956B-B6CFC11FC2DD" name="GUID-413B3E68-5590-4337-956B-B6CFC11FC2DD"></a><h5 id="ADFNS-GUID-413B3E68-5590-4337-956B-B6CFC11FC2DD" class="sect5">迭代数据处理：手动并行</h5>
                     <div>
                        <p>手动并行使用与逐行和数组处理相同的迭代算法，但允许多个服务器进程同时处理作业。</p>
                        <p>在典型的实现中，应用程序多次扫描源数据，然后使用<code class="codeph">ORA_HASH</code>函数在并行插入进程之间划分数据。
                        </p>
                        <p><code class="codeph">ORA_HASH</code>函数计算给定表达式的哈希值。该函数接受三个参数：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph"><span class="codeinlineitalic">expr</span></code> ，通常是列名</p>
                           </li>
                           <li>
                              <p><code class="codeph"><span class="codeinlineitalic">max_bucket</span></code> ，指定散列桶的数量</p>
                           </li>
                           <li>
                              <p><code class="codeph"><span class="codeinlineitalic">seed_value</span></code> ，它允许来自相同数据的多个结果（默认值为0）</p>
                           </li>
                        </ul>
                        <p>例如，以下语句将sales表划分为10个行，编号为0到9，并返回存储桶1中的行：</p><pre class="oac_no_warn" dir="ltr">SELECT * FROM sales WHERE ORA_HASH（cust_id，9）= 1;</pre><p>如果应用程序以这种方式使用<code class="codeph">ORA_HASH</code> ，并且如果存在n个哈希桶，则每个服务器进程对1 / <span class="italic">n</span>数据进行操作。
                        </p>
                        <p>假设功能要求与逐行和数组示例相同：从源表读取扫描事件，然后将它们插入<code class="codeph">stage1_scan_events</code>表。主要区别如下：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>扫描事件存储在大量平面文件中。<code class="codeph">ext_scan_events_dets</code>表描述了这些平面文件。<code class="codeph">ext_scan_events_dets.file_seq_nbr</code>列存储数字主键， <code class="codeph">ext_file_name</code>列存储文件名。
                              </p>
                           </li>
                           <li>
                              <p>32个服务器进程必须并行运行，每个服务器进程查询不同的外部表。32个外部表被命名<code class="codeph">ext_scan_events_0</code>通过ext_scan_events_31。但是，每个服务器进程都插入到同一<code class="codeph">stage1_scan_events</code>表中。
                              </p>
                           </li>
                           <li>
                              <p>您可以通过执行同一PL / SQL程序的32个线程来使用PL / SQL来实现并行性，每个线程同时作为Oracle Scheduler管理的单独作业运行。工作是计划和计划的组合。</p>
                           </li>
                        </ul>
                        <p>以下PL / SQL代码（在SQL * Plus中与数据库服务器不同的主机上执行）使用手动并行：</p><pre class="oac_no_warn" dir="ltr">声明sqlstmt varchar2（1024）：= q'[ -  BEGIN嵌入式匿名块游标c是从ext_scan_events _ $ {thr} s中选择s。*; type t是binary_integer的c％rowtype index表;在; rows binary_integer：= 0;以r开头（从ext_scan_events_dets中选择ext_file_name，其中ora_hash（file_seq_nbr，$ {thrs}）= $ {thr}）循环执行立即'alter table ext_scan_events _ $ {thr} location'|| '（'|| r.ext_file_name ||'）';打开c; loop fetch c bulk collect into limit $ {array_size};当a.count = 0时退出; foall i in 1..a.count insert into stage1_scan_events d values a（i）;承诺; -  demo instrumentation rows：= rows + a.count;如果rows&gt; 1e3则在没有sd_control.p_progress（'loading'，'userdefined'，rows）时退出; rows：= 0;万一;结束循环;关闭c;结束循环;结束; -  END嵌入匿名块]'; begin sqlstmt：= replace（sqlstmt，'$ {array_size}'，to_char（array_size））; sqlstmt：= replace（sqlstmt，'$ {thr}'，thr）; sqlstmt：= replace（sqlstmt，'$ {thrs}'，thrs）;执行立即sqlstmt;结束;</pre><p>这个程序有三个迭代结构，从外到内：</p>
                        <ol>
                           <li>
                              <p>外部<code class="codeph">FOR LOOP</code> ，用于检索平面文件的名称，并使用DDL将平面文件名指定为外部表的位置</p>
                           </li>
                           <li>
                              <p>中间<code class="codeph">LOOP</code>语句，用于从外部表的查询中提取行组。
                              </p>
                           </li>
                           <li>
                              <p>最内层的<code class="codeph">FORALL</code>语句，它遍历每个组并插入行</p>
                           </li>
                        </ol>
                        <p>在此示例程序中，您在每个作业中将<code class="codeph">$thrs</code>设置<code class="codeph">$thrs</code> 31，并在每个作业中将<code class="codeph">$thr</code>设置<code class="codeph">$thr</code> 0到31之间的其他值。例如，作业1可能将<code class="codeph">$thr</code>设置为0，作业2可能将<code class="codeph">$thr</code>设置为1，依此类推。
                        </p>
                        <p>在第一个作业执行的程序中，$ thr设置为0，外部<code class="codeph">FOR LOOP</code>迭代以下查询的结果：</p><pre class="oac_no_warn" dir="ltr">从ext_scan_events_dets中选择ext_file_name，其中ora_hash（file_seq_nbr，31）= 0</pre><p><code class="codeph">ORA_HASH</code>函数将<code class="codeph">ext_scan_events_dets</code>表划分为32个均匀分布的存储桶，然后<code class="codeph">SELECT</code>语句检索存储桶0的文件名。例如，查询结果集可能包含以下文件名：</p><pre class="oac_no_warn" dir="ltr">/ disk1 / scan_ev_101 / disk2 / scan_ev_003 / disk1 / scan_ev_077 .../磁盘4 / scan_ev_314</pre><p>中间<code class="codeph">LOOP</code>遍历文件名列表。例如，结果集中的第一个文件名可能是<code class="codeph">/disk1/scan_ev_101</code> 。对于作业1，外部表名为<code class="codeph">ext_scan_events_0</code> ，因此<code class="codeph">LOOP</code>的第一次迭代会更改此表的位置，如下所示：</p><pre class="oac_no_warn" dir="ltr">alter table ext_scan_events_0 location（/ disk1 / scan_ev_101）;</pre><p>在最里面的<code class="codeph">FORALL</code>语句中， <code class="codeph">BULK COLLECT</code>运算符将<code class="codeph">ext_scan_events_0</code>表中的行检索到数组中，将行插入<code class="codeph">stage1_scan_events</code>表，然后提交批量插入。当程序退出<code class="codeph">FORALL</code>语句时，程序将继续执行循环中的下一项，将外部表的文件位置更改为<code class="codeph">/disk2/scan_ev_003</code> ，然后像上一次迭代一样查询，插入和提交行。作业1以这种方式继续处理，直到包含在与散列桶0对应的平面文件中的所有记录已插入<code class="codeph">stage1_scan_events</code>表中。
                        </p>
                        <p>当作业1正在执行时，其他31个Oracle Scheduler作业并行执行。例如，作业2将<code class="codeph">$thr</code>设置<code class="codeph">$thr</code> 1，它将游标定义为表<code class="codeph">ext_scan_events_1</code>的查询， <code class="codeph">ext_scan_events_1</code> ，通过作业32，将<code class="codeph">$thr</code>设置<code class="codeph">$thr</code> 31并将游标定义为表<code class="codeph">ext_scan_events_31</code>的查询。通过这种方式，每个作业同时读取扫描事件文件的不同子集，并将其子集中的记录插入到同一<code class="codeph">stage1_scan_events</code>表中。
                        </p>
                        <p>与其他迭代技术相比，手动并行技术具有以下优点：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>它在大型数据集上的表现要好得多，因为服务器进程并行工作。例如，如果32个进程正在划分工作，并且如果数据库具有足够的CPU和内存资源并且没有遇到争用，则数据库可能会在阵列技术执行单个作业所花费的时间内执行32个插入作业。大数据集的性能增益通常比串行技术大一个数量级。</p>
                           </li>
                           <li>
                              <p>当应用程序使用<code class="codeph">ORA_HASH</code>分配工作负载时，每个执行线程都可以访问相同数量的数据。如果每个线程读取和写入相同数量的数据，则并行进程可以同时完成，这意味着只要应用程序运行，数据库就会使用硬件。
                              </p>
                           </li>
                        </ul>
                        <p>手动并行技术具有以下缺点：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>代码相对冗长，复杂且难以理解。该算法很复杂，因为在许多线程上分配工作负载的工作落在开发人员而不是数据库上。实际上，应用程序并行运行串行算法而不是运行并行算法。</p>
                           </li>
                           <li>
                              <p>通常，划分数据的启动成本具有固定的开销。在数据库开始主要工作之前，应用程序必须执行一定量的准备工作，主要工作是并行处理行。此启动限制不适用于不分割数据的竞争技术。</p>
                           </li>
                           <li>
                              <p>如果多个线程对一组公共数据库对象执行相同的操作，则可以进行锁定和锁存争用。例如，如果32个不同的服务器进程正在尝试更新同一组缓冲区，则缓冲区忙等待是可能的。此外，如果多个服务器进程几乎同时发出<code class="codeph">COMMIT</code>语句，则可能是日志文件同步等待。
                              </p>
                           </li>
                           <li>
                              <p>与竞争迭代技术相比，并行处理消耗大量CPU资源。如果数据库主机没有足够的内核可用于同时处理线程，则性能会受到影响。例如，如果只有4个内核可用于32个线程，那么在给定时间内具有CPU可用的线程的概率是1/8。</p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-49AA324B-A060-4284-9841-A6E27DB9E45C" name="GUID-49AA324B-A060-4284-9841-A6E27DB9E45C"></a><h4 id="ADFNS-GUID-49AA324B-A060-4284-9841-A6E27DB9E45C" class="sect4">基于集合的处理</h4>
                  <div>
                     <p>基于集合的处理是一种处理数据库内数据集的SQL技术。</p>
                     <p>在基于集合的模型中，SQL语句定义结果，并允许数据库确定获取它的最有效方法。相反，迭代算法使用条件逻辑将每行或每组行从数据库拉到客户端应用程序，处理客户端上的数据，然后将数据发送回数据库。基于集合的处理消除了网络往返和数据库API开销，因为数据永远不会离开数据库。它减少了COMMIT的数量。</p>
                     <p>假设与前面的例子中相同的功能要求。以下SQL语句使用基于集合的算法满足此要求：</p><pre class="oac_no_warn" dir="ltr">alter session enable parallel dml;插入/ * + APPEND * / into stage1_scan_events d从ext_scan_events s中选择s。*;承诺;</pre><p>由于<code class="codeph">INSERT</code>语句包含<code class="codeph">ext_scan_events</code>表的子查询，因此<span class="italic">单个</span> SQL语句将读取和写入所有行。此外，应用程序在数据库插入所有行后执行<span class="italic">单个</span> <code class="codeph">COMMIT</code> 。相反，迭代应用程序在插入每行或每组行之后执行<code class="codeph">COMMIT</code> 。
                     </p>
                     <p>基于集合的技术与迭代技术相比具有明显的优势：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>正如Oracle Real-World Performance演示和类中所示，大型数据集的性能要快几个数量级。程序的运行时间从几小时降到几秒并不罕见。大数据集性能的提高是如此深刻，以至于迭代技术变得非常难以证明。</p>
                        </li>
                        <li>
                           <p>处理速度急剧增加的副作用是DBA可以消除长时间运行且容易出错的批处理作业，并实时创新业务流程。例如，企业可以在白天根据需要运行12秒的作业，而不是每晚运行6小时的批处理作业。</p>
                        </li>
                        <li>
                           <p>代码的长度明显更短，只需要两到三行代码，因为SQL定义了结果而不是访问方法。这意味着数据库而不是应用程序决定了划分，检索和操作行的最佳方法。</p>
                        </li>
                        <li>
                           <p>与手动并行性相比，并行DML针对性能进行了优化，因为数据库而不是应用程序管理进程。因此，没有必要在客户端应用程序中手动划分工作负载，并希望每个进程同时完成。</p>
                        </li>
                        <li>
                           <p>加入数据集时，数据库会自动使用高效的散列连接，而不是相对低效的应用程序级循环。</p>
                        </li>
                        <li>
                           <p><code class="codeph">APPEND</code>提示强制直接路径加载，这意味着数据库不会创建重做和撤消，从而避免浪费I / O和CPU。在典型的ETL工作负载中，缓冲区高速缓存存在问题。修改缓冲区高速缓存中的数据，然后写回数据及其关联的撤消和重做，会消耗大量资源。因为缓冲区缓存不能足够快地管理块，并且因为操作块进入缓冲区缓存并再次退出（通常一次只有一个8 K块）的CPU成本很高，所以数据库编写器和服务器进程都必须极其努力跟上缓冲量。
                           </p>
                        </li>
                     </ul>
                     <p>基于集合的处理的缺点：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>许多数据库开发人员都不熟悉这些技术，因此它们更加困难。<code class="codeph">INSERT</code>示例相对简单。但是，更复杂的算法需要更复杂的语句，可能需要多个外连接。不熟悉流水线外连接以及使用<code class="codeph">WITH</code>子句和<code class="codeph">CASE</code>语句的开发人员可能会被写入和理解基于集合的代码的前景所吓倒。
                           </p>
                        </li>
                        <li>
                           <p>因为基于集合的模型与迭代模型完全不同，所以更改它需要完全重写源代码。相反，将逐行代码更改为基于数组的代码相对简单。</p>
                        </li>
                     </ul>
                     <p>尽管基于集合的处理存在缺点，但Oracle Real-World Performance小组认为，大数据集的巨大性能提升证明了这一努力的合理性。</p>
                     <div class="infoboxnote" id="GUID-49AA324B-A060-4284-9841-A6E27DB9E45C__NOTE-1410-77B77BA1">
                        <p class="notep1">视频：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/adfns&amp;id=vid_oll_rwp_set_based" target="_blank">RWP＃7基于集合的处理</a></p>
                           </li>
                           <li>
                              <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/adfns&amp;id=vid_oll_rwp_set_parallel" target="_blank">RWP＃8：基于集合的并行处理</a></p>
                           </li>
                           <li>
                              <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/adfns&amp;id=vid_oll_rwp_dedup" target="_blank">RWP＃9：基于集合的处理 - 数据重复数据删除</a></p>
                           </li>
                           <li>
                              <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/adfns&amp;id=vid_oll_rwp_transform" target="_blank">RWP＃10：基于集合的处理 - 数据转换</a></p>
                           </li>
                           <li>
                              <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/adfns&amp;id=vid_oll_rwp_agg" target="_blank">RWP＃11：基于集合的处理 - 数据聚合</a></p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>