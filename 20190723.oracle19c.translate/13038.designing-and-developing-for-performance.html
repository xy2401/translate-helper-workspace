<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <title>设计和开发性能</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Database Performance Tuning Guide"></meta>
      <meta property="og:description" content=""></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Database Performance Tuning Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="database-performance-tuning-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-03-12T22:26:14-07:00"></meta>
      <meta name="dcterms.title" content="Database Performance Tuning Guide"></meta>
      <meta name="dcterms.dateCopyrighted" content="2007, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96347-03"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="performance-tuning-overview.html" title="Previous" type="text/html"></link>
      <link rel="next" href="performance-improvement-methods.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.isVersionOf" content="TGDBA"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="performance-tuning-overview.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="performance-improvement-methods.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">数据库性能调优指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="part-I-database-performance-fundamentals.html" property="item" typeof="WebPage"><span property="name">数据库性能基础</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">设计和开发性能</li>
            </ol>
            <a id="GUID-CF4C8C89-9FFA-474F-B0F8-79049B8EB5FC" name="GUID-CF4C8C89-9FFA-474F-B0F8-79049B8EB5FC"></a><a id="TGDBA030"></a>
            
            <h2 id="TGDBA-GUID-CF4C8C89-9FFA-474F-B0F8-79049B8EB5FC" class="sect2"><span class="enumeration_chapter">2</span>设计和开发性能</h2>
         </header>
         <div class="ind">
            <div>
               <p>最佳系统性能始于设计，并贯穿系统的整个生命周期。在初始设计阶段仔细考虑性能问题，以便在生产过程中更轻松地调整系统。</p>
               <p>本章包含以下部分：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="designing-and-developing-for-performance.html#GUID-30C7065F-C099-4D3A-AA43-D61991FA5883">Oracle方法论</a></p>
                  </li>
                  <li>
                     <p><a href="designing-and-developing-for-performance.html#GUID-7521343A-F41D-4A5A-873F-ECB29E4E5083">了解投资选择</a></p>
                  </li>
                  <li>
                     <p><a href="designing-and-developing-for-performance.html#GUID-A0BA6C45-EF2B-4171-B716-51E7595F7DCD" title="可伸缩性是系统处理更多工作负载的能力，系统资源使用量成比例增加。可通过Internet访问的应用程序具有更复杂的性能和可用性要求。在构建应用程序时，设计人员和架构师应尽可能接近完美的可扩展性。这有时称为线性可扩展性，其中系统吞吐量与CPU数量成正比。">了解可伸缩性</a></p>
                  </li>
                  <li>
                     <p><a href="designing-and-developing-for-performance.html#GUID-F8511B21-9EEA-4F1D-A1A0-C7CCEF914503">系统架构</a></p>
                  </li>
                  <li>
                     <p><a href="designing-and-developing-for-performance.html#GUID-FB81D395-1940-49A2-925A-5AD3E1DBB570">应用设计原则</a></p>
                  </li>
                  <li>
                     <p><a href="designing-and-developing-for-performance.html#GUID-E6DFD7FD-E2E8-4C34-A81A-D25366F69594">工作负载测试，建模和实现</a></p>
                  </li>
                  <li>
                     <p><a href="designing-and-developing-for-performance.html#GUID-2E491D68-37F1-4D6B-B6E8-841A2C050E76">部署新应用程序</a></p>
                  </li>
               </ul>
            </div><a id="TGDBA94087"></a><div class="props_rev_3"><a id="GUID-30C7065F-C099-4D3A-AA43-D61991FA5883" name="GUID-30C7065F-C099-4D3A-AA43-D61991FA5883"></a><h3 id="TGDBA-GUID-30C7065F-C099-4D3A-AA43-D61991FA5883" class="sect3"><span class="enumeration_section">2.1</span> Oracle方法论</h3>
               <div>
                  <p>随着互联网在商业应用中发挥更大作用，计算机系统变得越来越大，越来越复杂，系统性能变得越来越重要。为了实现这一目标，Oracle基于多年的设计和性能经验制定了一种性能方法。此方法解释了可以显着提高系统性能的简单明了的活动。</p>
                  <p>绩效战略的有效性各不相同，具有不同目的的系统（如运营系统和决策支持系统）需要不同的绩效技能。本书探讨了任何数据库设计人员，管理员或性能专家应该集中精力的注意事项。</p>
                  <p>系统性能被设计并构建到系统中。它不仅仅发生。性能问题通常是某些系统资源争用或耗尽的结果。当系统资源耗尽时，系统无法扩展到更高级别的性能。这种新的性能方法基于对数据库的仔细规划和设计，以防止系统资源耗尽并导致停机。通过消除资源冲突，可以使系统可扩展到业务所需的级别。</p>
               </div>
            </div><a id="TGDBA94088"></a><div class="props_rev_3"><a id="GUID-7521343A-F41D-4A5A-873F-ECB29E4E5083" name="GUID-7521343A-F41D-4A5A-873F-ECB29E4E5083"></a><h3 id="TGDBA-GUID-7521343A-F41D-4A5A-873F-ECB29E4E5083" class="sect3"><span class="enumeration_section">2.2</span>了解投资选择</h3>
               <div>
                  <p>随着相对便宜，高性能处理器，内存和磁盘驱动器的出现，人们倾向于购买更多系统资源来提高性能。在许多情况下，新的CPU，内存或更多磁盘驱动器确实可以立即提供性能改进。但是，通过添加硬件实现的任何性能提升都应被视为对即时问题的短期缓解。如果应用程序的需求和负载率继续增长，那么很快就会出现同样问题的可能性。</p>
                  <p>在其他情况下，额外的硬件根本不会提高系统的性能。设计不良的系统无论分配多少额外硬件都表现不佳。在购买其他硬件之前，请确保应用程序中未发生序列化或单线程。从长期来看，就每个业务事务使用的物理资源数量而言，提高应用程序的效率通常更有价值。</p>
               </div>
            </div><a id="TGDBA94089"></a><div class="props_rev_3"><a id="GUID-A0BA6C45-EF2B-4171-B716-51E7595F7DCD" name="GUID-A0BA6C45-EF2B-4171-B716-51E7595F7DCD"></a><h3 id="TGDBA-GUID-A0BA6C45-EF2B-4171-B716-51E7595F7DCD" class="sect3"><span class="enumeration_section">2.3</span>了解可伸缩性</h3>
               <div>
                  <p><span class="italic">可伸缩性</span>这个词在开发环境中的许多上下文中使用。以下部分提供了针对应用程序设计人员和性能专家的可伸缩性说明。
                  </p>
                  <p>本节包括以下主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="designing-and-developing-for-performance.html#GUID-8168998B-9EC1-4AC2-8176-AFEFCAF7F155" title="可伸缩性是系统处理更多工作负载的能力，系统资源使用量成比例增加。">什么是可伸缩性？</a></p>
                     </li>
                     <li>
                        <p><a href="designing-and-developing-for-performance.html#GUID-5D62A34F-3A74-496A-A4F6-28CBC64BF0A3" title="可通过Internet访问的应用程序具有更复杂的性能和可用性要求。">系统可扩展性</a></p>
                     </li>
                     <li>
                        <p><a href="designing-and-developing-for-performance.html#GUID-8C0104E0-B20B-475A-9F03-93063D05A4E2" title="在构建应用程序时，设计人员和架构师应尽可能接近完美的可扩展性。这有时称为线性可扩展性，其中系统吞吐量与CPU数量成正比。">影响可伸缩性的因素</a></p>
                     </li>
                  </ul>
               </div><a id="TGDBA94090"></a><div class="props_rev_3"><a id="GUID-8168998B-9EC1-4AC2-8176-AFEFCAF7F155" name="GUID-8168998B-9EC1-4AC2-8176-AFEFCAF7F155"></a><h4 id="TGDBA-GUID-8168998B-9EC1-4AC2-8176-AFEFCAF7F155" class="sect4"><span class="enumeration_section">2.3.1</span>什么是可伸缩性？
                  </h4>
                  <div>
                     <p>可伸缩性是系统处理更多工作负载的能力，系统资源使用量成比例增加。</p>
                     <p>在可伸缩系统中，如果将工作负载加倍，则系统使用两倍的系统资源。这听起来很明显，但由于系统内部存在冲突，资源使用量可能会超过原始工作负载的两倍。</p>
                     <p>由于资源冲突导致可扩展性差的示例包括：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>随着用户群增加，需要大量并发管理的应用程序</p>
                        </li>
                        <li>
                           <p>锁定活动增加</p>
                        </li>
                        <li>
                           <p>增加了数据一致性工作量</p>
                        </li>
                        <li>
                           <p>增加了操作系统的工作量</p>
                        </li>
                        <li>
                           <p>随着数据量的增加，需要增加数据访问的事务</p>
                        </li>
                        <li>
                           <p>糟糕的SQL和索引设计导致返回相同行数的逻辑I / O数量更多</p>
                        </li>
                        <li>
                           <p>可用性降低，因为数据库对象需要更长的维护时间</p>
                        </li>
                     </ul>
                     <p>如果应用程序将系统资源耗尽到其工作负载增加时无法实现吞吐量的程度，则称应用程序是不可扩展的。这样的应用导致固定的吞吐量和较差的响应时间。</p>
                     <p>资源耗尽的示例包括以下内容：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>硬件耗尽</p>
                        </li>
                        <li>
                           <p>表扫描大量事务，导致不可避免的磁盘I / O短缺</p>
                        </li>
                        <li>
                           <p>网络请求过多，导致网络和调度瓶颈</p>
                        </li>
                        <li>
                           <p>内存分配导致分页和交换</p>
                        </li>
                        <li>
                           <p>过多的进程和线程分配导致操作系统抖动</p>
                        </li>
                     </ul>
                     <p>这意味着应用程序设计人员必须创建一个使用相同资源的设计，而不管用户群和数据量如何，并且不会将系统资源上的负载超出其限制。</p>
                  </div>
               </div><a id="TGDBA94092"></a><a id="TGDBA94091"></a><div class="props_rev_3"><a id="GUID-5D62A34F-3A74-496A-A4F6-28CBC64BF0A3" name="GUID-5D62A34F-3A74-496A-A4F6-28CBC64BF0A3"></a><h4 id="TGDBA-GUID-5D62A34F-3A74-496A-A4F6-28CBC64BF0A3" class="sect4"><span class="enumeration_section">2.3.2</span>系统可扩展性</h4>
                  <div>
                     <p>可通过Internet访问的应用程序具有更复杂的性能和可用性要求。</p>
                     <p>某些应用程序的设计和编写仅供Internet使用，但即使是典型的后台应用程序（如总帐应用程序），也可能需要在线提供部分或全部数据。</p>
                     <p>互联网时代应用的特征包括以下内容：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>可用性一年365天，每天24小时</p>
                        </li>
                        <li>
                           <p>不可预测且不精确的并发用户数</p>
                        </li>
                        <li>
                           <p>容量规划困难</p>
                        </li>
                        <li>
                           <p>任何类型的查询的可用性</p>
                        </li>
                        <li>
                           <p>多层架构</p>
                        </li>
                        <li>
                           <p>无状态中间件</p>
                        </li>
                        <li>
                           <p>快速开发时间表</p>
                        </li>
                        <li>
                           <p>最短的测试时间</p>
                        </li>
                     </ul>
                     <p>下图说明了经典的工作负载增长曲线，需求以不断增长的速度增长。应用程序必须随着工作负载的增加而扩展，并且还需要添加额外的硬件以支持不断增长的需无论额外的硬件资源或重新设计工作如何，设计错误都可能导致实现达到最大值。</p>
                     <div class="figure" id="GUID-5D62A34F-3A74-496A-A4F6-28CBC64BF0A3__I27836">
                        <p class="titleinfigure">图2-1工作量增长曲线</p><img src="img/figure_021_workload_growth_curve.gif" alt="下面描述图2-1" title="下面描述图2-1" longdesc="img_text/figure_021_workload_growth_curve.html"><br><a href="img_text/figure_021_workload_growth_curve.html">“图2-1工作量增长曲线”的描述</a></div>
                     <!-- class="figure" -->
                     <p>应用程序受到非常短的开发时间框架的挑战，测试和评估的时间有限。但是，糟糕的设计通常意味着您必须稍后重新架构并重新实现系统。如果在Internet上部署具有已知体系结构和实现限制的应用程序，并且如果工作负载超出预期需求，则失败是一种可能的现实。从业务角度来看，糟糕的表现可能意味着客户流失。如果Web用户在七秒内没有得到响应，那么用户的注意力可能会永远丢失。</p>
                     <p>在许多情况下，在迁移到新实现时重新设计具有相关停机成本的系统的成本超过了正确构建原始系统的成本。故事的寓意很简单：从一开始就考虑到可扩展性的设计和实现。</p>
                  </div>
               </div><a id="TGDBA94093"></a><div class="props_rev_3"><a id="GUID-8C0104E0-B20B-475A-9F03-93063D05A4E2" name="GUID-8C0104E0-B20B-475A-9F03-93063D05A4E2"></a><h4 id="TGDBA-GUID-8C0104E0-B20B-475A-9F03-93063D05A4E2" class="sect4"><span class="enumeration_section">2.3.3</span>阻止可扩展性的因素</h4>
                  <div>
                     <p>在构建应用程序时，设计人员和架构师应尽可能接近完美的可扩展性。这有时称为<span class="italic">线性</span>可扩展性，其中系统吞吐量与CPU数量成正比。
                     </p>
                     <p></p>
                     <p>在现实世界中，由于设计师无法控制的原因，线性可扩展性是不可能的。但是，尽可能使应用程序设计和实现具有可扩展性，应确保通过扩展硬件组件和CPU技术的发展来实现当前和未来的性能目标。</p>
                     <p>可能妨碍线性可扩展性的因素包括：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>应用程序设计，实现和配置不佳</p>
                           <p>该应用程序对可伸缩性的影响最大。例如：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>糟糕的架构设计可能导致昂贵的SQL无法扩展。</p>
                              </li>
                              <li>
                                 <p>糟糕的事务设计可能导致锁定和序列化问题。</p>
                              </li>
                              <li>
                                 <p>连接管理不良可能导致响应时间较短和系统不可靠。</p>
                              </li>
                           </ul>
                           <p>但是，设计并不是唯一的问题。应用程序的物理实现可能是薄弱环节。例如：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>系统可以迁移到具有错误I / O策略的生产环境。</p>
                              </li>
                              <li>
                                 <p>生产环境可能与测试中生成的执行计划不同。</p>
                              </li>
                              <li>
                                 <p>内存密集型应用程序分配大量内存而不考虑在运行时释放内存可能会导致内存使用过多。</p>
                              </li>
                              <li>
                                 <p>低效的内存使用和内存泄漏给操作虚拟内存子系统带来了很大的压力。这会影响性能和可用性。</p>
                              </li>
                           </ul>
                        </li>
                        <li>
                           <p>硬件组件的大小调整不正确</p>
                           <p>随着相对硬件价格的下降，所有硬件组件的不良容量规划变得越来越不成问题。但是，当系统上的工作负载增加时，过多的容量会掩盖可扩展性问题。</p>
                        </li>
                        <li>
                           <p>软件组件的局限性</p>
                           <p>所有软件组件都具有可伸缩性和资源使用限制。这适用于应用程序服务器，数据库服务器和操作系统。应用程序设计不应对软件提出超出其可处理范围的要求。</p>
                        </li>
                        <li>
                           <p>硬件组件的局限性</p>
                           <p>硬件不是完全可扩展的。大多数多处理器计算机可以通过有限数量的CPU接近线性扩展，但在某一点之后，每个额外的CPU可以提高整体性能，但不是成比例的。可能有一段时间，额外的CPU不会提高性能，甚至会降低性能。此行为与工作负载和操作系统设置密切相关。</p>
                           <div class="infoboxnote" id="GUID-8C0104E0-B20B-475A-9F03-93063D05A4E2__GUID-9B8138ED-49D3-4A7D-AA8A-5577CE843FBD">
                              <p class="notep1">注意：</p>
                              <p>这些因素基于Oracle Server Performance组调整不可扩展系统的经验。</p>
                           </div>
                        </li>
                     </ul>
                  </div>
               </div>
            </div><a id="TGDBA94094"></a><div class="props_rev_3"><a id="GUID-F8511B21-9EEA-4F1D-A1A0-C7CCEF914503" name="GUID-F8511B21-9EEA-4F1D-A1A0-C7CCEF914503"></a><h3 id="TGDBA-GUID-F8511B21-9EEA-4F1D-A1A0-C7CCEF914503" class="sect3"><span class="enumeration_section">2.4</span>系统架构</h3>
               <div>
                  <p><a id="d5548e672" class="indexterm-anchor"></a>系统架构有两个主要部分：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="designing-and-developing-for-performance.html#GUID-066F374E-35CE-4884-82C8-4F12BE61D727">硬件和软件组件</a></p>
                     </li>
                     <li>
                        <p><a href="designing-and-developing-for-performance.html#GUID-8537D484-BF0E-4D6B-A37E-32797B66AE09">根据您的要求配置正确的系统架构</a></p>
                     </li>
                  </ul>
               </div><a id="TGDBA94095"></a><div class="props_rev_3"><a id="GUID-066F374E-35CE-4884-82C8-4F12BE61D727" name="GUID-066F374E-35CE-4884-82C8-4F12BE61D727"></a><h4 id="TGDBA-GUID-066F374E-35CE-4884-82C8-4F12BE61D727" class="sect4"><span class="enumeration_section">2.4.1</span>硬件和软件组件</h4>
                  <div>
                     <p>系统架构主要包含硬件和软件组件。</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="designing-and-developing-for-performance.html#GUID-97E036C1-B8CF-4CF8-BCE6-2E9AE10D3D1B">硬件组件</a></p>
                        </li>
                        <li>
                           <p><a href="designing-and-developing-for-performance.html#GUID-9D533999-8218-4895-A914-382EEC08B6A9">软件组件</a></p>
                        </li>
                     </ul>
                  </div><a id="TGDBA94096"></a><div class="props_rev_3"><a id="GUID-97E036C1-B8CF-4CF8-BCE6-2E9AE10D3D1B" name="GUID-97E036C1-B8CF-4CF8-BCE6-2E9AE10D3D1B"></a><h5 id="TGDBA-GUID-97E036C1-B8CF-4CF8-BCE6-2E9AE10D3D1B" class="sect5"><span class="enumeration_section">2.4.1.1</span>硬件组件</h5>
                     <div>
                        <p>今天的设计师和架构师负责在多层环境中每层的硬件规模和容量规划。建筑师有责任实现平衡设计。这类似于桥梁设计师，他必须考虑桥梁的所有各种有效载荷和结构要求。桥梁只有最薄弱的部分才有力量。因此，桥梁设计平衡，使所有组件同时达到其设计极限。</p>
                        <p>以下是系统的主要硬件组件。</p>
                        <div class="section">
                           <p class="subhead3" id="GUID-97E036C1-B8CF-4CF8-BCE6-2E9AE10D3D1B__GUID-9669160A-54D2-4888-BC7F-52976D08C512">中央处理器</p>
                           <p><a id="d5548e819" class="indexterm-anchor"></a><a id="d5548e825" class="indexterm-anchor"></a>可以有一个或多个CPU，它们的处理能力可以从手持设备中的简单CPU到高功率服务器CPU。其他硬件组件的大小通常是系统上CPU的多个。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-97E036C1-B8CF-4CF8-BCE6-2E9AE10D3D1B__GUID-5F989B02-9AE8-4B95-9D61-685BAC4A559C">记忆</p>
                           <p><a id="d5548e832" class="indexterm-anchor"></a><a id="d5548e838" class="indexterm-anchor"></a>数据库和应用程序服务器需要大量内存来缓存数据并避免耗时的磁盘访问。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-97E036C1-B8CF-4CF8-BCE6-2E9AE10D3D1B__GUID-370E3734-8A26-48D7-8C3F-6A15067B4CC6">I / O子系统</p>
                           <p><a id="d5548e847" class="indexterm-anchor"></a> I / O子系统可以在客户端PC上的硬盘和高性能磁盘阵列之间变化。磁盘阵列每秒可以执行数千个I / O，并通过多个I / O路径和热插拔镜像磁盘的冗余提供可用性。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-97E036C1-B8CF-4CF8-BCE6-2E9AE10D3D1B__GUID-D0ACD511-C48C-4795-B342-1531CBD73425">网络</p>
                           <p><a id="d5548e858" class="indexterm-anchor"></a><a id="d5548e864" class="indexterm-anchor"></a>系统中的所有计算机都连接到网络，从调制解调器线路到高速内部LAN。网络规范的主要问题是带宽（卷）和延迟（速度）。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="TGDBA94101"></a><div class="props_rev_3"><a id="GUID-9D533999-8218-4895-A914-382EEC08B6A9" name="GUID-9D533999-8218-4895-A914-382EEC08B6A9"></a><h5 id="TGDBA-GUID-9D533999-8218-4895-A914-382EEC08B6A9" class="sect5"><span class="enumeration_section">2.4.1.2</span>软件组件</h5>
                     <div>
                        <p>计算机具有通用硬件组件的方式相同，应用程序具有通用功能组件。通过将软件开发划分为功能组件，可以更好地理解应用程序设计和体系结构。系统的某些组件由购买的现有软件执行，以加速应用程序实现，或避免重新开发通用组件。</p>
                        <p>软件组件和硬件组件之间的区别在于，虽然硬件组件仅执行一项任务，但一个软件可以执行各种软件组件的角色。例如，磁盘驱动器仅存储和检索数据，但客户端程序可以管理用户界面并执行业务逻辑。</p>
                        <p>大多数应用程序涉及以下软件组件：</p>
                        <div class="section">
                           <p class="subhead3" id="GUID-9D533999-8218-4895-A914-382EEC08B6A9__GUID-2234C6B9-58B4-414C-BC61-5BB089F631C9">用户界面</p>
                           <p><a id="d5548e942" class="indexterm-anchor"></a><a id="d5548e948" class="indexterm-anchor"></a>该组件对应用程序用户最为明显，包括以下功能：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>向用户显示屏幕</p>
                              </li>
                              <li>
                                 <p>收集用户数据并将其传输到业务逻辑</p>
                              </li>
                              <li>
                                 <p>验证数据输入</p>
                              </li>
                              <li>
                                 <p>浏览应用程序的级别或状态</p>
                              </li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-9D533999-8218-4895-A914-382EEC08B6A9__GUID-F3208F93-01BE-484A-A92D-BE5639E37484">商业逻辑</p>
                           <p><a id="d5548e968" class="indexterm-anchor"></a><a id="d5548e974" class="indexterm-anchor"></a><a id="d5548e976" class="indexterm-anchor"></a>该组件实现了应用程序功能的核心业务规则。修复此组件中的错误可能非常昂贵。该组件通过声明和程序方法的混合实现。声明性活动的一个示例是定义唯一键和外键。基于过程的逻辑的一个示例是实施折扣策略。
                           </p>
                           <p>该组件的常见功能包括：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>将数据模型移动到关系表结构</p>
                              </li>
                              <li>
                                 <p>在关系表结构中定义约束</p>
                              </li>
                              <li>
                                 <p>编写程序逻辑以实现业务规则</p>
                              </li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-9D533999-8218-4895-A914-382EEC08B6A9__GUID-8CF7611D-B97F-47EB-87A7-642E37C7D6D9">用于管理用户请求的资源</p>
                           <p><a id="d5548e995" class="indexterm-anchor"></a><a id="d5548e1001" class="indexterm-anchor"></a>该组件在所有软件中实现。但是，有些请求和资源可能会受到应用程序设计的影响，而有些则不能。
                           </p>
                           <p>在多用户应用程序中，用户请求的大多数资源分配由数据库服务器或操作系统处理。但是，在用户数量及其使用模式未知或快速增长的大型应用程序中，系统架构师必须主动确保没有单个软件组件过载和不稳定。</p>
                           <p>该组件的常见功能包括：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>与数据库的连接管理</p>
                              </li>
                              <li>
                                 <p>有效执行SQL（游标和SQL共享）</p>
                              </li>
                              <li>
                                 <p>管理客户端状态信息</p>
                              </li>
                              <li>
                                 <p>平衡跨硬件资源的用户请求负载</p>
                              </li>
                              <li>
                                 <p>设置硬件和软件组件的操作目标</p>
                              </li>
                              <li>
                                 <p>持久排队以执行异步任务</p>
                              </li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-9D533999-8218-4895-A914-382EEC08B6A9__GUID-8100FF86-0A9E-46FE-A288-A9BDC4ECDB3F">数据和交易</p>
                           <p><a id="d5548e1033" class="indexterm-anchor"></a><a id="d5548e1039" class="indexterm-anchor"></a><a id="d5548e1043" class="indexterm-anchor"></a>该组件主要由数据库服务器和操作系统负责。
                           </p>
                           <p>该组件的常见功能包括：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>使用锁和事务语义提供对数据的并发访问</p>
                              </li>
                              <li>
                                 <p>使用索引和内存缓存提供对数据的优化访问</p>
                              </li>
                              <li>
                                 <p>确保在发生硬件故障时记录数据更改</p>
                              </li>
                              <li>
                                 <p>执行为数据定义的任何规则</p>
                              </li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="TGDBA94106"></a><div class="props_rev_3"><a id="GUID-8537D484-BF0E-4D6B-A37E-32797B66AE09" name="GUID-8537D484-BF0E-4D6B-A37E-32797B66AE09"></a><h4 id="TGDBA-GUID-8537D484-BF0E-4D6B-A37E-32797B66AE09" class="sect4"><span class="enumeration_section">2.4.2</span>根据需求配置正确的系统架构</h4>
                  <div>
                     <p><a id="d5548e1111" class="indexterm-anchor"></a>配置初始系统架构是一个很大程度上是迭代的过程。系统架构师必须在预算和进度约束内满足系统要求。如果系统要求交互式用户根据数据库的内容处理业务决策，那么用户需求就会驱动架构。如果系统上的交互式用户很少，那么该体系结构是由流程驱动的。
                     </p>
                     <p>交互式用户应用程序示例：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>会计和簿记应用程序</p>
                        </li>
                        <li>
                           <p>订单输入系统</p>
                        </li>
                        <li>
                           <p>电邮服务器</p>
                        </li>
                        <li>
                           <p>基于Web的零售应用程序</p>
                        </li>
                        <li>
                           <p>交易系统</p>
                        </li>
                     </ul>
                     <p>流程驱动的应用程序示例：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>效用计费系统</p>
                        </li>
                        <li>
                           <p>欺诈检测系统</p>
                        </li>
                        <li>
                           <p>直邮</p>
                        </li>
                     </ul>
                     <p>在许多方面，流程驱动的应用程序比多用户应用程序更容易设计，因为消除了用户界面元素。但是，由于目标是面向过程的，因此不习惯处理大量数据和不同成功因素的系统架构师可能会感到困惑。流程驱动的应用程序来自基于用户的应用程序和数据仓库中使用的技能集。因此，本书侧重于为交互式用户不断发展的系统架构。</p>
                     <div class="infoboxnote" id="GUID-8537D484-BF0E-4D6B-A37E-32797B66AE09__GUID-594CDD81-8D52-4AAA-B7E2-07E66313B64A">
                        <p class="notep1">注意：</p>
                        <p>生成系统架构不是一个确定性过程。它需要仔细考虑业务需求，技术选择，现有基础设施和系统以及实际物理资源，如预算和人力。</p>
                     </div>
                     <p>以下问题应该激发对系统架构的思考，尽管它们不是系统架构的权威指南。这些问题演示了业务需求如何影响体系结构，易于实现以及系统的整体性能和可用性。例如：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a id="d5548e1156" class="indexterm-anchor"></a>系统必须支持多少用户？
                           </p>
                           <p>大多数应用程序属于以下类别之一：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>在一台使用不当或专用的计算机上用户很少</p>
                                 <p>对于这种类型的应用程序，通常有一个用户。应用程序设计的重点是通过提供良好的响应时间使单个用户尽可能高效，同时使应用程序需要最少的管理。这些应用程序的用户很少相互干扰，并且资源冲突最小。</p>
                              </li>
                              <li>
                                 <p>使用共享应用程序的公司中的大量中型用户</p>
                                 <p>对于这种类型的应用程序，用户受到公司中通过系统实际交易业务的员工数量的限制。因此，用户数量是可预测的。但是，提供可靠的服务对业务至关重要。用户必须共享资源，因此设计工作必须解决在繁重的系统负载下的响应时间，每个会话使用的资源升级以及未来增长的空间。</p>
                              </li>
                              <li>
                                 <p>在Internet上分发的无限用户群</p>
                                 <p>对于此类应用，需要额外的工程工作以确保没有系统组件超出其设计限制。这就产生了一个瓶颈，使系统停止或不稳定。这些应用程序需要复杂的负载平衡，无状态应用程序服务器和高效的数据库连接管此外，如果数据库由于系统过载而无法满足其请求，则使用统计信息和调控器来确保用户收到反馈。</p>
                              </li>
                           </ul>
                        </li>
                        <li>
                           <p><a id="d5548e1181" class="indexterm-anchor"></a>什么是用户交互方法？
                           </p>
                           <p>用户界面的选择范围从简单的Web浏览器到自定义客户端程序。</p>
                        </li>
                        <li>
                           <p><a id="d5548e1190" class="indexterm-anchor"></a>用户在哪里？
                           </p>
                           <p>用户之间的距离会影响应用程序的设计方式，以应对网络延迟。当无法执行批处理或系统维护功能时，该位置还会影响一天中的哪些时间繁忙。</p>
                        </li>
                        <li>
                           <p><a id="d5548e1199" class="indexterm-anchor"></a><a id="d5548e1203" class="indexterm-anchor"></a>什么是网络速度？
                           </p>
                           <p>网络速度会影响数据量以及与应用程序和数据库服务器的用户界面的对话性质。高度对话的用户界面可以在每次击键或场级验证时与后端服务器通信。较少会话的界面适用于屏幕发送和屏幕接收模型。在慢速网络上，使用高度对话的用户界面无法实现高数据输入速度。</p>
                        </li>
                        <li>
                           <p>用户可以访问多少数据，以及有多少数据基本上只读？</p>
                           <p><a id="d5548e1214" class="indexterm-anchor"></a><a id="d5548e1218" class="indexterm-anchor"></a><a id="d5548e1222" class="indexterm-anchor"></a>在线查询的数据量会影响设计的所有方面，从表格和索引设计到表示层。设计工作必须确保用户响应时间不是数据库大小的函数。如果应用程序基本上是只读的，那么复制和数据分发到应用程序服务器中的本地缓存将成为可行的选择。这还减少了核心事务服务器上的工作负载。
                           </p>
                        </li>
                        <li>
                           <p><a id="d5548e1229" class="indexterm-anchor"></a><a id="d5548e1233" class="indexterm-anchor"></a>用户响应时间要求是什么？
                           </p>
                           <p>考虑用户类型很重要。如果用户是需要准确信息做出拆分决策的执行人员，那么用户响应时间就不会受到影响。其他类型的用户（例如执行数据输入活动的用户）可能不需要如此高的性能水平。</p>
                        </li>
                        <li>
                           <p><a id="d5548e1240" class="indexterm-anchor"></a><a id="d5548e1242" class="indexterm-anchor"></a>用户是否期望24小时服务？
                           </p>
                           <p>这对于今天24小时进行交易的互联网应用是强制性的。但是，在单个时区中运行的企业系统可能能够容忍非工作时间的停机时间。您可以使用此非工作时间停机时间来运行批处理或执行系统管理。在这种情况下，运行完全可用的系统可能更经济。</p>
                        </li>
                        <li>
                           <p>所有变更都必须实时进行吗？</p>
                           <p>确定是否必须在用户响应时间内执行事务，或者是否可以将它们排队等待异步执行非常重要。</p>
                        </li>
                     </ul>
                     <p>以下是次要问题，这些问题也可能影响设计，但实际上对预算和易于实施的影响更大。例如：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a id="d5548e1257" class="indexterm-anchor"></a>数据库有多大？
                           </p>
                           <p>这会影响数据库服务器的大小。在具有非常大的数据库的服务器上，可能需要具有比工作负载所指定的更大的计算机。这是因为大型数据库的管理开销很大程度上取决于数据库大小。随着表和索引的增长，需要更多的CPU来允许表重组和索引构建在可接受的时间限制内完成。</p>
                        </li>
                        <li>
                           <p>业务交易所需的吞吐量是多少？</p>
                        </li>
                        <li>
                           <p>有哪些可用性要求？</p>
                        </li>
                        <li>
                           <p>是否存在构建和管理此应用程序的技能？</p>
                        </li>
                        <li>
                           <p>预算限制迫使哪些妥协？</p>
                        </li>
                     </ul>
                  </div>
               </div>
            </div><a id="TGDBA94107"></a><div class="props_rev_3"><a id="GUID-FB81D395-1940-49A2-925A-5AD3E1DBB570" name="GUID-FB81D395-1940-49A2-925A-5AD3E1DBB570"></a><h3 id="TGDBA-GUID-FB81D395-1940-49A2-925A-5AD3E1DBB570" class="sect3"><span class="enumeration_section">2.5</span>应用设计原则</h3>
               <div>
                  <p><a id="d5548e1326" class="indexterm-anchor"></a><a id="d5548e1330" class="indexterm-anchor"></a>本节介绍构建应用程序时涉及的以下设计决策：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="designing-and-developing-for-performance.html#GUID-FEF689B9-9D3B-4671-BBA7-AF9F0DB3B596">应用程序设计的简单性</a></p>
                     </li>
                     <li>
                        <p><a href="designing-and-developing-for-performance.html#GUID-BCFE8E0F-E08E-4D4A-8AD8-73C5342ACE47">数据建模</a></p>
                     </li>
                     <li>
                        <p><a href="designing-and-developing-for-performance.html#GUID-99A7FD1B-CEFD-4E91-9486-2CBBFC2B7A1D">表和索引设计</a></p>
                     </li>
                     <li>
                        <p><a href="designing-and-developing-for-performance.html#GUID-5262FB3D-4473-47A6-BDAE-F996192F9F21">使用视图</a></p>
                     </li>
                     <li>
                        <p><a href="designing-and-developing-for-performance.html#GUID-B95920ED-53C2-42A7-A53D-9083974A7A1D">SQL执行效率</a></p>
                     </li>
                     <li>
                        <p><a href="designing-and-developing-for-performance.html#GUID-D322A76C-FBFF-4A54-BD32-FFEA7A3C414F">实施应用程序</a></p>
                     </li>
                     <li>
                        <p><a href="designing-and-developing-for-performance.html#GUID-AA42DCCB-193C-4ED3-A6B6-D3059B6F4ED2">应用程序开发的趋势</a></p>
                     </li>
                  </ul>
               </div><a id="TGDBA94108"></a><div class="props_rev_3"><a id="GUID-FEF689B9-9D3B-4671-BBA7-AF9F0DB3B596" name="GUID-FEF689B9-9D3B-4671-BBA7-AF9F0DB3B596"></a><h4 id="TGDBA-GUID-FEF689B9-9D3B-4671-BBA7-AF9F0DB3B596" class="sect4"><span class="enumeration_section">2.5.1</span>应用程序设计的简单性</h4>
                  <div>
                     <p>应用程序与任何其他设计和工程产品没有什么不同。精心设计的结构，计算机和工具通常可靠，易于使用和维护，并且概念简单。用最一般的术语来说，如果设计看起来正确，那么可能就是这样。在构建应用程序时，应始终牢记这一原则。</p>
                     <p>请考虑以下设计问题：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>如果桌面设计如此复杂以至于没有人能够完全理解它，那么桌子可能设计得很差。</p>
                        </li>
                        <li>
                           <p>如果SQL语句太长且涉及到任何优化器都无法实时有效地优化它，那么可能存在错误的语句，底层事务或表设计。</p>
                        </li>
                        <li>
                           <p>如果表上有索引并且重复索引相同的列，则索引设计可能很差。</p>
                        </li>
                        <li>
                           <p>如果提交的查询没有适当的资格来对在线用户进行快速响应，则可能存在较差的用户界面或交易设计。</p>
                        </li>
                        <li>
                           <p>如果通过多层软件将对数据库的调用从应用程序逻辑中抽象出来，那么可能存在一种糟糕的软件开发方法。</p>
                        </li>
                     </ul>
                  </div>
               </div><a id="TGDBA94109"></a><div class="props_rev_3"><a id="GUID-BCFE8E0F-E08E-4D4A-8AD8-73C5342ACE47" name="GUID-BCFE8E0F-E08E-4D4A-8AD8-73C5342ACE47"></a><h4 id="TGDBA-GUID-BCFE8E0F-E08E-4D4A-8AD8-73C5342ACE47" class="sect4"><span class="enumeration_section">2.5.2</span>数据建模</h4>
                  <div>
                     <p><a id="d5548e1488" class="indexterm-anchor"></a><a id="d5548e1492" class="indexterm-anchor"></a>数据建模对于成功的关系应用程序设计很重要。您必须以快速表示业务实践的方式执行此建模。关于正确的数据模型可能会出现激烈的争论。重要的是将最大的建模工作应用于受最频繁的业务事务影响的实体。在建模阶段，很有可能花费太多时间来建模非核心数据元素，这会导致开发前置时间的增加。然后，使用建模工具可以快速生成模式定义，并且在需要快速原型时非常有用。
                     </p>
                  </div>
               </div><a id="TGDBA94110"></a><div class="props_rev_3"><a id="GUID-99A7FD1B-CEFD-4E91-9486-2CBBFC2B7A1D" name="GUID-99A7FD1B-CEFD-4E91-9486-2CBBFC2B7A1D"></a><h4 id="TGDBA-GUID-99A7FD1B-CEFD-4E91-9486-2CBBFC2B7A1D" class="sect4"><span class="enumeration_section">2.5.3</span>表和索引设计</h4>
                  <div>
                     <p><a id="d5548e1548" class="indexterm-anchor"></a>表设计主要是核心交易的灵活性和性能之间的折衷。为了保持数据库的灵活性并能够适应不可预见的工作负载，表格设计应该与数据模型非常相似，并且应该将其标准化为至少第3范式。但是，用户所需的某些核心事务可能需要选择性非规范化以实现性能目的。
                     </p>
                     <p>此技术的示例包括存储预先连接的表，添加派生列和聚合值。Oracle数据库通过群集和物化视图功能提供了许多用于存储聚合和预加入数据的选项。这些功能允许最初采用更简单的表格设计。</p>
                     <p>同样，应将重点和资源用于业务关键表，以便实现最佳性能。对于非关键表，可以采用设计中的快捷方式来实现更快速的应用程序开发。但是，如果原型设计和测试非核心表成为性能问题，则应立即应用补救设计工作。</p>
                     <p><a id="d5548e1558" class="indexterm-anchor"></a>基于应用程序设计者生成的SQL，索引设计也是一个很大程度上是迭代的过程。但是，通过构建强制主键约束的索引和已知访问模式的索引（例如人名），可以明智地开始。随着应用程序的发展，当您对实际数据量进行测试时，您可能需要通过构建更好的索引来提高特定查询的性能。在构建新索引时，请考虑以下索引设计思路列表：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="designing-and-developing-for-performance.html#GUID-474426C8-9CE1-4BE2-B922-F77F35444FD9">将列附加到索引或使用索引组织表</a></p>
                        </li>
                        <li>
                           <p><a href="designing-and-developing-for-performance.html#GUID-38FC5A9F-89E6-4812-8EE4-F9949B69BCFC">使用不同的索引类型</a></p>
                        </li>
                        <li>
                           <p><a href="designing-and-developing-for-performance.html#GUID-D2F5B6B1-4A75-42D4-8DB7-793C6BACB335">寻找指数的成本</a></p>
                        </li>
                        <li>
                           <p><a href="designing-and-developing-for-performance.html#GUID-914D618C-022A-4517-BBD0-C1D91D60272C">在索引中序列化</a></p>
                        </li>
                        <li>
                           <p><a href="designing-and-developing-for-performance.html#GUID-667C9B46-3D71-427E-BEDF-218718CF2038">订购索引中的列</a></p>
                        </li>
                     </ul>
                  </div><a id="TGDBA94111"></a><div class="props_rev_3"><a id="GUID-474426C8-9CE1-4BE2-B922-F77F35444FD9" name="GUID-474426C8-9CE1-4BE2-B922-F77F35444FD9"></a><h5 id="TGDBA-GUID-474426C8-9CE1-4BE2-B922-F77F35444FD9" class="sect5"><span class="enumeration_section">2.5.3.1</span>将列附加到索引或使用索引组织表</h5>
                     <div>
                        <p><a id="d5548e1639" class="indexterm-anchor"></a><a id="d5548e1643" class="indexterm-anchor"></a>加速查询的最简单方法之一是通过消除执行计划中的表访问来减少逻辑I / O的数量。这可以通过将查询引用的所有列附加到索引来完成。这些列是选择列表列，以及任何所需的连接或排序列。当耗时的I / O减少时，此技术对于加快在线应用程序响应时间特别有用。这在首次使用适当大小的数据测试应用程序时最佳应用。
                        </p>
                        <p>这种技术最积极的形式是构建索引组织表（IOT）。但是，您必须小心，IOT增加的叶子大小不会削弱减少I / O的努力。</p>
                     </div>
                  </div><a id="TGDBA94112"></a><div class="props_rev_3"><a id="GUID-38FC5A9F-89E6-4812-8EE4-F9949B69BCFC" name="GUID-38FC5A9F-89E6-4812-8EE4-F9949B69BCFC"></a><h5 id="TGDBA-GUID-38FC5A9F-89E6-4812-8EE4-F9949B69BCFC" class="sect5"><span class="enumeration_section">2.5.3.2</span>使用不同的索引类型</h5>
                     <div>
                        <p>有几种可用的索引类型，每种索引都可以为某些情况带来好处。以下列表提供了与每种索引类型相关的性能想法。</p>
                        <div class="section">
                           <p class="subhead3" id="GUID-38FC5A9F-89E6-4812-8EE4-F9949B69BCFC__GUID-D48B6E6C-0C1E-4E68-ACC6-45DD823F6787">B树索引</p>
                           <p><a id="d5548e1705" class="indexterm-anchor"></a><a id="d5548e1707" class="indexterm-anchor"></a>这些索引是标准索引类型，它们非常适合主键和高选择性索引。用作连接索引，数据库可以使用B树索引来检索按索引列排序的数据。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-38FC5A9F-89E6-4812-8EE4-F9949B69BCFC__GUID-F41DC082-F6C9-4807-ACC1-43B1C37E53CA">位图索引</p>
                           <p><a id="d5548e1716" class="indexterm-anchor"></a><a id="d5548e1718" class="indexterm-anchor"></a>这些索引适用于具有相对较少的不同值的列，其中添加B树索引的好处可能是有限的。这些索引适用于DML活动较少且临时过滤模式较低的数据仓库应用程序。在列上组合位图索引允许以最小的I / O进行有效的<code class="codeph">AND</code>和<code class="codeph">OR</code>操作。此外，通过压缩技术，它们可以生成大量具有最小I / O的rowid。位图索引在使用<code class="codeph">COUNT()</code>查询中特别有效，因为可以在索引中满足查询。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-38FC5A9F-89E6-4812-8EE4-F9949B69BCFC__GUID-77D4DD35-18F4-447D-9889-7227B79FC2F6">基于函数的索引</p>
                           <p><a id="d5548e1736" class="indexterm-anchor"></a><a id="d5548e1738" class="indexterm-anchor"></a>这些索引允许通过B树访问从基础数据上的函数派生的值。基于函数的索引在使用空值方面有一些限制，它们要求您启用查询优化器。
                           </p>
                           <p>在查询复合列以生成派生结果或克服数据存储在数据库中的方式的限制时，基于函数的索引特别有用。例如，查询订单中的订单项超过从（销售价格 - 折扣）x数量派生的特定值，其中这些是表格中的列。另一个示例是将<code class="codeph">UPPER</code>函数应用于数据以允许不区分大小写的搜索。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-38FC5A9F-89E6-4812-8EE4-F9949B69BCFC__GUID-B87EB95E-4FF5-43F5-A906-01EDEF1A27E9">分区索引</p>
                           <p><a id="d5548e1752" class="indexterm-anchor"></a><a id="d5548e1756" class="indexterm-anchor"></a>对全局索引进行分区允许在索引访问中进行分区修剪，从而导致I / O减少。通过定义好范围或列表分区，对正确索引分区的快速索引扫描可以导致非常快的查询时间。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-38FC5A9F-89E6-4812-8EE4-F9949B69BCFC__GUID-71C2F820-80AF-4C13-BB71-380C100E6734">反向键索引</p>
                           <p><a id="d5548e1763" class="indexterm-anchor"></a><a id="d5548e1767" class="indexterm-anchor"></a>这些索引旨在消除插入应用程序上的索引热点。这些索引非常适合插入性能，但它们受到限制，因为数据库无法将它们用于索引范围扫描。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="TGDBA94118"></a><div class="props_rev_3"><a id="GUID-D2F5B6B1-4A75-42D4-8DB7-793C6BACB335" name="GUID-D2F5B6B1-4A75-42D4-8DB7-793C6BACB335"></a><h5 id="TGDBA-GUID-D2F5B6B1-4A75-42D4-8DB7-793C6BACB335" class="sect5"><span class="enumeration_section">2.5.3.3</span>查找指数成本</h5>
                     <div>
                        <p><a id="d5548e1821" class="indexterm-anchor"></a>构建和维护索引结构可能很昂贵，并且可能消耗诸如磁盘空间，CPU和I / O容量之类的资源。设计师必须确保任何指数的好处都超过指数维护的负面影响。
                        </p>
                        <p>使用这个简单的估算指南来获取索引维护的成本：由索引键的<code class="codeph">INSERT</code> ， <code class="codeph">DELETE</code>或<code class="codeph">UPDATE</code>维护的每个索引所需的资源大约是表上实际DML操作的三倍。因此，如果您使用三个索引<code class="codeph">INSERT</code>到一个表中，那么插入比<code class="codeph">INSERT</code>慢大约10倍于没有索引的表。对于DML，特别是<code class="codeph">INSERT</code> -heavy应用程序，应仔细检查索引设计，这可能需要在查询和<code class="codeph">INSERT</code>性能之间进行折衷。
                        </p>
                        <div class="infoboxnotealso" id="GUID-D2F5B6B1-4A75-42D4-8DB7-793C6BACB335__GUID-233AD9CD-BE68-4917-81E9-79B170934E36">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="../admin/managing-indexes.html#ADMIN11735" target="_blank"><span class="italic">Oracle数据库管理员指南</span></a> ，了解如何监控索引使用情况</p>
                        </div>
                     </div>
                  </div><a id="TGDBA94119"></a><div class="props_rev_3"><a id="GUID-914D618C-022A-4517-BBD0-C1D91D60272C" name="GUID-914D618C-022A-4517-BBD0-C1D91D60272C"></a><h5 id="TGDBA-GUID-914D618C-022A-4517-BBD0-C1D91D60272C" class="sect5"><span class="enumeration_section">2.5.3.4</span>在索引中序列化</h5>
                     <div>
                        <p>使用序列或时间戳生成自身索引的键值可能会导致数据库热点问题，从而影响响应时间和吞吐量。这通常是单调增长密钥的结果，导致正确增长的指数。要避免此问题，请尝试生成插入索引的整个范围的键，以使工作负载更具可伸缩性。您可以使用以下任何方法来实现此目的：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>使用反向键索引</p>
                           </li>
                           <li>
                              <p>使用散列分区索引</p>
                           </li>
                           <li>
                              <p>使用循环序列为序列值添加前缀</p>
                           </li>
                           <li>
                              <p>使用可伸缩序列</p>
                           </li>
                        </ul>
                        <div class="infoboxnotealso" id="GUID-914D618C-022A-4517-BBD0-C1D91D60272C__GUID-93CF383D-787E-4796-B899-117BBA28BFFA">
                           <p class="notep1">也可以看看：</p>
                           <p>有关可伸缩序列的更多信息，请参见<a href="../admin/managing-views-sequences-and-synonyms.html#ADMIN-GUID-700340BB-7517-4994-B9DA-348E6113DD57" target="_blank"><span class="italic">“Oracle数据库管理员指南”</span></a></p>
                        </div>
                     </div>
                  </div><a id="TGDBA94120"></a><div class="props_rev_3"><a id="GUID-667C9B46-3D71-427E-BEDF-218718CF2038" name="GUID-667C9B46-3D71-427E-BEDF-218718CF2038"></a><h5 id="TGDBA-GUID-667C9B46-3D71-427E-BEDF-218718CF2038" class="sect5"><span class="enumeration_section">2.5.3.5</span>对索引中的列进行排序</h5>
                     <div>
                        <p><a id="d5548e1988" class="indexterm-anchor"></a><a id="d5548e1992" class="indexterm-anchor"></a><a id="d5548e1996" class="indexterm-anchor"></a><a id="d5548e2000" class="indexterm-anchor"></a>设计人员应该灵活地定义索引构建的任何规则。根据您的具体情况，使用以下两种方法之一来对索引中的键进行排序：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>最多订购列<a id="d5548e2009" class="indexterm-anchor"></a>选择性第一。此方法是最常用的方法，因为它提供了最快的访问速度，并且对所需的实际rowid的I / O最小。该技术主要用于主键和非常有选择性的范围扫描。
                              </p>
                           </li>
                           <li>
                              <p>通过对数据进行聚类或排序来对列进行排序以减少I / O.在大范围扫描中，通常可以通过以最小选择顺序对列进行排序，或者以按照应该检索的方式对数据进行排序的方式来减少I / O.</p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="TGDBA94121"></a><div class="props_rev_3"><a id="GUID-5262FB3D-4473-47A6-BDAE-F996192F9F21" name="GUID-5262FB3D-4473-47A6-BDAE-F996192F9F21"></a><h4 id="TGDBA-GUID-5262FB3D-4473-47A6-BDAE-F996192F9F21" class="sect4"><span class="enumeration_section">2.5.4</span>使用视图</h4>
                  <div>
                     <p><a id="d5548e2067" class="indexterm-anchor"></a>视图可以加速并简化应用程序设计。简单的视图定义可以掩盖数据模型的复杂性，这些复杂性来自程序员，其优先级是检索，显示，收集和存储数据。
                     </p>
                     <p>但是，虽然视图提供了干净的编程接口，但它们可能会导致次优的资源密集型查询。最糟糕的视图使用类型是视图引用其他视图以及它们在查询中连接时的情况。在许多情况下，开发人员可以直接从表中满足查询而无需使用视图。通常，由于视图的固有属性，视图使优化器难以生成最佳执行计划。</p>
                  </div>
               </div><a id="TGDBA94122"></a><div class="props_rev_3"><a id="GUID-B95920ED-53C2-42A7-A53D-9083974A7A1D" name="GUID-B95920ED-53C2-42A7-A53D-9083974A7A1D"></a><h4 id="TGDBA-GUID-B95920ED-53C2-42A7-A53D-9083974A7A1D" class="sect4"><span class="enumeration_section">2.5.5</span> SQL执行效率</h4>
                  <div>
                     <p>在任何系统开发的设计和架构阶段，都应注意确保应用程序开发人员了解SQL执行效率。为实现此目标，开发环境必须支持以下特征：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>良好的数据库连接管理</p>
                           <p>连接到数据库是一项昂贵的操作，非常不可扩展。因此，应尽可能减少与数据库的并发连接数。用户在应用程序初始化时连接的简单系统是理想的。但是，在基于Web或多层应用程序中，应用程序服务器用于将数据库连接多路复用到用户，这可能很困难。对于这些类型的应用程序，设计工作应确保池化数据库连接，并且不会为每个用户请求重新建立。</p>
                        </li>
                        <li>
                           <p>良好的游标使用和管理</p>
                           <p>维护用户连接对于最小化系统上的解析活动同样重要。解析是解释SQL语句并为其创建执行计划的过程。此过程有许多阶段，包括语法检查，安全检查，执行计划生成以及将共享结构加载到共享池中。有两种类型的解析操作：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><a id="d5548e2137" class="indexterm-anchor"></a><a id="d5548e2139" class="indexterm-anchor"></a>难以解析</p>
                                 <p>首次提交SQL语句，并且在共享池中找不到匹配项。硬解析是资源最密集且不可扩展的，因为它们执行解析中涉及的所有操作。</p>
                              </li>
                              <li>
                                 <p><a id="d5548e2148" class="indexterm-anchor"></a><a id="d5548e2150" class="indexterm-anchor"></a>软解析</p>
                                 <p>SQL语句被提交首次，并找到<span class="italic">匹配</span>的共享池。匹配可以是其他用户先前执行的结果。SQL语句是共享的，这有利于提高性能。但是，软解析并不理想，因为它们仍然需要语法和安全检查，这会消耗系统资源。
                                 </p>
                              </li>
                           </ul>
                           <p>因为解析应该尽可能地最小化，所以应用程序开发人员应该设计他们的应用程序来解析一次SQL语句并多次执行它们。这是通过游标完成的。经验丰富的SQL程序员应该熟悉打开和重新执行游标的概念。</p>
                           <p>应用程序开发人员还必须确保在共享池中共享SQL语句。要实现此目标，请使用绑定变量来表示从执行更改为执行的查询部分。如果不这样做，则SQL语句可能会被解析一次，并且永远不会被其他用户重用。要确保共享SQL，请使用绑定变量，不要将字符串文字与SQL语句一起使用。例如：</p>
                           <p>字符串文字的声明：</p><pre class="oac_no_warn" dir="ltr">SELECT * FROM employees WHERE last_name LIKE'KING';</pre><p>绑定变量的语句：</p><pre class="oac_no_warn" dir="ltr">SELECT * FROM employees WHERE last_name LIKE：1;</pre><p>以下示例显示了对简单OLTP应用程序的某些测试的结果：</p><pre class="oac_no_warn" dir="ltr">测试#Users支持否解析所有语句270软解析所有语句150硬解析所有语句60重新连接每个事务30</pre><p>这些测试是在四CPU计算机上进行的。随着系统上CPU数量的增加，差异会增加。</p>
                        </li>
                     </ul>
                  </div>
               </div><a id="TGDBA94123"></a><div class="props_rev_3"><a id="GUID-D322A76C-FBFF-4A54-BD32-FFEA7A3C414F" name="GUID-D322A76C-FBFF-4A54-BD32-FFEA7A3C414F"></a><h4 id="TGDBA-GUID-D322A76C-FBFF-4A54-BD32-FFEA7A3C414F" class="sect4"><span class="enumeration_section">2.5.6</span>实施应用程序</h4>
                  <div>
                     <p><a id="d5548e2230" class="indexterm-anchor"></a><a id="d5548e2234" class="indexterm-anchor"></a><a id="d5548e2236" class="indexterm-anchor"></a>开发环境和编程语言的选择在很大程度上取决于开发团队中可用的技能以及指定应用程序时所做的架构决策。但是，有一些简单的性能管理规则可以实现可扩展的高性能应用程序。
                     </p>
                     <ol>
                        <li>
                           <p>选择适合软件组件的开发环境，不要让它限制您的设计以进行性能决策。如果是，那么您可能选择了错误的语言或环境。</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><a id="d5548e2246" class="indexterm-anchor"></a>用户界面</p>
                                 <p>编程模型可以在HTML生成和直接调用窗口系统之间变化。开发方法应该关注用户界面代码的响应时间。如果通过网络发送HTML或Java，请尝试最小化网络卷和交互。</p>
                              </li>
                              <li>
                                 <p><a id="d5548e2255" class="indexterm-anchor"></a>商业逻辑</p>
                                 <p>解释语言（如Java和PL / SQL）是编码业务逻辑的理想选择。它们完全便携，这使得升级逻辑相对容易。两种语言在语法上都很丰富，以允许易于阅读和解释的代码。如果业务逻辑需要复杂的数学函数，则可能需要编译的二进制语言。业务逻辑代码可以位于客户端计算机，应用程序服务器和数据库服务器上。但是，应用程序服务器是业务逻辑的最常见位置。</p>
                              </li>
                              <li>
                                 <p><a id="d5548e2262" class="indexterm-anchor"></a><a id="d5548e2266" class="indexterm-anchor"></a>用户请求和资源分配</p>
                                 <p>其中大多数不受编程语言的影响，但掩盖数据库连接和游标管理的工具和第四代语言可能使用低效的机制。在评估这些工具和环境时，请检查其数据库连接模型及其对游标和绑定变量的使用。</p>
                              </li>
                              <li>
                                 <p>数据管理和交易</p>
                                 <p>其中大部分不受编程语言的影响。</p>
                              </li>
                           </ul>
                        </li>
                        <li>
                           <p>实现软件组件时，请实现其功能，而不是与其他组件关联的功能。实现另一个组件的功能会导致次优设计和实现。这适用于所有组件。</p>
                        </li>
                        <li>
                           <p>不要在功能上留下空白或在设计，实现或测试中对软件组件进行研究。在许多情况下，在应用程序推出或在实际卷上进行测试之前，不会发现差距。这通常是架构不良或初始系统规范的标志。在初始系统设计，构建和实现过程中，数据存档和清除模块最常被忽略。</p>
                        </li>
                        <li>
                           <p>在实现过程逻辑时，使用过程语言实现，例如C，Java或PL / SQL。在实现数据访问（查询）或数据更改（DML）时，请使用SQL。此规则特定于代码的业务逻辑模块，其中过程代码与数据访问（非过程SQL）代码混合。将过程逻辑放入SQL访问中有很大的诱惑力。这往往会导致资源密集的SQL不佳。带有<code class="codeph">DECODE</code> case语句的SQL语句通常是优化的候选者，具有大量<code class="codeph">OR</code>谓词或集合运算符的语句（如<code class="codeph">UNION</code>和<code class="codeph">MINUS</code> 。</p>
                        </li>
                        <li>
                           <p>缓存频繁访问，很少更改重复检索昂贵的数据。但是，使这个缓存机制易于使用，并确保它确实比访问原始方法中的数据便宜。这适用于应在本地缓存或存储常用数据值的所有模块，而不是从远程或昂贵的数据存储中重复检索。</p>
                           <p>最常见的本地缓存候选者示例包括：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>今天的日期。<code class="codeph">SELECT</code> <code class="codeph">SYSDATE</code> <code class="codeph">FROM</code> <code class="codeph">DUAL</code>可占数据库工作负载的60％以上。
                                 </p>
                              </li>
                              <li>
                                 <p>当前用户名。</p>
                              </li>
                              <li>
                                 <p>重复的应用程序变量和常量，例如税率，折扣率或位置信息。</p>
                              </li>
                              <li>
                                 <p>本地缓存数据可以进一步扩展到在应用服务器中间层中构建本地数据缓存。这有助于减轻中央数据库服务器的负担。但是，在构建本地缓存时应小心谨慎，这样它们就不会变得如此复杂，以至于它们不再能够提高性能。</p>
                              </li>
                              <li>
                                 <p>本地序列生成。</p>
                              </li>
                           </ul>
                           <p>应考虑使用缓存的设计含义。例如，如果用户在午夜连接并且日期被缓存，则用户的日期值将变为无效。</p>
                        </li>
                        <li>
                           <p>优化组件之间的接口，并确保在最可扩展的配置中使用所有组件。此规则需要最少的解释并适用于所有模块及其接口。</p>
                        </li>
                        <li>
                           <p>使用外键引用。通过应用程序实现引用完整性是昂贵的。您可以通过从父级中选择子级的列值并确保它存在来维护外键引用。由Oracle提供的不使用SQL的外键约束实施快速，易于声明，并且不会创建网络流量。</p>
                        </li>
                        <li>
                           <p>考虑在要使用的应用程序中设置操作和模块名称<a id="d5548e2343" class="indexterm-anchor"></a>端到端应用程序跟踪。这样可以更灵活地跟踪工作负载问题。
                           </p>
                        </li>
                     </ol>
                  </div>
               </div><a id="TGDBA94124"></a><div class="props_rev_3"><a id="GUID-AA42DCCB-193C-4ED3-A6B6-D3059B6F4ED2" name="GUID-AA42DCCB-193C-4ED3-A6B6-D3059B6F4ED2"></a><h4 id="TGDBA-GUID-AA42DCCB-193C-4ED3-A6B6-D3059B6F4ED2" class="sect4"><span class="enumeration_section">2.5.7</span>应用程序开发趋势</h4>
                  <div>
                     <p><a id="d5548e2398" class="indexterm-anchor"></a>当今应用程序开发面临的两大挑战是Java越来越多地使用Java来替换已编译的C或C ++应用程序，并且增加了面向对象技术的使用，从而影响了架构设计。
                     </p>
                     <p>Java为程序员提供了更好的代码可用性和可用性。但是，Java存在一些与性能相关的问题。因为Java是一种解释型语言，所以执行类似逻辑的速度比编译语言（例如C）慢。结果，客户端计算机的资源使用量增加。这需要在客户端或中间层计算机中应用更强大的CPU，并且程序员需要更加小心地生成有效的代码。</p>
                     <p>因为Java是一种面向对象的语言，所以它鼓励将数据访问绝缘到不执行业务逻辑的类中。结果，程序员可能在不知道所使用的数据访问方法的效率的情况下调用方法。这往往导致最小的数据库访问，并使用最简单和最粗糙的数据库接口。</p>
                     <p>使用这种类型的软件设计，查询并不总是包含所有<code class="codeph">WHERE</code>谓词都是有效的，并且行过滤在Java程序中执行。这是非常低效的。此外，对于DML操作 - 特别是对于<code class="codeph">INSERT</code> ，执行单个<code class="codeph">INSERT</code> ，无法使用阵列接口。在某些情况下，过程调用会使效率降低。与实际数据库调用相比，使用更多资源将数据移入和移出数据库。
                     </p>
                     <p>通常，最好将数据访问调用放在业务逻辑旁边，以实现最佳的整体事务设计。</p>
                     <p><a id="d5548e2421" class="indexterm-anchor"></a>在编程层面接受面向对象已经导致在Oracle Server中创建面向对象的数据库。这在许多方面表现出来，从在<code class="codeph">BLOB</code>存储对象结构，并且仅将数据库有效地用作索引卡文件到使用Oracle数据库对象关系特征。
                     </p>
                     <p>如果采用面向对象的方法进行模式设计，那么请确保不会失去关系存储模型的灵活性。在许多情况下，面向对象的模式设计方法最终导致严重非规范化的数据结构，需要相当多的维护和与对象关联的<code class="codeph">REF</code>指针。通常，这些设计代表了用关系存储方法取代的分层和网络数据库设计的一个倒退。
                     </p>
                     <p>总之，如果您将数据长期存储在数据库中，并且如果您预期在同一模式上进行一定程度的即席查询或应用程序开发，那么关系存储方法可能会提供最佳性能和灵活性。</p>
                  </div>
               </div>
            </div><a id="TGDBA94125"></a><div class="props_rev_3"><a id="GUID-E6DFD7FD-E2E8-4C34-A81A-D25366F69594" name="GUID-E6DFD7FD-E2E8-4C34-A81A-D25366F69594"></a><h3 id="TGDBA-GUID-E6DFD7FD-E2E8-4C34-A81A-D25366F69594" class="sect3"><span class="enumeration_section">2.6</span>工作负载测试，建模和实现</h3>
               <div>
                  <p>本节介绍工作负载估计，建模，实现和测试。本节包括以下主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="designing-and-developing-for-performance.html#GUID-436CDBC3-D9ED-424E-B06B-429777C12F3A">调整数据大小</a></p>
                     </li>
                     <li>
                        <p><a href="designing-and-developing-for-performance.html#GUID-8CD59302-6016-4A0A-A198-D216341927C6">估算工作量</a></p>
                     </li>
                     <li>
                        <p><a href="designing-and-developing-for-performance.html#GUID-04661179-051C-4F56-992B-DE8C08ECF2EA">应用程序建模</a></p>
                     </li>
                     <li>
                        <p><a href="designing-and-developing-for-performance.html#GUID-03D24516-86DF-407A-814A-2C5FE6629E4D">测试，调试和验证设计</a></p>
                     </li>
                  </ul>
               </div><a id="TGDBA94126"></a><div class="props_rev_3"><a id="GUID-436CDBC3-D9ED-424E-B06B-429777C12F3A" name="GUID-436CDBC3-D9ED-424E-B06B-429777C12F3A"></a><h4 id="TGDBA-GUID-436CDBC3-D9ED-424E-B06B-429777C12F3A" class="sect4"><span class="enumeration_section">2.6.1</span>调整数据大小</h4>
                  <div>
                     <p>如果使用较差的样本集，在处理可变长度数据时，您可能会遇到大小估计中的错误。随着数据量的增长，您的密钥长度可能会大幅增长，从而改变您对列大小的假设。</p>
                     <p>当系统运行时，预测数据库增长变得更加困难，特别是对于索引。表随着时间的推移而增长，并且索引在密钥生成，插入模式和行删除方面受到应用程序的个别行为的影响。最糟糕的情况是使用升序键插入，然后从左侧删除大多数行但不删除所有行。这留下了空隙和浪费的空间。如果你有这样的索引使用，那么请确保你知道如何使用在线索引重建工具。</p>
                     <p>DBA应监视每个对象的空间分配，并查找可能失控的对象。对应用程序的良好理解可以突出可能快速或不可预测地增长的对象。这是任何系统的性能和可用性规划的关键部分。在实现生产数据库时，设计应尝试确保在交互式用户使用应用程序时进行最小的空间管理。这适用于所有数据，临时和回滚段。</p>
                  </div>
               </div><a id="TGDBA94127"></a><div class="props_rev_3"><a id="GUID-8CD59302-6016-4A0A-A198-D216341927C6" name="GUID-8CD59302-6016-4A0A-A198-D216341927C6"></a><h4 id="TGDBA-GUID-8CD59302-6016-4A0A-A198-D216341927C6" class="sect4"><span class="enumeration_section">2.6.2</span>估算工作量</h4>
                  <div>
                     <p><a id="d5548e2612" class="indexterm-anchor"></a><a id="d5548e2614" class="indexterm-anchor"></a>考虑到所涉及的变量数量，估计容量规划和测试目的的工作量非常困难。但是，设计人员必须指定具有CPU，内存和磁盘驱动器的计算机，并最终推出应用程序。有几种技术用于确定尺寸，每种技术都有其优点。在调整大小时，最好使用以下方法来验证您的决策过程并提供支持文档。
                     </p>
                     <div class="section">
                        <p class="subhead3" id="GUID-8CD59302-6016-4A0A-A198-D216341927C6__GUID-C68628BE-1E63-42EF-AFAD-897D2403E3E9">从类似系统推断</p>
                        <p><a id="d5548e2621" class="indexterm-anchor"></a><a id="d5548e2623" class="indexterm-anchor"></a><a id="d5548e2627" class="indexterm-anchor"></a>这是一种完全经验的方法，其中具有相似特征和已知性能的现有系统被用作基础系统。然后，尺寸专家根据已知的差异修改该系统的规格。这种方法的优点在于它与现有系统相关，但在处理差异时几乎没有提供帮助。
                        </p>
                        <p>在准备工程项目（例如大型建筑物，船舶，桥梁或石油钻井平台）的成本时，这种方法几乎用于所有大型工程学科。如果参考系统的大小与预期系统的大小不同，则某些组件可能已超出其设计限制。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-8CD59302-6016-4A0A-A198-D216341927C6__GUID-B83FDFAD-884F-4A1D-B1B7-270EF66EE103">标杆</p>
                        <p><a id="d5548e2636" class="indexterm-anchor"></a><a id="d5548e2638" class="indexterm-anchor"></a><a id="d5548e2642" class="indexterm-anchor"></a>基准测试过程既耗费资源又耗时，并且可能无法产生正确的结果。通过在早期开发或原型中模拟应用程序，存在测量与实际生产系统无关的事物的危险。这听起来很奇怪，但在多年来使用数据库开发组织对客户应用程序进行基准测试时，Oracle尚未看到基准应用程序与实际生产系统之间的可靠关联。这主要是由于开发过程中引入的应用程序效率低下的数量。
                        </p>
                        <p>但是，基准测试已成功用于将系统规模调整到可接受的准确度。特别是，基准测试非常擅长确定系统满载时的实际I / O要求和测试恢复过程。</p>
                        <p>基准性质本质上强调所有系统组件的极限。由于基准测试强调所有组件，因此请准备好在基准测试时看到应用程序设计和实现中的所有错误。基准测试还测试数据库，操作系统和硬件组件。由于大多数基准测试都是匆忙执行的，因此在系统组件发生故障时会出现挫折和问题。基准测试是一项压力很大的活动，需要相当多的经验才能充分利用基准测试练习。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="TGDBA94130"></a><div class="props_rev_3"><a id="GUID-04661179-051C-4F56-992B-DE8C08ECF2EA" name="GUID-04661179-051C-4F56-992B-DE8C08ECF2EA"></a><h4 id="TGDBA-GUID-04661179-051C-4F56-992B-DE8C08ECF2EA" class="sect4"><span class="enumeration_section">2.6.3</span>应用程序建模</h4>
                  <div>
                     <p><a id="d5548e2700" class="indexterm-anchor"></a><a id="d5548e2702" class="indexterm-anchor"></a>应用程序建模的范围可以从复杂的数学建模练习到在信封背面执行的经典简单计算。这两种方法都有其优点，一种方法试图非常精确，另一种方法估计总量。这两种方法的缺点是它们不允许实现错误和低效率。
                     </p>
                     <p>估算和尺寸调整过程是一项不精确的科学。但是，通过调查过程，可以进行一些智能估算。整个估算过程不允许因不良SQL，索引设计或游标管理引入的应用程序低效。规模调整工程师应该为应用程序效率低下建立边际。性能工程师应该发现效率低下并使估算看起来很现实。Oracle性能方法描述了如何发现应用程序的低效率。</p>
                  </div>
               </div><a id="TGDBA94131"></a><div class="props_rev_3"><a id="GUID-03D24516-86DF-407A-814A-2C5FE6629E4D" name="GUID-03D24516-86DF-407A-814A-2C5FE6629E4D"></a><h4 id="TGDBA-GUID-03D24516-86DF-407A-814A-2C5FE6629E4D" class="sect4"><span class="enumeration_section">2.6.4</span>测试，调试和验证设计</h4>
                  <div>
                     <p><a id="d5548e2759" class="indexterm-anchor"></a><a id="d5548e2761" class="indexterm-anchor"></a><a id="d5548e2763" class="indexterm-anchor"></a><a id="d5548e2767" class="indexterm-anchor"></a><a id="d5548e2769" class="indexterm-anchor"></a><a id="d5548e2773" class="indexterm-anchor"></a><a id="d5548e2775" class="indexterm-anchor"></a>测试过程主要包括功能和稳定性测试。在该过程中的某个时刻，执行性能测试。
                     </p>
                     <p>以下列表描述了一些用于性能测试应用程序的简单规则。如果记录正确，则此列表在应用程序上线后为生产应用程序和容量规划过程提供重要信息。</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>使用自动数据库诊断监视器（ADDM）和SQL Tuning Advisor进行设计验证</p>
                        </li>
                        <li>
                           <p>使用实际数据量和分布进行测试</p>
                           <p>所有测试必须使用完全填充的表格完成。测试数据库应包含代表生产系统的数据，包括表格之间的数据量和基数。应构建所有生产索引，并正确填充模式统计信息。</p>
                        </li>
                        <li>
                           <p>使用正确的优化程序模式</p>
                           <p>使用您计划在生产中使用的优化程序模式执行所有测试。所有Oracle数据库研究和开发工作都集中在查询优化器上。因此，建议使用查询优化器。</p>
                        </li>
                        <li>
                           <p>测试单个用户性能</p>
                           <p>在空闲或轻度使用的数据库上测试单个用户以获得可接受的性能。如果单个用户在理想条件下无法达到可接受的性能，则多个用户在实际条件下无法实现可接受的性能。</p>
                        </li>
                        <li>
                           <p>获取并记录所有SQL语句的计划</p>
                           <p>获取每个SQL语句的执行计划。使用此过程验证优化程序是否正在获取最佳执行计划，并且可以根据CPU时间和物理I / O来理解SQL语句的相对成本。此过程有助于识别将来需要进行最多调整和性能工作的大量使用事务。</p>
                        </li>
                        <li>
                           <p>尝试多用户测试</p>
                           <p>此过程难以准确执行，因为用户工作负载和配置文件可能无法完全量化。但是，应测试执行DML语句的事务以确保不存在锁定冲突或序列化问题。</p>
                        </li>
                        <li>
                           <p>使用正确的硬件配置进行测试</p>
                           <p>使用尽可能靠近生产系统的配置进行测试。使用真实的系统对于网络延迟，I / O子系统带宽以及处理器类型和速度尤为重要。如果不使用此方法，可能会导致对潜在性能问题的错误分析。</p>
                        </li>
                        <li>
                           <p>测量稳态性能</p>
                           <p>在进行基准测试时，在稳态条件下测量性能非常重要。每个基准测试运行应该有一个提升阶段，用户连接到应用程序并逐渐开始执行应用程序的工作。此过程允许将频繁缓存的数据初始化到缓存中，并且单个执行操作（例如解析）在稳态条件之前完成。同样，在基准测试运行结束时，应该有一个减速期，资源从系统中释放出来，用户停止工作和断开连接。</p>
                        </li>
                     </ul>
                  </div>
               </div>
            </div><a id="TGDBA94132"></a><div class="props_rev_3"><a id="GUID-2E491D68-37F1-4D6B-B6E8-841A2C050E76" name="GUID-2E491D68-37F1-4D6B-B6E8-841A2C050E76"></a><h3 id="TGDBA-GUID-2E491D68-37F1-4D6B-B6E8-841A2C050E76" class="sect3"><span class="enumeration_section">2.7</span>部署新应用程序</h3>
               <div>
                  <p><a id="d5548e2871" class="indexterm-anchor"></a><a id="d5548e2875" class="indexterm-anchor"></a>以下是部署应用程序时涉及的关键设计决策：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="designing-and-developing-for-performance.html#GUID-BF4B19B8-B09A-40EE-B453-F31A98D003F5">推出策略</a></p>
                     </li>
                     <li>
                        <p><a href="designing-and-developing-for-performance.html#GUID-DFCECF0D-152F-4892-9B17-24BD0744444E">绩效核对表</a></p>
                     </li>
                  </ul>
               </div><a id="TGDBA94133"></a><div class="props_rev_3"><a id="GUID-BF4B19B8-B09A-40EE-B453-F31A98D003F5" name="GUID-BF4B19B8-B09A-40EE-B453-F31A98D003F5"></a><h4 id="TGDBA-GUID-BF4B19B8-B09A-40EE-B453-F31A98D003F5" class="sect4"><span class="enumeration_section">2.7.1</span>推出策略</h4>
                  <div>
                     <p>在推出新应用程序时，通常采用两种策略：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a id="d5548e2943" class="indexterm-anchor"></a><a id="d5548e2947" class="indexterm-anchor"></a> Big Bang方法 - 所有用户立即迁移到新系统</p>
                        </li>
                        <li>
                           <p><a id="d5548e2952" class="indexterm-anchor"></a><a id="d5548e2956" class="indexterm-anchor"></a>涓流方法 - 用户从现有系统慢慢迁移到新系统</p>
                        </li>
                     </ul>
                     <p>这两种方法都有优点和缺点。Big Bang方法依赖于以所需规模对应用程序进行可靠测试，但具有最小化数据转换和与旧系统同步的优势，因为它只是关闭。Trickle方法允许在工作负载增加时调试可伸缩性问题，但可能意味着必须在迁移发生时将数据迁移到遗留系统和从遗留系统迁移。</p>
                     <p>很难推荐一种方法而不是另一种方法，因为每种方法都存在相关风险，可能会在转换发生时导致系统中断。当然，Trickle方法允许在引入新应用程序时对真实用户进行概要分析，并允许重新配置系统，同时仅影响迁移的用户。这种方法会影响早期采用者的工作，但会限制支持服务的负担。这意味着计划外中断仅影响一小部分用户群。</p>
                     <p>关于如何推出新应用程序的决定是针对每个业务的。任何采用的方法都有其独特的压力和压力。您从测试过程中获得的测试和知识越多，您就越了解什么是最适合推出的产品。</p>
                  </div>
               </div><a id="TGDBA94134"></a><div class="props_rev_3"><a id="GUID-DFCECF0D-152F-4892-9B17-24BD0744444E" name="GUID-DFCECF0D-152F-4892-9B17-24BD0744444E"></a><h4 id="TGDBA-GUID-DFCECF0D-152F-4892-9B17-24BD0744444E" class="sect4"><span class="enumeration_section">2.7.2</span>性能检查表</h4>
                  <div>
                     <div class="section">
                        <p>为了帮助推出，请构建一个任务列表，以增加生产中最佳性能的可能性，并实现应用程序的快速调试。请执行下列操作：</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li><span>为生产数据库创建控制文件时，通过将<code class="codeph">MAXINSTANCES</code> ， <code class="codeph">MAXDATAFILES</code> ， <code class="codeph">MAXLOGFILES</code> ， <code class="codeph">MAXLOGMEMBERS</code>和<code class="codeph">MAXLOGHISTORY</code>为高于您预期的卷展栏的值来允许增长。此技术会导致更多的磁盘空间使用和更大的控制文件，但如果在紧急情况下需要扩展，则可以节省时间。</span></li>
                        <li><span>将块大小设置为用于开发应用程序的值。如果在代表性数据卷上执行测试并且当前SQL执行计划正确，则将架构统计信息从开发或测试环境导出到生产数据库。</span></li>
                        <li><span>设置最小数量的初始化参数。理想情况下，大多数其他参数应保留为默认值。如果要执行更多调整，则在系统处于负载状态时会出现此调整。</span></li>
                        <li><span>准备通过设置数据库对象的存储选项来管理块争用。应使用自动段空间管理创建经历高<code class="codeph">INSERT</code> / <code class="codeph">UPDATE</code> / <code class="codeph">DELETE</code>速率的表和索引。要避免回滚段的争用，请使用自动撤消管理。</span></li>
                        <li><span>应验证所有SQL语句是否最佳并理解其资源使用情况。</span></li>
                        <li><span>验证连接到数据库的中间件和程序在连接管理中是否有效，并且不会重复登录或注销。</span></li>
                        <li><span>验证SQL语句是否有效地使用游标。数据库应解析每个SQL语句一次，然后多次执行。这种情况最常见的原因是没有正确使用绑定变量， <code class="codeph">WHERE</code>子句谓词作为字符串文字发送。如果使用预编译器开发应用程序，请确保在预编译应用程序之前从默认值重置参数<code class="codeph">MAXOPENCURSORS</code> ， <code class="codeph">HOLD_CURSOR</code>和<code class="codeph">RELEASE_CURSOR</code> 。</span></li>
                        <li><span>验证所有模式对象是否已从开发环境正确迁移到生产数据库。这包括表，索引，序列，触发器，包，过程，函数，Java对象，同义词，授权和视图。确保对生产系统进行任何测试修改。</span></li>
                        <li><span>系统推出后，立即从数据库和操作系统建立一组基准统计信息。第一组统计信息验证或更正在设计和部署过程中所做的任何假设。</span></li>
                        <li><span>开始预测第一个瓶颈（这是不可避免的）并遵循Oracle性能方法来提高性能。</span></li>
                     </ol>
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>