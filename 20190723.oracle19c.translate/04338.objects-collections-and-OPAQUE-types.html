<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <title>对象，集合和OPAQUE类型</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="SQLJ Developer&#39;s Guide "></meta>
      <meta property="og:description" content=""></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="SQLJ Developer&#39;s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="sqlj-developers-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-11T08:20:03-08:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="1999, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96458-01"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="type-support.html" title="Previous" type="text/html"></link>
      <link rel="next" href="advanced-language-features.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="SQLJ Developer&#39;s Guide"></meta>
    <meta name="dcterms.isVersionOf" content="JSQLJ"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="type-support.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="advanced-language-features.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">SQLJ开发人员指南</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">对象，集合和OPAQUE类型</li>
            </ol>
            <a id="GUID-93B64A3E-4928-4039-BC10-D7B05E768BFF" name="GUID-93B64A3E-4928-4039-BC10-D7B05E768BFF"></a><a id="JSQLJ409"></a>
            
            <h2 id="JSQLJ-GUID-93B64A3E-4928-4039-BC10-D7B05E768BFF" class="sect2"><span class="enumeration_chapter">7个</span>对象，集合和OPAQUE类型</h2>
         </header>
         <div class="ind">
            <div>
               <p>本章讨论Oracle SQLJ实现如何支持用户定义的SQL类型。关于Oracle OPAQUE类型，最后还有一小部分。</p>
               <p>本章包括以下部分：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="objects-collections-and-OPAQUE-types.html#GUID-83FAE830-C137-413B-8654-5378A60A2E03">Oracle对象和集合</a></p>
                  </li>
                  <li>
                     <p><a href="objects-collections-and-OPAQUE-types.html#GUID-7B1AEDD4-C53B-47C9-973E-DD23EAA7608E">自定义Java类</a></p>
                  </li>
                  <li>
                     <p><a href="objects-collections-and-OPAQUE-types.html#GUID-88A459DA-AC72-4DD9-9143-BCD47CD6FF8B">用户定义的类型</a></p>
                  </li>
                  <li>
                     <p><a href="objects-collections-and-OPAQUE-types.html#GUID-A8FBF9FD-A786-4C6E-B093-9B179F079810">SQLJ可执行语句中的强类型对象和引用</a></p>
                  </li>
                  <li>
                     <p><a href="objects-collections-and-OPAQUE-types.html#GUID-B58EDE94-BD0C-4C00-960B-4D8267F72DFD">SQLJ可执行语句中强类型的集合</a></p>
                  </li>
                  <li>
                     <p><a href="objects-collections-and-OPAQUE-types.html#GUID-4A2FC8B8-81B2-4B3B-B0D4-1102A7F7F21A">序列化的Java对象</a></p>
                  </li>
                  <li>
                     <p><a href="objects-collections-and-OPAQUE-types.html#GUID-14DEE7DC-EA4A-4754-BF44-D1036E1CFB55">弱类型Objects_ References_和Collections</a></p>
                  </li>
                  <li>
                     <p><a href="objects-collections-and-OPAQUE-types.html#GUID-526F6AD9-AD62-4ED0-BCAB-5C2F8ED36FE4">Oracle OPAQUE类型</a></p>
                  </li>
               </ul>
            </div><a id="JSQLJ410"></a><div class="props_rev_3"><a id="GUID-83FAE830-C137-413B-8654-5378A60A2E03" name="GUID-83FAE830-C137-413B-8654-5378A60A2E03"></a><h3 id="JSQLJ-GUID-83FAE830-C137-413B-8654-5378A60A2E03" class="sect3">Oracle对象和集合</h3>
               <div>
                  <p>本节提供有关Oracle Database 12 <span class="italic">c</span>第2版（12.2）对象和集合的一些背景概念信息。
                  </p>
                  <div class="infoboxnotealso" id="GUID-83FAE830-C137-413B-8654-5378A60A2E03__GUID-31E81DE6-4FD3-495F-8C99-47989088638D">
                     <p class="notep1">也可以看看：</p>
                     <p><a href="../sqlrf/Database-Objects.html#SQLRF-GUID-31BE00A7-7FF9-41CB-852A-F1416912CA9E" target="_blank"><span class="italic">Oracle数据库SQL语言参考</span></a>和<a href="../adfns/sql-data-types.html#ADFNS-GUID-CCC643C7-88E1-421C-87DC-4353899FFB9E" target="_blank"><span class="italic">Oracle数据库开发指南</span></a> 。
                     </p>
                  </div>
                  <p>本节包括以下主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="objects-collections-and-OPAQUE-types.html#GUID-535092B2-B9CA-4978-A01E-6209609B579D">对象和集合概述</a></p>
                     </li>
                     <li>
                        <p><a href="objects-collections-and-OPAQUE-types.html#GUID-D0DE1809-5FA2-4558-89DC-D766822E6CA7">Oracle对象基础知识</a></p>
                     </li>
                     <li>
                        <p><a href="objects-collections-and-OPAQUE-types.html#GUID-B764C3B0-D3E8-4BE0-9A04-DC192C7FC300">Oracle Collection Fundamentals</a></p>
                     </li>
                     <li>
                        <p><a href="objects-collections-and-OPAQUE-types.html#GUID-BADD65E0-1975-4B2F-8F59-D3A693D31591">对象和集合数据类型</a></p>
                     </li>
                  </ul>
               </div><a id="JSQLJ412"></a><a id="JSQLJ413"></a><a id="JSQLJ411"></a><div class="props_rev_3"><a id="GUID-535092B2-B9CA-4978-A01E-6209609B579D" name="GUID-535092B2-B9CA-4978-A01E-6209609B579D"></a><h4 id="JSQLJ-GUID-535092B2-B9CA-4978-A01E-6209609B579D" class="sect4">对象和集合概述</h4>
                  <div>
                     <p>Oracle SQLJ实现支持用户定义的SQL对象类型，它们是复合数据结构，相关SQL对象引用类型和用户定义的SQL集合类型。Oracle对象和集合是由各个数据元素组成的复合数据结构。</p>
                     <p>Oracle SQLJ实现支持在迭代器或宿主表达式中使用的对象类型，引用类型和集合类型的强类型或弱类型Java表示。强类型表示使用映射到特定对象类型，引用类型或集合类型的自定义Java类，并且必须实现Java数据库连接（JDBC）2.0标准<code class="codeph">java.sql.SQLData</code>接口，仅用于对象类型，或Oracle <code class="codeph">oracle.sql.ORAData</code>接口。
                     </p>
                     <p>术语stron gly typed用于特定Java类型与特定SQL命名类型或用户定义类型相关联的情况。例如，如果存在<code class="codeph">PERSON</code>类型，则会将相应的<code class="codeph">Person</code> Java类与其关联。
                     </p>
                     <p>弱类型表示使用<code class="codeph">oracle.sql.对象的STRUCT</code> ， <code class="codeph">oracle.sql.REF</code>用于对象引用，或<code class="codeph">oracle.sql.ARRAY</code>收藏品。或者，您可以使用标准<code class="codeph">java.sql.Struct</code> ， <code class="codeph">java.sql.Ref</code>或<code class="codeph">java.sql.弱类型场景中的Array</code>对象。
                     </p>
                     <p>wea kly typed这个术语用于Java类型以通用方式使用的地方，可以映射到多个SQL命名类型。Java类或接口没有特定于任何SQL类型的特殊信息。这是<code class="codeph">oracle.sql.的情况<code class="codeph">oracle.sql.STRUCT</code> ， <code class="codeph">oracle.sql.REF</code>和<code class="codeph">oracle.sql.ARRAY</code>类型和<code class="codeph">java.sql.Struct</code> ， <code class="codeph">java.sql.Ref</code>和<code class="codeph">java.sql.Array</code>类型。
                     </p>
                     <p>请注意，在代码中使用Oracle扩展需要以下内容：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>使用Oracle JDBC驱动程序之一。</p>
                        </li>
                        <li>
                           <p>使用默认的Oracle特定代码生成，或者，对于ISO代码生成，适当地自定义配置文件。对于特定于Oracle的生成代码，不会生成任何配置文件，因此自定义不适用。Oracle JDBC应用程序编程接口（API）直接通过生成的Java代码调用。</p>
                           <div class="infoboxnote" id="GUID-535092B2-B9CA-4978-A01E-6209609B579D__GUID-C9E90461-A7B3-4278-A8AD-B2FE60B33C61">
                              <p class="notep1">注意：</p>
                              <p>Oracle建议使用默认的自定义程序<code class="codeph">oracle.sqlj.runtime.util.OraCustomizer</code> 。
                              </p>
                           </div>
                        </li>
                        <li>
                           <p>在应用程序运行时使用Oracle SQLJ运行时。即使您没有在代码中实际使用Oracle扩展，每当您使用Oracle自定义程序时，都需要Oracle SQLJ运行时和Oracle JDBC驱动程序。</p>
                        </li>
                     </ul>
                     <p>对于特定于Oracle的语义检查，您必须使用适当的检查程序。默认检查器<code class="codeph">oracle.sqlj.checker.OracleChecker</code>充当前端，将根据您的环境运行相应的检查程序。如果您使用的是Oracle JDBC驱动程序，那么这将是Oracle特定的检查程序之一。
                     </p>
                     <div class="infoboxnote" id="GUID-535092B2-B9CA-4978-A01E-6209609B579D__GUID-C034D024-E023-4F6E-B390-2E5FB82C96A3">
                        <p class="notep1">注意：</p>
                        <p>Oracle对象和集合的Oracle特定类型包含在<code class="codeph">oracle.sql</code>包中。
                        </p>
                     </div>
                     <div class="infoboxnotealso" id="GUID-535092B2-B9CA-4978-A01E-6209609B579D__GUID-3CF36A38-7E2C-4A91-A180-87CD56E3DA39">
                        <p class="notep1">也可以看看：</p>
                        <p><span class="q">“ <a href="translator-command-line-and-options.html#GUID-E001FA35-824A-47A1-8973-AA5771B0DFE5">连接选项</a> ”</span>和<span class="q">“ <a href="translator-command-line-and-options.html#GUID-ED7DD3DE-CA91-4085-82B2-D07EC9B15FB6">语义 - 检查和脱机 - 解析选项</a> ”</span></p>
                     </div>
                     <div class="section">
                        <p class="subhead3" id="GUID-535092B2-B9CA-4978-A01E-6209609B579D__GUID-E505B2A1-D691-4E7A-9D48-BE09505E01FE">自定义Java类使用说明</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p>本章主要讨论使用具有用户定义类型的自定义Java类。但是，实现<code class="codeph">ORAData</code>类也可以用于其他Oracle SQL类型。实现<code class="codeph">ORAData</code>的类可用于在SQL和Java之间传输数据的过程中执行任何类型的所需处理或转换。
                              </p>
                              <div class="infoboxnotealso" id="GUID-535092B2-B9CA-4978-A01E-6209609B579D__GUID-F5985ACE-4494-448B-9928-9B5E963A902A">
                                 <p class="notep1">也可以看看：</p>
                                 <p><span class="q">“ <a href="objects-collections-and-OPAQUE-types.html#GUID-1F822A17-F41C-4994-95BB-886397ACFAE3">ORAData实现的其他用途</a> ”</span></p>
                              </div>
                           </li>
                           <li>
                              <p><code class="codeph">SQLData</code>接口仅适用于自定义对象类。<code class="codeph">ORAData</code>接口可用于任何自定义Java类。
                              </p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-535092B2-B9CA-4978-A01E-6209609B579D__GUID-D84FE6D8-6B4A-4ABF-9A2A-F16EF64ED31F">术语说明</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p>用户定义的SQL对象类型和用户定义的SQL集合类型称为用户定义的类型（UDT）。</p>
                           </li>
                           <li>
                              <p>对象，引用和集合的自定义Java类分别称为自定义对象类，自定义引用类和自定义集合类。</p>
                           </li>
                        </ul>
                        <div class="infoboxnotealso" id="GUID-535092B2-B9CA-4978-A01E-6209609B579D__GUID-AC170A44-CEEC-40FA-8CB0-A0CB783A1A1D">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="../adobj/introduction-to-oracle-objects.html#ADOBJ-GUID-7667A5B4-22E3-465F-9F7B-7043A9525DD2" target="_blank"><span class="italic">Oracle数据库对象关系开发人员指南</span></a> ，了解有关Oracle对象特性和功能的一般信息</p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ414"></a><div class="props_rev_3"><a id="GUID-D0DE1809-5FA2-4558-89DC-D766822E6CA7" name="GUID-D0DE1809-5FA2-4558-89DC-D766822E6CA7"></a><h4 id="JSQLJ-GUID-D0DE1809-5FA2-4558-89DC-D766822E6CA7" class="sect4">Oracle对象基础知识</h4>
                  <div>
                     <p>Oracle SQL对象是复合数据结构，它将相关数据项（例如每个员工的事实）分组到一个数据单元中。对象类型在功能上类似于Java类。您可以填充和使用给定对象类型的任意数量的单个对象，就像您可以实例化和使用Java类的单个对象一样。</p>
                     <p>例如，你可以定义一个对象类型<code class="codeph">EMPLOYEE</code>具有属性<code class="codeph">name</code>类型的<code class="codeph">CHAR</code> ， <code class="codeph">address</code>类型的<code class="codeph">CHAR</code> ， <code class="codeph">phonenumber</code>类型的<code class="codeph">CHAR</code>和<code class="codeph">employeenumber</code>类型的<code class="codeph">NUMBER</code> 。</p>
                     <p>Oracle对象还可以具有与对象类型关联的方法或存储过程。这些方法可以是静态方法，也可以是实例方法，可以在PL / SQL或Java中实现。它们的签名可以包括任意数量的输入，输出或输入输出参数。所有这些都取决于它们最初的定义方式</p>
                  </div>
               </div><a id="JSQLJ415"></a><div class="props_rev_3"><a id="GUID-B764C3B0-D3E8-4BE0-9A04-DC192C7FC300" name="GUID-B764C3B0-D3E8-4BE0-9A04-DC192C7FC300"></a><h4 id="JSQLJ-GUID-B764C3B0-D3E8-4BE0-9A04-DC192C7FC300" class="sect4">Oracle Collection Fundamentals</h4>
                  <div>
                     <p>有两类Oracle SQL集合：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a id="d32224e422" class="indexterm-anchor"></a>可变长度数组（VARRAY类型）</p>
                        </li>
                        <li>
                           <p><a id="d32224e429" class="indexterm-anchor"></a>嵌套表（TABLE类型）</p>
                        </li>
                     </ul>
                     <p>两个类别都是一维的，尽管元素可以是复杂的对象类型。VARRAY类型用于一维数组，嵌套表类型用于外部表中的单列表。任何VARRAY类型的变量都可以称为VARRAY。任何嵌套表类型的变量都可以称为嵌套表。</p>
                     <p>与任何数组一样，VARRAY是一组有序的数据元素，每个元素都有一个索引，所有元素都具有相同的数据类型。VARRAY的大小是指元素的最大数量。Oracle VARRAYs，如其名称所示，具有可变大小，但在声明VARRAY类型时，必须指定任何特定VARRAY类型的最大大小。</p>
                     <p>嵌套表是一组无序元素。表中的嵌套表元素本身可以在SQL中查询。与任何表一样，嵌套表不会使用任何特定数量的行创建。这是动态确定的。</p>
                     <div class="infoboxnote" id="GUID-B764C3B0-D3E8-4BE0-9A04-DC192C7FC300__GUID-B67BEE30-0D52-4C1C-BD8E-7008B83D1D4E">
                        <p class="notep1">注意：</p>
                        <p>VARRAY中的元素或嵌套表中的行可以是用户定义的对象类型，VARRAY和嵌套表类型可以用于用户定义的对象类型中的属性。Oracle Database 12 <span class="italic">c</span>第2版（12.2）支持嵌套类型的嵌套。VARRAY的元素或嵌套表的行可以是另一个VARRAY或嵌套表类型，或者这些元素可以是具有VARRAY或嵌套表属性的用户定义对象类型。
                        </p>
                     </div>
                  </div>
               </div><a id="JSQLJ416"></a><div class="props_rev_3"><a id="GUID-BADD65E0-1975-4B2F-8F59-D3A693D31591" name="GUID-BADD65E0-1975-4B2F-8F59-D3A693D31591"></a><h4 id="JSQLJ-GUID-BADD65E0-1975-4B2F-8F59-D3A693D31591" class="sect4">对象和集合数据类型</h4>
                  <div>
                     <p>在Oracle Database 12 <span class="italic">c</span>第2版（12.2）中，用户定义的对象和集合定义用作SQL数据类型定义。在定义表列，SQL对象属性和存储过程或函数参数时，可以像使用任何其他数据类型一样使用这些数据类型。此外，一旦定义了对象类型，相关对象引用类型就可以用作任何其他SQL引用类型。
                     </p>
                     <p>例如，请考虑上一节中描述的<code class="codeph">EMPLOYEE</code> Oracle对象。定义此对象后，它将成为Oracle数据类型。您可以拥有类型为<code class="codeph">EMPLOYEE</code>的表列，就像您可以拥有<code class="codeph">NUMBER</code>类型的表列一样。 <code class="codeph">EMPLOYEE</code>列中的每一行都包含一个完整的<code class="codeph">EMPLOYEE</code>对象。您还可以使用<code class="codeph">REF EMPLOYEE</code>列类型，其中包含对<code class="codeph">EMPLOYEE</code>对象的引用。
                     </p>
                     <p>类似地，您可以将可变长度数组<code class="codeph">MYVARR</code>定义为<code class="codeph">NUMBER</code> <code class="codeph">VARRAY(10)</code>和<code class="codeph">CHAR(20)</code>的嵌套表<code class="codeph">NTBL</code> 。<code class="codeph">MYVARR</code>和<code class="codeph">NTBL</code>集合类型成为Oracle数据类型，您可以拥有任一类型的表列。<code class="codeph">MYVARR</code>列的每一行都包含一个最多10个数字的数组。<code class="codeph">NTBL</code>列的每一行由20个字符组成。
                     </p>
                  </div>
               </div>
            </div><a id="JSQLJ417"></a><div class="props_rev_3"><a id="GUID-7B1AEDD4-C53B-47C9-973E-DD23EAA7608E" name="GUID-7B1AEDD4-C53B-47C9-973E-DD23EAA7608E"></a><h3 id="JSQLJ-GUID-7B1AEDD4-C53B-47C9-973E-DD23EAA7608E" class="sect3">自定义Java类</h3>
               <div>
                  <p>自定义Java类是第一类类型，可用于透明地读取和写入用户定义的SQL类型。自定义Java类的目的是提供一种在SQL和Java之间转换数据并使数据可访问的方法，特别是在支持对象和集合时，或者如果要执行自定义数据转换。</p>
                  <p>通常建议为在SQLJ应用程序中使用的所有用户定义类型提供自定义Java类。Oracle JDBC驱动程序将使用这些类的实例来转换数据，这比使用弱类型的<code class="codeph">oracle.sql.更方便，更不容易出错<code class="codeph">oracle.sql.STRUCT</code> ， <code class="codeph">oracle.sql.REF</code>和<code class="codeph">oracle.sql.ARRAY</code>课程。
                  </p>
                  <p>要在SQLJ迭代器或主机表达式中使用，自定义Java类必须实现<code class="codeph">oracle.sql.ORAData</code>和<code class="codeph">oracle.sql.ORADataFactory</code>接口或标准<code class="codeph">java.sql.SQLData</code>接口。本节概述了这些接口和自定义Java类功能，包括以下主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="objects-collections-and-OPAQUE-types.html#GUID-B1819CB7-8F69-4B34-BF26-CABFA465F17F">自定义Java类接口规范</a></p>
                     </li>
                     <li>
                        <p><a href="objects-collections-and-OPAQUE-types.html#GUID-BCB8194D-F72A-4ABC-AFA2-A69711002B80">对象方法的自定义Java类支持</a></p>
                     </li>
                     <li>
                        <p><a href="objects-collections-and-OPAQUE-types.html#GUID-240D3A7C-D69A-4599-8B9B-6E0B9312853D">自定义Java类要求</a></p>
                     </li>
                     <li>
                        <p><a href="objects-collections-and-OPAQUE-types.html#GUID-700E14BF-E4F8-4A36-9092-05000452C60B">编译自定义Java类</a></p>
                     </li>
                     <li>
                        <p><a href="objects-collections-and-OPAQUE-types.html#GUID-9B5BACD2-3100-46FB-8B3F-A1B0557BF7F7">阅读和编写自定义数据</a></p>
                     </li>
                     <li>
                        <p><a href="objects-collections-and-OPAQUE-types.html#GUID-1F822A17-F41C-4994-95BB-886397ACFAE3">ORAData实现的其他用途</a></p>
                     </li>
                  </ul>
               </div><a id="JSQLJ419"></a><a id="JSQLJ421"></a><a id="JSQLJ418"></a><div class="props_rev_3"><a id="GUID-B1819CB7-8F69-4B34-BF26-CABFA465F17F" name="GUID-B1819CB7-8F69-4B34-BF26-CABFA465F17F"></a><h4 id="JSQLJ-GUID-B1819CB7-8F69-4B34-BF26-CABFA465F17F" class="sect4">自定义Java类接口规范</h4>
                  <div>
                     <div class="section">
                        <p>本节讨论<code class="codeph">ORAData</code>和<code class="codeph">ORADataFactory</code>接口以及标准<code class="codeph">SQLData</code>接口的规范。
                        </p>
                        <p>Oracle Database 12 <span class="italic">c</span>第2版（12.2）包含一组API，用于针对用户定义类型的Oracle特定的自定义Java类功能： <code class="codeph">oracle.sql.ORAData</code>和<code class="codeph">oracle.sql.ORADataFactory</code> 。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-B1819CB7-8F69-4B34-BF26-CABFA465F17F__GUID-755AD7E5-59DF-4D06-BA3B-81EED07E7AD6">ORAData和ORADataFactory规范</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>Oracle提供了<code class="codeph">oracle.sql.ORAData</code>接口和相关的<code class="codeph">oracle.sql.ORADataFactory</code>接口，用于将Oracle对象类型，引用类型和集合类型映射和转换为自定义Java类。
                        </p>
                        <p>以<code class="codeph">oracle.sql.的形式发送或检索数据<code class="codeph">oracle.sql.Datum</code>对象，底层数据采用适当的<code class="codeph">oracle.sql.格式<code class="codeph">oracle.sql.Datum</code>子类，例如<code class="codeph">oracle.sql.STRUCT</code> 。此数据仍为SQL格式。<code class="codeph">oracle.sql.Datum</code>对象只是一个包装器。
                        </p>
                        <div class="infoboxnotealso" id="GUID-B1819CB7-8F69-4B34-BF26-CABFA465F17F__GUID-1198871C-6658-4BEC-AA49-199C99152250">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="../jjdbc/Oracle-object-types.html#JJDBC-GUID-5905674A-A045-40B1-96DE-726761517D50" target="_blank"><span><cite>Oracle数据库JDBC开发人员指南</cite></span></a></p>
                        </div>
                        <p><code class="codeph">ORAData</code>接口指定用于从Java格式到SQL格式的数据转换的<code class="codeph">toDatum()</code>方法。此方法将连接对象作为输入，并将数据转换为适当的<code class="codeph">oracle.sql.*</code>表示。连接对象是必需的，以便JDBC驱动程序可以在运行时执行适当的类型检查和类型转换。<code class="codeph">ORAData</code>和<code class="codeph">toDatum()</code>规范如下：</p><pre class="oac_no_warn" dir="ltr">接口oracle.sql。ORAData {oracle.sql。Datum toDatum（java.sql。连接c）抛出SQLException; }</pre><p><code class="codeph">ORADataFactory</code>接口指定一个<code class="codeph">create()</code>方法，该方法构造自定义Java类的实例，从SQL格式转换为Java格式。此方法将包含数据的<code class="codeph">Datum</code>对象和类型代码（如<code class="codeph">OracleTypes.作为输入<code class="codeph">OracleTypes.RAW</code> ，表示底层数据的SQL类型。它返回自定义Java类的对象，该类实现<code class="codeph">ORAData</code>接口。此对象从输入的<code class="codeph">Datum</code>对象接收其数据。<code class="codeph">ORADataFactory</code>和<code class="codeph">create()</code>规范如下：</p><pre class="oac_no_warn" dir="ltr">接口oracle.sql。ORADataFactory {oracle.sql。ORAData create（oracle.sql。Datum d，int sqlType）抛出SQLException; }</pre><p>要完成<code class="codeph">ORAData</code>和<code class="codeph">ORADataFactory</code>接口之间的关系，必须在任何实现<code class="codeph">ORAData</code>接口的自定义Java类中实现静态<code class="codeph">getORADataFactory()</code>方法。此方法返回一个实现<code class="codeph">ORADataFactory</code>接口的对象，因此可用于创建自定义Java类的实例。返回的对象本身可以是自定义Java类的实例，并且Oracle JDBC驱动程序使用其<code class="codeph">create()</code>方法根据需要生成自定义Java类的更多实例。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-B1819CB7-8F69-4B34-BF26-CABFA465F17F__GUID-AB441F71-EEC4-404E-8AA6-FA0399EDF7E4">SQLData规范</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>标准JDBC 2.0提供<code class="codeph">java.sql.用于映射和将结构化对象类型转换为Java类的SQLData</code>接口。此接口仅用于映射结构化对象类型，而不是对象引用，集合或数组或其他SQL类型。
                        </p>
                        <p>所述<code class="codeph">SQLData</code>接口是JDBC 2.0标准，指定一个<code class="codeph">readSQL()</code>方法将数据读入Java对象和<code class="codeph">writeSQL()</code>方法写入从Java对象的数据库。
                        </p>
                        <p>有关标准<code class="codeph">SQLData</code>功能的其他信息，请参阅Sun Microsystems JDBC 2.0或更高版本的API规范。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ422"></a><div class="props_rev_3"><a id="GUID-BCB8194D-F72A-4ABC-AFA2-A69711002B80" name="GUID-BCB8194D-F72A-4ABC-AFA2-A69711002B80"></a><h4 id="JSQLJ-GUID-BCB8194D-F72A-4ABC-AFA2-A69711002B80" class="sect4">对象方法的自定义Java类支持</h4>
                  <div>
                     <p>可以从自定义Java类包装器调用Oracle对象的方法。底层存储过程是用PL / SQL编写的还是用Java编写并发布到SQL对用户是不可见的。</p>
                     <p>用于调用服务器方法的Java包装器方法需要连接以与服务器通信。连接对象可以作为显式参数提供，或者可以以其他方式关联。例如，作为自定义Java类的属性。如果包装器方法使用的连接对象是非静态属性，则包装器方法必须是自定义Java类的实例方法才能访问该连接。</p>
                     <p>Oracle对象的方法中也存在有关输出和输入输出参数的问题。如果存储过程（即SQL对象方法）修改其某个参数的内部状态，则会修改传递给存储过程的实际参数。在Java中，这是不可能的。从存储过程调用返回JDBC输出参数时，它必须存储在新创建的对象中。原始对象标识丢失。</p>
                     <p>将输出或输入输出参数返回给调用者的一种方法是将参数作为数组的元素传递。如果参数是输入输出，则包装器方法将数组元素作为输入。处理完成后，包装器将输出分配给数组元素。</p>
                  </div>
               </div><a id="JSQLJ424"></a><a id="JSQLJ425"></a><a id="JSQLJ426"></a><a id="JSQLJ427"></a><a id="JSQLJ423"></a><div class="props_rev_3"><a id="GUID-240D3A7C-D69A-4599-8B9B-6E0B9312853D" name="GUID-240D3A7C-D69A-4599-8B9B-6E0B9312853D"></a><h4 id="JSQLJ-GUID-240D3A7C-D69A-4599-8B9B-6E0B9312853D" class="sect4">自定义Java类要求</h4>
                  <div>
                     <div class="section">
                        <p>自定义Java类必须满足某些要求，以便Oracle SQLJ转换程序将其识别为有效的主机变量类型，并启用转换程序的类型检查。</p>
                        <div class="infoboxnote" id="GUID-240D3A7C-D69A-4599-8B9B-6E0B9312853D__GUID-11C55F73-1AA9-4697-8B54-BDA0EA01B7A5">
                           <p class="notep1">注意：</p>
                           <p>用户定义类型的自定义Java类在本手册中通常称为“包装类”。</p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-240D3A7C-D69A-4599-8B9B-6E0B9312853D__I1005846">
                        <p class="subhead3" id="GUID-240D3A7C-D69A-4599-8B9B-6E0B9312853D__GUID-6F102C1C-7597-47AE-96DB-651AD0D4E593">Oracle对类实现ORAData的要求</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>对于任何类型的自定义Java类， <code class="codeph">ORAData</code>实现的Oracle要求<code class="codeph">ORAData</code>相同，但根据该类是否用于映射到对象，对象引用，集合或某些其他SQL类型而略有不同。
                        </p>
                        <p>这些要求如下：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>该类实现了<code class="codeph">oracle.sql.ORAData</code>接口。
                              </p>
                           </li>
                           <li>
                              <p>该类实现了返回<code class="codeph">oracle.sql.的<code class="codeph">getORADataFactory()</code>方法<code class="codeph">oracle.sql.ORADataFactory</code>对象。方法签名如下：</p><pre class="oac_no_warn" dir="ltr">public static oracle.sql。ORADataFactory getORADataFactory（）;</pre></li>
                           <li>
                              <p>该类有一个<code class="codeph">String</code>常量<code class="codeph">_SQL_TYPECODE</code> ，初始化为<code class="codeph">oracle.jdbc.OracleTypes</code>类型代码是<code class="codeph">toDatum()</code>返回的<code class="codeph">Datum</code>子类实例的类型代码。类型代码是：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>对于自定义对象类：</p><pre class="oac_no_warn" dir="ltr">public static final int _SQL_TYPECODE = OracleTypes。STRUCT;</pre></li>
                                 <li>
                                    <p>对于自定义引用类：</p><pre class="oac_no_warn" dir="ltr">public static final int _SQL_TYPECODE = OracleTypes。REF;</pre></li>
                                 <li>
                                    <p>对于自定义集合类：</p><pre class="oac_no_warn" dir="ltr">public static final int _SQL_TYPECODE = OracleTypes。ARRAY;</pre></li>
                              </ul>
                              <p>对于其他用途，某些其他类型的代码可能是合适的。例如，使用自定义Java类将Java对象序列化和反序列化为<code class="codeph">RAW</code>字段或从<code class="codeph">RAW</code>字段中反序列化<code class="codeph">OracleTypes.的<code class="codeph">_SQL_TYPECODE</code> <code class="codeph">OracleTypes.RAW</code> 。
                              </p>
                              <div class="infoboxnote" id="GUID-240D3A7C-D69A-4599-8B9B-6E0B9312853D__GUID-4E064F67-09E6-4981-A253-435722E9E50E">
                                 <p class="notep1">注意：</p>
                                 <p><code class="codeph">OracleTypes</code>类只为每种Oracle数据类型定义一个类型代码，它是一个整型常量。对于标准SQL类型， <code class="codeph">OracleTypes</code>条目与标准<code class="codeph">java.sql.的条目相同<code class="codeph">java.sql.Types</code>定义类。
                                 </p>
                              </div>
                              <div class="infoboxnotealso" id="GUID-240D3A7C-D69A-4599-8B9B-6E0B9312853D__GUID-0CCC42C7-3E76-4C14-8B6E-ED26B8E63F89">
                                 <p class="notep1">也可以看看：</p>
                                 <p><span class="q">“ <a href="objects-collections-and-OPAQUE-types.html#GUID-4A2FC8B8-81B2-4B3B-B0D4-1102A7F7F21A">序列化Java对象</a> ”</span></p>
                              </div>
                           </li>
                           <li>
                              <p>对于具有<code class="codeph">STRUCT</code> ， <code class="codeph">REF</code>或<code class="codeph">ARRAY</code> <code class="codeph">_SQL_TYPECODE</code>的自定义Java类，即，对于表示对象，对象引用或集合的自定义Java类，该类具有一个常量，指示相关的用户定义的类型名称。具体如下：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>自定义对象类和自定义集合类必须具有<code class="codeph">String</code>常量<code class="codeph">_SQL_NAME</code> ，初始化为您为用户定义类型声明的SQL名称，如下所示：</p><pre class="oac_no_warn" dir="ltr">public static final String _SQL_NAME = <span class="italic">UDT name</span> ;</pre><p>例如，用户定义的<code class="codeph">PERSON</code>对象的自定义对象类将具有常量：</p><pre class="oac_no_warn" dir="ltr">public static final String _SQL_NAME =“PERSON”;</pre><p>如果合适，可以与模式一起指定相同的内容，如下所示：</p><pre class="oac_no_warn" dir="ltr">public static final String _SQL_NAME =“HR.PERSON”;</pre><p><code class="codeph">PERSON</code>对象集合的自定义集合类（已声明为<code class="codeph">PERSON_ARRAY</code> ）将具有常量：</p><pre class="oac_no_warn" dir="ltr">public static final String _SQL_NAME =“PERSON_ARRAY”;</pre></li>
                                 <li>
                                    <p>自定义引用类必须具有<code class="codeph">String</code>常量<code class="codeph">_SQL_BASETYPE</code> ，初始化为您为引用的用户定义类型声明的SQL名称，如下所示：</p><pre class="oac_no_warn" dir="ltr">public static final String _SQL_BASETYPE = <span class="italic">UDT name</span> ;</pre><p><code class="codeph">PERSON</code>引用的自定义引用类将具有常量：</p><pre class="oac_no_warn" dir="ltr">public static final String _SQL_BASETYPE =“PERSON”;</pre><p>对于其他<code class="codeph">ORAData</code>用法，指定UDT名称不适用。
                                    </p>
                                 </li>
                              </ul>
                           </li>
                        </ul>
                        <p>请记住以下使用说明：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>集合类型名称反映集合类型，而不是基本类型。例如，如果您为<code class="codeph">PERSON</code>对象声明了VARRAY或嵌套表类型<code class="codeph">PERSON_ARRAY</code> ，那么您为<code class="codeph">_SQL_NAME</code>条目指定的集合类型的名称是<code class="codeph">PERSON_ARRAY</code> ，而不是<code class="codeph">PERSON</code> 。</p>
                           </li>
                           <li>
                              <p>在<code class="codeph">_SQL_NAME</code>字段中指定SQL类型时，如果以类型敏感的方式（在引号中）声明SQL类型，则必须完全按照声明的方式指定SQL名称，例如<code class="codeph">CaseSensitive</code>或<code class="codeph">HR.CaseSensitive</code> 。
                              </p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-240D3A7C-D69A-4599-8B9B-6E0B9312853D__I1005901">
                        <p class="subhead3" id="GUID-240D3A7C-D69A-4599-8B9B-6E0B9312853D__GUID-066060FB-A06B-4EBB-9A1C-72989676D075">实现SQLData的类的要求</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>ISO SQLJ标准概述了实现<code class="codeph">SQLData</code>接口的类的类型映射定义的要求。或者， <code class="codeph">SQLData</code>包装类可以通过<code class="codeph">public static final</code>字段标识关联的SQL对象类型。
                        </p>
                        <p>请注意以下要点：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>无论是使用类型映射还是使用备用（非标准） <code class="codeph">public static final</code>字段来指定映射，您的方法都必须保持一致。使用指定所有相关映射的类型映射，以便不需要<code class="codeph">public static final</code>字段，或者根本不使用类型映射，并通过<code class="codeph">public static final</code>字段指定所有映射。
                              </p>
                           </li>
                           <li>
                              <p>与<code class="codeph">ORAData</code>不同， <code class="codeph">SQLData</code>仅用于映射结构化对象类型。它不适用于对象引用，集合或数组或任何其他SQL类型。如果您没有使用<code class="codeph">ORAData</code> ，那么映射对象引用和集合的唯一选择是弱<code class="codeph">java.sql.Ref</code>和<code class="codeph">java.sql.Array</code>类型，分别是<code class="codeph">oracle.sql.REF</code>和<code class="codeph">oracle.sql.ARRAY</code> 。</p>
                           </li>
                           <li>
                              <p><code class="codeph">SQLData</code>实现需要Java Development Kit（JDK）1.4.x或1.5.x环境。
                              </p>
                           </li>
                           <li>
                              <p>在指定从SQL类型到Java类型的映射时，如果以类型敏感的方式声明SQL类型，则必须完全按照声明的方式指定SQL名称，例如<code class="codeph">CaseSensitive</code>或<code class="codeph">HR.CaseSensitive</code> 。
                              </p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-240D3A7C-D69A-4599-8B9B-6E0B9312853D__GUID-43CB770B-3D70-4FF9-9429-F42104B9B158">类型映射资源中指定的映射</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>首先，根据ISO SQLJ标准考虑映射表示。假设<code class="codeph">Address</code> ， <code class="codeph">pack.Person</code> ，和<code class="codeph">pack.经理。InnerPM</code> ，其中<code class="codeph">InnerPM</code>是<code class="codeph">Manager</code>的内部类，是三个实现<code class="codeph">java.sql.包装类<code class="codeph">java.sql.SQLData</code> 。
                        </p>
                        <p>然后，您需要考虑以下事项：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>必须仅在使用声明的连接上下文类型的显式连接上下文实例的语句中使用这些类。例如，假设此类型称为<code class="codeph">SDContext</code> ：</p><pre class="oac_no_warn" dir="ltr">地址a = ......;包。人p = ......;包。经理。InnerPM pm = ...; SDContext ctx = new SDContext（url，user，pwd，false）; #sql [ctx] {...：a ...：p ...：pm ...};</pre></li>
                           <li>
                              <p>必须使用<code class="codeph">with</code>属性<code class="codeph">typeMap</code>声明连接上下文类型，该属性指定实现<code class="codeph">java.util.的关联类<code class="codeph">java.util.PropertyResourceBundle</code> 。在前面的示例中， <code class="codeph">SDContext</code>可以声明如下：</p><pre class="oac_no_warn" dir="ltr">#sql public static context SDContext with（typeMap =“SDMap”）;</pre></li>
                           <li>
                              <p>类型映射资源必须提供从SQL对象类型到实现<code class="codeph">java.sql.相应Java类的映射<code class="codeph">java.sql.SQLData</code>接口。使用以下格式的条目指定此映射：</p><pre class="oac_no_warn" dir="ltr">class.java_class_name = STRUCT sql_type_name</pre><p><code class="codeph">STRUCT</code>关键字也可以省略。在该示例中， <code class="codeph">SDMap.properties</code>资源文件可能包含以下条目：</p><pre class="oac_no_warn" dir="ltr">类。Address = STRUCT HR.ADDRESS class.pack。Person = PERSON class.pack。经理$ InnerPM = STRUCT PRODUCT_MANAGER</pre><p>虽然句点（。）分隔了包名和类名，但<span class="italic">必须</span>使用美元符号（$）来分隔内部类名。
                              </p>
                           </li>
                        </ul>
                        <div class="infoboxnote" id="GUID-240D3A7C-D69A-4599-8B9B-6E0B9312853D__GUID-E739A417-D3D5-4D36-9A46-3C5EA7BE37CE">
                           <p class="notep1">注意：</p>
                           <p>如果在此示例中使用了默认的Oracle特定代码生成，那么用于上下文类型为<code class="codeph">SDContext</code>的语句的任何迭代器也必须使用相同的关联类型映射<code class="codeph">SDMap</code> ，如下例所示：</p><pre class="oac_no_warn" dir="ltr">#sql public static iterator SDIter with（typeMap =“SDMap”）; ...SDContext sdctx = ...SDIter sditer; #sql [sdctx] sditer = {SELECT ...};</pre><p>这是为了确保为迭代器类生成正确的代码。</p>
                        </div>
                        <p>这种在类型映射资源中指定映射的机制比非标准替代方法更复杂。此外，无法将类型映射资源与默认连接上下文相关联。优点是所有映射信息都放在一个位置，即类型映射资源。这意味着可以在以后轻松调整已编译应用程序中的类型映射，例如，在扩展的SQL-Java类型层次结构中容纳新的SQL类型和Java包装器。</p>
                        <p>请注意以下事项：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>您必须使用SQLJ <code class="codeph">runtime12</code>或<code class="codeph">runtime12ee</code>库来使用此功能。类型映射表示为<code class="codeph">java.util.Map</code>对象。它们在SQLJ运行时API中公开，因此通用运行时库<span class="italic">不</span>支持。
                              </p>
                           </li>
                           <li>
                              <p>如果<code class="codeph">SQLData</code>包装类在SQLJ语句中作为<code class="codeph">OUT</code>或<code class="codeph">INOUT</code>参数出现，则必须使用Oracle SQLJ运行时和Oracle特定的代码生成或配置文件自定义。这是因为Oracle JDBC驱动程序需要这种参数的SQL类型为<code class="codeph">registerOutParameter()</code> 。此外，对于<code class="codeph">OUT</code>参数类型注册，SQL类型在转换期间由类型映射“冻结”。
                              </p>
                           </li>
                           <li>
                              <p>SQLJ类型映射独立于您可能在底层连接上使用的任何JDBC类型映射。因此，如果两者都使用<code class="codeph">SQLData</code>包装器，则在混合SQLJ和JDBC代码时必须小心。但是，您可以轻松地提取对给定SQLJ连接上下文有效的类型映射：</p><pre class="oac_no_warn" dir="ltr">ctx.getTypeMap（）;</pre></li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-240D3A7C-D69A-4599-8B9B-6E0B9312853D__GUID-FEAB3CB0-F57A-4DD3-B257-42E3D6810583">包装类静态字段中指定的映射</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>实现<code class="codeph">SQLData</code>的类可以满足以下非标准要求：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>Java类声明<code class="codeph">String</code>常量<code class="codeph">_SQL_NAME</code> ，它定义了Java类包装的SQL类型的名称。在示例中， <code class="codeph">Address</code>类将具有以下字段声明：</p><pre class="oac_no_warn" dir="ltr">public static final String _SQL_NAME =“HR.ADDRESS”;</pre><p>以下声明将<code class="codeph">pack.Person</code> ：</p><pre class="oac_no_warn" dir="ltr">public static final String _SQL_NAME =“PERSON”;</pre><p>和<code class="codeph">pack.经理。InnerPM</code>类将具有以下内容：</p><pre class="oac_no_warn" dir="ltr">public static final String _SQL_NAME =“PRODUCT_MANAGER”;</pre></li>
                        </ul>
                        <div class="infoboxnote" id="GUID-240D3A7C-D69A-4599-8B9B-6E0B9312853D__GUID-30647C5B-96B2-47B1-BEDF-6A9FC67D9CD9">
                           <p class="notep1">注意：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>如果在具有显式连接上下文类型和关联类型映射的SQLJ语句中使用实现<code class="codeph">_SQL_NAME</code>字段的类，则使用该类型映射并忽略<code class="codeph">_SQL_NAME</code>字段。这简化了现有SQLJ程序到ISO SQLJ标准的迁移。
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">_SQL_NAME</code>字段中指定的静态SQL-Java类型对应关系与您在底层连接上使用的任何JDBC类型映射无关。因此，如果两者都使用<code class="codeph">SQLData</code>包装器，则在混合SQLJ和JDBC代码时必须小心。
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ428"></a><div class="props_rev_3"><a id="GUID-700E14BF-E4F8-4A36-9092-05000452C60B" name="GUID-700E14BF-E4F8-4A36-9092-05000452C60B"></a><h4 id="JSQLJ-GUID-700E14BF-E4F8-4A36-9092-05000452C60B" class="sect4">编译自定义Java类</h4>
                  <div>
                     <div class="section">
                        <p>您可以在SQLJ命令行中为自定义Java类（无论是<code class="codeph">ORAData</code>还是<code class="codeph">SQLData</code>实现）包含任何<code class="codeph">.java</code>文件以及应用程序的<code class="codeph">.sqlj</code>文件。但是，如果SQLJ <code class="codeph">-checksource</code>标志设置为<code class="codeph">true</code> （默认值），并且类路径包含自定义Java源所在的目录，则<code class="codeph">-checksource</code> 。
                        </p>
                        <div class="infoboxnote" id="GUID-700E14BF-E4F8-4A36-9092-05000452C60B__GUID-D2BCD3EE-5E8D-49F0-9698-BDDA15D07FFA">
                           <p class="notep1">注意：</p>
                           <p>本讨论假定您正在为自定义对象和集合创建<code class="codeph">.java</code>文件，而不是<code class="codeph">.sqlj</code>文件。任何<code class="codeph">.sqlj</code>文件都必须包含在SQLJ命令行中。
                           </p>
                        </div>
                        <p>例如，如果<code class="codeph">ObjectDemo.sqlj</code>使用<code class="codeph">ADDRESS</code>和<code class="codeph">PERSON</code> Oracle对象类型，并且您已为这些对象生成自定义Java类，则可以按如下方式运行SQLJ。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p>如果<code class="codeph">-checksource=true</code>且类路径包含自定义Java源位置：</p><pre class="oac_no_warn" dir="ltr">％sqlj ObjectDemo.sqlj</pre></li>
                           <li>
                              <p>如果<code class="codeph">-checksource=false</code> （这是一条环绕线）：</p><pre class="oac_no_warn" dir="ltr">％sqlj ObjectDemo.sqlj Address.java AddressRef.java Person.java PersonRef.java</pre></li>
                        </ul>
                        <p>您还可以选择使用Java编译器直接编译自定义<code class="codeph">.java</code>源文件。如果您这样做，那么您必须在翻译<code class="codeph">.sqlj</code>文件之前执行此操作。
                        </p>
                        <div class="infoboxnote" id="GUID-700E14BF-E4F8-4A36-9092-05000452C60B__GUID-03FD8712-CC7C-4A68-B275-EE9BB22F03B5">
                           <p class="notep1">注意：</p>
                           <p>由于<code class="codeph">ORAData</code>实现依赖于Oracle特定的功能，因此如果您不使用<code class="codeph">-warn=noportable</code>转换器可移植性设置（默认设置），SQLJ将报告大量可移植性警告。
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ429"></a><div class="props_rev_3"><a id="GUID-9B5BACD2-3100-46FB-8B3F-A1B0557BF7F7" name="GUID-9B5BACD2-3100-46FB-8B3F-A1B0557BF7F7"></a><h4 id="JSQLJ-GUID-9B5BACD2-3100-46FB-8B3F-A1B0557BF7F7" class="sect4">阅读和编写自定义数据</h4>
                  <div>
                     <div class="section">
                        <p>通过使用自定义Java类实例，Oracle SQLJ和JDBC实现允许您读取和编写用户定义的类型，就像它们是内置类型一样。究竟如何实现这一点对用户来说是透明的。</p>
                        <p>有关如何读取和写入数据的机制，对于<code class="codeph">ORAData</code>实现和<code class="codeph">SQLData</code>实现，请参阅<a href="../jjdbc/Oracle-object-types.html#JJDBC-GUID-6D44496F-0CAA-4034-AF55-00B39DE4C6E3" target="_blank"><span class="italic">Oracle数据库JDBC开发人员指南</span></a> 。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ431"></a><a id="JSQLJ430"></a><div class="props_rev_3"><a id="GUID-1F822A17-F41C-4994-95BB-886397ACFAE3" name="GUID-1F822A17-F41C-4994-95BB-886397ACFAE3"></a><h4 id="JSQLJ-GUID-1F822A17-F41C-4994-95BB-886397ACFAE3" class="sect4">ORAData实现的其他用途</h4>
                  <div>
                     <div class="section">
                        <p>到目前为止，对自定义Java类的讨论已被用作以下之一。</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>SQL对象的包装器：自定义对象类，用于<code class="codeph">oracle.sql.STRUCT</code>实例</p>
                           </li>
                           <li>
                              <p>SQL引用的包装器：自定义引用类，用于<code class="codeph">oracle.sql.REF</code>实例</p>
                           </li>
                           <li>
                              <p>SQL集合的包装器：自定义集合类，用于<code class="codeph">oracle.sql.ARRAY</code>实例</p>
                           </li>
                        </ul>
                        <p>但是，提供自定义Java类以包装其他<code class="codeph">oracle.sql.*</code>类型，以进行自定义转换或处理可能会很有用。您可以使用实现<code class="codeph">ORAData</code>但不是<code class="codeph">SQLData</code>类来完成此操作，如以下示例所示：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>执行数据的加密和解密或验证。</p>
                           </li>
                           <li>
                              <p>执行已读取或正在写入的值的记录。</p>
                           </li>
                           <li>
                              <p>将字符列（例如包含URL信息的字符字段）解析为较小的组件。</p>
                           </li>
                           <li>
                              <p>将字符串映射到数字常量。</p>
                           </li>
                           <li>
                              <p>将数据映射到更理想的Java格式，例如将<code class="codeph">DATE</code>字段映射到<code class="codeph">java.util.Date</code>格式。
                              </p>
                           </li>
                           <li>
                              <p>自定义数据表示，例如，表格列中的数据以英尺为单位，但您希望在选择后以米为单位表示。</p>
                           </li>
                           <li>
                              <p>将Java对象序列化和反序列化，例如，进入或退出<code class="codeph">RAW</code>字段。
                              </p>
                           </li>
                        </ul>
                        <div class="infoboxnote" id="GUID-1F822A17-F41C-4994-95BB-886397ACFAE3__GUID-D6E68D4B-71B8-4068-BAE0-1BBBB741C629">
                           <p class="notep1">注意：</p>
                           <p>通过<code class="codeph">SQLData</code>接口无法实现这种功能，因为<code class="codeph">SQLData</code>实现只能包装结构化对象类型。
                           </p>
                        </div>
                        <div class="infoboxnotealso" id="GUID-1F822A17-F41C-4994-95BB-886397ACFAE3__GUID-02339C2A-8772-490B-9FCC-DBD04CE1050D">
                           <p class="notep1">也可以看看：</p>
                           <p><span class="q">“ <a href="objects-collections-and-OPAQUE-types.html#GUID-4A2FC8B8-81B2-4B3B-B0D4-1102A7F7F21A">序列化Java对象</a> ”</span></p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-1F822A17-F41C-4994-95BB-886397ACFAE3__GUID-D49D802B-B373-4078-8EB6-1EB63B54EDD0">ORAData的一般用法：BetterDate.java</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>此示例显示了一个实现<code class="codeph">ORAData</code>接口的类，以提供Java日期的自定义表示，并可用于代替<code class="codeph">java.sql.Date</code> 。
                        </p>
                        <div class="infoboxnote" id="GUID-1F822A17-F41C-4994-95BB-886397ACFAE3__GUID-9395F43C-FEE6-4060-A640-D4D3FC5EE3AC">
                           <p class="notep1">注意：</p>
                           <p>这不是一个完整的应用程序。没有<code class="codeph">main()</code>方法。
                           </p>
                        </div><pre class="oac_no_warn" dir="ltr">import java.util。日期; import oracle.sql。ORADATA; import oracle.sql。日期; import oracle.sql。ORADataFactory; import oracle.jdbc。OracleTypes; //为用户的首选项定制的日期类：//  - 月份是数字1..12，而不是0..11 //  - 年份是通过四位数字而不是两位来引用的。公共类BetterDate扩展了java.util。Date实现ORAData，ORADataFactory {public static final int _SQL_TYPECODE = OracleTypes。日期; String [] monthNames = {“JAN”，“FEB”，“MAR”，“APR”，“MAY”，“JUN”，“JUL”，“AUG”，“SEP”，“OCT”，“NOV”， “DEC”}; String [] toDigit = {“0”，“1”，“2”，“3”，“4”，“5”，“6”，“7”，“8”，“9”}; static final BetterDate _BetterDateFactory = new BetterDate（）; public static ORADataFactory getORADataFactory（）{return _BetterDateFactory;} //当前时间......public BetterDate（）{super（）; public oracle.sql。Datum toDatum（java.sql。连接conn）{return new DATE（toSQLDate（））; public oracle.sql。ORAData create（oracle.sql。Datum dat，int intx）{if（dat == null）返回null; DATE DAT =（（DATE）dat）; java.sql中。日期jsd = DAT.dateValue（）;返回新的BetterDate（jsd）; public java.sql。日期toSQLDate（）{java.sql。日期延期; retval = new java.sql。Date（this.getYear（） -  1900，this.getMonth（） -  1，this.getDate（））;返回; public BetterDate（java.sql。日期d）{this（d.getYear（）+ 1900，d.getMonth（）+ 1，d.getDate（））; private static int [] deconstructString（String s）{int [] retval = new int [3]; int y，m，d; char temp; int offset; StringBuffer sb = new StringBuffer（s）;温度= sb.charAt（1）; //计算月中的日期if（temp &lt;'0'|| temp&gt;'9'）{m = sb.charAt（0） - '0';偏移量= 2; } else {m =（sb.charAt（0） - '0'）* 10 +（temp-'0'）;偏移量= 3; } //计算月份temp = sb.charAt（offset + 1）; if（temp &lt;'0'|| temp&gt;'9'）{d = sb.charAt（offset） - '0';偏移+ = 2; } else {d =（sb.charAt（offset） - '0'）* 10 +（temp-'0'）;偏移+ = 3; } //计算年份，格式为“yy”或“yyyy”//（前者假设当前世纪）if（sb.length（）&lt;=（offset + 2））{y =（（ （new BetterDate（））。getYear（））/ 100）* 100 +（sb.charAt（offset） - '0'）* 10 +（sb.charAt（offset + 1） - '0'）; } else {y =（sb.charAt（offset） - '0'）* 1000 +（sb.charAt（offset + 1） - '0'）* 100 +（sb.charAt（offset + 2） - '0' ）* 10 +（sb.charAt（偏移+3） - '0'）; } retval [0] = y; RETVAL [1] =米; RETVAL [2] = d; // System.out.println（“从字符串构造日期为：”+ d +“/”+ m +“/”+ y）;返回;私有BetterDate（int [] stuff）{this（stuff [0]，stuff [1]，stuff [2]）; } //采用以下格式的字符串：“mm-dd-yyyy”或“mm / dd / yyyy”或//“mm-dd-yy”或“mm / dd / yy”（假设当前世纪） public BetterDate（String s）{this（BetterDate.deconstructString（s））; } //年为'1990'，月份为1..12（与java.util不同）。日期！），日期//为'1'到'31'公共BetterDate（int year，int months，int date）{super（year-1900，months-1，date）; } //返回“Date：dd-mon-yyyy”public String toString（）{int yr = getYear（）; return getDate（）+“ - ”+ monthNames [getMonth（） -  1] +“ - ”+ toDigit [（yr / 1000）％10] + toDigit [（yr / 100）％10] + toDigit [（年/ 10 ）％10] + toDigit [yr％10]; //返回“Date：”+ getDate（）+“ - ”+ getMonth（）+“ - ”+（getYear（）％100）; public BetterDate addDays（int i）{if（i == 0）return this;返回new BetterDate（getYear（），getMonth（），getDate（）+ i）; public BetterDate addMonths（int i）{if（i == 0）return this; int yr = getYear（）; int mon = getMonth（）+ i; int dat = getDate（）; while（mon &lt;1）{--yr; mon + = 12;返回new BetterDate（yr，mon，dat）; } //返回year，如1996年，2007年public int getYear（）{return super.getYear（）+ 1900; } //将month返回为1..12 public int getMonth（）{return super.getMonth（）+ 1; public boolean equals（BetterDate sd）{return（sd.getDate（）== this.getDate（）&amp;&amp; sd.getMonth（）== this.getMonth（）&amp;&amp; sd.getYear（）== this.getYear（）） ; } //减去两个日期;返回全年的答案//使用一年的平均长度，即365天加上//每4个闰年，除了100，除了400年= // = 365 97/400 = 365.2425天= 31,556,952秒公开double minusInYears（BetterDate sd）{//年份（如前文所定义），以毫秒为单位longInInLillis = 31556952L; long diff = myUTC（） -  sd.myUTC（）; return（（（double）diff /（double）yearInMillis）/1000.0）; public long myUTC（）{return Date。UTC（getYear（） -  1900，getMonth（） -  1，getDate（），0,0,0）; } //返回&lt;0如果它早于sd //则返回=如果这= = sd // else返回&gt; 0 public int compare（BetterDate sd）{if（getYear（）！= sd.getYear（））{return getYear（） -  sd.getYear（）;} if（getMonth（）！= sd.getMonth（））{return getMonth（） -  sd.getMonth（）;} return getDate（） -  sd.getDate（）; }}</pre></div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="JSQLJ433"></a><a id="JSQLJ434"></a><a id="JSQLJ432"></a><div class="props_rev_3"><a id="GUID-88A459DA-AC72-4DD9-9143-BCD47CD6FF8B" name="GUID-88A459DA-AC72-4DD9-9143-BCD47CD6FF8B"></a><h3 id="JSQLJ-GUID-88A459DA-AC72-4DD9-9143-BCD47CD6FF8B" class="sect3">用户定义的类型</h3>
               <div>
                  <div class="section">
                     <p>本节包含在Oracle Database 12 <span class="italic">c</span>第2版（12.2）中创建和使用用户定义的对象类型和集合类型的示例。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="section" id="GUID-88A459DA-AC72-4DD9-9143-BCD47CD6FF8B__I1006222">
                     <p class="subhead2" id="GUID-88A459DA-AC72-4DD9-9143-BCD47CD6FF8B__GUID-0999BCAD-A95F-4507-B369-D93708A039AD">创建对象类型</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p>用于创建对象类型的SQL命令具有以下形式：</p><pre class="oac_no_warn" dir="ltr">CREATE TYPE <span class="italic">typename</span> AS OBJECT（ <span class="italic">attrname1 datatype1</span> ， <span class="italic">attrname2 datatype2</span> ，......）
  <span class="italic">attrnameN datatypeN</span> ）;</pre><p>其中<span class="italic"><code class="codeph">typename</code></span>是对象类型的所需名称， <span class="italic"><code class="codeph">attrname1</code></span>到<span class="italic"><code class="codeph">attrnameN</code></span>是所需的属性名称， <span class="italic"><code class="codeph">datatype1</code></span>到<span class="italic"><code class="codeph">datatypeN</code></span>是属性数据类型。
                     </p>
                     <p>本节的其余部分提供了在Oracle Database 12 <span class="italic">c</span>第1版（12.1）中创建用户定义的对象类型的示例。
                     </p>
                     <p>在此示例中，使用SQL创建以下项：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>两种对象类型， <code class="codeph">PERSON</code>和<code class="codeph">ADDRESS</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">PERSON</code>对象的类型表</p>
                        </li>
                        <li>
                           <p>一个<code class="codeph">EMPLOYEES</code>表，其中包含<code class="codeph">ADDRESS</code>列和两列<code class="codeph">PERSON</code>引用</p>
                        </li>
                     </ul>
                     <p>创建这些项目的脚本如下：</p><pre class="oac_no_warn" dir="ltr">/ ***在SQLJ中使用用户定义的类型（UDT）*** / / / ***创建ADDRESS UDT *** /创建类型地址作为对象（街道VARCHAR（60），城市VARCHAR（30），状态CHAR （2），zip_code CHAR（5））/ / ***创建包含嵌入式ADDRESS UDT的PERSON UDT *** / CREATE TYPE PERSON AS OBJECT（名称VARCHAR（30），ssn NUMBER，addr ADDRESS）/ / ***为PERSON对象创建一个类型表*** / CREATE TABLE人员人员/ / ***创建一个关系表，其中包含两列作为PERSON对象的REF，以及一个作为地址ADT的列。 *** / CREATE TABLE员工（人数为INTEGER PRIMARY KEY，person_data REF PERSON，经理REF PERSON，office_addr ADDRESS，工资号码）/ ***将一些数据 -  2个对象插入到人员类型表中*** / INSERT INTO人员价值观（人物（'Wolfgang Amadeus Mozart'，123456，ADDRESS（'Am Berg 100'，'Salzburg'，'AT'，'10424'）））/ INSERT INTO VALUES（PERSON（'Ludwig van Beethoven'，234567， ADDRESS（'Rheinallee'，'Bonn'，'DE'，'69234'）））/ / **在员工表中添加一行** / INSERT INTO员工（empnumber，office_addr，薪水）VALUES（1001，ADDRESS（ '500 Oracle Parkway'，'Redwood Shores'，'CA'，'94065'），50000）/ / **为员工设置经理和PERSON REF ** / UPDATE员工SET manager =（SELECT REF（p）FROM人员p WHERE p.name ='Wolfgang Amadeus Mozart'）/ UPDATE员工SET person_data =（SELECT REF（p）FROM人员p WHERE p.name ='Ludwig van Beethoven'）</pre><div class="infoboxnote" id="GUID-88A459DA-AC72-4DD9-9143-BCD47CD6FF8B__GUID-8AB87128-031C-4267-9A11-6945A39C8326">
                        <p class="notep1">注意：</p>
                        <p>在SQL SQL实现中，建议使用表别名（例如<code class="codeph">p</code>中的<code class="codeph">p</code> ，尤其是在访问具有用户定义类型的表时。在某些情况下，访问对象属性是必需的语法。即使不需要，也有助于避免含糊不清。有关表别名的更多信息，请参阅<a href="../sqlrf/Data-Types.html#SQLRF-GUID-7CF27C66-9908-4C02-9401-06C2F2C4021C" target="_blank"><span class="italic">Oracle数据库SQL语言参考</span></a> 。
                        </p>
                     </div>
                  </div>
                  <!-- class="section" -->
                  <div class="section" id="GUID-88A459DA-AC72-4DD9-9143-BCD47CD6FF8B__I1006305">
                     <p class="subhead2" id="GUID-88A459DA-AC72-4DD9-9143-BCD47CD6FF8B__GUID-C5274E1D-36DB-4983-9C7E-BA6135481AF5">创建集合类型</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p>有两类收藏</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>可变长度数组（VARRAY）</p>
                        </li>
                        <li>
                           <p>嵌套表</p>
                        </li>
                     </ul>
                     <p>用于创建VARRAY类型的SQL命令具有以下形式：</p><pre class="oac_no_warn" dir="ltr">CREATE TYPE <span class="italic">typename</span> IS VARRAY（ <span class="italic">n</span> ）OF <span class="italic">数据类型</span> ;</pre><p><span class="italic"><code class="codeph">typename</code></span>标识是VARRAY类型的所需名称， <span class="italic"><code class="codeph">n</code></span>是数组中所需的最大元素数， <span class="italic"><code class="codeph">datatype</code></span>是数组元素的数据类型。例如：</p><pre class="oac_no_warn" dir="ltr">创建类型myvarr IS VARRAY（10）OF INTEGER;</pre><p>用于创建嵌套表类型的SQL命令具有以下形式：</p><pre class="oac_no_warn" dir="ltr">CREATE TYPE <span class="italic">typename</span> AS TABLE OF <span class="italic">数据类型</span> ;</pre><p><span class="italic"><code class="codeph">typename</code></span>指定是嵌套表类型的所需名称， <span class="italic"><code class="codeph">datatype</code></span>是表元素的数据类型。这可以是用户定义的类型以及标准数据类型。嵌套表仅限于一列，但该列类型可以是具有多个属性的复杂对象。与任何数据库表一样，嵌套表可以包含任意数量的行。例如：</p><pre class="oac_no_warn" dir="ltr">CREATE TYPE person_array AS TABLE of person;</pre><p>此命令创建一个嵌套表，其中每一行都包含一个<code class="codeph">PERSON</code>对象。
                     </p>
                     <p>本节的其余部分提供了在Oracle Database 12 <span class="italic">c</span>第2版（12.2）中创建用户定义的集合类型以及对象类型的示例。
                     </p>
                     <p>使用SQL创建并填充以下项：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>两种对象类型， <code class="codeph">PARTICIPANT_T</code>和<code class="codeph">MODULE_T</code></p>
                        </li>
                        <li>
                           <p>一种集合类型<code class="codeph">MODULETBL_T</code> ，它是<code class="codeph">MODULE_T</code>对象的嵌套表</p>
                        </li>
                        <li>
                           <p><code class="codeph">PROJECTS</code>表，其中包含一列<code class="codeph">PARTICIPANT_T</code>引用和一列<code class="codeph">MODULETBL_T</code>嵌套表</p>
                        </li>
                        <li>
                           <p>集合类型<code class="codeph">PHONE_ARRAY</code> ，它是<code class="codeph">VARCHAR2(30)</code>的VARRAY <code class="codeph">VARCHAR2(30)</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">PERSON</code>和<code class="codeph">ADDRESS</code>对象（重复前面使用的相同定义）</p>
                        </li>
                        <li>
                           <p><code class="codeph">EMPLOYEES</code>表，包含<code class="codeph">PHONE_ARRAY</code>列</p>
                        </li>
                     </ul>
                     <p>创建这些项目的脚本如下：</p><pre class="oac_no_warn" dir="ltr">Rem这是一个SQL * Plus脚本，用于创建模式以演示SQLJ CREATE TYPE PARTICIPANT_T AS OBJECT中的集合Rem操作（empno NUMBER（4），ename VARCHAR2（20），job VARCHAR2（12），mgr NUMBER（4），hiredate DATE，sal NUMBER（7,2），deptno NUMBER（2））/ SHOW ERRORS创建类型MODULE_T作为对象（module_id NUMBER（4），module_name VARCHAR2（20），module_owner REF PARTICIPANT_T，module_start_date DATE，module_duration NUMBER）/显示错误创建类型MODULETBL_T作为MODULE_T表; / SHOW ERRORS CREATE TABLE项目（id NUMBER（4），name VARCHAR（30），owner REF PARTICIPANT_T，start_date DATE，duration NUMBER（3），modules MODULETBL_T）NESTED TABLE modules STORE AS modules_tab;显示错误创建类型PHONE_ARRAY是varchar2（30）的VARRAY（10）/ / ***创建ADDRESS UDT *** /创建类型地址作为对象（街道VARCHAR（60），城市VARCHAR（30），州CHAR（2） ，zip_code CHAR（5））/ / ***创建包含嵌入式ADDRESS UDT的PERSON UDT *** / CREATE TYPE PERSON AS OBJECT（名称VARCHAR（30），ssn NUMBER，addr ADDRESS）/ CREATE TABLE employees（empnumber INTEGER PRIMARY KEY，person_data REF人，经理REF人，office_addr地址，工资号码，phone_nums phone_array）/</pre></div>
                  <!-- class="section" -->
               </div>
            </div><a id="JSQLJ467"></a><div class="props_rev_3"><a id="GUID-A8FBF9FD-A786-4C6E-B093-9B179F079810" name="GUID-A8FBF9FD-A786-4C6E-B093-9B179F079810"></a><h3 id="JSQLJ-GUID-A8FBF9FD-A786-4C6E-B093-9B179F079810" class="sect3">SQLJ可执行语句中的强类型对象和引用</h3>
               <div>
                  <p>Oracle SQLJ实现非常灵活，它使您能够在通过强类型对象或引用读取或写入对象数据时使用主机表达式和迭代器。</p>
                  <p>对于迭代器，您可以将自定义对象类用作迭代器列类型。或者，您可以使用适当映射到属性的SQL数据类型的列类型，使用与范围表类似的对应于单个对象属性的迭代器列。</p>
                  <p>对于主机表达式，您可以使用自定义对象类类型或自定义引用类类型的主机变量。或者，您可以使用与对象属性对应的主变量，使用适当映射到属性的SQL数据类型的变量类型。</p>
                  <p>本节的其余部分提供了如何使用自定义对象类，自定义对象类属性以及SQLJ可执行语句中的主机变量和迭代器列的自定义引用类来操作Oracle对象的示例。</p>
                  <p>以下两个示例在对象级别运行：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="objects-collections-and-OPAQUE-types.html#GUID-1CE3BE78-8A06-4707-94BD-C3EE317D4D84">选择对象和对象引用到迭代器列中</a></p>
                     </li>
                     <li>
                        <p><a href="objects-collections-and-OPAQUE-types.html#GUID-850AE641-018E-4F73-9BC0-E36A012CFD1B">更新对象</a></p>
                     </li>
                  </ul>
                  <p><a href="objects-collections-and-OPAQUE-types.html#GUID-1AAE5F9C-67D0-4800-A1F0-5BEEEC683013">插入从单个对象属性创建的对象</a>示例在标量属性级别运行。
                  </p>
                  <p><a href="objects-collections-and-OPAQUE-types.html#GUID-BE3CBAF4-E752-4F6E-93F5-76C06A848D51">更新对象参考</a>示例通过引用进行操作。
                  </p>
               </div><a id="JSQLJ468"></a><div class="props_rev_3"><a id="GUID-1CE3BE78-8A06-4707-94BD-C3EE317D4D84" name="GUID-1CE3BE78-8A06-4707-94BD-C3EE317D4D84"></a><h4 id="JSQLJ-GUID-1CE3BE78-8A06-4707-94BD-C3EE317D4D84" class="sect4">选择对象和对象引用到迭代器列中</h4>
                  <div>
                     <div class="section">
                        <p>此示例使用自定义Java类和自定义引用类作为迭代器列类型。假设<code class="codeph">ADDRESS</code> Oracle对象类型的以下定义：</p><pre class="oac_no_warn" dir="ltr">创建类型地址作为对象（街道VARCHAR（40），zip NUMBER）;</pre><p>以及<code class="codeph">EMPADDRS</code>表的以下定义，其中包括<code class="codeph">ADDRESS</code>列和<code class="codeph">ADDRESS</code>参考列：</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE empaddrs（名称VARCHAR（60），home ADDRESS，loc REF ADDRESS）;</pre><p>一旦创建了与<code class="codeph">ADDRESS</code> Oracle对象类型对应的自定义Java类， <code class="codeph">Address</code>和自定义引用类<code class="codeph">AddressRef</code> ，就可以在命名迭代器中使用<code class="codeph">Address</code>和<code class="codeph">AddressRef</code> ，如下所示：</p><pre class="oac_no_warn" dir="ltr">#sql iterator EmpIter（String name，Address home，AddressRef loc）; ...Emp eter ecur; #sql ecur = {SELECT name，home，loc FROM empaddrs}; while（ecur.next（））{Address homeAddr = ecur.home（）; //打印出家庭住址。System.out.println（“Name：”+ ecur.name（）+“\ n”+“Home address：”+ homeAddr.getStreet（）+“”+ homeAddr.getZip（））; //现在通过地址参考更新loc地址邮政编码。AddressRef homeRef = ecur.loc（）;地址location = homeRef.getValue（）; location.setZip（new BigDecimal（98765））; homeRef.setValue（位置）; } ...
</pre><p><code class="codeph">ecur.home()</code>方法调用从迭代器的<code class="codeph">home</code>列中提取<code class="codeph">Address</code>对象，并将其分配给<code class="codeph">homeAddr</code>局部变量（为了提高效率）。然后可以使用标准Java点语法访问该对象的属性：</p><pre class="oac_no_warn" dir="ltr">homeAddr.getStreet（）</pre><p>使用<code class="codeph">getValue()</code>和<code class="codeph">setValue()</code>方法来操作位置地址（在本例中为其邮政编码）。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ469"></a><div class="props_rev_3"><a id="GUID-850AE641-018E-4F73-9BC0-E36A012CFD1B" name="GUID-850AE641-018E-4F73-9BC0-E36A012CFD1B"></a><h4 id="JSQLJ-GUID-850AE641-018E-4F73-9BC0-E36A012CFD1B" class="sect4">更新对象</h4>
                  <div>
                     <div class="section">
                        <p>此示例声明并设置<code class="codeph">Address</code> Java类型的输入主机变量，以更新<code class="codeph">employees</code>表的列中的<code class="codeph">ADDRESS</code>对象。在更新之前和之后，地址被选择为<code class="codeph">Address</code>类型的输出主变量并打印以进行验证。
                        </p><pre class="oac_no_warn" dir="ltr">...//更新对象static void updateObject（）{Address addr;地址new_addr; int empnum = 1001;试试{#sql {SELECT office_addr INTO：addr FROM employees WHERE empnumber =：empnum}; System.out.println（“员工1001的当前办公地址：”）; printAddressDetails（addr）;将/ *现在更新地址街道* / String street =“100 Oracle Parkway”; addr.setStreet（街道）; / *将更新的对象放回数据库中* / try {#sql {UPDATE employees SET office_addr =：addr WHERE empnumber =：empnum}; System.out.println（“将员工1001更新为Oracle Parkway的新地址。”）; / *选择新地址以验证更新* / try {#sql {SELECT office_addr INTO：new_addr FROM employees WHERE empnumber =：empnum}; System.out.println（“员工1001的新办公地址：”）; printAddressDetails（new_addr）; } catch（SQLException exn）{System.out.println（“Verification SELECT failed with”+ exn）; catch（SQLException exn）{System.out.println（“UPDATE failed with”+ exn）; catch（SQLException exn）{System.out.println（“SELECT failed with”+ exn）; } ...
</pre><p>请注意使用<code class="codeph">Address</code>对象的<code class="codeph">setStreet()</code>访问器方法。
                        </p>
                        <p>此示例使用<code class="codeph">printAddressDetails()</code>实用程序。此方法的源代码如下：</p><pre class="oac_no_warn" dir="ltr">static void printAddressDetails（Address a）抛出SQLException {if（a == null）{System.out.println（“No Address available。”）;返回; } String street =（（a.getStreet（）== null）？“NULL street”：a.getStreet（））; String city =（a.getCity（）== null）？“NULL city”：a.getCity（）;字符串状态=（a.getState（）== null）？“NULL状态”：a.getState（）;字符串zip_code =（a.getZipCode（）== null）？“NULL zip”：a.getZipCode（）; System.out.println（“Street：'”+ street +“'”）; System.out.println（“City：'”+ city +“'”）; System.out.println（“State：'”+ state +“'”）; System.out.println（“Zip：'”+ zip_code +“'”）; }</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ470"></a><div class="props_rev_3"><a id="GUID-1AAE5F9C-67D0-4800-A1F0-5BEEEC683013" name="GUID-1AAE5F9C-67D0-4800-A1F0-5BEEEC683013"></a><h4 id="JSQLJ-GUID-1AAE5F9C-67D0-4800-A1F0-5BEEEC683013" class="sect4">插入从单个对象属性创建的对象</h4>
                  <div>
                     <div class="section">
                        <p>此示例声明并设置与<code class="codeph">PERSON</code>属性和嵌套<code class="codeph">ADDRESS</code>对象相对应的输入主机变量，然后使用这些值将新<code class="codeph">PERSON</code>对象插入到数据库中的<code class="codeph">persons</code>表中。
                        </p><pre class="oac_no_warn" dir="ltr">...//插入对象static void insertObject（）{String new_name =“NEW PERSON”; int new_ssn = 987654; String new_street =“NEW STREET”; String new_city =“NEW CITY”; String new_state =“NS”; String new_zip =“NZIP”; / * *在person表中插入一个新的PERSON对象* / try {#sql {INSERT INTO人VALUES（PERSON（：new_name，：new_ssn，ADDRESS（：new_street，：new_city，：new_state，：new_zip）））}; System.out.println（“Inserted PERSON object NEW PERSON。”）; } catch（SQLException exn）{System.out.println（“INSERT failed with”+ exn）; } ...
</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ471"></a><div class="props_rev_3"><a id="GUID-BE3CBAF4-E752-4F6E-93F5-76C06A848D51" name="GUID-BE3CBAF4-E752-4F6E-93F5-76C06A848D51"></a><h4 id="JSQLJ-GUID-BE3CBAF4-E752-4F6E-93F5-76C06A848D51" class="sect4">更新对象引用</h4>
                  <div>
                     <div class="section">
                        <p>本实施例中选择一个<code class="codeph">PERSON</code>从参考<code class="codeph">persons</code>表并使用它来更新<code class="codeph">PERSON</code>在参考<code class="codeph">employees</code>表。它使用简单的输入主机变量来检查属性值标准。然后，使用新更新的引用来选择它所引用的<code class="codeph">PERSON</code>对象，以便可以将信息输出给用户以验证更改。
                        </p><pre class="oac_no_warn" dir="ltr">...//将REF更新为对象static void updateRef（）{int empnum = 1001; String new_manager =“NEW PERSON”; System.out.println（“更新管理器REF。”）; try {#sql {UPDATE employees SET manager =（SELECT REF（p）FROM persons p WHERE p.name =：new_manager）WHERE empnumber =：empnum}; System.out.println（“员工1001的更新经理。选择返回“）;} catch（SQLException exn）{System.out.println（”UPDATE REF失败，带有“+ exn）;} / *选择管理器返回以验证更新* /人员管理器;尝试{#sql {SELECT deref （经理）INTO：经理来自员工e WHERE empnumber =：empnum}; System.out.println（“当前经理”+ empnum +“：”）; printPersonDetails（manager）;} catch（SQLException exn）{System.out。 println（“SELECT REF失败了”+ exn）;}} ...
</pre><div class="infoboxnote" id="GUID-BE3CBAF4-E752-4F6E-93F5-76C06A848D51__GUID-5E9841E5-65A2-4F61-8D59-A299294C1B22">
                           <p class="notep1">注意：</p>
                           <p>此示例使用表别名语法（ <code class="codeph">p</code> ），如前所述。此外，在通过它引用的对象选择引用时需要<code class="codeph">REF</code>语法，并且在通过引用选择对象时需要<code class="codeph">DEREF</code>语法。有关表别名， <code class="codeph">REF</code>和<code class="codeph">DEREF</code>更多信息，请参阅<a href="../sqlrf/Syntax-for-Schema-Objects-and-Parts-in-SQL-Statements.html#SQLRF-GUID-08B73ED6-2ABA-4737-B8A1-F7BD0456AEDB" target="_blank"><span class="italic">Oracle数据库SQL语言参考</span></a> 。</p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="JSQLJ472"></a><div class="props_rev_3"><a id="GUID-B58EDE94-BD0C-4C00-960B-4D8267F72DFD" name="GUID-B58EDE94-BD0C-4C00-960B-4D8267F72DFD"></a><h3 id="JSQLJ-GUID-B58EDE94-BD0C-4C00-960B-4D8267F72DFD" class="sect3">SQLJ可执行语句中强类型的集合</h3>
               <div>
                  <p>与强类型对象和引用一样，Oracle SQLJ实现支持使用迭代器或宿主表达式通过强类型集合读取和写入数据的不同方案。</p>
                  <p>从SQLJ开发人员的角度来看，两个集合类别VARRAY和嵌套表的处理方式基本相同，但在实现和性能方面存在一些差异。</p>
                  <p>Oracle SQLJ实现支持语法选择，因此嵌套表可以与其外表一起访问或操作。在本节中，嵌套表的操作本身将被称为详细级操作，嵌套表及其外表的操作将被称为主级操作。</p>
                  <p>在对一些语法进行简要讨论之后，本节的大部分内容都集中在操作嵌套表的示例上，因为它们的使用比VARRAY的使用稍微复杂一些。</p>
                  <div class="infoboxnote" id="GUID-B58EDE94-BD0C-4C00-960B-4D8267F72DFD__GUID-D0E7C0F8-8F58-41EF-B4AE-90B046B25F07">
                     <p class="notep1">注意：</p>
                     <p>在Oracle SQLJ实现中，只能完整地检索VARRAY类型和嵌套表类型。这与Oracle SQL实现相反，后者可以有选择地查询嵌套表。</p>
                  </div>
                  <p>本节包括以下主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="objects-collections-and-OPAQUE-types.html#GUID-CB799C12-7B7B-42D0-B07B-D62D44B93ADF">访问嵌套表：TABLE语法和CURSOR语法</a></p>
                     </li>
                     <li>
                        <p><a href="objects-collections-and-OPAQUE-types.html#GUID-2CDD8601-C214-4895-96D3-35585F3D5796">插入包含嵌套表的行</a></p>
                     </li>
                     <li>
                        <p><a href="objects-collections-and-OPAQUE-types.html#GUID-C646BEEE-5E17-4237-86F2-8A9C0E52E521">选择嵌套表到主机表达式</a></p>
                     </li>
                     <li>
                        <p><a href="objects-collections-and-OPAQUE-types.html#GUID-03072A77-33BA-4CA0-AF0C-BAFD8AAF75E8">使用TABLE语法操作嵌套表</a></p>
                     </li>
                     <li>
                        <p><a href="objects-collections-and-OPAQUE-types.html#GUID-0F4FEE06-608F-4CB9-BC5C-A0C36650A20E">使用嵌套迭代器从嵌套表中选择数据</a></p>
                     </li>
                     <li>
                        <p><a href="objects-collections-and-OPAQUE-types.html#GUID-DA6DA7F6-6743-4E59-B0A5-294FDEB204BB">选择VARRAY到主机表达式</a></p>
                     </li>
                     <li>
                        <p><a href="objects-collections-and-OPAQUE-types.html#GUID-03B5A7C7-CA42-4E3B-B57A-131DC6875B36">插入包含VARRAY的行</a></p>
                     </li>
                  </ul>
               </div><a id="JSQLJ473"></a><div class="props_rev_3"><a id="GUID-CB799C12-7B7B-42D0-B07B-D62D44B93ADF" name="GUID-CB799C12-7B7B-42D0-B07B-D62D44B93ADF"></a><h4 id="JSQLJ-GUID-CB799C12-7B7B-42D0-B07B-D62D44B93ADF" class="sect4">访问嵌套表：TABLE语法和CURSOR语法</h4>
                  <div>
                     <div class="section">
                        <p>Oracle SQLJ实现支持使用嵌套迭代器来访问嵌套表中的数据。使用外部<code class="codeph">SELECT</code>语句中的<code class="codeph">CURSOR</code>关键字来封装内部<code class="codeph">SELECT</code>语句。这在<span class="q">“ <a href="objects-collections-and-OPAQUE-types.html#GUID-0F4FEE06-608F-4CB9-BC5C-A0C36650A20E">使用嵌套迭代器从嵌套表中选择数据</a> ”中显示</span> 。
                        </p>
                        <p>Oracle还支持使用<code class="codeph">TABLE</code>关键字来操作嵌套表的各个行。此关键字通知Oracle子查询返回的列值是嵌套表，而不是标量值。您必须将<code class="codeph">TABLE</code>关键字前缀添加到返回单个列值的子查询或产生嵌套表的表达式。
                        </p>
                        <p>以下示例显示了<code class="codeph">TABLE</code>语法的用法：</p><pre class="oac_no_warn" dir="ltr">UPDATE TABLE（SELECT a.modules FROM project a WHERE a.id = 555）b SET module_owner =（SELECT ref（p）FROM employees p WHERE p.ename ='Smith'）WHERE b.module_name ='Zebra';</pre><p>当您看到此处使用的<code class="codeph">TABLE</code>时，请意识到它指的是从外部表的列中选择的单个嵌套表。
                        </p>
                        <div class="infoboxnote" id="GUID-CB799C12-7B7B-42D0-B07B-D62D44B93ADF__GUID-78769A8D-4B7E-4487-ABF6-B993D472C1C9">
                           <p class="notep1">注意：</p>
                           <p>此示例使用表别名语法（ <code class="codeph">a</code>表示<code class="codeph">projects</code> ， <code class="codeph">b</code>表示嵌套表， <code class="codeph">p</code>表示<code class="codeph">employees</code> ），如前所述。
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ474"></a><div class="props_rev_3"><a id="GUID-2CDD8601-C214-4895-96D3-35585F3D5796" name="GUID-2CDD8601-C214-4895-96D3-35585F3D5796"></a><h4 id="JSQLJ-GUID-2CDD8601-C214-4895-96D3-35585F3D5796" class="sect4">插入包含嵌套表的行</h4>
                  <div>
                     <div class="section">
                        <p>此示例显示了同时且显式地操作主级别（外部表）和详细级别（嵌套表）的操作。这会在<code class="codeph">projects</code>表中插入一行，其中每行包含<code class="codeph">MODULETBL_T</code>类型的嵌套表，该表包含<code class="codeph">MODULE_T</code>对象的行。
                        </p>
                        <p>首先，设置标量值（ <code class="codeph">id</code> ， <code class="codeph">name</code> ， <code class="codeph">start_date</code> ， <code class="codeph">duration</code> ），然后设置嵌套表值。这涉及额外的抽象级别，因为嵌套的表元素是具有多个属性的对象。在设置嵌套表值时，必须为嵌套表中的每个<code class="codeph">MODULE_T</code>对象设置每个属性值。最后，最初设置为<code class="codeph">null</code>的<code class="codeph">owner</code>值在单独的语句中设置。
                        </p><pre class="oac_no_warn" dir="ltr">//插入嵌套表详细信息以及主要详细信息public static void insertProject2（int id）throws Exception {System.out.println（“使用嵌套表详细信息插入项目..”）;尝试{#sql {INSERT INTO Projects（id，name，owner，start_date，duration，modules）VALUES（600，'Ruby'，null，'10 -MAY-98'，300，moduletbl_t（module_t（6001，'Setup'） ，null，'01 -JAN-98'，100），module_t（6002，'BenchMark'，null，'05-FEB-98'，20），module_t（6003，'Purchase'，null，'15 -MAR- 98'，50），module_t（6004，'Install'，null，'15 -MAR-98'，44），module_t（6005，'Launch'，null，'12 -MAY-98'，34）））} ; } catch（Exception e）{System.out.println（“Error：insertProject2”）; e.printStackTrace（）; } //将项目所有者分配给此项目try {#sql {UPDATE Projects pr SET owner =（SELECT ref（pa）FROM participant pa paERE pa.empno = 7698）WHERE pr.id = 600}; } catch（Exception e）{System.out.println（“Error：insertProject2：update”）; e.printStackTrace（）; }}</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ475"></a><div class="props_rev_3"><a id="GUID-C646BEEE-5E17-4237-86F2-8A9C0E52E521" name="GUID-C646BEEE-5E17-4237-86F2-8A9C0E52E521"></a><h4 id="JSQLJ-GUID-C646BEEE-5E17-4237-86F2-8A9C0E52E521" class="sect4">选择嵌套表到主机表达式</h4>
                  <div>
                     <div class="section">
                        <p>此示例提供了一种直接在嵌套表的详细级别上运行的操作。</p><pre class="oac_no_warn" dir="ltr">static ModuletblT mymodules = null; ...public static void getModules2（int projId）throws Exception {System.out.println（“display modules for project”+ projId）; try {#sql {SELECT modules INTO：mymodules FROM projects WHERE id =：projId}; showArray（mymodules）; } catch（Exception e）{System.out.println（“Error：getModules2”）; e.printStackTrace（）; public static void showArray（ModuletblT a）{try {if（a == null）System.out.println（“the array is null”）; else {System.out.println（“打印大小的ModuleTable数组对象”+ a.length（））; ModuleT [] modules = a.getArray（）; for（int i = 0; i &lt;modules.length; i ++）{ModuleT module = modules [i]; System.out.println（“module”+ module.getModuleId（）+“，”+ module.getModuleName（）+“，”+ module.getModuleStartDate（）+“，”+ module.getModuleDuration（））; catch（Exception e）{System.out.println（“Show Array”）; e.printStackTrace（）; }}</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ476"></a><div class="props_rev_3"><a id="GUID-03072A77-33BA-4CA0-AF0C-BAFD8AAF75E8" name="GUID-03072A77-33BA-4CA0-AF0C-BAFD8AAF75E8"></a><h4 id="JSQLJ-GUID-03072A77-33BA-4CA0-AF0C-BAFD8AAF75E8" class="sect4">使用TABLE语法操作嵌套表</h4>
                  <div>
                     <div class="section">
                        <p>此示例使用<code class="codeph">TABLE</code>语法在详细级别工作，以根据主级别条件直接访问和更新嵌套表元素。
                        </p>
                        <p><code class="codeph">assignModule()</code>方法从<code class="codeph">PROJECTS</code>表的<code class="codeph">MODULES</code>列中选择一个嵌套的<code class="codeph">MODULE_T</code>对象表，然后更新嵌套表的特定行的<code class="codeph">MODULE_NAME</code> 。类似地， <code class="codeph">deleteUnownedModules()</code>方法选择嵌套的<code class="codeph">MODULE_T</code>对象表，然后删除嵌套表中的任何无主模块，其中<code class="codeph">MODULE_OWNER</code>为<code class="codeph">null</code> 。
                        </p>
                        <p>如前所述，这些方法使用表别名语法。在这种情况下， <code class="codeph">m</code>用于嵌套表， <code class="codeph">p</code>用于<code class="codeph">participants</code>表。
                        </p><pre class="oac_no_warn" dir="ltr">/ * assignModule说明使用TABLE构造访问嵌套表并更新嵌套表行* / public static void assignModule（int projId，String moduleName，String modOwner）throws Exception {System.out.println（“Update：Assign'”+ moduleName +“'to'”+ modOwner +“'”）; try {#sql {UPDATE TABLE（SELECT modules FROM projects WHERE id =：projId）m SET m.module_owner =（SELECT ref（p）FROM participant p WHERE p.ename =：modOwner）WHERE m.module_name =：moduleName}; } catch（Exception e）{System.out.println（“Error：insertModules”）; e.printStackTrace（）; / * deleteUnownedModules //演示删除嵌套表元素* / public static void deleteUnownedModules（int projId）throws Exception {System.out.println（“删除项目的无主模块”+ projId）; try {#sql {DELETE TABLE（SELECT modules FROM projects WHERE id =：projId）m WHERE m.module_owner IS NULL}; } catch（Exception e）{System.out.println（“Error：deleteUnownedModules”）; e.printStackTrace（）; }}</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ477"></a><div class="props_rev_3"><a id="GUID-0F4FEE06-608F-4CB9-BC5C-A0C36650A20E" name="GUID-0F4FEE06-608F-4CB9-BC5C-A0C36650A20E"></a><h4 id="JSQLJ-GUID-0F4FEE06-608F-4CB9-BC5C-A0C36650A20E" class="sect4">使用嵌套迭代器从嵌套表中选择数据</h4>
                  <div>
                     <div class="section">
                        <p>SQLJ支持使用嵌套迭代器作为访问嵌套表的方法。这需要<code class="codeph">CURSOR</code>语法，如以下示例所示。该代码定义了一个命名迭代器类<code class="codeph">ModuleIter</code> ，然后将该类用作另一个命名迭代器类<code class="codeph">ProjIter</code>的<code class="codeph">modules</code>列的类型。在填充的<code class="codeph">ProjIter</code>实例中，每个<code class="codeph">modules</code>项都是一个嵌套的表，呈现为嵌套的迭代器。
                        </p>
                        <p><code class="codeph">CURSOR</code>语法是填充嵌套迭代器的嵌套<code class="codeph">SELECT</code>语句的一部分。选择数据后，将通过迭代器访问器方法将其输出给用户。
                        </p>
                        <p>此示例使用必需的表别名语法，如前所述。在这种情况下， <code class="codeph">a</code>表示<code class="codeph">projects</code>表， <code class="codeph">b</code>表示嵌套表。
                        </p><pre class="oac_no_warn" dir="ltr">...//使用ModuleIter访问嵌套表//将ModuleIter定义为Named Iterator #sql public static iterator ModuleIter（int moduleId，String moduleName，String moduleOwner）; //使用定义为//命名迭代器的ProjIter获取项目详细信息。注意ModuleIter的使用：#sql public static iterator ProjIter（int id，String name，String owner，Date start_date，ModuleIter modules）; ...public static void listAllProjects（）抛出SQLException {System.out.println（“列出项目......”）; //实例化并初始化迭代器ProjIter projs = null; ModuleIter mods = null; #sql projs = {SELECT a.id，a.name，initcap（a.owner.ename）as“owner”，a.start_date，CURSOR（SELECT b.module_id AS“moduleId”，b.module_name AS“moduleName”， initcap（b.module_owner.ename）AS“moduleOwner”FROM TABLE（a.modules）b）AS“modules”FROM projects a}; //显示项目详细信息while（projs.next（））{System.out.println（“\ n'”+ projs.name（）+“'Project Id：”+ projs.id（）+“归”所有+“'”+ projs.owner（）+“'”+“start on”+ projs.start_date（））; //注意ProjIter中的模块被分配给模块//迭代器变量mods = projs.modules（）; System.out.println（“此项目中的模块是：”）; //显示模块详细信息while（mods.next（））{System.out.println（“”+ mods.moduleId（）+“'”+ mods.moduleName（）+“'owner is'”+ mods.moduleOwner（ ）+“'”）; } //模块结束mods.close（）; } //项目结束projs.close（）; }</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ478"></a><div class="props_rev_3"><a id="GUID-DA6DA7F6-6743-4E59-B0A5-294FDEB204BB" name="GUID-DA6DA7F6-6743-4E59-B0A5-294FDEB204BB"></a><h4 id="JSQLJ-GUID-DA6DA7F6-6743-4E59-B0A5-294FDEB204BB" class="sect4">选择VARRAY到主机表达式</h4>
                  <div>
                     <div class="section">
                        <p>本节提供了将VARRAY选择到主机表达式的示例。假定以下SQL定义：</p><pre class="oac_no_warn" dir="ltr">创建类型PHONE_ARRAY是varray2（30）的VARRAY（10）/ / ***创建ADDRESS UDT *** /创建类型地址作为对象（街道VARCHAR（60），城市VARCHAR（30），状态CHAR（2），zip_code CHAR（5））/ / ***创建包含嵌入式ADDRESS UDT的PERSON UDT *** / CREATE TYPE PERSON AS OBJECT（名称VARCHAR（30），ssn NUMBER，addr ADDRESS）/ CREATE TABLE employees（empnumber INTEGER PRIMARY KEY， person_data REF人，经理REF人，office_addr地址，工资号码，phone_nums phone_array）/</pre><p>并假设您创建了一个<code class="codeph">PhoneArray</code>自定义集合类，以便从<code class="codeph">PHONE_ARRAY</code> SQL类型进行映射。
                        </p>
                        <p>以下方法从此表中选择一行，将数据放入<code class="codeph">PhoneArray</code>类型的主机变量中：</p><pre class="oac_no_warn" dir="ltr">private static void selectVarray（）抛出SQLException {PhoneArray ph; #sql {select phone_nums into：ph emp from employees empnumber = 2001}; System.out.println（PhoneArray中有“+ ph.length（）+”电话号码。它们是：“）; String [] pharr = ph.getArray（）; for（int i = 0; i &lt;pharr.length; ++ i）System.out.println（pharr [i]）;}</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ479"></a><div class="props_rev_3"><a id="GUID-03B5A7C7-CA42-4E3B-B57A-131DC6875B36" name="GUID-03B5A7C7-CA42-4E3B-B57A-131DC6875B36"></a><h4 id="JSQLJ-GUID-03B5A7C7-CA42-4E3B-B57A-131DC6875B36" class="sect4">插入包含VARRAY的行</h4>
                  <div>
                     <div class="section">
                        <p>本节提供了使用与上一节中相同的SQL定义和自定义集合类（ <code class="codeph">PhoneArray</code> ）将主机表达式中的数据插入VARRAY的示例。
                        </p>
                        <p>以下方法填充<code class="codeph">PhoneArray</code>实例并将其用作主机变量，将其数据插入数据库中的VARRAY：</p><pre class="oac_no_warn" dir="ltr">//创建一个PhoneArray的varray对象并将其插入一个新行private static void insertVarray（）抛出SQLException {PhoneArray phForInsert = consUpPhoneArray（）; //从先前的演示运行中清理#sql {从员工中删除empnumber = 2001}; //插入PhoneArray对象#sql {insert into employees（empnumber，phone_nums）values（2001，：phForInsert）}; private static PhoneArray consUpPhoneArray（）{String [] strarr = new String [3]; strarr [0] =“（510）555.1111”; strarr [1] =“（617）555.2222”; strarr [2] =“（650）555.3333”;返回新的PhoneArray（strarr）; }</pre></div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="JSQLJ480"></a><div class="props_rev_3"><a id="GUID-4A2FC8B8-81B2-4B3B-B0D4-1102A7F7F21A" name="GUID-4A2FC8B8-81B2-4B3B-B0D4-1102A7F7F21A"></a><h3 id="JSQLJ-GUID-4A2FC8B8-81B2-4B3B-B0D4-1102A7F7F21A" class="sect3">序列化的Java对象</h3>
               <div>
                  <p>在向数据库写入或从数据库中读取Java对象的实例时，有时候定义与Java类对应的SQL对象类型并使用映射前面描述的自定义Java类的机制是有利的。这完全允许对Java对象进行SQL查询。</p>
                  <p>但是，在某些情况下，您可能希望“按原样”存储Java对象，并使用<code class="codeph">RAW</code>或<code class="codeph">BLOB</code>类型的数据库列稍后检索它们。有不同的方法来实现这一目标：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>您可以使用类型映射工具的非标准扩展或通过向可序列化类添加类型代码字段将可序列化Java类映射到<code class="codeph">RAW</code>或<code class="codeph">BLOB</code>列，以便可序列化类的实例可以存储为<code class="codeph">RAW</code>或<code class="codeph">BLOB</code> 。</p>
                     </li>
                     <li>
                        <p>您可以使用<code class="codeph">ORAData</code>工具来定义可序列化的包装类，其实例可以存储在<code class="codeph">RAW</code>或<code class="codeph">BLOB</code>列中。
                        </p>
                     </li>
                  </ul>
                  <p>以任何这些方式进行序列化都适用于任何Oracle SQLJ运行时库。</p>
                  <p>本节包括以下主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="objects-collections-and-OPAQUE-types.html#GUID-E4E468F9-16AE-44FA-83E8-B9F40A487F3C">将Java类序列化为RAW和BLOB列</a></p>
                     </li>
                     <li>
                        <p><a href="objects-collections-and-OPAQUE-types.html#GUID-57A81264-D048-417F-8097-FDB9842DFAF0">SerializableDatum：ORAData实现</a></p>
                     </li>
                     <li>
                        <p><a href="objects-collections-and-OPAQUE-types.html#GUID-13212854-72AA-451F-8F85-CD8602AAB6DB">SQLJ应用程序中的SerializableDatum</a></p>
                     </li>
                     <li>
                        <p><a href="objects-collections-and-OPAQUE-types.html#GUID-FCD7C967-355A-48CF-A2DA-2E0E13BDD3C4">SerializableDatum（完整类）</a></p>
                     </li>
                  </ul>
               </div><a id="JSQLJ482"></a><a id="JSQLJ483"></a><a id="JSQLJ484"></a><a id="JSQLJ481"></a><div class="props_rev_3"><a id="GUID-E4E468F9-16AE-44FA-83E8-B9F40A487F3C" name="GUID-E4E468F9-16AE-44FA-83E8-B9F40A487F3C"></a><h4 id="JSQLJ-GUID-E4E468F9-16AE-44FA-83E8-B9F40A487F3C" class="sect4">将Java类序列化为RAW和BLOB列</h4>
                  <div>
                     <p>如果要直接在<code class="codeph">RAW</code>或<code class="codeph">BLOB</code>列中存储Java类的实例，则必须满足某些非标准要求才能指定所需的SQL-Java映射。请注意，在SQLJ语句中，可序列化的Java对象可以透明地读取和写入，就像它们是内置类型一样。
                     </p>
                     <p>在指定SQL-Java类型映射时有两个选项：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>在连接上下文声明中声明类型映射，并使用此类型映射指定映射。</p>
                        </li>
                        <li>
                           <p>使用<code class="codeph">public static final</code> field <code class="codeph">_SQL_TYPECODE</code>指定映射。
                           </p>
                        </li>
                     </ul>
                     <div class="section">
                        <p class="subhead3" id="GUID-E4E468F9-16AE-44FA-83E8-B9F40A487F3C__GUID-13105C6E-E3BC-4DDA-B83F-924EF821467F">为可序列化类定义类型映射</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>考虑一个<code class="codeph">SAddress</code> ， <code class="codeph">pack.的例子<code class="codeph">pack.SPerson</code> ，并<code class="codeph">pack.经理。InnerSPM</code> ，其中<code class="codeph">InnerSPM</code>是<code class="codeph">Manager</code>的内部类，是可序列化的Java类。换句话说，这些类实现了<code class="codeph">java.io.Serializable</code>界面。
                        </p>
                        <p>必须仅在使用声明的连接上下文类型的显式连接上下文实例的语句中使用这些类，例如以下示例中的<code class="codeph">SerContext</code> ：</p><pre class="oac_no_warn" dir="ltr">SAddress a = ...;包。SPerson p = ......;包。经理。InnerSPM pm = ...; SerContext ctx = new SerContext（url，user，pwd，false）; #sql [ctx] {...：a ...：OUT p ......：下午......};</pre><p>以下是必需的：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>必须使用<code class="codeph">with</code>子句的<code class="codeph">typeMap</code>属性声明连接上下文类型<code class="codeph">with</code>以指定实现<code class="codeph">java.util.的关联类<code class="codeph">java.util.PropertyResourceBundle</code> 。在示例中， <code class="codeph">SerContext</code>可以声明如下。
                              </p><pre class="oac_no_warn" dir="ltr">#sql public static context SerContext with（typeMap =“SerMap”）;</pre></li>
                           <li>
                              <p>类型映射资源必须提供从<code class="codeph">RAW</code>或<code class="codeph">BLOB</code>列到可序列化Java类的非标准映射。此映射使用以下格式的条目指定，具体取决于Java类是映射到<code class="codeph">RAW</code>列还是<code class="codeph">BLOB</code>列：</p><pre class="oac_no_warn" dir="ltr">甲骨文级。 <span class="variable" translate="no">java_class_name</span> = JAVA_OBJECT RAW oracle-class。 <span class="variable" translate="no">java_class_name</span> = JAVA_OBJECT BLOB</pre><p>关键字<code class="codeph">oracle-class</code>标记为特定于Oracle的扩展。在该示例中， <code class="codeph">SerMap.properties</code>资源文件可能包含以下条目：</p><pre class="oac_no_warn" dir="ltr">甲骨文级。SAddress = JAVA_OBJECT RAW oracle-class.pack。SPerson = JAVA_OBJECT BLOB oracle-class.packManager $ InnerSPM = JAVA_OBJECT RAW</pre><p>虽然句点（。）分隔包名和类名，但<span class="italic">必须</span>使用美元符号（$）来分隔内部类名。
                              </p>
                           </li>
                        </ul>
                        <p>请注意，此特定于Oracle的扩展可以放在与标准<code class="codeph">SQLData</code>类型映射条目相同的类型映射资源中。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-E4E468F9-16AE-44FA-83E8-B9F40A487F3C__GUID-7F86B2A1-EBF8-4CC2-AB63-3D5F3845993F">使用字段确定可序列化类的映射</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>作为对可序列化类使用类型映射的替代方法，可以使用可序列化类中的静态字段来确定类型映射。您可以将以下任一字段添加到实现<code class="codeph">java.io.的类中。Serializable</code>接口，例如前面示例中的<code class="codeph">SAddress</code>和<code class="codeph">SPerson</code>类：</p><pre class="oac_no_warn" dir="ltr">public final static int _SQL_TYPECODE = oracle.jdbc。OracleTypes。生的;</pre><pre class="oac_no_warn" dir="ltr">public final static int _SQL_TYPECODE = oracle.jdbc。OracleTypes。BLOB;</pre><div class="infoboxnote" id="GUID-E4E468F9-16AE-44FA-83E8-B9F40A487F3C__GUID-288B229B-EA5B-49BE-82EE-710F3E70AF45">
                           <p class="notep1">注意：</p>
                           <p>使用类型映射工具取代手动将<code class="codeph">_SQL_TYPECODE</code>字段添加到类中。
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-E4E468F9-16AE-44FA-83E8-B9F40A487F3C__GUID-CAD8FCC7-B322-484C-9DBA-6305A3982F2F">序列化Java对象的限制</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>您应该了解序列化的影响。如果两个对象A和B共享同一个对象C，那么在序列化和随后的A和B反序列化时，每个对象都指向它自己的对象C的克隆。共享被破坏。</p>
                        <p>另外，请注意，对于给定的Java类，您只能声明一种序列化： <code class="codeph">RAW</code>或<code class="codeph">BLOB</code> 。 SQLJ转换器只能检查实际使用是否符合<code class="codeph">RAW</code>或<code class="codeph">BLOB</code> 。</p>
                        <p><code class="codeph">RAW</code>色谱柱的大小有限。如果序列化Java对象的实际大小超过列的大小，则可能会遇到运行时错误。
                        </p>
                        <p>列大小对<code class="codeph">BLOB</code>列的限制要少得多。Oracle JDBC Oracle调用接口（OCI）驱动程序和Oracle JDBC Thin驱动程序支持将序列化Java对象写入<code class="codeph">BLOB</code>列。自Oracle9 <span class="italic">i</span>以来，所有Oracle JDBC驱动程序都支持从<code class="codeph">BLOB</code>列检索序列化对象。
                        </p>
                        <p>最后，以这种方式处理序列化Java对象是Oracle特定的扩展，需要Oracle SQLJ运行时以及默认的Oracle特定代码生成（ <code class="codeph">-codegen=oracle</code>期间<code class="codeph">-codegen=oracle</code> ）或ISO标准代码生成（ <code class="codeph">-codegen=iso</code> ），Oracle特定的配置文件定制。
                        </p>
                        <p>10iProd：请注意，Oracle的未来版本可能支持直接封装Java序列化对象的SQL类型。这些在JDBC 2.0中被描述为JAVA_OBJECT SQL类型。此时，您可以使用相应的JAVA_OBJECT SQL类型的名称替换每个BLOB和RAW名称，并且可以在条目上删除oracle-前缀。</p>
                        <div class="infoboxnote" id="GUID-E4E468F9-16AE-44FA-83E8-B9F40A487F3C__GUID-427AA3C2-4FF2-4001-939B-DA07D0969E16">
                           <p class="notep1">注意：</p>
                           <p>此特定序列化机制的实现不使用JDBC类型映射。映射（到<code class="codeph">BLOB</code>或<code class="codeph">RAW</code> ）在转换时在Oracle配置文件自定义中进行硬编码，或直接生成到Java代码中。
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ485"></a><div class="props_rev_3"><a id="GUID-57A81264-D048-417F-8097-FDB9842DFAF0" name="GUID-57A81264-D048-417F-8097-FDB9842DFAF0"></a><h4 id="JSQLJ-GUID-57A81264-D048-417F-8097-FDB9842DFAF0" class="sect4">SerializableDatum：ORAData实现</h4>
                  <div>
                     <div class="section">
                        <p><span class="q">“ <a href="objects-collections-and-OPAQUE-types.html#GUID-1F822A17-F41C-4994-95BB-886397ACFAE3">ORAData实现的其他用途</a> ”</span>包括您可能希望定义映射到<code class="codeph">oracle.sql.*</code>以外的某些<code class="codeph">oracle.sql.*</code>类型的自定义Java类的情况示例<code class="codeph">oracle.sql.STRUCT</code> ， <code class="codeph">oracle.sql.REF</code> ，或<code class="codeph">oracle.sql.ARRAY</code> 。</p>
                        <p>这种情况的一个示例是，如果要将Java对象序列化和反序列化为<code class="codeph">RAW</code>字段，请使用映射到<code class="codeph">oracle.sql.的自定义Java类<code class="codeph">oracle.sql.RAW</code>类型。这可以同样适用于<code class="codeph">BLOB</code>字段，使用映射到<code class="codeph">oracle.sql.的自定义Java类<code class="codeph">oracle.sql.BLOB</code>类型。
                        </p>
                        <p>本节提供了这样一个应用程序的示例，创建了一个类<code class="codeph">SerializableDatum</code> ，它实现了<code class="codeph">ORAData</code>接口并遵循自定义Java类的一般形式。该示例首先介绍了<code class="codeph">SerializableDatum</code>开发的逐步方法，然后是完整的示例代码。
                        </p>
                        <div class="infoboxnote" id="GUID-57A81264-D048-417F-8097-FDB9842DFAF0__GUID-5AC9D3E6-9A06-4C30-93D6-E3E04AEE81BE">
                           <p class="notep1">注意：</p>
                           <p>此应用程序使用<code class="codeph">java.io</code> ， <code class="codeph">java.sql</code> ， <code class="codeph">oracle.sql</code>和<code class="codeph">oracle.jdbc</code>包中的类。导入语句未在此处显示。
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>从课程的骨架开始。</span><div><pre class="oac_no_warn" dir="ltr">public class SerializableDatum实现ORAData {// <span class="italic">用于构造和访问Java对象</span> public Datum toDatum的<span class="italic">客户端方法</span> （java.sql。连接c）抛出SQLException {// <span class="italic">执行toDatum（）</span> } public static ORADataFactory getORADataFactory（）{return FACTORY; private static final ORADataFactory FACTORY = // <span class="italic">SerializableDatum的ORADataFactory实现</span> // <span class="italic">从oracle.sql构造SerializableDatum。RAW</span> public static final int _SQL_TYPECODE = OracleTypes。生的; }</pre><p><code class="codeph">SerializableDatum</code>不实现<code class="codeph">ORADataFactory</code>接口，但其<code class="codeph">getORADataFactory()</code>方法返回实现此接口的静态成员。
                              </p>
                              <p><code class="codeph">_SQL_TYPECODE</code>设置为<code class="codeph">OracleTypes.RAW</code>因为这是从数据库读取和写入的数据类型。SQLJ转换器在执行在线类型检查时需要此类型代码信息，以验证用户定义的Java类型与SQL类型之间的兼容性。
                              </p>
                           </div>
                        </li>
                        <li class="stepexpand"><span>定义执行以下操作的客户端方法：</span><div>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>创建<code class="codeph">SerializableDatum</code>对象。
                                    </p>
                                 </li>
                                 <li>
                                    <p>填充<code class="codeph">SerializableDatum</code>对象。
                                    </p>
                                 </li>
                                 <li>
                                    <p>从<code class="codeph">SerializableDatum</code>对象中检索数据。
                                    </p>
                                 </li>
                              </ul><pre class="oac_no_warn" dir="ltr">//构造和访问SerializableDatum私有对象的客户端方法m_data; public SerializableDatum（）{m_data = null; public void setData（Object data）{m_data = data; public Object getData（）{return m_data; }</pre></div>
                        </li>
                        <li class="stepexpand"><span>实现一个<code class="codeph">toDatum()</code>方法，该方法将<code class="codeph">SerializableDatum</code>对象中的数据序列化为<code class="codeph">oracle.sql.RAW</code>对象。<code class="codeph">toDatum()</code>的实现必须将<code class="codeph">m_data</code>字段中对象的序列化表示形式返回为<code class="codeph">oracle.sql.RAW</code>实例。</span><div><pre class="oac_no_warn" dir="ltr">// toDatum（）的实现尝试{ByteArrayOutputStream os = new ByteArrayOutputStream（）; ObjectOutputStream oos = new ObjectOutputStream（os）; oos.writeObject（M_DATA）; oos.close（）;返回新的RAW（os.toByteArray（））; } catch（Exception e）{throw new SQLException（“SerializableDatum.toDatum：”+ e.toString（））; }</pre></div>
                        </li>
                        <li class="stepexpand"><span>从<code class="codeph">oracle.sql.实现数据转换<code class="codeph">oracle.sql.RAW</code>对象为<code class="codeph">SerializableDatum</code>对象。此步骤反序列化数据。</span><div><pre class="oac_no_warn" dir="ltr">//从oracle.sql构造SerializableDatum。RAW private SerializableDatum（RAW raw）抛出SQLException {try {InputStream rawStream = new ByteArrayInputStream（raw.getBytes（））; ObjectInputStream是= new ObjectInputStream（rawStream）; m_data = is.readObject（）; is.close（）; } catch（Exception e）{throw new SQLException（“SerializableDatum.create：”+ e.toString（））; }}</pre></div>
                        </li>
                        <li class="stepexpand"><span>实现<code class="codeph">ORADataFactory</code> 。在这种情况下，它被实现为匿名类。</span><div><pre class="oac_no_warn" dir="ltr">//为SerializableDatum实现ORADataFactory new ORADataFactory（）{public ORAData create（Datum d，int sqlCode）抛出SQLException {if（sqlCode！= _SQL_TYPECODE）{throw new SQLException（“SerializableDatum：无效的SQL类型”+ sqlCode）; } return（d == null）？null：new SerializableDatum（（RAW）d）; }};</pre></div>
                        </li>
                     </ol>
                  </div>
               </div><a id="JSQLJ487"></a><a id="JSQLJ488"></a><a id="JSQLJ486"></a><div class="props_rev_3"><a id="GUID-13212854-72AA-451F-8F85-CD8602AAB6DB" name="GUID-13212854-72AA-451F-8F85-CD8602AAB6DB"></a><h4 id="JSQLJ-GUID-13212854-72AA-451F-8F85-CD8602AAB6DB" class="sect4">SQLJ应用程序中的SerializableDatum</h4>
                  <div>
                     <p>给定在上一节中创建的<code class="codeph">SerializableDatum</code>类，本节将介绍如何在SQLJ应用程序中使用它的实例，包括宿主变量和迭代器列。
                     </p>
                     <p>假设下表定义：</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE PERSONDATA（NAME VARCHAR2（20）NOT NULL，INFO RAW（2000））;</pre><div class="section">
                        <p class="subhead3" id="GUID-13212854-72AA-451F-8F85-CD8602AAB6DB__GUID-D7DFEB61-72D8-4391-BC8B-0D678CB18099">SerializableDatum作为主变量</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>以下使用<code class="codeph">SerializableDatum</code>实例作为主机变量：</p><pre class="oac_no_warn" dir="ltr">...SerializableDatum pinfo = new SerializableDatum（）; pinfo.setData（new Object [] {“Some objects”，new Integer（51），new Double（1234.27）}）; String pname =“MILLER”; #sql {INSERT INTO persondata VALUES（：pname，：pinfo）}; ...
</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-13212854-72AA-451F-8F85-CD8602AAB6DB__GUID-7D5AB996-FA5A-460A-9DC8-90FDEB946214">Iterator列中的SerializableDatum</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>以下是使用<code class="codeph">SerializableDatum</code>作为命名迭代器列的示例：</p><pre class="oac_no_warn" dir="ltr">#sql iterator PersonIter（SerializableDatum info，String name）; ...PersonIter pcur; #sql pcur = {SELECT * FROM persondata WHERE info IS NOT NULL}; while（pcur.next（））{System.out.println（“Name：”+ pcur.name（）+“Info：”+ pcur.info（））; } pcur.close（）; ...
</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ489"></a><div class="props_rev_3"><a id="GUID-FCD7C967-355A-48CF-A2DA-2E0E13BDD3C4" name="GUID-FCD7C967-355A-48CF-A2DA-2E0E13BDD3C4"></a><h4 id="JSQLJ-GUID-FCD7C967-355A-48CF-A2DA-2E0E13BDD3C4" class="sect4">SerializableDatum（完整类）</h4>
                  <div>
                     <p>以下是<code class="codeph">SerializableDatum</code>类的完整代码，它是在前面几节中逐步开发的。
                     </p><pre class="oac_no_warn" dir="ltr">import java.io.*; import java.sql。*; import oracle.sql。*; import oracle.jdbc。*; public class SerializableDatum实现ORAData {//用于构造和访问SerializableDatum私有对象m_data的客户端方法; public SerializableDatum（）{m_data = null; public void setData（Object data）{m_data = data; public Object getData（）{return m_data; } // toDatum（）的实现public Datum toDatum（Connection c）抛出SQLException {try {ByteArrayOutputStream os = new ByteArrayOutputStream（）; ObjectOutputStream oos = new ObjectOutputStream（os）; oos.writeObject（M_DATA）; oos.close（）;返回新的RAW（os.toByteArray（））; } catch（Exception e）{throw new SQLException（“SerializableDatum.toDatum：”+ e.toString（））; public static ORADataFactory getORADataFactory（）{return FACTORY; } //为SerializableDatum实现一个ORADataFactory私有静态最终ORADataFactory FACTORY = new ORADataFactory（）{public ORAData create（Datum d，int sqlCode）抛出SQLException {if（sqlCode！= _SQL_TYPECODE）{throw new SQLException（“SerializableDatum：无效的SQL类型”+ sqlCode）; } return（d == null）？null：new SerializableDatum（（RAW）d）; }}; //从oracle.sql构造SerializableDatum。RAW private SerializableDatum（RAW raw）抛出SQLException {try {InputStream rawStream = new ByteArrayInputStream（raw.getBytes（））; ObjectInputStream是= new ObjectInputStream（rawStream）; m_data = is.readObject（）; is.close（）; } catch（Exception e）{throw new SQLException（“SerializableDatum.create：”+ e.toString（））; public static final int _SQL_TYPECODE = OracleTypes。生的; }</pre></div>
               </div>
            </div><a id="JSQLJ490"></a><div class="props_rev_3"><a id="GUID-14DEE7DC-EA4A-4754-BF44-D1036E1CFB55" name="GUID-14DEE7DC-EA4A-4754-BF44-D1036E1CFB55"></a><h3 id="JSQLJ-GUID-14DEE7DC-EA4A-4754-BF44-D1036E1CFB55" class="sect3">弱类型对象，引用和集合</h3>
               <div>
                  <p>SQLJ支持弱类型的对象，引用和集合。通常不建议使用它们，并且存在一些特定的限制，但在某些情况下它们可能很有用。例如，您可能具有可以使用“任何<code class="codeph">STRUCT</code> ”或“任何<code class="codeph">REF</code> ”的通用代码。
                  </p>
                  <p>本节包括以下主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="objects-collections-and-OPAQUE-types.html#GUID-D7354A29-368B-4DB4-A7A5-49C0C0905006">支持弱类型Objects_ References_和Collections</a></p>
                     </li>
                     <li>
                        <p><a href="objects-collections-and-OPAQUE-types.html#GUID-4EF76552-5997-4966-970E-1947416861D3">弱类型Objects_ References_和Collections的限制</a></p>
                     </li>
                  </ul>
               </div><a id="JSQLJ491"></a><div class="props_rev_3"><a id="GUID-D7354A29-368B-4DB4-A7A5-49C0C0905006" name="GUID-D7354A29-368B-4DB4-A7A5-49C0C0905006"></a><h4 id="JSQLJ-GUID-D7354A29-368B-4DB4-A7A5-49C0C0905006" class="sect4">支持弱类型对象，引用和集合</h4>
                  <div>
                     <div class="section">
                        <p>在SQLJ应用程序中使用Oracle对象，引用或集合时，您可以选择使用泛型和弱类型的<code class="codeph">java.sql</code>或<code class="codeph">oracle.sql</code>实例，而不是实现<code class="codeph">ORAData</code>接口的强类型自定义对象，引用和集合类。或者实现<code class="codeph">SQLData</code>接口的强类型自定义对象类。请注意，如果您对自定义对象类使用<code class="codeph">SQLData</code>实现，那么您将别无选择，只能使用弱类型的自定义引用实例。
                        </p>
                        <p>以下弱类型可用于Oracle SQLJ实现中的迭代器列或主机表达式：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">java.sql中。Struct</code>或<code class="codeph">oracle.sql.对象的STRUCT</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">java.sql中。Ref</code>或<code class="codeph">oracle.sql.REF</code>用于对象引用</p>
                           </li>
                           <li>
                              <p><code class="codeph">java.sql中。Array</code>或<code class="codeph">oracle.sql.ARRAY</code>收藏品</p>
                           </li>
                        </ul>
                        <p>在主机表达式中，它们受支持如下：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>作为输入主机表达式</p>
                           </li>
                           <li>
                              <p>作为<code class="codeph">INTO</code> -list中的输出主机表达式</p>
                           </li>
                        </ul>
                        <p>但是，通常不建议使用这些弱类型，因为您将失去SQLJ提供的强类型范例的所有优点。</p>
                        <p><code class="codeph">STRUCT</code>对象中的每个属性或<code class="codeph">ARRAY</code>对象中的每个元素都存储在<code class="codeph">oracle.sql.Datum</code>对象，其底层数据采用<code class="codeph">Datum</code>的相应<code class="codeph">oracle.sql.*</code>子类型的形式，例如<code class="codeph">oracle.sql.NUMBER</code>或<code class="codeph">oracle.sql.CHAR</code> 。 <code class="codeph">STRUCT</code>对象中的属性是无名的。由于<code class="codeph">STRUCT</code>和<code class="codeph">ARRAY</code>类的通用特性，SQLJ无法执行类型检查，其中对象或集合被写入或读取这些类的实例。
                        </p>
                        <p>通常建议您为对象，引用和集合使用自定义Java类。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ492"></a><div class="props_rev_3"><a id="GUID-4EF76552-5997-4966-970E-1947416861D3" name="GUID-4EF76552-5997-4966-970E-1947416861D3"></a><h4 id="JSQLJ-GUID-4EF76552-5997-4966-970E-1947416861D3" class="sect4">弱类型对象，引用和集合的限制</h4>
                  <div>
                     <div class="section">
                        <p>在以下情况下， <span class="italic">不能</span>在主机表达式中使用弱类型对象（ <code class="codeph">Struct</code>或<code class="codeph">STRUCT</code>实例），引用（ <code class="codeph">Ref</code>或<code class="codeph">REF</code>实例）或集合（ <code class="codeph">Array</code>或<code class="codeph">ARRAY</code>实例）：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">IN</code>参数如果为null</p>
                           </li>
                           <li>
                              <p>存储过程或函数调用中的<code class="codeph">OUT</code>或<code class="codeph">INOUT</code>参数</p>
                           </li>
                           <li>
                              <p>存储函数结果表达式中的<code class="codeph">OUT</code>参数</p>
                           </li>
                        </ul>
                        <p>它们不能以这些方式使用，因为无法知道底层SQL类型名称，例如<code class="codeph">Person</code> ，Oracle JDBC驱动程序需要它来实现Java中用户定义类型的实例。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="JSQLJ493"></a><div class="props_rev_3"><a id="GUID-526F6AD9-AD62-4ED0-BCAB-5C2F8ED36FE4" name="GUID-526F6AD9-AD62-4ED0-BCAB-5C2F8ED36FE4"></a><h3 id="JSQLJ-GUID-526F6AD9-AD62-4ED0-BCAB-5C2F8ED36FE4" class="sect3">Oracle OPAQUE类型</h3>
               <div>
                  <p>Oracle OPAQUE类型是抽象数据类型。由于数据仅作为一系列字节实现，因此不会公开内部表示。通常，Oracle将提供OPAQUE类型，而不是由客户实现。</p>
                  <p>OPAQUE类型在对象类型的一些基本方式上类似，具有静态方法，实例和实例方法的类似概念。通常，只有OPAQUE类型提供的方法允许您操作状态和内部字节表示。在Java中，OPAQUE类型可以表示为<code class="codeph">oracle.sql.OPAQUE</code>或作为实现<code class="codeph">oracle.sql.的自定义类<code class="codeph">oracle.sql.ORAData</code>接口。在客户端，假设字节模式已知，可以实现Java代码来操作字节。
                  </p>
                  <p>OPAQUE类型的一个关键示例是<code class="codeph">XMLType</code> ，随Oracle Database 12 <span class="italic">c</span>第2版（12.2）提供。此Oracle提供的类型有助于在数据库中本机处理XML数据。
                  </p>
                  <p><code class="codeph">SYS.XMLType</code>提供以下通过Java <code class="codeph">SYS.XMLType</code>的功能<code class="codeph">oracle.xdb.XMLType</code>类：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>它可以用作表或视图中列的数据类型。<code class="codeph">XMLType</code>可以存储任何内容，但旨在优化存储XML内容。它的一个实例可以表示SQL中的XML文档。</p>
                     </li>
                     <li>
                        <p>它有一个带有内置成员函数的SQL API，可以对XML内容进行操作。例如，您可以使用<code class="codeph">XMLType</code>函数来创建，查询，提取和索引存储在Oracle Database <span class="italic">12c</span>第1版（12.1）实例中的XML数据。
                        </p>
                     </li>
                     <li>
                        <p>它可以在存储过程中用于参数，返回值和变量。</p>
                     </li>
                     <li>
                        <p>它的功能也可通过PL / SQL，Java和C（OCI）中提供的API获得。</p>
                     </li>
                  </ul>
                  <div class="infoboxnotealso" id="GUID-526F6AD9-AD62-4ED0-BCAB-5C2F8ED36FE4__GUID-F648856C-579D-4A37-A61E-A85176A1790F">
                     <p class="notep1">也可以看看：</p>
                     <p><a href="../adxdb/XML-DB-basics.html#ADXDB-GUID-8611495B-A091-4B11-9E65-E8AD20D50D97" target="_blank"><span class="italic">Oracle XML DB开发人员指南</span></a></p>
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>