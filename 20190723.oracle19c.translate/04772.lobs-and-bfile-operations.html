<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <meta name="abstract" content="This chapter describes LOB and BFILE operations."></meta>
      <meta name="description" content="This chapter describes LOB and BFILE operations."></meta>
      <title>LOB和BFILE操作</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Programmer&#39;s Guide"></meta>
      <meta property="og:description" content="This chapter describes LOB and BFILE operations."></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Programmer&#39;s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="oracle-call-interface-programmers-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-14T08:46:00-08:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="1996, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96204-01"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="describing-schema-metadata.html" title="Previous" type="text/html"></link>
      <link rel="next" href="managing-scalable-platforms.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Oracle Call Interface Programmer&#39;s Guide"></meta>
    <meta name="dcterms.isVersionOf" content="LNOCI"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="describing-schema-metadata.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="managing-scalable-platforms.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">程序员指南</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">LOB和BFILE操作</li>
            </ol>
            <a id="GUID-0A094518-F97C-40BE-A336-259AA82BD0A2" name="GUID-0A094518-F97C-40BE-A336-259AA82BD0A2"></a><a id="LNOCI070"></a>
            
            <h2 id="LNOCI-GUID-0A094518-F97C-40BE-A336-259AA82BD0A2" class="sect2"><span class="enumeration_chapter">9</span> LOB和BFILE操作</h2>
         </header>
         <div class="ind"><script type="text/javascript">window.name='lobs-and-bfile-operations'</script><script type="text/javascript">
    function footdisplay(footnum,footnote) {
    var msg = window.open('about:blank', 'NewWindow' + footnum,
        'directories=no,height=100,location=no,menubar=no,resizable=yes,' +
        'scrollbars=yes,status=no,toolbar=no,width=598');
    msg.document.open('text/html');
    msg.document.write('<!DOCTYPE html ');
    msg.document.write('PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" ');
    msg.document.write('"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">'); 
    msg.document.write('<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us" dir="ltr"><head><title>');
   
    msg.document.write('Footnote&nbsp; ' + footnum);
    msg.document.write('<\/title><meta http-equiv="Content-Type" ');
    msg.document.write('content="text/html; charset=utf-8" />');
    msg.document.write('<meta http-equiv="Content-Script-Type" ');
    msg.document.write('content="text/javascript" />');
    msg.document.write('<style type="text/css"> <![CDATA[ ');
    msg.document.write('h1 {text-align: center; font-size: 14pt;}');
    msg.document.write('fieldset {border: none;}');
    msg.document.write('form {text-align: center;}');
    msg.document.write(' ]]u003e </style>');
    msg.document.write('<\/head><body><div id="footnote"><h1>Footnote&nbsp; ' + footnum + '<\/h1><p>');
    msg.document.write(footnote);
    msg.document.write('<\/p><form action="" method="post"><fieldset>');
    msg.document.write('<input type="button" value="OK" ');
    msg.document.write('onclick="window.close();" />');
    msg.document.write('<\/fieldset><\/form><\/div><\/body><\/html>');
    msg.document.close();
    setTimeout(function() {
        var height = msg.document.getElementById('footnote').offsetHeight;
        msg.resizeTo(598, height + 100);
    }
    , 100);
    msg.focus();
}
            </script><noscript>
               <p>此页面上的脚本内容仅用于导航目的，不会以任何方式更改内容。</p>
            </noscript>
            <div>
               <p>本章介绍LOB和BFILE操作。</p>
               <p>本章包含以下主题：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="lobs-and-bfile-operations.html#GUID-CD11DD8F-77C6-4C14-BF75-DDB107CB246B" title="OCI包括一组用于对数据库中的大对象（LOB）执行操作的函数。">关于为LOB使用OCI函数</a></p>
                  </li>
                  <li>
                     <p><a href="lobs-and-bfile-operations.html#GUID-301C3875-9A32-4C37-A4A6-4FCF705EF1B2" title="LOB实例可以是持久性的（存储在数据库中），也可以是临时的（仅存在于应用程序的范围内）。">关于创建和修改持久性LOB</a></p>
                  </li>
                  <li>
                     <p><a href="lobs-and-bfile-operations.html#GUID-C416EA63-3DFE-4778-8163-8EFDEA1F8503" title="可以在INSERT语句中使用BFILENAME函数将外部服务器端（操作系统）文件与表中的BFILE列或属性相关联。">关于将表中的BFILE与操作系统文件关联</a></p>
                  </li>
                  <li>
                     <p><a href="lobs-and-bfile-operations.html#GUID-4622680F-D454-4DFE-8300-E74E74E39DBA" title="OCI应用程序可以使用OCIObjectNew（）函数创建具有LOB属性的持久或临时对象。">对象的LOB属性</a></p>
                  </li>
                  <li>
                     <p><a href="lobs-and-bfile-operations.html#GUID-93695EB3-E9D2-4F2B-B027-2D9AD99B586D" title="您可以将OCI阵列接口与LOB一起使用，就像使用任何其他数据类型一样。">LOB的数组接口</a></p>
                  </li>
                  <li>
                     <p><a href="lobs-and-bfile-operations.html#GUID-EC49588A-0534-4E43-8CB1-3D0FAE205BAB" title="从OCI的Oracle数据库10g第1版开始，引入了一些函数来支持大小超过4 GB的LOB。这些新功能也可用于少于4 GB的LOB的新应用程序。">关于使用大小超过4 GB的LOB</a></p>
                  </li>
                  <li>
                     <p><a href="lobs-and-bfile-operations.html#GUID-7595F604-B560-4121-8254-57801341B02F" title="在涉及数据偏移的所有LOB操作中，偏移量从1开始。对于LOB操作，例如OCILobCopy2（），OCILobErase2（），OCILobLoadFromFile2（）和OCILobTrim2（），无论客户端字符集如何，amount参数都是CLOB和NCLOB的字符。">OCI中的LOB和BFILE函数</a></p>
                  </li>
                  <li>
                     <p><a href="lobs-and-bfile-operations.html#GUID-B9A9B78B-570B-4B54-A4C4-A2F2D2808B06" title="OCI提供用于创建和释放临时LOB，OCILobCreateTemporary（）和OCILobFreeTemporary（）的函数，以及用于确定LOB是否是临时的函数OCILobIsTemporary（）。">临时LOB支持</a></p>
                  </li>
                  <li>
                     <p><a href="lobs-and-bfile-operations.html#GUID-3F7FEAFF-F4EF-42CC-8F95-598D227C5D83" title="为了改进较小LOB的OCI访问，可以预取和缓存LOB数据，同时还获取定位器。">预取LOB数据，长度和块大小</a></p>
                  </li>
                  <li>
                     <p><a href="lobs-and-bfile-operations.html#GUID-5DEEF1FA-0024-48B4-B587-506386EA5240" title="对于SecureFiles（具有STORE AS SECUREFILE选项的LOB，它是在Oracle Database 11g第1版中引入的），您可以在CREATE TABLE和ALTER TABLE语句中指定SQL参数DEDUPLICATE。">SecureFiles LOB的选项</a></p>
                  </li>
               </ul>
            </div><a id="LNOCI16500"></a><div class="props_rev_3"><a id="GUID-CD11DD8F-77C6-4C14-BF75-DDB107CB246B" name="GUID-CD11DD8F-77C6-4C14-BF75-DDB107CB246B"></a><h3 id="LNOCI-GUID-CD11DD8F-77C6-4C14-BF75-DDB107CB246B" class="sect3"><span class="enumeration_section">9.1</span>关于对LOB使用OCI函数</h3>
               <div>
                  <p>OCI包括一组用于对数据库中的大对象（LOB）执行操作的函数。</p>
                  <p>持久性LOB（ <code class="codeph">BLOB</code> ， <code class="codeph">CLOB</code> ， <code class="codeph">NCLOB</code> ）以优化空间和提供高效访问的方式存储在数据库表空间中。这些LOB具有Oracle数据库的完整事务支持。<code class="codeph">BFILE</code>是存储在数据库表空间外的服务器操作系统文件中的大型数据对象。
                  </p>
                  <p>OCI还为临时LOB提供支持，可以像局部变量一样使用它来操作LOB数据。</p>
                  <p><code class="codeph">BFILE</code>是只读的。Oracle数据库仅支持二进制<code class="codeph">BFILE</code> 。
                  </p>
                  <p>从Oracle Database 12c第2版（12.2）开始，大多数LOB功能都支持应用程序连续性。</p>
                  <p>从Oracle Database 12 <code class="codeph">c</code>第2版（12.2）开始，OCI LOB API支持远程LOB（CLOB，BLOB）上的分布式操作，但BFILES的OCI LOB API除外。这包括支持选择远程LOB定位器的某些查询，这些定位器在先前版本中返回错误。唯一的限制是，所有接收两个定位器的LOB API都应该在一个数据库中并置两个LOB。远程定位器传递给它时，以下LOB函数会抛出错误： <code class="codeph">OCILobAssign()</code> ， <code class="codeph">OCILobLocatorAssign()</code> ， <code class="codeph">OCILobEnableBuffering()</code> ， <code class="codeph">OCILobDisableBuffering()</code> ， <code class="codeph">OCILobFlushBuffer()</code> ， <code class="codeph">OCILobArrayRead()</code> ， <code class="codeph">OCILobArrayWrite()</code>和<code class="codeph">OCILobLoadFromFile2()</code> 。
                  </p>
                  <div class="infoboxnotealso" id="GUID-CD11DD8F-77C6-4C14-BF75-DDB107CB246B__GUID-39122048-791C-48F1-BFD4-95EB8F069524">
                     <p class="notep1">也可以看看：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="oci-demo-programs.html#GUID-75E18629-0C54-4495-A747-AFB346034F26" title="列出示例程序，其中包含示例代码，用于演示OCI句柄的分配和使用。">OCI演示程序，</a>用于显示LOB使用的代码示例</p>
                        </li>
                        <li>
                           <p><code class="codeph">$ORACLE_HOME/rdbms/demo/lobs/oci/</code>用于特定的LOB代码示例</p>
                        </li>
                        <li>
                           <p><code class="codeph">DBMS_LOB</code>包的<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/lnoci&amp;id=ARPLS020" target="_blank"><span><cite>Oracle Database PL / SQL包和类型参考</cite></span></a></p>
                        </li>
                        <li>
                           <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/lnoci&amp;id=ADLOB001" target="_blank"><span><cite>Oracle Database SecureFiles和大对象开发人员指南</cite></span></a></p>
                        </li>
                        <li>
                           <p><a href="high-availability-in-oci.html#GUID-D30079AC-4E59-4CC3-86E8-6487A4891BA2" title="描述如果发生中断，OCI中的应用程序连续性可以进行故障转移时的哪些功能。">当OCI中的应用程序连续性可以故障转移</a>以获得完整列表时。
                           </p>
                        </li>
                        <li>
                           <p>有关支持Application Continuity的信息，不推荐<a href="deprecated-oci-functions.html#GUID-9AAA282E-CCF4-4D93-9C04-4351E61E693F" title="描述不推荐使用的LOB函数。">使用的Lob函数</a>还包括一些不推荐使用的LOB函数，以实现兼容性。
                           </p>
                        </li>
                     </ul>
                  </div>
               </div>
            </div><a id="LNOCI13233"></a><div class="props_rev_3"><a id="GUID-301C3875-9A32-4C37-A4A6-4FCF705EF1B2" name="GUID-301C3875-9A32-4C37-A4A6-4FCF705EF1B2"></a><h3 id="LNOCI-GUID-301C3875-9A32-4C37-A4A6-4FCF705EF1B2" class="sect3"><span class="enumeration_section">9.2</span>关于创建和修改持久性LOB</h3>
               <div>
                  <p>LOB实例可以是持久性的（存储在数据库中），也可以是临时的（仅存在于应用程序的范围内）。</p>
                  <p>不要将持久性LOB的概念与持久性对象混淆。</p>
                  <p>有两种方法可以创建和修改持久性LOB：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><span>使用数据接口</span></p>
                        <p>您可以通过将字符数据插入<code class="codeph">CLOB</code>列或将<code class="codeph">RAW</code>数据直接插入<code class="codeph">BLOB</code>列来创建LOB。您还可以使用SQL <code class="codeph">UPDATE</code>语句修改LOB，将字符数据绑定到<code class="codeph">CLOB</code>列或将<code class="codeph">RAW</code>数据绑定到<code class="codeph">BLOB</code>列。
                        </p>
                        <p>支持插入，更新和选择远程LOB（通过dblink），因为远程服务器和本地服务器都不是Oracle Database <span class="italic">10g</span>第2版之前的版本。数据接口仅支持最大2 GB -1的数据大小，即<code class="codeph">sb4</code>数据类型的最大大小。
                        </p>
                     </li>
                     <li>
                        <p><span>使用LOB定位器</span></p>
                        <p>您可以通过使用<code class="codeph">OCIDescriptorAlloc()</code>初始化新的LOB定位器，调用<code class="codeph">OCIAttrSet()</code>将其设置为空（使用<code class="codeph">OCI_ATTR_LOBEMPTY</code>属性），然后将定位器绑定到<code class="codeph">INSERT</code>语句中的占位符来创建新的内部LOB。这样做会将空定位器插入到具有LOB列或属性的表中。然后，您可以执行<code class="codeph">SELECT</code> ...对此行进行<code class="codeph">FOR</code> <code class="codeph">UPDATE</code>操作以获取定位器，并使用其中一个OCI LOB函数对其进行写入。
                        </p>
                        <div class="infoboxnote" id="GUID-301C3875-9A32-4C37-A4A6-4FCF705EF1B2__GUID-3943ECBE-1CE2-4970-A226-C8CDB59AA7A3">
                           <p class="notep1">注意：</p>
                           <p>要修改LOB列或属性（写入，复制，修剪等），必须锁定包含LOB的行。一种方法是使用<code class="codeph">SELECT...FOR UPDATE</code>语句在执行操作之前选择定位器。
                           </p>
                        </div>
                     </li>
                  </ul>
                  <p>要使任何LOB写入命令成功，必须打开一个事务。如果在写入数据之前提交事务，则必须再次锁定该行（通过重新发出<code class="codeph">SELECT...例如， FOR UPDATE</code>语句，因为提交关闭了事务。
                  </p>
                  <div class="infoboxnotealso" id="GUID-301C3875-9A32-4C37-A4A6-4FCF705EF1B2__GUID-C4389A93-0A54-4153-83C9-5BE4B1A74226">
                     <p class="notep1">也可以看看：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="../adlob/data-interface-for-persistent-LOBs.html#ADLOB1300" target="_blank"><span><cite>Oracle Database SecureFiles和Large Objects Developer's Guide</cite></span></a>章节关于持久LOB的数据接口，以获取更多信息和示例</p>
                        </li>
                        <li>
                           <p><a href="binding-and-defining-in-oci.html#GUID-D757C946-BCDA-4A32-867B-BE951BA9BBF4" title="Oracle数据库允许对任何大小的LOB的INSERT和UPDATE进行非零绑定。">关于绑定LOB数据</a>以及<code class="codeph">INSERT</code>和<code class="codeph">UPDATE</code>示例</p>
                        </li>
                        <li>
                           <p><a href="handle-and-descriptor-functions.html#GUID-E9EF2766-E078-49A7-B1D1-738E4BA4814F" title="分配存储以保存描述符或LOB定位符。">OCIDescriptorAlloc（）</a></p>
                        </li>
                        <li>
                           <p><a href="handle-and-descriptor-functions.html#GUID-3741D7BD-7652-4D7A-8813-AC2AEA8D3B03" title="设置句柄或描述符的属性值。">OCIAttrSet（）</a></p>
                        </li>
                     </ul>
                  </div>
               </div>
            </div><a id="LNOCI16501"></a><div class="props_rev_3"><a id="GUID-C416EA63-3DFE-4778-8163-8EFDEA1F8503" name="GUID-C416EA63-3DFE-4778-8163-8EFDEA1F8503"></a><h3 id="LNOCI-GUID-C416EA63-3DFE-4778-8163-8EFDEA1F8503" class="sect3"><span class="enumeration_section">9.3</span>关于将表中的BFILE与操作系统文件关联</h3>
               <div>
                  <p>可以在<code class="codeph">INSERT</code>语句中使用<code class="codeph">BFILENAME</code>函数将外部服务器端（操作系统）文件与表中的<code class="codeph">BFILE</code>列或属性相关联。
                  </p>
                  <p>在<code class="codeph">UPDATE</code>语句中使用<code class="codeph">BFILENAME</code>将<code class="codeph">BFILE</code>列或属性与不同的操作系统文件相关联。<code class="codeph">OCILobFileSetName()</code>还可用于将表中的<code class="codeph">BFILE</code>与操作系统文件相关联。<code class="codeph">BFILENAME</code>通常在没有绑定变量的<code class="codeph">INSERT</code>或<code class="codeph">UPDATE</code>语句中使用， <code class="codeph">OCILobFileSetName()</code>用于绑定变量。
                  </p>
                  <div class="infoboxnotealso" id="GUID-C416EA63-3DFE-4778-8163-8EFDEA1F8503__GUID-4311FD20-8A1A-4E5B-9589-8C1024FCC871">
                     <p class="notep1">也可以看看：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="lob-functions.html#GUID-507AC0EF-4CAB-437E-BB94-1FD77EDC1B5C" title="在BFILE定位器中设置目录对象和文件名。">OCILobFileSetName（）</a> 
                           </p>
                        </li>
                        <li>
                           <p>有关<code class="codeph">BFILENAME</code>函数的更多信息，请<code class="codeph">BFILENAME</code> <a href="../adlob/working-with-LOBs.html#ADLOB45143" target="_blank"><span><cite>Oracle Database SecureFiles和Large Objects Developer's Guide</cite></span></a></p>
                        </li>
                     </ul>
                  </div>
               </div>
            </div><a id="LNOCI16502"></a><div class="props_rev_3"><a id="GUID-4622680F-D454-4DFE-8300-E74E74E39DBA" name="GUID-4622680F-D454-4DFE-8300-E74E74E39DBA"></a><h3 id="LNOCI-GUID-4622680F-D454-4DFE-8300-E74E74E39DBA" class="sect3"><span class="enumeration_section">9.4</span>对象的LOB属性</h3>
               <div>
                  <p>OCI应用程序可以使用<code class="codeph">OCIObjectNew()</code>函数创建具有LOB属性的持久或临时对象。
                  </p>
                  <div class="p">本节包括以下主题：<ul style="list-style-type:disc">
                        <li>
                           <p><a href="lobs-and-bfile-operations.html#GUID-DF80FECE-7F0A-46C7-B89B-EA2FB04358E5" title="可以使用OCI创建具有LOB属性的新持久对象并写入该LOB属性。">写入对象的LOB属性</a></p>
                        </li>
                        <li>
                           <p><a href="lobs-and-bfile-operations.html#GUID-B3E83C32-6E92-4E04-A381-BD738B064901" title="应用程序可以调用OCIObjectNew（）并创建具有内部LOB（BLOB，CLOB，NCLOB）属性的瞬态对象。">具有LOB属性的瞬态对象</a></p>
                        </li>
                     </ul>
                  </div>
                  <div class="infoboxnotealso" id="GUID-4622680F-D454-4DFE-8300-E74E74E39DBA__GUID-F1B102F3-9FA4-49C4-82E0-CD2A3E51DC78">
                     <p class="notep1">也可以看看：</p>
                     <p><a href="oci-miscellaneous-object-functions.html#GUID-2EFD6F01-A02F-4C5B-B20F-1EF841249056" title="创建独立实例。">OCIObjectNew（）</a></p>
                  </div>
               </div><a id="LNOCI16503"></a><div class="props_rev_3"><a id="GUID-DF80FECE-7F0A-46C7-B89B-EA2FB04358E5" name="GUID-DF80FECE-7F0A-46C7-B89B-EA2FB04358E5"></a><h4 id="LNOCI-GUID-DF80FECE-7F0A-46C7-B89B-EA2FB04358E5" class="sect4"><span class="enumeration_section">9.4.1</span>写入对象的LOB属性</h4>
                  <div>
                     <p>可以使用OCI创建具有LOB属性的新持久对象并写入该LOB属性。</p>
                     <div class="section">
                        <p>使用<span class="italic">LOB定位器</span>时，应用程序将遵循以下步骤：</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>调用<code class="codeph">OCIObjectNew()</code>以创建具有LOB属性的持久对象。</span></li>
                        <li class="stepexpand"><span>将对象标记为“脏”（已修改）。</span></li>
                        <li class="stepexpand"><span>刷新对象，从而在表中插入一行。</span></li>
                        <li class="stepexpand"><span>复制对象的最新版本（或刷新对象），从而从数据库中检索对象并获取LOB的有效定位器。</span></li>
                        <li class="stepexpand"><span>使用对象中的LOB定位符调用<code class="codeph">OCIObjectWrite2()</code>来写入数据。</span><div></div>
                        </li>
                     </ol>
                     <div class="section">
                        <p>还有第二种写入LOB属性的方法。使用<span class="italic">数据接口时</span> ，可以为<code class="codeph">BLOB</code>属性绑定或定义<code class="codeph">CLOB</code>属性或<code class="codeph">RAW</code>数据的字符数据。
                        </p>
                        <div class="infoboxnotealso" id="GUID-DF80FECE-7F0A-46C7-B89B-EA2FB04358E5__GUID-E78FCF32-F9DD-4449-8BE6-6DC048CD645B">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><a href="oci-object-relational-programming.html#GUID-8A9E9784-9D10-40B1-ADE9-4CE9325255E5" title="This chapter introduces the OCI facility for working with objects in an Oracle database. It also discusses the object navigational function calls of OCI.">OCI对象关系编程</a>及其<a href="oci-object-relational-programming.html#GUID-8A9E9784-9D10-40B1-ADE9-4CE9325255E5" title="本章介绍用于在Oracle数据库中处理对象的OCI工具。它还讨论了OCI的对象导航函数调用。">后面</a>的章节，以获取有关对象的更多信息</p>
                              </li>
                              <li>
                                 <p><a href="binding-and-defining-in-oci.html#GUID-D757C946-BCDA-4A32-867B-BE951BA9BBF4" title="Oracle数据库允许对任何大小的LOB的INSERT和UPDATE进行非零绑定。">关于绑定LOB数据</a>以及<code class="codeph">INSERT</code>和<code class="codeph">UPDATE statements</code>示例</p>
                              </li>
                              <li>
                                 <p><a href="binding-and-defining-in-oci.html#GUID-FE7DB3D8-9310-41ED-8869-B5106E60D29E">关于定义LOB数据</a>以了解<code class="codeph">SELECT</code>语句的用法和示例</p>
                              </li>
                              <li>
                                 <p><a href="oci-miscellaneous-object-functions.html#GUID-2EFD6F01-A02F-4C5B-B20F-1EF841249056" title="创建独立实例。">OCIObjectNew（）</a></p>
                              </li>
                              <li>
                                 <p><a href="lob-functions.html#GUID-77F056CA-9EEE-4550-8A8E-0155DF994DBE" title="将缓冲区写入LOB。此函数必须用于大小超过4 GB的LOB。">OCILobWrite2（）</a></p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNOCI16504"></a><div class="props_rev_3"><a id="GUID-B3E83C32-6E92-4E04-A381-BD738B064901" name="GUID-B3E83C32-6E92-4E04-A381-BD738B064901"></a><h4 id="LNOCI-GUID-B3E83C32-6E92-4E04-A381-BD738B064901" class="sect4"><span class="enumeration_section">9.4.2</span>具有LOB属性的瞬态对象</h4>
                  <div>
                     <p>应用程序可以调用<code class="codeph">OCIObjectNew()</code>并创建具有内部LOB（ <code class="codeph">BLOB</code> ， <code class="codeph">CLOB</code> ， <code class="codeph">NCLOB</code> ）属性的瞬态对象。
                     </p>
                     <p>但是，您无法对LOB属性执行任何操作（如读取或写入），因为不支持具有LOB属性的临时对象。调用<code class="codeph">OCIObjectNew()</code>来创建瞬态内部LOB类型不会失败，但应用程序不能对瞬态LOB使用任何LOB操作。</p>
                     <p>应用程序可以，但是，创建一个临时对象<code class="codeph">BFILE</code>属性和使用<code class="codeph">BFILE</code>属性从存储在服务器的文件系统中的文件中读取数据。应用程序还可以调用<code class="codeph">OCIObjectNew()</code>来创建瞬态<code class="codeph">BFILE</code> 。</p>
                     <div class="infoboxnotealso" id="GUID-B3E83C32-6E92-4E04-A381-BD738B064901__GUID-A88A569E-54CB-4E55-95F0-5371AC542FC0">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="oci-miscellaneous-object-functions.html#GUID-2EFD6F01-A02F-4C5B-B20F-1EF841249056" title="创建独立实例。">OCIObjectNew（）</a></p>
                     </div>
                  </div>
               </div>
            </div><a id="LNOCI16505"></a><div class="props_rev_3"><a id="GUID-93695EB3-E9D2-4F2B-B027-2D9AD99B586D" name="GUID-93695EB3-E9D2-4F2B-B027-2D9AD99B586D"></a><h3 id="LNOCI-GUID-93695EB3-E9D2-4F2B-B027-2D9AD99B586D" class="sect3"><span class="enumeration_section">9.5</span> LOB的阵列接口</h3>
               <div>
                  <p>您可以将OCI阵列接口与LOB一起使用，就像使用任何其他数据类型一样。</p>
                  <p>有两种使用阵列接口的方法。</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><span>使用数据接口</span></p>
                        <p>您可以绑定或定义<code class="codeph">CLOB</code>列的字符数据数组或<code class="codeph">BLOB</code>列的<code class="codeph">RAW</code>数据。您可以使用数组绑定和定义接口来插入和选择多个行，其中LOB <span class="italic">一次往返</span>服务器。
                        </p>
                     </li>
                     <li>
                        <p><span>使用LOB定位器</span></p>
                        <p>使用LOB定位器时，必须分配描述符，如以下代码示例所示。</p>
                        <p>使用LOB定位器和分配描述符</p><pre class="oac_no_warn" dir="ltr">/ *首先创建一个OCILobLocator指针数组：* / OCILobLocator * lobp [10]; for（i = 0; i &lt;10; i ++）{OCIDescriptorAlloc（...，＆lobp [i]，...）; / *然后绑定描述符如下* / OCIBindByPos（...＆lobp [i]，...）;</pre></li>
                  </ul>
                  <div class="infoboxnotealso" id="GUID-93695EB3-E9D2-4F2B-B027-2D9AD99B586D__GUID-1CA332F0-0381-4847-B209-C6ADA9394448">
                     <p class="notep1">也可以看看：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="binding-and-defining-in-oci.html#GUID-D757C946-BCDA-4A32-867B-BE951BA9BBF4" title="Oracle数据库允许对任何大小的LOB的INSERT和UPDATE进行非零绑定。">关于绑定LOB数据</a>以及<code class="codeph">INSERT</code>和<code class="codeph">UPDATE statements</code>示例</p>
                        </li>
                        <li>
                           <p><a href="binding-and-defining-in-oci.html#GUID-FE7DB3D8-9310-41ED-8869-B5106E60D29E">关于定义LOB数据</a>以了解<code class="codeph">SELECT</code>语句的用法和示例</p>
                        </li>
                     </ul>
                  </div>
               </div>
            </div><a id="LNOCI16506"></a><div class="props_rev_3"><a id="GUID-EC49588A-0534-4E43-8CB1-3D0FAE205BAB" name="GUID-EC49588A-0534-4E43-8CB1-3D0FAE205BAB"></a><h3 id="LNOCI-GUID-EC49588A-0534-4E43-8CB1-3D0FAE205BAB" class="sect3"><span class="enumeration_section">9.6</span>关于使用大小超过4 GB的LOB</h3>
               <div>
                  <p>从OCI的Oracle数据库<span class="italic">10g</span>第1版开始，引入了一些函数来支持大小超过4 GB的LOB。这些新功能也可用于少于4 GB的LOB的新应用程序。</p>
                  <p>Oracle Database使您可以创建块大小与数据库块大小不同的表空间。LOB的最大大小取决于表空间块的大小。存储LOB的表空间块大小控制<code class="codeph">CHUNK</code>的值， <code class="codeph">CHUNK</code>是LOB存储的参数。创建LOB列时，为<code class="codeph">CHUNK</code>指定一个值，这是为LOB操作分配的字节数。该值必须是表空间块大小的倍数，或Oracle数据库向上舍入到下一个倍数。（如果表空间块大小等于数据库块大小，则<code class="codeph">CHUNK</code>也是数据库块大小的倍数。）默认的<code class="codeph">CHUNK</code>大小是一个表空间块，最大值为32 KB。</p>
                  <p>在本指南中，4 GB定义为4千兆字节 -  1或4,294,967,295字节。LOB的最大大小（持久或临时）是（4千兆字节-1）*（ <code class="codeph">CHUNK</code> ）。最大LOB大小可以从8 TB到128 TB。</p>
                  <p>例如，假设您的数据库块大小为32 KB，并且您创建了一个非标准块大小为8 KB的表空间。进一步假设您创建一个包含LOB列的表，并指定<code class="codeph">CHUNK</code>大小为16 KB（这是8 KB表空间块大小的倍数）。然后，此列中LOB的最大大小为（4千兆字节-1）* 16 KB。</p>
                  <p><code class="codeph">BFILE</code>的最大大小是操作系统中允许的最大文件大小，或<code class="codeph">UB8MAXVAL</code> ，以较小者为准。
                  </p>
                  <p>较旧的LOB函数使用<code class="codeph">ub4</code>作为某些参数的数据类型，而<code class="codeph">ub4</code>数据类型最多只能容纳4 GB。较新的函数使用8字节长度的参数<code class="codeph">oraub8</code> ，它是<code class="codeph">oratypes.h</code>定义的数据类型。根据编译器和操作系统，数据类型<code class="codeph">oraub8</code>和<code class="codeph">orasb8</code>映射到适当的64位本机数据类型。如果使用严格的ANSI选项在32位模式下编译，则宏用于不定义<code class="codeph">oraub8</code>和<code class="codeph">orasb8</code> 。
                  </p>
                  <p> <code class="codeph">OCILobGetChunkSize()</code>返回<code class="codeph">BLOB</code> ， <code class="codeph">CLOB</code>和<code class="codeph">NCLOB</code>的可用块大小（以字节为单位）。由于内部存储开销，存储在块中的字节数实际上小于<code class="codeph">CHUNK</code>参数的大小。提供函数<code class="codeph">OCILobGetStorageLimit()</code>以返回当前安装中内部LOB的最大大小（以字节为单位）。
                  </p>
                  <div class="infoboxnote" id="GUID-EC49588A-0534-4E43-8CB1-3D0FAE205BAB__GUID-847EF166-6894-46AE-A4B2-D1BC378D7686">
                     <p class="notep1">注意：</p>
                     <p>在任何编程环境中，Oracle数据库都不支持大于4千兆字节的<code class="codeph">BFILE</code> 。操作系统强加的额外文件大小限制也适用于<code class="codeph">BFILE</code> 。
                     </p>
                  </div>
                  <div class="p">本节包括以下主题：<ul style="list-style-type:disc">
                        <li>
                           <p><a href="lobs-and-bfile-operations.html#GUID-4B5035F2-104E-4368-B603-09E069ED4544" title="名称以结尾的八个函数" data="" type="" ="=" ="">用于增加LOB大小的函数</a></p>
                        </li>
                        <li>
                           <p><a href="lobs-and-bfile-operations.html#GUID-24301AFA-3446-46A0-AA27-2C7E223E0D39" title="可以增强现有OCI程序以处理大于4 GB的大量LOB数据。">兼容性和迁移</a></p>
                        </li>
                        <li>
                           <p><a href="lob-functions.html#GUID-ABB71585-172E-4F3E-A0CF-F70D709F2072" title="获取LOB的块大小。">OCILobGetChunkSize（）</a></p>
                        </li>
                        <li>
                           <p><a href="lob-functions.html#GUID-0CBDB3C7-8A27-4A82-8C46-698B83C45A27" title="获取内部LOB（BLOB，CLOB或NCLOB）的最大长度（以字节为单位）。">OCILobGetStorageLimit（）</a></p>
                        </li>
                     </ul>
                  </div>
               </div><a id="LNOCI16507"></a><div class="props_rev_3"><a id="GUID-4B5035F2-104E-4368-B603-09E069ED4544" name="GUID-4B5035F2-104E-4368-B603-09E069ED4544"></a><h4 id="LNOCI-GUID-4B5035F2-104E-4368-B603-09E069ED4544" class="sect4"><span class="enumeration_section">9.6.1</span>用于增加LOB大小的函数</h4>
                  <div>
                     <p>在Oracle数据库<span class="italic">10g</span>第1版中引入了8个名称以“2”结尾并使用数据类型<code class="codeph">oraub8</code>代替数据类型<code class="codeph">ub4</code> 。
                     </p>
                     <p>在读取和写入函数（ <code class="codeph">OCILobRead2()</code> ， <code class="codeph">OCILobWrite2()</code>和<code class="codeph">OCILobWriteAppend2()</code> ）中进行了其他更改以解决几个问题：</p>
                     <p>问题：在Oracle Database <span class="italic">10g</span>第1版之前，参数<code class="codeph">amtp</code>根据定位器类型和字符集假定LOB的字节或字符长度。它很复杂，用户根据自己的要求无法灵活地使用字节长度或字符长度。
                     </p>
                     <p>解决方法：读/写调用应采取既<code class="codeph">byte_amtp</code>和<code class="codeph">char_amtp</code>参数替换为<code class="codeph">amtp</code>参数。<code class="codeph">char_amtp</code>参数是<code class="codeph">CLOB</code>和<code class="codeph">NCLOB</code>的<code class="codeph">byte_amtp</code>参数，如果<code class="codeph">char_amtp</code>为零，则<code class="codeph">byte_amtp</code>参数仅被视为输入。在输出<code class="codeph">CLOB</code>和<code class="codeph">NCLOB</code> ，将填充<code class="codeph">byte_amtp</code>和<code class="codeph">char_amtp</code>参数。对于<code class="codeph">BLOB</code>和<code class="codeph">BFILE</code> ，输入和输出都会忽略<code class="codeph">char_ampt</code>参数。
                     </p>
                     <p>问题：对于<code class="codeph">OCILobRead2()</code> ，没有标志指示轮询模式。用户没有简单的方法说“我有一个100字节的缓冲区。尽可能多地填写。“以前，他们必须估计要为金额指定的字符数。如果他们猜得太多，就会无意中被迫进入投票模式。因此，用户代码可能陷入轮询模式，并且后续的OCI调用都被阻止。
                     </p>
                     <p>解决方案：此调用应将<code class="codeph">piece</code>作为输入参数，如果传递<code class="codeph">OCI_ONE_PIECE</code> ，它应尽可能地填充缓冲区，并且即使<code class="codeph">byte_amtp</code>参数或<code class="codeph">char_amtp</code>参数指示的<code class="codeph">byte_amtp</code>于缓冲区长度<code class="codeph">char_amtp</code> 。<code class="codeph">bufl</code>的值用于指定要读取的最大字节数。
                     </p>
                     <p>问题：在轮询模式下调用LOB写入后，用户不知道在轮询结束之前实际获取了多少个字符或字节。</p>
                     <p>解决方案：在轮询模式下每次调用后，必须更新<code class="codeph">byte_amtp</code>和<code class="codeph">char_amtp</code>参数。
                     </p>
                     <p>问题：在使用回调的流模式下读取或写入数据时，用户必须为每个数据使用相同的缓冲区。</p>
                     <p>解决方案：回调函数必须有两个新参数来提供缓冲区和缓冲区长度。回调函数可以将buffer参数设置为<code class="codeph">NULL</code>以遵循旧行为：使用第一次调用中传递的默认缓冲区来处理所有部分。
                     </p>
                     <div class="infoboxnotealso" id="GUID-4B5035F2-104E-4368-B603-09E069ED4544__GUID-C216CCF5-9AE5-4FCD-902A-302BC69FABB6">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="lob-functions.html#GUID-699FFE4B-07C8-4904-959F-3686E73B8188" title="启动临时LOB的用户持续时间。终止临时LOB的用户持续时间。在指定的另一个LOB的末尾添加LOB值。在一次往返中读取多个定位器的LOB数据。将一个LOB或BFILE定位符分配给另一个获取LOB定位符的字符集形式（如果有）。获取LOB定位符的LOB定位符的数据库字符集ID（如果有）。关闭先前打开的LOB或BFILE.Copies全部或部分LOB值到另一个LOB值。创建临时LOB。从指定的偏移量开始删除内部LOB数据的指定部分。关闭先前打开的BFILE。关闭给定服务上下文中的所有打开的BFILE。测试服务器操作系统上是否存在BFILE。获取BFILE定位符的目录对象和文件名。测试BFILE是否打开。在服务器的文件系统上打开BFILE以进行只读访问。在BFILE定位器中设置目录对象和文件名。释放临时LOB。获取LOB的块大小。获取SecureFile中数据的用户指定内容类型字符串（如果已设置）。获取LOB的长度。此函数必须用于大小超过4 GB的LOB。为给定的SecureFile LOB创建与给定输入选项类型对应的已启用设置。获取内部LOB（BLOB，CLOB或NCLOB）的最大长度（以字节为单位）。比较两个LOB或BFILE定位器是否相等。测试LOB或BFILE是否打开。测试定位器是否指向临时LOB.Loads并将文件的全部或部分复制到内部LOB中。此函数必须用于大小超过4 GB的LOB。将一个LOB或BFILE定位器分配给另一个。测试是否初始化给定的LOB或BFILE定位器。以指示的模式打开内部或外部LOB。将调用所指定的LOB或BFILE的一部分读入缓冲区。此函数必须用于大小超过4 GB的LOB。将SecureFile中数据的内容类型字符串设置为应用程序可以使用的内容。启用SecureFile LOB的选项设置。将LOB值调整为较短的长度。此函数必须用于大小超过4 GB的LOB。将缓冲区写入LOB。此函数必须用于大小超过4 GB的LOB。从LOB结尾开始写入数据。此函数必须用于大小超过4 GB的LOB。">LOB功能</a></p>
                           </li>
                           <li>
                              <p><a href="lob-functions.html#GUID-6AC6E6DA-236B-4BF9-942F-9FCC4178FEDA" title="将调用所指定的LOB或BFILE的一部分读入缓冲区。此函数必须用于大小超过4 GB的LOB。">OCILobRead2（）</a></p>
                           </li>
                           <li>
                              <p><a href="lob-functions.html#GUID-77F056CA-9EEE-4550-8A8E-0155DF994DBE" title="将缓冲区写入LOB。此函数必须用于大小超过4 GB的LOB。">OCILobWrite2（）</a></p>
                           </li>
                           <li>
                              <p><a href="lob-functions.html#GUID-87D3275A-B042-4991-B261-AB531BB83CA2" title="从LOB结尾开始写入数据。此函数必须用于大小超过4 GB的LOB。">OCILobWriteAppend2（）</a></p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="LNOCI16509"></a><a id="LNOCI16508"></a><div class="props_rev_3"><a id="GUID-24301AFA-3446-46A0-AA27-2C7E223E0D39" name="GUID-24301AFA-3446-46A0-AA27-2C7E223E0D39"></a><h4 id="LNOCI-GUID-24301AFA-3446-46A0-AA27-2C7E223E0D39" class="sect4"><span class="enumeration_section">9.6.2</span>兼容性和迁移</h4>
                  <div>
                     <p>可以增强现有OCI程序以处理大于4 GB的大量LOB数据。</p>
                     <div class="section">
                        <p><a href="lobs-and-bfile-operations.html#GUID-24301AFA-3446-46A0-AA27-2C7E223E0D39__G446324" title="该表有4列。第1列是LOB函数名，第2列是旧客户端/新服务器或旧服务器。第3列是新客户端/旧服务器，第4列是新客户端/新服务器。">表9-1</a>总结了此表中的兼容性问题，“old”表示Oracle Database <span class="italic">10g</span>第1版之前的版本，NA表示不适用。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="tblformalwide" id="GUID-24301AFA-3446-46A0-AA27-2C7E223E0D39__G446324">
                        <p class="titleintable">表9-1 LOB功能兼容性和迁移</p>
                        <table cellpadding="4" cellspacing="0" class="FormalWide" title="LOB功能兼容性和迁移" width="100%" border="1" summary="This table has 4 columns. Column 1 is the LOB function name, column 2 is old client/new or old server. column 3 is new client/old server, and column 4 is new client/new server." frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="29%" id="d100201e3118">LOB功能</th>
                                 <th align="left" valign="bottom" width="25%" id="d100201e3121">旧客户端/新旧服务器（1）</th>
                                 <th align="left" valign="bottom" width="24%" id="d100201e3127">新客户端/旧服务器</th>
                                 <th align="left" valign="bottom" width="23%" id="d100201e3130">新客户端/新服务器</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d100201e3135" headers="d100201e3118 ">
                                    <p><a href="lob-functions.html#GUID-47652C79-0635-4595-A34B-CD03B7F81A9F" title="在一次往返中读取多个定位器的LOB数据。">OCILobArrayRead（）</a></p>
                                 </td>
                                 <td align="left" valign="top" width="25%" headers="d100201e3135 d100201e3121 ">
                                    <p><a id="fn_2" name="fn_2" href="#fn_2" na="" means="" not="" applicable=")" ="" onclick="footdisplay(2, "><sup>脚2</sup></a> NA</p>
                                 </td>
                                 <td align="left" valign="top" width="24%" headers="d100201e3135 d100201e3127 ">
                                    <p>确定，直到件尺寸和偏移量&lt;4 GB。</p>
                                 </td>
                                 <td align="left" valign="top" width="23%" headers="d100201e3135 d100201e3130 ">
                                    <p>好</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d100201e3156" headers="d100201e3118 ">
                                    <p><a href="lob-functions.html#GUID-10AB60C9-13FE-4CC9-9C62-CAD45DBB3B93">OCILobArrayWrite（）</a></p>
                                 </td>
                                 <td align="left" valign="top" width="25%" headers="d100201e3156 d100201e3121 ">
                                    <p>NA</p>
                                 </td>
                                 <td align="left" valign="top" width="24%" headers="d100201e3156 d100201e3127 ">
                                    <p>确定，直到件尺寸和偏移量&lt;4 GB。</p>
                                 </td>
                                 <td align="left" valign="top" width="23%" headers="d100201e3156 d100201e3130 ">
                                    <p>好</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d100201e3171" headers="d100201e3118 ">
                                    <p><a href="lob-functions.html#GUID-404C8A50-516F-4DFD-939D-646A232AF7DF" title="将全部或部分LOB值复制到另一个LOB值。">OCILobCopy2（）</a></p>
                                 </td>
                                 <td align="left" valign="top" width="25%" headers="d100201e3171 d100201e3121 ">
                                    <p>NA</p>
                                 </td>
                                 <td align="left" valign="top" width="24%" headers="d100201e3171 d100201e3127 ">
                                    <p>确定，直到LOB大小，件大小（数量）和偏移量&lt;4 GB。</p>
                                 </td>
                                 <td align="left" valign="top" width="23%" headers="d100201e3171 d100201e3130 ">
                                    <p>好</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d100201e3189" headers="d100201e3118 ">
                                    <p><a href="deprecated-oci-functions.html#GUID-2E89A469-397B-45BD-871B-4A7E7A5815C1" title="在Oracle Database 11g第2版（11.2）之前的版本中不推荐使用此功能。">OCILobCopy（）</a></p>
                                 </td>
                                 <td align="left" valign="top" width="25%" headers="d100201e3189 d100201e3121 ">
                                    <p>好;限制是4 GB。</p>
                                 </td>
                                 <td align="left" valign="top" width="24%" headers="d100201e3189 d100201e3127 ">
                                    <p>好</p>
                                 </td>
                                 <td align="left" valign="top" width="23%" headers="d100201e3189 d100201e3130 ">
                                    <p>好;限制是4 GB。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d100201e3210" headers="d100201e3118 ">
                                    <p><a href="lob-functions.html#GUID-264797B2-B3EA-4F6D-9A0E-BF8A4DDA13FA" title="从指定的偏移量开始擦除内部LOB数据的指定部分。">OCILobErase2（）</a></p>
                                 </td>
                                 <td align="left" valign="top" width="25%" headers="d100201e3210 d100201e3121 ">
                                    <p>NA</p>
                                 </td>
                                 <td align="left" valign="top" width="24%" headers="d100201e3210 d100201e3127 ">
                                    <p>确定，直到件尺寸和偏移量&lt;4 GB。</p>
                                 </td>
                                 <td align="left" valign="top" width="23%" headers="d100201e3210 d100201e3130 ">
                                    <p>好</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d100201e3228" headers="d100201e3118 ">
                                    <p><a href="deprecated-oci-functions.html#GUID-FD529B73-7D7B-4F93-BB01-4A4625503C36" title="在Oracle Database 11g第2版（11.2）之前的版本中不推荐使用此功能。">OCILobErase（）</a></p>
                                 </td>
                                 <td align="left" valign="top" width="25%" headers="d100201e3228 d100201e3121 ">
                                    <p>好;限制是4 GB。</p>
                                 </td>
                                 <td align="left" valign="top" width="24%" headers="d100201e3228 d100201e3127 ">
                                    <p>好</p>
                                 </td>
                                 <td align="left" valign="top" width="23%" headers="d100201e3228 d100201e3130 ">
                                    <p>好;限制是4 GB。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d100201e3249" headers="d100201e3118 ">
                                    <p><a href="lob-functions.html#GUID-9BC0A78A-37CB-432F-AE2B-22C905608C4C" title="获取LOB的长度。此函数必须用于大小超过4 GB的LOB。">OCILobGetLength2（）</a></p>
                                 </td>
                                 <td align="left" valign="top" width="25%" headers="d100201e3249 d100201e3121 ">
                                    <p>NA</p>
                                 </td>
                                 <td align="left" valign="top" width="24%" headers="d100201e3249 d100201e3127 ">
                                    <p>好</p>
                                 </td>
                                 <td align="left" valign="top" width="23%" headers="d100201e3249 d100201e3130 ">
                                    <p>好</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d100201e3267" headers="d100201e3118 ">
                                    <p><a href="deprecated-oci-functions.html#GUID-3CEE9E79-A7E5-4078-949B-BD0ED3FB4124" title="在Oracle Database 11g第2版（11.2）之前的版本中不推荐使用此功能。">OCILobGetLength（）</a></p>
                                 </td>
                                 <td align="left" valign="top" width="25%" headers="d100201e3267 d100201e3121 ">
                                    <p>好;限制是4 GB。</p>
                                 </td>
                                 <td align="left" valign="top" width="24%" headers="d100201e3267 d100201e3127 ">
                                    <p>好</p>
                                 </td>
                                 <td align="left" valign="top" width="23%" headers="d100201e3267 d100201e3130 ">
                                    <p>好;如果LOB大小&gt; 4 GB， <code class="codeph">OCI_ERROR</code> 。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d100201e3291" headers="d100201e3118 ">
                                    <p><a href="lob-functions.html#GUID-DA1CD18B-7044-4E40-B1F4-4FCC1FCAB6C4" title="将全部或部分文件加载并复制到内部LOB中。此函数必须用于大小超过4 GB的LOB。">OCILobLoadFromFile2（）</a></p>
                                 </td>
                                 <td align="left" valign="top" width="25%" headers="d100201e3291 d100201e3121 ">
                                    <p>NA</p>
                                 </td>
                                 <td align="left" valign="top" width="24%" headers="d100201e3291 d100201e3127 ">
                                    <p>确定，直到LOB大小，块大小（数量）和偏移量&lt;4 GB。</p>
                                 </td>
                                 <td align="left" valign="top" width="23%" headers="d100201e3291 d100201e3130 ">
                                    <p>好</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d100201e3309" headers="d100201e3118 ">
                                    <p><a href="deprecated-oci-functions.html#GUID-87C6AE88-5E71-4D89-A2B8-B391BFF73AC6" title="在Oracle Database 11g第2版（11.2）之前的版本中不推荐使用此功能。">OCILobLoadFromFile（）</a></p>
                                 </td>
                                 <td align="left" valign="top" width="25%" headers="d100201e3309 d100201e3121 ">
                                    <p>好;限制是4 GB。</p>
                                 </td>
                                 <td align="left" valign="top" width="24%" headers="d100201e3309 d100201e3127 ">
                                    <p>好</p>
                                 </td>
                                 <td align="left" valign="top" width="23%" headers="d100201e3309 d100201e3130 ">
                                    <p>好;限制是4 GB。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d100201e3330" headers="d100201e3118 ">
                                    <p><a href="lob-functions.html#GUID-6AC6E6DA-236B-4BF9-942F-9FCC4178FEDA" title="将调用所指定的LOB或BFILE的一部分读入缓冲区。此函数必须用于大小超过4 GB的LOB。">OCILobRead2（）</a></p>
                                 </td>
                                 <td align="left" valign="top" width="25%" headers="d100201e3330 d100201e3121 ">
                                    <p>NA</p>
                                 </td>
                                 <td align="left" valign="top" width="24%" headers="d100201e3330 d100201e3127 ">
                                    <p>确定，直到LOB大小，块大小（数量）和偏移量&lt;4 GB。</p>
                                 </td>
                                 <td align="left" valign="top" width="23%" headers="d100201e3330 d100201e3130 ">
                                    <p>好</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d100201e3352" headers="d100201e3118 ">
                                    <p><a href="deprecated-oci-functions.html#GUID-4F904ADC-547E-40CE-8F2F-98C7D7480D03" title="在Oracle Database 11g第2版（11.2）之前的版本中不推荐使用此功能。">OCILobRead（）</a></p>
                                 </td>
                                 <td align="left" valign="top" width="25%" headers="d100201e3352 d100201e3121 ">
                                    <p>好;限制4 GB。</p>
                                    <p>使用新服务器：如果您尝试从任何&lt;4 GB的偏移量读取任何数量&gt; = 4 GB，则返回<code class="codeph">OCI_ERROR</code> 。这是因为当您读取任何数量&gt; = 4 GB时，会导致* amtp中返回值溢出，因此会将其标记为错误。
                                    </p>
                                    <p>注意：</p>
                                    <ul style="list-style-type:disc">
                                       <li>
                                          <p>如果从偏移量读取最多4 GB  -  1，则不会将其标记为错误。</p>
                                       </li>
                                       <li>
                                          <p>当您使用带轮询的流模式时，如果没有尝试使用大小&gt; 4 GB的片段（在这种情况下您可以读取&gt; 4 GB的数据），则不会返回错误。</p>
                                       </li>
                                    </ul>
                                 </td>
                                 <td align="left" valign="top" width="24%" headers="d100201e3352 d100201e3127 ">
                                    <p>好</p>
                                 </td>
                                 <td align="left" valign="top" width="23%" headers="d100201e3352 d100201e3130 ">
                                    <p>好。</p>
                                    <p>如果您尝试从任何&lt;4 GB的偏移量读取&gt; = 4 GB的任何数量，则返回<code class="codeph">OCI_ERROR</code> 。这是因为当您读取任何数量&gt; = 4 GB时，会导致* amtp中返回值溢出，因此会将其标记为错误。
                                    </p>
                                    <p>注意：</p>
                                    <ul style="list-style-type:disc">
                                       <li>
                                          <p>如果从偏移量读取最多4 GB  -  1，则不会将其标记为错误。</p>
                                       </li>
                                       <li>
                                          <p>使用带轮询的流模式时，如果不尝试使用大小&gt; 4 GB的片段，则不会返回错误。</p>
                                       </li>
                                    </ul>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d100201e3400" headers="d100201e3118 ">
                                    <p><a href="lob-functions.html#GUID-ABDB1543-1782-4216-AD80-55FA82CFF733" title="将LOB值截断为较短的长度。此函数必须用于大小超过4 GB的LOB。">OCILobTrim2（）</a></p>
                                 </td>
                                 <td align="left" valign="top" width="25%" headers="d100201e3400 d100201e3121 ">
                                    <p>NA</p>
                                 </td>
                                 <td align="left" valign="top" width="24%" headers="d100201e3400 d100201e3127 ">
                                    <p>好</p>
                                 </td>
                                 <td align="left" valign="top" width="23%" headers="d100201e3400 d100201e3130 ">
                                    <p>好</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d100201e3418" headers="d100201e3118 ">
                                    <p><a href="deprecated-oci-functions.html#GUID-2D1D8F83-040B-4923-9F02-108D1F636B20" title="在Oracle Database 11g第2版（11.2）之前的版本中不推荐使用此功能。">OCILobTrim（）</a></p>
                                 </td>
                                 <td align="left" valign="top" width="25%" headers="d100201e3418 d100201e3121 ">
                                    <p>好;限制4 GB。</p>
                                 </td>
                                 <td align="left" valign="top" width="24%" headers="d100201e3418 d100201e3127 ">
                                    <p>好</p>
                                 </td>
                                 <td align="left" valign="top" width="23%" headers="d100201e3418 d100201e3130 ">
                                    <p>好;限制4 GB。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d100201e3439" headers="d100201e3118 ">
                                    <p><a href="lob-functions.html#GUID-77F056CA-9EEE-4550-8A8E-0155DF994DBE" title="将缓冲区写入LOB。此函数必须用于大小超过4 GB的LOB。">OCILobWrite2（）</a></p>
                                 </td>
                                 <td align="left" valign="top" width="25%" headers="d100201e3439 d100201e3121 ">
                                    <p>NA</p>
                                 </td>
                                 <td align="left" valign="top" width="24%" headers="d100201e3439 d100201e3127 ">
                                    <p>确定，直到LOB大小，件大小（数量）和偏移量&lt;4 GB。</p>
                                 </td>
                                 <td align="left" valign="top" width="23%" headers="d100201e3439 d100201e3130 ">
                                    <p>好</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d100201e3457" headers="d100201e3118 ">
                                    <p><a href="deprecated-oci-functions.html#GUID-CA0A90B9-0BB0-4017-AC53-996A102A7854" title="在Oracle Database 11g第2版（11.2）之前的版本中不推荐使用此功能。">OCILobWrite（）</a></p>
                                 </td>
                                 <td align="left" valign="top" width="25%" headers="d100201e3457 d100201e3121 ">
                                    <p>好;限制4 GB。</p>
                                    <p>使用新服务器：</p>
                                    <p><code class="codeph">OCI_ERROR</code>如果写任何量&gt; = 4 GB（来自任何偏移&lt;4 GB）被返回，因为在返回值的溢出导致的<code class="codeph">*amtp</code> 。
                                    </p>
                                    <p>注意：从最大4 GB -1的任何偏移量更新10 GB的LOB，最多4 GB -1的数据量不会被标记为错误。</p>
                                 </td>
                                 <td align="left" valign="top" width="24%" headers="d100201e3457 d100201e3127 ">
                                    <p>好</p>
                                 </td>
                                 <td align="left" valign="top" width="23%" headers="d100201e3457 d100201e3130 ">
                                    <p>好。</p>
                                    <p><code class="codeph">OCI_ERROR</code>如果写任何量&gt; = 4 GB（来自任何偏移&lt;4 GB）被返回，因为在* amtp返回值的溢出造成的。
                                    </p>
                                    <p>注意：从最大4 GB -1的任何偏移量更新10 GB的LOB，最多4 GB -1的数据量不会被标记为错误。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d100201e3495" headers="d100201e3118 ">
                                    <p><a href="lob-functions.html#GUID-87D3275A-B042-4991-B261-AB531BB83CA2" title="从LOB结尾开始写入数据。此函数必须用于大小超过4 GB的LOB。">OCILobWriteAppend2（）</a></p>
                                 </td>
                                 <td align="left" valign="top" width="25%" headers="d100201e3495 d100201e3121 ">
                                    <p>NA</p>
                                 </td>
                                 <td align="left" valign="top" width="24%" headers="d100201e3495 d100201e3127 ">
                                    <p>OK，直到LOB大小和件大小&lt;4 GB。</p>
                                 </td>
                                 <td align="left" valign="top" width="23%" headers="d100201e3495 d100201e3130 ">
                                    <p>好</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d100201e3513" headers="d100201e3118 ">
                                    <p><a href="deprecated-oci-functions.html#GUID-BC03A84A-5747-414F-9A79-BAAF0EE71EF8" title="在Oracle Database 11g第2版（11.2）之前的版本中不推荐使用此功能。">OCILobWriteAppend（）</a></p>
                                 </td>
                                 <td align="left" valign="top" width="25%" headers="d100201e3513 d100201e3121 ">
                                    <p>好;限制4 GB。</p>
                                    <p>使用新服务器：如果附加任何数量&gt; = 4 GB的数据，则返回<code class="codeph">OCI_ERROR</code> ，因为这会导致<code class="codeph">*amtp</code>中返回值溢出。
                                    </p>
                                 </td>
                                 <td align="left" valign="top" width="24%" headers="d100201e3513 d100201e3127 ">
                                    <p>好</p>
                                 </td>
                                 <td align="left" valign="top" width="23%" headers="d100201e3513 d100201e3130 ">
                                    <p>好;限制4 GB。</p>
                                    <p>如果附加任何数量&gt; = 4 GB的数据，则返回<code class="codeph">OCI_ERROR</code> ，因为这会导致<code class="codeph">*amtp</code>的返回值溢出。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d100201e3549" headers="d100201e3118 ">
                                    <p><a href="lob-functions.html#GUID-0CBDB3C7-8A27-4A82-8C46-698B83C45A27" title="获取内部LOB（BLOB，CLOB或NCLOB）的最大长度（以字节为单位）。">OCILobGetStorageLimit（）</a></p>
                                 </td>
                                 <td align="left" valign="top" width="25%" headers="d100201e3549 d100201e3121 ">
                                    <p>NA</p>
                                 </td>
                                 <td align="left" valign="top" width="24%" headers="d100201e3549 d100201e3127 ">
                                    <p>错误</p>
                                 </td>
                                 <td align="left" valign="top" width="23%" headers="d100201e3549 d100201e3130 ">
                                    <p>好</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <p class="tablefootnote"><sup class="tablefootnote">脚注1</sup>术语“旧”是指Oracle Database 10g第1版之前的版本。
                     </p>
                     <p class="tablefootnote"><sup class="tablefootnote">脚注2</sup></p><p>NA表示不适用。</p>
                     <p></p>
                     <div class="section">
                        <p>使用当前服务器和当前客户端时以“2”结尾的功能。将已弃用的函数与以“2”结尾的函数混合可能会导致意外情况，例如，如果应用程序尝试使用<code class="codeph">OCILobRead()</code>读取数据，则使用<code class="codeph">OCILobWrite2()</code>写入的数据大于4 GB并且仅获取部分数据（如果回调功能未使用）。在大多数情况下，当大小超过4 GB并使用不推荐使用的函数时，应用程序会收到错误消息。但是，如果对大小小于4 GB的LOB使用这些已弃用的函数，则没有问题。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="LNOCI16510"></a><div class="props_rev_3"><a id="GUID-7595F604-B560-4121-8254-57801341B02F" name="GUID-7595F604-B560-4121-8254-57801341B02F"></a><h3 id="LNOCI-GUID-7595F604-B560-4121-8254-57801341B02F" class="sect3"><span class="enumeration_section">9.7</span> OCI中的LOB和BFILE函数</h3>
               <div>
                  <p>在涉及数据偏移的所有LOB操作中，偏移量从1开始。对于LOB操作，例如<code class="codeph">OCILobCopy2()</code> ， <code class="codeph">OCILobErase2()</code> ， <code class="codeph">OCILobLoadFromFile2()</code>和<code class="codeph">OCILobTrim2()</code> ，无论客户端字符集如何， <code class="codeph">amount</code>参数都是<code class="codeph">CLOB</code>和<code class="codeph">NCLOB</code>的字符。
                  </p>
                  <p></p>
                  <p>这些LOB操作指的是服务器上的LOB数据量。当客户端字符集的宽度不同时，以下一般规则适用于LOB调用中的<code class="codeph">amount</code>和<code class="codeph">offset</code>参数：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><code class="codeph">amount</code> - 当amount参数引用服务器端LOB时，金额以字符为单位。当amount参数引用客户端缓冲区时，该数量以字节为单位。
                        </p>
                     </li>
                     <li>
                        <p><code class="codeph">offset</code> - 无论客户端字符集是否为宽度变化，offset参数始终以<code class="codeph">CLOB</code>或<code class="codeph">NCLOB</code>为字符，以<code class="codeph">BLOB</code>或<code class="codeph">BFILE</code>单位。
                        </p>
                     </li>
                  </ul>
                  <p>在特定LOB调用的描述中记录了这些一般规则的例外情况。</p>
                  <div class="p">本节包括以下主题：<ul style="list-style-type:disc">
                        <li>
                           <p><a href="lobs-and-bfile-operations.html#GUID-8C5ABC9E-3048-49AE-BFE3-DB4CB1A63AB3" title="如何提高LOB读/写性能。">关于提高LOB读/写性能</a></p>
                        </li>
                        <li>
                           <p><a href="lobs-and-bfile-operations.html#GUID-A88C554E-5397-477E-BC5D-1675D959D287" title="不推荐使用这些LOB函数。使用LOB预取功能代替这些LOB缓冲功能。">LOB缓冲功能</a></p>
                        </li>
                        <li>
                           <p><a href="lobs-and-bfile-operations.html#GUID-7BFEAAEE-0BF5-4104-844B-0AF8C4C6D6C9" title="OCI提供了显式打开LOB，OCILobOpen（），关闭LOB，OCILobClose（）以及测试LOB是否打开的函数，OCILobIsOpen（）。">打开和关闭LOB的功能</a></p>
                        </li>
                        <li>
                           <p><a href="lobs-and-bfile-operations.html#GUID-FFFD9E4C-03CE-469C-AA47-DFD73C0C9C69" title="OCI支持读写回调函数。">LOB读写回调</a></p>
                        </li>
                     </ul>
                  </div>
                  <div class="infoboxnotealso" id="GUID-7595F604-B560-4121-8254-57801341B02F__GUID-C40EC1D2-A511-487A-8E6D-0483F0549346">
                     <p class="notep1">也可以看看：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="lob-functions.html#GUID-699FFE4B-07C8-4904-959F-3686E73B8188" title="启动临时LOB的用户持续时间。终止临时LOB的用户持续时间。在指定的另一个LOB的末尾添加LOB值。在一次往返中读取多个定位器的LOB数据。将一个LOB或BFILE定位符分配给另一个获取LOB定位符的字符集形式（如果有）。获取LOB定位符的LOB定位符的数据库字符集ID（如果有）。关闭先前打开的LOB或BFILE.Copies全部或部分LOB值到另一个LOB值。创建临时LOB。从指定的偏移量开始删除内部LOB数据的指定部分。关闭先前打开的BFILE。关闭给定服务上下文中的所有打开的BFILE。测试服务器操作系统上是否存在BFILE。获取BFILE定位符的目录对象和文件名。测试BFILE是否打开。在服务器的文件系统上打开BFILE以进行只读访问。在BFILE定位器中设置目录对象和文件名。释放临时LOB。获取LOB的块大小。获取SecureFile中数据的用户指定内容类型字符串（如果已设置）。获取LOB的长度。此函数必须用于大小超过4 GB的LOB。为给定的SecureFile LOB创建与给定输入选项类型对应的已启用设置。获取内部LOB（BLOB，CLOB或NCLOB）的最大长度（以字节为单位）。比较两个LOB或BFILE定位器是否相等。测试LOB或BFILE是否打开。测试定位器是否指向临时LOB.Loads并将文件的全部或部分复制到内部LOB中。此函数必须用于大小超过4 GB的LOB。将一个LOB或BFILE定位器分配给另一个。测试是否初始化给定的LOB或BFILE定位器。以指示的模式打开内部或外部LOB。将调用所指定的LOB或BFILE的一部分读入缓冲区。此函数必须用于大小超过4 GB的LOB。将SecureFile中数据的内容类型字符串设置为应用程序可以使用的内容。启用SecureFile LOB的选项设置。将LOB值调整为较短的长度。此函数必须用于大小超过4 GB的LOB。将缓冲区写入LOB。此函数必须用于大小超过4 GB的LOB。从LOB结尾开始写入数据。此函数必须用于大小超过4 GB的LOB。">LOB功能</a></p>
                        </li>
                        <li>
                           <p><a href="binding-and-defining-in-oci.html#GUID-2A4C92CD-74EF-4990-9786-C50E7E1B1DEA" title="不要为OUT绑定或PL / SQL绑定设置OCI_ATTR_MAXDATA_SIZE。仅为INSERT或UPDATE语句设置OCI_ATTR_MAXDATA_SIZE。">OCI绑定期间的缓冲区扩展</a></p>
                        </li>
                        <li>
                           <p><a href="lob-functions.html#GUID-404C8A50-516F-4DFD-939D-646A232AF7DF" title="将全部或部分LOB值复制到另一个LOB值。">OCILobCopy2（）</a></p>
                        </li>
                        <li>
                           <p><a href="lob-functions.html#GUID-264797B2-B3EA-4F6D-9A0E-BF8A4DDA13FA" title="从指定的偏移量开始擦除内部LOB数据的指定部分。">OCILobErase2（）</a></p>
                        </li>
                        <li>
                           <p><a href="lob-functions.html#GUID-DA1CD18B-7044-4E40-B1F4-4FCC1FCAB6C4" title="将全部或部分文件加载并复制到内部LOB中。此函数必须用于大小超过4 GB的LOB。">OCILobLoadFromFile2（）</a></p>
                        </li>
                        <li>
                           <p><a href="lob-functions.html#GUID-ABDB1543-1782-4216-AD80-55FA82CFF733" title="将LOB值截断为较短的长度。此函数必须用于大小超过4 GB的LOB。">OCILobTrim2（）</a></p>
                        </li>
                     </ul>
                  </div>
               </div><a id="LNOCI16511"></a><div class="props_rev_3"><a id="GUID-8C5ABC9E-3048-49AE-BFE3-DB4CB1A63AB3" name="GUID-8C5ABC9E-3048-49AE-BFE3-DB4CB1A63AB3"></a><h4 id="LNOCI-GUID-8C5ABC9E-3048-49AE-BFE3-DB4CB1A63AB3" class="sect4"><span class="enumeration_section">9.7.1</span>关于提高LOB读/写性能</h4>
                  <div>
                     <p>如何提高LOB读/写性能。</p>
                     <div class="p">以下是一些提高性能的提示：<ul style="list-style-type:disc">
                           <li>
                              <p><a href="lobs-and-bfile-operations.html#GUID-46577645-65A6-4530-B784-21404578F672" title="您可以绑定或定义CLOB列的字符数据或BLOB列的RAW数据。">关于为LOB使用数据接口</a></p>
                           </li>
                           <li>
                              <p><a href="lobs-and-bfile-operations.html#GUID-7FE1C621-757B-48AC-A3C4-4FE6B5570DAC" title="OCILobGetChunkSize（）返回BLOB，CLOB和NCLOB的可用块大小（以字节为单位）。">关于使用OCILobGetChunkSize（）</a></p>
                           </li>
                           <li>
                              <p><a href="lobs-and-bfile-operations.html#GUID-AA23DEDD-1C1D-48DB-898E-CC6D2A403F49" title="OCI提供了一种快捷方式，可以更有效地将数据写入LOB的末尾。">关于使用OCILobWriteAppend2（）</a></p>
                           </li>
                           <li>
                              <p><a href="lobs-and-bfile-operations.html#GUID-79FAE125-5AF2-4B7A-B82D-5690196E3595" title="通过使用OCILobArrayRead（）读取多个LOB定位器的LOB数据和OCILobArrayWrite（）来为多个LOB定位器写入LOB数据，可以提高性能。">关于使用OCILobArrayRead（）和OCILobArrayWrite（）</a></p>
                           </li>
                        </ul>
                     </div>
                  </div><a id="LNOCI16512"></a><div class="props_rev_3"><a id="GUID-46577645-65A6-4530-B784-21404578F672" name="GUID-46577645-65A6-4530-B784-21404578F672"></a><h5 id="LNOCI-GUID-46577645-65A6-4530-B784-21404578F672" class="sect5"><span class="enumeration_section">9.7.1.1</span>关于为LOB使用数据接口</h5>
                     <div>
                        <p>您可以绑定或定义<code class="codeph">CLOB</code>列的字符数据或<code class="codeph">BLOB</code>列的<code class="codeph">RAW</code>数据。
                        </p>
                        <p>与传统的需要多次往返的LOB接口相比，这只需要一次往返插入或选择LOB。</p>
                        <div class="infoboxnotealso" id="GUID-46577645-65A6-4530-B784-21404578F672__GUID-12CCC473-A8E8-4C0F-93A9-0FB0CA97FD46">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><a href="binding-and-defining-in-oci.html#GUID-D757C946-BCDA-4A32-867B-BE951BA9BBF4" title="Oracle数据库允许对任何大小的LOB的INSERT和UPDATE进行非零绑定。">关于绑定LOB数据</a>以及<code class="codeph">INSERT</code>和<code class="codeph">UPDATE</code> <span>语句的</span>示例</p>
                              </li>
                              <li>
                                 <p><a href="binding-and-defining-in-oci.html#GUID-FE7DB3D8-9310-41ED-8869-B5106E60D29E">关于定义LOB数据</a>以了解<code class="codeph">SELECT</code>语句的用法和示例</p>
                              </li>
                           </ul>
                        </div>
                     </div>
                  </div><a id="LNOCI16513"></a><div class="props_rev_3"><a id="GUID-7FE1C621-757B-48AC-A3C4-4FE6B5570DAC" name="GUID-7FE1C621-757B-48AC-A3C4-4FE6B5570DAC"></a><h5 id="LNOCI-GUID-7FE1C621-757B-48AC-A3C4-4FE6B5570DAC" class="sect5"><span class="enumeration_section">9.7.1.2</span>关于使用OCILobGetChunkSize（）</h5>
                     <div>
                        <p><code class="codeph">OCILobGetChunkSize()</code>返回<code class="codeph">BLOB</code> ， <code class="codeph">CLOB</code>和<code class="codeph">NCLOB</code>的可用块大小（以字节为单位）。
                        </p>
                        <p>您可以使用<code class="codeph">OCILobGetChunkSize()</code>调用来提高BasicFile LOB的LOB读写操作的性能。当对大小为可用块大小的倍数的BasicFile LOB数据进行读或写操作并且操作在块边界上开始时，性能得到改善。不需要使用<code class="codeph">OCILobGetChunkSize()</code>对齐来编写或读取SecureFile LOB。
                        </p>
                        <p>调用<code class="codeph">OCILobGetChunkSize()</code>返回LOB的可用块大小，以便应用程序可以批量处理整个块的一系列写操作，而不是为同一块发出多个LOB写调用。
                        </p>
                        <div class="infoboxnotealso" id="GUID-7FE1C621-757B-48AC-A3C4-4FE6B5570DAC__GUID-5BC49F72-5B8C-485D-977D-2EA258523754">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><a href="lobs-and-bfile-operations.html#GUID-5DEEF1FA-0024-48B4-B587-506386EA5240" title="对于SecureFiles（具有STORE AS SECUREFILE选项的LOB，它是在Oracle Database 11g第1版中引入的），您可以在CREATE TABLE和ALTER TABLE语句中指定SQL参数DEDUPLICATE。">SecureFiles LOB的选项</a></p>
                              </li>
                              <li>
                                 <p><a href="lob-functions.html#GUID-ABB71585-172E-4F3E-A0CF-F70D709F2072" title="获取LOB的块大小。">OCILobGetChunkSize（）</a></p>
                              </li>
                           </ul>
                           <p></p>
                        </div>
                     </div>
                  </div><a id="LNOCI16514"></a><div class="props_rev_3"><a id="GUID-AA23DEDD-1C1D-48DB-898E-CC6D2A403F49" name="GUID-AA23DEDD-1C1D-48DB-898E-CC6D2A403F49"></a><h5 id="LNOCI-GUID-AA23DEDD-1C1D-48DB-898E-CC6D2A403F49" class="sect5"><span class="enumeration_section">9.7.1.3</span>关于使用OCILobWriteAppend2（）</h5>
                     <div>
                        <p>OCI提供了一种快捷方式，可以更有效地将数据写入LOB的末尾。</p>
                        <p><code class="codeph">OCILobWriteAppend2()</code>调用将数据附加到LOB的末尾，而不需要先调用<code class="codeph">OCILobGetLength2()</code>来确定<code class="codeph">OCILobWrite2()</code>操作的<code class="codeph">OCILobWrite2()</code> 。<code class="codeph">OCILobWriteAppend2()</code>执行这两个步骤。
                        </p>
                        <div class="infoboxnotealso" id="GUID-AA23DEDD-1C1D-48DB-898E-CC6D2A403F49__GUID-1CAD009D-571F-497F-9A10-8C69675C8A0B">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><a href="lob-functions.html#GUID-87D3275A-B042-4991-B261-AB531BB83CA2" title="从LOB结尾开始写入数据。此函数必须用于大小超过4 GB的LOB。">OCILobWriteAppend2（）</a></p>
                              </li>
                              <li>
                                 <p><a href="lob-functions.html#GUID-9BC0A78A-37CB-432F-AE2B-22C905608C4C" title="获取LOB的长度。此函数必须用于大小超过4 GB的LOB。">OCILobGetLength2（）</a></p>
                              </li>
                              <li>
                                 <p><a href="lob-functions.html#GUID-77F056CA-9EEE-4550-8A8E-0155DF994DBE" title="将缓冲区写入LOB。此函数必须用于大小超过4 GB的LOB。">OCILobWrite2（）</a></p>
                              </li>
                           </ul>
                        </div>
                     </div>
                  </div><a id="LNOCI11597"></a><div class="props_rev_3"><a id="GUID-79FAE125-5AF2-4B7A-B82D-5690196E3595" name="GUID-79FAE125-5AF2-4B7A-B82D-5690196E3595"></a><h5 id="LNOCI-GUID-79FAE125-5AF2-4B7A-B82D-5690196E3595" class="sect5"><span class="enumeration_section">9.7.1.4</span>关于使用OCILobArrayRead（）和OCILobArrayWrite（）</h5>
                     <div>
                        <p>通过使用<code class="codeph">OCILobArrayRead()</code>读取多个LOB定位器的LOB数据和<code class="codeph">OCILobArrayWrite()</code>来为多个LOB定位器写入LOB数据，可以提高性能。
                        </p>
                        <p>Oracle数据库10g第2版中引入的这些功能减少了这些操作的往返次数。</p>
                        <div class="infoboxnotealso" id="GUID-79FAE125-5AF2-4B7A-B82D-5690196E3595__GUID-989E9FDB-B869-4A69-BC97-8F3011A54787">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/lnoci&amp;id=ADLOB1400" target="_blank"><span><cite>Oracle Database SecureFiles和Large Objects Developer's Guide</cite></span></a> “LOB Array Read”和“LOB Array Write”部分提供了更多信息和代码示例，展示了如何将这些函数用于回调函数和分段模式</p>
                              </li>
                              <li>
                                 <p><a href="lob-functions.html#GUID-47652C79-0635-4595-A34B-CD03B7F81A9F" title="在一次往返中读取多个定位器的LOB数据。">OCILobArrayRead（）</a></p>
                              </li>
                              <li>
                                 <p><a href="lob-functions.html#GUID-10AB60C9-13FE-4CC9-9C62-CAD45DBB3B93">OCILobArrayWrite（）</a></p>
                              </li>
                           </ul>
                           <p></p>
                        </div>
                     </div>
                  </div>
               </div><a id="LNOCI16515"></a><div class="props_rev_3"><a id="GUID-A88C554E-5397-477E-BC5D-1675D959D287" name="GUID-A88C554E-5397-477E-BC5D-1675D959D287"></a><h4 id="LNOCI-GUID-A88C554E-5397-477E-BC5D-1675D959D287" class="sect4"><span class="enumeration_section">9.7.2</span> LOB缓冲功能</h4>
                  <div>
                     <p>不推荐使用这些LOB函数。使用LOB预取功能代替这些LOB缓冲功能。</p>
                     <p></p>
                     <p>OCI提供了几个调用来控制内部LOB值的小读取和写入的LOB缓冲：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">OCILobEnableBuffering（）</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">OCILobDisableBuffering（）</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">OCILobFlushBuffer（）</code></p>
                        </li>
                     </ul>
                     <p>这些函数使使用内部LOB（ <code class="codeph">BLOB</code> ， <code class="codeph">CLOB</code> ， <code class="codeph">NCLOB</code> ）的应用程序能够缓冲客户端缓冲区中的小型读写操作。这减少了网络往返和LOB版本的数量，从而显着提高了LOB性能。
                     </p>
                     <div class="infoboxnotealso" id="GUID-A88C554E-5397-477E-BC5D-1675D959D287__GUID-8F3C0713-CF09-43BC-8F2C-DA47A722AF94">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>有关LOB缓冲的更多信息，请参阅<a href="../adlob/index.html" target="_blank"><span><cite>Oracle Database SecureFiles和Large Objects Developer's Guide</cite></span></a> ，请参阅有关使用LOB API的章节。 <span class="italic"> </span></p>
                           </li>
                           <li>
                              <p><a href="oci-function-server-round-trips.html#GUID-AD3700EF-9293-4E14-807E-43A6B395CBD5" title="描述每个OCI LOB功能的服务器往返次数。">LOB函数Round-Trips，</a>用于列出每个函数所需的服务器往返</p>
                           </li>
                           <li>
                              <p><a href="lobs-and-bfile-operations.html#GUID-3F7FEAFF-F4EF-42CC-8F95-598D227C5D83" title="为了改进较小LOB的OCI访问，可以预取和缓存LOB数据，同时还获取定位器。">预取LOB数据，长度和块大小</a></p>
                           </li>
                           <li>
                              <p><a href="deprecated-oci-functions.html#GUID-588B17BE-DB5F-4D2D-8FF1-7E4BEABFA917" title="从Oracle Database 12c第2版（12.2）开始，不推荐使用此功能。">OCILobEnableBuffering（）</a></p>
                           </li>
                           <li>
                              <p><a href="deprecated-oci-functions.html#GUID-6BE287D0-3385-4514-850A-349940ECB26A" title="从Oracle Database 12c第2版（12.2）开始，不推荐使用此功能。">OCILobDisableBuffering（）</a></p>
                           </li>
                           <li>
                              <p><a href="deprecated-oci-functions.html#GUID-E63ACF53-B64F-4E57-9EBE-B7B73C033EE1" title="从Oracle Database 12c第2版（12.2）开始，不推荐使用此功能。">OCILobFlushBuffer（）</a></p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="LNOCI16516"></a><div class="props_rev_3"><a id="GUID-7BFEAAEE-0BF5-4104-844B-0AF8C4C6D6C9" name="GUID-7BFEAAEE-0BF5-4104-844B-0AF8C4C6D6C9"></a><h4 id="LNOCI-GUID-7BFEAAEE-0BF5-4104-844B-0AF8C4C6D6C9" class="sect4"><span class="enumeration_section">9.7.3</span>打开和关闭LOB的功能</h4>
                  <div>
                     <p>OCI提供了显式打开LOB， <code class="codeph">OCILobOpen()</code> ，关闭LOB， <code class="codeph">OCILobClose()</code>以及测试LOB是否打开的<code class="codeph">OCILobIsOpen()</code> ， <code class="codeph">OCILobIsOpen()</code> 。
                     </p>
                     <p>这些函数标记一系列LOB操作的开始和结束，以便在关闭LOB时可以执行特定处理，例如更新索引。</p>
                     <p>对于内部LOB，开放性的概念与LOB而不是其定位器相关联。定位器不存储有关LOB状态的任何信息。多个定位器可以指向相同的开放LOB。但是，对于<code class="codeph">BFILE</code> ，打开与特定定位器相关联。因此，可以通过使用不同的定位符在同一<code class="codeph">BFILE</code>上执行多个开放调用。
                     </p>
                     <p>如果应用程序未在一组<code class="codeph">OCILobOpen()</code>和<code class="codeph">OCILobClose()</code>调用中包装LOB操作，则对LOB的每次修改都会隐式打开和关闭LOB，从而触发与LOB更改相关联的任何触发器。</p>
                     <p>如果LOB操作未包含在open和close调用中，则LOB上的任何可扩展索引都会在进行LOB修改时更新，因此始终有效并且可以随时使用。如果在一组<code class="codeph">OCILobOpen()</code>和<code class="codeph">OCILobClose()</code>调用中修改了LOB，则不会针对单个LOB修改触发触发器。触发器仅在<code class="codeph">OCILobClose()</code>调用之后触发，因此索引在关闭调用之后才会更新，因此在打开和关闭调用中无效。<code class="codeph">OCILobIsOpen()</code>可以与内部LOB和<code class="codeph">BFILEs</code> 。
                     </p>
                     <p>在关闭事务打开的所有打开的LOB之前提交事务时会返回错误。返回错误时，LOB不再标记为打开，但事务已成功提交。因此，提交了对事务中的LOB和非LOB数据所做的所有更改，但不更新域和功能索引。如果发生这种情况，请在LOB列上重建功能和域索引。</p>
                     <p>没有交易时打开的LOB必须在会话结束前关闭。如果在会话结束时打开LOB，则LOB不再标记为打开，并且不会更新域和功能索引。如果发生这种情况，请在LOB列上重建功能和域索引。</p>
                     <p>本节包括以下主题： <a href="lobs-and-bfile-operations.html#GUID-5B778EC5-B4C3-49BF-9254-E9BB853DE61D" title="打开和关闭LOB有哪些限制。">打开和关闭LOB的限制</a> 。
                     </p>
                     <div class="infoboxnotealso" id="GUID-7BFEAAEE-0BF5-4104-844B-0AF8C4C6D6C9__GUID-8D571BCD-9877-4C37-BD29-0C108B74C7AA">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="lob-functions.html#GUID-B007A3C7-999B-4AD7-8BF7-C6D14572F470" title="以指示的模式打开内部或外部LOB。">OCILobOpen（）</a></p>
                           </li>
                           <li>
                              <p><a href="lob-functions.html#GUID-CBEB9238-6B47-4A08-8C8D-FC2E5ED56557" title="关闭先前打开的LOB或BFILE。">OCILobClose（）</a></p>
                           </li>
                           <li>
                              <p><a href="lob-functions.html#GUID-FFF883CE-3B99-4319-A81C-A11F8740209E" title="测试LOB或BFILE是否打开。">OCILobIsOpen（）</a></p>
                           </li>
                        </ul>
                     </div>
                  </div><a id="LNOCI16517"></a><div class="props_rev_3"><a id="GUID-5B778EC5-B4C3-49BF-9254-E9BB853DE61D" name="GUID-5B778EC5-B4C3-49BF-9254-E9BB853DE61D"></a><h5 id="LNOCI-GUID-5B778EC5-B4C3-49BF-9254-E9BB853DE61D" class="sect5"><span class="enumeration_section">9.7.3.1</span>打开和关闭LOB的限制</h5>
                     <div>
                        <p>打开和关闭LOB有哪些限制。</p>
                        <p>LOB开闭机制有以下限制：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>在提交事务之前，应用程序必须关闭所有先前打开的LOB。如果不这样做会导致错误。如果回滚事务，则会丢弃所有打开的LOB以及所做的更改。由于LOB未关闭，因此不会触发关联的触发器。</p>
                           </li>
                           <li>
                              <p>虽然打开的内部LOB数量没有限制，但是由<code class="codeph">SESSION_MAX_OPEN_FILES</code>参数确定的打开文件数量有限制。将已打开的定位器分配给另一个定位器不算作打开新的LOB。</p>
                           </li>
                           <li>
                              <p>在同一事务中打开或关闭相同的内部LOB是错误的，使用不同的定位器或相同的定位器。</p>
                           </li>
                           <li>
                              <p>关闭尚未打开的LOB是错误的。</p>
                              <div class="infoboxnote" id="GUID-5B778EC5-B4C3-49BF-9254-E9BB853DE61D__GUID-9D5AD462-6E56-40D6-B102-0A9DCC769D12">
                                 <p class="notep1">注意：</p>
                                 <p>必须关闭打开的LOB值的<span class="italic">事务</span>的定义是以下之一：</p>
                                 <ul style="list-style-type:disc">
                                    <li>
                                       <p>在<code class="codeph">SET TRANSACTION</code>和<code class="codeph">COMMIT</code></p>
                                    </li>
                                    <li>
                                       <p>在<code class="codeph">DATA</code> <code class="codeph">MODIFYING</code> <code class="codeph">DML</code>或<code class="codeph">SELECT</code> <code class="codeph">...FOR UPDATE</code>和<code class="codeph">COMMIT</code> 。</p>
                                    </li>
                                    <li>
                                       <p>在自治事务块内</p>
                                    </li>
                                 </ul>
                              </div>
                           </li>
                        </ul>
                        <div class="infoboxnotealso" id="GUID-5B778EC5-B4C3-49BF-9254-E9BB853DE61D__GUID-3D1E1245-9440-49DC-A2B4-A1D55F36E53F">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><a href="../refrn/SESSION_MAX_OPEN_FILES.html#REFRN10196" target="_blank"><span><cite>Oracle数据库参考中的</cite></span></a> <code class="codeph">SESSION_MAX_OPEN_FILES</code>参数</p>
                              </li>
                              <li>
                                 <p><a href="oci-demo-programs.html#GUID-75E18629-0C54-4495-A747-AFB346034F26" title="列出示例程序，其中包含示例代码，用于演示OCI句柄的分配和使用。">OCI演示程序，</a>用于在线演示程序中使用<a href="lob-functions.html#GUID-B007A3C7-999B-4AD7-8BF7-C6D14572F470" title="以指示的模式打开内部或外部LOB。">OCILobOpen（）</a>和<a href="lob-functions.html#GUID-CBEB9238-6B47-4A08-8C8D-FC2E5ED56557" title="关闭先前打开的LOB或BFILE。">OCILobClose（）</a>调用的示例</p>
                              </li>
                              <li>
                                 <p><a href="oci-function-server-round-trips.html#GUID-AD3700EF-9293-4E14-807E-43A6B395CBD5__CACHAFFI" title="该表有2列。第1列是功能名称，第2列描述服务器往返次数。">表C-2</a></p>
                              </li>
                           </ul>
                        </div>
                     </div>
                  </div>
               </div><a id="LNOCI16518"></a><div class="props_rev_3"><a id="GUID-FFFD9E4C-03CE-469C-AA47-DFD73C0C9C69" name="GUID-FFFD9E4C-03CE-469C-AA47-DFD73C0C9C69"></a><h4 id="LNOCI-GUID-FFFD9E4C-03CE-469C-AA47-DFD73C0C9C69" class="sect4"><span class="enumeration_section">9.7.4</span> LOB读写回调</h4>
                  <div>
                     <p>OCI支持读写回调函数。</p>
                     <div class="p">以下部分更详细地描述了回调的使用：<ul style="list-style-type:disc">
                           <li>
                              <p><a href="lobs-and-bfile-operations.html#GUID-94EB10D8-73A4-4F90-8610-3A2B31D1F5C0" title="用于插入或检索数据的用户定义的读写回调函数提供了流式LOB的轮询方法的替代方法。">流式回调接口</a></p>
                           </li>
                           <li>
                              <p><a href="lobs-and-bfile-operations.html#GUID-5DB4A35A-BCE1-4D7B-B836-63FD2C83195E" title="用户定义的读回调函数通过OCILobRead2（）函数注册。">使用回调读取LOB</a></p>
                           </li>
                           <li>
                              <p><a href="lobs-and-bfile-operations.html#GUID-4BE362B6-B13C-4959-94B2-599CBC2B581D" title="与读回调类似，用户定义的写回调函数通过OCILobWrite2（）函数注册。">使用回调编写LOB</a></p>
                           </li>
                        </ul>
                     </div>
                  </div><a id="LNOCI16519"></a><div class="props_rev_3"><a id="GUID-94EB10D8-73A4-4F90-8610-3A2B31D1F5C0" name="GUID-94EB10D8-73A4-4F90-8610-3A2B31D1F5C0"></a><h5 id="LNOCI-GUID-94EB10D8-73A4-4F90-8610-3A2B31D1F5C0" class="sect5"><span class="enumeration_section">9.7.4.1</span>流的回调接口</h5>
                     <div>
                        <p>用于插入或检索数据的用户定义的读写回调函数提供了流式LOB的轮询方法的替代方法。</p>
                        <p>这些函数由您实现，并通过<code class="codeph">OCILobRead2()</code> ， <code class="codeph">OCILobWriteAppend2()</code>和<code class="codeph">OCILobWrite2()</code>调用向OCI注册。只要需要，OCI就会调用这些回调函数。
                        </p>
                        <div class="infoboxnotealso" id="GUID-94EB10D8-73A4-4F90-8610-3A2B31D1F5C0__GUID-FBDD741C-9B88-4D80-AB92-AC1F0EEF6895">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><a href="lob-functions.html#GUID-6AC6E6DA-236B-4BF9-942F-9FCC4178FEDA" title="将调用所指定的LOB或BFILE的一部分读入缓冲区。此函数必须用于大小超过4 GB的LOB。">OCILobRead2（）</a></p>
                              </li>
                              <li>
                                 <p><a href="lob-functions.html#GUID-87D3275A-B042-4991-B261-AB531BB83CA2" title="从LOB结尾开始写入数据。此函数必须用于大小超过4 GB的LOB。">OCILobWriteAppend2（）</a></p>
                              </li>
                              <li>
                                 <p><a href="lob-functions.html#GUID-77F056CA-9EEE-4550-8A8E-0155DF994DBE" title="将缓冲区写入LOB。此函数必须用于大小超过4 GB的LOB。">OCILobWrite2（）</a></p>
                              </li>
                           </ul>
                        </div>
                     </div>
                  </div><a id="LNOCI72636"></a><a id="LNOCI16520"></a><div class="props_rev_3"><a id="GUID-5DB4A35A-BCE1-4D7B-B836-63FD2C83195E" name="GUID-5DB4A35A-BCE1-4D7B-B836-63FD2C83195E"></a><h5 id="LNOCI-GUID-5DB4A35A-BCE1-4D7B-B836-63FD2C83195E" class="sect5"><span class="enumeration_section">9.7.4.2</span>使用回调读取LOB</h5>
                     <div>
                        <p>用户定义的读回调函数通过<code class="codeph">OCILobRead2()</code>函数注册。
                        </p>
                        <div class="section">
                           <p>回调函数应该具有以下原型：</p><pre class="oac_no_warn" dir="ltr"><code class="codeph">CallbackFunctionName</code> （void * ctxp，CONST void * bufp，oraub8 len，ub1 piece，void ** changed_bufpp，oraub8 * changed_lenp）;</pre><p>第一个参数<code class="codeph">ctxp</code>是在<code class="codeph">OCILobRead2()</code>函数调用中传递给OCI的回调的上下文。当调用回调函数时，您在<code class="codeph">ctxp</code>提供的信息将传递给您（OCI不会在IN路上使用此信息）。<code class="codeph">OCILobRead2()</code>的<code class="codeph">bufp</code>参数是指向返回LOB数据的存储的指针， <code class="codeph">bufl</code>是此缓冲区的长度。它告诉您已将多少数据读入所提供的缓冲区。
                           </p>
                           <p>如果原始<code class="codeph">OCILobRead2()</code>调用中提供的缓冲区长度不足以存储服务器返回的所有数据，则调用用户定义的回调。在这种情况下， <code class="codeph">piece</code>参数指示缓冲区中返回的信息是第一个，下一个还是最后一个。
                           </p>
                           <p>可以在回调函数内使用参数<code class="codeph">changed_bufpp</code>和<code class="codeph">changed_lenp</code>来动态更改缓冲区。<code class="codeph">changed_bufpp</code>参数应指向已更改缓冲区的地址， <code class="codeph">changed_lenp</code>参数应指向已更改缓冲区的长度。如果应用程序未动态更改缓冲区，则无需在回调函数内使用<code class="codeph">changed_bufpp</code>和<code class="codeph">changed_lenp</code>参数。
                           </p>
                           <p><a href="lobs-and-bfile-operations.html#GUID-5DB4A35A-BCE1-4D7B-B836-63FD2C83195E__BGBBBEDI">例9-1</a>显示了使用<code class="codeph">OCILobRead2()</code>实现读回调函数的代码片段。假设<code class="codeph">lobl</code>是先前已选择的有效定位器， <code class="codeph">svchp</code>是有效的服务句柄，并且<code class="codeph">errhp</code>是有效的错误句柄。在该示例中，重复调用用户定义的函数<code class="codeph">cbk_read_lob()</code>直到读取了所有LOB数据。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-5DB4A35A-BCE1-4D7B-B836-63FD2C83195E__BGBBBEDI">
                           <p class="titleinexample">例9-1使用OCILobRead2（）实现读回调函数</p><pre class="oac_no_warn" dir="ltr">...oraub8 offset = 1; oraub8 loblen = 0; oraub8 byte_amt = 0; oraub8 char_amt = 0 ub1 bufp [MAXBUFLEN];剑报; byte_amtp = 4294967297; / * 4千兆字加1 * / if（retval = OCILobRead2（svchp，errhp，lobl，＆byte_amt，＆char_amt，offset，（void *）bufp，（oraub8）MAXBUFLEN，（void *）0，OCI_FIRST_PIECE，cbk_read_lob，（ub2） 0，（ub1）SQLCS_IMPLICIT））{（void）printf（“ERROR：OCILobRead2（）LOB。\ n”）;的Report_Error（）; } ...sb4 cbk_read_lob（ctxp，bufxp，len，piece，changed_bufpp，changed_lenp）void * ctxp; CONST void * bufxp; oraub8 len; ub1件; void ** changed_bufpp; oraub8 * changed_lenp; {static ub4 piece_count = 0; piece_count ++; switch（piece）{case OCI_LAST_PIECE：/ * ---缓冲处理代码在这里--- * /（void）printf（“回调读取％d th piece \ n \ n”，piece_count）; piece_count = 0;打破; case OCI_FIRST_PIECE：/ * ---缓冲区处理代码在这里--- * /（void）printf（“回调读取％d th piece \ n”，piece_count）; / *  - 如果必须动态更改缓冲区，则设置changed_bufpp和changed_lenp的可选代码 -  * / break; case OCI_NEXT_PIECE：/ * ---缓冲区处理代码在这里--- * /（void）printf（“回调读取％d th piece \ n”，piece_count）; / *  - 如果必须动态更改缓冲区，则设置changed_bufpp和changed_lenp的可选代码 -  * / break; default：（void）printf（“callback read error：unknown piece =％d。\ n”，piece）;返回OCI_ERROR; } return OCI_CONTINUE; }</pre></div>
                        <!-- class="example" -->
                        <div class="section">
                           <div class="infoboxnotealso" id="GUID-5DB4A35A-BCE1-4D7B-B836-63FD2C83195E__GUID-961AB33C-04BF-47B4-B253-EA15D09081D8">
                              <p class="notep1">也可以看看：</p>
                              <p><a href="lob-functions.html#GUID-6AC6E6DA-236B-4BF9-942F-9FCC4178FEDA" title="将调用所指定的LOB或BFILE的一部分读入缓冲区。此函数必须用于大小超过4 GB的LOB。">OCILobRead2（）</a></p>
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNOCI72637"></a><a id="LNOCI16521"></a><div class="props_rev_3"><a id="GUID-4BE362B6-B13C-4959-94B2-599CBC2B581D" name="GUID-4BE362B6-B13C-4959-94B2-599CBC2B581D"></a><h5 id="LNOCI-GUID-4BE362B6-B13C-4959-94B2-599CBC2B581D" class="sect5"><span class="enumeration_section">9.7.4.3</span>使用回调编写LOB</h5>
                     <div>
                        <p>与读回调类似，用户定义的写回调函数通过<code class="codeph">OCILobWrite2()</code>函数注册。
                        </p>
                        <div class="section">
                           <p>回调函数应该具有以下原型：</p><pre class="oac_no_warn" dir="ltr">CallbackFunctionName（void * ctxp，void * bufp，oraub8 * lenp，ub1 * piecep，void ** changed_bufpp，oraub8 * changed_lenp）;</pre><p>第一个参数<code class="codeph">ctxp</code>是在<code class="codeph">OCILobWrite2()</code>函数调用中传递给OCI的回调的上下文。当您通过OCI调用回调函数时，您在<code class="codeph">ctxp</code>提供的信息将传回给您（OCI在IN路上不使用此信息）。<code class="codeph">bufp</code>参数是指向存储区域的指针;您在调用<code class="codeph">OCILobWrite2()</code>提供此指针。
                           </p>
                           <p>在将调用中提供的数据插入<code class="codeph">OCILobWrite2()</code> ，用户定义的回调将插入剩余的任何数据。在回调中，提供要插入<code class="codeph">bufp</code>指示的存储中的数据，并指定<code class="codeph">lenp</code>的长度。您还可以使用<code class="codeph">piecep</code>参数指示它是下一个（ <code class="codeph">OCI_NEXT_PIECE</code> ）还是最后一个（ <code class="codeph">OCI_LAST_PIECE</code> ）。您必须确保应用程序提供的存储指针的写入次数不超过分配的存储大小。
                           </p>
                           <p>可以在回调函数内使用参数<code class="codeph">changed_bufpp</code>和<code class="codeph">changed_lenp</code>来动态更改缓冲区。<code class="codeph">changed_bufpp</code>参数应指向已更改缓冲区的地址， <code class="codeph">changed_lenp</code>参数应指向已更改缓冲区的长度。如果应用程序未动态更改缓冲区，则无需在回调函数内使用<code class="codeph">changed_bufpp</code>和<code class="codeph">changed_lenp</code>参数。
                           </p>
                           <p><a href="lobs-and-bfile-operations.html#GUID-4BE362B6-B13C-4959-94B2-599CBC2B581D__BGBCHBJA">例9-2</a>显示了使用<code class="codeph">OCILobWrite2()</code>实现写回调函数的代码片段。假设<code class="codeph">lobl</code>是一个已被锁定以进行更新的有效定位器， <code class="codeph">svchp</code>是一个有效的服务句柄，并且<code class="codeph">errhp</code>是一个有效的错误句柄。重复调用用户定义的函数<code class="codeph">cbk_write_lob()</code>直到<code class="codeph">piecep</code>参数指示应用程序提供最后一个部分。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-4BE362B6-B13C-4959-94B2-599CBC2B581D__BGBCHBJA">
                           <p class="titleinexample">例9-2使用OCILobWrite2（）实现写回调函数</p><pre class="oac_no_warn" dir="ltr">...ub1 bufp [MAXBUFLEN]; oraub8 byte_amt = MAXBUFLEN * 20; oraub8 char_amt = 0; oraub8 offset = 1; oraub8 nbytes = MAXBUFLEN; / *  - 用数据填充bufp的代码在这里。 nbytes应该反映大小，应该小于或等于MAXBUFLEN  -  * / if（retval = OCILobWrite2（svchp，errhp，lobl，＆byte_amt，＆char_amt，offset，（void *）bufp，（ub4）nbytes，OCI_FIRST_PIECE，（ void *）0，cbk_write_lob，（ub2）0，（ub1）SQLCS_IMPLICIT））{（void）printf（“ERROR：OCILobWrite2（）。\ n”）;的Report_Error（）;返回; } ...sb4 cbk_write_lob（ctxp，bufxp，lenp，piecep，changed_bufpp，changed_lenp）void * ctxp; void * bufxp; oraub8 * lenp; ub1 * piecep; void ** changed_bufpp; oraub8 * changed_lenp; {/ *  - 用数据填充bufxp的代码在这里。 * lenp应该反映大小，应该小于或等于MAXBUFLEN  -  * / / *  - 如果必须动态更改缓冲区，则设置changed_bufpp和changed_lenp的可选代码 -  * / if（这是最后一个数据缓冲区） * piecep = OCI_LAST_PIECE; else * piecep = OCI_NEXT_PIECE;返回OCI_CONTINUE; }</pre></div>
                        <!-- class="example" -->
                        <div class="section">
                           <div class="infoboxnotealso" id="GUID-4BE362B6-B13C-4959-94B2-599CBC2B581D__GUID-F879D593-5DEF-456C-8B0E-6CE731754D82">
                              <p class="notep1">也可以看看：</p>
                              <p><a href="lob-functions.html#GUID-77F056CA-9EEE-4550-8A8E-0155DF994DBE" title="将缓冲区写入LOB。此函数必须用于大小超过4 GB的LOB。">OCILobWrite2（）</a></p>
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div>
            </div><a id="LNOCI16522"></a><div class="props_rev_3"><a id="GUID-B9A9B78B-570B-4B54-A4C4-A2F2D2808B06" name="GUID-B9A9B78B-570B-4B54-A4C4-A2F2D2808B06"></a><h3 id="LNOCI-GUID-B9A9B78B-570B-4B54-A4C4-A2F2D2808B06" class="sect3"><span class="enumeration_section">9.8</span>临时LOB支持</h3>
               <div>
                  <p>OCI提供用于创建和释放临时LOB， <code class="codeph">OCILobCreateTemporary()</code>和<code class="codeph">OCILobFreeTemporary()</code>的函数，以及用于确定LOB是否是临时的函数<code class="codeph">OCILobIsTemporary()</code> 。
                  </p>
                  <p>临时LOB不会永久存储在数据库中，而是像本地变量一样用于操作LOB数据。在标准（持久）LOB上运行的OCI函数也可用于临时LOB。</p>
                  <p>与持久性LOB一样，所有函数都在临时LOB的定位器上运行，并且通过定位器访问实际的LOB数据。</p>
                  <p>临时LOB定位器可用作以下类型的SQL语句的参数：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><code class="codeph">UPDATE</code> - 临时LOB定位器在测试nullity或作为函数的参数时可以用作<code class="codeph">WHERE</code>子句中的值。定位器也可以在<code class="codeph">SET</code>子句中使用。
                        </p>
                     </li>
                     <li>
                        <p><code class="codeph">DELETE</code> - 在测试nullity或作为函数的参数时，可以在<code class="codeph">WHERE</code>子句中使用临时LOB定位器。
                        </p>
                     </li>
                     <li>
                        <p><code class="codeph">SELECT</code> - 在测试nullity或作为函数的参数时，可以在<code class="codeph">WHERE</code>子句中使用临时LOB定位器。临时LOB也可以用作<code class="codeph">SELECT...的返回变量<code class="codeph">SELECT...选择函数返回值时的INTO</code>语句。
                        </p>
                     </li>
                  </ul>
                  <div class="infoboxnote" id="GUID-B9A9B78B-570B-4B54-A4C4-A2F2D2808B06__GUID-FF3460B5-AEF2-49A0-82E0-FA95A7123DCC">
                     <p class="notep1">注意：</p>
                     <p>如果在临时定位器中选择永久定位器，则使用永久定位器覆盖临时定位器。在这种情况下，不会隐式释放临时LOB。您必须在<code class="codeph">SELECT...之前显式释放临时LOB <code class="codeph">SELECT...INTO</code>运营。如果未明确释放临时LOB，则在指定的<code class="codeph">duration</code>结束之前不会释放它。除非你有另一个临时定位器指向同一个LOB，否则你不再有一个指向临时LOB的定位器，因为原来的定位器被<code class="codeph">SELECT...覆盖<code class="codeph">SELECT...INTO</code>运营。
                     </p>
                  </div>
                  <div class="p">本节包括以下主题：<ul style="list-style-type:disc">
                        <li>
                           <p><a href="lobs-and-bfile-operations.html#GUID-7A401AB9-FFFB-49B9-86FE-BEFFBF0EF438" title="使用OCILobCreateTemporary（）函数创建临时LOB。">创建和释放临时LOB</a></p>
                        </li>
                        <li>
                           <p><a href="lobs-and-bfile-operations.html#GUID-5291BFEA-E35C-4097-AC29-59D03166546A" title="OCI支持临时LOB的几个预定义持续时间，以及应用程序可用于定义特定于应用程序的持续时间的一组函数。">临时LOB持续时间</a></p>
                        </li>
                        <li>
                           <p><a href="lobs-and-bfile-operations.html#GUID-19F5922C-3560-476B-B414-27F13B5C2BAC" title="每当您的OCI程序从SQL或PL / SQL获取LOB定位器时，请使用OCILobIsTemporary（）函数检查定位器是否是临时的。">关于释放临时LOB</a></p>
                        </li>
                        <li>
                           <p><a href="lobs-and-bfile-operations.html#GUID-793BD3A1-0D07-4A59-A9ED-CDF7A4976B5D" title="分配OCILobLocator指针时必须特别小心。">分配指针时要小心</a></p>
                        </li>
                        <li>
                           <p><a href="lobs-and-bfile-operations.html#GUID-8A0523FD-25E9-45AE-A623-CCB8940713D4" title="显示临时LOB的使用方式。">临时LOB示例</a></p>
                        </li>
                     </ul>
                  </div>
                  <div class="infoboxnotealso" id="GUID-B9A9B78B-570B-4B54-A4C4-A2F2D2808B06__GUID-6B2776B2-4CEC-45CD-9A84-42F44D5B793C">
                     <p class="notep1">也可以看看：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="lob-functions.html#GUID-63F75EC5-EB14-4E25-B593-270FF814615A" title="创建一个临时LOB。">OCILobCreateTemporary（）</a></p>
                        </li>
                        <li>
                           <p><a href="lob-functions.html#GUID-E0FBF017-1B08-410C-9E53-F6E14008813A" title="释放临时LOB。">OCILobFreeTemporary（）</a></p>
                        </li>
                        <li>
                           <p><a href="lob-functions.html#GUID-071D8134-F9E7-4C5A-8E63-E90831FA7AC3" title="测试定位器是否指向临时LOB。">OCILobIsTemporary（）</a></p>
                        </li>
                     </ul>
                  </div>
               </div><a id="LNOCI16523"></a><div class="props_rev_3"><a id="GUID-7A401AB9-FFFB-49B9-86FE-BEFFBF0EF438" name="GUID-7A401AB9-FFFB-49B9-86FE-BEFFBF0EF438"></a><h4 id="LNOCI-GUID-7A401AB9-FFFB-49B9-86FE-BEFFBF0EF438" class="sect4"><span class="enumeration_section">9.8.1</span>创建和释放临时LOB</h4>
                  <div>
                     <p>使用<code class="codeph">OCILobCreateTemporary()</code>函数创建临时LOB。
                     </p>
                     <p>传递给此函数的参数包括LOB持续时间的值。默认持续时间是当前会话的长度。在持续时间结束时删除所有临时LOB。用户可以通过使用<code class="codeph">OCILobFreeTemporary()</code>函数显式释放临时LOB来回收临时LOB空间。临时LOB在创建时为空。
                     </p>
                     <p>创建临时LOB时，还可以指定是否将临时LOB读入服务器的缓冲区高速缓存。</p>
                     <p>要使临时LOB永久化，请使用<code class="codeph">OCILobCopy2()</code>将临时LOB中的数据复制到永久LOB中。您还可以在<code class="codeph">INSERT</code>语句的<code class="codeph">VALUES</code>子句中使用临时LOB作为<code class="codeph">UPDATE</code>语句中赋值的源，或者将其分配给持久LOB属性，然后刷新对象。可以使用与标准LOB相同的函数来修改临时LOB。
                     </p>
                     <div class="infoboxnote" id="GUID-7A401AB9-FFFB-49B9-86FE-BEFFBF0EF438__GUID-A7A1D5BE-60E3-4867-B110-FB9865EAF1DD">
                        <p class="notep1">注意：</p>
                        <p>插入空LOB的最有效方法是绑定一个没有赋值的临时LOB。这比以下方法使用更少的资源。</p><pre class="oac_no_warn" dir="ltr">INSERT INTO tab1 VALUES（EMPTY_CLOB（））</pre></div>
                     <div class="infoboxnotealso" id="GUID-7A401AB9-FFFB-49B9-86FE-BEFFBF0EF438__GUID-14437FF9-0A4E-4D62-AFF1-1A8975209151">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="lob-functions.html#GUID-63F75EC5-EB14-4E25-B593-270FF814615A" title="创建一个临时LOB。">OCILobCreateTemporary（）</a></p>
                           </li>
                           <li>
                              <p><a href="lob-functions.html#GUID-E0FBF017-1B08-410C-9E53-F6E14008813A" title="释放临时LOB。">OCILobFreeTemporary（）</a></p>
                           </li>
                           <li>
                              <p><a href="lob-functions.html#GUID-404C8A50-516F-4DFD-939D-646A232AF7DF" title="将全部或部分LOB值复制到另一个LOB值。">OCILobCopy2（）</a></p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="LNOCI16524"></a><div class="props_rev_3"><a id="GUID-5291BFEA-E35C-4097-AC29-59D03166546A" name="GUID-5291BFEA-E35C-4097-AC29-59D03166546A"></a><h4 id="LNOCI-GUID-5291BFEA-E35C-4097-AC29-59D03166546A" class="sect4"><span class="enumeration_section">9.8.2</span>临时LOB持续时间</h4>
                  <div>
                     <p>OCI支持临时LOB的几个预定义持续时间，以及应用程序可用于定义特定于应用程序的持续时间的一组函数。</p>
                     <p>预定义的持续时间及其相关属性是：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>仅在服务器端调用<code class="codeph">OCI_DURATION_CALL</code></p>
                        </li>
                        <li>
                           <p>会话， <code class="codeph">OCI_DURATION_SESSION</code></p>
                        </li>
                     </ul>
                     <p>会话持续时间在包含会话或连接结束时到期。呼叫持续时间在当前OCI呼叫结束时到期。</p>
                     <p>在对象模式下运行时，还可以定义特定于应用程序的持续时间。特定于应用程序的持续时间（也称为用户持续时间）通过使用<code class="codeph">OCIDurationBegin()</code>指定持续时间的开始和使用<code class="codeph">OCIDurationBegin()</code>的持续时间结束来<code class="codeph">OCIDurationEnd()</code> 。
                     </p>
                     <div class="infoboxnote" id="GUID-5291BFEA-E35C-4097-AC29-59D03166546A__GUID-922A6C12-F5BF-4BA2-BDFB-1E1D596D22C1">
                        <p class="notep1">注意：</p>
                        <p>用户定义的持续时间仅在应用程序已在对象模式下初始化时可用。</p>
                     </div>
                     <p>每个应用程序的特定的持续时间具有由返回的持续时间识别符<code class="codeph">OCIDurationBegin()</code>并保证是唯一的，直到<code class="codeph">OCIDurationEnd()</code>被调用。特定于应用程序的持续时间可以与会话持续时间一样长。
                     </p>
                     <p>在持续时间结束时，释放与该持续时间相关联的所有临时LOB。必须使用<code class="codeph">OCIDescriptorFree()</code>调用显式释放与临时LOB关联的描述符。
                     </p>
                     <p>用户定义的持续时间可以嵌套;一个持续时间可以定义为另一个用户持续时间的子持续时间。父母持续时间可能具有具有其子女持续时间的子持续时间。</p>
                     <div class="infoboxnote" id="GUID-5291BFEA-E35C-4097-AC29-59D03166546A__GUID-EDF7A261-7692-43A6-8213-74C1FFCDDF98">
                        <p class="notep1">注意：</p>
                        <p>当使用<code class="codeph">OCIDurationBegin()</code>开始持续时间时，其中一个参数是父持续时间的标识符。当父级持续时间结束时，所有子持续时间也将结束。
                        </p>
                     </div>
                     <div class="infoboxnotealso" id="GUID-5291BFEA-E35C-4097-AC29-59D03166546A__GUID-30B26B9E-BC6D-412B-9BB6-85DF8124846C">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="cartridge-services-memory-services.html#GUID-7DE91342-CFF9-4227-8E67-58296C2C8F69" title="开始用户持续时间。">OCIDurationBegin（）</a></p>
                           </li>
                           <li>
                              <p><a href="cartridge-services-memory-services.html#GUID-23B6E6E2-FAB7-4862-A81E-25C94112E05E" title="终止用户持续时间。">OCIDurationEnd（）</a></p>
                           </li>
                           <li>
                              <p><a href="handle-and-descriptor-functions.html#GUID-A32BF051-3DC1-491C-AAFD-A46034DD1629" title="释放先前分配的描述符。">OCIDescriptorFree（）</a></p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="LNOCI16525"></a><div class="props_rev_3"><a id="GUID-19F5922C-3560-476B-B414-27F13B5C2BAC" name="GUID-19F5922C-3560-476B-B414-27F13B5C2BAC"></a><h4 id="LNOCI-GUID-19F5922C-3560-476B-B414-27F13B5C2BAC" class="sect4"><span class="enumeration_section">9.8.3</span>关于释放临时LOB</h4>
                  <div>
                     <p>每当您的OCI程序从SQL或PL / SQL获取LOB定位器时，请使用<code class="codeph">OCILobIsTemporary()</code>函数检查定位器是否是临时的。
                     </p>
                     <p>如果是，则在应用程序完成后使用<code class="codeph">OCILobFreeTemporary()</code>调用释放定位器。定位器可以在select或out绑定期间来自定义。临时LOB持续时间始终在发送到客户端时升级到会话持续时间。在定位器被下一行的定位器覆盖之前，应用程序必须执行以下操作：</p><pre class="oac_no_warn" dir="ltr">OCILobIsTemporary（env，err，locator，is_temporary）; if（is_temporary）OCILobFreeTemporary（svc，err，locator）;</pre><div class="infoboxnotealso" id="GUID-19F5922C-3560-476B-B414-27F13B5C2BAC__GUID-5B9D6058-CD86-4CFB-A493-78723F0D0540">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="lob-functions.html#GUID-071D8134-F9E7-4C5A-8E63-E90831FA7AC3" title="测试定位器是否指向临时LOB。">OCILobIsTemporary（）</a></p>
                           </li>
                           <li>
                              <p><a href="lob-functions.html#GUID-E0FBF017-1B08-410C-9E53-F6E14008813A" title="释放临时LOB。">OCILobFreeTemporary（）</a></p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="LNOCI16526"></a><div class="props_rev_3"><a id="GUID-793BD3A1-0D07-4A59-A9ED-CDF7A4976B5D" name="GUID-793BD3A1-0D07-4A59-A9ED-CDF7A4976B5D"></a><h4 id="LNOCI-GUID-793BD3A1-0D07-4A59-A9ED-CDF7A4976B5D" class="sect4"><span class="enumeration_section">9.8.4</span>分配指针时要小心</h4>
                  <div>
                     <p>分配<code class="codeph">OCILobLocator</code>指针时必须特别小心。
                     </p>
                     <p>指针赋值创建LOB的浅表副本。指针赋值后，源和目标LOB指向同一个数据副本。此行为与使用LOB API（如<code class="codeph">OCILobAssign()</code>或<code class="codeph">OCILobLocatorAssign()</code>执行分配不同。使用API时，定位器在分配后在逻辑上指向数据的独立副本。
                     </p>
                     <p>对于临时LOB，在指针赋值之前，必须确保<code class="codeph">OCILobFreeTemporary()</code>释放目标LOB定位器中的任何临时LOB。使用<code class="codeph">OCILobLocatorAssign()</code> ，在分配发生之前释放目标LOB定位器变量中的原始临时LOB（如果有）。
                     </p>
                     <p>在执行SQL语句时重用out-bind变量之前，必须使用<code class="codeph">OCILobFreeTemporary()</code>调用<code class="codeph">OCILobFreeTemporary()</code>现有out-bind LOB定位器缓冲区中的任何临时LOB。
                     </p>
                     <div class="infoboxnotealso" id="GUID-793BD3A1-0D07-4A59-A9ED-CDF7A4976B5D__GUID-67C193DC-A4E0-474C-BCFA-6CB36BAA2880">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>有关临时LOB性能指南的部分中的信息，请参阅<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/lnoci&amp;id=ADLOB105" target="_blank"><span><cite>Oracle Database SecureFiles和Large Objects Developer's Guide</cite></span></a></p>
                           </li>
                           <li>
                              <p><a href="../adlob/performance-guidelines.html#ADLOB106" target="_blank"><span><cite>Oracle Database SecureFiles和Large Objects Developer's Guide，</cite></span></a>用于讨论临时LOB的最佳性能</p>
                           </li>
                           <li>
                              <p><a href="lob-functions.html#GUID-B052C110-D039-44A1-85C6-F5CC7348E2DC" title="将一个LOB或BFILE定位器分配给另一个">OCILobAssign（）</a></p>
                           </li>
                           <li>
                              <p><a href="lob-functions.html#GUID-F7887376-4B3C-430C-94A3-11FE96E26627" title="将一个LOB或BFILE定位器分配给另一个。">OCILobLocatorAssign（）</a></p>
                           </li>
                           <li>
                              <p><a href="lob-functions.html#GUID-E0FBF017-1B08-410C-9E53-F6E14008813A" title="释放临时LOB。">OCILobFreeTemporary（）</a></p>
                           </li>
                           <li>
                              <p><a href="lob-functions.html#GUID-F7887376-4B3C-430C-94A3-11FE96E26627" title="将一个LOB或BFILE定位器分配给另一个。">OCILobLocatorAssign（）</a></p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="LNOCI72638"></a><a id="LNOCI16527"></a><div class="props_rev_3"><a id="GUID-8A0523FD-25E9-45AE-A623-CCB8940713D4" name="GUID-8A0523FD-25E9-45AE-A623-CCB8940713D4"></a><h4 id="LNOCI-GUID-8A0523FD-25E9-45AE-A623-CCB8940713D4" class="sect4"><span class="enumeration_section">9.8.5</span>临时LOB示例</h4>
                  <div>
                     <p>显示临时LOB的使用方式。</p>
                     <div class="section">
                        <p><a href="lobs-and-bfile-operations.html#GUID-8A0523FD-25E9-45AE-A623-CCB8940713D4__BGBDECFH">例9-3</a>显示了如何使用临时LOB。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-8A0523FD-25E9-45AE-A623-CCB8940713D4__BGBDECFH">
                        <p class="titleinexample">例9-3使用临时LOB</p><pre class="oac_no_warn" dir="ltr">#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;oci.h&gt; / * Function Prototype * / static void checkerr（/ * _ OCIError * errhp，sword status _ * / ）; sb4 select_and_createtemp（OCILobLocator * lob_loc，OCIError * errhp，OCISvcCtx * svchp，OCIStmt * stmthp，OCIEnv * envhp）; / *此函数从print_media表中读取单个视频帧。然后它创建一个临时LOB。创建的临时LOB通过CACHE读取，并在用户会话结束时自动清除，如果未及早明确释放。如果成功完成，则此函数返回OCI_SUCCESS;如果失败，则返回OCI_ERROR。* / sb4 select_and_createtemp（OCILobLocator * lob_loc，OCIError * errhp，OCISvcCtx * svchp，OCIStmt * stmthp，OCIEnv * envhp）{OCIDefine * defnp1; OCIBind * bndhp; text * sqlstmt; int rowind = 1; ub4 loblen = 0; OCILobLocator * tblob; printf（“在select_and_createtemp \ n”中）; if（OCIDescriptorAlloc（（void *）envhp，（void **）＆tblob，（ub4）OCI_DTYPE_LOB，（size_t）0，（void **）0））{printf（“select_and_createtemp \ n中的OCIDescriptor Alloc失败”）;返回OCI_ERROR; } / *任意选择Clip_ID = 1 * / sqlstmt =（text *）“SELECT Frame FROM print_media WHERE product_ID = 1 FOR UPDATE”; if（OCIStmtPrepare2（svchp，stmthp，errhp，sqlstmt，（ub4）strlen（（char *）sqlstmt），NULL，0，（ub4）OCI_NTV_SYNTAX，（ub4）OCI_DEFAULT））{（void）printf（“FAILED：OCIStmtPrepare（ ）sqlstmt \ n“）;返回OCI_ERROR; } / *定义BLOB * / if（OCIDefineByPos（stmthp，＆defnp1，errhp，（ub4）1，（void *）＆lob_loc，（sb4）0，（ub2）SQLT_BLOB，（void *）0，（ub2 *）0 ，（ub2 *）0，（ub4）OCI_DEFAULT））{（void）printf（“FAILED：选择定位器：OCIDefineByPos（）\ n”）;返回OCI_ERROR; } / *执行select和fetch one row * / if（OCIStmtExecute（svchp，stmthp，errhp，（ub4）1，（ub4）0，（CONST OCISnapshot *）0，（OCISnapshot *）0，（ub4）OCI_DEFAULT） ）{（void）printf（“FAILED：OCIStmtExecute（）sqlstmt \ n”）;返回OCI_ERROR; } if（OCILobCreateTemporary（svchp，errhp，tblob，（ub2）0，SQLCS_IMPLICIT，OCI_TEMP_BLOB，OCI_ATTR_NOCACHE，OCI_DURATION_SESSION））{（void）printf（“FAILED：CreateTemporary（）\ n”）;返回OCI_ERROR; if（OCILobGetLength（svchp，errhp，lob_loc，＆loblen）！= OCI_SUCCESS）{printf（“OCILobGetLength FAILED \ n”）;返回OCI_ERROR; } if（OCILobCopy（svchp，errhp，tblob，lob_loc，（ub4）loblen，（ub4）1，（ub4）1））{printf（“OCILobCopy FAILED \ n”）; } if（OCILobFreeTemporary（svchp，errhp，tblob））{printf（“FAILED：OCILobFreeTemporary call \ n”）;返回OCI_ERROR; } return OCI_SUCCESS; } int main（char * argv，int argc）{/ * OCI句柄* / OCIEnv * envhp; OCIServer * srvhp; OCISvcCtx * svchp; OCIError * errhp; OCISession * authp; OCIStmt * stmthp; OCILobLocator * clob，* blob; OCILobLocator * lob_loc; int type = 1; / *初始化并登录* / OCIEnvCreate（＆envhp，OCI_DEFAULT，（void *）0,0,0,0，（size_t）0，（void *）0）; （void）OCIHandleAlloc（（void *）envhp，（void **）＆errhp，OCI_HTYPE_ERROR，（size_t）0，（void **）0）; / * server contexts * /（void）OCIHandleAlloc（（void *）envhp，（void **）＆srvhp，OCI_HTYPE_SERVER，（size_t）0，（void **）0）; / * service context * /（void）OCIHandleAlloc（（void *）envhp，（void **）＆svchp，OCI_HTYPE_SVCCTX，（size_t）0，（void **）0）; / *附加到Oracle数据库* /（void）OCIServerAttach（srvhp，errhp，（text *）“”，strlen（“”），0）; / *在服务上下文中设置属性服务器上下文* /（void）OCIAttrSet（（void *）svchp，OCI_HTYPE_SVCCTX，（void *）srvhp，（ub4）0，OCI_ATTR_SERVER，（OCIError *）errhp）; （void）OCIHandleAlloc（（void *）envhp，（void **）＆authp，（ub4）OCI_HTYPE_SESSION，（size_t）0，（void **）0）; （void）OCIAttrSet（（void *）authp，（ub4）OCI_HTYPE_SESSION，（void *）“scott”，（ub4）5，（ub4）OCI_ATTR_USERNAME，errhp）; （void）OCIAttrSet（（void *）authp，（ub4）OCI_HTYPE_SESSION，（void *）“ <span class="italic">password</span> ”，（ub4）5，（ub4）OCI_ATTR_PASSWORD，errhp）; / *开始用户会话* / checkerr（errhp，OCISessionBegin（svchp，errhp，authp，OCI_CRED_RDBMS，（ub4）OCI_DEFAULT））; （void）OCIAttrSet（（void *）svchp，（ub4）OCI_HTYPE_SVCCTX，（void *）authp，（ub4）0，（ub4）OCI_ATTR_SESSION，errhp）; / * -------完成登录---------------------------------- * / / *分配语句句柄* / checkerr（errhp，OCIHandleAlloc（（void *）envhp，（void **）＆stmthp，OCI_HTYPE_STMT，（size_t）0，（void **）0））; checkerr（errhp，OCIDescriptorAlloc（（void *）envhp，（void **）＆lob_loc，（ub4）OCI_DTYPE_LOB，（size_t）0，（void **）0））; / *子程序调用从这里开始* / printf（“调用select_and_createtemp \ n”）; select_and_createtemp（lob_loc，errhp，svchp，stmthp，envhp）;返回0; } void checkerr（errhp，status）OCIError * errhp;剑的地位; {text errbuf [512]; sb4 errcode = 0; switch（status）{case OCI_SUCCESS：break; case OCI_SUCCESS_WITH_INFO：（void）printf（“Error  -  OCI_SUCCESS_WITH_INFO \ n”）;打破; case OCI_NEED_DATA：（void）printf（“Error  -  OCI_NEED_DATA \ n”）;打破; case OCI_NO_DATA：（void）printf（“Error  -  OCI_NODATA \ n”）;打破; case OCI_ERROR：（void）OCIErrorGet（（void *）errhp，（ub4）1，（text *）NULL，＆errcode，errbuf，（ub4）sizeof（errbuf），OCI_HTYPE_ERROR）; （void）printf（“Error  - ％。* s \ n”，512，errbuf）;打破; case OCI_INVALID_HANDLE：（void）printf（“Error  -  OCI_INVALID_HANDLE \ n”）;打破; case OCI_STILL_EXECUTING：（void）printf（“Error  -  OCI_STILL_EXECUTE \ n”）;打破; case OCI_CONTINUE：（void）printf（“Error  -  OCI_CONTINUE \ n”）;打破;默认值：break; }}</pre></div>
                     <!-- class="example" -->
                  </div>
               </div>
            </div><a id="LNOCI72639"></a><a id="LNOCI07100"></a><div class="props_rev_3"><a id="GUID-3F7FEAFF-F4EF-42CC-8F95-598D227C5D83" name="GUID-3F7FEAFF-F4EF-42CC-8F95-598D227C5D83"></a><h3 id="LNOCI-GUID-3F7FEAFF-F4EF-42CC-8F95-598D227C5D83" class="sect3"><span class="enumeration_section">9.9</span>预取LOB数据，长度和块大小</h3>
               <div>
                  <p>为了改进较小LOB的OCI访问，可以预取和缓存LOB数据，同时还获取定位器。</p>
                  <div class="section">
                     <p>这适用于内部LOB，临时LOB和<code class="codeph">BFILE</code> 。请按照以下步骤准备您的应用程序：</p>
                  </div>
                  <!-- class="section" -->
                  <ol>
                     <li><span>为会话句柄设置<code class="codeph">OCI_ATTR_DEFAULT_LOBPREFETCH_SIZE</code>属性。此属性的值指示LOB定位符的默认预取数据大小。此属性值允许预取在会话中提取的所有LOB定位符。此属性的默认值为零（不预取LOB数据）。此选项使应用程序开发人员无需为每个定义句柄设置预取LOB大小。您可以设置此属性或设置（在步骤3中） <code class="codeph">OCI_ATTR_LOBPREFETCH_SIZE</code> 。</span></li>
                     <li><span>执行准备并定义要执行的语句的步骤。</span></li>
                     <li><span>如果需要，可以通过为define句柄设置<code class="codeph">OCI_ATTR_LOBPREFETCH_SIZE</code>属性来<code class="codeph">OCI_ATTR_LOBPREFETCH_SIZE</code>要获取的LOB定位符的默认预取大小。此可选属性提供对从特定列提取的定位符的预取大小的控制。</span></li>
                     <li><span>将<code class="codeph">OCI_ATTR_LOBPREFETCH_LENGTH</code>属性设置为预取LOB长度和块大小。必须将第1项中描述的属性（ <code class="codeph">OCI_ATTR_LOBPREFETCH_SIZE</code> ）设置为<code class="codeph">TRUE</code>才能工作。</span></li>
                     <li><span>执行该语句。</span></li>
                     <li><span>使用单独的LOB定位符调用<a href="lob-functions.html#GUID-6AC6E6DA-236B-4BF9-942F-9FCC4178FEDA" title="将调用所指定的LOB或BFILE的一部分读入缓冲区。此函数必须用于大小超过4 GB的LOB。">OCILobRead2（）</a>或<a href="lob-functions.html#GUID-47652C79-0635-4595-A34B-CD03B7F81A9F" title="在一次往返中读取多个定位器的LOB数据。">OCILobArrayRead（）</a> ; OCI从预取缓冲区获取数据，进行必要的字符转换，并将数据复制到LOB读缓冲区（LOB语义没有变化）。如果请求的数据大于预取缓冲区，则需要额外的往返。</span></li>
                     <li><span>调用<a href="lob-functions.html#GUID-9BC0A78A-37CB-432F-AE2B-22C905608C4C" title="获取LOB的长度。此函数必须用于大小超过4 GB的LOB。">OCILobGetLength2（）</a>和<a href="lob-functions.html#GUID-ABB71585-172E-4F3E-A0CF-F70D709F2072" title="获取LOB的块大小。">OCILobGetChunkSize（）</a>以获取长度和块大小，而无需往返服务器。</span></li>
                  </ol>
                  <div class="example" id="GUID-3F7FEAFF-F4EF-42CC-8F95-598D227C5D83__BGBGCGCB">
                     <p class="titleinexample">例9-4预取LOB数据，长度和块大小</p><pre class="oac_no_warn" dir="ltr">...ub4 default_lobprefetch_size = 2000; / *将默认大小设置为2K * / .../ *将LOB预取属性设置为session * / OCIAttrSet（sesshp，（ub4）OCI_HTYPE_SESSION，（void *）＆default_lobprefetch_size，/ *属性值* / 0，/ *属性大小;不需要指定; * /（ub4）OCI_ATTR_DEFAULT_LOBPREFETCH_SIZE， errhp）; .../ * select statement * / char * stmt =“SELECT lob1 FROM lob_table”; .../ *声明并分配LOB定位器* / OCILobLocator * lob_locator; lob_locator = OCIDescriptorAlloc（...，OCI_DTYPE_LOB，...）; OCIDefineByPos（...，1，（void *）＆lob_locator，...，SQLT_CLOB，...）; .../ *将默认预取大小覆盖为4KB * / ub4 prefetch_size = 4000; OCIAttrSet（defhp，OCI_HTYPE_DEFINE，（void *）＆prefetch_size / * attr value * /，0 / *将预取大小限制为ub4 max val * /，OCI_ATTR_LOBPREFETCH_SIZE / * attr type * /，errhp）; .../ *设置预取长度属性* / boolean prefetch_length = TRUE; OCIAttrSet（defhp，OCI_HTYPE_DEFINE，（dvoid *）＆prefetch_length / * attr value * /，0，OCI_ATTR_LOBPREFETCH_LENGTH / * attr type * /，errhp）; .../ *执行语句。读取4KB的LOB数据并在描述符缓存缓冲区中进行*缓存。* / OCIStmtExecute（svchp，stmthp，errhp，1，/ * iters * / 0，/ *行偏移* / NULL，/ *快照IN * / NULL，/ *快照输出* / OCI_DEFAULT）; / *模式* / ...oraub8 char_amtp = 4000; oraub8 lob_len; ub4 chunk_size; / *从缓存中读取LOB块大小，长度和数据。没有往返。* / OCILobGetChunkSize（svchp，errhp，lob_locator，＆chunk_size）; OCILobGetLength2（svchp，errhp，lob_locator，＆lob_len）; OCILobRead2（svchp，errhp，lob_locator，NULL，＆char_amtp，...）; ...
</pre></div>
                  <!-- class="example" -->
                  <div class="section">
                     <p>请注意，预取大小是<code class="codeph">BLOB</code>和<code class="codeph">BFILE</code>的字节数以及<code class="codeph">CLOB</code>的字符数。
                     </p>
                     <p><a href="lobs-and-bfile-operations.html#GUID-3F7FEAFF-F4EF-42CC-8F95-598D227C5D83__BGBGCGCB">例9-4</a>显示了说明这些步骤的代码片段。
                     </p>
                     <p><span class="bold">预取高速缓存分配：</span>在获取LOB定位符时分配描述符的预取高速缓存缓冲区。分配的缓冲区大小由define句柄的<code class="codeph">OCI_ATTR_LOBPREFETCH_SIZE</code>属性确定;此属性的默认值由会话句柄的<code class="codeph">OCI_ATTR_DEFAULT_LOBPREFETCH_SIZE</code>属性值指示。如果已分配缓存缓冲区，则在需要时调整其大小。
                     </p>
                     <p>对于以下两个LOB API，如果源定位器具有高速缓存数据，则会分配或调整目标定位器高速缓存，并将高速缓存数据从源复制到目标。</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="lob-functions.html#GUID-B052C110-D039-44A1-85C6-F5CC7348E2DC" title="将一个LOB或BFILE定位器分配给另一个">OCILobAssign（）</a></p>
                        </li>
                        <li>
                           <p><a href="lob-functions.html#GUID-F7887376-4B3C-430C-94A3-11FE96E26627" title="将一个LOB或BFILE定位器分配给另一个。">OCILobLocatorAssign（）</a></p>
                        </li>
                     </ul>
                     <p>一旦分配，描述符本身被释放时释放描述符的缓存缓冲区内存。</p>
                     <p><span class="bold">预取高速缓存失效：</span>使用定位器更新LOB数据时，描述符的高速<span class="bold">缓存无效</span> 。这意味着缓存不再用于读取数据，并且定位器上的下一个<a href="lob-functions.html#GUID-6AC6E6DA-236B-4BF9-942F-9FCC4178FEDA" title="将调用所指定的LOB或BFILE的一部分读入缓冲区。此函数必须用于大小超过4 GB的LOB。">OCILobRead2（）</a>调用进行往返。
                     </p>
                     <p>以下LOB API使使用的描述符的预取高速缓存无效：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="deprecated-oci-functions.html#GUID-FD529B73-7D7B-4F93-BB01-4A4625503C36" title="在Oracle Database 11g第2版（11.2）之前的版本中不推荐使用此功能。">OCILobErase（）</a> （已弃用）</p>
                        </li>
                        <li>
                           <p><a href="lob-functions.html#GUID-264797B2-B3EA-4F6D-9A0E-BF8A4DDA13FA" title="从指定的偏移量开始擦除内部LOB数据的指定部分。">OCILobErase2（）</a></p>
                        </li>
                        <li>
                           <p><a href="deprecated-oci-functions.html#GUID-2D1D8F83-040B-4923-9F02-108D1F636B20" title="在Oracle Database 11g第2版（11.2）之前的版本中不推荐使用此功能。">OCILobTrim（）</a> （已弃用）</p>
                        </li>
                        <li>
                           <p><a href="lob-functions.html#GUID-ABDB1543-1782-4216-AD80-55FA82CFF733" title="将LOB值截断为较短的长度。此函数必须用于大小超过4 GB的LOB。">OCILobTrim2（）</a></p>
                        </li>
                        <li>
                           <p><a href="deprecated-oci-functions.html#GUID-CA0A90B9-0BB0-4017-AC53-996A102A7854" title="在Oracle Database 11g第2版（11.2）之前的版本中不推荐使用此功能。">OCILobWrite（）</a> （不建议使用）</p>
                        </li>
                        <li>
                           <p><a href="lob-functions.html#GUID-77F056CA-9EEE-4550-8A8E-0155DF994DBE" title="将缓冲区写入LOB。此函数必须用于大小超过4 GB的LOB。">OCILobWrite2（）</a></p>
                        </li>
                        <li>
                           <p><a href="deprecated-oci-functions.html#GUID-BC03A84A-5747-414F-9A79-BAAF0EE71EF8" title="在Oracle Database 11g第2版（11.2）之前的版本中不推荐使用此功能。">OCILobWriteAppend（）</a> （不建议使用）</p>
                        </li>
                        <li>
                           <p><a href="lob-functions.html#GUID-87D3275A-B042-4991-B261-AB531BB83CA2" title="从LOB结尾开始写入数据。此函数必须用于大小超过4 GB的LOB。">OCILobWriteAppend2（）</a></p>
                        </li>
                        <li>
                           <p><a href="lob-functions.html#GUID-10AB60C9-13FE-4CC9-9C62-CAD45DBB3B93">OCILobArrayWrite（）</a></p>
                        </li>
                     </ul>
                     <p>以下LOB API使目标LOB定位器的高速缓存无效：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="lob-functions.html#GUID-5B43FC88-A649-4764-8C1E-6D792F05F7CE" title="在指定的另一个LOB的末尾追加LOB值。">OCILobAppend（）</a></p>
                        </li>
                        <li>
                           <p><a href="deprecated-oci-functions.html#GUID-2E89A469-397B-45BD-871B-4A7E7A5815C1" title="在Oracle Database 11g第2版（11.2）之前的版本中不推荐使用此功能。">OCILobCopy（）</a> （已弃用）</p>
                        </li>
                        <li>
                           <p><a href="lob-functions.html#GUID-404C8A50-516F-4DFD-939D-646A232AF7DF" title="将全部或部分LOB值复制到另一个LOB值。">OCILobCopy2（）</a></p>
                        </li>
                        <li>
                           <p><a href="deprecated-oci-functions.html#GUID-87C6AE88-5E71-4D89-A2B8-B391BFF73AC6" title="在Oracle Database 11g第2版（11.2）之前的版本中不推荐使用此功能。">OCILobLoadFromFile（）</a> （不建议使用）</p>
                        </li>
                        <li>
                           <p><a href="lob-functions.html#GUID-DA1CD18B-7044-4E40-B1F4-4FCC1FCAB6C4" title="将全部或部分文件加载并复制到内部LOB中。此函数必须用于大小超过4 GB的LOB。">OCILobLoadFromFile2（）</a></p>
                        </li>
                     </ul>
                     <p><span class="bold">性能调整：</span>必须根据平均LOB大小和客户端内存来确定预取缓冲区大小。如果预取了大量数据，则必须确保内存可用性。性能增益对于预取大型LOB可能并不重要，因为与服务器往返的成本相比，获取数据的成本要高得多。
                     </p>
                     <p>您必须对LOB数据大小有一个合理的了解才能充分利用此LOB预取功能。由于参数是应用程序设计的一部分，因此必须重建应用程序，如果必须修改任何参数值。</p>
                     <p><span class="bold">升级：</span> LOB预取不能用于11.1之前的版本服务器，也不能用于针对11.1或更高版本服务器的11.1之前版本的客户端。当您将11.1之前的服务器与11.1或更高版本的客户端一起使用时， <a href="handle-and-descriptor-functions.html#GUID-3741D7BD-7652-4D7A-8813-AC2AEA8D3B03" title="设置句柄或描述符的属性值。">OCIAttrSet（）</a>将返回错误或错误信息，指出“服务器不支持此功能”。</p>
                     <div class="infoboxnotealso" id="GUID-3F7FEAFF-F4EF-42CC-8F95-598D227C5D83__GUID-9C92E1F6-7B26-4DC6-9D6F-AD82DBA53F57">
                        <p class="notep1">也可以看看：</p>
                        <p> </p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="handle-and-descriptor-attributes.html#GUID-FB263210-118E-4DB3-A840-1769EF0CB977__BAJJDCII">OCI_ATTR_DEFAULT_LOBPREFETCH_SIZE</a></p>
                           </li>
                           <li>
                              <p><a href="handle-and-descriptor-attributes.html#GUID-64F4D502-E9BE-4418-99A6-01899A4EBDAF__CHDECDDE">OCI_ATTR_LOBPREFETCH_LENGTH</a></p>
                           </li>
                           <li>
                              <p><a href="handle-and-descriptor-attributes.html#GUID-64F4D502-E9BE-4418-99A6-01899A4EBDAF__CHDJEBCB">OCI_ATTR_LOBPREFETCH_SIZE</a></p>
                           </li>
                        </ul>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div>
            </div><a id="LNOCI16528"></a><div class="props_rev_3"><a id="GUID-5DEEF1FA-0024-48B4-B587-506386EA5240" name="GUID-5DEEF1FA-0024-48B4-B587-506386EA5240"></a><h3 id="LNOCI-GUID-5DEEF1FA-0024-48B4-B587-506386EA5240" class="sect3"><span class="enumeration_section">9.10</span> SecureFiles LOB的选项</h3>
               <div>
                  <p>对于<span>SecureFiles</span> （具有<code class="codeph">STORE AS SECUREFILE</code>选项的LOB，它是在Oracle Database <span class="italic">11g</span>第1版中引入的），您可以在<code class="codeph">CREATE</code> <code class="codeph">TABLE</code>和<code class="codeph">ALTER</code> <code class="codeph">TABLE</code>语句中指定SQL参数<code class="codeph">DEDUPLICATE</code> 。
                  </p>
                  <p>通过此参数值，您可以指定LOB列中两行或更多行中相同的LOB数据共享相同的数据块，从而节省磁盘空间。<code class="codeph">KEEP_DUPLICATES</code>关闭此功能。以下选项也与<code class="codeph">SECUREFILE</code>一起<code class="codeph">SECUREFILE</code> ：</p>
                  <p>参数<code class="codeph">COMPRESS</code>打开LOB压缩。<code class="codeph">NOCOMPRESS</code>关闭了LOB压缩。
                  </p>
                  <p>参数<code class="codeph">ENCRYPT</code>打开LOB加密并可选择加密算法。<code class="codeph">NOENCRYPT</code>关闭LOB加密。每个LOB列都可以有自己的加密规范，与其他LOB或非LOB列的加密无关。有效算法是<code class="codeph">3DES168</code> ， <code class="codeph">AES128</code> ， <code class="codeph">AES192</code>和<code class="codeph">AES256</code> 。
                  </p>
                  <p>在版本11.1之前使用的LOBs范例是默认的。此默认LOBs范例现在也由<code class="codeph">STORE AS BASICFILE</code>选项显式设置。</p>
                  <p>以下OCI函数与<code class="codeph">SECUREFILE</code>功能一起使用：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><code class="codeph">OCILobGetOptions（）</code></p>
                     </li>
                     <li>
                        <p><code class="codeph">OCILobSetOptions（）</code></p>
                     </li>
                     <li>
                        <p><code class="codeph">OCILobGetContentType（）</code></p>
                     </li>
                     <li>
                        <p><code class="codeph">OCILobSetContentType（）</code></p>
                     </li>
                  </ul>
                  <div class="infoboxnotealso" id="GUID-5DEEF1FA-0024-48B4-B587-506386EA5240__GUID-B996D8C0-B14C-468F-BA74-769E149578F1">
                     <p class="notep1">也可以看看：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="../adlob/using-oracle-LOBs-storage.html#ADLOB4444" target="_blank"><span><cite>Oracle Database SecureFiles和Large Objects Developer's Guide</cite></span></a> ，了解相关SQL函数的完整详细信息以及对PL / SQL包的交叉引用以及有关迁移到<span>SecureFile</span>的信息</p>
                        </li>
                        <li>
                           <p><a href="lob-functions.html#GUID-E989E74D-F00C-476A-A8A5-D8E84F83F2F5" title="获取与给定SecureFile LOB的给定输入选项类型相对应的已启用设置。">OCILobGetOptions（）</a></p>
                        </li>
                        <li>
                           <p><a href="lob-functions.html#GUID-A6CCDD69-980B-423A-B6B4-BF75B8DBCC26" title="启用SecureFile LOB的选项设置。">OCILobSetOptions（）</a></p>
                        </li>
                        <li>
                           <p><a href="lob-functions.html#GUID-D62200EF-FA60-4788-950F-0C0686D807FD" title="获取SecureFile中数据的用户指定的内容类型字符串（如果已设置）。">OCILobGetContentType（）</a></p>
                        </li>
                        <li>
                           <p><a href="lob-functions.html#GUID-789C0971-76D5-4439-9379-E3DCE7885528" title="将SecureFile中的数据的内容类型字符串设置为可由应用程序使用的内容。">OCILobSetContentType（）</a></p>
                        </li>
                     </ul>
                     <p> </p>
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>