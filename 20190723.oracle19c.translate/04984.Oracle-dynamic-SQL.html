<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <title>Oracle动态SQL</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Programmer&#39;s Guide"></meta>
      <meta property="og:description" content=""></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Programmer&#39;s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="c-c-programmers-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-11T03:52:01-08:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="1996, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96467-01"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="C-Plus-Plus-Applications.html" title="Previous" type="text/html"></link>
      <link rel="next" href="ANSI-dynamic-SQL.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Pro*C/C++ Programmer&#39;s Guide"></meta>
    <meta name="dcterms.isVersionOf" content="LNPCC"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="C-Plus-Plus-Applications.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="ANSI-dynamic-SQL.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">程序员指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="applications.html" property="item" typeof="WebPage"><span property="name">应用</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">Oracle动态SQL</li>
            </ol>
            <a id="GUID-3B9E253A-F03D-431D-A77E-84C02C43F494" name="GUID-3B9E253A-F03D-431D-A77E-84C02C43F494"></a><a id="LNPCC3991"></a>
            
            <h2 id="LNPCC-GUID-3B9E253A-F03D-431D-A77E-84C02C43F494" class="sect2"><span class="enumeration_chapter">13</span> Oracle动态SQL</h2>
         </header>
         <div class="ind">
            <div>
               <p>本章介绍如何使用Oracle Dynamic SQL，这是一种高级编程技术，可为您的应用程序增加灵活性和功能。您将学习四种编写在运行时接受和处理SQL语句的程序的方法。本章包含以下主题：</p>
               <div class="infoboxnote" id="GUID-3B9E253A-F03D-431D-A77E-84C02C43F494__GUID-4932366D-E9D8-49FD-8490-59E0FB39DC60">
                  <p class="notep1">注意：</p>
                  <p>Oracle Dynamic SQL不支持对象类型，游标变量，结构数组，DML返回子句，Unicode变量和LOB。请改用ANSI Dynamic SQL方法4。</p>
               </div>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="Oracle-dynamic-SQL.html#GUID-E2A4E8F7-9986-45B1-9C0C-266B2ECC0AC2">什么是动态SQL？</a></p>
                  </li>
                  <li>
                     <p><a href="Oracle-dynamic-SQL.html#GUID-8379C305-7618-4573-BED4-5B1BB6986508">动态SQL的优缺点</a></p>
                  </li>
                  <li>
                     <p><a href="Oracle-dynamic-SQL.html#GUID-691DFEDC-68A6-416A-9EBA-BD13BAC6CE64">何时使用动态SQL</a></p>
                  </li>
                  <li>
                     <p><a href="Oracle-dynamic-SQL.html#GUID-6EB4BB7D-F50B-48F7-9889-9954FF899D06">动态SQL语句的要求</a></p>
                  </li>
                  <li>
                     <p><a href="Oracle-dynamic-SQL.html#GUID-C57DDC76-61C8-4CC7-93D1-E112030D84B1">如何处理动态SQL语句</a></p>
                  </li>
                  <li>
                     <p><a href="Oracle-dynamic-SQL.html#GUID-B2A1F2A9-46FC-4CF9-8FCE-763D77C441BD">使用动态SQL的方法</a></p>
                  </li>
                  <li>
                     <p><a href="Oracle-dynamic-SQL.html#GUID-3731826A-5EF8-4839-86FE-0C02E31313CD">使用方法1</a></p>
                  </li>
                  <li>
                     <p><a href="Oracle-dynamic-SQL.html#GUID-7B34257D-1DB8-4D5D-968B-4DA73F0683F2">使用方法2</a></p>
                  </li>
                  <li>
                     <p><a href="Oracle-dynamic-SQL.html#GUID-7D399AD7-79BA-4390-8A2D-C15D60BDEA24">使用方法3</a></p>
                  </li>
                  <li>
                     <p><a href="Oracle-dynamic-SQL.html#GUID-AFD0B0E4-4B76-4AA9-AA4D-1027A620634E">使用方法4</a></p>
                  </li>
                  <li>
                     <p><a href="Oracle-dynamic-SQL.html#GUID-0EB50EB7-D4C8-401D-AFCD-340D281711C4">关于使用DECLARE STATEMENT语句</a></p>
                  </li>
                  <li>
                     <p><a href="Oracle-dynamic-SQL.html#GUID-DA470F59-C45E-4C6E-8471-F6CFCEF96E89">关于使用PL / SQL</a></p>
                  </li>
                  <li>
                     <p><a href="Oracle-dynamic-SQL.html#GUID-EE96ED5E-CA49-46D1-ADE1-CF2911434EAC">动态SQL语句缓存</a></p>
                  </li>
               </ul>
            </div><a id="LNPCC3992"></a><div class="props_rev_3"><a id="GUID-E2A4E8F7-9986-45B1-9C0C-266B2ECC0AC2" name="GUID-E2A4E8F7-9986-45B1-9C0C-266B2ECC0AC2"></a><h3 id="LNPCC-GUID-E2A4E8F7-9986-45B1-9C0C-266B2ECC0AC2" class="sect3"><span class="enumeration_section">13.1</span>什么是动态SQL？
               </h3>
               <div>
                  <p>大多数数据库应用程序执行特定的工例如，一个简单的程序可能会提示用户输入员工编号，然后更新EMP和DEPT表中的行。在这种情况下，您知道在预编译时UPDATE语句的组成。也就是说，您知道可能更改哪些表，为每个表和列定义的约束，可能更新的列以及每列的数据类型。 <a id="d73629e116" class="indexterm-anchor"></a> 
                  </p>
                  <p>但是，某些应用程序必须在运行时接受（或构建）和处理各种SQL语句。例如，通用报表编写者必须为其生成的各种报表构建不同的SELECT语句。在这种情况下，语句的构成在运行时才会被识别。这些陈述可以并且可能会从执行变为执行。它们恰当地称为<span class="italic">动态</span> SQL语句。 <a id="d73629e126" class="indexterm-anchor"></a> 
                  </p>
                  <p>与静态SQL语句不同，动态SQL语句未嵌入源程序中。相反，它们存储在运行时输入或由程序构建的字符串中。它们可以交互式输入或从文件中读取。 <a id="d73629e133" class="indexterm-anchor"></a> 
                  </p>
               </div>
            </div><a id="LNPCC3993"></a><div class="props_rev_3"><a id="GUID-8379C305-7618-4573-BED4-5B1BB6986508" name="GUID-8379C305-7618-4573-BED4-5B1BB6986508"></a><h3 id="LNPCC-GUID-8379C305-7618-4573-BED4-5B1BB6986508" class="sect3"><span class="enumeration_section">13.2</span>动态SQL的优缺点</h3>
               <div>
                  <p>接受和处理动态定义的SQL语句的主机程序比普通的嵌入式SQL程序更通用。可以使用对SQL知之甚少或根本不了解的用户的输入以交互方式构建动态SQL语句。 <a id="d73629e162" class="indexterm-anchor"></a> 
                  </p>
                  <p>例如，您的程序可能只是提示用户在SELECT，UPDATE或DELETE语句的WHERE子句中使用搜索条件。更复杂的程序可能允许用户从列出SQL操作，表和视图名称，列名称等的菜单中进行选择。因此，动态SQL允许您编写高度灵活的应用程序。 <a id="d73629e169" class="indexterm-anchor"></a> 
                  </p>
                  <p>但是，一些动态查询需要复杂的编码，特殊数据结构的使用以及更多的运行时处理。虽然您可能没有注意到增加的处理时间，但除非您完全理解动态SQL概念和方法，否则您可能会发现编码很困难。</p>
               </div>
            </div><a id="LNPCC3994"></a><div class="props_rev_3"><a id="GUID-691DFEDC-68A6-416A-9EBA-BD13BAC6CE64" name="GUID-691DFEDC-68A6-416A-9EBA-BD13BAC6CE64"></a><h3 id="LNPCC-GUID-691DFEDC-68A6-416A-9EBA-BD13BAC6CE64" class="sect3"><span class="enumeration_section">13.3</span>何时使用动态SQL</h3>
               <div>
                  <p>实际上，静态SQL几乎可以满足您的所有编程需求。仅在需要开放式灵活性时才使用动态SQL。在预编译时未知以下项目之一时建议使用它： <a id="d73629e201" class="indexterm-anchor"></a> 
                  </p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>SQL语句的文本（命令，子句等）</p>
                     </li>
                     <li>
                        <p>主机变量的数量</p>
                     </li>
                     <li>
                        <p>主机变量的数据类型</p>
                     </li>
                     <li>
                        <p>对数据库对象的引用，例如列，索引，序列，表，用户名和视图</p>
                     </li>
                  </ul>
               </div>
            </div><a id="LNPCC3995"></a><div class="props_rev_3"><a id="GUID-6EB4BB7D-F50B-48F7-9889-9954FF899D06" name="GUID-6EB4BB7D-F50B-48F7-9889-9954FF899D06"></a><h3 id="LNPCC-GUID-6EB4BB7D-F50B-48F7-9889-9954FF899D06" class="sect3"><span class="enumeration_section">13.4</span>动态SQL语句的要求</h3>
               <div>
                  <p>要表示动态SQL语句，字符串必须包含有效SQL语句的文本，但<span class="italic">不</span>包含EXEC SQL子句，语句终止符或以下任何嵌入式SQL命令： <a id="d73629e246" class="indexterm-anchor"></a> 
                  </p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>分配</p>
                     </li>
                     <li>
                        <p>关</p>
                     </li>
                     <li>
                        <p>宣布</p>
                     </li>
                     <li>
                        <p>描述</p>
                     </li>
                     <li>
                        <p>执行</p>
                     </li>
                     <li>
                        <p>取</p>
                     </li>
                     <li>
                        <p>自由</p>
                     </li>
                     <li>
                        <p>得到</p>
                     </li>
                     <li>
                        <p>包括</p>
                     </li>
                     <li>
                        <p>打开</p>
                     </li>
                     <li>
                        <p>准备</p>
                     </li>
                     <li>
                        <p>组</p>
                     </li>
                     <li>
                        <p>每当</p>
                     </li>
                  </ul>
                  <p>在大多数情况下，字符串可以包含<span class="italic">虚拟</span>主机变量。它们在SQL语句中保存实际主机变量的位置。因为虚拟主机变量只是占位符，所以不要声明它们，并且可以将它们命名为任何您喜欢的名称。例如，Oracle不区分以下两个字符串： <a id="d73629e297" class="indexterm-anchor"></a><a id="d73629e301" class="indexterm-anchor"></a><a id="d73629e305" class="indexterm-anchor"></a><a id="d73629e309" class="indexterm-anchor"></a> 
                  </p><pre class="oac_no_warn" dir="ltr">'从EMP删除MGR =：mgr_number AND JOB =：job_title''从EMP删除MGR =：m AND JOB =：j'</pre></div>
            </div><a id="LNPCC3996"></a><div class="props_rev_3"><a id="GUID-C57DDC76-61C8-4CC7-93D1-E112030D84B1" name="GUID-C57DDC76-61C8-4CC7-93D1-E112030D84B1"></a><h3 id="LNPCC-GUID-C57DDC76-61C8-4CC7-93D1-E112030D84B1" class="sect3"><span class="enumeration_section">13.5</span>如何处理动态SQL语句</h3>
               <div>
                  <p>通常，应用程序会提示用户输入SQL语句的文本以及语句中使用的主机变量的值。然后Oracle解析SQL语句以确保它符合语法规则。</p>
                  <p>接下来，Oracle <span class="italic">将</span>主机变量<span class="italic">绑定</span>到SQL语句。也就是说，Oracle获取主机变量的地址，以便它可以读取或写入它们的值。 <a id="d73629e345" class="indexterm-anchor"></a><a id="d73629e350" class="indexterm-anchor"></a> 
                  </p>
                  <p>然后Oracle <span class="italic">执行</span> SQL语句。也就是说，Oracle执行SQL语句请求的内容，例如从表中删除行。
                  </p>
                  <p>可以使用主机变量的新值重复执行SQL语句。 <a id="d73629e362" class="indexterm-anchor"></a> 
                  </p>
               </div>
            </div><a id="LNPCC3998"></a><a id="LNPCC3997"></a><div class="props_rev_3"><a id="GUID-B2A1F2A9-46FC-4CF9-8FCE-763D77C441BD" name="GUID-B2A1F2A9-46FC-4CF9-8FCE-763D77C441BD"></a><h3 id="LNPCC-GUID-B2A1F2A9-46FC-4CF9-8FCE-763D77C441BD" class="sect3"><span class="enumeration_section">13.6</span>使用动态SQL的方法</h3>
               <div>
                  <p>本节介绍可用于定义动态SQL语句的四种方法。它简要描述了每种方法的功能和局限性，然后提供了选择正确方法的指南。后面的部分将向您展示如何使用这些方法，并包含您可以学习的示例程序。 <a id="d73629e391" class="indexterm-anchor"></a> 
                  </p>
                  <p>这四种方法越来越普遍。也就是说，方法2包括方法1，方法3包括方法1和2，等等。但是，每种方法对于处理某种SQL语句最有用，如<a href="Oracle-dynamic-SQL.html#GUID-B2A1F2A9-46FC-4CF9-8FCE-763D77C441BD__CHDGGGEB" title="使用动态SQL的方法">表13-1</a>所示：</p>
                  <div class="tblformal" id="GUID-B2A1F2A9-46FC-4CF9-8FCE-763D77C441BD__CHDGGGEB">
                     <p class="titleintable">表13-1使用动态SQL的方法</p>
                     <table cellpadding="4" cellspacing="0" class="Formal" title="使用动态SQL的方法" width="100%" border="1" summary="Methods for Using Dynamic SQL" frame="hsides" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="31%" id="d73629e413">方法</th>
                              <th align="left" valign="bottom" width="69%" id="d73629e416">一种SQL语句</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d73629e421" headers="d73629e413 ">
                                 <p>1</p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d73629e421 d73629e416 ">
                                 <p>没有主机变量的非查询</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d73629e428" headers="d73629e413 ">
                                 <p>2</p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d73629e428 d73629e416 ">
                                 <p>具有已知数量的输入主机变量的非查询</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d73629e435" headers="d73629e413 ">
                                 <p>3</p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d73629e435 d73629e416 ">
                                 <p>查询具有已知数量的选择列表项和输入主变量</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d73629e442" headers="d73629e413 ">
                                 <p>4</p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d73629e442 d73629e416 ">
                                 <p>查询具有未知数量的选择列表项或输入主变量</p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
                  <div class="infoboxnote" id="GUID-B2A1F2A9-46FC-4CF9-8FCE-763D77C441BD__GUID-DD2F8328-899F-4F5C-9F71-CCE4CB8A136C">
                     <p class="notep1">注意：</p>
                     <p>术语<span class="italic">select-list项</span>包括列名和表达式，例如SAL * 1.10和MAX（SAL）。
                     </p>
                  </div>
               </div><a id="LNPCC3999"></a><div class="props_rev_3"><a id="GUID-2D2A61F9-1FFD-469C-9AAC-D4CE4706FA17" name="GUID-2D2A61F9-1FFD-469C-9AAC-D4CE4706FA17"></a><h4 id="LNPCC-GUID-2D2A61F9-1FFD-469C-9AAC-D4CE4706FA17" class="sect4"><span class="enumeration_section">13.6.1</span>方法1</h4>
                  <div>
                     <p>此方法允许程序接受或构建动态SQL语句，然后使用EXECUTE IMMEDIATE命令立即执行它。SQL语句不能是查询（SELECT语句），并且不能包含输入主机变量的任何占位符。例如，以下主机字符串符合条件： <a id="d73629e478" class="indexterm-anchor"></a><a id="d73629e482" class="indexterm-anchor"></a> 
                     </p><pre class="oac_no_warn" dir="ltr">'从EMP删除DEPTNO = 20''选择EMP到斯科特'</pre><p>使用方法1，每次执行时都会解析SQL语句。</p>
                  </div>
               </div><a id="LNPCC4000"></a><div class="props_rev_3"><a id="GUID-D6F9D1EC-149C-4E07-A171-476A6E2A6254" name="GUID-D6F9D1EC-149C-4E07-A171-476A6E2A6254"></a><h4 id="LNPCC-GUID-D6F9D1EC-149C-4E07-A171-476A6E2A6254" class="sect4"><span class="enumeration_section">13.6.2</span>方法2</h4>
                  <div>
                     <p>此方法允许程序接受或构建动态SQL语句，然后使用PREPARE和EXECUTE命令对其进行处理。SQL语句不能是查询。必须在预编译时知道输入主机变量的占位符数和输入主机变量的数据类型。例如，以下主机字符串属于以下类别： <a id="d73629e515" class="indexterm-anchor"></a><a id="d73629e519" class="indexterm-anchor"></a> 
                     </p><pre class="oac_no_warn" dir="ltr">'INSERT INTO EMP（ENAME，JOB）VALUES（：emp_name，：job_title）''从EMP删除EMPNO =：emp_number'</pre><p>使用方法2，SQL语句只解析一次，但可以使用不同的主机变量值执行多次。SQL数据定义语句（如CREATE和GRANT）在PREPAREd时执行。 <a id="d73629e528" class="indexterm-anchor"></a> 
                     </p>
                  </div>
               </div><a id="LNPCC4001"></a><div class="props_rev_3"><a id="GUID-FB936021-B614-47DE-AAE8-F7E883E23F3E" name="GUID-FB936021-B614-47DE-AAE8-F7E883E23F3E"></a><h4 id="LNPCC-GUID-FB936021-B614-47DE-AAE8-F7E883E23F3E" class="sect4"><span class="enumeration_section">13.6.3</span>方法3</h4>
                  <div>
                     <p>此方法允许程序接受或构建动态查询，然后使用带有DECLARE，OPEN，FETCH和CLOSE游标命令的PREPARE命令处理它。必须在预编译时知道选择列表项的数量，输入主机变量的占位符数以及输入主机变量的数据类型。例如，以下主机字符串符合条件： <a id="d73629e558" class="indexterm-anchor"></a><a id="d73629e562" class="indexterm-anchor"></a> 
                     </p><pre class="oac_no_warn" dir="ltr">'按DEPTNO从EMP GROUP中选择DEPTNO，MIN（SAL），MAX（SAL）''选择ENAME，EMPNO从EMP到DEPTNO =：dept_number'</pre></div>
               </div><a id="LNPCC4002"></a><div class="props_rev_3"><a id="GUID-9E37CB4B-E53C-4A77-BD2A-69DE8E582C9D" name="GUID-9E37CB4B-E53C-4A77-BD2A-69DE8E582C9D"></a><h4 id="LNPCC-GUID-9E37CB4B-E53C-4A77-BD2A-69DE8E582C9D" class="sect4"><span class="enumeration_section">13.6.4</span>方法4</h4>
                  <div>
                     <p>此方法允许程序接受或构建动态SQL语句，然后使用描述符对其进行处理。在运行时之前，选择列表项的数量，输入主机变量的占位符数以及输入主机变量的数据类型可能是未知的。例如，以下主机字符串属于以下类别： <a id="d73629e593" class="indexterm-anchor"></a> 
                     </p><pre class="oac_no_warn" dir="ltr">'INSERT INTO EMP（&lt;unknown&gt;）VALUES（&lt;unknown&gt;）''SELECT &lt;unknown&gt; FROM EMP WHERE DEPTNO = 20'</pre><p>对于包含未知数量的选择列表项或输入主机变量的动态SQL语句，需要方法4。</p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="Oracle-dynamic-SQL.html#GUID-AFD0B0E4-4B76-4AA9-AA4D-1027A620634E">使用方法4</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div><a id="LNPCC4003"></a><div class="props_rev_3"><a id="GUID-FD213D0C-FEA9-40B8-900F-6E01E675D638" name="GUID-FD213D0C-FEA9-40B8-900F-6E01E675D638"></a><h4 id="LNPCC-GUID-FD213D0C-FEA9-40B8-900F-6E01E675D638" class="sect4"><span class="enumeration_section">13.6.5</span>指南</h4>
                  <div>
                     <p>使用所有四种方法，必须将动态SQL语句存储在字符串中，该字符串必须是主变量或带引号的文字。将SQL语句存储在字符串中时，省略关键字EXEC SQL和';'声明终结者。 <a id="d73629e635" class="indexterm-anchor"></a><a id="d73629e640" class="indexterm-anchor"></a> 
                     </p>
                     <p>使用方法2和3，必须在预编译时知道输入主变量的占位符数和输入主变量的数据类型。</p>
                     <p>每个后续方法对应用程序施加的约束较少，但编码起来更加困难。通常，使用最简单的方法。但是，如果方法1将重复执行动态SQL语句，请使用方法2来避免每次执行的重新分析。</p>
                     <p>方法4提供了最大的灵活性，但需要复杂的编码和对动态SQL概念的充分理解。通常，仅当您不能使用方法1,2或3时才使用方法4。</p>
                     <p><a href="Oracle-dynamic-SQL.html#GUID-5DBFF637-B95F-4648-B89F-45A577BDC80B__I13156">图13-1中</a>的决策逻辑将帮助您选择正确的方法。 <a id="d73629e655" class="indexterm-anchor"></a> 
                     </p>
                  </div><a id="LNPCC4005"></a><a id="LNPCC4004"></a><div class="props_rev_3"><a id="GUID-5DBFF637-B95F-4648-B89F-45A577BDC80B" name="GUID-5DBFF637-B95F-4648-B89F-45A577BDC80B"></a><h5 id="LNPCC-GUID-5DBFF637-B95F-4648-B89F-45A577BDC80B" class="sect5"><span class="enumeration_section">13.6.5.1</span>关于避免常见错误</h5>
                     <div>
                        <p>如果使用命令行选项DBMS = V6_CHAR进行预编译，请在存储SQL语句之前对数组进行空白填充。这样，你就清除了无关紧要的角色。当您将数组重用于不同的SQL语句时，这一点尤为重要。通常，在存储SQL语句之前始终初始化（或重新初始化）主机字符串。<span class="italic">不要</span>空终止主机字符串。Oracle不会将null终止符识别为字符串结尾的标记。相反，Oracle将其视为SQL语句的一部分。
                        </p>
                        <p>如果使用命令行选项DBMS = V8进行预编译，请确保在执行PREPARE或EXECUTE IMMEDIATE语句之前字符串为空终止。</p>
                        <p>无论DBMS的值如何，如果使用VARCHAR变量来存储动态SQL语句，请确保在执行PREPARE或EXECUTE IMMEDIATE语句之前正确设置（或重置）VARCHAR的长度。</p>
                        <div class="figure" id="GUID-5DBFF637-B95F-4648-B89F-45A577BDC80B__I13156">
                           <p class="titleinfigure">图13-1选择正确的方法</p><img src="img/lnpcc009.gif" width="496" alt="下面是图13-1的描述" title="下面是图13-1的描述" longdesc="img_text/lnpcc009.html"><br><a href="img_text/lnpcc009.html">“图13-1选择正确方法”的说明</a></div>
                        <!-- class="figure" -->
                     </div>
                  </div>
               </div>
            </div><a id="LNPCC4006"></a><div class="props_rev_3"><a id="GUID-3731826A-5EF8-4839-86FE-0C02E31313CD" name="GUID-3731826A-5EF8-4839-86FE-0C02E31313CD"></a><h3 id="LNPCC-GUID-3731826A-5EF8-4839-86FE-0C02E31313CD" class="sect3"><span class="enumeration_section">13.7</span>使用方法1</h3>
               <div>
                  <div class="section">
                     <p>最简单的动态SQL语句仅导致“成功”或“失败”，并且不使用主机变量。一些例子如下： <a id="d73629e722" class="indexterm-anchor"></a> 
                     </p><pre class="oac_no_warn" dir="ltr">'DELETE FROM table_name WHERE column_name = constant''CREATE TABLE table_name ...''DROP INDEX index_name''UPDATE table_name SET column_name = constant''GRANT SELECT ON table_name TO username''REVOKE RESOURCE FROM username'</pre><p>方法1解析，然后使用EXECUTE IMMEDIATE命令立即执行SQL语句。该命令后跟一个字符串（主机变量或文字），其中包含要执行的SQL语句，该语句不能是查询。</p>
                     <p>EXECUTE IMMEDIATE语句的语法如下： <a id="d73629e733" class="indexterm-anchor"></a><a id="d73629e737" class="indexterm-anchor"></a><a id="d73629e741" class="indexterm-anchor"></a> 
                     </p><pre class="oac_no_warn" dir="ltr">EXEC SQL EXECUTE IMMEDIATE {：host_string |字符串字面量 };</pre><p>在以下示例中，您使用主机变量<span class="italic">dyn_stmt</span>来存储用户输入的SQL语句：</p><pre class="oac_no_warn" dir="ltr">char dyn_stmt [132]; ...for（;;）{printf（“输入SQL语句：”）;得到（dyn_stmt）; if（* dyn_stmt =='\ 0'）中断; / * dyn_stmt现在包含SQL语句的文本* / EXEC SQL EXECUTE IMMEDIATE：dyn_stmt; } ...
</pre><p>您还可以使用字符串文字，如以下示例所示：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL EXECUTE IMMEDIATE'从MILLER中撤回资源';</pre><p>因为EXECUTE IMMEDIATE在每次执行之前解析输入SQL语句，所以方法1最适合仅执行一次的语句。数据定义语言语句通常属于此类别。</p>
                  </div>
                  <!-- class="section" -->
               </div><a id="LNPCC4007"></a><div class="props_rev_3"><a id="GUID-56E41F14-669F-4CFD-8672-601EE3EDAD62" name="GUID-56E41F14-669F-4CFD-8672-601EE3EDAD62"></a><h4 id="LNPCC-GUID-56E41F14-669F-4CFD-8672-601EE3EDAD62" class="sect4"><span class="enumeration_section">13.7.1</span>示例程序：动态SQL方法1</h4>
                  <div>
                     <div class="section">
                        <p>以下程序使用动态SQL方法1创建表，插入行，提交插入，然后删除表。该程序可在<code class="codeph">sample6.pc</code>文件的demo目录中<code class="codeph">sample6.pc</code> 。 <a id="d73629e789" class="indexterm-anchor"></a><a id="d73629e793" class="indexterm-anchor"></a> 
                        </p><pre class="oac_no_warn" dir="ltr">/ * * sample6.pc：动态SQL方法1 * *此程序使用动态SQL方法1创建表，*插入行，提交插入，然后删除表。* / #include &lt;stdio.h&gt; #include &lt;string.h&gt; / *包括SQL通讯区，通过*的结构，ORACLE为* *提供运行时状态信息，例如错误*代码，警告标志和诊断文本*程序。* / #include &lt;sqlca.h&gt; / *包括ORACLE通信区域，这是一个通过*的结构，ORACLE为程序提供了额外的运行时状态信息*。* / #include &lt;oraca.h&gt; / *必须指定ORACA = YES选项才能使*使用ORACA。 * / EXEC ORACLE选项（ORACA = YES）; / *指定RELEASE_CURSOR = YES选项指示Pro * C *在执行后释放与嵌入式SQL *语句关联的资源。这确保了* ORACLE在数据*操作操作之后不会对表保持解析锁定，因此对这些表的后续数据定义*操作不会导致解析锁定*错误。* / EXEC ORACLE选项（RELEASE_CURSOR = YES）; void dyn_error（）; main（）{/ *声明程序主机变量。* / char * username =“SCOTT”; char *密码=“TIGER”; char * dynstmt1; char dynstmt2 [10]; VARCHAR dynstmt3 [80]; / *如果发生ORACLE错误，则调用例程dyn_error（）。* / EXEC SQL WHENEVER SQLERROR DO dyn_error（“Oracle error：”）; / *如果发生*错误，则在ORACA中保存当前SQL语句的文本。* / oraca.orastxtf = ORASTFERR; / *连接到Oracle。* / EXEC SQL CONNECT：用户名IDENTIFIED BY：密码; puts（“\ n连接到ORACLE。\ n”）; / *执行字符串文字以创建表。此*用法实际上不是动态的，因为程序在运行时不确定SQL语句。* / puts（“CREATE TABLE dyn1（col1 VARCHAR2（4））”）; EXEC SQL EXECUTE IMMEDIATE“CREATE TABLE dyn1（col1 VARCHAR2（4））”; / *执行一个字符串以插入一行。该字符串必须*以null结尾。这种用法是动态的，因为* SQL语句是一个字符串变量，*程序可以在运行时确定其内容。* / dynstmt1 =“INSERT INTO DYN1值（'TEST'）”;放（dynstmt1）; EXEC SQL EXECUTE IMMEDIATE：dynstmt1; / *在字符串中执行SQL语句以提交插入。*用空格填充数组未使用的尾部。*不要空终止它。* / strncpy（dynstmt2，“COMMIT”，10）; printf（“％。10s \ n”，dynstmt2）; EXEC SQL EXECUTE IMMEDIATE：dynstmt2; / *执行VARCHAR以删除表。将.len字段*设置为.arr字段的长度。* / strcpy（dynstmt3.arr，“DROP TABLE DYN1”）; dynstmt3.len = strlen（dynstmt3.arr）; puts（（char *）dynstmt3.arr）; EXEC SQL EXECUTE IMMEDIATE：dynstmt3; / *提交任何未完成的更改并断开与Oracle的连接。* / EXEC SQL COMMIT RELEASE;放（“\ n祝你有个美好的一天！\ n“）; return 0;} void dyn_error（msg）char * msg; {/ *这是Oracle错误处理程序。*打印包含错误消息，*当前SQL语句和错误位置的诊断文本。* / printf（“\ n％。* s \ n”，sqlca.sqlerrm.sqlerrml，sqlca.sqlerrm.sqlerrmc）; printf（“in \”％。* s ... \'\ n“，oraca.orastxt.orastxtl，oraca.orastxt.orastxtc）; printf（”on。％d of％。* s。\ n \ n“ ，oraca.oraslnr，oraca.orasfnm.orasfnml，oraca.orasfnm.orasfnmc）; / *禁用Oracle错误检查以避免无限循环*如果此例程中发生另一个错误，则作为回滚结果。* / EXEC SQL WHENEVER SQLERROR CONTINUE; / *回滚任何挂起的更改并断开与Oracle的连接。* / EXEC SQL ROLLBACK RELEASE;出口（1）; }</pre></div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="LNPCC4008"></a><div class="props_rev_3"><a id="GUID-7B34257D-1DB8-4D5D-968B-4DA73F0683F2" name="GUID-7B34257D-1DB8-4D5D-968B-4DA73F0683F2"></a><h3 id="LNPCC-GUID-7B34257D-1DB8-4D5D-968B-4DA73F0683F2" class="sect3"><span class="enumeration_section">13.8</span>使用方法2</h3>
               <div>
                  <div class="section">
                     <p>方法1在一步中做了什么，方法2做了两个。动态SQL语句不能是查询，首先是PREPAREd（命名和解析），然后是EXECUTEd。</p>
                     <p>使用方法2，SQL语句可以包含输入主机变量和指示符变量的占位符。您可以一次PREPARE SQL语句，然后使用不同的主机变量值重复执行它。此外，你<span class="italic">不必</span> rePREPARE后COMMIT或ROLLBACK（除非你注销并重新连接）的SQL语句。 <a id="d73629e830" class="indexterm-anchor"></a><a id="d73629e834" class="indexterm-anchor"></a><a id="d73629e838" class="indexterm-anchor"></a><a id="d73629e842" class="indexterm-anchor"></a><a id="d73629e846" class="indexterm-anchor"></a> 
                     </p>
                     <p>您可以使用方法4将EXECUTE用于非查询。</p>
                     <p>PREPARE语句的语法如下：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL PREPARE statement_name FROM {：host_string |字符串字面量 };</pre><p>PREPARE解析SQL语句并为其命名。</p>
                     <p><span class="italic">statement_name</span>是预编译器使用的标识符， <span class="italic">而不是</span>主机或程序变量，不应在Declare Section中声明。它只是指定要执行的PREPAREd语句。</p>
                     <p>EXECUTE语句的语法是</p><pre class="oac_no_warn" dir="ltr">EXEC SQL EXECUTE statement_name [USING host_variable_list];</pre><p>其中<span class="italic">host_variable_list</span>代表以下语法：</p><pre class="oac_no_warn" dir="ltr">：host_variable1 [：indicator1] [，host_variable2 [：indicator2]，...]
</pre><p>EXECUTE使用为每个输入主机变量提供的值执行已解析的SQL语句。</p>
                     <p>在以下示例中，输入SQL语句包含占位符<span class="italic">n</span> ：</p><pre class="oac_no_warn" dir="ltr">...int emp_number INTEGER; char delete_stmt [120]，search_cond [40] ;; ...strcpy（delete_stmt，“DELETE FROM EMP WHERE EMPNO =：n AND”）; printf（“完成以下语句的搜索条件 -  \ n”）; printf（“％s \ n”，delete_stmt）;得到（search_cond）; strcat（delete_stmt，search_cond）; EXEC SQL PREPARE sql_stmt FROM：delete_stmt; for（;;）{printf（“输入员工编号：”）;得到（临时）; emp_number = atoi（temp）; if（emp_number == 0）中断; EXEC SQL EXECUTE sql_stmt USING：emp_number; } ...
</pre><p>使用方法2，您必须在预编译时知道输入主机变量的数据类型。在最后一个示例中， <span class="italic">emp_number</span>被声明为<span class="bold">int</span> 。它也可以声明为<span class="bold">float</span>类型，甚至是<span class="bold">char</span> ，因为Oracle支持所有这些数据类型转换为内部Oracle NUMBER数据类型。
                     </p>
                  </div>
                  <!-- class="section" -->
               </div><a id="LNPCC4009"></a><div class="props_rev_3"><a id="GUID-B41E02AD-D30C-46C5-8897-1B8CE466F0AD" name="GUID-B41E02AD-D30C-46C5-8897-1B8CE466F0AD"></a><h4 id="LNPCC-GUID-B41E02AD-D30C-46C5-8897-1B8CE466F0AD" class="sect4"><span class="enumeration_section">13.8.1</span>使用条款</h4>
                  <div>
                     <p>当SQL语句为EXECUTEd时，USING子句中的输入主机变量将替换PREPAREd动态SQL语句中的相应占位符。 <a id="d73629e926" class="indexterm-anchor"></a><a id="d73629e930" class="indexterm-anchor"></a> 
                     </p>
                     <p>PREPAREd动态SQL语句中的每个占位符都必须与USING子句中的不同主机变量相对应。因此，如果相同的占位符在PREPAREd语句中出现两次或多次，则每个外观必须对应于USING子句中的主变量。 <a id="d73629e937" class="indexterm-anchor"></a> 
                     </p>
                     <p>占位符的名称不需要与主变量的名称匹配。但是，PREPAREd动态SQL语句中占位符的顺序必须与USING子句中相应主机变量的顺序匹配。 <a id="d73629e944" class="indexterm-anchor"></a><a id="d73629e949" class="indexterm-anchor"></a> 
                     </p>
                     <p>如果USING子句中的一个主变量是一个数组，则所有主变量都必须是数组。</p>
                     <p>要指定NULL，可以将指示符变量与USING子句中的主变量相关联。</p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="embedded-SQL.html#GUID-22C65C80-42A1-4C8B-B883-19EFDF7AA31C">指标变量</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div><a id="LNPCC4010"></a><div class="props_rev_3"><a id="GUID-94FEF1CE-1B27-4344-A518-9052A1B519D5" name="GUID-94FEF1CE-1B27-4344-A518-9052A1B519D5"></a><h4 id="LNPCC-GUID-94FEF1CE-1B27-4344-A518-9052A1B519D5" class="sect4"><span class="enumeration_section">13.8.2</span>示例程序：动态SQL方法2</h4>
                  <div>
                     <div class="section">
                        <p>以下程序使用动态SQL方法2将两行插入EMP表，然后删除它们。该程序可在您的演示目录中的<code class="codeph">sample7.pc</code>文件中<code class="codeph">sample7.pc</code> 。 <a id="d73629e995" class="indexterm-anchor"></a><a id="d73629e999" class="indexterm-anchor"></a> 
                        </p><pre class="oac_no_warn" dir="ltr">/ * * sample7.pc：动态SQL方法2 * *该程序使用动态SQL方法2将两行插入到EMP表中，然后删除它们。* / #include &lt;stdio.h&gt; #include &lt;string.h&gt; #define USERNAME“SCOTT”#define PASSWORD“TIGER”/ *包括SQL通讯区，通过*的结构，ORACLE生成运行状态信息，如错误* *程序可用的代码，警告标志和诊断文本。* / #include &lt;sqlca.h&gt; / *包括ORACLE通信区域，这是一个通过*的结构，ORACLE为程序提供了额外的运行时状态信息*。* / #include &lt;oraca.h&gt; / *必须指定ORACA = YES选项才能使用* ORACA。 * / EXEC ORACLE选项（ORACA = YES）; char * username = USERNAME; char *密码=密码; VARCHAR dynstmt [80]; int empno = 1234; int deptno1 = 97; int deptno2 = 99; / *处理SQL运行时错误。* / void dyn_error（）; main（）{/ *每当发生错误时调用dyn_error（）*处理嵌入式SQL语句。* / EXEC SQL WHENEVER SQLERROR DO dyn_error（“Oracle错误”）; / *如果发生*错误，则在ORACA中保存当前SQL语句的文本。* / oraca.orastxtf = ORASTFERR; / *连接到Oracle。* / EXEC SQL CONNECT：用户名IDENTIFIED BY：密码; puts（“\ n连接到Oracle。\ n”）; / *将一个SQL语句分配给VARCHAR dynstmt。*数组和长度部分都必须正确设置。*请注意，该语句包含两个主机变量*占位符v1和v2，必须在EXECUTE时提供实际输入*主机变量。* / strcpy（dynstmt.arr，“INSERT INTO EMP（EMPNO，DEPTNO）VALUES（：v1，：v2）”）; dynstmt.len = strlen（dynstmt.arr）; / *显示SQL语句及其当前输入主机*变量。* / puts（（char *）dynstmt.arr）; printf（“v1 =％d，v2 =％d \ n”，empno，deptno1）; / * PREPARE语句将语句名称与*包含SQL语句的字符串相关联。语句名称*是SQL标识符，而不是主机变量，因此*不会出现在Declare Section中。*单个语句名称可以多次PREPAREd，*可选FROM不同的字符串变量。* / EXEC SQL PREPARE S FROM：dynstmt; / * EXECUTE语句执行PREPAREd SQL语句*使用指定的输入主机变量，* *位置替换* PREPAREd语句中的占位符。对于语句中每个*占位符的出现，USING子句中必须有一个变量*。也就是说，如果占位符在语句中多次出现，则相应的*变量必须在USING子句中多次出现。*仅当语句*不包含占位符时，才能省略USING子句。* *单个PREPAREd语句可以多次执行EXECUTEd，可选择使用不同的输入主机*变量。* / EXEC SQL EXECUTE S使用：empno，：deptno1; / *递增empno并显示新的输入主变量。* / empno ++; printf（“v1 =％d，v2 =％d \ n”，empno，deptno2）; / * ReEXECUTE S插入empno的新值和*不同的输入主变量deptno2。*不需要rePREPARE。* / EXEC SQL EXECUTE S使用：empno，：deptno2; / *为dynstmt分配一个新值。* / strcpy（dynstmt.arr，“DELETE FROM EMP WHERE DEPTNO =：v1 OR DEPTNO =：v2”）; dynstmt.len = strlen（dynstmt.arr）; / *显示新的SQL语句及其当前输入的主机*变量。* / puts（（char *）dynstmt.arr）; printf（“v1 =％d，v2 =％d \ n”，deptno1，deptno2）; / *从新dynstmt RePREPARE S。* / EXEC SQL PREPARE S FROM：dynstmt; / * EXECUTE新S删除之前*插入的两行。* / EXEC SQL EXECUTE S使用：deptno1，：deptno2; / *提交任何挂起的更改并断开与Oracle的连接。* / EXEC SQL COMMIT RELEASE;放（“\ n祝你有个美好的一天！\ n“）; exit（0）;} void dyn_error（msg）char * msg; {/ *这是ORACLE错误处理程序。*打印包含错误消息，*当前SQL语句和错误位置的诊断文本。* / printf（“\ n％s”，msg）; printf（“\ n％。* s \ n”，sqlca.sqlerrm.sqlerrml，sqlca.sqlerrm.sqlerrmc）; printf（“in \”％。* s ... \“\ n”，oraca.orastxt.orastxtl，oraca.orastxt.orastxtc）; printf（“on％d of％。* s。\ n \ n”，oraca.oraslnr，oraca.orasfnm.orasfnml，oraca.orasfnm.orasfnmc）; / *如果在此例程中发生另一个错误，则禁用ORACLE错误检查以避免无限循环*。* / EXEC SQL WHENEVER SQLERROR CONTINUE; / *回滚任何挂起的更改并*断开与Oracle的连接。* / EXEC SQL ROLLBACK RELEASE;出口（1）; }</pre></div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="LNPCC4011"></a><div class="props_rev_3"><a id="GUID-7D399AD7-79BA-4390-8A2D-C15D60BDEA24" name="GUID-7D399AD7-79BA-4390-8A2D-C15D60BDEA24"></a><h3 id="LNPCC-GUID-7D399AD7-79BA-4390-8A2D-C15D60BDEA24" class="sect3"><span class="enumeration_section">13.9</span>使用方法3</h3>
               <div>
                  <div class="section">
                     <p>方法3类似于方法2，但将PREPARE语句与定义和操作游标所需的语句组合在一起。这允许您的程序接受和处理查询。实际上，如果动态SQL语句是查询，则<span class="italic">必须</span>使用方法3或4。 <a id="d73629e1035" class="indexterm-anchor"></a> 
                     </p>
                     <p>对于方法3，必须在预编译时知道查询选择列表中的列数和输入主机变量的占位符数。但是，在运行时之前不需要指定数据库对象（如表和列）的名称。数据库对象的名称不能是主机变量。还可以在运行时指定限制，分组和排序查询结果（例如WHERE，GROUP BY和ORDER BY）的子句。</p>
                     <p>使用方法3，您可以使用以下嵌入式SQL语句序列： <a id="d73629e1044" class="indexterm-anchor"></a> 
                     </p><pre class="oac_no_warn" dir="ltr">PREPARE statement_name FROM {：host_string |字符串字面量 }; DECLARE cursor_name CURSOR FOR statement_name; OPEN cursor_name [USING host_variable_list]; FETCH cursor_name INTO host_variable_list; CLOSE cursor_name;</pre><p>可滚动游标也可以与方法3一起使用。必须将以下嵌入式SQL语句序列用于可滚动游标。</p><pre class="oac_no_warn" dir="ltr">PREPARE statement_name FROM {：host_string |字符串字面量 }; DECLARE cursor_name SCROLL CURSOR FOR statement_name; OPEN cursor_name [USING host_variable_list]; FETCH [FIRST | PRIOR | NEXT | LAST | CURRENT | RELATIVE fetch_offset | ABSOLUTE fetch_offset] cursor_name INTO host_variable_list; CLOSE cursor_name;</pre><p>现在我们来看看每个陈述的作用。</p>
                  </div>
                  <!-- class="section" -->
               </div><a id="LNPCC4012"></a><div class="props_rev_3"><a id="GUID-2DFF0BF6-7FBF-4F3C-A714-B33069B4C3DE" name="GUID-2DFF0BF6-7FBF-4F3C-A714-B33069B4C3DE"></a><h4 id="LNPCC-GUID-2DFF0BF6-7FBF-4F3C-A714-B33069B4C3DE" class="sect4"><span class="enumeration_section">13.9.1</span> PREPARE（动态SQL）</h4>
                  <div>
                     <p>PREPARE解析动态SQL语句并为其命名。在以下示例中，PREPARE解析存储在字符串<span class="italic">select_stmt中</span>的查询，并为其指定名称<span class="italic">sql_stmt</span> ： <a id="d73629e1087" class="indexterm-anchor"></a><a id="d73629e1091" class="indexterm-anchor"></a> 
                     </p><pre class="oac_no_warn" dir="ltr">char select_stmt [132] =“SELECT MGR，JOB FROM EMP WHERE SAL &lt;：salary”; EXEC SQL PREPARE sql_stmt FROM：select_stmt;</pre><p>通常，查询WHERE子句在运行时从终端输入或由应用程序生成。</p>
                     <p>标识符<span class="italic">sql_stmt</span> <span class="italic">不是</span>主机或程序变量，但必须是唯一的。它指定一个特定的动态SQL语句。
                     </p>
                     <p>以下陈述也是正确的：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL PREPARE sql_stmt FROM SELECT MGR，JOB FROM EMP WHERE SAL &lt;：salary;</pre><p>以下使用'％'通配符的prepare语句也是正确的：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL PREPARE S FROM select ename FROM test WHERE ename LIKE'SMIT％';</pre></div>
               </div><a id="LNPCC4013"></a><div class="props_rev_3"><a id="GUID-5219B97D-D587-4A6A-91E0-A959952FF4F0" name="GUID-5219B97D-D587-4A6A-91E0-A959952FF4F0"></a><h4 id="LNPCC-GUID-5219B97D-D587-4A6A-91E0-A959952FF4F0" class="sect4"><span class="enumeration_section">13.9.2</span> DECLARE（动态SQL）</h4>
                  <div>
                     <p>DECLARE通过为游标指定名称并将其与特定查询相关联来定义游标。继续我们的示例，DECLARE定义了一个名为<span class="italic">emp_cursor</span>的游标并将其与<span class="italic">sql_stmt</span>相关联，如下所示： <a id="d73629e1146" class="indexterm-anchor"></a><a id="d73629e1151" class="indexterm-anchor"></a> 
                     </p><pre class="oac_no_warn" dir="ltr">执行SQL DECLARE emp_cursor CURSOR FOR sql_stmt;</pre><p>标识符<span class="italic">sql_stmt</span>和<span class="italic">emp_cursor</span> <span class="italic">不是</span>主机或程序变量，但必须是唯一的。如果使用相同的语句名称声明两个游标，则预编译器会将两个游标名称视为同义。
                     </p>
                     <p>我们可以定义一个名为emp_cursor的可滚动游标，并将其与sql_stmt关联，如下所示：</p><pre class="oac_no_warn" dir="ltr">执行SQL DECLARE emp_cursor用于sql_stmt的SCROLL CURSOR;</pre><p></p>
                     <p>例如，如果执行语句</p><pre class="oac_no_warn" dir="ltr">EXEC SQL PREPARE sql_stmt FROM：select_stmt; EXEC SQL DECLARE emp_cursor FOR sql_stmt; EXEC SQL PREPARE sql_stmt FROM：delete_stmt; EXEC SQL DECLARE dept_cursor FOR sql_stmt;</pre><p>当您打开<span class="italic">emp_cursor时</span> ，您将处理存储在<span class="italic">delete_stmt</span>中的动态SQL语句，而不是存储在<span class="italic">select_stmt</span>中的动态SQL语句<span class="italic">。</span> 
                     </p>
                  </div>
               </div><a id="LNPCC4014"></a><div class="props_rev_3"><a id="GUID-5EB9A22F-6458-4719-A371-18DD4E87FB20" name="GUID-5EB9A22F-6458-4719-A371-18DD4E87FB20"></a><h4 id="LNPCC-GUID-5EB9A22F-6458-4719-A371-18DD4E87FB20" class="sect4"><span class="enumeration_section">13.9.3</span> OPEN（动态SQL）</h4>
                  <div>
                     <p>OPEN分配Oracle游标，绑定输入主机变量，并执行查询，识别其活动集。OPEN还将光标定位在活动集中的第一行，并将SQLCA中<span class="italic">sqlerrd</span>的第三个元素保留的行处理计数<span class="italic">归零</span> 。 USING子句中的输入主机变量替换PREPAREd动态SQL语句中的相应占位符。 <a id="d73629e1217" class="indexterm-anchor"></a><a id="d73629e1222" class="indexterm-anchor"></a> 
                     </p>
                     <p>在我们的示例中，OPEN分配<span class="italic">emp_cursor</span>并将主机变量<span class="italic">salary</span>分配给WHERE子句，如下所示：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL OPEN emp_cursor使用：salary;</pre></div>
               </div><a id="LNPCC4015"></a><div class="props_rev_3"><a id="GUID-9B7A9994-EA3E-466F-A643-5D310D97D556" name="GUID-9B7A9994-EA3E-466F-A643-5D310D97D556"></a><h4 id="LNPCC-GUID-9B7A9994-EA3E-466F-A643-5D310D97D556" class="sect4"><span class="enumeration_section">13.9.4</span> FETCH（动态SQL）</h4>
                  <div>
                     <p>FETCH从活动集返回一行，将选择列表中的列值分配给INTO子句中的相应主机变量，并将光标前进到下一行。如果没有更多行，FETCH将“无数据找到”Oracle错误代码返回给<span class="italic">sqlca.sqlcode</span> 。 <a id="d73629e1264" class="indexterm-anchor"></a><a id="d73629e1269" class="indexterm-anchor"></a> 
                     </p>
                     <p>在我们的示例中，FETCH从活动集返回一行，并将列MGR和JOB的值分配给主变量<span class="italic">mgr_number</span>和<span class="italic">job_title</span> ，如下所示：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL FETCH emp_cursor INTO：mgr_number，：job_title;</pre><p>如果光标在SCROLL模式下声明，则可以使用各种FETCH方向模式随机访问结果集。</p>
                  </div>
               </div><a id="LNPCC4016"></a><div class="props_rev_3"><a id="GUID-18D8152B-7BF8-46AE-8FCC-43FBE99F5574" name="GUID-18D8152B-7BF8-46AE-8FCC-43FBE99F5574"></a><h4 id="LNPCC-GUID-18D8152B-7BF8-46AE-8FCC-43FBE99F5574" class="sect4"><span class="enumeration_section">13.9.5</span> CLOSE（动态SQL）</h4>
                  <div>
                     <p>CLOSE禁用光标。关闭游标后，您将无法再使用它。</p>
                     <p>在我们的示例中，CLOSE禁用<span class="italic">emp_cursor</span> ，如下所示：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL CLOSE emp_cursor;</pre></div>
               </div><a id="LNPCC4017"></a><div class="props_rev_3"><a id="GUID-7B8B4966-B65A-4AF2-97D0-4886AA0A07D5" name="GUID-7B8B4966-B65A-4AF2-97D0-4886AA0A07D5"></a><h4 id="LNPCC-GUID-7B8B4966-B65A-4AF2-97D0-4886AA0A07D5" class="sect4"><span class="enumeration_section">13.9.6</span>示例程序：动态SQL方法3</h4>
                  <div>
                     <div class="section">
                        <p>以下程序使用动态SQL方法3从EMP表中检索给定部门中所有员工的名称。该程序可在您的演示目录中的<code class="codeph">sample8.pc</code>文件中在线获得<a id="d73629e1346" class="indexterm-anchor"></a><a id="d73629e1350" class="indexterm-anchor"></a> 
                        </p><pre class="oac_no_warn" dir="ltr">/ * * sample8.pc：动态SQL方法3 * *此程序使用动态SQL方法3从EMP表中检索给定部门中所有员工的姓名*。* / #include &lt;stdio.h&gt; #include &lt;string.h&gt; #define USERNAME“SCOTT”#define PASSWORD“TIGER”/ *包括SQL通讯区，通过*的结构，ORACLE生成运行状态信息，如错误* *程序可用的代码，警告标志和诊断文本。还包括ORACA。 * / #include &lt;sqlca.h&gt; #include &lt;oraca.h&gt; / *必须指定ORACA = YES选项才能使用* ORACA。 * / EXEC ORACLE选项（ORACA = YES）; char * username = USERNAME; char *密码=密码; VARCHAR dynstmt [80]; VARCHAR ename [10]; int deptno = 10; void dyn_error（）; main（）{/ *对嵌入式SQL语句中的任何错误调用dyn_error（）函数。* / EXEC SQL WHENEVER SQLERROR DO dyn_error（“Oracle错误”）; / *如果发生*错误，则在ORACA中保存SQL当前语句的文本。* / oraca.orastxtf = ORASTFERR; / *连接到Oracle。* / EXEC SQL CONNECT：用户名IDENTIFIED BY：密码; puts（“\ n连接到Oracle。\ n”）; / *将SQL查询分配给VARCHAR dynstmt。必须正确设置*数组和长度部分。注意*查询包含一个主机变量占位符* v1，在OPEN时必须为其提供实际输入主机变量*。* / strcpy（dynstmt.arr，“SELECT ename FROM emp WHERE deptno =：v1”）; dynstmt.len = strlen（dynstmt.arr）; / *显示SQL语句及其当前输入主机*变量。* / puts（（char *）dynstmt.arr）; printf（“v1 =％d \ n”，deptno）;的printf（ “\ nEmployee \ n”）;的printf（ “-------- \ n”）; / * PREPARE语句将语句名称与*包含SELECT语句的字符串相关联。语句* name是SQL标识符，而不是宿主变量，因此*不会出现在Declare Section中。*单个语句名称可以多次PREPAREd，*可选FROM不同的字符串变量。* / EXEC SQL PREPARE S FROM：dynstmt; / * DECLARE语句将游标与* PREPAREd语句相关联。游标名称（如语句* name）不会出现在Declare Section中。*单个游标名称不能多次DECLAREd。* / EXEC SQL DECLARE C CURSOR FOR S; / * OPEN语句使用指定的输入主机变量*来评估* PREPAREd查询的活动集，这些变量在* PREPAREd查询中的位置替换为占位符。对于语句中每个*占位符的出现，USING子句中必须有一个变量*。也就是说，如果占位符在语句中多次出现，则相应的*变量必须在USING子句中多次出现。*仅当语句*不包含占位符时，才能省略USING子句。OPEN将光标置于活动集的第一行以准备FETCH。 *单个DECLAREd游标可以多次打开，*可选地使用不同的输入主机变量。* / EXEC SQL OPEN C使用：deptno; / *在检索完所有数据后中断循环。* / EXEC SQL WHENEVER NOT FOUND DO break; / *循环直到检测到NOT FOUND条件。* / for（;;）{/ * FETCH语句将*当前行的选择列表放入INTO *子句指定的变量中，然后将光标前进到下一行。如果*有更多的select-list字段而不是输出host *变量，则不会返回额外的字段。*指定比select-list *字段更多的输出主机变量会导致ORACLE错误。* / EXEC SQL FETCH C INTO：ename; / *在输出之前终止数组。* / ename.arr [ename.len] ='\ 0'; puts（（char *）ename.arr）; } / *打印*当前SQL语句处理的累计行数。* / printf（“\ nQuery返回％d行％s。\ n \ n”，sqlca.sqlerrd [2]，（sqlca.sqlerrd [2] == 1）？“”：“s”）; / * CLOSE语句释放与*游标相关的资源。* / EXEC SQL CLOSE C; / *提交任何挂起的更改并断开与Oracle的连接。* / EXEC SQL COMMIT RELEASE;放（ “再见\ n”）;出口（0）; } void dyn_error（msg）char * msg; {printf（“\ n％s”，msg）; sqlca.sqlerrm.sqlerrmc [sqlca.sqlerrm.sqlerrml] ='\ 0'; oraca.orastxt.orastxtc [oraca.orastxt.orastxtl] ='\ 0'; oraca.orasfnm.orasfnmc [oraca.orasfnm.orasfnml] ='\ 0'; printf（“\ n％s \ n”，sqlca.sqlerrm.sqlerrmc）; printf（“in \”％s ... \“\ n”，oraca.orastxt.orastxtc）; printf（“％s上的％d。\ n \ n”，oraca.oraslnr，oraca.orasfnm.orasfnmc）; / *如果在此例程中发生另一个错误，则禁用ORACLE错误检查以避免无限循环*。* / EXEC SQL WHENEVER SQLERROR CONTINUE; / *释放与游标关联的资源。* / EXEC SQL CLOSE C; / *回滚任何挂起的更改并断开与Oracle的连接。* / EXEC SQL ROLLBACK RELEASE;出口（1）; }</pre></div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="LNPCC4018"></a><div class="props_rev_3"><a id="GUID-AFD0B0E4-4B76-4AA9-AA4D-1027A620634E" name="GUID-AFD0B0E4-4B76-4AA9-AA4D-1027A620634E"></a><h3 id="LNPCC-GUID-AFD0B0E4-4B76-4AA9-AA4D-1027A620634E" class="sect3"><span class="enumeration_section">13.10</span>使用方法4</h3>
               <div>
                  <div class="section">
                     <p>本节概述了Oracle Dynamic SQL方法4。Oracle Dynamic SQL方法4不支持对象类型，结果集，结构数组或LOB。</p>
                     <p>ANSI SQL支持所有数据类型。对所有新应用程序使用ANSI SQL。</p>
                     <p>您的程序无法使用方法3处理某种动态SQL语句。如果输入主机变量的选择列表项或占位符的数量在运行时之前是未知的，则程序必须使用描述符。<span class="italic">描述符</span>是程序和Oracle用于在动态SQL语句中保存变量的完整描述的内存区域。 <a id="d73629e1389" class="indexterm-anchor"></a><a id="d73629e1393" class="indexterm-anchor"></a><a id="d73629e1397" class="indexterm-anchor"></a> 
                     </p>
                     <p>回想一下，对于多行查询，您将FETCH选定的列值INTO到已声明的输出主机变量列表中。如果选择列表未知，则INTO子句无法在预编译时建立主机变量列表。例如，您知道以下查询返回两个列值：</p><pre class="oac_no_warn" dir="ltr">SELECT ename，empno FROM emp WHERE deptno =：dept_number;</pre><p>但是，如果您让用户定义选择列表，您可能不知道查询将返回多少列值。</p>
                  </div>
                  <!-- class="section" -->
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="ANSI-dynamic-SQL.html#GUID-BF450DA3-B05F-403E-B5DF-C967A20524BF">ANSI动态SQL</a></li>
                        <li><a href="Oracle-dynamic-SQL-method-4.html#GUID-B516B7C8-1859-4A54-B15D-DF0C3D3C474D">Oracle动态SQL：方法4</a></li>
                     </ul>
                  </div>
               </div>
               <a id="LNPCC4019"></a><div class="props_rev_3"><a id="GUID-126A218A-D65F-4442-BC69-38D1896A3441" name="GUID-126A218A-D65F-4442-BC69-38D1896A3441"></a><h4 id="LNPCC-GUID-126A218A-D65F-4442-BC69-38D1896A3441" class="sect4"><span class="enumeration_section">13.10.1</span>需要SQLDA</h4>
                  <div>
                     <p>要处理这种动态查询，您的程序必须发出DESCRIBE SELECT LIST命令并声明一个名为SQL Descriptor Area（SQLDA）的数据结构。因为它包含查询选择列表中列的描述，所以此结构也称为<span class="italic">选择描述符</span> 。<a id="d73629e1450" class="indexterm-anchor"></a><a id="d73629e1454" class="indexterm-anchor"></a><a id="d73629e1458" class="indexterm-anchor"></a><a id="d73629e1462" class="indexterm-anchor"></a><a id="d73629e1466" class="indexterm-anchor"></a><a id="d73629e1470" class="indexterm-anchor"></a><a id="d73629e1474" class="indexterm-anchor"></a><a id="d73629e1478" class="indexterm-anchor"></a></p>
                     <p>同样，如果动态SQL语句包含输入主机变量的未知数量的占位符，则USING子句无法在预编译时建立主机变量列表。</p>
                     <p>要处理动态SQL语句，程序必须发出DESCRIBE BIND VARIABLES命令并声明另一种称为<span class="italic">绑定描述符</span>的SQLDA，以保存输入主机变量占位符的描述。（输入主变量也称为<span class="italic">绑定变量</span> 。） <a id="d73629e1492" class="indexterm-anchor"></a><a id="d73629e1496" class="indexterm-anchor"></a><a id="d73629e1498" class="indexterm-anchor"></a> 
                     </p>
                     <p>如果您的程序有多个活动的SQL语句（例如，它可能打开了两个或更多个游标），则每个语句都必须有自己的SQLDA。但是，非并发游标可以重用SQLDA。程序中的SQLDA数量没有设置限制。</p>
                  </div>
               </div><a id="LNPCC4020"></a><div class="props_rev_3"><a id="GUID-EF4B376D-E13C-4D07-B60D-964B49957645" name="GUID-EF4B376D-E13C-4D07-B60D-964B49957645"></a><h4 id="LNPCC-GUID-EF4B376D-E13C-4D07-B60D-964B49957645" class="sect4"><span class="enumeration_section">13.10.2</span> DESCRIBE声明</h4>
                  <div>
                     <p>DESCRIBE初始化描述符以保存选择列表项或输入主变量的描述。</p>
                     <p>如果提供选择描述符，则DESCRIBE SELECT LIST语句将检查PREPAREd动态查询中的每个选择列表项，以确定其名称，数据类型，约束，长度，比例和精度。然后它将此信息存储在选择描述符中。 <a id="d73629e1532" class="indexterm-anchor"></a> 
                     </p>
                     <p>如果提供绑定描述符，则DESCRIBE BIND VARIABLES语句将检查PREPAREd动态SQL语句中的每个占位符，以确定其名称，长度以及其关联的输入主机变量的数据类型。然后，它将此信息存储在绑定描述符中供您使用。例如，您可以使用占位符名称来提示用户输入主机变量的值。 <a id="d73629e1539" class="indexterm-anchor"></a> 
                     </p>
                  </div>
               </div><a id="LNPCC4021"></a><div class="props_rev_3"><a id="GUID-CB7D9C2F-0892-4AFF-A5D2-7C3CDFC6361E" name="GUID-CB7D9C2F-0892-4AFF-A5D2-7C3CDFC6361E"></a><h4 id="LNPCC-GUID-CB7D9C2F-0892-4AFF-A5D2-7C3CDFC6361E" class="sect4"><span class="enumeration_section">13.10.3</span>什么是SQLDA？
                  </h4>
                  <div>
                     <p>SQLDA是一种主机程序数据结构，它包含选择列表项或输入主机变量的描述。 <a id="d73629e1568" class="indexterm-anchor"></a> 
                     </p>
                     <p>SQLDA变量<span class="italic">未</span>在Declare部分中定义。
                     </p>
                     <p>select SQLDA包含有关查询选择列表的以下信息： <a id="d73629e1580" class="indexterm-anchor"></a><a id="d73629e1584" class="indexterm-anchor"></a> 
                     </p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>可以DESCRIBEd的最大列数</p>
                        </li>
                        <li>
                           <p>DESCRIBE找到的实际列数</p>
                        </li>
                        <li>
                           <p>用于存储列值的缓冲区地址</p>
                        </li>
                        <li>
                           <p>列值的长度</p>
                        </li>
                        <li>
                           <p>列值的数据类型</p>
                        </li>
                        <li>
                           <p>指标变量值的地址</p>
                        </li>
                        <li>
                           <p>用于存储列名称的缓冲区地址</p>
                        </li>
                        <li>
                           <p>用于存储列名称的缓冲区大小</p>
                        </li>
                        <li>
                           <p>列名的当前长度</p>
                        </li>
                     </ul>
                     <p>绑定SQLDA包含有关SQL语句中的输入主机变量的以下信息：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>可以DESCRIBEd的最大占位符数</p>
                        </li>
                        <li>
                           <p>DESCRIBE找到的实际占位符数</p>
                        </li>
                        <li>
                           <p>输入主变量的地址</p>
                        </li>
                        <li>
                           <p>输入主机变量的长度</p>
                        </li>
                        <li>
                           <p>输入主机变量的数据类型</p>
                        </li>
                        <li>
                           <p>指标变量的地址</p>
                        </li>
                        <li>
                           <p>用于存储占位符名称的缓冲区地址</p>
                        </li>
                        <li>
                           <p>用于存储占位符名称的缓冲区大小</p>
                        </li>
                        <li>
                           <p>占位符名称的当前长度</p>
                        </li>
                        <li>
                           <p>用于存储指示符变量名称的缓冲区地址</p>
                        </li>
                        <li>
                           <p>用于存储指示符变量名称的缓冲区大小</p>
                        </li>
                        <li>
                           <p>指标变量名称的当前长度</p>
                           <div class="infoboxnotealso" id="GUID-CB7D9C2F-0892-4AFF-A5D2-7C3CDFC6361E__GUID-1F810159-0D1B-46B4-A38A-F0BE828120C2">
                              <p class="notep1">也可以看看：</p>
                              <p><a href="Oracle-dynamic-SQL-method-4.html#GUID-B516B7C8-1859-4A54-B15D-DF0C3D3C474D">Oracle Dynamic SQL：方法4，</a>用于获取有关SQLDA结构和变量名称的信息。
                              </p>
                           </div>
                        </li>
                     </ul>
                  </div>
               </div><a id="LNPCC4022"></a><div class="props_rev_3"><a id="GUID-4671C2D2-471C-4E6C-904B-A1B8DC6DA2CE" name="GUID-4671C2D2-471C-4E6C-904B-A1B8DC6DA2CE"></a><h4 id="LNPCC-GUID-4671C2D2-471C-4E6C-904B-A1B8DC6DA2CE" class="sect4"><span class="enumeration_section">13.10.4</span>关于实现Oracle方法4</h4>
                  <div>
                     <p>使用Oracle方法4，通常使用以下嵌入式SQL语句序列： <a id="d73629e1687" class="indexterm-anchor"></a> 
                     </p><pre class="oac_no_warn" dir="ltr">EXEC SQL PREPARE statement_name FROM {：host_string |字符串字面量 }; EXEC SQL DECLARE cursor_name CURSOR FOR statement_name;对于statement_name INTO bind_descriptor_name，EXEC SQL DESCRIBE BIND VARIABLES; EXEC SQL OPEN cursor_name [USING DESCRIPTOR bind_descriptor_name]; EXEC SQL DESCRIBE [SELECT LIST FOR] statement_name INTO select_descriptor_name; EXEC SQL FETCH cursor_name使用DESCRIPTOR select_descriptor_name; EXEC SQL CLOSE cursor_name;</pre><p>但是，select和bind描述符不需要串联工作。因此，如果查询选择列表中的列数已知，但输入主机变量的占位符数未知，则可以使用方法4 OPEN语句和以下方法3 FETCH语句：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL FETCH emp_cursor INTO host_variable_list;</pre><p>相反，如果已知输入主变量的占位符数，但选择列表中的列数未知，则可以使用方法3 OPEN语句</p><pre class="oac_no_warn" dir="ltr">EXEC SQL OPEN cursor_name [USING host_variable_list];</pre><p>使用Method 4 FETCH语句。</p>
                     <p>使用方法4，EXECUTE可用于非查询。</p>
                  </div>
               </div><a id="LNPCC4023"></a><div class="props_rev_3"><a id="GUID-D9A439AF-10AC-48CE-A5D6-107437285D74" name="GUID-D9A439AF-10AC-48CE-A5D6-107437285D74"></a><h4 id="LNPCC-GUID-D9A439AF-10AC-48CE-A5D6-107437285D74" class="sect4"><span class="enumeration_section">13.10.5</span>限制</h4>
                  <div>
                     <p>在动态SQL方法4中，您无法使用类型为“table”的参数将主机数组绑定到PL / SQL过程。</p>
                  </div>
               </div>
            </div><a id="LNPCC4024"></a><div class="props_rev_3"><a id="GUID-0EB50EB7-D4C8-401D-AFCD-340D281711C4" name="GUID-0EB50EB7-D4C8-401D-AFCD-340D281711C4"></a><h3 id="LNPCC-GUID-0EB50EB7-D4C8-401D-AFCD-340D281711C4" class="sect3"><span class="enumeration_section">13.11</span>关于使用DECLARE STATEMENT语句</h3>
               <div>
                  <p>使用方法2,3和4，您可能需要使用该语句<a id="d73629e1755" class="indexterm-anchor"></a><a id="d73629e1759" class="indexterm-anchor"></a><a id="d73629e1763" class="indexterm-anchor"></a><a id="d73629e1767" class="indexterm-anchor"></a> 
                  </p><pre class="oac_no_warn" dir="ltr">EXEC SQL [AT db_name] DECLARE statement_name STATEMENT;</pre><p>其中<span class="italic">db_name</span>和<span class="italic">statement_name</span>是预编译器使用的标识符， <span class="italic">而不是</span>主机或程序变量。
                  </p>
                  <p>DECLARE STATEMENT声明动态SQL语句的名称，以便PREPARE，EXECUTE，DECLARE CURSOR和DESCRIBE可以引用该语句。如果要在非默认数据库中执行动态SQL语句，则需要它。使用方法2的示例如下：<a id="d73629e1787" class="indexterm-anchor"></a><a id="d73629e1791" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">EXEC SQL AT remote_db DECLARE sql_stmt STATEMENT; EXEC SQL PREPARE sql_stmt FROM：dyn_string; EXEC SQL EXECUTE sql_stmt;</pre><p>在该示例中， <span class="italic">remote_db</span>告诉Oracle在哪里执行SQL语句。
                  </p>
                  <p>对于方法3和4，如果DECLARE CURSOR语句在PREPARE语句之前，则还需要DECLARE STATEMENT，如以下示例所示：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL DECLARE sql_stmt STATEMENT;执行SQL DECLARE emp_cursor CURSOR FOR sql_stmt; EXEC SQL PREPARE sql_stmt FROM：dyn_string;</pre><p>通常的陈述顺序是</p><pre class="oac_no_warn" dir="ltr">EXEC SQL PREPARE sql_stmt FROM：dyn_string;执行SQL DECLARE emp_cursor CURSOR FOR sql_stmt;</pre></div><a id="LNPCC4025"></a><div class="props_rev_3"><a id="GUID-7CABAD9B-7E8B-47D9-94D6-53E94D109867" name="GUID-7CABAD9B-7E8B-47D9-94D6-53E94D109867"></a><h4 id="LNPCC-GUID-7CABAD9B-7E8B-47D9-94D6-53E94D109867" class="sect4"><span class="enumeration_section">13.11.1</span>关于使用主机阵列</h4>
                  <div>
                     <p>在静态SQL和动态SQL中使用主机数组是类似的。例如，要将输入主机数组与动态SQL方法2一起使用，只需使用语法即可<a id="d73629e1834" class="indexterm-anchor"></a><a id="d73629e1838" class="indexterm-anchor"></a> 
                     </p><pre class="oac_no_warn" dir="ltr">EXEC SQL EXECUTE statement_name USING host_array_list;</pre><p>其中<span class="italic">host_array_list</span>包含一个或多个主机阵列。
                     </p>
                     <p>同样，要使用方法3的输入主机数组，请使用以下语法：</p><pre class="oac_no_warn" dir="ltr">OPEN cursor_name使用host_array_list;</pre><p>要使用方法3使用输出主机数组，请使用以下语法：</p><pre class="oac_no_warn" dir="ltr">FETCH cursor_name INTO host_array_list;</pre><p>使用方法4，必须使用可选的FOR子句告诉Oracle输入或输出主机阵列的大小。</p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="Oracle-dynamic-SQL-method-4.html#GUID-B516B7C8-1859-4A54-B15D-DF0C3D3C474D">Oracle动态SQL：方法4</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div>
            </div><a id="LNPCC4026"></a><div class="props_rev_3"><a id="GUID-DA470F59-C45E-4C6E-8471-F6CFCEF96E89" name="GUID-DA470F59-C45E-4C6E-8471-F6CFCEF96E89"></a><h3 id="LNPCC-GUID-DA470F59-C45E-4C6E-8471-F6CFCEF96E89" class="sect3"><span class="enumeration_section">13.12</span>关于使用PL / SQL</h3>
               <div>
                  <p>Pro * C / C ++预编译器将PL / SQL块视为单个SQL语句。因此，像SQL语句一样，PL / SQL块可以存储在字符串主变量或文字中。将PL / SQL块存储在字符串中时，省略关键字EXEC SQL EXECUTE，关键字END-EXEC和';'声明终结者。 <a id="d73629e1894" class="indexterm-anchor"></a><a id="d73629e1898" class="indexterm-anchor"></a> 
                  </p>
                  <p>但是，预编译器处理SQL和PL / SQL的方式有两点不同：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>预编译器将所有PL / SQL主变量视为<span class="italic">输入</span>主变量，无论它们是PL / SQL块内的输入还是输出主变量（或两者）。
                        </p>
                     </li>
                     <li>
                        <p>您无法从PL / SQL块进行FETCH，因为它可能包含任意数量的SQL语句。</p>
                     </li>
                  </ul>
               </div><a id="LNPCC4027"></a><div class="props_rev_3"><a id="GUID-AFA8AD6C-AE0C-426D-B14C-45DDB70BB718" name="GUID-AFA8AD6C-AE0C-426D-B14C-45DDB70BB718"></a><h4 id="LNPCC-GUID-AFA8AD6C-AE0C-426D-B14C-45DDB70BB718" class="sect4"><span class="enumeration_section">13.12.1</span>使用方法1</h4>
                  <div>
                     <p>如果PL / SQL块不包含主机变量，则可以使用方法1以常规方式执行PL / SQL字符串。 <a id="d73629e1939" class="indexterm-anchor"></a> 
                     </p>
                  </div>
               </div><a id="LNPCC4028"></a><div class="props_rev_3"><a id="GUID-F00D9323-E7F5-48A1-A37A-E54A6175DBB5" name="GUID-F00D9323-E7F5-48A1-A37A-E54A6175DBB5"></a><h4 id="LNPCC-GUID-F00D9323-E7F5-48A1-A37A-E54A6175DBB5" class="sect4"><span class="enumeration_section">13.12.2</span>使用方法2</h4>
                  <div>
                     <p>如果PL / SQL块包含已知数量的输入和输出主机变量，则可以使用方法2以常规方式PREPARE和EXECUTE PL / SQL字符串。 <a id="d73629e1968" class="indexterm-anchor"></a> 
                     </p>
                     <p>您必须将<span class="italic">所有</span>主变量放在USING子句中。当PL / SQL字符串为EXECUTEd时，USING子句中的主变量将替换PREPAREd字符串中的相应占位符。虽然预编译器将所有PL / SQL主机变量视为输入主机变量，但是值是正确分配的。输入（程序）值分配给输入主变量，输出（列）值分配给输出主变量。
                     </p>
                     <p>PREPAREd PL / SQL字符串中的每个占位符都必须与USING子句中的主机变量相对应。因此，如果相同的占位符在PREPAREd字符串中出现两次或多次，则每个外观必须对应于USING子句中的主机变量。 <a id="d73629e1980" class="indexterm-anchor"></a> 
                     </p>
                  </div>
               </div><a id="LNPCC4029"></a><div class="props_rev_3"><a id="GUID-4F8F4E5A-DF44-421A-8C83-D83483213DB8" name="GUID-4F8F4E5A-DF44-421A-8C83-D83483213DB8"></a><h4 id="LNPCC-GUID-4F8F4E5A-DF44-421A-8C83-D83483213DB8" class="sect4"><span class="enumeration_section">13.12.3</span>使用方法3</h4>
                  <div>
                     <p>除了方法3允许FETCHing之外，方法2和3是相同的。由于您无法从PL / SQL块进行FETCH，因此只需使用方法2即可。 <a id="d73629e2010" class="indexterm-anchor"></a> 
                     </p>
                  </div>
               </div><a id="LNPCC4030"></a><div class="props_rev_3"><a id="GUID-85B00EB5-791F-4ABA-9356-A042E960AF6A" name="GUID-85B00EB5-791F-4ABA-9356-A042E960AF6A"></a><h4 id="LNPCC-GUID-85B00EB5-791F-4ABA-9356-A042E960AF6A" class="sect4"><span class="enumeration_section">13.12.4</span>使用Oracle方法4</h4>
                  <div>
                     <p>如果PL / SQL块包含未知数量的输入或输出主机变量，则必须使用方法4。 <a id="d73629e2039" class="indexterm-anchor"></a> 
                     </p>
                     <p>要使用方法4，请为所有输入和输出主机变量设置一个绑定描述符。执行DESCRIBE BIND VARIABLES将有关输入<span class="italic">和</span>输出主机变量的信息存储在绑定描述符中。由于预编译器将所有PL / SQL主机变量视为输入主机变量，因此执行DESCRIBE SELECT LIST无效。
                     </p>
                     <div class="infoboxnotewarn" id="GUID-85B00EB5-791F-4ABA-9356-A042E960AF6A__GUID-79CC48E6-44E0-4DFE-9829-170DD83B496C">
                        <p class="notep1">警告：</p>
                        <p>在动态SQL方法4中，您无法使用类型为“table”的参数将主机数组绑定到PL / SQL过程。</p>
                     </div>
                     <div class="infoboxnotewarn" id="GUID-85B00EB5-791F-4ABA-9356-A042E960AF6A__GUID-F14B1294-D473-4E35-A025-F7515677F4FE">
                        <p class="notep1">警告：</p>
                        <p>不要在将动态处理的PL / SQL块中使用ANSI样式的注释（ -   - ），因为忽略了行尾字符。因此，ANSI样式的注释扩展到块的末尾，而不仅仅是行的末尾。相反，使用C风格的评论（/ * ...* /）。 <a id="d73629e2055" class="indexterm-anchor"></a><a id="d73629e2059" class="indexterm-anchor"></a> 
                        </p>
                     </div>
                     <p></p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="Oracle-dynamic-SQL-method-4.html#GUID-B516B7C8-1859-4A54-B15D-DF0C3D3C474D">Oracle动态SQL：方法4</a></li>
                        </ul>
                     </div>
                  </div>
               </div>
            </div><a id="LNPCC4032"></a><a id="LNPCC4031"></a><div class="props_rev_3"><a id="GUID-EE96ED5E-CA49-46D1-ADE1-CF2911434EAC" name="GUID-EE96ED5E-CA49-46D1-ADE1-CF2911434EAC"></a><h3 id="LNPCC-GUID-EE96ED5E-CA49-46D1-ADE1-CF2911434EAC" class="sect3"><span class="enumeration_section">13.13</span>动态SQL语句缓存</h3>
               <div>
                  <div class="section">
                     <p>语句缓存是指为每个会话提供和管理语句缓存的功能。在服务器中，这意味着可以使用游标，而无需再次解析语句。可以在预编译器应用程序中启用语句缓存，这将有助于提高依赖于动态SQL语句的所有应用程序的性能。通过消除在重用时解析动态语句的开销来实现性能改进。</p>
                     <p>您可以使用新的命令行选项<code class="codeph">stmt_cache</code> （对于语句高速缓存大小）来获得此性能改进，该选项将启用动态语句的语句高速缓存。通过启用新选项，将在会话创建时创建语句缓存。缓存仅适用于动态语句，静态语句的游标缓存与此功能共存。
                     </p>
                     <p>命令行选项<code class="codeph">stmt_cache</code>可以给出0到65535范围内的任何值。默认情况下禁用语句缓存（值0）。可以将<code class="codeph">stmt_cache</code>选项设置为保存应用程序中预期的不同动态SQL语句数。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-EE96ED5E-CA49-46D1-ADE1-CF2911434EAC__GUID-CEE8240B-2ED2-4936-98C9-EBF7975638A3">
                     <p class="titleinexample">示例13-1使用stmt_cache选项</p>
                     <p>此示例演示了<code class="codeph">stmt_cache</code>选项的<code class="codeph">stmt_cache</code> 。在此程序中，您将行插入表中，并使用循环中的光标选择插入的行。使用stmt_cache选项预编译此程序时，与正常的预编译相比，性能会提高。
                     </p><pre class="oac_no_warn" dir="ltr">/ * * stmtcache.pc * *注意：*当使用此程序测量带有和不带* stmt_cache选项的性能时，请在程序中执行以下更改，* 1。将ROWSCNT增加到高值，比如10000。* 2。删除所有打印语句，通常占总程序执行时间的重要*部分。* *提示：在Linux中，gettimeofday（）可用于测量时间。* / #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; #include &lt;sqlca.h&gt; #include &lt;oraca.h&gt; #define ROWSCNT 10 char * username =“scott”; char *密码=“老虎”; / *函数原型* / void sql_error（char * msg）; void selectdata（）; void insertdata（）; int main（）{EXEC SQL WHENEVER SQLERROR DO sql_error（“Oracle error”）; / *使用默认模式连接scott / tiger * / EXEC SQL CONNECT：username IDENTIFIED BY：password; / *核心函数插入和选择数据* / insertdata（）; selectdata（）; / *回滚pll更改并断开与Oracle的连接。* / EXEC SQL ROLLBACK工作版;出口（0）; / / *将ROWSCNT项的数据插入到tpc2sc01 * / void insertdata（）{varchar dynstmt [80]; int i; varchar ename [10];浮动通讯; char * str; / *分配临时缓冲区* / str =（char *）malloc（11 * sizeof（char））; strcpy（（char *）dynstmt.arr，“INSERT INTO bonus（ename，comm）VALUES（：ename，：comm）”）; dynstmt.len = strlen（dynstmt.arr）; EXEC SQL PREPARE S FROM：dynstmt; printf（“使用动态SQL语句将％d行插入奖励表\ n”，ROWSCNT）; for（i = 1; i &lt;= ROWSCNT; i ++）{sprintf（str，“EMP_％05d”，i）; strcpy（ename.arr，str）; comm = i; ename.len = strlen（ename.arr）; EXEC SQL EXECUTE S使用：ename，：comm; } free（str）; / *使用游标选择数据* / void selectdata（）{varchar dynstmt [80]; varchar ename [10];浮动通讯; int i; strcpy（（char *）dynstmt.arr，“SELECT ename，comm FROM bonus WHERE comm =：v1”）; dynstmt.len =（unsigned short）strlen（（char *）dynstmt.arr）; printf（“使用动态SQL语句获取插入的行\ n \ n”）; printf（“ENAME COMMISSION \ n \ n”）; for（i = 1; i &lt;= ROWSCNT; i ++）{/ *在循环中进行准备，以便stmt_caching的优势可见* / EXEC SQL PREPARE S FROM：dynstmt;用于S的EXEC SQL DECLARE C CURSOR; EXEC SQL OPEN C使用：i; EXEC SQL WHENEVER NOT FOUND DO break; / *循环直到检测到NOT FOUND条件。* / for（;;）{EXEC SQL FETCH C INTO：ename，：comm; ename.arr [ename.len] ='\ 0'; printf（“％10s％7.2f \ n”，ename.arr，comm）; } / *关闭游标，以便stmt_cache * / EXEC SQL CLOSE C不需要重新分析; void sql_error（char * msg）{printf（“\ n％s”，msg）; sqlca.sqlerrm.sqlerrmc [sqlca.sqlerrm.sqlerrml] ='\ 0'; oraca.orastxt.orastxtc [oraca.orastxt.orastxtl] ='\ 0'; oraca.orasfnm.orasfnmc [oraca.orasfnm.orasfnml] ='\ 0'; printf（“\ n％s \ n”，sqlca.sqlerrm.sqlerrmc）; printf（“in \”％s ... \“\ n”，oraca.orastxt.orastxtc）; printf（“％s上的％d。\ n \ n”，oraca.oraslnr，oraca.orasfnm.orasfnmc）; / *如果在此例程中发生另一个错误，则禁用ORACLE错误检查以避免无限循环*。* / EXEC SQL WHENEVER SQLERROR CONTINUE; / *释放与游标关联的资源。* / EXEC SQL CLOSE C; / *回滚任何挂起的更改并断开与Oracle的连接。* / EXEC SQL ROLLBACK工作版;出口（1）; }</pre></div>
                  <!-- class="example" -->
               </div>
            </div>
         </div>
      </article>
   </body>
</html>