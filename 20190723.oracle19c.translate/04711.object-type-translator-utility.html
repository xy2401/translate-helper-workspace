<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <title>对象类型转换器实用程序</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Programmer&#39;s Guide "></meta>
      <meta property="og:description" content=""></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Programmer&#39;s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="oracle-c-call-interface-programmers-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-03-06T02:31:59-08:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="1999, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96205-02"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="programming-with-lobs.html" title="Previous" type="text/html"></link>
      <link rel="next" href="globalization-and-unicode-support.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Oracle C++ Call Interface Programmer&#39;s Guide"></meta>
    <meta name="dcterms.isVersionOf" content="LNCPP"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="programming-with-lobs.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="globalization-and-unicode-support.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">程序员指南</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">对象类型转换器实用程序</li>
            </ol>
            <a id="GUID-72088FFE-4A01-4296-B207-10F2D3550318" name="GUID-72088FFE-4A01-4296-B207-10F2D3550318"></a><a id="LNCPP008"></a>
            
            <h2 id="LNCPP-GUID-72088FFE-4A01-4296-B207-10F2D3550318" class="sect2"><span class="enumeration_chapter">8</span>对象类型转换器实用程序</h2>
         </header>
         <div class="ind">
            <div>
               <p>本章讨论对象类型转换器（OTT）实用程序，该实用程序用于将数据库对象类型，LOB类型和命名集合类型映射到CCI类声明，以便在OCCI应用程序中使用。</p>
               <p>本章包含以下主题：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="object-type-translator-utility.html#GUID-6CEFB856-A10E-49EC-B379-C28FC06C7551">对象类型转换器实用程序概述</a></p>
                  </li>
                  <li>
                     <p><a href="object-type-translator-utility.html#GUID-985273B1-B82F-405A-9575-A5F87D18CA65">使用OTT实用程序</a></p>
                  </li>
                  <li>
                     <p><a href="object-type-translator-utility.html#GUID-AB0A022F-7EE1-422D-9036-BC3F7D96B858">在数据库中创建类型</a></p>
                  </li>
                  <li>
                     <p><a href="object-type-translator-utility.html#GUID-60EAEC6F-2F61-4FA1-BC58-85B00F32D8B3">关于调用OTT实用程序</a></p>
                  </li>
                  <li>
                     <p><a href="object-type-translator-utility.html#GUID-2B0C5750-97C8-41E7-BD07-F417598C5E9D">关于使用INTYPE文件</a></p>
                  </li>
                  <li>
                     <p><a href="object-type-translator-utility.html#GUID-3DC5D83D-331B-4BE6-820A-DC6330B68751">使用OTT实用程序数据类型映射</a></p>
                  </li>
                  <li>
                     <p><a href="object-type-translator-utility.html#GUID-B5D1FB85-549E-484A-B492-24ADE223C24E">OUTTYPE文件概述</a></p>
                  </li>
                  <li>
                     <p><a href="object-type-translator-utility.html#GUID-048D2653-6462-406A-A43C-26BF9B3FD6FD">使用OTT实用程序和OCCI应用程序</a></p>
                  </li>
                  <li>
                     <p><a href="object-type-translator-utility.html#GUID-497FB400-8E07-4810-B481-ADCCA703C1F9">继承用户添加的代码</a></p>
                  </li>
               </ul>
               <div class="infoboxnotealso" id="GUID-72088FFE-4A01-4296-B207-10F2D3550318__GUID-EBBFDFE2-3EA7-4463-8704-7F408F294614">
                  <p class="notep1">也可以看看：</p>
                  <p><code class="codeph">$</code> <span class="italic"><code class="codeph">ORACLE_HOME</code></span> <code class="codeph">/rdbms/demo</code>获取本章中使用的演示程序的完整代码清单，以及OTT实用程序生成的类和方法实现。
                  </p>
               </div>
            </div><a id="LNCPP20348"></a><div class="props_rev_3"><a id="GUID-6CEFB856-A10E-49EC-B379-C28FC06C7551" name="GUID-6CEFB856-A10E-49EC-B379-C28FC06C7551"></a><h3 id="LNCPP-GUID-6CEFB856-A10E-49EC-B379-C28FC06C7551" class="sect3"><span class="enumeration_section">8.1</span>对象类型转换器实用程序概述</h3>
               <div>
                  <p>对象类型转换器（OTT）实用程序有助于开发在Oracle数据库服务器中使用用户定义类型的应用程序。</p>
                  <p>您可以使用SQL <code class="codeph">CREATE TYPE</code>语句创建对象类型。这些类型的定义存储在数据库中，随后可用于创建数据库表。填充这些表后，OCCI程序员可以访问存储在表中的对象。
                  </p>
                  <p>访问对象数据的应用程序必须能够以宿主语言格式表示数据。这是通过在C ++中表示对象类型类来实现的。</p>
                  <p>您可以手动编写结构或类来表示数据库对象类型，但这非常耗时且容易出错。OTT实用程序通过自动为C ++生成适当的类来简化此步骤。</p>
                  <p>对于OCCI，应用程序必须包含并链接以下文件：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>包含包含生成的类声明的头文件</p>
                     </li>
                     <li>
                        <p>包含包含函数原型的头文件以注册映射</p>
                     </li>
                     <li>
                        <p>链接C ++源文件，其中包含OCCI在实例化对象时要调用的静态方法</p>
                     </li>
                     <li>
                        <p>链接包含函数的文件以注册与环境的映射并调用此函数</p>
                     </li>
                  </ul>
               </div>
            </div><a id="LNCPP20350"></a><a id="LNCPP20349"></a><div class="props_rev_3"><a id="GUID-985273B1-B82F-405A-9575-A5F87D18CA65" name="GUID-985273B1-B82F-405A-9575-A5F87D18CA65"></a><h3 id="LNCPP-GUID-985273B1-B82F-405A-9575-A5F87D18CA65" class="sect3"><span class="enumeration_section">8.2</span>使用OTT实用程序</h3>
               <div>
                  <div class="section">
                     <p>要将数据库类型转换为C ++表示，必须显式调用OTT实用程序。OCCI程序员必须在环境中注册映射。该功能由OTT实用程序生成。</p>
                     <p>在大多数操作系统上，在命令行上调用OTT实用程序。它将<code class="codeph">INTYPE</code>文件作为输入，并生成一个<code class="codeph">OUTTYPE</code>文件，一个或多个包含原型信息的C ++头文件，以及注册生成的映射的其他C ++方法文件。
                     </p>
                     <div class="infoboxnotealso" id="GUID-985273B1-B82F-405A-9575-A5F87D18CA65__GUID-D746BC51-7C10-4EBE-B496-A00B1FDB18DB">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="object-type-translator-utility.html#GUID-ACB9795D-378E-4D18-A31B-AA674410BE65">扩展C ++类</a>以获得完整的C ++示例</p>
                     </div>
                  </div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-985273B1-B82F-405A-9575-A5F87D18CA65__GUID-0AC92BAC-244C-44B8-B983-05B39624D9B3">
                     <p class="titleinexample">例8-1如何使用OTT实用程序</p>
                     <p>以下命令调用OTT实用程序并生成C ++类。OTT尝试连接用户名<code class="codeph">demousr</code> ;系统提示输入密码。
                     </p><pre class="oac_no_warn" dir="ltr">ott userid = demousr intype = demoin.typ outtype = demoout.typ code = cpp hfile = demo.h cppfile = demo.cpp mapfile = RegisterMappings.cpp</pre><p>OTT实用程序使用<code class="codeph">demoin.typ</code>文件作为<code class="codeph">INTYPE</code>文件，将<code class="codeph">demoout.typ</code>文件用作<code class="codeph">OUTTYPE</code>文件。生成的声明输出到C ++文件<code class="codeph">demo.h</code> ，由<code class="codeph">CODE=cpp</code>参数指定，方法实现写入文件<code class="codeph">demo.cpp</code> ，注册映射的函数写入<code class="codeph">RegisterMappings.cpp</code> ，其原型写入<code class="codeph">RegisterMappings.h</code> 。
                     </p>
                  </div>
                  <!-- class="example" -->
               </div>
            </div><a id="LNCPP20352"></a><a id="LNCPP20351"></a><div class="props_rev_3"><a id="GUID-AB0A022F-7EE1-422D-9036-BC3F7D96B858" name="GUID-AB0A022F-7EE1-422D-9036-BC3F7D96B858"></a><h3 id="LNCPP-GUID-AB0A022F-7EE1-422D-9036-BC3F7D96B858" class="sect3"><span class="enumeration_section">8.3</span>在数据库中创建类型</h3>
               <div>
                  <div class="section">
                     <p>使用OTT实用程序的第一步是创建对象类型或命名集合类型，并将它们存储在数据库中。这是通过SQL <code class="codeph">CREATE TYPE</code>语句完成的。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-AB0A022F-7EE1-422D-9036-BC3F7D96B858__GUID-DA5A70B1-6D03-4E87-9F62-852100843C34">
                     <p class="titleinexample">例8-2 OTT实用程序的对象创建语句</p><pre class="oac_no_warn" dir="ltr">CREATE TYPE FULL_NAME AS OBJECT（first_name CHAR（20），last_name CHAR（20））; CREATE TYPE ADDRESS AS OBJECT（状态CHAR（20），zip CHAR（20））;创建类型ADDRESS_TAB作为REF地址的变体（3）;创建类型人员作为对象（ID号，名称FULL_NAME，curr_addr REF ADDRESS，prev_addr_1 ADDRESS_TAB）NOT FINAL;创建学生类型学生（school_name CHAR（20））;</pre></div>
                  <!-- class="example" -->
               </div>
            </div><a id="LNCPP20353"></a><div class="props_rev_3"><a id="GUID-60EAEC6F-2F61-4FA1-BC58-85B00F32D8B3" name="GUID-60EAEC6F-2F61-4FA1-BC58-85B00F32D8B3"></a><h3 id="LNCPP-GUID-60EAEC6F-2F61-4FA1-BC58-85B00F32D8B3" class="sect3"><span class="enumeration_section">8.4</span>关于调用OTT实用程序</h3>
               <div>
                  <p>在数据库中创建类型后，下一步是调用OTT实用程序。</p>
                  <div class="p">本节包括以下主题：<ul style="list-style-type:disc">
                        <li>
                           <p><a href="object-type-translator-utility.html#GUID-F7DB9784-89D1-4AA8-A625-10E686CC9860">指定OTT参数</a></p>
                        </li>
                        <li>
                           <p><a href="object-type-translator-utility.html#GUID-05CDF705-35FE-4494-9636-F662B5F21D00">在命令行上调用OTT实用程序</a></p>
                        </li>
                        <li>
                           <p><a href="object-type-translator-utility.html#GUID-D462A1B9-D2C2-4A1A-BFF8-97E2FC8C578B">OTT实用程序参数</a></p>
                        </li>
                        <li>
                           <p><a href="object-type-translator-utility.html#GUID-77786ABB-AD5E-4FA1-9455-FFBC30DC1D86">OTT参数可以出现的地方</a></p>
                        </li>
                        <li>
                           <p><a href="object-type-translator-utility.html#GUID-A0881819-C788-439D-8DCB-2E3628FDD2EB">文件名比较限制</a></p>
                        </li>
                        <li>
                           <p><a href="object-type-translator-utility.html#GUID-8FC3C3F1-C21B-494C-859C-37F72409FE02">在Microsoft Windows上使用OTT命令</a></p>
                        </li>
                     </ul>
                  </div>
               </div><a id="LNCPP20354"></a><div class="props_rev_3"><a id="GUID-F7DB9784-89D1-4AA8-A625-10E686CC9860" name="GUID-F7DB9784-89D1-4AA8-A625-10E686CC9860"></a><h4 id="LNCPP-GUID-F7DB9784-89D1-4AA8-A625-10E686CC9860" class="sect4"><span class="enumeration_section">8.4.1</span>指定OTT参数</h4>
                  <div>
                     <div class="section">
                        <p>您可以在命令行或配置文件中指定OTT参数。某些参数也可以在<code class="codeph">INTYPE</code>文件中指定。
                        </p>
                        <p>如果在多个位置指定参数，则其在命令行上的值优先于其在<code class="codeph">INTYPE</code>文件中的值。<code class="codeph">INTYPE</code>文件中的值优先于用户定义的配置文件中的值，该文件优先于默认配置文件中的值。
                        </p>
                        <p>参数优先级如下：</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li><span>OTT命令行</span></li>
                        <li><span><code class="codeph">INTYPE</code>文件中的值</span></li>
                        <li><span>用户定义的配置文件</span></li>
                        <li><span>默认配置文件</span></li>
                     </ol>
                     <div class="section">
                        <p>对于全局选项（即命令行上的选项或任何<code class="codeph">TYPE</code>语句之前<code class="codeph">INTYPE</code>文件开头的选项），命令行上的值将覆盖<code class="codeph">INTYPE</code>文件中的值。（可以在<code class="codeph">INTYPE</code>文件中全局指定的选项是<code class="codeph">CASE</code> ， <code class="codeph">INITFILE</code> ， <code class="codeph">INITFUNC</code> ， <code class="codeph">MAPFILE</code>和<code class="codeph">MAPFUNC</code> ，但不是<code class="codeph">HFILE</code>或<code class="codeph">CPPFILE</code> 。）<code class="codeph">TYPE</code>规范中的<code class="codeph">INTYPE</code>文件中的任何内容仅适用于特定类型，并覆盖命令行上可能适用于该类型的任何内容。因此，如果输入<code class="codeph">TYPE person HFILE=ph</code> ，则它仅适用于<code class="codeph">person</code>并覆盖命令行上的<code class="codeph">HFILE</code> 。该语句不被视为命令行参数。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <div class="p">本节包括以下主题：<ul style="list-style-type:disc">
                              <li>
                                 <p><a href="object-type-translator-utility.html#GUID-F0C5A03C-03CD-4D20-97F7-6C5498638CAE">关于在命令行上设置参数</a></p>
                              </li>
                              <li>
                                 <p><a href="object-type-translator-utility.html#GUID-93043F2C-9181-40CD-AF79-7A0B6E96A986">关于在INTYPE文件中设置参数</a></p>
                              </li>
                              <li>
                                 <p><a href="object-type-translator-utility.html#GUID-586A860A-772D-4849-864E-F094F8D548A0">关于在配置文件中设置参数</a></p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div><a id="LNCPP20355"></a><div class="props_rev_3"><a id="GUID-F0C5A03C-03CD-4D20-97F7-6C5498638CAE" name="GUID-F0C5A03C-03CD-4D20-97F7-6C5498638CAE"></a><h5 id="LNCPP-GUID-F0C5A03C-03CD-4D20-97F7-6C5498638CAE" class="sect5"><span class="enumeration_section">8.4.1.1</span>关于在命令行上设置参数</h5>
                     <div>
                        <p>在命令行上设置的参数（也称为选项）会覆盖其他地方设置的任何参数或选项。</p>
                     </div>
                  </div><a id="LNCPP20356"></a><div class="props_rev_3"><a id="GUID-93043F2C-9181-40CD-AF79-7A0B6E96A986" name="GUID-93043F2C-9181-40CD-AF79-7A0B6E96A986"></a><h5 id="LNCPP-GUID-93043F2C-9181-40CD-AF79-7A0B6E96A986" class="sect5"><span class="enumeration_section">8.4.1.2</span>关于在INTYPE文件中设置参数</h5>
                     <div>
                        <p><code class="codeph">INTYPE</code>文件提供要翻译的OTT实用程序的类型列表。
                        </p>
                        <p>参数<code class="codeph">CASE</code> ， <code class="codeph">CPPFILE</code> ， <code class="codeph">HFILE</code> ， <code class="codeph">INITFILE</code> ， <code class="codeph">INITFUNC</code> ， <code class="codeph">MAPFILE</code>和<code class="codeph">MAPFUNC</code>可以出现在<code class="codeph">INTYPE</code>文件中。
                        </p>
                     </div>
                  </div><a id="LNCPP20357"></a><div class="props_rev_3"><a id="GUID-586A860A-772D-4849-864E-F094F8D548A0" name="GUID-586A860A-772D-4849-864E-F094F8D548A0"></a><h5 id="LNCPP-GUID-586A860A-772D-4849-864E-F094F8D548A0" class="sect5"><span class="enumeration_section">8.4.1.3</span>关于配置文件中的参数设置</h5>
                     <div>
                        <p>配置文件是包含OTT参数的文本文件。文件中的每个非空行包含一个参数及其关联的值。如果多个参数在同一行上，则仅使用第一个参数。配置文件的任何非空行都不允许有空格。</p>
                        <p>可以在命令行上命名配置文件。此外，始终读取默认配置文件。此默认配置文件必须始终存在，但可以为空。默认配置文件的名称是<code class="codeph">ottcfg.cfg</code> ，文件的位置是特定于操作系统的。
                        </p>
                        <div class="infoboxnotealso" id="GUID-586A860A-772D-4849-864E-F094F8D548A0__GUID-8E213F7C-2D08-44F2-9D39-959D276BD7E4">
                           <p class="notep1">也可以看看：</p>
                           <p>有关默认配置文件位置的详细信息，请参见特定于操作系统的文档。</p>
                        </div>
                     </div>
                  </div>
               </div><a id="LNCPP20359"></a><a id="LNCPP20358"></a><div class="props_rev_3"><a id="GUID-05CDF705-35FE-4494-9636-F662B5F21D00" name="GUID-05CDF705-35FE-4494-9636-F662B5F21D00"></a><h4 id="LNCPP-GUID-05CDF705-35FE-4494-9636-F662B5F21D00" class="sect4"><span class="enumeration_section">8.4.2</span>在命令行上调用OTT实用程序</h4>
                  <div>
                     <div class="section">
                        <p>在大多数平台上，在命令行上调用OTT实用程序。您可以在命令行中指定输入和输出文件以及数据库连接信息等。</p>
                        <div class="infoboxnotealso" id="GUID-05CDF705-35FE-4494-9636-F662B5F21D00__GUID-FECF1F2F-3370-457F-B5C1-C5B858D73D51">
                           <p class="notep1">也可以看看：</p>
                           <p>您的操作系统特定文档，以了解如何在操作系统上调用OTT实用程序</p>
                        </div>
                        <div class="infoboxnote" id="GUID-05CDF705-35FE-4494-9636-F662B5F21D00__GUID-3F34F521-A91E-42FE-823D-229BB663ADC3">
                           <p class="notep1">注意：</p>
                           <p>OTT命令行上的等号（ <code class="codeph">=</code> ）周围不允许有空格。
                           </p>
                        </div>
                        <p>OTT命令行语句由命令OTT组成，后跟OTT实用程序参数列表。</p>
                        <p>几乎总是使用<code class="codeph">HFILE</code>参数。如果省略，然后<code class="codeph">HFILE</code>必须单独在每种类型的指定<code class="codeph">INTYPE</code>文件。如果OTT实用程序确定必须翻译<code class="codeph">INTYPE</code>文件中未列出的类型，则会报告错误。因此，仅当<code class="codeph">INTYPE</code>文件先前作为OTT <code class="codeph">OUTTYPE</code>文件生成时，才能安全地省略<code class="codeph">HFILE</code>参数。
                        </p>
                        <p>如果省略<code class="codeph">INTYPE</code>文件，则翻译整个模式。有关详细信息，请参阅以下部分中的参数说明。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-05CDF705-35FE-4494-9636-F662B5F21D00__GUID-10DB08B2-8377-408F-AFF4-3B063CB2DE5F">
                        <p class="titleinexample">示例8-3如何调用OTT实用程序以生成C ++类</p>
                        <p>OTT尝试连接用户名<code class="codeph">demousr</code> ;系统提示输入密码。
                        </p><pre class="oac_no_warn" dir="ltr">ott userid = demousr intype = demoin.typ outtype = demoout.typ code = cpp hfile = demo.h cppfile = demo.cpp mapfile = RegisterMappings.cpp</pre></div>
                     <!-- class="example" -->
                     <div class="section">
                        <p>本节包括以下主题： <a href="object-type-translator-utility.html#GUID-3EE229DA-9EE4-40D4-A074-7B4E1FB2169C">OTT命令行上使用的元素</a> 。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div><a id="LNCPP20360"></a><div class="props_rev_3"><a id="GUID-3EE229DA-9EE4-40D4-A074-7B4E1FB2169C" name="GUID-3EE229DA-9EE4-40D4-A074-7B4E1FB2169C"></a><h5 id="LNCPP-GUID-3EE229DA-9EE4-40D4-A074-7B4E1FB2169C" class="sect5"><span class="enumeration_section">8.4.2.1</span> OTT命令行使用的元素</h5>
                     <div>
                        <p>OTT命令行中使用的元素是：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>调用OTT实用程序的OTT命令。它必须是命令行中的第一项。</p>
                           </li>
                           <li>
                              <p><a href="object-type-translator-utility.html#GUID-B4BB12D4-5527-4B83-B7E9-F1916BBC32EE">USERID</a>参数</p>
                           </li>
                           <li>
                              <p><a href="object-type-translator-utility.html#GUID-CF2AE1F7-49E8-4600-8103-534AE659FF1D">INTYPE</a>参数</p>
                           </li>
                           <li>
                              <p><a href="object-type-translator-utility.html#GUID-317685CC-A0F0-48E0-853E-DA7F6A3A7E9E">OUTTYPE</a>参数。
                              </p>
                           </li>
                           <li>
                              <p><a href="object-type-translator-utility.html#GUID-2158AA13-83C8-412A-8241-8F8893D03009">CODE</a>参数。
                              </p>
                           </li>
                           <li>
                              <p><a href="object-type-translator-utility.html#GUID-3D18CAD9-3650-4CB3-81ED-6C77D2A1EA03">HFILE</a>参数。
                              </p>
                           </li>
                           <li>
                              <p><a href="object-type-translator-utility.html#GUID-14386588-D5A8-4DCA-84D2-3CBCA18BE418">CPPFILE</a>参数。
                              </p>
                           </li>
                           <li>
                              <p><a href="object-type-translator-utility.html#GUID-7FBA0DB4-3C69-4DEA-8082-13C05552F299">MAPFILE</a>参数。
                              </p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="LNCPP20362"></a><a id="LNCPP20361"></a><div class="props_rev_3"><a id="GUID-D462A1B9-D2C2-4A1A-BFF8-97E2FC8C578B" name="GUID-D462A1B9-D2C2-4A1A-BFF8-97E2FC8C578B"></a><h4 id="LNCPP-GUID-D462A1B9-D2C2-4A1A-BFF8-97E2FC8C578B" class="sect4"><span class="enumeration_section">8.4.3</span> OTT实用程序参数</h4>
                  <div>
                     <div class="section">
                        <p>要使用OTT实用程序生成C ++，必须将<code class="codeph">CODE</code>参数设置为<code class="codeph">CODE=CPP</code> 。指定<code class="codeph">CODE=CPP</code> ，您需要指定<code class="codeph">CPPFILE</code>和<code class="codeph">MAPFILE</code>参数，以定义方法实现文件和映射注册函数文件的文件名。映射函数的名称由<code class="codeph">MAPFILE</code>实用程序从<code class="codeph">MAPFILE</code>或者您可以使用<code class="codeph">MAPFUNC</code>参数指定名称。<code class="codeph">ATTRACCESS</code>也是一个可选参数，可以指定它来更改生成的代码。这些参数控制C ++类的生成。
                        </p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>在OTT命令行上输入参数，其中<code class="codeph">parameter</code>是文字参数字符串， <code class="codeph">value</code>是有效参数设置。文字参数字符串不区分大小写：</p><pre class="oac_no_warn" dir="ltr">参数=值</pre></li>
                           <li>
                              <p>使用空格或制表符分隔命令行参数。</p>
                           </li>
                           <li>
                              <p>参数也可以出现在配置文件中，但在这种情况下，行内不允许有空格，并且每个参数必须出现在单独的行中。此外，参数<code class="codeph">CASE</code> ， <code class="codeph">CPPFILE</code> ， <code class="codeph">HFILE</code> ， <code class="codeph">INITFILE</code> ， <code class="codeph">INTFUNC</code> ， <code class="codeph">MAPFILE</code>和<code class="codeph">MAPFUNC</code>可以出现在<code class="codeph">INTYPE</code>文件中。
                              </p>
                           </li>
                        </ul>
                        <p><a href="object-type-translator-utility.html#GUID-D462A1B9-D2C2-4A1A-BFF8-97E2FC8C578B__BABBEIHG" title="该表有2列。第1列是参数名称，第2列是其描述">表8-1</a>列出了所有OTT Utility参数：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="tblformal" id="GUID-D462A1B9-D2C2-4A1A-BFF8-97E2FC8C578B__BABBEIHG">
                        <p class="titleintable">表8-1 OTT实用程序参数摘要</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="OTT实用程序参数摘要" width="100%" border="1" summary="This table has 2 columns. Column 1 is the parameter name and column 2 is its description" frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="30%" id="d65341e1302">参数</th>
                                 <th align="left" valign="bottom" width="70%" id="d65341e1305">描述</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="30%" id="d65341e1310" headers="d65341e1302 ">
                                    <p><a href="object-type-translator-utility.html#GUID-F2698DEF-6EA6-4026-9546-09F1CC24AE05">ATTRACCESS</a></p>
                                 </td>
                                 <td align="left" valign="top" width="70%" headers="d65341e1310 d65341e1305 ">
                                    <p>指定对类型属性的访问权限是<code class="codeph">PROTECTED</code>还是<code class="codeph">PRIVATE</code> 。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="30%" id="d65341e1324" headers="d65341e1302 ">
                                    <p><a href="object-type-translator-utility.html#GUID-30B1799D-8D84-4A72-A4B1-2FD0629166AC">案件</a></p>
                                 </td>
                                 <td align="left" valign="top" width="70%" headers="d65341e1324 d65341e1305 ">
                                    <p>影响生成的C ++标识符的字母大小写</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="30%" id="d65341e1332" headers="d65341e1302 ">
                                    <p><a href="object-type-translator-utility.html#GUID-2158AA13-83C8-412A-8241-8F8893D03009">码</a></p>
                                 </td>
                                 <td align="left" valign="top" width="70%" headers="d65341e1332 d65341e1305 ">
                                    <p>指定转换的目标语言。使用<code class="codeph">CPP</code> 。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="30%" id="d65341e1343" headers="d65341e1302 ">
                                    <p><a href="object-type-translator-utility.html#GUID-3C1A0D54-82C4-49C4-879A-DC5FCCE6B8F2">CONFIG</a></p>
                                 </td>
                                 <td align="left" valign="top" width="70%" headers="d65341e1343 d65341e1305 ">
                                    <p>指定列出常用参数规范的OTT配置文件的名称。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="30%" id="d65341e1351" headers="d65341e1302 ">
                                    <p><a href="object-type-translator-utility.html#GUID-14386588-D5A8-4DCA-84D2-3CBCA18BE418">CPPFILE</a></p>
                                 </td>
                                 <td align="left" valign="top" width="70%" headers="d65341e1351 d65341e1305 ">
                                    <p>指定编写方法实现的C ++源文件的名称。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="30%" id="d65341e1359" headers="d65341e1302 ">
                                    <p><a href="object-type-translator-utility.html#GUID-E96901DC-49A5-4CBB-AD5A-1C725FC61C08">ERRTYPE</a></p>
                                 </td>
                                 <td align="left" valign="top" width="70%" headers="d65341e1359 d65341e1305 ">
                                    <p>指定错误消息输出文件的名称。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="30%" id="d65341e1367" headers="d65341e1302 ">
                                    <p><a href="object-type-translator-utility.html#GUID-3D18CAD9-3650-4CB3-81ED-6C77D2A1EA03">HFILE</a></p>
                                 </td>
                                 <td align="left" valign="top" width="70%" headers="d65341e1367 d65341e1305 ">
                                    <p>指定生成的C ++类所写的C ++头文件的名称。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="30%" id="d65341e1375" headers="d65341e1302 ">
                                    <p><a href="object-type-translator-utility.html#GUID-CF2AE1F7-49E8-4600-8103-534AE659FF1D">输入法菜单</a></p>
                                 </td>
                                 <td align="left" valign="top" width="70%" headers="d65341e1375 d65341e1305 ">
                                    <p>指定<code class="codeph">INTYPE</code>文件的名称。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="30%" id="d65341e1386" headers="d65341e1302 ">
                                    <p><a href="object-type-translator-utility.html#GUID-7FBA0DB4-3C69-4DEA-8082-13C05552F299">MAPFILE</a></p>
                                 </td>
                                 <td align="left" valign="top" width="70%" headers="d65341e1386 d65341e1305 ">
                                    <p>指定映射文件的名称以及OTT实用程序生成的相应头文件。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="30%" id="d65341e1394" headers="d65341e1302 ">
                                    <p><a href="object-type-translator-utility.html#GUID-FFFBB8D5-1EC0-46DB-A838-2001B258D224">MAPFUNC</a></p>
                                 </td>
                                 <td align="left" valign="top" width="70%" headers="d65341e1394 d65341e1305 ">
                                    <p>指定用于注册生成的映射的函数的名称。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="30%" id="d65341e1402" headers="d65341e1302 ">
                                    <p><a href="object-type-translator-utility.html#GUID-317685CC-A0F0-48E0-853E-DA7F6A3A7E9E">OUTTYPE</a></p>
                                 </td>
                                 <td align="left" valign="top" width="70%" headers="d65341e1402 d65341e1305 ">
                                    <p>指定<code class="codeph">OUTTYPE</code>文件的名称。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="30%" id="d65341e1414" headers="d65341e1302 ">
                                    <p><a href="object-type-translator-utility.html#GUID-8D3EE31C-90B9-4681-BB8D-227658DCF5F9">SCHEMA_NAMES</a></p>
                                 </td>
                                 <td align="left" valign="top" width="70%" headers="d65341e1414 d65341e1305 ">
                                    <p>控制从默认架构中限定类型的数据库名称</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="30%" id="d65341e1422" headers="d65341e1302 ">
                                    <p><a href="object-type-translator-utility.html#GUID-6EAA11AD-1287-403B-87AF-C103F9D171A3">传递性</a></p>
                                 </td>
                                 <td align="left" valign="top" width="70%" headers="d65341e1422 d65341e1305 ">
                                    <p>指示是否转换未在<a href="object-type-translator-utility.html#GUID-CF2AE1F7-49E8-4600-8103-534AE659FF1D">INTYPE中</a>明确列出的类型依赖<a href="object-type-translator-utility.html#GUID-CF2AE1F7-49E8-4600-8103-534AE659FF1D">项</a> 。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="30%" id="d65341e1433" headers="d65341e1302 ">
                                    <p><a href="object-type-translator-utility.html#GUID-34F425D9-344F-4413-8909-3048DBCA6778">UNICODE</a></p>
                                 </td>
                                 <td align="left" valign="top" width="70%" headers="d65341e1433 d65341e1305 ">
                                    <p>指示应用程序是否应提供UTF16支持生成<code class="codeph">UString</code>类型。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="30%" id="d65341e1444" headers="d65341e1302 ">
                                    <p><a href="object-type-translator-utility.html#GUID-966D792F-9ADF-45B6-8EFD-7C3301B080E9">USE_MARKER</a></p>
                                 </td>
                                 <td align="left" valign="top" width="70%" headers="d65341e1444 d65341e1305 ">
                                    <p>指示是否应支持OTT标记以结转用户添加的cod</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="30%" id="d65341e1452" headers="d65341e1302 ">
                                    <p><a href="object-type-translator-utility.html#GUID-B4BB12D4-5527-4B83-B7E9-F1916BBC32EE">用户身份</a></p>
                                 </td>
                                 <td align="left" valign="top" width="70%" headers="d65341e1452 d65341e1305 ">
                                    <p>指定OTT实用程序使用的数据库连接信息。</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                  </div><a id="LNCPP20363"></a><div class="props_rev_3"><a id="GUID-F2698DEF-6EA6-4026-9546-09F1CC24AE05" name="GUID-F2698DEF-6EA6-4026-9546-09F1CC24AE05"></a><h5 id="LNCPP-GUID-F2698DEF-6EA6-4026-9546-09F1CC24AE05" class="sect5"><span class="enumeration_section">8.4.3.1</span>吸引力</h5>
                     <div>
                        <div class="section">
                           <p>此参数指定对类型属性的访问：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">PROTECTED</code>是默认值。
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">PRIVATE</code>表示OTT实用程序为每个类型属性生成附件和mutator方法， <code class="codeph">get</code> <span class="italic"><code class="codeph">XXX</code></span> <code class="codeph">()</code>并<code class="codeph">set</code> <span class="italic"><code class="codeph">XXX</code></span> <code class="codeph">()</code> 。
                                 </p>
                              </li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNCPP20364"></a><div class="props_rev_3"><a id="GUID-30B1799D-8D84-4A72-A4B1-2FD0629166AC" name="GUID-30B1799D-8D84-4A72-A4B1-2FD0629166AC"></a><h5 id="LNCPP-GUID-30B1799D-8D84-4A72-A4B1-2FD0629166AC" class="sect5"><span class="enumeration_section">8.4.3.2</span>案例</h5>
                     <div>
                        <div class="section">
                           <p>此参数会影响生成的C ++标识符的字母大小写。<code class="codeph">CASE</code>的有效值为：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>将数据库类型和属性名称转换为C ++标识符时， <code class="codeph">SAME</code>是字母保持不变的情况。
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">LOWER</code>表示所有大写字母都转换为小写。
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">UPPER</code>表示所有小写字母都转换为大写。
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">OPPOSITE</code>表示所有大写字母都转换为小写，所有小写字母都转换为大写。
                                 </p>
                              </li>
                           </ul>
                           <p>此参数仅影响<code class="codeph">INTYPE</code>文件中未提及的那些标识符（未明确列出的属性或类型）。在生成合法标识符之后进行大小写转换。
                           </p>
                           <p>如果<code class="codeph">CASE=SAME</code> ， <code class="codeph">INTYPE</code>文件中未提及的不区分大小写的SQL标识符<code class="codeph">INTYPE</code>大写<code class="codeph">INTYPE</code>显示，如果<code class="codeph">CASE=OPPOSITE</code> ， <code class="codeph">INTYPE</code>小写形式显示。如果SQL标识符在声明时未引用，则它不区分大小写。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNCPP20365"></a><div class="props_rev_3"><a id="GUID-2158AA13-83C8-412A-8241-8F8893D03009" name="GUID-2158AA13-83C8-412A-8241-8F8893D03009"></a><h5 id="LNCPP-GUID-2158AA13-83C8-412A-8241-8F8893D03009" class="sect5"><span class="enumeration_section">8.4.3.3</span>代码</h5>
                     <div>
                        <div class="section">
                           <p>此参数指定OTT实用程序要输出的主机语言。必须为OTT实用程序指定<code class="codeph">CODE=CPP</code> ，以便为OCCI应用程序生成C ++代码。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNCPP20366"></a><div class="props_rev_3"><a id="GUID-3C1A0D54-82C4-49C4-879A-DC5FCCE6B8F2" name="GUID-3C1A0D54-82C4-49C4-879A-DC5FCCE6B8F2"></a><h5 id="LNCPP-GUID-3C1A0D54-82C4-49C4-879A-DC5FCCE6B8F2" class="sect5"><span class="enumeration_section">8.4.3.4</span>配置</h5>
                     <div>
                        <div class="section">
                           <p>此参数指定列出常用参数规范的OTT配置文件的名称。还从依赖于操作系统的位置中的系统配置文件中读取参数规范。所有剩余的参数规范必须出现在命令行或<code class="codeph">INTYPE</code>文件中。
                           </p>
                           <p><code class="codeph">CONFIG</code>参数只能在OTT命令行中指定。<code class="codeph">CONFIG</code>文件中不允许使用它。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNCPP20367"></a><div class="props_rev_3"><a id="GUID-14386588-D5A8-4DCA-84D2-3CBCA18BE418" name="GUID-14386588-D5A8-4DCA-84D2-3CBCA18BE418"></a><h5 id="LNCPP-GUID-14386588-D5A8-4DCA-84D2-3CBCA18BE418" class="sect5"><span class="enumeration_section">8.4.3.5</span> CPPFILE</h5>
                     <div>
                        <div class="section">
                           <p>此参数指定包含OTT实用程序生成的方法实现的C ++源文件的名称。OCCI在实例化对象时调用此文件中生成的方法，而不是直接在应用程序中调用。</p>
                           <p>在以下条件下需要此参数：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>必须生成<code class="codeph">INTYPE</code>文件中未提及的类型，并且正在生成两个或更多<code class="codeph">CPPFILE</code> 。在这种情况下，未提及的类型将在命令行中指定的<code class="codeph">CPPFILE</code>中。
                                 </p>
                              </li>
                              <li>
                                 <p>未指定<code class="codeph">INTYPE</code>参数，并且您希望OTT实用程序转换架构中的所有类型。
                                 </p>
                              </li>
                           </ul>
                           <p>当为<code class="codeph">INTYPE</code>文件中的各个类型指定<code class="codeph">CPPFILE</code>时，此参数是可选的。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNCPP20368"></a><div class="props_rev_3"><a id="GUID-E96901DC-49A5-4CBB-AD5A-1C725FC61C08" name="GUID-E96901DC-49A5-4CBB-AD5A-1C725FC61C08"></a><h5 id="LNCPP-GUID-E96901DC-49A5-4CBB-AD5A-1C725FC61C08" class="sect5"><span class="enumeration_section">8.4.3.6</span> ERRTYPE</h5>
                     <div>
                        <div class="section">
                           <p>此参数指定错误消息输出文件的名称。无论是否指定了<code class="codeph">ERRTYPE</code>参数，都会将信息和错误消息发送到标准输出。从本质上讲， <code class="codeph">ERRTYPE</code>文件是复印件<code class="codeph">INTYPE</code>添加了错误信息的文件。在大多数情况下，错误消息包含指向导致错误的文本的指针。
                           </p>
                           <p>如果在命令行上为<code class="codeph">ERRTYPE</code>参数指定的文件名不包含扩展名，则特定于平台的扩展名，如。<code class="codeph">TLS</code>或。 <code class="codeph">tls</code> ，自动添加。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNCPP20369"></a><div class="props_rev_3"><a id="GUID-3D18CAD9-3650-4CB3-81ED-6C77D2A1EA03" name="GUID-3D18CAD9-3650-4CB3-81ED-6C77D2A1EA03"></a><h5 id="LNCPP-GUID-3D18CAD9-3650-4CB3-81ED-6C77D2A1EA03" class="sect5"><span class="enumeration_section">8.4.3.7</span> HFILE</h5>
                     <div>
                        <div class="section">
                           <p>此参数指定OTT实用程序生成的标头（ <code class="codeph">.h</code> ）文件的名称。命令行中指定的<code class="codeph">HFILE</code>包含<code class="codeph">INTYPE</code>文件中提到但未在其中指定其头文件的类型声明。
                           </p>
                           <p>除非在<code class="codeph">INTYPE</code>文件中单独指定每种类型的头文件，否则此参数是必需的。如果必须生成<code class="codeph">INTYPE</code>文件中未提及的类型，因为其他类型需要它，并且这些其他类型在两个或多个不同的文件中声明，则此参数也是必需的。
                           </p>
                           <p>如果在命令行或<code class="codeph">INTYPE</code>文件中为<code class="codeph">HFILE</code>参数指定的文件名不包含扩展名， <code class="codeph">INTYPE</code>特定于平台的扩展名，如<code class="codeph">.H</code>或<code class="codeph">.h</code> ，自动添加。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNCPP20370"></a><div class="props_rev_3"><a id="GUID-CF2AE1F7-49E8-4600-8103-534AE659FF1D" name="GUID-CF2AE1F7-49E8-4600-8103-534AE659FF1D"></a><h5 id="LNCPP-GUID-CF2AE1F7-49E8-4600-8103-534AE659FF1D" class="sect5"><span class="enumeration_section">8.4.3.8</span> INTYPE</h5>
                     <div>
                        <div class="section">
                           <p>此参数指定要从中读取对象类型规范列表的文件的名称。OTT实用程序转换列表中的每种类型。如果未指定<code class="codeph">INTYPE</code>参数，则转换用户架构中的所有类型。
                           </p>
                           <p>如果在命令行上为<code class="codeph">INTYPE</code>参数指定的文件名不包含扩展名，则特定于平台的扩展名，如<code class="codeph">.TYP</code>或<code class="codeph">.typ</code>会自动添加。
                           </p>
                           <p>如果<code class="codeph">USERID</code>和<code class="codeph">INTYPE</code>是前两个参数，则可以省略<code class="codeph">INTYPE=</code> ，并且省略<code class="codeph">USERID=</code> 。
                           </p>
                           <p><code class="codeph">INTYPE</code>文件可以被认为是类型声明的makefile。它列出了需要C ++类的类型。
                           </p>
                           <div class="infoboxnotealso" id="GUID-CF2AE1F7-49E8-4600-8103-534AE659FF1D__GUID-76E153DA-BD45-425A-91F4-57AE9FDC0688">
                              <p class="notep1">也可以看看：</p>
                              <p><span class="q">“ <a href="object-type-translator-utility.html#GUID-D78CB214-1A42-42D1-9100-EDAFB463602C">INTYPE文件的结构</a> ”</span> ，以获取有关<code class="codeph">INTYPE</code>文件格式的更多信息</p>
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNCPP20371"></a><div class="props_rev_3"><a id="GUID-7FBA0DB4-3C69-4DEA-8082-13C05552F299" name="GUID-7FBA0DB4-3C69-4DEA-8082-13C05552F299"></a><h5 id="LNCPP-GUID-7FBA0DB4-3C69-4DEA-8082-13C05552F299" class="sect5"><span class="enumeration_section">8.4.3.9</span> MAPFILE</h5>
                     <div>
                        <div class="section">
                           <p>此参数指定由OTT实用程序生成的映射文件（ <span class="italic"><code class="codeph">XXX</code></span> <code class="codeph">.cpp</code> ）和相应的头文件（ <span class="italic"><code class="codeph">XXX</code></span> <code class="codeph">.h</code> ）的名称。<span class="italic"><code class="codeph">XXX</code></span> <code class="codeph">.cpp</code>文件包含注册映射的函数的实现，而<span class="italic"><code class="codeph">XXX</code></span> <code class="codeph">.h</code>文件包含函数的原型。
                           </p>
                           <p>可以在命令行或<code class="codeph">INTYPE</code>文件中指定此参数。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNCPP20372"></a><div class="props_rev_3"><a id="GUID-FFFBB8D5-1EC0-46DB-A838-2001B258D224" name="GUID-FFFBB8D5-1EC0-46DB-A838-2001B258D224"></a><h5 id="LNCPP-GUID-FFFBB8D5-1EC0-46DB-A838-2001B258D224" class="sect5"><span class="enumeration_section">8.4.3.10</span> MAPFUNC</h5>
                     <div>
                        <div class="section">
                           <p>此参数指定用于注册OTT实用程序生成的映射的函数的名称。</p>
                           <p>如果省略此参数，则注册映射的函数的名称是从<code class="codeph">MAPFILE</code>参数中指定的文件名派生的。
                           </p>
                           <p>可以在命令行或<code class="codeph">INTYPE</code>文件中指定此参数。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNCPP20373"></a><div class="props_rev_3"><a id="GUID-317685CC-A0F0-48E0-853E-DA7F6A3A7E9E" name="GUID-317685CC-A0F0-48E0-853E-DA7F6A3A7E9E"></a><h5 id="LNCPP-GUID-317685CC-A0F0-48E0-853E-DA7F6A3A7E9E" class="sect5"><span class="enumeration_section">8.4.3.11</span> OUTTYPE</h5>
                     <div>
                        <div class="section">
                           <p>此参数指定OTT实用程序为其处理的所有对象数据类型写入类型信息的文件的名称。此文件包括在<code class="codeph">INTYPE</code>文件中显式命名的所有类型，并且可能包含已翻译的其他类型，因为它们用于必须转换的其他类型的声明中。在将来调用OTT实用程序时，此文件可用作<code class="codeph">INTYPE</code>文件。
                           </p>
                           <p>如果<code class="codeph">INTYPE</code>和<code class="codeph">OUTTYPE</code>参数引用同一文件，则新的<code class="codeph">INTYPE</code>信息将替换<code class="codeph">INTYPE</code>文件中的旧信息。这为在更改类型，生成类型声明，编辑源代码，预编译，编译和调试的循环中重复使用相同的<code class="codeph">INTYPE</code>文件提供了一种便捷的方法。
                           </p>
                           <p>如果在命令行或<code class="codeph">INTYPE</code>文件中为<code class="codeph">OUTTYPE</code>参数指定的文件名不包含扩展名， <code class="codeph">INTYPE</code>特定于平台的扩展名，如<code class="codeph">.TYP</code>或<code class="codeph">.typ</code>会自动添加。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNCPP20375"></a><a id="LNCPP20374"></a><div class="props_rev_3"><a id="GUID-8D3EE31C-90B9-4681-BB8D-227658DCF5F9" name="GUID-8D3EE31C-90B9-4681-BB8D-227658DCF5F9"></a><h5 id="LNCPP-GUID-8D3EE31C-90B9-4681-BB8D-227658DCF5F9" class="sect5"><span class="enumeration_section">8.4.3.12</span> SCHEMA_NAMES</h5>
                     <div>
                        <div class="section">
                           <p>此参数提供控制，以从<a href="object-type-translator-utility.html#GUID-317685CC-A0F0-48E0-853E-DA7F6A3A7E9E">OUTTYPE</a>文件中指定的默认架构限定类型的数据库名称。OTT实用程序生成的<code class="codeph">OUTTYPE</code>文件包含有关OTT实用程序处理的类型的信息，包括类型名称。有效值包括：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">ALWAYS</code> （默认值）表示<code class="codeph">OUTTYPE</code>文件中的所有类型名称都使用模式名称限定。
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">IF_NEEDED</code>表示<code class="codeph">OUTTYPE</code>文件中属于默认架构的类型名称未使用架构名称限定。属于其他模式的类型名称使用模式名称限定。
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">FROM_INTYPE</code>表明，在提到型<a href="object-type-translator-utility.html#GUID-CF2AE1F7-49E8-4600-8103-534AE659FF1D">输入法菜单</a>文件是用合格的架构名称<code class="codeph">OUTTYPE</code>文件，只有当它被用在模式名修饰<code class="codeph">INTYPE</code>文件。缺省模式中的类型在<code class="codeph">INTYPE</code>文件中未提及但由于类型依赖性而生成的类型仅在依赖于它的OTT实用程序遇到的第一个类型也使用模式名称写入时才使用模式名称编写。但是，OTT实用程序所连接的默认架构中的类型始终使用显式架构名称编写。
                                 </p>
                              </li>
                           </ul>
                           <p>来自其他模式的类型的名称，默认模式始终使用<code class="codeph">OUTTYPE</code>文件中的模式名称进行<code class="codeph">OUTTYPE</code> 。
                           </p>
                           <p>模式名称或其缺席确定在程序执行期间在哪个模式中找到类型。</p>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-8D3EE31C-90B9-4681-BB8D-227658DCF5F9__GUID-29CEB3B6-81F4-4ACC-9E26-6D946901DC0A">
                           <p class="titleinexample">示例8-4如何在OTT实用程序中使用SCHEMA_NAMES参数</p>
                           <p>考虑一个示例，其中<code class="codeph">SCHEMA_NAMES</code>参数设置为<code class="codeph">FROM_INTYPE</code> ， <code class="codeph">INTYPE</code>文件包含以下内容：</p><pre class="oac_no_warn" dir="ltr">TYPE Person TYPE乔。部门类型山姆。公司</pre><p>如果OTT实用程序和应用程序都连接到schema joe，那么应用程序使用相同的类型（ <code class="codeph">joe.Person</code> ），该OTT实用程序使用。如果OTT实用程序连接到架构<code class="codeph">joe</code>但应用程序连接到架构<code class="codeph">mary</code> ，则应用程序使用类型<code class="codeph">mary.Person</code>仅当在schema <code class="codeph">joe</code>和schema <code class="codeph">mary</code>执行了相同的<code class="codeph">CREATE TYPE Person</code>语句时，此行为才适用。
                           </p>
                           <p>另一方面，应用程序使用类型<code class="codeph">joe.无论应用程序连接到哪个架构，都要Dept</code> 。如果这是您想要的行为，请确保在<code class="codeph">INTYPE</code>文件中包含带有您的类型名称的模式名称。
                           </p>
                           <p>在某些情况下，OTT实用程序会转换用户未明确命名的类型。例如，请考虑以下SQL声明：</p><pre class="oac_no_warn" dir="ltr">CREATE TYPE地址AS OBJECT（街道VARCHAR2（40），城市VARCHAR（30），州CHAR（2），zip_code CHAR（10））; CREATE TYPE Person AS OBJECT（名称CHAR（20），年龄NUMBER，地址ADDRESS）;</pre><p>假设OTT实用程序连接到模式<code class="codeph">joe</code> ，指定了<code class="codeph">SCHEMA_NAMES=FROM_INTYPE</code> ，并且用户的<code class="codeph">INTYPE</code>文件包括<code class="codeph">TYPE Person</code>或<code class="codeph">TYPE joe.Person</code><code class="codeph">INTYPE</code>文件未提及类型<code class="codeph">joe.Address</code> ，用作类型为<code class="codeph">joe.的嵌套对象类型<code class="codeph">joe.Person</code>
                           </p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>如果<code class="codeph">Type Person</code>出现在<code class="codeph">INTYPE</code>文件中，则<code class="codeph">TYPE Person</code>和<code class="codeph">TYPE Address</code>出现在<code class="codeph">OUTTYPE</code>文件中。
                                 </p>
                              </li>
                              <li>
                                 <p>如果<code class="codeph">TYPE joe.Person</code>出现在<code class="codeph">INTYPE</code>文件中，然后出现在<code class="codeph">TYPE joe.Person</code>与<code class="codeph">TYPE joe.Address</code>显示在<code class="codeph">OUTTYPE</code>文件中。
                                 </p>
                              </li>
                              <li>
                                 <p>如果是<code class="codeph">joe.Address</code>类型嵌入在由OTT实用程序转换的几种类型中，但在<code class="codeph">INTYPE</code>文件中没有明确提及，然后在OTT实用程序第一次遇到嵌入式<code class="codeph">joe.决定是否使用模式名称<code class="codeph">joe.Address</code>类型。如果由于某种原因，用户想要键入<code class="codeph">joe.要具有模式名称但不希望类型为<code class="codeph">Person</code> Address</code> ，则必须在<code class="codeph">INTYPE</code>文件中显式请求： <code class="codeph">TYPE joe.Address</code> 。
                                 </p>
                              </li>
                           </ul>
                           <p>在通常情况下，在单个模式中声明每个类型，最安全的是使用<code class="codeph">INTYPE</code>文件中的模式名称限定所有类型名称。
                           </p>
                        </div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="LNCPP20376"></a><div class="props_rev_3"><a id="GUID-6EAA11AD-1287-403B-87AF-C103F9D171A3" name="GUID-6EAA11AD-1287-403B-87AF-C103F9D171A3"></a><h5 id="LNCPP-GUID-6EAA11AD-1287-403B-87AF-C103F9D171A3" class="sect5"><span class="enumeration_section">8.4.3.13传统</span></h5>
                     <div>
                        <div class="section">
                           <p>此参数指示是否要转换未在<code class="codeph">INTYPE</code>文件中明确列出的类型依赖项。有效值为：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">TRUE</code> （默认值）：生成<code class="codeph">INTYPE</code>文件中未提及的其他类型所需的类型</p>
                              </li>
                              <li>
                                 <p><code class="codeph">FALSE</code> ：不会生成<code class="codeph">INTYPE</code>文件中未提及的类型，即使它们用作其他生成类型的属性类型也是如此。
                                 </p>
                              </li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNCPP20378"></a><a id="LNCPP20379"></a><a id="LNCPP20380"></a><a id="LNCPP20377"></a><div class="props_rev_3"><a id="GUID-34F425D9-344F-4413-8909-3048DBCA6778" name="GUID-34F425D9-344F-4413-8909-3048DBCA6778"></a><h5 id="LNCPP-GUID-34F425D9-344F-4413-8909-3048DBCA6778" class="sect5"><span class="enumeration_section">8.4.3.14</span> UNICODE</h5>
                     <div>
                        <div class="section">
                           <p>此参数指定应用程序是否提供unicode（ <code class="codeph">UTF16</code> ）支持。
                           </p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">NONE</code> （默认）</p>
                              </li>
                              <li>
                                 <p><code class="codeph">ALL</code> ：所有<code class="codeph">CHAR</code> （ <code class="codeph">CHAR</code> / <code class="codeph">VARCHAR</code> ）和<code class="codeph">NCHAR</code> （ <code class="codeph">NCHAR</code> / <code class="codeph">NVARCHAR2</code> ）类型属性在OTT生成的C ++类文件中声明为<code class="codeph">UString</code>类型。相应的<code class="codeph">get</code> <span class="italic"><code class="codeph">XXX</code></span> <code class="codeph">()</code> / <code class="codeph">set</code> <span class="italic"><code class="codeph">XXX</code></span> <code class="codeph">()</code>返回值或参数是<code class="codeph">UString</code>类型。生成的持久运算符new也只<code class="codeph">UString</code>参数。
                                 </p>
                                 <p>当客户端字符集和国家字符集都是<code class="codeph">UTF16</code>时，此设置是必需的。
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">ONLYNCHAR</code> ：类似于<code class="codeph">ALL</code>选项，但只有<code class="codeph">NCHAR</code>类型属性声明为<code class="codeph">UString</code> 。
                                 </p>
                                 <p>当应用程序仅将环境的国家字符集设置为<code class="codeph">UTF16</code>时，此设置是必需的。
                                 </p>
                              </li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-34F425D9-344F-4413-8909-3048DBCA6778__GUID-834C2600-E423-4F36-BE68-98C2146B42C5">
                           <p class="titleinexample">示例8-5如何在OTT中定义Unicode支持的模式</p><pre class="oac_no_warn" dir="ltr">创建类型CitiesList作为varchar2（100）的varray（100）; create type Country as object（CNo Number（10），CName Varchar2（100），CNationalName NVarchar2（100），MainCities CitiesList）;</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-34F425D9-344F-4413-8909-3048DBCA6778__GUID-9CE4C656-6062-4F66-A89E-35E75958BFB7">
                           <p class="titleinexample">例8-6如何在OTT中使用UNICODE = ALL参数</p><pre class="oac_no_warn" dir="ltr">class Country：public oracle :: occi :: PObject {private：oracle :: occi :: Number CNO; oracle :: occi :: UString CNAME; oracle :: occi :: UString CNATIONALNAME; OCCI_STD_NAMESPACE ::: vector &lt;oracle :: occi :: UString&gt; MAINCITIES; public：oracle :: occi :: Number getCno（）const; void setCno（const oracle :: occi :: Number＆value）; oracle :: occi :: UString getCname（）const; void setCname（const oracle :: occi :: UString＆value）; oracle :: occi :: UString getCnationalname（）const; void setCnationalname（const oracle :: occi :: UString＆value）; OCCI_STD_NAMESPACE :: vector &lt;oracle :: occi :: UString&gt;＆getMaincities（）; const OCCI_STD_NAMESPACE :: vector &lt;oracle :: occi :: UString&gt;＆getMaincities（）const; void setMaincities（const OCCI_STD_NAMESPACE :: vector &lt;oracle :: occi :: UString&gt;＆value）; ...}</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-34F425D9-344F-4413-8909-3048DBCA6778__GUID-D7F65DA3-1125-49DE-8C72-E56910ADB970">
                           <p class="titleinexample">例8-7如何在OTT中使用UNICODE = ONLYCHAR参数</p><pre class="oac_no_warn" dir="ltr">class Country：public oracle :: occi :: PObject {private：oracle :: occi :: Number CNO; oracle :: occi :: string CNAME; oracle :: occi :: UString CNATIONALNAME; OCCI_STD_NAMESPACE :: vector &lt;std :: string&gt; MAINCITIES; public：oracle :: occi :: Number getCno（）const; void setCno（const oracle :: occi :: Number＆value）; oracle :: occi :: string getCname（）const; void setCname（const OCCI_STD_NAMESPACE :: string＆value）; oracle :: occi :: UString getCnationalname（）const; void setCnationalname（const oracle :: occi :: UString＆value）; OCCI_STD_NAMESPACE :: vector &lt;OCCI_STD_NAMESPACE :: string&gt;＆getMaincities（）; const OCCI_STD_NAMESPACE :: vector &lt;OCCI_STD_NAMESPACE :: string&gt;＆getMaincities（）const; void setMaincities（const OCCI_STD_NAMESPACE :: vector &lt;OCCI_STD_NAMESPACE :: string&gt;＆value）; ...}</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="LNCPP20381"></a><div class="props_rev_3"><a id="GUID-966D792F-9ADF-45B6-8EFD-7C3301B080E9" name="GUID-966D792F-9ADF-45B6-8EFD-7C3301B080E9"></a><h5 id="LNCPP-GUID-966D792F-9ADF-45B6-8EFD-7C3301B080E9" class="sect5"><span class="enumeration_section">8.4.3.15</span> USE_MARKER</h5>
                     <div>
                        <div class="section">
                           <p>此参数指示是否支持用于转发用户添加代码的OTT标记。有效值为：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">FALSE</code> （默认值）：即使在<code class="codeph">OTT_USERCODE_START</code>和<code class="codeph">OTT_USERCODE_END</code>标记之间添加代码，也不会继续使用用户提供的代码。
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">TRUE</code> ：标记<code class="codeph">OTT_USER_CODESTART</code>和<code class="codeph">OTT_USERCODE_END</code>之间的用户提供的代码在再次生成相同文件时继续执行。
                                 </p>
                              </li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNCPP20382"></a><div class="props_rev_3"><a id="GUID-B4BB12D4-5527-4B83-B7E9-F1916BBC32EE" name="GUID-B4BB12D4-5527-4B83-B7E9-F1916BBC32EE"></a><h5 id="LNCPP-GUID-B4BB12D4-5527-4B83-B7E9-F1916BBC32EE" class="sect5"><span class="enumeration_section">8.4.3.16</span> USERID</h5>
                     <div>
                        <div class="section">
                           <p>此参数指定Oracle用户名和可选数据库名称（Oracle Net数据库规范字符串）。如果省略数据库名称，则假定使用缺省数据库。</p><pre class="oac_no_warn" dir="ltr">USERID = <span class="italic">用户名</span> [@db_name]</pre><p>如果这是第一个参数，则可以省略<code class="codeph">USERID=</code> ，如下所示：</p><pre class="oac_no_warn" dir="ltr">OTT <span class="italic">用户名</span> ...
</pre><p>请注意，系统会提示您输入与用户ID对应的密码。</p>
                           <p>此参数是可选的。如果省略，OTT实用程序会自动尝试以用户<span class="italic"><code class="codeph">OPS$username</code></span>连接到默认数据库，其中<span class="italic"><code class="codeph">username</code></span>是用户的操作系统用户名。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="LNCPP20383"></a><div class="props_rev_3"><a id="GUID-77786ABB-AD5E-4FA1-9455-FFBC30DC1D86" name="GUID-77786ABB-AD5E-4FA1-9455-FFBC30DC1D86"></a><h4 id="LNCPP-GUID-77786ABB-AD5E-4FA1-9455-FFBC30DC1D86" class="sect4"><span class="enumeration_section">8.4.4</span>可以出现OTT参数的地方</h4>
                  <div>
                     <p>在命令行，命令行上指定的<code class="codeph">CONFIG</code>文件或两者中提供OTT参数。<code class="codeph">INTYPE</code>文件中也允许使用某些参数。
                     </p>
                     <p>OTT实用程序的调用方式如下：</p><pre class="oac_no_warn" dir="ltr">OTT参数</pre><p>您可以使用<code class="codeph">CONFIG</code>参数在命令行上命名配置文件，如下所示：</p><pre class="oac_no_warn" dir="ltr">CONFIG = <span class="italic">文件名</span>
</pre><p>如果在命令行中为此参数命名，则会从名为<span class="italic"><code class="codeph">filename</code></span>的配置文件中读取其他参数。
                     </p>
                     <p>此外，还会从驻留在依赖于操作系统的位置的默认配置文件中读取参数。此文件必须存在，但可以为空。如果选择在配置文件中输入数据，请注意一行上不允许有空格，并且必须在一行中输入参数。</p>
                     <p>如果在没有任何参数的情况下执行OTT实用程序，则会显示在线参数引用。</p>
                     <p>要转换的OTT实用程序的类型在<code class="codeph">INTYPE</code>参数指定的文件中命名。参数<code class="codeph">CASE</code> ， <code class="codeph">CPPFILE</code> ， <code class="codeph">HFILE</code> ， <code class="codeph">INITFILE</code> ， <code class="codeph">INITFUNC</code> ， <code class="codeph">MAPFILE</code>和<code class="codeph">MAPFNC</code>也可能出现在<code class="codeph">INTYPE</code>文件中。OTT实用程序生成的<code class="codeph">OUTTYPE</code>文件包括<code class="codeph">CASE</code>参数，如果生成了初始化文件，则包括<code class="codeph">INITFILE</code>和<code class="codeph">INITFUNC</code>参数;如果生成了C ++代码，则包括<code class="codeph">MAPFILE</code>和<code class="codeph">MAPFUNC</code>参数。<code class="codeph">OUTTYPE</code>文件和<code class="codeph">CPPFILE</code> for C ++为每种类型单独指定<code class="codeph">HFILE</code> 。
                     </p>
                     <p>OTT命令的情况与操作系统有关。</p>
                  </div>
               </div><a id="LNCPP20384"></a><div class="props_rev_3"><a id="GUID-A0881819-C788-439D-8DCB-2E3628FDD2EB" name="GUID-A0881819-C788-439D-8DCB-2E3628FDD2EB"></a><h4 id="LNCPP-GUID-A0881819-C788-439D-8DCB-2E3628FDD2EB" class="sect4"><span class="enumeration_section">8.4.5</span>文件名比较限制</h4>
                  <div>
                     <p>目前，OTT实用程序通过比较用户在命令行或<code class="codeph">INTYPE</code>文件中提供的文件名来确定两个文件是否相同。但是，当OTT实用程序必须知道两个文件名是否引用同一文件时，可能会出现一个潜在问题。例如，如果OTT生成的文件foo.h需要写入<code class="codeph">foo1.h</code>的类型声明，并且另一个类型声明写入<code class="codeph">/private/smith/foo1.h</code> ，那么OTT实用程序应该生成一个<code class="codeph">#include</code>如果这两个文件是相同的，如果文件不同，则有两个<code class="codeph">#include</code> 。但实际上，它得出的结论是两个文件不同，并生成两个<code class="codeph">#include</code> ，如下所示：</p><pre class="oac_no_warn" dir="ltr">#ifndef FOO1_ORACLE #include“foo1.h”#endif #ifndef FOO1_ORACLE #include“/private/smith/foo1.h”#endif</pre><p>如果<code class="codeph">foo1.h</code>和<code class="codeph">/private/smith/foo1.h</code>是不同的文件，则只包含第一个文件。如果<code class="codeph">foo1.h</code>和<code class="codeph">/private/smith/foo1.h</code>是同一个文件，则写入冗余的<code class="codeph">#include</code> 。
                     </p>
                     <p>因此，如果在命令行或<code class="codeph">INTYPE</code>文件中多次提到文件，则每次提及该文件都应使用相同的文件名。
                     </p>
                  </div>
               </div>
               <div class="props_rev_3"><a id="GUID-8FC3C3F1-C21B-494C-859C-37F72409FE02" name="GUID-8FC3C3F1-C21B-494C-859C-37F72409FE02"></a><h4 id="LNCPP-GUID-8FC3C3F1-C21B-494C-859C-37F72409FE02" class="sect4"><span class="enumeration_section">8.4.6</span>在Microsoft Windows上使用OTT命令</h4>
                  <div>
                     <div class="section">
                        <p>当前版本中Microsoft Windows上的OTT可执行文件是<code class="codeph">ott.bat</code> ，而不是早期版本中的<code class="codeph">ott.exe</code> 。这可能会破坏Windows批处理脚本，因为脚本在执行ott后立即退出。要解决此问题，应在Windows批处理脚本中按如下方式调用OTT：</p><pre class="oac_no_warn" dir="ltr">叫ott [参数]</pre><div class="infoboxnote" id="GUID-8FC3C3F1-C21B-494C-859C-37F72409FE02__GUID-EA3DAC7B-2D22-450B-BA8F-CBBE4A14875E">
                           <p class="notep1">注意：</p>
                           <p>在修复脚本之前，可以使用<code class="codeph">ORACLE_HOME\precomp\admin\ott.exe</code>作为中间解决方案。但是，将来的版本中不会提供此中间解决方案。
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="LNCPP20385"></a><div class="props_rev_3"><a id="GUID-2B0C5750-97C8-41E7-BD07-F417598C5E9D" name="GUID-2B0C5750-97C8-41E7-BD07-F417598C5E9D"></a><h3 id="LNCPP-GUID-2B0C5750-97C8-41E7-BD07-F417598C5E9D" class="sect3"><span class="enumeration_section">8.5</span>关于使用INTYPE文件</h3>
               <div>
                  <p>运行OTT实用程序时， <code class="codeph">INTYPE</code>文件告诉OTT实用程序应转换哪些数据库类型。<code class="codeph">INTYPE</code>文件还控制生成的结构或类的命名。您可以创建<code class="codeph">INTYPE</code>文件，也可以使用先前调用OTT实用程序的<code class="codeph">OUTTYPE</code>文件。如果不使用<code class="codeph">INTYPE</code>文件，则转换OTT实用程序所连接的架构中的所有类型。
                  </p>
                  <div class="p">本节包括以下主题：<ul style="list-style-type:disc">
                        <li>
                           <p><a href="object-type-translator-utility.html#GUID-55F8629A-7420-4AA5-8BA2-AED2CCF50290">使用INTYPE文件</a></p>
                        </li>
                        <li>
                           <p><a href="object-type-translator-utility.html#GUID-D78CB214-1A42-42D1-9100-EDAFB463602C">INTYPE文件的结构</a></p>
                        </li>
                        <li>
                           <p><a href="object-type-translator-utility.html#GUID-38986E01-A479-4BCE-A7AB-7FB51ED64348">使用嵌套包括文件生成</a></p>
                        </li>
                     </ul>
                  </div>
               </div><a id="LNCPP20387"></a><a id="LNCPP20386"></a><div class="props_rev_3"><a id="GUID-55F8629A-7420-4AA5-8BA2-AED2CCF50290" name="GUID-55F8629A-7420-4AA5-8BA2-AED2CCF50290"></a><h4 id="LNCPP-GUID-55F8629A-7420-4AA5-8BA2-AED2CCF50290" class="sect4"><span class="enumeration_section">8.5.1</span>使用INTYPE文件</h4>
                  <div>
                     <div class="section">
                        <p>OTT实用程序可能必须转换<code class="codeph">INTYPE</code>文件中未列出的其他类型。这是因为OTT实用程序在执行转换之前分析<code class="codeph">INTYPE</code>文件中的类型依赖关系类型，并根据需要转换其他类型。例如，如果<code class="codeph">ADDRESS</code>类型并没有在上市<code class="codeph">INTYPE</code>文件，但<code class="codeph">Person</code>类型有类型的属性<code class="codeph">ADDRESS</code> ，那么OTT效用仍然翻译<code class="codeph">ADDRESS</code> ，因为它需要定义的<code class="codeph">Person</code>类型。
                        </p>
                        <p>您可以指示OTT实用程序是否应生成<code class="codeph">INTYPE</code>文件中未指定的所需对象类型。设置<code class="codeph">TRANSITIVE=FALSE</code>以便OTT实用程序不会生成所需的对象类型。默认值为<code class="codeph">TRANSITIVE=TRUE</code> 。</p>
                        <p>正常的不区分大小写的SQL标识符可以拼写为<code class="codeph">INTYPE</code>文件中的大写和小写的任意组合，并且不会引用。
                        </p>
                        <p>使用引号（例如<code class="codeph">TYPE "Person"</code>来引用以区分大小写的方式创建的SQL标识符，例如， <code class="codeph">CREATE TYPE "Person"</code> 。如果SQL标识符在声明时引用，则它区分大小写。引号也可用于引用作为OTT保留字的SQL标识符，例如<code class="codeph">TYPE "CASE"</code> 。在这种情况下，如果SQL标识符是以不区分大小写的方式创建的，则引用的名称必须为大写，例如， <code class="codeph">CREATE TYPE Case</code> 。如果使用OTT保留字来引用SQL标识符的名称但未引用，则OTT实用程序会报告<code class="codeph">INTYPE</code>文件中的语法错误。
                        </p>
                        <div class="infoboxnotealso" id="GUID-55F8629A-7420-4AA5-8BA2-AED2CCF50290__GUID-463DF289-349B-4796-B0B7-E592C113B4ED">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><span class="q">“ <a href="object-type-translator-utility.html#GUID-D78CB214-1A42-42D1-9100-EDAFB463602C">INTYPE文件的结构</a> ”，</span>用于更详细地说明<code class="codeph">INTYPE</code>文件的结构和可用选项。
                                 </p>
                              </li>
                              <li>
                                 <p><span class="q">“ <a href="object-type-translator-utility.html#GUID-30B1799D-8D84-4A72-A4B1-2FD0629166AC">CASE</a> ”</span>有关<code class="codeph">CASE</code>参数的更多信息</p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-55F8629A-7420-4AA5-8BA2-AED2CCF50290__GUID-2869A6CC-877A-4FDA-8366-C79CF6289F3D">
                        <p class="titleinexample">示例8-8如何使用OTT实用程序创建用户定义的INTYPE文件</p><pre class="oac_no_warn" dir="ltr">CASE = LOWER TYPE员工TRANSLATE SALARY $ AS薪水DEPTNO AS部门类型地址类型项目类型“人员”TYPE PURCHASE_ORDER as p_o</pre><ul style="list-style-type:disc">
                           <li>
                              <p>在第一行中， <code class="codeph">CASE</code>参数指示生成的C标识符应为小写。但是，此<code class="codeph">CASE</code>参数仅应用于<code class="codeph">INTYPE</code>文件中未明确提及的那些标识符。因此， <code class="codeph">employee</code>和<code class="codeph">ADDRESS</code>将始终分别导致C结构<code class="codeph">employee</code>和<code class="codeph">ADDRESS</code> 。这些结构的成员以小写命名。
                              </p>
                           </li>
                           <li>
                              <p>以<code class="codeph">TYPE</code>关键字开头的行指定应转换数据库中的哪些类型。在这种情况下， <code class="codeph">EMPLOYEE</code> ， <code class="codeph">ADDRESS</code> ， <code class="codeph">ITEM</code> ， <code class="codeph">PERSON</code>和<code class="codeph">PURCHASE_ORDER</code>类型设置为翻译。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">TRANSLATE...AS</code>关键字指定在将类型转换为C结构时应更改对象属性的名称。在这种情况下， <code class="codeph">employee</code>类型的<code class="codeph">SALARY$</code>属性将转换为<code class="codeph">salary</code> 。
                              </p>
                           </li>
                           <li>
                              <p>最后一行中的<code class="codeph">AS</code>关键字指定在将对象类型转换为结构时应更改该对象类型的名称。在这种情况下， <code class="codeph">purchase_order</code>数据库类型将转换为名为<code class="codeph">p_o</code>的结构。
                              </p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="example" -->
                  </div>
               </div><a id="LNCPP20388"></a><div class="props_rev_3"><a id="GUID-D78CB214-1A42-42D1-9100-EDAFB463602C" name="GUID-D78CB214-1A42-42D1-9100-EDAFB463602C"></a><h4 id="LNCPP-GUID-D78CB214-1A42-42D1-9100-EDAFB463602C" class="sect4"><span class="enumeration_section">8.5.2</span> INTYPE文件的结构</h4>
                  <div>
                     <p><code class="codeph">INTYPE</code>和<code class="codeph">OUTTYPE</code>文件列出了OTT实用程序转换的类型，并提供了确定如何将类型或属性名称转换为合法的C或C ++标识符所需的所有信息。这些文件包含一个或多个类型规范，也可能包含<code class="codeph">CASE</code> ， <code class="codeph">CPPFILE</code> ， <code class="codeph">HFILE</code> ， <code class="codeph">INITFILE</code> ， <code class="codeph">INITFUNC</code> ， <code class="codeph">MAPFILE</code>或<code class="codeph">MAPFUNC</code> 。</p>
                     <p>如果存在<code class="codeph">CASE</code> ， <code class="codeph">INITFILE</code> ， <code class="codeph">INITFUNC</code> ， <code class="codeph">MAPFILE</code>或<code class="codeph">MAPFUNC</code>选项，则它们必须位于任何类型规范之前。如果这些选项同时出现在命令行和<code class="codeph">INTYPE</code>文件中，则使用命令行上的值。
                     </p>
                     <div class="infoboxnotealso" id="GUID-D78CB214-1A42-42D1-9100-EDAFB463602C__GUID-C1133465-2E5B-4B13-97CC-07DAB368BC7F">
                        <p class="notep1">也可以看看：</p>
                        <p><span class="q">“ <a href="object-type-translator-utility.html#GUID-B5D1FB85-549E-484A-B492-24ADE223C24E">OUTTYPE文件概述</a> ”，</span>用于简单的用户定义的<code class="codeph">INTYPE</code>文件和OTT实用程序从中生成的完整<code class="codeph">OUTTYPE</code>文件的示例</p>
                     </div>
                     <p>本节包括以下主题： <a href="object-type-translator-utility.html#GUID-CD9E83E7-51BF-4B23-A5D9-E0E7DAC68847">INTYPE文件类型规范</a> 。
                     </p>
                  </div><a id="LNCPP20389"></a><div class="props_rev_3"><a id="GUID-CD9E83E7-51BF-4B23-A5D9-E0E7DAC68847" name="GUID-CD9E83E7-51BF-4B23-A5D9-E0E7DAC68847"></a><h5 id="LNCPP-GUID-CD9E83E7-51BF-4B23-A5D9-E0E7DAC68847" class="sect5"><span class="enumeration_section">8.5.2.1</span> INTYPE文件类型规范</h5>
                     <div>
                        <div class="section">
                           <p><code class="codeph">INTYPE</code>文件中的类型规范命名要转换的对象数据类型。以下是用户创建的<code class="codeph">INTYPE</code>文件的示例：</p><pre class="oac_no_warn" dir="ltr">TYPE员工TRANSLATE SALARY $ AS薪水DEPTNO AS部门类型地址类型PURCHASE_ORDER作为p_o</pre><p>类型规范的结构如下：</p><pre class="oac_no_warn" dir="ltr">TYPE type_name [GENERATE type_identifier] [AS type_identifier] [VERSION [=] version_string] [HFILE [=] hfile_name] [CPPFILE [=] cppfile_name] [TRANSLATE {member_name [AS identifier]} ...]
</pre><p><code class="codeph">type_name</code>语法遵循以下形式：</p><pre class="oac_no_warn" dir="ltr">[模式名。] TYPE_NAME</pre><p>在此语法中， <span class="italic"><code class="codeph">schema_name</code></span>是拥有给定对象数据类型的模式的名称， <span class="italic"><code class="codeph">type_name</code></span>是该类型的名称。如果未指定默认架构，则默认架构是调用OTT实用程序的userID的架构。要使用特定架构，必须使用schema_name。
                           </p>
                           <p>类型规范的组件是：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><span class="italic"><code class="codeph">type_name</code></span> ：对象数据类型的名称。
                                 </p>
                              </li>
                              <li>
                                 <p><span class="italic"><code class="codeph">type_identifier</code></span> ：用于表示类的C / C ++标识符。<code class="codeph">GENERATE</code>子句用于指定OTT实用程序生成的类的名称。AS子句指定您编写的类的名称。<code class="codeph">GENERATE</code>子句通常用于扩展类。<code class="codeph">AS</code>子句（可选地在没有<code class="codeph">GENERATE</code>子句的情况下使用）指定C结构的名称或表示用户定义类型的C ++类。
                                 </p>
                              </li>
                              <li>
                                 <p><span class="italic"><code class="codeph">version_string</code></span> ：上次调用OTT实用程序生成代码时使用的类型的版本字符串。版本字符串由OTT实用程序生成并写入<code class="codeph">OUTTYPE</code>文件，以后可以在以后的OTT实用程序调用中用作<code class="codeph">INTYPE</code>文件。版本字符串不会影响OTT实用程序的运行方式，但可用于选择正在运行的程序中使用的对象数据类型的版本。
                                 </p>
                              </li>
                              <li>
                                 <p><span class="italic"><code class="codeph">hfile_name</code></span> ：写入相应类的声明的头文件的名称。如果省略<code class="codeph">HFILE</code>子句，则使用命令行<code class="codeph">HFILE</code>参数指定的文件。
                                 </p>
                              </li>
                              <li>
                                 <p><span class="italic"><code class="codeph">cppfile_name</code></span> ：写入相应类的方法实现的C ++源文件的名称。如果省略<code class="codeph">CPPFILE</code>子句，则使用命令行<code class="codeph">CPPFILE</code>参数指定的文件。
                                 </p>
                              </li>
                              <li>
                                 <p><span class="italic"><code class="codeph">member_name</code></span> ：要转换为标识符的属性（数据成员）的名称。
                                 </p>
                              </li>
                              <li>
                                 <p><span class="italic"><code class="codeph">identifier</code></span> ：用于表示程序中属性的C / C ++标识符。您可以通过这种方式为任意数量的属性指定标识符。默认名称映射算法用于未提及的属性。
                                 </p>
                              </li>
                           </ul>
                           <p>可以翻译对象数据类型，原因有两个：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>它出现在<code class="codeph">INTYPE</code>文件中。
                                 </p>
                              </li>
                              <li>
                                 <p>需要声明必须转换的另一种类型，并且<code class="codeph">TRANSITIVE</code>参数设置为<code class="codeph">TRUE</code> 。</p>
                              </li>
                           </ul>
                           <p>如果在一个文件中声明的类型需要显式未提及的类型，则所需类型的转换将写入与需要它的显式声明类型相同的文件。</p>
                           <p>如果在多个文件中声明的类型需要未明确提及的类型，则所需类型的转换将写入全局<code class="codeph">HFILE</code>文件。
                           </p>
                           <p>您可以指示OTT实用程序是否应生成<code class="codeph">INTYPE</code>文件中未指定的所需对象类型。设置<code class="codeph">TRANSITIVE=FALSE</code>以便OTT实用程序不会生成所需的对象类型。默认值为<code class="codeph">TRANSITIVE=TRUE</code> 。</p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="LNCPP20391"></a><a id="LNCPP20392"></a><a id="LNCPP20390"></a><div class="props_rev_3"><a id="GUID-38986E01-A479-4BCE-A7AB-7FB51ED64348" name="GUID-38986E01-A479-4BCE-A7AB-7FB51ED64348"></a><h4 id="LNCPP-GUID-38986E01-A479-4BCE-A7AB-7FB51ED64348" class="sect4"><span class="enumeration_section">8.5.3</span>使用嵌套包含文件生成</h4>
                  <div>
                     <div class="section">
                        <p>OTT实用程序生成的<code class="codeph">HFILE</code>文件<code class="codeph">#include</code>其他必要文件和<code class="codeph">#define</code> <code class="codeph"> </code>从文件名构造的符号。然后可以使用此符号<code class="codeph">#define</code>来确定是否已包含相关的<code class="codeph">HFILE</code>文件。例如，考虑具有以下类型的数据库：</p><pre class="oac_no_warn" dir="ltr">create type px1 AS OBJECT（col1 number，col2 integer）;创建类型px2 AS OBJECT（col1 px1）;创建类型px3 AS OBJECT（col1 px1）;</pre><p><code class="codeph">INTYPE</code>文件包含以下信息：</p><pre class="oac_no_warn" dir="ltr">CASE =低级类型pxl hfile tott95a.h类型px3 hfile tott95b.h</pre><p>您可以按如下方式调用OTT实用程序：</p><pre class="oac_no_warn" dir="ltr">&gt; ott hr intype = tott95i.typ outtype = tott95o.typ code = cpp ...输入密码： <span class="italic">密码</span>
</pre><p>然后，OTT实用程序生成以下两个头文件，名为<code class="codeph">tott95a.h</code>和<code class="codeph">tott95b.h</code> 。它们列在</p>
                        <p>在<code class="codeph">tott95b.h</code>文件中，符号<code class="codeph">TOTT95B_ORACLE</code>在文件开头是<code class="codeph">#define</code> d。这使您可以使用以下构造有条件地<code class="codeph">#include</code>此头文件在另一个文件中：</p><pre class="oac_no_warn" dir="ltr">#ifndef TOTT95B_ORACLE #include“tott95b.h”#endif</pre><p>通过使用这种技术，您可以<code class="codeph">#include</code> <code class="codeph">tott95b.h</code> ，比如<code class="codeph">foo.h</code> ，而不必知道<code class="codeph">foo.h</code>其他文件<code class="codeph">#includ</code> ed是否也包含<code class="codeph">#include</code> s <code class="codeph">tott95b.h</code> 。
                        </p>
                        <p>接下来，包含文件<code class="codeph">tott95a.h</code> ，因为它包含<code class="codeph">tott95b.h</code>所需的<code class="codeph">struct px1</code>的声明。当<code class="codeph">INTYPE</code>文件请求将类型声明写入多个文件时，OTT实用程序确定每个<code class="codeph">HFILE</code>必须<code class="codeph">#include</code>其他文件，并生成每个必要的<code class="codeph">#include</code> 。
                        </p>
                        <p>请注意，OTT实用程序在此<code class="codeph">#include</code>使用引号。当编译包含<code class="codeph">tott95b.h</code>的程序时，搜索<code class="codeph">tott95a.h</code>从找到源程序的<code class="codeph">tott95a.h</code>开始，然后遵循实现定义的搜索规则。如果无法以这种方式找到<code class="codeph">tott95a.h</code> ，则在<code class="codeph">INTYPE</code>文件中需要一个完整的文件名（例如，以斜杠字符（ <code class="codeph">/</code> ）开头的UNIX绝对路径名）来指定<code class="codeph">tott95a.h</code>的位置。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-38986E01-A479-4BCE-A7AB-7FB51ED64348__GUID-E6EB376E-532E-440F-98A7-679DA1B7E493">
                        <p class="titleinexample">例8-9 ott95a.h的列表</p><pre class="oac_no_warn" dir="ltr">#ifndef TOTT95A_ORACLE #define TOTT95A_ORACLE #ifndef OCCI_ORACLE #include &lt;occi.h&gt; #endif / ******************************* ***************************** / //生成PX1对象类型的声明。/ ******************* *********** / class px1：public oracle :: occi :: PObject {protected：oracle :: occi :: Number col1; oracle :: occi :: Number col2; public：void * operator new（size_t size）; void * operator new（size_t size，const oracle :: occi :: Connection * sess，const OCCI_STD_NAMESPACE :: string＆table）; void * operator new（size_t，void * ctxOCCI_）; void * operator new（size_t size，const oracle :: occi :: Connection * sess，const OCCI_STD_NAMESPACE :: string＆tableName，const OCCI_STD_NAMESPACE :: string＆typeName，const OCCI_STD_NAMESPACE :: string＆tableSchema，const OCCI_STD_NAMESPACE :: string＆typeSchema）; void getSQLTypeName（oracle :: occi :: Environment * env，void ** schemaName，unsigned int＆schemaNameLen，void ** typeName，unsigned int＆typeNameLen）const; PX1（）; px1（void * ctxOCCI_）：oracle :: occi :: PObject（ctxOCCI_）{}; static void * readSQL（void * ctxOCCI_）; virtual void readSQL（oracle :: occi :: AnyData＆streamOCCI_）; static void writeSQL（void * objOCCI_，void * ctxOCCI_）; virtual void writeSQL（oracle :: occi :: AnyData＆streamOCCI_）; 〜PX1（）; }; ＃万一</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-38986E01-A479-4BCE-A7AB-7FB51ED64348__GUID-A6F52469-A639-4E97-83ED-5418FFBBA090">
                        <p class="titleinexample">例8-10 ott95b.h的列表</p><pre class="oac_no_warn" dir="ltr">#ifndef TOTT95B_ORACLE #define TOTT95B_ORACLE #ifndef OCCI_ORACLE #include &lt;occi.h&gt; #endif #ifndef TOTT95A_ORACLE #include“tott95a.h”#endif / ******************* ***************************************** / //生成PX3对象的声明类型。/ ******************* *********** / class px3：public oracle :: occi :: PObject {protected：px1 * col1; public：void * operator new（size_t size）; void * operator new（size_t size，const oracle :: occi :: Connection * sess，const OCCI_STD_NAMESPACE :: string＆table）; void * operator new（size_t，void * ctxOCCI_）; void * operator new（size_t size，const oracle :: occi :: Connection * sess，const OCCI_STD_NAMESPACE :: string＆tableName，const OCCI_STD_NAMESPACE :: string＆typeName，const OCCI_STD_NAMESPACE :: string＆tableSchema，const OCCI_STD_NAMESPACE :: string＆typeSchema）; void getSQLTypeName（oracle :: occi :: Environment * env，void ** schemaName，unsigned int＆schemaNameLen，void ** typeName，unsigned int＆typeNameLen）const; PX3（）; px3（void * ctxOCCI_）：oracle :: occi :: PObject（ctxOCCI_）{}; static void * readSQL（void * ctxOCCI_）; virtual void readSQL（oracle :: occi :: AnyData＆streamOCCI_）; static void writeSQL（void * objOCCI_，void * ctxOCCI_）; virtual void writeSQL（oracle :: occi :: AnyData＆streamOCCI_）; 〜PX3（）; }; ＃万一</pre></div>
                     <!-- class="example" -->
                  </div>
               </div>
            </div><a id="LNCPP20395"></a><a id="LNCPP20394"></a><a id="LNCPP20396"></a><a id="LNCPP20393"></a><div class="props_rev_3"><a id="GUID-3DC5D83D-331B-4BE6-820A-DC6330B68751" name="GUID-3DC5D83D-331B-4BE6-820A-DC6330B68751"></a><h3 id="LNCPP-GUID-3DC5D83D-331B-4BE6-820A-DC6330B68751" class="sect3"><span class="enumeration_section">8.6</span>使用OTT实用程序数据类型映射</h3>
               <div>
                  <div class="section">
                     <p>当OTT实用程序从数据库类型生成C ++类时，该结构或类包含与该对象类型的每个属性对应的一个元素。属性的数据类型映射到Oracle对象数据类型中使用的类型。Oracle中的数据类型包括一组预定义的原始类型，并提供用户定义类型的创建，如对象类型和集合。</p>
                     <p>预定义类型集包括大多数程序员熟悉的标准类型，包括数字和字符类型。它还包括大对象数据类型（例如， <code class="codeph">BLOB</code>或<code class="codeph">CLOB</code> ）。
                     </p>
                     <div class="tblformal" id="GUID-3DC5D83D-331B-4BE6-820A-DC6330B68751__G498965">
                        <p class="titleintable">表8-2对象类型属性的C ++对象数据类型映射</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="对象类型属性的C ++对象数据类型映射" width="100%" border="1" summary="This table has 2 columns. Column 1 lists the object attribute types and column 2 provides the C++ mappings." frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="56%" id="d65341e4590">对象属性类型</th>
                                 <th align="left" valign="bottom" width="44%" id="d65341e4593">C ++映射</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="56%" id="d65341e4598" headers="d65341e4590 ">
                                    <p><code class="codeph">BFILE</code></p>
                                 </td>
                                 <td align="left" valign="top" width="44%" headers="d65341e4598 d65341e4593 ">
                                    <p><code class="codeph">BFILE</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="56%" id="d65341e4607" headers="d65341e4590 ">
                                    <p><code class="codeph">BLOB</code></p>
                                 </td>
                                 <td align="left" valign="top" width="44%" headers="d65341e4607 d65341e4593 ">
                                    <p><code class="codeph">斑点</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="56%" id="d65341e4616" headers="d65341e4590 ">
                                    <p><code class="codeph">BINARY_DOUBLE</code></p>
                                 </td>
                                 <td align="left" valign="top" width="44%" headers="d65341e4616 d65341e4593 ">
                                    <p><code class="codeph">B双击</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="56%" id="d65341e4625" headers="d65341e4590 ">
                                    <p><code class="codeph">BINARY_FLOAT</code></p>
                                 </td>
                                 <td align="left" valign="top" width="44%" headers="d65341e4625 d65341e4593 ">
                                    <p><code class="codeph">BFloat</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="56%" id="d65341e4634" headers="d65341e4590 ">
                                    <p><code class="codeph">CHAR（n），CHARACTER（n）</code></p>
                                 </td>
                                 <td align="left" valign="top" width="44%" headers="d65341e4634 d65341e4593 ">
                                    <p><code class="codeph">串</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="56%" id="d65341e4643" headers="d65341e4590 ">
                                    <p><code class="codeph">CLOB</code></p>
                                 </td>
                                 <td align="left" valign="top" width="44%" headers="d65341e4643 d65341e4593 ">
                                    <p><code class="codeph">CLOB</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="56%" id="d65341e4652" headers="d65341e4590 ">
                                    <p><code class="codeph">日期</code></p>
                                 </td>
                                 <td align="left" valign="top" width="44%" headers="d65341e4652 d65341e4593 ">
                                    <p><code class="codeph">日期</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="56%" id="d65341e4661" headers="d65341e4590 ">
                                    <p><code class="codeph">DEC，DEC（n），DEC（n，n）</code></p>
                                 </td>
                                 <td align="left" valign="top" width="44%" headers="d65341e4661 d65341e4593 ">
                                    <p><code class="codeph">数</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="56%" id="d65341e4670" headers="d65341e4590 ">
                                    <p><code class="codeph">DECIMAL，DECIMAL（n），DECIMAL（n，n）</code></p>
                                 </td>
                                 <td align="left" valign="top" width="44%" headers="d65341e4670 d65341e4593 ">
                                    <p><code class="codeph">数</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="56%" id="d65341e4679" headers="d65341e4590 ">
                                    <p><code class="codeph">FLOAT，FLOAT（n），双精度</code></p>
                                 </td>
                                 <td align="left" valign="top" width="44%" headers="d65341e4679 d65341e4593 ">
                                    <p><code class="codeph">数</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="56%" id="d65341e4688" headers="d65341e4590 ">
                                    <p><code class="codeph">INT，INTEGER，SMALLINT</code></p>
                                 </td>
                                 <td align="left" valign="top" width="44%" headers="d65341e4688 d65341e4593 ">
                                    <p><code class="codeph">数</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="56%" id="d65341e4698" headers="d65341e4590 ">
                                    <p><code class="codeph">间隔第二天</code></p>
                                 </td>
                                 <td align="left" valign="top" width="44%" headers="d65341e4698 d65341e4593 ">
                                    <p><code class="codeph">IntervalDS</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="56%" id="d65341e4707" headers="d65341e4590 ">
                                    <p><code class="codeph">间隔年至月</code></p>
                                 </td>
                                 <td align="left" valign="top" width="44%" headers="d65341e4707 d65341e4593 ">
                                    <p><code class="codeph">IntervalYM</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="56%" id="d65341e4716" headers="d65341e4590 ">
                                    <p><code class="codeph">嵌套对象类型</code></p>
                                 </td>
                                 <td align="left" valign="top" width="44%" headers="d65341e4716 d65341e4593 ">
                                    <p>嵌套对象类型的C ++名称</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="56%" id="d65341e4724" headers="d65341e4590 ">
                                    <p><code class="codeph">嵌套表</code></p>
                                 </td>
                                 <td align="left" valign="top" width="44%" headers="d65341e4724 d65341e4593 ">
                                    <p><code class="codeph">矢量&lt;attribute_type&gt;</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="56%" id="d65341e4733" headers="d65341e4590 ">
                                    <p><code class="codeph">NUMBER，NUMBER（n），NUMBER（n，n）</code></p>
                                 </td>
                                 <td align="left" valign="top" width="44%" headers="d65341e4733 d65341e4593 ">
                                    <p><code class="codeph">数</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="56%" id="d65341e4742" headers="d65341e4590 ">
                                    <p><code class="codeph">NUMERIC，NUMERIC（n），NUMERIC（n，n）</code></p>
                                 </td>
                                 <td align="left" valign="top" width="44%" headers="d65341e4742 d65341e4593 ">
                                    <p><code class="codeph">数</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="56%" id="d65341e4751" headers="d65341e4590 ">
                                    <p><code class="codeph">生的</code></p>
                                 </td>
                                 <td align="left" valign="top" width="44%" headers="d65341e4751 d65341e4593 ">
                                    <p><code class="codeph">字节</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="56%" id="d65341e4760" headers="d65341e4590 ">
                                    <p><code class="codeph">真实</code></p>
                                 </td>
                                 <td align="left" valign="top" width="44%" headers="d65341e4760 d65341e4593 ">
                                    <p><code class="codeph">数</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="56%" id="d65341e4769" headers="d65341e4590 ">
                                    <p><code class="codeph">REF</code></p>
                                 </td>
                                 <td align="left" valign="top" width="44%" headers="d65341e4769 d65341e4593 ">
                                    <p><code class="codeph">参考&lt;attribute_type&gt;</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="56%" id="d65341e4778" headers="d65341e4590 ">
                                    <p><code class="codeph">TIMESTAMP，TIMESTAMP与时区，TIMESTAMP与当地时区</code></p>
                                 </td>
                                 <td align="left" valign="top" width="44%" headers="d65341e4778 d65341e4593 ">
                                    <p><code class="codeph">时间戳</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="56%" id="d65341e4787" headers="d65341e4590 ">
                                    <p><code class="codeph">VARCHAR（n）的</code></p>
                                 </td>
                                 <td align="left" valign="top" width="44%" headers="d65341e4787 d65341e4593 ">
                                    <p><code class="codeph">串</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="56%" id="d65341e4797" headers="d65341e4590 ">
                                    <p><code class="codeph">VARCHAR2（N）</code></p>
                                 </td>
                                 <td align="left" valign="top" width="44%" headers="d65341e4797 d65341e4593 ">
                                    <p><code class="codeph">串</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="56%" id="d65341e4806" headers="d65341e4590 ">
                                    <p><code class="codeph">VARRAY</code></p>
                                 </td>
                                 <td align="left" valign="top" width="44%" headers="d65341e4806 d65341e4593 ">
                                    <p><code class="codeph">矢量&lt;attribute_type&gt;</code></p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                  </div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-3DC5D83D-331B-4BE6-820A-DC6330B68751__GUID-B1DE7EE8-6138-4168-9E4F-835957D5C4AA">
                     <p class="titleinexample">示例8-11如何使用OTT实用程序表示对象属性</p>
                     <p>Oracle还包括一组预定义类型，用于表示C ++类中的对象类型属性。考虑以下对象类型定义及其对应的OTT生成的结构声明：</p><pre class="oac_no_warn" dir="ltr">CREATE TYPE employee AS OBJECT（名称VARCHAR2（30），empno NUMBER，deptno NUMBER，hiredate DATE，salary NUMBER）;</pre><p>假设<code class="codeph">CASE</code>参数设置为<code class="codeph">LOWER</code>并且没有类型或属性名称的显式映射，OTT实用程序会生成以下输出：</p><pre class="oac_no_warn" dir="ltr">#ifndef DATATYPES_ORACLE #define DATATYPES_ORACLE #ifndef OCCI_ORACLE #include &lt;occi.h&gt; #endif / ******************************* ***************************** / //生成EMPLOYEE对象类型的声明。/ ******************* *********** / class employee：public oracle :: occi :: PObject {protected：OCCI_STD_NAMESPACE :: string NAME; oracle :: occi :: Number EMPNO; oracle :: occi :: Number DEPTNO; oracle :: occi :: Date HIREDATE; oracle :: occi :: Number SALARY; public：void * operator new（size_t size）; void * operator new（size_t size，const oracle :: occi :: Connection * sess，const OCCI_STD_NAMESPACE :: string＆table）; void * operator new（size_t，void * ctxOCCI_）; void * operator new（size_t size，const oracle :: occi :: Connection * sess，const OCCI_STD_NAMESPACE :: string＆tableName，const OCCI_STD_NAMESPACE :: string＆typeName，const OCCI_STD_NAMESPACE :: string＆tableSchema，const OCCI_STD_NAMESPACE :: string＆typeSchema）; void getSQLTypeName（oracle :: occi :: Environment * env，void ** schemaName，unsigned int＆schemaNameLen，void ** typeName，unsigned int＆typeNameLen）const;雇员（）; employee（void * ctxOCCI_）：oracle :: occi :: PObject（ctxOCCI_）{}; static void * readSQL（void * ctxOCCI_）; virtual void readSQL（oracle :: occi :: AnyData＆streamOCCI_）; static void writeSQL（void * objOCCI_，void * ctxOCCI_）; virtual void writeSQL（oracle :: occi :: AnyData＆streamOCCI_）; 〜雇员（）; }; ＃万一</pre><p><a href="object-type-translator-utility.html#GUID-3DC5D83D-331B-4BE6-820A-DC6330B68751__G498965" title="该表有2列。第1列列出了对象属性类型，第2列提供了C ++映射。">表8-2</a>列出了可以用作OTT实用程序生成的对象数据类型属性的类型的映射。
                     </p>
                  </div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-3DC5D83D-331B-4BE6-820A-DC6330B68751__GUID-8B530001-790F-46FE-A68E-5B1E68793D11">
                     <p class="titleinexample">示例8-12如何使用OTT实用程序映射对象数据类型</p>
                     <p>该示例假定已创建以下数据库类型：</p><pre class="oac_no_warn" dir="ltr">CREATE TYPE my_varray AS VARRAY（5）的整数; CREATE TYPE object_type AS OBJECT（object_name VARCHAR2（20））; CREATE TYPE other_type AS OBJECT（object_number NUMBER）; CREATE TYPE my_table AS TABLE OF object_type; CREATE TYPE many_types AS OBJECT（the_varchar VARCHAR2（30），the_char CHAR（3），the_blob BLOB，the_clob CLOB，the_object object_type，another_ref REF other_type，the_ref REF many_types，the_varray my_varray，the_table my_table，the_date DATE，the_num NUMBER，the_raw RAW（ 255））;</pre><p>存在<code class="codeph">INTYPE</code>文件，包括以下内容：</p><pre class="oac_no_warn" dir="ltr">CASE = LOWER TYPE many_types</pre><p>以下是C ++的OTT类型映射示例，给出了上一节示例中创建的类型，以及包含以下内容的<code class="codeph">INTYPE</code>文件：</p><pre class="oac_no_warn" dir="ltr">CASE = LOWER TYPE many_types</pre><pre class="oac_no_warn" dir="ltr">#ifndef MYFILENAME_ORACLE #define MYFILENAME_ORACLE #ifndef OCCI_ORACLE #include &lt;occi.h&gt; #endif / ******************************* ***************************** / //生成OBJECT_TYPE对象类型的声明。/ ******************* *********** / class object_type：public oracle :: occi :: PObject {protected：OCCI_STD_NAMESPACE :: string object_name; public：void * operator new（size_t size）; void * operator new（size_t size，const oracle :: occi :: Connection * sess，const OCCI_STD_NAMESPACE :: string＆table）; void getSQLTypeName（oracle :: occi :: Environment * env，void ** schemaName，unsigned int＆schemaNameLen，void ** typeName，unsigned int＆typeNameLen）const; object_type的（）; object_type（void * ctxOCCI_）：oracle :: occi :: PObject（ctxOCCI_）{}; static void * readSQL（void * ctxOCCI_）; virtual void readSQL（oracle :: occi :: AnyData＆streamOCCI_）; static void writeSQL（void * objOCCI_，void * ctxOCCI_）; virtual void writeSQL（oracle :: occi :: AnyData＆streamOCCI_）; }; / ******************* *********** / //为OTHER_TYPE对象类型生成声明。/ ******************* *********** / class other_type：public oracle :: occi :: PObject {protected：oracle :: occi :: Number object_number; public：void * operator new（size_t size）; void * operator new（size_t size，const oracle :: occi :: Connection * sess，const OCCI_STD_NAMESPACE :: string＆table）; void getSQLTypeName（oracle :: occi :: Environment * env，void ** schemaName，unsigned int＆schemaNameLen，void ** typeName，unsigned int＆typeNameLen）const; other_type（）; other_type（void * ctxOCCI_）：oracle :: occi :: PObject（ctxOCCI_）{}; static void * readSQL（void * ctxOCCI_）; virtual void readSQL（oracle :: occi :: AnyData＆streamOCCI_）; static void writeSQL（void * objOCCI_，void * ctxOCCI_）; virtual void writeSQL（oracle :: occi :: AnyData＆streamOCCI_）; }; / ******************* *********** / //为MANY_TYPES对象类型生成声明。/ ******************* *********** / class many_types：public oracle :: occi :: PObject {protected：OCCI_STD_NAMESPACE :: string the_varchar; OCCI_STD_NAMESPACE :: string the_char; oracle :: occi :: Blob the_blob; oracle :: occi :: Clob the_clob; object_type * the_object; oracle :: occi :: Ref &lt;other_type&gt; another_ref; oracle :: occi :: Ref &lt;many_types&gt; the_ref; OCCI_STD_NAMESPACE :: vector &lt;oracle :: occi :: Number&gt; the_varray; OCCI_STD_NAMESPACE :: vector &lt;object_type *&gt; the_table; oracle :: occi :: Date the_date; oracle :: occi :: Number the_num; oracle :: occi :: Bytes the_raw; public：void * operator new（size_t size）; void * operator new（size_t size，const oracle :: occi :: Connection * sess，const OCCI_STD_NAMESPACE :: string＆table）; void getSQLTypeName（oracle :: occi :: Environment * env，void ** schemaName，unsigned int＆schemaNameLen，void ** typeName，unsigned int＆typeNameLen）const; many_types（）; many_types（void * ctxOCCI_）：oracle :: occi :: PObject（ctxOCCI_）{}; static void * readSQL（void * ctxOCCI_）; virtual void readSQL（oracle :: occi :: AnyData＆streamOCCI_）; static void writeSQL（void * objOCCI_，void * ctxOCCI_）; virtual void writeSQL（oracle :: occi :: AnyData＆streamOCCI_）; }; ＃万一</pre><p>OTT实用程序生成以下C ++类声明（注释不是OTT输出的一部分，并且仅为了阐明示例而添加）：</p>
                     <p>对于C ++，当<code class="codeph">TRANSITIVE=TRUE</code> ，OTT实用程序会自动转换用作要转换类型的属性的任何类型，包括仅由对象类型属性中的指针或<code class="codeph">REF</code>访问的类型。即使在C ++示例的<code class="codeph">INTYPE</code>文件中仅指定了<code class="codeph">many_types</code>对象， <code class="codeph">INTYPE</code>为所有对象类型生成类声明，包括<code class="codeph">other_type</code>对象，该对象仅由<code class="codeph">many_types</code>对象中的<code class="codeph">REF</code>访问。
                     </p>
                  </div>
                  <!-- class="example" -->
                  <div class="section">
                     <p>本节包括以下主题： <a href="object-type-translator-utility.html#GUID-75715714-22B6-4CD4-B022-E27AD7BED67A">默认名称映射</a> 。
                     </p>
                  </div>
                  <!-- class="section" -->
               </div><a id="LNCPP20397"></a><div class="props_rev_3"><a id="GUID-75715714-22B6-4CD4-B022-E27AD7BED67A" name="GUID-75715714-22B6-4CD4-B022-E27AD7BED67A"></a><h4 id="LNCPP-GUID-75715714-22B6-4CD4-B022-E27AD7BED67A" class="sect4"><span class="enumeration_section">8.6.1</span>默认名称映射</h4>
                  <div>
                     <p>当OTT实用程序为对象类型或属性创建C或C ++标识符名称时，它会将名称从数据库字符集转换为合法的C或C ++标识符。首先，名称从数据库字符集转换为OTT实用程序使用的字符集。接下来，如果在<code class="codeph">INTYPE</code>文件中提供了结果名称的翻译，则使用该翻译。否则，OTT实用程序将字符逐个字符转换为编译器字符集，并应用CASE参数中指定的字符大小写。以下文本更详细地描述了这一点。
                     </p>
                     <p>当OTT实用程序读取数据库实体的名称时，该名称将自动从数据库字符集转换为OTT实用程序使用的字符集。为了使OTT实用程序成功读取数据库实体的名称，必须在OTT字符集中找到名称的所有字符，尽管字符在两个字符集中可能具有不同的编码。</p>
                     <p>保证OTT实用程序使用的字符集包含所有必需字符的最简单方法是使其与数据库字符集相同。但请注意，OTT字符集必须是编译器字符集的超集。也就是说，如果编译器字符集是7位ASCII，则OTT字符集必须包含7位ASCII作为子集，如果编译器字符集是7位EBCDIC，则OTT字符集必须包括7-位EBCDIC作为子集。用户通过设置<code class="codeph">NLS_LANG</code>环境变量或某些其他特定于操作系统的机制来指定OTT实用程序使用的字符集。
                     </p>
                     <p>一旦OTT实用程序读取了数据库实体的名称，它就会将名称从OTT实用程序使用的字符集转换为编译器的字符集。如果名称的翻译出现在<code class="codeph">INTYPE</code>文件中，则OTT实用程序将使用该翻译。
                     </p>
                     <p>否则，OTT实用程序会尝试按如下方式转换名称：</p>
                     <ol>
                        <li>
                           <p>如果OTT字符集是多字节字符集，则名称中具有单字节等效字符的所有多字节字符将转换为那些单字节等效字符。</p>
                        </li>
                        <li>
                           <p>名称从OTT字符集转换为编译器字符集。编译器字符集是单字节字符集，例如<code class="codeph">US7ASCII</code> 。</p>
                        </li>
                        <li>
                           <p>根据<code class="codeph">CASE</code>参数的定义方式设置字母<code class="codeph">CASE</code> ，并且任何在C或C ++标识符中不合法或在编译器字符集中没有翻译的字符都由下划线字符（ <code class="codeph">_</code> ）替换。如果至少有一个字符被下划线替换，则OTT实用程序会发出警告消息。如果名称中的所有字符都被下划线替换，则OTT实用程序会显示错误消息。
                           </p>
                        </li>
                     </ol>
                     <p>逐个字符的名称转换不会改变编译器字符集中出现的下划线，数字或单字节字母，因此不会更改合法的C或C ++标识符。</p>
                     <p>例如，名称转换可以将重音单字节字符（例如<span class="italic">o</span> ，带有变音符号或带有重音符号的<span class="italic">a）转换</span>为<span class="italic">o</span>或<span class="italic">a</span> ，没有重音，并且可以将多字节字母转换为其单字节等效字符。如果名称包含缺少单字节等效项的多字节字符，则名称转换通常会失败。在这种情况下，用户必须在<code class="codeph">INTYPE</code>文件中指定名称翻译。
                     </p>
                     <p>OTT实用程序不检测由两个或多个数据库标识符映射到同一C名称引起的命名冲突，也不检测数据库标识符映射到C关键字的命名问题。</p>
                  </div>
               </div>
            </div><a id="LNCPP20399"></a><a id="LNCPP20398"></a><div class="props_rev_3"><a id="GUID-B5D1FB85-549E-484A-B492-24ADE223C24E" name="GUID-B5D1FB85-549E-484A-B492-24ADE223C24E"></a><h3 id="LNCPP-GUID-B5D1FB85-549E-484A-B492-24ADE223C24E" class="sect3"><span class="enumeration_section">8.7</span> OUTTYPE文件概述</h3>
               <div>
                  <p><code class="codeph">OUTTYPE</code>文件在OTT命令行上命名。当OTT实用程序生成C ++头文件时，它还会将转换结果写入<code class="codeph">OUTTYPE</code>文件。此文件包含每个已翻译类型的条目，包括其版本字符串和其C ++表示形式所写的头文件。
                  </p>
                  <p>所述<code class="codeph">OUTTYPE</code>从一个OTT效用运行文件可以被用作<code class="codeph">INTYPE</code>的OTT效用的后续调用文件。
                  </p>
                  <p>OTT实用程序在执行转换之前分析<code class="codeph">INTYPE</code>文件中的类型依赖关系类型，并根据需要转换其他类型。
                  </p>
                  <p>您可以指示OTT实用程序是否应生成<code class="codeph">INTYPE</code>文件中未指定的所需对象类型。设置<code class="codeph">TRANSITIVE=FALSE</code>以便OTT实用程序不生成所需的对象类型。默认值为<code class="codeph">TRANSITIVE=TRUE</code> 。</p>
                  <div class="example" id="GUID-B5D1FB85-549E-484A-B492-24ADE223C24E__GUID-FA3BF57D-C35A-4AA4-8B18-00145B6511BF">
                     <p class="titleinexample">例8-13 OTT实用程序生成的OUTTYPE文件</p>
                     <p>在此<code class="codeph">INTYPE</code>文件中，程序员指定OTT生成的C ++标识符的大小写，并提供应翻译的类型列表。在其中两种类型中，指定了命名约定。这是运行OTT实用程序后<code class="codeph">OUTTYPE</code>文件的样子：</p>
                     <p>以下示例显示了t：</p><pre class="oac_no_warn" dir="ltr">CASE = LOWER TYPE EMPLOYEE AS员工VERSION =“$ 8.0”HFILE = demo.h TRANSLATE SALARY $ AS薪水DEPTNO AS部门类型地址作为地址VERSION =“$ 8.0”HFILE = demo.h类型项目为VERSION =“$ 8.0”HFILE = demo.h TYPE“Person”AS Person VERSION =“$ 8.0”HFILE = demo.h TYPE PURCHASE_ORDER as p_o VERSION =“$ 8.0”HFILE = demo.h</pre><p>检查<code class="codeph">OUTTYPE</code>文件的内容时，您可能会发现列出的类型未包含在<code class="codeph">INTYPE</code>文件规范中。例如，考虑<code class="codeph">INTYPE</code>文件仅指定要转换<code class="codeph">person</code>类型的情况：</p><pre class="oac_no_warn" dir="ltr">案例=较低级别的人</pre><p>如果<code class="codeph">person</code>类型的定义包含<code class="codeph">address</code>类型的属性，则<code class="codeph">OUTTYPE</code>文件包括<code class="codeph">PERSON</code>和<code class="codeph">ADDRESS</code>条目。如果没有首先翻译<code class="codeph">address</code>则无法完全翻译<code class="codeph">person</code>类型。
                     </p>
                  </div>
                  <!-- class="example" -->
               </div>
            </div><a id="LNCPP20401"></a><a id="LNCPP20400"></a><div class="props_rev_3"><a id="GUID-048D2653-6462-406A-A43C-26BF9B3FD6FD" name="GUID-048D2653-6462-406A-A43C-26BF9B3FD6FD"></a><h3 id="LNCPP-GUID-048D2653-6462-406A-A43C-26BF9B3FD6FD" class="sect3"><span class="enumeration_section">8.8</span>使用OTT实用程序和OCCI应用程序</h3>
               <div>
                  <div class="section">
                     <p>OTT实用程序生成对象并将SQL数据类型映射到C ++类。OTT实用程序还实现了OCCI在实例化对象时调用的一些方法，以及在OCCI应用程序中调用的函数来注册与环境的映射。这些声明存储在您在OCCI应用程序中包含（ <code class="codeph">#include</code> ）的头文件中。注册映射的函数的原型被写入单独的头文件，您也将其包含在OCCI应用程序中。方法实现存储在与OCCI应用程序链接的C ++源代码文件（扩展名为<code class="codeph">.cpp</code> ）中。注册映射的函数存储在单独的C ++（ <span class="italic"><code class="codeph">xxx</code></span> <code class="codeph">.cpp</code> ）文件中，该文件也与应用程序链接。
                     </p>
                     <p><a href="object-type-translator-utility.html#GUID-048D2653-6462-406A-A43C-26BF9B3FD6FD__CHDCICIE">图8-1</a>显示了将OTT实用程序与OCCI一起使用所涉及的步骤。这些步骤如下图所示。
                     </p>
                     <div class="figure" id="GUID-048D2653-6462-406A-A43C-26BF9B3FD6FD__CHDCICIE">
                        <p class="titleinfigure">图8-1带OCCI的OTT实用程序</p><img src="img/ott_utility_with_occi.gif" alt="下面是图8-1的描述" title="下面是图8-1的描述" longdesc="img_text/ott_utility_with_occi.html"><br><a href="img_text/ott_utility_with_occi.html">“图8-1带OCCI的OTT实用程序”的描述</a></div>
                     <!-- class="figure" -->
                  </div>
                  <!-- class="section" -->
                  <ol>
                     <li class="stepexpand"><span>使用SQL DLL在数据库中创建类型定义。</span></li>
                     <li class="stepexpand"><span>创建包含要由OTT实用程序转换的数据库类型的<code class="codeph">INTYPE</code>文件。</span></li>
                     <li class="stepexpand"><span>指定应生成C ++并调用OTT实用程序。</span><div>
                           <p>然后OTT实用程序生成以下文件：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>头文件（扩展名为<code class="codeph">.h</code> ），包含对象类型的C ++类表示;文件名由<code class="codeph">HFILE</code>参数在OTT命令行上指定。
                                 </p>
                              </li>
                              <li>
                                 <p>一个头文件，包含注册映射的函数原型（ <code class="codeph">MAPFUNC</code> ）。
                                 </p>
                              </li>
                              <li>
                                 <p>一个C ++源文件（扩展名为<code class="codeph">.cpp</code> ），包含OCCI在实例化对象时调用的静态方法;文件名由<code class="codeph">CPPFILE</code>参数在OTT命令行上指定。不要直接从您的OCCI应用程序调用这些方法。
                                 </p>
                              </li>
                              <li>
                                 <p>包含用于向环境注册映射的函数的文件（扩展名为<code class="codeph">.cpp</code> ）;文件名由<code class="codeph">MAPFILE</code>参数在OTT命令行上指定。
                                 </p>
                              </li>
                              <li>
                                 <p>一个文件（ <code class="codeph">OUTTYPE</code>文件），包含每个已翻译类型的条目，包括版本字符串和写入的文件;文件名由<code class="codeph">OUTTYPE</code>参数在OTT命令行中指定。
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </li>
                     <li class="stepexpand"><span>编写OCCI应用程序并将OTT实用程序创建的头文件包含在OCCI源代码文件中。</span><div>
                           <p>应用程序声明一个环境并调用函数<code class="codeph">MAPFUNC</code>来注册映射。
                           </p>
                        </div>
                     </li>
                     <li class="stepexpand"><span>编译OCCI应用程序以创建OCCI目标代码，并将目标代码链接到OCCI库以创建程序可执行文件。</span></li>
                  </ol>
               </div>
            </div><a id="LNCPP20403"></a><a id="LNCPP20402"></a><div class="props_rev_3"><a id="GUID-24AA6ED3-C895-469B-8A72-D7AFD570C529" name="GUID-24AA6ED3-C895-469B-8A72-D7AFD570C529"></a><h3 id="LNCPP-GUID-24AA6ED3-C895-469B-8A72-D7AFD570C529" class="sect3"><span class="enumeration_section">8.9</span>生成OTT实用程序生成的C ++类</h3>
               <div>
                  <div class="section">
                     <p>当OTT实用程序从数据库对象类型生成C ++类时，类声明包含与对象类型的每个属性对应的一个元素。属性的数据类型映射到Oracle对象数据类型中使用的类型，如<a href="object-type-translator-utility.html#GUID-3DC5D83D-331B-4BE6-820A-DC6330B68751__G498965" title="该表有2列。第1列列出了对象属性类型，第2列提供了C ++映射。">表8-2中</a>所定义。
                     </p>
                     <p>对于每个类，生成两个新的运算符<code class="codeph">readSQL()</code>和<code class="codeph">writeSQL()</code>方法。它们被OCCI用于编组和解组对象。
                     </p>
                     <p>默认情况下，OTT实用程序为对象类型生成的C ++类是从<code class="codeph">PObject</code>类派生的，因此类中生成的构造函数也派生自<code class="codeph">PObject</code>类。对于继承的数据库类型，类是从父类型类派生的，生成的构造函数也是如此，并且只包含与父类不在的属性对应的元素。
                     </p>
                     <p>包含与数据库类型属性和方法声明对应的元素的类声明包含在OTT实用程序生成的头文件中。方法实现包含在OTT实用程序生成的<code class="codeph">CPPFILE</code>文件中。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-24AA6ED3-C895-469B-8A72-D7AFD570C529__GUID-6766A72E-D477-4873-AFAF-9F592E7CDD8B">
                     <p class="titleinexample">示例8-14如何使用OTT实用程序生成C ++类</p>
                     <p>此示例演示如何使用OTT实用程序生成C ++类：</p>
                     <ol>
                        <li>
                           <p>定义类型：</p><pre class="oac_no_warn" dir="ltr">CREATE TYPE FULL_NAME AS OBJECT（first_name CHAR（20），last_name CHAR（20））; CREATE TYPE ADDRESS AS OBJECT（状态CHAR（20），zip CHAR（20））;创建类型ADDRESS_TAB作为REF ADDRESS的VARRAY（3）;创建类型人员作为对象（ID号，名称FULL_NAME，curr_addr REF ADDRESS，prev_addr_l ADDRESS_TAB）NOT FINAL;创建学生类型学生（school_name CHAR（20））;</pre></li>
                        <li>
                           <p>提供<code class="codeph">INTYPE</code>文件：</p><pre class="oac_no_warn" dir="ltr">CASE = SAME MAPFILE = RegisterMappings_3.cpp TYPE FULL_NAME AS FullName TRANSLATE first_name as FirstName last_name as LastName TYPE ADDRESS TYPE PERSON TYPE STUDENT</pre></li>
                        <li>
                           <p>调用OTT实用程序：</p><pre class="oac_no_warn" dir="ltr">ott userid = demousr intype = demoin_3.typ outype = demoout_3.typ code = cpp hfile = demo_3.h cppfile = demo_3.cpp</pre></li>
                     </ol>
                  </div>
                  <!-- class="example" -->
                  <div class="section">
                     <div class="p">本节包括以下主题：<ul style="list-style-type:disc">
                           <li>
                              <p><a href="object-type-translator-utility.html#GUID-7947A68A-03B8-4008-B6EC-7667C54F0EFF">映射注册表功能</a></p>
                           </li>
                           <li>
                              <p><a href="object-type-translator-utility.html#GUID-ACB9795D-378E-4D18-A31B-AA674410BE65">扩展C ++类</a></p>
                           </li>
                           <li>
                              <p><a href="object-type-translator-utility.html#GUID-497FB400-8E07-4810-B481-ADCCA703C1F9">继承用户添加的代码</a></p>
                           </li>
                        </ul>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div><a id="LNCPP20404"></a><div class="props_rev_3"><a id="GUID-7947A68A-03B8-4008-B6EC-7667C54F0EFF" name="GUID-7947A68A-03B8-4008-B6EC-7667C54F0EFF"></a><h4 id="LNCPP-GUID-7947A68A-03B8-4008-B6EC-7667C54F0EFF" class="sect4"><span class="enumeration_section">8.9.1</span>映射注册表功能</h4>
                  <div>
                     <p>OTT实用程序生成一个向环境注册映射的函数。该函数包含通过调用OTT实用程序转换的所有类型的映射。函数名称在<code class="codeph">MAPFUNC</code>参数中指定，或者，如果未指定该参数，则从<code class="codeph">MAPFILE</code>参数派生。该函数的唯一参数是指向<code class="codeph">Environment</code>的指针。
                     </p>
                     <p>该函数使用提供的<code class="codeph">Environment</code>获取<code class="codeph">Map</code> ，然后注册每个翻译类型的映射。
                     </p>
                  </div>
               </div><a id="LNCPP20406"></a><a id="LNCPP20405"></a><div class="props_rev_2"><a id="GUID-ACB9795D-378E-4D18-A31B-AA674410BE65" name="GUID-ACB9795D-378E-4D18-A31B-AA674410BE65"></a><h4 id="LNCPP-GUID-ACB9795D-378E-4D18-A31B-AA674410BE65" class="sect4"><span class="enumeration_section">8.9.2</span>扩展C ++类</h4>
                  <div>
                     <div class="section">
                        <p>要增强OTT实用程序生成的类的功能，可以派生新类。您还可以向类添加方法，但由于存在固有风险，Oracle不建议这样做。</p>
                        <div class="infoboxnotealso" id="GUID-ACB9795D-378E-4D18-A31B-AA674410BE65__GUID-DB2CC36E-B65A-4F0A-B699-4881FBC5014D">
                           <p class="notep1">也可以看看：</p>
                           <p><span class="q">“ <a href="object-type-translator-utility.html#GUID-497FB400-8E07-4810-B481-ADCCA703C1F9">携带用户添加代码</a> ”</span>有关如何使用OTT标记保留要在OTT生成的文件中<span class="q"><a href="object-type-translator-utility.html#GUID-497FB400-8E07-4810-B481-ADCCA703C1F9">添加的代码</a></span>的详细信息</p>
                        </div>
                        <p>同时生成<code class="codeph">CAddress</code>和<code class="codeph">MyAddress</code>从SQL对象类型类<code class="codeph">ADDRESS</code> ， <code class="codeph">MyAddress</code>类可以衍生自<code class="codeph">CAddress</code>类。然后，OTT实用程序必须以下列方式更改它生成的代码：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p>通过使用<code class="codeph">MyAddress</code>类而不是<code class="codeph">CAddress</code>类来表示数据库类型为<code class="codeph">ADDRESS</code>属性</p>
                           </li>
                           <li>
                              <p>通过使用<code class="codeph">MyAddress</code>类而不是<code class="codeph">CAddress</code>类来表示数据库类型为<code class="codeph">ADDRESS</code>向量和<code class="codeph">REF</code>元素</p>
                           </li>
                           <li>
                              <p>通过使用<code class="codeph">MyAddress</code>类而不是<code class="codeph">CAddress</code>类作为从<code class="codeph">ADDRESS</code>继承的数据库对象类型的基类。即使派生类是<code class="codeph">MyAddress</code>的子类型， <code class="codeph">MyAddress</code>的<code class="codeph">readSQL</code> （）和<code class="codeph">writeSQL()</code>方法也是<code class="codeph">CAddress</code>类的方法。
                              </p>
                           </li>
                        </ul>
                        <div class="infoboxnote" id="GUID-ACB9795D-378E-4D18-A31B-AA674410BE65__GUID-F63FE63B-9508-47D5-8986-7C24D6FCBFE5">
                           <p class="notep1">注意：</p>
                           <p>当一个类被扩展并用作另一个生成的类的基类时，必须在单独的文件中生成<span class="italic">继承</span>类型类和<span class="italic">继承的</span>类型类。
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-ACB9795D-378E-4D18-A31B-AA674410BE65__GUID-3EC3732E-10F7-49D8-BD02-1A4D82AC046B">
                        <p class="titleinexample">示例8-15如何使用OTT实用程序扩展C ++类</p>
                        <p>要使用OTT实用程序生成<code class="codeph">CAddress</code>类，它源自<code class="codeph">MyAddress</code>类），以下条款必须在指定<code class="codeph">TYPE</code>语句：</p><pre class="oac_no_warn" dir="ltr">TYPE ADDRESS GENERATE CAdress AS MyAddress</pre><p>鉴于数据库类型为<code class="codeph">FULL_NAME</code> ， <code class="codeph">ADDRESS</code> ， <code class="codeph">PERSON</code>和<code class="codeph">PFGRFDENT</code>因为它们之前已创建并更改<code class="codeph">INTYPE</code>文件以包含<code class="codeph">GENERATE...</code><code class="codeph">AS</code>条款：</p><pre class="oac_no_warn" dir="ltr">CASE = SAME MAPFILE = RegisterMappings_5.cpp TYPE FULL_NAME GENERATE CFullName AS MyFullName TRANSLATE first_name as FirstName last_name as LastName TYPE ADDRESS GENERATE CAddress AS MyAddress TYPE PERSON GENERATE CPerson AS MyPerson TYPE STUDENT GENERATE CStudent AS MyStudent</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="LNCPP20407"></a><div class="props_rev_3"><a id="GUID-497FB400-8E07-4810-B481-ADCCA703C1F9" name="GUID-497FB400-8E07-4810-B481-ADCCA703C1F9"></a><h4 id="LNCPP-GUID-497FB400-8E07-4810-B481-ADCCA703C1F9" class="sect4"><span class="enumeration_section">8.9.3</span>继承用户添加的代码</h4>
                  <div>
                     <div class="section">
                        <p>为了扩展OTT生成代码的功能，程序员有时可能希望在OTT生成的文件中添加代码。OTT可以区分OTT生成的代码和用户添加的代码的方式是寻找一些预定义的标记（标记）。OTT识别<code class="codeph">OTT_USERCODE_START</code>作为用户代码标记的开始，和<code class="codeph">OTT_USERCODE_END</code>作为用户代码标志的结束。
                        </p>
                        <p>对于OTT标记支持，用户块定义为</p><pre class="oac_no_warn" dir="ltr">OTT_USERCODE_START +用户添加的代码+ OTT_USERCODE_END</pre><p>OTT标记支持可以在* .h和* .cpp文件中转发用户添加的块。</p>
                        <div class="p">本节包括以下主题：<ul style="list-style-type:disc">
                              <li>
                                 <p><a href="object-type-translator-utility.html#GUID-14BA9888-5DA3-44C6-98F1-CB994464F1D1">如何使用OTT标记的属性</a></p>
                              </li>
                              <li>
                                 <p><a href="object-type-translator-utility.html#GUID-6E20D3B2-2960-4517-B920-F77EC4BEE410">使用OTT标记</a></p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div><a id="LNCPP20408"></a><div class="props_rev_3"><a id="GUID-14BA9888-5DA3-44C6-98F1-CB994464F1D1" name="GUID-14BA9888-5DA3-44C6-98F1-CB994464F1D1"></a><h5 id="LNCPP-GUID-14BA9888-5DA3-44C6-98F1-CB994464F1D1" class="sect5"><span class="enumeration_section">8.9.3.1</span>如何使用OTT标记的属性</h5>
                     <div>
                        <div class="section">
                           <p>这些项目描述了OTT标记支持的属性：</p>
                        </div>
                        <!-- class="section" -->
                        <ol>
                           <li class="stepexpand"><span>用户必须在调用OTT时首次使用命令行选项<code class="codeph">USE_MARKER=TRUE</code>来生成文件。</span></li>
                           <li class="stepexpand"><span>用户应该像其他C ++语句一样处理标记;使用命令行选项<code class="codeph">USE_MARKER=TRUE</code>时，生成文件中由OTT定义的标记如下：</span><div><pre class="oac_no_warn" dir="ltr">#ifndef OTT_USERCODE_START #define OTT_USERCODE_START #endif #ifndef OTT_USERCODE_END #define OTT_USERCODE_END #endif</pre></div>
                           </li>
                           <li class="stepexpand"><span>标记<code class="codeph">OTT_USERCODE_START</code>和<code class="codeph">OTT_USERCODE_END</code>必须以空格开头和之后。</span></li>
                           <li class="stepexpand"><span>OTT将标记中给出的文本或代码与标记一起复制，同时下次生成代码。</span><div>
                                 <p>用户修改代码：</p><pre class="oac_no_warn" dir="ltr">1 // ---修改生成的代码2 OTT_USERCODE_START 3 // ---包括“myfullname.h”4 #ifndef MYFULLNAME_ORACLE 5 #include“myfullname.h”6 #endif 7 OTT_USERCODE_END 8 // ---代码加法结束</pre><p>前进代码：</p><pre class="oac_no_warn" dir="ltr">1 OTT_USERCODE_START 2 // ---包括“myfullname.h”3 #ifndef MYFULLNAME_ORACLE 4 #include“myfullname.h”5 #endif 6 OTT_USERCODE_END</pre></div>
                           </li>
                           <li class="stepexpand"><span>如果数据库<code class="codeph">TYPE</code>或<code class="codeph">INTYPE</code>文件发生更改，则OTT不会正确执行用户添加的代码，如以下情况所示：</span><div>
                                 <ul style="list-style-type:disc">
                                    <li>
                                       <p>如果用户修改了类型名称的大小写，则OTT无法确定先前与代码关联的类名称，因为用户在<code class="codeph">INTYPE</code>文件中修改了类名称的情况。
                                       </p><pre class="oac_no_warn" dir="ltr"><span class="bold">CASE = UPPER CASE = LOWER</span> TYPE employee TYPE employee TRANSLATE SALARY $ AS salary TRANSLATE SALARY $ AS salary DEPTNO AS department DEPTNO AS department TYPE ADDRESS TYPE ADDRESS TYPE item TYPE item TYPE“Person”TYPE“Person”TYPE PURCHASE_ORDER as p_o TYPE PURCHASE_ORDER as p_o</pre></li>
                                    <li>
                                       <p>如果用户要求生成具有不同名称的类（ <code class="codeph">INTYPE</code>文件的<code class="codeph">GENERATE AS</code>子句），则OTT无法确定先前与代码关联的类名，因为用户在<code class="codeph">INTYPE</code>文件中修改了类名。
                                       </p><pre class="oac_no_warn" dir="ltr">CASE = LOWER CASE = LOWER TYPE employee TYPE employee TRANSLATE SALARY $ AS salary TRANSLATE SALARY $ AS salary DEPTNO AS department DEPTNO AS department TYPE ADDRESS TYPE ADDRESS TYPE item TYPE item TYPE“Person”TYPE <span class="bold">TYPE PURCHASE_ORDER as p_o TYPE PURCHASE_ORDER as</span> <span class="bold">purchase_order</span>
</pre></li>
                                 </ul>
                              </div>
                           </li>
                           <li class="stepexpand"><span>如果OTT在解析<code class="codeph">.h</code>或<code class="codeph">.cpp</code>文件时遇到错误，它会报告错误并使文件保持错误，以便用户可以返回并更正报告的错误，然后重新运行OTT。</span></li>
                           <li class="stepexpand"><span>OTT标记错误，如果：</span><div>
                                 <ul style="list-style-type:disc">
                                    <li>
                                       <p>它没有找到匹配的<code class="codeph">OTT_USERCODE_END</code>为<code class="codeph">OTT_USERCODE_START</code>遇到</p>
                                    </li>
                                    <li>
                                       <p>标记嵌套（OTT找到下一个<code class="codeph">OTT_USERCODE_START</code>之前<code class="codeph">OTT_USERCODE_END</code>被发现以前<code class="codeph">OTT_USERCODE_START</code> ）</p>
                                    </li>
                                    <li>
                                       <p><code class="codeph">OTT_USERCODE_END</code>之前遇到<code class="codeph">OTT_USERCODE_START</code></p>
                                    </li>
                                 </ul>
                              </div>
                           </li>
                        </ol>
                     </div>
                  </div><a id="LNCPP20409"></a><div class="props_rev_2"><a id="GUID-6E20D3B2-2960-4517-B920-F77EC4BEE410" name="GUID-6E20D3B2-2960-4517-B920-F77EC4BEE410"></a><h5 id="LNCPP-GUID-6E20D3B2-2960-4517-B920-F77EC4BEE410" class="sect5"><span class="enumeration_section">8.9.3.2</span>使用OTT标记</h5>
                     <div>
                        <div class="section">
                           <p>用户必须使用命令行选项<code class="codeph">USE_MARKER=TRUE</code>才能启用标记支持。OTT标记有两种通用方式可以转发用户添加的代码：</p>
                        </div>
                        <!-- class="section" -->
                        <ol>
                           <li class="stepexpand"><span><span class="bold">用户代码添加在.h文件中。</span></span><div>
                                 <ul style="list-style-type:disc">
                                    <li>
                                       <p><span class="bold">用户代码在全局范围内添加。</span> 当用户必须包含不同的头文件，前向声明等时，通常就是这种情况。请参阅稍后提供的代码示例。
                                       </p>
                                    </li>
                                    <li>
                                       <p><span class="bold">在类声明中添加用户代码。</span> 在任何时候，OTT生成的类声明都具有数据成员的私有范围和方法的公共范围，或者数据成员的受保护范围和方法的公共范围。可以在任一访问说明符中的所有OTT生成声明之后添加用户块。
                                       </p>
                                    </li>
                                 </ul>
                                 <p>如何使用OTT实用程序将用户代码添加到头文件</p><pre class="oac_no_warn" dir="ltr">...#ifndef OTT_USERCODE_START #define OTT_USERCODE_START #endif #ifndef OTT_USERCODE_END #define OTT_USERCODE_END #endif #ifndef OCCI_ORACLE #include &lt;occi.h&gt; #endif OTT_USERCODE_START //用户添加的代码...OTT_USERCODE_END #ifndef ...//生成的OTT包括#include“...”＃endif OTT_USERCODE_START //用户添加的代码...OTT_USERCODE_END类&lt;class_name_1&gt;：public oracle :: occi :: PObject {protected：...// OTT生成的数据成员OTT_USERCODE_START //用户为数据成员/方法添加的代码... //声明/内联方法OTT_USERCODE_END public：void * operator new（size_t size）; ...OTT_USERCODE_START //用户为数据成员/方法添加了代码... //声明/内联方法定义OTT_USERCODE_END}; OTT_USERCODE_START //用户添加的代码...OTT_USERCODE_END类&lt;class_name_2&gt;：public oracle :: occi :: PObject {...}; OTT_USERCODE_START //用户添加的代码...OTT_USERCODE_END ...#endif // .h文件的结尾</pre></div>
                           </li>
                           <li class="stepexpand"><span><span class="bold">用户代码添加在.cpp文件中。</span>OTT支持在OTT标记内添加新的用户定义方法。必须在文件的开头添加用户块，在包含之后和OTT生成的方法定义之前添加用户块。如果存在多个OTT生成的<code class="codeph">include</code> s，则还可以在OTT生成的包含之间添加用户代码。在<span class="italic"><code class="codeph">xxx</code></span> <code class="codeph">.cpp</code>文件的任何其他部分中添加的用户代码不会继续使用。</span><div>
                                 <p>如何使用OTT实用程序将用户代码添加到源文件</p><pre class="oac_no_warn" dir="ltr">#ifndef OTT_USERCODE_START #define OTT_USERCODE_START #endif #ifndef OTT_USERCODE_END #define OTT_USERCODE_END #endif ...OTT_USERCODE_START //用户添加的代码...OTT_USERCODE_END ...OTT_USERCODE_START //用户添加的代码...OTT_USERCODE_END / ************************************************ ************* /生成...对象类型的方法实现。/ ******************* ************ / void * &lt;class_name_1&gt; :: operator new（size_t size）{return oracle :: occi :: PObject :: operator new（size）; } ...// .cpp文件的结尾</pre></div>
                           </li>
                        </ol>
                     </div>
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>