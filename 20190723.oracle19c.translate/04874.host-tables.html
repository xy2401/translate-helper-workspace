<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <title>主机表</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Programmer&#39;s Guide"></meta>
      <meta property="og:description" content=""></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Programmer&#39;s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="cobol-programmers-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-11T02:40:40-08:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="1996, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96466-01"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="embedded-PLSQL.html" title="Previous" type="text/html"></link>
      <link rel="next" href="error-handling-and-diagnostics.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Pro*COBOL Programmer&#39;s Guide"></meta>
    <meta name="dcterms.isVersionOf" content="LNPCB"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="embedded-PLSQL.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="error-handling-and-diagnostics.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">程序员指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="introduction-and-concepts.html" property="item" typeof="WebPage"><span property="name">介绍和概念</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">主机表</li>
            </ol>
            <a id="GUID-B4A3765E-BBA7-4D71-860D-1058CD2D23C6" name="GUID-B4A3765E-BBA7-4D71-860D-1058CD2D23C6"></a>
            
            <h2 id="LNPCB-GUID-B4A3765E-BBA7-4D71-860D-1058CD2D23C6" class="sect2"><span class="enumeration_chapter">7</span>主机表</h2>
         </header>
         <div class="ind">
            <div>
               <p>本章介绍如何使用主机表来简化编码并提高程序性能。您将学习如何使用主机表操作Oracle数据，如何使用单个SQL语句操作主机表的所有元素，如何限制处理的表元素数以及如何使用组项表。</p>
               <p>主要部分是：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="host-tables.html#GUID-11D1B8B5-B5E0-4EB8-8DCB-85D44752F7BB">主机表</a></p>
                  </li>
                  <li>
                     <p><a href="host-tables.html#GUID-4946BC15-629C-49F2-B76B-808B7312B23D">主机表的优点</a></p>
                  </li>
                  <li>
                     <p><a href="host-tables.html#GUID-A4BAABCB-ABC9-4E6F-B427-E40C0FFBB9C2">选择表格</a></p>
                  </li>
                  <li>
                     <p><a href="host-tables.html#GUID-A4BAABCB-ABC9-4E6F-B427-E40C0FFBB9C2">选择表格</a></p>
                  </li>
                  <li>
                     <p><a href="host-tables.html#GUID-3340D08A-431A-45C9-9003-13636C7278C6">插入表格</a></p>
                  </li>
                  <li>
                     <p><a href="host-tables.html#GUID-6A12E0DA-59C0-40D8-A344-DEBB7DA3BAD2">使用表格更新</a></p>
                  </li>
                  <li>
                     <p><a href="host-tables.html#GUID-3B29B709-9EE7-4113-AEC4-20DB043F4E8D">删除表格</a></p>
                  </li>
                  <li>
                     <p><a href="host-tables.html#GUID-96196A54-F463-4D14-809B-39C58FAEA526">使用指标表</a></p>
                  </li>
                  <li>
                     <p><a href="host-tables.html#GUID-81265F69-2532-4014-A048-BF0739CC8486">FOR条款</a></p>
                  </li>
                  <li>
                     <p><a href="host-tables.html#GUID-495EE5BF-AB60-449E-9FD1-0252E40AEBD0">WHERE子句</a></p>
                  </li>
                  <li>
                     <p><a href="host-tables.html#GUID-48EF2A66-B3E8-4E99-81C2-083482363350">模仿当前的条款</a></p>
                  </li>
                  <li>
                     <p><a href="host-tables.html#GUID-D3C7D439-9D10-414B-9130-8FB1265A4C8A">组项目表作为主机变量</a></p>
                  </li>
                  <li>
                     <p><a href="host-tables.html#GUID-EF3A3A6D-171F-4147-B4D4-B8FE488CD026">附加阵列插入/选择语法</a></p>
                  </li>
                  <li>
                     <p><a href="host-tables.html#GUID-7F3C702D-8901-4F1E-9F7F-A4818FCC0D19">使用隐式缓冲插入</a></p>
                  </li>
               </ul>
            </div><a id="LNPCB007"></a><a id="LNPCB451"></a><div class="props_rev_3"><a id="GUID-11D1B8B5-B5E0-4EB8-8DCB-85D44752F7BB" name="GUID-11D1B8B5-B5E0-4EB8-8DCB-85D44752F7BB"></a><h3 id="LNPCB-GUID-11D1B8B5-B5E0-4EB8-8DCB-85D44752F7BB" class="sect3"><span class="enumeration_section">7.1</span>主机表</h3>
               <div>
                  <p><span class="italic">主机表</span> （也称为数组） <span class="italic"> </span>是一组与单个变量关联的相关数据项，称为<span class="italic">元素</span> 。定义为表的指示符变量称为<span class="italic">指标表</span> 。指示符表可以与任何NULLABLE主机表相关联。<a id="d45327e124" class="indexterm-anchor"></a><a id="d45327e126" class="indexterm-anchor"></a><a id="d45327e131" class="indexterm-anchor"></a><a id="d45327e133" class="indexterm-anchor"></a></p>
               </div>
            </div><a id="LNPCB452"></a><div class="props_rev_3"><a id="GUID-4946BC15-629C-49F2-B76B-808B7312B23D" name="GUID-4946BC15-629C-49F2-B76B-808B7312B23D"></a><h3 id="LNPCB-GUID-4946BC15-629C-49F2-B76B-808B7312B23D" class="sect3"><span class="enumeration_section">7.2</span>主机表的优点</h3>
               <div>
                  <p>主机表可以简化编程，并可以提供极大改进的性能。编写应用程序时，通常会遇到存储和操作大量数据的问题。主机表简化了访问多个返回值的任务。<a id="d45327e159" class="indexterm-anchor"></a></p>
                  <p>主机表允许您使用单个SQL语句操作多个行。因此，通信开销显着降低，尤其是在网络环境中。例如，假设您要将有关300名员工的信息插入EMP表。如果没有主机表，您的程序必须执行300个单独的INSERT  - 每个员工一个。使用主机表时，只需要执行一次INSERT。</p>
               </div>
            </div><a id="LNPCB453"></a><div class="props_rev_3"><a id="GUID-153F146D-2CB9-4050-B12B-259BD75240FE" name="GUID-153F146D-2CB9-4050-B12B-259BD75240FE"></a><h3 id="LNPCB-GUID-153F146D-2CB9-4050-B12B-259BD75240FE" class="sect3"><span class="enumeration_section">7.3</span>数据操作语句中的表</h3>
               <div>
                  <p>Pro * COBOL允许在数据操作语句中使用主机表。您可以在INSERT，UPDATE和DELETE语句中将主机表用作输入变量，并在SELECT和FETCH语句的INTO子句中将输出变量用作输出变量。</p>
                  <p>用于主机表和简单主机变量的语法几乎相同。一个区别是可选的FOR子句，它允许您控制表处理。此外，在SQL语句中混合主机表和简单主机变量存在限制。</p>
               </div><a id="LNPCB454"></a><div class="props_rev_3"><a id="GUID-BB596F1E-F23E-455B-8114-B8B4D046AA7D" name="GUID-BB596F1E-F23E-455B-8114-B8B4D046AA7D"></a><h4 id="LNPCB-GUID-BB596F1E-F23E-455B-8114-B8B4D046AA7D" class="sect4"><span class="enumeration_section">7.3.1</span>声明主机表</h4>
                  <div>
                     <div class="section">
                        <p>您在数据部门中声明和标注主机表。在以下示例中，声明了三个主机表，每个表都标有50个元素：<a id="d45327e217" class="indexterm-anchor"></a><a id="d45327e221" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">....01 EMP-TABLES。 05 EMP-NUMBER OCCURS 50次PIC S9（4）COMP。 05 EMP-NAME发生50次PIC X（10。05薪资发生50次PIC S9（5）V99 COMP-3。....</pre><p>您可以使用OCCURS子句中的INDEXED BY短语指定索引，如下一个示例所示：</p><pre class="oac_no_warn" dir="ltr">...01 EMP-TABLES。 05 EMP-NUMBER PIC X（10）发生EMP-INDX指示的50次。 ......</pre><p>INDEXED BY短语隐式声明索引项EMP-INDX。</p>
                     </div>
                     <!-- class="section" -->
                  </div><a id="LNPCB455"></a><div class="props_rev_3"><a id="GUID-ED2BF09F-0C7F-4BC7-93DD-FD513800C735" name="GUID-ED2BF09F-0C7F-4BC7-93DD-FD513800C735"></a><h5 id="LNPCB-GUID-ED2BF09F-0C7F-4BC7-93DD-FD513800C735" class="sect5"><span class="enumeration_section">7.3.1.1</span>限制</h5>
                     <div>
                        <p>不允许使用多维主机表。因此，以下示例中声明的二维主机表<span class="italic">无效</span> ：<a id="d45327e260" class="indexterm-anchor"></a><a id="d45327e264" class="indexterm-anchor"></a><a id="d45327e266" class="indexterm-anchor"></a><a id="d45327e270" class="indexterm-anchor"></a><a id="d45327e274" class="indexterm-anchor"></a><a id="d45327e278" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">...01国家。 05国家发生50次。 10状态名称PIC X（25）。10个县发生25次。 15 COUNTY-NAME PIX X（25）。...
</pre><p>也不允许使用可变长度的主机表。例如，以下EMP-REC声明<span class="italic">对于主机变量无效</span> ： <a id="d45327e289" class="indexterm-anchor"></a><a id="d45327e291" class="indexterm-anchor"></a> 
                        </p><pre class="oac_no_warn" dir="ltr">...01 EMP-FILE。 05 REC-COUNT PIC S9（3）COMP。 05 EMP-REC发生0至250次依赖REC-COUNT。 ...
</pre><p><a id="d45327e299" class="indexterm-anchor"></a><a id="d45327e303" class="indexterm-anchor"></a>一次获取中可访问的SQL语句中的主机表元素的最大数量为32K（或者可能更大，具体取决于您的平台和可用内存）。如果您尝试访问超过最大值的数字，则会出现“参数超出范围”运行时错误。如果语句是匿名PL / SQL块，则可访问元素的数量限制为32512除以数据类型的大小。
                        </p>
                     </div>
                  </div>
               </div><a id="LNPCB456"></a><div class="props_rev_3"><a id="GUID-FEC4C293-671B-4620-AFE3-180AF5716A50" name="GUID-FEC4C293-671B-4620-AFE3-180AF5716A50"></a><h4 id="LNPCB-GUID-FEC4C293-671B-4620-AFE3-180AF5716A50" class="sect4"><span class="enumeration_section">7.3.2</span>引用主机表</h4>
                  <div>
                     <div class="section">
                        <p>如果在单个SQL语句中使用多个主机表，则它们的维度应相同。但是，这不是必需的，因为Pro * COBOL始终使用SQL操作的<span class="italic">最小</span>维度。在以下示例中，只有25行<a id="d45327e336" class="indexterm-anchor"></a><a id="d45327e340" class="indexterm-anchor"></a>插入<a id="d45327e345" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">工作储存部分。 EXEC SQL BEGIN DECLARE SECTION END-EXEC。 01 EMP-TABLES。 05 EMP-NUMBER PIC S9（4）COMP发生50次。 05 EMP-NAME PIC X（10）发生50次。 05 DEPT-NUMBER PIC S9（4）COMP出现25次。 EXEC SQL END DECLARE SECTION END-EXEC。 ...程序部门。 ...*在此填充主机表。...EXEC SQL INSERT INTO EMP（EMPNO，ENAME，DEPTNO）值（：EMP-NUMBER，：EMP-NAME，：DEPT-NUMBER）END-EXEC。</pre><p>主机表<span class="italic">不能</span>在SQL语句中下标。例如，以下INSERT语句<span class="italic">无效</span> ：</p><pre class="oac_no_warn" dir="ltr">工作储存部分。 EXEC SQL BEGIN DECLARE SECTION END-EXEC。 01 EMP-TABLES。 05 EMP-NUMBER PIC S9（4）COMP发生50次。 05 EMP-NAME PIC X（10）发生50次。 05 DEPT-NUMBER PIC S9（4）COMP发生50次。 EXEC SQL END DECLARE SECTION END-EXEC。 ...程序部门。 ...执行负载-EMP从1乘1变化J直到J&gt; 50。...LOAD-EMP。 EXEC SQL INSERT INTO EMP（EMPNO，ENAME，DEPTNO）值（：EMP-NUMBER（J），：EMP-NAME（J），：DEPT-NUMBER（J））END-EXEC。</pre><p>您无需在PERFORM VARYING语句中处理主机表。而是在SQL语句中使用未预订的表名。Pro * COBOL将包含维度为<span class="italic">n的</span>主表的SQL语句视为使用<span class="italic">n个</span>不同标量主变量执行<span class="italic">n</span>次的相同语句，但效率更高。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCB457"></a><div class="props_rev_3"><a id="GUID-A16E169C-0B12-464E-957D-3DBA9113CAEA" name="GUID-A16E169C-0B12-464E-957D-3DBA9113CAEA"></a><h4 id="LNPCB-GUID-A16E169C-0B12-464E-957D-3DBA9113CAEA" class="sect4"><span class="enumeration_section">7.3.3</span>使用指标表</h4>
                  <div>
                     <div class="section">
                        <p>您可以使用指示符表将NULL分配给输入主机表中的元素，并检测输出主机表中的NULL或截断值（仅限字符列）。以下示例显示如何使用指示符表执行INSERT： <a id="d45327e398" class="indexterm-anchor"></a><a id="d45327e402" class="indexterm-anchor"></a> 
                        </p><pre class="oac_no_warn" dir="ltr">工作储存部分。 EXEC SQL BEGIN DECLARE SECTION END-EXEC。 01 EMP-TABLES。 05 EMP-NUMBER PIC S9（4）COMP发生50次。 05 DEPT-NUMBER PIC S9（4）COMP发生50次。 05委员会PIC S9（5）V99 COMP-3发生50次。 05 COMM-IND PIC S9（4）COMP发生50次。 EXEC SQL END DECLARE SECTION END-EXEC。 ...程序部门。 ...*填充主机和指标表。*将指标表设置为全零。...EXEC SQL INSERT INTO EMP（EMPNO，DEPTNO，COMM）值（：EMP-NUMBER，：DEPT-NUMBER，：COMMISSION：COMM-IND）END-EXEC。</pre><p>指标表的维度必须大于或等于主表的维度。</p>
                        <p>使用主机表SELECT和FETCH时，建议您使用指示符变量。这样，您可以在关联的输出主机表中测试NULL。</p>
                        <p>如果选择NULL或将其提取到没有关联指示符变量的主变量中，则程序将停止处理，将<span class="italic">sqlca.sqlerrd（3）设置</span>为已处理的行数，并返回错误。
                        </p>
                        <p>默认情况下会选择NULL，但您可以使用UNSAFE_NULL = YES选项将其关闭。</p>
                        <p>当DBMS = V7或V8时，程序不会将截断视为错误。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCB458"></a><div class="props_rev_3"><a id="GUID-2411D823-706F-4F86-B0AB-DEA6B816E305" name="GUID-2411D823-706F-4F86-B0AB-DEA6B816E305"></a><h4 id="LNPCB-GUID-2411D823-706F-4F86-B0AB-DEA6B816E305" class="sect4"><span class="enumeration_section">7.3.4</span>包含表的主机组项</h4>
                  <div>
                     <div class="section">
                        <p><span class="bold">注意：</span>如果您有包含表的主机组项，则必须使用表的相应组项作为指示符。例如，如果您的组项目如下：</p><pre class="oac_no_warn" dir="ltr">01离开。 05小时图片X（2）发生3次。 05分钟PIC X（2）发生3次。</pre><p>以下指标变量<span class="italic">不能</span>使用：</p><pre class="oac_no_warn" dir="ltr">01 DEPARTURE-IND PIC S9（4）COMP发生6次。</pre><p>与表组项一起使用的指示符变量本身必须是表的组项，如下所示：</p><pre class="oac_no_warn" dir="ltr">01 DEPARTURE-IND。 05 HOUR-IND PIC S9（4）COMP发生3次。 05 MINUTE-IND PIC S9（4）COMP发生3次。</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCB459"></a><div class="props_rev_3"><a id="GUID-ABAC969A-FD7D-464E-8E7D-CE7E8C9C094A" name="GUID-ABAC969A-FD7D-464E-8E7D-CE7E8C9C094A"></a><h4 id="LNPCB-GUID-ABAC969A-FD7D-464E-8E7D-CE7E8C9C094A" class="sect4"><span class="enumeration_section">7.3.5</span> Oracle限制</h4>
                  <div>
                     <div class="section">
                        <p>混合主机表标主机变量中的值，SET，进入或WHERE子句是<span class="italic">不允许</span>的。如果任何主机变量是主机表，则所有主机变量都必须是主机表。 <a id="d45327e490" class="indexterm-anchor"></a><a id="d45327e494" class="indexterm-anchor"></a> 
                        </p>
                        <p>你不能使用主机表<a id="d45327e501" class="indexterm-anchor"></a><a id="d45327e503" class="indexterm-anchor"></a> UPDATE或DELETE语句中的CURRENT OF子句。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCB460"></a><div class="props_rev_3"><a id="GUID-8B13D572-8E98-43B6-93CE-C12FD6E63568" name="GUID-8B13D572-8E98-43B6-93CE-C12FD6E63568"></a><h4 id="LNPCB-GUID-8B13D572-8E98-43B6-93CE-C12FD6E63568" class="sect4"><span class="enumeration_section">7.3.6</span> ANSI限制和要求</h4>
                  <div>
                     <p>阵列接口是ANSI / ISO嵌入式SQL标准的Oracle扩展。但是，当您使用MODE = ANSI进行预编译时，仍然允许使用数组SELECT和FETCH。如果需要，可以使用FIPS flagger预编译器选项标记数组的使用。<a id="d45327e533" class="indexterm-anchor"></a></p>
                  </div>
               </div>
            </div><a id="LNPCB461"></a><div class="props_rev_3"><a id="GUID-A4BAABCB-ABC9-4E6F-B427-E40C0FFBB9C2" name="GUID-A4BAABCB-ABC9-4E6F-B427-E40C0FFBB9C2"></a><h3 id="LNPCB-GUID-A4BAABCB-ABC9-4E6F-B427-E40C0FFBB9C2" class="sect3"><span class="enumeration_section">7.4</span>选择表格</h3>
               <div>
                  <div class="section">
                     <p>您可以在SELECT语句中将主机表用作输出变量。如果知道select将返回的最大行数，只需使用该数量的元素定义主机表。在以下示例中，您可以直接选择三个主机表。该表定义为50行，知道select将返回不超过50行。<a id="d45327e562" class="indexterm-anchor"></a><a id="d45327e566" class="indexterm-anchor"></a><a id="d45327e570" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">01 EMP-REC-TABLES。 05 EMP-NUMBER OCCURS 50次PIC S9（4）COMP。 05 EMP-NAME发生50次PIC X（10）变化。 05年度佣金50次PIC S9（6）V99显示标志领先分离。 ...EXEC SQL SELECT ENAME，EMPNO，SAL INTO：EMP-NAME，：EMP-NUMBER，：来自EMP的SALARY&gt; 1000 END-EXEC。</pre><p>在此示例中，SELECT语句最多返回50行。如果符合条件的行少于50个，或者您只想检索50行，则此方法就足够了。但是，如果有超过50个符合条件的行，则无法以这种方式检索所有行。如果重新执行SELECT语句，它只会再次返回前50行，即使更多符合条件。您必须定义更大的表或声明游标以与FETCH语句一起使用。</p>
                     <p>如果SELECT INTO语句返回的行数多于您定义的表的大小，则Oracle会发出错误消息，除非您指定SELECT_ERROR = NO。</p>
                  </div>
                  <!-- class="section" -->
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="precompiler-options.html#GUID-FF4FD0A6-A076-40AC-A1F2-9758122A34C2">SELECT_ERROR</a></li>
                     </ul>
                  </div>
               </div><a id="LNPCB462"></a><div class="props_rev_3"><a id="GUID-37DAFCCC-30FE-4609-92AB-35C45AD25D21" name="GUID-37DAFCCC-30FE-4609-92AB-35C45AD25D21"></a><h4 id="LNPCB-GUID-37DAFCCC-30FE-4609-92AB-35C45AD25D21" class="sect4"><span class="enumeration_section">7.4.1</span>批量提取</h4>
                  <div>
                     <p>当您正在处理的数据大小（大于约100行）以及您不知道将返回多少行时，请使用批量提取。</p>
                     <p>如果您不知道select将返回的最大行数，您可以声明并打开游标，然后在“批处理”中从中获取它。循环内的批量提取可让您轻松检索大量行。每次提取都会返回当前活动集中的下一批行。在以下示例中，您将获取20行批处理：<a id="d45327e611" class="indexterm-anchor"></a><a id="d45327e613" class="indexterm-anchor"></a><a id="d45327e615" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">...01 EMP-REC-TABLES。 05 EMP-NUMBER OCCURS 20次PIC S9（4）COMP。 05 EMP-NAME发生20次PIC X（10）变化。 05薪资发生20次PIC S9（6）V99显示标志领先分离。 ...用于SELECT EMPNO的EXEC SQL DECLARE EMPCURSOR CURSOR，来自EMP END-EXEC的SAL。 ...EXEC SQL OPEN EMPCURSOR END-EXEC。 ...执行SQL SQL WHENEVER未找到执行END-IT。环。 EXEC SQL FETCH EMPCURSOR INTO：EMP-NUMBER，：SALARY END-EXEC。 *  - 处理批次行...转到循环。结束它。 ...
</pre><p>不要忘记检查上次获取中实际返回的行数并处理它们。</p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="host-tables.html#GUID-B62DE8FA-276F-4210-BAFA-5D39618B7CF4">示例程序3：批量获取</a></li>
                        </ul>
                     </div>
                  </div>
               </div><a id="LNPCB463"></a><div class="props_rev_3"><a id="GUID-D253F033-4C06-4299-869A-D46BF15B597F" name="GUID-D253F033-4C06-4299-869A-D46BF15B597F"></a><h4 id="LNPCB-GUID-D253F033-4C06-4299-869A-D46BF15B597F" class="sect4"><span class="enumeration_section">7.4.2</span>使用SQLERRD（3）</h4>
                  <div>
                     <p>对于INSERT，UPDATE和DELETE语句，SQLERRD（3）记录处理的行数。</p>
                     <p>在表操作期间发生错误时，SQLERRD（3）也很有用。处理在导致错误的行停止，因此SQLERRD（3）给出成功处理的行数。</p>
                  </div>
               </div><a id="LNPCB464"></a><div class="props_rev_3"><a id="GUID-70333183-03EB-4AD0-9DE2-6E701AE365E2" name="GUID-70333183-03EB-4AD0-9DE2-6E701AE365E2"></a><h4 id="LNPCB-GUID-70333183-03EB-4AD0-9DE2-6E701AE365E2" class="sect4"><span class="enumeration_section">7.4.3</span>提取的行数</h4>
                  <div>
                     <p>每次提取最多返回表中的条目数。在以下情况下返回的行数较少：<a id="d45327e679" class="indexterm-anchor"></a></p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>达到活动集的结尾。“未找到数据”警告代码返回到SQLCA中的SQLCODE。例如，如果您获取条目数为100的表，则会发生这种情况，但只返回20行。</p>
                        </li>
                        <li>
                           <p>仍然需要获取完整批次的行。例如，如果您将70行输入到条目数为20的表中，则会发生这种情况，因为在第三次提取之后，仍然只有10行需要提取。</p>
                        </li>
                        <li>
                           <p>处理行时检测到错误。提取失败，适用的错误代码返回给SQLCODE。</p>
                        </li>
                     </ul>
                     <p>返回的累计行数可以在SQLCA的SQLERRD的第三个元素中找到，在本指南中称为SQLERRD（3）。这适用于每个打开的游标。在以下示例中，请注意如何单独维护每个游标的状态：<a id="d45327e695" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">EXEC SQL OPEN CURSOR1 END-EXEC。 EXEC SQL OPEN CURSOR2 END-EXEC。 EXEC SQL FETCH CURSOR1 INTO：20-OUT-EXEC表。 *  - 现在在SQLERRD（3）中运行总计为20 EXEC SQL FETCH CURSOR2 INTO：TABLE-OF-30 END-EXEC。 *  - 现在在SQLERRD（3）中运行总计为30，而不是50 EXEC SQL FETCH CURSOR1 INTO：TABLE-OF-20 END-EXEC。 *  - 现在在SQLERRD（3）中运行总计是40（20 + 20）EXEC SQL FETCH CURSOR2 INTO：TABLE-OF-30 END-EXEC。 *  - 现在在SQLERRD（3）中运行总计为60（30 + 30）</pre></div>
               </div><a id="LNPCB466"></a><a id="LNPCB465"></a><div class="props_rev_3"><a id="GUID-68A555DE-2BC6-4ACB-8261-9225D1B34441" name="GUID-68A555DE-2BC6-4ACB-8261-9225D1B34441"></a><h4 id="LNPCB-GUID-68A555DE-2BC6-4ACB-8261-9225D1B34441" class="sect4"><span class="enumeration_section">7.4.4</span>使用主机表的限制</h4>
                  <div>
                     <p>仅在子查询中允许在SELECT语句的WHERE子句中使用主机表。此外，由于Pro * COBOL始终采用表的最小维度，因此不要在SELECT或FETCH语句的INTO子句中将简单主机变量与主机表混合，因为只检索一行。如果任何主机变量是表，那么所有主变量都必须是表。<a id="d45327e726" class="indexterm-anchor"></a><a id="d45327e730" class="indexterm-anchor"></a></p>
                     <p><a href="host-tables.html#GUID-68A555DE-2BC6-4ACB-8261-9225D1B34441__I6325">主机表在SELECT INTO</a>中<a href="host-tables.html#GUID-68A555DE-2BC6-4ACB-8261-9225D1B34441__I6325">有效</a>显示主机表的哪些使用在SELECT INTO语句中有效。
                     </p>
                     <div class="tblformal" id="GUID-68A555DE-2BC6-4ACB-8261-9225D1B34441__GUID-664F57EE-D356-4CBC-A402-64BEC09BA0C3">
                        <p class="titleintable">表7-1 <span class="italic" id="GUID-68A555DE-2BC6-4ACB-8261-9225D1B34441__I6325"><span class="bold">主机表在SELECT INTO中有效</span></span></p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="主机表在SELECT INTO中有效" width="100%" border="1" summary="q" frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="34%" id="d45327e751">INTO条款</th>
                                 <th align="left" valign="bottom" width="42%" id="d45327e754">条款</th>
                                 <th align="left" valign="bottom" width="24%" id="d45327e757">有效？</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="34%" id="d45327e762" headers="d45327e751 ">
                                    <p>表</p>
                                 </td>
                                 <td align="left" valign="top" width="42%" headers="d45327e762 d45327e754 ">
                                    <p>表</p>
                                 </td>
                                 <td align="left" valign="top" width="24%" headers="d45327e762 d45327e757 ">
                                    <p>没有</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="34%" id="d45327e772" headers="d45327e751 ">
                                    <p>纯量</p>
                                 </td>
                                 <td align="left" valign="top" width="42%" headers="d45327e772 d45327e754 ">
                                    <p>纯量</p>
                                 </td>
                                 <td align="left" valign="top" width="24%" headers="d45327e772 d45327e757 ">
                                    <p>是</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="34%" id="d45327e782" headers="d45327e751 ">
                                    <p>表</p>
                                 </td>
                                 <td align="left" valign="top" width="42%" headers="d45327e782 d45327e754 ">
                                    <p>纯量</p>
                                 </td>
                                 <td align="left" valign="top" width="24%" headers="d45327e782 d45327e757 ">
                                    <p>是</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="34%" id="d45327e792" headers="d45327e751 ">
                                    <p>纯量</p>
                                 </td>
                                 <td align="left" valign="top" width="42%" headers="d45327e792 d45327e754 ">
                                    <p>表</p>
                                 </td>
                                 <td align="left" valign="top" width="24%" headers="d45327e792 d45327e757 ">
                                    <p>没有</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="host-tables.html#GUID-495EE5BF-AB60-449E-9FD1-0252E40AEBD0">WHERE子句</a></li>
                        </ul>
                     </div>
                  </div>
               </div><a id="LNPCB467"></a><div class="props_rev_3"><a id="GUID-424CFE93-E66F-4E64-8E4E-31FBF2877A71" name="GUID-424CFE93-E66F-4E64-8E4E-31FBF2877A71"></a><h4 id="LNPCB-GUID-424CFE93-E66F-4E64-8E4E-31FBF2877A71" class="sect4"><span class="enumeration_section">7.4.5</span>获取NULL</h4>
                  <div>
                     <p>当UNSAFE_NULL = YES时，如果在缺少指示符表的主机表中选择或获取NULL，则不会生成错误。因此，在进行表选择和提取时，Oracle建议您使用指标表。这是因为这使得在关联的输出主机表中更容易找到NULL。</p>
                     <p>当UNSAFE_NULL = NO时，如果在缺少指标表的主机表中选择或获取NULL，则Oracle停止处理，将SQLERRD（3）设置为处理的行数，并发出错误消息：</p>
                     <div class="infoboxnotealso" id="GUID-424CFE93-E66F-4E64-8E4E-31FBF2877A71__GUID-E70221B5-31DC-49BB-AFD1-F53E6B62EAAD">
                        <p class="notep1">也可以看看：</p><a href="embedded-SQL.html#GUID-CB6FDC6E-6FED-478D-8A47-B9CDE504C102">使用指示符变量</a>来学习如何查找NULL和截断值。
                     </div>
                  </div>
               </div><a id="LNPCB468"></a><div class="props_rev_3"><a id="GUID-CAB9A065-0D56-4AA9-976D-DABA90E50E5C" name="GUID-CAB9A065-0D56-4AA9-976D-DABA90E50E5C"></a><h4 id="LNPCB-GUID-CAB9A065-0D56-4AA9-976D-DABA90E50E5C" class="sect4"><span class="enumeration_section">7.4.6</span>获取截断值</h4>
                  <div>
                     <p>如果在缺少指示符表的主机表中选择或获取截断的列值，Oracle会设置SQLWARN（2）。</p>
                     <p>您可以在截断发生之前检查SQLERRD（3）以查找处理的行数。行处理的计数包括导致截断错误的行。</p>
                     <p>在执行表选择和提取时，您可以使用指标表。这样，如果Oracle将一个或多个截断的列值分配给输出主机表，则可以在关联的指标表中找到列值的原始长度。</p>
                  </div>
               </div><a id="LNPCB469"></a><div class="props_rev_3"><a id="GUID-B62DE8FA-276F-4210-BAFA-5D39618B7CF4" name="GUID-B62DE8FA-276F-4210-BAFA-5D39618B7CF4"></a><h4 id="LNPCB-GUID-B62DE8FA-276F-4210-BAFA-5D39618B7CF4" class="sect4"><span class="enumeration_section">7.4.7</span>示例程序3：批量获取</h4>
                  <div>
                     <div class="section">
                        <p>可以在演示目录中找到以下主机表示例程序。</p><pre class="oac_no_warn" dir="ltr">************************************************** *************** *示例程序3：主机表* * * *此程序登录到ORACLE，声明并打开游标，* *使用主机表批量提取，并打印结果。* ************************************************* ****************身份识别部门。 PROGRAM-ID。 HOST-表。环境部门。数据部门。工作储存部分。 EXEC SQL BEGIN DECLARE SECTION END-EXEC。 01 USERNAME PIC X（15）变化。 01 PASSWD PIC X（15）变化。 01 EMP-REC-TABLES。 05 EMP-NUMBER OCCURS 5次PIC S9（4）COMP。 05 EMP-NAME发生5次PIC X（10）变化。 05年度佣金5次PIC S9（6）V99显示标志领先独立。 EXEC SQL VAR SALARY是显示（8,2）END-EXEC。 EXEC SQL END DECLARE SECTION END-EXEC。 EXEC SQL包含SQLCA END-EXEC。 01 NUM-RET PIC S9（9）COMP VALUE ZERO。 01 PRINT-NUM PIC S9（9）COMP VALUE ZERO。 01计数器PIC S9（9）COMP。 01 DISPLAY-VARIABLES。 05 D-EMP-NAME PIC X（10）。05 D-EMP-NUMBER PIC 9（4）。05 D-SALARY PIC Z（4）9.99。程序部门。 BEGIN-PGM。执行SQL WHENEVER SQLERROR执行SQL-ERROR END-EXEC。表演登录。 EXEC SQL DECLARE C1 CURSOR用于从EMP END-EXEC中选择EMPNO，SAL，ENAME。 EXEC SQL OPEN C1 END-EXEC。 FETCH-LOOP。 EXEC SQL无法找到执行签名END-EXEC。 EXEC SQL FETCH C1 INTO：EMP-NUMBER，：SALARY，：EMP-NAME END-EXEC。从SQLERRD中减去NUM-RET（3）给出PRINT-NUM。 PERFORM PRINT-IT。将SQLERRD（3）移到NUM-RET。去FETCH-LOOP。登录。将“SCOTT”移至USERNAME-ARR。移动5到USERNAME-LEN。将“TIGER”转移到PASSWD-ARR。移动5到PASSWD-LEN。 EXEC SQL CONNECT：USERNAME IDENTIFIED BY：PASSWD END-EXEC。显示“”。显示“连接到ORACLE作为用户：”，USERNAME-ARR。 PRINT-IT。显示“”。显示“员工姓名薪酬雇员姓名”。显示“--------------- ------- -------------”。执行打印行改变计数器从1比1直到计数器&gt; PRINT-NUM。 PRINT-行。将EMP-NUMBER（COUNTER）移到D-EMP-NUMBER。将薪水（计数器）转移到D-SALARY。显示“”，D-EMP-NUMBER，“”，D-SALARY，“”，EMP-NAME-ARR在EMP-NAME（COUNTER）中。在EMP-NAME（COUNTER）中向EMP-NAME-ARR移动空格。登出。从SQLERRD中减去NUM-RET（3）给出PRINT-NUM。 IF（PRINT-NUM&gt; 0）PERFORM PRINT-IT。 EXEC SQL CLOSE C1 END-EXEC。 EXEC SQL COMMIT WORK RELEASE END-EXEC。显示“”。显示“有一个好日子。”显示“”。停止运行。 SQL-ERROR。执行SQL WHENEVER SQLERROR CONTINUE END-EXEC。显示“”。显示“ORACLE ERROR DETECTED：”。显示“”。显示SQLERRMC。 EXEC SQL ROLLBACK工作发布END-EXEC。停止运行。</pre></div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="LNPCB470"></a><div class="props_rev_3"><a id="GUID-3340D08A-431A-45C9-9003-13636C7278C6" name="GUID-3340D08A-431A-45C9-9003-13636C7278C6"></a><h3 id="LNPCB-GUID-3340D08A-431A-45C9-9003-13636C7278C6" class="sect3"><span class="enumeration_section">7.5</span>插入表格</h3>
               <div>
                  <p>您可以在INSERT语句中将主机表用作输入变量。在执行INSERT语句之前，只需确保您的程序使用数据填充表。如果表中的某些元素不相关，则可以使用FOR子句来控制插入的行数。<a id="d45327e929" class="indexterm-anchor"></a><a id="d45327e933" class="indexterm-anchor"></a><a id="d45327e937" class="indexterm-anchor"></a></p>
                  <p>使用主机表插入的示例如下：</p><pre class="oac_no_warn" dir="ltr">01 EMP-REC-TABLES。 05 EMP-NUMBER OCCURS 50次PIC S9（4）COMP。 05 EMP-NAME发生50次PIC X（10）变化。 05年度佣金50次PIC S9（6）V99显示标志领先分离。 *  - 填充主机表EXEC SQL INSERT INTO EMP（ENAME，EMPNO，SAL）VALUES（：EMP-NAME，：EMP-NUMBER，：SALARY）END-EXEC。</pre><p>插入的行数将在SQLERRD（3）中提供。</p>
                  <p>主机表<span class="italic">不能</span>在SQL语句中下标。例如，以下INSERT语句无效：</p><pre class="oac_no_warn" dir="ltr">执行变化我从1乘1直到我=表尺寸。 EXEC SQL INSERT INTO EMP（ENAME，EMPNO，SAL）VALUES（：EMP-NAME（I），：EMP-NUMBER（I），：SALARY（I））END_EXEC END-PERFORM。</pre></div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="host-tables.html#GUID-81265F69-2532-4014-A048-BF0739CC8486">FOR条款</a></li>
                     </ul>
                  </div>
               </div><a id="LNPCB471"></a><div class="props_rev_3"><a id="GUID-3A7041C7-D8FC-46A2-96F9-5ADEC2AF16AF" name="GUID-3A7041C7-D8FC-46A2-96F9-5ADEC2AF16AF"></a><h4 id="LNPCB-GUID-3A7041C7-D8FC-46A2-96F9-5ADEC2AF16AF" class="sect4"><span class="enumeration_section">7.5.1</span>主机表限制</h4>
                  <div>
                     <div class="section">
                        <p>将简单主机变量与INSERT，UPDATE或DELETE语句的VALUES子句中的主机表混合会导致只处理任何主机表的第一个元素，因为简单主机变量被视为维度为1的主表，而Pro * COBOL始终使用最小的声明尺寸。发生这种情况时会收到警告。<a id="d45327e984" class="indexterm-anchor"></a><a id="d45327e988" class="indexterm-anchor"></a></p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="LNPCB472"></a><div class="props_rev_3"><a id="GUID-6A12E0DA-59C0-40D8-A344-DEBB7DA3BAD2" name="GUID-6A12E0DA-59C0-40D8-A344-DEBB7DA3BAD2"></a><h3 id="LNPCB-GUID-6A12E0DA-59C0-40D8-A344-DEBB7DA3BAD2" class="sect3"><span class="enumeration_section">7.6</span>使用表格更新</h3>
               <div>
                  <p>您还可以在UPDATE语句中将主机表用作输入变量，如以下示例所示：<a id="d45327e1017" class="indexterm-anchor"></a><a id="d45327e1021" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">01 EMP-REC-TABLES。 05 EMP-NUMBER OCCURS 50次PIC S9（4）COMP。 05年度佣金50次PIC S9（6）V99显示标志领先分离。 ...*  - 填充主机表EXEC SQL UPDATE EMP SET SAL =：SALARY WHERE EMPNO =：EMP-NUMBER END-EXEC。</pre><p>SQLERRD（3）中提供了通过发出此语句更新的行数。这不一定是主机表中的行数。数<span class="italic">不</span>包括由更新级联处理的行（这将导致随后的更新）。
                  </p>
                  <p>如果表中的某些元素不相关，则可以使用FOR子句限制更新的行数。</p>
                  <p>最后一个示例显示了使用唯一密钥（ <span class="italic">EMP-NUMBER</span> ）的典型更新。每个表元素只限一行进行更新。在以下示例中，每个表元素限定多行：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL BEGIN DECLARE SECTION END-EXEC。 ...05职业生涯10次PIC X（10）变化。 05委员会发布50次PIC S9（6）V99显示标志领先分离。 EXEC SQL END DECLARE SECTION END-EXEC。 *  - 填充主机表EXEC SQL UPDATE EMP SET COMM =：COMMISSION WHERE JOB =：JOB-TITLE END-EXEC。</pre></div><a id="LNPCB474"></a><a id="LNPCB473"></a><div class="props_rev_3"><a id="GUID-9083160B-85F4-45F5-88D1-43CAA5506E4A" name="GUID-9083160B-85F4-45F5-88D1-43CAA5506E4A"></a><h4 id="LNPCB-GUID-9083160B-85F4-45F5-88D1-43CAA5506E4A" class="sect4"><span class="enumeration_section">7.6.1</span> UPDATE中的限制</h4>
                  <div>
                     <div class="section">
                        <p>您不能在UPDATE语句中使用具有CURRENT OF子句的主机表。有关替代方案，请参阅<span class="q">“ <a href="host-tables.html#GUID-48EF2A66-B3E8-4E99-81C2-083482363350">模仿当前条款</a> ”</span> 。
                        </p>
                        <p><a href="host-tables.html#GUID-9083160B-85F4-45F5-88D1-43CAA5506E4A__g12833" title="q">表7-2</a>显示了主表的哪些用法在UPDATE语句中有效：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="tblformal" id="GUID-9083160B-85F4-45F5-88D1-43CAA5506E4A__g12833">
                        <p class="titleintable">表7-2主机表在UPDATE中有效</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="主机表在UPDATE中有效" width="100%" border="1" summary="q" frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="33%" id="d45327e1089">SET子句</th>
                                 <th align="left" valign="bottom" width="43%" id="d45327e1092">条款</th>
                                 <th align="left" valign="bottom" width="23%" id="d45327e1095">有效？</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="33%" id="d45327e1100" headers="d45327e1089 ">
                                    <p>表</p>
                                 </td>
                                 <td align="left" valign="top" width="43%" headers="d45327e1100 d45327e1092 ">
                                    <p>表</p>
                                 </td>
                                 <td align="left" valign="top" width="23%" headers="d45327e1100 d45327e1095 ">
                                    <p>是</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="33%" id="d45327e1110" headers="d45327e1089 ">
                                    <p>纯量</p>
                                 </td>
                                 <td align="left" valign="top" width="43%" headers="d45327e1110 d45327e1092 ">
                                    <p>纯量</p>
                                 </td>
                                 <td align="left" valign="top" width="23%" headers="d45327e1110 d45327e1095 ">
                                    <p>是</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="33%" id="d45327e1120" headers="d45327e1089 ">
                                    <p>表</p>
                                 </td>
                                 <td align="left" valign="top" width="43%" headers="d45327e1120 d45327e1092 ">
                                    <p>纯量</p>
                                 </td>
                                 <td align="left" valign="top" width="23%" headers="d45327e1120 d45327e1095 ">
                                    <p>没有</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="33%" id="d45327e1130" headers="d45327e1089 ">
                                    <p>纯量</p>
                                 </td>
                                 <td align="left" valign="top" width="43%" headers="d45327e1130 d45327e1092 ">
                                    <p>表</p>
                                 </td>
                                 <td align="left" valign="top" width="23%" headers="d45327e1130 d45327e1095 ">
                                    <p>没有</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                  </div>
               </div>
            </div><a id="LNPCB475"></a><div class="props_rev_3"><a id="GUID-3B29B709-9EE7-4113-AEC4-20DB043F4E8D" name="GUID-3B29B709-9EE7-4113-AEC4-20DB043F4E8D"></a><h3 id="LNPCB-GUID-3B29B709-9EE7-4113-AEC4-20DB043F4E8D" class="sect3"><span class="enumeration_section">7.7</span>删除表格</h3>
               <div>
                  <p>您还可以在DELETE语句中将主机表用作输入变量。这样做就像使用WHERE子句中的主机表的连续元素重复执行DELETE语句。因此，每次执行都可能从表中删除零个，一个或多个行。使用主机表删除的示例如下：<a id="d45327e1163" class="indexterm-anchor"></a><a id="d45327e1167" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">EXEC SQL BEGIN DECLARE SECTION END-EXEC。 ...05 EMP-NUMBER OCCURS 50次PIC S9（4）COMP。 EXEC SQL END DECLARE SECTION END-EXEC。 *  - 填充主机表EXEC SQL DELETE FROM EMP WHERE EMPNO =：EMP-NUMBER END-EXEC。</pre><p>删除的累计行数可以在SQLERRD（3）中找到。这个数字<span class="italic">不</span>包括被删除级联处理的行。
                  </p>
                  <p>最后一个示例显示了使用唯一键（ <span class="italic">EMP-NUMBER</span> ）的典型删除。每个表元素只限一行进行删除。在以下示例中，每个表元素限定多行：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL BEGIN DECLARE SECTION END-EXEC。 ...05职业生涯10次PIC X（10）变化。 EXEC SQL END DECLARE SECTION END-EXEC。 *  - 填充主机表EXEC SQL DELETE FROM EMP WHERE JOB =：JOB-TITLE END-EXEC。</pre></div><a id="LNPCB476"></a><div class="props_rev_3"><a id="GUID-37B00D0A-329C-4438-8B2A-3C005D22933B" name="GUID-37B00D0A-329C-4438-8B2A-3C005D22933B"></a><h4 id="LNPCB-GUID-37B00D0A-329C-4438-8B2A-3C005D22933B" class="sect4"><span class="enumeration_section">7.7.1</span> DELETE中的限制</h4>
                  <div>
                     <div class="section">
                        <p>您不能在DELETE语句中使用具有CURRENT OF子句的主机表。有关替代方案，请参阅<span class="q">“ <a href="host-tables.html#GUID-48EF2A66-B3E8-4E99-81C2-083482363350">模仿当前条款</a> ”</span> 。<a id="d45327e1221" class="indexterm-anchor"></a><a id="d45327e1225" class="indexterm-anchor"></a></p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="LNPCB477"></a><div class="props_rev_3"><a id="GUID-96196A54-F463-4D14-809B-39C58FAEA526" name="GUID-96196A54-F463-4D14-809B-39C58FAEA526"></a><h3 id="LNPCB-GUID-96196A54-F463-4D14-809B-39C58FAEA526" class="sect3"><span class="enumeration_section">7.8</span>使用指标表</h3>
               <div>
                  <p>您可以使用指示符表将NULL分配给输入主机表，并检测输出主机表中的NULL或截断值。以下示例显示如何使用指标表插入：</p><pre class="oac_no_warn" dir="ltr">01 EMP-REC-VARS。 05 EMP-NUMBER OCCURS 50次PIC S9（4）COMP。 05 DEPT-NUMBER OCCURS 50次PIC S9（4）COMP。 05委员会发布50次PIC S9（6）V99显示标志领先分离。 *  - 指标表：05 COMM-IND发生50次PIC S9（4）COMP。 *  - 填充主机表*  - 填充指标表;在*  -  COMM列中插入NULL，将-1分配给*中的相应元素 - 指示符表EXEC SQL INSERT INTO EMP（EMPNO，DEPTNO，COMM）VALUES（：EMP_NUMBER，：DEPT-NUMBER，：COMMISSION ：COMM-IND）END-EXEC。</pre><p>指标表的条目数不能小于主表的条目数。</p>
               </div>
            </div><a id="LNPCB478"></a><div class="props_rev_3"><a id="GUID-81265F69-2532-4014-A048-BF0739CC8486" name="GUID-81265F69-2532-4014-A048-BF0739CC8486"></a><h3 id="LNPCB-GUID-81265F69-2532-4014-A048-BF0739CC8486" class="sect3"><span class="enumeration_section">7.9</span> FOR条款</h3>
               <div>
                  <div class="section">
                     <p>您可以使用可选的FOR子句来设置由以下任何SQL语句处理的表元素的数量：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>删除</p>
                        </li>
                        <li>
                           <p>EXECUTE（请参阅Oracle Dynamic SQL中有关<a href="Oracle-dynamic-SQL-method-4.html#GUID-C6256169-5928-466C-B7C7-960D20705EED">Oracle动态SQL的信息：方法4</a> 。
                           </p>
                        </li>
                        <li>
                           <p>取</p>
                        </li>
                        <li>
                           <p>插入</p>
                        </li>
                        <li>
                           <p>打开</p>
                        </li>
                        <li>
                           <p>UPDATE</p>
                        </li>
                     </ul>
                     <p>FOR子句在UPDATE，INSERT和DELETE语句中特别有用。使用这些语句，您可能不想使用整个表。FOR子句允许您将所使用的元素限制为所需的数字，如以下示例所示：<a id="d45327e1308" class="indexterm-anchor"></a><a id="d45327e1312" class="indexterm-anchor"></a><a id="d45327e1316" class="indexterm-anchor"></a><a id="d45327e1318" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">EXEC SQL BEGIN DECLARE SECTION END-EXEC。 01 EMP-REC-VARS。 05 EMP-NAME发生1000次PIC X（20）变化。 05薪资发生100次PIC S9（6）V99显示标志领先独立。 01 ROWS-TO-INSERT PIC S9（4）COMP。 EXEC SQL END DECLARE SECTION END-EXEC。 *  - 填充主机表MOVE 25 TO ROWS-TO-INSERT。 *  - 设置FOR子句变量*  - 将只处理25行EXEC SQL FOR：ROWS-TO-INSERT INSERT INTO EMP（ENAME，SAL）VALUES（：EMP-NAME，：SALARY）END-EXEC。</pre><p>FOR子句必须使用整数主机变量来计算表元素。例如，以下声明是非法的：</p><pre class="oac_no_warn" dir="ltr">*  - 非法EXEC SQL FOR 25插入EMP（ENAME，EMPNO，SAL）值（：EMP-NAME，：EMP-NUMBER，：SALARY）END-EXEC。</pre><p>FOR子句变量指定要处理的表元素的数量。确保该数字不超过最小的表格尺寸。在内部，该值被视为无符号数量。尝试通过使用已签名的主机变量传递负值将导致不可预测的行为。</p>
                  </div>
                  <!-- class="section" -->
               </div><a id="LNPCB479"></a><div class="props_rev_3"><a id="GUID-383AE9B8-FD57-4506-B93A-AA9228070DD7" name="GUID-383AE9B8-FD57-4506-B93A-AA9228070DD7"></a><h4 id="LNPCB-GUID-383AE9B8-FD57-4506-B93A-AA9228070DD7" class="sect4"><span class="enumeration_section">7.9.1</span>限制</h4>
                  <div>
                     <div class="section">
                        <p>两个限制使FOR子句语义清晰：您不能在SELECT语句中使用FOR子句或使用CURRENT OF子句。<a id="d45327e1355" class="indexterm-anchor"></a><a id="d45327e1359" class="indexterm-anchor"></a></p>
                     </div>
                     <!-- class="section" -->
                  </div><a id="LNPCB480"></a><div class="props_rev_3"><a id="GUID-6A115D6B-DDB2-4734-A616-676F5057D061" name="GUID-6A115D6B-DDB2-4734-A616-676F5057D061"></a><h5 id="LNPCB-GUID-6A115D6B-DDB2-4734-A616-676F5057D061" class="sect5"><span class="enumeration_section">7.9.1.1</span>在SELECT语句中</h5>
                     <div>
                        <p>如果在SELECT语句中使用FOR子句，则会收到错误消息。</p>
                        <p>SELECT语句中不允许使用FOR子句，因为它的含义不清楚。这是否意味着“执行此SELECT语句<span class="italic">n</span>次”？或者，它是否意味着“执行此SELECT语句一次，但返回<span class="italic">n</span>行”？前一种情况的问题是每次执行都可能返回多行。在后一种情况下，最好声明一个游标并在FETCH语句中使用FOR子句，如下所示：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL FOR：LIMIT FETCH EMPCURSOR INTO ...</pre></div>
                  </div><a id="LNPCB481"></a><div class="props_rev_3"><a id="GUID-204ED877-76C1-46E8-AE9A-CA0DC7D1F958" name="GUID-204ED877-76C1-46E8-AE9A-CA0DC7D1F958"></a><h5 id="LNPCB-GUID-204ED877-76C1-46E8-AE9A-CA0DC7D1F958" class="sect5"><span class="enumeration_section">7.9.1.2</span>使用CURRENT OF子句</h5>
                     <div>
                        <p>您可以使用UPDATE或DELETE语句中的CURRENT OF子句来引用FETCH语句返回的最新行，如以下示例所示：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL DECLARE EMPCURSOR CURSOR用于选择ENAME，SAL来自EMP，其中EMPNO =：EMP-NUMBER END-EXEC。 ...EXEC SQL OPEN EMPCURSOR END-EXEC。 ...EXEC SQL FETCH emp_cursor INTO：EM-NAME，：SALARY END-EXEC。 ...EXEC SQL UPDATE EMP SET SAL =：当前EPCCURSOR END-EXEC当前的新SALARY。</pre><p>但是，您不能将FOR子句与CURRENT OF子句一起使用。以下语句无效，因为<span class="italic">LIMIT</span>的唯一逻辑值为1（您只能更新或删除当前行一次）：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL FOR：限制UPDA-CURSOR END-EXEC。 ...EXEC SQL FOR：限制从EMP切换到emp_cursor END-EXEC的当前状态。</pre></div>
                  </div>
               </div>
            </div><a id="LNPCB482"></a><div class="props_rev_3"><a id="GUID-495EE5BF-AB60-449E-9FD1-0252E40AEBD0" name="GUID-495EE5BF-AB60-449E-9FD1-0252E40AEBD0"></a><h3 id="LNPCB-GUID-495EE5BF-AB60-449E-9FD1-0252E40AEBD0" class="sect3"><span class="enumeration_section">7.10</span> WHERE子句</h3>
               <div>
                  <div class="section">
                     <p>PRO * COBOL对待包含条目具有<span class="italic">n个</span>不同标量变量（各个表元素<span class="italic">）N</span>等执行相同的SQL语句的<span class="italic">n</span>倍的数量的主机表的SQL语句。仅当此类处理不明确时，预编译器才会发出错误消息：<a id="d45327e1464" class="indexterm-anchor"></a><a id="d45327e1468" class="indexterm-anchor"></a></p>
                     <p>例如，假设声明：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL BEGIN DECLARE SECTION END-EXEC。 ...05 MGRP-NUMBER OCCURS 50次PIC S9（4）COMP。 05职业生涯50次PIC X（20）变化。 01 I PIC S9（4）COMP。 EXEC SQL END DECLARE SECTION END-EXEC。</pre><p>如果声明如下，那将是模棱两可的：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL SELECT MGR INTO：MMP-NUMBER from EMP WHERE JOB =：JOB-TITLE END-EXEC。</pre><p>被视为如下陈述</p><pre class="oac_no_warn" dir="ltr">执行从1比1改变我直到我= 50选择MGR INTO：MGR-NUMBER（I）从EMP JOERE =：JOB_TITLE（I）END-EXEC END-PERFORM。</pre><p>因为多行可能符合WHERE子句搜索条件，但只有一个输出变量可用于接收数据。因此，会发出错误消息。</p>
                     <p>另一方面，如果声明如此，则不会含糊不清</p><pre class="oac_no_warn" dir="ltr">EXEC SQL UPDATE EMP SET MGR =：MGR_NUMBER EMPNO IN（从EMP中选择EMPNO，其中JOB =：JOB-TITLE）END-EXEC。</pre><p>被视为如下陈述</p><pre class="oac_no_warn" dir="ltr">从1比1开始变化我直到我= 50 <span class="bold">         </span> UPDATE EMP SET MGR =：MGR_NUMBER（I）EMPNO IN（从EMP中选择EMPNO，JOB =：JOB-TITLE（I））END-EXEC END-PERFORM。</pre><p>因为在WHERE子句中匹配<span class="italic">JOB-TITLE的</span>每一行的SET子句中都有一个<span class="italic">MGR-NUMBER</span> ，即使每个<span class="italic">JOB-TITLE</span>匹配多行也是如此。与每个<span class="italic">JOB-TITLE</span>匹配的所有行都可以设置为相同的<span class="italic">MGR-NUMBER</span> ，因此不会发出错误消息。
                     </p>
                  </div>
                  <!-- class="section" -->
               </div>
            </div><a id="LNPCB483"></a><div class="props_rev_3"><a id="GUID-48EF2A66-B3E8-4E99-81C2-083482363350" name="GUID-48EF2A66-B3E8-4E99-81C2-083482363350"></a><h3 id="LNPCB-GUID-48EF2A66-B3E8-4E99-81C2-083482363350" class="sect3"><span class="enumeration_section">7.11</span>模仿当前的条款</h3>
               <div>
                  <p>CURRENT OF子句使您可以对游标中的最新行执行UPDATE或DELETE。使用CURRENT OF子句会将FOR UPDATE子句添加到游标中。添加此子句可以锁定光标在独占模式下标识的所有行。请注意，您不能将CURRENT OF与主机表一起使用。而是将FOR UPDATE附加到游标的定义并显式选择ROWID列，然后在更新或删除期间使用该值来标识当前行。一个例子如下：<a id="d45327e1539" class="indexterm-anchor"></a><a id="d45327e1543" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">05 EMP-NAME发生25次PIC X（20）变化。 05职业生涯25次PIC X（15）变化。 05 OLV-TITLE OCCURS 25次PIC X（15）变化。 05 ROW-ID发生25次PIC X（18）变化。 ...EXEC SQL DECLARE EMPCURSOR CURSOR for SELECT ENAME，JOB，ROWID from EMP FOR UPDATE END-EXEC。 ...EXEC SQL OPEN EMPCURSOR END-EXEC。 ...EXEC SQL WHENEVER未找到GOTO <span class="bold">......</span>...PERFORM <span class="bold"> </span> EXEC SQL FETCH EMPCURSOR INTO：EMP-NAME，：JOB-TITLE，：ROW-ID END-EXEC ...EXEC SQL DELETE FROM EMP WHERE JOB =：OLD-TITLE AND ROWID =：ROW-ID END-EXEC EXEC SQL COMMIT WORK END-EXEC END-PERFORM。</pre></div>
            </div><a id="LNPCB484"></a><div class="props_rev_3"><a id="GUID-D3C7D439-9D10-414B-9130-8FB1265A4C8A" name="GUID-D3C7D439-9D10-414B-9130-8FB1265A4C8A"></a><h3 id="LNPCB-GUID-D3C7D439-9D10-414B-9130-8FB1265A4C8A" class="sect3"><span class="enumeration_section">7.12</span>组项目表作为主机变量</h3>
               <div>
                  <p>Pro * COBOL允许在嵌入式SQL语句中使用组项（也称为<span class="italic">记录</span> ）表。组项的表可以在SELECT或FETCH语句的INTO子句中引用，也可以在INSERT语句的VALUES列表中引用。
                  </p>
                  <p>例如，给出以下声明：</p><pre class="oac_no_warn" dir="ltr">01表。 05 EMP-TABLE发生20次。 10 EMP-NUMBER PIC S9（4）COMP。 10 EMP-NAME PIC X（10）。10 DEPT-NUMBER PIC S9（4）COMP。</pre><p>以下声明有效：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL INSERT INTO EMP（EMPNO，ENAME，DEPTNO）VALUES（：EMP-TABLE）END-EXEC。</pre><p>假设组项已经填充了数据，则语句批量插入包含员工编号，员工姓名和部门编号的20行到EMP表中。</p>
                  <p>确保组项的顺序与SQL语句中的顺序相对应。</p>
                  <p>要使用指标变量，请设置组项目的第二个表格，其中包含组项目中每个变量的指示符变量：</p><pre class="oac_no_warn" dir="ltr">01 TABLES-IND。 05 EMP-TABLE-IND发生20次。 10 EMP-NUMBER-IND PIC S9（4）COMP。 10 EMP-NAME-IND PIC S9（4）COMP。 10 DEPT-NUMBER_IND PIC S9（4）COMP。</pre><p>组项的主机指标表可以如下使用：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL INSERT INTO EMP（EMPNO，ENAME，DEPTNO）值（：EMP-TABLE：EMP-TABLE-IND）END-EXEC。</pre><p>如果已知数据的确切特征，则可以方便地为组项指定基本项目指示符：</p><pre class="oac_no_warn" dir="ltr">05 EMP-TABLE-IND PIC S9（4）COMP发生20次。</pre><p>组项的主机表不能具有作为表的组项。例如：</p><pre class="oac_no_warn" dir="ltr">01表。 05 EMP-TABLE发生20次。 10 EMP-NUMBER PIC S9（4）COMP发生10次。 10 EMP-NAME PIC X（10）。10 DEPT-NUMBER PIC S9（4）COMP。</pre><p><code class="codeph">EMP-TABLE</code> <span class="italic">不能</span>用作主机变量，因为<code class="codeph">EMP-NUMBER</code>是一个表。
                  </p>
                  <p>不允许嵌套组项的主机表。例如：</p><pre class="oac_no_warn" dir="ltr">01表。 05团队表20次10 EMP-TABLE 15 EMP-NUMBER PIC S9（4）COMP。 15 EMP-NAME PIC X（10）。10 DEPT-TABLE。 15 DEPT-NUMBER PIC S9（4）COMP。 15 DEPT-NAME PIC X（10）。
</pre><p><code class="codeph">TEAM-TABLE</code>不能用作主变量，因为其成员（ <code class="codeph">EMP-TABLE</code>和<code class="codeph">DEPT-TABLE</code> ）本身就是组项。
                  </p>
                  <p>最后，适用于Pro * COBOL中主机表的限制也适用于组项目表：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>不允许使用多维和可变长度的表。</p>
                     </li>
                     <li>
                        <p>如果在单个SQL语句中使用多个表，则它们的维度应该相同。</p>
                     </li>
                     <li>
                        <p>SQL语句中的主机表不得下标。</p>
                     </li>
                  </ul>
               </div>
            </div><a id="LNPCB485"></a><div class="props_rev_3"><a id="GUID-C8565154-1FBC-4CF6-807B-E82CA72450A2" name="GUID-C8565154-1FBC-4CF6-807B-E82CA72450A2"></a><h3 id="LNPCB-GUID-C8565154-1FBC-4CF6-807B-E82CA72450A2" class="sect3"><span class="enumeration_section">7.13</span>示例程序14：组项目表</h3>
               <div>
                  <div class="section">
                     <p>该程序登录，声明并打开游标，使用组项目表批量提取。阅读初始评论了解详情。<a id="d45327e1683" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">************************************************** *************** *示例程序14：组项目表* * * *此程序登录到ORACLE，声明并打开游标，* *使用表格批量提取组项目，并打印* *结果。此示例与sample3相同，除了* *而不是使用三个* * *的三个独立主机表，它使用包含三个组项的五元素表。* *输出应相同。* ************************************************* ****************身份识别部门。 PROGRAM-ID。 TABLE-OF-GROUP项。环境部门。数据部门。工作储存部分。 EXEC SQL BEGIN DECLARE SECTION END-EXEC。 01 USERNAME PIC X（15）变化。 01 PASSWD PIC X（15）变化。 01 EMP-REC-TABLE发生5次。 05 EMP-NUMBER PIC S9（4）COMP。 05 SALARY PIC S9（6）V99显示标志领先独立。 05 EMP-NAME PIC X（10）变化。 EXEC SQL VAR SALARY是显示（8,2）END-EXEC。 EXEC SQL END DECLARE SECTION END-EXEC。 EXEC SQL包含SQLCA END-EXEC。 01 NUM-RET PIC S9（9）COMP VALUE ZERO。 01 PRINT-NUM PIC S9（9）COMP VALUE ZERO。 01计数器PIC S9（9）COMP。 01 DISPLAY-VARIABLES。 05 D-EMP-NAME PIC X（10）。05 D-EMP-NUMBER PIC 9（4）。05 D-SALARY PIC Z（4）9.99。程序部门。 BEGIN-PGM。执行SQL WHENEVER SQLERROR执行SQL-ERROR END-EXEC。表演登录。 EXEC SQL DECLARE C1 CURSOR用于从EMP END-EXEC中选择EMPNO，SAL，ENAME。 EXEC SQL OPEN C1 END-EXEC。 FETCH-LOOP。 EXEC SQL无法找到执行签名END-EXEC。 EXEC SQL FETCH C1 INTO：EMP-REC-TABLE END-EXEC。从SQLERRD中减去NUM-RET（3）给出PRINT-NUM。 PERFORM PRINT-IT。将SQLERRD（3）移到NUM-RET。去FETCH-LOOP。登录。将“SCOTT”移至USERNAME-ARR。移动5到USERNAME-LEN。将“TIGER”转移到PASSWD-ARR。移动5到PASSWD-LEN。 EXEC SQL CONNECT：USERNAME IDENTIFIED BY：PASSWD END-EXEC。显示“”。显示“连接到ORACLE作为用户：”，USERNAME-ARR。 PRINT-IT。显示“”。显示“员工姓名薪酬雇员姓名”。显示“--------------- ------- -------------”。执行打印行改变计数器从1比1直到计数器&gt; PRINT-NUM。 PRINT-行。将EMP-NUMBER（COUNTER）移到D-EMP-NUMBER。将薪水（计数器）转移到D-SALARY。显示“”，D-EMP-NUMBER，“”，D-SALARY，“”，EMP-NAME-ARR在EMP-NAME（COUNTER）中。在EMP-NAME（COUNTER）中向EMP-NAME-ARR移动空格。登出。从SQLERRD中减去NUM-RET（3）给出PRINT-NUM。 IF（PRINT-NUM&gt; 0）PERFORM PRINT-IT。 EXEC SQL CLOSE C1 END-EXEC。 EXEC SQL COMMIT WORK RELEASE END-EXEC。显示“”。显示“有一个好日子。”显示“”。停止运行。 SQL-ERROR。执行SQL WHENEVER SQLERROR CONTINUE END-EXEC。显示“”。显示“ORACLE ERROR DETECTED：”。显示“”。显示SQLERRMC。 EXEC SQL ROLLBACK工作发布END-EXEC。停止运行。</pre></div>
                  <!-- class="section" -->
               </div>
            </div><a id="LNPCB487"></a><a id="LNPCB488"></a><a id="LNPCB489"></a><a id="LNPCB490"></a><a id="LNPCB486"></a><div class="props_rev_3"><a id="GUID-EF3A3A6D-171F-4147-B4D4-B8FE488CD026" name="GUID-EF3A3A6D-171F-4147-B4D4-B8FE488CD026"></a><h3 id="LNPCB-GUID-EF3A3A6D-171F-4147-B4D4-B8FE488CD026" class="sect3"><span class="enumeration_section">7.14</span>附加阵列插入/选择语法</h3>
               <div>
                  <p>Oracle预编译器还支持主机表的DB2插入和获取语法。支持的附加阵列插入和获取语法分别显示在以下图像中。</p>
                  <div class="figure" id="GUID-EF3A3A6D-171F-4147-B4D4-B8FE488CD026__GUID-82DD6843-ABF5-4AA4-AF88-37EA45827E55">
                     <p class="titleinfigure">图7-1附加插入语法</p><img src="img/insert2.png" alt="下面是图7-1的描述" title="下面是图7-1的描述" longdesc="img_text/insert2.html"><br><a href="img_text/insert2.html">“图7-1附加插入语法”的说明</a></div>
                  <!-- class="figure" -->
                  <div class="figure" id="GUID-EF3A3A6D-171F-4147-B4D4-B8FE488CD026__GUID-600F105F-F662-4676-857F-8CF8AF02CFC0">
                     <p class="titleinfigure">图7-2其他获取语法</p><img src="img/fetch2.png" alt="下面是图7-2的描述" title="下面是图7-2的描述" longdesc="img_text/fetch2.html"><br><a href="img_text/fetch2.html">“图7-2附加提取语法”的说明</a></div>
                  <!-- class="figure" -->
                  <p>可选的ROWSET和ROWSET STARTING AT子句用于获取方向（FIRST，PRIOR，NEXT，LAST，CURRENT，RELATIVE和ABSOLUTE）。请考虑以下示例：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>第一行</p>
                     </li>
                     <li>
                        <p>先前的行</p>
                     </li>
                     <li>
                        <p>下一行</p>
                     </li>
                     <li>
                        <p>最后一行</p>
                     </li>
                     <li>
                        <p>当前行</p>
                     </li>
                     <li>
                        <p>ROWSET在RELATIVEn开始</p>
                     </li>
                     <li>
                        <p>在ABSOLUTEn开始的ROWSET</p>
                     </li>
                  </ul>
                  <p><a href="host-tables.html#GUID-EF3A3A6D-171F-4147-B4D4-B8FE488CD026__BABHDBHI" title="DB2与Oracle预编译器语法">表7-3</a>中显示了DB2数组插入/获取语法的示例以及它们与相应的Oracle预编译器语法的比较：</p>
                  <div class="tblformal" id="GUID-EF3A3A6D-171F-4147-B4D4-B8FE488CD026__BABHDBHI">
                     <p class="titleintable">表7-3 DB2阵列语法与Oracle预编译器语法</p>
                     <table cellpadding="4" cellspacing="0" class="Formal" title="DB2阵列语法与Oracle预编译器语法" width="100%" border="1" summary="DB2 vs. Oracle Precompiler syntax" frame="hsides" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="47%" id="d45327e1768">DB2阵列语法</th>
                              <th align="left" valign="bottom" width="53%" id="d45327e1771">Oracle预编译器语法</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="47%" id="d45327e1776" headers="d45327e1768 "><pre class="oac_no_warn" dir="ltr">EXEC SQL INSERT INTO DSN8810。ACT（ACTNO，ACTKWD，ACTDESC）值（：HVA1，：HVA2，：HVA3）FOR：NUM_ROWS ROWS END-EXEC。</pre></td>
                              <td align="left" valign="top" width="53%" headers="d45327e1776 d45327e1771 "><pre class="oac_no_warn" dir="ltr">EXEC SQL FOR：NUM_ROWS INSERT INTO DSN8810。ACT（ACTNO，ACTKWD，ACTDESC）值（：HVA1，：HVA2，：HVA3）END-EXEC。</pre></td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="47%" id="d45327e1783" headers="d45327e1768 "><pre class="oac_no_warn" dir="ltr">EXEC SQL FETCH NEXT ROWSET from C1 for 20 ROWS INTO：HVA_EMPNO，：HVA_LASTNAME，：HVA_SALARY END-EXEC。</pre></td>
                              <td align="left" valign="top" width="53%" headers="d45327e1783 d45327e1771 "><pre class="oac_no_warn" dir="ltr">EXEC SQL FOR：TWENTY FETCH c1 INTO：HVA_EMPNO，：HVA_LASTNAME，：HVA_SALARY END-EXEC。</pre></td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
                  <p>在DB2语法中，应在检索行数据集之前首先声明行集定位游标。要使游标能够获取行集，必须在DECLARE CURSOR语句中使用“WITH ROWSET POSITIONING”子句，这在Oracle预编译器语法中不是必需且相关的，如下表所示。</p>
                  <div class="tblformal" id="GUID-EF3A3A6D-171F-4147-B4D4-B8FE488CD026__GUID-CDF826A9-ED9A-42CC-B663-0D93C9E0785A">
                     <table cellpadding="4" cellspacing="0" class="Formal" title="" width="100%" border="1" summary="table for difference between DB2 and Oracle precompiler syntax" frame="hsides" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="43%" id="d45327e1799">DB2阵列语法</th>
                              <th align="left" valign="bottom" width="57%" id="d45327e1802">Oracle预编译器语法</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="43%" id="d45327e1807" headers="d45327e1799 "><pre class="oac_no_warn" dir="ltr">EXEC SQL DECLARE C1游标，具有DSN8810的SELECT EMPNO，LASTNAME，SALARY的ROWSET定位。EMP END-EXEC。</pre></td>
                              <td align="left" valign="top" width="57%" headers="d45327e1807 d45327e1802 "><pre class="oac_no_warn" dir="ltr">EXEC SQL DECLARE C1 CURSOR，用于从DSN8810中选择EMPNO，LASTNAME，SALARY。EMP END-EXEC。</pre></td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
                  <p>可以使用预编译器选项“db2_array”启用此附加数组语法支持，其默认选项为“no”。DB2数组语法支持不能与Oracle预编译器语法一起使用;一次只支持一种语法，Oracle预编译器或DB2语法。</p>
                  <div class="example" id="GUID-EF3A3A6D-171F-4147-B4D4-B8FE488CD026__GUID-96AE1816-7E6D-4073-9BAE-66935C645B56">
                     <p class="titleinexample">示例7-1使用DB2数组语法插入和获取行</p>
                     <p>此程序使用DB2数组插入语法将INSCNT行插入EMP表，然后使用DB2数组提取语法提取插入的行。</p><pre class="oac_no_warn" dir="ltr">************************************************** *************** * db2arrdemo：* ******************************* **********************************身份证明司。 PROGRAM-ID。 db2arrdemo。环境部门。配置部分。数据部门。工作储存部分。 * EMBEDDED COBOL（文件“DB2ARRDEMO.PCO”）EXEC SQL BEGIN DECLARE SECTION END-EXEC。 01 USERNAME PIC X（10）变化。 01 PASSWD PIC X（10）变化。 01 EMPINDATA。 02期限发生25次。 03 EMPNO PIC 9（4）COMP。 03 ENAME PIC X（10）。03 JOB PIC X（9）。03 MGR PIC 9（4）。03 HIREDATE PIC X（9）。03 SAL PIC X（6）。03 COMM PIC X（6）。03 DEPTNO PIC 9（2）。01 EMPOUTDATA。 02重演5次。 03 EMPNO1 PIC 9（4）COMP。 03 ENAME1 PIC X（10）。03 JOB1 PIC X（9）。03 MGR1 PIC 9（4）。03 HIREDATE1 PIC X（9）。03 SAL1 PIC X（6）。03 COMM1 PIC X（6）。03 DEPTNO1 PIC 9（2）。EXEC SQL END DECLARE SECTION END-EXEC。 01 INSCNT PIC 9（3）COMP VALUE 25。01 FETCHCNT PIC 9（3）COMP值5。01 CNT PIC 9（4）。01 CNT2 PIC 9（2）。01 STRINGFIELDS。 02 STR PIC X（18）变化。 EXEC SQL包含SQLCA END-EXEC。程序部门。 BEGIN-PGM。执行SQL WHENEVER SQLERROR执行SQL-ERROR END-EXEC。表演登录。 *填充要插入的数组元素。执行填充数据从1比1改变CNT CNTIL&gt; INSCNT。 *使用DB2数组插入语法插入数据。显示“使用DB2数组插入语法插入数据”。EXEC SQL INSERT INTO EMP（EMPNO，ENAME，JOB，MGR，HIREDATE，SAL，COMM，DEPTNO）价值（：EMPIN）FOR：INSCNT ROWS END-EXEC。 EXEC SQL SELECT COUNT（*）INTO：CNT from EMP EERE LIKE'EMP_％'END-EXEC。 DISPLAY“成功插入EMP的行数”“表：”，CNT。显示“”。*声明可滚动游标以获取数据。EXEC SQL DECLARE C1 SCROLL CURSOR用于选择EMPNO，ENAME，JOB，MGR，HIREDATE，SAL，COMM，DEPTNO来自EMP，ENAME喜欢EMP_％'按EMPNO END-EXEC排序。 EXEC SQL OPEN C1 END-EXEC。显示“使用DB2数组提取语法获取数据”。PERFORM FETCH-TAB。 ENDFETCH-TAB。 EXEC SQL CLOSE C1 END-EXEC。 EXEC SQL ROLLBACK工作发布END-EXEC。停止运行。登录。将“scott”移至USERNAME-ARR。移动5到USERNAME-LEN。将“老虎”移到PASSWD-ARR。移动5到PASSWD-LEN。 EXEC SQL CONNECT：USERNAME IDENTIFIED BY：PASSWD END-EXEC。 * FILLS ARRAY插入EMP表填充数据。将CNT转移到EMPNO（CNT）。移动“”到STR。 STRING“EMP_”，CNT IN STR STR-STRING。移动到ENAME（CNT）。移动“”到STR。 STRING“JOB_”，CNT IN STR STR-STRING。移动工作（CNT）。移动100到MGR（CNT）。如果CNT&gt; 30那么计算CNT2 = 30 ELSE将CNT移动到CNT2结束 - 如果移动“”到STR。 STRING CNT2，“-JAN-06”进入STR END-STRING。移动STR（CNT）。移动“”到STR。 STRING CNT2，“000”进入STR END-STRING。移动到SAL（CNT）。移动1000到COMM（CNT）。移动10到DEPTNO（CNT）。*从EMP TABLE FETCH-TAB中获取数据。 EXEC SQL WHENEVER未找到GOTO ENDFETCH-TAB END-EXEC。显示“使用FETCH FIRST ROWSET获取”。从C1到EXEC SQL FETCH第一行：FETCHCNT进入：EMPOUT END-EXEC。执行PRINTDATA。显示“”。显示“使用FETCH NEXT ROWSET获取”。EXEC SQL FETCH NEXT ROWSET来自C1 for 5 ROWS INTO：EMPOUT END-EXEC。执行PRINTDATA。显示“”。显示“使用FETCH CURRENT ROWSET获取”。从C1到EXEC SQL FETCH当前行：FETCHCNT进入：EMPOUT END-EXEC。执行PRINTDATA。显示“”。显示“使用FETCH LAST ROWSET获取”。执行SQL FETCH最后一行来自C1 FOR：FETCHCNT行进：EMPOUT END-EXEC。执行PRINTDATA。显示“”。DISPLAY“使用FETCH ROWSET在绝对时启动”。COMPUTE CNT = 4 * FETCHCNT。 EXEC SQL FETCH ROWSET在绝对时启动：CNT从C1到5行进入：EMPOUT END-EXEC。执行PRINTDATA。显示“”。显示“使用FETCH ROWSET在相对时启动”。EXEC SQL FETCH ROWSET起始于相关-3从C1 FOR：FETCHCNT行进：EMPOUT END-EXEC。执行PRINTDATA。显示“”。显示“使用FETCH PRIOR ROWSET获取”。来自C1的EXEC SQL FETCH PRIOR ROWSET：FETCHCNT行进：EMPOUT END-EXEC。执行PRINTDATA。 *打印获取的数据PRINTDATA。执行从1比1改变CNT到CNT&gt; FETCHCNT显示“Empno =”，EMPNO1（CNT），“，Ename =”，ENAME1（CNT），“，Job =”，JOB1（CNT），“，Mgr =”， MGR1（CNT），“，Hiredate =”，HIREDATE1（CNT）DISPLAY“Sal =”，SAL1（CNT），“，Comm =”，COMM1（CNT），“，Deptno =”，DEPTNO1（CNT）END-PERFORM 。 *处理SQL错误条件SQL-ERROR。执行SQL WHENEVER SQLERROR CONTINUE END-EXEC。显示“”。显示“ORACLE ERROR DETECTED：”。显示“”。显示SQLERRMC。 EXEC SQL ROLLBACK工作发布END-EXEC。停止运行。</pre></div>
                  <!-- class="example" -->
               </div>
            </div><a id="LNPCB492"></a><a id="LNPCB491"></a><div class="props_rev_3"><a id="GUID-7F3C702D-8901-4F1E-9F7F-A4818FCC0D19" name="GUID-7F3C702D-8901-4F1E-9F7F-A4818FCC0D19"></a><h3 id="LNPCB-GUID-7F3C702D-8901-4F1E-9F7F-A4818FCC0D19" class="sect3"><span class="enumeration_section">7.15</span>使用隐式缓冲插入</h3>
               <div>
                  <p>为了提高性能，Pro * Cobol应用程序开发人员可以在其嵌入式SQL语句中引用主机数组。这提供了一种通过单次往返数据库来执行SQL语句数组的方法。尽管阵列执行提供了显着的性能改进，但一些开发人员选择不使用此功能，因为它不是ANSI标准。例如，使用IBM的预编译器无法预编译在Oracle中利用数组执行编写的应用程序。</p>
                  <p>一种解决方法是使用缓冲的INSERT语句，这使您可以在保留ANSI标准嵌入式SQL语法的同时获得性能优势。</p>
                  <p>命令行选项“max_row_insert”控制在执行INSERT语句之前要缓冲的行数。默认情况下，它为零，并且禁用该功能。要启用此功能，请指定任何大于零的数字。</p>
                  <p>如果启用了插入缓冲，则预编译器运行时将标记相应的光标并：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>分配或重新分配额外的内存以保存绑定值（仅首先执行）。</p>
                     </li>
                     <li>
                        <p>将绑定值从程序主机变量复制到内部运行时绑定结构。</p>
                     </li>
                     <li>
                        <p>增加行缓冲计数。</p>
                     </li>
                     <li>
                        <p>如果MAX_INSERT_ROWS已被缓冲，则刷新缓冲的INSERT语句。</p>
                     </li>
                     <li>
                        <p>如果尚未命中MAX_INSERT_ROWS，则在将值复制到内部绑定缓冲区而不刷新后返回。</p>
                     </li>
                  </ul>
                  <p>如果要执行新的嵌入式SQL语句，则会导致刷新缓冲的插入语句：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>冲洗缓冲区。</p>
                     </li>
                     <li>
                        <p>继续提示刷新的调用</p>
                     </li>
                  </ul>
                  <p>通过标准预编译器错误机制（例如Pro * Cobol中的SQLCODE或SQLSTATE）通知应用程序错误。</p>
                  <p>“implicit_svpt”选项控制是否在新批处理插入的开始之前采用隐式保存点。</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>如果是，则在开始新批次行之前获取保存点。如果插入时发生错误，则执行隐式“回滚到保存点”。</p>
                     </li>
                     <li>
                        <p>如果不是，则不会采用隐式保存点。如果缓冲插入时发生错误，则会将其报告回应用程序，但不会执行回滚。缓冲区插入异步报告错误。在应用程序中执行INSERT语句时，不会报告插入行的错误。</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>当执行除INSERT之外的第一个语句时，稍后将报告插入行的某些错误。这可能包括DELETE，UPDATE，INSERT（进入不同的表），COMMIT和ROLLBACK。任何关闭缓冲插入语句的语句都可以报告错误。在这种情况下，不会执行报告错误的语句。您需要首先处理错误并重新执行报告缓冲插入错误的语句。否则，您可以回滚事务并重新执行它。</p>
                              <p>例如，考虑使用COMMIT语句来关闭缓冲的插入循环。COMMIT可以报告错误，因为来自先前插入的重复键。在这种情况下，不执行提交。您应该首先处理错误，然后重新执行COMMIT。否则，您可以回滚事务并重新执行它。</p>
                           </li>
                           <li>
                              <p>插件本身会报告一些错误，并且可能反映先前插入的行的错误。在这种情况下，不会执行进一步的插入。您需要处理先前插入的行的错误并继续插入当前插入，这是一个漫长的过程。相反，您可以回滚并重新执行该事务。</p>
                              <p>例如，考虑内部缓冲区的限制为10行，应用程序在循环中插入15行。假设第8行有错误。第11行插入发生时报告错误，并且不再执行插入操作。</p>
                           </li>
                        </ul>
                     </li>
                  </ul>
                  <p>以下是缓冲插入期间可能遇到的一些错误：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>ORA-00001：索引中的重复键</p>
                     </li>
                     <li>
                        <p>ORA-01400：在插入期间缺少必需（非空）列或Null</p>
                     </li>
                     <li>
                        <p>ORA-01401：插入的值对于列太大</p>
                     </li>
                     <li>
                        <p>ORA-01438：大于指定精度的值允许此列</p>
                     </li>
                  </ul>
                  <div class="example" id="GUID-7F3C702D-8901-4F1E-9F7F-A4818FCC0D19__GUID-A28BF4EE-FE2C-4B62-A5FB-2A6B21CA1845">
                     <p class="titleinexample">例7-2将缓冲行插入表中</p>
                     <p>该程序将LOOPCNT行数插入EMP表。在循环计数器= 5时，此程序尝试插入无效的empno。如果没有max_row_insert选项，程序将插入除无效行之外的所有行。当max_row_insert选项设置为LOOPCNT时，仅插入前四行。</p>
                     <p>使用max_row_insert选项，当删除错误语句时，程序执行与数组插入程序相同的方式。</p><pre class="oac_no_warn" dir="ltr">************************************************** *************** * bufinsdemo：* * * *此程序将LOOPCNT行数插入EMP表。* *在循环计数器= 5时，此程序尝试插入无效的* * empno。如果没有max_row_insert选项，此程序将插入* *除此无效行之外的所有行。当max_row_insert选项* *设置为LOOPCNT时，仅插入前4行。* * * *使用max_row_insert选项，当删除此错误语句* *时，此程序的性能类似于在此程序中具有数组插入的* *。* ************************************************* ****************身份识别部门。 PROGRAM-ID。 bufinsdemo。环境部门。配置部分。数据部门。工作储存部分。 * EMBEDDED COBOL（文件“BUFINSDEMO.PCO”）执行SQL开始声明部分END-EXEC。 01 USERNAME PIC X（10）变化。 01 PASSWD PIC X（10）变化。 01 EMPIN。 02 EMPNO PIC 9（6）COMP。 02 ENAME PIC X（10）。02 JOB PIC X（9）。02 MGR PIC 9（4）。02 HIREDATE PIC X（9）。02 SAL PIC X（6）。02 COMM PIC X（6）。02 DEPTNO PIC 9（2）。01 EMPOUT。 02 EMPNO1 PIC 9（4）COMP。 02 ENAME1 PIC X（10）。02 JOB1 PIC X（9）。02 MGR1 PIC 9（4）。02 HIREDATE1 PIC X（9）。02 SAL1 PIC X（6）。02 COMM1 PIC X（6）。02 DEPTNO1 PIC 9（2）。EXEC SQL END DECLARE SECTION END-EXEC。 01 LOOPCNT PIC 9（4）COMP值100。01 CNT PIC 9（4）。01 CNT2 PIC 9（2）。01 STRINGFIELDS。 02 STR PIC X（18）变化。 EXEC SQL包含SQLCA END-EXEC。程序部门。 BEGIN-PGM。执行SQL WHENEVER SQLERROR执行SQL-ERROR END-EXEC。表演登录。 *当max_row_insert选项设置为LOOPCNT并且删除errorneous *语句时，所有行将在一个段中插入数据库*，因此将实现最大性能增益。显示“插入”，LOOPCNT，“行到EMP表”。通过CNT&gt; LOOPCNT从1比1改变CNT的性能。 EXEc SQL COMMIT END-EXEC。 EXEC SQL SELECT COUNT（*）INTO：CNT from EMP EERE LIKE'EMP_％'END-EXEC。 DISPLAY“成功插入EMP的行数”“表：”，CNT。显示“”。EXEC SQL DECLARE C1 CURSOR用于选择EMPNO，ENAME，JOB，MGR，HIREDATE，SAL，COMM，DEPTNO来自EMP，ENAME喜欢EMP_％'按EMPNO END-EXEC排序。 EXEC SQL OPEN C1 END-EXEC。显示“从EMP表中获取插入的行”。PERFORM FETCH-TAB。 ENDFETCH-TAB。 EXEC SQL CLOSE C1 END-EXEC。 EXEC SQL从EMP中删除EMPNO &lt;1000 END-EXEC。 EXEC SQL COMMIT WORK RELEASE END-EXEC。停止运行。登录。将“scott”移至USERNAME-ARR。移动5到USERNAME-LEN。将“老虎”移到PASSWD-ARR。移动5到PASSWD-LEN。 EXEC SQL CONNECT：USERNAME IDENTIFIED BY：PASSWD END-EXEC。 *将数据插入EMP表INS-TAB。如果CNT = 5那么移动10000到EMPNO移动CNT到EMPNO结束 - 如果移动到“STR”。 STRING“EMP_”，CNT IN STR STR-STRING。移动STR到ENAME。移动“”到STR。 STRING“JOB_”，CNT IN STR STR-STRING。移动到工作岗位。移动100到MGR。如果CNT&gt; 30那么计算CNT2 = 30 ELSE将CNT移动到CNT2结束 - 如果移动“”到STR。 STRING CNT2，“-JAN-06”进入STR END-STRING。移动STR进行招聘。移动“”到STR。 STRING CNT2，“000”进入STR END-STRING。移动STR到SAL。移动1000到COMM。移动10到DEPTNO。 EXEC SQL INSERT INTO EMP（EMPNO，ENAME，JOB，MGR，HIREDATE，SAL，COMM，DEPTNO）VALUES（：EMPIN）END-EXEC。 *从EMP TABLE FETCH-TAB中获取数据。 EXEC SQL WHENEVER未找到GOTO ENDFETCH-TAB END-EXEC。 EXEC SQL FETCH C1 INTO：EMPOUT END-EXEC。 DISPLAY“Empno =”，EMPNO1，“，Ename =”，ENAME1，“，Job =”，JOB1，“，Mgr =”，MGR1，“，Hiredate =”，HIREDATE1。显示“Sal =”，SAL1，“，Comm =”，COMM1，“，Deptno =”，DEPTNO1。去FETCH-TAB。 *处理SQL错误条件SQL-ERROR。显示“ORACLE ERROR DETECTED：”。显示SQLERRMC。</pre></div>
                  <!-- class="example" -->
               </div>
            </div>
         </div>
      </article>
   </body>
</html>