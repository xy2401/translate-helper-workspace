<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <title>优化C ++应用程序的性能</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Programmer&#39;s Guide "></meta>
      <meta property="og:description" content=""></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Programmer&#39;s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="oracle-c-call-interface-programmers-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-03-06T02:31:59-08:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="1999, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96205-02"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="oracle-xa-library.html" title="Previous" type="text/html"></link>
      <link rel="next" href="occi-application-programing-interface.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Oracle C++ Call Interface Programmer&#39;s Guide"></meta>
    <meta name="dcterms.isVersionOf" content="LNCPP"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="oracle-xa-library.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="occi-application-programing-interface.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">程序员指南</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">优化C ++应用程序的性能</li>
            </ol>
            <a id="GUID-0901F6D0-F5DE-462A-A367-EE2C2AA55698" name="GUID-0901F6D0-F5DE-462A-A367-EE2C2AA55698"></a><a id="LNCPP012"></a>
            
            <h2 id="LNCPP-GUID-0901F6D0-F5DE-462A-A367-EE2C2AA55698" class="sect2"><span class="enumeration_chapter">12</span>优化C ++应用程序的性能</h2>
         </header>
         <div class="ind">
            <div>
               <p>本章介绍了一些可以提高OCCI自定义应用程序性能的建议。</p>
               <p>本章包含以下主题：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="optimizing-performance-of-cplusplus-applications.html#GUID-B822003D-DCE2-4704-9D83-4BF401B26882">关于透明应用程序故障转移</a></p>
                  </li>
                  <li>
                     <p><a href="optimizing-performance-of-cplusplus-applications.html#GUID-7191B319-0109-446E-96A1-65AB696C8C99">关于连接共享</a></p>
                  </li>
                  <li>
                     <p><a href="optimizing-performance-of-cplusplus-applications.html#GUID-96783A66-4018-4CC4-9D9A-36075BB3FF1A">关于应用程序管理数据缓冲</a></p>
                  </li>
                  <li>
                     <p><a href="optimizing-performance-of-cplusplus-applications.html#GUID-F6AD3A0C-7DD2-4362-8BFE-F4718D26817C">使用数组提取使用next（）方法</a></p>
                  </li>
                  <li>
                     <p><a href="optimizing-performance-of-cplusplus-applications.html#GUID-B406B496-9395-4D76-899F-71E414B68FB9">迭代地修改行</a></p>
                  </li>
                  <li>
                     <p><a href="optimizing-performance-of-cplusplus-applications.html#GUID-BF9AFFD6-537A-4252-BBFB-3A60EEAC3E61" title="Traffic Director Mode中的Oracle Connection Manager是一个放置在支持的数据库客户端和数据库实例之间的代理。">关于在Traffic Director模式下使用Oracle Connection Manager</a></p>
                  </li>
                  <li>
                     <p><a href="optimizing-performance-of-cplusplus-applications.html#GUID-5F06D230-7248-4BB0-AC4C-0BC42AC6B3AC">关于无状态连接池的运行时负载平衡</a></p>
                  </li>
                  <li>
                     <p><a href="optimizing-performance-of-cplusplus-applications.html#GUID-8ADCAB82-EBBE-43C0-BECE-4E74687A166D">关于故障诊断</a></p>
                  </li>
                  <li>
                     <p><a href="optimizing-performance-of-cplusplus-applications.html#GUID-740894FB-9DAE-4F98-BA70-0C4E04479200">使用客户端结果缓存</a></p>
                  </li>
                  <li>
                     <p><a href="optimizing-performance-of-cplusplus-applications.html#GUID-E8DD631B-9AFF-49F5-BFBA-ED55001DB052">关于客户端部署参数和自动调整</a></p>
                  </li>
               </ul>
               <div class="infoboxnotealso" id="GUID-0901F6D0-F5DE-462A-A367-EE2C2AA55698__GUID-EC4BD1C4-6E53-41FC-9630-B47F3073E041">
                  <p class="notep1">也可以看看：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="occi-application-programing-interface.html#GUID-3C824380-073E-4F32-AA6E-928A18D52F4B">OCCI应用程序编程接口</a></p>
                     </li>
                  </ul>
               </div>
            </div><a id="LNCPP20011"></a><div class="props_rev_3"><a id="GUID-B822003D-DCE2-4704-9D83-4BF401B26882" name="GUID-B822003D-DCE2-4704-9D83-4BF401B26882"></a><h3 id="LNCPP-GUID-B822003D-DCE2-4704-9D83-4BF401B26882" class="sect3"><span class="enumeration_section">12.1</span>关于透明应用程序故障转移</h3>
               <div>
                  <p>OCCI <span class="bold">透明应用程序故障转移</span> （TAF）使OCCI在运行时处理分布式应用程序中的数据库实例故障时更加强大。如果服务器节点不可用，应用程序将自动重新连接到另一个幸存节点。
                  </p>
                  <p>当客户端应用程序在往返操作期间检测到数据库实例已关闭时，会发生TAF。它建立与为TAF配置的备份数据库的连接。此备份可以是Oracle RAC配置中的另一个节点，热备用数据库或相同的数据库实例本身。</p>
                  <p>负责失败连接往返的OCCI / OCI API通常会返回以下错误之一：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><code class="codeph">ORA-25401：无法继续提取</code></p>
                     </li>
                     <li>
                        <p><code class="codeph">ORA-25402：交易必须回滚</code></p>
                     </li>
                     <li>
                        <p><code class="codeph">ORA-25408：无法安全重播通话</code></p>
                     </li>
                  </ul>
                  <p>新连接可用于后续应用程序请求以及必须重新启动的任何正在进行的工作。应用程序中的空闲连接不受影响。</p>
                  <p>在应用程序中包含透明应用程序故障转移时，应考虑一些设计选项：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>由于故障转移处理固有的延迟，应用程序的设计可能包括通知用户正在进行故障转移并且应该很快恢复正常操作。</p>
                     </li>
                     <li>
                        <p>如果初始实例上的<code class="codeph">ALTER SESSION</code>在故障转移开始之前收到<code class="codeph">ALTER SESSION</code>命令，则它们不会在第二个实例上自动重播。
                        </p>
                        <p>因此，开发人员可能希望在第二个实例上重播这些<code class="codeph">ALTER SESSION</code>命令。
                        </p>
                     </li>
                  </ul>
                  <p>用户有责任跟踪<code class="codeph">SESSION</code>参数的更改。
                  </p>
                  <p>为解决这些问题，应用程序可以注册故障转移回调函数。故障转移后，在重新建立用户会话时，将在不同时间调用回调函数。</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>当Oracle首次检测到实例连接丢失时，会发生对回调函数的第一次调用。此回调旨在允许应用程序通知用户即将发生的延迟。</p>
                     </li>
                     <li>
                        <p>如果故障转移成功，则在重新建立和使用连接时会发生对回调函数的第二次调用。此时，客户端可能希望重播<code class="codeph">ALTER SESSION</code>命令并通知用户已发生故障转移。请注意，您必须跟踪<code class="codeph">SESSION</code>参数更改，然后在故障转移完成后重播它们。
                        </p>
                        <p>如果故障转移不成功，则调用回调函数以通知应用程序无法进行故障转移。</p>
                     </li>
                     <li>
                        <p>故障转移的初始尝试可能并不总是成功。故障转移回调应返回<code class="codeph">FO_RETRY</code>以指示应再次尝试故障转移。
                        </p>
                        <div class="infoboxnotealso" id="GUID-B822003D-DCE2-4704-9D83-4BF401B26882__GUID-9E243EF4-4174-48DD-944B-E7A5B6585D4F">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><a href="occi-application-programing-interface.html#GUID-3C824380-073E-4F32-AA6E-928A18D52F4B">OCCI应用程序编程接口</a> <a href="connection-class.html#GUID-412D06D3-7636-4A32-AF24-534099F989D0__BBAEAHAH" title="第一列列出类使用的属性，第二列描述每个属性可用的选项">中表13-11</a>中<code class="codeph">FailOverType</code>和<code class="codeph">FailOverEventType</code>定义 
                                 </p>
                              </li>
                              <li>
                                 <p>有关应用程序故障转移的详细信息，请参见<a href="../netag/enabling-advanced-features.html#NETAG455" target="_blank"><span><cite>“Oracle数据库网络服务管理员指南”</cite></span></a>
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </li>
                  </ul>
                  <div class="p">本节包括以下主题：<ul style="list-style-type:disc">
                        <li>
                           <p><a href="optimizing-performance-of-cplusplus-applications.html#GUID-D8B753E9-89F6-46F1-BB03-4B6836DBD138">使用透明应用程序故障转移</a></p>
                        </li>
                        <li>
                           <p><a href="optimizing-performance-of-cplusplus-applications.html#GUID-6729D045-E737-4BE9-A50D-6AB39243DA5F">关于对象和透明应用程序故障转移</a></p>
                        </li>
                        <li>
                           <p><a href="optimizing-performance-of-cplusplus-applications.html#GUID-146ED846-BA38-42BC-8F71-F88BD9631444">使用连接池和透明应用程序故障转移</a></p>
                        </li>
                     </ul>
                  </div>
               </div><a id="LNCPP20477"></a><div class="props_rev_3"><a id="GUID-D8B753E9-89F6-46F1-BB03-4B6836DBD138" name="GUID-D8B753E9-89F6-46F1-BB03-4B6836DBD138"></a><h4 id="LNCPP-GUID-D8B753E9-89F6-46F1-BB03-4B6836DBD138" class="sect4"><span class="enumeration_section">12.1.1</span>使用透明应用程序故障转移</h4>
                  <div>
                     <div class="section">
                        <p>要启用TAF，必须配置连接字符串以进行故障转移并在<code class="codeph">Connection</code>注册（从<code class="codeph">Environment</code> ， <code class="codeph">ConnectionPool</code>和<code class="codeph">StatelessConnectionPool</code>创建）。要注册回调函数，请使用<a href="connection-class.html#GUID-412D06D3-7636-4A32-AF24-534099F989D0">Connection Class</a>接口<a href="connection-class.html#GUID-0C0A528D-6669-490E-BC2E-9A8183D4F95B">setTAFNotify（）</a> ：</p><pre class="oac_no_warn" dir="ltr">void Connection :: setTAFNotify（int（* notifyFn）（Environment * env，Connection * conn，void * ctx，FailOverType foType，FailOverEventType foEvent），void * ctxTAF）;</pre><p>请注意，对<code class="codeph">ConnectionPool</code>的TAF支持不包括<code class="codeph">BACKUP</code>和<code class="codeph">PRECONNECT</code>子句;这些不应该在连接字符串中使用。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNCPP20478"></a><div class="props_rev_3"><a id="GUID-6729D045-E737-4BE9-A50D-6AB39243DA5F" name="GUID-6729D045-E737-4BE9-A50D-6AB39243DA5F"></a><h4 id="LNCPP-GUID-6729D045-E737-4BE9-A50D-6AB39243DA5F" class="sect4"><span class="enumeration_section">12.1.2</span>关于对象和透明应用程序故障转移</h4>
                  <div>
                     <p>透明应用程序故障转移与OCCI导航和关联访问模型以及对象缓存一起使用。在非Oracle RAC设置中，必须确保主实例和备份实例中的对象类型定义和对象OID相同。</p>
                     <p>如果应用程序收到<code class="codeph">ORA-25402: transaction must roll back</code>在故障转移后<code class="codeph">ORA-25402: transaction must roll back</code>错误，那么它必须启动回滚以正确重置客户端上的对象缓存。如果事务在故障转移之前尚未启动，则应用程序仍应在故障转移后启动回滚，以从新实例刷新客户端对象缓存上的对象。
                     </p>
                  </div>
               </div><a id="LNCPP21907"></a><a id="LNCPP20479"></a><div class="props_rev_3"><a id="GUID-146ED846-BA38-42BC-8F71-F88BD9631444" name="GUID-146ED846-BA38-42BC-8F71-F88BD9631444"></a><h4 id="LNCPP-GUID-146ED846-BA38-42BC-8F71-F88BD9631444" class="sect4"><span class="enumeration_section">12.1.3</span>使用连接池和透明应用程序故障转移</h4>
                  <div>
                     <div class="section">
                        <p>如果激活透明应用程序故障转移功能，则还会在连接池中创建的连接进行故障转移。必须为从连接池获取的每个连接指定应用程序故障转移回调;在主实例失败后使用时，这些连接会被故障转移。</p>
                        <p>请注意，必须明确清除和修复自定义连接池中的连接。考虑一个池中有500个连接的应用程序; 10个连接正忙（进行往返），490个空闲或空闲。如果数据库实例失败，则TAF将处理10个活动连接，并且必须重新启动这些连接上的客户端请求。当应用程序拾取每个其他490个连接时，执行TAF并且OCCI返回错误代码<code class="codeph">ORA-25401</code> ， <code class="codeph">ORA-24502</code>或<code class="codeph">ORA-25408</code> ，强制重新启动用户请求。应用程序可以通过使用先前在连接池中的10个连接上激活TAF的知识来修复或清除这些连接，从而避免490空闲连接上的这些错误。
                        </p>
                        <p>要修复OCCI中的<a href="connection-class.html#GUID-412D06D3-7636-4A32-AF24-534099F989D0">连接</a> ，请使用<a href="connection-class.html#GUID-412D06D3-7636-4A32-AF24-534099F989D0">Connection Class</a>接口<a href="connection-class.html#GUID-D158EE4A-59B4-46F6-82FF-F26E6B07C1B7">getServerVersion（）</a> ，这是一个轻量级，数据中立的数据库调用，用于在与失败实例的连接上启动TAF：</p><pre class="oac_no_warn" dir="ltr">string getServerVersion（）const;</pre><p>在OCCI TAF回调中，应用程序可以在自定义池中的空闲连接上调用<a href="connection-class.html#GUID-D158EE4A-59B4-46F6-82FF-F26E6B07C1B7">getServerVersion（）</a> ，以启动并完成这些连接的故障转移。
                        </p>
                        <p><a href="optimizing-performance-of-cplusplus-applications.html#GUID-146ED846-BA38-42BC-8F71-F88BD9631444__BBACAHGD">例12-1</a>演示了如何将OCCI用于TAF回调和修复错误连接。请注意，该示例未显示自定义池数据结构或静音和并发控制。
                        </p>
                        <p>请注意，自定义连接池中的独立连接和连接的TAF行为是相同的。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-146ED846-BA38-42BC-8F71-F88BD9631444__BBACAHGD">
                        <p class="titleinexample">例12-1如何为连接池启用TAF</p><pre class="oac_no_warn" dir="ltr">#include &lt;occi.h&gt; #include &lt;iostream&gt; #include &lt;time.h&gt; using namespace std; using namespace oracle :: occi; // 3个连接的应用程序自定义池Environment * env;连接* conn1，* conn2，* conn3; bool conn1free，conn2free，conn3free; bool repairing = false; int taf_callback（Environment * env，Connection * conn，void * ctx，Connection :: FailOverType foType，Connection :: FailOverEventType foEvent）{cout &lt;&lt;“TAF callback for connection”&lt;&lt; conn &lt;&lt; endl; if（foEvent == Connection :: FO_ERROR）{cout &lt;&lt;“Retrying”&lt;&lt; endl;返回FO_RETRY; if（foEvent == Connection :: FO_END）{cout &lt;&lt;“TAF complete for connnection”&lt;&lt; conn &lt;&lt; endl; if（修复==假）{repairing = true; cout &lt;&lt;“修复其他空闲连接”&lt;&lt; endl; //在TAF尝试期间忽略错误{if（conn1free）conn1-&gt; getServerVersion（）;抓住（...）{} try {if（conn2free）conn2-&gt; getServerVersion（）;抓住（...）{} try {if（conn3free）conn3-&gt; getServerVersion（）;抓住（...）{}修复=假; } // if} //如果返回0; // continue failover} main（）{try {env = Environment :: createEnvironment（Environment :: THREADED_MUTEXED）; //打开3个连接; conn1 = env-&gt; createConnection（“hr”，“ <span class="italic">password</span> ”，“inst1_failback”）; conn2 = env-&gt; createConnection（“hr”，“ <span class="italic">password</span> ”，“inst1_failback”）; conn3 = env-&gt; createConnection（“hr”，“ <span class="italic">password</span> ”，“inst1_failback”）; //所有连接都是'空闲'conn1free = conn2free = conn3free = true; //在所有连接上设置TAF回调conn1-&gt; setTAFNotify（taf_callback，NULL）; conn2-&gt; setTAFNotify（taf_callback，NULL）; conn3-&gt; setTAFNotify（taf_callback，NULL）; //使用1个连接conn1free = false; cout &lt;&lt;“使用conn1”&lt;&lt; endl; Statement * stmt = conn1-&gt; createStatement（“select * from employees”）; ResultSet * rs = stmt-&gt; executeQuery（）; while（rs-&gt; next（））{cout &lt;&lt;（rs-&gt; getString（2））&lt;&lt; endl; } stmt-&gt; closeResultSet（rs）; conn1-&gt; terminateStatement（语句）; cout &lt;&lt;“关闭并重新启动数据库”&lt;&lt; endl;字符串buf; cin &gt;&gt; buf;声明* stmt2; try {cout &lt;&lt;“在EMP表上尝试更新”&lt;&lt; endl; stmt2 = conn1-&gt; createStatement（“从员工中删除”）; stmt2-&gt;的executeUpdate（）; } catch（SQLException＆ex）{cout &lt;&lt;“Update EMPLOYEES返回错误：”&lt;&lt; ex.getMessage（）&lt;&lt; endl; cin &gt;&gt; buf; } cout &lt;&lt;“完成”&lt;&lt; endl; env-&gt; terminateConnection（conn1连接）; env-&gt; terminateConnection（CONN2）; env-&gt; terminateConnection（CONN3）;环境:: terminateEnvironment（ENV）; } catch（SQLException＆ex）{cout &lt;&lt; ex.getMessage（）&lt;&lt; endl; }}</pre></div>
                     <!-- class="example" -->
                  </div>
               </div>
            </div><a id="LNCPP1202"></a><div class="props_rev_3"><a id="GUID-7191B319-0109-446E-96A1-65AB696C8C99" name="GUID-7191B319-0109-446E-96A1-65AB696C8C99"></a><h3 id="LNCPP-GUID-7191B319-0109-446E-96A1-65AB696C8C99" class="sect3"><span class="enumeration_section">12.2</span>关于连接共享</h3>
               <div>
                  <p>本节包括以下主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="optimizing-performance-of-cplusplus-applications.html#GUID-E81F6929-F527-4FF3-A38C-58FCC384964E">线程安全简介</a></p>
                     </li>
                     <li>
                        <p><a href="optimizing-performance-of-cplusplus-applications.html#GUID-2462E0CD-D58A-405C-B7D6-E725ED5147AE">实施线程安全</a></p>
                     </li>
                     <li>
                        <p><a href="optimizing-performance-of-cplusplus-applications.html#GUID-A1BDEA6E-2FB9-4E0F-B15B-83F1A56419A3">关于序列化</a></p>
                     </li>
                     <li>
                        <p><a href="optimizing-performance-of-cplusplus-applications.html#GUID-11EFCB7F-D572-43D8-A345-4737BD09E9EF">操作系统注意事项</a></p>
                     </li>
                  </ul>
               </div><a id="LNCPP20480"></a><div class="props_rev_3"><a id="GUID-E81F6929-F527-4FF3-A38C-58FCC384964E" name="GUID-E81F6929-F527-4FF3-A38C-58FCC384964E"></a><h4 id="LNCPP-GUID-E81F6929-F527-4FF3-A38C-58FCC384964E" class="sect4"><span class="enumeration_section">12.2.1</span>线程安全简介</h4>
                  <div>
                     <p>线程是存在于更大进程中的轻量级进程。每个线程共享相同的代码和数据段，但有自己的程序计数器，系统寄存器和堆栈。全局变量和静态变量对于所有线程都是通用的，并且可能需要互斥机制来管理从应用程序内的多个线程对这些变量的访问。</p>
                     <p>一旦产生，线程就会彼此异步运行。他们可以访问公共数据元素并以任何顺序进行OCCI调用。由于对数据元素的这种共享访问，需要一种机制来维护多个线程访问的数据的完整性。管理数据访问的机制采用互斥（互斥锁）的形式，确保在访问应用程序中的共享资源的多个线程之间不会发生冲突。在OCCI中，互斥体是在OCCI环境的基础上授予的。</p>
                     <p>Oracle数据库服务器和OCCI库的此线程安全功能使开发人员能够在多线程应用程序中使用OCCI，并具有以下额外优势：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>多个执行线程可以使OCCI调用与单个线程进行的连续调用具有相同的结果。</p>
                        </li>
                        <li>
                           <p>当多个线程进行OCCI调用时，线程之间没有副作用。</p>
                        </li>
                        <li>
                           <p>即使您不编写多线程程序，也不会因包含线程安全的OCCI调用而支付任何性能损失。</p>
                        </li>
                        <li>
                           <p>使用多个线程可以提高程序性能。您可以在多处理器系统上辨别线程，其中线程在单独的处理器上并发运行，并且在单处理器系统上可以在较慢的操作和更快的操作之间发生重叠。</p>
                        </li>
                     </ul>
                     <p>除客户端/服务器应用程序（客户端可以是多线程程序）之外，线程安全性通常用于三层或客户端/代理程序/服务器体系结构中。在此体系结构中，客户端仅关注表示服务。代理（或应用程序服务器）处理客户端应用程序的应用程序逻辑。通常，此关系是多对一关系，多个客户端共享同一应用程序服务器。</p>
                     <p>三层体系结构中的服务器层是Oracle数据库服务器。应用程序服务器（代理）支持多线程，每个线程为单独的客户端应用程序提供服务。在Oracle环境中，此中间层应用程序服务器是OCCI或预编译器程序。</p>
                  </div>
               </div><a id="LNCPP20481"></a><div class="props_rev_3"><a id="GUID-2462E0CD-D58A-405C-B7D6-E725ED5147AE" name="GUID-2462E0CD-D58A-405C-B7D6-E725ED5147AE"></a><h4 id="LNCPP-GUID-2462E0CD-D58A-405C-B7D6-E725ED5147AE" class="sect4"><span class="enumeration_section">12.2.2</span>实现线程安全</h4>
                  <div>
                     <div class="section">
                        <p>要通过使用OCCI来利用线程安全性，应用程序必须在线程安全的操作系统中运行。然后，应用程序必须通过为<code class="codeph">createEnvironment()</code>方法的mode参数指定<code class="codeph">THREADED_MUTEXED</code>或<code class="codeph">THREADED_UNMUTEXED</code>来通知OCCI应用程序在多线程模式下运行。例如，要启用互斥锁定，请发出以下声明：</p><pre class="oac_no_warn" dir="ltr">Environment * env = Environment :: createEnvironment（Environment :: THREADED_MUTEXED）;</pre><p>请注意，一旦<code class="codeph">createEnvironment</code>被称为与<code class="codeph">THREADED_MUTEXED</code>或<code class="codeph">THREADED_UNMUTEXED</code> ，对所有后续调用<code class="codeph">createEnvironment</code>方法也必须做出<code class="codeph">THREADED_MUTEXED</code>或<code class="codeph">THREADED_UNMUTEXED</code>模式。
                        </p>
                        <p>如果多线程应用程序在线程安全的操作系统中运行，则OCCI库在每个OCCI环境的基础上管理应用程序的互斥锁。但是，您可以覆盖此功能并让您的应用程序维护自己的互斥锁方案。这是通过为<code class="codeph">createEnvironment()</code>方法指定<code class="codeph">THREADED_UNMUTEXED</code>的模式值来完成的。
                        </p>
                        <p>在非线程安全平台上运行的应用程序不应将<code class="codeph">THREADED_MUTEXED</code>或<code class="codeph">THREADED_UNMUTEXED</code>值传递给<code class="codeph">createEnvironment()</code>方法。
                        </p>
                        <p>如果应用程序是单线程的，则无论平台是否是线程安全的，应用程序都应将<code class="codeph">Environment::DEFAULT</code>的值传递给<code class="codeph">createEnvironment()</code>方法。这也是mode参数的默认值。在<code class="codeph">THREADED_MUTEXED</code>模式下运行的单线程应用程序可能会导致性能下降。
                        </p>
                        <p>OCCI不支持非阻塞模式。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNCPP20482"></a><div class="props_rev_3"><a id="GUID-A1BDEA6E-2FB9-4E0F-B15B-83F1A56419A3" name="GUID-A1BDEA6E-2FB9-4E0F-B15B-83F1A56419A3"></a><h4 id="LNCPP-GUID-A1BDEA6E-2FB9-4E0F-B15B-83F1A56419A3" class="sect4"><span class="enumeration_section">12.2.3</span>关于序列化</h4>
                  <div>
                     <p>作为应用程序员，您在多线程应用程序中有两个关于并发的基本选项：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="optimizing-performance-of-cplusplus-applications.html#GUID-747EE0AB-EED6-4B03-9029-190AF2C0B609">自动序列化</a> ，您可以使用OTIS的透明机制</p>
                        </li>
                        <li>
                           <p><a href="optimizing-performance-of-cplusplus-applications.html#GUID-9A71755F-9EC4-4F00-AED0-B7CBBF96DFEF">应用程序提供的序列化</a> ，您可以在其中管理维护多个线程所涉及的意外事件</p>
                        </li>
                     </ul>
                  </div><a id="LNCPP20483"></a><div class="props_rev_3"><a id="GUID-747EE0AB-EED6-4B03-9029-190AF2C0B609" name="GUID-747EE0AB-EED6-4B03-9029-190AF2C0B609"></a><h5 id="LNCPP-GUID-747EE0AB-EED6-4B03-9029-190AF2C0B609" class="sect5"><span class="enumeration_section">12.2.3.1</span>自动序列化</h5>
                     <div>
                        <p>如果有多个线程在从OCCI环境派生的对象（连接和连接池）上运行，您可以选择让OCCI序列化对这些对象的访问。第一步是将值<code class="codeph">THREADED_MUTEXED</code>传递给<code class="codeph">createEnvironment</code>方法。此时，OCCI库会自动获取环境中线程安全对象的互斥锁。
                        </p>
                        <p>使用<code class="codeph">THREADED_MUTEXED</code>模式创建OCCI环境时，只有<code class="codeph">Environment</code> ， <code class="codeph">Map</code> ， <code class="codeph">ConnectionPool</code> ， <code class="codeph">StatelessConnectionPool</code>和<code class="codeph">Connection</code>对象是线程安全的。也就是说，如果两个线程同时调用其中一个对象，则OCCI会在内部对它们进行序列化。但请注意，所有其他OCCI对象（如<code class="codeph">Statement</code> ， <code class="codeph">ResultSet</code> ， <code class="codeph">SQLException</code> ， <code class="codeph">Stream</code>等）都不是线程安全的，因为应用程序不应同时从多个线程对这些对象进行操作。
                        </p>
                        <p>请注意，OCCI调用的大部分处理都发生在服务器上，因此如果使用OCCI调用的两个线程转到同一连接，则其中一个线程可能会被阻塞，而另一个线程在服务器上完成处理。</p>
                     </div>
                  </div><a id="LNCPP20484"></a><div class="props_rev_3"><a id="GUID-9A71755F-9EC4-4F00-AED0-B7CBBF96DFEF" name="GUID-9A71755F-9EC4-4F00-AED0-B7CBBF96DFEF"></a><h5 id="LNCPP-GUID-9A71755F-9EC4-4F00-AED0-B7CBBF96DFEF" class="sect5"><span class="enumeration_section">12.2.3.2</span>应用程序提供的序列化</h5>
                     <div>
                        <p>如果有多个线程在从OCCI环境派生的对象上运行，则可以选择管理序列化。第一步是为<code class="codeph">createEnvironment</code>模式传递<code class="codeph">THREADED_UNMUTEXED</code>值。在这种情况下，应用程序必须相互独占地锁定对从同一OCCI环境派生的对象进行的OCCI调用。这具有以下优点：可以基于应用程序设计来优化互斥方案以获得更大的并发性。
                        </p>
                        <p>在此模式下创建OCCI环境时，OCCI会识别应用程序在多线程应用程序中运行，但OCCI无需获取其内部互斥锁。OCCI假定所有对从该OCCI环境派生的对象方法的调用都由应用程序序列化。您可以通过以下两种方式实现：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>每个线程都有自己的环境。也就是说，环境和从中派生的所有对象（连接，连接池，语句，结果集等）不会跨线程共享。在这种情况下，您的应用程序不需要应用任何互斥锁。</p>
                           </li>
                           <li>
                              <p>如果应用程序共享OCCI环境或跨线程从环境派生的任何对象，则它必须序列化对这些对象的访问（通过使用互斥锁等），这样只有一个线程在任何这些对象上调用OCCI方法。</p>
                           </li>
                        </ul>
                        <p>在这两种情况下，OCCI都没有获得互斥体。你必须确保只有一个OCCI通话过程中从OCCI环境在任何给定的时间派生的任何物体上时<code class="codeph">THREADED_UNMUTEXED</code>使用。
                        </p>
                        <p>OCCI经过优化，可以尽可能地重用对象。由于每个环境都有自己的堆，因此多个环境会导致内存消耗增加。拥有多个环境可能意味着重复有关连接，连接池，语句和结果集对象的工作。这导致进一步的内存消耗。</p>
                        <p>与服务器建立多个连接会导致服务器和网络上的资源消耗更多。拥有多个环境通常需要更多连接。</p>
                     </div>
                  </div>
               </div><a id="LNCPP21906"></a><div class="props_rev_3"><a id="GUID-11EFCB7F-D572-43D8-A345-4737BD09E9EF" name="GUID-11EFCB7F-D572-43D8-A345-4737BD09E9EF"></a><h4 id="LNCPP-GUID-11EFCB7F-D572-43D8-A345-4737BD09E9EF" class="sect4"><span class="enumeration_section">12.2.4</span>操作系统注意事项</h4>
                  <div>
                     <p>某些操作系统提供了生成进程的工具，允许子进程重用其父进程创建的状态。</p>
                     <p>父进程生成子进程后，子进程<span class="italic">不得</span>使用父进程创建的数据库连接。由于SQL * Net只希望一个用户进程使用与数据库的特定连接，因此子进程尝试使用与父进程相同的数据库连接可能会导致意外的连接干扰，并导致间歇性的<code class="codeph">ORA-03137</code>错误。
                     </p>
                     <p>当应用程序需要多个并发连接时，Oracle建议在支持线程的平台上使用线程。Oracle支持单线程和多线程应用程序中的并发连接。</p>
                     <p>有关<span class="q"><a href="optimizing-performance-of-cplusplus-applications.html#GUID-2462E0CD-D58A-405C-B7D6-E725ED5147AE">线程</a></span>的更多信息，请参见<span class="q">“ <a href="optimizing-performance-of-cplusplus-applications.html#GUID-E81F6929-F527-4FF3-A38C-58FCC384964E">线程安全性简介</a> ”</span>和<span class="q">“ <a href="optimizing-performance-of-cplusplus-applications.html#GUID-2462E0CD-D58A-405C-B7D6-E725ED5147AE">实现线程安全性</a> ”</span> 。
                     </p>
                     <p>要提高许多并发打开的连接的性能，请参阅<span class="q">“ <a href="accessing-oracle-database-using-cplusplus.html#GUID-753C36CE-E6A0-4F0D-B85E-C253EB916C8D">关于池连接</a> ”</span> 。
                     </p>
                  </div>
               </div>
            </div><a id="LNCPP1203"></a><div class="props_rev_3"><a id="GUID-96783A66-4018-4CC4-9D9A-36075BB3FF1A" name="GUID-96783A66-4018-4CC4-9D9A-36075BB3FF1A"></a><h3 id="LNCPP-GUID-96783A66-4018-4CC4-9D9A-36075BB3FF1A" class="sect3"><span class="enumeration_section">12.3</span>关于应用程序管理数据缓冲</h3>
               <div>
                  <p>当您通过参数化语句中的<code class="codeph">set</code> <span class="italic">xxx</span>方法提供绑定参数的数据时，会将值复制到内部数据缓冲区中，然后将复制的值提供给数据库服务器以进行插入。要减少复制用户缓冲区中可用的<code class="codeph">string</code>类型数据的开销，请使用<a href="resultset-class.html#GUID-9E0C0A68-57B7-4C77-8865-A306BF6953CA">ResultSet类</a>的<a href="resultset-class.html#GUID-98BF5B63-A834-419B-927B-7F02E9ECF1B3">setDataBuffer（）</a>和<a href="resultset-class.html#GUID-1535D185-F592-4B90-B358-998EDC72094A">next（）</a>方法以及<a href="statement-class.html#GUID-DF0FF9BE-6EF5-4D2A-A45D-A6F2FDF6133D">Statement类</a>的<a href="statement-class.html#GUID-9D152584-D72E-42AE-A3CC-3C6A4F35C11B">execute（）</a>方法。
                  </p>
                  <div class="p">本节包括以下主题：<ul style="list-style-type:disc">
                        <li>
                           <p><a href="optimizing-performance-of-cplusplus-applications.html#GUID-0F9A3D45-5912-4AD0-B0FB-DDA8F03C91B5">使用setDataBuffer（）方法</a></p>
                        </li>
                        <li>
                           <p><a href="optimizing-performance-of-cplusplus-applications.html#GUID-D689DB14-F381-4874-9200-8705FCA00CFC">使用executeArrayUpdate（）方法</a></p>
                        </li>
                     </ul>
                  </div>
               </div><a id="LNCPP20485"></a><div class="props_rev_3"><a id="GUID-0F9A3D45-5912-4AD0-B0FB-DDA8F03C91B5" name="GUID-0F9A3D45-5912-4AD0-B0FB-DDA8F03C91B5"></a><h4 id="LNCPP-GUID-0F9A3D45-5912-4AD0-B0FB-DDA8F03C91B5" class="sect4"><span class="enumeration_section">12.3.1</span>使用setDataBuffer（）方法</h4>
                  <div>
                     <div class="section">
                        <p>对于高性能应用程序，OCCI提供<code class="codeph">setDataBuffer</code>方法，由此数据缓冲区由应用程序管理。以下示例显示了<a href="resultset-class.html#GUID-98BF5B63-A834-419B-927B-7F02E9ECF1B3">setDataBuffer（）</a>方法：</p><pre class="oac_no_warn" dir="ltr">void setDataBuffer（int paramIndex，void * buffer，Type type，sb4 size，ub2 * length，sb2 * ind = NULL，ub2 * rc = NULL）;</pre><p>以前的方法示例中使用以下参数：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">paramIndex</code> ：参数号</p>
                           </li>
                           <li>
                              <p><code class="codeph">buffer</code> ：包含数据的数据缓冲区</p>
                           </li>
                           <li>
                              <p><code class="codeph">type</code> ：数据缓冲区中数据的类型</p>
                           </li>
                           <li>
                              <p><code class="codeph">size</code> ：数据缓冲区的大小</p>
                           </li>
                           <li>
                              <p><code class="codeph">length</code> ：数据缓冲区中当前的数据长度</p>
                           </li>
                           <li>
                              <p><code class="codeph">ind</code> ：指标信息。这表示数据是否为<code class="codeph">NULL</code> 。对于参数化语句，值为<code class="codeph">-1</code>表示要插入<code class="codeph">NULL</code>值。对于从可调用语句返回的数据，值<code class="codeph">-1</code>表示检索<code class="codeph">NULL</code>数据。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">rc</code> ：返回代码。此变量不适用于提供给<code class="codeph">Statement</code>方法的数据。但是，对于从可调用语句返回的数据，返回代码指定特定于参数的错误号。
                              </p>
                           </li>
                        </ul>
                        <p>并非所有数据类型都可以通过<code class="codeph">setDataBuffer()</code>方法提供和检索。例如，C ++标准库字符串不能与<code class="codeph">setDataBuffer()</code>接口一起提供。
                        </p>
                        <div class="infoboxnotealso" id="GUID-0F9A3D45-5912-4AD0-B0FB-DDA8F03C91B5__GUID-4F095C86-BBAE-47A8-9BF4-7F33B153427E">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="data-types.html#GUID-62361201-C028-425D-A809-AB0CC01F2F67__CJAFHAAD" title="该表有4列。第1列列出了外部数据类型;第2栏提供简要说明;第3列列出了匹配的C ++类型;第4列列出了匹配的OCCI类型。">表5-2</a>针对特定情况的<a href="data-types.html#GUID-90F238BF-BF35-411C-9CB8-3D6A2970729D">数据类型</a></p>
                        </div>
                        <p><code class="codeph">set</code> <span class="italic">xxx</span> <code class="codeph">()</code>方法和<code class="codeph">setDataBuffer()</code>方法提供的数据之间存在重要差异。在<code class="codeph">set</code> <span class="italic">xxx</span> <code class="codeph">()</code>方法中复制数据时，一旦复制数据，原始文件就会更改。例如，您可以使用<code class="codeph">setString(str1)</code>方法，然后在执行之前更改<code class="codeph">str1</code>的值。使用的<code class="codeph">str1</code>的值是调用<code class="codeph">setString(str1)</code>时的值。但是，对于<code class="codeph">setDataBuffer()</code>方法提供的数据，缓冲区必须保持有效，直到执行完成。
                        </p>
                        <p>如果执行迭代或使用<code class="codeph">executeArrayUpdate()</code>方法，则可以在单个缓冲区中提供多行和迭代的数据。在这种情况下，第<span class="italic">i</span>次迭代的数据位于<code class="codeph">buffer + (i-1) *size address</code> ，长度，指示符和返回码位于<code class="codeph">*(length + i)</code> ， <code class="codeph">*(ind + i)</code>和<code class="codeph">*(rc + i)</code>分别。
                        </p>
                        <p>此接口还适用于具有数组或<code class="codeph">OUT</code>绑定参数的数组执行和可调用语句。
                        </p>
                        <p><code class="codeph">ResultSet</code>类中提供了相同的方法来检索数据，而无需为每次提取重新分配缓冲区。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNCPP20487"></a><a id="LNCPP20488"></a><a id="LNCPP20486"></a><div class="props_rev_3"><a id="GUID-D689DB14-F381-4874-9200-8705FCA00CFC" name="GUID-D689DB14-F381-4874-9200-8705FCA00CFC"></a><h4 id="LNCPP-GUID-D689DB14-F381-4874-9200-8705FCA00CFC" class="sect4"><span class="enumeration_section">12.3.2</span>使用executeArrayUpdate（）方法</h4>
                  <div>
                     <div class="section">
                        <p>如果所有数据都是使用<code class="codeph">setDataBuffer()</code>方法或输出流提供的（也就是说，除了<code class="codeph">setDataBuffer()</code>或<code class="codeph">getStream()</code>之外没有<code class="codeph">set</code> <span class="italic">xxx（）</span>方法），那么有一种简化的迭代执行方式。
                        </p>
                        <p>在这种情况下，您不应该调用<code class="codeph">setMaxIterations()</code>和<code class="codeph">setMaxParamSize()</code> 。相反，为具有适当大小数组的每个参数调用<code class="codeph">setDataBuffer()</code>或<code class="codeph">getStream()</code>方法，以便为每次迭代提供数据，然后执行<code class="codeph">executeArrayUpdate(int</code> <code class="codeph">arrayLength)</code>方法。<code class="codeph">arrayLength</code>参数指定每个缓冲区中提供的元素数。本质上，这与将迭代次数设置为<code class="codeph">arrayLength</code>并执行语句相同。
                        </p>
                        <p>由于流参数仅指定一次，因此它们也可以与数组执行一起使用。但是，如果使用任何<code class="codeph">set</code> <span class="italic">xxx</span> <code class="codeph">()</code>方法，则<code class="codeph">addIteration()</code>方法以提供多行数据。要比较这两种方法，请考虑在<code class="codeph">employees</code>表中插入两个雇员的<a href="optimizing-performance-of-cplusplus-applications.html#GUID-D689DB14-F381-4874-9200-8705FCA00CFC__CIAEIFHJ">示例12-2</a> ：</p>
                        <p>但是，如果第一个参数也可以通过<code class="codeph">setDataBuffer()</code>接口提供，那么，您将使用<code class="codeph">executeArrayUpdate()</code>方法而不是<code class="codeph">addIteration()</code>方法，如<a href="optimizing-performance-of-cplusplus-applications.html#GUID-D689DB14-F381-4874-9200-8705FCA00CFC__CIAIGGHF">例12-3</a>所示：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-D689DB14-F381-4874-9200-8705FCA00CFC__CIAEIFHJ">
                        <p class="titleinexample">示例12-2如何使用addIteration（）方法插入记录</p><pre class="oac_no_warn" dir="ltr">Statement * stmt = conn-&gt; createStatement（“insert into departments（department_id，department_name）values（：1，：2）”）; char dnames [] [100] = {“社区外展”，“大学招聘”}; ub2 dnameLen [2]; for（int i = 0; i &lt;2; i ++）dnameLen [i] = strlen（dnames [i] + 1）; stmt-&gt; setMaxIterations（2）; //设置最大迭代次数stmt-&gt; setInt（1,7369）; //指定第一行的数据stmt-&gt; setDataBuffer（2，dnames，OCCI_SQLT_STR，sizeof（dnames [0]），dnameLen）; stmt-&gt; addIteration（）; stmt-&gt; setInt（1,7654）; //指定第二行的数据//第二个// bind参数不需要setDatBuffer，因为// setDataBuffer提供的数据只指定一次。stmt-&gt;的executeUpdate（）;</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-D689DB14-F381-4874-9200-8705FCA00CFC__CIAIGGHF">
                        <p class="titleinexample">示例12-3如何使用executeArrayUpdate（）方法插入记录</p><pre class="oac_no_warn" dir="ltr">Statement * stmt = conn-&gt; createStatement（“insert into departments（department_id，department_name）values（：1，：2）”）; char dnames [] [100] = {“社区外展”，“大学招聘”}; ub2 dnameLen [2]; for（int i = 0; i &lt;2; i ++）dnameLen [i] = strlen（dnames [i] + 1）; int ids [2] = {7369,7654}; ub2 idLen [2] = {sizeof（ids [0]），sizeof（ids [1]）}; stmt-&gt; setDataBuffer（1，ids，OCCIINT，sizeof（ids [0]），idLen）; stmt-&gt; setDataBuffer（2，dnames，OCCI_SQLT_STR，sizeof（dnames [0]），dnameLen）; stmt-&gt; executeArrayUpdate（2）; //插入了两行数据。</pre></div>
                     <!-- class="example" -->
                  </div>
               </div>
            </div><a id="LNCPP20489"></a><a id="LNCPP1204"></a><div class="props_rev_2"><a id="GUID-F6AD3A0C-7DD2-4362-8BFE-F4718D26817C" name="GUID-F6AD3A0C-7DD2-4362-8BFE-F4718D26817C"></a><h3 id="LNCPP-GUID-F6AD3A0C-7DD2-4362-8BFE-F4718D26817C" class="sect3"><span class="enumeration_section">12.4</span>使用next（）方法使用数组提取</h3>
               <div>
                  <div class="section">
                     <p>如果应用程序仅使用<code class="codeph">setDataBuffer()</code>接口或流接口获取数据，则可以执行数组提取。数组提取是通过<code class="codeph">ResultSet</code>类的<code class="codeph">next(</code> ）方法实现的。在再次调用之前，您必须处理通过next（）获得的结果。
                     </p>
                     <p>这会导致每列最多获取<span class="italic"><code class="codeph">numRows</code></span>数据量。使用<code class="codeph">setDataBuffer()</code>接口指定的缓冲区应足够大，至少可容纳数量的<span class="italic"><code class="codeph">numRows</code></span> 。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-F6AD3A0C-7DD2-4362-8BFE-F4718D26817C__GUID-4F56D45D-D0E1-4A40-BF56-949B04A764CC">
                     <p class="titleinexample">示例12-4如何对ResultSet使用Array Fetch</p><pre class="oac_no_warn" dir="ltr">ResultSet * resultSet = stmt-&gt; executeQuery（...）; resultSet-&gt; setDataBuffer（...）; while（resultSet-&gt; next（ <span class="italic">numRows</span> ）== DATA_AVAILABLE）进程（resultSet-&gt; getNumArrayRows（））;</pre></div>
                  <!-- class="example" -->
               </div>
            </div><a id="LNCPP20490"></a><a id="LNCPP1205"></a><div class="props_rev_3"><a id="GUID-B406B496-9395-4D76-899F-71E414B68FB9" name="GUID-B406B496-9395-4D76-899F-71E414B68FB9"></a><h3 id="LNCPP-GUID-B406B496-9395-4D76-899F-71E414B68FB9" class="sect3"><span class="enumeration_section">12.5</span>迭代修改行</h3>
               <div>
                  <div class="section">
                     <p>处理批次的错误，指定<code class="codeph">Statement</code>对象处于<code class="codeph">batchMode</code>使用执行的<a href="statement-class.html#GUID-EF2EE8DD-29C6-4669-BE6C-76173C5DF0A8">setBatchErrorMode（）</a>方法。设置<code class="codeph">batchMode</code>并运行批量更新后，将通过<a href="batchsqlexcept-class.html#GUID-C0D03734-0259-41A6-881A-6176820F7249">BatchSQLException类</a>报告任何结果错误。
                     </p>
                     <p><code class="codeph">BatchSQLException</code>类提供处理批错误的方法。<a href="optimizing-performance-of-cplusplus-applications.html#GUID-B406B496-9395-4D76-899F-71E414B68FB9__CHDHIIJD">例12-5</a>说明了如何在任何OCCI应用程序中实现批处理。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-B406B496-9395-4D76-899F-71E414B68FB9__CHDHIIJD">
                     <p class="titleinexample">示例12-5如何迭代地修改行并处理错误</p>
                     <ol>
                        <li>
                           <p>创建Statement对象并将其批处理错误模式设置为<code class="codeph">TRUE</code> 。</p><pre class="oac_no_warn" dir="ltr">Statement * stmt = conn-&gt; createStatement（“...”）; stmt-&gt; setBatchErrorMode（true）;</pre></li>
                        <li>
                           <p>执行应用程序所需的程序化更改。</p>
                        </li>
                        <li>
                           <p>更新声明。</p><pre class="oac_no_warn" dir="ltr">尝试{updateCount = stmt-&gt; executeUpdate（）; }</pre></li>
                        <li>
                           <p>捕获并处理批量插入或更新期间生成的任何错误。</p><pre class="oac_no_warn" dir="ltr">catch（BatchSQLException＆batchEx）{cout &lt;&lt;“Batch Exception：”&lt;&lt; batchEx.what（）&lt;&lt; endl; int errCount = batchEx.getFailedRowCount（）; cout &lt;&lt;“失败的行数”&lt;&lt; errCount &lt;endl; for（int i = 0; i &lt;errCount; i ++）{SQLException err = batchEx.getException（i）; unsigned int rowIndex = batchEx.getRowNum（i）; cout &lt;&lt;“Row”&lt;&lt; rowIndex &lt;&lt;“失败，因为”&lt;&lt; err.getErrorCode（）&lt;&lt; endl; } //对失败的行执行恢复操作}</pre></li>
                        <li>
                           <p>捕获并处理语句更新期间生成的其他错误。请注意，语句级错误仍然作为<code class="codeph">SQLException</code>实例<code class="codeph">SQLException</code> 。
                           </p><pre class="oac_no_warn" dir="ltr">catch（SQLException＆ex）//捕获其他SQLExceptions。{cout &lt;&lt;“SQLException：”&lt;&lt; e.what（）&lt;&lt; endl; }</pre></li>
                     </ol>
                  </div>
                  <!-- class="example" -->
               </div>
            </div>
            <div class="sect2"><a id="GUID-BF9AFFD6-537A-4252-BBFB-3A60EEAC3E61" name="GUID-BF9AFFD6-537A-4252-BBFB-3A60EEAC3E61"></a><h3 id="LNCPP-GUID-BF9AFFD6-537A-4252-BBFB-3A60EEAC3E61" class="sect3"><span class="enumeration_section">12.6</span>关于在Traffic Director模式下使用Oracle Connection Manager</h3>
               <div>
                  <p>Traffic Director Mode中的Oracle Connection Manager是一个放置在支持的数据库客户端和数据库实例之间的代理。</p>
                  <div class="p">Oracle Database <span class="italic">11g</span>第2版（11.2）及更高版本中支持的客户端可以在Traffic Director模式下连接到Oracle Connection Manager。流量控制器模式中的Oracle连接管理器为计划内和计划外数据库服务器中断，连接多路复用支持和负载平衡提供了改进的高可用性（HA）。以下各节将更详细地介绍对Traffic Director模式中的Oracle Connection Manager的支持<ul style="list-style-type:disc">
                        <li>
                           <p><a href="optimizing-performance-of-cplusplus-applications.html#GUID-BF9AFFD6-537A-4252-BBFB-3A60EEAC3E61__MODESOFOPERATION-4FD4C8FE">运作模式</a></p>
                        </li>
                        <li>
                           <p><a href="optimizing-performance-of-cplusplus-applications.html#GUID-BF9AFFD6-537A-4252-BBFB-3A60EEAC3E61__KEYFEATURES-4FD4D08F">主要特点</a></p>
                        </li>
                     </ul>
                  </div>
                  <div class="section" id="GUID-BF9AFFD6-537A-4252-BBFB-3A60EEAC3E61__MODESOFOPERATION-4FD4C8FE">
                     <p class="subhead2" id="GUID-BF9AFFD6-537A-4252-BBFB-3A60EEAC3E61__GUID-749BC524-93BC-42F1-B765-970605875B7F">运作模式</p>
                     <p>流量控制器模式中的Oracle连接管理器支持以下操作模式：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <div class="p">在池连接模式下，流量控制器模式中的Oracle连接管理器支持使用以下数据库客户端版本的任何应用程序：<ul style="list-style-type:disc">
                                 <li>
                                    <p>OCI，OCCI和开源驱动程序（Oracle Database <span class="italic">11g第</span> 2版（11.2.0.4）及更高版本））</p>
                                 </li>
                                 <li>
                                    <p>JDBC（Oracle Database 12c <span class="italic">第</span> 1版（12.1）及更高版本）</p>
                                 </li>
                                 <li>
                                    <p>ODP.NET（Oracle Database 12 <span class="italic">c第</span> 2版（12.2）及更高版本）</p>
                                 </li>
                              </ul>
                           </div>
                           <p>此外，应用程序必须使用DRCP。也就是说，应用程序必须在连接字符串（或<code class="codeph">tnsnames.ora</code>别名）中启用DRCP。
                           </p>
                        </li>
                        <li>
                           <p>在非池化连接（或专用）模式下，流量控制器模式中的Oracle连接管理器支持使用数据库客户机版本Oracle Database <span class="italic">11g第</span> 2版（11.2.0.4）及更高版本的任何应用程序。在此模式下，某些功能（如连接多路复用）不可用。
                           </p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
                  <div class="section" id="GUID-BF9AFFD6-537A-4252-BBFB-3A60EEAC3E61__KEYFEATURES-4FD4D08F">
                     <p class="subhead2" id="GUID-BF9AFFD6-537A-4252-BBFB-3A60EEAC3E61__GUID-3A52B2C3-D63C-4ACB-8FED-1BAFC3801338">主要特点</p>
                     <div class="p">Traffic Director Mode中的Oracle Connection Manager提供以下支持：<ul style="list-style-type:disc">
                           <li>
                              <div class="p">透明的性能增强和连接多路复用，包括：<ul style="list-style-type:disc">
                                    <li>
                                       <p>对所有操作模式自动启用语句高速缓存，行预取和结果集高速缓存。</p>
                                    </li>
                                    <li>
                                       <p>使用代理驻留连接池（PRCP）的数据库会话多路复用（仅池化模式），其中PRCP是数据库驻留连接池（DRCP）的代理模式。应用程序在Traffic Director模式下的Oracle Connection Manager与数据库之间获得透明的连接时负载平衡和运行时负载平衡。</p>
                                    </li>
                                    <li>
                                       <p>对于Traffic Director模式实例中的多个Oracle Connection Manager，应用程序通过客户端连接时间负载平衡或负载均衡器（BIG-IP，NGINX等）获得更高的可扩展性</p>
                                    </li>
                                 </ul>
                              </div>
                           </li>
                           <li>
                              <div class="p">零应用程序停机时间<ul style="list-style-type:disc">
                                    <li>
                                       <div class="p">计划数据库维护或可插拔数据库（PDB）重定位<ul style="list-style-type:disc">
                                             <li>
                                                <p>合并模式</p>
                                                <p>流量控制器模式中的Oracle Connection Manager响应Oracle Notification Service（ONS）事件以计划中断和重定向工作。请求完成后，在流量控制器模式下，Oracle Connection Manager上的池中的连接将耗尽。Oracle Database <span class="italic">11g第</span> 2版（11.2.0.4）及更高版本支持服务重定位。
                                                </p>
                                                <p>对于PDB重定位，当PDB重新定位时，流量控制器模式中的Oracle连接管理器会响应带内通知，即使未配置ONS时也是如此（对于Oracle数据库版本18c，仅限版本18.1及更高版本的服务器）</p>
                                             </li>
                                             <li>
                                                <p>非汇集或专用模式</p>
                                                <div class="p">当客户端没有请求边界信息时，流量控制器模式中的Oracle连接管理器支持许多应用程序的计划中断（只要在请求/事务边界上只需要保留简单的会话状态和游标状态）。这种支持包括：<ul style="list-style-type:disc">
                                                      <li>
                                                         <p>在事务边界处停止服务/ PDB，或者利用Oracle数据库版本18c连续应用程序可用性来停止请求边界处的服务</p>
                                                      </li>
                                                      <li>
                                                         <p>流量控制器模式中的Oracle连接管理器利用透明应用程序故障转移（TAF）故障转移还原来重新连接和还原简单状态。</p>
                                                      </li>
                                                   </ul>
                                                </div>
                                             </li>
                                          </ul>
                                       </div>
                                    </li>
                                    <li>
                                       <p>针对大多数读取工作负载的计划外数据库中断</p>
                                    </li>
                                 </ul>
                              </div>
                           </li>
                           <li>
                              <div class="p">流量控制器模式中Oracle Connection Manager的高可用性，以避免单点故障。这得到以下支持：<ul style="list-style-type:disc">
                                    <li>
                                       <p>流量控制器模式中的多个Oracle连接管理器实例，使用连接字符串中的负载平衡器或客户端负载平衡/故障转移</p>
                                    </li>
                                    <li>
                                       <p>在Traffic Director模式实例中滚动升级Oracle Connection Manager</p>
                                    </li>
                                    <li>
                                       <p>针对计划中断，在流量控制器模式下从客户端到Oracle Connection Manager的现有连接的正常关闭</p>
                                    </li>
                                    <li>
                                       <p>带有Oracle数据库版本18c及更高版本客户端的带内通知</p>
                                    </li>
                                    <li>
                                       <p>对于较旧的客户端，通知将与当前请求的响应一起发送</p>
                                    </li>
                                 </ul>
                              </div>
                           </li>
                           <li>
                              <div class="p">为了安全性和隔离性，Traffic Director Mode中的Oracle Connection Manager提供：<ul style="list-style-type:disc">
                                    <li>
                                       <p>数据库代理支持传输控制协议/传输控制协议安全（TCP / TCPS）和协议转换</p>
                                    </li>
                                    <li>
                                       <p>防火墙基于IP地址，服务名称和安全套接字层/传输层安全性（SSL / TLS）钱包</p>
                                    </li>
                                    <li>
                                       <p>多租户环境中的租户隔离</p>
                                    </li>
                                    <li>
                                       <p>防止拒绝服务和模糊测试攻击</p>
                                    </li>
                                    <li>
                                       <p>跨Oracle数据库本地和Oracle Cloud安全地隧道传输数据库流量</p>
                                    </li>
                                 </ul>
                              </div>
                           </li>
                        </ul>
                     </div>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <div class="infoboxnotealso" id="GUID-BF9AFFD6-537A-4252-BBFB-3A60EEAC3E61__GUID-A2DD3A99-8792-4704-A482-B66B30AD1B85">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>有关配置<code class="codeph">cman.ora</code>配置文件以在Traffic Director模式下设置Oracle Connection Manager的信息，请<code class="codeph">cman.ora</code> <a href="../netag/configuring-oracle-connection-manager.html#NETAG-GUID-3917FC5D-4B23-4752-85BA-39A88C4D13F8" target="_blank"><span><cite>“Oracle数据库网络服务管理员指南”</cite></span></a></p>
                           </li>
                           <li>
                              <p><a href="../netag/configuring-oracle-connection-manager.html#NETAG-GUID-58847B76-3836-41DB-9EB6-A81D5C397024" target="_blank"><span><cite>“Oracle数据库网络服务管理员指南”</cite></span></a> ，了解有关在Traffic Director模式代理身份验证中为Oracle Connection Manager配置数据库的信息</p>
                           </li>
                           <li>
                              <p><a href="../netag/configuring-oracle-connection-manager.html#NETAG-GUID-96FA23BA-F32B-4D47-9CBB-69D27E8D94F6" target="_blank"><span><cite>“Oracle数据库网络服务管理员指南”</cite></span></a> ，了解有关在流量控制器模式下为计划外停机事件配置Oracle Connection Manager的信息</p>
                           </li>
                           <li>
                              <p><a href="../netag/configuring-oracle-connection-manager.html#NETAG-GUID-E73658E7-BBF7-4C13-AAD5-70D32062AD8D" target="_blank"><span><cite>“Oracle数据库网络服务管理员指南”</cite></span></a> ，了解有关在Traffic Director模式下为计划的关闭事件配置Oracle Connection Manager的信息</p>
                           </li>
                           <li>
                              <p><a href="../netag/configuring-oracle-connection-manager.html#NETAG-GUID-15756B12-5ED5-4EDE-9D4B-6B890D5BE9AF" target="_blank"><span><cite>“Oracle数据库网络服务管理员指南”，</cite></span></a>以获取有关在流量控制器模式下配置Oracle Connection Manager使用的代理驻留连接池的信息</p>
                           </li>
                           <li>
                              <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/lncpp&amp;id=NETAG-GUID-FC833F8F-CE5A-4C02-A962-244954158853" target="_blank"><span><cite>“Oracle数据库网络服务管理员指南”</cite></span></a> ，了解有关在流量控制器模式下使用Oracle Connection Manager的所有驱动程序不支持的功能的信息</p>
                           </li>
                           <li>
                              <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/lncpp&amp;id=NETRF-GUID-668B9035-0B99-4CDF-B7D5-468B30AD7A80" target="_blank"><span><cite>Oracle Database Net Services参考</cite></span></a> ，以获取Oracle CMAN配置文件的概述</p>
                           </li>
                        </ul>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div>
            </div><a id="LNCPP20028"></a><div class="props_rev_3"><a id="GUID-5F06D230-7248-4BB0-AC4C-0BC42AC6B3AC" name="GUID-5F06D230-7248-4BB0-AC4C-0BC42AC6B3AC"></a><h3 id="LNCPP-GUID-5F06D230-7248-4BB0-AC4C-0BC42AC6B3AC" class="sect3"><span class="enumeration_section">12.7</span>关于无状态连接池的运行时负载平衡</h3>
               <div>
                  <p>无状态连接池中的运行时负载平衡动态地将连接请求路由到最少加载的数据库实例。这是通过使用服务指标实现的，服务指标由Oracle RAC负载平衡通报分发。</p>
                  <p>该功能通过以下方式修改无状态连接池：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>池会定期收到有关实例加载的通知。</p>
                     </li>
                     <li>
                        <p>收到连接请求后，池会根据实例的负载为请求类型选择最佳连接。</p>
                     </li>
                     <li>
                        <p>无状态连接池定期终止重载实例的连接，维护与实例加载相对应的连接拓扑。</p>
                     </li>
                     <li>
                        <p>由于可以终止与重载实例的连接，因此池会创建新连接以维持并发要求。这些新连接是使用Oracle RAC侦听器的连接时负载平衡创建的。</p>
                     </li>
                  </ul>
                  <p>在<code class="codeph">THREADED_MUTEXED</code>和<code class="codeph">EVENTS</code>模式下创建OCCI环境时，以及当服务器配置为发出事件通知时，默认情况下会启用运行时负载平衡。
                  </p>
                  <div class="infoboxnotealso" id="GUID-5F06D230-7248-4BB0-AC4C-0BC42AC6B3AC__GUID-14845788-AC87-4745-A21F-DFF4FD4F1AF3">
                     <p class="notep1">也可以看看：</p>
                     <p><a href="../lnoci/index.html" target="_blank"><span><cite>Oracle调用接口程序员指南</cite></span></a></p>
                  </div>
                  <p>本节包括以下主题： <a href="optimizing-performance-of-cplusplus-applications.html#GUID-7DBAD779-65CD-4AED-9A9B-C48D8D533337">API支持</a> 。
                  </p>
               </div><a id="LNCPP20491"></a><div class="props_rev_3"><a id="GUID-7DBAD779-65CD-4AED-9A9B-C48D8D533337" name="GUID-7DBAD779-65CD-4AED-9A9B-C48D8D533337"></a><h4 id="LNCPP-GUID-7DBAD779-65CD-4AED-9A9B-C48D8D533337" class="sect4"><span class="enumeration_section">12.7.1</span> API支持</h4>
                  <div>
                     <p>新<code class="codeph">NO_RLB</code>的选项<code class="codeph">PoolType</code>的属性<a href="statelessconnectionpool-class.html#GUID-C0591485-F818-4AC0-9875-ED245BDABCA6">StatelessConnectionPool类</a>禁用运行时的负载均衡。
                     </p>
                  </div>
               </div>
            </div><a id="LNCPP1206"></a><div class="props_rev_3"><a id="GUID-8ADCAB82-EBBE-43C0-BECE-4E74687A166D" name="GUID-8ADCAB82-EBBE-43C0-BECE-4E74687A166D"></a><h3 id="LNCPP-GUID-8ADCAB82-EBBE-43C0-BECE-4E74687A166D" class="sect3"><span class="enumeration_section">12.8</span>关于故障诊断</h3>
               <div>
                  <p>故障可诊断性在发生问题事件时在OCCI客户端上捕获诊断数据，例如转储文件或核心转储文件。对于每个事件，故障可诊断功能会创建一个自动诊断存储库（ADR）子目录，用于存储此诊断数据。例如，如果Linux或UNIX应用程序失败并带有空指针引用，则核心文件将显示在ADR主目录（如果存在）中，而不是在操作系统目录中。本节讨论ADR子目录结构和管理其输出的实用程序ADR命令解释器（ADRCI）。</p>
                  <p>ADR主目录是产品实例（如OCCI）和特定操作系统用户的所有诊断数据的根目录。所有ADR家庭都出现在同一个根目录ADR基础之下。</p>
                  <div class="infoboxnotealso" id="GUID-8ADCAB82-EBBE-43C0-BECE-4E74687A166D__GUID-0B2FA5EE-F101-448F-A5A3-786E12127A41">
                     <p class="notep1">也可以看看：</p>
                     <p><a href="../admin/diagnosing-and-resolving-problems.html#ADMIN11007" target="_blank"><span><cite>Oracle数据库管理员指南</cite></span></a></p>
                     <div class="p">本节包括以下主题：<ul style="list-style-type:disc">
                           <li>
                              <p><a href="optimizing-performance-of-cplusplus-applications.html#GUID-1D994784-B26E-4934-ADFE-83A997CCF3DA">使用ADR基本位置</a></p>
                           </li>
                           <li>
                              <p><a href="optimizing-performance-of-cplusplus-applications.html#GUID-15F8B697-7B7B-4583-A6C8-D74760315E2A">使用ADRCI</a></p>
                           </li>
                           <li>
                              <p><a href="optimizing-performance-of-cplusplus-applications.html#GUID-20C6A172-C450-44C0-BE4E-CE7AEF56F243">控制ADR创建和禁用故障可诊断性</a></p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="LNCPP20492"></a><div class="props_rev_3"><a id="GUID-1D994784-B26E-4934-ADFE-83A997CCF3DA" name="GUID-1D994784-B26E-4934-ADFE-83A997CCF3DA"></a><h4 id="LNCPP-GUID-1D994784-B26E-4934-ADFE-83A997CCF3DA" class="sect4"><span class="enumeration_section">12.8.1</span>使用ADR基本位置</h4>
                  <div>
                     <div class="section">
                        <p>ADR基地的位置按以下顺序确定：</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>在<code class="codeph">sqlnet.ora</code>文件中（在<span class="italic"><span class="bold">Windows上</span></span> ，在<code class="codeph">%TNS_ADMIN%</code>目录中，或在<span class="italic"><span class="bold">Linux</span></span>或<span class="italic"><span class="bold">UNIX上</span></span> ，在<code class="codeph">$TNS_ADMIN</code>目录中）。</span><div>
                              <p>如果没有<code class="codeph">TNS_ADMIN</code>目录，则<code class="codeph">sqlnet.ora</code>存储在当前目录中。
                              </p>
                              <p>如果在<code class="codeph">sqlnet.ora</code>文件中列出了ADR基础，则它是类型的语句：</p><pre class="oac_no_warn" dir="ltr">ADR_BASE = <span class="italic">/ directory / adr</span>
</pre><p>哪里：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p><span class="italic"><code class="codeph">adr</code></span>参数是一个目录，必须存在并且可由执行OCCI应用程序并希望共享相同ADR基础的所有操作系统用户写入。
                                    </p>
                                 </li>
                                 <li>
                                    <p><span class="italic"><code class="codeph">directory</code></span>参数是路径名</p>
                                 </li>
                              </ul>
                              <p>如果设置了<code class="codeph">ADR_BASE</code> ，并且所有用户共享一个<code class="codeph">sqlnet.ora</code>文件，则当目录<code class="codeph">adr</code>不存在或者它不可写时，OCCI将停止搜索。如果未设置<code class="codeph">ADR_BASE</code> ，则OCCI继续搜索，测试是否存在其他特定目录。
                              </p>
                              <p>例如，如果<code class="codeph">sqlnet.ora</code>包含条目<code class="codeph">ADR_BASE=/home/chuck/test</code>那么：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>ADR基础是：</p><pre class="oac_no_warn" dir="ltr">/家庭/夹具/测试/ oradiag_chuck</pre></li>
                                 <li>
                                    <p>ADR主页可能是：</p><pre class="oac_no_warn" dir="ltr">/家庭/夹具/测试/ oradiag_chuck /诊断/客户/ user_chuck / host_4144260688_11</pre></li>
                              </ul>
                           </div>
                        </li>
                        <li class="stepexpand"><span>如果存在Oracle基础（在<span class="italic"><span class="bold">Windows上</span></span> ： <span class="italic"><code class="codeph">%ORACLE_BASE%</code></span> ，或在<span class="italic"><span class="bold">Linux</span></span>和<span class="italic"><span class="bold">UNIX上</span></span> ： <span class="italic"><code class="codeph">$ORACLE_BASE</code></span> ），则客户端子目录也存在，因为它是在安装数据库时由Oracle Universal Installer创建的。</span><div>
                              <p>例如，如果<span class="italic"><code class="codeph">$ORACLE_BASE</code></span>是<code class="codeph">/home/chuck/obase</code> ，那么：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>ADR基础是：</p><pre class="oac_no_warn" dir="ltr">/家庭/夹头/一个obase</pre></li>
                                 <li>
                                    <p>ADR主页可能是：</p><pre class="oac_no_warn" dir="ltr">/家庭/夹头/ obase的/诊断/客户/ user_chuck / host_4144260688_11</pre></li>
                              </ul>
                           </div>
                        </li>
                        <li class="stepexpand"><span>如果Oracle主目录存在（在<span class="italic"><span class="bold">Windows上</span></span> ： <span class="italic"><code class="codeph">%ORACLE_HOME%</code></span> ，或在<span class="italic"><span class="bold">Linux</span></span>和<span class="italic"><span class="bold">UNIX上</span></span> ： <span class="italic"><code class="codeph">$ORACLE_HOME</code></span> ），则客户端子目录也存在，因为它是在安装数据库时由Oracle Universal Installer创建的。</span><div>
                              <p>例如，如果<span class="italic"><code class="codeph">$ORACLE_HOME</code></span>是<code class="codeph">/ade/chuck_l1/oracle</code> ，那么：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>ADR基础是：</p><pre class="oac_no_warn" dir="ltr">/ ADE / chuck_l1 / ORACLE /日志</pre></li>
                                 <li>
                                    <p>ADR主页可能是：</p><pre class="oac_no_warn" dir="ltr">/ ADE / chuck_l1 / ORACLE /日志/诊断/客户/ user_chuck / host_4144260688_11</pre></li>
                              </ul>
                           </div>
                        </li>
                        <li class="stepexpand"><span>在操作系统主目录中。</span><div>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>在<span class="italic"><span class="bold">Windows上</span></span> ，操作系统主目录为<span class="italic"><code class="codeph">%USERPROFILE%</code></span> 。
                                    </p>
                                    <p><code class="codeph">Oracle</code>文件夹的位置是：</p><pre class="oac_no_warn" dir="ltr">C：\ Documents and Settings \ chuck</pre><p>如果应用程序作为服务运行，则会跳过主目录选项。</p>
                                 </li>
                                 <li>
                                    <p>在<span class="italic"><span class="bold">Linux</span></span>和<span class="italic"><span class="bold">UNIX上</span></span> ，操作系统主目录是<span class="italic"><code class="codeph">$HOME</code></span> 。</p>
                                    <p>位置可能是：</p><pre class="oac_no_warn" dir="ltr">/家庭/夹头/ oradiag_chuck</pre></li>
                              </ul>
                              <p>例如，在Instant Client中，如果<span class="italic"><code class="codeph">$HOME</code></span>是<code class="codeph">/home/chuck</code> ，则：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>ADR基础是：</p><pre class="oac_no_warn" dir="ltr">/家庭/夹头/ oradiag_chuck</pre></li>
                                 <li>
                                    <p>ADR主页可能是：</p><pre class="oac_no_warn" dir="ltr">/家庭/夹头/ oradiag_chuck /诊断/客户/ user_chuck / host_4144260688_11</pre></li>
                              </ul>
                              <div class="infoboxnotealso" id="GUID-1D994784-B26E-4934-ADFE-83A997CCF3DA__GUID-7D725391-A376-4CF6-9BB0-C574EDC9FC22">
                                 <p class="notep1">也可以看看：</p>
                                 <p><span class="q">“ <a href="installation-and-upgrading.html#GUID-5556BCFD-E14D-4562-A0CE-5AFAD47AC08F">关于Instant Client</a> ”</span></p>
                              </div>
                           </div>
                        </li>
                        <li class="stepexpand"><span>在临时目录中。</span><div>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>在<span class="italic"><span class="bold">Windows上</span></span> ，按以下顺序搜索临时目录：</p>
                                    <ul style="list-style-type:disc">
                                       <li>
                                          <p><code class="codeph">％TMP％</code></p>
                                       </li>
                                       <li>
                                          <p><code class="codeph">％TEMP％</code></p>
                                       </li>
                                       <li>
                                          <p><code class="codeph">％用户资料％</code></p>
                                       </li>
                                       <li>
                                          <p>Windows系统目录</p>
                                       </li>
                                    </ul>
                                 </li>
                                 <li>
                                    <p>在<span class="italic"><span class="bold">Linux</span></span>和<span class="italic"><span class="bold">UNIX上</span></span> ，临时目录位于<code class="codeph">/var/tmp</code> 。
                                    </p>
                                 </li>
                              </ul>
                              <p>例如，在Instant Client中，如果<span class="italic"><code class="codeph">$HOME</code></span>不可写，则：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>ADR基础是：</p><pre class="oac_no_warn" dir="ltr">/ var / tmp中/ oradiag_chuck</pre></li>
                                 <li>
                                    <p>ADR主页可能是：</p><pre class="oac_no_warn" dir="ltr">/ var / tmp中/ oradiag_chuck /诊断/客户/ user_chuck / host_4144260688_11</pre></li>
                              </ul>
                           </div>
                        </li>
                     </ol>
                     <div class="section">
                        <p>如果这些目录选项都不可用且不可写，则不会创建ADR并且不会存储诊断。</p>
                        <div class="infoboxnotealso" id="GUID-1D994784-B26E-4934-ADFE-83A997CCF3DA__GUID-068B4674-3807-49CB-AB44-D36C6F44DCE6">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="../netrf/index.html" target="_blank"><span><cite>Oracle数据库网络服务参考</cite></span></a></p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNCPP20494"></a><a id="LNCPP20495"></a><a id="LNCPP20493"></a><div class="props_rev_3"><a id="GUID-15F8B697-7B7B-4583-A6C8-D74760315E2A" name="GUID-15F8B697-7B7B-4583-A6C8-D74760315E2A"></a><h4 id="LNCPP-GUID-15F8B697-7B7B-4583-A6C8-D74760315E2A" class="sect4"><span class="enumeration_section">12.8.2</span>使用ADRCI</h4>
                  <div>
                     <div class="section">
                        <p>ADRCI是一个命令行工具，使您可以在ADR中查看诊断数据，并将事件和问题信息打包到可与Oracle支持共享的zip文件中。ADRCI可以交互方式使用，也可以通过脚本使用。</p>
                        <p><span class="bold">问题</span>是OCI或客户端的严重错误。每个问题都有一个问题关键。<span class="bold">事件</span>是一次出现问题，并由唯一的数字事件ID标识。每个事件都有一个问题键，它具有一组属性： <code class="codeph">ORA</code>错误号，错误参数值和类似信息。如果问题键匹配，则两个事件具有相同的根本原因。
                        </p>
                        <p>以下示例演示了如何在Linux操作系统上使用ADRCI。请注意，ARDCI命令不区分大小写。所有用户输入均为粗体字。</p>
                        <div class="infoboxnotealso" id="GUID-15F8B697-7B7B-4583-A6C8-D74760315E2A__GUID-E3351A51-3514-47B0-9B28-2F4690F4B6E7">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><a href="../sutil/oracle-adr-command-interpreter-adrci.html#SUTIL700" target="_blank"><span><cite>Oracle数据库实用程序</cite></span></a> ，介绍ADRCI</p>
                              </li>
                              <li>
                                 <p><span class="q">“ <a href="installation-and-upgrading.html#GUID-5556BCFD-E14D-4562-A0CE-5AFAD47AC08F">关于Instant Client</a> ”</span></p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-15F8B697-7B7B-4583-A6C8-D74760315E2A__GUID-6A25581C-7456-40D0-A025-EF54C747C2EF">
                        <p class="titleinexample">例12-6如何将ADRCI用于OCCI应用程序事件</p>
                        <p>要在Linux系统中启动ADRCI，请使用<code class="codeph">adrci</code>命令。一旦ADRCI开始，找出的细节<code class="codeph">show base</code>与命令<code class="codeph">help</code> ，然后确定使用特定客户端的基础<code class="codeph">-product client</code>选项（必要OCCI应用程序）。要设置ADRCI基数，请使用set base命令。<code class="codeph">ADRCI</code>启动后，默认ADR基础用于<code class="codeph">rdbms</code>服务器。<span class="italic"><code class="codeph">$ORACLE_HOME</code></span>设置为<code class="codeph">/ade/chuck_l3/oracle</code> 。要查看事件，请使用<code class="codeph">show incidents</code>命令。要退出ADRCI，请使用<code class="codeph">quit</code>命令。
                        </p><pre class="oac_no_warn" dir="ltr">％ <span class="bold">adrci</span> ADRCI：版本11.2。 -  11月25日星期三16:16:55 2008版权所有（c）1982,2008，Oracle。版权所有。adrci&gt; <span class="bold">help show base</span>用法：SHOW BASE [-product &lt;product_name&gt;]目的：显示当前的ADR基本设置。选项：[ -  product &lt;product_name&gt;]：此选项允许用户显示给定产品的ADR Base位置。目前注册的产品是“客户”和“ADRCI”。示例：show base -product client show base adrci&gt; <span class="bold">show base -product client</span> ADR base is“/ ade / chuck_l3 / oracle / log”adrci&gt; <span class="bold">help set base</span>用法：SET BASE &lt;base_str&gt;目的：设置要使用的ADR基数目前的ADRCI会议。如果基地下有有效的ADR住宅，则所有住宅都将添加到当前的ADRCI会话中。参数：&lt;base_str&gt;：它是ADR基目录，它是一个依赖于系统的目录路径字符串。注意：在使用“。”的平台上。表示当前工作目录，它可以用作base_str。示例：set base / net / sttttd1 / scratch / someone / view_storage / someone_v1 / log set base。adrci&gt; <span class="bold">set base / ade / chuck_l3 / oracle / log</span> adrci&gt; <span class="bold">show</span> <span class="bold">events</span> ...adrci&gt; <span class="bold">退出</span></pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-15F8B697-7B7B-4583-A6C8-D74760315E2A__GUID-794139B0-25F9-4654-99E3-9E54F0D86006">
                        <p class="titleinexample">示例12-7如何使用ADRCI for Instant Client</p>
                        <p>由于Instant Client不使用<span class="italic"><code class="codeph">$ORACLE_HOME</code></span> ，因此默认ADR基础是用户的主目录。
                        </p><pre class="oac_no_warn" dir="ltr">adrci&gt; <span class="bold">show base -product client</span> ADR base is“/ home / chuck / oradiag_chuck”adrci&gt; <span class="bold">set base / home / chuck / oradiag_chuck</span> adrci&gt; <span class="bold">show</span> <span class="bold">events</span> ADR Home = / home / chuck / oradiag_chuck / diag / clients / user_chuck / host_4144260688_11： ************************************************** *********************** INCIDENT_ID PROBLEM_KEY CREATE_TIME ------------------------ ------------------------------------------------- 1 oci 24550 [6] 2007-05-01 17：20：02.803697 -07：00 1行取出adrci&gt; <span class="bold">退出</span></pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="LNCPP20496"></a><div class="props_rev_3"><a id="GUID-20C6A172-C450-44C0-BE4E-CE7AEF56F243" name="GUID-20C6A172-C450-44C0-BE4E-CE7AEF56F243"></a><h4 id="LNCPP-GUID-20C6A172-C450-44C0-BE4E-CE7AEF56F243" class="sect4"><span class="enumeration_section">12.8.3</span>控制ADR创建和禁用故障诊断</h4>
                  <div>
                     <div class="section">
                        <p>要禁用故障可诊断功能，必须关闭诊断捕获。通过将<code class="codeph">DIAG_ADR_ENABLED</code>和<code class="codeph">DIAG_DDE_ENABLED</code>参数的值更改为<code class="codeph">FALSE</code>或<code class="codeph">OFF</code>来编辑<code class="codeph">sqlnet.ora</code>文件;默认值为<code class="codeph">TRUE</code>或<code class="codeph">ON</code> 。</p>
                        <p>要关闭OCCI信号处理程序并重新启用标准操作系统故障处理，请通过添加相应参数来编辑<code class="codeph">sqlnet.ora</code>文件： <code class="codeph">DIAG_SIGHANDLER_ENABLED=FALSE</code> 。</p>
                        <div class="infoboxnotealso" id="GUID-20C6A172-C450-44C0-BE4E-CE7AEF56F243__GUID-62806A91-EF36-40C9-85F7-F74B42829BA5">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/lncpp&amp;id=LNOCI-GUID-E100960D-1E4F-4C3D-A6A3-0D5A5FB06B4C" target="_blank"><span><cite>Oracle调用接口程序员指南</cite></span></a></p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="LNCPP21897"></a><a id="LNCPP21896"></a><div class="props_rev_3"><a id="GUID-740894FB-9DAE-4F98-BA70-0C4E04479200" name="GUID-740894FB-9DAE-4F98-BA70-0C4E04479200"></a><h3 id="LNCPP-GUID-740894FB-9DAE-4F98-BA70-0C4E04479200" class="sect3"><span class="enumeration_section">12.9</span>使用客户端结果缓存</h3>
               <div>
                  <div class="section">
                     <p>客户端结果缓存可以改善重复执行的查询的响应时间。此功能使用客户端内存来缓存从数据库执行和提取的SQL查询的结果。后续执行同一查询将从客户端缓存中获取结果，从而降低服务器CPU使用率。由于消除了数据库往返，因此应用程序可以缩短响应时间。</p>
                     <p>OCCI应用程序可以通过启用OCCI语句缓存来透明地使用客户端结果缓存功能。请注意，必须缓存的<code class="codeph">SELECT</code>查询使用<code class="codeph">/*+ result_cache */</code> hint进行注释。<a href="optimizing-performance-of-cplusplus-applications.html#GUID-740894FB-9DAE-4F98-BA70-0C4E04479200__CIADDJCA">例12-8</a>显示了如何创建使用这种<code class="codeph">SELECT</code>查询的OCCI Statement对象。
                     </p>
                     <p>有关使用指南，缓存一致性和限制，请参阅<a href="../lnoci/performance-topics.html#LNOCI10103" target="_blank"><span><cite>Oracle Call Interface Programmer's Guide</cite></span></a> 。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-740894FB-9DAE-4F98-BA70-0C4E04479200__CIADDJCA">
                     <p class="titleinexample">示例12-8如何启用和使用客户端结果缓存</p><pre class="oac_no_warn" dir="ltr">连接*连接;声明* stmt; ResultSet * rs; ...//启用OCCI语句缓存conn-&gt; setStmtCacheSize（20）; //在SELECT查询中指定提示stmt = conn-&gt; createStatement（“select / * + result_cache * / * from products \ where product_id =：1”）; //如果//缓存了查询结果，则以下execute从客户端缓存中获取行。如果这是查询的第一个执行//，则从服务器获取的结果将缓存在客户端。rs = stmt-&gt; executeQuery（）;</pre></div>
                  <!-- class="example" -->
               </div>
            </div><a id="LNCPP78967"></a><div class="props_rev_3"><a id="GUID-E8DD631B-9AFF-49F5-BFBA-ED55001DB052" name="GUID-E8DD631B-9AFF-49F5-BFBA-ED55001DB052"></a><h3 id="LNCPP-GUID-E8DD631B-9AFF-49F5-BFBA-ED55001DB052" class="sect3"><span class="enumeration_section">12.10</span>关于客户端部署参数和自动调整</h3>
               <div>
                  <p>从Oracle Database Release 12 <span class="italic">c</span>第1版（12.1）开始，Oracle提供了<code class="codeph">oraaccess.xml</code> ，这是一个客户端配置文件，可用于配置所选属性，允许在部署期间更改应用程序行为，而无需修改源代码。
                  </p>
                  <div class="infoboxnote" id="GUID-E8DD631B-9AFF-49F5-BFBA-ED55001DB052__GUID-40C288AE-8E23-4CC1-B185-6B79C6745052">
                     <p class="notep1">注意：</p>
                     <p>如果OCCI应用程序已在使用<code class="codeph">setPrefetchRowCount()</code>或<code class="codeph">setPrefetchMemorySize()</code>方法，请不要使用prefetch部署参数。
                     </p>
                  </div>
                  <div class="infoboxnote" id="GUID-E8DD631B-9AFF-49F5-BFBA-ED55001DB052__GUID-A0EC8D27-7D85-4E91-BB2E-C3BD9FAB5EBD">
                     <p class="notep1">看到：</p>
                     <p>有关客户端部署参数和自动调整的更多信息，请参阅<a href="../lnoci/index.html" target="_blank"><span><cite>“Oracle调用接口程序员指南”</cite></span></a></p>
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>