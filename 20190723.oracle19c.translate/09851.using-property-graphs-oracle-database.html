<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <meta name="abstract" content="This chapter provides conceptual and usage information about creating, storing, and working with property graph data in an Oracle Database environment."></meta>
      <meta name="description" content="This chapter provides conceptual and usage information about creating, storing, and working with property graph data in an Oracle Database environment."></meta>
      <title>在Oracle数据库环境中使用属性图</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Property Graph Developer’s Guide"></meta>
      <meta property="og:description" content="This chapter provides conceptual and usage information about creating, storing, and working with property graph data in an Oracle Database environment."></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Property Graph Developer’s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="spatial-and-graph-property-graph-developers-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-10T15:23:57-08:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="2016, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E94800-01"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="property-graph-overview-spgdg.html" title="Previous" type="text/html"></link>
      <link rel="next" href="using-inmemory-analyst-oracle-database.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Spatial and Graph Property Graph Developer&#39;s Guide"></meta>
    <meta name="dcterms.isVersionOf" content="SPGDG"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="property-graph-overview-spgdg.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="using-inmemory-analyst-oracle-database.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">Property Graph开发人员指南</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">在Oracle数据库环境中使用属性图</li>
            </ol>
            <a id="GUID-4B5AF258-79BE-418D-84FF-9B8A692B8604" name="GUID-4B5AF258-79BE-418D-84FF-9B8A692B8604"></a><a id="BDSPA191"></a>
            
            <h2 id="SPGDG-GUID-4B5AF258-79BE-418D-84FF-9B8A692B8604" class="sect2"><span class="enumeration_chapter">2</span>在Oracle数据库环境中使用属性图</h2>
         </header>
         <div class="ind">
            <div>
               <p>本章提供有关在Oracle数据库环境中创建，存储和使用属性图数据的概念和用法信息。</p>
            </div>
            <div>
               <ul class="ullinks">
                  <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-E4951F06-3B5F-4B82-8B23-7D4F629DE808">关于Property Graphs</a><br>属性图允许将属性（键值对）与图形顶点和边缘轻松关联，并且它们可以基于大量数据集之间的关系启用分析操作。
                  </li>
                  <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-B6C28C47-656F-4193-B70E-D6EC555F9D24">关于Property Graph数据格式</a><br>属性图数据支持多种图形格式。
                  </li>
                  <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-728A5FBC-998C-4675-9C0A-31C9195B737D">Oracle数据库的属性图架构对象</a><br>属性图PL / SQL和Java API使用特殊的Oracle数据库模式对象。
                  </li>
                  <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-E754CCD1-FB01-4644-A028-FEEA0ED683ED">属性图入门</a><br>按照以下步骤开始使用属性图。
                  </li>
                  <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-734D16D3-E8AA-4097-B644-14D80A4C7958">使用Java API获取属性图数据</a><br>创建属性图涉及使用Java API在其中创建属性图和对象。
                  </li>
                  <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-72E0D670-D477-4C0F-914C-8E70E45F9692">管理属性图数据的文本索引</a><br>Oracle Spatial and Graph属性图支持中的索引允许通过特定键/值或键/文本对快速检索元素。这些索引是基于元素类型（顶点或边），一组键（和值）和索引类型创建的。
                  </li>
                  <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-5E5587AB-52F0-4C69-9C4B-6EC667620BB7">属性图数据的访问控制（图级和OLS）</a><br>Oracle Spatial and Graph中的属性图功能支持两种访问控制和安全模型：图级访问控制，以及通过与Oracle Label Security（OLS）集成的细粒度安全性。
                  </li>
                  <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-DFCC2E13-5548-4DAC-B0DE-E4CEF13E97C7">将Groovy Shell与Property Graph数据一起使用</a><br>Oracle Spatial and Graph属性图支持包括一个内置的Groovy shell（基于原始的Gremlin Groovy shell脚本）。使用此命令行shell界面，您可以浏览Java API。</li>
                  <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-BDA846D6-DA18-4049-91DF-E96BEAB02B6D">在Oracle数据库中使用内存分析器Zeppelin Interpreter</a><br>内存分析师为Apache Zeppelin提供了一个解释器实现。本教程主题介绍如何将内存分析器解释器安装到本地Zeppelin安装中并执行一些简单的操作。
                  </li>
                  <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-D0904048-83F2-48AE-9B23-675D3F934BD9">REST支持Oracle数据库属性图数据</a><br>一组RESTful API通过HTTP / REST协议公开数据访问层Java API。
                  </li>
                  <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-24C684A5-8A18-45F3-9F0D-A8F7CCF964BE">在RDF图上创建属性图视图</a><br>使用Oracle Spatial and Graph，您可以将RDF数据视为属性图，以通过在Oracle数据库中存储的RDF图上创建属性图视图来执行图分析操作。
                  </li>
                  <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-7A2037E1-2DB7-40A2-AA37-0A91D0E34D00">使用双表模式处理属性图</a><br>对于具有相对固定，简单数据结构的属性图，您不需要灵活的<code class="codeph">&lt;graph_name&gt;VT$</code>和<code class="codeph">&lt;graph_name&gt;GE$</code>键/值数据表的顶点和边，您可以使用两表模式来实现更好的运行时性能。
                  </li>
                  <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-7FC09376-F237-41E8-B0FE-9D1044A59FBB">Oracle平面文件格式定义</a><br>可以在两个平面文件中定义属性图，特别是顶点和边的描述文件。
                  </li>
                  <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-1946BFA3-8995-4EE5-8E39-FE1C58391EAD">示例Python用户界面</a><br><code class="codeph">$ORACLE_HOME/md/property_graph/pyopg/</code>的示例Python脚本可以与Oracle Spatial and Graph Property Graph一起使用，您可能希望更改和增强它们（或它们的副本）以满足您的需要。
                  </li>
               </ul>
            </div>
            
            <div class="props_rev_3"><a id="GUID-E4951F06-3B5F-4B82-8B23-7D4F629DE808" name="GUID-E4951F06-3B5F-4B82-8B23-7D4F629DE808"></a><h3 id="SPGDG-GUID-E4951F06-3B5F-4B82-8B23-7D4F629DE808" class="sect3"><span class="enumeration_section">2.1</span>关于属性图</h3>
               <div>
                  <p>属性图允许将属性（键值对）与图形顶点和边缘轻松关联，并且它们可以基于大量数据集之间的关系启用分析操作。</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-9BA44355-E97D-4E7A-81AA-269873E506B2">什么是属性图？</a><br></li>
                     <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-D76CD113-5B02-417A-A91A-7063BC395C08">什么是Oracle数据库支持属性图？</a><br></li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="using-property-graphs-oracle-database.html#GUID-4B5AF258-79BE-418D-84FF-9B8A692B8604" title="本章提供有关在Oracle数据库环境中创建，存储和使用属性图数据的概念和用法信息。">在Oracle数据库环境中使用属性图</a></p>
                     </div>
                  </div>
               </div>
               
               <div class="props_rev_3"><a id="GUID-9BA44355-E97D-4E7A-81AA-269873E506B2" name="GUID-9BA44355-E97D-4E7A-81AA-269873E506B2"></a><h4 id="SPGDG-GUID-9BA44355-E97D-4E7A-81AA-269873E506B2" class="sect4"><span class="enumeration_section">2.1.1</span>什么是属性图？
                  </h4>
                  <div>
                     <p>属性图由一组对象或<span class="bold">顶点</span>以及一组连接对象的箭头或<span class="bold">边组成</span> 。顶点和边可以具有多个属性，这些属性表示为键值对。
                     </p>
                     <p>每个顶点都有一个唯一的标识符，可以有：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>一组外发边缘</p>
                        </li>
                        <li>
                           <p>一组传入边缘</p>
                        </li>
                        <li>
                           <p>一组属性</p>
                        </li>
                     </ul>
                     <p>每条边都有一个唯一的标识符，可以有：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>一个传出的顶点</p>
                        </li>
                        <li>
                           <p>传入的顶点</p>
                        </li>
                        <li>
                           <p>描述两个顶点之间关系的文本标签</p>
                        </li>
                        <li>
                           <p>一组属性</p>
                        </li>
                     </ul>
                     <p>下图说明了一个包含两个顶点和一个边的非常简单的属性图。两个顶点具有标识符1和2。两个顶点都具有属性<code class="codeph">name</code>和<code class="codeph">age</code> 。边缘从输出顶点1到输入顶点2。边缘具有文本标签<code class="codeph">knows</code>和标识顶点1和2之间的关系类型的属性<code class="codeph">type</code> 。
                     </p>
                     <div class="figure" id="GUID-9BA44355-E97D-4E7A-81AA-269873E506B2__BHBBGAGE">
                        <p class="titleinfigure">图2-1简单属性图示例</p><img src="img/two_vertices.png" alt="下面描述图2-1" title="下面描述图2-1" longdesc="img_text/two_vertices.html"><br><a href="img_text/two_vertices.html">“图2-1简单属性图示例”的说明</a></div>
                     <!-- class="figure" -->
                     <p>标准不适用于大数据空间和图形属性图数据模型，但它类似于基于W3C标准的资源描述框架（RDF）图数据模型。属性图数据模型比RDF更简单且更不精确。这些差异使它成为这些用例的良好候选者：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>识别社交网络中的影响者</p>
                        </li>
                        <li>
                           <p>预测趋势和客户行为</p>
                        </li>
                        <li>
                           <p>基于模式匹配发现关系</p>
                        </li>
                        <li>
                           <p>识别群集以自定义广告系列</p>
                        </li>
                     </ul>
                     <div class="infoboxnote" id="GUID-9BA44355-E97D-4E7A-81AA-269873E506B2__THEPROPERTYGRAPHDATAMODELTHATORACLE-3AC6C8FA">
                        <p class="notep1">注意：</p>
                        <p>Oracle在数据库端支持的属性图数据模型不允许顶点标签。但是，您可以将指定顶点属性的值视为一个或多个标签。</p>
                     </div>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="using-property-graphs-oracle-database.html#GUID-DCDC3B41-4679-4525-A3E1-44BF8C86187C">指定顶点的标签</a></li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="using-property-graphs-oracle-database.html#GUID-E4951F06-3B5F-4B82-8B23-7D4F629DE808" title="属性图允许将属性（键值对）与图形顶点和边缘轻松关联，并且它们可以基于大量数据集之间的关系启用分析操作。">关于属性图</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="props_rev_3"><a id="GUID-D76CD113-5B02-417A-A91A-7063BC395C08" name="GUID-D76CD113-5B02-417A-A91A-7063BC395C08"></a><h4 id="SPGDG-GUID-D76CD113-5B02-417A-A91A-7063BC395C08" class="sect4"><span class="enumeration_section">2.1.2</span>什么是Oracle数据库支持属性图？
                  </h4>
                  <div>
                     <p>除了支持Hadoop中的大数据外，Oracle数据库还支持属性图。此支持包括一组PL / SQL包，数据访问层和分析层。</p>
                     <p>下图提供了Oracle属性图体系结构的概述。</p>
                     <div class="figure" id="GUID-D76CD113-5B02-417A-A91A-7063BC395C08__BHBDDCAI">
                        <p class="titleinfigure">图2-2 Oracle Property Graph Architecture</p><img src="img/pg_architecture_db.jpg" alt="下面是图2-2的描述" title="下面是图2-2的描述" longdesc="img_text/pg_architecture_db.html"><br><a href="img_text/pg_architecture_db.html">“图2-2 Oracle Property Graph Architecture”的描述</a></div>
                     <!-- class="figure" -->
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-EA9A6C3D-0946-41A5-BB79-A5118BF5AA1D">内存分析师</a><br></li>
                        <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-69E5D72E-2EA2-4B6E-B52E-C397F820355A">数据访问层</a><br></li>
                        <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-F0741F29-0FE0-472F-886A-096B5FC17E1C">存储管理</a><br></li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="using-property-graphs-oracle-database.html#GUID-E4951F06-3B5F-4B82-8B23-7D4F629DE808" title="属性图允许将属性（键值对）与图形顶点和边缘轻松关联，并且它们可以基于大量数据集之间的关系启用分析操作。">关于属性图</a></p>
                        </div>
                     </div>
                  </div>
                  
                  <div class="props_rev_3"><a id="GUID-EA9A6C3D-0946-41A5-BB79-A5118BF5AA1D" name="GUID-EA9A6C3D-0946-41A5-BB79-A5118BF5AA1D"></a><h5 id="SPGDG-GUID-EA9A6C3D-0946-41A5-BB79-A5118BF5AA1D" class="sect5"><span class="enumeration_section">2.1.2.1</span>内存分析师</h5>
                     <div>
                        <p>内存分析器层使您可以使用并行内存执行来分析属性图。它提供超过35种分析功能，包括路径计算，排名，社区检测和建议。</p>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="using-property-graphs-oracle-database.html#GUID-D76CD113-5B02-417A-A91A-7063BC395C08">Oracle数据库对属性图的支持是什么？</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
                  <div class="props_rev_3"><a id="GUID-69E5D72E-2EA2-4B6E-B52E-C397F820355A" name="GUID-69E5D72E-2EA2-4B6E-B52E-C397F820355A"></a><h5 id="SPGDG-GUID-69E5D72E-2EA2-4B6E-B52E-C397F820355A" class="sect5"><span class="enumeration_section">2.1.2.2</span>数据访问层</h5>
                     <div>
                        <p>数据访问层提供了一组Java API，您可以使用这些API创建和删除属性图，添加和删除顶点和边，使用键值对搜索顶点和边，创建文本索引以及执行其他操作。Java API包括属性图数据模型的TinkerPop Blueprints图接口的实现。Java和PL / SQL API还与Apache Lucene和Apache SolrCloud集成，后者是广泛采用的开源文本索引和搜索引擎。（必须单独下载和配置Apache SolrCloud，如<a href="property-graph-overview-spgdg.html#GUID-FF149F69-574D-43B8-B888-4CCD019DAE56" title="虽然不需要特殊的配置操作，但使用属性图功能的要求如下。">Property Graph Prerequisites中所述</a> ）。
                        </p>
                        <p>有关更多信息，请参阅：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="using-property-graphs-oracle-database.html#GUID-72E0D670-D477-4C0F-914C-8E70E45F9692" title="Oracle Spatial and Graph属性图支持中的索引允许通过特定键/值或键/文本对快速检索元素。这些索引是基于元素类型（顶点或边），一组键（和值）和索引类型创建的。">管理属性图数据的文本索引</a></p>
                           </li>
                           <li>
                              <p><a href="using-property-graphs-oracle-database.html#GUID-734D16D3-E8AA-4097-B644-14D80A4C7958" title="创建属性图涉及使用Java API在其中创建属性图和对象。">使用Java API获取属性图数据</a></p>
                           </li>
                           <li>
                              <p><a href="using-property-graphs-oracle-database.html#GUID-728A5FBC-998C-4675-9C0A-31C9195B737D" title="属性图PL / SQL和Java API使用特殊的Oracle数据库模式对象。">Oracle数据库的属性图架构对象</a> （PL / SQL和Java API）和<a href="OPG_APIS-reference.html#GUID-A5F629F8-D086-4E7F-8ECF-6094982E7A05" title="OPG_APIS包中包含用于处理Oracle数据库中的属性图的子程序（函数和过程）。">OPG_APIS包子程序</a> （PL / SQL API）。
                              </p>
                           </li>
                        </ul>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="using-property-graphs-oracle-database.html#GUID-D76CD113-5B02-417A-A91A-7063BC395C08">Oracle数据库对属性图的支持是什么？</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
                  <div class="props_rev_3"><a id="GUID-F0741F29-0FE0-472F-886A-096B5FC17E1C" name="GUID-F0741F29-0FE0-472F-886A-096B5FC17E1C"></a><h5 id="SPGDG-GUID-F0741F29-0FE0-472F-886A-096B5FC17E1C" class="sect5"><span class="enumeration_section">2.1.2.3</span>存储管理</h5>
                     <div>
                        <p>属性图存储在Oracle数据库中。表在内部用于建模属性图的顶点和边。</p>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="using-property-graphs-oracle-database.html#GUID-D76CD113-5B02-417A-A91A-7063BC395C08">Oracle数据库对属性图的支持是什么？</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div>
            </div>
            <div class="props_rev_3"><a id="GUID-B6C28C47-656F-4193-B70E-D6EC555F9D24" name="GUID-B6C28C47-656F-4193-B70E-D6EC555F9D24"></a><h3 id="SPGDG-GUID-B6C28C47-656F-4193-B70E-D6EC555F9D24" class="sect3"><span class="enumeration_section">2.2</span>关于属性图数据格式</h3>
               <div>
                  <p>属性图数据支持多种图形格式。</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-D85BDA74-F0E3-4590-874E-DEBFD95CE30B">GraphML数据格式</a><br></li>
                     <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-8F01B553-22F0-429E-9018-A1C6F3655508">GraphSON数据格式</a><br></li>
                     <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-B6EB163B-C03F-4720-B57F-78ADEB657B13">GML数据格式</a><br></li>
                     <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-15A4AE0C-2AF6-459B-A3D5-432434ECAD70">Oracle平面文件格式</a><br></li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="using-property-graphs-oracle-database.html#GUID-4B5AF258-79BE-418D-84FF-9B8A692B8604" title="本章提供有关在Oracle数据库环境中创建，存储和使用属性图数据的概念和用法信息。">在Oracle数据库环境中使用属性图</a></p>
                     </div>
                  </div>
               </div>
               
               <div class="props_rev_3"><a id="GUID-D85BDA74-F0E3-4590-874E-DEBFD95CE30B" name="GUID-D85BDA74-F0E3-4590-874E-DEBFD95CE30B"></a><h4 id="SPGDG-GUID-D85BDA74-F0E3-4590-874E-DEBFD95CE30B" class="sect4"><span class="enumeration_section">2.2.1</span> GraphML数据格式</h4>
                  <div>
                     <p>GraphML文件格式使用XML来描述图形。本主题中的示例显示了<a href="using-property-graphs-oracle-database.html#GUID-9BA44355-E97D-4E7A-81AA-269873E506B2">什么是</a>属性图中显示的属性图的GraphML描述<a href="using-property-graphs-oracle-database.html#GUID-9BA44355-E97D-4E7A-81AA-269873E506B2">？</a> 。
                     </p>
                     <div class="example" id="GUID-D85BDA74-F0E3-4590-874E-DEBFD95CE30B__BHBJAHIE">
                        <p class="titleinexample">示例2-1简单属性图的GraphML描述</p><pre class="oac_no_warn" dir="ltr">&lt;？xml version =“1.0”encoding =“UTF-8”？&gt; &lt;graphml xmlns =“http://graphml.graphdrawing.org/xmlns”&gt; &lt;key id =“name”for =“node”attr.name =“name”attr.type =“string”/&gt; &lt;key id =“age”for =“node”attr.name =“age”attr.type =“int”/&gt; &lt;key id =“type”for =“edge”attr.name =“type”attr.type =“string “/&gt; &lt;graph id =”PG“edgedefault =”directed“&gt; &lt;node id =”1“&gt; &lt;data key =”name“&gt; Alice &lt;/ data&gt; &lt;data key =”age“&gt; 31 &lt;/ data&gt; &lt;/ node&gt; &lt;node id =“2”&gt; &lt;data key =“name”&gt; Bob &lt;/ data&gt; &lt;data key =“age”&gt; 27 &lt;/ data&gt; &lt;/ node&gt; &lt;edge id =“3”source =“1”target =“2”label =“knows”&gt; &lt;data key =“type”&gt;朋友&lt;/ data&gt; &lt;/ edge&gt; &lt;/ graph&gt; &lt;/ graphml&gt;</pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="http://graphml.graphdrawing.org/" target="_blank">GraphML文件格式</a></li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="using-property-graphs-oracle-database.html#GUID-B6C28C47-656F-4193-B70E-D6EC555F9D24" title="属性图数据支持多种图形格式。">关于属性图数据格式</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="props_rev_3"><a id="GUID-8F01B553-22F0-429E-9018-A1C6F3655508" name="GUID-8F01B553-22F0-429E-9018-A1C6F3655508"></a><h4 id="SPGDG-GUID-8F01B553-22F0-429E-9018-A1C6F3655508" class="sect4"><span class="enumeration_section">2.2.2</span> GraphSON数据格式</h4>
                  <div>
                     <p>GraphSON文件格式基于JavaScript Object Notation（JSON）来描述图形。本主题中的示例显示了<a href="using-property-graphs-oracle-database.html#GUID-9BA44355-E97D-4E7A-81AA-269873E506B2">什么是</a>属性图中显示的属性图的GraphSON描述<a href="using-property-graphs-oracle-database.html#GUID-9BA44355-E97D-4E7A-81AA-269873E506B2">？</a> 。
                     </p>
                     <div class="example" id="GUID-8F01B553-22F0-429E-9018-A1C6F3655508__BHBHABBB">
                        <p class="titleinexample">示例2-2简单属性图的GraphSON描述</p><pre class="oac_no_warn" dir="ltr">{“graph”：{“mode”：“NORMAL”，“vertices”：[{“name”：“Alice”，“age”：31，“_ id”：“1”，“_ type”：“vertex”} ，{“name”：“Bob”，“age”：27，“_ id”：“2”，“_ type”：“vertex”}]，“edges”：[{“type”：“friends”，“_ id “：”3“，”_ type“：”edge“，”_ outV“：”1“，”_ inV“：”2“，”_ label“：”know“}]}}</pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="https://github.com/tinkerpop/blueprints/wiki/GraphSON-Reader-and-Writer-Library" target="_blank">GraphSON读者和作家库</a></li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="using-property-graphs-oracle-database.html#GUID-B6C28C47-656F-4193-B70E-D6EC555F9D24" title="属性图数据支持多种图形格式。">关于属性图数据格式</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="props_rev_3"><a id="GUID-B6EB163B-C03F-4720-B57F-78ADEB657B13" name="GUID-B6EB163B-C03F-4720-B57F-78ADEB657B13"></a><h4 id="SPGDG-GUID-B6EB163B-C03F-4720-B57F-78ADEB657B13" class="sect4"><span class="enumeration_section">2.2.3</span> GML数据格式</h4>
                  <div>
                     <p>图形建模语言（GML）文件格式使用ASCII来描述图形。本主题中的示例显示了<a href="using-property-graphs-oracle-database.html#GUID-9BA44355-E97D-4E7A-81AA-269873E506B2">什么是</a>属性图中显示的属性图的GML描述<a href="using-property-graphs-oracle-database.html#GUID-9BA44355-E97D-4E7A-81AA-269873E506B2">？</a> 。
                     </p>
                     <div class="example" id="GUID-B6EB163B-C03F-4720-B57F-78ADEB657B13__BHBDFBBB">
                        <p class="titleinexample">示例2-3简单属性图的GML描述</p><pre class="oac_no_warn" dir="ltr">graph [注释“简单属性图”指示1 IsPlanar 1节点[id 1标签“1”名称“Alice”年龄31]节点[id 2标签“2”名称“Bob”年龄27] edge [source 1 target 2 label“知道“打字”的朋友“]]</pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="http://www.fim.uni-passau.de/fileadmin/files/lehrstuhl/brandenburg/projekte/gml/gml-technical-report.pdf" target="_blank">GML：可移植图形文件格式“作者：Michael Himsolt</a></li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="using-property-graphs-oracle-database.html#GUID-B6C28C47-656F-4193-B70E-D6EC555F9D24" title="属性图数据支持多种图形格式。">关于属性图数据格式</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="props_rev_3"><a id="GUID-15A4AE0C-2AF6-459B-A3D5-432434ECAD70" name="GUID-15A4AE0C-2AF6-459B-A3D5-432434ECAD70"></a><h4 id="SPGDG-GUID-15A4AE0C-2AF6-459B-A3D5-432434ECAD70" class="sect4"><span class="enumeration_section">2.2.4</span> Oracle平面文件格式</h4>
                  <div>
                     <p>Oracle平面文件格式专门描述属性图。它比其他文件格式更简洁，提供更好的数据类型支持。Oracle平面文件格式使用两个文件进行图形描述，一个用于顶点，一个用于边缘。逗号分隔记录的字段。</p>
                     <div class="example" id="GUID-15A4AE0C-2AF6-459B-A3D5-432434ECAD70__ORACLEFLATFILEDESCRIPTIONOFASIMPLEP-1152EB16">
                        <p class="titleinexample">示例2-4简单属性图的Oracle Flat File描述</p>
                        <p>下面显示了Oracle平面文件，它们描述了<a href="using-property-graphs-oracle-database.html#GUID-9BA44355-E97D-4E7A-81AA-269873E506B2">什么是属性图中</a>显示的简单属性图示例<a href="using-property-graphs-oracle-database.html#GUID-9BA44355-E97D-4E7A-81AA-269873E506B2">？</a> 。
                        </p>
                        <p><span class="bold">顶点文件：</span></p><pre class="oac_no_warn" dir="ltr">1，姓名，1，Alice ,, 1岁，2岁，31岁，2岁，姓名，1岁，Bob ,, 2岁，年龄2岁，27岁，</pre><p><span class="bold">边缘文件：</span></p><pre class="oac_no_warn" dir="ltr">1,1,2，知道，类型，1，朋友,,</pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="using-property-graphs-oracle-database.html#GUID-7FC09376-F237-41E8-B0FE-9D1044A59FBB" title="可以在两个平面文件中定义属性图，特别是顶点和边的描述文件。">Oracle平面文件格式定义</a></li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="using-property-graphs-oracle-database.html#GUID-B6C28C47-656F-4193-B70E-D6EC555F9D24" title="属性图数据支持多种图形格式。">关于属性图数据格式</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div>
            <div class="props_rev_3"><a id="GUID-728A5FBC-998C-4675-9C0A-31C9195B737D" name="GUID-728A5FBC-998C-4675-9C0A-31C9195B737D"></a><h3 id="SPGDG-GUID-728A5FBC-998C-4675-9C0A-31C9195B737D" class="sect3"><span class="enumeration_section">2.3</span> Oracle数据库的属性图架构对象</h3>
               <div>
                  <p>属性图PL / SQL和Java API使用特殊的Oracle数据库模式对象。</p>
                  <p>本主题描述与使用图形数据的属性图模式方法相关的对象。这是一种比使用双表模式<a href="using-property-graphs-oracle-database.html#GUID-7A2037E1-2DB7-40A2-AA37-0A91D0E34D00" title="For property graphs with relatively fixed, simple data structures, where you do not need the flexibility of &lt;graph_name&gt;VT$ and &lt;graph_name&gt;GE$ key/value data tables for vertices and edges, you can use a two-tables schema to achieve better run-time performance.">处理属性图</a>所描述的双表模式方法更灵活的方法，该<a href="using-property-graphs-oracle-database.html#GUID-7A2037E1-2DB7-40A2-AA37-0A91D0E34D00" title="对于具有相对固定，简单数据结构的属性图，您不需要灵活的&lt;graph_name&gt; VT $和&lt;graph_name&gt; GE $键/值数据表的顶点和边，您可以使用两表模式来实现更好的运行时性能。">模式</a>具有局限性。
                  </p>
                  <p>Oracle Spatial and Graph允许您在Oracle数据库中存储，查询，操作和查询属性图数据。例如，要创建名为myGraph的属性图，可以使用Java API（ <code class="codeph">oracle.pg.rdbms.OraclePropertyGraph</code> ）或PL / SQL API（MDSYS.OPG_APIS包）。
                  </p>
                  <div class="infoboxnote" id="GUID-728A5FBC-998C-4675-9C0A-31C9195B737D__GUID-E3923CB1-F855-41BE-B46A-DEE431974A4B">
                     <p class="notep1">注意：</p>
                     <p>如果使用属性图架构，则需要Oracle分区许可证。为了提高性能和可伸缩性，VT $和GE $表都根据ID进行散列分区，并且可以自定义分区数。分区数应为2的幂（2,4,8,16等）。分区从“p1”开始按顺序命名，因此对于使用8个分区创建的属性图，分区集将为“p1”，“p2”，...，“p8”。</p>
                  </div>
                  <p>使用PL / SQL API：</p><pre class="pre codeblock"><code>BEGIN opg_apis.create_pg（'myGraph'，dop =&gt; 4， - 并行度num_hash_ptns =&gt; 8， - 用于存储图形的散列分区数tbs =&gt;'USERS'， -  tablespace options =&gt;'COMPRESS = T'）;结束; /</code></pre><p>使用Java API：</p><pre class="pre codeblock"><code>cfg = GraphConfigBuilder .forPropertyGraphRdbms（）。setJdbcUrl（“jdbc：oracle：thin：@ 127.0.0.1：1521：orcl”）。setUsername（“&lt;your_user_name&gt;”）。setPassword（“&lt;your_password&gt;”）。setName（“myGraph” “）。setMaxNumConnections（8）.setLoadEdgeLabel（false）.build（）; OraclePropertyGraph opg = OraclePropertyGraph.getInstance（cfg）;</code></pre><p>在数据库中建立属性图<code class="codeph">myGraph</code>后，将在用户的模式中自动创建多个表，其中图名称为前缀，VT $或GE $作为后缀。例如，对于名为<code class="codeph">myGraph</code>的图形，创建表myGraphVT $以存储顶点及其属性（K / V对），并创建表myGraphGE $以存储边缘及其属性。
                  </p>
                  <p>为简单起见，只允许使用简单的图形名称，它们不区分大小写。</p>
                  <p>使用SS $，IT $和GT $后缀创建其他内部表，分别用于存储图快照，文本索引元数据和图形框架（拓扑结构）。</p>
                  <p>表myGraphVT $和myGraphGE $的定义如下。它们对基于SQL的分析和基于SQL的属性图查询很重要。在VT $和GE $表中，VTS，VTE和FE都是保留列;列SL用于安全标签;并且列K，T，V，VN和VT一起存储关于图元素的属性（K / V对）的所有信息。在VT $表中，VID是用于存储顶点ID的长整数。在GE $表中，EID，SVID和DVID是长整数列，分别用于存储边ID，源（从）顶点ID和目标（到）顶点ID。</p><pre class="pre codeblock"><code>SQL&gt;描述myGraph <span class="bold">VT $</span> Name Null？输入----------------------------------------- -------- ---------------------------- VID NOT NULL NUMBER K NVARCHAR2（3100）T NUMBER（38）V NVARCHAR2（15000）VN NUMBER VT TIMESTAMP（6）WITH TIME ZONE SL NUMBER VTS DATE VTE DATE FE NVARCHAR2（4000）SQL&gt; describe myGraph <span class="bold">GE $</span> Name Null？输入----------------------------------------- -------- ---------------------------- EID NOT NULL NUMBER SVID NOT NULL NUMBER DVID NOT NULL NUMBER EL NVARCHAR2（3100）K NVARCHAR2（3100） T NUMBER（38）V NVARCHAR2（15000）VN NUMBER VT TIMESTAMP（6）WITH TIME ZONE SL NUMBER VTS DATE VTE DATE FE NVARCHAR2（4000）</code></pre><p>在属性图模式设计中，如果值具有数值数据类型（long，int，double，float等），则属性值存储在VN列中，如果值是时间戳，则存储在VT列中，或者字符串的V列，布尔值和其他可序列化的数据类型。为了获得更好的Oracle Text查询支持，即使数据类型为数字或时间戳，属性值的文字表示也会保存在V列中。为了区分所有支持的数据类型，整数ID保存在T列中。</p>
                  <p>VT $和GE $表中的K列存储属性键。每个边必须具有String类型的标签，并且标签存储在GE $表的EL列中。</p>
                  <p>VT $和GE $表中的T列是一个数字，表示它描述的属性值的数据类型。例如，1表示值是字符串，2表示值是整数，依此类推。一些T列可能的值和关联的数据类型如下：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>1：STRING</p>
                     </li>
                     <li>
                        <p>2：INTEGER</p>
                     </li>
                     <li>
                        <p>3：FLOAT</p>
                     </li>
                     <li>
                        <p>4：双倍</p>
                     </li>
                     <li>
                        <p>5：日期</p>
                     </li>
                     <li>
                        <p>6：布尔兰</p>
                     </li>
                     <li>
                        <p>7：长</p>
                     </li>
                     <li>
                        <p>8：简短</p>
                     </li>
                     <li>
                        <p>9：BYTE</p>
                     </li>
                     <li>
                        <p>10：CHAR</p>
                     </li>
                     <li>
                        <p>20：空间数据（请参阅<a href="property-graph-overview-spgdg.html#GUID-5411672D-89D0-4829-AEB6-25232A12E897">在属性图中表示空间数据</a> ）</p>
                     </li>
                  </ul>
                  <p>为了支持国际字符，NVARCHAR列用于VT $和GE $表。Oracle强烈建议使用UTF8作为默认数据库字符集。此外，V列的大小为15000， <span class="bold">需要</span>启用32K VARCHAR（ <code class="codeph">MAX_STRING_SIZE = EXTENDED</code> ）。
                  </p>
                  <div class="example" id="GUID-728A5FBC-998C-4675-9C0A-31C9195B737D__GUID-3FCFC70B-1F00-427D-B8CC-9D905DFD578F">
                     <p class="titleinexample">例2-5将行插入VT $表</p>
                     <p>此示例将行插入名为CONNECTIONSVT $的表中。它包括T列值1到10（表示各种数据类型）。</p><pre class="pre codeblock"><code>INSERT INTO connectionsvt $（vid，k，t，v，vn，vt）VALUES（2001，'1-STRING'，1，'Some String'，NULL，NULL）; INSERT INTO connectionsvt $（vid，k，t，v，vn，vt）VALUES（2001，'2-INTEGER'，2，NULL，21，NULL）; INSERT INTO connectionsvt $（vid，k，t，v，vn，vt）VALUES（2001，'3-FLOAT'，3，NULL，21.5，NULL）; INSERT INTO connectionsvt $（vid，k，t，v，vn，vt）VALUES（2001，'4-DOUBLE'，4，NULL，21.5，NULL）; INSERT INTO connectionsvt $（vid，k，t，v，vn，vt）VALUES（2001，'5-DATE'，5，NULL，NULL，timestamp'2018-07-20 15：32：53.991000'）; INSERT INTO connectionsvt $（vid，k，t，v，vn，vt）VALUES（2001，'6-BOOLEAN'，6，'Y'，NULL，NULL）; INSERT INTO connectionsvt $（vid，k，t，v，vn，vt）VALUES（2001，'7-LONG'，7，NULL，42，NULL）; INSERT INTO connectionsvt $（vid，k，t，v，vn，vt）VALUES（2001，'8-SHORT'，8，NULL，10，NULL）; INSERT INTO connectionsvt $（vid，k，t，v，vn，vt）VALUES（2001，'9-BYTE'，9，NULL，10，NULL）; INSERT INTO connectionsvt $（vid，k，t，v，vn，vt）VALUES（2001，'10 -CHAR'，10，'A'，NULL，NULL）; ...UPDATE connectionsVT $ SET V = coalesce（v，to_nchar（vn），to_nchar（vt））WHERE vid = 2001;承诺;</code></pre></div>
                  <!-- class="example" -->
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-78D0CA44-DA26-43BC-ABD8-64548544BCA2">Vertex（VT $）和Edge（GE $）表上的默认索引</a><br></li>
                     <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-10626028-5648-4BCB-9992-2E6488C1DA13">属性图架构的灵活性</a><br></li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="using-property-graphs-oracle-database.html#GUID-4B5AF258-79BE-418D-84FF-9B8A692B8604" title="本章提供有关在Oracle数据库环境中创建，存储和使用属性图数据的概念和用法信息。">在Oracle数据库环境中使用属性图</a></p>
                     </div>
                  </div>
               </div>
               
               <div class="props_rev_3"><a id="GUID-78D0CA44-DA26-43BC-ABD8-64548544BCA2" name="GUID-78D0CA44-DA26-43BC-ABD8-64548544BCA2"></a><h4 id="SPGDG-GUID-78D0CA44-DA26-43BC-ABD8-64548544BCA2" class="sect4"><span class="enumeration_section">2.3.1</span> Vertex（VT $）和Edge（GE $）表的默认索引</h4>
                  <div>
                     <p>对于查询性能，默认情况下会创建属性图表上的多个索引。索引名称遵循与表名相同的约定，包括使用图名作为前缀。例如，对于属性图<code class="codeph">myGraph</code> ，将创建以下本地索引：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">on myGraphVT$(VID, K)</code>唯一索引<code class="codeph">myGraphXQV$</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">myGraphGE$(EID, K)</code>上的唯一索引<code class="codeph">myGraphXQE$</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">myGraphXSE$</code>上的索引<code class="codeph">myGraphXSE$</code> <code class="codeph">myGraphGE$(SVID, DVID, EID, VN)</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">myGraphXDE$</code>上的索引<code class="codeph">myGraphXDE$</code> <code class="codeph">myGraphGE$(DVID, SVID, EID, VN)</code></p>
                        </li>
                     </ul>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="using-property-graphs-oracle-database.html#GUID-728A5FBC-998C-4675-9C0A-31C9195B737D" title="属性图PL / SQL和Java API使用特殊的Oracle数据库模式对象。">Oracle数据库的属性图架构对象</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="props_rev_3"><a id="GUID-10626028-5648-4BCB-9992-2E6488C1DA13" name="GUID-10626028-5648-4BCB-9992-2E6488C1DA13"></a><h4 id="SPGDG-GUID-10626028-5648-4BCB-9992-2E6488C1DA13" class="sect4"><span class="enumeration_section">2.3.2</span>属性图模式的灵活性</h4>
                  <div>
                     <p>属性图架构设计不使用任何类型的目录或集中式存储库。每个属性图由用户选择的模式单独存储和管理。用户的架构可能具有一个或多个属性图。</p>
                     <p>该设计为用户提供了相当大的灵活性例如：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>可以根据需要添加其他索引。</p>
                        </li>
                        <li>
                           <p>不同的属性图可以为基表提供不同的索引集或压缩选项。</p>
                        </li>
                        <li>
                           <p>不同的属性图可以具有不同数量的散列分区。</p>
                        </li>
                        <li>
                           <p>您甚至可以删除属性图的XSE $或XDE $索引;但是，为了完整性，您应该保持独特的约束。</p>
                        </li>
                     </ul>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="using-property-graphs-oracle-database.html#GUID-728A5FBC-998C-4675-9C0A-31C9195B737D" title="属性图PL / SQL和Java API使用特殊的Oracle数据库模式对象。">Oracle数据库的属性图架构对象</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div>
            <div class="props_rev_3"><a id="GUID-E754CCD1-FB01-4644-A028-FEEA0ED683ED" name="GUID-E754CCD1-FB01-4644-A028-FEEA0ED683ED"></a><h3 id="SPGDG-GUID-E754CCD1-FB01-4644-A028-FEEA0ED683ED" class="sect3"><span class="enumeration_section">2.4</span>属性图入门</h3>
               <div>
                  <p>按照以下步骤开始使用属性图。</p>
                  <ol>
                     <li><span>首次使用属性图时，请确保软件已安装且可运行。</span></li>
                     <li><span>使用Java API中提供的类创建Java程序。</span></li>
                  </ol>
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="using-property-graphs-oracle-database.html#GUID-734D16D3-E8AA-4097-B644-14D80A4C7958" title="创建属性图涉及使用Java API在其中创建属性图和对象。">使用Java API获取属性图数据</a></li>
                     </ul>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="using-property-graphs-oracle-database.html#GUID-4B5AF258-79BE-418D-84FF-9B8A692B8604" title="本章提供有关在Oracle数据库环境中创建，存储和使用属性图数据的概念和用法信息。">在Oracle数据库环境中使用属性图</a></p>
                     </div>
                  </div>
               </div>
               
            </div>
            <div class="props_rev_3"><a id="GUID-734D16D3-E8AA-4097-B644-14D80A4C7958" name="GUID-734D16D3-E8AA-4097-B644-14D80A4C7958"></a><h3 id="SPGDG-GUID-734D16D3-E8AA-4097-B644-14D80A4C7958" class="sect3"><span class="enumeration_section">2.5</span>使用Java API获取属性图数据</h3>
               <div>
                  <p>创建属性图涉及使用Java API在其中创建属性图和对象。</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-85A4E0F7-0C3C-411D-912A-FD4744FADE44">Java API概述</a><br></li>
                     <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-6212D301-F439-4B4B-A36F-73194D404979">图数据的并行加载</a><br></li>
                     <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-5CC8B971-DDCD-46CF-86EF-CDFD69E20FDC">图数据的并行检索</a><br></li>
                     <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-216595F2-BBA0-4FAB-AC6C-1FDF25D46469">使用元素过滤器回调进行子图提取</a><br></li>
                     <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-D33E2232-BE9C-444D-BC5C-2B4E62CAF2C4">在读取属性图数据时使用优化标志</a><br></li>
                     <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-991EA4C2-1DC0-413F-BF3C-D7B71537AA36">添加和删除属性图子图的属性</a><br></li>
                     <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-F97996AC-8DE0-4F8A-9789-09FF1A473B68">获取属性图元数据</a><br></li>
                     <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-0D1255E4-CE0B-4E2F-B78F-BAF569B7DE43">将新数据合并到现有属性图中</a><br></li>
                     <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-4B2A2CB6-FE53-4C92-A915-4673D355F470">打开和关闭属性图实例</a><br></li>
                     <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-08F8D5A9-F070-487A-A4E2-221CDDA39344">创建顶点</a><br></li>
                     <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-82E59D39-5C57-4987-9BC4-22369A9DBF01">创建边缘</a><br></li>
                     <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-0FC2511D-0E43-41B7-B2D1-77ECBEF6A417">删除顶点和边</a><br></li>
                     <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-454C00B5-9662-4C19-BF4D-FD8B1C503E34">将数据库中的图形读入嵌入式内存分析器</a><br></li>
                     <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-DCDC3B41-4679-4525-A3E1-44BF8C86187C">指定顶点的标签</a><br></li>
                     <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-A34FD5F5-EE5F-4956-9630-4C5B02DB6CF7">构建内存图</a><br></li>
                     <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-E17BCADE-4BC9-41D7-A54E-5612C4C6531F">删除属性图</a><br></li>
                     <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-6CDBA4FE-84B2-4666-93AF-45BFF0FF5552">执行PGQL查询</a><br></li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="using-property-graphs-oracle-database.html#GUID-4B5AF258-79BE-418D-84FF-9B8A692B8604" title="本章提供有关在Oracle数据库环境中创建，存储和使用属性图数据的概念和用法信息。">在Oracle数据库环境中使用属性图</a></p>
                     </div>
                  </div>
               </div>
               
               <div class="props_rev_3"><a id="GUID-85A4E0F7-0C3C-411D-912A-FD4744FADE44" name="GUID-85A4E0F7-0C3C-411D-912A-FD4744FADE44"></a><h4 id="SPGDG-GUID-85A4E0F7-0C3C-411D-912A-FD4744FADE44" class="sect4"><span class="enumeration_section">2.5.1</span> Java API概述</h4>
                  <div>
                     <p>可用于属性图的Java API包括以下内容：</p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-42D0F0B5-43A6-47E7-AEA9-B18A6A27D138">Oracle Spatial and Graph Property Graph Java API</a><br></li>
                        <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-5EC28F8B-49CA-42FB-A070-823C43BD9328">TinkerPop Java API</a><br></li>
                        <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-7D4751AA-40D6-4B4C-A117-1D639B342E84">Oracle数据库属性图Java API</a><br></li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="using-property-graphs-oracle-database.html#GUID-734D16D3-E8AA-4097-B644-14D80A4C7958" title="创建属性图涉及使用Java API在其中创建属性图和对象。">将Java API用于属性图数据</a></p>
                        </div>
                     </div>
                  </div>
                  
                  <div class="props_rev_3"><a id="GUID-42D0F0B5-43A6-47E7-AEA9-B18A6A27D138" name="GUID-42D0F0B5-43A6-47E7-AEA9-B18A6A27D138"></a><h5 id="SPGDG-GUID-42D0F0B5-43A6-47E7-AEA9-B18A6A27D138" class="sect5"><span class="enumeration_section">2.5.1.1</span> Oracle Spatial和Graph属性图Java API</h5>
                     <div>
                        <p>Oracle Spatial and Graph属性图支持为Oracle数据库提供特定于数据库的API。数据访问层API（ <code class="codeph">oracle.pg.*</code> ）实现了TinkerPop Blueprints API，文本搜索以及存储在Oracle数据库中的属性图的索引。
                        </p>
                        <p>要使用Oracle Spatial和Graph API，请将类导入Java程序：</p><pre class="oac_no_warn" dir="ltr">导入oracle.pg.common。*; import oracle.pg.text。*; import oracle.pg.rdbms。*; import oracle.pgx.config。*;导入oracle.pgx.common.types。*;</pre><p>还包括<a href="using-property-graphs-oracle-database.html#GUID-5EC28F8B-49CA-42FB-A070-823C43BD9328">TinkerPop Java API</a> 。</p>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="using-property-graphs-oracle-database.html#GUID-85A4E0F7-0C3C-411D-912A-FD4744FADE44">Java API概述</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
                  <div class="props_rev_3"><a id="GUID-5EC28F8B-49CA-42FB-A070-823C43BD9328" name="GUID-5EC28F8B-49CA-42FB-A070-823C43BD9328"></a><h5 id="SPGDG-GUID-5EC28F8B-49CA-42FB-A070-823C43BD9328" class="sect5"><span class="enumeration_section">2.5.1.2</span> TinkerPop Java API</h5>
                     <div>
                        <p>Apache TinkerPop支持属性图数据模型。API提供了用于操作图形的实用程序，您主要通过Spatial和Graph属性图数据访问层Java API使用这些实用程序。</p>
                        <p>要使用TinkerPop API，请将类导入Java程序：</p><pre class="oac_no_warn" dir="ltr">import org.apache.tinkerpop.gremlin.structure。顶点; import org.apache.tinkerpop.gremlin.structure。边缘;</pre></div>
                     <div>
                        <div class="relinfo">
                           <p><strong>相关话题</strong></p>
                           <ul>
                              <li><a href="http://www.tinkerpop.com/docs/javadocs/blueprints/2.3.0/index.html" target="_blank">蓝图：属性图模型接口API</a></li>
                           </ul>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="using-property-graphs-oracle-database.html#GUID-85A4E0F7-0C3C-411D-912A-FD4744FADE44">Java API概述</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
                  <div class="props_rev_3"><a id="GUID-7D4751AA-40D6-4B4C-A117-1D639B342E84" name="GUID-7D4751AA-40D6-4B4C-A117-1D639B342E84"></a><h5 id="SPGDG-GUID-7D4751AA-40D6-4B4C-A117-1D639B342E84" class="sect5"><span class="enumeration_section">2.5.1.3</span> Oracle数据库属性图Java API</h5>
                     <div>
                        <p>Oracle数据库属性图Java API使您能够创建和填充存储在Oracle数据库中的属性图。</p>
                        <p>要使用这些Java API，请将类导入Java程序。例如：</p><pre class="oac_no_warn" dir="ltr">import oracle.pg.rdbms。*; import java.sql。*;</pre></div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="using-property-graphs-oracle-database.html#GUID-85A4E0F7-0C3C-411D-912A-FD4744FADE44">Java API概述</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div>
               <div class="sect3"><a id="GUID-6212D301-F439-4B4B-A36F-73194D404979" name="GUID-6212D301-F439-4B4B-A36F-73194D404979"></a><h4 id="SPGDG-GUID-6212D301-F439-4B4B-A36F-73194D404979" class="sect4"><span class="enumeration_section">2.5.2</span>图形数据的并行加载</h4>
                  <div>
                     <p>提供Java API用于执行图形数据的并行加载。</p>
                     <p>Oracle Spatial and Graph支持将图形数据加载到Oracle数据库中。可以使用以下方法将图表数据加载到属性图中：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>可以使用<code class="codeph">graph.addVertex(Object id)/graph.addEdge(Object id)</code> API逐步添加顶点和/或边。</p>
                        </li>
                        <li>
                           <p>可以使用<code class="codeph">OraclePropertyGraphDataLoader</code> API并行地从Oracle flat-File格式的文件加载图表数据。</p>
                        </li>
                        <li>
                           <p>GraphML，GML或GraphSON中的属性图可以分别使用<code class="codeph">GMLReader</code> ， <code class="codeph">GraphMLReader</code>和<code class="codeph">GraphSONReader</code>加载。
                           </p>
                        </li>
                     </ul>
                     <p>本主题重点介绍以Oracle定义的平面文件格式并行加载属性图。</p>
                     <p>并行数据加载为数据加载提供了优化的解决方案，其中顶点（或边）输入流被分成多个块并且并行加载到Oracle数据库中。此操作涉及两个主要重叠阶段：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>分裂。顶点和边输入流被分成多个块并保存到临时输入流中。块的数量由指定的并行度确定</p>
                        </li>
                        <li>
                           <p>图加载。对于每个块，创建加载器线程以处理关于顶点（或边）信息的信息并将数据加载到属性图表中。</p>
                        </li>
                     </ul>
                     <p><code class="codeph">OraclePropertyGraphDataLoader</code>使用几个不同的选项支持并行数据加载：</p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-40B77BBF-9FEC-412A-8A3F-8DB41993E4C7">基于JDBC的数据加载</a><br></li>
                        <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-4AB847C3-7EE6-4C18-B4AF-0F885277EBA3">外部基于表的数据加载</a><br></li>
                        <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-9E4F7C89-A28B-4F54-8132-C6F2F8395A6F">基于SQL * Loader的数据加载</a><br></li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="using-property-graphs-oracle-database.html#GUID-734D16D3-E8AA-4097-B644-14D80A4C7958" title="创建属性图涉及使用Java API在其中创建属性图和对象。">将Java API用于属性图数据</a></p>
                        </div>
                     </div>
                  </div>
                  
                  <div class="props_rev_3"><a id="GUID-40B77BBF-9FEC-412A-8A3F-8DB41993E4C7" name="GUID-40B77BBF-9FEC-412A-8A3F-8DB41993E4C7"></a><h5 id="SPGDG-GUID-40B77BBF-9FEC-412A-8A3F-8DB41993E4C7" class="sect5"><span class="enumeration_section">2.5.2.1</span>基于JDBC的数据加载</h5>
                     <div>
                        <p>基于JDBC的数据加载使用Java数据库连接（JDBC）API将图形数据加载到Oracle数据库中。在此选项中，给定输入流中的顶点（或边）将由拆分器线程在多个块之间分布。每个块将由不同的加载器线程处理，该线程使用JDBC批处理将块中的所有元素插入到临时工作表中。使用的分离器和加载器线程的数量由用户指定的并行度（DOP）确定。</p>
                        <p>将所有图形数据加载到临时工作表后，存储在临时工作表中的所有数据都将加载到属性图VT $和GE $表中。</p>
                        <p>以下示例使用基于JDBC的并行数据加载以48的并行度加载Oracle定义的平面文件格式的顶点和边文件中的图形数据。</p><pre class="pre codeblock"><code>String szOPVFile =“../../data/connections.opv“; String szOPEFile =”../../data/connections.ope“; OraclePropertyGraph opg = OraclePropertyGraph.getInstance（args，szGraphName）; opgdl = OraclePropertyGraphDataLoader.getInstance（）; opgdl.loadData（opg，szOPVFile，szOPEFile，48 / * DOP * /，1000 / *批量大小* /，真/ *重建索引标志* /，“pddl = t，pdml = t”/ * options * /）;）;</code></pre><p>为了优化数据加载操作的性能，可以在调用基于JDBC的数据加载时指定一组标志和提示。这些提示包括：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><span class="bold">DOP：</span>加载数据时使用的并行度。此参数确定拆分文件时生成的块数以及将数据加载到属性图VT $和GE $表时要使用的加载程序线程数。
                              </p>
                           </li>
                           <li>
                              <p><span class="bold">批处理大小：</span>一个整数，指定在批处理模式下用于Oracle更新语句的批处理大小。基于JDBC的数据加载中使用的默认批处理大小为1000。
                              </p>
                           </li>
                           <li>
                              <p><span class="bold">重建索引：</span>如果此标志设置为<code class="codeph">true</code> ，则数据加载器将禁用在将加载数据的属性图上定义的所有索引和约束。将所有数据加载到属性图中后，将重建所有索引和约束。
                              </p>
                           </li>
                           <li>
                              <p><span class="bold">加载选项：</span>用于优化数据加载操作的选项（或由逗号分隔的多个选项）。这些选项包括：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>NO_DUP = T：假设输入数据没有无效的重复项。在有效的属性图中，每个顶点（边）最多只能有一个给定属性键的值。在无效的属性图中，顶点（边）可以具有特定键的两个或更多个值。例如，顶点v具有两个键/值对：name /“John”和name /“Johnny”，它们共享相同的键。</p>
                                 </li>
                                 <li>
                                    <p>PDML = T：为数据加载器中使用的数据库会话启用DML操作的并行执行。此提示用于提高长时间运行的批处理作业的性能。</p>
                                 </li>
                                 <li>
                                    <p>PDDL = T：为数据加载器中使用的数据库会话启用DDL操作的并行执行。此提示用于提高长时间运行的批处理作业的性能。</p>
                                 </li>
                                 <li>
                                    <p>KEEP_WORK_TABS = T：数据加载完成后，跳过清理和删除工作表。这仅供调试使用。</p>
                                 </li>
                                 <li>
                                    <p>KEEP_TMP_FILES = T：在数据加载完成后跳过删除临时拆分器文件。这仅用于调试。</p>
                                 </li>
                              </ul>
                           </li>
                           <li>
                              <p>拆分<span class="bold">器标志：</span>一个整数值，用于定义在拆分阶段使用的文件或流的类型，以生成图加载阶段中使用的数据块。临时文件可以创建为常规文件（0），命名管道（1）或管道流（2）。默认情况下，基于JDBC的数据加载使用</p>
                              <p>用于处理中间数据块的管道流管道流仅用于基于JDBC的加载程序。它们纯粹是内存和高效的，不需要在操作系统上创建任何文件。</p>
                              <p>常规文件占用本地操作系统上的空间，而命名管道在本地操作系统上显示为空文件。请注意，并非每个操作系统都支持命名管道。</p>
                           </li>
                           <li>
                              <p><span class="bold">拆分文件前缀：</span>用于在拆分阶段为图形加载生成数据块时创建的临时文件或管道的前缀。默认情况下，前缀“OPG_Chunk”用于常规文件，“OPG_Pipe”用于命名管道。
                              </p>
                           </li>
                           <li>
                              <p><span class="bold">表空间：</span>将创建所有临时工作表的表空间的名称。
                              </p>
                           </li>
                        </ul>
                        <p>副题</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>基于JDBC的数据加载多个文件</p>
                           </li>
                           <li>
                              <p>使用分区加载基于JDBC的数据</p>
                           </li>
                           <li>
                              <p>基于JDBC的并行数据加载使用微调</p>
                           </li>
                        </ul>
                        <div class="section">
                           <p class="subhead3" id="GUID-40B77BBF-9FEC-412A-8A3F-8DB41993E4C7__GUID-809125AC-B153-41B4-A6C6-78D42398768E">基于JDBC的数据加载多个文件</p>
                           <p>基于JDBC的数据加载还支持将多个文件或输入流中的顶点和边加载到数据库中。以下代码片段使用并行数据加载API加载多个顶点和边缘文件。在该示例中，两个字符串数组szOPVFiles和szOPEFiles用于保存输入文件。</p><pre class="pre codeblock"><code>String [] szOPVFiles = new String [] {“../../data/connections-p1.opv“，”../../data/connections-p2.opv“}; String [] szOPEFiles = new String [] {”../../data/connections-p1.ope“，”../../data/connections-p2.ope“}; OraclePropertyGraph opg = OraclePropertyGraph.getInstance（args，szGraphName）; opgdl = OraclePropertyGraphDataLoader.getInstance（）; opgdl.loadData（opg，szOPVFiles，szOPEFiles，48 / * DOP * / ，1000 / *批量大小* /，真/ *重建索引标志* /，“pddl = t，pdml = t”/ * options * /）;</code></pre></div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-40B77BBF-9FEC-412A-8A3F-8DB41993E4C7__GUID-E813D90D-3233-412A-91BF-A6DCCCFD587C">使用分区加载基于JDBC的数据</p>
                           <p>在处理从数千到数十万个元素的图形数据时，基于JDBC的数据加载API允许使用逻辑分区将Oracle Flat文件格式的图形数据加载到Oracle数据库中。</p>
                           <p>每个分区表示图形数据文件中的顶点（或边）的子集，其大小大约是文件中的不同元素ID的数量除以分区的数量。每个分区由[0，分区数 -  1]范围内的整数ID标识。</p>
                           <p>要使用分区并行数据加载，除了<code class="codeph">loadData</code> API中使用的基本参数外，还必须指定要使用的逻辑分区总数和分区偏移量（起始ID）。要将图形数据文件或输入流完全加载到数据库中，必须执行数据加载操作的次数与定义的分区数一样多。例如，要使用两个分区从文件加载图形数据，应使用偏移量0和1进行两次数据加载API调用。可以使用多个线程或单个系统或多个系统上的单独Java客户端来处理对数据加载器的每次调用。
                           </p>
                           <p>请注意，此方法旨在与单个顶点文件（或输入流）和单个边缘文件（或输入流）一起使用。此外，此选项需要禁用顶点和边的索引和约束。在加载<span class="bold"><span class="italic">所有</span></span>分区后，必须重建这些索引和约束。
                           </p>
                           <p>以下示例使用两个分区加载图数据。每个分区由一个Java进程<code class="codeph">DataLoaderWorker</code>加载。为了协调多个worker，使用名为DataLoaderCoordinator的协调器进程。此示例执行以下操作</p>
                           <ol>
                              <li>
                                 <p>禁用所有索引和约束，</p>
                              </li>
                              <li>
                                 <p>创建一个临时工作表loaderProgress，它记录数据加载进度（即，有多少工人完成了他们的工作。创建工作表后，所有<code class="codeph">DataLoaderWorker</code>进程都开始加载数据。
                                 </p>
                              </li>
                              <li>
                                 <p>将进度增加1。</p>
                              </li>
                              <li>
                                 <p>继续轮询（使用<code class="codeph">DataLoaderCoordinator</code>进程）进度，直到完成所有<code class="codeph">DataLoaderWorker</code>进程。
                                 </p>
                              </li>
                              <li>
                                 <p>重建所有索引和约束。</p>
                              </li>
                           </ol>
                           <p>注意：在<code class="codeph">DataLoaderWorker</code> ，标志<code class="codeph">SKIP_INDEX</code>应设置为<code class="codeph">true</code> ，标志<code class="codeph">rebuildIndx</code>应设置为<code class="codeph">false</code> 。
                           </p><pre class="pre codeblock"><code>//启动DataLoaderCoordinator，设置dop = 8和分区数= 2 java DataLoaderCoordinator jdbcUrl用户密码pg 8 2 //启动第一个DataLoaderWorker，设置dop = 8，分区数= 2，分区偏移= 0 java DataLoaderWorker jdbcUrl用户密码pg 8 2 0 //启动第一个DataLoaderWorker，设置dop = 8，分区数= 2，分区偏移= 1 java DataLoaderWorker jdbcUrl用户密码pg 8 2 1</code></pre><p><code class="codeph">DataLoaderCoordinator</code>首先禁用所有索引和约束。然后，它创建一个名为loaderProgress的表，并插入一行，其中列progress = 0。
                           </p><pre class="pre codeblock"><code>public class DataLoaderCoordinator {public static void main（String [] szArgs）{String jdbcUrl = szArgs [0]; String user = szArgs [1]; String password = szArgs [2]; String graphName = szArgs [3]; int dop = Integer.parseInt（szArgs [4]）; int numLoaders = Integer.parseInt（szArgs [5]）; Oracle oracle = null; OraclePropertyGraph opg = null;试试{oracle = new Oracle（jdbcUrl，user，password）; OraclePropertyGraphUtils.dropPropertyGraph（oracle，graphName）; opg = OraclePropertyGraph.getInstance（oracle，graphName）; List &lt;String&gt; vIndices = opg.disableVertexTableIndices（）; List &lt;String&gt; vConstraints = opg.disableVertexTableConstraints（）; List &lt;String&gt; eIndices = opg.disableEdgeTableIndices（）; List &lt;String&gt; eConstraints = opg.disableEdgeTableConstraints（）; String szStmt = null;尝试{szStmt =“drop table loaderProgress”; 。opg.getOracle（）的executeUpdate（szStmt）; } catch（SQLException ex）{if（ex.getErrorCode（）== 942）{//表不存在。 ignore} else {throw new OraclePropertyGraphException（ex）; szStmt =“create table loaderProgress（progress integer）”; 。opg.getOracle（）的executeUpdate（szStmt）; szStmt =“插入loaderProgress（进度）值（0）”; 。opg.getOracle（）的executeUpdate（szStmt）; 。opg.getOracle（）的getConnection（）提交（）; while（true）{if（checkLoaderProgress（oracle）== numLoaders）{break; } else {Thread.sleep（1000）; opg.rebuildVertexTableIndices（vIndices，dop，null）; opg.rebuildVertexTableConstraints（vConstraints，dop，null）; opg.rebuildEdgeTableIndices（eIndices，dop，null）; opg.rebuildEdgeTableConstraints（eConstraints，dop，null）; } catch（IOException ex）{throw new OraclePropertyGraphException（ex）; } catch（SQLException ex）{throw new OraclePropertyGraphException（ex）; } catch（InterruptedException ex）{throw new OraclePropertyGraphException（ex）; } catch（Exception ex）{throw new OraclePropertyGraphException（ex）; } finally {try {if（opg！= null）{opg.shutdown（）;如果（oracle！= null）{oracle.dispose（）; catch（Throwable t）{System.out.println（t）; private static int checkLoaderProgress（Oracle oracle）{int result = 0; ResultSet rs = null; try {String szStmt =“从loaderProgress中选择进度”; rs = oracle.executeQuery（szStmt）; if（rs.next（））{result = rs.getInt（1）; catch（Exception ex）{throw new OraclePropertyGraphException（ex）; } finally {try {if（rs！）= null）{rs.close（）; catch（Throwable t）{System.out.println（t）;返回结果; public class DataLoaderWorker {public static void main（String [] szArgs）{String jdbcUrl = szArgs [0]; String user = szArgs [1]; String password = szArgs [2]; String graphName = szArgs [3]; int dop = Integer.parseInt（szArgs [4]）; int numLoaders = Integer.parseInt（szArgs [5]）; int offset = Integer.parseInt（szArgs [6]）; Oracle oracle = null; OraclePropertyGraph opg = null;试试{oracle = new Oracle（jdbcUrl，user，password）; opg = OraclePropertyGraph.getInstance（oracle，graphName，8，dop，null / * tbs * /，“，SKIP_INDEX = T，”）; OraclePropertyGraphDataLoader opgdal = OraclePropertyGraphDataLoader.getInstance（）; while（true）{if（checkLoaderProgress（oracle）== 1）{break; } else {Thread.sleep（1000）;字符串opvFile =“../ ../../data/connections.opv“; String opeFile =”../ ../../data/connections.ope“; opgdal.loadData（opg，opvFile，opeFile，dop，numLoaders，offset，1000，false，null，”pddl = t，pdml = t“）; updateLoaderProgress（oracle）;} catch（SQLException ex）{throw new OraclePropertyGraphException（ex）;} catch（InterruptedException ex）{throw new OraclePropertyGraphException（ex）;} finally {try {if（opg！）= null）{opg.shutdown（）;如果（oracle！= null）{oracle.dispose（）; catch（Throwable t）{System.out.println（t）; private static int checkLoaderProgress（Oracle oracle）{int result = 0; ResultSet rs = null; try {String szStmt =“从loaderProgress中选择count（*）”; rs = oracle.executeQuery（szStmt）; if（rs.next（））{result = rs.getInt（1）; catch（SQLException ex）{if（ex.getErrorCode（）== 942）{//表不存在。 ignore} else {throw new OraclePropertyGraphException（ex）;终于{try {if（rs！）= null）{rs.close（）; catch（Throwable t）{System.out.println（t）;返回结果; private static void updateLoaderProgress（Oracle oracle）{ResultSet rs = null; try {String szStmt =“update loaderProgress set progress = progress + 1”; oracle.executeUpdate（szStmt）; oracle.getConnection（）提交（）; } catch（Exception ex）{throw new OraclePropertyGraphException（ex）; } finally {try {if（rs！）= null）{rs.close（）; catch（Throwable t）{System.out.println（t）; }}}}</code></pre></div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-40B77BBF-9FEC-412A-8A3F-8DB41993E4C7__GUID-C57C9B4B-DDA2-4D0D-A6C0-013939268F18">基于JDBC的并行数据加载使用微调</p>
                           <p>基于JDBC的数据加载支持微调要加载的行的数据子集，以及在将元素加载到属性图实例时使用的ID偏移。您可以通过指定从文件中读取的最大行数以及顶点和边的偏移行编号（起始位置）来指定要从文件加载的数据子集。这样，数据将从偏移行号加载，直到读取最大行数。如果最大行号为-1，则加载过程将扫描数据直到到达文件末尾。</p>
                           <p>由于多个图形数据文件可能存在一些ID冲突或重叠，因此基于JDBC的数据加载允许您定义顶点和边缘ID偏移。这样，每个加载顶点的ID将是原始顶点ID和给定顶点ID偏移的总和。类似地，将根据原始边缘ID和给定边缘ID偏移的总和生成每个加载边缘的ID。请注意，顶点和边文件必须相关，因为加载边的入/出顶点ID将相对于指定的顶点ID偏移进行修改。仅在使用单个逻辑分区的数据加载中支持此操作。</p>
                           <p>以下代码片段从给定的图形数据文件加载前100个顶点和边线。在该示例中，使用ID偏移0，其指示不执行ID调整。</p><pre class="pre codeblock"><code>String szOPVFile =“../../data/connections.opv“; String szOPEFile =”../../data/connections.ope“; //使用微调long lVertexOffsetlines = 0运行数据加载; long lEdgeOffsetlines = 0; long lVertexMaxlines = 100; long lEdgeMaxlines = 100; long lVIDOffset = 0; long lEIDOffset = 0; OraclePropertyGraph opg = OraclePropertyGraph.getInstance（args，szGraphName）; OraclePropertyGraphDataLoader opgdl = OraclePropertyGraphDataLoader.getInstance（）; opgdl.loadData（opg，szOPVFile，szOPEFile，lVertexOffsetlines / *从分区开始加载的行的偏移量，默认为0 * /，lEdgeOffsetlines / *从分区开始加载的行的偏移量，默认为0 * /，lVertexMaxlines / *从分区开始加载的最大行数，默认为-1（分区中的所有行）* /，lEdgeMaxlines / *开始加载的最大行数from partition，默认-1（分区中的所有行）* /，lVIDOffset / * vertex ID offset：顶点ID将是原始顶点ID +偏移量，默认为0 * /，lEIDOffset / *边缘ID偏移量：边缘ID将为原始边ID +偏移，def ault 0 * /，4 / * DOP * /，1 / *分区总数，默认1 * /，0 / *要加载的分区：从0到totalPartitions  -  1，默认为0 * /，OraclePropertyGraphDataLoader。PIPEDSTREAM / * splitter标志* /，“chunkPrefix”/ * prefix：用于为常规文件或命名管道生成拆分块的前缀* /，1000 / *批量大小：批处理模式下Oracle更新的批量大小。默认值为1000 * /，true / * rebuild index * /，null / *表空间名称* /，“pddl = t，pdml = t”/ * options：enable parallel DDL and DML * /）;</code></pre></div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="using-property-graphs-oracle-database.html#GUID-6212D301-F439-4B4B-A36F-73194D404979">图形数据的并行加载</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
                  <div class="props_rev_3"><a id="GUID-4AB847C3-7EE6-4C18-B4AF-0F885277EBA3" name="GUID-4AB847C3-7EE6-4C18-B4AF-0F885277EBA3"></a><h5 id="SPGDG-GUID-4AB847C3-7EE6-4C18-B4AF-0F885277EBA3" class="sect5"><span class="enumeration_section">2.5.2.2</span>外部基于表的数据加载</h5>
                     <div>
                        <p>基于外部表的数据加载使用外部表将图数据加载到Oracle数据库中。外部表加载允许用户访问外部源中的数据，就好像它位于数据库中的常规关系表中一样。在这种情况下，给定输入流中的顶点（或边）将由分割器线程在多个块之间分布。每个块都将由不同的加载器线程处理，该线程负责将块中的所有元素传递给Oracle数据库。使用的分离器和加载器线程的数量由用户指定的并行度（DOP）确定。</p>
                        <p>在外部表由数据加载逻辑自动创建之后，加载器将从外部表读取并将所有数据加载到属性图模式表（VT $和GE $）中。</p>
                        <p>基于外部表的数据加载需要一个目录对象，其中将存储外部表读取的文件。可以通过在SQL * Plus环境中运行以下脚本来创建此目录：</p><pre class="pre codeblock"><code>创建或替换目录tmp_dir为'/ tmppath /';授予读取权限，将目录tmp_dir写入公共;</code></pre><p>以下代码片段使用基于表的并行数据加载，以48的并行度加载来自Oracle平面文件格式的顶点和边缘文件的图形数据。</p><pre class="pre codeblock"><code>String szOPVFile =“../../data/connections.opv“; String szOPEFile =”../../data/connections.ope“; String szExtDir =”tmp_dir“; OraclePropertyGraph opg = OraclePropertyGraph.getInstance（args，szGraphName）; opgdl = OraclePropertyGraphDataLoader.getInstance（）; opgdl.loadDataWithExtTab（opg，szOPVFile，szOPEFile，48 / * DOP * /，true / *命名管道标志：将标志设置为true将使用基于命名管道的拆分;否则，将使用基于常规文件的拆分* /，szExtDir / *数据库目录对象* /，true / *重建索引* /，“pddl = t，pdml = t，NO_DUP = T”/ * options * /）;</code></pre><p>为了优化数据加载操作的性能，可以在调用基于外部表的数据加载时指定一组标志和提示。这些提示包括：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><span class="bold">DOP：</span>加载数据时使用的并行度。此参数确定拆分文件时生成的块数，以及将数据加载到属性图VT $和GE $表时要使用的加载程序线程数。
                              </p>
                           </li>
                           <li>
                              <p><span class="bold">重建索引：</span>如果此标志设置为<code class="codeph">true</code> ，则数据加载器将禁用在将加载数据的属性图上定义的所有索引和约束。将所有数据加载到属性图中后，将重建所有索引和约束。
                              </p>
                           </li>
                           <li>
                              <p><span class="bold">加载选项：</span>用于优化数据加载操作的选项（或由逗号分隔的多个选项）。这些选项包括：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>NO_DUP = T：选择更快的方式将数据加载到属性图表中，因为不会对重复的键/值对进行验证。</p>
                                 </li>
                                 <li>
                                    <p>PDML = T：为数据加载器中使用的数据库会话启用DML操作的并行执行。此提示用于提高长时间运行的批处理作业的性能。</p>
                                 </li>
                                 <li>
                                    <p>PDDL = T：为数据加载器中使用的数据库会话启用DDL操作的并行执行。此提示用于提高长时间运行的批处理作业的性能。</p>
                                 </li>
                                 <li>
                                    <p>KEEP_WORK_TABS = T：数据加载完成后，跳过清理和删除工作表。这仅供调试使用。</p>
                                 </li>
                                 <li>
                                    <p>KEEP_TMP_FILES = T：在数据加载完成后跳过删除临时拆分器文件。这仅供调试使用。</p>
                                 </li>
                              </ul>
                           </li>
                           <li>
                              <p>拆分<span class="bold">器标志：</span>一个整数值，用于定义在拆分阶段使用的文件或流的类型，以生成图加载阶段中使用的数据块。临时文件可以创建为常规文件（0）或命名管道（1）。
                              </p>
                              <p>默认情况下，基于外部表的数据加载使用常规文件来处理数据块的临时文件。命名管道只能在支持它们的操作系统上使用。将常规文件与DBFS一起使用通常是一种很好的做法。</p>
                           </li>
                           <li>
                              <p><span class="bold">拆分文件前缀：</span>用于在拆分阶段为图形加载生成数据块时创建的临时文件或管道的前缀。默认情况下，前缀“Chunk”用于常规文件，“Pipe”用于命名管道。
                              </p>
                           </li>
                           <li>
                              <p><span class="bold">表空间：</span>将创建所有临时工作表的表空间的名称。
                              </p>
                           </li>
                        </ul>
                        <p>与基于JDBC的数据加载一样，基于外部表的数据加载支持使用单个文件，多个文件，分区和微调进行并行数据加载。</p>
                        <p>副题</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>基于表的外部数据加载多个文件</p>
                           </li>
                           <li>
                              <p>使用分区的基于外部表的数据加载</p>
                           </li>
                           <li>
                              <p>基于微调的外部基于表的并行数据加载</p>
                           </li>
                        </ul>
                        <div class="section">
                           <p class="subhead3" id="GUID-4AB847C3-7EE6-4C18-B4AF-0F885277EBA3__GUID-A17C7E8F-E91D-4039-B29F-FF1043A9B746">基于表的外部数据加载多个文件</p>
                           <p>外部基于表的数据加载还支持将多个文件或输入流中的顶点和边加载到数据库中。以下代码片段使用并行数据加载API加载多个顶点和边缘文件。在该示例中，两个字符串数组<code class="codeph">szOPVFiles</code>和<code class="codeph">szOPEFiles</code>用于保存输入文件。
                           </p><pre class="pre codeblock"><code>String szOPVFile =“../../data/connections.opv“; String szOPEFile =”../../data/connections.ope“; String szExtDir =”tmp_dir“; OraclePropertyGraph opg = OraclePropertyGraph.getInstance（args，szGraphName）; opgdl = OraclePropertyGraphDataLoader.getInstance（）; opgdl.loadDataWithExtTab（opg，szOPVFile，szOPEFile，48 / * DOP * /，true / *命名管道标志* /，szExtDir / *数据库目录对象* /，true / *重建索引标志* /，“pddl = t，pdml = t”/ * options * /）;</code></pre></div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-4AB847C3-7EE6-4C18-B4AF-0F885277EBA3__GUID-9FDEAA4C-2D85-4263-8261-F3B457C07C8F">使用分区的基于外部表的数据加载</p>
                           <p>在处理非常大的属性图时，基于外部表的数据加载API允许使用逻辑分区将Oracle平面文件格式的图数据加载到Oracle数据库中。每个分区表示图形数据文件中的顶点（或边）的子集，其大小大约是文件中的不同元素ID的数量除以分区的数量。每个分区由[0，分区数 -  1]范围内的整数ID标识。</p>
                           <p>要对分区使用并行数据加载，必须指定要使用的分区总数以及除<code class="codeph">loadDataWithExtTab</code> API中使用的基本参数之外的分区偏移量。要将图形数据文件或输入流完全加载到数据库中，必须执行数据加载操作的次数与定义的分区数一样多。例如，要使用两个分区从文件加载图形数据，应使用偏移量0和1进行两次数据加载API调用。可以使用多个线程或单个系统或多个系统上的单独Java客户端来处理对数据加载器的每次调用。
                           </p>
                           <p>请注意，此方法旨在与单个顶点文件（或输入流）和单个边缘文件（或输入流）一起使用。此外，此选项需要禁用顶点和边的索引和约束。在加载所有分区后，必须重建这些索引和约束。</p>
                           <p>可以轻松迁移基于JDBC的数据加载分区的示例，以作为基于外部表的分区加载。唯一需要的更改是使用<code class="codeph">loadDataWithExtTab()</code>替换API <code class="codeph">loadData()</code> ，并提供一些其他输入参数，例如数据库目录对象。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-4AB847C3-7EE6-4C18-B4AF-0F885277EBA3__GUID-78F16FE0-DAB6-4751-89A5-D32FBC252AB3">基于微调的外部基于表的并行数据加载</p>
                           <p>外部基于表的数据加载还支持微调要加载的行的数据子集，以及在将元素加载到属性图实例时使用的ID偏移。您可以通过指定从文件中读取的最大行数以及顶点和边的偏移行数来指定要从文件加载的数据子集。这样，数据将从偏移行号加载，直到读取最大行数。如果最大行数为-1，则加载过程将扫描数据，直到到达文件末尾。</p>
                           <p>由于图形数据文件可能存在一些ID冲突，因此基于外部表的数据加载允许您定义顶点和边缘ID偏移。这样，每个加载顶点的ID将从具有给定顶点ID偏移的原始顶点ID的总和获得。类似地，将根据原始边缘ID与给定边缘ID偏移的总和来生成每个加载边缘的ID。请注意，顶点和边文件必须相关，因为加载边的入/出顶点ID将相对于指定的顶点ID偏移进行修改。仅在使用单个分区的数据加载中支持此操作。</p>
                           <p>以下代码片段从给定的图形数据文件加载前100个顶点和边。在此示例中，未提供ID偏移。</p><pre class="pre codeblock"><code>String szOPVFile =“../../data/connections.opv“; String szOPEFile =”../../data/connections.ope“; //使用微调long lVertexOffsetlines = 0运行数据加载; long lEdgeOffsetlines = 0; long lVertexMaxlines = 100; long lEdgeMaxlines = 100; long lVIDOffset = 0; long lEIDOffset = 0; String szExtDir =“tmp_dir”; OraclePropertyGraph opg = OraclePropertyGraph.getInstance（args，szGraphName）; OraclePropertyGraphDataLoader opgdl = OraclePropertyGraphDataLoader.getInstance（）; opgdl.loadDataWithExtTab（opg，szOPVFile，szOPEFile，lVertexOffsetlines / *从分区开始加载的行的偏移量，默认0 * /，lEdgeOffsetlines / *从分区开始加载的行的偏移量，默认为0 * /，lVertexMaxlines / *从分区开始加载的最大行数，默认为-1（分区中的所有行）* /，lEdgeMaxlines / *从分区开始加载的最大行数，默认为-1（分区中的所有行）* /，lVIDOffset / * vertex ID offset：顶点ID将是原始顶点ID +偏移量，默认为0 * /，lEIDOffset / *边缘ID offset：边缘ID将是原始边缘ID +偏移，默认为0 * /，4 / * DOP * /，1 / *分区总数，默认1 * /，0 / *要加载的分区（从0到totalPartitions  -  1，默认为0） * /，OraclePropertyGraphDataLoader。NAMEDPIPE / * splitter标志* /，“chunkPrefix”/ *前缀* /，szExtDir / *数据库目录对象* /，true / *重建索引标志* /，“pddl = t，pdml = t”/ * options * /） ;</code></pre></div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="using-property-graphs-oracle-database.html#GUID-6212D301-F439-4B4B-A36F-73194D404979">图形数据的并行加载</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
                  <div class="props_rev_3"><a id="GUID-9E4F7C89-A28B-4F54-8132-C6F2F8395A6F" name="GUID-9E4F7C89-A28B-4F54-8132-C6F2F8395A6F"></a><h5 id="SPGDG-GUID-9E4F7C89-A28B-4F54-8132-C6F2F8395A6F" class="sect5"><span class="enumeration_section">2.5.2.3</span>基于SQL * Loader的数据加载</h5>
                     <div>
                        <p>SQL *基于Loader的数据加载使用Oracle SQL * Loader将图形数据加载到Oracle数据库中。SQL * Loader将外部文件中的数据加载到Oracle数据库表中。在这种情况下，给定输入流中的顶点（或边）将由分割器线程在多个块之间分布。每个块都将由不同的加载器线程处理，该线程使用SQL * Loader将块中的所有元素插入到临时工作表中。使用的分离器和加载器线程的数量由用户指定的并行度（DOP）确定。</p>
                        <p>在将所有图形数据加载到临时工作表之后，图形加载器将存储在临时工作表中的所有数据加载到属性图VT $和GE $表中。</p>
                        <p>以下代码片段使用基于SQL的并行数据加载以48的并行度加载来自Oracle平面文件格式的顶点和边缘文件的图形数据。要使用API，必须指定SQL * Loader的路径。</p><pre class="pre codeblock"><code>String szUser =“username”; String szPassword =“password”; String szDbId =“db18c”; / *数据库的服务名称* / String szOPVFile =“../../data/connections.opv“; String szOPEFile =”../../data/connections.ope“; String szSQLLoaderPath =”&lt;YOUR_ORACLE_HOME&gt; / bin / sqlldr“; OraclePropertyGraph opg = OraclePropertyGraph.getInstance（args，szGraphName）; opgdl = OraclePropertyGraphDataLoader.getInstance（）; opgdl.loadDataWithSqlLdr（opg， szUser，szPassword，szDbId，szOPVFile，szOPEFile，48 / * DOP * /，true / *命名管道标志* /，szSQLLoaderPath / * SQL * Loader路径：bin / sqlldr的路径* /，true / * rebuild index * / ，“pddl = t，pdml = t”/ * options * /）;</code></pre><p>与基于JDBC的数据加载一样，基于SQL * Loader的数据加载支持使用单个文件，多个文件，分区和微调加载并行数据。</p>
                        <p>副题</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>基于SQL * Loader的数据加载多个文件</p>
                           </li>
                           <li>
                              <p>基于SQL * Loader的数据加载分区</p>
                           </li>
                           <li>
                              <p>基于SQL * Loader的并行数据加载使用微调</p>
                           </li>
                        </ul>
                        <div class="section">
                           <p class="subhead3" id="GUID-9E4F7C89-A28B-4F54-8132-C6F2F8395A6F__GUID-6971B860-4C5E-4A55-A109-BF115E61D8C9">基于SQL * Loader的数据加载多个文件</p>
                           <p>SQL *基于Loader的数据加载支持将多个文件或输入流中的顶点和边加载到数据库中。以下代码片段使用并行数据加载API加载多个顶点和边缘文件。在该示例中，两个字符串数组<code class="codeph">szOPVFiles</code>和<code class="codeph">szOPEFiles</code>用于保存输入文件。
                           </p><pre class="pre codeblock"><code>String szUser =“username”; String szPassword =“password”; String szDbId =“db18c”; / *数据库的服务名称* / String [] szOPVFiles = new String [] {“../../data/connections-p1.opv“，”../../data/connections-p2.opv“}; String [] szOPEFiles = new String [] {”../../data/connections-p1.ope“，”../../data/connections-p2.ope“}; String szSQLLoaderPath =”../ ../../dbhome_1/bin/sqlldr“; OraclePropertyGraph opg = OraclePropertyGraph.getInstance（args，szGraphName）; opgdl = OraclePropertyGraphDataLoader.getInstance（）; opgdl.loadDataWithSqlLdr（opg，szUser，szPassword，szDbId，szOPVFiles，szOPEFiles，48 / * DOP * /，true / *命名管道标志* /，szSQLLoaderPath / * SQL * Loader路径* /，true / *重建索引标志* /，“pddl = t，pdml = t”/ * options * /）;</code></pre></div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-9E4F7C89-A28B-4F54-8132-C6F2F8395A6F__GUID-58D8B24E-0798-4FDE-AA4F-1C3EC56C64FA">基于SQL * Loader的数据加载分区</p>
                           <p>处理大型属性图时，基于SQL * Loader的数据加载API允许使用逻辑分区将Oracle平面文件格式的图形数据加载到Oracle数据库中。每个分区表示图形数据文件中的顶点（或边）的子集，其大小大约是文件中的不同元素ID的数量除以分区的数量。每个分区由[0，分区数 -  1]范围内的整数ID标识。</p>
                           <p>要使用与分区并行数据加载，除了<code class="codeph">loadDataWithSqlLdr</code> API中使用的基本参数外，还必须指定要使用的分区总数和分区偏移量。要将图形数据文件或输入流完全加载到数据库中，必须执行数据加载操作的次数与定义的分区数一样多。例如，要使用两个分区从文件加载图形数据，应使用偏移量0和1进行两次数据加载API调用。可以使用多个线程或单个系统或多个系统上的单独Java客户端来处理对数据加载器的每次调用。
                           </p>
                           <p>请注意，此方法旨在与单个顶点文件（或输入流）和单个边缘文件（或输入流）一起使用。此外，此选项需要禁用顶点和边的索引和约束。加载所有分区后，必须重建这些索引和约束。</p>
                           <p>可以轻松迁移基于JDBC的数据加载分区示例，以便作为基于SQL * Loader的分区加载工作。所需的唯一更改是使用<code class="codeph">loadDataWithSqlLdr()</code>替换API <code class="codeph">loadData()</code> ，并提供一些其他输入参数，例如SQL * Loader的位置。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-9E4F7C89-A28B-4F54-8132-C6F2F8395A6F__GUID-851A8312-923E-438F-B83C-A86998AE5449">基于SQL * Loader的并行数据加载使用微调</p>
                           <p>基于SQL Loader的数据加载支持微调要加载的行的数据子集，以及在将元素加载到属性图实例时使用的ID偏移。您可以通过指定从文件中读取的最大行数以及顶点和边的偏移行数来指定要从文件加载的数据子集。这样，数据将从偏移行号加载，直到读取最大行数。如果最大行数为-1，则加载过程将扫描数据，直到到达文件末尾。</p>
                           <p>由于图形数据文件可能存在一些ID冲突，因此基于SQL Loader的数据加载允许您定义顶点和边缘ID偏移。这样，每个加载顶点的ID将从具有给定顶点ID偏移的原始顶点ID的总和获得。类似地，将根据原始边缘ID与给定边缘ID偏移的总和来生成每个加载边缘的ID。请注意，顶点和边文件必须相关，因为加载边的入/出顶点ID将相对于指定的顶点ID偏移进行修改。仅在使用单个分区的数据加载中支持此操作。</p>
                           <p>以下代码片段从给定的图形数据文件加载前100个顶点和边。在此示例中，未提供ID偏移。</p><pre class="pre codeblock"><code>String szUser =“username”; String szPassword =“password”; String szDbId =“db18c”; / *数据库的服务名称* / String szOPVFile =“../../data/connections.opv“; String szOPEFile =”../../data/connections.ope“; String szSQLLoaderPath =”../ ../../dbhome_1/bin/sqlldr“; //使用微调long lVertexOffsetlines = 0运行数据加载; long lEdgeOffsetlines = 0; long lVertexMaxlines = 100; long lEdgeMaxlines = 100; long lVIDOffset = 0; long lEIDOffset = 0; OraclePropertyGraph opg = OraclePropertyGraph.getInstance（args，szGraphName）; OraclePropertyGraphDataLoader opgdl = OraclePropertyGraphDataLoader.getInstance（）; opgdl.loadDataWithSqlLdr（opg，szUser，szPassword，szDbId，szOPVFile，szOPEFile，lVertexOffsetlines / *从分区开始加载的行的偏移量，默认0 * /，lEdgeOffsetlines / *从分区开始加载的行的偏移量，默认为0 * /，lVertexMaxlines / *从分区开始加载的最大行数，默认为-1（分区中的所有行）* /，lEdgeMaxlines / * maximum从分区开始加载的行数，默认-1（分区中的所有行）* /，lVIDOffset / * vertex ID offset：顶点ID将是原始顶点ID +偏移量，默认为0 * /，lEIDOffset / *边缘ID偏移量：边缘ID将是原始边缘ID +偏移，默认为0 * /，48 / * DOP * /，1 / *分区总数，默认1 * /，0 / *要加载的分区（从0到totalPartitions  -  1，默认为0）* /，OraclePropertyGraphDataLoader。NAMEDPIPE / * splitter标志* /，“chunkPrefix”/ *前缀* /，szSQLLoaderPath / * SQL * Loader路径：bin / sqlldr的路径* /，true / * rebuild index * /，“pddl = t，pdml = t “/ *期权* /）;</code></pre></div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="using-property-graphs-oracle-database.html#GUID-6212D301-F439-4B4B-A36F-73194D404979">图形数据的并行加载</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div>
               <div class="props_rev_3"><a id="GUID-5CC8B971-DDCD-46CF-86EF-CDFD69E20FDC" name="GUID-5CC8B971-DDCD-46CF-86EF-CDFD69E20FDC"></a><h4 id="SPGDG-GUID-5CC8B971-DDCD-46CF-86EF-CDFD69E20FDC" class="sect4"><span class="enumeration_section">2.5.3</span>图形数据的并行检索</h4>
                  <div>
                     <p>并行属性图查询提供了一个简单的Java API，用于在顶点（或边）上执行并行扫描。并行检索是一种优化的解决方案，它利用跨表分区的数据分布，因此使用单独的数据库连接查询每个分区。</p>
                     <p>并行检索将生成一个数组，其中每个元素包含特定分区（拆分）的所有顶点（或边）。查询的分片子集将由给定的起始分割ID和提供的连接数组的大小分隔。这样，子集将考虑[start，start  -  1 +连接数组大小]范围内的拆分。注意，整数ID（在[0，N-1]范围内）被分配给具有N个分割的顶点表中的所有分割。</p>
                     <p>以下代码加载属性图，打开连接数组，并执行并行查询以使用打开的连接检索所有顶点和边。对<code class="codeph">getVerticesPartitioned (getEdgesPartitioned)</code>方法的调用次数由拆分总数和使用的连接数控制。
                     </p><pre class="pre codeblock"><code>OraclePropertyGraph opg = OraclePropertyGraph.getInstance（args，szGraphName）; //清除属性图中的现有顶点/边opg.clearRepository（）; String szOPVFile =“../../data/connections.opv“; String szOPEFile =”../../data/connections.ope“; //此对象将处理并行数据加载OraclePropertyGraphDataLoader opgdl = OraclePropertyGraphDataLoader.getInstance（）; opgdl.loadData（opg，szOPVFile，szOPEFile，dop）; //创建并行查询中使用的连接Oracle [] oracleConns = new Oracle [dop]; Connection [] conns = new Connection [dop]; for（int i = 0; i &lt;dop; i ++）{oracleConns [i] = opg.getOracle（）。clone（） ; conns [i] = oracleConns [i] .getConnection（）;} long lCountV = 0; //迭代所有顶点的partitionID来计算所有顶点（int partitionID = 0; partitionID &lt;opg.getVertexPartitionsNumber（）; partitionID + = dop）{Iterable &lt;Vertex&gt; [] iterables = opg.getVerticesPartitioned（conns / * Connection array * /，true / * skip store to cache * /，partitionID / * starting partition * /）; lCountV + = consumeIterables（ iterables）; / *使用线程消耗迭代* /} //计算所有顶点System.out.println（“使用并行查询找到的顶点：”+ lCountV）; long lCountE = 0; //迭代在所有边的partitionID上计算所有边（int partitionID = 0; partitionID &lt;opg.getEdgeTablePartitionIDs（）; partitionID + = dop）{Iterable &lt;Edge&gt; [] iterables = opg.getEdgesPartitioned（conns / * Connection array * /，true / * skip store to cache * /，partitionID / * starting partitionID * /）; lCountE + = consumeIterables（iterables）; / *使用线程消耗iterables * /} //计算所有边缘System.out.println（“使用并行查询找到边缘：”+ lCountE）; //完成后关闭与数据库的连接（int idx = 0; idx &lt;conns.length; idx ++）{conns [idx] .close（）; }</code></pre></div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="using-property-graphs-oracle-database.html#GUID-734D16D3-E8AA-4097-B644-14D80A4C7958" title="创建属性图涉及使用Java API在其中创建属性图和对象。">将Java API用于属性图数据</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="props_rev_3"><a id="GUID-216595F2-BBA0-4FAB-AC6C-1FDF25D46469" name="GUID-216595F2-BBA0-4FAB-AC6C-1FDF25D46469"></a><h4 id="SPGDG-GUID-216595F2-BBA0-4FAB-AC6C-1FDF25D46469" class="sect4"><span class="enumeration_section">2.5.4</span>使用元素过滤器回调子图提取</h4>
                  <div>
                     <p>Oracle Spatial and Graph使用用户定义的元素过滤器回调为简单的子图提取提供支持。元素过滤器回调定义了顶点（或边）必须满足的一组条件，以便将其保留在子图中。用户可以通过实现<code class="codeph">VertexFilterCallback</code>和<code class="codeph">EdgeFilterCallback</code> API接口来定义自己的元素过滤。
                     </p>
                     <p>以下代码片段实现了一个<code class="codeph">VertexFilterCallback</code> ，用于验证顶点是否具有政治角色且其来源是否为美国。
                     </p><pre class="oac_no_warn" dir="ltr">/ ** * VertexFilterCallback从美国*中检索没有政治角色的顶点* / private static class NonPoliticianFilterCallback实现VertexFilterCallback {@Override public boolean keepVertex（OracleVertexBase vertex）{String country = vertex.getProperty（“country” ）; String role = vertex.getProperty（“role”）;如果（国家！= null &amp;&amp; country.equals（“United States”））{if（role == null ||！role.toLowerCase（）。contains（“political”））{return true;返回false; public static NonPoliticianFilterCallback getInstance（）{return new NonPoliticianFilterCallback（）; }}</pre><p>下面的代码片段实现了一个<code class="codeph">EdgeFilterCallback</code> ，它使用<code class="codeph">VertexFilterCallback</code>只保留连接到给定输入顶点的边，并且其连接不是政治家，而是来自美国。
                     </p><pre class="oac_no_warn" dir="ltr">/ ** * EdgeFilterCallback检索连接到带有“collaborates”标签的输入*顶点的所有边，其顶点来自*美国，其角色不同于政治* / private静态类CollaboratorsFilterCallback实现EdgeFilterCallback {private VertexFilterCallback m_vfc; private Vertex m_startV; public CollaboratorsFilterCallback（VertexFilterCallback vfc，Vertex v）{m_vfc = vfc; m_startV = v; } @Override public boolean keepEdge（OracleEdgeBase edge）{if（“collaborates”.equals（edge.getLabel（）））{if（edge.getVertex（Direction。IN）.equals（m_startV）&amp;&amp; m_vfc.keepVertex（（OracleVertex）edge.getVertex（Direction。OUT）））{return true; } else if（edge.getVertex（Direction。OUT）.equals（m_startV）&amp;&amp; m_vfc.keepVertex（（OracleVertex）edge.getVertex（Direction。IN）））{return true;返回false; public static CollaboratorsFilterCallback getInstance（VertexFilterCallback vfc，Vertex v）{return new CollaboratorsFilterCallback（vfc，v）; }}</pre><p>使用先前定义的过滤器回调，以下代码片段加载属性图，创建过滤器回调的实例，然后获得所有非政治家并且来自美国的Barack Obama的合作者。</p><pre class="oac_no_warn" dir="ltr">OraclePropertyGraph opg = OraclePropertyGraph.getInstance（args，szGraphName）; //清除属性图中的现有顶点/边opg.clearRepository（）; String szOPVFile =“../../data/connections.opv“; String szOPEFile =”../../data/connections.ope“; //此对象将处理并行数据加载OraclePropertyGraphDataLoader opgdl = OraclePropertyGraphDataLoader.getInstance（）; opgdl.loadData（opg，szOPVFile，szOPEFile，dop）; // VertexFilterCallback从中检索所有人美国//谁不是政治家<span class="bold">NonPoliticianFilterCallback npvfc = NonPoliticianFilterCallback.getInstance（）;</span> //初始顶点：Barack Obama Vertex v = opg.getVertices（“name”，“Barack Obama”）。iterator（）。next（）; // EdgeFilterCallback检索Barack Obama的所有合作者//来自美国的非政治家<span class="bold">CollaboratorsFilterCallback cefc = CollaboratorsFilterCallback.getInstance（npvfc，v）;</span> Iterable &lt;&lt; Edge&gt; obamaCollabs = <span class="bold">opg.getEdges（（String []）null / *匹配任何属性* /，cefc / *匹配EdgeFilterCallback * /）;</span>迭代器&lt;&lt; Edge&gt; iter = obamaCollabs.iterator（）; System.out.println（“\ n \ n ------- - 来自美国“+”的巴拉克·奥巴马的指导者和非政治家\ n \ n“）;长计数V = 0; whi le（iter.hasNext（））{Edge edge = iter.next（）; //获取边缘//检查obama是否为IN顶点if（edge.getVertex（Direction。IN）.equals（v））{System.out.println（edge.getVertex（Direction。OUT）+“（边缘ID：”+ edge.getId（）+“）”）; // get out vertex} else {System.out.println（edge.getVertex（Direction。IN）+“（边缘ID：”+ edge.getId（）+“）”）; //进入顶点} countV ++; }</pre><p>默认情况下，所有读取操作（如获取所有顶点，获取所有边（和并行方法））将使用与属性图关联的过滤器回调，使用方法<code class="codeph">opg.setVertexFilterCallback(vfc)</code>和<code class="codeph">opg.setEdgeFilterCallback(efc)</code> 。如果没有过滤器回调集，则将检索所有顶点（或边）和边。
                     </p>
                     <p>以下代码片段使用属性图上设置的默认边缘过滤器回调来检索边。</p><pre class="oac_no_warn" dir="ltr">// VertexFilterCallback来检索来自美国的所有人//谁不是政治家<span class="bold">NonPoliticianFilterCallback npvfc = NonPoliticianFilterCallback.getInstance（）;</span> //初始顶点：Barack Obama Vertex v = opg.getVertices（“name”，“Barack Obama”）。iterator（）。next（）; // EdgeFilterCallback检索Barack Obama的所有合作者//来自美国的非政治家<span class="bold">CollaboratorsFilterCallback cefc = CollaboratorsFilterCallback.getInstance（npvfc，v）; opg.setEdgeFilterCallback（CEFC）;</span> Iterable &lt;Edge&gt; obamaCollabs = <span class="bold">opg.getEdges（）</span> ; Iterator &lt;Edge&gt; iter = obamaCollabs.iterator（）; System.out.println（“\ n \ n -------- Barack Obama的合作者来自”+“美国和非政治家\ n \ n”）; long countV = 0; while（iter.hasNext（））{Edge edge = iter.next（）; //获取边缘//检查obama是否为IN顶点if（edge.getVertex（Direction。IN）.equals（v））{System.out.println（edge.getVertex（Direction。OUT）+“（边缘ID：”+ edge.getId（）+“）”）; // get out vertex} else {System.out.println（edge.getVertex（Direction。IN）+“（边缘ID：”+ edge.getId（）+“）”）; //进入顶点} countV ++; }</pre></div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="using-property-graphs-oracle-database.html#GUID-734D16D3-E8AA-4097-B644-14D80A4C7958" title="创建属性图涉及使用Java API在其中创建属性图和对象。">将Java API用于属性图数据</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="props_rev_3"><a id="GUID-D33E2232-BE9C-444D-BC5C-2B4E62CAF2C4" name="GUID-D33E2232-BE9C-444D-BC5C-2B4E62CAF2C4"></a><h4 id="SPGDG-GUID-D33E2232-BE9C-444D-BC5C-2B4E62CAF2C4" class="sect4"><span class="enumeration_section">2.5.5</span>在读取属性图数据时使用优化标志</h4>
                  <div>
                     <p>Oracle Spatial and Graph为优化标志提供支持，以提高图迭代性能。优化标志允许将顶点（或边）处理为没有或具有最小信息的对象，例如ID，标签和/或传入/传出顶点。这样，减少了在迭代期间处理每个顶点（或边缘）所需的时间。</p>
                     <p>下表显示了在处理属性图中的顶点（或边）时可用的优化标志。</p>
                     <div class="tblformal" id="GUID-D33E2232-BE9C-444D-BC5C-2B4E62CAF2C4__OPTIMIZATIONFLAGSANDDESCRIPTIONSFOR-110D35B6">
                        <table cellpadding="4" cellspacing="0" class="Formal" title="" border="1" summary="Optimization flags and descriptions for processing vertices (or edges) in a property graph. Column 1 is Optimization Flags and column 2 is Description." frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="20%" id="d4109e2779"><span class="bold">优化标志</span></th>
                                 <th align="left" valign="bottom" width="20%" id="d4109e2782"><span class="bold">描述</span></th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="20%" id="d4109e2787" headers="d4109e2779 ">DO_NOT_CREATE_OBJECT</td>
                                 <td align="left" valign="top" width="20%" headers="d4109e2787 d4109e2782 ">处理顶点或边时使用预定义的常量对象。</td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="20%" id="d4109e2792" headers="d4109e2779 ">JUST_EDGE_ID</td>
                                 <td align="left" valign="top" width="20%" headers="d4109e2792 d4109e2782 ">仅在处理边时使用ID构造边对象。</td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="20%" id="d4109e2797" headers="d4109e2779 ">JUST_LABEL_EDGE_ID</td>
                                 <td align="left" valign="top" width="20%" headers="d4109e2797 d4109e2782 ">仅在处理边时使用ID和标签构造边对象。</td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="20%" id="d4109e2802" headers="d4109e2779 ">JUST_LABEL_VERTEX_EDGE_ID</td>
                                 <td align="left" valign="top" width="20%" headers="d4109e2802 d4109e2782 ">仅在处理边时，使用ID，标签和输入/输出顶点ID构造边对象</td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="20%" id="d4109e2807" headers="d4109e2779 ">JUST_VERTEX_EDGE_ID</td>
                                 <td align="left" valign="top" width="20%" headers="d4109e2807 d4109e2782 ">处理边时，使用ID和输入/输出顶点ID构造边对象。</td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="20%" id="d4109e2812" headers="d4109e2779 ">JUST_VERTEX_ID</td>
                                 <td align="left" valign="top" width="20%" headers="d4109e2812 d4109e2782 ">仅在处理顶点时使用ID构造顶点对象。</td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <p>以下代码片段使用一组优化标志来仅检索属性图中顶点和边的所有ID。通过读取所有顶点和边缘检索的对象将仅包含ID，不包含键/值属性或其他信息。</p><pre class="oac_no_warn" dir="ltr">导入oracle.pg.common。OraclePropertyGraphBase。OptimizationFlag; OraclePropertyGraph opg = OraclePropertyGraph.getInstance（args，szGraphName）; //清除属性图中的现有顶点/边opg.clearRepository（）; String szOPVFile =“../../data/connections.opv“; String szOPEFile =”../../data/connections.ope“; //此对象将处理并行数据加载OraclePropertyGraphDataLoader opgdl = OraclePropertyGraphDataLoader.getInstance（）; opgdl.loadData（opg，szOPVFile，szOPEFile，dop）; //优化标志仅检索顶点IDs <span class="bold">OptimizationFlag optFlagVertex = OptimizationFlag。JUST_VERTEX_ID;</span> //仅检索边ID的优化标志<span class="bold">OptimizationFlag optFlagEdge = OptimizationFlag。JUST_EDGE_ID;</span> //打印所有顶点迭代器&lt;顶点&gt;顶点= <span class="bold">opg.getVertices（（String []）null / *匹配任何属性* /，null / *匹配VertexFilterCallback * /，optFlagVertex / * optimization flag * /。.iterator （）;</span> System.out.println（“----- Vertices IDs ----”）; long vCount = 0; while（vertices.hasNext（））{OracleVertex v = vertices.next（）; System.out.println（（Long）v.getId（））; vCount ++; System.out.println（“Vertices found：”+ vCount）; //打印所有边Iterator &lt;Edge&gt; edges = <span class="bold">opg.getEdges（（String []）null / *匹配任何属性* /，null / *匹配EdgeFilterCallback * /，optFlagEdge / * optimization flag * /）.iterator （）;</span> System.out.println（“----- Edges ----”）; long eCount = 0; while（edges.hasNext（））{Edge e = edges.next（）; System.out.println（（Long）e.getId（））; eCount ++; System.out.println（“Edges found：”+ eCount）;</pre><p>默认情况下，使用方法<code class="codeph">opg.setDefaultVertexOptFlag(optFlagVertex)</code>和<code class="codeph">opg.setDefaultEdgeOptFlag(optFlagEdge)</code>等所有读取操作（如获取所有顶点，获取所有边（和并行方法））将使用与属性图关联的优化标记。如果未定义用于处理顶点和边的优化标志，则将检索关于顶点和边的所有信息。
                     </p>
                     <p>以下代码片段使用属性图上设置的默认优化标志来仅从其顶点和边缘检索所有ID。</p><pre class="oac_no_warn" dir="ltr">导入oracle.pg.common。OraclePropertyGraphBase。OptimizationFlag; //优化标志，仅检索顶点ID OptimizationFlag optFlagVertex = OptimizationFlag。JUST_VERTEX_ID; //仅检索边ID的优化标志OptimizationFlag optFlagEdge = OptimizationFlag。JUST_EDGE_ID; <span class="bold">opg.setDefaultVertexOptFlag（optFlagVertex）; opg.setDefaultEdgeOptFlag（optFlagEdge）;</span> Iterator &lt;Vertex&gt; vertices = <span class="bold">opg.getVertices（）。iterator（）;</span> System.out.println（“----- Vertices IDs ----”）; long vCount = 0; while（vertices.hasNext（））{OracleVertex v = vertices.next（）; System.out.println（（Long）v.getId（））; vCount ++; System.out.println（“Vertices found：”+ vCount）; //打印所有边Iterator &lt;Edge&gt; edges = <span class="bold">opg.getEdges（）。iterator（）;</span> System.out.println（“----- Edges ----”）; long eCount = 0; while（edges.hasNext（））{Edge e = edges.next（）; System.out.println（（Long）e.getId（））; eCount ++; System.out.println（“Edges found：”+ eCount）;</pre></div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="using-property-graphs-oracle-database.html#GUID-734D16D3-E8AA-4097-B644-14D80A4C7958" title="创建属性图涉及使用Java API在其中创建属性图和对象。">将Java API用于属性图数据</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="props_rev_3"><a id="GUID-991EA4C2-1DC0-413F-BF3C-D7B71537AA36" name="GUID-991EA4C2-1DC0-413F-BF3C-D7B71537AA36"></a><h4 id="SPGDG-GUID-991EA4C2-1DC0-413F-BF3C-D7B71537AA36" class="sect4"><span class="enumeration_section">2.5.6</span>添加和删除属性图子图的属性</h4>
                  <div>
                     <p>Oracle Spatial and Graph支持使用用户自定义的操作回调将属性（键/值对）更新为顶点和/或边的子图。操作回调定义顶点（或边）必须满足的一组条件才能更新它（添加或删除给定的属性和值）。</p>
                     <p>您可以通过实现<code class="codeph">VertexOpCallback</code>和<code class="codeph">EdgeOpCallback</code> API接口来定义自己的属性操作。您必须覆盖<code class="codeph">needOp</code>方法，该方法定义要包含在更新操作中的顶点（或边）要满足的条件，以及<code class="codeph">getAttributeKeyName</code>和<code class="codeph">getAttributeKeyValue</code>方法，它们分别返回键名和值，更新元素时使用。
                     </p>
                     <p>以下代码片段实现了一个<code class="codeph">VertexOpCallback</code> ， <code class="codeph">obamaCollaborator</code>属性进行操作，该属性仅与Barack Obama合作者相关联。此属性的值是根据协作者的角色指定的。
                     </p><pre class="oac_no_warn" dir="ltr">private static class CollaboratorsVertexOpCallback <span class="bold">实现VertexOpCallback</span> {private OracleVertexBase m_obama; private List &lt;Vertex&gt; m_obamaCollaborators; public CollaboratorsVertexOpCallback（OraclePropertyGraph opg）{//获取Barack Obama'sCollaborators的列表m_obama =（OracleVertexBase）opg.getVertices（“name”，“Barack Obama”）.iterator（）。next（）; Iterable &lt;Vertex&gt; iter = m_obama.getVertices（Direction。同时，“合作”）; m_obamaCollaborators = OraclePropertyGraphUtils.listify（iter）; public static CollaboratorsVertexOpCallback getInstance（OraclePropertyGraph opg）{return new CollaboratorsVertexOpCallback（opg）; } / ** *当且仅当顶点是Barack * Obama * / <span class="bold">@Override</span>公共布尔<span class="bold">needOp（OracleVertexBase v）</span>的合作者时才添加属性{return m_obamaCollaborators！= null &amp;&amp; m_obamaCollaborators.contains（v）; } @Override public String <span class="bold">getAttributeKeyName（OracleVertexBase v）</span> {return“obamaCollaborator”; } / ** *根据顶点角色定义属性的值* / @Override public Object <span class="bold">getAttributeKeyValue（OracleVertexBase v）</span> {String role = v.getProperty（“role”）; role = role.toLowerCase（）; if（role.contains（“political”））{return“political”; } else if（role.contains（“actor”）|| role.contains（“singer”）|| role.contains（“actress”）|| role.contains（“writer”）|| role.contains（“producer “）|| role.contains（”director“））{return”arts“; } else if（role.contains（“player”））{return“sports”; } else if（role.contains（“journalist”））{return“newsism”; } else if（role.contains（“business”）|| role.contains（“economist”））{return“business”; } else if（role.contains（“philanthropist”））{return“philanthropy”; } return“”; }}</pre><p>以下代码片段实现了一个<code class="codeph">EdgeOpCallback</code> ， <code class="codeph">obamaFeud</code>属性进行操作，该属性仅与Barack Obama的不和。此属性的值是根据协作者的角色指定的。
                     </p><pre class="oac_no_warn" dir="ltr">私有静态类FeudsEdgeOpCallback <span class="bold">实现EdgeOpCallback</span> {private OracleVertexBase m_obama;私人清单&lt;Edge&gt; m_obamaFeuds; public FeudsEdgeOpCallback（OraclePropertyGraph opg）{//获取巴拉克奥巴马的不和之列表m_obama =（OracleVertexBase）opg.getVertices（“name”，“Barack Obama”）.iterator（）。next（）; Iterable &lt;Vertex&gt; iter = m_obama.getVertices（Direction。同时，“不和”）; m_obamaFeuds = OraclePropertyGraphUtils.listify（iter）; public static FeudsEdgeOpCallback getInstance（OraclePropertyGraph opg）{return new FeudsEdgeOpCallback（opg）; } / ** *当且仅当边缘位于Barack Obama的* <span class="bold">feuds</span> * / <span class="bold">@Override</span>公共布尔<span class="bold">needOp（OracleEdgeBase e）</span>列表中时才添加属性{return m_obamaFeuds！= null &amp;&amp; m_obamaFeuds.contains（e）; } @Override public String <span class="bold">getAttributeKeyName（OracleEdgeBase e）</span> {return“obamaFeud”; } / ** *根据输入/输出顶点角色定义属性的值* / @Override public Object <span class="bold">getAttributeKeyValue（OracleEdgeBase e）</span> {OracleVertexBase v =（OracleVertexBase）e.getVertex（Direction。在）; if（m_obama.equals（v））{v =（OracleVertexBase）e.getVertex（Direction。OUT）; } String role = v.getProperty（“role”）; role = role.toLowerCase（）; if（role.contains（“political”））{return“political”; } else if（role.contains（“actor”）|| role.contains（“singer”）|| role.contains（“actress”）|| role.contains（“writer”）|| role.contains（“producer “）|| role.contains（”director“））{return”arts“; } else if（role.contains（“journalist”））{return“newsism”; } else if（role.contains（“player”））{return“sports”; } else if（role.contains（“business”）|| role.contains（“economist”））{return“business”; } else if（role.contains（“philanthropist”））{return“philanthropy”; } return“”; }}</pre><p>使用先前定义的操作回调，以下代码片段加载属性图，创建操作回调的实例，然后使用<code class="codeph">OraclePropertyGraph</code>的<code class="codeph">addAttributeToAllVertices</code>和<code class="codeph">addAttributeToAllEdges</code>方法将属性添加到相关的顶点和边。
                     </p><pre class="oac_no_warn" dir="ltr">OraclePropertyGraph opg = OraclePropertyGraph.getInstance（args，szGraphName）; //清除属性图中的现有顶点/边opg.clearRepository（）; String szOPVFile =“../../data/connections.opv“; String szOPEFile =”../../data/connections.ope“; //此对象将处理并行数据加载OraclePropertyGraphDataLoader opgdl = OraclePropertyGraphDataLoader.getInstance（）; opgdl.loadData（opg，szOPVFile，szOPEFile，dop）; //创建顶点操作回调<span class="bold">CollaboratorsVertexOpCallback cvoc = CollaboratorsVertexOpCallback.getInstance（opg）;</span> //根据角色<span class="bold">opg.addAttributeToAllVertices（cvoc，true / **跳过存储到Cache * /，dop）</span>为所有与Obama合作的人添加属性<span class="bold">;</span> //查找所有协作者of Obama Iterable &lt;Vertex&gt; collaborators = opg.getVertices（“obamaCollaborator”，“political”）; System.out.println（“Barack Obama的政治合作者”+ getVerticesAsString（合作者））; collaborators = opg.getVertices（“obamaCollaborator”） ，“business”）; System.out.println（“Barack Obama的业务合作者”+ getVerticesAsString（合作者））; //为所有与Barack Obama发生争执的人添加一个属性来设置他们所拥有的关系类型<span class="bold">FeudsEdgeOpCallba ck feoc = FeudsEdgeOpCallback.getInstance（opg）; opg.addAttributeToAllEdges（feoc，true / **跳过存储到Cache * /，dop）;</span> //查看奥巴马的所有争执Irablerable &lt;Edge&gt; feuds = opg.getEdges（“obamaFeud”，“political”）; System.out.println（“\ n \ n巴拉克奥巴马的政治争执”+ getEdgesAsString（feuds））; feuds = opg.getEdges（“obamaFeud”，“business”）; System.out.println（“巴拉克奥巴马的商业纠纷”+ getEdgesAsString（feuds））;</pre><p>以下代码片段定义了<code class="codeph">VertexOpCallback</code>的实现，该实现可用于删除属性<code class="codeph">obamaCollaborator</code>具有慈善价值的顶点，然后调用API <code class="codeph">removeAttributeFromAllVertices</code> ;它还定义了<code class="codeph">EdgeOpCallback</code>的实现，可用于删除具有属性<code class="codeph">obamaFeud</code>值业务的<code class="codeph">obamaFeud</code> ，然后调用API <code class="codeph">removeAttributeFromAllEdges</code> 。
                     </p><pre class="oac_no_warn" dir="ltr">System.out.println（“\ n \ n删除所有”+“慈善合作者的'obamaCollaborator'属性”）; PhilanthropyCollaboratorsVertexOpCallback pvoc = PhilanthropyCollaboratorsVertexOpCallback.getInstance（）; <span class="bold">opg.removeAttributeFromAllVertices（PVOC）;</span> System.out.println（“\ n \ n从所有”+“商业世仇中删除'obamaFeud'属性”）; BusinessFeudsEdgeOpCallback beoc = BusinessFeudsEdgeOpCallback.getInstance（）; <span class="bold">opg.removeAttributeFromAllEdges（beoc）;</span> / ** *实施EdgeOpCallback以从所有与Barack Obama合作的人员中删除“obamaCollaborators”属性*具有*慈善角色* /私有静态类PhilanthropyCollaboratorsVertexOpCallback实现VertexOpCallback {public static PhilanthropyCollaboratorsVertexOpCallback getInstance（）{return new PhilanthropyCollaboratorsVertexOpCallback（） ; } / ** *当且仅当* obamaCollaborator的属性值为Philanthropy * / @Override public boolean needOp（OracleVertexBase v）{String type = v.getProperty（“obamaCollaborator”）时才删除属性;返回类型！= null &amp;&amp; type.equals（“philanthropy”）; } @Override public String getAttributeKeyName（OracleVertexBase v）{return“obamaCollaborator”; } / ** *定义属性的值。在这种情况下可以为空* / @Override public Object getAttributeKeyValue（OracleVertexBase v）{return“”; / * *实现EdgeOpCallback以从Barack Obama与业务角色* /私有静态类的不和中的所有连接中删除“obamaFeud”属性* BusinessFeudsEdgeOpCallback实现EdgeOpCallback {public static BusinessFeudsEdgeOpCallback getInstance（）{return new BusinessFeudsEdgeOpCallback（）; } / ** *当且仅当obamaFeud的属性值为* business * / @Override public boolean needOp（OracleEdgeBase e）{String type = e.getProperty（“obamaFeud”）时才删除属性;返回类型！= null &amp;&amp; type.equals（“business”）; } @Override public String getAttributeKeyName（OracleEdgeBase e）{return“obamaFeud”; } / ** *定义属性的值。在这种情况下可以为空* / @Override public Object getAttributeKeyValue（OracleEdgeBase e）{return“”; }}</pre></div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="using-property-graphs-oracle-database.html#GUID-734D16D3-E8AA-4097-B644-14D80A4C7958" title="创建属性图涉及使用Java API在其中创建属性图和对象。">将Java API用于属性图数据</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="props_rev_3"><a id="GUID-F97996AC-8DE0-4F8A-9789-09FF1A473B68" name="GUID-F97996AC-8DE0-4F8A-9789-09FF1A473B68"></a><h4 id="SPGDG-GUID-F97996AC-8DE0-4F8A-9789-09FF1A473B68" class="sect4"><span class="enumeration_section">2.5.7</span>获取属性图元数据</h4>
                  <div>
                     <p>您可以获取图形元数据和统计信息，例如数据库中的所有图形名称;对于每个图形，获取最小/最大顶点ID，最小/最大边缘ID，顶点属性名称，边缘属性名称，图形顶点中的分割数以及支持并行表扫描的边缘表。</p>
                     <p>以下代码片段获取存储在Oracle数据库中的现有属性图的元数据和统计信息。</p><pre class="oac_no_warn" dir="ltr">//获取数据库中的所有图形名称List &lt;String&gt; graphNames = OraclePropertyGraphUtils.getGraphNames（dbArgs）; for（String graphName：graphNames）{OraclePropertyGraph opg = OraclePropertyGraph.getInstance（args，graphName）; System.err.println（“\ n图形名称：”+ graphName）; System.err.println（“总顶点：”+ <span class="bold">opg.countVertices（dop）</span> ）; System.err.println（“Minimum Vertex ID：”+ <span class="bold">opg.getMinVertexID（dop）</span> ）; System.err.println（“Maximum Vertex ID：”+ <span class="bold">opg.getMaxVertexID（dop）</span> ）;设置&lt;String&gt; propertyNamesV = new HashSet &lt;String&gt;（）; <span class="bold">opg.getVertexPropertyNames（dop，0 / * timeout，0 no timeout * /，propertyNamesV）;</span> System.err.println（“Vertices属性名称：”+ getPropertyNamesAsString（propertyNamesV））; System.err.println（“\ n \ n总边数：”+ <span class="bold">opg.countEdges（dop）</span> ）; System.err.println（“Minimum Edge ID：”+ <span class="bold">opg.getMinEdgeID（dop）</span> ）; System.err.println（“Maximum Edge ID：”+ <span class="bold">opg.getMaxEdgeID（dop）</span> ）;设置&lt;String&gt; propertyNamesE = new HashSet &lt;String&gt;（）; <span class="bold">opg.getEdgePropertyNames（dop，0 / * timeout，0 no timeout * /，propertyNamesE）;</span> System.err.println（“Edge属性名称：”+ getPropertyNamesAsString（propertyNamesE））; System.err.println（“\ n \ n表信息：”）; System.err.println（“Vertex表分割数：”+（ <span class="bold">opg.getVertexPartitionsNumber（）</span> ））; System.err.println（“边缘表分割数：”+（ <span class="bold">opg.getEdgePartitionsNumber（）</span> ））; }</pre></div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="using-property-graphs-oracle-database.html#GUID-734D16D3-E8AA-4097-B644-14D80A4C7958" title="创建属性图涉及使用Java API在其中创建属性图和对象。">将Java API用于属性图数据</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="sect3"><a id="GUID-0D1255E4-CE0B-4E2F-B78F-BAF569B7DE43" name="GUID-0D1255E4-CE0B-4E2F-B78F-BAF569B7DE43"></a><h4 id="SPGDG-GUID-0D1255E4-CE0B-4E2F-B78F-BAF569B7DE43" class="sect4"><span class="enumeration_section">2.5.8</span>将新数据合并到现有属性图中</h4>
                  <div>
                     <p>除了将图形数据加载到Oracle数据库中的空属性图之外，还可以将新图形数据合并到现有（空或非空）图形中。与数据加载一样，数据合并将输入顶点和边缘拆分为多个块，并将它们与数据库中的现有图形并行合并。</p>
                     <p>在进行合并时，流程不同取决于新图形数据与现有图形数据之间是否存在重叠。这里<span class="italic">重叠</span>意味着图元素的相同键在新图形数据和现有图形数据中可能具有不同的值。例如，具有ID 1的顶点的密钥<code class="codeph">weight</code>可以在新图形数据中具有值0.8并且在现有图形数据中具有值0.5。在这种情况下，您必须指定是否应将新值或现有值用于密钥。
                     </p>
                     <p>以下选项可用于图形数据合并：基于JDB，基于外部表和基于SQL加载器的合并。</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>基于JDBC的图形数据合并</p>
                        </li>
                        <li>
                           <p>外部基于表的数据合并</p>
                        </li>
                        <li>
                           <p>基于SQL Loader的数据合并</p>
                        </li>
                     </ul>
                     <div class="section">
                        <p class="subhead3" id="GUID-0D1255E4-CE0B-4E2F-B78F-BAF569B7DE43__GUID-07A0DCE7-4127-4DC3-99C0-F18429F9BF7A"><span class="bold">基于JDBC的图形数据合并</span></p>
                        <p>基于JDBC的数据合并使用Java数据库连接（JDBC）API将新图形数据加载到Oracle数据库中，然后将新图形数据合并到现有图形中。</p>
                        <p>下面的示例使用基于JDBC的数据合并DOP（并行度）为48，批处理，将Oracle定义的平面文件格式的顶点和边文件szOPVFile和szOPEFile中的新图形数据与名为opg的现有图形合并。大小为1000，以及指定的数据合并选项。</p><pre class="pre codeblock"><code>String szOPVFile =“../../data/connectionsNew.opv“; String szOPEFile =”../../data/connectionsNew.ope“; OraclePropertyGraphDataLoader opgdl = OraclePropertyGraphDataLoader.getInstance（）; opgdl.mergeData（opg，szOPVFile，szOPEFile，48 / * DOP * /，1000 / *批量大小* /，真/ *重建索引* /，“pdml = t，pddl = t，no_dup = t，use_new_val_for_dup_key = t”/ *合并选项* /）;</code></pre><p>为了优化数据合并操作的性能，在调用基于JDBC的数据合并时，可以在mergeging options参数中指定一组标志和提示。这些提示包括：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><span class="bold">DOP：</span>合并数据时使用的并行度。此参数确定拆分文件时生成的块数，以及将数据合并到属性图VT $和GE $表时要使用的加载程序线程数。
                              </p>
                           </li>
                           <li>
                              <p><span class="bold">批处理大小：</span>一个整数，指定在批处理模式下用于Oracle JDBC语句的批处理大小。
                              </p>
                           </li>
                           <li>
                              <p><span class="bold">重建索引：</span>如果设置为true，则数据加载器将禁用在将加载数据的属性图上定义的所有索引和约束。将所有数据合并到属性图中后，将重建并启用所有原始索引和约束。
                              </p>
                           </li>
                           <li>
                              <p><span class="bold">合并选项：</span>用于优化数据合并操作的选项（或用逗号分隔的多个选项）。这些选项包括：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>PDML = T：为数据加载器中使用的数据库会话启用DML操作的并行执行。此提示用于提高长时间运行的批处理作业的性能。</p>
                                 </li>
                                 <li>
                                    <p>PDDL = T：为数据加载器中使用的数据库会话启用DDL操作的并行执行。此提示用于提高长时间运行的批处理作业的性能。</p>
                                 </li>
                                 <li>
                                    <p>NO_DUP = T：假设输入的新图形数据没有无效的重复项。在有效的属性图中，每个顶点（或边）最多只能有一个给定属性键的值。在无效的属性图中，顶点（或边）可能具有特定键的两个或多个值。例如，顶点v具有两个键/值对：name /“John”和name /“Johnny”，它们共享相同的键。</p>
                                 </li>
                                 <li>
                                    <p>OVERLAP = F：假设新图形数据与现有图形数据之间没有重叠。也就是说，在新的和现有的图数据中没有具有多个不同值的键。</p>
                                 </li>
                                 <li>
                                    <p>USE_NEW_VAL_FOR_DUP_KEY = T：如果新图形数据与现有图形数据之间存在重叠，请使用新图形数据中的值;否则，使用现有图表数据中的值。</p>
                                 </li>
                              </ul>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-0D1255E4-CE0B-4E2F-B78F-BAF569B7DE43__GUID-A8348A05-4186-4F56-81B8-34EA0619655D">外部基于表的数据合并</p>
                        <p>基于外部表的数据合并使用外部表将新图形数据加载到Oracle数据库中，然后将新图形数据合并到现有图形中。</p>
                        <p>基于外部表的数据合并需要一个目录对象，其中将存储外部表读取的文件。可以使用以下SQL * Plus语句创建此目录：</p><pre class="pre codeblock"><code>创建或替换目录tmp_dir为'/ tmppath /';授予读取权限，将目录tmp_dir写入公共;</code></pre><p>以下示例使用基于外部表的数据合并，DOP（并行度）为48，以及指定的合并，将Oracle平面文件格式的顶点和边文件szOPVFile和szOPEFile中的新图形数据与现有图形opg合并选项。</p><pre class="pre codeblock"><code>String szOPVFile =“../../data/connectionsNew.opv“; String szOPEFile =”../../data/connectionsNew.ope“; String szExtDir =”tmp_dir“; OraclePropertyGraphDataLoader opgdl = OraclePropertyGraphDataLoader.getInstance（）; opgdl.mergeDataWithExtTab（opg，szOPVFile，szOPEFile，48 / * DOP * /，true / *使用命名管道用于拆分* /， <span class="bold">szExtDir</span> / *数据库目录对象* /，true / *重建索引* /，“pdml = t，pddl = t，no_dup = t，use_new_val_for_dup_key = t”/ *合并选项* /）;</code></pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-0D1255E4-CE0B-4E2F-B78F-BAF569B7DE43__GUID-C82B523A-464D-4F87-9FF5-FB339054B275">基于SQL Loader的数据合并</p>
                        <p>基于SQL加载器的数据合并使用Oracle SQL * Loader将新图形数据加载到Oracle数据库中，然后将新图形数据合并到现有图形中。</p>
                        <p>下面的示例将来自顶级和边缘文件szOPVFile和szOPEFile的新图形数据以Oracle平面文件格式与现有图形opg合并，使用基于SQL加载器的数据合并，DOP（并行度）为48，并指定合并选项。要使用API，需要指定SQL * Loader的路径。</p><pre class="pre codeblock"><code>String szUser =“username”; String szPassword =“password”; String szDbId =“db18c”; / *数据库的服务名称* / String szOPVFile =“../../data/connectionsNew.opv“; 0 String szOPEFile =”../../data/connectionsNew.ope“; String szSQLLoaderPath =”&lt;YOUR_ORACLE_HOME&gt; / bin / sqlldr“; OraclePropertyGraphDataLoader opgdl = OraclePropertyGraphDataLoader.getInstance（）; opgdl.mergeDataWithSqlLdr（opg，szUser，szPassword，szDbId，szOPVFile，szOPEFile，48 / * DOP * /，true / *使用命名管道进行拆分* /，szSQLLoaderPath / * SQL * Loader路径：bin / sqlldr的路径* /，true / *重建索引* /，“pdml = t，pddl = t ，no_dup = t，use_new_val_for_dup_key = t“/ *合并选项* /）;</code></pre></div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="using-property-graphs-oracle-database.html#GUID-734D16D3-E8AA-4097-B644-14D80A4C7958" title="创建属性图涉及使用Java API在其中创建属性图和对象。">将Java API用于属性图数据</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="props_rev_3"><a id="GUID-4B2A2CB6-FE53-4C92-A915-4673D355F470" name="GUID-4B2A2CB6-FE53-4C92-A915-4673D355F470"></a><h4 id="SPGDG-GUID-4B2A2CB6-FE53-4C92-A915-4673D355F470" class="sect4"><span class="enumeration_section">2.5.9</span>打开和关闭属性图实例</h4>
                  <div>
                     <p>在描述属性图时，使用这些Oracle Property Graph类正确打开和关闭属性图实例：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">OraclePropertyGraph.getInstance</code> ：打开Oracle属性图的实例。此方法有两个参数，连接信息和图形名称。连接信息的格式取决于您是使用HBase还是Oracle NoSQL Database作为后端数据库。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">OraclePropertyGraph.clearRepository</code> ：从属性图实例中删除所有顶点和边。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">OraclePropertyGraph.shutdown</code> ：关闭图形实例。
                           </p>
                        </li>
                     </ul>
                     <p>对于Oracle数据库， <code class="codeph">OraclePropertyGraph.getInstance</code>方法使用Oracle实例来管理数据库连接。<code class="codeph">OraclePropertyGraph</code>有一组构造函数，可用于设置图形名称，散列分区数，并行度，表空间和存储选项（如压缩）。例如：</p><pre class="pre codeblock"><code>import oracle.pg.rdbms。*; Oracle oracle = new Oracle（jdbcURL，用户名，密码）; OraclePropertyGraph opg = OraclePropertyGraph.getInstance（oracle，graphName）; opg.clearRepository（）; ////图表说明//。//关闭图形实例opg.shutdown（）;</code></pre><p>如果应用程序需要内存<code class="codeph">GraphConfigBuilder</code>函数，则应使用<code class="codeph">GraphConfigBuilder</code>为Oracle数据库创建图形，并使用该图形名称作为参数实例化<code class="codeph">OraclePropertyGraph</code> 。例如，以下代码片段构造图形<code class="codeph">config</code> ，获取<code class="codeph">OraclePropertyGraph</code>实例，将一些数据加载到该图形中，并获取内存<code class="codeph">OraclePropertyGraph</code> 。
                     </p><pre class="pre codeblock"><code>import oracle.pgx.config。*; import oracle.pgx.api。*;导入oracle.pgx.common.types。*; ...PgNosqlGraphConfig cfg = GraphConfigBuilder。 forPropertyGraphRdbms（）。setJdbcUrl（“jdbc：oracle：thin：@ &lt;hostname&gt;：1521：&lt;sid&gt;”）。setUsername（“&lt;username&gt;”）。setPassword（“&lt;password&gt;”）。setName（szGraphName）.setMaxNumConnections （8）.addEdgeProperty（“lbl”，PropertyType。STRING，“lbl”）。addEdgeProperty（“weight”，PropertyType。DOUBLE，“1000000”）。build（）; OraclePropertyGraph opg = OraclePropertyGraph.getInstance（cfg）; String szOPVFile =“../../data/connections.opv“; String szOPEFile =”../../data/connections.ope“; //执行并行数据加载OraclePropertyGraphDataLoader opgdl = OraclePropertyGraphDataLoader.getInstance（）; opgdl.loadData（opg，szOPVFile，szOPEFile，2 / * dop * /，1000，true，”PDML = T，PDDL = T，NO_DUP = T，“）; ...PgxSession session = Pgx.createSession（“session-id-1”）; PgxGraph g = session.readGraphWithProperties（cfg）;分析师分析师= session.createAnalyst（）; ...
</code></pre></div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="using-property-graphs-oracle-database.html#GUID-734D16D3-E8AA-4097-B644-14D80A4C7958" title="创建属性图涉及使用Java API在其中创建属性图和对象。">将Java API用于属性图数据</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="props_rev_3"><a id="GUID-08F8D5A9-F070-487A-A4E2-221CDDA39344" name="GUID-08F8D5A9-F070-487A-A4E2-221CDDA39344"></a><h4 id="SPGDG-GUID-08F8D5A9-F070-487A-A4E2-221CDDA39344" class="sect4"><span class="enumeration_section">2.5.10</span>创建顶点</h4>
                  <div>
                     <p>要创建顶点，请使用以下Oracle Property Graph方法：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">OraclePropertyGraph.addVertex</code> ：将一个顶点实例添加到图形中。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">OracleVertex.setProperty</code> ：为顶点指定键值属性。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">OraclePropertyGraph.commit</code> ：保存对属性图实例的所有更改。
                           </p>
                        </li>
                     </ul>
                     <p>以下代码片段创建两个名为<code class="codeph">V1</code>和<code class="codeph">V2</code>顶点，其中包含<code class="codeph">opg</code>属性图实例中的年龄，名称，重量，高度和性别的属性。<code class="codeph">v1</code>属性显式设置数据类型。
                     </p><pre class="oac_no_warn" dir="ltr">//创建顶点v1并将其属性指定为键值对Vertex v1 = opg.addVertex（1l）; v1.setProperty（“age”，Integer.valueOf（31））; v1.setProperty（“name”，“Alice”）; v1.setProperty（“weight”，Float.valueOf（135.0f））; v1.setProperty（“height”，Double.valueOf（64.5d））; v1.setProperty（“female”，布尔值。真正）; Vertex v2 = opg.addVertex（2l）; v2.setProperty（“年龄”，27）; v2.setProperty（“name”，“Bob”）; v2.setProperty（“weight”，Float.valueOf（156.0f））; v2.setProperty（“height”，Double.valueOf（69.5d））; v2.setProperty（“female”，布尔值。假）;</pre></div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="using-property-graphs-oracle-database.html#GUID-734D16D3-E8AA-4097-B644-14D80A4C7958" title="创建属性图涉及使用Java API在其中创建属性图和对象。">将Java API用于属性图数据</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="props_rev_3"><a id="GUID-82E59D39-5C57-4987-9BC4-22369A9DBF01" name="GUID-82E59D39-5C57-4987-9BC4-22369A9DBF01"></a><h4 id="SPGDG-GUID-82E59D39-5C57-4987-9BC4-22369A9DBF01" class="sect4"><span class="enumeration_section">2.5.11</span>创建边</h4>
                  <div>
                     <p>要创建边缘，请使用以下Oracle Property Graph方法：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">OraclePropertyGraph.addEdge</code> ：将边实例添加到图形中。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">OracleEdge.setProperty</code> ：为边指定键值属性。
                           </p>
                        </li>
                     </ul>
                     <p>以下代码片段创建两个顶点（ <code class="codeph">v1</code>和<code class="codeph">v2</code> ）和一个边（ <code class="codeph">e1</code> ）。
                     </p><pre class="oac_no_warn" dir="ltr">//添加顶点v1和v2 Vertex v1 = opg.addVertex（1l）; v1.setProperty（“name”，“Alice”）; v1.setProperty（“年龄”，31）; Vertex v2 = opg.addVertex（2l）; v2.setProperty（“name”，“Bob”）; v2.setProperty（“年龄”，27）; //添加边e1边e1 = opg.addEdge（1l，v1，v2，“知道”）; e1.setProperty（“type”，“friends”）;</pre></div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="using-property-graphs-oracle-database.html#GUID-734D16D3-E8AA-4097-B644-14D80A4C7958" title="创建属性图涉及使用Java API在其中创建属性图和对象。">将Java API用于属性图数据</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="props_rev_3"><a id="GUID-0FC2511D-0E43-41B7-B2D1-77ECBEF6A417" name="GUID-0FC2511D-0E43-41B7-B2D1-77ECBEF6A417"></a><h4 id="SPGDG-GUID-0FC2511D-0E43-41B7-B2D1-77ECBEF6A417" class="sect4"><span class="enumeration_section">2.5.12</span>删除顶点和边缘</h4>
                  <div>
                     <p>您可以单独删除顶点和边缘实例，也可以同时删除所有顶点和边缘实例。使用这些方法：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">OraclePropertyGraph.removeEdge</code> ：从图中删除指定的边。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">OraclePropertyGraph.removeVertex</code> ：从图中移除指定的顶点。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">OraclePropertyGraph.clearRepository</code> ：从属性图实例中删除所有顶点和边。
                           </p>
                        </li>
                     </ul>
                     <p>以下代码片段从图形实例中删除边<code class="codeph">e1</code>和顶点<code class="codeph">v1</code> 。移除顶点时，相邻边也将从图中删除。这是因为每个边都必须有一个开始和结束的顶点。删除开始或结束顶点后，边缘不再是有效边。
                     </p><pre class="oac_no_warn" dir="ltr">//删除边e1 opg.removeEdge（e1）; //删除顶点v1 opg.removeVertex（v1）;</pre><p><code class="codeph">OraclePropertyGraph.clearRepository</code>方法可用于从<code class="codeph">OraclePropertyGraph</code>实例中删除所有内容。但是，请小心使用它，因为此操作无法撤消。
                     </p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="using-property-graphs-oracle-database.html#GUID-734D16D3-E8AA-4097-B644-14D80A4C7958" title="创建属性图涉及使用Java API在其中创建属性图和对象。">将Java API用于属性图数据</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="props_rev_3"><a id="GUID-454C00B5-9662-4C19-BF4D-FD8B1C503E34" name="GUID-454C00B5-9662-4C19-BF4D-FD8B1C503E34"></a><h4 id="SPGDG-GUID-454C00B5-9662-4C19-BF4D-FD8B1C503E34" class="sect4"><span class="enumeration_section">2.5.13</span>将数据库中的图形读入嵌入式内存分析器</h4>
                  <div>
                     <p>您可以将Oracle数据库中的图形读入内嵌分析程序，该分析程序嵌入在同一客户机Java应用程序（单个JVM）中。对于以下示例，需要正确的<code class="codeph">java.io.tmpdir</code>设置。
                     </p><pre class="pre codeblock"><code>int dop = 8; //需要自定义Map &lt;PgxConfig。Field，Object&gt; confPgx = new HashMap &lt;PgxConfig。Field，Object&gt;（）; confPgx.put（PgxConfig。领域。ENABLE_GM_COMPILER，false）; confPgx.put（PgxConfig。领域。NUM_WORKERS_IO，dop）; // confPgx.put（PgxConfig。领域。NUM_WORKERS_ANALYSIS，dop）; // &lt;=物理核心数＃confPgx.put（PgxConfig。领域。NUM_WORKERS_FAST_TRACK_ANALYSIS，2）; confPgx.put（PgxConfig。领域。SESSION_TASK_TIMEOUT_SECS，0）; //没有超时设置confPgx.put（PgxConfig。领域。SESSION_IDLE_TIMEOUT_SECS，0）; //没有超时设置PgRdbmsGraphConfig cfg = GraphConfigBuilder.forPropertyGraphRdbms（）。setJdbcUrl（“jdbc：oracle：thin：@ &lt;your_db_host&gt;：&lt;db_port&gt;：&lt;db_sid&gt;”）。setUsername（“&lt;username&gt;”）。setPassword（“ &lt;password&gt;“）。setName（”&lt;graph_name&gt;“）。setMaxNumConnections（8）.setLoadEdgeLabel（false）.build（）; OraclePropertyGraph opg = OraclePropertyGraph.getInstance（cfg）; ServerInstance localInstance = Pgx.getInstance（）; localInstance.startEngine（confPgx）; PgxSession session = localInstance.createSession（“session-id-1”）; //在此处输入您的会话描述分析师分析师= session.createAnalyst（）; //以下调用将触发从数据库读取图形数据PgxGraph pgxGraph = session.readGraphWithProperties（opg.getConfig（））; long triangles = analyst.countTriangles（pgxGraph，false）; System.out.println（“三角形”+三角形）; //删除边e1 opg.removeEdge（e1）; //删除顶点v1 opg.removeVertex（v1）;</code></pre></div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="using-property-graphs-oracle-database.html#GUID-734D16D3-E8AA-4097-B644-14D80A4C7958" title="创建属性图涉及使用Java API在其中创建属性图和对象。">将Java API用于属性图数据</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="props_rev_3"><a id="GUID-DCDC3B41-4679-4525-A3E1-44BF8C86187C" name="GUID-DCDC3B41-4679-4525-A3E1-44BF8C86187C"></a><h4 id="SPGDG-GUID-DCDC3B41-4679-4525-A3E1-44BF8C86187C" class="sect4"><span class="enumeration_section">2.5.14</span>指定顶点的标签</h4>
                  <div>
                     <p>数据库和数据访问层不提供顶点标签;但是，您可以将指定顶点属性的值视为一个或多个标签。这种转变仅与内存分析师有关。</p>
                     <p>在以下示例中，在调用<code class="codeph">setUseVertexPropertyValueAsLabel()</code>指定属性“ <code class="codeph">country</code> ”，并在调用<code class="codeph">setPropertyValueDelimiter()</code>指定逗号分隔符“ <code class="codeph">,</code> ”。这两者一起暗示<code class="codeph">country</code>顶点属性的值将被视为由逗号分隔的顶点标签。例如，如果顶点X的国家/地区属性具有字符串值<code class="codeph">"US"</code> ，则其顶点标签将为<code class="codeph">US</code> ;如果顶点Y的字符串值为<code class="codeph">"UK,CN"</code> ，那么它将有两个标签： <code class="codeph">UK</code>和<code class="codeph">CN</code> 。</p><pre class="pre codeblock"><code>GraphConfigBuilder.forPropertyGraph ....setName（“&lt;your_graph_name&gt;”）....setUseVertexPropertyValueAsLabel（“country”）。setPropertyValueDelimiter（“，”）。setLoadVertexLabels（true）.build（）;</code></pre></div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="using-property-graphs-oracle-database.html#GUID-9BA44355-E97D-4E7A-81AA-269873E506B2">什么是属性图？</a></li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="using-property-graphs-oracle-database.html#GUID-734D16D3-E8AA-4097-B644-14D80A4C7958" title="创建属性图涉及使用Java API在其中创建属性图和对象。">将Java API用于属性图数据</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="props_rev_3"><a id="GUID-A34FD5F5-EE5F-4956-9630-4C5B02DB6CF7" name="GUID-A34FD5F5-EE5F-4956-9630-4C5B02DB6CF7"></a><h4 id="SPGDG-GUID-A34FD5F5-EE5F-4956-9630-4C5B02DB6CF7" class="sect4"><span class="enumeration_section">2.5.15</span>构建内存中图</h4>
                  <div>
                     <p>除了将<a href="using-inmemory-analyst-oracle-database.html#GUID-4D385F44-4DE9-4223-BEE5-06E1479FAE06">图形数据读入内存之外</a> ，您还可以以编程方式创建内存中的图形。当图形的大小很小或者图形的内容是高度动态的时，这可以简化开发。关键的Java类是<code class="codeph">GraphBuilder</code> ，它可以累积一组使用<code class="codeph">addVertex</code>和<code class="codeph">addEdge</code> API添加的顶点和边。所有更改后，内存中的曲线图的实例（ <code class="codeph">PgxGraph</code> ）可以通过创建<code class="codeph">GraphBuilder</code> 。
                     </p>
                     <p>以下Java代码段说明了图构建流程。请注意，没有对<code class="codeph">addVertex</code>显式调用，因为任何尚未存在的顶点将在创建其相邻边时动态添加。
                     </p><pre class="pre codeblock"><code>import oracle.pgx.api。*; PgxSession session = Pgx.createSession（“example”）; GraphBuilder &lt;Integer&gt; builder = session.newGraphBuilder（）; builder.addEdge（0,1,2）; builder.addEdge（1,2,3）; builder.addEdge（2,2,4）; builder.addEdge（3,3,4）; builder.addEdge（4,4,2）; PgxGraph graph = builder.build（）;</code></pre><p>要构造具有顶点属性的图形，可以对创建的顶点对象使用<code class="codeph">setProperty</code> 。
                     </p><pre class="pre codeblock"><code>PgxSession session = Pgx.createSession（“example”）; GraphBuilder &lt;Integer&gt; builder = session.newGraphBuilder（）; builder.addVertex（1）.setProperty（“double-prop”，0.1）; builder.addVertex（2）.setProperty（“double-prop”，2.0）; builder.addVertex（3）.setProperty（“double-prop”，0.3）; builder.addVertex（4）.setProperty（“double-prop”，4.56789）; builder.addEdge（0,1,2）; builder.addEdge（1,2,3）; builder.addEdge（2,2,4）; builder.addEdge（3,3,4）; builder.addEdge（4,4,2）; PgxGraph graph = builder.build（）;</code></pre><p>要将长整数用作顶点和边标识符，请指定<code class="codeph">IdType.LONG</code>获得的新实例时<code class="codeph">GraphBuilder</code> 。例如：</p><pre class="pre codeblock"><code>导入oracle.pgx.common.types。IdType; GraphBuilder &lt;Long&gt; builder = session.newGraphBuilder（IdType。长）;</code></pre><p>在边缘构造期间，您可以直接使用先前在调用<code class="codeph">addEdge</code>创建的顶点对象。
                     </p><pre class="pre codeblock"><code>v1 = builder.addVertex（1l）.setProperty（“double-prop”，0.5）v2 = builder.addVertex（2l）.setProperty（“double-prop”，2.0）builder.addEdge（0，v1，v2）</code></pre><p>与顶点一样，边可以具有属性。以下示例使用<code class="codeph">setLabel</code>设置边缘标签：</p><pre class="pre codeblock"><code>builder.addEdge（4，v4，v2）.setProperty（“edge-prop”，“edge_prop_4_2”）。setLabel（“label”）</code></pre></div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="using-property-graphs-oracle-database.html#GUID-734D16D3-E8AA-4097-B644-14D80A4C7958" title="创建属性图涉及使用Java API在其中创建属性图和对象。">将Java API用于属性图数据</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="props_rev_3"><a id="GUID-E17BCADE-4BC9-41D7-A54E-5612C4C6531F" name="GUID-E17BCADE-4BC9-41D7-A54E-5612C4C6531F"></a><h4 id="SPGDG-GUID-E17BCADE-4BC9-41D7-A54E-5612C4C6531F" class="sect4"><span class="enumeration_section">2.5.16</span>删除属性图</h4>
                  <div>
                     <p>要从数据库中删除属性图，请使用<code class="codeph">OraclePropertyGraphUtils.dropPropertyGraph</code>方法。此方法有两个参数，连接信息和图形名称。例如：</p><pre class="pre codeblock"><code>//删除图形Oracle oracle = new Oracle（jdbcUrl，username，password）; OraclePropertyGraphUtils.dropPropertyGraph（oracle，graphName）;</code></pre><p>您还可以使用PL / SQL API删除属性图。例如：</p><pre class="pre codeblock"><code>执行opg_apis.drop_pg（'my_graph_name'）;</code></pre></div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="using-property-graphs-oracle-database.html#GUID-734D16D3-E8AA-4097-B644-14D80A4C7958" title="创建属性图涉及使用Java API在其中创建属性图和对象。">将Java API用于属性图数据</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="props_rev_3"><a id="GUID-6CDBA4FE-84B2-4666-93AF-45BFF0FF5552" name="GUID-6CDBA4FE-84B2-4666-93AF-45BFF0FF5552"></a><h4 id="SPGDG-GUID-6CDBA4FE-84B2-4666-93AF-45BFF0FF5552" class="sect4"><span class="enumeration_section">2.5.17</span>执行PGQL查询</h4>
                  <div>
                     <p>您可以使用<code class="codeph">OraclePgqlStatement</code>和<code class="codeph">OraclePgqlPreparedStatement</code>接口直接针对Oracle数据库执行PGQL查询。有关详细信息，请参阅<a href="sql-based-property-graph-query-analytics.html#GUID-94F08780-EC3D-4F9B-985F-49984939E61C" title="本主题说明如何直接对Oracle数据库中的图形执行PGQL查询（而不是内存中）。">直接针对Oracle数据库执行PGQL查询</a> 。
                     </p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="using-property-graphs-oracle-database.html#GUID-734D16D3-E8AA-4097-B644-14D80A4C7958" title="创建属性图涉及使用Java API在其中创建属性图和对象。">将Java API用于属性图数据</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div>
            <div class="props_rev_3"><a id="GUID-72E0D670-D477-4C0F-914C-8E70E45F9692" name="GUID-72E0D670-D477-4C0F-914C-8E70E45F9692"></a><h3 id="SPGDG-GUID-72E0D670-D477-4C0F-914C-8E70E45F9692" class="sect3"><span class="enumeration_section">2.6</span>管理属性图数据的文本索引</h3>
               <div>
                  <p>Oracle Spatial and Graph属性图支持中的索引允许通过特定键/值或键/文本对快速检索元素。这些索引是基于元素类型（顶点或边），一组键（和值）和索引类型创建的。</p>
                  <p>Oracle Spatial and Graph支持各种文本索引技术，包括Oracle Text（Oracle数据库的一个功能），Apache Lucene（随Oracle Spatial和Graph一起分发），以及可选的Apache SolrCloud（必须按照<a href="property-graph-overview-spgdg.html#GUID-FF149F69-574D-43B8-B888-4CCD019DAE56" title="Although no special configuration operations are required, the requirements for using the property graph features are the following.">属性中的</a>说明下载的单独分发） <a href="property-graph-overview-spgdg.html#GUID-FF149F69-574D-43B8-B888-4CCD019DAE56" title="虽然不需要特殊的配置操作，但使用属性图功能的要求如下。">图表先决条件</a> ）。
                  </p>
                  <p>支持两种类型的索引结构。</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>自动文本索引通过一组属性键提供顶点或边的自动索引。它们的主要目的是基于特定的键/值对来增强顶点和边的查询性能。</p>
                     </li>
                     <li>
                        <p>手动文本索引使您可以在指定的顶点集和属性图的边上定义多个索引。您必须指定哪些图形元素进入索引。</p>
                     </li>
                  </ul>
                  <p>Oracle Spatial and Graph提供API，以便在Oracle数据库中存储的属性图上创建手动和自动文本索引。索引使用可用的开源搜索引擎Apache Lucene和SolrCloud以及Oracle Text（一种专有的搜索和分析引擎）进行管理。本节的其余部分重点介绍如何使用数据访问层的属性图功能创建文本索引。</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-17FBB50B-DF01-4C07-9617-A89F7CACBA67">配置属性图数据的文本索引</a><br></li>
                     <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-469E1B26-DE30-4AFA-801E-BA14AB30214B">使用属性图数据的自动索引</a><br></li>
                     <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-C56AB70D-CB45-4208-84D8-6C5DBF67A8FC">使用属性图数据的手动索引</a><br></li>
                     <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-F175FF6A-5E87-4499-8086-95069168C88B">在属性图的文本索引上执行搜索查询</a><br></li>
                     <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-26C80DDB-DA5A-48B6-B729-9BE34DECCBB6">处理数据类型</a><br></li>
                     <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-A5797EAF-4165-4ACE-B1BD-0284DA391DB3">将Collection的SolrCloud配置上传到Zookeeper</a><br></li>
                     <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-F198F6FA-875D-42E4-A43C-7A9B01FFEA1E">更新属性图数据的文本索引上的配置设置</a><br></li>
                     <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-7C5C1BDB-13EA-4504-9B4F-B8F7D788AE52">在属性图数据的文本索引上使用并行查询</a><br></li>
                     <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-C957BD65-7FA5-4EC2-8485-4BB0D297AE26">在属性图数据的文本索引上使用本机查询对象</a><br></li>
                     <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-F0D99092-49A0-434E-9827-C672CC18F64C">在属性图数据的文本索引上使用本机查询结果</a><br></li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="using-property-graphs-oracle-database.html#GUID-4B5AF258-79BE-418D-84FF-9B8A692B8604" title="本章提供有关在Oracle数据库环境中创建，存储和使用属性图数据的概念和用法信息。">在Oracle数据库环境中使用属性图</a></p>
                     </div>
                  </div>
               </div>
               
               <div class="props_rev_3"><a id="GUID-17FBB50B-DF01-4C07-9617-A89F7CACBA67" name="GUID-17FBB50B-DF01-4C07-9617-A89F7CACBA67"></a><h4 id="SPGDG-GUID-17FBB50B-DF01-4C07-9617-A89F7CACBA67" class="sect4"><span class="enumeration_section">2.6.1</span>配置属性图数据的文本索引</h4>
                  <div>
                     <p>使用<code class="codeph">OracleIndexParameters</code>对象定义文本索引的配置。此对象包括有关索引的信息，例如搜索引擎，位置，目录（或分片）数量和并行度。
                     </p>
                     <p>默认情况下，使用<code class="codeph">opg.setDefaultIndexParameters(indexParams)</code>方法，基于与属性图关联的<code class="codeph">OracleIndexParameters</code>配置文本索引。最初创建自动索引会为将来的索引键分隔配置和文本搜索引擎。
                     </p>
                     <p>也可以通过指定一组不同的参数来创建索引。以下代码片段使用带有物理目录的Lucene引擎在现有属性图上创建自动文本索引。</p><pre class="oac_no_warn" dir="ltr">//创建OracleIndexParameters对象以获取索引配置（搜索引擎等）。OracleIndexParameters indexParams = OracleIndexParameters.buildFS（args）//为所有顶点的上述属性创建自动索引opg.createKeyIndex（“name”，Vertex.class，indexParams.getParameters（））;</pre></div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-E33E997D-3210-4DD5-9B33-90549B1AABD2">使用Oracle Text配置文本索引</a><br></li>
                        <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-1C216BB1-D3B0-4FED-B986-53A1DFE1A6C0">使用Apache Lucene搜索引擎配置文本索引</a><br></li>
                        <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-B226DD33-93B6-4DF0-A6B3-68EDF280B38C">使用SolrCloud搜索引擎配置文本索引</a><br></li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="using-property-graphs-oracle-database.html#GUID-72E0D670-D477-4C0F-914C-8E70E45F9692" title="Oracle Spatial and Graph属性图支持中的索引允许通过特定键/值或键/文本对快速检索元素。这些索引是基于元素类型（顶点或边），一组键（和值）和索引类型创建的。">管理属性图数据的文本索引</a></p>
                        </div>
                     </div>
                  </div>
                  
                  <div class="props_rev_3"><a id="GUID-E33E997D-3210-4DD5-9B33-90549B1AABD2" name="GUID-E33E997D-3210-4DD5-9B33-90549B1AABD2"></a><h5 id="SPGDG-GUID-E33E997D-3210-4DD5-9B33-90549B1AABD2" class="sect5"><span class="enumeration_section">2.6.1.1</span>使用Oracle Text配置文本索引</h5>
                     <div>
                        <p>Oracle Spatial and Graph使用Oracle Text支持自动文本索引。Oracle Text使用标准SQL来索引，搜索和分析存储在顶点（或边）表的V列中的文本值。因为Oracle文本索引在属性图中的顶点（或边缘）的所有现有ķ/ V对，此选项<span class="bold"><span class="italic">只能</span></span>与自动文本索引使用，必须使用一个通配符（“*”）的索引创建期间索引关键参数。
                        </p>
                        <p>由于属性图功能使用NVARCHAR类型列来更好地支持Unicode，因此强烈建议将UTF8（AL32UTF8）用作数据库字符集。</p>
                        <p>要在顶点表（或边表）上创建Oracle Text索引，需要ALTER SESSION权限。以下示例授予权限。</p><pre class="pre codeblock"><code>SQL&gt;将alter session授予&lt;YOUR_USER_SCHEMA_HERE&gt;;</code></pre><p>如果需要自定义，请在CTX_DDL上授予EXECUTE，如下例所示。</p><pre class="pre codeblock"><code>SQL&gt;将ctx_ddl上的execute赋予&lt;YOUR_USER_SCHEMA_HERE&gt;;</code></pre><p>使用Oracle Text的文本索引使用<code class="codeph">OracleTextIndexParameters</code>对象。使用Oracle Text的索引的配置参数包括：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><span class="bold">首选项所有者：首选项的所有者</span> 。
                              </p>
                           </li>
                           <li>
                              <p><span class="bold">数据存储：</span>指定文本值存储方式的数据存储区首选项。可以使用ctx_ddl.create_preference API创建数据存储区首选项，如下所示：</p><pre class="pre codeblock"><code>SQL&gt;  - 以下要求对CTX_DDL SQL&gt; exec ctx_ddl.create_preference（'SCOTT.OPG_DATASTORE'，'DIRECT_DATASTORE'）的访问权限;</code></pre><p>如果该值设置为NULL，则将使用CTXSYS.DEFAULT_DATASORE创建索引。此首选项使用DIRECT_DATASTORE类型。</p>
                           </li>
                           <li>
                              <p><span class="bold">过滤：</span>过滤器首选项确定如何过滤文本以进行索引。可以使用<code class="codeph">ctx_ddl.create_preference</code>创建过滤器首选项，如下所示：</p><pre class="pre codeblock"><code>SQL&gt;  - 以下要求对CTX_DDL SQL&gt; exec ctx_ddl.create_preference（'SCOTT.OPG_FILTER'，'AUTO_FILTER'）的访问权限;</code></pre><p>如果该值设置为NULL，则将使用CTXSYS.NULL_FILTER创建索引。此首选项使用NULL_FILTER类型。</p>
                           </li>
                           <li>
                              <p><span class="bold">存储：</span>存储首选项，指定与Text索引关联的表的表空间和创建参数。可以使用<code class="codeph">ctx_ddl.create_preference</code>创建存储首选项，如下所示：</p><pre class="pre codeblock"><code>SQL&gt;  - 以下要求对CTX_DDL SQL&gt; exec ctx_ddl.create_preference（'SCOTT.OPG_STORAGE'，'BASIC_STORAGE'）的访问权限;</code></pre><p>如果该值设置为NULL，则将使用CTXSYS.DEFAULT_STORAGE创建索引。此首选项使用BASIC_STORAGE类型。</p>
                           </li>
                           <li>
                              <p><span class="bold">单词列表：</span>单词列表首选项，指定启用的查询选项。这些查询选项可以包括词干分析，模糊匹配，子字符串和前缀索引。可以使用<code class="codeph">ctx_ddl.create_preference</code>创建数据存储首选项，如下所示：</p><pre class="pre codeblock"><code>SQL&gt;  - 以下示例为英语启用词干和模糊匹配。SQL&gt; exec ctx_ddl.create_preference（'SCOTT.OPG_WORDLIST'，'BASIC_WORDLIST'）;</code></pre><p>如果该值设置为NULL，则将使用CTXSYS.DEFAULT_WORDLIST创建索引。此首选项将语言词干分析器用于您的数据库语言。</p>
                           </li>
                           <li>
                              <p><span class="bold">停止列表：</span>停止列表首选项，指定不打算编入索引的单词列表。可以使用<code class="codeph">ctx_ddl.create_stoplist</code>创建停止列表首选项。
                              </p>
                              <p>如果该值设置为NULL，则将使用CTXSYS.DEFAULT_STOPLIST创建索引。此首选项使用数据库语言的停止列表。</p>
                           </li>
                           <li>
                              <p><span class="bold">Lexer：</span>词法分析器首选项，指定要编制索引的文本的语言。可以使用<code class="codeph">ctx_ddl.create_preference</code>创建词法分析器首选项，如下所示：</p><pre class="pre codeblock"><code>SQL&gt;  - 以下要求对CTX_DDL SQL&gt; exec ctx_ddl.create_preference（'SCOTT.OPG_AUTO_LEXER'，'AUTO_LEXER'）的访问权限;</code></pre><p>如果该值设置为NULL，则将使用CTXSYS.DEFAULT_LEXER创建索引。此首选项使用BASIC_LEXER类型，并根据安装时使用的语言添加其他选项。</p>
                           </li>
                        </ul>
                        <p>以下代码片段使用带有默认选项和OPG_AUTO_LEXER的Oracle Text创建文本索引的配置。</p><pre class="oac_no_warn" dir="ltr">String prefOwner =“scott”; String datastore =（String）null; String filter =（String）null; String storage =（String）null; String wordlist =（String）null; String stoplist =（String）null; String lexer =“OPG_AUTO_LEXER”; String options =（String）null; OracleIndexParameters params = OracleTextIndexParameters.buildOracleText（prefOwner，datastore，filter，storage，wordlist，stoplist，lexer，dop，options）;</pre></div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="using-property-graphs-oracle-database.html#GUID-17FBB50B-DF01-4C07-9617-A89F7CACBA67">为属性图数据配置文本索引</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
                  <div class="props_rev_3"><a id="GUID-1C216BB1-D3B0-4FED-B986-53A1DFE1A6C0" name="GUID-1C216BB1-D3B0-4FED-B986-53A1DFE1A6C0"></a><h5 id="SPGDG-GUID-1C216BB1-D3B0-4FED-B986-53A1DFE1A6C0" class="sect5"><span class="enumeration_section">2.6.1.2</span>使用Apache Lucene搜索引擎配置文本索引</h5>
                     <div>
                        <p>使用Apache Lucene搜索引擎的文本索引使用<code class="codeph">LuceneIndexParameters</code>配置对象。使用Lucene搜索引擎的索引的配置参数包括：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><span class="bold">目录数：</span>一个整数，指定用于自动索引的Apache Lucene目录的数量。使用多个目录可提供存储和性能可伸缩性。默认值设置为1。
                              </p>
                           </li>
                           <li>
                              <p><span class="bold">批处理大小：</span>一个整数，指定用于Apache Lucene中的文档批处理的批处理大小。使用的默认批处理大小为10000。
                              </p>
                           </li>
                           <li>
                              <p><span class="bold">提交批处理大小：</span>一个整数，指定在执行提交操作之前要添加到Apache Lucene索引中的文档数。使用的默认提交批处理大小为500000。
                              </p>
                           </li>
                           <li>
                              <p><span class="bold">数据类型处理标志：</span>一个布尔值，指定是否启用Apache Lucene数据类型处理。启用数据类型处理可以加快数字和日期时间数据类型的查找。
                              </p>
                           </li>
                           <li>
                              <p><span class="bold">目录名称：</span>一个字符串数组，指定将创建Apache Lucene目录的基本路径位置。
                              </p>
                           </li>
                        </ul>
                        <p>以下代码片段使用具有物理目录的Apache Lucene搜索引擎创建文本索引的配置。</p><pre class="oac_no_warn" dir="ltr">OracleIndexParameters indexParams = OracleIndexParameters.buildFS（4,4,10000,50000，true，“/ home / data / text-index”）;</pre><p>Oracle Spatial and Graph通过使用DBFS目录来存储所有Apache Lucene目录和数据文件，从而扩展了Apache Lucene功能。</p>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="using-property-graphs-oracle-database.html#GUID-17FBB50B-DF01-4C07-9617-A89F7CACBA67">为属性图数据配置文本索引</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
                  <div class="props_rev_3"><a id="GUID-B226DD33-93B6-4DF0-A6B3-68EDF280B38C" name="GUID-B226DD33-93B6-4DF0-A6B3-68EDF280B38C"></a><h5 id="SPGDG-GUID-B226DD33-93B6-4DF0-A6B3-68EDF280B38C" class="sect5"><span class="enumeration_section">2.6.1.3</span>配置文本索引使用SolrCloud搜索引擎</h5>
                     <div>
                        <div class="infoboxnote" id="GUID-B226DD33-93B6-4DF0-A6B3-68EDF280B38C__GUID-A263DC3F-5D52-4CDE-9658-7262CC1004FD">
                           <p class="notep1">注意：</p>
                           <p>必须单独下载和配置SolrCloud，如<a href="property-graph-overview-spgdg.html#GUID-FF149F69-574D-43B8-B888-4CCD019DAE56" title="虽然不需要特殊的配置操作，但使用属性图功能的要求如下。">Property Graph Prerequisites中所述</a> 。
                           </p>
                        </div>
                        <p>使用Apache SolrCloud搜索引擎的文本索引在后台使用<code class="codeph">SolrIndexParameters</code>对象来标识索引构建期间使用的SolrCloud主机名，分片数和复制因子。使用SolrCloud搜索引擎的索引的配置参数包括：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><span class="bold">配置名称：</span>存储Oracle Property Graph的SolrCloud配置文件的Zookeeper目录的名称，例如<span class="italic">opgconfig</span> 。配置文件包括必需字段的架构（ <code class="codeph">schema.xml</code> ）和存储设置（ <code class="codeph">solrconfig.xml</code> ）。
                              </p>
                           </li>
                           <li>
                              <p><span class="bold">服务器URL：</span>用于连接SolrCloud服务的SolrCloud服务器URL，例如<span class="italic">http：// localhost：2181 / solr</span></p>
                           </li>
                           <li>
                              <p><span class="bold">SolrCloud节点集：</span> SolrCloud服务中将存储集合的分片的节点的主机名，例如<span class="italic">node01：8983_solr，node02：8983_solr，node03：8983_solr</span> 。如果该值设置为null，则将使用服务中可用的所有SolrCloud节点创建集合。
                              </p>
                           </li>
                           <li>
                              <p><span class="bold">Zookeeper Timeout</span> ：一个正整数，表示用于等待Zookeeper连接的超时（以秒为单位）。
                              </p>
                           </li>
                           <li>
                              <p><span class="bold">分片数：</span>为文本索引集合创建的分片数。如果SolrCloud配置使用HDFS目录，则分片数不得超过SolrCloud节点集中指定的SolrCloud节点数。
                              </p>
                           </li>
                           <li>
                              <p><span class="bold">复制因子：</span> SolrCloud集合中使用的复制因子。默认值设置为<span class="italic">1</span> 。
                              </p>
                           </li>
                           <li>
                              <p><span class="bold">每个节点的最大分片数：</span>每个SolrCloud节点上可以创建的最大分片数。请注意，此值不得小于SolrCloud节点集中的分片数/节点数。
                              </p>
                           </li>
                           <li>
                              <p><span class="bold">DOP：</span>从属性图中读取顶点（或边）并索引K / V对时使用的并行度。默认值设置为<span class="italic">1</span> 。
                              </p>
                           </li>
                           <li>
                              <p><span class="bold">批处理大小：</span>一个整数，指定用于Apache SolrCloud中的文档批处理的批处理大小。使用的默认批处理大小为10000。
                              </p>
                           </li>
                           <li>
                              <p><span class="bold">提交批处理大小：</span>一个整数，指定在执行提交操作之前要添加到Apache SolrCloud索引中的文档数。使用的默认提交批处理大小为500000。
                              </p>
                           </li>
                           <li>
                              <p><span class="bold">写入超时：</span>用于等待索引操作完成的超时（以秒为单位）。如果索引操作由于通信错误而失败，则将再次尝试操作，直到达到超时或操作完成。
                              </p>
                           </li>
                        </ul>
                        <p>以下代码片段使用SolrCloud为文本索引创建配置。</p><pre class="oac_no_warn" dir="ltr">String configName =“opgconfig”; String solrServerUrl =“nodea：2181 / solr”String solrNodeSet =“nodea：8983_solr，nodeb：8983_solr，”+“nodec：8983_solr，noded：8983_solr”; int zkTimeout = 15; int numShards = 4; int replicationFactor = 1; int maxShardsPerNode = 1; OracleIndexParameters indexParams = OracleIndexParameters.buildSolr（configName，solrServerUrl，solrNodeSet，zkTimeout，numShards，replicationFactor，maxShardsPerNode，4,10000,500000,15）;</pre><p>使用SolrCloud时，必须首先将文本索引的集合配置加载到Apache Zookeeper中，如将<a href="using-property-graphs-oracle-database.html#GUID-A5797EAF-4165-4ACE-B1BD-0284DA391DB3">集合的SolrCloud配置上载到Zookeeper中所述</a> 。
                        </p>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="using-property-graphs-oracle-database.html#GUID-17FBB50B-DF01-4C07-9617-A89F7CACBA67">为属性图数据配置文本索引</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div>
               <div class="props_rev_3"><a id="GUID-469E1B26-DE30-4AFA-801E-BA14AB30214B" name="GUID-469E1B26-DE30-4AFA-801E-BA14AB30214B"></a><h4 id="SPGDG-GUID-469E1B26-DE30-4AFA-801E-BA14AB30214B" class="sect4"><span class="enumeration_section">2.6.2</span>使用属性图数据的自动索引</h4>
                  <div>
                     <p>自动文本索引通过一组属性键提供顶点或边的自动索引。其主要目的是根据特定的键/值对提高顶点和边缘的查找速度。如果启用了给定键的自动索引，则键/值对查找将作为针对索引的文本搜索而不是数据库查找执行。</p>
                     <p>在属性图上指定自动索引时，请使用以下方法创建，删除和操作自动索引：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">OraclePropertyGraph.createKeyIndex(String key, Class elementClass, Parameter[] parameters)</code> ：通过给定的属性键为<code class="codeph">elementClass</code>类型的所有元素创建自动索引。索引是根据指定的参数配置的。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">OraclePropertyGraph.createKeyIndex(String[] keys, Class elementClass, Parameter[] parameters)</code> ：使用一组属性键为<code class="codeph">elementClass</code>类型的所有元素创建自动索引。索引是根据指定的参数配置的。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">OraclePropertyGraph.dropKeyIndex(String key, Class elementClass)</code> ：删除给定属性键的<code class="codeph">elementClass</code>类型的所有元素的自动索引。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">OraclePropertyGraph.dropKeyIndex(String[] keys, Class elementClass)</code> ：删除给定属性键集的<code class="codeph">elementClass</code>类型的所有元素的自动索引。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">OraclePropertyGraph.getAutoIndex(Class elementClass)</code> ：获取<code class="codeph">elementClass</code>类型的自动索引的索引实例。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">OraclePropertyGraph.getIndexedKeys(Class elementClass)</code> ：获取当前在<code class="codeph">elementClass</code>类型的所有元素的自动索引中使用的索引键集。
                           </p>
                        </li>
                     </ul>
                     <p>提供的示例ExampleRDBMS6从输入文件创建属性图，在顶点上创建自动文本索引，并使用Apache Lucene执行一些文本搜索查询。</p>
                     <p>以下代码片段使用以下属性键在现有属性图的顶点上创建自动索引：name，role，religion和country。自动文本索引将存储在<code class="codeph">/home/data/text-index</code>目录下的四个子目录下。启用Apache Lucene数据类型处理。此示例使用4的DOP（并行性）来重新编制索引任务。
                     </p><pre class="oac_no_warn" dir="ltr">OraclePropertyGraph opg = OraclePropertyGraph.getInstance（...）; String szOPVFile =“../../data/connections.opv“; String szOPEFile =”../../data/connections.ope“; //并行数据加载OraclePropertyGraphDataLoader opgdl = OraclePropertyGraphDataLoader.getInstance（）; opgdl.loadData（opg，szOPVFile，szOPEFile，2 / * dop * /，1000，true，”PDML = T，PDDL = T，NO_DUP = T，“）; //使用Apache Lucene引擎创建自动索引。//指定索引目录参数（目录数，//数据库连接数，批量大小，提交大小，//启用数据类型，位置）OracleIndexParameters indexParams = OracleIndexParameters.buildFS（4,4,10000,50000，true，“ / home / data / text-index“）; opg.setDefaultIndexParameters（indexParams）; //指定索引键String [] indexedKeys = new String [4]; indexedKeys [0] =“name”; indexedKeys [1] =“角色”; indexedKeys [2] =“宗教”; indexedKeys [3] =“国家”; //为所有顶点的上述属性创建自动索引opg.createKeyIndex（indexedKeys，Vertex.class）;</pre><p>默认情况下，使用<code class="codeph">opg.setDefaultIndexParameters(indexParams</code> ）方法，根据与属性图关联的<code class="codeph">OracleIndexParameters</code>配置索引。
                     </p>
                     <p>也可以通过指定一组不同的参数来创建索引。这显示在以下代码段中。</p><pre class="oac_no_warn" dir="ltr">//创建OracleIndexParameters对象以获取索引配置（搜索引擎等）。OracleIndexParameters indexParams = OracleIndexParameters.buildFS（args）//为所有顶点的上述属性创建自动索引opg.createKeyIndex（“name”，Vertex.class，indexParams.getParameters（））;</pre><p>下一个示例中的代码片段对所有顶点执行查询，以查找具有键/值对<code class="codeph">name:Barack Obama</code>所有匹配顶点<code class="codeph">name:Barack Obama</code> 。此操作将执行对文本索引的查找。
                     </p>
                     <p>此外，通过在<code class="codeph">getVertices</code> API调用中指定参数<code class="codeph">useWildCards</code>来支持通配符搜索。仅当为指定的属性键启用自动索引时，才支持通配符搜索。有关使用Apache Lucene的文本搜索语法的详细信息，请参阅<a href="https://lucene.apache.org/core/2_9_4/queryparsersyntax.html" target="_blank"><code class="codeph">https://lucene.apache.org/core/2_9_4/queryparsersyntax.html</code></a> 。</p><pre class="oac_no_warn" dir="ltr">//找到名为Barack Obama的所有顶点。Iterator &lt;Vertices&gt; vertices = opg.getVertices（“name”，“Barack Obama”）。iterator（）; System.out.println（“-----姓名巴拉克奥巴马的顶点-----”）; countV = 0; while（vertices.hasNext（））{System.out.println（vertices.next（））; countV ++; System.out.println（“Vertices found：”+ countV）; //查找名称中包含关键字“Obama”的所有顶点//支持通配符搜索。boolean useWildcard = true; Iterator &lt;Vertices&gt; vertices = opg.getVertices（“name”，“* Obama *”）。iterator（）; System.out.println（“-----顶点名称*奥巴马* -----”）; countV = 0; while（vertices.hasNext（））{System.out.println（vertices.next（））; countV ++; System.out.println（“Vertices found：”+ countV）;</pre><p>上面的代码示例生成如下输出：</p><pre class="oac_no_warn" dir="ltr">-----名字为Barack Obama的顶点----- Vertex ID 1 {姓名：str：Barack Obama，角色：str：政治权威，职业：str：美利坚合众国第44任总统，国家：str：United国家，政党：str：民主党，宗教：str：基督教}发现顶点：1 -----顶点名称*奥巴马* -----顶点ID 1 {名称：str：Barack Obama，角色：str：政治权威，职业：str：美利坚合众国第44任总统，国家：str：美国，政党：str：民主党，宗教：str：基督教}发现顶点：1</pre></div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="using-property-graphs-oracle-database.html#GUID-72E0D670-D477-4C0F-914C-8E70E45F9692" title="Oracle Spatial and Graph属性图支持中的索引允许通过特定键/值或键/文本对快速检索元素。这些索引是基于元素类型（顶点或边），一组键（和值）和索引类型创建的。">管理属性图数据的文本索引</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="props_rev_3"><a id="GUID-C56AB70D-CB45-4208-84D8-6C5DBF67A8FC" name="GUID-C56AB70D-CB45-4208-84D8-6C5DBF67A8FC"></a><h4 id="SPGDG-GUID-C56AB70D-CB45-4208-84D8-6C5DBF67A8FC" class="sect4"><span class="enumeration_section">2.6.3</span>使用属性图数据的手动索引</h4>
                  <div>
                     <p>手动索引支持在属性图的顶点和边上定义多个索引。手动索引要求您手动放入，获取和删除索引中的元素。</p>
                     <p>在属性图上描述手动索引时，请使用以下方法添加，删除和操作手动索引：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">OraclePropertyGraph.createIndex(String name, Class elementClass, Parameter[] parameters)</code> ：为<code class="codeph">elementClass</code>类型的所有元素创建一个具有指定名称的手动索引。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">OraclePropertyGraph.dropIndex(String name)</code> ：删除给定的手动索引。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">OraclePropertyGraph.getIndex(String name, Class elementClass)</code> ：获取<code class="codeph">elementClass</code>类型的给定手动索引的索引实例。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">OraclePropertyGraph.getIndices()</code> ：获取属性图中创建的所有手动索引的索引实例数组。
                           </p>
                        </li>
                     </ul>
                     <p>本主题中的示例代码在边缘上创建手动文本索引，将一些数据放入索引，并使用Apache SolrCloud执行一些文本搜索查询。</p>
                     <p>使用SolrCloud时，必须首先将文本索引的集合配置加载到Apache Zookeeper中，如将<a href="using-property-graphs-oracle-database.html#GUID-A5797EAF-4165-4ACE-B1BD-0284DA391DB3">集合的SolrCloud配置上载到Zookeeper中所述</a> 。
                     </p>
                     <p>以下代码片段使用四个分片，每个节点一个分片和复制因子1在现有属性图上创建手动文本索引。分片数对应于SolrCloud集群中的节点数。</p><pre class="oac_no_warn" dir="ltr">String szOPVFile =“../../data/connections.opv“; String szOPEFile =”../../data/connections.ope“; //并行数据加载OraclePropertyGraphDataLoader opgdl = OraclePropertyGraphDataLoader.getInstance（）; opgdl.loadData（opg，szOPVFile，szOPEFile，2 / * dop * /，1000，true，”PDML = T，PDDL = T，NO_DUP = T，“）; //使用SolrCloud创建手动文本索引//指定索引目录参数：配置名称，Solr服务器URL，Solr节点集，//复制因子，zookeeper超时（秒），//每个节点的最大分片数，//数据库连接数，批量大小，提交大小，//写入超时（以秒为单位）字符串configName =“opgconfig”;字符串solrServerUrl =“nodea：2181 / solr” String solrNodeSet =“nodea：8983_solr，nodeb：8983_solr，”+“nodec：8983_solr，noded：8983_solr”; int zkTimeout = 15; int numShards = 4; int replicationFactor = 1; int maxShardsPerNode = 1; OracleIndexParameters indexParams = OracleIndexParameters.buildSolr （configName，solrServerUrl，solrNodeSet，zkTimeout，numShards，replicationFactor，maxShardsPerNode，4,10000,500000,15）; opg .setDefaultIndexParameters（indexParams）; //为所有顶点创建上述属性的手动索引OracleIndex &lt;Edge&gt; index =（（OracleIndex &lt;Edge&gt;）opg.createIndex（“myIdx”，Edge.class））; Vertex v1 = opg.getVertices（“name”，“Barack Obama”）。iterator（）。next（）; Iterator &lt;Edge&gt; edges = v1.getEdges（Direction。OUT，“合作”）。iterator（）; while（edges.hasNext（））{Edge edge = edges.next（）; Vertex vIn = edge.getVertex（Direction。在）; index.put（“collaboratesWith”，vIn.getProperty（“name”），edge）; }</pre><p>下一个代码片段对手动索引执行查询，以获得具有键/值对的所有边缘c <code class="codeph">ollaboratesWith:Beyonce</code> 。此外，可以通过在get API调用中指定参数<code class="codeph">useWildCards</code>来支持通配符搜索。
                     </p><pre class="oac_no_warn" dir="ltr">//找到合作的所有边缘与Beyonce。//使用true参数支持通配符搜索。edges = index.get（“collaboratesWith”，“Beyonce”）。iterator（）; System.out.println（“-----名字Beyonce的边缘-----”）; countE = 0; while（edges.hasNext（））{System.out.println（edges.next（））; countE ++; System.out.println（“Edges found：”+ countE）; //查找名称中包含Bey *的所有顶点。//使用true参数支持通配符搜索。edges = index.get（“collaboratesWith”，“* Bey *”，true）.iterator（）; System.out.println（“-----与Edge合作的边缘* -----”）; countE = 0; while（edges.hasNext（））{System.out.println（edges.next（））; countE ++; System.out.println（“Edges found：”+ countE）;</pre><p>上面的代码示例生成如下输出：</p><pre class="oac_no_warn" dir="ltr">-----边缘名为Beyonce的边缘-----来自Vertex ID 1的Edge ID 1000 {country：str：美国，姓名：str：Barack Obama，职业：str：美国第44任总统，政党：str：民主党，宗教：str：基督教，角色：str：政治权威} = [合作] =&gt; Vertex ID 2 {country：str：美国，音乐类型：str：pop soul，name：str：Beyonce，role ：str：歌手女演员} edgeKV [{weight：flo：1.0}]边缘发现：1 -----与合作者的边缘与Bey * -----来自Vertex ID 1的Edge ID 1000 {country：str：United States，姓名：str：Barack Obama，职业：str：第44任美利坚合众国总统，政党：str：民主党，宗教：str：基督教，角色：str：政治权威} = [合作] =&gt; Vertex ID 2 {country ：str：美国，音乐类型：str：pop soul，name：str：Beyonce，角色：str：歌手女演员} edgeKV [{weight：flo：1.0}]边缘发现：1</pre></div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="using-property-graphs-oracle-database.html#GUID-72E0D670-D477-4C0F-914C-8E70E45F9692" title="Oracle Spatial and Graph属性图支持中的索引允许通过特定键/值或键/文本对快速检索元素。这些索引是基于元素类型（顶点或边），一组键（和值）和索引类型创建的。">管理属性图数据的文本索引</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="props_rev_3"><a id="GUID-F175FF6A-5E87-4499-8086-95069168C88B" name="GUID-F175FF6A-5E87-4499-8086-95069168C88B"></a><h4 id="SPGDG-GUID-F175FF6A-5E87-4499-8086-95069168C88B" class="sect4"><span class="enumeration_section">2.6.4</span>在属性图的文本索引上执行搜索查询</h4>
                  <div>
                     <p>Oracle Spatial and Graph提供了一组实用程序，用于通过自动和手动文本索引执行文本搜索查询。这些实用程序不同于基于特定键/值对的查询，以及通过单个或多个键执行文本搜索（具有扩展查询选项，例如通配符，模糊搜索和范围查询）。</p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-E54C31E3-6DA4-4E75-A194-D3090A72C52C">使用Oracle Text在文本索引上执行搜索查询</a><br></li>
                        <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-D2358E05-A701-4285-8A25-B1C4CCD2C476">使用Apache Lucene在文本索引上执行搜索查询</a><br></li>
                        <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-A622D5B1-6515-419B-AF22-327B8C10F57E">使用SolrCloud在文本索引上执行搜索查询</a><br></li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="using-property-graphs-oracle-database.html#GUID-72E0D670-D477-4C0F-914C-8E70E45F9692" title="Oracle Spatial and Graph属性图支持中的索引允许通过特定键/值或键/文本对快速检索元素。这些索引是基于元素类型（顶点或边），一组键（和值）和索引类型创建的。">管理属性图数据的文本索引</a></p>
                        </div>
                     </div>
                  </div>
                  
                  <div class="props_rev_3"><a id="GUID-E54C31E3-6DA4-4E75-A194-D3090A72C52C" name="GUID-E54C31E3-6DA4-4E75-A194-D3090A72C52C"></a><h5 id="SPGDG-GUID-E54C31E3-6DA4-4E75-A194-D3090A72C52C" class="sect5"><span class="enumeration_section">2.6.4.1</span>使用Oracle Text在文本索引上执行搜索查询</h5>
                     <div>
                        <p>Oracle Text上的文本搜索查询将转换为带有“ <span class="italic">contains</span> ”子句的SELECT SQL查询，该子句包括分数范围和排序以及分数ID。 Oracle的属性图包含一个名为<code class="codeph">OracleTextQueryObject</code>的实用程序，它允许您通过Oracle Text索引执行文本搜索查询。
                        </p>
                        <p>以下代码片段使用Oracle Text创建自动索引，并通过指定特定键/值对对文本索引执行查询。</p><pre class="oac_no_warn" dir="ltr">String prefOwner =“scott”; String datastore =（String）null; String filter =（String）null; String storage =（String）null; String wordlist =（String）null; String stoplist =（String）null; String lexer =“OPG_AUTO_LEXER”; String options =（String）null; OracleIndexParameters params = OracleTextIndexParameters.buildOracleText（prefOwner，datastore，filter，storage，wordlist，stoplist，lexer，dop，options）; opg.setDefaultIndexParameters（indexParams）; //在所有现有属性上创建自动索引，对所有opg.createKeyIndex使用通配符（（“*”，Vertex.class）; //获取自动索引对象OracleIndex &lt;Vertex&gt; index =（（OracleIndex &lt;Vertex&gt;）opg。 getAutoIndex（Vertex.class）; //为Oracle Text创建文本查询对象OracleTextQueryObject otqo = OracleTextQueryObject.getInstance（“Obama”/ *查询正文* /，1 / *得分* /，ScoreRange。积极/ *分数范围* /，方向。ASC / *按方向排序* /）; Iterator &lt;Vertex&gt; vertices = index.get（“name”，otqo）.iterator（）; System.out.println（“-----带查询的顶点：”+ otqo.toString（）+“-----”）; countV = 0; while（vertices.hasNext（））{System.out.println（vertices.next（））; countV ++; System.out.println（“Vertices found：”+ countV）;</pre><p>您可以通过指定要执行查询的数据类型类来过滤匹配键/值对的日期类型。以下代码片段对文本索引执行查询，以检索具有包含单词<span class="italic">Obama</span>的String值的所有属性。
                        </p><pre class="oac_no_warn" dir="ltr">//为Oracle Text创建文本查询对象OracleTextQueryObject otqo = OracleTextQueryObject.getInstance（“Obama”/ *查询正文* /，1 / *得分* /，ScoreRange。积极/ *分数范围* /，方向。ASC / *按方向排序* /，“name”，String.class）; Iterator &lt;Vertex&gt; vertices = index.get（“name”，otqo）.iterator（）; System.out.println（“-----带查询的顶点：”+ otqo.toString（）+“-----”）; countV = 0; while（vertices.hasNext（））{System.out.println（vertices.next（））; countV ++; System.out.println（“Vertices found：”+ countV）;</pre></div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="using-property-graphs-oracle-database.html#GUID-F175FF6A-5E87-4499-8086-95069168C88B">在属性图的文本索引上执行搜索查询</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
                  <div class="props_rev_3"><a id="GUID-D2358E05-A701-4285-8A25-B1C4CCD2C476" name="GUID-D2358E05-A701-4285-8A25-B1C4CCD2C476"></a><h5 id="SPGDG-GUID-D2358E05-A701-4285-8A25-B1C4CCD2C476" class="sect5"><span class="enumeration_section">2.6.4.2</span>使用Apache Lucene在文本索引上执行搜索查询</h5>
                     <div>
                        <p>以下代码片段使用Apache Lucene创建自动索引，并通过指定特定键/值对对文本索引执行查询。</p><pre class="oac_no_warn" dir="ltr">//执行并行数据加载OraclePropertyGraphDataLoader opgdl = OraclePropertyGraphDataLoader.getInstance（）; opgdl.loadData（opg，szOPVFile，szOPEFile，2 / * dop * /，1000，true，“PDML = T，PDDL = T，NO_DUP = T，”）; //使用Apache Lucene引擎创建自动索引。//指定索引目录参数（目录数，//数据库连接数，批量大小，提交大小，//启用数据类型，位置）OracleIndexParameters indexParams = OracleIndexParameters.buildFS（4,4,10000,50000，true，“ / home / data / text-index“）; opg.setDefaultIndexParameters（indexParams）; //为所有顶点创建上述属性的手动索引OracleIndex &lt;Edge&gt; index =（（OracleIndex &lt;Edge&gt;）opg.createIndex（“myIdx”，Edge.class））; Vertex v1 = opg.getVertices（“name”，“Barack Obama”）。iterator（）。next（）; Iterator &lt;Edge&gt; edges = v1.getEdges（Direction。OUT，“合作”）。iterator（）; while（edges.hasNext（））{Edge edge = edges.next（）; Vertex vIn = edge.getVertex（Direction。在）; index.put（“collaboratesWith”，vIn.getProperty（“name”），edge）; index.put（“country”，vIn.getProperty（“country”），edge）; } //使用true参数支持通配符搜索。Iterator &lt;Edge&gt; edges = index.get（“country”，“United States”）。iterator（）; System.out.println（“-----带有查询的边缘：”+ queryExpr +“-----”）; long countE = 0; while（edges.hasNext（））{System.out.println（edges.next（））; countE ++; System.out.println（“Edges found：”+ countE）;</pre><p>在这种情况下，文本索引将从键和值对象中生成搜索查询。如果未指定或启用<code class="codeph">useWildcards</code>标志，则检索到的结果将仅包含完全匹配。如果值对象是数字或日期时间值，则生成的查询将是包含范围查询，其中下限和上限由值定义。仅检索数字或日期时间匹配。
                        </p>
                        <p>另一方面，如果值是字符串，则无论数据类型如何，都将检索所有匹配的键/值对。此类查询的结果文本查询是一个布尔查询，其中包含一组可选搜索项，每个支持的数据类型一个。有关数据类型处理的更多详细信息，请参阅<a href="using-property-graphs-oracle-database.html#GUID-26C80DDB-DA5A-48B6-B729-9BE34DECCBB6">处理数据类型</a> 。
                        </p>
                        <p>这样，前面的代码生成一个查询表达式<span class="italic">country1：“United States”OR country9：“United States”OR ... OR countryE：“United States”</span> （如果Lucene的数据类型处理已启用）或<span class="italic">国家/地区：“1United States”OR country：“2United States”OR ... OR country：“EUnited States”</span> （如果Lucene的数据类型处理被禁用）。
                        </p>
                        <p>使用启用了通配符的String值对象需要使用Apache Lucene语法编写该值。有关使用Apache Lucene的文本搜索语法的详细信息，请参阅https://lucene.apache.org/core/2_9_4/queryparsersyntax.html <a href="https://lucene.apache.org/core/2_9_4/queryparsersyntax.html" target="_blank">https://lucene.apache.org/core/2_9_4/queryparsersyntax.html</a> 。</p>
                        <p>您可以通过指定要执行查询的数据类型类来过滤匹配键/值对的日期类型。以下代码片段使用仅具有String数据类型的单个键/值对对文本索引执行查询。以下代码生成查询表达式<span class="italic">country1：“United States”</span> （如果启用了Lucene的数据类型处理）或<span class="italic">country：“1United States”</span> （如果禁用Lucene的数据类型处理）。
                        </p><pre class="oac_no_warn" dir="ltr">//使用true参数支持通配符搜索。Iterator &lt;Edge&gt; edges = index.get（“country”，“United States”，true，String.class）.iterator（）; System.out.println（“-----带有查询的边缘：”+ queryExpr +“-----”）; long countE = 0; while（edges.hasNext（））{System.out.println（edges.next（））; countE ++; System.out.println（“Edges found：”+ countE）;</pre><p>处理布尔运算符时，每个后续键/值对必须附加数据类型的前缀/后缀，以便查询可以找到正确的匹配项。Oracle Spatial and Graph提供了一组实用程序，可帮助用户使用自动和手动文本索引所需的查询语法和数据类型标识符编写自己的Lucene文本搜索查询。</p>
                        <p>该方法<code class="codeph">buildSearchTerm(key, value, dtClass)</code>在<code class="codeph">LuceneIndex</code>通过将数据类型标识符的密钥（或值）和转化的值成基于给定的数据类型所要求的字符串表示<span class="italic">query_expr：</span>创建的表单<span class="italic">字段</span>的查询表达式和Apache Lucene的数据类型处理配置。
                        </p>
                        <p>以下代码片段使用<code class="codeph">buildSearchTerm</code>方法生成查询表达式<span class="italic">country1：United *</span> （如果启用了Lucene的数据类型处理），或者在前面的示例中使用<span class="italic">country：1United *</span> （如果禁用了Lucene的数据类型处理）：</p><pre class="oac_no_warn" dir="ltr">String szQueryStrCountry = index.buildSearchTerm（“country”，“United *”，String.class）;</pre><p>要将键和值作为单个对象处理以使用所需语法构建不同的Lucene Query（如<code class="codeph">WildcardQuery</code> <code class="codeph">appendDatatypesSuffixToKey(key, dtClass)</code> ， <code class="codeph">appendDatatypesSuffixToValue(value, dtClass)</code> <code class="codeph">appendDatatypesSuffixToKey(key, dtClass)</code>和<code class="codeph">appendDatatypesSuffixToValue(value, dtClass)</code> <code class="codeph">LuceneIndex</code>将追加相应的数据类型标识符并进行转换根据给定的数据类型将值转换为所需的Lucene字符串表示形式。
                        </p>
                        <p>以下代码片段使用<code class="codeph">appendDatatypesSuffixToKey</code>方法生成Lucene文本查询中所需的字段名称。如果启用了Lucene的数据类型处理，则返回的字符串将追加String数据类型标识符作为键的后缀（ <code class="codeph">country1</code> ）。在任何其他情况下，检索到的字符串将是原始密钥（ <code class="codeph">country</code> ）。
                        </p><pre class="oac_no_warn" dir="ltr">String key = index.appendDatatypesSuffixToKey（“country”，String.class）;</pre><p>下一个代码片段使用<code class="codeph">appendDatatypesSuffixToValue</code>方法生成Lucene文本查询中所需的查询体表达式。如果禁用Lucene的数据类型处理，则返回的字符串将追加String数据类型标识符作为键的前缀（ <code class="codeph">1United*</code> ）。在所有其他情况下，返回的字符串将是值（ <code class="codeph">United*</code> ）的字符串表示形式。
                        </p><pre class="oac_no_warn" dir="ltr">String value = index.appendDatatypesSuffixToValue（“United *”，String.class）;</pre><p><code class="codeph">LuceneIndex</code>还支持使用方法<code class="codeph">buildSearchTermObject(key, value, dtClass)</code>生成Term对象。术语对象通常用于不同类型的Lucene Query对象中，以约束要检索的文档的字段和值。以下代码片段显示如何使用<code class="codeph">buildSearchTermObject</code>方法创建通配符查询对象。
                        </p><pre class="oac_no_warn" dir="ltr">术语term = index.buildSearchTermObject（“country”，“United *”，String.class）;查询查询=新的WildcardQuery（term）;</pre></div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="using-property-graphs-oracle-database.html#GUID-F175FF6A-5E87-4499-8086-95069168C88B">在属性图的文本索引上执行搜索查询</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
                  <div class="props_rev_3"><a id="GUID-A622D5B1-6515-419B-AF22-327B8C10F57E" name="GUID-A622D5B1-6515-419B-AF22-327B8C10F57E"></a><h5 id="SPGDG-GUID-A622D5B1-6515-419B-AF22-327B8C10F57E" class="sect5"><span class="enumeration_section">2.6.4.3</span>使用SolrCloud在文本索引上执行搜索查询</h5>
                     <div>
                        <p>以下代码片段使用SolrCloud创建自动索引，并通过指定特定键/值对对文本索引执行查询。</p><pre class="oac_no_warn" dir="ltr">//使用SolrCloud创建手动文本索引//指定索引目录参数：配置名称，Solr服务器URL，Solr节点集，//复制因子，zookeeper超时（秒），//每个节点的最大分片数，//数连接到数据库，批量大小，提交大小，//写入超时（以秒为单位）String configName =“opgconfig”; String solrServerUrl =“nodea：2181 / solr”String solrNodeSet =“nodea：8983_solr，nodeb：8983_solr，”+“nodec：8983_solr，noded：8983_solr”; int zkTimeout = 15; int numShards = 4; int replicationFactor = 1; int maxShardsPerNode = 1; OracleIndexParameters indexParams = OracleIndexParameters.buildSolr（configName，solrServerUrl，solrNodeSet，zkTimeout，numShards，replicationFactor，maxShardsPerNode，4,10000,500000,15）; opg.setDefaultIndexParameters（indexParams）; //指定索引键String [] indexedKeys = new String [4]; indexedKeys [0] =“name”; indexedKeys [1] =“角色”; indexedKeys [2] =“宗教”; indexedKeys [3] =“国家”; //为所有顶点的上述属性创建自动索引opg.createKeyIndex（indexedKeys，Vertex.class）; //为所有顶点创建上述属性的手动索引OracleIndex &lt;Vertex&gt; index =（（OracleIndex &lt;Vertex&gt;）opg.getAutoIndex（Vertex.class）; Iterator &lt;Vertex&gt; vertices = index.get（“country”，“United States” “）.iterator（）; System.out.println（”-----带查询的顶点：“+ queryExpr +”-----“）; countV = 0; while（vertices.hasNext（））{System .out.println（vertices.next（））; countV ++;} System.out.println（“Vertices found：”+ countV）;</pre><p>在这种情况下，文本索引将从值对象中生成搜索查询。如果未指定或启用<code class="codeph">useWildcards</code>标志，则检索到的结果将仅包含完全匹配。如果值对象是数字或日期时间值，则生成的查询将是包含范围查询，其中下限和上限由值定义。仅检索数字或日期时间匹配。
                        </p>
                        <p>另一方面，如果值是字符串，则无论数据类型如何，都将检索所有匹配的键/值对。此类查询的结果文本查询是一个布尔查询，其中包含一组可选搜索项，每个支持的数据类型一个。有关数据类型处理的更多详细信息，请参阅<a href="using-property-graphs-oracle-database.html#GUID-26C80DDB-DA5A-48B6-B729-9BE34DECCBB6">处理数据类型</a> 。
                        </p>
                        <p>这样，前面的代码生成一个查询表达式<span class="italic">country_str：“United States”OR country_ser：“United States”OR ... OR country_json：“United States”</span> 。
                        </p>
                        <p>使用启用了通配符的String值对象需要使用Apache Lucene语法编写该值。有关使用Apache Lucene的文本搜索语法的详细信息，请参阅https://lucene.apache.org/core/2_9_4/queryparsersyntax.html <a href="https://lucene.apache.org/core/2_9_4/queryparsersyntax.html" target="_blank">https://lucene.apache.org/core/2_9_4/queryparsersyntax.html</a> 。</p>
                        <p>您可以通过指定要执行查询的数据类型类来过滤匹配键/值对的日期类型。以下代码片段使用仅具有String数据类型的单个键/值对对文本索引执行查询。该代码生成一个查询表达式<span class="italic">country_str：“United States”。</span></p><pre class="oac_no_warn" dir="ltr">//使用true参数支持通配符搜索。Iterator &lt;Edge&gt; edges = index.get（“country”，“United States”，true，String.class）.iterator（）; System.out.println（“-----带有查询的边缘：”+ queryExpr +“-----”）; countE = 0; while（edges.hasNext（））{System.out.println（edges.next（））; countE ++; System.out.println（“Edges found：”+ countE）;</pre><p>处理布尔运算符时，每个后续键/值对必须附加数据类型的前缀/后缀，以便查询可以找到正确的匹配项。Oracle Spatial and Graph提供了一组实用程序，可帮助用户使用自动和手动文本索引所需的查询语法和数据类型标识符编写自己的Lucene文本搜索查询。</p>
                        <p><code class="codeph">buildSearchTerm(key, value, dtClass)</code>的方法<code class="codeph">buildSearchTerm(key, value, dtClass)</code>通过将数据类型标识符添加到键（或值）并使用所需的数据类型格式将值转换为所需的字符串表示形式<code class="codeph">SolrIndex</code>创建表单<span class="italic">字段</span>的查询表达式<span class="italic">：query_expr</span>按指数。
                        </p>
                        <p>以下代码片段使用<code class="codeph">buildSearchTerm</code>方法生成上一个示例中使用的查询表达式<span class="italic">country_str：United *</span> ：</p><pre class="oac_no_warn" dir="ltr">String szQueryStrCountry = index.buildSearchTerm（“country”，“United *”，String.class）;</pre><p>为了解决键和值作为各个对象以构建不同SolrCloud查询像<code class="codeph">WildcardQuery</code>使用所需的语法，所述方法<code class="codeph">appendDatatypesSuffixToKey(key, dtClass)</code>和<code class="codeph">appendDatatypesSuffixToValue(value, dtClass)</code>在<code class="codeph">SolrIndex</code>将追加适当的数据类型标识符和变换基于给定数据类型的所需SolrCloud字符串表示的键和值。
                        </p>
                        <p>以下代码片段使用<code class="codeph">appendDatatypesSuffixToKey</code>方法生成Lucene文本查询中所需的字段名称。如果启用了Lucene的数据类型处理，则返回的字符串将追加String数据类型标识符作为键的后缀（ <code class="codeph">country_str</code> ）。
                        </p><pre class="oac_no_warn" dir="ltr">String key = index.appendDatatypesSuffixToKey（“country”，String.class）;</pre><p>下一个代码片段使用<code class="codeph">appendDatatypesSuffixToValue</code>方法生成Lucene文本查询中所需的查询体表达式。如果禁用Lucene的数据类型处理，则返回的字符串将追加String数据类型标识符作为键的前缀（ <code class="codeph">1United*</code> ）。在所有其他情况下，返回的字符串将是值（ <code class="codeph">United*</code> ）的字符串表示形式。
                        </p><pre class="oac_no_warn" dir="ltr">String key = index.appendDatatypesSuffixToKey（“country”，String.class）;</pre><p>下一个代码片段使用<code class="codeph">appendDatatypesSuffixToValue</code>方法生成<code class="codeph">SolrCloud</code>文本查询中所需的查询正文表达式。返回的字符串将是值（ <code class="codeph">United*</code> ）的字符串表示形式。
                        </p><pre class="oac_no_warn" dir="ltr">String value = index.appendDatatypesSuffixToValue（“United *”，String.class）;</pre></div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="using-property-graphs-oracle-database.html#GUID-F175FF6A-5E87-4499-8086-95069168C88B">在属性图的文本索引上执行搜索查询</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div>
               <div class="props_rev_3"><a id="GUID-26C80DDB-DA5A-48B6-B729-9BE34DECCBB6" name="GUID-26C80DDB-DA5A-48B6-B729-9BE34DECCBB6"></a><h4 id="SPGDG-GUID-26C80DDB-DA5A-48B6-B729-9BE34DECCBB6" class="sect4"><span class="enumeration_section">2.6.5</span>处理数据类型</h4>
                  <div>
                     <p>Oracle的属性图支持根据值数据类型索引和存储元素的键/值对。处理数据类型的主要目的是提供广泛的查询支持，如数字和日期范围查询。</p>
                     <p>默认情况下，基于值的数据类型，对特定键/值对的搜索与查询表达式匹配。例如，要查找键/值对<code class="codeph">age:30</code>顶点，将使用数据类型为整数的所有年龄字段执行查询。如果值是查询表达式，您还可以通过调用API <code class="codeph">get(String key, Object value, Class dtClass, Boolean useWildcards)</code>来指定要查找的值的数据类型类。如果未指定数据类型，则查询表达式将与所有可能的数据类型匹配。
                     </p>
                     <p>处理布尔运算符时，每个后续键/值对必须附加数据类型的前缀/后缀，以便查询可以找到正确的匹配项。以下主题包括如何为Oracle Text，Apache Lucene和SolrCloud附加此前缀/后缀。</p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-BC847F16-AA8A-4CD0-BEF3-F50344F5EA9B">处理Oracle Text上的数据类型</a><br></li>
                        <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-3B1143F6-AEE0-46A9-8BE4-FA7860A844CD">在Apache Lucene上附加数据类型标识符</a><br></li>
                        <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-996CAF8D-F77E-4624-8684-695434B555A3">在SolrCloud上附加数据类型标识符</a><br></li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="using-property-graphs-oracle-database.html#GUID-72E0D670-D477-4C0F-914C-8E70E45F9692" title="Oracle Spatial and Graph属性图支持中的索引允许通过特定键/值或键/文本对快速检索元素。这些索引是基于元素类型（顶点或边），一组键（和值）和索引类型创建的。">管理属性图数据的文本索引</a></p>
                        </div>
                     </div>
                  </div>
                  
                  <div class="props_rev_3"><a id="GUID-BC847F16-AA8A-4CD0-BEF3-F50344F5EA9B" name="GUID-BC847F16-AA8A-4CD0-BEF3-F50344F5EA9B"></a><h5 id="SPGDG-GUID-BC847F16-AA8A-4CD0-BEF3-F50344F5EA9B" class="sect5"><span class="enumeration_section">2.6.5.1</span>在Oracle Text上处理数据类型</h5>
                     <div>
                        <p>使用Oracle Text的文本索引是在属性图表的K和V文本列上创建的。为了在所有可用数据类型上提供文本索引功能，Oracle使用数字，空间和日期时间键/值对的字符串表示填充V列。</p>
                        <p>要指定填充V列时使用的日期时间和数字格式，可以使用方法<code class="codeph">setNumberToCharSqlFormatString</code>和<code class="codeph">setTimeToCharSqlFormatString</code> 。以下代码段显示了如何在属性图实例中设置日期时间和数字格式。
                        </p><pre class="oac_no_warn" dir="ltr">OraclePropertyGraph opg = OraclePropertyGraph.getInstance（args，szGraphName）; opg.setNumberToCharSqlFormatString（ “TM9”）; opg.setTimeToCharSqlFormatString（ “SYYYY-MM-DD \” T \ “HH24：MI：SS.FF9TZH：TZM”）;</pre><p>在数字或日期时间值上执行文本搜索查询时，应使用与属性图关联的格式使用文本表达式。<code class="codeph">OraclePropertyGraph</code>包含一个实用程序API <code class="codeph">opg.parseValueToCharSQLFormatString</code> ，它允许您将数字或日期时间对象解析为V列存储中使用的格式。以下代码段使用日期值调用此函数，并从检索到的文本中创建文本查询对象。
                        </p><pre class="oac_no_warn" dir="ltr">日期d =新的java.util。日期（100升）; String szDate = opg.parseValueToCharSQLFormatString（d）; //为Oracle Text创建文本查询对象OracleTextQueryObject otqo = OracleTextQueryObject.getInstance（szDate / *查询正文* /，1 / *得分* /，ScoreRange。积极/ *分数范围* /，方向。ASC / *按方向排序）;</pre></div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="using-property-graphs-oracle-database.html#GUID-26C80DDB-DA5A-48B6-B729-9BE34DECCBB6">处理数据类型</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
                  <div class="props_rev_3"><a id="GUID-3B1143F6-AEE0-46A9-8BE4-FA7860A844CD" name="GUID-3B1143F6-AEE0-46A9-8BE4-FA7860A844CD"></a><h5 id="SPGDG-GUID-3B1143F6-AEE0-46A9-8BE4-FA7860A844CD" class="sect5"><span class="enumeration_section">2.6.5.2</span>在Apache Lucene上附加数据类型标识符</h5>
                     <div>
                        <p>启用Lucene的数据类型处理时，必须将正确的数据类型标识符作为后缀附加到查询表达式中的键。这可以通过对键执行<code class="codeph">String.concat()</code>操作来完成。如果禁用Lucene的数据类型处理，则必须在值String中插入数据类型标识符作为前缀。下表显示了可用于使用Apache Lucene进行文本索引的数据类型标识符（另请参阅<code class="codeph">LuceneIndex</code>的Javadoc）。
                        </p>
                        <div class="tblformal" id="GUID-3B1143F6-AEE0-46A9-8BE4-FA7860A844CD__APACHELUCENEDATATYPEIDENTIFIERS-11261E8F">
                           <p class="titleintable">表2-1 Apache Lucene数据类型标识符</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="Apache Lucene数据类型标识符" width="100%" border="1" summary="Apache Lucene Data Type Identifiers. Column 1 is Lucene Data Type Identifier, and column 2 is Description." frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="51%" id="d4109e5642">Lucene数据类型标识符</th>
                                    <th align="left" valign="bottom" width="49%" id="d4109e5645">描述</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="51%" id="d4109e5650" headers="d4109e5642 ">
                                       <p>TYPE_DT_STRING</p>
                                    </td>
                                    <td align="left" valign="top" width="49%" headers="d4109e5650 d4109e5645 ">
                                       <p>串</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="51%" id="d4109e5657" headers="d4109e5642 ">
                                       <p>TYPE_DT_BOOL</p>
                                    </td>
                                    <td align="left" valign="top" width="49%" headers="d4109e5657 d4109e5645 ">
                                       <p>布尔</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="51%" id="d4109e5664" headers="d4109e5642 ">
                                       <p>TYPE_DT_DATE</p>
                                    </td>
                                    <td align="left" valign="top" width="49%" headers="d4109e5664 d4109e5645 ">
                                       <p>日期</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="51%" id="d4109e5671" headers="d4109e5642 ">
                                       <p>TYPE_DT_FLOAT</p>
                                    </td>
                                    <td align="left" valign="top" width="49%" headers="d4109e5671 d4109e5645 ">
                                       <p>浮动</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="51%" id="d4109e5678" headers="d4109e5642 ">
                                       <p>TYPE_DT_DOUBLE</p>
                                    </td>
                                    <td align="left" valign="top" width="49%" headers="d4109e5678 d4109e5645 ">
                                       <p>双</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="51%" id="d4109e5685" headers="d4109e5642 ">
                                       <p>TYPE_DT_LONG</p>
                                    </td>
                                    <td align="left" valign="top" width="49%" headers="d4109e5685 d4109e5645 ">
                                       <p>长</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="51%" id="d4109e5692" headers="d4109e5642 ">
                                       <p>TYPE_DT_CHAR</p>
                                    </td>
                                    <td align="left" valign="top" width="49%" headers="d4109e5692 d4109e5645 ">
                                       <p>字符</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="51%" id="d4109e5699" headers="d4109e5642 ">
                                       <p>TYPE_DT_SHORT</p>
                                    </td>
                                    <td align="left" valign="top" width="49%" headers="d4109e5699 d4109e5645 ">
                                       <p>短</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="51%" id="d4109e5706" headers="d4109e5642 ">
                                       <p>TYPE_DT_BYTE</p>
                                    </td>
                                    <td align="left" valign="top" width="49%" headers="d4109e5706 d4109e5645 ">
                                       <p>字节</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="51%" id="d4109e5713" headers="d4109e5642 ">
                                       <p>TYPE_DT_SPATIAL</p>
                                    </td>
                                    <td align="left" valign="top" width="49%" headers="d4109e5713 d4109e5645 ">
                                       <p>空间的</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="51%" id="d4109e5720" headers="d4109e5642 ">
                                       <p>TYPE_DT_INTEGER</p>
                                    </td>
                                    <td align="left" valign="top" width="49%" headers="d4109e5720 d4109e5645 ">
                                       <p>整数</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="51%" id="d4109e5728" headers="d4109e5642 ">
                                       <p>TYPE_DT_SERIALIZABLE</p>
                                    </td>
                                    <td align="left" valign="top" width="49%" headers="d4109e5728 d4109e5645 ">
                                       <p>序列化</p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <p>下面的代码片段使用Lucene的数据类型处理创建边缘的手动索引，添加数据，然后在手动索引上执行查询以获得具有键/值对的所有边缘<code class="codeph">collaboratesWith:Beyonce AND country1:United*</code> using wildcards。
                        </p><pre class="oac_no_warn" dir="ltr">OraclePropertyGraph opg = OraclePropertyGraph.getInstance（...）; String szOPVFile =“../../data/connections.opv“; String szOPEFile =”../../data/connections.ope“; //并行数据加载OraclePropertyGraphDataLoader opgdl = OraclePropertyGraphDataLoader.getInstance（）; opgdl.loadData（opg，szOPVFile，szOPEFile，2 / * dop * /，1000，true，”PDML = T，PDDL = T，NO_DUP = T，“）; //指定索引目录参数（目录数，//数据库连接数，批量大小，提交大小，//启用数据类型，位置）OracleIndexParameters indexParams = OracleIndexParameters .buildFS（4,4,10000,50000，true，“/ home / data / text-index”）; opg.setDefaultIndexParameters（indexParams）; //为所有边缘的上述属性创建手动索引OracleIndex &lt;Edge&gt; index =（ （OracleIndex &lt;Edge&gt;）opg.createIndex（“myIdx”，Edge.class））; Vertex v1 = opg.getVertices（“name”，“Barack Obama”）。iterator（）。next（）; Iterator &lt;Edge&gt; edges = v1.getEdges（方向。OUT，“合作”）。iterator（）; while（edges.hasNext（））{Edge edge = edges.next（）; Vertex vIn = edge.getVertex（Direction。在）; index.put（“collaboratesWith”，vIn.getProperty（“name”），edge）; index.put（“country”，vIn.getProperty（“country”），edge）; } //使用true参数支持通配符搜索。String key =“country”; key = key.concat（String.valueOf（oracle.pg.text.lucene。LuceneIndex。TYPE_DT_STRING））; String queryExpr =“Beyonce AND”+ key +“：United *”; edges = index.get（“collaboratesWith”，queryExpr，true / * UseWildcard * /）。iterator（）; System.out.println（“-----带有查询的边缘：”+ queryExpr +“-----”）; countE = 0; while（edges.hasNext（））{System.out.println（edges.next（））; countE ++; System.out.println（“Edges found：”+ countE）;</pre><p>上面的代码示例可能会产生如下输出：</p><pre class="oac_no_warn" dir="ltr">-----边缘名为Beyonce AND country1：United * -----来自Vertex ID 1的Edge ID 1000 {country：str：美国，姓名：str：Barack Obama，职业：str：美国第44任总统美国，政党：str：民主党，宗教：str：基督教，角色：str：政治权威} = [合作] =&gt; Vertex ID 2 {country：str：美国，音乐类型：str：pop soul，name： str：Beyonce，角色：str：歌手女演员} edgeKV [{weight：flo：1.0}]边缘发现：1</pre><p>以下代码片段在顶点上创建自动索引，禁用Lucene的数据类型处理，添加数据，然后对前一个示例中的手动索引执行查询以获取具有键/值对<code class="codeph">country:United* AND role:1*political*</code> / <code class="codeph">country:United* AND role:1*political*</code>所有顶点<code class="codeph">country:United* AND role:1*political*</code>使用通配符。
                        </p><pre class="oac_no_warn" dir="ltr">OraclePropertyGraph opg = OraclePropertyGraph.getInstance（...）; String szOPVFile =“../../data/connections.opv“; String szOPEFile =”../../data/connections.ope“; //并行数据加载OraclePropertyGraphDataLoader opgdl = OraclePropertyGraphDataLoader.getInstance（）; opgdl.loadData（opg，szOPVFile，szOPEFile，2 / * dop * /，1000，true，”PDML = T，PDDL = T，NO_DUP = T，“）; //使用Apache Lucene引擎创建自动索引。//指定索引目录参数（目录数，//数据库连接数，批量大小，提交大小，//启用数据类型，位置）OracleIndexParameters indexParams = OracleIndexParameters.buildFS（4,4,10000,50000，false，“ / home / data / text-index“）; opg.setDefaultIndexParameters（indexParams）; //指定索引键String [] indexedKeys = new String [4]; indexedKeys [0] =“name”; indexedKeys [1] =“角色”; indexedKeys [2] =“宗教”; indexedKeys [3] =“国家”; //为所有顶点的上述属性创建自动索引opg.createKeyIndex（indexedKeys，Vertex.class）; //使用true参数支持通配符搜索。String value =“* political *”; value = String.valueOf（LuceneIndex。TYPE_DT_STRING）+值; String queryExpr =“United * AND role：”+ value; vertices = opg.getVertices（“country”，queryExpr，true / * useWildcard * /）。iterator（）; System.out.println（“-----带查询的顶点：”+ queryExpr +“-----”）; countV = 0; while（vertices.hasNext（））{System.out.println（vertices.next（））; countV ++; System.out.println（“Vertices found：”+ countV）;</pre><p>上面的代码示例可能会产生如下输出：</p><pre class="oac_no_warn" dir="ltr">-----具有查询的顶点：联合*和角色：1 *政治* -----顶点ID 30 {名称：str：杰里布朗，角色：str：政治权威，职业：str：第34和第39州长加利福尼亚州，国家：str：美国，政党：str：民主党，宗教：str：罗马天主教} Vertex ID 24 {姓名：str：Edward Snowden，角色：str：政治权威，职业：str：系统管理员，国家： str：美国，宗教：str：buddhism} Vertex ID 22 {name：str：John Kerry，角色：str：政治权威，国家：str：美国，政党：str：民主，职业：str：68th United States国务卿，宗教：str：天主教}顶点ID 21 {姓名：str：希拉里克林顿，角色：str：政治权威，国家：str：美国，政党：str：民主，占领：str：第67位美国国务卿国家，宗教：str：Methodism} Vertex ID 19 {姓名：str：Kirsten Gillibrand，角色：str：政治权威，国家：str：美国，政党：str：民主，职业：str：初级联合来自纽约的参议员，宗教：str：Methodism} Vertex ID 13 {姓名：str：Ertharin Cousin，角色：str：政治权威，国家：str：美国，政党：str：民主国家} Vertex ID 11 {姓名： str：Eric Holder，角色：str：政治权威，国家：str：美国，政党：str：民主党，职业：str：美国副检察长} Vertex ID 1 {姓名：str：Barack Obama，角色：str ：政治权威，职业：str：美利坚合众国第44任总统，国家：str：美国，政党：str：民主党，宗教：str：基督教}发现顶点：8</pre></div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="using-property-graphs-oracle-database.html#GUID-26C80DDB-DA5A-48B6-B729-9BE34DECCBB6">处理数据类型</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
                  <div class="props_rev_3"><a id="GUID-996CAF8D-F77E-4624-8684-695434B555A3" name="GUID-996CAF8D-F77E-4624-8684-695434B555A3"></a><h5 id="SPGDG-GUID-996CAF8D-F77E-4624-8684-695434B555A3" class="sect5"><span class="enumeration_section">2.6.5.3</span>在SolrCloud附加数据类型标识符</h5>
                     <div>
                        <p>对于SolrCloud文本索引的布尔运算，必须将正确的数据类型标识符作为后缀附加到查询表达式中的键。这可以通过对键执行<code class="codeph">String.concat()</code>操作来完成。以下trable显示了可用于使用SolrCloud进行文本索引的数据类型标识符（请参阅Javadoc for <code class="codeph">SolrIndex</code> ）。
                        </p>
                        <div class="tblformal" id="GUID-996CAF8D-F77E-4624-8684-695434B555A3__SOLRCLOUDDATATYPEIDENTIFIERS-11263D32">
                           <p class="titleintable">表2-2 SolrCloud数据类型标识符</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="SolrCloud数据类型标识符" width="100%" border="1" summary="SolrCloud Data Type Identifiers. Column 1 is SolrCloud Data Type IDentifier, and column 2 is Description." frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="51%" id="d4109e5827">Solr数据类型标识符</th>
                                    <th align="left" valign="bottom" width="49%" id="d4109e5830">描述</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="51%" id="d4109e5835" headers="d4109e5827 ">
                                       <p>TYPE_DT_STRING</p>
                                    </td>
                                    <td align="left" valign="top" width="49%" headers="d4109e5835 d4109e5830 ">
                                       <p>串</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="51%" id="d4109e5842" headers="d4109e5827 ">
                                       <p>TYPE_DT_BOOL</p>
                                    </td>
                                    <td align="left" valign="top" width="49%" headers="d4109e5842 d4109e5830 ">
                                       <p>布尔</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="51%" id="d4109e5849" headers="d4109e5827 ">
                                       <p>TYPE_DT_DATE</p>
                                    </td>
                                    <td align="left" valign="top" width="49%" headers="d4109e5849 d4109e5830 ">
                                       <p>日期</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="51%" id="d4109e5856" headers="d4109e5827 ">
                                       <p>TYPE_DT_FLOAT</p>
                                    </td>
                                    <td align="left" valign="top" width="49%" headers="d4109e5856 d4109e5830 ">
                                       <p>浮动</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="51%" id="d4109e5863" headers="d4109e5827 ">
                                       <p>TYPE_DT_DOUBLE</p>
                                    </td>
                                    <td align="left" valign="top" width="49%" headers="d4109e5863 d4109e5830 ">
                                       <p>双</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="51%" id="d4109e5870" headers="d4109e5827 ">
                                       <p>TYPE_DT_INTEGER</p>
                                    </td>
                                    <td align="left" valign="top" width="49%" headers="d4109e5870 d4109e5830 ">
                                       <p>整数</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="51%" id="d4109e5877" headers="d4109e5827 ">
                                       <p>TYPE_DT_LONG</p>
                                    </td>
                                    <td align="left" valign="top" width="49%" headers="d4109e5877 d4109e5830 ">
                                       <p>长</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="51%" id="d4109e5884" headers="d4109e5827 ">
                                       <p>TYPE_DT_CHAR</p>
                                    </td>
                                    <td align="left" valign="top" width="49%" headers="d4109e5884 d4109e5830 ">
                                       <p>字符</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="51%" id="d4109e5891" headers="d4109e5827 ">
                                       <p>TYPE_DT_SHORT</p>
                                    </td>
                                    <td align="left" valign="top" width="49%" headers="d4109e5891 d4109e5830 ">
                                       <p>短</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="51%" id="d4109e5898" headers="d4109e5827 ">
                                       <p>TYPE_DT_BYTE</p>
                                    </td>
                                    <td align="left" valign="top" width="49%" headers="d4109e5898 d4109e5830 ">
                                       <p>字节</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="51%" id="d4109e5905" headers="d4109e5827 ">
                                       <p>TYPE_DT_SPATIAL</p>
                                    </td>
                                    <td align="left" valign="top" width="49%" headers="d4109e5905 d4109e5830 ">
                                       <p>空间的</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="51%" id="d4109e5913" headers="d4109e5827 ">
                                       <p>TYPE_DT_SERIALIZABLE</p>
                                    </td>
                                    <td align="left" valign="top" width="49%" headers="d4109e5913 d4109e5830 ">
                                       <p>序列化</p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <p>以下代码片段使用SolrCloud在边缘上创建手动索引，添加数据，然后在手动索引上执行查询，以获得具有键/值对的所有边缘<code class="codeph">collaboratesWith:Beyonce AND country1:United*</code> using wildcards。
                        </p><pre class="oac_no_warn" dir="ltr">OraclePropertyGraph opg = OraclePropertyGraph.getInstance（args，szGraphName）; String szOPVFile =“../../data/connections.opv“; String szOPEFile =”../../data/connections.ope“; //并行数据加载OraclePropertyGraphDataLoader opgdl = OraclePropertyGraphDataLoader.getInstance（）; opgdl.loadData（opg，szOPVFile，szOPEFile，2 / * dop * /，1000，true，”PDML = T，PDDL = T，NO_DUP = T，“）; //使用SolrCloud创建手动文本索引//指定索引目录参数：配置名称，Solr服务器URL，Solr节点集，//复制因子，zookeeper超时（秒），//每个节点的最大分片数，//数据库连接数，批量大小，提交大小，//写入超时（以秒为单位）字符串configName =“opgconfig”;字符串solrServerUrl =“nodea：2181 / solr” String solrNodeSet =“nodea：8983_solr，nodeb：8983_solr，”+“nodec：8983_solr，noded：8983_solr”; int zkTimeout = 15; int numShards = 4; int replicationFactor = 1; int maxShardsPerNode = 1; OracleIndexParameters indexParams = OracleIndexParameters.buildSolr （configName，solrServerUrl，solrNodeSet，zkTimeout，numShards，replicationFactor，maxShardsPerNode，4,10000,500000,15）; opg .setDefaultIndexParameters（indexParams）; //为所有顶点创建上述属性的手动索引OracleIndex &lt;Edge&gt; index =（（OracleIndex &lt;Edge&gt;）opg.createIndex（“myIdx”，Edge.class））; Vertex v1 = opg.getVertices（“name”，“Barack Obama”）。iterator（）。next（）; Iterator &lt;Edge&gt; edges = v1.getEdges（Direction。OUT，“合作”）。iterator（）; while（edges.hasNext（））{Edge edge = edges.next（）; Vertex vIn = edge.getVertex（Direction。在）; index.put（“collaboratesWith”，vIn.getProperty（“name”），edge）; index.put（“country”，vIn.getProperty（“country”），edge）; } //使用true参数支持通配符搜索。String key =“country”; key = key.concat（oracle.pg.text.solr。SolrIndex。TYPE_DT_STRING）; String queryExpr =“Beyonce AND”+ key +“：United *”; edges = index.get（“collaboratesWith”，queryExpr，true / ** UseWildcard * /）。iterator（）; System.out.println（“-----带有查询的边缘：”+ queryExpr +“-----”）; countE = 0; while（edges.hasNext（））{System.out.println（edges.next（））; countE ++; System.out.println（“Edges found：”+ countE）;</pre><p>上面的代码示例可能会产生如下输出：</p><pre class="oac_no_warn" dir="ltr">-----边缘名为Beyonce AND country_str：United * -----来自Vertex ID 1的Edge ID 1000 {country：str：美国，姓名：str：Barack Obama，职业：str：美国第44任总统美国，政党：str：民主党，宗教：str：基督教，角色：str：政治权威} = [合作] =&gt; Vertex ID 2 {country：str：美国，音乐类型：str：pop soul，name： str：Beyonce，角色：str：歌手女演员} edgeKV [{weight：flo：1.0}]边缘发现：1</pre></div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="using-property-graphs-oracle-database.html#GUID-26C80DDB-DA5A-48B6-B729-9BE34DECCBB6">处理数据类型</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div>
               <div class="props_rev_3"><a id="GUID-A5797EAF-4165-4ACE-B1BD-0284DA391DB3" name="GUID-A5797EAF-4165-4ACE-B1BD-0284DA391DB3"></a><h4 id="SPGDG-GUID-A5797EAF-4165-4ACE-B1BD-0284DA391DB3" class="sect4"><span class="enumeration_section">2.6.6</span>将Collection的SolrCloud配置上传到Zookeeper</h4>
                  <div>
                     <p>在Oracle Spatial和Graph属性图上使用SolrCloud文本索引之前，必须将集合的配置上载到Zookeeper。这可以使用SolrCloud集群节点之一的ZkCli工具完成。</p>
                     <p>可以在安装主目录下的<code class="codeph">dal/opg-solr-config</code>找到预定义的集合配置目录。以下显示了如何上载<code class="codeph">PropertyGraph</code>配置目录的示例。
                     </p>
                     <ol>
                        <li>
                           <p>将<code class="codeph">$ORACLE_HOME/md/property_graph/dal/opg-solr-config.zip</code>到其中一个Solr集群节点上的<code class="codeph">/tmp</code>目录中。例如：</p><pre class="oac_no_warn" dir="ltr">scp -r $ ORACLE_HOME / md / property_graph / dal / opg-solr-config.zip user @ solr-node：/ tmp</pre></li>
                        <li>
                           <p>使用同一节点上的ZkCli工具执行以下命令，如下所示：</p><pre class="oac_no_warn" dir="ltr">cd / tmp unzip opg-solr-config.zip $ SOLR_HOME / bin / zkcli.sh -zkhost 127.0.0.1:2181/solr -cmd upconfig -confname opgconfig -confdir / tmp / opg-solr-config</pre></li>
                     </ol>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="using-property-graphs-oracle-database.html#GUID-72E0D670-D477-4C0F-914C-8E70E45F9692" title="Oracle Spatial and Graph属性图支持中的索引允许通过特定键/值或键/文本对快速检索元素。这些索引是基于元素类型（顶点或边），一组键（和值）和索引类型创建的。">管理属性图数据的文本索引</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="props_rev_3"><a id="GUID-F198F6FA-875D-42E4-A43C-7A9B01FFEA1E" name="GUID-F198F6FA-875D-42E4-A43C-7A9B01FFEA1E"></a><h4 id="SPGDG-GUID-F198F6FA-875D-42E4-A43C-7A9B01FFEA1E" class="sect4"><span class="enumeration_section">2.6.7</span>更新属性图数据的文本索引上的配置设置</h4>
                  <div>
                     <p>Oracle的属性图支持通过与Oracle Text，Apache Lucene和SolrCloud的集成来管理手动和自动文本索引。在创建时，您必须创建一个<code class="codeph">OracleIndexParameters</code>对象，指定搜索引擎和文本索引要使用的其他配置设置。创建属性图的文本索引后，无法更改这些配置设置。对于自动索引，所有顶点索引键由单个文本索引管理，并且所有边索引键使用在索引第一个顶点或边键时指定的配置由不同的文本索引管理。
                     </p>
                     <p>如果需要更改配置设置，必须先禁用当前索引，然后使用新的<code class="codeph">OracleIndexParameters</code>对象再次创建它。以下代码片段在现有属性图上创建两个基于Apache Lucene的自动索引（在顶点和边上），禁用它们，并重新创建它们以使用SolrCloud。
                     </p><pre class="oac_no_warn" dir="ltr">OraclePropertyGraph opg = OraclePropertyGraph.getInstance（...）; //使用Apache Lucene创建自动索引。//指定索引目录参数（目录数，//数据库连接数，批量大小，提交大小，//启用数据类型，位置）OracleIndexParameters luceneIndexParams = OracleIndexParameters.buildFS（4,4,10000,50000，true，“ / home / oracle / text-index“）; //指定索引键String [] indexedKeys = new String [4]; indexedKeys [0] =“name”; indexedKeys [1] =“角色”; indexedKeys [2] =“宗教”; indexedKeys [3] =“国家”; //为所有顶点的上述属性创建自动索引opg.createKeyIndex（indexedKeys，Vertex.class，luceneIndexParams.getParameters（））; //为所有边创建自动索引权重opg.createKeyIndex（“weight”，Edge.class，luceneIndexParams.getParameters（））; //禁用自动索引来更改参数opg.getOracleIndexManager（）。disableVertexAutoIndexer（）; 。opg.getOracleIndexManager（）disableEdgeAutoIndexer（）; //使用SolrCloud重新创建文本索引//指定索引目录参数：配置名称，Solr服务器URL，Solr节点集，//复制因子，zookeeper超时（秒），//每个节点的最大分片数，//连接数to database，batch size，commit size，// write timeout（in secs）String configName =“opgconfig”; String solrServerUrl =“nodea：2181 / solr”; String solrNodeSet =“nodea：8983_solr，nodeb：8983_solr，”+“nodec：8983_solr，noded：8983_solr”; int zkTimeout = 15; int numShards = 4; int replicationFactor = 1; int maxShardsPerNode = 1; OracleIndexParameters solrIndexParams = OracleIndexParameters.buildSolr（configName，solrServerUrl，solrNodeSet，zkTimeout，numShards，replicationFactor，maxShardsPerNode，4,10000,500000,15）; //为所有顶点的上述属性创建自动索引opg.createKeyIndex（indexedKeys，Vertex.class，solrIndexParams.getParameters（））; //为所有边创建自动索引权重opg.createKeyIndex（“weight”，Edge.class，solrIndexParams.getParameters（））;</pre></div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="using-property-graphs-oracle-database.html#GUID-72E0D670-D477-4C0F-914C-8E70E45F9692" title="Oracle Spatial and Graph属性图支持中的索引允许通过特定键/值或键/文本对快速检索元素。这些索引是基于元素类型（顶点或边），一组键（和值）和索引类型创建的。">管理属性图数据的文本索引</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="props_rev_3"><a id="GUID-7C5C1BDB-13EA-4504-9B4F-B8F7D788AE52" name="GUID-7C5C1BDB-13EA-4504-9B4F-B8F7D788AE52"></a><h4 id="SPGDG-GUID-7C5C1BDB-13EA-4504-9B4F-B8F7D788AE52" class="sect4"><span class="enumeration_section">2.6.8</span>对属性图数据的文本索引使用并行查询</h4>
                  <div>
                     <p>Oracle Spatial and Graph中的文本索引允许使用并行查询执行，通过特定键/值或键/文本对在数百万个顶点和边上执行文本查询。</p>
                     <p>并行文本查询是一种优化的解决方案，它利用SolrCloud（或Apache Lucene中的子目录）中的分片中索引中的数据分布，因此使用单独的索引连接查询每个分片。这涉及到SolrCloud（或Apache Lucene）搜索引擎的多个线程和连接，以提高读取操作的性能并从索引中检索多个元素。请注意，此方法不会根据分数对匹配结果进行排名。</p>
                     <p>并行文本查询将生成一个数组，其中每个元素包含所有顶点（或边），其属性与来自分片的给定K / V对匹配。查询的分片子集将由给定的起始子目录ID和提供的连接数组的大小分隔。这样，子集将考虑[start，start  -  1 +连接数组大小]范围内的分片。注意，整数ID（在[0，N-1]范围内）被分配给具有N个分片的索引中的所有分片。</p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-BDA00920-033D-4E99-AB1E-69E5DC28354C">使用Oracle Text进行并行文本搜索</a><br></li>
                        <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-39271C38-DD04-4883-BA8F-010C549EC934">使用Apache Lucene进行并行文本查询</a><br></li>
                        <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-EF81CE3F-8C63-4A0F-9D4F-84F8740ED446">使用SolrCloud进行并行文本搜索</a><br></li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="using-property-graphs-oracle-database.html#GUID-72E0D670-D477-4C0F-914C-8E70E45F9692" title="Oracle Spatial and Graph属性图支持中的索引允许通过特定键/值或键/文本对快速检索元素。这些索引是基于元素类型（顶点或边），一组键（和值）和索引类型创建的。">管理属性图数据的文本索引</a></p>
                        </div>
                     </div>
                  </div>
                  
                  <div class="props_rev_3"><a id="GUID-BDA00920-033D-4E99-AB1E-69E5DC28354C" name="GUID-BDA00920-033D-4E99-AB1E-69E5DC28354C"></a><h5 id="SPGDG-GUID-BDA00920-033D-4E99-AB1E-69E5DC28354C" class="sect5"><span class="enumeration_section">2.6.8.1</span>使用Oracle Text进行并行文本搜索</h5>
                     <div>
                        <p>可以通过调用该方法使用使用Oracle文本平行文本查询<code class="codeph">getPartitioned</code>在<code class="codeph">OracleTextAutoIndex</code> ，指定到Oracle文本（连接对象）中，密钥/值对的搜索，和起始分区ID的连接的数组。</p>
                        <p>以下代码片段使用Oracle Text生成自动文本索引并执行并行文本查询。<code class="codeph">OracleTextAutoIndex</code>类中对<code class="codeph">getPartitioned</code>方法的调用次数由VT $（或GE $表）中的分区总数和使用的连接数控制。
                        </p><pre class="oac_no_warn" dir="ltr">OraclePropertyGraph opg = OraclePropertyGraph.getInstance（...）; String prefOwner =“scott”; String datastore =（String）null; String filter =（String）null; String storage =（String）null; String wordlist =（String）null; String stoplist =（String）null; String lexer =“OPG_AUTO_LEXER”; String options =（String）null; OracleIndexParameters params = OracleTextIndexParameters.buildOracleText（prefOwner，datastore，filter，storage，wordlist，stoplist，lexer，dop，options）; opg.setDefaultIndexParameters（indexParams）; //在所有现有属性上创建自动索引，对所有opg.createKeyIndex使用通配符（（“*”，Vertex.class）; //为Oracle Text创建文本查询对象OracleTextQueryObject otqo = OracleTextQueryObject.getInstance（“Obama”/ *查询正文* /，1 / *得分* /，ScoreRange。积极/ *分数范围* /，方向。ASC / *按方向排序* /）; //获取Connection对象<span class="bold">Connection [] conns = new Connection [dop]; for（int idx = 0; idx &lt;conns.length; idx ++）{conns [idx] = opg.getOracle（）。clone（）。getConnection（）;</span> //获取自动索引对象OracleIndex &lt;Vertex&gt; index =（（OracleIndex &lt;Vertex&gt;）opg.getAutoIndex（Vertex.class）; //迭代覆盖索引中的所有分区long lCount = 0; for（int split = 0; split &lt;index.getTotalShards（）; split + = conns.length）{//获取从split到split + conns.length的元素Iterable &lt;Vertex&gt; [] iterAr = <span class="bold">index.getPartitioned（conns / * connections * /， “名称”/ *键* /，otqo，真/ *通配符* /，拆分/ *开始分裂ID * /）;</span> lCount = countFromIterables（iterAr）; / *消耗并联* iterables /} //关闭<span class="bold">用于</span>连接<span class="bold">（int idx = 0; idx &lt;conns.length; idx ++）{conns [idx] .dispose（）;</span> } //计算结果System.out.println（“使用并行查询找到的顶点：”+ lCount）;</pre></div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="using-property-graphs-oracle-database.html#GUID-7C5C1BDB-13EA-4504-9B4F-B8F7D788AE52">对属性图数据的文本索引使用并行查询</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
                  <div class="props_rev_3"><a id="GUID-39271C38-DD04-4883-BA8F-010C549EC934" name="GUID-39271C38-DD04-4883-BA8F-010C549EC934"></a><h5 id="SPGDG-GUID-39271C38-DD04-4883-BA8F-010C549EC934" class="sect5"><span class="enumeration_section">2.6.8.2</span>使用Apache Lucene进行并行文本查询</h5>
                     <div>
                        <p>可以通过调用该方法使用使用Apache Lucene的并行文本查询<code class="codeph">getPartitioned</code>在<code class="codeph">LuceneIndex</code> ，指定连接到设置子目录（的阵列<code class="codeph">SearcherManager</code>对象），密钥/值对的搜索，和起始子目录ID。每个连接都需要链接到相应的子目录，因为每个子目录都独立于索引中的其余子目录。
                        </p>
                        <p>以下代码片段使用Apache Lucene搜索引擎生成自动文本索引，并执行并行文本查询。<code class="codeph">LuceneIndex</code>类中对<code class="codeph">getPartitioned</code>方法的调用次数由子目录的总数和使用的连接数控制。
                        </p><pre class="oac_no_warn" dir="ltr">OraclePropertyGraph opg = OraclePropertyGraph.getInstance（...）; //创建自动索引OracleIndexParameters indexParams = OracleIndexParameters.buildFS（dop / *目录数* /，dop / *索引时使用的连接数* /，提交前10000 / *批量大小* /，500000 / *提交大小之前Lucene commit * /，true / * enable datatypes * /，“。/ lucene-index”/ * index location * /）; opg.setDefaultIndexParameters（indexParams）; //为所有顶点的System属性创建自动索引System.out.println（“为顶点名称创建自动索引”）; opg.createKeyIndex（“name”，Vertex.class）; //获取LuceneIndex对象SearcherManager [] conns = new SearcherManager [dop]; LuceneIndex &lt;Vertex&gt; index =（LuceneIndex &lt;Vertex&gt;）opg.getAutoIndex（Vertex.class）; long lCount = 0; for（int split = 0; split &lt;index.getTotalShards（）; split + = conns.length）{//从子目录split获取连接对象//（split + conns.length）for（int idx = 0; idx &lt;conns.length; idx ++）{ <span class="bold">conns [idx] = index.getOracleSearcherManager（idx + split）;</span>获取从split到split + conns.length的元素Iterable &lt;Vertex&gt; [] iterAr = <span class="bold">index.getPartitioned（conns / * connections * /，“name”/ * key * /，“*”/ * value * /， true / *通配符* /，split / * start split ID * /）;</span> lCount = countFromIterables（iterAr）; / *并行使用iterables * / //完成后不要关闭子目录的连接，//因为LuceneIndex对象本身使用了这些连接。//计算所有顶点System.out.println（“使用并行查询找到的顶点：”+ lCount）;</pre></div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="using-property-graphs-oracle-database.html#GUID-7C5C1BDB-13EA-4504-9B4F-B8F7D788AE52">对属性图数据的文本索引使用并行查询</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
                  <div class="props_rev_3"><a id="GUID-EF81CE3F-8C63-4A0F-9D4F-84F8740ED446" name="GUID-EF81CE3F-8C63-4A0F-9D4F-84F8740ED446"></a><h5 id="SPGDG-GUID-EF81CE3F-8C63-4A0F-9D4F-84F8740ED446" class="sect5"><span class="enumeration_section">2.6.8.3</span>使用SolrCloud进行并行文本搜索</h5>
                     <div>
                        <p>您可以使用SolrCloud通过调用<code class="codeph">getPartitioned</code>中的<code class="codeph">SolrIndex</code>方法，指定与SolrCloud（ <code class="codeph">CloudSolrServer</code>对象）的连接数组，要搜索的键/值对以及起始分片ID来使用并行文本查询。</p>
                        <p>以下代码片段使用SolrCloud搜索引擎生成自动文本索引，并执行并行文本查询。<code class="codeph">SolrIndex</code>类中对<code class="codeph">getPartitioned</code>方法的调用次数由索引中的分片总数和使用的连接数控制。
                        </p><pre class="oac_no_warn" dir="ltr">OraclePropertyGraph opg = OraclePropertyGraph.getInstance（...）; String configName =“opgconfig”; String solrServerUrl = args [4]; //“localhost：2181 / solr”String solrNodeSet = args [5]; // “本地主机：8983_solr”; int zkTimeout = 15; // zookeeper timeout in seconds int numShards = Integer.parseInt（args [6]）; //索引中的分片数int replicationFactor = 1; //复制因子int maxShardsPerNode = 1; //每个节点的最大分片数//使用SolrCloud创建自动索引OracleIndexParameters indexParams = OracleIndexParameters.buildSolr（configName，solrServerUrl，solrNodeSet，zkTimeout / * zookeeper timeout in seconds * /，numShards / *分片总数* /，replicationFactor / *复制因子* /，maxShardsPerNode / *最大分片节点数* /，4 / * dop用于扫描* /，10000 / *批量大小提交前* /，500000 / *提交大小之前SolrCloud提交* /，15 / *以秒为单位写入超时* /）; opg.setDefaultIndexParameters（indexParams）; //为所有顶点的System属性创建自动索引System.out.println（“为顶点名称创建自动索引”）; opg.createKeyIndex（“name”，Vertex.class）; //获取SolrIndex对象SearcherManager [] conns = new SearcherManager [dop]; <span class="bold">SolrIndex &lt;Vertex&gt; index =（SolrIndex &lt;Vertex&gt;）opg.getAutoIndex（Vertex.class）;</span> //打开一个连接数组来处理并行文本搜索所需的SolrCloud连接CloudSolrServer [] conns = new CloudSolrServer [dop]; <span class="bold">for（int idx = 0; idx &lt;conns.length; idx ++）{conns [idx] = index.getCloudSolrServer（15 / *写入超时，以秒为单位* /）; }</span> //迭代覆盖索引中的所有分片long lCount = 0; for（int split = 0; split &lt;index.getTotalShards（）; split + = conns.length）{//获取从split到split + conns.length的元素Iterable &lt;Vertex&gt; [] iterAr = <span class="bold">index.getPartitioned（conns / * connections * /，“name”/ * key * /，“*”/ * value * /，true / *通配符* /，split / * start split ID * /）;</span> lCount = countFromIterables（iterAr）; / *并行使用iterables * /} //完成for后，关闭子目录的连接（int idx = 0; idx &lt;conns.length; idx ++）{conns [idx] .shutdown（）; } //计算结果System.out.println（“使用并行查询找到的顶点：”+ lCount）;</pre></div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="using-property-graphs-oracle-database.html#GUID-7C5C1BDB-13EA-4504-9B4F-B8F7D788AE52">对属性图数据的文本索引使用并行查询</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div>
               <div class="props_rev_3"><a id="GUID-C957BD65-7FA5-4EC2-8485-4BB0D297AE26" name="GUID-C957BD65-7FA5-4EC2-8485-4BB0D297AE26"></a><h4 id="SPGDG-GUID-C957BD65-7FA5-4EC2-8485-4BB0D297AE26" class="sect4"><span class="enumeration_section">2.6.9</span>在属性图数据的文本索引上使用本机查询对象</h4>
                  <div>
                     <p>直接使用Query对象适用于高级用户，使他们能够充分利用文本搜索引擎（Apache Lucene或SolrCloud）的基础查询功能。例如，您可以向文本搜索添加约束，例如向匹配分数添加提升并添加排序子句。</p>
                     <p>使用Query对象进行文本搜索将生成一个Iterable对象，其中包含与文本查询匹配的属性（或属性集）的所有顶点（或边），同时满足约束。此方法将根据匹配分数自动对结果进行排名。</p>
                     <p>要在查询主体中构建子句，您可能需要考虑要匹配的键/值对使用的数据类型，以及所使用的搜索引擎的配置。有关构建搜索词的更多信息，请参阅<a href="using-property-graphs-oracle-database.html#GUID-26C80DDB-DA5A-48B6-B729-9BE34DECCBB6">处理数据类型</a> 。
                     </p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-586EFE55-1CB4-4B41-BCFB-0F07384635CD">在Apache Lucene中使用本机查询对象</a><br></li>
                        <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-B0C35597-01E6-42EB-AAB3-7B42E2EBB644">在SolrCloud中使用本机查询对象</a><br></li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="using-property-graphs-oracle-database.html#GUID-72E0D670-D477-4C0F-914C-8E70E45F9692" title="Oracle Spatial and Graph属性图支持中的索引允许通过特定键/值或键/文本对快速检索元素。这些索引是基于元素类型（顶点或边），一组键（和值）和索引类型创建的。">管理属性图数据的文本索引</a></p>
                        </div>
                     </div>
                  </div>
                  
                  <div class="props_rev_3"><a id="GUID-586EFE55-1CB4-4B41-BCFB-0F07384635CD" name="GUID-586EFE55-1CB4-4B41-BCFB-0F07384635CD"></a><h5 id="SPGDG-GUID-586EFE55-1CB4-4B41-BCFB-0F07384635CD" class="sect5"><span class="enumeration_section">2.6.9.1</span>在Apache Lucene中使用本机查询对象</h5>
                     <div>
                        <p>您可以通过在<code class="codeph">LuceneIndex</code>调用<code class="codeph">get(Query)</code>方法，使用Apache Lucene来使用本机查询对象。还可以通过调用方法使用与本地查询对象平行文本查询<code class="codeph">getPartitioned(SearcherManager[], Query, int)</code>在<code class="codeph">LuceneIndex</code>指定连接的阵列的一组子目录（的<code class="codeph">SearcherManager</code>对象），Lucene的查询对象，并且起始子目录ID。每个连接都必须链接到相应的子目录，因为每个子目录都独立于索引中的其余子目录。
                        </p>
                        <p>以下代码片段使用Apache Lucene搜索引擎生成自动文本索引，创建Lucene查询，并执行并行文本查询。<code class="codeph">LuceneIndex</code>类中对<code class="codeph">getPartitioned</code>方法的调用次数由子目录的总数和使用的连接数控制。
                        </p><pre class="oac_no_warn" dir="ltr">import oracle.pg.text.lucene。LuceneIndex; import org.apache.lucene.search。*; import org.apache.lucene.index。*; ...OraclePropertyGraph opg = OraclePropertyGraph.getInstance（...）; //创建自动索引OracleIndexParameters indexParams = OracleIndexParameters.buildFS（dop / *目录数* /，dop / *索引时使用的连接数* /，提交前10000 / *批量大小* /，500000 / *提交大小之前Lucene commit * /，true / * enable datatypes * /，“。/ lucene-index”/ * index location * /）; opg.setDefaultIndexParameters（indexParams）; //为所有顶点的名称和国家/地区属性创建自动索引System.out.println（“为名称创建自动索引，为顶点创建国家/地区”）; String [] indexedKeys = new String [2]; indexedKeys [0] = “姓名”; indexedKeys [1] = “国家”; opg.createKeyIndex（indexedKeys，Vertex.class）; //获取LuceneIndex对象LuceneIndex &lt;Vertex&gt; index =（LuceneIndex &lt;Vertex&gt;）opg.getAutoIndex（Vertex.class）; //首先搜索具有属性值Beyon *的密钥名称，仅使用字符串//数据类型Term term = index.buildSearchTermObject（“name”，“Beyo *”，String.class）;查询queryBey = new WildcardQuery（term）; //添加另一个条件来查询其国家/地区为//“United States”的所有顶点String key = index.appendDatatypesSuffixToKey（“country”，String.class）; String value = index.appendDatatypesSuffixToValue（“United States”，String.class）;查询queryCountry = new PhraseQuery（）; StringTokenizer st = new StringTokenizer（value）; while（st.hasMoreTokens（））{queryCountry.add（new Term（key，st.nextToken（）））; }; // Concatenate查询BooleanQuery bQuery = new BooleanQuery（）; bQuery.add（queryBey，BooleanClause。发生。必须）; bQuery.add（queryCountry，BooleanClause。发生。必须）; long lCount = 0; SearcherManager [] conns = new SearcherManager [dop]; for（int split = 0; split &lt;index.getTotalShards（）; split + = conns.length）{//从子目录split获取连接对象//（split + conns.length）。跳过缓存，以便我们克隆连接并//避免使用索引使用的连接。for（int idx = 0; idx &lt;conns.length; idx ++）{conns [idx] = index.getOracleSearcherManager（idx + split，true / * skip to cache in cache * /）;获取从split到split + conns.length的元素Iterable &lt;Vertex&gt; [] iterAr = index.getPartitioned（conns / * connections * /，bQuery，split / * start split ID * /）; lCount = countFromIterables（iterAr）; / *并行使用iterables * / //完成后不要关闭子目录的连接，//因为索引本身使用了这些连接} //计算所有顶点System.out.println（“使用的顶点并行查询：“+ lCount）;</pre></div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="using-property-graphs-oracle-database.html#GUID-C957BD65-7FA5-4EC2-8485-4BB0D297AE26">在属性图数据的文本索引上使用本机查询对象</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
                  <div class="props_rev_3"><a id="GUID-B0C35597-01E6-42EB-AAB3-7B42E2EBB644" name="GUID-B0C35597-01E6-42EB-AAB3-7B42E2EBB644"></a><h5 id="SPGDG-GUID-B0C35597-01E6-42EB-AAB3-7B42E2EBB644" class="sect5"><span class="enumeration_section">2.6.9.2</span>在SolrCloud中使用本机查询对象</h5>
                     <div>
                        <p>您可以直接使用通过调用方法对SolrCloud本地查询对象<code class="codeph">get(SolrQuery)</code>在<code class="codeph">SolrIndex</code> 。还可以通过调用方法使用与本地查询对象平行文本查询<code class="codeph">getPartitioned(CloudSolrServer[],SolrQuery,int)</code>在<code class="codeph">SolrIndex</code>指定连接的阵列以SolrCloud（ <code class="codeph">CloudSolrServer</code>对象），则<code class="codeph">SolrQuery</code>对象，和起始碎片ID。</p>
                        <p>以下代码片段使用Apache SolrCloud搜索引擎生成自动文本索引，创建<code class="codeph">SolrQuery</code>对象，并执行并行文本查询。<code class="codeph">SolrIndex</code>类中对<code class="codeph">getPartitioned</code>方法的调用次数由子目录的总数和使用的连接数控制。
                        </p><pre class="oac_no_warn" dir="ltr">import oracle.pg.text.solr。*; import org.apache.solr.client.solrj。*; OraclePropertyGraph opg = OraclePropertyGraph.getInstance（...）; String configName =“opgconfig”; String solrServerUrl = args [4]; //“localhost：2181 / solr”String solrNodeSet = args [5]; // “本地主机：8983_solr”; int zkTimeout = 15; // zookeeper timeout in seconds int numShards = Integer.parseInt（args [6]）; //索引中的分片数int replicationFactor = 1; //复制因子int maxShardsPerNode = 1; //每个节点的最大分片数//使用SolrCloud创建自动索引OracleIndexParameters indexParams = OracleIndexParameters.buildSolr（configName，solrServerUrl，solrNodeSet，zkTimeout / * zookeeper timeout in seconds * /，numShards / *分片总数* /，replicationFactor / *复制因子* /，maxShardsPerNode / *最大分片节点数* /，4 / * dop用于扫描* /，10000 / *批量大小提交前* /，500000 / *提交大小之前SolrCloud提交* /，15 / *以秒为单位写入超时* /）; opg.setDefaultIndexParameters（indexParams）; //为所有顶点的System属性创建自动索引System.out.println（“为名称创建自动索引，为顶点创建国家/地区”）; String [] indexedKeys = new String [2]; indexedKeys [0] = “姓名”; indexedKeys [1] = “国家”; opg.createKeyIndex（indexedKeys，Vertex.class）; //获取SolrIndex对象SolrIndex &lt;Vertex&gt; index =（SolrIndex &lt;Vertex&gt;）opg.getAutoIndex（Vertex.class）; //首先搜索具有属性值Beyon *的密钥名称，仅使用字符串//数据类型字符串szQueryStrBey = index.buildSearchTerm（“name”，“Beyo *”，String.class）; String key = index.appendDatatypesSuffixToKey（“country”，String.class）; String value = index.appendDatatypesSuffixToValue（“United States”，String.class）; String szQueryStrCountry = key +“：”+ value; Solrquery query = new SolrQuery（szQueryStrBey +“AND”+ szQueryStrCountry）; //使用get operation index.get（query）查询; //打开一个连接数组来处理所需的SolrCloud连接//用于并行文本搜索CloudSolrServer [] conns = new CloudSolrServer [dop]; for（int idx = 0; idx &lt;conns.length; idx ++）{conns [idx] = index.getCloudSolrServer（15 / *写入超时，以秒为单位* /）; } //迭代覆盖索引中的所有分片long lCount = 0; for（int split = 0; split &lt;index.getTotalShards（）; split + = conns.length）{//从split到split + conns.length获取元素Iterable &lt;Vertex&gt; [] iterAr = index.getPartitioned（conns / *连接* /，查询，拆分/ *开始拆分ID * /）; lCount = countFromIterables（iterAr）; / *并行使用iterables * /} //完成后关闭与SolCloud的连接（int idx = 0; idx &lt;conns.length; idx ++）{conns [idx] .shutdown（）; } //计算结果System.out.println（“使用并行查询找到的顶点：”+ lCount）;</pre></div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="using-property-graphs-oracle-database.html#GUID-C957BD65-7FA5-4EC2-8485-4BB0D297AE26">在属性图数据的文本索引上使用本机查询对象</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div>
               <div class="props_rev_3"><a id="GUID-F0D99092-49A0-434E-9827-C672CC18F64C" name="GUID-F0D99092-49A0-434E-9827-C672CC18F64C"></a><h4 id="SPGDG-GUID-F0D99092-49A0-434E-9827-C672CC18F64C" class="sect4"><span class="enumeration_section">2.6.10</span>在属性图数据的文本索引上使用本机查询结果</h4>
                  <div>
                     <p>将本机查询结果直接应用于属性图数据使用户能够充分利用文本搜索引擎（Apache Lucene或SolrCloud）的查询功能。这样，用户可以在文本引擎上执行不同类型的查询（如Faceted查询），并将检索到的结果解析为顶点（或边）对象。</p>
                     <p>使用Query结果进行文本搜索将生成一个<code class="codeph">Iterable</code>对象，该对象包含给定结果对象的所有顶点（或边）。此方法将根据结果集顺序自动对结果进行排名。
                     </p>
                     <p>要直接将搜索查询执行到Apache Lucene或SolrCloud索引，您可能需要考虑要匹配的键/值对使用的数据类型，以及所使用的搜索引擎的配置。有关构建搜索词的更多信息，请参阅<a href="using-property-graphs-oracle-database.html#GUID-26C80DDB-DA5A-48B6-B729-9BE34DECCBB6">处理数据类型</a> 。
                     </p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-1EE27967-2238-4DBD-8642-D6D18142E54C">使用Apache Lucene的本机查询结果</a><br></li>
                        <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-5F6E1DB7-78EA-4A44-85A9-6F5BB6D8FEE8">使用SolrCloud的本机查询结果</a><br></li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="using-property-graphs-oracle-database.html#GUID-72E0D670-D477-4C0F-914C-8E70E45F9692" title="Oracle Spatial and Graph属性图支持中的索引允许通过特定键/值或键/文本对快速检索元素。这些索引是基于元素类型（顶点或边），一组键（和值）和索引类型创建的。">管理属性图数据的文本索引</a></p>
                        </div>
                     </div>
                  </div>
                  
                  <div class="props_rev_3"><a id="GUID-1EE27967-2238-4DBD-8642-D6D18142E54C" name="GUID-1EE27967-2238-4DBD-8642-D6D18142E54C"></a><h5 id="SPGDG-GUID-1EE27967-2238-4DBD-8642-D6D18142E54C" class="sect5"><span class="enumeration_section">2.6.10.1</span>在Apache Lucene中使用本机查询结果</h5>
                     <div>
                        <p>您可以通过调用<code class="codeph">get(TopDocs) in LuceneIndex</code>方法，使用Apache Lucene来使用本机查询结果。<code class="codeph">TopDocs</code>对象提供一组与特定Apache Lucene目录上的文本搜索查询匹配的文档。<code class="codeph">LuceneIndex</code>将生成一个<code class="codeph">Iterable</code>对象，其中包含<code class="codeph">TopDocs</code>对象中找到的文档中的所有顶点（或边）。
                        </p>
                        <p>使用Apache Lucene的Oracle属性图文本索引是使用多个Apache Lucene目录创建的。索引顶点和边缘分布在目录中，以增强存储可伸缩性和查询性能。如果需要对属性图的文本索引中的所有数据执行查询，则必须对每个Apache Lucene目录执行查询。您可以使用<code class="codeph">getOracleSearcher in LuceneIndex</code>的API <code class="codeph">getOracleSearcher in LuceneIndex</code>轻松获取与目录关联的<code class="codeph">IndexSearcher</code>对象。
                        </p>
                        <p>以下代码片段使用Apache Lucene搜索引擎生成自动文本索引，创建Lucene查询并针对<code class="codeph">IndexSearcher</code>对象执行它以获取<code class="codeph">TopDocs</code>对象。稍后，将从结果对象创建一个<code class="codeph">Iterable</code>顶点。
                        </p><pre class="oac_no_warn" dir="ltr">import oracle.pg.text.lucene。LuceneIndex; import org.apache.lucene.search。*; import org.apache.lucene.index。*; ...OraclePropertyGraph opg = OraclePropertyGraph.getInstance（...）; //创建自动索引OracleIndexParameters indexParams = OracleIndexParameters.buildFS（dop / *目录数* /，dop / *索引时使用的连接数* /，提交前10000 / *批量大小* /，500000 / *提交大小之前Lucene commit * /，true / * enable datatypes * /，“。/ lucene-index”/ * index location * /）; opg.setDefaultIndexParameters（indexParams）; //为所有顶点的名称和国家/地区属性创建自动索引System.out.println（“为名称创建自动索引，为顶点创建国家/地区”）; String [] indexedKeys = new String [2]; indexedKeys [0] = “姓名”; indexedKeys [1] = “国家”; opg.createKeyIndex（indexedKeys，Vertex.class）; //获取LuceneIndex对象LuceneIndex &lt;Vertex&gt; index =（LuceneIndex &lt;Vertex&gt;）opg.getAutoIndex（Vertex.class）; //首先搜索具有属性值Beyon *的密钥名称，仅使用字符串//数据类型Term term = index.buildSearchTermObject（“name”，“Beyo *”，String.class）;查询queryBey = new WildcardQuery（term）; //添加另一个条件来查询其国家/地区为//“United States”的所有顶点String key = index.appendDatatypesSuffixToKey（“country”，String.class）; String value = index.appendDatatypesSuffixToValue（“United States”，String.class）;查询queryCountry = new PhraseQuery（）; StringTokenizer st = new StringTokenizer（value）; while（st.hasMoreTokens（））{queryCountry.add（new Term（key，st.nextToken（）））; }; // Concatenate查询BooleanQuery bQuery = new BooleanQuery（）; bQuery.add（queryBey，BooleanClause。发生。必须）; bQuery.add（queryCountry，BooleanClause。发生。必须）; //获取执行查询所需的IndexSearcher对象。//索引搜索器对象映射到单个Apache Lucene目录<span class="bold">SearcherManager searcherMgr = index.getOracleSearcherManager（0，true / *跳过查找缓存* /）; IndexSearcher indexSearcher = searcherMgr.acquire（）; //在当前索引目录中搜索前1000个结果0 TopDocs docs = index.search（bQuery，1000）; long lCount = 0; Iterable &lt;Vertex&gt; it = index.get（docs）;</span> while（it.hasNext（））{System.out.println（it.next（））; lCount ++; System.out.println（“Vertices found：”+ lCount）;</pre></div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="using-property-graphs-oracle-database.html#GUID-F0D99092-49A0-434E-9827-C672CC18F64C">对属性图数据的文本索引使用本机查询结果</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
                  <div class="props_rev_3"><a id="GUID-5F6E1DB7-78EA-4A44-85A9-6F5BB6D8FEE8" name="GUID-5F6E1DB7-78EA-4A44-85A9-6F5BB6D8FEE8"></a><h5 id="SPGDG-GUID-5F6E1DB7-78EA-4A44-85A9-6F5BB6D8FEE8" class="sect5"><span class="enumeration_section">2.6.10.2在SolrCloud中</span>使用本机查询结果</h5>
                     <div>
                        <p>您可以通过调用方法使用使用SolrCloud本地查询结果<code class="codeph">get(QueryResponse)</code>在<code class="codeph">SolrIndex</code> 。<code class="codeph">QueryResponse</code>对象提供一组与特定SolrCloud集合上的文本搜索查询匹配的文档。<code class="codeph">SolrIndex</code>将生成一个<code class="codeph">Iterable</code>对象，该对象包含<code class="codeph">QueryResponse</code>对象中找到的文档中的所有顶点（或边）。
                        </p>
                        <p>以下代码片段使用Apache SolrCloud搜索引擎生成自动文本索引，创建<code class="codeph">SolrQuery</code>对象，并针对<code class="codeph">CloudSolrServer</code>对象执行它以获取<code class="codeph">QueryResponse</code>对象。稍后，将从结果对象创建一个<code class="codeph">Iterable</code>顶点。
                        </p><pre class="oac_no_warn" dir="ltr">import oracle.pg.text.solr。*; import org.apache.solr.client.solrj。*; OraclePropertyGraph opg = OraclePropertyGraph.getInstance（...）; String configName =“opgconfig”; String solrServerUrl = args [4]; //“localhost：2181 / solr”String solrNodeSet = args [5]; // “本地主机：8983_solr”; int zkTimeout = 15; // zookeeper timeout in seconds int numShards = Integer.parseInt（args [6]）; //索引中的分片数int replicationFactor = 1; //复制因子int maxShardsPerNode = 1; //每个节点的最大分片数//使用SolrCloud创建自动索引OracleIndexParameters indexParams = OracleIndexParameters.buildSolr（configName，solrServerUrl，solrNodeSet，zkTimeout / * zookeeper timeout in seconds * /，numShards / *分片总数* /，replicationFactor / *复制因子* /，maxShardsPerNode / *最大分片节点数* /，4 / * dop用于扫描* /，10000 / *批量大小提交前* /，500000 / *提交大小之前SolrCloud提交* /，15 / *以秒为单位写入超时* /）; opg.setDefaultIndexParameters（indexParams）; //为所有顶点的System属性创建自动索引System.out.println（“为名称创建自动索引，为顶点创建国家/地区”）; String [] indexedKeys = new String [2]; indexedKeys [0] = “姓名”; indexedKeys [1] = “国家”; opg.createKeyIndex（indexedKeys，Vertex.class）; //获取SolrIndex对象SolrIndex &lt;Vertex&gt; index =（SolrIndex &lt;Vertex&gt;）opg.getAutoIndex（Vertex.class）; //首先搜索具有属性值Beyon *的密钥名称，仅使用字符串//数据类型字符串szQueryStrBey = index.buildSearchTerm（“name”，“Beyo *”，String.class）; String key = index.appendDatatypesSuffixToKey（“country”，String.class）; String value = index.appendDatatypesSuffixToValue（“United States”，String.class）; String szQueryStrCountry = key +“：”+ value; Solrquery query = new SolrQuery（szQueryStrBey +“AND”+ szQueryStrCountry）; <span class="bold">CloudSolrServer conn = index.getCloudSolrServer（15 / *写入超时，以秒为单位* /）; //使用get操作查询QueryResponse qr = conn.query（query，SolrRequest.METHOD.POST）; Iterable &lt;Vertex&gt; it = index.get（qr）;</span> long lCount = 0; while（it.hasNext（））{System.out.println（it.next（））; lCount ++; System.out.println（“Vertices found：”+ lCount）;</pre></div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="using-property-graphs-oracle-database.html#GUID-F0D99092-49A0-434E-9827-C672CC18F64C">对属性图数据的文本索引使用本机查询结果</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div>
            </div>
            <div class="sect2"><a id="GUID-5E5587AB-52F0-4C69-9C4B-6EC667620BB7" name="GUID-5E5587AB-52F0-4C69-9C4B-6EC667620BB7"></a><h3 id="SPGDG-GUID-5E5587AB-52F0-4C69-9C4B-6EC667620BB7" class="sect3"><span class="enumeration_section">2.7</span>属性图数据的访问控制（图级和OLS）</h3>
               <div>
                  <p>Oracle Spatial and Graph中的属性图功能支持两种访问控制和安全模型：图级访问控制，以及通过与Oracle Label Security（OLS）集成的细粒度安全性。</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>图级访问控制依赖于grant / revoke来允许/禁止除所有者之外的用户访问属性图。</p>
                     </li>
                     <li>
                        <p>属性图数据的OLS允许灵敏度标签与存储在属性图中的各个顶点或边相关联。</p>
                     </li>
                  </ul>
                  <p>存储在Oracle数据库中的对属性图数据的访问的默认控制是图形级别：图形的所有者可以将图形的读取，插入，删除，更新和选择权限授予其他用户。</p>
                  <p>但是，对于具有严格安全要求的应用程序，可以使用Oracle数据库的Oracle Label Security选项强制实施细粒度的访问控制机制。使用OLS，对于每个查询，通过将其标签与用户的标签进行比较来授予对特定元素（顶点或边）的访问权限。（有关使用OLS的信息，请参阅“ <a href="../olsag/introduction-to-oracle-label-security.html#OLSAG001" target="_blank"><span><cite>Oracle Label Security管理员指南”</cite></span></a> 。）
                  </p>
                  <p>启用Oracle Label Security后，如果数据库中存在具有更强灵敏度标签的相同元素，则可能无法在图形中插入元素（顶点或边）。例如，假设您有一个带有非常敏感标签的顶点，例如:( <code class="codeph">( Vertex ID 1 {name:str:v1} "SENSITIVE" )</code> 。这实际上阻止了低权限（PUBLIC）用户更新顶点:( <code class="codeph">( Vertex ID 1 {name:str:v1} "PUBLIC" )</code> 。另一方面，如果高权限用户覆盖使用低级别安全标签创建的顶点或边缘，则具有更高安全性的较新标签将分配给顶点或边缘，而低权限用户将无法再看到它了。
                  </p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-3A4E6B7D-5803-4379-912E-9BCCFA08308A">在属性图数据上应用Oracle Label Security（OLS）</a><br>本主题提供了一个示例，说明如何将OLS应用于属性图数据。
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="using-property-graphs-oracle-database.html#GUID-4B5AF258-79BE-418D-84FF-9B8A692B8604" title="本章提供有关在Oracle数据库环境中创建，存储和使用属性图数据的概念和用法信息。">在Oracle数据库环境中使用属性图</a></p>
                     </div>
                  </div>
               </div>
               
               <div class="sect3"><a id="GUID-3A4E6B7D-5803-4379-912E-9BCCFA08308A" name="GUID-3A4E6B7D-5803-4379-912E-9BCCFA08308A"></a><h4 id="SPGDG-GUID-3A4E6B7D-5803-4379-912E-9BCCFA08308A" class="sect4"><span class="enumeration_section">2.7.1</span>在属性图数据上应用Oracle Label Security（OLS）</h4>
                  <div>
                     <p>本主题提供了一个示例，说明如何将OLS应用于属性图数据。</p>
                     <p>由于属性图存储在常规关系表中，因此该示例与在常规关系表上应用OLS没有什么不同。以下显示如何配置和启用OLS，使用安全标签创建安全策略，并将其应用于属性图。代码示例非常简单，并不一定反映有关用户名和密码的推荐做法。</p>
                     <ol>
                        <li>
                           <p>作为SYSDBA，创建名为userP，userP2，userS，userTS，userTS2和pgAdmin的数据库用户。</p><pre class="pre codeblock"><code>CONNECT / as sysdba; CREATE USER userP IDENTIFIED BY userPpass; GRANT连接，资源，创建表，创建视图，为userP创建任何索引; GRANT无限制TABLESPACE到userP; CREATE USER userP2 IDENTIFIED BY userP2pass; GRANT连接，资源，创建表，创建视图，创建任何索引到userP2; GRANT无限制TABLESPACE到userP2; CREATE USER userS由userSpass标识; GRANT连接，资源，创建表，创建视图，为用户创建任何索引;向用户授予无限的TABLESPACE; CREATE USER userTS IDENTIFIED BY userTSpass; GRANT连接，资源，创建表，创建视图，为userTS创建任何索引;向用户授予无限的TABLESPACE; CREATE USER userTS2 IDENTIFIED BY userTS2pass; GRANT连接，资源，创建表，创建视图，创建任何索引到userTS2; GRANT无限TABLESPACE到userTS2;通过pgAdminpass识别创建用户pgAdmin; GRANT连接，资源，创建表，创建视图，创建任何索引TO pgAdmin; GRANT无限制TABLESPACE到pgAdmin;</code></pre></li>
                        <li>
                           <p>作为SYSDBA，配置并启用Oracle Label Security。</p><pre class="pre codeblock"><code>ALTER USER lbacsys由lbacsys ACCOUNT UNLOCK识别; EXEC LBACSYS.CONFIGURE_OLS; EXEC LBACSYS.OLS_ENFORCEMENT.ENABLE_OLS;</code></pre></li>
                        <li>
                           <p>作为SYSTEM，为sec_admin和hr_sec授予权限。</p><pre class="pre codeblock"><code>CONNECT system / &lt;system-password&gt; GRANT connect，创建任何索引到sec_admin IDENTIFIED BY密码; GRANT连接，创建用户，删除用户，创建角色，删除任何角色TO hr_sec IDENTIFIED BY password;</code></pre></li>
                        <li>
                           <p>作为LBACSYS，创建安全策略。</p><pre class="pre codeblock"><code>CONNECT lbacsys / &lt;lbacsys-password&gt; BEGIN SA_SYSDBA.CREATE_POLICY（policy_name =&gt;'DEFENSE'，column_name =&gt;'SL'，default_options =&gt;'READ_CONTROL，LABEL_DEFAULT，HIDE'）;结束; /</code></pre></li>
                        <li>
                           <p>作为LBACSYS，授予DEFENSE_DBA并执行到sec_admin和hr_sec用户。</p><pre class="pre codeblock"><code>GRANT DEFENSE_DBA到sec_admin; GRANT DEFENSE_DBA至hr_sec; GRANT在SA_COMPONENTS上执行到sec_admin; GRANT在SA_USER_ADMIN上执行到hr_sec;</code></pre></li>
                        <li>
                           <p>作为SEC_ADMIN，创建三个安全级别（为简单起见，这里省略了隔离专区和组。）</p><pre class="pre codeblock"><code>CONNECT sec_admin / &lt;sec_admin-password&gt;; BEGIN SA_COMPONENTS.CREATE_LEVEL（policy_name =&gt;'DEFENSE'，level_num =&gt; 1000，short_name =&gt;'PUB'，long_name =&gt;'PUBLIC'）;结束; / EXECUTE SA_COMPONENTS.CREATE_LEVEL（'DEFENSE'，2000，'CONF'，'CONFIDENTIAL'）; EXECUTE SA_COMPONENTS.CREATE_LEVEL（'DEFENSE'，3000，'SENS'，'SENSITIVE'）;</code></pre></li>
                        <li>
                           <p>创建三个标签。</p><pre class="pre codeblock"><code>EXECUTE SA_LABEL_ADMIN.CREATE_LABEL（'DEFENSE'，1000，'PUB'）; EXECUTE SA_LABEL_ADMIN.CREATE_LABEL（'DEFENSE'，2000，'CONF'）; EXECUTE SA_LABEL_ADMIN.CREATE_LABEL（'DEFENSE'，3000，'SENS'）;</code></pre></li>
                        <li>
                           <p>作为HR_SEC，分配标签和权限。</p><pre class="pre codeblock"><code>CONNECT hr_sec / &lt;hr_sec-password&gt;; BEGIN SA_USER_ADMIN.SET_USER_LABELS（policy_name =&gt;'DEFENSE'，user_name =&gt;'UT'，max_read_label =&gt;'SENS'，max_write_label =&gt;'SENS'，min_write_label =&gt;'CONF'，def_label =&gt;'SENS'，row_label =&gt; 'SENS'）;结束; / EXECUTE SA_USER_ADMIN.SET_USER_LABELS（'DEFENSE'，'userTS'，'SENS'）; EXECUTE SA_USER_ADMIN.SET_USER_LABELS（'DEFENSE'，'userTS2'，'SENS'）; EXECUTE SA_USER_ADMIN.SET_USER_LABELS（'DEFENSE'，'userS'，'CONF'）; EXECUTE SA_USER_ADMIN.SET_USER_LABELS（'DEFENSE'，userP'，'PUB'，'PUB'，'PUB'，'PUB'，'PUB'）; EXECUTE SA_USER_ADMIN.SET_USER_LABELS（'DEFENSE'，'userP2'，'PUB'，'PUB'，'PUB'，'PUB'，'PUB'）; EXECUTE SA_USER_ADMIN.SET_USER_PRIVS（'DEFENSE'，'pgAdmin'，'FULL'）;</code></pre></li>
                        <li>
                           <p>作为SEC_ADMIN，将安全策略应用于所需的属性图。假设一个名为OLSEXAMPLE的属性图，其中userP作为图所有者。要应用OLS安全性，请执行以下语句。</p><pre class="pre codeblock"><code>CONNECT sec_admin / welcome1; EXECUTE SA_POLICY_ADMIN.APPLY_TABLE_POLICY（'DEFENSE'，'userP'，'OLSEXAMPLEVT $'）; EXECUTE SA_POLICY_ADMIN.APPLY_TABLE_POLICY（'DEFENSE'，'userP'，'OLSEXAMPLEGE $'）; EXECUTE SA_POLICY_ADMIN.APPLY_TABLE_POLICY（'DEFENSE'，'userP'，'OLSEXAMPLEGT $'）; EXECUTE SA_POLICY_ADMIN.APPLY_TABLE_POLICY（'DEFENSE'，'userP'，'OLSEXAMPLESS $'）;</code></pre></li>
                     </ol>
                     <p>现在，Oracle Label Security的敏感度标签与存储在属性图中的各个顶点或边相关联。</p>
                     <p>以下示例说明如何使用名称OLSEXAMPLE创建属性图，以及演示具有不同安全标签的不同用户创建，读取和写入图元素时的行为的示例流。</p><pre class="pre codeblock"><code>//创建Oracle Property Graph String graphName =“OLSEXAMPLE”; Oracle connPub = new Oracle（“jdbc：oracle：thin：@host：port：SID”，“userP”，“userPpass”）; OraclePropertyGraph graphPub = OraclePropertyGraph.getInstance（connPub，graphName，48）; //授予其他用户访问权限graphPub.grantAccess（“userP2”，“RSIUD”）; //读取，选择，插入，更新，删除（RSIUD）graphPub.grantAccess（“userS”，“RSIUD”）; graphPub.grantAccess（“userTS”，“RSIUD”）; graphPub.grantAccess（“userTS2”，“RSIUD”）; //加载数据OraclePropertyGraphDataLoader opgdl = OraclePropertyGraphDataLoader.getInstance（）; String vfile =“../../data/connections.opv“; String efile =”../../data/connections.ope“; graphPub.clearRepository（）; opgdl.loadData（graphPub，vfile，efile，48,1000，true，null）; System.out.println（”具有用户userP和PUBLIC LABEL的顶点：“+ graphPub.countVertices（））; // 78 System.out.println（”具有用户userP和PUBLIC LABEL的顶点：“+ graphPub.countEdges（））; // 164 //具有更高级别Oracle connTS的第二个用户= new Oracle（“jdbc：oracle：thin：@host：port：SID”，“userTS”，“userTpassS”）; OraclePropertyGraph graphTS = OraclePropertyGraph.getInstance（connTS，“USERP”，graphName，8,48，null，null ）; System.out.println（“带有用户userTS和SENSITIVE LABEL的顶点：”+ graphTS.countVertices（））; // 78 System.out.println（“带有用户userTS和SENSITIVE LABEL的顶点：”+ graphTS.countEdges（ ））; // 164 //用第二个用户long添加顶点和边lMaxVertexID = graphTS.getMaxVertexID（）; long lMaxEdgeID = graphTS.getMaxEdgeID（）; long size = 10; System.out.println（“\ nAdd”+ size +“顶点和边缘，用户userTS和SENSITIVE LABEL \ n”） ; for（long idx = 1; idx &lt;= size; idx ++）{Vertex v = graphTS.addVertex（idx + lMaxVertexID）; v.setProperty（“name”，“v _”+（idx + lMaxVertexID））;边e = graphTS.addEdge（idx + lMaxEdgeID，v，graphTS.getVertex（idx），“edge_”+（idx + lMaxEdgeID））; graphTS.commit（）; //具有较低级别的用户userP仅看到原始顶点和边缘，用户userTS可以看到更多System.out.println（“具有用户userP和PUBLIC LABEL的顶点：”+ graphPub.countVertices（））; // 78 System.out.println（“带有用户userP和PUBLIC LABEL的顶点：”+ graphPub.countEdges（））; // 164 System.out.println（“具有用户userTS和SENSITIVE LABEL的顶点：”+ graphTS.countVertices（））; // 88 System.out.println（“具有用户userTS和SENSITIVE LABEL的顶点：”+ graphTS.countEdges（））; // 174 //具有更高级别的第三个用户Oracle connTS2 = new Oracle（“jdbc：oracle：thin：@host：port：SID”，“userTS2”，“userTS2pass”）; OraclePropertyGraph graphTS2 = OraclePropertyGraph.getInstance（connTS2，“USERP”，graphName，8,48，null，null）; System.out.println（“具有用户userTS2和SENSITIVE LABEL的顶点：”+ graphTS2.countVertices（））; // 88 System.out.println（“具有用户userTS2和SENSITIVE LABEL的顶点：”+ graphTS2.countEdges（））; // 174 //具有中级Oracle的第四个用户connS = new Oracle（“jdbc：oracle：thin：@host：port：SID”，“userS”，“userSpass”）; OraclePropertyGraph graphS = OraclePropertyGraph.getInstance（connS，“USERP”，graphName，8,48，null，null）; System.out.println（“具有用户userS和CONFIDENTIAL LABEL的顶点：”+ graphS.countVertices（））; // 78 System.out.println（“具有用户userS和CONFIDENTIAL LABEL的顶点：”+ graphS.countEdges（））; // 164 //用第四个用户System.out.println修改顶点（“\ nModify”+ size +“顶点用户userS和CONFIDENTIAL LABEL \ n”）; for（long idx = 1; idx &lt;= size; idx ++）{Vertex v = graphS.getVertex（idx）; v.setProperty（“security_label”，“CONFIDENTIAL”）; } graphS.commit（）; //用户userP具有较低级别，userS无法看到新顶点//用户userS和userTS可以看到它们System.out.println（“用户userP具有属性security_label的顶点：”+ OraclePropertyGraphUtils.size（graphPub.getVertices（“ security_label“，”CONFIDENTIAL“）））; // 0 System.out.println（“具有属性security_label的用户userS的顶点：”+ OraclePropertyGraphUtils.size（graphS.getVertices（“security_label”，“CONFIDENTIAL”）））; // 10 System.out.println（“具有用户userTS的顶点与属性security_label：”+ OraclePropertyGraphUtils.size（graphTS.getVertices（“security_label”，“CONFIDENTIAL”）））; // 10 System.out.println（“具有用户userP和PUBLIC LABEL的顶点：”+ graphPub.countVertices（））; // 68 System.out.println（“带有用户userTS和SENSITIVE LABEL的顶点：”+ graphTS.countVertices（））; // 88</code></pre><p>前面的示例应该生成以下输出。</p><pre class="oac_no_warn" dir="ltr">具有用户userP和PUBLIC LABEL的顶点：78具有用户userP和PUBLIC LABEL的顶点：164具有用户userTS和SENSITIVE LABEL的顶点：78具有用户userTS和SENSITIVE LABEL的顶点：164使用用户userTS和SENSITIVE LABEL顶点和用户添加10个顶点和边userP和PUBLIC LABEL：78具有用户userP和PUBLIC LABEL的顶点：164具有用户userTS和SENSITIVE LABEL的顶点：88具有用户userTS和SENSITIVE LABEL的顶点：174具有用户userTS2和SENSITIVE LABEL的顶点：88具有用户userTS2和SENSITIVE LABEL的顶点： 174具有用户userS和机密标签的顶点：78具有用户userS和机密标签的顶点：164使用用户userS和机密标签修改10个顶点使用带有属性security_label的用户userP的顶点：0具有属性security_label的用户userS的顶点：10具有用户userTS的顶点with property security_label：10个顶点，用户userP和PUBLIC LABEL：68个顶点，用户userTS和SENSITIVE LABEL：88</pre></div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="using-property-graphs-oracle-database.html#GUID-5E5587AB-52F0-4C69-9C4B-6EC667620BB7" title="Oracle Spatial and Graph中的属性图功能支持两种访问控制和安全模型：图级访问控制，以及通过与Oracle Label Security（OLS）集成的细粒度安全性。">属性图数据的访问控制（图形级和OLS）</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div>
            <div class="props_rev_3"><a id="GUID-DFCC2E13-5548-4DAC-B0DE-E4CEF13E97C7" name="GUID-DFCC2E13-5548-4DAC-B0DE-E4CEF13E97C7"></a><h3 id="SPGDG-GUID-DFCC2E13-5548-4DAC-B0DE-E4CEF13E97C7" class="sect3"><span class="enumeration_section">2.8</span>将Groovy Shell与属性图数据一起使用</h3>
               <div>
                  <p>Oracle Spatial and Graph属性图支持包括一个内置的Groovy shell（基于原始的Gremlin Groovy shell脚本）。使用此命令行shell界面，您可以浏览Java API。</p>
                  <p>要启动Groovy shell，请转到安装主目录下的<code class="codeph">dal/groovy</code>目录（ <code class="codeph">$ORACLE_HOME/md/property_graph by default</code>下默认<code class="codeph">$ORACLE_HOME/md/property_graph by default</code> ）。例如：</p><pre class="oac_no_warn" dir="ltr">cd $ ORACLE_HOME / md / property_graph / dal / groovy /</pre><p>包括用于连接Oracle数据库的脚本<code class="codeph">gremlin-opg-rdbms.sh</code> 。
                  </p>
                  <div class="infoboxnote" id="GUID-DFCC2E13-5548-4DAC-B0DE-E4CEF13E97C7__GUID-08B8E3DA-9227-4BF6-ABD3-7C3ABCC2CA38">
                     <p class="notep1">注意：</p>要运行一些gremlin遍历示例，必须先执行以下导入操作：<pre class="pre codeblock"><code>import com.tinkerpop.pipes.util.structures。*;</code></pre></div>
                  <p>以下示例连接到Oracle数据库，获取具有图形名称<code class="codeph">myGraph</code>的<code class="codeph">OraclePropertyGraph</code>实例，加载一些示例图形数据，并获取顶点和边的列表。
                  </p><pre class="oac_no_warn" dir="ltr"><span class="bold">$ sh ./gremlin-rdbms.sh opg</span> -rdbms&gt; cfg = cfg = GraphConfigBuilder.forPropertyGraphRdbms（）\ .setJdbcUrl（“jdbc：oracle：thin：@ 127.0.0.1：1521：orcl”）\。setUsername（“scott” ）.setPassword（“&lt;password&gt;”）\ .setName（“connections”）。setMaxNumConnections（2）\ .setLoadEdgeLabel（false）\ .addEdgeProperty（“weight”，PropertyType。DOUBLE，“1000000”）\。build（）; opg-rdbms&gt; opg = OraclePropertyGraph.getInstance（cfg）; ==&gt; oraclepropertygraph，名称为myGraph opg-rdbms&gt; opgdl = OraclePropertyGraphDataLoader.getInstance（）; ==&gt; oracle.pg.nosql。OraclePropertyGraphDataLoader @ 576f1cad opg-rdbms&gt; opgdl.loadData（opg，new FileInputStream（“../../data/connections.opv“），新的FileInputStream（”../../data/connections.ope“），4 / * dop * /，1000 / * iBatchSize * /，true / * rebuildIndex * /，null / * szOptions * /）; ==&gt; null opg-rdbms&gt; opg .getVertices（）; ==&gt; Vertex ID 5 {country：str：Italy，name：str：Pope Francis，职业：str：教皇，宗教：str：天主教，角色：str：天主教宗教权威} [...其他省略输出线以简洁......]opg-rdbms&gt; opg.getEdges（）; ==&gt;来自Vertex ID 64的Edge ID 1139 {country：str：United States，name：str：Jeff Bezos，职业：str：business man} = [leads] =&gt; Vertex ID 37 {country：str：美国，名字：str：亚马逊，输入：str：online retailing} edgeKV [{weight：flo：1.0}] [...为简洁省略了其他输出行...]
</pre><p>以下示例为内存分析自定义多个配置参数。它连接到Oracle数据库，获取带有图形名称<code class="codeph">myGraph</code>的<code class="codeph">OraclePropertyGraph</code>实例，加载一些示例图形数据，获取顶点和边缘列表，获取内存分析器，并执行其中一个内置分析，三角计数。
                  </p><pre class="oac_no_warn" dir="ltr"><span class="bold">$ sh ./gremlin-opg-rdbms.sh opg</span> -rdbms&gt; <span class="bold">opg</span> -rdbms&gt; dop = 2; //并行度==&gt; 2 opg-rdbms&gt; confPgx = new HashMap &lt;PgxConfig。Field，Object&gt;（）; opg-rdbms&gt; confPgx.put（PgxConfig。领域。ENABLE_GM_COMPILER，false）; ==&gt; null opg-rdbms&gt; confPgx.put（PgxConfig。领域。NUM_WORKERS_IO，dop）; ==&gt; null opg-rdbms&gt; confPgx.put（PgxConfig。领域。NUM_WORKERS_ANALYSIS，3）; ==&gt; null opg-rdbms&gt; confPgx.put（PgxConfig。领域。NUM_WORKERS_FAST_TRACK_ANALYSIS，2）; ==&gt; null opg-rdbms&gt; confPgx.put（PgxConfig。领域。SESSION_TASK_TIMEOUT_SECS，0）; ==&gt; null opg-rdbms&gt; confPgx.put（PgxConfig。领域。SESSION_IDLE_TIMEOUT_SECS，0）; ==&gt; null opg-rdbms&gt; instance = Pgx.getInstance（）==&gt; null opg-rdbms&gt; instance.startEngine（confPgx）==&gt; null opg-rdbms&gt; cfg = GraphConfigBuilder.forPropertyGraphRdbms（）\ .setJdbcUrl（“jdbc” ：oracle：thin：@ 127.0.0.1：1521：orcl“）\ .setUsername（”scott“）。setPassword（”&lt;password&gt;“）\。setName（”connections“）。setMaxNumConnections（2）\ .setLoadEdgeLabel（false ）\ .addEdgeProperty（“weight”，PropertyType。DOUBLE，“1000000”）\。build（）; opg-rdbms&gt; opg = OraclePropertyGraph.getInstance（cfg）; ==&gt; oraclepropertygraph，名称为myGraph opg-rdbms&gt; opgdl = OraclePropertyGraphDataLoader.getInstance（）; ==&gt; oracle.pg.hbase。OraclePropertyGraphDataLoader @ 3451289b opg-rdbms&gt; opgdl.loadData（opg，“../../data/connections.opv“，”../../data/connections.ope“，4 / * dop * /，1000 / * iBatchSize * /，true / * rebuildIndex * /，null / * szOptions * /）; ==&gt; null opg-rdbms&gt; opg。 getVertices（）; ==&gt; Vertex ID 78 {country：str：United States，name：str：Hosain Rahman，职业：str：Jawbone首席执行官} ...opg-rdbms&gt; opg.getEdges（）; ==&gt;来自Vertex ID 64的Edge ID 1139 {country：str：United States，name：str：Jeff Bezos，职业：str：business man} = [leads] =&gt; Vertex ID 37 {country：str：美国，名字：str：亚马逊，输入：str：online retailing} edgeKV [{weight：flo：1.0}] [...为简洁省略了其他输出行...]opg-rdbms&gt; session = Pgx.createSession（“session-id-1”）; opg-rdbms&gt; g = session.readGraphWithProperties（cfg）; opg-rdbms&gt; analyst = session.createAnalyst（）; opg-rdbms&gt; triangles = analyst.countTriangles（false）.get（）; ==&gt; 22</pre><p>有关Java API的详细信息，请参阅Javadoc参考信息。</p>
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="using-property-graphs-oracle-database.html#GUID-4B5AF258-79BE-418D-84FF-9B8A692B8604" title="本章提供有关在Oracle数据库环境中创建，存储和使用属性图数据的概念和用法信息。">在Oracle数据库环境中使用属性图</a></p>
                     </div>
                  </div>
               </div>
               
            </div>
            <div class="props_rev_3"><a id="GUID-BDA846D6-DA18-4049-91DF-E96BEAB02B6D" name="GUID-BDA846D6-DA18-4049-91DF-E96BEAB02B6D"></a><h3 id="SPGDG-GUID-BDA846D6-DA18-4049-91DF-E96BEAB02B6D" class="sect3"><span class="enumeration_section">2.9</span>在Oracle数据库中使用内存分析器Zeppelin Interpreter</h3>
               <div>
                  <p>内存分析师为Apache Zeppelin提供了一个解释器实现。本教程主题介绍如何将内存分析器解释器安装到本地Zeppelin安装中并执行一些简单的操作。</p>
                  <div class="section">
                     <p class="subhead2" id="GUID-BDA846D6-DA18-4049-91DF-E96BEAB02B6D__GUID-294969D0-6737-42DC-936C-E8F34F3C9407">安装口译员</p>
                     <p>以下步骤使用Zeppelin 0.7.0版进行了测试，可能需要使用较新版本进行修改。</p>
                     <ol>
                        <li>
                           <p>如果您还没有这样做，请<a href="http://zeppelin.apache.org/download.html" target="_blank">下载并安装Apache Zeppelin</a> 。
                           </p>
                        </li>
                        <li>
                           <p>按照<a href="https://zeppelin.apache.org/docs/latest/development/writing_zeppelin_interpreter.html#install-your-interpreter-binary" target="_blank">官方解释器安装步骤操作</a> 。
                           </p>
                           <ol type="a">
                              <li>
                                 <p>将<code class="codeph">$OSG_HOME/md/property_graph/pgx/client/</code>中的内存<code class="codeph">$OSG_HOME/md/property_graph/pgx/client/</code>解释器包解压缩到<code class="codeph">$ZEPPELIN_HOME/interpreter/pgx</code> 。
                                 </p>
                              </li>
                              <li>
                                 <p>使用模板中的默认<code class="codeph">zeppelin-site</code>配置： <code class="codeph">cp $ZEPPELIN_HOME/conf/zeppelin-site.xml.template $ZEPPELIN_HOME/conf/zeppelin-site.xml</code></p>
                              </li>
                              <li>
                                 <p>编辑<code class="codeph">$ZEPPELIN_HOME/conf/zeppelin-site.xml</code>并添加内存分析师Zeppelin解释器类名<code class="codeph">oracle.pgx.zeppelin.PgxInterpreter</code>到<code class="codeph">zeppelin.interpreters</code>属性字段。
                                 </p>
                              </li>
                              <li>
                                 <p>重启Zeppelin。</p>
                              </li>
                              <li>
                                 <p>在Zeppelin解释器页面中，单击<span class="bold">+创建</span>按钮以添加解释器组<code class="codeph">pgx</code>的新解释器。
                                 </p>
                              </li>
                              <li>
                                 <p>有关不同配置字段的说明，请参阅<a href="https://docs.oracle.com/cd/E56133_01/2.5.0/reference/config/client.html" target="_blank">PGX客户端配置指南</a> 。
                                 </p>
                                 <p>请注意，PGX解释器的作用类似于与远程PGX服务器通信的客户端。您无法运行Zeppelin解释器中<a href="https://docs.oracle.com/cd/E56133_01/2.5.0/reference/overview/usage.html" target="_blank">嵌入</a>的PGX实例。您必须提供PGX服务器基本URL和连接信息。
                                 </p>
                              </li>
                           </ol>
                        </li>
                     </ol>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-BDA846D6-DA18-4049-91DF-E96BEAB02B6D__GUID-A1A9FA55-37B0-418D-87F6-05B7CC3CBD7D">使用口译员</p>
                     <p>如果您命名了内存<code class="codeph">pgx</code>解释器<code class="codeph">pgx</code> ，则可以通过使用<code class="codeph">%pgx</code>指令启动段落将段落发送到内存分析器解释器，就像使用任何其他解释器一样。
                     </p>
                     <p>内存分析器Zeppelin解释器以与内存分析器shell相同的方式评估段落，并返回输出。因此，任何有效的内存分析器shell脚本都将在内存分析器解释器中运行，如下例所示：</p><pre class="pre codeblock"><code>％pgx g_brands = session.readGraphWithProperties（“/ opt / data / exommerce / brand_cat.json”）g_brands.getNumVertices（）rank = analyst.pagerank（g_brands，0.001,0.85,100）rank.getTopKValues（10）</code></pre><p>下图显示了单击图标执行后查询的结果。</p>
                     <div class="figure" id="GUID-BDA846D6-DA18-4049-91DF-E96BEAB02B6D__GUID-0E6AA854-8552-4351-A6E9-B3067774DAAF"><img src="img/pgx-zeppelin-results.jpg" alt="pgx-zeppelin-results.jpg的描述如下" title="pgx-zeppelin-results.jpg的描述如下" longdesc="img_text/pgx-zeppelin-results.html"><br><a href="img_text/pgx-zeppelin-results.html">插图描述pgx-zeppelin-results.jpg</a></div>
                     <!-- class="figure" -->
                     <p>正如您在上图中所看到的，内存<code class="codeph">rank.getTopKValues(10)</code> Zeppelin解释器会自动将<code class="codeph">rank.getTopKValues(10)</code>返回的值呈现为Zeppelin表，以便您更方便地浏览结果。
                     </p>
                     <p>除了属性值（ <code class="codeph">getTopKValues(), getBottomKValues(), and getValues()</code> ）之外，如果从段落返回，则以下返回类型也会自动呈现为表：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">PgqlResultSet</code> - <code class="codeph">PgxGraph</code>类的<code class="codeph">queryPgql("...")</code>方法返回的对象</p>
                        </li>
                        <li>
                           <p><code class="codeph">MapIterable</code> - <code class="codeph">PgxMap</code>类的<code class="codeph">entries()</code>方法返回的对象</p>
                        </li>
                     </ul>
                     <p>所有其他返回类型和错误都作为普通字符串返回，就像内存分析器shell一样。</p>
                     <p>有关Zeppelin的更多信息，请参阅<a href="https://zeppelin.apache.org/" target="_blank">Zeppelin官方文档</a> 。
                     </p>
                  </div>
                  <!-- class="section" -->
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="using-property-graphs-oracle-database.html#GUID-4B5AF258-79BE-418D-84FF-9B8A692B8604" title="本章提供有关在Oracle数据库环境中创建，存储和使用属性图数据的概念和用法信息。">在Oracle数据库环境中使用属性图</a></p>
                     </div>
                  </div>
               </div>
               
            </div>
            <div class="props_rev_3"><a id="GUID-D0904048-83F2-48AE-9B23-675D3F934BD9" name="GUID-D0904048-83F2-48AE-9B23-675D3F934BD9"></a><h3 id="SPGDG-GUID-D0904048-83F2-48AE-9B23-675D3F934BD9" class="sect3"><span class="enumeration_section">2.10</span> Oracle数据库属性图数据的REST支持</h3>
               <div>
                  <p>一组RESTful API通过HTTP / REST协议公开数据访问层Java API。</p>
                  <p>这些RESTful API支持创建，更新，查询和遍历属性图，以及执行文本搜索查询，使用gremlin执行图遍历查询以及处理Oracle数据库中的图。</p>
                  <p>以下主题说明如何使用数据访问层（DAL）中包含的REST API为Oracle大数据空间和图形属性图支持创建RESTful Web服务。稍后可以在Apache Tomcat或Oracle WebLogic Server（12 <span class="italic">c</span> Release 2或更高版本）上部署该服务。
                  </p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-0ED64238-CBAB-4D89-9411-05D2F920ACFB">为Oracle数据库构建REST Web应用程序归档（WAR）文件</a><br></li>
                     <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-A51758AD-5930-4105-81AC-9F1AA5EF4E0D">为Oracle数据库部署RESTful Property Graph Web服务</a><br></li>
                     <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-BB6CBF64-8B59-4356-B45B-3D9CBEBCA2C6">属性图REST API Oracle数据库操作信息</a><br></li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="using-property-graphs-oracle-database.html#GUID-4B5AF258-79BE-418D-84FF-9B8A692B8604" title="本章提供有关在Oracle数据库环境中创建，存储和使用属性图数据的概念和用法信息。">在Oracle数据库环境中使用属性图</a></p>
                     </div>
                  </div>
               </div>
               
               <div class="props_rev_3"><a id="GUID-0ED64238-CBAB-4D89-9411-05D2F920ACFB" name="GUID-0ED64238-CBAB-4D89-9411-05D2F920ACFB"></a><h4 id="SPGDG-GUID-0ED64238-CBAB-4D89-9411-05D2F920ACFB" class="sect4"><span class="enumeration_section">2.10.1</span>为Oracle数据库构建REST Web应用程序归档（WAR）文件</h4>
                  <div>
                     <div class="p">
                        <p>本主题描述如何为Oracle Spatial和Graph创建Web应用程序归档（WAR）文件，以将RESTful API用于属性图。</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>转到产品主目录下的<code class="codeph">webapp</code>目录。</span><div><pre class="pre codeblock"><code>cd / opt / oracle / oracle-spatial-graph / property_graph / dal / webapp</code></pre></div>
                        </li>
                        <li class="stepexpand"><span>设置HTTP_PROXY环境变量（如果需要），以允许从可用的maven存储库下载第三方库。例如：</span><div><pre class="pre codeblock"><code>setenv HTTP_PROXY www-myproxy.com:80导出HTTP_PROXY = www-myproxy.com:80</code></pre></div>
                        </li>
                        <li class="stepexpand"><span>下载RESTful API所需的第三方库：</span><div><pre class="oac_no_warn" dir="ltr">commons-httpclient-3.1.jar gremlin-java-2.3.0.jar jackson-jaxrs-base-2.8.4.jar jackson-jaxrs-json-provider-2.8.4.jar jackson-module-jaxb-annotations-2.8。 4.jar jersey-entity-filtering-2.25.1.jar jersey-media-json-jackson-2.25.1.jar jersey-media-multipart-2.25.1.jar mimepull-1.9.6.jar rexster-core-2.3 .0.jar rexster-protocol-2.3.0.jar rexster-server-2.3.0.jar</pre><p>以下命令显示如何将库从maven存储库下载到目录<code class="codeph">/tmp/extlib-unified-rest</code> 。请注意，URL可能会更改：</p><pre class="pre codeblock"><code>mkdir / tmp / extlib-unified-rest cd / tmp / extlib-unified-rest wget http://central.maven.org/maven2/commons-httpclient/commons-httpclient/3.1/commons-httpclient-3.1.jar wget http ：//central.maven.org/maven2/com/tinkerpop/gremlin/gremlin-java/2.3.0/gremlin-java-2.3.0.jar wget http://central.maven.org/maven2/com/fasterxml /jackson/jaxrs/jackson-jaxrs-base/2.8.4/jackson-jaxrs-base-2.8.4.jar wget http://central.maven.org/maven2/com/fasterxml/jackson/jaxrs/jackson-jaxrs -json-provider / 2.8.4 / jackson-jaxrs-json-provider-2.8.4.jar wget http://central.maven.org/maven2/com/fasterxml/jackson/module/jackson-module-jaxb-annotations /2.8.4/jackson-module-jaxb-annotations-2.8.4.jar wget http://central.maven.org/maven2/org/glassfish/jersey/ext/jersey-entity-filtering/2.25.1/jersey -entity-filtering-2.25.1.jar wget http://central.maven.org/maven2/org/glassfish/jersey/media/jersey-media-json-jackson/2.25.1/jersey-media-json-jackson -2.25.1.jar wget http://central.maven.org/maven2/org/glassfish/jersey/media/jersey -media-multipart / 2.25.1 / jersey-media-multipart-2.25.1.jar wget http://central.maven.org/maven2/org/jvnet/mimepull/mimepull/1.9.6/mimepull-1.9.6 .jar wget http://central.maven.org/maven2/com/tinkerpop/rexster/rexster-core/2.3.0/rexster-core-2.3.0.jar wget http://central.maven.org/maven2 /com/tinkerpop/rexster/rexster-protocol/2.3.0/rexster-protocol-2.3.0.jar wget http://central.maven.org/maven2/com/tinkerpop/rexster/rexster-server/2.3.0 /rexster-server-2.3.0.jar</code></pre></div>
                        </li>
                        <li class="stepexpand"><span>通过保存并运行名为<code class="codeph">assemble_unified_rest.sh</code>的以下脚本来创建RESTFul Web应用程序存档。</span><div><pre class="pre codeblock"><code>＃！/ bin / sh #Input一个临时工作目录名saveDir =`pwd` read -p“请输入一个临时工作目录名称（例如/ tmp / work_unified）：”tmpDir #Append date到目录名tmpDir =“$ {tmpDir } /`date“+％m％d％H％M％S”`“mkdir -p $ {tmpDir} read -p”使用$ {tmpDir}来保存一些中间文件是否可以？（是|否）：“yn case $ yn in [Nn] *）echo”Quit。“; exit; esac echo”继续...“#Input目录名称到属性图目录read -p”请输入目录名称到属性图表目录（例如/ opt / oracle / oracle-spatial-graph / property_graph）：“pgSrc＃验证属性图目录是否包含sdopgdal.jar if [-f $ {pgSrc} /lib/sdopgdal.jar] ;然后echo“$ {pgSrc}似乎有效”，否则echo“$ {pgSrc}似乎无效。找不到$ {pgSrc} / lib下的文件sdopgdal.jar“echo”Quit。“; exit; fi＃输入下载第三方库的目录cat &lt;&lt; EOF ------------ ---------------------------- commons-httpclient-3.1.jar gremlin-java-2.3.0.jar jackson-jaxrs-base- 2.8.4.jar jackson-jaxrs-json-provider-2.8.4.jar jackson-module-jaxb-annotations-2.8.4.jar jersey-entity-filtering-2.25.1.jar jersey-media-json-jackson- 2.25.1.jar jersey-media-multipart-2.25.1.jar mimepull-1.9.6.jar rexster-core-2.3.0.jar rexster-protocol-2.3.0.jar rexster-server-2.3.0.jar ---------------------------------------- EOF read -p“请输入目录名称它包含上面显示的库集：“extSrc＃做一些健全性检查，如果[-f $ {extSrc} /gremlin-java-2.3.0.jar];那么如果[-f $ {extSrc} / rexster-core -2.3.0.jar];然后回显“通过完整性检查。”否则回显“$ {extSrc}似乎无效。找不到rexster-core-2.3.0.jar。“echo”退出。“;退出; fi else echo”$ {extSrc}似乎无效。找不到gremlin-java-2.3.0.jar。“echo”退出。“;退出; fi＃将库转换成一些变量groovylib =”$ {pgSrc} /lib/groovy*all*.jar“gremgroovylib = “$ {pgSrc} /dal/groovy/gremlin-groovy*.jar”msglib =“$ {pgSrc} /dal/webapp/msgpack*.jar”javaxservletlib =“$ {pgSrc} /dal/webapp/javax.servlet* .jar“httpcorelib =”$ {pgSrc} /pgx/spark/httpcore*.jar“jtalib =”$ {pgSrc} /lib/jta*.jar“＃更新休息逻辑。这将修改Rexster库以包含Oracle逻辑回声“更新休息逻辑”tmpRestDir = $ {tmpDir} / rest mkdir -p $ {tmpRestDir} cd $ {tmpRestDir}; jar xf $ {extSrc} /rexster-serv*.jar cd $ {tmpRestDir}; jar xf $ {extSrc} /rexster-core*.jar cd $ {tmpRestDir}; jar xf $ {extSrc} /rexster-prot*.jar tmpRestDir1 = $ {tmpDir} / rest1 mkdir -p $ {tmpRestDir1} cd $ {tmpRestDir1}; jar xf $ {pgSrc} /lib/sdopgdal.jar cp -rf $ {tmpRestDir1} / com / tinkerpop / rexster / * $ {tmpRestDir} / com / tinkerpop / rexster / cd $ {tmpRestDir}; jar cfM $ {tmpDir} /rexster-combined.jar * #Update Web应用程序。这将修改PGX战争以包括下载的第三方库echo“更新Web应用程序”tmpWarDir = $ {tmpDir} / webapp mkdir -p $ {tmpWarDir} cd $ {tmpWarDir} jar xf $ {pgSrc} / pgx / server / shared-mem / pgx-webapp-2.5.0.war cp -f $ {groovylib} $ {tmpWarDir} / WEB-INF / lib / cp -f $ {gremgroovylib} $ {tmpWarDir} / WEB-INF / lib / cp -f $ {msglib} $ {tmpWarDir} / WEB-INF / lib / cp -f $ {javaxservletlib} $ {tmpWarDir} / WEB-INF / lib / cp -f $ {httpcorelib} $ {tmpWarDir} / WEB-INF / lib / cp -f $ {jtalib} $ {tmpWarDir} / WEB-INF / lib / cp -f $ {extSrc} / * .jar $ {tmpWarDir} / WEB-INF / lib / rm -f $ {tmpWarDir} /WEB-INF/lib/rexster*.jar#添加更新的休息库cp -f $ {tmpDir} /rexster-combined.jar $ {tmpWarDir} / WEB-INF / lib /＃更新元数据mkdir -p $ {tmpWarDir / WEB-INF / classes / META-INF / services / cp -f $ {pgSrc} /dal/webapp/rest-extension.txt $ {tmpWarDir} / WEB-INF / classes / META-INF / services / com。 tinkerpop.rexster.extension。RexsterExtension＃包含rexster配置文件cp -f $ {pgSrc} /dal/webapp/rest-config.xml $ {tmpWarDir} /WEB-INF/classes/rexster.xml#include web.xml和weblogic.xml cp -f $ {pgSrc} /dal/webapp/web*.xml $ {tmpWarDir} / WEB-INF /＃添加索引页面echo“&lt;html&gt; &lt;body&gt; &lt;h1&gt;欢迎使用统一属性图REST界面！&lt;/ h1&gt; &lt;/ body&gt; &lt;/ html&gt;“&gt; $ {tmpWarDir} /index.html＃创建战争CD $ {tmpWarDir}; jar cfM $ {tmpDir} /opg_unified.war * echo”完成。最终的Web应用程序是“ls -l $ {tmpDir} /opg_unified.war cd $ {saveDir}</code></pre><p>要运行该脚本，请执行以下命令：</p><pre class="pre codeblock"><code>sh assemble_unified_rest.sh</code></pre></div>
                        </li>
                        <li class="stepexpand"><span>指定用于构建<code class="codeph">opg_unified.war</code>文件的临时目录。例如：</span><div><pre class="pre codeblock"><code>请输入临时工作目录名称（例如/ tmp / work_unified）：/ tmp / work_unified</code></pre><p>该脚本将使用此目录使用系统的当前日期（MMDDhhmmss）创建临时工作目录，以保存构建RESTful Web应用程序存档所需的所有中间文件。其中包括RESTful API，第三方库和REST配置。请注意，您必须确保可以创建目录并用于保存这些中间文件。</p><pre class="pre codeblock"><code>是否可以使用/ tmp / work_unified / 0823150126来保存一些中间文件？（是|否）：是的</code></pre></div>
                        </li>
                        <li class="stepexpand"><span>6。指定产品主目录。例如：</span><div><pre class="oac_no_warn" dir="ltr">继续...请输入属性图目录的目录名（例如/ opt / oracle / oracle-spatial-graph / property_graph）：/ opt / oracle / oracle-spatial-graph / property_graph opt / oracle / oracle-spatial-graph / property_graph似乎有效</pre></div>
                        </li>
                        <li class="stepexpand"><span>指定包含RESTful第三方库的目录。</span><div>
                              <p>这是您之前指定的目录。例如： <code class="codeph">/tmp/extlib-unified-rest</code></p>
                              <p>设置所需目录后，脚本将更新REST API并使用Jersey配置REST Web应用程序存档。在该过程结束时，将打印出一条消息，其中包含生成的war文件的最终大小和位置。例如：</p><pre class="oac_no_warn" dir="ltr">通过了理智检查。更新休息逻辑更新Web应用程序完成。最终的Web应用程序是-rw-r  -  r-- 1用户组108219486 Aug 24 08:59 /tmp/work_unified/0823150126/opg_unified.war</pre><p>请注意，执行这些步骤时，创建的基于时间戳的临时目录名称（在此示例中为<code class="codeph">0823150126/</code> ）将有所不同。
                              </p>
                           </div>
                        </li>
                     </ol>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="using-property-graphs-oracle-database.html#GUID-D0904048-83F2-48AE-9B23-675D3F934BD9" title="一组RESTful API通过HTTP / REST协议公开数据访问层Java API。">Oracle数据库属性图数据的REST支持</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="props_rev_3"><a id="GUID-A51758AD-5930-4105-81AC-9F1AA5EF4E0D" name="GUID-A51758AD-5930-4105-81AC-9F1AA5EF4E0D"></a><h4 id="SPGDG-GUID-A51758AD-5930-4105-81AC-9F1AA5EF4E0D" class="sect4"><span class="enumeration_section">2.10.2</span>为Oracle数据库部署RESTful Property Graph Web Service</h4>
                  <div>
                     <div class="section">
                        <p>本主题描述如何将<code class="codeph">opg_unified.war</code>文件部署到Oracle WebLogic 12.2.0.1或Apache Server Apache Tomcat中。
                        </p>
                        <ol>
                           <li>
                              <p>确保已下载REST第三方库并创建了<code class="codeph">opg_unified.war</code> REST Web应用程序归档（WAR）文件，如构建REST Web应用程序归档（WAR）文件中所述。
                              </p>
                           </li>
                           <li>
                              <p>提取<code class="codeph">rexster.xml</code>位于文件<code class="codeph">opg_unified.war</code>使用下面的命令：</p><pre class="pre codeblock"><code>cd / tmp / work_unified / &lt;MMDDhhmmss&gt; / jar xf opg_unified.war WEB-INF / classes / rexster.xml</code></pre></li>
                           <li>
                              <p>修改REST配置文件（ <code class="codeph">rexster.xml</code> ）以指定默认后端，后端的附加列表（如果存在），以及在处理属性图请求时将使用的可用图表列表。有关此文件的详细信息，请参阅<a href="using-property-graphs-oracle-database.html#GUID-64BB71FF-D88C-4182-BED1-C382297F3CFD">Oracle数据库的RESTful属性图服务配置文件（rexster.xml）</a> 。
                              </p>
                           </li>
                           <li>
                              <p>通过更新<code class="codeph">rexster.xml</code>文件重建<code class="codeph">opg_unified.war</code> ，如下所示：</p><pre class="pre codeblock"><code>jar uf opg_unified.war WEB-INF / classes / rexster.xml</code></pre></li>
                           <li>
                              <p>将<code class="codeph">opg_unified.war</code>部署到选定的J2EE容器中。
                              </p>
                           </li>
                        </ol>
                        <p>部署容器选项：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="using-property-graphs-oracle-database.html#GUID-A51758AD-5930-4105-81AC-9F1AA5EF4E0D__DEPLOYMENTUSINGAPACHETOMCAT-4943326C">使用Apache Tomcat进行部署</a></p>
                           </li>
                           <li>
                              <p><a href="using-property-graphs-oracle-database.html#GUID-A51758AD-5930-4105-81AC-9F1AA5EF4E0D__DEPLOYMENTUSINGORACLEWEBLOGICSERVER-49433FEA">使用Oracle WebLogic Server进行部署</a></p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-A51758AD-5930-4105-81AC-9F1AA5EF4E0D__DEPLOYMENTUSINGAPACHETOMCAT-4943326C">
                        <p class="subhead3" id="GUID-A51758AD-5930-4105-81AC-9F1AA5EF4E0D__DEPLOYMENTUSINGAPACHETOMCAT-494334F7">使用Apache Tomcat进行部署</p>
                        <p>本节介绍如何使用Apache Tomcat 8.5.14（或更高版本）部署RESTful Property Graph Web服务。Apache Tomcat是一个开源Web服务器，它实现Java Servlet和JavaServer Pages（JSP）并提供HTTP Web服务器环境来运行Web应用程序。有关Apache Tomcat的更多信息，请参阅<a href="http://tomcat.apache.org/" target="_blank">http://tomcat.apache.org/</a> 。</p>
                        <ol>
                           <li>
                              <p>下载并安装Apache Tomcat 8.5.14。</p>
                           </li>
                           <li>
                              <p>转到Apache Tomcat Server的Web应用程序目录并复制<code class="codeph">opg_unified.war</code>文件，如下所示。
                              </p><pre class="pre codeblock"><code>cd $ CATALINA_BASE cp -f /tmp/work_unified/&lt;MMDDhhmmss&gt;/opg_unified.war webapps</code></pre><p>此操作将解压war文件并部署Web应用程序。（有关在Apache Tomcat中部署Web应用程序的更多信息，请参阅Apache Tomcat文档。）</p>
                           </li>
                           <li>
                              <p>通过在浏览器中打开以下URL来验证部署（假设Web应用程序部署在端口8080）： <code class="codeph">http://&lt;hostname&gt;:8080/opg_unified</code></p>
                              <p>您应该会看到一个标题为<span class="italic">欢迎使用统一属性图REST界面的页面！</span></p>
                           </li>
                        </ol>
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-A51758AD-5930-4105-81AC-9F1AA5EF4E0D__DEPLOYMENTUSINGORACLEWEBLOGICSERVER-49433FEA">
                        <p class="subhead3" id="GUID-A51758AD-5930-4105-81AC-9F1AA5EF4E0D__DEPLOYMENTUSINGORACLEWEBLOGICSERVER-494342EB">使用Oracle WebLogic Server进行部署</p>
                        <p>本节介绍如何使用Oracle WebLogic Server 12 <span class="italic">c</span>版本12.2.1.2.0部署RESTful Property Graph端点。有关Oracle WebLogic Server的详细信息，请参阅其产品文档。
                        </p>
                        <ol>
                           <li>
                              <p>下载并安装Oracle WebLogic Server 12 <span class="italic">c</span>第2版（12.2.1.2.0）。
                              </p>
                           </li>
                           <li>
                              <p>注册Jersey 2.5.1的共享预构建共享库（JAX-RS 2.0。RI）包含在WebLogic Server安装中。该库需要运行基于Jersey 2.5.1的应用程序，例如用于Oracle Spatial和Graph Property Graph的RESTful Web服务。</p>
                              <ol type="a">
                                 <li>
                                    <p>登录WebLogic Server管理控制台。示例控制台端点是<code class="codeph">http://localhost:7001/console</code> 。</p>
                                 </li>
                                 <li>
                                    <p>选择<span class="bold">部署</span> 。
                                    </p>
                                 </li>
                                 <li>
                                    <p>单击“ <span class="bold">安装”</span>以安装共享库。
                                    </p>
                                 </li>
                                 <li>
                                    <p>在“ <span class="bold">路径”</span>字段中，输入或导航到以下目录：MW_HOME \ wlserver \ common \ deployable-libraries。
                                    </p>
                                 </li>
                                 <li>
                                    <p>选择<span class="bold">jax-rs-2.0.war</span>文件，然后单击“ <span class="bold">下一步”</span> 。
                                    </p>
                                 </li>
                                 <li>
                                    <p>选择“ <span class="bold">将此部署安装为库”</span> 。
                                    </p>
                                 </li>
                                 <li>
                                    <p>单击<span class="bold">下一步</span> 。
                                    </p>
                                 </li>
                                 <li>
                                    <p>单击<span class="bold">完成</span> 。
                                    </p>
                                 </li>
                              </ol>
                           </li>
                           <li>
                              <p>修改<code class="codeph">opg_unified.war</code>以删除WebLogic Server已提供的<code class="codeph">jersey</code>和<code class="codeph">hk2</code>第三方库。
                              </p>
                              <ol type="a">
                                 <li>
                                    <p>在work_unified目录下创建一个临时工作目录，其中创建了<code class="codeph">opg_unified.war</code> 。例如：</p><pre class="pre codeblock"><code>cd / tmp / work_unified / &lt;MMDDhhmmss&gt; / mkdir work_weblogic cd work_weblogic</code></pre></li>
                                 <li>
                                    <p>将<code class="codeph">opg_unified.war</code>内容解压缩到临时目录中：例如：</p><pre class="pre codeblock"><code>jar xf ../opg_unified.war</code></pre></li>
                                 <li>
                                    <p>从<code class="codeph">WEB-INF/lib</code>目录中删除Jersey 2.25第三方库：</p><pre class="oac_no_warn" dir="ltr">rm -rf WEB-INF / lib / jersey-client-2.25.1.jar rm -rf WEB-INF / lib / jersey-common-2.25.1.jar rm -rf WEB-INF / lib / jersey-container-servlet -core-2.25.1.jar rm -rf WEB-INF / lib / jersey-entity-filtering-2.25.1.jar rm -rf WEB-INF / lib / jersey-guava-2.25.1.jar rm -rf WEB -INF / lib / jersey-server-2.25.1.jar rm -rf WEB-INF / lib / hk2-api-2.5.0-b32.jar rm -rf WEB-INF / lib / hk2-locator-2.5.0 -b32.jar rm -rf WEB-INF / lib / hk2-utils-2.5.0-b32.jar</pre><p></p>
                                 </li>
                                 <li>
                                    <p>重建<code class="codeph">opg_unified.war</code> ：</p><pre class="pre codeblock"><code>jar cfM ../opg_unified.war *</code></pre></li>
                              </ol>
                           </li>
                           <li>
                              <p>转到WebLogic Server安装的<code class="codeph">autodeploy</code>目录并复制文件。例如：</p><pre class="pre codeblock"><code>cd &lt;domain_name&gt; / autodeploy cp -rf /tmp/work_unified/&lt;MMDDhhmmss&gt;/opg_unified.war &lt;domain_name&gt; / autodeploy</code></pre><p>在前面的示例中， <span class="italic">&lt;domain_name&gt;</span>是WebLogic Server域的名称。
                              </p>
                              <p>请注意，虽然您可以在开发或生产模式下运行WebLogic Server域，但只有<span class="bold">开发</span>模式允许您使用自动部署功能。
                              </p>
                           </li>
                           <li>
                              <p>通过在浏览器中打开以下URL来验证部署（假设Web应用程序部署在端口7001）： <code class="codeph">http://&lt;hostname&gt;:7001/opg_unified</code></p>
                              <p>您应该会看到一个标题为<span class="italic">欢迎使用统一属性图REST界面的页面！</span></p>
                           </li>
                        </ol>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-64BB71FF-D88C-4182-BED1-C382297F3CFD">Oracle数据库的RESTful属性图服务配置文件（rexster.xml）</a><br></li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="using-property-graphs-oracle-database.html#GUID-D0904048-83F2-48AE-9B23-675D3F934BD9" title="一组RESTful API通过HTTP / REST协议公开数据访问层Java API。">Oracle数据库属性图数据的REST支持</a></p>
                        </div>
                     </div>
                  </div>
                  
                  <div class="props_rev_3"><a id="GUID-64BB71FF-D88C-4182-BED1-C382297F3CFD" name="GUID-64BB71FF-D88C-4182-BED1-C382297F3CFD"></a><h5 id="SPGDG-GUID-64BB71FF-D88C-4182-BED1-C382297F3CFD" class="sect5"><span class="enumeration_section">2.10.2.1</span> Oracle数据库的RESTful属性图服务配置文件（rexster.xml）</h5>
                     <div>
                        <p>Oracle Spatial and Graph扩展了Tinkerpop Rexster RESTful API，以便在属性图上提供RESTful功能。要启用RESTful服务的配置， <code class="codeph">opg_unified.war</code>包含一个<code class="codeph">rexster.xml</code>文件，其中包含数据库后端的配置以及应在服务启动时设置和加载的图形。
                        </p>
                        <p><code class="codeph">rexster.xml</code>文件是基于XML的配置文件，至少包含四个主要部分（或标记）：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><span class="bold">&lt;script-engines&gt;：</span>用于在属性图上运行脚本的脚本引擎。默认情况下，使用<code class="codeph">gremlin-groovy</code> 。
                              </p>
                           </li>
                           <li>
                              <p><span class="bold">&lt;oracle-pool-size&gt;：</span>允许属性图的并发连接数。默认情况下，配置使用池大小为3。
                              </p>
                           </li>
                           <li>
                              <p><span class="bold">&lt;oracle-property-graph-backends&gt;：</span>有关RESTful API应使用的数据库<span class="bold">后端</span>的信息。默认情况下，必须至少定义一个指定了<code class="codeph">&lt;default-backend&gt;true&lt;/default-backend&gt;</code>标记<code class="codeph">&lt;default-backend&gt;true&lt;/default-backend&gt;</code> 。此配置将用作所有RESTful API服务的默认数据库连接。
                              </p>
                           </li>
                           <li>
                              <p><span class="bold">&lt;graphs&gt;：</span>服务启动时为请求提供服务的可用图表列表。此列表中定义的图表是基于其关联的数据库配置创建的。
                              </p>
                           </li>
                        </ul>
                        <p>默认情况下， <code class="codeph">rexster.xml</code>必须在<span class="bold">&lt;oracle-property-graph-backends&gt;</span>部分下定义至少一个后端配置。每个后端由<span class="italic">后端名称</span>和<span class="italic">后端类型</span> （ <code class="codeph">oracle_rdms</code> l）标识。必须将其他数据库参数指定为后端的属性。这些数据库参数包括JDBC_URL，用户名和用户密码。
                        </p>
                        <p>配置文件可以包含多个后端。</p>
                        <p>以下代码段显示了具有Oracle数据库后端的<code class="codeph">rexster.xml</code>文件的配置。
                        </p><pre class="oac_no_warn" dir="ltr">&lt;backend&gt; &lt;backend-name&gt; rdbms_connection &lt;/ backend-name&gt; &lt;backend-type&gt; oracle_rdbms &lt;/ backend-type&gt; &lt;default-backend&gt; true &lt;/ default-backend&gt; &lt;properties&gt; &lt;jdbcUrl&gt; jdbc：oracle：thin ：@ 127.0.0.1：1521：orcl &lt;/ jdbcUrl&gt; &lt;user&gt; scott &lt;/ user&gt; &lt;password&gt; YOUR_PASSWORD_HERE &lt;/ password&gt; &lt;/ properties&gt; &lt;/ backend&gt;</pre><p>必须为服务设置默认后端，因为<code class="codeph">rexster.xml</code>端将用作所有属性图RESTful操作的<span class="bold">默认</span>数据库配置，这些操作是通过先前未在<code class="codeph">rexster.xml</code>文件的图形部分中定义的图形<code class="codeph">rexster.xml</code> 。在前面的示例中，名为<span class="italic">rdbms_connection的后端</span>将设置为默认后端。
                        </p>
                        <p><span class="bold">&lt;graphs&gt;</span> XML元素标识可用于用户请求的属性图表列表。每个图形由<span class="italic">图形名称</span>和<span class="italic">图形类型</span> （ <code class="codeph">oracle.pg.rdbms.OraclePropertyGraphConfiguration</code> ）。必须根据图表的类型将其他数据库参数指定为属性。这些数据库参数包括JDBC_URL，用户名和用户密码。
                        </p>
                        <p>此外，您可以通过在<code class="codeph">extensions</code>子部分下使用带有<code class="codeph">tp:gremlin</code>值的<span class="italic">allow</span>标记来指定是否允许在图上运行的扩展，例如运行gremlin查询的<code class="codeph">extensions</code> 。
                        </p>
                        <p>以下代码段显示了<code class="codeph">rexster.xml</code>的配置， <code class="codeph">rexster.xml</code>包含使用Oracle数据库命名为<span class="italic">connections</span> graph的属性图。
                        </p><pre class="oac_no_warn" dir="ltr">&lt;graphs&gt; &lt;graph&gt; &lt;graph-name&gt; connections &lt;/ graph-name&gt; &lt;graph-type&gt; oracle.pg.rdbms。OraclePropertyGraphConfiguration &lt;/ graph-type&gt; &lt;properties&gt; &lt;jdbcUrl&gt; jdbc：oracle：thin：@ 127.0.0.1：1521：orcl &lt;/ jdbcUrl&gt; &lt;user&gt; scott &lt;/ user&gt; &lt;password&gt; YOUR_PASSWORD_HERE &lt;/ password&gt; &lt;/ properties &gt; &lt;extensions&gt; &lt;allows&gt; &lt;allow&gt; tp：gremlin &lt;/ allow&gt; &lt;/ allows&gt; &lt;/ extensions&gt; &lt;/ graph&gt; &lt;/ graphs&gt;</pre><p>当针对给定图形名称执行HTTP请求（GET，POST，PUT，DELETE）操作时，该服务将查找<code class="codeph">rexster.xml</code>配置文件中定义的图形数据库配置。如果图形未包含在配置文件中，则请求将失败，并显示“无法找到图形”错误消息，并且操作将无法完成。
                        </p>
                        <p>您可以通过在创建图形服务上执行HTTP POST请求，将新图形动态添加到服务中以用于后续HTTP请求。</p>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="using-property-graphs-oracle-database.html#GUID-A51758AD-5930-4105-81AC-9F1AA5EF4E0D">为Oracle数据库部署RESTful Property Graph Web Service</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div>
               <div class="props_rev_3"><a id="GUID-BB6CBF64-8B59-4356-B45B-3D9CBEBCA2C6" name="GUID-BB6CBF64-8B59-4356-B45B-3D9CBEBCA2C6"></a><h4 id="SPGDG-GUID-BB6CBF64-8B59-4356-B45B-3D9CBEBCA2C6" class="sect4"><span class="enumeration_section">2.10.3</span> Oracle数据库的属性图REST API操作信息</h4>
                  <div>
                     <p>本主题描述属性图REST API的操作。</p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-22F4D8AA-D028-4B68-A026-A970F1BCE343">针对Oracle数据库的GET操作（属性图）</a><br></li>
                        <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-BCF729EE-0742-41A0-8BBE-B629EF7D4FF8">Oracle数据库的POST操作（属性图）</a><br></li>
                        <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-22BD7107-5546-4072-A194-BBBDF8C63CBA">Oracle数据库的PUT操作（属性图）</a><br></li>
                        <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-4343EDC5-88CE-441E-A377-238ED855D010">删除Oracle数据库的操作（属性图）</a><br></li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="using-property-graphs-oracle-database.html#GUID-D0904048-83F2-48AE-9B23-675D3F934BD9" title="一组RESTful API通过HTTP / REST协议公开数据访问层Java API。">Oracle数据库属性图数据的REST支持</a></p>
                        </div>
                     </div>
                  </div>
                  
                  <div class="props_rev_3"><a id="GUID-22F4D8AA-D028-4B68-A026-A970F1BCE343" name="GUID-22F4D8AA-D028-4B68-A026-A970F1BCE343"></a><h5 id="SPGDG-GUID-22F4D8AA-D028-4B68-A026-A970F1BCE343" class="sect5"><span class="enumeration_section">2.10.3.1</span> Oracle数据库的GET操作（属性图）</h5>
                     <div>
                        <p>本主题描述属性图REST API的GET操作。</p>
                        <div class="infoboxnote" id="GUID-22F4D8AA-D028-4B68-A026-A970F1BCE343__GUID-B81D9BCF-1E1D-4E2B-9D7B-697636C07CBE">
                           <p class="notep1">注意：</p>
                           <p>有关属性图索引的信息，请参阅<a href="using-property-graphs-oracle-database.html#GUID-469E1B26-DE30-4AFA-801E-BA14AB30214B">使用属性图数据的自动索引</a>和<a href="using-property-graphs-oracle-database.html#GUID-C56AB70D-CB45-4208-84D8-6C5DBF67A8FC">使用</a> <a href="using-property-graphs-oracle-database.html#GUID-469E1B26-DE30-4AFA-801E-BA14AB30214B">属性图数据的</a> <a href="using-property-graphs-oracle-database.html#GUID-C56AB70D-CB45-4208-84D8-6C5DBF67A8FC">手动索引</a> ，</p>
                        </div>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="using-property-graphs-oracle-database.html#GUID-22F4D8AA-D028-4B68-A026-A970F1BCE343__GRAPHSGRAPHNAMEINDICES-49465767">/图形/ {graphname} /索引</a></p>
                           </li>
                           <li>
                              <p><a href="using-property-graphs-oracle-database.html#GUID-22F4D8AA-D028-4B68-A026-A970F1BCE343__GRAPHSGRAPHNAMEINDICESINDEXNAMEKEYK-49465F85">/图/ {} graphname /指数/ {} INDEXNAME？键= &lt;键&gt;＆值= &lt;值&gt;</a></p>
                           </li>
                           <li>
                              <p><a href="using-property-graphs-oracle-database.html#GUID-22F4D8AA-D028-4B68-A026-A970F1BCE343__GRAPHSGRAPHNAMEINDICESINDEXNAMECOUN-49466537">/图/ {} graphname /指数/ {} INDEXNAME /算什么？键= &lt;键&gt;＆值= &lt;值&gt;</a></p>
                           </li>
                           <li>
                              <p><a href="using-property-graphs-oracle-database.html#GUID-22F4D8AA-D028-4B68-A026-A970F1BCE343__GRAPHSGRAPHNAMEKEYINDICES-49466D2D">/图形/ {graphname} / keyindices</a></p>
                           </li>
                           <li>
                              <p><a href="using-property-graphs-oracle-database.html#GUID-22F4D8AA-D028-4B68-A026-A970F1BCE343__GRAPHSGRAPHNAMEKEYINDICESCLASS-49467285">/图形/ {graphname} / keyindices / {类}</a></p>
                           </li>
                           <li>
                              <p><a href="using-property-graphs-oracle-database.html#GUID-22F4D8AA-D028-4B68-A026-A970F1BCE343__BACKENDS-494677EC">/后端</a></p>
                           </li>
                           <li>
                              <p><a href="using-property-graphs-oracle-database.html#GUID-22F4D8AA-D028-4B68-A026-A970F1BCE343__BACKENDSDEFAULT-49467F12">/后端/默认</a></p>
                           </li>
                           <li>
                              <p><a href="using-property-graphs-oracle-database.html#GUID-22F4D8AA-D028-4B68-A026-A970F1BCE343__BACKENDSBACKENDNAME-494687F8">/后端/ {backendName}</a></p>
                           </li>
                           <li>
                              <p><a href="using-property-graphs-oracle-database.html#GUID-22F4D8AA-D028-4B68-A026-A970F1BCE343__GRAPHSGRAPHNAME-49468CDE">/图形/ {graphname}</a></p>
                           </li>
                           <li>
                              <p><a href="using-property-graphs-oracle-database.html#GUID-22F4D8AA-D028-4B68-A026-A970F1BCE343__GRAPHSGRAPHNAMEEDGES-494692BC">/图形/ {graphname} /边缘</a></p>
                           </li>
                           <li>
                              <p><a href="using-property-graphs-oracle-database.html#GUID-22F4D8AA-D028-4B68-A026-A970F1BCE343__GRAPHSGRAPHNAMEEDGESID-49469966">/图形/ {graphname} /边缘/ {ID}</a></p>
                           </li>
                           <li>
                              <p><a href="using-property-graphs-oracle-database.html#GUID-22F4D8AA-D028-4B68-A026-A970F1BCE343__GRAPHSGRAPHNAMEVERTICES-49469FA0">/图形/ {graphname} /顶点</a></p>
                           </li>
                           <li>
                              <p><a href="using-property-graphs-oracle-database.html#GUID-22F4D8AA-D028-4B68-A026-A970F1BCE343__GRAPHSGRAPHNAMEVERTICESID-4946A53E">/图形/ {graphname} /顶点/ {ID}</a></p>
                           </li>
                           <li>
                              <p><a href="using-property-graphs-oracle-database.html#GUID-22F4D8AA-D028-4B68-A026-A970F1BCE343__GRAPHSGRAPHNAMEVERTICESIDDIRECTION-4946AAFF">/图形/ {graphName} /顶点/ {ID} / {方向}</a></p>
                           </li>
                           <li>
                              <p><a href="using-property-graphs-oracle-database.html#GUID-22F4D8AA-D028-4B68-A026-A970F1BCE343__GRAPHSGRAPHNAMECONFIG-4946B0C9">/图形/ {graphname} /配置</a></p>
                           </li>
                           <li>
                              <p><a href="using-property-graphs-oracle-database.html#GUID-22F4D8AA-D028-4B68-A026-A970F1BCE343__GRAPHSGRAPHNAMEEXPORTDATA-4946B762">/图形/ {graphname} / exportData</a></p>
                           </li>
                           <li>
                              <p><a href="using-property-graphs-oracle-database.html#GUID-22F4D8AA-D028-4B68-A026-A970F1BCE343__EDGESGRAPHNAMEPROPERTIES-4946BC65">/边缘/ {graphname} /性能</a></p>
                           </li>
                           <li>
                              <p><a href="using-property-graphs-oracle-database.html#GUID-22F4D8AA-D028-4B68-A026-A970F1BCE343__VERTICESGRAPHNAMETEXTQUERY-4946C765">/顶点/ {graphname} / textquery</a></p>
                           </li>
                           <li>
                              <p><a href="using-property-graphs-oracle-database.html#GUID-22F4D8AA-D028-4B68-A026-A970F1BCE343__EDGESGRAPHNAMETEXTQUERY-4946CCAF">/边缘/ {graphname} / textquery</a></p>
                           </li>
                        </ul>
                        <div class="section" id="GUID-22F4D8AA-D028-4B68-A026-A970F1BCE343__GRAPHSGRAPHNAMEINDICES-49465767">
                           <p class="subhead3" id="GUID-22F4D8AA-D028-4B68-A026-A970F1BCE343__GRAPHSGRAPHNAMEINDICES-49465B29">/图形/ {graphname} /索引</p>
                           <p><span class="bold">描述</span> ：获取为指定图形创建的所有手动索引的名称和类。
                           </p>
                           <p><span class="bold">参数</span></p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">graphname</code> ：</p>属性图的名称。
                              </li>
                           </ul>
                           <p><span class="bold">使用说明</span></p>
                           <p>此GET操作执行对<code class="codeph">OraclePropertyGraph.getIndices()</code>方法的调用。
                           </p>
                           <p><span class="bold">例</span></p>
                           <p>以下URL获取名为<code class="codeph">connections</code>的图形的所有手动索引：</p><pre class="oac_no_warn" dir="ltr">HTTP：//本地主机：7001 / opg_unified / DAL /图表/连接/指数</pre><p>结果可能如下所示：</p><pre class="oac_no_warn" dir="ltr">{results：[name：“myIdx”，class：“vertex”]，totalSize：1，queryTime：9.112078}</pre></div>
                        <!-- class="section" -->
                        <div class="section" id="GUID-22F4D8AA-D028-4B68-A026-A970F1BCE343__GRAPHSGRAPHNAMEINDICESINDEXNAMEKEYK-49465F85">
                           <p class="subhead3" id="GUID-22F4D8AA-D028-4B68-A026-A970F1BCE343__GRAPHSGRAPHNAMEINDICESINDEXNAMEKEYK-4946623E">/图/ {} graphname /指数/ {} INDEXNAME？键= &lt;键&gt;＆值= &lt;值&gt;</p>
                           <p><span class="bold">说明</span>获取具有特定键值对的指定索引中的元素。
                           </p>
                           <p><span class="bold">参数</span></p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">graphname</code> ：</p>属性图的名称。
                              </li>
                              <li>
                                 <p><code class="codeph">indexName</code> ：</p>索引的名称。
                              </li>
                              <li>
                                 <p><code class="codeph">&lt;key&gt;</code> ：</p>键值对中的键。
                              </li>
                              <li>
                                 <p><code class="codeph">&lt;value&gt;</code> ：</p>键值对中的值。
                              </li>
                           </ul>
                           <p><span class="bold">使用说明</span></p>
                           <p>如果未指定键值对，则显示有关指定手动索引的信息。如果索引不存在，则返回“无法找到索引”消息。</p>
                           <p>此GET操作执行对<code class="codeph">OracleIndex.get(key,value)</code>方法的调用。
                           </p>
                           <p><span class="bold">例</span></p>
                           <p>以下URL使用键值对<code class="codeph">name-Beyonce</code>获取myIdx索引中的所有顶点：</p><pre class="oac_no_warn" dir="ltr">HTTP：//本地主机：7001 / opg_unified / DAL /图形/连接/索引/ myIdx键=名称＆值=碧昂丝</pre><p>结果可能如下所示：</p><pre class="oac_no_warn" dir="ltr">{“results”：[{“country”：{“type”：“string”，“value”：“United States”}，“music genre”：{“type”：“string”，“value”：“pop”灵魂“}，”角色“：{”type“：”string“，”value“：”歌手女演员“}，”名字“：{”type“：”string“，”value“：”Beyonce“}，” _id“：2，”_ type“：”vertex“}]，”totalSize“：1，”queryTime“：79.910928}</pre></div>
                        <!-- class="section" -->
                        <div class="section" id="GUID-22F4D8AA-D028-4B68-A026-A970F1BCE343__GRAPHSGRAPHNAMEINDICESINDEXNAMECOUN-49466537">
                           <p class="subhead3" id="GUID-22F4D8AA-D028-4B68-A026-A970F1BCE343__GRAPHSGRAPHNAMEINDICESINDEXNAMECOUN-49466799">/图/ {} graphname /指数/ {} INDEXNAME /算什么？键= &lt;键&gt;＆值= &lt;值&gt;</p>
                           <p><span class="bold">描述</span> ：获取具有特定键值对的指定索引中的元素数。
                           </p>
                           <p><span class="bold">参数</span></p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">graphname</code> ：</p>属性图的名称。
                              </li>
                              <li>
                                 <p><code class="codeph">indexName</code> ：</p>索引的名称。
                              </li>
                              <li>
                                 <p><code class="codeph">&lt;key&gt;</code> ：</p>键值对中的键。
                              </li>
                              <li>
                                 <p><code class="codeph">&lt;value&gt;</code> ：</p>键值对中的值。
                              </li>
                           </ul>
                           <p><span class="bold">使用说明</span></p>
                           <p>此GET操作执行对<code class="codeph">OracleIndex.count(key,value)</code>方法的调用。
                           </p>
                           <p><span class="bold">例</span></p>
                           <p>以下URL在<code class="codeph">connections</code>图的<code class="codeph">myIdx</code>索引中获取具有键值对<code class="codeph">name-Beyonce</code>的<code class="codeph">myIdx</code>点数：</p><pre class="oac_no_warn" dir="ltr">HTTP：//本地主机：7001 / opg_unified / DAL /图表/连接/指数/ myIdx /计数键=名称和值=碧昂丝</pre><p>结果可能如下所示：</p><pre class="oac_no_warn" dir="ltr">{totalSize：1，queryTime：20.781228}</pre></div>
                        <!-- class="section" -->
                        <div class="section" id="GUID-22F4D8AA-D028-4B68-A026-A970F1BCE343__GRAPHSGRAPHNAMEKEYINDICES-49466D2D">
                           <p class="subhead3" id="GUID-22F4D8AA-D028-4B68-A026-A970F1BCE343__GRAPHSGRAPHNAMEKEYINDICES-49466EFD">/图形/ {graphname} / keyindices</p>
                           <p><span class="bold">描述</span> ：获取有关指定图形中所有自动文本索引的信息。它提供当前在自动索引中使用的索引键。
                           </p>
                           <p><span class="bold">参数</span></p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">graphname</code> ：</p>属性图的名称。
                              </li>
                           </ul>
                           <p><span class="bold">使用说明</span></p>
                           <p>此GET操作对<code class="codeph">Vertex</code>和<code class="codeph">Edge</code>类执行对<code class="codeph">OraclePropertyGraph.getIndexedKeys(class)</code>方法的调用。
                           </p>
                           <p><span class="bold">例</span></p>
                           <p>以下URL获取有关<code class="codeph">connections</code>图的所有自动索引的信息。
                           </p><pre class="oac_no_warn" dir="ltr">HTTP：//本地主机：7001 / opg_unified / DAL /图形/连接/ keyindices</pre><p>结果可能如下所示：</p><pre class="oac_no_warn" dir="ltr">{keys：{edge：[]，vertex：[“name”]}，queryTime：28.776229}</pre></div>
                        <!-- class="section" -->
                        <div class="section" id="GUID-22F4D8AA-D028-4B68-A026-A970F1BCE343__GRAPHSGRAPHNAMEKEYINDICESCLASS-49467285">
                           <p class="subhead3" id="GUID-22F4D8AA-D028-4B68-A026-A970F1BCE343__GRAPHSGRAPHNAMEKEYINDICESCLASS-49467473">/图形/ {graphname} / keyindices / {类}</p>
                           <p><span class="bold">描述</span> ：获取当前在给定类型的所有元素的自动索引中使用的索引键。
                           </p>
                           <p><span class="bold">参数</span></p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">graphname</code> ：</p>属性图的名称。
                              </li>
                              <li>
                                 <p><code class="codeph">class</code> ：</p>键索引中元素的类类型。
                              </li>
                           </ul>
                           <p><span class="bold">使用说明</span></p>
                           <p>此GET操作执行对<code class="codeph">OraclePropertyGraph.getIndexedKeys(class)</code>方法的调用。
                           </p>
                           <p><span class="bold">例</span></p>
                           <p>以下URL获取<code class="codeph">connections</code>图的所有自动索引：</p><pre class="oac_no_warn" dir="ltr">HTTP：//本地主机：7001 / opg_unified / DAL /图形/连接/ keyindices /顶点/</pre><p>结果可能如下所示：</p><pre class="oac_no_warn" dir="ltr">{results：[“name”]，queryTime：28.776229}</pre></div>
                        <!-- class="section" -->
                        <div class="section" id="GUID-22F4D8AA-D028-4B68-A026-A970F1BCE343__BACKENDS-494677EC">
                           <p class="subhead3" id="GUID-22F4D8AA-D028-4B68-A026-A970F1BCE343__BACKENDS-49467A19">/后端</p>
                           <p><span class="bold">描述</span> ：返回所有可用的后端及其配置信息。
                           </p>
                           <p><span class="bold">参数</span></p>
                           <p>（没有。）</p>
                           <p><span class="bold">使用说明</span></p>
                           <p>（没有。）</p>
                           <p><span class="bold">例</span></p>
                           <p>以下URL获取所有已配置的后端：</p><pre class="oac_no_warn" dir="ltr">HTTP：//本地主机：7001 / opg_unified / DAL /后端/</pre><p>结果可能如下所示：</p><pre class="oac_no_warn" dir="ltr">{backends：[{jdbcUrl：“jdbc：oracle：thin：@ 127.0.0.1：1521：orcl”，backendName：“rdbms_connection”，isDefault：true，user：“scott”，backendType：“OracleRDBMSBackendConnection”}]，queryTime： 0.166505，upTime：“0 [d]：00 [h]：01 [m]：32 [s]”}</pre></div>
                        <!-- class="section" -->
                        <div class="section" id="GUID-22F4D8AA-D028-4B68-A026-A970F1BCE343__BACKENDSDEFAULT-49467F12">
                           <p class="subhead3" id="GUID-22F4D8AA-D028-4B68-A026-A970F1BCE343__BACKENDSDEFAULT-494680D4">/后端/默认</p>
                           <p><span class="bold">描述</span> ：获取图形使用的默认后端。
                           </p>
                           <p><span class="bold">参数</span></p>
                           <p>（没有。）</p>
                           <p><span class="bold">使用说明</span></p>
                           <p>（没有。）</p>
                           <p><span class="bold">例</span></p>
                           <p>以下URL获取默认后端：</p><pre class="oac_no_warn" dir="ltr">HTTP：//本地主机：7001 / opg_unified / DAL /后端/默认/</pre><p>结果可能如下所示：</p><pre class="oac_no_warn" dir="ltr">{defaultBackend：{jdbcUrl：“jdbc：oracle：thin：@ 127.0.0.1：1521：orcl”，backendName：“rdbms_connection”，isDefault：true，user：“scott”，backendType：“OracleRDBMSBackendConnection”}，queryTime：0.171087， upTime：“0 [d]：00 [h]：09 [m]：51 [s]”}</pre></div>
                        <!-- class="section" -->
                        <div class="section" id="GUID-22F4D8AA-D028-4B68-A026-A970F1BCE343__BACKENDSBACKENDNAME-494687F8">
                           <p class="subhead3" id="GUID-22F4D8AA-D028-4B68-A026-A970F1BCE343__BACKENDSBACKENDNAME-49468A70">/后端/ {backendName}</p>
                           <p><span class="bold">描述</span> ：获取有关指定后端的所有配置信息。
                           </p>
                           <p><span class="bold">参数</span></p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">backendName</code> ：</p>后端的名称。
                              </li>
                           </ul>
                           <p><span class="bold">使用说明</span></p>
                           <p>（没有。）</p>
                           <p><span class="bold">例</span></p>
                           <p>以下URL获取<code class="codeph">rdbms_connection</code>后端的配置：</p><pre class="oac_no_warn" dir="ltr">HTTP：//本地主机：7001 / opg_unified / DAL /后端/ rdbms_connection /</pre><p>结果可能如下所示：</p><pre class="oac_no_warn" dir="ltr">{backend：{jdbcUrl：“jdbc：oracle：thin：@ 127.0.0.1：1521：orcl”，backendName：“rdbms_connection”，isDefault：true，user：“scott”，backendType：“OracleRDBMSBackendConnection”}，queryTime：0.171087， upTime：“0 [d]：00 [h]：09 [m]：51 [s]”}</pre></div>
                        <!-- class="section" -->
                        <div class="section" id="GUID-22F4D8AA-D028-4B68-A026-A970F1BCE343__GRAPHSGRAPHNAME-49468CDE">
                           <p class="subhead3" id="GUID-22F4D8AA-D028-4B68-A026-A970F1BCE343__GRAPHSGRAPHNAME-49468F8D">/图形/ {graphname}</p>
                           <p><span class="bold">描述</span> ：获取有关指定图形的类型和支持的功能的信息。
                           </p>
                           <p><span class="bold">参数</span></p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">graphname</code> ：</p>属性图的名称。
                              </li>
                           </ul>
                           <p><span class="bold">使用说明</span></p>
                           <p>（没有。）</p>
                           <p><span class="bold">例</span></p>
                           <p>以下URL获取有关<code class="codeph">connections</code>图的信息：</p><pre class="oac_no_warn" dir="ltr">HTTP：//本地主机：7001 / opg_unified / DAL /图形/连接/</pre><p>结果可能如下所示：</p><pre class="oac_no_warn" dir="ltr">{name：“connections”，graph：“oraclepropertygraph with name connections”，features：{isWrapper：false，supportsVertexProperties：true，supportsMapProperty：true，supportsUniformListProperty：true，supportsIndices：true，ignoresSuppliedIds：false，supportsFloatProperty：true，supportsPrimitiveArrayProperty：true ，supportsEdgeIndex：true，supportsDeyProperty：true，isRDFModel：false，isPersistent：true，supportsVertexIteration：true，supportsEdgeProperties：true，supportsSelfLoops：false，supportsDuplicateEdges：true，supportsSerializableObjectProperty：true，supportsEdgeIteration：true，supportsVertexIndex：true，supportsIntegerProperty ：true，supportsBixedProperty：true，supportsMixedListProperty：true，supportsEdgeRetrieval：true，supportsTransactions：true，supportsThreadedTransactions：true，supportsStringProperty：true，supportsVertexKeyIndex：true，supportsRdgeKeyIndex：true，supportsLongProperty：true}，readOnly：false，type：“oracle.pg .rdbms。OraclePropertyGraph“，queryTime：1010.203456，upTime：”0 [d]：19 [h]：28 [m]：37 [s]“}</pre></div>
                        <!-- class="section" -->
                        <div class="section" id="GUID-22F4D8AA-D028-4B68-A026-A970F1BCE343__GRAPHSGRAPHNAMEEDGES-494692BC">
                           <p class="subhead3" id="GUID-22F4D8AA-D028-4B68-A026-A970F1BCE343__GRAPHSGRAPHNAMEEDGES-49469473">/图形/ {graphname} /边缘</p>
                           <p><span class="bold">描述</span> ：获取有关指定图形边缘的信息。
                           </p>
                           <p><span class="bold">参数</span></p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">graphname</code> ：</p>属性图的名称。
                              </li>
                              <li>
                                 <p><code class="codeph">opg.showTypes</code> （查询参数）：</p>布尔值，指定每个键值对的数据类型是否应包含在响应中。
                              </li>
                              <li>
                                 <p><code class="codeph">opg.offset.start</code> （查询参数）：</p>整数，表示处理请求时要跳过的边数。</li>
                              <li>
                                 <p><code class="codeph">opg.offset.limit</code> （查询参数）：</p>要从图形中检索的最大边数。
                              </li>
                              <li>
                                 <p><code class="codeph">opg.ids=[&lt;id1&gt;, &lt;id2&gt;, &lt;id3&gt;, ...]</code> （查询参数）：</p>从中选择结果的边ID的列表。
                              </li>
                           </ul>
                           <p><span class="bold">使用说明</span></p>
                           <p>（没有。）</p>
                           <p><span class="bold">例</span></p>
                           <p>以下GET请求获取有关<code class="codeph">connections</code>图的所有边的信息：</p><pre class="oac_no_warn" dir="ltr">HTTP：//本地主机：7001 / opg_unified / DAL /图形/连接/边缘</pre><p>结果可能如下所示：</p><pre class="oac_no_warn" dir="ltr">{结果：[{weight：1，_id：1001，_type：“edge”，_ outV：1，_inV：3，_ label：“collaborates”}，{weight：1，_id：1002，_type：“edge”，_ outV ：1，_inV：4，_label：“admires”}，...]，totalSize：164，queryTime：49.491961}</pre><p>以下GET请求修改前一个请求，仅请求<code class="codeph">connections</code>图中ID值为1001和1002的边：</p><pre class="oac_no_warn" dir="ltr">HTTP：//本地主机：7001 / opg_unified / DAL /图形/连接/边缘opg.ids = [1001,1002]</pre><p>结果可能如下所示：</p><pre class="oac_no_warn" dir="ltr">{结果：[{weight：1，_id：1001，_type：“edge”，_ outV：1，_inV：3，_ label：“collaborates”}，{weight：1，_id：1002，_type：“edge”，_ outV ：1，_inV：4，_label：“admires”}]，totalSize：2，queryTime：49.491961}</pre><p>跳过<code class="codeph">connections</code>图的前五个边后，以下GET请求获取一条边：</p><pre class="oac_no_warn" dir="ltr">HTTP：//本地主机：7001 / opg_unified / DAL /图形/连接/边缘opg.offset.start = 5＆opg.offset.limit = 1</pre><p>结果可能如下所示：</p><pre class="oac_no_warn" dir="ltr">{results：[{weight：1，_id：1005，_ type：“edge”，_ outV：1，_inV：7，_label：“collaborates”}]，totalSize：1，queryTime：49.491961}</pre></div>
                        <!-- class="section" -->
                        <div class="section" id="GUID-22F4D8AA-D028-4B68-A026-A970F1BCE343__GRAPHSGRAPHNAMEEDGESID-49469966">
                           <p class="subhead3" id="GUID-22F4D8AA-D028-4B68-A026-A970F1BCE343__GRAPHSGRAPHNAMEEDGESID-49469B22">/图形/ {graphname} /边缘/ {ID}</p>
                           <p><span class="bold">描述</span> ：从图中获取有关具有指定ID的边的信息。
                           </p>
                           <p><span class="bold">参数</span></p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">graphname</code> ：</p>属性图的名称。
                              </li>
                              <li>
                                 <p><code class="codeph">id</code> ：</p>要读取的边的边ID。
                              </li>
                              <li>
                                 <p><code class="codeph">opg.showTypes</code> （查询参数）：</p>布尔值，指定每个键值对的数据类型是否应包含在响应中。
                              </li>
                           </ul>
                           <p><span class="bold">使用说明</span></p>
                           <p>（没有。）</p>
                           <p><span class="bold">例</span></p>
                           <p>以下GET请求获取有关<code class="codeph">connections</code>图的边ID 100的信息：</p><pre class="oac_no_warn" dir="ltr">HTTP：//本地主机：7001 / opg_unified / DAL /图形/连接/边缘/ 1001</pre><p>结果可能如下所示：</p><pre class="oac_no_warn" dir="ltr">{results：{weight：{type：“double”，value：1}，_ id：1001，_ type：“edge”，_ outV：1，_inV：3，_label：“collaborates”}，queryTime：43.720456}</pre><p>以下GET请求显示边缘1的失败请求的输出，该请求在<code class="codeph">connections</code>图中不存在。
                           </p><pre class="oac_no_warn" dir="ltr">HTTP：//本地主机：7001 / opg_unified / DAL /图形/连接/边缘/ 1</pre><p>结果可能如下所示：</p><pre class="oac_no_warn" dir="ltr">{message：“无法找到名称为[1]的边缘。” }</pre><p>跳过<code class="codeph">connections</code>图的前五个边后，以下GET请求获取一条边：</p><pre class="oac_no_warn" dir="ltr">HTTP：//本地主机：7001 / opg_unified / DAL /图形/连接/边缘opg.offset.start = 5＆opg.offset.limit = 1</pre><p>结果可能如下所示：</p><pre class="oac_no_warn" dir="ltr">{results：[{weight：1，_id：1005，_ type：“edge”，_ outV：1，_inV：7，_label：“collaborates”}]，totalSize：1，queryTime：49.491961}</pre></div>
                        <!-- class="section" -->
                        <div class="section" id="GUID-22F4D8AA-D028-4B68-A026-A970F1BCE343__GRAPHSGRAPHNAMEVERTICES-49469FA0">
                           <p class="subhead3" id="GUID-22F4D8AA-D028-4B68-A026-A970F1BCE343__GRAPHSGRAPHNAMEVERTICES-4946A148">/图形/ {graphname} /顶点</p>
                           <p><span class="bold">描述</span> ：获取有关指定图形顶点的信息。
                           </p>
                           <p><span class="bold">参数</span></p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">graphname</code> ：</p>属性图的名称。
                              </li>
                              <li>
                                 <p><code class="codeph">opg.showTypes</code> （查询参数）：</p>布尔值，指定每个键值对的数据类型是否应包含在响应中。
                              </li>
                              <li>
                                 <p><code class="codeph">opg.offset.start</code> （查询参数）：</p>整数，表示处理请求时要跳过的顶点数。</li>
                              <li>
                                 <p><code class="codeph">opg.offset.limit</code> （查询参数）：</p>从图中检索的最大顶点数。
                              </li>
                              <li>
                                 <p><code class="codeph">opg.ids=[&lt;id1&gt;, &lt;id2&gt;, &lt;id3&gt;, ...]</code> （查询参数）：</p>从中选择结果的顶点ID列表。
                              </li>
                           </ul>
                           <p><span class="bold">使用说明</span></p>
                           <p>（没有。）</p>
                           <p><span class="bold">例</span></p>
                           <p>以下GET请求获取有关<code class="codeph">connections</code>图的所有顶点的信息：</p><pre class="oac_no_warn" dir="ltr">HTTP：//本地主机：7001 / opg_unified / DAL /图表/连接/顶点</pre><p>结果可能如下所示：</p><pre class="oac_no_warn" dir="ltr">{结果：[{国家：“葡萄牙”，职业：“职业足球运动员”，姓名：“克里斯蒂亚诺罗纳尔多”，_id：63，_type：“vertex”}，{国家：“朝鲜”，职业：“最高领导人朝鲜“，角色：”政治权威“，名称：”金正恩“，政党：”朝鲜劳动党“，宗教：”无神论“，_id：32，_type：”vertex“}，...]， totalSize：78，queryTime：22.345108}</pre><p>以下GET请求修改前一个请求，仅请求<code class="codeph">connections</code>图中ID值为4和63的顶点：</p><pre class="oac_no_warn" dir="ltr">HTTP：//本地主机：7001 / opg_unified / DAL /图形/连接/顶点opg.ids = [4,63]</pre><p>结果可能如下所示：</p><pre class="oac_no_warn" dir="ltr">{结果：[{国家：“美国”，角色：“美国经济学家”，姓名：“Janet Yellen”，政党：“民主党”，_id：4，_type：“vertex”}，{country：“Portugal” ，职业：“职业足球运动员”，姓名：“Cristiano Ronaldo”，_ id：63，_type：“vertex”}，]，totalSize：2，queryTime：22.345108}</pre><p>以下GET请求在跳过<code class="codeph">connections</code>图的前五个顶点后获取一个顶点：</p><pre class="oac_no_warn" dir="ltr">HTTP：//本地主机：7001 / opg_unified / DAL /图表/连接/顶点opg.offset.start = 5＆opg.offset.limit = 1</pre><p>结果可能如下所示：</p><pre class="oac_no_warn" dir="ltr">{结果：[{country：“United States”，职业：“创始人”，角色：“philantropist”，姓名：“Tom Steyer”，公司：“Farallon Capital Management”，政党：“民主党”，_id：20， _type：“vertex”}]，totalSize：1，queryTime：65.366488}</pre></div>
                        <!-- class="section" -->
                        <div class="section" id="GUID-22F4D8AA-D028-4B68-A026-A970F1BCE343__GRAPHSGRAPHNAMEVERTICESID-4946A53E">
                           <p class="subhead3" id="GUID-22F4D8AA-D028-4B68-A026-A970F1BCE343__GRAPHSGRAPHNAMEVERTICESID-4946A763">/图形/ {graphname} /顶点/ {ID}</p>
                           <p><span class="bold">描述</span> ：从图中获取有关具有指定ID的顶点的信息。
                           </p>
                           <p><span class="bold">参数</span></p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">graphname</code> ：</p>属性图的名称。
                              </li>
                              <li>
                                 <p><code class="codeph">id</code> ：</p>要读取的顶点的顶点ID。
                              </li>
                              <li>
                                 <p><code class="codeph">opg.showTypes</code> （查询参数）：</p>布尔值，指定每个键值对的数据类型是否应包含在响应中。
                              </li>
                           </ul>
                           <p><span class="bold">使用说明</span></p>
                           <p>（没有。）</p>
                           <p><span class="bold">例</span></p>
                           <p>以下GET请求获取有关<code class="codeph">connections</code>图的顶点ID 1的信息：</p><pre class="oac_no_warn" dir="ltr">HTTP：//本地主机：7001 / opg_unified / DAL /图形/连接/顶点/ 1</pre><p>结果可能如下所示：</p><pre class="oac_no_warn" dir="ltr">{结果：{国家：“美国”，职业：“美利坚合众国第44任总统”，角色：“政治权威”，名称：“巴拉克奥巴马”，政党：“民主党”，宗教：“基督教”， _id：1，_type：“vertex”}，queryTime：13.95932}</pre><p>以下GET请求修改了前一个请求，以包含顶点1的所有属性的数据类型。</p><pre class="oac_no_warn" dir="ltr">HTTP：//本地主机：7001 / opg_unified / DAL /图形/连接/顶点/ 1 opg.showTypes =真</pre><p>结果可能如下所示：</p><pre class="oac_no_warn" dir="ltr">{results：{country：{type：“string”，value：“United States”}，职业：{type：“string”，value：“美国第44任总统”}，角色：{type：“string “，价值：”政治权威“}，姓名：{type：”string“，价值：”Barack Obama“}，政党：{type：”string“，value：”Democratic“}，宗教：{type：” string“，value：”Christianity“}，_ id：1，_type：”vertex“}，queryTime：13.147989}</pre><p>以下GET请求显示顶点1000的失败请求的输出，该请求在<code class="codeph">connections</code>图中不存在。
                           </p><pre class="oac_no_warn" dir="ltr">HTTP：//本地主机：7001 / opg_unified / DAL /图形/连接/顶点/ 1000</pre><p>结果可能如下所示：</p><pre class="oac_no_warn" dir="ltr">{message：“无法找到名称为[1000]的顶点。” }</pre></div>
                        <!-- class="section" -->
                        <div class="section" id="GUID-22F4D8AA-D028-4B68-A026-A970F1BCE343__GRAPHSGRAPHNAMEVERTICESIDDIRECTION-4946AAFF">
                           <p class="subhead3" id="GUID-22F4D8AA-D028-4B68-A026-A970F1BCE343__GRAPHSGRAPHNAMEVERTICESIDDIRECTION-4946AD3F">/图形/ {graphName} /顶点/ {ID} / {方向}</p>
                           <p><span class="bold">描述</span> ：获取具有指定ID值的顶点的{in，out，both} -adjacent顶点。
                           </p>
                           <p><span class="bold">参数</span></p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">direction</code> ：</p>可<code class="codeph">in</code>对-顶点， <code class="codeph">out</code>了外顶点，或<code class="codeph">both</code>在-顶点和出顶点。
                              </li>
                           </ul>
                           <p><span class="bold">使用说明</span></p>
                           <p>（没有。）</p>
                           <p><span class="bold">例</span></p>
                           <p>以下URL获取id为5的顶点的顶点：</p><pre class="oac_no_warn" dir="ltr">HTTP：//本地主机：7001 / opg_unified / DAL /图形/连接/顶点/ 5 /输出/</pre><p>结果可能如下所示：</p><pre class="oac_no_warn" dir="ltr">{结果：[{姓名：“Omar Kobine Layama”，_id：56，_type：“vertex”}，{name：“Dieudonne Nzapalainga”，_ id：57，_type：“vertex”}，{name：“Nicolas Guerekoyame Gbangou “，_id：58，_type：”vertex“}，{country：”Rome“，name：”The Vatican“，type：”state“，religion：”Catholicism“，_id：59，_type：”vertex“}] ，totalSize：4，queryTime：56.044806}</pre></div>
                        <!-- class="section" -->
                        <div class="section" id="GUID-22F4D8AA-D028-4B68-A026-A970F1BCE343__GRAPHSGRAPHNAMECONFIG-4946B0C9">
                           <p class="subhead3" id="GUID-22F4D8AA-D028-4B68-A026-A970F1BCE343__GRAPHSGRAPHNAMECONFIG-4946B3BD">/图形/ {graphname} /配置</p>
                           <p><span class="bold">描述</span> ：获取指定图形配置的表示形式（采用JSON格式）。
                           </p>
                           <p><span class="bold">参数</span></p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">graphname</code> ：</p>属性图的名称。
                              </li>
                           </ul>
                           <p><span class="bold">使用说明</span></p>
                           <p>（没有。）</p>
                           <p><span class="bold">例</span></p>
                           <p>以下URL获取<code class="codeph">connections</code>图的图形配置：</p><pre class="oac_no_warn" dir="ltr">HTTP：//本地主机：7001 / opg_unified /图形/连接/配置</pre><p>结果可能如下所示：</p><pre class="oac_no_warn" dir="ltr">{edge_props：[{name：“weight”，type：“string”}]，db_engine：“RDBMS”，vertex_props：[{name：“name”，type：“string”}，{name：“role”，type ：“string”}，... {name：“country”，type：“string”}]，格式：“pg”，名称：“connections”，属性：{}，max_num_connections：2，error_handling：{}，loading： {load_edge_label：true}，edge_label：true，data_source_id：null}</pre></div>
                        <!-- class="section" -->
                        <div class="section" id="GUID-22F4D8AA-D028-4B68-A026-A970F1BCE343__GRAPHSGRAPHNAMEEXPORTDATA-4946B762">
                           <p class="subhead3" id="GUID-22F4D8AA-D028-4B68-A026-A970F1BCE343__GRAPHSGRAPHNAMEEXPORTDATA-4946B8E8">/图形/ {graphname} / exportData</p>
                           <p><span class="bold">说明</span> ：下载包含Oracle Property Graph Flat File格式（ <code class="codeph">.opv</code>和<code class="codeph">.ope</code>文件）图形的.zip文件。
                           </p>
                           <p><span class="bold">参数</span></p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">graphname</code> ：</p>属性图的名称。
                              </li>
                              <li>
                                 <p><code class="codeph">dop</code> （查询参数）</p>操作的程度或并行度。
                              </li>
                           </ul>
                           <p><span class="bold">使用说明</span></p>
                           <p>（没有。）</p>
                           <p><span class="bold">例</span></p>
                           <p>以下URL使用最多4个并行执行线程导出<code class="codeph">connections</code>图：</p><pre class="oac_no_warn" dir="ltr">HTTP：//本地主机：7001 / opg_unified /图形/连接/ exportData DOP = 4</pre><p>它下载一个包含OPV（顶点）文件和OPE（边缘）文件的zip文件，其内容类似于以下内容。</p>
                           <p>OPV文件：</p><pre class="oac_no_warn" dir="ltr">1，姓名，1，Barack％20Obama ,, 1，角色，1，政治％20权威，1，职业，1,44th％20President％20of％20United％20States％20of％20America ,, 1，country，1，United ％20States ,, ...</pre><p>OPE文件：</p><pre class="oac_no_warn" dir="ltr">1000,1,2，合作，重量，3,1.0,1001,1,3，合作，重量，3,1.0,1002,1,4，钦佩，重量，3,1.0,1003,1,5 ，欣赏，重量，3，1.0，...</pre></div>
                        <!-- class="section" -->
                        <div class="section" id="GUID-22F4D8AA-D028-4B68-A026-A970F1BCE343__EDGESGRAPHNAMEPROPERTIES-4946BC65">
                           <p class="subhead3" id="GUID-22F4D8AA-D028-4B68-A026-A970F1BCE343__EDGESGRAPHNAMEPROPERTIES-4946BECA">/边缘/ {graphname} /性能</p>
                           <p><span class="bold">描述</span> ：获取指定图形的边使用的属性键集。
                           </p>
                           <p><span class="bold">参数</span></p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">graphname</code> ：</p>属性图的名称。
                              </li>
                           </ul>
                           <p><span class="bold">使用说明</span></p>
                           <p>（没有。）</p>
                           <p><span class="bold">例</span></p>
                           <p>以下URL获取<code class="codeph">connections</code>图的边属性键：</p><pre class="oac_no_warn" dir="ltr">HTTP：//本地主机：7001 / opg_unified /边缘/连接/属性</pre><p>结果可能如下所示：</p><pre class="oac_no_warn" dir="ltr">{完成：1，结果：[“weight”]，totalSize：1，queryTime：360.491961}</pre></div>
                        <!-- class="section" -->
                        <div class="section" id="GUID-22F4D8AA-D028-4B68-A026-A970F1BCE343__VERTICESGRAPHNAMETEXTQUERY-4946C765">
                           <p class="subhead3" id="GUID-22F4D8AA-D028-4B68-A026-A970F1BCE343__VERTICESGRAPHNAMETEXTQUERY-4946C352">/顶点/ {graphname} / textquery</p>
                           <p><span class="bold">说明</span>获取与某些键值对标准匹配的图形顶点。对现有索引执行全文搜索。
                           </p>
                           <p><span class="bold">参数</span></p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">graphname</code> ：</p>属性图的名称。
                              </li>
                              <li>
                                 <p><code class="codeph">key</code> （查询参数）</p>匹配顶点必须具有的属性键。
                              </li>
                              <li>
                                 <p><code class="codeph">value</code> （查询参数）</p>匹配顶点必须具有的属性值。
                              </li>
                              <li>
                                 <p><code class="codeph">useWildCards</code> （查询参数）</p>布尔字符串，指定是执行完全匹配搜索（ <code class="codeph">false</code> ）还是使用通配符（ <code class="codeph">true</code> ）。
                              </li>
                           </ul>
                           <p><span class="bold">使用说明</span></p>
                           <p>返回的结果不仅取决于参数的值，还取决于它们的存在。</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>如果未指定查询参数，则其行为与<span class="italic">/ graphs / {graphname} / vertices完全相同</span> 。如果仅指定了<code class="codeph">key</code>查询参数，则只返回具有该属性键的边，而不管其值如何。
                                 </p>
                              </li>
                              <li>
                                 <p>如果指定了<code class="codeph">key</code>和<code class="codeph">value</code>查询参数，但<code class="codeph">useWildCards</code>查询参数<span class="bold">不</span>等于<code class="codeph">true</code> ，则它仅返回与该键值对完全匹配的顶点，即使该值包含通配符（*）。
                                 </p>
                              </li>
                              <li>
                                 <p>如果指定了<code class="codeph">key</code>和<code class="codeph">value</code>查询参数且<code class="codeph">useWildCards</code>查询参数为<code class="codeph">true</code> ，则它使用索引执行文本搜索并返回匹配的顶点。
                                 </p>
                              </li>
                           </ul>
                           <p>如果请求通配符搜索并且指定键的请求索引不存在，则返回错误。</p>
                           <p><span class="bold">例</span></p>
                           <p>以下URL获取具有名称键的顶点，其<code class="codeph">value</code>以<code class="codeph">connections</code>图中的字符串<span class="italic">Po</span>开头。
                           </p><pre class="oac_no_warn" dir="ltr">HTTP：//本地主机：7001 / opg_unified /顶点/连接/ textquery键=名称和值=宝* useWildCards =真</pre><p>返回的JSON可能如下所示：</p><pre class="oac_no_warn" dir="ltr">{结果：[{国家：“意大利”，职业：“教皇”，角色：“天主教宗教权威”，姓名：“教皇弗朗西斯”，宗教：“天主教”，_id：5，_type：“vertex”}，{国家：“中国”，职业：“商人”，姓名：“小马”，_id：71，_type：“vertex”}]，totalSize：2，queryTime：49.491961}</pre></div>
                        <!-- class="section" -->
                        <div class="section" id="GUID-22F4D8AA-D028-4B68-A026-A970F1BCE343__EDGESGRAPHNAMETEXTQUERY-4946CCAF">
                           <p class="subhead3" id="GUID-22F4D8AA-D028-4B68-A026-A970F1BCE343__EDGESGRAPHNAMETEXTQUERY-4946CEA3">/边缘/ {graphname} / textquery</p>
                           <p><span class="bold">描述</span> ：获取与某些键值对标准匹配的图形边缘。对现有索引执行全文搜索。
                           </p>
                           <p><span class="bold">参数</span></p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">graphname</code> ：</p>属性图的名称。
                              </li>
                              <li>
                                 <p><code class="codeph">key</code> （查询参数）</p>匹配边必须具有的属性键。
                              </li>
                              <li>
                                 <p><code class="codeph">value</code> （查询参数）</p>匹配边必须具有的值。
                              </li>
                              <li>
                                 <p><code class="codeph">useWildCards</code> （查询参数）</p>布尔字符串，指定是执行完全匹配搜索（false <code class="codeph">false</code> ）还是使用通配符（ <code class="codeph">true</code> ）。
                              </li>
                           </ul>
                           <p><span class="bold">使用说明</span></p>
                           <p>返回的结果不仅取决于参数的值，还取决于它们的存在。</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>如果未指定查询参数，则其行为与<span class="italic">/ graphs / {graphname} / edges完全相同</span> 。如果仅指定了<code class="codeph">key</code>查询参数，则只返回具有该属性键的边，而不管其值如何。
                                 </p>
                              </li>
                              <li>
                                 <p>如果指定了<code class="codeph">key</code>和<code class="codeph">value</code>查询参数，但<code class="codeph">useWildCards</code>查询参数<span class="bold">不</span>等于<code class="codeph">true</code> ，则返回与该键值对完全匹配的边，即使该值包含通配符（*）。
                                 </p>
                              </li>
                              <li>
                                 <p>如果指定了<code class="codeph">key</code>和<code class="codeph">value</code>查询参数并且<code class="codeph">useWildCards</code>查询参数等于<code class="codeph">true</code> ，则它使用索引执行文本搜索并返回匹配的边。
                                 </p>
                              </li>
                           </ul>
                           <p><span class="bold">例</span></p>
                           <p>以下URL获取具有<code class="codeph">type</code>键的边，其值以<code class="codeph">connections</code>图中的字符串<span class="italic">frien</span>开头。
                           </p><pre class="oac_no_warn" dir="ltr">HTTP：//本地主机：7001 / opg_unified /边缘/连接/ textquery键=类型＆值= frien * useWildCards =真</pre><p>返回的JSON可能如下所示：</p><pre class="oac_no_warn" dir="ltr">{results：[{weight：1，type：“friends”，_ id：10000，_type：“edge”，_ outV：1，_inV：3，_label：“collaborates”}]，totalSize：1，queryTime：49.491961}</pre></div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="using-property-graphs-oracle-database.html#GUID-BB6CBF64-8B59-4356-B45B-3D9CBEBCA2C6">Oracle数据库的属性图REST API操作信息</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
                  <div class="props_rev_3"><a id="GUID-BCF729EE-0742-41A0-8BBE-B629EF7D4FF8" name="GUID-BCF729EE-0742-41A0-8BBE-B629EF7D4FF8"></a><h5 id="SPGDG-GUID-BCF729EE-0742-41A0-8BBE-B629EF7D4FF8" class="sect5"><span class="enumeration_section">2.10.3.2</span> Oracle数据库的POST操作（属性图）</h5>
                     <div>
                        <p>本主题描述属性图REST API的POST操作。</p>
                        <div class="infoboxnote" id="GUID-BCF729EE-0742-41A0-8BBE-B629EF7D4FF8__GUID-B81D9BCF-1E1D-4E2B-9D7B-697636C07CBE">
                           <p class="notep1">注意：</p>
                           <p>有关属性图索引的信息，请参阅<a href="using-property-graphs-oracle-database.html#GUID-469E1B26-DE30-4AFA-801E-BA14AB30214B">使用属性图数据的自动索引</a>和<a href="using-property-graphs-oracle-database.html#GUID-C56AB70D-CB45-4208-84D8-6C5DBF67A8FC">使用</a> <a href="using-property-graphs-oracle-database.html#GUID-469E1B26-DE30-4AFA-801E-BA14AB30214B">属性图数据的</a> <a href="using-property-graphs-oracle-database.html#GUID-C56AB70D-CB45-4208-84D8-6C5DBF67A8FC">手动索引</a> ，</p>
                        </div>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="using-property-graphs-oracle-database.html#GUID-BCF729EE-0742-41A0-8BBE-B629EF7D4FF8__GRAPHSGRAPHNAMEINDICESINDEXNAMECLAS-494EF7B2">/图/ {} graphname /指数/ {} INDEXNAME？类= &lt;类&gt;</a></p>
                           </li>
                           <li>
                              <p><a href="using-property-graphs-oracle-database.html#GUID-BCF729EE-0742-41A0-8BBE-B629EF7D4FF8__GRAPHSGRAPHNAMEKEYINDICESCLASSKEYNA-494F25AB">/图形/ {graphname} / keyindices / {类} / {的keyName}</a></p>
                           </li>
                           <li>
                              <p><a href="using-property-graphs-oracle-database.html#GUID-BCF729EE-0742-41A0-8BBE-B629EF7D4FF8__GRAPHSCONNECTIONSEDGES-494F2CB7">/图形/连接/边缘</a></p>
                           </li>
                           <li>
                              <p><a href="using-property-graphs-oracle-database.html#GUID-BCF729EE-0742-41A0-8BBE-B629EF7D4FF8__CSVEDGES-494F385E">/ CSV /边缘</a></p>
                           </li>
                           <li>
                              <p><a href="using-property-graphs-oracle-database.html#GUID-BCF729EE-0742-41A0-8BBE-B629EF7D4FF8__CSVVERTICES-494F3F15">/ CSV /顶点</a></p>
                           </li>
                           <li>
                              <p><a href="using-property-graphs-oracle-database.html#GUID-BCF729EE-0742-41A0-8BBE-B629EF7D4FF8__GRAPHSGRAPHNAMELOADDATA-494F4625">/图形/ {graphname} / loadData</a></p>
                           </li>
                           <li>
                              <p><a href="using-property-graphs-oracle-database.html#GUID-BCF729EE-0742-41A0-8BBE-B629EF7D4FF8__BACKENDSNEWBACKENDNAME-494F4F2D">/后端/ {newBackendName}</a></p>
                           </li>
                           <li>
                              <p><a href="using-property-graphs-oracle-database.html#GUID-BCF729EE-0742-41A0-8BBE-B629EF7D4FF8__EDGESGRAPHNAMEIDS-494F551B">/边缘/ {graphName} / IDS</a></p>
                           </li>
                           <li>
                              <p><a href="using-property-graphs-oracle-database.html#GUID-BCF729EE-0742-41A0-8BBE-B629EF7D4FF8__EDGESGRAPHNAMEPROPERTIES-494F5B2A">/边缘/ {graphName} /性能</a></p>
                           </li>
                        </ul>
                        <div class="section" id="GUID-BCF729EE-0742-41A0-8BBE-B629EF7D4FF8__GRAPHSGRAPHNAMEINDICESINDEXNAMECLAS-494EF7B2">
                           <p class="subhead3" id="GUID-BCF729EE-0742-41A0-8BBE-B629EF7D4FF8__GRAPHSGRAPHNAMEINDICESINDEXNAMECLAS-494EFA35">/图/ {} graphname /指数/ {} INDEXNAME？类= &lt;类&gt;</p>
                           <p><span class="bold">描述</span> ：为指定的图形创建指定的手动索引。
                           </p>
                           <p><span class="bold">参数</span></p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">graphname</code> ：</p>属性图的名称。
                              </li>
                              <li>
                                 <p><code class="codeph">indexName</code> ：</p>要创建的手动索引的名称。
                              </li>
                              <li>
                                 <p><code class="codeph">class</code> ：</p>索引类。它可以是<code class="codeph">vertex</code>或<code class="codeph">edge</code> 。
                              </li>
                           </ul>
                           <p><span class="bold">使用说明</span></p>
                           <p>此POST操作执行对<code class="codeph">OraclePropertyGraph.createIndex(name,class)</code>方法的调用。
                           </p>
                           <p><span class="bold">例</span></p>
                           <p>以下POST操作在<code class="codeph">connections</code>属性图中创建类<code class="codeph">vertex</code>的<code class="codeph">myIdx</code>索引。
                           </p><pre class="oac_no_warn" dir="ltr">http：// localhost：7001 / opg_unified / dal / graphs / connections / indices / myIdx？类=顶点</pre><p>结果可能如下所示：</p><pre class="oac_no_warn" dir="ltr">{“queryTime”：551.798547，“results”：{“name”：“myIdx”，“class”：“vertex”}}</pre></div>
                        <!-- class="section" -->
                        <div class="section" id="GUID-BCF729EE-0742-41A0-8BBE-B629EF7D4FF8__GRAPHSGRAPHNAMEKEYINDICESCLASSKEYNA-494F25AB">
                           <p class="subhead3" id="GUID-BCF729EE-0742-41A0-8BBE-B629EF7D4FF8__GRAPHSGRAPHNAMEKEYINDICESCLASSKEYNA-494F2877">/图形/ {graphname} / keyindices / {类} / {的keyName}</p>
                           <p><span class="bold">描述</span> ：在指定的图形中创建自动键索引。
                           </p>
                           <p><span class="bold">参数</span></p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">graphname</code> ：</p>属性图的名称。
                              </li>
                              <li>
                                 <p><code class="codeph">class</code> ：</p>索引类。它可以是<code class="codeph">vertex</code>或<code class="codeph">edge</code> 。
                              </li>
                              <li>
                                 <p><code class="codeph">keyName</code> ：</p>密钥索引的名称。
                              </li>
                           </ul>
                           <p><span class="bold">使用说明</span></p>
                           <p>此POST操作执行对<code class="codeph">OraclePropertyGraph.createKeyIndex(key,class)</code>方法的调用。
                           </p>
                           <p><span class="bold">例</span></p>
                           <p>以下POST操作在<code class="codeph">connections</code>属性图中创建类<code class="codeph">vertex</code>的<code class="codeph">myVKeyIdx</code>自动索引。
                           </p><pre class="oac_no_warn" dir="ltr">http：// localhost：7001 / opg_unified / dal / graphs / connections / keyindices / vertex / myVKeyIdx</pre><p>结果可能如下所示：</p><pre class="oac_no_warn" dir="ltr">{“queryTime”：234.970874}</pre></div>
                        <!-- class="section" -->
                        <div class="section" id="GUID-BCF729EE-0742-41A0-8BBE-B629EF7D4FF8__GRAPHSCONNECTIONSEDGES-494F2CB7">
                           <p class="subhead3" id="GUID-BCF729EE-0742-41A0-8BBE-B629EF7D4FF8__GRAPHSCONNECTIONSEDGES-494F2F45">/图形/连接/边缘</p><pre class="oac_no_warn" dir="ltr">...边缘？_outV = &lt;id&gt;＆_ label = value＆_inV = &lt;id&gt; ... edges / &lt;edgeId&gt;？_outV = &lt;id&gt;＆_ label = value＆_inV = &lt;id&gt; ... edges / &lt;edgeId&gt;？&lt;键&gt; =值</pre><p><span class="bold">描述</span> ：在两个顶点之间创建一条新边。
                           </p>
                           <p><span class="bold">参数</span></p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">_outV</code> ：</p>传出的顶点。
                              </li>
                              <li>
                                 <p><code class="codeph">_inV</code> ：</p>传入的顶点。
                              </li>
                              <li>
                                 <p><code class="codeph">_label</code> ：</p>边缘的传出标签。
                              </li>
                              <li>
                                 <p><code class="codeph">edgeID</code> ：</p>要创建的边的ID。
                              </li>
                              <li>
                                 <p><code class="codeph">key</code> ：</p>创造的关键价值。
                              </li>
                           </ul>
                           <p><span class="bold">使用说明</span></p>
                           <p>（没有。）</p>
                           <p><span class="bold">例</span></p>
                           <p>以下POST操作使用从顶点29到顶点26的标签<code class="codeph">friend</code>创建边。
                           </p><pre class="oac_no_warn" dir="ltr">HTTP：//本地主机：8080 /图形/连接/ edges_outV = 29＆_label =朋友＆_inV = 26</pre><p>结果可能如下所示：</p><pre class="oac_no_warn" dir="ltr">{“results”：{“_ id”：1810534020425227300，“_ type”：“edge”，“_ outV”：29，“_ inV”：26，“_ label”：“friend”}，“queryTime”：36.635908}</pre></div>
                        <!-- class="section" -->
                        <div class="section" id="GUID-BCF729EE-0742-41A0-8BBE-B629EF7D4FF8__CSVEDGES-494F385E">
                           <p class="subhead3" id="GUID-BCF729EE-0742-41A0-8BBE-B629EF7D4FF8__CSVEDGES-494F360D">/ CSV /边缘</p>
                           <p><span class="bold">说明</span> ：将边缘文件从CSV格式转换为OPE格式。
                           </p>
                           <p><span class="bold">参数</span></p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">fileName</code> ：</p>边缘文件的名称（CSV格式）。
                              </li>
                              <li>
                                 <p><code class="codeph">cboxEdgeIDColName</code> ：</p>应该用作边ID的密钥。</li>
                              <li>
                                 <p><code class="codeph">cboxEdgeSVIDColName</code> ：</p>应该用作起始顶点ID的键。</li>
                              <li>
                                 <p><code class="codeph">cboxEdgeLabelColName</code> ：</p>应该用作边缘标签的键。
                              </li>
                              <li>
                                 <p><code class="codeph">cboxEdgeDVIDColName</code> ：</p>应该用作端点顶点ID的键。</li>
                           </ul>
                           <p><span class="bold">使用说明</span></p>
                           <p>有关文件格式的信息，请参阅<a href="using-property-graphs-oracle-database.html#GUID-7FC09376-F237-41E8-B0FE-9D1044A59FBB" title="可以在两个平面文件中定义属性图，特别是顶点和边的描述文件。">Oracle平面文件格式定义</a> 。
                           </p>
                           <p><span class="bold">例</span></p>
                           <p>以下是一个HTML表单，可用于执行POST操作并将CSV文件转换为OPE文件。</p><pre class="oac_no_warn" dir="ltr">&lt;html&gt; &lt;body&gt; &lt;h1&gt; CSV示例 - 边缘&lt;/ h1&gt; &lt;form id =“myForm”action =“http：// localhost：7001 / opg_unified / dal / csv / edges”method =“POST”enctype = “multipart / form-data”&gt; &lt;p&gt;选择边缘文件：&lt;input type =“file”name =“fileEdge”size =“45”/&gt; &lt;/ p&gt; &lt;p&gt;边缘标识：&lt;输入类型= “text”name =“cboxEdgeIDColName”size =“25”/&gt; &lt;/ p&gt; &lt;p&gt;开始顶点ID：&lt;input type =“text”name =“cboxEdgeSVIDColName”size =“25”/&gt; &lt;/ p&gt; &lt; p&gt;边缘标签：&lt;input type =“text”name =“cboxEdgeLabelColName”size =“25”/&gt; &lt;/ p&gt; &lt;p&gt;结束顶点Id：&lt;input type =“text”name =“cboxEdgeDVIDColName”size =“ 25“/&gt; &lt;/ p&gt; &lt;input type =”button“onclick =”myFunction（）“value =”Upload“&gt; &lt;/ form&gt; &lt;script&gt; function myFunction（）{frm = document.getElementById（”myForm“） ; frm.submit（）; } &lt;/ script&gt; &lt;/ body&gt; &lt;/ html&gt;</pre><p>这是表单在浏览器中的外观：</p><img src="img/post_csv_edges_output.jpg" alt="post_csv_edges_output.jpg的描述如下" title="post_csv_edges_output.jpg的描述如下" longdesc="img_text/post_csv_edges_output.html"><br><a href="img_text/post_csv_edges_output.html">post_csv_edges_output.jpg插图的描述</a><p>输入边文件（ <code class="codeph">edges.csv</code> ）的内容如下：</p><pre class="oac_no_warn" dir="ltr">EDGE_ID，START_ID：long，weight：float，END_ID：long，label：string 1,1,1.0,2，know</pre><p>输出边缘文件（ <code class="codeph">vertices.ope</code> ）的内容如下：</p><pre class="oac_no_warn" dir="ltr">1,1,2，知道，重量，3，1.0，</pre></div>
                        <!-- class="section" -->
                        <div class="section" id="GUID-BCF729EE-0742-41A0-8BBE-B629EF7D4FF8__CSVVERTICES-494F3F15">
                           <p class="subhead3" id="GUID-BCF729EE-0742-41A0-8BBE-B629EF7D4FF8__CSVVERTICES-494F40F6">/ CSV /顶点</p>
                           <p><span class="bold">说明</span> ：将顶点文件从CSV格式转换为OPV格式。
                           </p>
                           <p><span class="bold">参数</span></p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">fileVertex</code> ：</p>顶点文件的名称（CSV格式）。
                              </li>
                              <li>
                                 <p><code class="codeph">cboxVertexIDColName</code> ：</p>应该用作顶点ID的键。</li>
                           </ul>
                           <p><span class="bold">使用说明</span></p>
                           <p>有关文件格式的信息，请参阅<a href="using-property-graphs-oracle-database.html#GUID-7FC09376-F237-41E8-B0FE-9D1044A59FBB" title="可以在两个平面文件中定义属性图，特别是顶点和边的描述文件。">Oracle平面文件格式定义</a> 。
                           </p>
                           <p><span class="bold">例</span></p>
                           <p>以下是一个HTML表单，可用于执行POST操作并将CSV文件转换为OPV文件。</p><pre class="oac_no_warn" dir="ltr">&lt;html&gt; &lt;body&gt; &lt;h1&gt; CSV示例&lt;/ h1&gt; &lt;form id =“myForm”action =“http：// localhost：7001 / opg_unified / dal / csv / vertices”method =“POST”enctype =“multipart / form-data“&gt; &lt;p&gt;选择顶点文件：&lt;input type =”file“name =”fileVertex“size =”45“/&gt; &lt;/ p&gt; &lt;p&gt; Vertex Id：&lt;input type =”text “name =”cboxVertexIDColName“size =”25“/&gt; &lt;/ p&gt; &lt;input type =”button“onclick =”myFunction（）“value =”Upload“&gt; &lt;/ form&gt; &lt;script&gt; function myFunction（）{frm = document.getElementById（“myForm”）; frm.submit（）; } &lt;/ script&gt; &lt;/ body&gt; &lt;/ html&gt;</pre><p>这是表单在浏览器中的外观：</p><img src="img/post_csv_vertices_output.jpg" alt="post_csv_vertices_output.jpg的描述如下" title="post_csv_vertices_output.jpg的描述如下" longdesc="img_text/post_csv_vertices_output.html"><br><a href="img_text/post_csv_vertices_output.html">post_csv_vertices_output.jpg插图的描述</a><p>输入顶点文件（ <code class="codeph">vertices.csv</code> ）的内容如下：</p><pre class="oac_no_warn" dir="ltr">id，name，country 1，Eros％20Ramazzotti，Italy 2，Monica％20Bellucci，Italy</pre><p>输出顶点文件（ <code class="codeph">vertices.opv</code> ）的内容如下：</p><pre class="oac_no_warn" dir="ltr">1，name，1，Eros％20Ramazzotti ,, 1，country，1，Italy ,, 2，name，1，Monica％20Bellucci ,, 2，country，1，Italy}</pre></div>
                        <!-- class="section" -->
                        <div class="section" id="GUID-BCF729EE-0742-41A0-8BBE-B629EF7D4FF8__GRAPHSGRAPHNAMELOADDATA-494F4625">
                           <p class="subhead3" id="GUID-BCF729EE-0742-41A0-8BBE-B629EF7D4FF8__GRAPHSGRAPHNAMELOADDATA-494F4825">/图形/ {graphname} / loadData</p>
                           <p><span class="bold">描述</span> ：将OPV和OPE文件上载到服务器，并将顶点和边缘导入图形。返回图元数据。
                           </p>
                           <p><span class="bold">参数</span></p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">graphname</code> ：</p>属性图的名称。
                              </li>
                              <li>
                                 <p><code class="codeph">vertexFile</code> （请求有效载荷）：</p>顶点（ <code class="codeph">.opv</code> ）文件。
                              </li>
                              <li>
                                 <p><code class="codeph">edgeFile</code> （请求有效负载）：</p>边（ <code class="codeph">.ope</code> ）文件。
                              </li>
                              <li>
                                 <p><code class="codeph">clearRepository</code> （请求有效负载）：</p>布尔值，指示在开始加载操作之前是否清除图形。
                              </li>
                              <li>
                                 <p><code class="codeph">dop</code> （请求有效负载）：</p>操作的并行度。
                              </li>
                           </ul>
                           <p><span class="bold">使用说明</span></p>
                           <p>此操作使您可以在同一操作中发布顶点和边文件。</p>
                           <p><span class="bold">例</span></p>
                           <p>以下简单的HTML表单可用于上传一对。OPV和。OPE文件到服务器：</p><pre class="oac_no_warn" dir="ltr">http：// localhost：7001 / opg_unified / graphs / connections / loadData &lt;html&gt; &lt;body&gt; &lt;h1&gt;文件上传到OPG Unified &lt;/ h1&gt; &lt;p&gt;图名：&lt;input type =“text”name =“graphTxt “id =”graphTxt“size =”45“/&gt; &lt;/ p&gt; &lt;form id =”myForm“action =”http：// localhost：7001 / opg_unified / graphs /“method =”POST“enctype =”multipart / form-data“&gt; &lt;p&gt;选择顶点文件：&lt;input type =”file“name =”vertexFile“size =”45“/&gt; &lt;/ p&gt; &lt;p&gt;选择边缘文件：&lt;input type = “file”name =“edgeFile”size =“45”/&gt; &lt;/ p&gt; &lt;p&gt;清除图表？ ：&lt;input type =“text”name =“clearRepository”size =“25”/&gt; &lt;/ p&gt; &lt;input type =“button”onclick =“myFunction（）”value =“Upload”&gt; &lt;/ form&gt; &lt;script &gt; function myFunction（）{frm = document.getElementById（“myForm”）; frm.action = frm.action + graphTxt.value +'/ loadData'; frm.submit（）; } &lt;/ script&gt; &lt;/ body&gt; &lt;/ html&gt;</pre><p>显示的表单如下所示：</p><img src="img/post_loaddata_output.jpg" alt="post_loaddata_output.jpg的描述如下" title="post_loaddata_output.jpg的描述如下" longdesc="img_text/post_loaddata_output.html"><br><a href="img_text/post_loaddata_output.html">post_loaddata_output.jpg插图的描述</a><p>以下是OPV（顶点）文件的内容：</p><pre class="oac_no_warn" dir="ltr">1，姓名，1，Barack％20Obama ,, 1，角色，1，政治％20权威，1，职业，1,44th％20President％20of％20United％20States％20of％20America ,, 1，country，1，United ％20States ,, ...</pre><p>以下是OPE（edgee）文件的内容：</p><pre class="oac_no_warn" dir="ltr">1000,1,2，合作，重量，3,1.0,1001,1,3，合作，重量，3,1.0,1002,1,4，钦佩，重量，3,1.0,1003,1,5 ，欣赏，重量，3，1.0，...</pre><p>返回的JSON结果可能如下所示：</p><pre class="oac_no_warn" dir="ltr">{name：“connections”，graph：“oraclepropertygraph with name connections”，features：{isWrapper：false，supportsVertexProperties：true，supportsMapProperty：true，supportsUniformListProperty：true，supportsIndices：true，ignoresSuppliedIds：false，supportsFloatProperty：true，supportsPrimitiveArrayProperty：true ，supportsEdgeIndex：true，supportsDeyProperty：true，isRDFModel：false，isPersistent：true，supportsVertexIteration：true，supportsEdgeProperties：true，supportsSelfLoops：false，supportsDuplicateEdges：true，supportsSerializableObjectProperty：true，supportsEdgeIteration：true，supportsVertexIndex：true，supportsIntegerProperty ：true，supportsBixedProperty：true，supportsMixedListProperty：true，supportsEdgeRetrieval：true，supportsTransactions：true，supportsThreadedTransactions：true，supportsStringProperty：true，supportsVertexKeyIndex：true，supportsRdgeKeyIndex：true，supportsLongProperty：true}，readOnly：false，type：“oracle.pg .rdbms。OraclePropertyGraph“，queryTime：1010.203456，upTime：”0 [d]：19 [h]：28 [m]：37 [s]“}</pre></div>
                        <!-- class="section" -->
                        <div class="section" id="GUID-BCF729EE-0742-41A0-8BBE-B629EF7D4FF8__BACKENDSNEWBACKENDNAME-494F4F2D">
                           <p class="subhead3" id="GUID-BCF729EE-0742-41A0-8BBE-B629EF7D4FF8__BACKENDSNEWBACKENDNAME-494F514C">/后端/ {newBackendName}</p>
                           <p><span class="bold">描述</span> ：设置具有指定属性的新后端条目。
                           </p>
                           <p><span class="bold">参数</span></p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">newBackendName</code> ：</p>要支持的新后端的名称。
                              </li>
                           </ul>
                           <p><span class="bold">使用说明</span></p>
                           <p>如果后端名称已存在，则会生成错误</p>
                           <p>指定的任何其他参数（例如<code class="codeph">isDefault</code>或<code class="codeph">backendType</code> ）将作为有效内容的一部分传递。
                           </p>
                           <p><span class="bold">例</span></p>
                           <p>以下POST操作将创建名为<code class="codeph">rdbms_connection2</code>的新后端。
                           </p><pre class="oac_no_warn" dir="ltr">HTTP：//本地主机：7001 / opg_unified / DAL /后端/ rdbms_connection2</pre><p>有效负载例如：</p><pre class="oac_no_warn" dir="ltr">{“isDefault”：false，“jdbcUrl”：“jdbc：oracle：thin：@ 127.0.0.1：1521：orcl”，“user”：“scott”，“password”：“&lt;password&gt;”，“backendType”： “OracleRDBMSBackendConnection”}</pre><p>结果可能如下所示：</p><pre class="oac_no_warn" dir="ltr">{“backend”：{“jdbcUrl”：“jdbc：oracle：thin：@ 127.0.0.1：1521：orcl”，“backendName”：“rdbms_connection2”，“isDefault”：false，“user”：“scott”，“ backendType“：”OracleRDBMSBackendConnection“}，”queryTime“：0.670459，”upTime“：”0 [d]：00 [h]：51 [m]：21 [s]“}</pre></div>
                        <!-- class="section" -->
                        <div class="section" id="GUID-BCF729EE-0742-41A0-8BBE-B629EF7D4FF8__EDGESGRAPHNAMEIDS-494F551B">
                           <p class="subhead3" id="GUID-BCF729EE-0742-41A0-8BBE-B629EF7D4FF8__EDGESGRAPHNAMEIDS-494F5752">/边缘/ {graphName} / IDS</p>
                           <p><span class="bold">描述</span> ：返回一组边。
                           </p>
                           <p><span class="bold">参数</span></p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">graphname</code> ：</p>属性图的名称。
                              </li>
                              <li>
                                 <p><code class="codeph">ids</code> （请求有效载荷）：</p>带有请求边的ID的JSON数组。
                              </li>
                           </ul>
                           <p><span class="bold">使用说明</span></p>
                           <p>此API发送带有ID键和整数ID值数组的JSON数组。它返回一个与输入<span class="italic">ids</span>参数大小匹配的数组</p>
                           <p>如果未找到边，则结果数组中的对应值将为null。</p>
                           <p>即使图中没有任何边存在，它也总是返回一个结果数组，在这种情况下返回一个充满空值而不是404 HTTP代码的数组。</p>
                           <p><span class="bold">例</span></p>
                           <p>以下命令获取<code class="codeph">connections</code>图中ID为1001和1002（如果存在）的边。
                           </p><pre class="oac_no_warn" dir="ltr">curl -v -X POST'http：// localhost：7001 / opg_unified / edges / connections / ids'-H“Content-Type：application / json”-d'{“ids”：[1001,1002,1]}</pre><p>返回的JSON可能如下所示：</p><pre class="oac_no_warn" dir="ltr">{结果：[{weight：1，_id：1001，_type：“edge”，_ outV：1，_inV：3，_ label：“collaborates”}，{weight：1，_id：1002，_type：“edge”，_ outV ：1，_inV：4，_label：“admires”}，null]，totalSize：3，queryTime：49.491961}</pre></div>
                        <!-- class="section" -->
                        <div class="section" id="GUID-BCF729EE-0742-41A0-8BBE-B629EF7D4FF8__EDGESGRAPHNAMEPROPERTIES-494F5B2A">
                           <p class="subhead3" id="GUID-BCF729EE-0742-41A0-8BBE-B629EF7D4FF8__EDGESGRAPHNAMEPROPERTIES-494F5D5D">/边缘/ {graphName} /性能</p>
                           <p><span class="bold">描述</span> ：返回指定边的指定属性。
                           </p>
                           <p><span class="bold">参数</span></p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">graphname</code> ：</p>属性图的名称。
                              </li>
                              <li>
                                 <p><code class="codeph">ids</code> （请求有效载荷）：</p>具有边缘ID的JSON数组。
                              </li>
                              <li>
                                 <p><code class="codeph">propertyName</code> （请求有效载荷）：</p>一个JSON字符串，指定属性的名称。
                              </li>
                           </ul>
                           <p><span class="bold">使用说明</span></p>
                           <p>此API发送带有“ids”键和整数ID值数组的JSON数组。它返回一个与输入<span class="italic">ids</span>参数大小匹配的数组</p>
                           <p>如果未找到边，则结果数组中的对应值将为null。</p>
                           <p>即使图中没有任何边存在，它也总是返回一个结果数组，在这种情况下返回一个充满空值而不是404 HTTP代码的数组。</p>
                           <p><span class="bold">例</span></p>
                           <p>以下命令获取<code class="codeph">connections</code>图中ID为1001,1002和1003（如果存在）的边的<code class="codeph">weight</code>值。
                           </p><pre class="oac_no_warn" dir="ltr">curl -v -X POST'http：// localhost：7001 / opg_unified / edges / connections / properties'-H“Content-Type：application / json”-d'{“ids”：[1001,1002,1003]， “PROPERTYNAME”： “权重”}”</pre><p>返回的JSON可能如下所示：</p><pre class="oac_no_warn" dir="ltr">{results：[{_ id：1001，weight：1}，{_ id：1002，weight：1}，{_ id：1003，weight：1}]，totalSize：3，queryTime：12.491961}</pre></div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="using-property-graphs-oracle-database.html#GUID-BB6CBF64-8B59-4356-B45B-3D9CBEBCA2C6">Oracle数据库的属性图REST API操作信息</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
                  <div class="props_rev_3"><a id="GUID-22BD7107-5546-4072-A194-BBBDF8C63CBA" name="GUID-22BD7107-5546-4072-A194-BBBDF8C63CBA"></a><h5 id="SPGDG-GUID-22BD7107-5546-4072-A194-BBBDF8C63CBA" class="sect5"><span class="enumeration_section">2.10.3.3</span> Oracle数据库的PUT操作（属性图）</h5>
                     <div>
                        <p>本主题描述属性图REST API的PUT操作。</p>
                        <div class="infoboxnote" id="GUID-22BD7107-5546-4072-A194-BBBDF8C63CBA__GUID-B81D9BCF-1E1D-4E2B-9D7B-697636C07CBE">
                           <p class="notep1">注意：</p>
                           <p>有关属性图索引的信息，请参阅<a href="using-property-graphs-oracle-database.html#GUID-469E1B26-DE30-4AFA-801E-BA14AB30214B">使用属性图数据的自动索引</a>和<a href="using-property-graphs-oracle-database.html#GUID-C56AB70D-CB45-4208-84D8-6C5DBF67A8FC">使用</a> <a href="using-property-graphs-oracle-database.html#GUID-469E1B26-DE30-4AFA-801E-BA14AB30214B">属性图数据的</a> <a href="using-property-graphs-oracle-database.html#GUID-C56AB70D-CB45-4208-84D8-6C5DBF67A8FC">手动索引</a> ，</p>
                        </div>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="using-property-graphs-oracle-database.html#GUID-22BD7107-5546-4072-A194-BBBDF8C63CBA__BACKENDSNEWBACKENDNAME-0F023CA9">/后端/ {backendNameNew}</a></p>
                           </li>
                           <li>
                              <p><a href="using-property-graphs-oracle-database.html#GUID-22BD7107-5546-4072-A194-BBBDF8C63CBA__GRAPHSCONNECITONSEDGES-0F0104FB">/图形/连接/边缘</a></p>
                           </li>
                           <li>
                              <p><a href="using-property-graphs-oracle-database.html#GUID-22BD7107-5546-4072-A194-BBBDF8C63CBA__GRAPHSGRAPHNAMEINDICESINDEXNAMEKEYK-13AAC2FB">/图/ {} graphname /指数/ {INDEXNAME}}？键= &lt;键&gt;＆值= &lt;值&gt;＆ID = &lt;ID&gt;</a></p>
                           </li>
                        </ul>
                        <div class="section" id="GUID-22BD7107-5546-4072-A194-BBBDF8C63CBA__BACKENDSNEWBACKENDNAME-0F023CA9">
                           <p class="subhead3" id="GUID-22BD7107-5546-4072-A194-BBBDF8C63CBA__BACKENDSNEWBACKENDNAME-0F023EC5">/后端/ {backendNameNew}</p>
                           <p><span class="bold">描述</span> ：设置具有指定属性的新后端条目。
                           </p>
                           <p><span class="bold">参数</span></p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">backendNameNew</code> ：</p>要支持的新后端的名称。
                              </li>
                              <li>
                                 <p><code class="codeph">backendType</code> ：</p>要支持的新后端的类型。
                              </li>
                              <li>
                                 <p><code class="codeph">(other)</code> ：</p>（其他特定于后端的属性。）
                              </li>
                           </ul>
                           <p><span class="bold">使用说明</span></p>
                           <p>如果后端名称已存在，则会生成错误。</p>
                           <p>指定的任何其他参数（例如<code class="codeph">isDefault</code>或<code class="codeph">backendType</code> ）将作为有效内容的一部分传递。
                           </p>
                           <p><span class="bold">例</span></p>
                           <p>以下PUT操作会创建一个名为<code class="codeph">rdbms_connection2</code>的新后端。
                           </p><pre class="oac_no_warn" dir="ltr">HTTP：//本地主机：7001 / opg_unified / DAL /后端/ rdbms_connection2</pre><p>有效负载例如：</p><pre class="oac_no_warn" dir="ltr">{“isDefault”：false，“jdbcUrl”：“jdbc：oracle：thin：@ 127.0.0.1：1521：orcl”，“user”：“scott”，“password”：“&lt;password&gt;”，“backendType”： “OracleRDBMSBackendConnection”}</pre><p>结果可能如下所示：</p><pre class="oac_no_warn" dir="ltr">{“backend”：{“jdbcUrl”：“jdbc：oracle：thin：@ 127.0.0.1：1521：orcl”，“backendName”：“rdbms_connection2”，“isDefault”：false，“user”：“scott”，“ backendType“：”OracleRDBMSBackendConnection“}，”queryTime“：0.683681，”upTime“：”0 [d]：00 [h]：54 [m]：04 [s]“}</pre></div>
                        <!-- class="section" -->
                        <div class="section" id="GUID-22BD7107-5546-4072-A194-BBBDF8C63CBA__GRAPHSCONNECITONSEDGES-0F0104FB">
                           <p class="subhead3" id="GUID-22BD7107-5546-4072-A194-BBBDF8C63CBA__GRAPHSCONNECITONSEDGES-0F010818">/图形/连接/边缘</p><pre class="oac_no_warn" dir="ltr">...边缘？_outV = &lt;id&gt;＆_ label = value＆_inV = &lt;id&gt; ... edges / &lt;edgeId&gt;？_outV = &lt;id&gt;＆_ label = value＆_inV = &lt;id&gt; ... edges / &lt;edgeId&gt;？&lt;键&gt; =值</pre><p><span class="bold">描述</span> ：在两个顶点之间创建一条新边。
                           </p>
                           <p><span class="bold">参数</span></p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">_outV</code> ：</p>传出的顶点。
                              </li>
                              <li>
                                 <p><code class="codeph">_inV</code> ：</p>传入的顶点。
                              </li>
                              <li>
                                 <p><code class="codeph">_label</code> ：</p>边缘的传出标签。
                              </li>
                              <li>
                                 <p><code class="codeph">edgeID</code> ：</p>要创建的边的ID。
                              </li>
                              <li>
                                 <p><code class="codeph">key</code> ：</p>创造的关键价值。
                              </li>
                           </ul>
                           <p><span class="bold">使用说明</span></p>
                           <p>（没有。）</p>
                           <p><span class="bold">例</span></p>
                           <p>以下PUT操作使用从顶点29到顶点26的标签<code class="codeph">friend</code>创建边。
                           </p><pre class="oac_no_warn" dir="ltr">HTTP：//本地主机：8080 /图形/连接/ edges_outV = 29＆_label =朋友＆_inV = 26</pre><p>结果可能如下所示：</p><pre class="oac_no_warn" dir="ltr">{“results”：{“_ id”：1810534020425227300，“_ type”：“edge”，“_ outV”：29，“_ inV”：26，“_ label”：“friend”}，“queryTime”：36.635908}</pre></div>
                        <!-- class="section" -->
                        <div class="section" id="GUID-22BD7107-5546-4072-A194-BBBDF8C63CBA__GRAPHSGRAPHNAMEINDICESINDEXNAMEKEYK-13AAC2FB">
                           <p class="subhead3" id="GUID-22BD7107-5546-4072-A194-BBBDF8C63CBA__GRAPHSGRAPHNAMEINDICESINDEXNAMEKEYK-13AAC5A6">/图/ {} graphname /指数/ {INDEXNAME}}？键= &lt;键&gt;＆值= &lt;值&gt;＆ID = &lt;ID&gt;</p>
                           <p><span class="bold">描述</span> ：将指定的顶点或边添加到指定手动索引的键值对。
                           </p>
                           <p><span class="bold">参数</span></p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">graphName</code> ：</p>属性图的名称。
                              </li>
                              <li>
                                 <p><code class="codeph">indexName</code> ：</p>索引的名称。
                              </li>
                              <li>
                                 <p><code class="codeph">&lt;key&gt;</code> ：</p>键值对的关键。
                              </li>
                              <li>
                                 <p><code class="codeph">&lt;value&gt;</code> ：</p>键值对的值。
                              </li>
                              <li>
                                 <p><code class="codeph">&lt;id&gt;</code> ：</p>顶点或边的ID值。
                              </li>
                           </ul>
                           <p><span class="bold">使用说明</span></p>
                           <p>此PUT操作执行对<code class="codeph">OracleIndex.put(key,value,class)</code>方法的调用。
                           </p>
                           <p><span class="bold">例</span></p>
                           <p>以下示例将键值对<code class="codeph">“name”-“Beyonce”</code>到ID为2的顶点。
                           </p><pre class="oac_no_warn" dir="ltr">HTTP：//本地主机：7001 / opg_unified / DAL /图形/连接/索引/ myIdx键=名称＆值=碧昂丝＆ID = 2</pre><p>如果PUT操作成功，您可能会看到如下响应：</p><pre class="oac_no_warn" dir="ltr">{“queryTime”：39.265613}</pre></div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="using-property-graphs-oracle-database.html#GUID-BB6CBF64-8B59-4356-B45B-3D9CBEBCA2C6">Oracle数据库的属性图REST API操作信息</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
                  <div class="props_rev_3"><a id="GUID-4343EDC5-88CE-441E-A377-238ED855D010" name="GUID-4343EDC5-88CE-441E-A377-238ED855D010"></a><h5 id="SPGDG-GUID-4343EDC5-88CE-441E-A377-238ED855D010" class="sect5"><span class="enumeration_section">2.10.3.4</span>删除Oracle数据库的操作（属性图）</h5>
                     <div>
                        <p>本主题描述属性图REST API的DELETE操作。</p>
                        <div class="infoboxnote" id="GUID-4343EDC5-88CE-441E-A377-238ED855D010__GUID-B81D9BCF-1E1D-4E2B-9D7B-697636C07CBE">
                           <p class="notep1">注意：</p>
                           <p>有关属性图索引的信息，请参阅<a href="using-property-graphs-oracle-database.html#GUID-469E1B26-DE30-4AFA-801E-BA14AB30214B">使用属性图数据的自动索引</a>和<a href="using-property-graphs-oracle-database.html#GUID-C56AB70D-CB45-4208-84D8-6C5DBF67A8FC">使用</a> <a href="using-property-graphs-oracle-database.html#GUID-469E1B26-DE30-4AFA-801E-BA14AB30214B">属性图数据的</a> <a href="using-property-graphs-oracle-database.html#GUID-C56AB70D-CB45-4208-84D8-6C5DBF67A8FC">手动索引</a> ，</p>
                        </div>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="using-property-graphs-oracle-database.html#GUID-4343EDC5-88CE-441E-A377-238ED855D010__BACKENDSBACKENDNAMENEW-0F07FF5F">/后端/ {backendName}</a></p>
                           </li>
                           <li>
                              <p><a href="using-property-graphs-oracle-database.html#GUID-4343EDC5-88CE-441E-A377-238ED855D010__GRAPHSGRAPHNAMEINDICESINDEXNAMEKEYK-0F09845B">/图形/ {graphName} /边缘/ &lt;ID&gt;</a></p>
                           </li>
                           <li>
                              <p><a href="using-property-graphs-oracle-database.html#GUID-4343EDC5-88CE-441E-A377-238ED855D010__GRAPHSGRAPHNAMEINDICESINDEXNAME-0F0ABDC4">/图形/ {graphName} /索引/ {INDEXNAME}</a></p>
                           </li>
                           <li>
                              <p><a href="using-property-graphs-oracle-database.html#GUID-4343EDC5-88CE-441E-A377-238ED855D010__GRAPHSGRAPHNAMEKEYINDICESCLASSKEYNA-13AB333B">/图形/ {graphName} / keyindices / {类} / {的keyName}</a></p>
                           </li>
                        </ul>
                        <div class="section" id="GUID-4343EDC5-88CE-441E-A377-238ED855D010__BACKENDSBACKENDNAMENEW-0F07FF5F">
                           <p class="subhead3" id="GUID-4343EDC5-88CE-441E-A377-238ED855D010__BACKENDSBACKENDNAMENEW-0F080262">/后端/ {backendName}</p>
                           <p><span class="bold">描述</span> ：从图形服务器的可用后端列表中删除指定的后端。它返回已删除后端的信息。
                           </p>
                           <p><span class="bold">参数</span></p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">backendName</code> ：</p>后端的名称。
                              </li>
                           </ul>
                           <p><span class="bold">使用说明</span></p>
                           <p>（没有。）</p>
                           <p><span class="bold">例</span></p>
                           <p>以下DELETE操作从图形服务器的可用后端列表中删除名为<code class="codeph">rdbms_connection2</code>的后端</p><pre class="oac_no_warn" dir="ltr">HTTP：//本地主机：7001 / opg_unified / DAL /后端/ rdbms_connection2</pre><p>结果可能如下所示：</p><pre class="oac_no_warn" dir="ltr">{“backend”：{“jdbcUrl”：“jdbc：oracle：thin：@ 127.0.0.1：1521：orcl”，“backendName”：“rdbms_connection2”，“isDefault”：false，“user”：“scott”，“ backendType“：”OracleRDBMSBackendConnection“}，”queryTime“：0.418729，”upTime“：”0 [d]：00 [h]：57 [m]：15 [s]“}</pre></div>
                        <!-- class="section" -->
                        <div class="section" id="GUID-4343EDC5-88CE-441E-A377-238ED855D010__GRAPHSGRAPHNAMEINDICESINDEXNAMEKEYK-0F09845B">
                           <p class="subhead3" id="GUID-4343EDC5-88CE-441E-A377-238ED855D010__GRAPHSGRAPHNAMEINDICESINDEXNAMEKEYK-0F09825C">/图形/ {graphName} /边缘/ &lt;ID&gt;</p>
                           <p><span class="bold">描述</span> ：从指定的图形中删除具有指定边ID的边。</p>
                           <p><span class="bold">参数</span></p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">id</code> ：</p>要删除的边缘的ID。
                              </li>
                           </ul>
                           <p><span class="bold">使用说明</span></p>
                           <p>此API返回操作所用的时间。</p>
                           <p><span class="bold">例</span></p>
                           <p>以下示例删除ID为1010的边。</p><pre class="oac_no_warn" dir="ltr">HTTP：//本地主机：7001 / opg_unified / DAL /图形/连接/边缘/ 1010</pre><p>如果操作成功，您可能会看到如下响应：</p><pre class="oac_no_warn" dir="ltr">{“queryTime”：10.925611}</pre></div>
                        <!-- class="section" -->
                        <div class="section" id="GUID-4343EDC5-88CE-441E-A377-238ED855D010__GRAPHSGRAPHNAMEINDICESINDEXNAME-0F0ABDC4">
                           <p class="subhead3" id="GUID-4343EDC5-88CE-441E-A377-238ED855D010__GRAPHSGRAPHNAMEINDICESINDEXNAME-0F0AC08F">/图形/ {graphName} /索引/ {INDEXNAME}</p>
                           <p><span class="bold">描述</span> ：从指定的图形中删除指定的手动索引。
                           </p>
                           <p><span class="bold">参数</span></p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">graphName</code> ：</p>属性图的名称。
                              </li>
                              <li>
                                 <p><code class="codeph">indexName</code> ：</p>要删除的mamual索引的名称。
                              </li>
                           </ul>
                           <p><span class="bold">使用说明</span></p>
                           <p>此DELETE操作执行对<code class="codeph">OraclePropertyGraph.dropIndex(name)</code>方法的调用。
                           </p>
                           <p><span class="bold">例</span></p>
                           <p>以下示例从<code class="codeph">connections</code>图中删除手动索引<code class="codeph">myIdx</code> 。
                           </p><pre class="oac_no_warn" dir="ltr">http：// localhost：7001 / opg_unified / dal / graphs / connections / indices / myIdx</pre></div>
                        <!-- class="section" -->
                        <div class="section" id="GUID-4343EDC5-88CE-441E-A377-238ED855D010__GRAPHSGRAPHNAMEKEYINDICESCLASSKEYNA-13AB333B">
                           <p class="subhead3" id="GUID-4343EDC5-88CE-441E-A377-238ED855D010__GRAPHSGRAPHNAMEKEYINDICESCLASSKEYNA-13AB3538">/图形/ {graphName} / keyindices / {类} / {的keyName}</p>
                           <p><span class="bold">描述</span> ：从指定的图形中删除指定的自动索引。
                           </p>
                           <p><span class="bold">参数</span></p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">graphName</code> ：</p>属性图的名称。
                              </li>
                              <li>
                                 <p><code class="codeph">indexName</code> ：</p>要删除的自动索引的名称。
                              </li>
                           </ul>
                           <p><span class="bold">使用说明</span></p>
                           <p>此DELETE操作执行对<code class="codeph">OraclePropertyGraph.dropKeyIndex(name,class)</code>方法的调用。
                           </p>
                           <p><span class="bold">例</span></p>
                           <p>以下示例从<code class="codeph">connections</code>图中删除自动索引<code class="codeph">myVKeyIdx</code> 。
                           </p><pre class="oac_no_warn" dir="ltr">http：// localhost：7001 / opg_unified / dal / graphs / connections / keyindices / vertex / myVKeyIdx</pre></div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="using-property-graphs-oracle-database.html#GUID-BB6CBF64-8B59-4356-B45B-3D9CBEBCA2C6">Oracle数据库的属性图REST API操作信息</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div>
            </div>
            <div class="props_rev_3"><a id="GUID-24C684A5-8A18-45F3-9F0D-A8F7CCF964BE" name="GUID-24C684A5-8A18-45F3-9F0D-A8F7CCF964BE"></a><h3 id="SPGDG-GUID-24C684A5-8A18-45F3-9F0D-A8F7CCF964BE" class="sect3"><span class="enumeration_section">2.11</span>在RDF图上创建属性图视图</h3>
               <div>
                  <p>使用Oracle Spatial and Graph，您可以将RDF数据视为属性图，以通过在Oracle数据库中存储的RDF图上创建属性图视图来执行图分析操作。</p>
                  <p>给定RDF模型（或虚拟模型），属性图功能创建两个视图，顶点的&lt;graph_name&gt; VT $视图和边的&lt;graph_name&gt; GE $视图。</p>
                  <p><code class="codeph">PGUtils.createPropertyGraphViewOnRDF</code>方法允许您自定义RDF数据的属性图表视图：</p><pre class="oac_no_warn" dir="ltr">public static void createPropertyGraphViewOnRDF（Connection conn / *一个到Oracle数据库的连接实例* /，String pgGraphName / *要创建的属性图的名称* /，String rdfModelName / * RDF模型的名称* /，boolean virtualModel / *一个标志表示RDF模型是否为虚拟模型; true  - 虚拟模式，false  - 正常模型* /，RDFPredicate [] predListForVertexAttrs / *一个RDFPredicate对象数组，指定如何使用这些谓词创建顶点视图;每个RDFPredicate包括两个字段：RDF谓词的URL，属性图中顶点键的对应名称。将基于此参数创建从RDF谓词到顶点键的映射。* /，RDFPredicate [] predListForEdges / *一个RDFPredicate数组，指定如何使用这些谓词创建边视图;每个RDFPredicate包括两个（或三个）字段：RDF谓词的URL，属性图中的边缘标签，边缘的权重（可选）。将基于此参数创建从RDF谓词到边的映射。* /）</pre><p>此操作需要属性图的名称，用于生成“属性图”视图的RDF模型的名称，以及一组确定三元组将如何解析为顶点或边的映射。<code class="codeph">createPropertyGraphViewOnRDF</code>方法需要<span class="italic">键/值映射</span>数组，指定RDF谓词如何映射到顶点的键/值属性，以及<span class="italic">边缘映射</span>数组，指定RDF谓词如何映射到边。<code class="codeph">PGUtils.RDFPredicate</code> API允许您创建从RDF断言到顶点/边的映射。
                  </p>
                  <p>基于与键/值映射中的至少一个RDF谓词匹配的三元组来创建顶点。满足映射数组中定义的RDF谓词之一的每个三元组被解析为具有基于三元组的主体的内部RDF资源ID的ID的顶点，以及其键由映射本身定义的键/值对。值是从三元组的对象获得的。</p>
                  <p>以下示例将RDF谓词URI <code class="codeph">http://purl.org/dc/elements/1.1/title</code>的键/值映射定义为具有属性名称<code class="codeph">title</code>的键/值属性。
                  </p><pre class="oac_no_warn" dir="ltr">String titleURL =“http://purl.org/dc/elements/1.1/title”; //创建一个RDFPredicate来指定如何将RDF谓词映射到顶点键RDFPredicate titleRDFPredicate = RDFPredicate.getInstance（titleURL / * RDF Predicate URI * /，“title”/ * property name * /）;</pre><p>基于匹配边缘映射阵列中的至少一个RDF谓词的三元组来创建边缘。满足映射数组中定义的RDF谓词的每个三元组被解析为具有基于行号的ID的边缘，由映射本身定义的边缘标签，从三元组的主题的RDF资源ID获得的源顶点，以及从三元组的对象的RDF资源ID获得的目标顶点。对于此处解析的每个三元组，如果它们不是从键/值映射生成的，则将创建两个顶点。</p>
                  <p>以下示例将RDF谓词URI <code class="codeph">http://purl.org/dc/elements/1.1/reference</code>的边缘映射定义为具有标签<span class="italic">引用</span>且权重为0.5d的边。
                  </p><pre class="oac_no_warn" dir="ltr">字符串referencesURL =“http://purl.org/dc/terms/references”; //创建一个RDFPredicate来指定如何将RDF谓词映射到边缘RDFPredicate referencesRDFPredicate = RDFPredicate.getInstance（referencesURL，“references”，0.5d）;</pre><p>以下示例在描述不同出版物，作者和参考的RDF模型<code class="codeph">articles</code>创建属性图视图。生成的属性图将包含具有一些键/值属性的顶点，这些属性可能包括<code class="codeph">title</code>和<code class="codeph">creator</code> 。属性图中的边缘将由出版物中的参考确定。
                  </p><pre class="oac_no_warn" dir="ltr">Oracle oracle = null;连接conn = null; OraclePropertyGraph pggraph = null; try {//创建连接实例到Oracle数据库OracleDataSource ds = new oracle.jdbc.pool。OracleDataSource（）; ds.setURL（JDBCURL）; conn =（OracleConnection）ds.getConnection（user，password）; //为RDF谓词定义一些字符串变量String titleURL =“http://purl.org/dc/elements/1.1/title”; String creatorURL =“http://purl.org/dc/elements/1.1/creator”; String serialnumberURL =“http://purl.org/dc/elements/1.1/serialnumber”; String widthURL =“http://purl.org/dc/elements/1.1/width”; String weightURL =“http://purl.org/dc/elements/1.1/weight”;字符串onsaleURL =“http://purl.org/dc/elements/1.1/onsale”; String publicationDateURL =“http://purl.org/dc/elements/1.1/publicationDate”;字符串publicationTimeURL =“http://purl.org/dc/elements/1.1/publicationTime”;字符串referencesURL =“http://purl.org/dc/terms/references”; //创建RDFPredicate [] predsForVertexAttrs以指定如何将// RDF谓词映射到顶点键RDFPredicate [] predsForVertexAttrs = new RDFPredicate [8]; predsForVertexAttrs [0] = RDFPredicate.getInstance（titleURL，“title”）; predsForVertexAttrs [1] = RDFPredicate.getInstance（creatorURL，“creator”）; predsForVertexAttrs [2] = RDFPredicate.getInstance（serialnumberURL，“serialnumber”）; predsForVertexAttrs [3] = RDFPredicate.getInstance（widthURL，“width”）; predsForVertexAttrs [4] = RDFPredicate.getInstance（weightURL，“weight”）; predsForVertexAttrs [5] = RDFPredicate.getInstance（onsaleURL，“onsale”）; predsForVertexAttrs [6] = RDFPredicate.getInstance（publicationDateURL，“publicationDate”）; predsForVertexAttrs [7] = RDFPredicate.getInstance（publicationTimeURL，“publicationTime”）; //创建RDFPredicate [] predsForEdges以指定如何将RDF谓词映射到//边缘RDFPredicate [] predsForEdges = new RDFPredicate [1]; predsForEdges [0] = RDFPredicate.getInstance（referencesURL，“references”，0.5d）; //在RDF模型<span class="bold">PGUtils.createPropertyGraphViewOnRDF</span>上创建PG视图<span class="bold">（conn，“articles”，“articles”，false，predsForVertexAttrs，predsForEdges）;</span> //获取Property Graph实例oracle = new Oracle（jdbcUrl，user，password）; pggraph = OraclePropertyGraph.getInstance（oracle，“articles”，24）; System.err.println（“------属性图视图中的顶点------”）; pggraph.getVertices（）; System.err.println（“------来自属性图的视图------”）; pggraph.getEdges（）; } finally {pggraph.shutdown（）; oracle.dispose（）; conn.close（）; }</pre><p>鉴于<code class="codeph">articles</code> RDF模型中的以下三元组（11个三元组），输出属性图将包括两个顶点，一个用于<code class="codeph">&lt;http://nature.example.com/Article1&gt;</code> （v1），另一个用于<code class="codeph">&lt;http://nature.example.com/Article2&gt;</code> ）。对于顶点v1，它有八个属性，其值与它们的RDF谓词相同。例如，v1的标题是<span class="italic">“All about XYZ”。</span> 类似地，对于顶点v2，它有两个属性： <code class="codeph">title</code>和<code class="codeph">creator</code> 。输出属性图将包括从顶点v1到顶点v2的单个边（eid：1），边标签为<span class="italic">“references”</span> ，权重为0.5d。
                  </p><pre class="oac_no_warn" dir="ltr">&lt;http://nature.example.com/Article1&gt; &lt;http://purl.org/dc/elements/1.1/title&gt;“所有关于XYZ”^^ xsd：string。&lt;http://nature.example.com/Article1&gt; &lt;http://purl.org/dc/elements/1.1/creator&gt;“Jane Smith”^^ xsd：string。&lt;http://nature.example.com/Article1&gt; &lt;http://purl.org/dc/elements/1.1/serialnumber&gt;“123456”^^ xsd：integer。&lt;http://nature.example.com/Article1&gt; &lt;http://purl.org/dc/elements/1.1/width&gt;“10.5”^^ xsd：float。&lt;http://nature.example.com/Article1&gt; &lt;http://purl.org/dc/elements/1.1/weight&gt;“1.08”^^ xsd：double。&lt;http://nature.example.com/Article1&gt; &lt;http://purl.org/dc/elements/1.1/onsale&gt;“false”^^ xsd：boolean。&lt;http://nature.example.com/Article1&gt; &lt;http://purl.org/dc/elements/1.1/publicationDate&gt;“2016-03-08”^^ xsd：date）&lt;http：// nature。 example.com/Article1&gt; &lt;http://purl.org/dc/elements/1.1/publicationTime&gt;“2016-03-08T10：10：10”^^ xsd：dateTime）&lt;http://nature.example.com / Article2&gt; &lt;http://purl.org/dc/elements/1.1/title&gt;“审查ABC”^^ xsd：string。&lt;http://nature.example.com/Article2&gt; &lt;http://purl.org/dc/elements/1.1/creator&gt;“Joe Bloggs”^^ xsd：string。&lt;http://nature.example.com/Article1&gt; &lt;http://purl.org/dc/terms/references&gt; &lt;http://nature.example.com/Article2&gt;。</pre><p>前面的代码将产生类似于以下的输出。请注意，内部RDF资源ID值可能因不同的Oracle数据库而异。</p><pre class="oac_no_warn" dir="ltr">------属性图视图中的顶点------顶点ID 7299961478807817799 {creator：str：Jane Smith，onsale：bol：false，publicationDate：dat：Mon Mar 07 16:00:00 PST 2016，publicationTime ：dat：Tue Mar 08 02:10:10 PST 2016，serialnumber：dbl：123456.0，title：str：All about XYZ，weight：dbl：1.08，width：flo：10.5} Vertex ID 7074365724528867041 {creator：str：Joe Bloggs ，title：str：审查ABC} ------来自属性图视图的边缘------来自顶点ID的边缘ID 1 7299961478807817799 {creator：str：Jane Smith，onsale：bol：false，publicationDate： dat：Mon Mar 07 16:00:00 PST 2016，publicationTime：dat：Tue Mar 08 02:10:10 PST 2016，serialnumber：dbl：123456.0，title：str：All about XYZ，weight：dbl：1.08，width： flo：10.5} = [references] =&gt; Vertex ID 7074365724528867041 {creator：str：Joe Bloggs，title：str：ABC的评论} edgeKV [{weight：dbl：0.5}]</pre></div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="using-property-graphs-oracle-database.html#GUID-4B5AF258-79BE-418D-84FF-9B8A692B8604" title="本章提供有关在Oracle数据库环境中创建，存储和使用属性图数据的概念和用法信息。">在Oracle数据库环境中使用属性图</a></p>
                     </div>
                  </div>
               </div>
               
            </div>
            <div class="props_rev_3"><a id="GUID-7A2037E1-2DB7-40A2-AA37-0A91D0E34D00" name="GUID-7A2037E1-2DB7-40A2-AA37-0A91D0E34D00"></a><h3 id="SPGDG-GUID-7A2037E1-2DB7-40A2-AA37-0A91D0E34D00" class="sect3"><span class="enumeration_section">2.12</span>使用双表模式处理属性图</h3>
               <div>
                  <p>对于具有相对固定，简单数据结构的属性图，您不需要灵活的<code class="codeph">&lt;graph_name&gt;VT$</code>和<code class="codeph">&lt;graph_name&gt;GE$</code>键/值数据表的顶点和边，您可以使用两表模式来实现更好的运行时性能。
                  </p>
                  <p>两表模式方法是使用属性图模式的替代方法（在Oracle数据库的属性图模式对象中描述）。</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>属性图模式方法主要针对异构和/或大图设计。当图形模型用于呈现动态应用程序域时，其中引入了相同属性名称的新关系和可能的新数据类型，并且动态地将其添加到图形模型中，建议使用属性图模式。</p>
                        <p>当图形模型用于呈现动态应用程序域时，其中引入了相同属性名称的新关系和可能的新数据类型，并且动态地将其添加到图形模型中，建议使用属性图模式。</p>
                     </li>
                     <li>
                        <p>两表模式方法是为同构图设计的。</p>
                        <p>如果图模型表示已知关系集的应用程序域，并且不同关系的总数相对较小（小于1000），则建议采用双表方法。当原始数据源来自一个或一组现有关系表或视图时，通常会发生这种情况。</p>
                     </li>
                  </ul>
                  <p>双表方法可能有用的一个示例是，如果所有节点都是特定组织的员工，并且每个员工都具有有限且固定的属性集和潜在关系。如果节点可以是可以具有不同属性和关系的任何个体，并且可以动态地添加和更改属性和关系，则两个表方法无用的示例。</p>
                  <p>在灵活的键/值方法（ <span class="italic">不是</span>两个表）中，Oracle Spatial和Graph使用灵活的模式存储属性图数据： <code class="codeph">&lt;graph_name&gt;VT$</code>表示顶点， <code class="codeph">&lt;graph_name&gt;GE$</code>表示边。在此模式中，使用多行存储顶点和边，其中每一行表示与顶点（或边）关联的键/值属性，其具有由属性<code class="codeph">T</code> （类型）确定的灵活数据类型。此架构设计可以轻松容纳异构图，其中顶点（边）具有不同的属性集或属性值的数据类型。
                  </p>
                  <p>另一方面，对于具有同构结构的属性图，您可以使用两表模式存储图数据。使用此方法，每个顶点在指定的顶点表中存储为单个行，并且每个边在指定的边表中作为单个行存储。这样，行中的每列对应于具有固定数据类型的属性。然后，内存分析师可以使用此方法来构建和管理内存中的图形。</p>
                  <div class="infoboxnote" id="GUID-7A2037E1-2DB7-40A2-AA37-0A91D0E34D00__GUID-4C489E91-0C00-47B4-BCA6-59493964217B">
                     <p class="notep1">注意：</p>
                     <p>两表的方法主要是针对内存的分析师对现有提供图形数据蓝图基于Java的API，并文本索引<span class="bold">不</span>与两个表的方式工作。
                     </p>
                     <p>图形数据更改跟踪仅在使用属性图模式方法时可用。</p>
                  </div>
                  <p>以下主题重点介绍如何使用双表模式创建属性图，以及如何对此数据执行读写操作。</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-AE6022AC-2B38-46AA-83E7-3A94DD2648CD">准备两表模式</a><br></li>
                     <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-D494CD8D-80D7-45B0-A6FF-E35988AE5A65">使用双表模式在属性图中存储数据</a><br></li>
                     <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-977CBAFC-9B5B-4C48-BF65-626E410A85FE">使用双表模式从属性图中读取数据</a><br></li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="using-property-graphs-oracle-database.html#GUID-4B5AF258-79BE-418D-84FF-9B8A692B8604" title="本章提供有关在Oracle数据库环境中创建，存储和使用属性图数据的概念和用法信息。">在Oracle数据库环境中使用属性图</a></p>
                     </div>
                  </div>
               </div>
               
               <div class="props_rev_3"><a id="GUID-AE6022AC-2B38-46AA-83E7-3A94DD2648CD" name="GUID-AE6022AC-2B38-46AA-83E7-3A94DD2648CD"></a><h4 id="SPGDG-GUID-AE6022AC-2B38-46AA-83E7-3A94DD2648CD" class="sect4"><span class="enumeration_section">2.12.1</span>准备双表模式</h4>
                  <div>
                     <p><code class="codeph">OraclePropertyGraphUtils.prepareTwoTablesGraphVertexTab</code>允许您使用两表模式自定义顶点表的模式，以将所有顶点存储在图形中。此操作需要连接到Oracle数据库，表所有者，表名以及指定属性名称及其数据类型的两个数组。默认情况下，生成的表的表模式包括属性<code class="codeph">VID</code> ，它表示表的主键并映射到顶点ID。</p>
                     <p>以下代码段使用两表模式创建顶点表。在这种情况下，生成的表<code class="codeph">employeesNodes</code>将包括四个属性： <code class="codeph">name</code> ， <code class="codeph">age</code> ， <code class="codeph">address</code>和<code class="codeph">SSN</code> （社会安全号码）。顶点表的主键是生成的属性<code class="codeph">VID</code> 。</p><pre class="pre codeblock"><code>导入oracle.pgx.common.types。财产类型; List &lt;String&gt; propertyNames = new ArrayList &lt;String&gt;（）; propertyNames.addAll（new String [4] {“name”，“age”，“address”，“SSN”}）; List &lt;PropertyType&gt; = new ArrayList &lt;PropertyType&gt;（）; propertyType.add（属性类型。串）; propertyType.add（属性类型。整数）; propertyType.add（属性类型。串）; propertyType.add（属性类型。串）; <span class="bold">OraclePropertyGraphUtils.prepareTwoTablesGraphVertexTab（conn / *连接对象* /，pg / *表所有者* /，“employeesNodes”/ *顶点表名* /，propertyNames / *属性名称* /，propertyTypes / *属性数据类型* /，“pgts “/ *表空间* /，null / *存储选项* /，true / * no logging * /）;</span>
</code></pre><p>上面的代码生成一个表模式，如下所示：</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE employeenodes（VID号不为空，NAME nvarchar2（15000），AGE整数，ADDRESS nvarchar2（15000），SSN nvarchar2（15000），CONSTRAINT employenodes_pk PRIMARY KEY（VID））;</pre><p>同样， <code class="codeph">OraclePropertyGraphUtils.prepareTwoTablesGraphEdgeTab</code>允许您使用双表模式自定义边表的模式，以存储图形中的所有边。此操作需要连接到Oracle数据库，表所有者，表名，指定属性名称及其数据类型的两个数组。默认情况下，生成的表的表模式包括以下属性： <code class="codeph">EID</code> ，表示表的主键并映射到边ID; <code class="codeph">EL</code> ，映射到边缘标签;以及源和目标顶点ID的<code class="codeph">SVID</code>和<code class="codeph">DVID</code> 。
                     </p>
                     <p>以下代码段使用两表模式创建边表。在这种情况下，生成的表<code class="codeph">organizationEdges</code>将包含名为<code class="codeph">weight</code>的属性。顶点表的主键是生成的属性<code class="codeph">EID</code> ，它是表模式的默认属性，映射到顶点的ID（长值）值。
                     </p><pre class="pre codeblock"><code>导入oracle.pgx.common.types。财产类型; List &lt;String&gt; propertyNames = new ArrayList &lt;String&gt;（）; propertyNames.addAll（new String [1] {“weight”}）; List &lt;PropertyType&gt; = new ArrayList &lt;PropertyType&gt;（）; propertyType.add（属性类型。双）; <span class="bold">OraclePropertyGraphUtils.prepareTwoTablesGraphEdgeTab（conn / *连接对象* /，pg / *表所有者* /，organizationEdges“/ *边缘表名称* /，propertyNames / *属性名称* /，propertyTypes / *属性数据类型* /，”pgts“ / *表空间* /，null / *存储选项* /，true / * no logging * /）;</span>
</code></pre><p>上面的代码生成一个表结构，如下所示：</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE organizationedges（EID号不为空，SVID号不为空，DVID号不为空，EL nvarchar2（3100），WEIGHT号，CONSTRAINT organizationedges_pk PRIMARY KEY（EID））;</pre><p>请注意，如果表已存在，则<code class="codeph">prepareTwoTablesGraphEdgeTab</code>和<code class="codeph">prepareTwoTablesGraphEdgeTab</code>都将截断表内容。
                     </p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="using-property-graphs-oracle-database.html#GUID-7A2037E1-2DB7-40A2-AA37-0A91D0E34D00" title="对于具有相对固定，简单数据结构的属性图，您不需要灵活的&lt;graph_name&gt; VT $和&lt;graph_name&gt; GE $键/值数据表的顶点和边，您可以使用两表模式来实现更好的运行时性能。">使用双表模式处理属性图</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="props_rev_3"><a id="GUID-D494CD8D-80D7-45B0-A6FF-E35988AE5A65" name="GUID-D494CD8D-80D7-45B0-A6FF-E35988AE5A65"></a><h4 id="SPGDG-GUID-D494CD8D-80D7-45B0-A6FF-E35988AE5A65" class="sect4"><span class="enumeration_section">2.12.2</span>使用双表模式在属性图中存储数据</h4>
                  <div>
                     <p>要使用双表模式将一组顶点加载到顶点表中，可以使用API <code class="codeph">OraclePropertyGraphUtils.writeTwoTablesGraphVertexAndProperties</code> 。此操作采用TinkerPop蓝图Vertex对象的Iterable（或Iterator）数组，并读取顶点表模式中定义的属性的ID和值。基于此信息，顶点稍后将作为新行插入顶点表中。请注意，如果顶点不包含架构中定义的属性，则该关联列的值将设置为NULL。</p>
                     <p>以下代码段使用<code class="codeph">OraclePropertyGraph</code> API创建属性图<code class="codeph">employeesGraphDAL</code> ，并加载两个顶点和边。然后，它会创建一个顶点表<code class="codeph">employeesNodes</code>使用两表的模式，并从顶点数据填充它<code class="codeph">employeesGraphDAL</code> 。请注意，顶点<code class="codeph">v1</code>中的属性<code class="codeph">email</code>未加载到<code class="codeph">employeesNode</code>表中，因为它未在架构中定义。此外，顶点<code class="codeph">v2</code>的属性<code class="codeph">SSN</code>设置为NULL，因为它未在顶点中定义。
                     </p><pre class="pre codeblock"><code>//创建employeesGraphDAL导入oracle.pg.rdbms。*; Oracle oracle = new Oracle（jdbcURL，用户名，密码）; OraclePropertyGraph opgEmployees = OraclePropertyGraph.getInstance（oracle，“employeesGraphDAL”）; //创建顶点v1并将其属性指定为键值对Vertex v1 = opgEmployees.addVertex（1l）; v1.setProperty（“age”，Integer.valueOf（31））; v1.setProperty（“name”，“Alice”）; v1.setProperty（“地址”，“主街12”）; v1.setProperty（“email”，“alice@mymail.com”）; v1.setProperty（“SSN”，“123456789”）; Vertex v2 = opgEmployees.addVertex（2l）; v2.setProperty（“age”，Integer.valueOf（27））; v2.setProperty（“name”，“Bob”）; v2.setProperty（“地址”，“芝麻街334”）; //添加边e1边e1 = opgEmployees.addEdge（1l，v1，v2，“managerOf”）; e1.setProperty（“重量”，0.5d）; opgEmployees.commit（）; //使用两个表模式导入oracle.pgx.common.types准备顶点表。财产类型; List &lt;String&gt; propertyNames = new ArrayList &lt;String&gt;（）; propertyNames.addAll（new String [4] {“name”，“age”，“address”，“SSN”}）; List &lt;PropertyType&gt; = new ArrayList &lt;PropertyType&gt;（）; propertyType.add（属性类型。串）; propertyType.add（属性类型。整数）; propertyType.add（属性类型。串）; propertyType.add（属性类型。串）; Connection conn = opgEmployees.getOracle（）。clone（）。getConnection（）; / *从属性图实例克隆连接* / <span class="bold">OraclePropertyGraphUtils.prepareTwoTablesGraphVertexTab（conn / *连接对象* /，pg / *表所有者* /，“employeesNodes”/ *顶点表名* /，propertyNames / *属性名* / ，propertyTypes / *属性数据类型* /，“pgts”/ *表空间* /，null / *存储选项* /，true / * no logging * /）;</span> //从employeesDAL图中获取顶点Iterable &lt;Vertex&gt; vertices = opgEmployees.getVertices（）; <span class="bold">//使用双表模式将顶点加载到顶点表中</span> Connection [] conns = new Connection [1]; / *连接数组大小定义并行度（多线程）* / conns [1] = conn; <span class="bold">OraclePropertyGraphUtils.writeTwoTablesGraphVertexAndProperties（conn / * Connectionobject * /，pg / * table owner * /，“employeesNodes”/ * vertex table name * /，1000 / *批量大小* /，新的Iterable [] {vertices} / *顶点数组iterables * /）;</span> 
</code></pre><p>要使用双表模式将一组边加载到边表中，可以使用API <code class="codeph">OraclePropertyGraphUtils.writeTwoTablesGraphEdgesAndProperties</code> 。此操作采用Blueprints Edge对象的Iterable（或Iterator）数组，并读取ID，EL，SVID，DVID以及边表模式中定义的属性的值。根据此信息，边缘稍后将作为新行插入边缘表中。请注意，如果边缘不包含架构中定义的属性，则该给定列的值将设置为NULL。</p>
                     <p>以下代码段使用<code class="codeph">OraclePropertyGraph</code> API创建属性图<code class="codeph">employeesGraphDAL</code> ，并加载两个顶点和边。然后，它使用两表模式创建顶点表<code class="codeph">organizationEdges</code> ，并使用<code class="codeph">employeesGraphDAL</code>边缘的数据填充它。</p><pre class="pre codeblock"><code>//创建employeesGraphDAL导入oracle.pg.rdbms。*; Oracle oracle = new Oracle（jdbcURL，用户名，密码）; OraclePropertyGraph opgEmployees = OraclePropertyGraph.getInstance（oracle，“employeesGraphDAL”）; //创建顶点v1并将其属性指定为键值对Vertex v1 = opgEmployees.addVertex（1l）; v1.setProperty（“age”，Integer.valueOf（31））; v1.setProperty（“name”，“Alice”）; v1.setProperty（“地址”，“主街12”）; v1.setProperty（“email”，“alice@mymail.com”）; v1.setProperty（“SSN”，“123456789”）; Vertex v2 = opgEmployees.addVertex（2l）; v2.setProperty（“age”，Integer.valueOf（27））; v2.setProperty（“name”，“Bob”）; v2.setProperty（“地址”，“芝麻街334”）; //添加边e1边e1 = opgEmployees.addEdge（1l，v1，v2，“managerOf”）; e1.setProperty（“重量”，0.5d）; opgEmployees.commit（）; //使用两个表模式导入oracle.pgx.common.types准备边表。财产类型; Connection conn = opgEmployees.getOracle（）。clone（）。getConnection（）; / *从属性图实例克隆连接* / List &lt;String&gt; propertyNames = new ArrayList &lt;String&gt;（）; propertyNames.addAll（new String [1] {“weight”}）; List &lt;PropertyType&gt; = new ArrayList &lt;PropertyType&gt;（）; propertyType.add（属性类型。双）; <span class="bold">OraclePropertyGraphUtils.prepareTwoTablesGraphEdgeTab（conn / *连接对象* /，pg / *表所有者* /，organizationEdges“/ *边缘表名称* /，propertyNames / *属性名称* /，propertyTypes / *属性数据类型* /，”pgts“ / *表空间* /，null / *存储选项* /，true / * no logging * /）;</span> //从employeesDAL图中获取边Iterator &lt;Edge&gt; edges = opgEmployees.getEdges（）。iterator（）; <span class="bold">/ /使用双表模式将边加载到边表中</span> Connection [] conns = new Connection [1]; / *连接数组大小定义并行度（多线程）* / conns [1] = conn; <span class="bold">OraclePropertyGraphUtils。 writeTwoTablesGraphVertexAndProperties（conn / *连接对象* /，pg / *表所有者* /，“organizationEdges”/ *边表名* /，1000 / *批量大小* /，新迭代器[] {edges} / *迭代器数组边缘* /）;</span> 
</code></pre><p>要优化存储操作的性能，可以在调用<code class="codeph">writeTwoTablesGraph</code> API时指定一组标志和提示。这些提示包括：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><span class="bold">DOP</span> ：并行度。连接数组的大小定义加载数据时使用的并行度。这决定了读取Iterables时生成的块数以及将数据加载到表中时使用的加载器线程数。
                           </p>
                        </li>
                        <li>
                           <p><span class="bold">批处理大小</span> ：一个整数，指定在批处理模式下用于Oracle更新语句的批处理大小。建议的批次大小为1000。
                           </p>
                        </li>
                     </ul>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="using-property-graphs-oracle-database.html#GUID-7A2037E1-2DB7-40A2-AA37-0A91D0E34D00" title="对于具有相对固定，简单数据结构的属性图，您不需要灵活的&lt;graph_name&gt; VT $和&lt;graph_name&gt; GE $键/值数据表的顶点和边，您可以使用两表模式来实现更好的运行时性能。">使用双表模式处理属性图</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="props_rev_3"><a id="GUID-977CBAFC-9B5B-4C48-BF65-626E410A85FE" name="GUID-977CBAFC-9B5B-4C48-BF65-626E410A85FE"></a><h4 id="SPGDG-GUID-977CBAFC-9B5B-4C48-BF65-626E410A85FE" class="sect4"><span class="enumeration_section">2.12.3</span>使用双表模式从属性图中读取数据</h4>
                  <div>
                     <p>要使用双表模式从顶点表中读取顶点子集，可以使用API <code class="codeph">OraclePropertyGraphUtils.readTwoTablesGraphVertexAndProperties</code> 。此操作返回一个<code class="codeph">ResultSet</code>对象数组，其中包含在顶点表的相应拆分中找到的所有行。数组中的每个<code class="codeph">ResultSet</code>对象使用提供的一个连接来从相应的拆分中获取顶点行。拆分由指定的总拆分数决定。
                     </p>
                     <p>整数ID（在[0，N-1]范围内）被分配给具有N个分裂的顶点表中的分裂。这样，查询的拆分子集将包括ID值在开始拆分ID和起始拆分ID之间的范围加上连接数组大小的那些拆分。如果总和大于拆分总数，则查询的拆分子集将包含ID在[start split ID，N-1]范围内的拆分。</p>
                     <p>以下代码使用两个表模式从顶点表中读取所有顶点，总共使用1个拆分。请注意，您可以通过在<code class="codeph">OraclePropertyGraph</code>上执行API轻松创建Blueprints Vertex Iterables数组。检索到的顶点将包括顶点表模式中定义的所有属性。
                     </p><pre class="pre codeblock"><code>ResultSet [] rsAr = readTwoTablesGraphVertexAndProperties（conns，“pg”/ * table owner * /，“employeeNodes / * vertex table name * /，1 / * Total Splits * /，0 / * Start Split）; Iterable &lt;Vertex&gt; [] vertices = getVerticesPartitioned（rsAr / * ResultSet array * /，true / * skip store to cache * /，null / * vertex filter callback * /，null / * optimization flag * /）;</code></pre><p>要优化读取性能，可以指定要从表中读取的每个顶点检索的属性名称列表。</p>
                     <p>以下代码使用<code class="codeph">OraclePropertyGraph</code> API创建属性图<code class="codeph">employeesGraphDAL</code> ，并加载两个顶点和一个边。然后，它使用两表模式创建顶点表<code class="codeph">employeNodes</code> ，并使用<code class="codeph">employeesGraphDAL</code>顶点的数据填充它。最后，它仅使用name属性从顶点表中读取顶点。
                     </p><pre class="pre codeblock"><code>//创建employeesGraphDAL导入oracle.pg.rdbms。*; Oracle oracle = new Oracle（jdbcURL，用户名，密码）; OraclePropertyGraph opgEmployees = OraclePropertyGraph.getInstance（oracle，“employeesGraphDAL”）; //创建顶点v1并将其属性指定为键值对Vertex v1 = opgEmployees.addVertex（1l）; v1.setProperty（“age”，Integer.valueOf（31））; v1.setProperty（“name”，“Alice”）; v1.setProperty（“地址”，“主街12”）; v1.setProperty（“email”，“alice@mymail.com”）; v1.setProperty（“SSN”，“123456789”）; Vertex v2 = opgEmployees.addVertex（2l）; v2.setProperty（“age”，Integer.valueOf（27））; v2.setProperty（“name”，“Bob”）; v2.setProperty（“地址”，“芝麻街334”）; //添加边e1边e1 = opgEmployees.addEdge（1l，v1，v2，“managerOf”）; e1.setProperty（“重量”，0.5d）; opgEmployees.commit（）; //使用两个表模式导入oracle.pgx.common.types准备顶点表。财产类型; List &lt;String&gt; propertyNames = new ArrayList &lt;String&gt;（）; propertyNames.addAll（new String [4] {“name”，“age”，“address”，“SSN”}）; List &lt;PropertyType&gt; = new ArrayList &lt;PropertyType&gt;（）; propertyType.add（属性类型。串）; propertyType.add（属性类型。整数）; propertyType.add（属性类型。串）; propertyType.add（属性类型。串）; Connection conn = opgEmployees.getOracle（）。clone（）。getConnection（）; / *从属性图实例克隆连接* / OraclePropertyGraphUtils.prepareTwoTablesGraphVertexTab（conn / *连接对象* /，pg / *表所有者* /，“employeesNodes”/ *顶点表名* /，propertyNames / *属性名* / ，propertyTypes / *属性数据类型* /，“pgts”/ *表空间* /，null / *存储选项* /，true / * no logging * /）; //从employeesDAL图中获取顶点Iterable &lt;Vertex&gt; vertices = opgEmployees.getVertices（）; //使用两个表模式将顶点加载到顶点表中Connection [] conns = new Connection [1]; / *连接数组大小定义并行度（多线程）* / conns [1] = conn; OraclePropertyGraphUtils.writeTwoTablesGraphVertexAndProperties（conn / *连接对象* /，pg / *表所有者* /，“employeesNodes”/ *顶点表名* /，1000 / *批量大小* /，新的Iterable [] {vertices} / *数组顶点迭代* /）; //读取顶点（仅使用name属性）List &lt;String&gt; vPropertyNames = new ArrayList &lt;String&gt;（）; vPropertyNames.add（ “名称”）; <span class="bold">ResultSet [] rsAr = readTwoTablesGraphVertexAndProperties（conns，“pg”/ * table owner * /，“employeeNodes / * vertex table name * /，vPropertyNames / *属性名称列表* /，1 / * Total Splits * /，0 / *开始分割）; Iterable &lt;Vertex&gt; [] vertices = getVerticesPartitioned（rsAr / * ResultSet数组* /，true / * skip store to cache * /，null / * vertex filter callback * /，null / * optimization flag * /）;</span> for（int idx = 0; vertices.length; idx ++）{Iterator &lt;Vertex&gt; it = vertices [idx] .iterator（）; while（it.hasNext（））{System.out.println（it.next（）） ;}}</code></pre><p>上面的代码生成类似于以下内容的输出：</p><pre class="oac_no_warn" dir="ltr">顶点ID 1 {名称：str：Alice}顶点ID 2 {名称：str：Bob}</pre><p>要使用双表模式从边表读取边的子集，可以使用API <code class="codeph">OraclePropertyGraphUtils.readTwoTablesGraphEdgeAndProperties</code> 。此操作返回一个<code class="codeph">ResultSet</code>对象数组，其中包含在顶点表的相应拆分中找到的所有行。数组中的每个<code class="codeph">ResultSet</code>对象使用提供的一个连接来从相应的拆分中获取顶点行。拆分由指定的总拆分数决定。
                     </p>
                     <p>与读取顶点所做的类似，整数ID（在[0，N-1]范围内）被分配给具有N个分割的顶点表中的分割。查询的拆分子集将包含ID值在开始拆分ID和起始拆分ID之间的范围加上连接数组大小的拆分。</p>
                     <p>以下代码使用<code class="codeph">OraclePropertyGraph</code> API创建属性图<code class="codeph">employeesGraphDAL</code> ，并加载两个顶点和一个边。然后，它使用两表模式创建边缘表<code class="codeph">organizationEdges</code> ，并使用<code class="codeph">employeesGraphDAL</code>边缘的数据填充它。最后，它仅使用名称权重从表中读取边缘。
                     </p><pre class="pre codeblock"><code>//创建employeesGraphDAL导入oracle.pg.rdbms。*; Oracle oracle = new Oracle（jdbcURL，用户名，密码）; OraclePropertyGraph opgEmployees = OraclePropertyGraph.getInstance（oracle，“employeesGraphDAL”）; //创建顶点v1并将其属性指定为键值对Vertex v1 = opgEmployees.addVertex（1l）; v1.setProperty（“age”，Integer.valueOf（31））; v1.setProperty（“name”，“Alice”）; v1.setProperty（“地址”，“主街12”）; v1.setProperty（“email”，“alice@mymail.com”）; v1.setProperty（“SSN”，“123456789”）; Vertex v2 = opgEmployees.addVertex（2l）; v2.setProperty（“age”，Integer.valueOf（27））; v2.setProperty（“name”，“Bob”）; v2.setProperty（“地址”，“芝麻街334”）; //添加边e1边e1 = opgEmployees.addEdge（1l，v1，v2，“managerOf”）; e1.setProperty（“重量”，0.5d）; opgEmployees.commit（）; //使用两个表模式导入oracle.pgx.common.types准备边表。财产类型; List &lt;String&gt; propertyNames = new ArrayList &lt;String&gt;（）; propertyNames.addAll（new String [4] {“weight”}）; List &lt;PropertyType&gt; = new ArrayList &lt;PropertyType&gt;（）; propertyType.add（属性类型。双）; Connection conn = opgEmployees.getOracle（）。clone（）。getConnection（）; / *从属性图实例克隆连接* / OraclePropertyGraphUtils.prepareTwoTablesGraphEdgeTab（conn / *连接对象* /，pg / *表所有者* /，“organizationEdges”/ *边表名* /，propertyNames / *属性名* / ，propertyTypes / *属性数据类型* /，“pgts”/ *表空间* /，null / *存储选项* /，true / * no logging * /）; //从employeesDAL图中获取边缘Iterable &lt;Edge&gt; edges = opgEmployees.getVertices（）; //使用两个表模式将顶点加载到顶点表中Connection [] conns = new Connection [1]; / *连接数组大小定义并行度（多线程）* / conns [1] = conn; OraclePropertyGraphUtils.writeTwoTablesGraphEdgeAndProperties（conn / *连接对象* /，pg / *表所有者* /，organizationEdges“/ *边缘表名称* /，1000 / *批量大小* /，新的Iterable [] {edges} / *数组边缘iterables * /）; //读取边（仅使用权重属性）List &lt;String&gt; ePropertyNames = new ArrayList &lt;String&gt;（）; ePropertyNames.add（“weight”）; <span class="bold">ResultSet [] rsAr = readTwoTablesGraphVertexAndProperties（conns，“pg “/ * table owner * /，”organizationEdges / * edge table name * /，ePropertyNames / *属性名称列表* /，1 / * Total Splits * /，0 / * Start Split）; Iterable &lt;Edge&gt; [] edges = getEdgesPartitioned（rsAr / * ResultSet数组* /，true / * skip store to cache * /，null / * edge filter callback * /，null / * optimization flag * /）;</span> for（int idx = 0; edges.length; idx ++）{Iterator &lt;Edge&gt; it = edges [idx] .iterator（）; while（it.hasNext（））{System.out.println（it.next（））; }}</code></pre><p>上面的代码生成类似于以下内容的输出：</p><pre class="oac_no_warn" dir="ltr">来自顶点ID 1的边ID 1 {} = [references] =&gt;顶点ID 2 {} edgeKV [{weight：dbl：0.5}]</pre></div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="using-property-graphs-oracle-database.html#GUID-7A2037E1-2DB7-40A2-AA37-0A91D0E34D00" title="对于具有相对固定，简单数据结构的属性图，您不需要灵活的&lt;graph_name&gt; VT $和&lt;graph_name&gt; GE $键/值数据表的顶点和边，您可以使用两表模式来实现更好的运行时性能。">使用双表模式处理属性图</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div>
            <div class="props_rev_3"><a id="GUID-7FC09376-F237-41E8-B0FE-9D1044A59FBB" name="GUID-7FC09376-F237-41E8-B0FE-9D1044A59FBB"></a><h3 id="SPGDG-GUID-7FC09376-F237-41E8-B0FE-9D1044A59FBB" class="sect3"><span class="enumeration_section">2.13</span> Oracle平面文件格式定义</h3>
               <div>
                  <p>可以在两个平面文件中定义属性图，特别是顶点和边的描述文件。</p>
                  <p>可以在两个平面文件中定义属性图，特别是顶点和边的描述文件。</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-2716F004-2C67-489A-87E2-957C5AEAA7D4">关于属性图描述文件</a><br></li>
                     <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-20FD630A-CE49-44F5-A117-EE1BA5CC5DB3">边缘文件</a><br></li>
                     <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-18026FD1-4EF5-4CE8-A6A2-73A31FE44AFF">顶点文件</a><br></li>
                     <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-7323744B-BD8D-4179-91D3-93C92461D92B">编码特殊字符</a><br></li>
                     <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-14C10BAB-3CE4-4D5E-BA09-7C6697F226FE">Oracle平面文件格式的示例属性图</a><br></li>
                     <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-EFA9E4E7-F854-4224-8828-F8843DE91D8B">将Oracle数据库表转换为Oracle定义的属性图平面文件</a><br></li>
                     <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-269EA431-B8C2-45F5-9338-482D4D4E34F5">将顶点和边的CSV文件转换为Oracle定义的属性图平面文件</a><br></li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="using-property-graphs-oracle-database.html#GUID-4B5AF258-79BE-418D-84FF-9B8A692B8604" title="本章提供有关在Oracle数据库环境中创建，存储和使用属性图数据的概念和用法信息。">在Oracle数据库环境中使用属性图</a></p>
                     </div>
                  </div>
               </div>
               
               <div class="props_rev_3"><a id="GUID-2716F004-2C67-489A-87E2-957C5AEAA7D4" name="GUID-2716F004-2C67-489A-87E2-957C5AEAA7D4"></a><h4 id="SPGDG-GUID-2716F004-2C67-489A-87E2-957C5AEAA7D4" class="sect4"><span class="enumeration_section">2.13.1</span>关于属性图描述文件</h4>
                  <div>
                     <p>一对文件描述了属性图：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><span class="bold">顶点文件</span> ：描述属性图的顶点。此文件具有<code class="codeph">.opv</code>文件扩展名。
                           </p>
                        </li>
                        <li>
                           <p><span class="bold">边缘文件</span> ：描述属性图的边缘。此文件具有<code class="codeph">.ope</code>文件扩展名。
                           </p>
                        </li>
                     </ul>
                     <p>建议这两个文件共享相同的基本名称。例如， <code class="codeph">simple.opv</code>和<code class="codeph">simple.ope</code>定义属性图。
                     </p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="using-property-graphs-oracle-database.html#GUID-7FC09376-F237-41E8-B0FE-9D1044A59FBB" title="可以在两个平面文件中定义属性图，特别是顶点和边的描述文件。">Oracle平面文件格式定义</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="props_rev_3"><a id="GUID-20FD630A-CE49-44F5-A117-EE1BA5CC5DB3" name="GUID-20FD630A-CE49-44F5-A117-EE1BA5CC5DB3"></a><h4 id="SPGDG-GUID-20FD630A-CE49-44F5-A117-EE1BA5CC5DB3" class="sect4"><span class="enumeration_section">2.13.2</span>边缘文件</h4>
                  <div>
                     <p>边文件中的每一行都是描述属性图边缘的记录。记录可以描述边的一个键值属性，因此多个记录用于描述具有多个属性的边。</p>
                     <p>记录包含以逗号分隔的九个字段。每条记录必须包含八个逗号来分隔所有字段，无论它们是否具有值：</p>
                     <p><span class="italic">edge_ID，source_vertex_ID，destination_vertex_ID，edge_label，key_name，value_type，value，value，value</span></p>
                     <p>下表描述了组成边缘文件记录的字段。</p>
                     <div class="tblformal" id="GUID-20FD630A-CE49-44F5-A117-EE1BA5CC5DB3__EDGEFILERECORDFORMAT-112820D6">
                        <p class="titleintable">表2-3边缘文件记录格式</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="边缘文件记录格式" width="100%" border="1" summary="Edge file field descriptions. Columns are Field Number, Name, and Description." frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="12%" id="d4109e11554">场号</th>
                                 <th align="left" valign="bottom" width="32%" id="d4109e11557">名称</th>
                                 <th align="left" valign="bottom" width="56%" id="d4109e11560">描述</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="12%" id="d4109e11565" headers="d4109e11554 ">
                                    <p>1</p>
                                 </td>
                                 <td align="left" valign="top" width="32%" headers="d4109e11565 d4109e11557 ">
                                    <p><span class="italic">edge_ID</span></p>
                                 </td>
                                 <td align="left" valign="top" width="56%" headers="d4109e11565 d4109e11560 ">
                                    <p>唯一标识边的整数</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="12%" id="d4109e11576" headers="d4109e11554 ">
                                    <p>2</p>
                                 </td>
                                 <td align="left" valign="top" width="32%" headers="d4109e11576 d4109e11557 ">
                                    <p><span class="italic">source_vertex_ID</span></p>
                                 </td>
                                 <td align="left" valign="top" width="56%" headers="d4109e11576 d4109e11560 ">
                                    <p>边缘的传出尾部的<span class="italic">vertex_ID</span> 。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="12%" id="d4109e11590" headers="d4109e11554 ">
                                    <p>3</p>
                                 </td>
                                 <td align="left" valign="top" width="32%" headers="d4109e11590 d4109e11557 ">
                                    <p><span class="italic">destination_vertex_ID</span></p>
                                 </td>
                                 <td align="left" valign="top" width="56%" headers="d4109e11590 d4109e11560 ">
                                    <p>边缘入射头的<span class="italic">vertex_ID</span> 。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="12%" id="d4109e11604" headers="d4109e11554 ">
                                    <p>4</p>
                                 </td>
                                 <td align="left" valign="top" width="32%" headers="d4109e11604 d4109e11557 ">
                                    <p><span class="italic">edge_label</span></p>
                                 </td>
                                 <td align="left" valign="top" width="56%" headers="d4109e11604 d4109e11560 ">
                                    <p>边缘的编码标签，描述两个顶点之间的关系</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="12%" id="d4109e11615" headers="d4109e11554 ">
                                    <p>五</p>
                                 </td>
                                 <td align="left" valign="top" width="32%" headers="d4109e11615 d4109e11557 ">
                                    <p><span class="italic">KEY_NAME</span></p>
                                 </td>
                                 <td align="left" valign="top" width="56%" headers="d4109e11615 d4109e11560 ">
                                    <p>键值对中键的编码名称</p>
                                    <p>如果边没有属性，则输入空格（ <code class="codeph">%20</code> ）。此示例描述了没有属性的边100：</p><pre class="oac_no_warn" dir="ltr">100,1,2，喜欢，％20 ,,,,</pre></td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="12%" id="d4109e11633" headers="d4109e11554 ">
                                    <p>6</p>
                                 </td>
                                 <td align="left" valign="top" width="32%" headers="d4109e11633 d4109e11557 ">
                                    <p><span class="italic">值类型</span></p>
                                 </td>
                                 <td align="left" valign="top" width="56%" headers="d4109e11633 d4109e11560 ">
                                    <p>一个整数，表示键值对中值的数据类型：</p>
                                    <ul class="simple" style="list-style-type:none;padding-left:0">
                                       <li><code class="codeph">1</code>字符串</li>
                                       <li><code class="codeph">2</code>整数</li>
                                       <li><code class="codeph">3</code>漂浮</li>
                                       <li><code class="codeph">4</code>双</li>
                                       <li><code class="codeph">5</code>时间戳（日期）</li>
                                       <li><code class="codeph">6</code>布尔值</li>
                                       <li><code class="codeph">7</code>长整数</li>
                                       <li><code class="codeph">8</code>短整数</li>
                                       <li><code class="codeph">9</code>字节</li>
                                       <li><code class="codeph">10</code>字符</li>
                                       <li><code class="codeph">20</code>空间</li>
                                       <li><code class="codeph">101</code>序列化的Java对象</li>
                                    </ul>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="12%" id="d4109e11694" headers="d4109e11554 ">
                                    <p>7</p>
                                 </td>
                                 <td align="left" valign="top" width="32%" headers="d4109e11694 d4109e11557 ">
                                    <p><span class="italic">值</span></p>
                                 </td>
                                 <td align="left" valign="top" width="56%" headers="d4109e11694 d4109e11560 ">
                                    <p><span class="italic">key_name</span>的编码非null值，既不是数字也不是时间戳（日期）</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="12%" id="d4109e11708" headers="d4109e11554 ">
                                    <p>8</p>
                                 </td>
                                 <td align="left" valign="top" width="32%" headers="d4109e11708 d4109e11557 ">
                                    <p><span class="italic">值</span></p>
                                 </td>
                                 <td align="left" valign="top" width="56%" headers="d4109e11708 d4109e11560 ">
                                    <p><span class="italic">key_name</span>的编码非空值，当它是数字时</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="12%" id="d4109e11722" headers="d4109e11554 ">
                                    <p>9</p>
                                 </td>
                                 <td align="left" valign="top" width="32%" headers="d4109e11722 d4109e11557 ">
                                    <p><span class="italic">值</span></p>
                                 </td>
                                 <td align="left" valign="top" width="56%" headers="d4109e11722 d4109e11560 ">
                                    <p>当<span class="italic">key_name</span>为时间戳（日期）时， <span class="italic">key_name</span>的编码非空值</p>
                                    <p>使用Java <code class="codeph">SimpleDateFormat</code>类来标识日期的格式。此示例描述了<code class="codeph">2015-03-26Th00:00:00.000-05:00</code>的日期格式：</p><pre class="oac_no_warn" dir="ltr">SimpleDateFormat sdf = new SimpleDateFormat（“yyyy-MM-dd'T'HH：mm：ss。SSSXXX“）; encode（sdf.format（（java.util。日期）价值））;</pre></td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <p><span class="bold">必需的边缘分组</span> ：边缘可以具有多个属性，边缘文件包括边缘ID和该边缘属性的每个组合的记录（由平面文件中的单行文本表示）。在边缘文件中，每个边缘的所有记录必须组合在一起（即，没有任何其他边缘的介入记录。您可以以任何方式完成此操作，但一种方便的方法是按边缘ID按升序（或降序）排序边缘文件记录。 （但是，请注意，边缘文件不需要按边ID排序所有记录;这只是实现分组要求的一种方式。）
                     </p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="using-property-graphs-oracle-database.html#GUID-7FC09376-F237-41E8-B0FE-9D1044A59FBB" title="可以在两个平面文件中定义属性图，特别是顶点和边的描述文件。">Oracle平面文件格式定义</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="props_rev_3"><a id="GUID-18026FD1-4EF5-4CE8-A6A2-73A31FE44AFF" name="GUID-18026FD1-4EF5-4CE8-A6A2-73A31FE44AFF"></a><h4 id="SPGDG-GUID-18026FD1-4EF5-4CE8-A6A2-73A31FE44AFF" class="sect4"><span class="enumeration_section">2.13.3</span>顶点文件</h4>
                  <div>
                     <p>顶点文件中的每一行都是描述属性图顶点的记录。记录可以描述顶点的一个键值属性，因此多个记录/行用于描述具有多个属性的顶点。</p>
                     <p>记录包含以逗号分隔的六个字段。每条记录必须包含五个逗号来分隔所有字段，无论它们是否具有值：</p>
                     <p><span class="italic">vertex_ID，key_name，value_type，value，value，value</span></p>
                     <p>下表描述了组成顶点文件记录的字段。</p>
                     <div class="tblformal" id="GUID-18026FD1-4EF5-4CE8-A6A2-73A31FE44AFF__VERTEXFILERECORDFORMAT-1127FAA7">
                        <p class="titleintable">表2-4顶点文件记录格式</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="顶点文件记录格式" width="100%" border="1" summary="Vertex file field descriptions. Columns are Field Number, Name, and Description." frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="13%" id="d4109e11824">场号</th>
                                 <th align="left" valign="bottom" width="28%" id="d4109e11827">名称</th>
                                 <th align="left" valign="bottom" width="59%" id="d4109e11830">描述</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="13%" id="d4109e11835" headers="d4109e11824 ">
                                    <p>1</p>
                                 </td>
                                 <td align="left" valign="top" width="28%" headers="d4109e11835 d4109e11827 ">
                                    <p><span class="italic">vertex_ID</span></p>
                                 </td>
                                 <td align="left" valign="top" width="59%" headers="d4109e11835 d4109e11830 ">
                                    <p>唯一标识顶点的整数</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="13%" id="d4109e11846" headers="d4109e11824 ">
                                    <p>2</p>
                                 </td>
                                 <td align="left" valign="top" width="28%" headers="d4109e11846 d4109e11827 ">
                                    <p><span class="italic">KEY_NAME</span></p>
                                 </td>
                                 <td align="left" valign="top" width="59%" headers="d4109e11846 d4109e11830 ">
                                    <p>键值对中键的名称</p>
                                    <p>如果顶点没有属性，则输入空格（ <code class="codeph">%20</code> ）。此示例描述了没有属性的顶点1：</p><pre class="oac_no_warn" dir="ltr">1，％20 ,,,,</pre></td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="13%" id="d4109e11864" headers="d4109e11824 ">
                                    <p>3</p>
                                 </td>
                                 <td align="left" valign="top" width="28%" headers="d4109e11864 d4109e11827 ">
                                    <p><span class="italic">值类型</span></p>
                                 </td>
                                 <td align="left" valign="top" width="59%" headers="d4109e11864 d4109e11830 ">
                                    <p>一个整数，表示键值对中值的数据类型：</p>
                                    <ul class="simple" style="list-style-type:none;padding-left:0">
                                       <li><code class="codeph">1</code>字符串</li>
                                       <li><code class="codeph">2</code>整数</li>
                                       <li><code class="codeph">3</code>漂浮</li>
                                       <li><code class="codeph">4</code>双</li>
                                       <li><code class="codeph">5</code>时间戳（日期）</li>
                                       <li><code class="codeph">6</code>布尔值</li>
                                       <li><code class="codeph">7</code>长整数</li>
                                       <li><code class="codeph">8</code>短整数</li>
                                       <li><code class="codeph">9</code>字节</li>
                                       <li><code class="codeph">10</code>字符</li>
                                       <li><code class="codeph">20</code>空间数据，可以是地理空间坐标，线，多边形或已知文本（WKT）文字</li>
                                       <li><code class="codeph">101</code>序列化的Java对象</li>
                                    </ul>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="13%" id="d4109e11925" headers="d4109e11824 ">
                                    <p>4</p>
                                 </td>
                                 <td align="left" valign="top" width="28%" headers="d4109e11925 d4109e11827 ">
                                    <p><span class="italic">值</span></p>
                                 </td>
                                 <td align="left" valign="top" width="59%" headers="d4109e11925 d4109e11830 ">
                                    <p><span class="italic">key_name</span>的编码非空值，既不是数字也不是日期</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="13%" id="d4109e11939" headers="d4109e11824 ">
                                    <p>五</p>
                                 </td>
                                 <td align="left" valign="top" width="28%" headers="d4109e11939 d4109e11827 ">
                                    <p><span class="italic">值</span></p>
                                 </td>
                                 <td align="left" valign="top" width="59%" headers="d4109e11939 d4109e11830 ">
                                    <p><span class="italic">key_name</span>的编码非空值，当它是数字时</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="13%" id="d4109e11953" headers="d4109e11824 ">
                                    <p>6</p>
                                 </td>
                                 <td align="left" valign="top" width="28%" headers="d4109e11953 d4109e11827 ">
                                    <p><span class="italic">值</span></p>
                                 </td>
                                 <td align="left" valign="top" width="59%" headers="d4109e11953 d4109e11830 ">
                                    <p>当<span class="italic">key_name</span>为时间戳（日期）时， <span class="italic">key_name</span>的编码非空值</p>
                                    <p>使用Java <code class="codeph">SimpleDateFormat</code>类来标识日期的格式。此示例描述了<code class="codeph">2015-03-26T00:00:00.000-05:00</code>的日期格式：</p><pre class="oac_no_warn" dir="ltr">SimpleDateFormat sdf = new SimpleDateFormat（“yyyy-MM-dd'T'HH：mm：ss。SSSXXX“）; encode（sdf.format（（java.util。日期）价值））;</pre></td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <p><span class="bold">所需的顶点分组</span> ：顶点可以具有多个属性，并且顶点文件包括顶点ID和该顶点的属性的每个组合的记录（由平面文件中的单行文本表示）。在顶点文件中，每个顶点的所有记录必须组合在一起（即，没有任何其他顶点的插入记录。您可以以任何方式完成此操作，但一种方便的方法是按顶点ID按升序（或降序）排序顶点文件记录。 （但是请注意，顶点文件不需要按顶点ID排序所有记录;这只是实现分组要求的一种方式。）
                     </p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="using-property-graphs-oracle-database.html#GUID-7FC09376-F237-41E8-B0FE-9D1044A59FBB" title="可以在两个平面文件中定义属性图，特别是顶点和边的描述文件。">Oracle平面文件格式定义</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="props_rev_3"><a id="GUID-7323744B-BD8D-4179-91D3-93C92461D92B" name="GUID-7323744B-BD8D-4179-91D3-93C92461D92B"></a><h4 id="SPGDG-GUID-7323744B-BD8D-4179-91D3-93C92461D92B" class="sect4"><span class="enumeration_section">2.13.4</span>编码特殊字符</h4>
                  <div>
                     <p>顶点和边缘文件的编码为UTF-8。下表列出了当它们出现在顶点或边缘属性（键值对）或边缘标签中时必须编码为字符串的特殊字符。没有其他字符需要编码。</p>
                     <div class="tblformal" id="GUID-7323744B-BD8D-4179-91D3-93C92461D92B__SPECIALCHARACTERCODESINTHEORACLEFLA-11283C25">
                        <p class="titleintable">表2-5 Oracle Flat File格式的特殊字符代码</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="Oracle平面文件格式中的特殊字符代码" width="100%" border="1" summary="Special character encoding. Column names are Spacial Character, String Encoding, and Description." frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="35%" id="d4109e12048">特殊字符</th>
                                 <th align="left" valign="bottom" width="33%" id="d4109e12051">字符串编码</th>
                                 <th align="left" valign="bottom" width="33%" id="d4109e12054">描述</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="35%" id="d4109e12059" headers="d4109e12048 ">
                                    <p><code class="codeph">％</code></p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d4109e12059 d4109e12051 ">
                                    <p><code class="codeph">％25</code></p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d4109e12059 d4109e12054 ">
                                    <p>百分</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="35%" id="d4109e12071" headers="d4109e12048 ">
                                    <p><code class="codeph">\ t</code></p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d4109e12071 d4109e12051 ">
                                    <p><code class="codeph">％09</code></p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d4109e12071 d4109e12054 ">
                                    <p>标签</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="35%" id="d4109e12083" headers="d4109e12048 ">
                                    <p><code class="codeph"> </code> （空间）</p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d4109e12083 d4109e12051 ">
                                    <p><code class="codeph">％20</code></p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d4109e12083 d4109e12054 ">
                                    <p>空间</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="35%" id="d4109e12096" headers="d4109e12048 ">
                                    <p><code class="codeph">\ n</code></p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d4109e12096 d4109e12051 ">
                                    <p><code class="codeph">％0A</code></p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d4109e12096 d4109e12054 ">
                                    <p>新队</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="35%" id="d4109e12108" headers="d4109e12048 ">
                                    <p><code class="codeph">\ r</code></p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d4109e12108 d4109e12051 ">
                                    <p><code class="codeph">％0D</code></p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d4109e12108 d4109e12054 ">
                                    <p>返回</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="35%" id="d4109e12120" headers="d4109e12048 ">
                                    <p><code class="codeph">，</code></p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d4109e12120 d4109e12051 ">
                                    <p><code class="codeph">％2C</code></p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d4109e12120 d4109e12054 ">
                                    <p>逗号</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="using-property-graphs-oracle-database.html#GUID-7FC09376-F237-41E8-B0FE-9D1044A59FBB" title="可以在两个平面文件中定义属性图，特别是顶点和边的描述文件。">Oracle平面文件格式定义</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="props_rev_3"><a id="GUID-14C10BAB-3CE4-4D5E-BA09-7C6697F226FE" name="GUID-14C10BAB-3CE4-4D5E-BA09-7C6697F226FE"></a><h4 id="SPGDG-GUID-14C10BAB-3CE4-4D5E-BA09-7C6697F226FE" class="sect4"><span class="enumeration_section">2.13.5</span> Oracle平面文件格式的示例属性图</h4>
                  <div>
                     <p>Oracle平面文件格式的示例属性图如下所示。在此示例中，有两个顶点（John和Mary），以及表示John是Mary的朋友的单个边。</p><pre class="oac_no_warn" dir="ltr">％cat simple.opv 1，年龄，2,10,1，姓名，1，John ,, 2，姓名，1，Mary ,, 2，业余爱好，1，足球，％cat simple.ope 100,1， 2，friendOf，％20 ,,,,</pre></div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="using-property-graphs-oracle-database.html#GUID-7FC09376-F237-41E8-B0FE-9D1044A59FBB" title="可以在两个平面文件中定义属性图，特别是顶点和边的描述文件。">Oracle平面文件格式定义</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="props_rev_3"><a id="GUID-EFA9E4E7-F854-4224-8828-F8843DE91D8B" name="GUID-EFA9E4E7-F854-4224-8828-F8843DE91D8B"></a><h4 id="SPGDG-GUID-EFA9E4E7-F854-4224-8828-F8843DE91D8B" class="sect4"><span class="enumeration_section">2.13.6</span>将Oracle数据库表转换为Oracle定义的属性图平面文件</h4>
                  <div>
                     <p>您可以将表示图形顶点和边缘的Oracle数据库表转换为Oracle定义的平面文件格式（ <code class="codeph">.opv</code>和<code class="codeph">.ope</code>文件扩展名）。
                     </p>
                     <p>如果您在Oracle数据库表中存储了图形数据，则可以使用Java API方法将该数据转换为平面文件，然后将表作为属性图加载到Oracle数据库中。这样就无需采用其他手动方法从现有Oracle数据库表生成平面文件。</p>
                     <div class="section">
                        <p class="subhead3" id="GUID-EFA9E4E7-F854-4224-8828-F8843DE91D8B__GUID-D2921A29-77D8-43A5-B37B-F2E066B41CC9"><span class="bold">将表存储图顶点转换为.opv文件</span></p>
                        <p>您可以将包含实体（可以表示为图形顶点）的Oracle数据库表转换为<code class="codeph">.opv</code>格式的属性图平面文件。
                        </p>
                        <p>例如，假设以下关系表： <code class="codeph">EmployeeTab (empID integer not null, hasName varchar(255), hasAge integer, hasSalary number)</code></p>
                        <p>假设此表具有以下数据：</p><pre class="oac_no_warn" dir="ltr">101，Jean，20,120.0 102，Mary，21,50.0 103，Jack，22,110.0 ......</pre><p>可以将每个员工视为图表中的顶点。顶点ID可以是employeeID的值，也可以是使用哈希等一些启发式生成的ID。列hasName，hasAge和hasSalary可以视为属性。</p>
                        <p>Java方法<code class="codeph">OraclePropertyGraphUtils.convertRDBMSTable2OP <span class="bold">V</span></code>及其Javadoc信息如下：</p><pre class="oac_no_warn" dir="ltr">/ ** * conn：是Oracle关系数据库的连接实例* rdbmsTableName：要转换的RDBMS表的名称* vidColName是RDBMS表中要被视为顶点ID的列的名称* lVIDOffset是偏移量将是应用于顶点ID * ctams定义如何将RDBMS表中的列映射到属性* dop并行度* dcl DataConverterListener实例报告进度并控制错误发生时的行为* / OraclePropertyGraphUtils.convertRDBMSTable2OPV（Connection conn， String rdbmsTableName，String vidColName，long lVIDOffset，ColumnToAttrMapping [] ctams，int dop，OutputStream opvOS，DataConverterListener dcl）;</pre><p>以下代码段将此表转换为Oracle定义的顶点文件（ <code class="codeph">.opv</code> ）：</p><pre class="pre codeblock"><code>//输出文件的位置字符串opv =“。/EmployeeTab.opv“; OutputStream opvOS = new FileOutputStream（opv）; // ColumnToAttrMapping对象的数组;每个对象定义如何将RDBMS表中的列映射到Oracle Property Graph中的顶点属性。ColumnToAttrMapping [] ctams = new ColumnToAttrMapping [3]; //将列“hasName”映射到String类型的“name”属性ctams [0] = ColumnToAttrMapping.getInstance（“hasName”，“name”，String.class）; //将列“hasAge”映射到属性“age”，类型为Integer ctams [1] = ColumnToAttrMapping.getInstance（“hasAge”，“age”，Integer.class）; //将列“hasSalary”映射到Double ctams [2] = ColumnToAttrMapping.getInstance（“hasSalary”，“salary”，Double.class）类型的属性“salary”; //将RDBMS表“EmployeeTab”转换为opv文件“。/EmployeeTab.opv“，列”empID“是顶点ID列，偏移量1000l将应用于顶点ID，使用ctams将RDBMS列映射到属性，将DOP设置为8 OraclePropertyGraphUtils.convertRDBMSTable2OPV（conn，”EmployeeTab“，”empID“ “，1000l，ctams，8，opvOS，（DataConverterListener）null）;</code></pre><div class="infoboxnote" id="GUID-EFA9E4E7-F854-4224-8828-F8843DE91D8B__GUID-EFB41B19-4333-4E77-85C4-7C7737E9CD66">
                           <p class="notep1">注意：</p>
                           <p>作为偏移值<code class="codeph">1000l</code>的最后一个字符的小写字母“l”表示它之前的值是长整数。
                           </p>
                        </div>
                        <p>转换结果如下：</p><pre class="oac_no_warn" dir="ltr">1101，姓名，1，Jean ,, 1101，年龄，2，，20，1101，工资，4，120.0,1102，姓名，1，Mary ,, 1102，年龄，2岁，21岁，1102岁，工资，4 ,, 50.0,1103，name，1，Jack ,, 1103，年龄，2，，22，1103，年龄，4，110.0，</pre><p>在这种情况下，表EmployeeTab中的每一行都转换为一个具有三个属性的顶点。例如，具有数据“101，Jean，20,120.0”的行被转换为具有ID 1101的顶点，其具有属性名称/“Jean”，年龄/ 20，工资/ 120.0。原始empID 101和顶点ID 1101之间存在偏移，因为应用了偏移1000l。偏移量有助于避免图元素的ID值发生冲突。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-EFA9E4E7-F854-4224-8828-F8843DE91D8B__GUID-CA095AE1-F68E-4CAB-8E3A-6ECA18090FE1"><span class="bold">将表存储图形边缘转换为.ope文件</span></p>
                        <p>您可以将包含实体关系（可以表示为图形边缘）的Oracle数据库表转换为<code class="codeph">.ope</code>格式的属性图平面文件。
                        </p>
                        <p>例如，假设以下关系表： <code class="codeph">EmpRelationTab (relationID integer not null, source integer not null, destination integer not null, relationType varchar(255), startDate date)</code></p>
                        <p>假设此表具有以下数据：</p><pre class="oac_no_warn" dir="ltr">90001,101,102，manage，10-May-2015 90002,101,103，manage，11-Jan-2015 90003,102,103，同事，2015年1月11日......</pre><p>每个关系（行）都可以视为图中的边。具体而言，边缘ID可以与relationID相同，也可以是使用哈希等一些启发式生成的ID。列relationType可用于定义边标签，列startDate可被视为边属性。</p>
                        <p>Java方法<code class="codeph">OraclePropertyGraphUtils.convertRDBMSTable2OP <span class="bold">E</span></code>及其Javadoc信息如下：</p><pre class="oac_no_warn" dir="ltr">/ ** * conn：是Oracle关系数据库的连接实例* rdbmsTableName：要转换的RDBMS表的名称* eidColName是RDBMS表中要作为边ID标识的列的名称* lEIDOffset是偏移量将是应用于边ID * svidColName是RDBMS表中要作为边的源顶点ID的列的名称* dvidColName是RDBMS表中要作为边的目标顶点ID的列的名称* lVIDOffset是偏移量将应用于顶点ID * bHasEdgeLabelCol布尔标志表示给定的RDBMS表是否具有边标签列;如果为true，则使用列elColName的值作为边标签;否则，使用常量字符串elColName作为边标签* elColName是RDBMS表中要作为边标签处理的列的名称* ctams定义如何将RDBMS表中的列映射到属性* dop parallel of parallelism * dcl an DataConverterListener的实例，用于报告进度并控制错误发生时的行为* / OraclePropertyGraphUtils.convertRDBMSTable2OPE（连接conn，String rdbmsTableName，String eidColName，long lEIDOffset，String svidColName，String dvidColName，long lVIDOffset，boolean bHasEdgeLabelCol，String elColName，ColumnToAttrMapping [] ctams，int dop，OutputStream opeOS，DataConverterListener dcl）;</pre><p>以下代码段将此表转换为Oracle定义的边缘文件（ <code class="codeph">.ope</code> ）：</p><pre class="pre codeblock"><code>//输出文件的位置String ope =“。/EmpRelationTab.ope“; OutputStream opeOS = new FileOutputStream（ope）; // ColumnToAttrMapping对象的数组;每个对象定义如何将RDBMS表中的列映射到Oracle Property Graph中边的属性。ColumnToAttrMapping [] ctams = new ColumnToAttrMapping [1]; //将列“startDate”映射到Date类型的“Since”属性[0] = ColumnToAttrMapping.getInstance（“startDate”，“since”，Date.class）; //将RDBMS表“EmpRelationTab”转换为ope文件“。/EmpRelationTab.opv“，列”relationID“是边ID列，偏移10000l将应用于边ID，边的源和目标顶点由列”source“和”destination“定义，将应用偏移1000l对于顶点ID，RDBMS表有一个列“relationType”被视为边标签，使用ctams将RDBMS列映射到边缘属性，将DOP设置为8 OraclePropertyGraphUtils.convertRDBMSTable2OPE（conn，“EmpRelationTab”，“relationID”，10000l， “source”，“destination”，1000l，true，“relationType”，ctams，8，opeOS，（DataConverterListener）null）;</code></pre><div class="infoboxnote" id="GUID-EFA9E4E7-F854-4224-8828-F8843DE91D8B__GUID-29C25198-B41F-4595-9EBB-0045D2DBA5BC">
                           <p class="notep1">注意：</p>
                           <p>作为偏移值<code class="codeph">10000l</code>的最后一个字符的小写字母“l”表示它之前的值是长整数。
                           </p>
                        </div>
                        <p>转换结果如下：</p><pre class="oac_no_warn" dir="ltr">100001,1101,1102，manage，since，5 ,,, 2015-05-10T00：00：00.000-07：00 100002,1101,1103，manage，since，5 ,,, 2015-01-11T00：00：00.000 -07：00 100003,1102,1103，同事，自5 ,,, 2015-01-11T00：00：00.000-07：00</pre><p>在这种情况下，在表EmpRelationTab每一行被转换成不同的边缘与属性<code class="codeph">since</code> 。例如，具有数据“90001,101,102，manage，10-May-2015”的行被转换为ID为100001的边缘，其将顶点1101链接到顶点1102。此边缘具有自“/ 2015-05-10T00：00：00.000-07：00”以来的属性。原始relationID“90001”和边缘ID“100001”之间存在偏移，因为应用了偏移10000l。类似地，偏移量1000l应用于源和目标顶点ID。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="using-property-graphs-oracle-database.html#GUID-7FC09376-F237-41E8-B0FE-9D1044A59FBB" title="可以在两个平面文件中定义属性图，特别是顶点和边的描述文件。">Oracle平面文件格式定义</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="props_rev_3"><a id="GUID-269EA431-B8C2-45F5-9338-482D4D4E34F5" name="GUID-269EA431-B8C2-45F5-9338-482D4D4E34F5"></a><h4 id="SPGDG-GUID-269EA431-B8C2-45F5-9338-482D4D4E34F5" class="sect4"><span class="enumeration_section">2.13.7</span>将顶点和边的CSV文件转换为Oracle定义的属性图平面文件</h4>
                  <div>
                     <p>某些应用程序使用CSV（逗号分隔值）格式来编码图形的顶点和边。在此格式中，CSV文件的每个记录表示单个顶点或边，并具有其所有属性。您可以将表示图形顶点的CSV文件转换为Oracle定义的平面文件格式定义（ <code class="codeph">.opv</code>表示顶点， <code class="codeph">.ope</code>表示边缘）。
                     </p>
                     <p>要转换的CSV文件可能包含一个标题行，用于指定列名称和列所代表的属性的类型。如果标头仅包含属性名称，则转换器将假定值的数据类型为String。</p>
                     <p>将CSV转换为OPV或OPE的Java API接收一个<code class="codeph">InputStream</code> ，从中读取顶点或边（从CSV），并将它们以<code class="codeph">.opv</code>或<code class="codeph">.ope</code>格式写入<code class="codeph">OutputStream</code> 。转换器API还允许自定义转换过程。
                     </p>
                     <p>以下子主题提供了转换顶点和边的说明：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>顶点：将CSV文件转换为Oracle定义的平面文件格式（ <code class="codeph">.opv</code> ）</p>
                        </li>
                        <li>
                           <p>边缘：将CSV文件转换为Oracle定义的平面文件格式（ <code class="codeph">.ope</code> ）</p>
                        </li>
                     </ul>
                     <p>两者的说明非常相似，但具有特定于顶点和边的差异。</p>
                     <div class="section">
                        <p class="subhead3" id="GUID-269EA431-B8C2-45F5-9338-482D4D4E34F5__CONVERTINGATABLESTORINGGRAPHVERTICE-37D31759"><span class="bold">顶点：将CSV文件转换为Oracle定义的平面文件格式（.opv）</span></p>
                        <p>如果CSV文件不包含标题，则必须指定ColumnToAttrMapping数组，该数组描述所有属性名称（映射到其值数据类型），其顺序与CSV文件中显示的顺序相同。此外，必须在数组中描述CSV文件中的整个列，包括特殊列，例如顶点的ID。如果要在同一CSV文件的第一行中指定列的标题，则必须将此参数设置为null。</p>
                        <p>要转换表示顶点的CSV文件，可以使用convertCSV2OPV API之一。这些API中最简单的API要求：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>用于从CSV文件中读取顶点的<code class="codeph">InputStream</code></p>
                           </li>
                           <li>
                              <p>表示顶点ID的列的名称（此列必须出现在CSV文件中）</p>
                           </li>
                           <li>
                              <p>要添加到VID的整数偏移量（偏移量对于避免图元素的ID值发生冲突很有用）</p>
                           </li>
                           <li>
                              <p><code class="codeph">ColumnToAttrMapping</code>数组（如果在文件中指定了标头，则必须为null）</p>
                           </li>
                           <li>
                              <p>并行度（DOP）</p>
                           </li>
                           <li>
                              <p>转换前表示偏移量（要跳过的顶点记录数）的整数</p>
                           </li>
                           <li>
                              <p>将在其中写入顶点平面文件（.opv）的<code class="codeph">OutputStream</code></p>
                           </li>
                           <li>
                              <p>可选的<code class="codeph">DataConverterListener</code> ，可用于跟踪转换进度并确定发生错误时要执行的操作</p>
                           </li>
                        </ul>
                        <p>其他参数可用于指定CSV文件的不同格式：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>分隔符，用于分隔记录中的标记。默认值为逗号字符'，'。</p>
                           </li>
                           <li>
                              <p>引号字符，用于引用String值，以便它们可以包含特殊字符，例如逗号。如果引号字符出现在String本身的值中，则必须通过复制或在其前面放置反斜杠字符'\'来转义它。一些例子是：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>“”你好，世界“”，屏幕显示......“</p>
                                 </li>
                                 <li>
                                    <p>“但维达回答说：”不，我是你的父亲。“</p>
                                 </li>
                              </ul>
                           </li>
                           <li>
                              <p>Date格式，用于解析日期值。对于CSV转换，此参数可以为null，但如果CSV具有特定日期格式，则建议指定该参数。提供特定的日期格式有助于提高性能，因为在尝试解析日期值时，该格式将用作第一个选项。一些示例日期格式是：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>“YYYY-MM-dd'T'HH：MM：SS。SSSXXX”</p>
                                 </li>
                                 <li>
                                    <p>“MM / dd / yyyy HH：mm：ss”</p>
                                 </li>
                                 <li>
                                    <p>“ddd，dd MMM yyyy HH'：'mm'：'ss'GMT'”</p>
                                 </li>
                                 <li>
                                    <p>“dddd，dd MMMM yyyy hh：mm：ss”</p>
                                 </li>
                                 <li>
                                    <p>“YYYY-MM-DD”</p>
                                 </li>
                                 <li>
                                    <p>“MM / DD / YYYY”</p>
                                 </li>
                              </ul>
                           </li>
                           <li>
                              <p>一个标志，指示CSV文件是否包含带有换行符的字符串值。如果此参数设置为true，则必须引用文件中包含新行或引号字符作为值的所有字符串。</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>“堂吉诃德的第一行是：”“在拉曼查的一个村庄里，我不想忘记这个名字”“。”</p>
                                 </li>
                              </ul>
                           </li>
                        </ul>
                        <p>以下代码片段显示了如何创建<code class="codeph">ColumnToAttrMapping</code>数组并使用API将CSV文件转换为<code class="codeph">.opv</code>文件。
                        </p><pre class="pre codeblock"><code>String inputCSV =“/ path / mygraph-vertices.csv”; String outputOPV =“/ path / mygraph.opv”; ColumnToAttrMapping [] ctams = new ColumnToAttrMapping [4]; ctams [0] = ColumnToAttrMapping.getInstance（“VID”，Long.class）; ctams [1] = ColumnToAttrMapping.getInstance（“name”，String.class）; ctams [2] = ColumnToAttrMapping.getInstance（“score”，Double.class）; ctams [3] = ColumnToAttrMapping.getInstance（“age”，Integer.class）; String vidColumn =“VID”; isCSV = new FileInputStream（inputCSV）; osOPV = new FileOutputStream（new File（outputOPV））; //转换顶点OraclePropertyGraphUtilsBase.convertCSV2OPV（isCSV，vidColumn，0，ctams，1,0，osOPV，null）; isOPV.close（）; osOPV.close（）;</code></pre><p>在此示例中，要转换的CSV文件不得包含标题，并且包含四列（顶点ID，名称，分数和年龄）。CVS示例如下：</p><pre class="oac_no_warn" dir="ltr">1，John，4.2,30 2，Mary，4.3,32 3，“Skywalker，Anakin”，5.0,46 4，“Darth Vader”，5.0,46 5，“Skywalker，Luke”，5.0,53</pre><p>生成的<code class="codeph">.opv</code>文件如下：</p><pre class="oac_no_warn" dir="ltr">1，姓名，1，John ,, 1，得分，4 ,, 4.2,1，年龄，2，30,2，姓名，1，Mary ,, 2，得分，4 ,, 4.3,2，年龄，2 ,, 32,3，名称，1，天行者％2C％20Anakin ,, 3，得分，4，5.0,3，年龄，2，，46，4，名称，1，达斯％20Vader ,, 4，得分， 4，5.0,4，年龄，2岁，46岁，5岁，名字，1，天行者％2C％20Luke ,, 5，得分，4，5.0,5，年龄，2，53，</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-269EA431-B8C2-45F5-9338-482D4D4E34F5__CONVERTINGATABLESTORINGGRAPHEDGESTO-37D31A87"><span class="bold">边缘：将CSV文件转换为Oracle定义的平面文件格式（.ope）</span></p>
                        <p>如果CSV文件不包含标题，则必须指定<code class="codeph">ColumnToAttrMapping</code>数组，该数组描述所有属性名称（映射到其值数据类型），其顺序与CSV文件中显示的顺序相同。此外，必须在数组中描述CSV文件中的整个列，包括特殊列（如果适用的边缘ID）以及所需的START_ID，END_ID和TYPE。如果要在同一CSV文件的第一行中指定列的标题，则必须将此参数设置为null。
                        </p>
                        <p>要转换表示顶点的CSV文件，可以使用<code class="codeph">convertCSV2OPE</code> API之一。这些API中最简单的API要求：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>用于从CSV文件中读取顶点的<code class="codeph">InputStream</code></p>
                           </li>
                           <li>
                              <p>表示边缘ID的列的名称（这在CSV文件中是可选的;如果不存在，则行号将用作ID）</p>
                           </li>
                           <li>
                              <p>要添加到EID的整数偏移量（偏移量对于避免图元素的ID值发生冲突很有用）</p>
                           </li>
                           <li>
                              <p>表示源顶点ID的列的名称（此列必须出现在CSV文件中）</p>
                           </li>
                           <li>
                              <p>表示目标顶点ID的列的名称（此列必须出现在CSV文件中）</p>
                           </li>
                           <li>
                              <p>偏移到VID（ <code class="codeph">lOffsetVID</code> ）。此偏移量将添加到原始SVID和DVID值之上。（此API的变体有两个参数（ <code class="codeph">lOffsetSVID</code>和<code class="codeph">lOffsetDVID</code> ）：SVID的一个偏移量，DVID的另一个偏移量。）
                              </p>
                           </li>
                           <li>
                              <p>一个布尔标志，指示CSV文件中是否存在边缘标签列。</p>
                           </li>
                           <li>
                              <p>表示边标签的列的名称（如果CSV文件中不存在此列，则此参数将用作所有边标签的常量）</p>
                           </li>
                           <li>
                              <p><code class="codeph">ColumnToAttrMapping</code>数组（如果在文件中指定了标头，则必须为null）</p>
                           </li>
                           <li>
                              <p>并行度（DOP）</p>
                           </li>
                           <li>
                              <p>转换前表示偏移量（要跳过的边记录数）的整数</p>
                           </li>
                           <li>
                              <p>将在其中写入边平面文件（.ope）的<code class="codeph">OutputStream</code></p>
                           </li>
                           <li>
                              <p>可选的<code class="codeph">DataConverterListener</code> ，可用于跟踪转换进度并确定发生错误时要执行的操作。
                              </p>
                           </li>
                        </ul>
                        <p>其他参数可用于指定CSV文件的不同格式：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>分隔符，用于分隔记录中的标记。默认值为逗号字符'，'。</p>
                           </li>
                           <li>
                              <p>引号字符，用于引用String值，以便它们可以包含特殊字符，例如逗号。如果引号字符出现在String本身的值中，则必须通过复制或在其前面放置反斜杠字符'\'来转义它。一些例子是：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>“”你好，世界“”，屏幕显示......“</p>
                                 </li>
                                 <li>
                                    <p>“但维达回答说：”不，我是你的父亲。“</p>
                                 </li>
                              </ul>
                           </li>
                           <li>
                              <p>Date格式，用于解析日期值。对于CSV转换，此参数可以为null，但如果CSV具有特定日期格式，则建议指定该参数。提供特定的日期格式有助于提高性能，因为在尝试解析日期值时，该格式将用作第一个选项。一些示例日期格式是：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>“YYYY-MM-dd'T'HH：MM：SS。SSSXXX”</p>
                                 </li>
                                 <li>
                                    <p>“MM / dd / yyyy HH：mm：ss”</p>
                                 </li>
                                 <li>
                                    <p>“ddd，dd MMM yyyy HH'：'mm'：'ss'GMT'”</p>
                                 </li>
                                 <li>
                                    <p>“dddd，dd MMMM yyyy hh：mm：ss”</p>
                                 </li>
                                 <li>
                                    <p>“YYYY-MM-DD”</p>
                                 </li>
                                 <li>
                                    <p>“MM / DD / YYYY”</p>
                                 </li>
                              </ul>
                           </li>
                           <li>
                              <p>一个标志，指示CSV文件是否包含带有换行符的字符串值。如果此参数设置为true，则必须引用文件中包含新行或引号字符作为值的所有字符串。</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>“堂吉诃德的第一行是：”“在拉曼查的一个村庄里，我不想忘记这个名字”“。”</p>
                                 </li>
                              </ul>
                           </li>
                        </ul>
                        <p>以下代码片段显示了如何使用API将CSV文件转换为具有null <code class="codeph">ColumnToAttrMapping</code>数组的<code class="codeph">.ope</code>文件。
                        </p><pre class="pre codeblock"><code>String inputOPE =“/ path / mygraph-edges.csv”; String outputOPE =“/ path / mygraph.ope”; String eidColumn = null; // null意味着将使用整数序列String svidColumn =“START_ID”; String dvidColumn =“END_ID”; boolean hasLabel = true; String labelColumn =“TYPE”; isOPE = new FileInputStream（inputOPE）; osOPE = new FileOutputStream（new File（outputOPE））; //转换边缘OraclePropertyGraphUtilsBase.convertCSV2OPE（isOPE，eidColumn，0，svidColumn，dvidColumn，hasLabel，labelColumn，null，1,0，osOPE，null）;</code></pre><p>使用前一个示例进行转换的输入CSV应包含指定列名称及其类型的标头。示例CSV文件如下。</p><pre class="oac_no_warn" dir="ltr">START_ID：长，重量：浮点数，END_ID：长，：TYPE 1,1.0,2，喜欢1,1.0,5，喜欢2,0.9,1，喜欢1,0.5,3，喜欢2,0.0,4，喜欢4 ，1.0,5，是3,1.0,4的父亲，转为5,1.0,3，从黑暗面拯救</pre><p>生成的.ope文件如下。</p><pre class="oac_no_warn" dir="ltr">1,1,2，爱情，体重，3,1.0,11,5，钦佩，体重，3，1.0,3,2,1，爱情，体重，3，0.9,4,1,3 ，喜欢，重量，3，0.5,5,2,4，喜欢，重量，3，0.0,6,4,5，是％20％20dad％20of，重量，3，1.0,7,3， 4，转动％20to，重量，3，1.0,8,5,3，保存％20从％20％20dark％20side，重量，3，1.0，</pre></div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="using-property-graphs-oracle-database.html#GUID-7FC09376-F237-41E8-B0FE-9D1044A59FBB" title="可以在两个平面文件中定义属性图，特别是顶点和边的描述文件。">Oracle平面文件格式定义</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div>
            <div class="props_rev_3"><a id="GUID-1946BFA3-8995-4EE5-8E39-FE1C58391EAD" name="GUID-1946BFA3-8995-4EE5-8E39-FE1C58391EAD"></a><h3 id="SPGDG-GUID-1946BFA3-8995-4EE5-8E39-FE1C58391EAD" class="sect3"><span class="enumeration_section">2.14</span> Python用户界面示例</h3>
               <div>
                  <p><code class="codeph">$ORACLE_HOME/md/property_graph/pyopg/</code>的示例Python脚本可以与Oracle Spatial and Graph Property Graph一起使用，您可能希望更改和增强它们（或它们的副本）以满足您的需要。
                  </p>
                  <div class="infoboxnote" id="GUID-1946BFA3-8995-4EE5-8E39-FE1C58391EAD__GUID-88F50BD3-C9B6-4F8C-B646-0A2CAB6365B2">
                     <p class="notep1">注意：</p>
                     <p>名称不会出现在顶点或边文件中，但这里提供的名称是为了简化字段引用。</p>
                  </div>
                  <p>要调用用户界面来运行示例，请使用脚本<code class="codeph">pyopg.sh</code> 。
                  </p>
                  <p>示例包括以下内容：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>示例1：连接到Oracle数据库并执行顶点数和边数的简单检查。要运行它：</p><pre class="oac_no_warn" dir="ltr">sh ./pyopg.sh connectRDBMS（“connections”，“jdbc：oracle：thin：@ 127.0.0.1：1521：orcl”，“scott”，“&lt;password&gt;”）;打印“vertices”，countV（）print“边缘“，countE（）</pre><p>在前面的示例中， <code class="codeph">mygraph</code>是存储在Oracle数据库中的图的名称，其余参数是访问Oracle数据库的连接信息。它们必须根据您的环境进行定制。
                        </p>
                     </li>
                     <li>
                        <p>示例2：连接到Oracle数据库并运行一些分析函数。要运行它：</p><pre class="oac_no_warn" dir="ltr">connectRDBMS（“connections”，“jdbc：oracle：thin：@ 127.0.0.1：1521：orcl”，“scott”，“&lt;password&gt;”）; print“vertices”，countV（）print“edges”，countE（）import pprint analyzer = analyst（）print“＃triangles in the graph”，analyzer.countTriangles（）graph_communities = [{“commid”：i.getName（） ，“size”：i.size（）}对于i在analyzer.communities（）。iterator（）中将pandas导入为pd import numpy为np community_frame = pd。DataFrame（graph_communities）community_frame [：5]将matplotlib导入为mpl import matplotlib.pyplot为plt fig，ax = plt.subplots（nrows = 1，ncols = 1，figsize =（16,12））; community_frame [“size”]。plot（kind =“bar”，title =“Communities and Sizes”）ax.set_xticklabels（community_frame.index）; plt.show（）</pre><p>前面的示例连接到Oracle数据库，打印有关顶点和边的基本信息，获取内存分析器，计算三角形的数量，执行社区检测，最后绘制条形图社区及其大小。</p>
                     </li>
                  </ul>
                  <p>有关此示例Python界面的详细信息，请参阅安装主目录下的以下目录：</p><pre class="oac_no_warn" dir="ltr">$ ORACLE_HOME / MD / property_graph / pyopg / DOC /</pre></div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="using-property-graphs-oracle-database.html#GUID-4B5AF258-79BE-418D-84FF-9B8A692B8604" title="本章提供有关在Oracle数据库环境中创建，存储和使用属性图数据的概念和用法信息。">在Oracle数据库环境中使用属性图</a></p>
                     </div>
                  </div>
               </div>
               
            </div>
         </div>
      </article>
   </body>
</html>