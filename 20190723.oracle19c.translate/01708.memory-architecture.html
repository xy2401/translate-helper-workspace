<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <meta name="abstract" content="This chapter discusses the memory architecture of a database instance."></meta>
      <meta name="description" content="This chapter discusses the memory architecture of a database instance."></meta>
      <title>内存架构</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Database Concepts"></meta>
      <meta property="og:description" content="This chapter discusses the memory architecture of a database instance."></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Database Concepts"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="database-concepts.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-09T07:47:16-08:00"></meta>
      <meta name="dcterms.title" content="Database Concepts"></meta>
      <meta name="dcterms.dateCopyrighted" content="1993, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96138-01"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="oracle-database-instance.html" title="Previous" type="text/html"></link>
      <link rel="next" href="process-architecture.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.isVersionOf" content="CNCPT"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="oracle-database-instance.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="process-architecture.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">数据库概念</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="oracle-instance-architecture.html" property="item" typeof="WebPage"><span property="name">Oracle实例架构</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">内存架构</li>
            </ol>
            <a id="GUID-913335DF-050A-479A-A653-68A064DCCA41" name="GUID-913335DF-050A-479A-A653-68A064DCCA41"></a><a id="CNCPT007"></a>
            
            <h2 id="CNCPT-GUID-913335DF-050A-479A-A653-68A064DCCA41" class="sect2"><span class="enumeration_chapter">14</span>内存架构</h2>
         </header>
         <div class="ind">
            <div>
               <p>本章讨论数据库实例的内存体系结构。</p>
               <p>本章包含以下部分：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="memory-architecture.html#GUID-1A40F9B9-EB2F-4060-9007-7B26C033A774" title="启动实例时，Oracle数据库会分配一个内存区域并启动后台进程。">Oracle数据库内存结构简介</a></p>
                  </li>
                  <li>
                     <p><a href="memory-architecture.html#GUID-61B574AB-8493-4D43-8B30-0050A30550AD" title="UGA是会话内存，它是为会话变量分配的内存，例如登录信息，以及数据库会话所需的其他信息。实质上，UGA存储会话状态。">用户全局区域概述</a></p>
                  </li>
                  <li>
                     <p><a href="memory-architecture.html#GUID-859795E2-87CD-442B-B36F-584A77755F59" title="PGA是特定于操作进程或线程的内存，不由系统上的其他进程或线程共享。因为PGA是特定于进程的，所以它永远不会在SGA中分配。">计划全球区域（PGA）概述</a></p>
                  </li>
                  <li>
                     <p><a href="memory-architecture.html#GUID-24EDB8CD-8279-4CED-82AF-642FC01A4A73" title="SGA是一个读/写内存区域，与Oracle后台进程一起构成一个数据库实例。">系统全局区域（SGA）概述</a></p>
                  </li>
                  <li>
                     <p><a href="memory-architecture.html#GUID-EE4E1B4E-1C00-499F-B00E-2637B7E19963" title="软件代码区域是存储器的一部分，用于存储正在运行或可以运行的代码。Oracle数据库代码存储在软件区域中，该区域通常比用户程序的位置更加独占和受保护。">软件代码区概述</a></p>
                  </li>
               </ul>
               <div class="infoboxnotealso" id="GUID-913335DF-050A-479A-A653-68A064DCCA41__GUID-A380A7A7-B722-4313-BF06-3548919FA5A1">
                  <p class="notep1">也可以看看：</p>
                  <p>有关配置和管理内存的说明，请参见<a href="../admin/managing-memory.html#ADMIN00207" target="_blank"><span><cite>“Oracle数据库管理员指南”</cite></span></a></p>
               </div>
            </div><a id="CNCPT7776"></a><div class="props_rev_3"><a id="GUID-1A40F9B9-EB2F-4060-9007-7B26C033A774" name="GUID-1A40F9B9-EB2F-4060-9007-7B26C033A774"></a><h3 id="CNCPT-GUID-1A40F9B9-EB2F-4060-9007-7B26C033A774" class="sect3">Oracle数据库内存结构简介</h3>
               <div>
                  <p>启动实例时，Oracle数据库会分配一个内存区域并启动后台进程。</p>
                  <p>存储区存储如下信息：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>程序代码</p>
                     </li>
                     <li>
                        <p>有关每个已连接<a href="glossary.html#GUID-0F44C072-9841-4E2E-B846-FB16A2E54139"><span class="xrefglossterm">会话的信息</span></a> ，即使它当前未处于活动状态</p>
                     </li>
                     <li>
                        <p>程序执行期间所需的信息，例如，从中提取行的<a href="glossary.html#GUID-CCF91C9F-A98A-498F-A84B-58A0FA16CD6E"><span class="xrefglossterm">查询</span></a>的当前状态</p>
                     </li>
                     <li>
                        <p>诸如在进程之间共享和通信的<a href="glossary.html#GUID-6D016291-A487-4F88-BE0B-ACF8FA2AE72C"><span class="xrefglossterm">锁定</span></a>数据之类的信息</p>
                     </li>
                     <li>
                        <p>磁盘上也存在的缓存数据，如数据块和重做记录</p>
                     </li>
                  </ul>
                  <div class="infoboxnotealso" id="GUID-1A40F9B9-EB2F-4060-9007-7B26C033A774__GUID-07FDFA76-13C8-462F-AD2A-1EDADA321CCE">
                     <p class="notep1">也可以看看：</p>
                     <p><span class="q">“ <a href="process-architecture.html#GUID-85D9852E-5BF1-4AC0-9E5A-49F0570DBD7A" title="本章讨论Oracle数据库中的过程。">流程架构</a> ”</span></p>
                  </div>
               </div><a id="CNCPT89066"></a><a id="CNCPT7777"></a><div class="props_rev_3"><a id="GUID-02378E7A-865B-456B-8725-1E73D16A34BE" name="GUID-02378E7A-865B-456B-8725-1E73D16A34BE"></a><h4 id="CNCPT-GUID-02378E7A-865B-456B-8725-1E73D16A34BE" class="sect4">基本内存结构</h4>
                  <div>
                     <p>Oracle数据库包括几个内存区域，每个内存区域包含多个子组件。</p>
                     <p>与Oracle数据库关联的基本内存结构包括：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>系统全局区域（SGA）</p>
                           <p>SGA是一组共享内存结构，称为<span class="italic">SGA组件</span> ，包含一个Oracle数据库实例的数据和控制信息。所有服务器和后台进程共享SGA。存储在SGA中的数据的示例包括高速缓存的数据块和共享的SQL区域。
                           </p>
                        </li>
                        <li>
                           <p>全球计划（PGA）</p>
                           <p>PGA是一个非共享内存区域，包含专门供Oracle进程使用的数据和控制信息。Oracle数据库在Oracle进程启动时创建PGA。</p>
                           <p>每个<a href="glossary.html#GUID-E660AC1C-B704-4DC1-A35A-DB49EFB34F4A"><span class="xrefglossterm">服务器进程</span></a>和后台进程都存在一个PGA。单个PGA的集合是总实例PGA或<a href="glossary.html#GUID-8341392A-07AD-45A0-8E71-E330584EEE74"><span class="xrefglossterm">实例PGA</span></a> 。数据库初始化参数设置实例PGA的大小，而不是单个PGA。
                           </p>
                        </li>
                        <li>
                           <p>用户全局区域（UGA）</p>
                           <p>UGA是与用户会话相关联的存储器。</p>
                        </li>
                        <li>
                           <p>软件代码区域</p>
                           <p>软件代码区域是用于存储正在运行或可以运行的代码的内存部分。Oracle数据库代码存储在软件区域中，该区域通常位于与用户程序不同的位置 - 更独特或受保护的位置。</p>
                        </li>
                     </ul>
                     <p>下图说明了这些内存结构之间的关系。</p>
                     <div class="figure" id="GUID-02378E7A-865B-456B-8725-1E73D16A34BE__CHDHAHIJ">
                        <p class="titleinfigure">图14-1 Oracle数据库内存结构</p><img src="img/cncpt217.gif" alt="下面是图14-1的描述" title="下面是图14-1的描述" longdesc="img_text/cncpt217.html"><br><a href="img_text/cncpt217.html">“图14-1 Oracle数据库内存结构”的说明</a></div>
                     <!-- class="figure" -->
                  </div>
               </div><a id="CNCPT7778"></a><div class="props_rev_3"><a id="GUID-079064A0-DBFC-45C4-B10A-1442D4667036" name="GUID-079064A0-DBFC-45C4-B10A-1442D4667036"></a><h4 id="CNCPT-GUID-079064A0-DBFC-45C4-B10A-1442D4667036" class="sect4">Oracle数据库内存管理</h4>
                  <div>
                     <p>内存管理涉及在数据库更改需求时保持Oracle实例内存结构的最佳大小。Oracle数据库根据与内存相关的初始化参数的设置来管理内存。</p>
                     <p>内存管理的基本选项如下：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>自动内存管理</p>
                           <p>您指定数据库实例内存的目标大小。实例自动调整到目标内存大小，在SGA和实例PGA之间根据需要重新分配内存。</p>
                        </li>
                        <li>
                           <p>自动共享内存管理</p>
                           <p>此管理模式部分自动化。您可以为SGA设置目标大小，然后可以选择为PGA设置聚合目标大小或单独管理PGA工作区。</p>
                        </li>
                        <li>
                           <p>手动内存管理</p>
                           <p>您可以设置许多初始化参数来分别管理SGA和实例PGA的组件，而不是设置总内存大小。</p>
                        </li>
                     </ul>
                     <p>如果使用Database Configuration Assistant（DBCA）创建数据库并选择基本安装选项，则默认为自动内存管理。</p>
                     <div class="infoboxnotealso" id="GUID-079064A0-DBFC-45C4-B10A-1442D4667036__GUID-F2F3F67F-D0CD-4CD1-8226-A351C51FC434">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><span class="q">“ <a href="concepts-for-database-administrators.html#GUID-D39DB708-CC94-4EE6-ACDA-ACED36DA4DA5" title="内存管理涉及在数据库更改需求时保持Oracle实例内存结构的最佳大小。初始化参数设置确定如何管理SGA和实例PGA内存。">内存管理</a> ”</span> ，了解有关DBA内存管理选项的更多信息</p>
                           </li>
                           <li>
                              <p><span class="q">“ <a href="concepts-for-database-administrators.html#GUID-87ACF317-FEBC-418C-9BE6-253F2C43F482" title="Oracle提供了多种工具来简化安装和配置Oracle数据库软件的任务。">数据库安装和配置工具</a> ”</span>了解DBCA</p>
                           </li>
                           <li>
                              <p><a href="../admin/managing-memory.html#ADMIN11197" target="_blank"><span><cite>Oracle数据库管理员指南</cite></span></a> ，了解内存管理选项</p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div>
            </div><a id="CNCPT89067"></a><a id="CNCPT1238"></a><div class="props_rev_3"><a id="GUID-61B574AB-8493-4D43-8B30-0050A30550AD" name="GUID-61B574AB-8493-4D43-8B30-0050A30550AD"></a><h3 id="CNCPT-GUID-61B574AB-8493-4D43-8B30-0050A30550AD" class="sect3">用户全局区域概述</h3>
               <div>
                  <p>UGA是会话内存，它是为会话变量分配的内存，例如登录信息，以及数据库会话所需的其他信息。实质上，UGA存储会话状态。</p>
                  <p>下图描绘了UGA。</p>
                  <div class="figure" id="GUID-61B574AB-8493-4D43-8B30-0050A30550AD__BGBJCDEA">
                     <p class="titleinfigure">图14-2用户全局区域（UGA）</p><img src="img/cncpt222.gif" alt="下面是图14-2的描述" title="下面是图14-2的描述" longdesc="img_text/cncpt222.html"><br><a href="img_text/cncpt222.html">“图14-2用户全局区域（UGA）”的描述</a></div>
                  <!-- class="figure" -->
                  <p>如果会话将<a href="glossary.html#GUID-FE40E95B-5EB8-46D6-8ED2-5DB2D26C8726"><span class="xrefglossterm">PL / SQL包</span></a>加载到内存中，则UGA包含<span class="italic">包状态</span> ，该<span class="italic">状态</span>是在特定时间存储在所有包变量中的值集。当包子程序更改变量时，包状态会更改。默认情况下，包变量在会话的生命周期中是唯一的并且持久存在。
                  </p>
                  <p><a href="glossary.html#GUID-D802897B-B87B-462C-9E55-5C36226CE128"><span class="xrefglossterm">OLAP页面池</span></a>也存储在UGA中。此池管理<a href="glossary.html#GUID-A6734D1E-A45B-4BE3-ABF8-F6201A40F6B3"><span class="xrefglossterm">OLAP</span></a>数据页，它们等同于数据块。页面池在OLAP会话开始时分配，并在会话结束时释放。只要用户查询维度对象（如<a href="glossary.html#GUID-A41DC92E-57F1-4ECB-96EA-E641EEC33748"><span class="xrefglossterm">多维数据集），</span></a> OLAP会话就会自动打开。
                  </p>
                  <p>在会话期间，UGA必须可用于数据库会话。因此，在使用<a href="glossary.html#GUID-E94CE0E3-CC86-4F46-B8EF-54945F026326"><span class="xrefglossterm">共享服务器</span></a>连接时，UGA无法存储在PGA中，因为PGA特定于单个进程。因此，在使用共享服务器连接时，UGA存储在SGA中，从而允许任何共享服务器进程访问它。使用<a href="glossary.html#GUID-8B14C804-9D68-471C-A581-5AEE673A9FCD"><span class="xrefglossterm">专用服务器</span></a>连接时，UGA存储在PGA中。</p>
                  <div class="infoboxnotealso" id="GUID-61B574AB-8493-4D43-8B30-0050A30550AD__GUID-D46BD30E-0CF3-49A1-8709-4491CD633EBB">
                     <p class="notep1">也可以看看：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><span class="q">“ <a href="server-side-programming.html#GUID-87FA8137-A449-4542-8869-441C63810C63" title="PL / SQL包是一组相关的子程序，以及它们使用的游标和变量，它们一起存储在数据库中以便作为一个单元继续使用。应用程序或用户可以显式调用打包的子程序。">PL / SQL包</a> ”</span></p>
                        </li>
                        <li>
                           <p><span class="q">“ <a href="process-architecture.html#GUID-3A11FF2F-50EE-4839-A1A6-F746DFF634AB" title="数据库连接是客户端进程和数据库实例之间的物理通信路径。">连接和会话</a> ”</span></p>
                        </li>
                        <li>
                           <p><a href="../netag/understanding-oracle-net-architecture.html#NETAG210" target="_blank"><span><cite>Oracle Database Net Services管理员指南</cite></span></a> ，了解共享服务器连接</p>
                        </li>
                        <li>
                           <p><a href="../olaug/overview.html#OLAUG100" target="_blank"><span><cite>Oracle OLAP用户指南</cite></span></a> ，概述了Oracle OLAP</p>
                        </li>
                     </ul>
                  </div>
               </div>
            </div><a id="CNCPT89068"></a><a id="CNCPT803"></a><div class="props_rev_3"><a id="GUID-859795E2-87CD-442B-B36F-584A77755F59" name="GUID-859795E2-87CD-442B-B36F-584A77755F59"></a><h3 id="CNCPT-GUID-859795E2-87CD-442B-B36F-584A77755F59" class="sect3">计划全球区域（PGA）概述</h3>
               <div>
                  <p>PGA是特定于操作进程或线程的内存，不由系统上的其他进程或线程共享。因为PGA是特定于进程的，所以它永远不会在SGA中分配。</p>
                  <p>PGA是一个内存堆，包含专用或共享服务器进程所需的会话相关变量。服务器进程在PGA中分配它需要的内存结构。</p>
                  <p>PGA的类比是文件职员使用的临时工作台工作空间。在这个类比中，文件职员是代表客户（客户端进程）工作的服务器进程。职员清理工作台面的一部分，使用工作区存储有关客户请求的详细信息并对客户请求的文件夹进行排序，然后在工作完成后放弃空间。</p>
                  <p>下图显示了未为共享服务器配置的实例的实例PGA（所有PGA的集合）。您可以使用初始化参数来设置实例PGA的目标最大大小。个别PGA可以根据需要增长到此目标大小。</p>
                  <div class="figure" id="GUID-859795E2-87CD-442B-B36F-584A77755F59__BGBFGGFF">
                     <p class="titleinfigure">图14-3实例PGA</p><img src="img/cncpt218.gif" width="257" alt="下面是图14-3的描述" title="下面是图14-3的描述" longdesc="img_text/cncpt218.html"><br><a href="img_text/cncpt218.html">“图14-3实例PGA”的描述</a></div>
                  <!-- class="figure" -->
                  <div class="infoboxnote" id="GUID-859795E2-87CD-442B-B36F-584A77755F59__GUID-A3441764-26D0-4269-9F89-50A9B1825587">
                     <p class="notep1">注意：</p>
                     <p>后台进程还分配自己的PGA。本讨论仅关注服务器进程PGA。</p>
                  </div>
                  <div class="infoboxnotealso" id="GUID-859795E2-87CD-442B-B36F-584A77755F59__GUID-73AE7CC2-C339-4403-A147-62B7CC658325">
                     <p class="notep1">也可以看看：</p>
                     <p> <span class="q">“ <a href="concepts-for-database-administrators.html#GUID-17DC29B0-9741-4B80-8091-D9E1A886B357" title="内存管理是自动或手动的。">内存管理方法摘要</a> ”</span></p>
                  </div>
               </div><a id="CNCPT89069"></a><a id="CNCPT1237"></a><div class="props_rev_3"><a id="GUID-0788EAEE-0E93-497B-9ACA-401EC0F7BCA1" name="GUID-0788EAEE-0E93-497B-9ACA-401EC0F7BCA1"></a><h4 id="CNCPT-GUID-0788EAEE-0E93-497B-9ACA-401EC0F7BCA1" class="sect4">PGA的内容</h4>
                  <div>
                     <p>PGA细分为不同的区域，每个区域都有不同的用途。</p>
                     <p>下图显示了专用服务器会话的PGA的可能内容。并非所有的PGA区域都会存在。</p>
                     <div class="figure" id="GUID-0788EAEE-0E93-497B-9ACA-401EC0F7BCA1__BGBCICEI">
                        <p class="titleinfigure">图14-4 PGA内容</p><img src="img/cncpt219.gif" alt="下面是图14-4的描述" title="下面是图14-4的描述" longdesc="img_text/cncpt219.html"><br><a href="img_text/cncpt219.html">“图14-4 PGA内容”的说明</a></div>
                     <!-- class="figure" -->
                  </div><a id="CNCPT89189"></a><a id="CNCPT1239"></a><div class="props_rev_3"><a id="GUID-8C561EE3-04BC-44A9-BED0-19CDBA566810" name="GUID-8C561EE3-04BC-44A9-BED0-19CDBA566810"></a><h5 id="CNCPT-GUID-8C561EE3-04BC-44A9-BED0-19CDBA566810" class="sect5">私有SQL区域</h5>
                     <div>
                        <p><span class="bold">私有SQL区域</span>包含有关已解析的SQL语句和其他特定于会话的信息以供处理的信息。
                        </p>
                        <p>当服务器进程执行SQL或PL / SQL代码时，该进程使用私有SQL区域来存储<a href="glossary.html#GUID-456A73CB-75F4-4197-B1CD-12A51A1CBDC7"><span class="xrefglossterm">绑定变量</span></a>值，查询执行状态信息和查询执行工作区。
                        </p>
                        <p>不要将PGA中的<span class="italic">私有</span> SQL区域与<span class="italic">共享</span> SQL区域混淆，后者在SGA中存储执行计划。相同或不同会话中的多个私有SQL区域可以指向SGA中的单个执行计划。例如，在一个会话中执行20次<code class="codeph">SELECT * FROM sales</code> ，在不同会话中执行10次相同查询，可以共享同一计划。每次执行的私有SQL区域不共享，可能包含不同的值和数据。
                        </p>
                        <p><a href="glossary.html#GUID-D1D3E8DD-CD5C-4C0D-93E4-DE0BF0BD53A3"><span class="xrefglossterm">游标</span></a>是特定私有SQL区域的名称或句柄。如下图所示，您可以将游标视为客户端上的指针和服务器端的状态。由于游标与私有SQL区域紧密相关，因此这些术语有时可互换使用。
                        </p>
                        <div class="figure" id="GUID-8C561EE3-04BC-44A9-BED0-19CDBA566810__BGBJBFAE">
                           <p class="titleinfigure">图14-5光标</p><img src="img/cncpt324.gif" alt="下面是图14-5的描述" title="下面是图14-5的描述" longdesc="img_text/cncpt324.html"><br><a href="img_text/cncpt324.html">“图14-5光标”的说明</a></div>
                        <!-- class="figure" -->
                        <p>私有SQL区域分为以下几个区域：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>运行时区域</p>
                              <p>该区域包含查询执行状态信息。例如，运行时区域跟踪到目前为止在<a href="glossary.html#GUID-BF9B54D6-892E-4C3B-8536-38958ACC069D"><span class="xrefglossterm">全表扫描中</span></a>检索到的行数。
                              </p>
                              <p>Oracle数据库创建运行时区域作为执行请求的第一步。对于<a href="glossary.html#GUID-B5F2F112-1B33-41B5-B63D-9DC8F99A369D"><span class="xrefglossterm">DML</span></a>语句，SQL语句关闭时将释放运行时区域。
                              </p>
                           </li>
                           <li>
                              <p>持久性区域</p>
                              <p>该区域包含<a href="glossary.html#GUID-456A73CB-75F4-4197-B1CD-12A51A1CBDC7"><span class="xrefglossterm">绑定变量</span></a>值。执行语句时，绑定变量值在运行时提供给SQL语句。仅在光标关闭时才释放持久区域。
                              </p>
                           </li>
                        </ul>
                        <p>客户端进程负责管理私有SQL区域。私有SQL区域的分配和释放在很大程度上取决于应用程序，尽管客户端进程可以分配的私有SQL区域的数量受初始化参数<code class="codeph">OPEN_CURSORS</code>限制。</p>
                        <p>虽然大多数用户依赖于数据库实用程序的自动游标处理，但Oracle数据库编程接口为开发人员提供了对游标的更多控制。通常，应用程序应该关闭所有不会再次使用的打开游标来释放持久区域并最小化应用程序用户所需的内存。</p>
                        <div class="infoboxnotealso" id="GUID-8C561EE3-04BC-44A9-BED0-19CDBA566810__GUID-A2D832E3-D2AB-446E-9C2E-2EF928024AF0">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><span class="q">“ <a href="memory-architecture.html#GUID-0DBEB809-0660-4A04-ADF6-CABE4F6DF0B8" title="数据库表示它在共享SQL区域和私有SQL区域中运行的每个SQL语句。">共享SQL区域</a> ”</span></p>
                              </li>
                              <li>
                                 <p><a href="../adfns/coding-subprograms-and-packages.html#ADFNS00903" target="_blank"><span><cite>Oracle数据库开发指南</cite></span></a>和<a href="../lnpls/static-sql.html#LNPLS00602" target="_blank"><span><cite>Oracle数据库PL / SQL语言参考</cite></span></a> ，了解如何使用游标</p>
                              </li>
                           </ul>
                        </div>
                     </div>
                  </div><a id="CNCPT89070"></a><a id="CNCPT1242"></a><div class="props_rev_3"><a id="GUID-6DAE943E-D164-46E2-A3AC-4FFC59A7CB82" name="GUID-6DAE943E-D164-46E2-A3AC-4FFC59A7CB82"></a><h5 id="CNCPT-GUID-6DAE943E-D164-46E2-A3AC-4FFC59A7CB82" class="sect5">SQL工作区</h5>
                     <div>
                        <p><span class="bold">工作区</span>是PGA内存的专用分配，用于内存密集型操作。
                        </p>
                        <p>例如，排序运算符使用排序区域对一组行进行排序。类似地， <a href="glossary.html#GUID-D2587A67-E1CB-4F35-8830-4599717C47BC"><span class="xrefglossterm">散列连接</span></a>运算符使用散列区域从其左输入构建<a href="glossary.html#GUID-1EBD10A8-7E0A-45B9-94CB-0859F4773082"><span class="xrefglossterm">散列表</span></a> ，而<a href="glossary.html#GUID-85F90309-D2DA-455C-A726-81C33043566E"><span class="xrefglossterm">位图合并</span></a>使用位图合并区域来合并从多个位图索引的扫描中检索的数据。
                        </p>
                        <p>下面的例子显示了一个<a href="glossary.html#GUID-71A4D429-D0A6-4979-AACA-EDE5F4BCFC8B"><span class="xrefglossterm">加入</span></a>的<code class="codeph">employees</code>和<code class="codeph">departments</code> ，其<a href="glossary.html#GUID-78BCF1CD-1865-4AEB-8F14-AFA4FF1981BF"><span class="xrefglossterm">查询计划</span></a> ：</p><pre class="pre codeblock"><code>SQL&gt; SELECT * 2 FROM employees e JOIN departments d 3 ON e.department_id = d.department_id 4 ORDER BY last_name; 。。。-------------------------------------------------- ------------------------------ | ID |操作|名称|行|字节|成本（％CPU）|时间| -------------------------------------------------- ------------------------------ | 0 |选择声明| | 106 | 9328 | 7（29）| 00:00:01 | | 1 |排序顺序| | 106 | 9328 | 7（29）| 00:00:01 | | * 2 | HASH JOIN | | 106 | 9328 | 6（17）| 00:00:01 | | 3 |表访问完全|部门| 27 | 540 | 2（0）| 00:00:01 | | 4 |表访问完全|员工| 107 | 7276 | 3（0）| 00:00:01 | -------------------------------------------------- ------------------------------</code></pre><p>在前面的示例中，运行时区域跟踪全表扫描的进度。会话在散列区域中执行散列连接以匹配来自两个表的行。<code class="codeph">ORDER BY</code>排序发生在排序区域中。
                        </p>
                        <p>如果操作员要处理的数据量不适合工作区，则Oracle数据库会将输入数据分成较小的部分。通过这种方式，数据库处理内存中的一些数据片段，同时将其余数据写入临时磁盘存储器以便稍后处理。</p>
                        <p>启用自动PGA内存管理后，数据库会自动调整工作区大小。您还可以手动控制和调整工作区的大小。有关更多信息，请参阅<span class="q">“ <a href="concepts-for-database-administrators.html#GUID-D39DB708-CC94-4EE6-ACDA-ACED36DA4DA5" title="内存管理涉及在数据库更改需求时保持Oracle实例内存结构的最佳大小。初始化参数设置确定如何管理SGA和实例PGA内存。">内存管理</a> ”</span> 。
                        </p>
                        <p>通常，较大的工作区域可以以较高的存储器消耗为代价显着提高操作员的性能。最佳地，工作区的大小足以容纳由其关联的SQL运算符分配的输入数据和辅助存储器结构。否则，响应时间会增加，因为部分输入数据必须缓存在磁盘上。在极端情况下，如果工作区域的大小与输入数据大小相比太小，则数据库必须对数据块执行多次传递，从而大大增加响应时间。</p>
                        <div class="infoboxnotealso" id="GUID-6DAE943E-D164-46E2-A3AC-4FFC59A7CB82__GUID-F88BA790-8DEF-4180-A59C-DFBF076839F3">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><a href="../admin/managing-memory.html#ADMIN11233" target="_blank"><span><cite>Oracle数据库管理员指南</cite></span></a> ，了解如何使用自动PGA管理</p>
                              </li>
                              <li>
                                 <p><a href="../tgdba/tuning-program-global-area.html#TGDBA346" target="_blank"><span><cite>Oracle数据库性能调优指南</cite></span></a> ，了解如何调整PGA内存</p>
                              </li>
                           </ul>
                        </div>
                     </div>
                  </div>
               </div><a id="CNCPT89071"></a><a id="CNCPT1243"></a><div class="props_rev_3"><a id="GUID-26FCB7D9-7B1D-4F5A-88AA-1DB1E0ACD2BE" name="GUID-26FCB7D9-7B1D-4F5A-88AA-1DB1E0ACD2BE"></a><h4 id="CNCPT-GUID-26FCB7D9-7B1D-4F5A-88AA-1DB1E0ACD2BE" class="sect4">专用和共享服务器模式下的PGA使用</h4>
                  <div>
                     <p>PGA内存分配取决于数据库是使用专用服务器连接还是共享服务器连接。</p>
                     <p>下表显示了差异。</p>
                     <div class="tblformal" id="GUID-26FCB7D9-7B1D-4F5A-88AA-1DB1E0ACD2BE__G26073">
                        <p class="titleintable">表14-1专用服务器和共享服务器之间内存分配的差异</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="专用服务器和共享服务器之间的内存分配差异" width="100%" border="1" summary="This table shows the differences between dedicated and shared server architecture." frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="40%" id="d75455e3144">记忆区</th>
                                 <th align="left" valign="bottom" width="30%" id="d75455e3147">专用服务器</th>
                                 <th align="left" valign="bottom" width="30%" id="d75455e3150">共享服务器</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="40%" id="d75455e3155" headers="d75455e3144 ">
                                    <p>会话记忆的本质</p>
                                 </td>
                                 <td align="left" valign="top" width="30%" headers="d75455e3155 d75455e3147 ">
                                    <p>私人的</p>
                                 </td>
                                 <td align="left" valign="top" width="30%" headers="d75455e3155 d75455e3150 ">
                                    <p>共享</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="40%" id="d75455e3165" headers="d75455e3144 ">
                                    <p>持久区域的位置</p>
                                 </td>
                                 <td align="left" valign="top" width="30%" headers="d75455e3165 d75455e3147 ">
                                    <p>PGA</p>
                                 </td>
                                 <td align="left" valign="top" width="30%" headers="d75455e3165 d75455e3150 ">
                                    <p>SGA</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="40%" id="d75455e3175" headers="d75455e3144 ">
                                    <p>DML和DDL语句的运行时区域的位置</p>
                                 </td>
                                 <td align="left" valign="top" width="30%" headers="d75455e3175 d75455e3147 ">
                                    <p>PGA</p>
                                 </td>
                                 <td align="left" valign="top" width="30%" headers="d75455e3175 d75455e3150 ">
                                    <p>PGA</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <div class="infoboxnotealso" id="GUID-26FCB7D9-7B1D-4F5A-88AA-1DB1E0ACD2BE__GUID-3F7C0208-F532-4AF2-AD08-5B1A4709B086">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="../admin/managing-processes.html#GUID-1EC99B97-38DC-4061-A2F5-3890828616B5" target="_blank"><span><cite>Oracle数据库管理员指南</cite></span></a> ，了解如何为共享服务器配置数据库</p>
                     </div>
                  </div>
               </div>
            </div><a id="CNCPT802"></a><div class="props_rev_3"><a id="GUID-24EDB8CD-8279-4CED-82AF-642FC01A4A73" name="GUID-24EDB8CD-8279-4CED-82AF-642FC01A4A73"></a><h3 id="CNCPT-GUID-24EDB8CD-8279-4CED-82AF-642FC01A4A73" class="sect3">系统全局区域（SGA）概述</h3>
               <div>
                  <p><span class="bold">SGA</span>是一个读/写内存区域，与Oracle后台进程一起构成一个数据库实例。
                  </p>
                  <div class="infoboxnote" id="GUID-24EDB8CD-8279-4CED-82AF-642FC01A4A73__GUID-26164DEF-334F-494A-9DE2-DF996A2FDB3B">
                     <p class="notep1">注意：</p>
                     <p>服务器和后台进程不驻留<span class="italic">在</span> SGA中，而是存在于单独的内存空间中。
                     </p>
                  </div>
                  <p>代表用户执行的所有服务器进程都可以读取实例SGA中的信息。在数据库操作期间，有几个进程写入SGA。</p>
                  <p>每个数据库实例都有自己的SGA。 Oracle数据库在实例启动时自动为SGA分配内存，并在实例关闭时回收内存。使用SQL * Plus或Oracle Enterprise Manager启动实例时，SGA的大小如下例所示：</p><pre class="pre codeblock"><code>SQL&gt; STARTUP ORACLE实例已启动。系统全局总面积368283648字节固定大小1300440字节可变大小343935016字节数据库缓冲区16777216字节重做缓冲区6270976字节数据库已装入。数据库已打开
</code></pre><p><a href="memory-architecture.html#GUID-02378E7A-865B-456B-8725-1E73D16A34BE__CHDHAHIJ">如图14-1</a>所示，SGA由几个内存组件组成，这些内存组件是用于满足特定类别的内存分配请求的内存池。除重做日志缓冲区之外的所有SGA组件都以称为<span class="italic">粒度</span>的连续内存为单位分配和释放空间。颗粒大小是特定于平台的，由总SGA大小决定。
                  </p>
                  <p>您可以查询<code class="codeph">V$SGASTAT</code>视图以获取有关SGA组件的信息。
                  </p>
                  <p>最重要的SGA组件如下：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="memory-architecture.html#GUID-4FF66585-E469-4631-9225-29D75594CD14" title="数据库缓冲区高速缓存（也称为缓冲区高速缓存）是存储从数据文件读取的数据块副本的存储区。">数据库缓冲区缓存</a></p>
                     </li>
                     <li>
                        <p><a href="memory-architecture.html#GUID-80C1C6A3-3E48-4868-ACA1-370C4D341209" title="内存区域是一个可选的SGA组件，包含内存中列存储（IM列存储）。">记忆区</a></p>
                     </li>
                     <li>
                        <p><a href="memory-architecture.html#GUID-C2AD1BF6-A5AE-42E9-9677-0AA08126864B" title="重做日志缓冲区是SGA中的循环缓冲区，用于存储描述对数据库所做更改的重做条目。">重做日志缓冲区</a></p>
                     </li>
                     <li>
                        <p><a href="memory-architecture.html#GUID-1CB2BA23-4386-46DA-9146-5FE0E4599AC6" title="共享池缓存各种类型的程序数据。">共享池</a></p>
                     </li>
                     <li>
                        <p><a href="memory-architecture.html#GUID-1ECB5213-AC4E-4BB4-9113-91C761676B34" title="大型池是一个可选的内存区域，用于大于适用于共享池的内存分配。">大型游泳池</a></p>
                     </li>
                     <li>
                        <p><a href="memory-architecture.html#GUID-51234BB8-1976-4670-8BC5-BB0E3D3BA12D" title="Java池是一个内存区域，用于在Java虚拟机（JVM）中存储所有特定于会话的Java代码和数据。此内存包括在调用结束时迁移到Java会话空间的Java对象。">Java池</a></p>
                     </li>
                     <li>
                        <p><a href="memory-architecture.html#GUID-F18E4E7F-2ED9-4734-A6E4-4E77D0561C19" title="固定的SGA是内部管理区域。">固定SGA</a></p>
                     </li>
                     <li>
                        <p><a href="memory-architecture.html#GUID-9933962C-2D8C-4EC6-9FBE-E9F4AA1B4851" title="某些SGA子区域仅针对特定性能功能启用。">可选的与性能相关的SGA子区域</a></p>
                     </li>
                  </ul>
                  <div class="infoboxnotealso" id="GUID-24EDB8CD-8279-4CED-82AF-642FC01A4A73__GUID-F5E90AF3-0D70-400E-A85F-24BC049AA484">
                     <p class="notep1">也可以看看：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><span class="q">“ <a href="oracle-database-instance.html#GUID-2942B648-70FA-47B4-8950-0CC6884B1F80" title="数据库实例是一组管理数据库文件的内存结构。">Oracle数据库实例简介</a> ”</span></p>
                        </li>
                        <li>
                           <p><a href="../tgdba/tuning-system-global-area.html#GUID-8059B22B-0F5F-4492-A6D0-256E6FDF1E59" target="_blank"><span><cite>Oracle数据库性能调优指南</cite></span></a> ，了解有关粒度调整的更多信息</p>
                        </li>
                     </ul>
                  </div>
               </div><a id="CNCPT1222"></a><div class="props_rev_3"><a id="GUID-4FF66585-E469-4631-9225-29D75594CD14" name="GUID-4FF66585-E469-4631-9225-29D75594CD14"></a><h4 id="CNCPT-GUID-4FF66585-E469-4631-9225-29D75594CD14" class="sect4">数据库缓冲区缓存</h4>
                  <div>
                     <p><span class="bold">数据库缓冲区高速缓存</span> （也称为<span class="italic">缓冲区高速缓存</span> ）是存储从数据文件读取的数据块副本的存储区。
                     </p>
                     <p><a href="glossary.html#GUID-F789350A-9B90-4361-9BEF-68DECB15E755"><span class="xrefglossterm">缓冲区</span></a>是主存储器地址，缓冲区管理器临时缓存当前或最近使用的数据块。并发连接到数据库实例的所有用户共享对缓冲区缓存的访问权限。
                     </p>
                  </div><a id="CNCPT94670"></a><div class="props_rev_3"><a id="GUID-093B7282-1A44-4E29-9E9A-B8511F4267C9" name="GUID-093B7282-1A44-4E29-9E9A-B8511F4267C9"></a><h5 id="CNCPT-GUID-093B7282-1A44-4E29-9E9A-B8511F4267C9" class="sect5">数据库缓冲区高速缓存的用途</h5>
                     <div>
                        <p>Oracle数据库使用缓冲区缓存来实现多个目标。</p>
                        <p>目标包括：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>优化物理I / O.</p>
                              <p>数据库更新缓存中的数据块，并在重做日志缓冲区中存储有关更改的元数据。在<code class="codeph">COMMIT</code> ，数据库将重做缓冲区写入联机重做日志，但不会立即将数据块写入数据文件。相反， <a href="glossary.html#GUID-C27AAA54-E60B-49BC-AB04-7B3848EBAFD6"><span class="xrefglossterm">数据库写程序（DBW）</span></a>在后台执行惰性写入。
                              </p>
                           </li>
                           <li>
                              <p>将频繁访问的块保留在缓冲区高速缓存中，并将不经常访问的块写入磁盘</p>
                              <p>启用数据库智能闪存缓存（闪存缓存）时，缓冲区缓存的一部分可以驻留在闪存缓存中。此缓冲区高速缓存扩展存储在一个或多个闪存磁盘设备上，这些设备是使用闪存的固态存储设备。数据库可以通过将缓冲区缓存在闪存中而不是从磁盘读取来提高性能。</p>
                              <p>使用<code class="codeph">DB_FLASH_CACHE_FILE</code>和<code class="codeph">DB_FLASH_CACHE_SIZE</code>初始化参数来配置多个闪存设备。缓冲区缓存跟踪每个设备并统一分配缓冲区到设备。
                              </p>
                              <div class="infoboxnote" id="GUID-093B7282-1A44-4E29-9E9A-B8511F4267C9__GUID-DF24B739-1B05-425C-914A-C12DA376E428">
                                 <p class="notep1">注意：</p>
                                 <p>Database Smart Flash Cache仅在Solaris和Oracle Linux中可用。</p>
                              </div>
                           </li>
                        </ul>
                        <div class="infoboxnotealso" id="GUID-093B7282-1A44-4E29-9E9A-B8511F4267C9__GUID-5D8D8F72-76B0-4580-B6CD-4185F629F7DC">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="../refrn/DB_FLASH_CACHE_FILE.html#REFRN10315" target="_blank"><span><cite>Oracle Database Reference</cite></span></a>了解<code class="codeph">DB_FLASH_CACHE_FILE</code>初始化参数</p>
                        </div>
                     </div>
                  </div><a id="CNCPT1223"></a><div class="props_rev_3"><a id="GUID-BC14C103-F8A6-4E72-A451-EECA62F13D85" name="GUID-BC14C103-F8A6-4E72-A451-EECA62F13D85"></a><h5 id="CNCPT-GUID-BC14C103-F8A6-4E72-A451-EECA62F13D85" class="sect5">缓冲国</h5>
                     <div>
                        <p>数据库使用内部算法来管理缓存中的缓冲区。</p>
                        <p>缓冲区可以处于以下任何互斥状态：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>没用过</p>
                              <p>缓冲区可供使用，因为它从未使用过或当前未使用过。这种类型的缓冲区是数据库最容易使用的。</p>
                           </li>
                           <li>
                              <p>清洁</p>
                              <p>之前使用过此缓冲区，现在包含一个块的读取一致版本。该块包含数据但是“干净”，因此不需要检查点。数据库可以固定块并重用它。</p>
                           </li>
                           <li>
                              <p>脏</p>
                              <p>缓冲区包含尚未写入磁盘的已修改数据。数据库必须在重新使用之前检查该块。</p>
                           </li>
                        </ul>
                        <p>每个缓冲区都有一个访问模式：固定或空闲（未固定）。缓冲区被“固定”在缓存中，以便在用户会话访问缓冲区时它不会老化。多个会话无法同时修改固定缓冲区。</p>
                     </div>
                  </div><a id="CNCPT89169"></a><div class="props_rev_3"><a id="GUID-23325842-C7CB-4939-8698-FD52F36A564C" name="GUID-23325842-C7CB-4939-8698-FD52F36A564C"></a><h5 id="CNCPT-GUID-23325842-C7CB-4939-8698-FD52F36A564C" class="sect5">缓冲模式</h5>
                     <div>
                        <p>当客户端请求数据时，Oracle数据库以当前模式或一致模式从数据库缓冲区高速缓存中检索缓冲区。</p>
                        <p>模式不同如下：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>当前模式</p>
                              <p><a href="glossary.html#GUID-FEFF09C7-3935-4DA6-B85B-BB1350B79C14"><span class="xrefglossterm">当前模式get</span></a> ，也称为<span class="italic">db block get</span> ，是当前出现在缓冲区高速缓存中的块的检索。例如，如果未提交的事务已更新块中的两行，则当前模式get将使用这些未提交的行检索该块。数据库使用db块在修改语句期间最常见，它必须仅更新块的当前版本。
                              </p>
                           </li>
                           <li>
                              <p>一致的模式</p>
                              <p><a href="glossary.html#GUID-F881B50F-FA19-48CB-B512-05841067F42C"><span class="xrefglossterm">一致的读取get</span></a>是对块的读取一致版本的检索。该检索可以使用<a href="glossary.html#GUID-297B963A-989C-4720-B061-A2352FF72892"><span class="xrefglossterm">撤销数据</span></a> 。例如，如果未提交的事务已更新块中的两行，并且如果单个会话中的查询请求该块，则数据库使用撤消数据来创建此块的读取一致版本（称为<span class="italic">一致读取克隆</span> ）不包括未提交的更新。通常，查询以一致模式检索块。
                              </p>
                           </li>
                        </ul>
                        <div class="infoboxnotealso" id="GUID-23325842-C7CB-4939-8698-FD52F36A564C__GUID-75EAE1D6-73F7-4680-92ED-FC3510455A44">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><span class="q">“ <a href="data-concurrency-and-consistency.html#GUID-8DC0D1D1-C2B1-4237-9B77-27889B6467C1" title="要管理多版本读取一致性模型，数据库必须在同时查询和更新表时创建一组读取一致的数据。">读取一致性和撤消段</a> ”</span></p>
                              </li>
                              <li>
                                 <p><a href="../refrn/statistics-descriptions.html#REFRN103" target="_blank"><span><cite>Oracle Database Reference，</cite></span></a>用于描述数据库统计信息，例如db block get和一致读取get</p>
                              </li>
                           </ul>
                        </div>
                     </div>
                  </div><a id="CNCPT89146"></a><div class="props_rev_3"><a id="GUID-D1429BAA-6543-4B34-93DB-C8F33D497B53" name="GUID-D1429BAA-6543-4B34-93DB-C8F33D497B53"></a><h5 id="CNCPT-GUID-D1429BAA-6543-4B34-93DB-C8F33D497B53" class="sect5">缓冲I / O.</h5>
                     <div>
                        <p><span class="bold">逻辑I / O</span> （也称为<span class="italic">缓冲区I / O</span> ）是指缓冲区高速缓存中缓冲区的读写。
                        </p>
                        <p>当在内存中找不到请求的缓冲区时，数据库会执行物理I / O以将缓冲区从闪存缓存或磁盘复制到内存中。然后，数据库执行逻辑I / O以读取缓存的缓冲区。</p>
                     </div><a id="CNCPT94671"></a><div class="props_rev_3"><a id="GUID-43AE366D-9BDA-4C95-A7BB-46C84E4A4C18" name="GUID-43AE366D-9BDA-4C95-A7BB-46C84E4A4C18"></a><h6 id="CNCPT-GUID-43AE366D-9BDA-4C95-A7BB-46C84E4A4C18" class="sect6">缓冲区替换算法</h6>
                        <div>
                           <p>为了使缓冲区访问有效，数据库必须决定在内存中缓存哪些缓冲区以及从磁盘访问哪些缓冲区。</p>
                           <p>数据库使用以下算法：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>基于LRU的块级替换算法</p>
                                 <p>这种复杂的算法是默认的，它使用最近最少使用的（LRU）列表，该列表包含指向脏缓冲区和非脏缓冲区的指针。LRU列表具有热端和冷端。<a href="glossary.html#GUID-B427531D-6550-4071-A0C2-C46BAE6680A1"><span class="xrefglossterm">冷缓冲区</span></a>是最近未使用的缓冲区。经常访问<a href="glossary.html#GUID-6CBD65A1-DC66-44DF-B642-42EC36FE4984"><span class="xrefglossterm">热缓冲区</span></a>并且最近已经使用过。从概念上讲，只有一个LRU，但对于<a href="glossary.html#GUID-D7E696DB-944C-4798-B70D-5C2381FE971F"><span class="xrefglossterm">数据并发</span></a> ，数据库实际上使用了几个LRU。
                                 </p>
                              </li>
                              <li>
                                 <p>基于温度的对象级替换算法</p>
                                 <p>从<span>Oracle Database 12c</span>第1版（12.1.0.2）开始，自动大表缓存功能使表扫描在以下方案中使用不同的算法：</p>
                                 <ul style="list-style-type:disc">
                                    <li>
                                       <p>并行查询</p>
                                       <p>在单实例和Oracle Real Applications Cluster（Oracle RAC）数据库中，当<code class="codeph">DB_BIG_TABLE_CACHE_PERCENT_TARGET</code>初始化参数设置为非零值时，并行查询可以使用大表缓存，并且<code class="codeph">PARALLEL_DEGREE_POLICY</code>设置为<code class="codeph">auto</code>或<code class="codeph">adaptive</code> 。
                                       </p>
                                    </li>
                                    <li>
                                       <p>串行查询</p>
                                       <p>仅在单实例配置中，当<code class="codeph">DB_BIG_TABLE_CACHE_PERCENT_TARGET</code>初始化参数设置为非零值时，串行查询可以使用大表缓存。
                                       </p>
                                    </li>
                                 </ul>
                                 <p>当表不适合内存时，数据库根据访问模式决定要缓存哪些缓冲区。例如，如果只有95％的流行表适合内存，那么数据库可能会选择将5％的块留在磁盘上而不是循环地将块读入内存并将块写入磁盘 - 这种现象称为<span class="italic">颠簸</span> 。当缓存多个大对象时，数据库会考虑更热门的表格，而较不流行的表格会更冷，这会影响缓存哪些块。<code class="codeph">DB_BIG_TABLE_CACHE_PERCENT_TARGET</code>初始化参数设置使用此算法的缓冲区高速缓存的百分比。
                                 </p>
                                 <div class="infoboxnote" id="GUID-43AE366D-9BDA-4C95-A7BB-46C84E4A4C18__GUID-539C4682-EEF5-4D5E-BF16-1CC4E2C31F35">
                                    <p class="notep1">注意：</p>
                                    <p>本文档解释了基于LRU的块级替换算法。</p>
                                 </div>
                              </li>
                           </ul>
                           <div class="infoboxnotealso" id="GUID-43AE366D-9BDA-4C95-A7BB-46C84E4A4C18__GUID-81A18A9C-DC96-4371-B334-B03D1A960F9E">
                              <p class="notep1">也可以看看：</p>
                              <p><a href="../vldbg/inmemory-parallel-exec.html#GUID-A553169D-C6CD-443E-88C3-B746D5E32923" target="_blank"><span><cite>Oracle Database VLDB和分区指南</cite></span></a> ，了解有关基于温度的算法的更多信息</p>
                           </div>
                        </div>
                     </div><a id="CNCPT89074"></a><div class="props_rev_3"><a id="GUID-9247D1BA-36E3-4407-ACCE-DF212F81C019" name="GUID-9247D1BA-36E3-4407-ACCE-DF212F81C019"></a><h6 id="CNCPT-GUID-9247D1BA-36E3-4407-ACCE-DF212F81C019" class="sect6">缓冲写入</h6>
                        <div>
                           <p><span class="bold">数据库写程序（DBW）</span>进程定期将冷，脏缓冲区写入磁盘。
                           </p>
                           <p>DBW在以下情况下写入缓冲区：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>服务器进程找不到用于将新块读入数据库缓冲区高速缓存的干净缓冲区。</p>
                                 <p>当缓冲区变脏时，空闲缓冲区的数量会减少。如果数字低于内部阈值，并且需要干净缓冲区，则服务器进程会向DBW发送信号以进行写入。</p>
                                 <p>数据库使用LRU来确定要写入的脏缓冲区。当脏缓冲区到达LRU的冷端时，数据库将它们从LRU移到写入队列。如果可能，DBW使用多块写入将队列中的缓冲区写入磁盘。此机制可防止LRU的末端被脏缓冲区阻塞，并允许找到干净的缓冲区以供重用。</p>
                              </li>
                              <li>
                                 <p>数据库必须提前<a href="glossary.html#GUID-95DBDA37-4C57-444F-B660-D52B4A99D919"><span class="xrefglossterm">检查点</span></a> ，该<a href="glossary.html#GUID-95DBDA37-4C57-444F-B660-D52B4A99D919"><span class="xrefglossterm">检查点</span></a>是重做线程中必须从中开始<a href="glossary.html#GUID-FFDBC27D-CE99-49C7-8BB9-C8C2D8D52801"><span class="xrefglossterm">实例恢复</span></a>的位置。
                                 </p>
                              </li>
                              <li>
                                 <p>表空间更改为只读状态或脱机。</p>
                              </li>
                           </ul>
                           <div class="infoboxnotealso" id="GUID-9247D1BA-36E3-4407-ACCE-DF212F81C019__GUID-91053C0C-FEEA-4F87-AFA0-ABC3F0E4930D">
                              <p class="notep1">也可以看看：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p><span class="q">“ <a href="process-architecture.html#GUID-DC9CBDED-3978-450A-9D7A-0A94CE8FF233" title="数据库写程序进程（DBW）将数据库缓冲区的内容写入数据文件。DBW进程将数据库缓冲区高速缓存中的修改缓冲区写入磁盘。">数据库编写器进程（DBW）</a> ”</span></p>
                                 </li>
                                 <li>
                                    <p><a href="../tgdba/tuning-database-buffer-cache.html#GUID-F2D11BC8-986F-4A8B-A37F-530BE9EB2DA8" target="_blank"><span><cite>Oracle数据库性能调优指南</cite></span></a> ，了解如何诊断和调整缓冲区写入问题</p>
                                 </li>
                              </ul>
                           </div>
                        </div>
                     </div><a id="CNCPT89177"></a><a id="CNCPT89073"></a><div class="props_rev_3"><a id="GUID-57D00A42-6C41-4655-A268-691E84158294" name="GUID-57D00A42-6C41-4655-A268-691E84158294"></a><h6 id="CNCPT-GUID-57D00A42-6C41-4655-A268-691E84158294" class="sect6">缓冲读取</h6>
                        <div>
                           <p>当未使用的缓冲区数量较少时，数据库必须从缓冲区缓存中删除缓冲区。</p>
                           <p>该算法取决于是否启用了闪存缓存：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>Flash缓存已禁用</p>
                                 <p>数据库根据需要重新使用每个干净缓冲区，覆盖它。如果稍后需要覆盖缓冲区，则数据库必须从磁盘读取它。</p>
                              </li>
                              <li>
                                 <p>启用Flash缓存</p>
                                 <p>DBW可以将干净缓冲区的主体写入闪存缓存，从而可以重用其内存缓冲区。数据库将缓冲区头保留在主内存中的LRU列表中，以跟踪缓存主体在闪存缓存中的状态和位置。如果稍后需要此缓冲区，则数据库可以从闪存缓存而不是磁盘读取它。</p>
                              </li>
                           </ul>
                           <p>当客户端进程请求缓冲区时，服务器进程在缓冲区缓存中搜索缓冲区。如果数据库在内存中找到缓冲区，则会发生缓存命中。搜索顺序如下：</p>
                           <ol>
                              <li>
                                 <p>服务器进程在缓冲区高速缓存中搜索整个缓冲区。</p>
                                 <p>如果进程找到整个缓冲区，则数据库会对此缓冲区执行<a href="glossary.html#GUID-267C24F9-BB8A-4D14-8513-0D7DC97D8F8D"><span class="xrefglossterm">逻辑读取</span></a> 。
                                 </p>
                              </li>
                              <li>
                                 <p>服务器进程在闪存缓存LRU列表中搜索缓冲区头。</p>
                                 <p>如果进程找到缓冲区头，则数据库将执行缓冲区主体从闪存缓存到内存缓存的优化物理读取。</p>
                              </li>
                              <li>
                                 <p>如果进程<span class="italic">未</span>在内存中找到缓冲区（缓存未命中），则服务器进程执行以下步骤：</p>
                                 <ol type="a">
                                    <li>
                                       <p>将块从磁盘上的数据文件复制到内存中（物理读取）</p>
                                    </li>
                                    <li>
                                       <p>对读入内存的缓冲区执行逻辑读取</p>
                                    </li>
                                 </ol>
                              </li>
                           </ol>
                           <p><a href="memory-architecture.html#GUID-57D00A42-6C41-4655-A268-691E84158294__BGBHEHBG">图14-6</a>说明了缓冲区搜索顺序。扩展缓冲区高速缓存包括内存缓冲区高速缓存（包含整个缓冲区）和闪存高速缓存（包含缓冲区主体）。在图中，数据库在缓冲区高速缓存中搜索缓冲区，而不是找到缓冲区，从磁盘将其读入内存。
                           </p>
                           <div class="figure" id="GUID-57D00A42-6C41-4655-A268-691E84158294__BGBHEHBG">
                              <p class="titleinfigure">图14-6缓冲区搜索</p><img src="img/cncpt304.gif" alt="下面是图14-6的描述" title="下面是图14-6的描述" longdesc="img_text/cncpt304.html"><br><a href="img_text/cncpt304.html">“图14-6缓冲区搜索”的说明</a></div>
                           <!-- class="figure" -->
                           <p>通常，通过缓存命中访问数据比通过缓存未命中更快。<a href="glossary.html#GUID-51C6BAE1-58AA-4C6A-9FC3-5C4014DB2470"><span class="xrefglossterm">缓冲区高速缓存命中率</span></a>衡量数据库在缓冲区高速缓存中找到请求的块的频率，而无需从磁盘读取它。
                           </p>
                           <p>数据库可以从数据文件或<a href="glossary.html#GUID-5760E541-E0BB-4246-A423-E725E599A9D0"><span class="xrefglossterm">临时文件</span></a>执行物理读取。从数据文件读取后跟逻辑I / O.当内存不足迫使数据库将数据写入<a href="glossary.html#GUID-41501962-A37B-4D37-BAF2-59030048FE08"><span class="xrefglossterm">临时表</span></a>并稍后将其读回时，会发生临时文件的读取。这些物理读取绕过缓冲区高速缓存，不会产生逻辑I / O.</p>
                           <div class="infoboxnotealso" id="GUID-57D00A42-6C41-4655-A268-691E84158294__GUID-35576A87-8C40-4FE3-B68B-F7F4988B2D69">
                              <p class="notep1">也可以看看：</p>
                              <p><a href="../tgdba/tuning-database-buffer-cache.html#GUID-186EEE2D-11A1-401A-B9B2-E72325F972BC" target="_blank"><span><cite>Oracle数据库性能调优指南</cite></span></a> ，了解如何计算缓冲区缓存命中率</p>
                           </div>
                        </div>
                     </div><a id="CNCPT9833"></a><div class="props_rev_3"><a id="GUID-AD0569FF-DF51-4B8B-BE22-73B659199BF2" name="GUID-AD0569FF-DF51-4B8B-BE22-73B659199BF2"></a><h6 id="CNCPT-GUID-AD0569FF-DF51-4B8B-BE22-73B659199BF2" class="sect6">缓冲接触计数</h6>
                        <div>
                           <p>数据库使用触摸计数测量LRU列表上缓冲区的访问频率。这种机制使数据库能够在固定缓冲区时递增计数器，而不是在LRU列表上不断地缓冲缓冲区。</p>
                           <div class="infoboxnote" id="GUID-AD0569FF-DF51-4B8B-BE22-73B659199BF2__GUID-33BCEE66-99EC-4B9F-A4D8-13BF66B5E28C">
                              <p class="notep1">注意：</p>
                              <p>数据库不会在内存中物理移动块。移动是指针在列表上的位置变化。</p>
                           </div>
                           <p>固定缓冲区时，数据库会确定其触摸计数最后一次递增的时间。如果计数在三秒前增加，则计数增加;否则，计数保持不变。三秒规则可防止缓冲区上的引脚突发计数多次触摸。例如，会话可以在数据块中插入多行，但数据库将这些插入视为一次触摸。</p>
                           <p>如果缓冲区位于LRU的冷端，但其触摸计数很高，则缓冲区移动到热端。如果触摸计数较低，则缓冲区会从缓存中老化。</p>
                        </div>
                     </div>
                  </div><a id="CNCPT89072"></a><a id="CNCPT9832"></a><div class="props_rev_3"><a id="GUID-69531656-7F8C-4852-BB69-C4B9F0AE5437" name="GUID-69531656-7F8C-4852-BB69-C4B9F0AE5437"></a><h5 id="CNCPT-GUID-69531656-7F8C-4852-BB69-C4B9F0AE5437" class="sect5">缓冲池</h5>
                     <div>
                        <p><strong class="term">缓冲池</strong>是<strong class="term">缓冲区</strong>的集合。
                        </p>
                        <p>数据库缓冲区高速缓存分为一个或多个缓冲池，这些缓冲池以大致相同的方式管理块。这些池没有完全不同的老化或缓存块算法。</p>
                        <p>您可以手动配置单独的缓冲池，这些缓冲池可以将数据保留在缓冲区高速缓存中，也可以在使用数据块后立即使缓冲区可用于新数据。然后，您可以将特定的模式对象分配给相应的缓冲池，以控制块如何从缓存中老化。例如，您可以将段分隔为热，热和冷缓冲池。</p>
                        <p>可能的缓冲池如下：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>默认池</p>
                              <p>此池是通常缓存块的位置。除非您手动配置单独的池，否则默认池是唯一的缓冲池。其他池的可选配置对默认池没有影响。</p>
                              <p>从<span>Oracle Database 12c</span>第1版（12.1.0.2）开始， <a href="glossary.html#GUID-46A51ED5-DC39-47B0-9592-81C56414487B"><span class="xrefglossterm">大表缓存</span></a>是默认池的可选部分，它使用基于温度的对象级替换算法。在单实例和Oracle RAC数据库中，当<code class="codeph">DB_BIG_TABLE_CACHE_PERCENT_TARGET</code>初始化参数设置为非零值时，并行查询可以使用大表缓存，并且<code class="codeph">PARALLEL_DEGREE_POLICY</code>设置为<code class="codeph">auto</code>或<code class="codeph">adaptive</code> 。仅在单实例配置中，当设置<code class="codeph">DB_BIG_TABLE_CACHE_PERCENT_TARGET</code>时，串行查询可以使用大表缓存。
                              </p>
                           </li>
                           <li>
                              <p>保持游泳池</p>
                              <p>此池适用于频繁访问但由于空间不足而在默认池中老化的块。保持缓冲池的目的是将对象保留在内存中，从而避免I / O操作。</p>
                              <div class="infoboxnote" id="GUID-69531656-7F8C-4852-BB69-C4B9F0AE5437__GUID-F208A310-95A3-4D07-B76F-451F26EC93D4">
                                 <p class="notep1">注意：</p>
                                 <p>保持池以与其他池相同的方式管理缓冲区：它不使用特殊算法来固定缓冲区。“保持”一词是一种命名惯例。您可以将要保留的表放在较大的保留池中，并将不希望保留的表放在较小的回收池中。</p>
                              </div>
                           </li>
                           <li>
                              <p>回收池</p>
                              <p>此池适用于不经常使用的块。循环池可防止对象占用缓存中不必要的空间。</p>
                           </li>
                        </ul>
                        <p>数据库具有标准块大小。您可以创建块大小不同于标准大小的表空间。每个非缺省块大小都有自己的池。Oracle数据库以与默认池中相同的方式管理这些池中的块。</p>
                        <p>下图显示了使用多个池时缓冲区缓存的结构。缓存包含默认，保留和回收池。默认块大小为8 KB。缓存包含用于表空间的单独池，这些表空间使用2 KB，4 KB和16 KB的非标准块大小。</p>
                        <div class="figure" id="GUID-69531656-7F8C-4852-BB69-C4B9F0AE5437__BGBBEBCH">
                           <p class="titleinfigure">图14-7数据库缓冲区高速缓存</p><img src="img/cncpt220.gif" alt="下面是图14-7的描述" title="下面是图14-7的描述" longdesc="img_text/cncpt220.html"><br><a href="img_text/cncpt220.html">“图14-7数据库缓冲区高速缓存”的说明</a></div>
                        <!-- class="figure" -->
                        <div class="infoboxnotealso" id="GUID-69531656-7F8C-4852-BB69-C4B9F0AE5437__GUID-C89B5770-2DFC-46B4-90D9-1FBB1763A7D1">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><span class="q">“ <a href="logical-storage-structures.html#GUID-39B58094-478C-4DD9-8419-504439F4E8F7" title="每个数据库都有一个数据库块大小。">数据库块大小</a> ”</span></p>
                              </li>
                              <li>
                                 <p><a href="../admin/managing-memory.html#ADMIN11222" target="_blank"><span><cite>Oracle数据库管理员指南</cite></span></a> ，了解有关缓冲池的更多信息</p>
                              </li>
                              <li>
                                 <p><a href="../tgdba/tuning-database-buffer-cache.html#TGDBA315" target="_blank"><span><cite>Oracle数据库性能调优指南</cite></span></a> ，了解如何使用多个缓冲池</p>
                              </li>
                              <li>
                                 <p><a href="../refrn/DB_BIG_TABLE_CACHE_PERCENT_TARGET.html#GUID-122865EE-4589-434D-8DD5-4E201C6CC739" target="_blank"><span><cite>Oracle Database Reference</cite></span></a>了解<code class="codeph">DB_BIG_TABLE_CACHE_PERCENT_TARGET</code>初始化参数</p>
                              </li>
                           </ul>
                        </div>
                     </div>
                  </div><a id="CNCPT1224"></a><div class="props_rev_3"><a id="GUID-AA95A3C7-C452-4DDB-B7E4-44CB43B1E9C3" name="GUID-AA95A3C7-C452-4DDB-B7E4-44CB43B1E9C3"></a><h5 id="CNCPT-GUID-AA95A3C7-C452-4DDB-B7E4-44CB43B1E9C3" class="sect5">缓冲区和全表扫描</h5>
                     <div>
                        <p>数据库使用复杂的算法来管理表扫描。默认情况下，必须从磁盘读取缓冲区时，数据库会将缓冲区插入LRU列表的中间。通过这种方式，热块可以保留在高速缓存中，这样就不需要再次从磁盘读取它们。</p>
                        <p><a href="glossary.html#GUID-BF9B54D6-892E-4C3B-8536-38958ACC069D"><span class="xrefglossterm">全表扫描</span></a>引起问题，该<a href="glossary.html#GUID-BF9B54D6-892E-4C3B-8536-38958ACC069D"><span class="xrefglossterm">表扫描</span></a>顺序读取表<a href="glossary.html#GUID-F3F5ACB2-94C8-483F-B427-1981836D0609"><span class="xrefglossterm">高水位线（HWM）</span></a>下的所有行。假设表段中块的总大小大于缓冲区高速缓存的大小。对该表的完全扫描可以清除缓冲区高速缓存，从而防止数据库维护频繁访问的块的高速缓存。
                        </p>
                        <div class="infoboxnotealso" id="GUID-AA95A3C7-C452-4DDB-B7E4-44CB43B1E9C3__GUID-63FA5FB5-B7CA-42F1-AC89-AE0757F648CC">
                           <p class="notep1">也可以看看：</p>
                           <p><span class="q">“ <a href="logical-storage-structures.html#GUID-5050DCC5-DBBD-4B57-AB14-D83A480B9AAE" title="为了管理空间，Oracle数据库跟踪段中的块状态。高水位线（HWM）是段中的一个点，超出该段的数据块未被格式化并且从未使用过。">分段空间和高水位线</a> ”</span></p>
                        </div>
                     </div><a id="CNCPT94672"></a><div class="props_rev_3"><a id="GUID-C1918CC8-2F33-49AA-A4F4-D1ED5BF73E57" name="GUID-C1918CC8-2F33-49AA-A4F4-D1ED5BF73E57"></a><h6 id="CNCPT-GUID-C1918CC8-2F33-49AA-A4F4-D1ED5BF73E57" class="sect6">全表扫描的默认模式</h6>
                        <div>
                           <p>默认情况下，数据库采用保守的方法进行全表扫描，仅在表大小占缓冲区高速缓存的一小部分时才将小表加载到内存中。</p>
                           <p>要确定是否应缓存中型表，数据库使用的算法包含最后一次表扫描，缓冲区高速缓存的老化时间戳和缓冲区高速缓存中剩余空间之间的时间间隔。</p>
                           <p>对于非常大的表，数据库通常使用<a href="glossary.html#GUID-F824D5F8-5826-48F6-AB0D-7855B73BFB4B"><span class="xrefglossterm">直接路径读取</span></a> ，它直接将块加载到PGA中并完全绕过SGA，以避免填充缓冲区高速缓存。对于中等大小的表，数据库可以使用直接读取或高速缓存读取。如果它决定使用高速缓存读取，则数据库将块放在LRU列表的末尾，以防止扫描有效地清除缓冲区高速缓存。
                           </p>
                           <p>从<span>Oracle Database 12c</span>第1版（12.1.0.2）开始，数据库实例的缓冲区高速缓存会自动执行内部计算，以确定内存是否足以使数据库在实例SGA中完全缓存，以及在访问时缓存表是否足够对表现有益。如果整个数据库完全适合内存，并且满足各种其他内部条件，则Oracle数据库会将数据库中的所有表视为小表，并认为它们有资格进行缓存。但是，数据库不会缓存标有<code class="codeph">NOCACHE</code>属性的LOB。
                           </p>
                        </div>
                     </div><a id="CNCPT94667"></a><div class="props_rev_3"><a id="GUID-14D5B148-DDC0-4BC5-A7DA-3F28822B46B1" name="GUID-14D5B148-DDC0-4BC5-A7DA-3F28822B46B1"></a><h6 id="CNCPT-GUID-14D5B148-DDC0-4BC5-A7DA-3F28822B46B1" class="sect6">并行查询执行</h6>
                        <div>
                           <p>执行全表扫描时，数据库有时可以通过使用多个并行执行服务器来缩短响应时间。</p>
                           <p>在某些情况下，当数据库具有大量内存时，数据库可以在系统全局区域（SGA）中缓存并行查询数据，而不是使用直接路径读入程序全局区域（PGA）。通常，并行查询在低并发数据仓库中发生，因为潜在的资源使用。</p>
                           <div class="infoboxnotealso" id="GUID-14D5B148-DDC0-4BC5-A7DA-3F28822B46B1__GUID-CD90D906-005C-404A-B565-74C3E67BCA79">
                              <p class="notep1">也可以看看：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p><a href="../dwhsg/introduction-data-warehouse-concepts.html#GUID-452FBA23-6976-4590-AA41-1369647AD14D" target="_blank"><span><cite>Oracle数据库数据仓库指南</cite></span></a> ，介绍数据仓库</p>
                                 </li>
                                 <li>
                                    <p><a href="../vldbg/using-parallel.html#VLDBG010" target="_blank"><span><cite>Oracle Database VLDB和分区指南</cite></span></a>了解有关并行执行的更多信息</p>
                                 </li>
                              </ul>
                           </div>
                        </div>
                     </div><a id="CNCPT94673"></a><div class="props_rev_3"><a id="GUID-18580B49-AA0E-4ACD-AB52-8F514FE09B6A" name="GUID-18580B49-AA0E-4ACD-AB52-8F514FE09B6A"></a><h6 id="CNCPT-GUID-18580B49-AA0E-4ACD-AB52-8F514FE09B6A" class="sect6">CACHE属性</h6>
                        <div>
                           <p>在极少数情况下，不需要默认的缓存行为，您可以使用<code class="codeph">ALTER TABLE ...CACHE</code>用于更改从大型表读取数据库缓冲区高速缓存的方式。
                           </p>
                           <p>对于设置了<code class="codeph">CACHE</code>属性的表，数据库不会强制或固定缓冲区高速缓存中的块。相反，数据库以与任何其他表块相同的方式将块从缓存中移除。在执行此选项时要小心，因为对大表的完全扫描可能会清除缓存中的大多数其他块。
                           </p>
                           <div class="infoboxnote" id="GUID-18580B49-AA0E-4ACD-AB52-8F514FE09B6A__GUID-72A80A37-B8D9-44A1-BB73-D2A1530840E9">
                              <p class="notep1">注意：</p>
                              <p>执行<code class="codeph">ALTER TABLE ...CACHE</code>不会<span class="italic">导致</span>表被缓存。
                              </p>
                           </div>
                        </div>
                     </div><a id="CNCPT94674"></a><div class="props_rev_3"><a id="GUID-EF7A548D-CB7C-4FFB-8D11-CD277975ED58" name="GUID-EF7A548D-CB7C-4FFB-8D11-CD277975ED58"></a><h6 id="CNCPT-GUID-EF7A548D-CB7C-4FFB-8D11-CD277975ED58" class="sect6">保持属性</h6>
                        <div>
                           <p>对于大型表，您可以使用<code class="codeph">ALTER TABLE ...STORAGE BUFFER_POOL KEEP</code>继续使扫描将这些表的块加载到保留池中。
                           </p>
                           <p>将表放入保留池会更改缓冲区缓存中存储块的部分。数据库不是在默认缓冲池中缓存块，而是将它们缓存在保持缓冲池中。没有单独的算法控制来保持池缓存。</p>
                           <div class="infoboxnotealso" id="GUID-EF7A548D-CB7C-4FFB-8D11-CD277975ED58__GUID-CA23C813-940F-4DE8-BBF0-C646FB1FA9EF">
                              <p class="notep1">也可以看看：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>有关<code class="codeph">CACHE</code>子句和<code class="codeph">KEEP</code>属性的信息，请<a href="../sqlrf/CREATE-TABLE.html#SQLRF54597" target="_blank"><span class="italic">参见Oracle数据库SQL语言参考</span></a></p>
                                 </li>
                                 <li>
                                    <p><a href="../tgdba/tuning-database-buffer-cache.html#GUID-DE6B6C6E-D947-45FF-B189-F0271B86DB10" target="_blank"><span class="italic">Oracle数据库性能调优指南</span></a> ，了解如何解释缓冲区缓存顾问统计信息</p>
                                 </li>
                              </ul>
                           </div>
                        </div>
                     </div><a id="CNCPT94675"></a><div class="props_rev_3"><a id="GUID-6A62FF03-2D75-471F-AF8B-A5688E3A8F48" name="GUID-6A62FF03-2D75-471F-AF8B-A5688E3A8F48"></a><h6 id="CNCPT-GUID-6A62FF03-2D75-471F-AF8B-A5688E3A8F48" class="sect6">强制完全数据库缓存模式</h6>
                        <div>
                           <p>要在某些情况下提高性能，您可以显式执行<code class="codeph">ALTER DATABASE ...FORCE FULL DATABASE CACHING</code>语句启用<strong class="term">强制完全数据库缓存模式</strong> 。
                           </p>
                           <p>与默认模式（自动）相反，强制完全数据库缓存模式将整个数据库（包括<code class="codeph">NOCACHE</code> LOB）视为符合数据库缓冲区缓存中的缓存条件。从<span>Oracle Database 12c</span>第1版（12.1.0.2）开始提供此模式。
                           </p>
                           <div class="infoboxnote" id="GUID-6A62FF03-2D75-471F-AF8B-A5688E3A8F48__GUID-9C27C724-D24F-418C-A05C-9988F457051B">
                              <p class="notep1">注意：</p>
                              <p>启用动力最大数据库高速缓存模式<span class="italic">不</span>强制数据库到内存中。相反，整个数据库有<span class="italic">资格</span>缓存在缓冲区缓存中。Oracle数据库仅在访问表时才缓存表。
                              </p>
                           </div>
                           <p>Oracle建议仅在每个实例的缓冲区高速缓存大小大于数据库大小时启用强制完全数据库高速缓存模式。本指南适用于单实例和Oracle RAC数据库。但是，当Oracle RAC应用程序分区良好时，如果所有实例的组合缓冲区高速缓存（用于处理实例之间的重复高速缓存块的额外空间）大于数据库大小，则可以启用强制完全数据库高速缓存模式。</p>
                           <div class="infoboxnotealso" id="GUID-6A62FF03-2D75-471F-AF8B-A5688E3A8F48__GUID-3A7D5C4C-5206-4E6A-84E0-9B3B12F58900">
                              <p class="notep1">也可以看看：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p><a href="../admin/managing-memory.html#ADMIN14237" target="_blank"><span><cite>Oracle数据库管理员指南</cite></span></a> ，了解如何启用强制完全数据库缓存模式</p>
                                 </li>
                                 <li>
                                    <p>有关<code class="codeph">ALTER DATABASE ...更多信息，请参阅<a href="../sqlrf/ALTER-DATABASE.html#SQLRF56678" target="_blank"><span><cite>Oracle数据库SQL语言参考</cite></span></a> <code class="codeph">ALTER DATABASE ...FORCE FULL DATABASE CACHING</code>语句</p>
                                 </li>
                              </ul>
                           </div>
                        </div>
                     </div>
                  </div>
               </div><a id="CNCPT89075"></a><a id="CNCPT1225"></a><div class="props_rev_3"><a id="GUID-C2AD1BF6-A5AE-42E9-9677-0AA08126864B" name="GUID-C2AD1BF6-A5AE-42E9-9677-0AA08126864B"></a><h4 id="CNCPT-GUID-C2AD1BF6-A5AE-42E9-9677-0AA08126864B" class="sect4">重做日志缓冲区</h4>
                  <div>
                     <p><span class="bold">重做日志缓冲区</span>是SGA中的循环缓冲区，用于存储描述对数据库所做更改的重做条目。
                     </p>
                     <p><a href="glossary.html#GUID-F73D3BEC-7C9E-4BE0-A30F-D7E1DA4F217A"><span class="xrefglossterm">重做记录</span></a>是一种数据结构，其中包含重建或重做DML或DDL操作对数据库所做更改所需的信息。数据库恢复将重做条目应用于数据文件以重建丢失的更改。
                     </p>
                     <p>数据库处理将重做条目从用户存储空间复制到SGA中的重做日志缓冲区。重做条目占用缓冲区中连续的连续空间。后台进程<a href="glossary.html#GUID-E96BC851-0B78-4250-8EAB-26EBDF4FE5A6"><span class="xrefglossterm">日志写入器进程（LGWR）</span></a>将重做日志缓冲区写入磁盘上的活动联机重做日志组。<a href="memory-architecture.html#GUID-C2AD1BF6-A5AE-42E9-9677-0AA08126864B__BGBFDAHB">图14-8</a>显示了此重做缓冲区活动。
                     </p>
                     <div class="figure" id="GUID-C2AD1BF6-A5AE-42E9-9677-0AA08126864B__BGBFDAHB">
                        <p class="titleinfigure">图14-8重做日志缓冲区</p><img src="img/cncpt226.gif" alt="下面是图14-8的描述" title="下面是图14-8的描述" longdesc="img_text/cncpt226.html"><br><a href="img_text/cncpt226.html">“图14-8重做日志缓冲区”的说明</a></div>
                     <!-- class="figure" -->
                     <p>LGWR按顺序将重做写入磁盘，而DBW则将数据块分散写入磁盘。分散写入往往比顺序写入慢得多。由于LGWR使用户能够避免等待DBW完成其慢速写入，因此数据库可提供更好的性能。</p>
                     <p><code class="codeph">LOG_BUFFER</code>初始化参数指定Oracle数据库在缓冲重做条目时使用的内存量。与其他SGA组件不同，重做日志缓冲区和固定SGA缓冲区不会将内存划分为颗粒。
                     </p>
                     <div class="infoboxnotealso" id="GUID-C2AD1BF6-A5AE-42E9-9677-0AA08126864B__GUID-C0180021-8641-4BF3-A2D9-D5A28C4AF40F">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><span class="q">“ <a href="process-architecture.html#GUID-B6BE2C31-1543-4504-9763-6FFBBF99DC85" title="日志写入器进程（LGWR）管理联机重做日志缓冲区。">日志编写器进程（LGWR）</a> ”</span>和<span class="q">“ <a href="oracle-database-instance.html#GUID-19F515DA-AA77-4138-853B-1C41A759D76E" title="实例恢复使用检查点来确定必须对数据文件应用哪些更改。检查点位置保证SCN低于检查点SCN的每个已提交更改都保存到数据文件中。">实例恢复检查点的重要性</a> ”</span></p>
                           </li>
                           <li>
                              <p>有关联机重做日志的信息，请参见<a href="../admin/managing-the-redo-log.html#ADMIN11302" target="_blank"><span><cite>“Oracle数据库管理员指南”</cite></span></a></p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="CNCPT89076"></a><a id="CNCPT1226"></a><div class="props_rev_3"><a id="GUID-1CB2BA23-4386-46DA-9146-5FE0E4599AC6" name="GUID-1CB2BA23-4386-46DA-9146-5FE0E4599AC6"></a><h4 id="CNCPT-GUID-1CB2BA23-4386-46DA-9146-5FE0E4599AC6" class="sect4">共享池</h4>
                  <div>
                     <p><span class="bold">共享池</span>缓存各种类型的程序数据。
                     </p>
                     <p>例如，共享池存储已解析的SQL，PL / SQL代码，系统参数和<a href="glossary.html#GUID-D6A3934F-BA6D-464F-9612-C683E20514A4"><span class="xrefglossterm">数据字典</span></a>信息。共享池几乎涉及数据库中发生的每个操作。例如，如果用户执行SQL语句，则Oracle数据库将访问共享池。
                     </p>
                     <p>共享池分为几个子组件，其中最重要的子组件<a href="memory-architecture.html#GUID-1CB2BA23-4386-46DA-9146-5FE0E4599AC6__BGBIAJIG">如图14-9</a>所示。
                     </p>
                     <div class="figure" id="GUID-1CB2BA23-4386-46DA-9146-5FE0E4599AC6__BGBIAJIG">
                        <p class="titleinfigure">图14-9共享池</p><img src="img/cncpt225.gif" alt="下面是图14-9的描述" title="下面是图14-9的描述" longdesc="img_text/cncpt225.html"><br><a href="img_text/cncpt225.html">“图14-9共享池”的说明</a></div>
                     <!-- class="figure" -->
                     <p>本节包括以下主题：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="memory-architecture.html#GUID-DE757E9C-3437-408A-8598-3EB4C8E2A3B0" title="库高速缓存是一个共享池内存结构，用于存储可执行的SQL和PL / SQL代码。">库缓存</a></p>
                        </li>
                        <li>
                           <p><a href="memory-architecture.html#GUID-66430838-7862-4389-96B5-795B99A72473" title="数据字典是数据库表和视图的集合，包含有关数据库，其结构和用户的参考信息。">数据字典缓存</a></p>
                        </li>
                        <li>
                           <p><a href="memory-architecture.html#GUID-675AAFFB-E915-4197-8159-C0CF1C009973" title="服务器结果缓存是共享池中的内存池。与缓冲池不同，服务器结果缓存保存结果集而不是数据块。">服务器结果缓存</a></p>
                        </li>
                        <li>
                           <p><a href="memory-architecture.html#GUID-A1D3C388-AB6B-4FD1-BD40-FEDB8CF307F8" title="保留池是共享池中的一个内存区域，Oracle数据库可以使用它来分配大量连续的内存块。">预留池</a></p>
                        </li>
                     </ul>
                  </div><a id="CNCPT1227"></a><div class="props_rev_3"><a id="GUID-DE757E9C-3437-408A-8598-3EB4C8E2A3B0" name="GUID-DE757E9C-3437-408A-8598-3EB4C8E2A3B0"></a><h5 id="CNCPT-GUID-DE757E9C-3437-408A-8598-3EB4C8E2A3B0" class="sect5">库缓存</h5>
                     <div>
                        <p><span class="bold">库高速缓存</span>是一个共享池内存结构，用于存储可执行的SQL和PL / SQL代码。
                        </p>
                        <p>此缓存包含共享的SQL和PL / SQL区域以及控件结构，例如锁和库缓存句柄。在共享服务器体系结构中，库高速缓存还包含私有SQL区域。</p>
                        <p>执行SQL语句时，数据库会尝试重用以前执行的代码。如果库缓存中存在已解析的SQL语句表示并且可以共享，则数据库将重用该代码，称为<a href="glossary.html#GUID-A9D78636-6F7B-472B-8AC6-4B07C775DE00"><span class="xrefglossterm">软解析</span></a>或<span class="italic">库缓存命中</span> 。否则，数据库必须构建应用程序代码的新可执行版本，称为<a href="glossary.html#GUID-1BFB2AF7-BC88-4A93-B9AA-C75CA62C5824"><span class="xrefglossterm">硬解析</span></a>或<span class="italic">库高速缓存未命中</span> 。
                        </p>
                     </div><a id="CNCPT89077"></a><a id="CNCPT1228"></a><div class="props_rev_3"><a id="GUID-0DBEB809-0660-4A04-ADF6-CABE4F6DF0B8" name="GUID-0DBEB809-0660-4A04-ADF6-CABE4F6DF0B8"></a><h6 id="CNCPT-GUID-0DBEB809-0660-4A04-ADF6-CABE4F6DF0B8" class="sect6">共享SQL区域</h6>
                        <div>
                           <p>数据库表示它在共享SQL区域和私有SQL区域中运行的每个SQL语句。</p>
                           <p>数据库使用共享SQL区域来处理第一次出现的SQL语句。所有用户都可以访问此区域，并包含语句分析树和<a href="glossary.html#GUID-2DF33B85-94BB-44F3-93B7-06916FB18361"><span class="xrefglossterm">执行计划</span></a> 。唯一语句只存在一个共享SQL区域。发出SQL语句的每个会话在其PGA中都有一个私有SQL区域。提交相同语句的每个用户都有一个指向同一共享SQL区域的私有SQL区域。因此，单独的PGA中的许多私有SQL区域可以与相同的共享SQL区域相关联。
                           </p>
                           <p>数据库自动确定应用程序何时提交类似的SQL语句。数据库考虑用户和应用程序直接发出的SQL语句以及其他语句在内部发出的递归SQL语句。</p>
                           <p>数据库执行以下步骤：</p>
                           <ol>
                              <li>
                                 <p>检查共享池以查看是否存在语法和语义相同的语句的共享SQL区域：</p>
                                 <ul style="list-style-type:disc">
                                    <li>
                                       <p>如果存在相同的语句，则数据库使用共享SQL区域来执行语句的后续新实例，从而减少内存消耗。</p>
                                    </li>
                                    <li>
                                       <p>如果不存在相同的语句，则数据库将在共享池中分配新的共享SQL区域。具有相同语法但语义不同的语句使用<a href="glossary.html#GUID-8230A43B-CD9B-4A64-9D59-182F747A0BD5"><span class="xrefglossterm">子游标</span></a> 。
                                       </p>
                                    </li>
                                 </ul>
                                 <p>在任何一种情况下，用户的私有SQL区域都指向包含语句和执行计划的共享SQL区域。</p>
                              </li>
                              <li>
                                 <p>代表会话分配私有SQL区域</p>
                                 <p>私有SQL区域的位置取决于为会话建立的连接。如果会话通过共享服务器连接，则部分私有SQL区域保留在SGA中。</p>
                              </li>
                           </ol>
                           <p><a href="memory-architecture.html#GUID-0DBEB809-0660-4A04-ADF6-CABE4F6DF0B8__BGBGFFFF">图14-10</a>显示了一个专用服务器体系结构，其中两个会话在其自己的PGA中保留相同SQL语句的副本。在共享服务器中，此副本位于UGA中，当存在大型池时，该UGA位于大型池或共享池中。
                           </p>
                           <div class="figure" id="GUID-0DBEB809-0660-4A04-ADF6-CABE4F6DF0B8__BGBGFFFF">
                              <p class="titleinfigure">图14-10私有SQL区域和共享SQL区域</p><img src="img/cncpt252.gif" alt="下面是图14-10的描述" title="下面是图14-10的描述" longdesc="img_text/cncpt252.html"><br><a href="img_text/cncpt252.html">“图14-10私有SQL区域和共享SQL区域”的说明</a></div>
                           <!-- class="figure" -->
                           <div class="infoboxnotealso" id="GUID-0DBEB809-0660-4A04-ADF6-CABE4F6DF0B8__GUID-9994EA56-128F-4651-95E7-0B3DFCBB0449">
                              <p class="notep1">也可以看看：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p><span class="q">“ <a href="memory-architecture.html#GUID-8C561EE3-04BC-44A9-BED0-19CDBA566810" title="私有SQL区域包含有关已解析的SQL语句和其他特定于会话的信息以供处理的信息。">私有SQL区</a> ”</span></p>
                                 </li>
                                 <li>
                                    <p><a href="../tgdba/tuning-shared-pool-and-large-pool.html#TGDBA562" target="_blank"><span><cite>Oracle数据库性能调整指南</cite></span></a> ，了解有关管理库高速缓存的更多信息</p>
                                 </li>
                                 <li>
                                    <p>有关共享SQL的详细信息，请参见<a href="../adfns/sql-processing-for-application-developers.html#ADFNS99965" target="_blank"><span><cite>Oracle数据库开发指南</cite></span></a></p>
                                 </li>
                              </ul>
                           </div>
                        </div>
                     </div><a id="CNCPT1230"></a><div class="props_rev_3"><a id="GUID-59808C48-B7AF-49D5-A3BA-D923655FE9CE" name="GUID-59808C48-B7AF-49D5-A3BA-D923655FE9CE"></a><h6 id="CNCPT-GUID-59808C48-B7AF-49D5-A3BA-D923655FE9CE" class="sect6">程序单元和库高速缓存</h6>
                        <div>
                           <p>库高速缓存包含PL / SQL程序和Java类的可执行形式。这些项目统称为<span class="italic">计划单位</span> 。
                           </p>
                           <p>数据库处理程序单元与SQL语句类似。例如，数据库分配一个共享区域来保存PL / SQL程序的已解析的编译形式。数据库分配一个专用区域来保存特定于运行程序的会话的值，包括本地，全局和包变量，以及用于执行SQL的缓冲区。如果多个用户运行相同的程序，则每个用户都维护其私有SQL区域的单独副本，该区域保存特定于会话的值，并访问单个共享SQL区域。</p>
                           <p>如前所述，数据库处理PL / SQL程序单元内的各个SQL语句。尽管它们起源于PL / SQL程序单元，但这些SQL语句使用共享区域来保存其解析的表示，并为运行该语句的每个会话使用私有区域。</p>
                        </div>
                     </div><a id="CNCPT1232"></a><div class="props_rev_3"><a id="GUID-F41EF3AF-42D7-4445-A2DD-E800A5E54E3F" name="GUID-F41EF3AF-42D7-4445-A2DD-E800A5E54E3F"></a><h6 id="CNCPT-GUID-F41EF3AF-42D7-4445-A2DD-E800A5E54E3F" class="sect6">共享池中内存的分配和重用</h6>
                        <div>
                           <p>解析新SQL语句时，数据库会分配共享池内存，除非该语句是DDL，不认为是可共享的。分配的内存大小取决于语句的复杂程度。</p>
                           <p>通常，共享池中的项目将保留，直到数据库根据最近最少使用（LRU）算法将其删除。只要数据库有用，数据库允许许多会话使用的共享池项目保留在内存中，即使创建项目的数据库进程终止也是如此。此机制可最大限度地减少SQL语句的开销和处理。如果新项目需要空间，则数据库将释放不常使用的项目所消耗的内存。</p>
                           <p><code class="codeph">ALTER SYSTEM FLUSH SHARED_POOL</code>语句删除共享池中的所有信息，更改<a href="glossary.html#GUID-2820B9D9-E349-4A2D-9BDA-E0B3BD1772D1"><span class="xrefglossterm">全局数据库名称也是如此</span></a> 。
                           </p>
                           <div class="infoboxnotealso" id="GUID-F41EF3AF-42D7-4445-A2DD-E800A5E54E3F__GUID-0619567A-5B52-4AC8-8B55-4D56790AF7C3">
                              <p class="notep1">也可以看看：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p><a href="../tgsql/improving-rwp-cursor-sharing.html#TGSQL-GUID-E04CF45D-CC70-4122-9BAC-EAB5B4D0E17A" target="_blank"><span><cite>“Oracle数据库SQL调优指南”</cite></span></a> ，概述共享SQL区域的生命周期</p>
                                 </li>
                                 <li>
                                    <p>有关使用<code class="codeph">ALTER SYSTEM FLUSH SHARED_POOL</code>信息，请<a href="../sqlrf/ALTER-SYSTEM.html#SQLRF53120" target="_blank"><span><cite>参见Oracle数据库SQL语言参考</cite></span></a></p>
                                 </li>
                                 <li>
                                    <p>有关<code class="codeph">V$SQL</code>和<code class="codeph">V$SQLAREA</code>动态视图的信息，请参阅<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/cncpt&amp;id=REFRN30246" target="_blank"><span><cite>Oracle数据库参考</cite></span></a></p>
                                 </li>
                              </ul>
                           </div>
                        </div>
                     </div>
                  </div><a id="CNCPT1231"></a><div class="props_rev_3"><a id="GUID-66430838-7862-4389-96B5-795B99A72473" name="GUID-66430838-7862-4389-96B5-795B99A72473"></a><h5 id="CNCPT-GUID-66430838-7862-4389-96B5-795B99A72473" class="sect5">数据字典缓存</h5>
                     <div>
                        <p><strong class="term">数据字典</strong>是数据库表和视图的集合，包含有关数据库，其结构和用户的参考信息。
                        </p>
                        <p>Oracle数据库在SQL语句解析期间经常访问数据字典。Oracle数据库经常访问数据字典，指定以下特殊内存位置来保存字典数据：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>数据字典缓存</p>
                              <p>此缓存包含有关数据库对象的信息。缓存也称为<span class="italic">行缓存，</span>因为它将数据保存为行而不是缓冲区。
                              </p>
                           </li>
                           <li>
                              <p>库缓存</p>
                           </li>
                        </ul>
                        <p>所有服务器进程共享这些高速缓存以访问数据字典信息。</p>
                        <div class="infoboxnotealso" id="GUID-66430838-7862-4389-96B5-795B99A72473__GUID-92447A87-B604-414F-B9AB-D205278EB02C">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><span class="q">“ <a href="data-dictionary-and-dynamic-performance-views.html#GUID-BDF5B748-EB43-4B48-938E-89099069C3BB" title="每个Oracle数据库的中央只读参考表和视图集合统称为数据字典。动态性能视图是在数据库打开和使用时不断更新的特殊视图。">数据字典和动态性能视图</a> ”</span></p>
                              </li>
                              <li>
                                 <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/cncpt&amp;id=TGDBA593" target="_blank"><span><cite>Oracle数据库性能调优指南</cite></span></a> ，了解如何为数据字典缓存分配额外的内存</p>
                              </li>
                           </ul>
                        </div>
                     </div>
                  </div><a id="CNCPT1919"></a><div class="props_rev_3"><a id="GUID-675AAFFB-E915-4197-8159-C0CF1C009973" name="GUID-675AAFFB-E915-4197-8159-C0CF1C009973"></a><h5 id="CNCPT-GUID-675AAFFB-E915-4197-8159-C0CF1C009973" class="sect5">服务器结果缓存</h5>
                     <div>
                        <p><span class="bold">服务器结果缓存</span>是共享池中的内存池。与缓冲池不同，服务器结果缓存保存结果集而不是数据块。
                        </p>
                        <p>服务器结果缓存包含<a href="glossary.html#GUID-EAEA5633-B660-4D51-99FF-48B596750DB8"><span class="xrefglossterm">SQL查询结果缓存</span></a>和<a href="glossary.html#GUID-9804DF97-092F-48A5-827B-67F1065ADAB3"><span class="xrefglossterm">PL / SQL函数结果缓存</span></a> ，它们共享相同的基础结构。
                        </p>
                        <div class="infoboxnote" id="GUID-675AAFFB-E915-4197-8159-C0CF1C009973__GUID-423E25C2-A44B-443C-BAA8-341F7F571C8F">
                           <p class="notep1">注意：</p>
                           <p>客户端结果缓存与服务器结果缓存不同。客户端缓存在应用程序级别配置，位于客户端内存中，而不是数据库内存中。</p>
                        </div>
                        <div class="infoboxnotealso" id="GUID-675AAFFB-E915-4197-8159-C0CF1C009973__GUID-2FF2AC7A-F5D1-4995-AD57-D9F507BA14D3">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>有关调整结果缓存大小的信息，请参见“ <a href="../admin/managing-memory.html#ADMIN11228" target="_blank"><span><cite>Oracle数据库管理员指南”</cite></span></a></p>
                              </li>
                              <li>
                                 <p>有关<code class="codeph">DBMS_RESULT_CACHE</code>包的信息，请参阅<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/cncpt&amp;id=ARPLS202" target="_blank"><span><cite>Oracle Database PL / SQL包和类型参考</cite></span></a></p>
                              </li>
                              <li>
                                 <p>有关客户端结果缓存的详细信息，请<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/cncpt&amp;id=TGDBA638" target="_blank"><span><cite>参见“Oracle数据库性能调整指南”</cite></span></a></p>
                              </li>
                           </ul>
                        </div>
                     </div><a id="CNCPT1920"></a><div class="props_rev_3"><a id="GUID-A778611A-E802-4D9B-A645-90CDA658D61F" name="GUID-A778611A-E802-4D9B-A645-90CDA658D61F"></a><h6 id="CNCPT-GUID-A778611A-E802-4D9B-A645-90CDA658D61F" class="sect6">SQL查询结果缓存</h6>
                        <div>
                           <p><span class="bold">SQL查询结果缓存</span>是服务器结果缓存的子集，用于存储查询和查询片段的结果。
                           </p>
                           <p>大多数应用程序都受益于此性能改进考虑一个重复运行相同<code class="codeph">SELECT</code>语句的应用程序。如果结果被缓存，则数据库立即返回它们。通过这种方式，数据库避免了重新读取块和重新计算结果的昂贵操作。
                           </p>
                           <p>执行查询时，数据库将搜索内存以确定结果缓存中是否存在结果。如果结果存在，则数据库从内存中检索结果，而不是执行查询。如果未缓存结果，则数据库执行查询，将结果作为输出返回，然后将结果存储在结果缓存中。只要事务修改用于构造缓存结果的数据库对象的数据或元数据，数据库就会自动使缓存的结果无效。</p>
                           <p>用户可以使用<code class="codeph">RESULT_CACHE</code> <a href="glossary.html#GUID-B2534A3C-7E63-45E3-A61F-3746124B7CCA"><span class="xrefglossterm">提示</span></a>注释查询或查询片段，以指示数据库应将结果存储在SQL查询结果缓存中。<code class="codeph">RESULT_CACHE_MODE</code>初始化参数确定SQL查询结果缓存是用于所有查询（如果可能），还是仅用于带注释的查询。
                           </p>
                           <div class="infoboxnotealso" id="GUID-A778611A-E802-4D9B-A645-90CDA658D61F__GUID-35051DAA-5A96-42DF-92C1-CD280D4A636F">
                              <p class="notep1">也可以看看：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/cncpt&amp;id=REFRN10270" target="_blank"><span><cite>Oracle Database Reference</cite></span></a>了解有关<code class="codeph">RESULT_CACHE_MODE</code>初始化参数的更多信息</p>
                                 </li>
                                 <li>
                                    <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/cncpt&amp;id=SQLRF20004" target="_blank"><span><cite>Oracle Database SQL语言参考</cite></span></a> ，了解<code class="codeph">RESULT_CACHE</code>提示</p>
                                 </li>
                              </ul>
                           </div>
                        </div>
                     </div><a id="CNCPT1921"></a><div class="props_rev_3"><a id="GUID-1E702BCE-CA52-472E-918B-0C5FB8C09767" name="GUID-1E702BCE-CA52-472E-918B-0C5FB8C09767"></a><h6 id="CNCPT-GUID-1E702BCE-CA52-472E-918B-0C5FB8C09767" class="sect6">PL / SQL函数结果缓存</h6>
                        <div>
                           <p><span class="bold">PL / SQL函数结果缓存</span>是存储函数结果集的服务器结果缓存的子集。
                           </p>
                           <p>如果没有缓存，每次调用1次的1000次函数调用将需要1000秒。使用缓存，具有相同输入的1000个函数调用可能<span class="italic">总共</span>需要1秒。结果缓存的良好候选者经常被调用依赖于相对静态数据的函数。
                           </p>
                           <p>PL / SQL功能代码可以包括缓存其结果的请求。在调用此函数时，系统会检查缓存。如果高速缓存包含具有相同参数值的先前函数调用的结果，则系统将高速缓存的结果返回给调用者，并且不重新执行函数体。如果缓存不包含结果，则系统执行函数体并将结果（对于这些参数值）添加到缓存中，然后将控制权返回给调用者。</p>
                           <div class="infoboxnote" id="GUID-1E702BCE-CA52-472E-918B-0C5FB8C09767__GUID-A6601CDA-7D49-484C-BA32-C81129F6E79C">
                              <p class="notep1">注意：</p>
                              <p>您可以指定Oracle数据库用于计算缓存结果的数据库对象，以便在更新任何数据库对象时，缓存的结果将变为无效，必须重新计算。</p>
                           </div>
                           <p>缓存可以累积许多结果 - 每个唯一的参数值组合的一个结果，用于调用每个结果缓存函数。如果数据库需要更多内存，那么它会使一个或多个缓存结果老化。</p>
                           <div class="infoboxnotealso" id="GUID-1E702BCE-CA52-472E-918B-0C5FB8C09767__GUID-5C5CBFD5-A598-49EF-81F9-46F978727B7E">
                              <p class="notep1">也可以看看：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/cncpt&amp;id=ADFNS333" target="_blank"><span><cite>Oracle数据库开发指南</cite></span></a> ，了解有关PL / SQL函数结果缓存的更多信息</p>
                                 </li>
                                 <li>
                                    <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/cncpt&amp;id=LNPLS00817" target="_blank"><span><cite>Oracle Database PL / SQL语言参考，</cite></span></a>以了解有关PL / SQL函数结果缓存的更多信息</p>
                                 </li>
                              </ul>
                           </div>
                        </div>
                     </div>
                  </div><a id="CNCPT9835"></a><div class="props_rev_3"><a id="GUID-A1D3C388-AB6B-4FD1-BD40-FEDB8CF307F8" name="GUID-A1D3C388-AB6B-4FD1-BD40-FEDB8CF307F8"></a><h5 id="CNCPT-GUID-A1D3C388-AB6B-4FD1-BD40-FEDB8CF307F8" class="sect5">预留池</h5>
                     <div>
                        <p><span class="bold">保留池</span>是共享池中的一个内存区域，Oracle数据库可以使用它来分配大量连续的内存块。
                        </p>
                        <p>数据库以块的形式从共享池中分配内存。Chunking允许将大对象（超过5 KB）加载到缓存中，而不需要单个连续区域。通过这种方式，数据库可以减少由于碎片而耗尽连续内存的可能性。</p>
                        <p>Java，PL / SQL或SQL游标很少会从共享池中进行大于5 KB的分配。为了使这些分配最有效地发生，数据库将为保留池分离少量共享池。</p>
                        <div class="infoboxnotealso" id="GUID-A1D3C388-AB6B-4FD1-BD40-FEDB8CF307F8__GUID-4A8B314F-BEF2-436B-AA82-10E0804A9843">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/cncpt&amp;id=TGDBA605" target="_blank"><span><cite>Oracle数据库性能调整指南</cite></span></a> ，了解如何配置保留池</p>
                        </div>
                     </div>
                  </div>
               </div><a id="CNCPT89078"></a><a id="CNCPT1233"></a><div class="props_rev_3"><a id="GUID-1ECB5213-AC4E-4BB4-9113-91C761676B34" name="GUID-1ECB5213-AC4E-4BB4-9113-91C761676B34"></a><h4 id="CNCPT-GUID-1ECB5213-AC4E-4BB4-9113-91C761676B34" class="sect4">大型游泳池</h4>
                  <div>
                     <p><strong class="term">大型池</strong>是一个可选的内存区域，用于大于适用于共享池的内存分配。
                     </p>
                     <p>大型池可以为以下内容提供大量内存分配：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>用于共享服务器和<a href="glossary.html#GUID-4805B3F4-1858-473B-A802-3496C73CE818"><span class="xrefglossterm">Oracle XA</span></a>接口的UGA（用于事务与多个数据库交互的位置）</p>
                        </li>
                        <li>
                           <p>并行执行中使用的消息缓冲区</p>
                        </li>
                        <li>
                           <p>恢复管理器（RMAN）I / O从站的缓冲区</p>
                        </li>
                        <li>
                           <p><span>延迟插入</span>的缓冲区（使用<code class="codeph">MEMOPTIMIZE_WRITE</code>提示插入）</p>
                        </li>
                     </ul>
                     <p>下图描绘了大型池。</p>
                     <div class="figure" id="GUID-1ECB5213-AC4E-4BB4-9113-91C761676B34__BGBDJBCF">
                        <p class="titleinfigure">图14-11大池</p><img src="img/cncpt221.png" alt="下面是图14-11的描述" title="下面是图14-11的描述" longdesc="img_text/cncpt221.html"><br><a href="img_text/cncpt221.html">“图14-11大池”的描述</a></div>
                     <!-- class="figure" -->
                     <div class="infoboxnotealso" id="GUID-1ECB5213-AC4E-4BB4-9113-91C761676B34__GUID-76E7713A-12B1-4CF6-9AF9-D7C42291CC47">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><span class="q">“ <a href="process-architecture.html#GUID-6487F7FA-2299-4428-8588-7937BD8675D3" title="在并行执行中，服务器进程充当查询协调器（也称为并行执行协调器）。">查询协调器</a> ”，</span>以获取有关为并行执行分配内存的信息</p>
                           </li>
                           <li>
                              <p><span class="q">“ <a href="application-and-networking-architecture.html#GUID-EC8F8778-02B7-4CF9-9E6F-A5D88C777235" title="来自用户的请求是单个API调用，它是用户SQL语句的一部分。">Dispatcher Request and Response Queues</a> ”</span>以了解为共享服务器分配会话内存</p>
                           </li>
                           <li>
                              <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/cncpt&amp;id=ADFNS017" target="_blank"><span><cite>Oracle数据库开发指南</cite></span></a> ，了解Oracle XA</p>
                           </li>
                           <li>
                              <p>有关大型池的详细信息，请<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/cncpt&amp;id=TGDBA609" target="_blank"><span><cite>参见“Oracle数据库性能调整指南”</cite></span></a></p>
                           </li>
                        </ul>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-76833FAA-41D8-44AA-ADB7-FAAEBB836759" name="GUID-76833FAA-41D8-44AA-ADB7-FAAEBB836759"></a><h5 id="CNCPT-GUID-76833FAA-41D8-44AA-ADB7-FAAEBB836759" class="sect5">大型池内存管理</h5>
                     <div>
                        <p>大型池管理内存的方式与共享池不同，共享池使用LRU列表，以便部分内存可以老化。</p>
                        <p>大型游泳池没有LRU列表。当数据库将大型池内存分配给数据库会话时，除非会话释放该内存，否则不能释放该内存。一旦释放了一部分内存，其他进程就可以使用它。通过从大型池分配会话内存，数据库可以避免共享池中可能发生的碎片。</p>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-07D4439A-8E4E-4FBC-A403-1B0F0B9E0058" name="GUID-07D4439A-8E4E-4FBC-A403-1B0F0B9E0058"></a><h5 id="CNCPT-GUID-07D4439A-8E4E-4FBC-A403-1B0F0B9E0058" class="sect5"><span>延迟插入</span>的大型缓冲区</h5>
                     <div>
                        <p>对于称为<strong class="term">延迟插入</strong>的特殊类型的插入，数据库从大型池中分配缓冲区。
                        </p>
                        <p>对于来自物联网（IoT）应用程序的快速“即发即忘”插入，数据库基础结构会产生性能开销。例如，代码路径包括缓冲区缓存导航，缓冲区引脚和并发保护。数组插入可以最大限度地降低这些成本，但必须在客户端构建阵列，这对于物联网应用程序来说并不常见。要解决此问题，Oracle应用程序可以使用提示将行插入指定为<code class="codeph">MEMOPTIMIZE FOR WRITE</code>的表中。</p>
                        <p>插入是延迟的，因为它们在大型池中缓冲，然后由后台进程异步写入磁盘。数据库处理<span>延迟插入</span> ，如下所示：</p>
                        <ol>
                           <li>
                              <p>应用程序将<code class="codeph">MEMOPTIMIZE_WRITE</code>插入发送到中间层，中间层可以聚合数据。虽然IoT应用程序几乎总是将插入发送到中间层，但也可以将插入直接发送到数据库。例如，使用SQL * Plus将插入直接发送到数据库。
                              </p>
                           </li>
                           <li>
                              <p>中间层将插入的聚合写入数据库服务器。</p>
                           </li>
                           <li>
                              <p>（可选）中间层客户端保留其在上一步中编写的数据的本地副本。</p>
                           </li>
                           <li>
                              <p>服务器进程将数据写入缓冲区或大池中的缓冲区。</p>
                              <p>为避免争用，每个缓冲区都有自己的内部锁定机制。此锁定机制与数据库缓冲区高速缓存用于其缓冲区的锁定机制分开。基本的写过程如下：</p>
                              <ol type="a">
                                 <li>
                                    <p>实例启动后，第一个<code class="codeph">MEMOPTIMIZE_WRITE</code>插入分配大池中的缓冲区。
                                    </p>
                                 </li>
                                 <li>
                                    <p>编写器从可用缓冲区列表中选择一个缓冲区。</p>
                                 </li>
                                 <li>
                                    <p>如果未锁定所选缓冲区，并且此缓冲区具有可用空间，则客户端将写入缓冲区，使用特定于会话的序列号标记每个缓冲区写入。如果没有，则编写器返回上一步，并以此方式继续，直到找到缓冲区或在大池中释放了足够的空间。</p>
                                 </li>
                              </ol>
                           </li>
                           <li>
                              <p>数据库根据缓冲的数据创建服务器端数组。</p>
                           </li>
                           <li>
                              <p>空间管理协调员（SMCO）及其辅助进程（W <span class="italic">nnn</span> ）使用标准数据块格式异步地将数组写入磁盘。
                              </p>
                              <p>与标准插入不同，延迟插入会自动提交，无法回滚。数据库按照它们在会话中出现的顺序将插入提交给给定对象。无法保证对象或会话<span class="italic">之间</span>的排序。
                              </p>
                              <p>数据库支持约束和索引维护，就像常规插入一样。但是，数据库在写入磁盘期间执行评估，而不是写入大型池。</p>
                              <div class="infoboxnote" id="GUID-07D4439A-8E4E-4FBC-A403-1B0F0B9E0058__GUID-4C814566-52F5-49E0-A509-B0AC0BD2B6D9">
                                 <p class="notep1">注意：</p>
                                 <p>为获得最佳性能，Oracle建议禁用约束。</p>
                              </div>
                           </li>
                           <li>
                              <p>如果后台进程写入数据文件时发生主键冲突，则数据库会将标记的行写入应用进程的跟踪文件。</p>
                           </li>
                        </ol>
                        <p>下图描述了<span>延迟插入</span>的工作流程。
                        </p>
                        <div class="figure" id="GUID-07D4439A-8E4E-4FBC-A403-1B0F0B9E0058__GUID-B78B885C-D404-4887-A165-F71909DAC62B">
                           <p class="titleinfigure">图14-12 <span>延迟插入</span>机制</p><img src="img/cncpt_pb_002a.png" alt="下面是图14-12的描述" title="下面是图14-12的描述" longdesc="img_text/cncpt_pb_002a.html"><br><a href="img_text/cncpt_pb_002a.html">“图14-12延迟插入机制”的描述</a></div>
                        <!-- class="figure" -->
                        <div class="infoboxnotealso" id="GUID-07D4439A-8E4E-4FBC-A403-1B0F0B9E0058__GUID-AC54067B-AE7F-485C-A20A-BB0113D454F6">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><span class="q">“ <a href="data-concurrency-and-consistency.html#GUID-ED6AFF56-F998-4E80-9D6B-105B2610ECAC" title="称为延迟插入的特殊类型的插入不使用标准读取一致性机制。">读取一致性和延迟插入</a> ”</span></p>
                              </li>
                              <li>
                                 <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/cncpt&amp;id=TGDBA-GUID-CFADC9EA-2E2F-4EBB-BA2C-3663291DCC25" target="_blank"><span><cite>Oracle数据库性能调优指南</cite></span></a> ，了解如何将表指定为<code class="codeph">MEMOPTIMIZE FOR WRITE</code></p>
                              </li>
                              <li>
                                 <p>用于<code class="codeph">INSERT</code>语法和语义的<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/cncpt&amp;id=SQLRF-GUID-903F8043-0254-4EE9-ACC1-CB8AC0AF3423" target="_blank"><span><cite>Oracle数据库SQL语言参考</cite></span></a></p>
                              </li>
                              <li>
                                 <p>有关<code class="codeph">MEMOPTIMIZE_POOL_SIZE</code>更多信息，请<code class="codeph">MEMOPTIMIZE_POOL_SIZE</code> <a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/cncpt&amp;id=GUID-D33BB2FE-94A7-475F-B8C8-CC9AC61B502F" target="_blank"><span><cite>Oracle数据库参考</cite></span></a></p>
                              </li>
                           </ul>
                        </div>
                     </div>
                  </div>
               </div><a id="CNCPT1234"></a><div class="props_rev_3"><a id="GUID-51234BB8-1976-4670-8BC5-BB0E3D3BA12D" name="GUID-51234BB8-1976-4670-8BC5-BB0E3D3BA12D"></a><h4 id="CNCPT-GUID-51234BB8-1976-4670-8BC5-BB0E3D3BA12D" class="sect4">Java池</h4>
                  <div>
                     <p><span class="bold">Java池</span>是一个内存区域，用于在Java虚拟机（JVM）中存储所有特定于会话的Java代码和数据。此内存包括在调用结束时迁移到Java会话空间的Java对象。
                     </p>
                     <p>对于专用服务器连接，Java池包括每个Java类的共享部分，包括方法和只读存储器（如代码向量），但不包括每个会话的每会话Java状态。对于共享服务器，池包括每个类的共享部分以及用于每个会话状态的一些UGA。每个UGA都会根据需要增长和缩小，但总的UGA大小必须适合Java池空间。</p>
                     <p>Java Pool Advisor统计信息提供有关用于Java的库高速缓存内存的信息，并预测Java池大小的变化如何影响解析速率。当<code class="codeph">statistics_level</code>设置为<code class="codeph">TYPICAL</code>或更高时，Java Pool Advisor在内部打开。关闭顾问程序时会重置这些统计信息。
                     </p>
                     <div class="infoboxnotealso" id="GUID-51234BB8-1976-4670-8BC5-BB0E3D3BA12D__GUID-A7B0BD15-211A-4085-A633-F45DFB403D69">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/cncpt&amp;id=JJDEV01000" target="_blank"><span><cite>Oracle数据库Java开发人员指南</cite></span></a></p>
                           </li>
                           <li>
                              <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/cncpt&amp;id=TGDBA589" target="_blank"><span><cite>Oracle数据库性能调优指南</cite></span></a> ，了解包含Java池顾问统计信息的视图</p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="CNCPT9837"></a><div class="props_rev_3"><a id="GUID-F18E4E7F-2ED9-4734-A6E4-4E77D0561C19" name="GUID-F18E4E7F-2ED9-4734-A6E4-4E77D0561C19"></a><h4 id="CNCPT-GUID-F18E4E7F-2ED9-4734-A6E4-4E77D0561C19" class="sect4">固定SGA</h4>
                  <div>
                     <p><strong class="term">固定的SGA</strong>是内部管理区域。
                     </p>
                     <p>例如，固定的SGA包含：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>有关后台进程需要访问的数据库和实例状态的一般信息</p>
                        </li>
                        <li>
                           <p>流程之间传递的信息，例如有关锁的信息</p>
                        </li>
                     </ul>
                     <p>固定SGA的大小由Oracle数据库设置，不能手动更改。固定的SGA大小可以在发行版之间变化。</p>
                     <div class="infoboxnotealso" id="GUID-F18E4E7F-2ED9-4734-A6E4-4E77D0561C19__GUID-DE542EB4-4294-4469-8A0C-3C3208420091">
                        <p class="notep1">也可以看看：</p>
                        <p><span class="q">“ <a href="data-concurrency-and-consistency.html#GUID-E926E638-0161-4389-887B-4A31A529478A" title="Oracle数据库代表事务自动锁定资源，以防止其他事务执行需要独占访问同一资源的事务。">自动锁概述</a> ”</span></p>
                     </div>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-9933962C-2D8C-4EC6-9FBE-E9F4AA1B4851" name="GUID-9933962C-2D8C-4EC6-9FBE-E9F4AA1B4851"></a><h4 id="CNCPT-GUID-9933962C-2D8C-4EC6-9FBE-E9F4AA1B4851" class="sect4">可选的与性能相关的SGA子区域</h4>
                  <div>
                     <p>某些SGA子区域仅针对特定性能功能启用。</p>
                     <p>本节包含以下主题：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="memory-architecture.html#GUID-80C1C6A3-3E48-4868-ACA1-370C4D341209" title="内存区域是一个可选的SGA组件，包含内存中列存储（IM列存储）。">记忆区</a></p>
                        </li>
                        <li>
                           <p><a href="memory-architecture.html#GUID-D58DC90F-0ABB-4B1E-96C1-6094A04A5E12" title="memoptimize池存储指定为MEMOPTIMIZE FOR READ的堆组织表的缓冲区和相关结构。">Memoptimize Pool</a></p>
                        </li>
                     </ul>
                  </div>
                  <div class="sect4"><a id="GUID-80C1C6A3-3E48-4868-ACA1-370C4D341209" name="GUID-80C1C6A3-3E48-4868-ACA1-370C4D341209"></a><h5 id="CNCPT-GUID-80C1C6A3-3E48-4868-ACA1-370C4D341209" class="sect5">记忆区</h5>
                     <div>
                        <p>内存区域是一个可选的SGA组件，包含<span class="bold">内存中列存储</span> （IM列存储）。
                        </p>
                        <p>IM列存储包含以快速扫描优化的<a href="glossary.html#GUID-DDC39B24-BE95-406A-986F-D760308CA26D"><span class="xrefglossterm">柱状格式</span></a>的表，分区和物化视图的副本。IM列存储库补充了数据库缓冲区缓存，它以传统的行格式存储数据。
                        </p>
                        <div class="infoboxnote" id="GUID-80C1C6A3-3E48-4868-ACA1-370C4D341209__GUID-FD650FFC-B680-4938-ACA6-3F045222B1FC">
                           <p class="notep1">注意：</p>
                           <p>要启用IM列存储，您必须具有Oracle Database In-Memory选项。</p>
                        </div>
                        <div class="infoboxnotealso" id="GUID-80C1C6A3-3E48-4868-ACA1-370C4D341209__GUID-4F10D212-BD66-43B5-8C55-43F6072E9CEB">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/cncpt&amp;id=INMEM-GUID-EEA265EE-8FBA-4457-8C3F-315B9EEA2224" target="_blank"><span><cite>Oracle Database In-Memory指南</cite></span></a>了解有关内存区域和IM列存储的更多信息</p>
                        </div>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-D58DC90F-0ABB-4B1E-96C1-6094A04A5E12" name="GUID-D58DC90F-0ABB-4B1E-96C1-6094A04A5E12"></a><h5 id="CNCPT-GUID-D58DC90F-0ABB-4B1E-96C1-6094A04A5E12" class="sect5"><span>Memoptimize Pool</span></h5>
                     <div>
                        <p><span class="bold"><span>memoptimize池</span></span>存储指定为<code class="codeph">MEMOPTIMIZE FOR READ</code>堆组织表的缓冲区和相关结构。</p>
                        <p>此结构为基于键的查询提供了高性能和可伸缩性，例如<code class="codeph">SELECT * FROM cust WHERE cid = 10</code> 。为了减少端到端响应时间，客户端通过网络直接从SGA提取请求的缓冲区，从而避免CPU和操作系统开销。应用程序可以从<span>memoptimize池中</span>受益，而无需更改代码。
                        </p>
                        <p><span>memoptimize池</span>包含两部分：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>Memoptimize缓冲区</p>
                              <p>为避免磁盘I / O，数据库永久锁定<span>memoptimize池中</span> <code class="codeph">MEMOPTIMIZE FOR READ</code>表的<span>缓冲区</span> ，直到该表标记为<code class="codeph">NO MEMOPTIMIZE FOR READ</code> 。 memoptimize缓冲区使用与数据库缓冲区缓存中的缓冲区相同的结构。但是， <span>memoptimize池中</span>的缓冲区与数据库缓冲区缓存完全分开，不计入其大小。memoptimize缓冲区占用<span>memoptimize池的</span> 75％。
                              </p>
                           </li>
                           <li>
                              <p>哈希指数</p>
                              <p><a href="glossary.html#GUID-EE5E8238-C900-46DB-A688-6A5D0BDFEA7C"><span class="xrefglossterm">哈希索引</span></a>是非持久的段数据结构。数据库将哈希索引分配为多个非连续内存单元。每个单元包含许多散列桶。单独的映射结构将存储器单元与主键相关联。哈希索引占<span>memoptimize池的</span> 25％。
                              </p>
                           </li>
                        </ul>
                        <div class="figure" id="GUID-D58DC90F-0ABB-4B1E-96C1-6094A04A5E12__GUID-A81EFC1E-BEA0-488C-9ADE-42746438A85F">
                           <p class="titleinfigure">图14-13 <span>Memoptimize Pool</span></p><img src="img/cncpt_pb_001a.png" alt="下面是图14-13的描述" title="下面是图14-13的描述" longdesc="img_text/cncpt_pb_001a.html"><br><a href="img_text/cncpt_pb_001a.html">“图14-13 Memoptimize Pool”的描述</a></div>
                        <!-- class="figure" -->
                        <p>要启用<span>memoptimize池</span> ，请将<code class="codeph">MEMOPTIMIZE_POOL_SIZE</code>初始化参数设置为整数值（默认情况下禁用池）。该值指定要分配给池的SGA数量。该<code class="codeph">MEMOPTIMIZE_POOL_SIZE</code>值<span class="italic">不</span>计入<code class="codeph">SGA_TARGET</code> ，但数据库<span class="italic">不会</span>增长和自动收缩<span>memoptimize池</span> 。例如，如果<code class="codeph">SGA_TARGET</code>为10 GB，并且<code class="codeph">MEMOPTIMIZE_POOL_SIZE</code>为1 GB，那么除了<span>memoptimize池</span>之外，总共有9 GB可用于SGA内存。
                        </p>
                        <p>要更改<span>memoptimize池</span>的大小，必须手动设置<code class="codeph">MEMOPTIMIZE_POOL_SIZE</code>并重新启动数据库实例。您无法使用<code class="codeph">ALTER SYSTEM</code>动态更改池大小。</p>
                        <p><code class="codeph">DBMS_MEMOPTIMIZE</code>包使您可以将表显式填充到<span>memoptimize池中</span> 。
                        </p>
                        <div class="infoboxnotealso" id="GUID-D58DC90F-0ABB-4B1E-96C1-6094A04A5E12__GUID-D6BA968E-6232-4E85-95DE-93514493377B">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><span class="q">“ <a href="concepts-for-database-administrators.html#GUID-C7AFB6E3-195E-4269-A871-D514CD9A84BE" title="在自动内存管理中，Oracle数据库完全自动管理SGA和实例PGA内存。此方法最简单，Oracle强烈建议使用此方法。">自动内存管理</a> ”</span></p>
                              </li>
                              <li>
                                 <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/cncpt&amp;id=TGDBA-GUID-9752E93D-55A7-4584-B09B-9623B33B5CCF" target="_blank"><span><cite>Oracle数据库性能调优指南</cite></span></a> ，了解如何通过启用<span>memoptimize池</span>来提高查询性能</p>
                              </li>
                              <li>
                                 <p><a href="../arpls/DBMS_MEMOPTIMIZE.html#ARPLS-GUID-49F0E799-97F0-41E7-9CD3-24AE3CAA8105" target="_blank"><span><cite>Oracle Database PL / SQL包和类型参考，</cite></span></a>以了解有关<code class="codeph">DBMS_MEMOPTIMIZE</code>包的更多信息</p>
                              </li>
                              <li>
                                 <p><a href="../sqlrf/CREATE-TABLE.html#SQLRF-GUID-F9CE0CC3-13AE-4744-A43C-EAC7A71AAAB6" target="_blank"><span><cite>Oracle数据库SQL语言参考</cite></span></a>以了解有关<code class="codeph">CREATE TABLE ...更多信息<code class="codeph">CREATE TABLE ...MEMOPTIMIZE FOR READ</code></p>
                              </li>
                              <li>
                                 <p>有关<code class="codeph">MEMOPTIMIZE_POOL_SIZE</code>更多信息，请<code class="codeph">MEMOPTIMIZE_POOL_SIZE</code> <a href="../refrn/MEMOPTIMIZE_POOL_SIZE.html#GUID-D33BB2FE-94A7-475F-B8C8-CC9AC61B502F" target="_blank"><span><cite>Oracle数据库参考</cite></span></a></p>
                              </li>
                           </ul>
                        </div>
                     </div>
                  </div>
               </div>
            </div><a id="CNCPT804"></a><div class="props_rev_3"><a id="GUID-EE4E1B4E-1C00-499F-B00E-2637B7E19963" name="GUID-EE4E1B4E-1C00-499F-B00E-2637B7E19963"></a><h3 id="CNCPT-GUID-EE4E1B4E-1C00-499F-B00E-2637B7E19963" class="sect3">软件代码区概述</h3>
               <div>
                  <p><span class="bold">软件代码区域</span>是存储器的一部分，用于存储正在运行或可以运行的代码。Oracle数据库代码存储在软件区域中，该区域通常比用户程序的位置更加独占和受保护。
                  </p>
                  <p>软件区域通常是静态的，只有在更新或重新安装软件时才会更改。这些区域所需的大小因操作系统而异。</p>
                  <p>软件区域是只读的，可以共享或非共享安装。某些数据库工具和实用程序（如Oracle Forms和SQL * Plus）可以共享安装，但有些则不能。在可能的情况下，共享数据库代码，以便所有用户都可以访问它而不需要在内存中有多个副本，从而减少主内存并提高性能。如果在同一台计算机上运行，则数据库的多个实例可以使用具有不同数据库的相同数据库代码区域。</p>
                  <div class="infoboxnote" id="GUID-EE4E1B4E-1C00-499F-B00E-2637B7E19963__GUID-1543C5D6-3DE6-400C-A008-C771B365EBE3">
                     <p class="notep1">注意：</p>
                     <p>安装共享软件的选项并非适用于所有操作系统，例如，在运行Microsoft Windows的PC上。有关更多信息，请参阅特定于操作系统的文档。</p>
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>