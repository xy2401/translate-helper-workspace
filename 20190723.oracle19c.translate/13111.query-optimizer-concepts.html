<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <meta name="abstract" content="This chapter describes the most important concepts relating to the query optimizer, including its principal components."></meta>
      <meta name="description" content="This chapter describes the most important concepts relating to the query optimizer, including its principal components."></meta>
      <title>查询优化器概念</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="SQL Tuning Guide"></meta>
      <meta property="og:description" content="This chapter describes the most important concepts relating to the query optimizer, including its principal components."></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="SQL Tuning Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="sql-tuning-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-31T14:57:08-08:00"></meta>
      <meta name="dcterms.title" content="SQL Tuning Guide"></meta>
      <meta name="dcterms.dateCopyrighted" content="2013, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96095-03"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="sql-processing.html" title="Previous" type="text/html"></link>
      <link rel="next" href="query-transformations.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.isVersionOf" content="TGSQL"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="sql-processing.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="query-transformations.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">SQL调优指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="query-optimizer-fundamentals.html" property="item" typeof="WebPage"><span property="name">查询优化工具基础知识</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">查询优化器概念</li>
            </ol>
            <a id="GUID-06129ACE-36B2-4534-AE68-EDFCAEBB3B5D" name="GUID-06129ACE-36B2-4534-AE68-EDFCAEBB3B5D"></a><a id="TGSQL192"></a>
            
            <h2 id="TGSQL-GUID-06129ACE-36B2-4534-AE68-EDFCAEBB3B5D" class="sect2"><span class="enumeration_chapter">4</span>查询优化器概念</h2>
         </header>
         <div class="ind">
            <div>
               <p>本章描述了与查询优化器相关的最重要的概念，包括其主要组件。</p>
               <p>本章包含以下主题：</p>
            </div>
            <div>
               <ul class="ullinks">
                  <li class="ulchildlink"><a href="query-optimizer-concepts.html#GUID-6213C0FF-CE34-44AB-97A1-D567820F9419">查询优化器简介</a><br><strong class="term">查询优化器</strong> （简称为<strong class="term">优化器</strong> ）是内置数据库软件，用于确定SQL语句访问请求数据的最有效方法。
                  </li>
                  <li class="ulchildlink"><a href="query-optimizer-concepts.html#GUID-12C47112-B713-4658-89C2-DA756E4D29D3">关于优化组件</a><br>优化器包含三个组件：变换器，估计器和计划生成器。
                  </li>
                  <li class="ulchildlink"><a href="query-optimizer-concepts.html#GUID-7D015E05-A08D-478B-81AC-AB04ECEED8FA">关于自动调整优化器</a><br>优化器根据调用方式执行不同的操作。
                  </li>
                  <li class="ulchildlink"><a href="query-optimizer-concepts.html#GUID-F368C89A-5CAE-432C-845C-CC38C7F93A03">关于自适应查询优化</a><br>在Oracle数据库中， <strong class="term">自适应查询优化</strong>使优化器能够对执行计划进行运行时调整，并发现可以带来更好统计信息的其他信息。
                  </li>
                  <li class="ulchildlink"><a href="query-optimizer-concepts.html#GUID-6273DFAC-7C4D-4540-AE11-B6973F237323">关于近似查询处理</a><br><strong class="term">近似查询处理</strong>是一组优化技术，通过在可接受的误差范围内计算结果来加速分析查询。
                  </li>
                  <li class="ulchildlink"><a href="query-optimizer-concepts.html#GUID-CC06CD2F-2B18-40CB-B182-FE5AE6A4E21D">关于SQL计划管理</a><br><span class="bold">SQL计划管理</span>使优化器能够自动管理执行计划，确保数据库仅使用已知或已验证的计划。
                  </li>
                  <li class="ulchildlink"><a href="query-optimizer-concepts.html#GUID-E76CD42A-3D1B-4A0A-82F6-5270D3B32E7A">关于隔离的SQL计划</a><br>Oracle数据库自动隔离由Oracle数据库资源管理器（资源管理器）终止的SQL语句的计划，以超出资源限制。
                  </li>
                  <li class="ulchildlink"><a href="query-optimizer-concepts.html#GUID-44EB8261-A7B1-4402-94ED-5152EE1C5D08">关于表达式统计存储（ESS）</a><br><span class="bold">表达式统计信息存储（ESS）</span>是由优化程序维护的存储库，用于存储有关表达式评估的统计信息。
                  </li>
               </ul>
               <div class="familylinks">
                  <div class="parentlink">
                     <p><strong>父主题：</strong> <a href="query-optimizer-fundamentals.html#GUID-EF45F82A-F17D-4C79-9B6A-8CBBB95F0684" title="要调优Oracle SQL，您必须了解查询优化器。优化器是内置软件，用于确定语句访问数据的最有效方法。">查询优化器基础知识</a></p>
                  </div>
               </div>
            </div>
            <a id="TGSQL193"></a><div class="props_rev_3"><a id="GUID-6213C0FF-CE34-44AB-97A1-D567820F9419" name="GUID-6213C0FF-CE34-44AB-97A1-D567820F9419"></a><h3 id="TGSQL-GUID-6213C0FF-CE34-44AB-97A1-D567820F9419" class="sect3"><span class="enumeration_section">4.1</span>查询优化器简介</h3>
               <div>
                  <p><strong class="term">查询优化器</strong> （简称为<strong class="term">优化器</strong> ）是内置数据库软件，用于确定SQL语句访问请求数据的最有效方法。
                  </p>
                  <p>本节包含以下主题：</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="query-optimizer-concepts.html#GUID-65F99893-DBA9-4955-B133-DBFFA2F43145">查询优化程序的用途</a><br>优化程序尝试为SQL语句生成最佳执行计划。
                     </li>
                     <li class="ulchildlink"><a href="query-optimizer-concepts.html#GUID-B743F9BE-9971-4CD1-8C0C-0EAF7C80E5F2">基于成本的优化</a><br><strong class="term">查询优化</strong>是选择执行SQL语句的最有效方法的过程。
                     </li>
                     <li class="ulchildlink"><a href="query-optimizer-concepts.html#GUID-5D925135-6CF3-40B8-8AEF-12159055DE1F">执行计划</a><br><strong class="term">执行计划</strong>描述了SQL语句的推荐执行方法。
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="query-optimizer-concepts.html#GUID-06129ACE-36B2-4534-AE68-EDFCAEBB3B5D" title="本章描述了与查询优化器相关的最重要的概念，包括其主要组件。">查询优化器概念</a></p>
                     </div>
                  </div>
               </div>
               <a id="TGSQL194"></a><div class="props_rev_3"><a id="GUID-65F99893-DBA9-4955-B133-DBFFA2F43145" name="GUID-65F99893-DBA9-4955-B133-DBFFA2F43145"></a><h4 id="TGSQL-GUID-65F99893-DBA9-4955-B133-DBFFA2F43145" class="sect4"><span class="enumeration_section">4.1.1</span>查询优化器的用途</h4>
                  <div>
                     <p>优化程序尝试为SQL语句生成最佳执行计划。</p>
                     <p>优化程序在所有考虑的候选计划中选择成本最低的计划。优化程序使用可用统计信息来计算成本。对于给定环境中的特定查询，成本计算考虑了查询执行的因素，例如I / O，CPU和通信。</p>
                     <p>例如，查询可能会请求有关作为经理的员工的信息。如果优化程序统计信息表明80％的员工是经理，那么优化程序可能会认为全表扫描最有效。但是，如果统计信息表明很少有员工是经理，那么读取索引后跟rowid进行表访问可能比全表扫描更有效。</p>
                     <p>由于数据库有许多内部统计信息和工具可供使用，因此优化器通常比用户更有利于确定语句执行的最佳方法。因此，所有SQL语句都使用优化程序。</p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="query-optimizer-concepts.html#GUID-6213C0FF-CE34-44AB-97A1-D567820F9419" title="查询优化器（简称为优化器）是内置数据库软件，用于确定SQL语句访问请求数据的最有效方法。">查询优化程序简介</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="TGSQL195"></a><div class="props_rev_3"><a id="GUID-B743F9BE-9971-4CD1-8C0C-0EAF7C80E5F2" name="GUID-B743F9BE-9971-4CD1-8C0C-0EAF7C80E5F2"></a><h4 id="TGSQL-GUID-B743F9BE-9971-4CD1-8C0C-0EAF7C80E5F2" class="sect4"><span class="enumeration_section">4.1.2</span>基于成本的优化</h4>
                  <div>
                     <p><strong class="term">查询优化</strong>是选择执行SQL语句的最有效方法的过程。
                     </p>
                     <p>SQL是一种非过程语言，因此优化器可以按任何顺序自由合并，重组和处理。数据库根据收集的有关访问数据的统计信息优化每个SQL语句。优化程序通过检查多个访问方法（如全表扫描或索引扫描），不同的连接方法（如嵌套循环和散列连接），不同的连接顺序以及可能的转换来确定SQL语句的最佳计划。</p>
                     <p>对于给定的查询和环境，优化程序会为可能的计划的每个步骤分配相对数字成本，然后将这些值计算在一起以生成计划的总体成本估算。在计算替代计划的成本之后，优化程序选择具有最低成本估算的计划。出于这个原因，优化器有时被称为<a href="glossary.html#GUID-D7916C1E-4AE1-4065-BB33-4CD86842FC6A"><span class="xrefglossterm">基于成本的优化器（CBO），</span></a>以将其与基于遗留规则的优化器（RBO）进行对比。
                     </p>
                     <div class="infoboxnote" id="GUID-B743F9BE-9971-4CD1-8C0C-0EAF7C80E5F2__GUID-52548C07-3FB8-4EE3-89CF-FF9A6C285268">
                        <p class="notep1">注意：</p>
                        <p>优化程序可能不会从一个版本的Oracle数据库到下一个版本做出相同的决策。在最新版本中，优化器可能会做出不同的决定，因为可以获得更好的信息，并且可以进行更多的优化器转换。</p>
                     </div>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="query-optimizer-concepts.html#GUID-6213C0FF-CE34-44AB-97A1-D567820F9419" title="查询优化器（简称为优化器）是内置数据库软件，用于确定SQL语句访问请求数据的最有效方法。">查询优化程序简介</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="TGSQL197"></a><a id="TGSQL196"></a><div class="props_rev_3"><a id="GUID-5D925135-6CF3-40B8-8AEF-12159055DE1F" name="GUID-5D925135-6CF3-40B8-8AEF-12159055DE1F"></a><h4 id="TGSQL-GUID-5D925135-6CF3-40B8-8AEF-12159055DE1F" class="sect4"><span class="enumeration_section">4.1.3</span>执行计划</h4>
                  <div>
                     <p><strong class="term">执行计划</strong>描述了SQL语句的推荐执行方法。
                     </p>
                     <p>该计划显示了Oracle数据库用于执行SQL语句的步骤组合。每个步骤都从数据库中物理地检索数据行，或者为发出语句的用户准备它们。</p>
                     <p>执行计划显示整个计划的成本（在第0行指示）和每个单独的操作。成本是执行计划仅显示以允许计划比较的内部单位。因此，您无法调整或更改成本值。</p>
                     <p>在下图中，优化程序为输入SQL语句生成两个可能的执行计划，使用统计信息估算其成本，比较其成本，然后选择成本最低的计划。</p>
                     <div class="figure" id="GUID-5D925135-6CF3-40B8-8AEF-12159055DE1F__BABHFBIJ">
                        <p class="titleinfigure">图4-1执行计划</p><img src="img/tgsql_vm_040.png" alt="下面是图4-1的描述" title="下面是图4-1的描述" longdesc="img_text/tgsql_vm_040.html"><br><a href="img_text/tgsql_vm_040.html">“图4-1执行计划”的描述</a></div>
                     <!-- class="figure" -->
                     <p>本节包含以下主题：</p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="query-optimizer-concepts.html#GUID-7A266A25-90F9-443A-83C5-C2BF1DC3F588">查询块</a><br>优化器的输入是SQL语句的解析表示。
                        </li>
                        <li class="ulchildlink"><a href="query-optimizer-concepts.html#GUID-CBA60A24-7C4F-4F1F-876E-8D8FDCEA26ED">查询子计划</a><br>对于每个查询块，优化器生成查询子计划。
                        </li>
                        <li class="ulchildlink"><a href="query-optimizer-concepts.html#GUID-9FCB33CB-C71C-43C2-A2BD-C8E49EF4D5D5">比较优化器</a><br>优化器的一个类比是在线旅行顾问。
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="query-optimizer-concepts.html#GUID-6213C0FF-CE34-44AB-97A1-D567820F9419" title="查询优化器（简称为优化器）是内置数据库软件，用于确定SQL语句访问请求数据的最有效方法。">查询优化程序简介</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="TGSQL199"></a><a id="TGSQL198"></a><div class="props_rev_3"><a id="GUID-7A266A25-90F9-443A-83C5-C2BF1DC3F588" name="GUID-7A266A25-90F9-443A-83C5-C2BF1DC3F588"></a><h5 id="TGSQL-GUID-7A266A25-90F9-443A-83C5-C2BF1DC3F588" class="sect5"><span class="enumeration_section">4.1.3.1</span>查询块</h5>
                     <div>
                        <p>优化器的输入是SQL语句的解析表示。</p>
                        <p>原始SQL语句中的每个<code class="codeph">SELECT</code>块由<a href="glossary.html#GUID-F2D03097-5F4B-4A2A-9DAE-6EC76F7BED61"><span class="xrefglossterm">查询块在</span></a>内部表示。查询块可以是顶级语句，子查询或未合并视图。
                        </p>
                        <div class="example" id="GUID-7A266A25-90F9-443A-83C5-C2BF1DC3F588__BABDBJJJ">
                           <p class="titleinexample">示例4-1查询块</p>
                           <p>以下SQL语句由两个查询块组成。括号中的子查询是内部查询块。外部查询块（SQL语句的其余部分）检索由子查询提供ID的部门中的员工的名称。查询表单确定查询块如何相互关联。</p><pre class="pre codeblock"><code>SELECT first_name，last_name FROM hr.employees WHERE department_id IN（SELECT department_id FROM hr.departments WHERE location_id = 1800）;</code></pre></div>
                        <!-- class="example" -->
                     </div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-7A266A25-90F9-443A-83C5-C2BF1DC3F588__GUID-0FDE4814-39FC-4C08-9E93-58880DBE3B03">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><span class="q">“ <a href="query-transformations.html#GUID-6045D0F4-79A9-4688-A844-85F225DFA7DD" title="在视图合并中，优化器将表示视图的查询块合并到包含它的查询块中。">查看合并</a> ”</span></p>
                              </li>
                              <li>
                                 <p>有关SQL处理概述的<a href="../cncpt/sql.html#CNCPT015" target="_blank"><span><cite>Oracle数据库概念</cite></span></a></p>
                              </li>
                           </ul>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="query-optimizer-concepts.html#GUID-5D925135-6CF3-40B8-8AEF-12159055DE1F" title="执行计划描述了SQL语句的推荐执行方法。">执行计划</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TGSQL200"></a><div class="props_rev_3"><a id="GUID-CBA60A24-7C4F-4F1F-876E-8D8FDCEA26ED" name="GUID-CBA60A24-7C4F-4F1F-876E-8D8FDCEA26ED"></a><h5 id="TGSQL-GUID-CBA60A24-7C4F-4F1F-876E-8D8FDCEA26ED" class="sect5"><span class="enumeration_section">4.1.3.2</span>查询子计划</h5>
                     <div>
                        <p>对于每个查询块，优化器生成查询子计划。</p>
                        <p>数据库从下到上分别优化查询块。因此，数据库首先优化最里面的查询块并为其生成子计划，然后生成表示整个查询的外部查询块。</p>
                        <p>查询块的可能计划数与<code class="codeph">FROM</code>子句中的对象数成比例。该数字随着对象的数量呈指数增长。例如，五个表的连接的可能计划明显高于两个表的连接的可能计划。
                        </p>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="query-optimizer-concepts.html#GUID-5D925135-6CF3-40B8-8AEF-12159055DE1F" title="执行计划描述了SQL语句的推荐执行方法。">执行计划</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TGSQL201"></a><div class="props_rev_3"><a id="GUID-9FCB33CB-C71C-43C2-A2BD-C8E49EF4D5D5" name="GUID-9FCB33CB-C71C-43C2-A2BD-C8E49EF4D5D5"></a><h5 id="TGSQL-GUID-9FCB33CB-C71C-43C2-A2BD-C8E49EF4D5D5" class="sect5"><span class="enumeration_section">4.1.3.3</span>优化器的类比</h5>
                     <div>
                        <p>优化器的一个类比是在线旅行顾问。</p>
                        <p>骑自行车的人想要知道从A点到B点的最有效的自行车路线。查询就像指令“我需要从A点到B点的最有效路线”或“我需要从A点到点A的最有效路线” B通过C点。“旅行顾问使用内部算法来确定最有效的路线，该算法依赖于速度和难度等因素。骑车人可以通过使用诸如“我想尽快到达”或“我希望最简单的骑行”等指令来影响旅行顾问的决定。</p>
                        <p>在这个类比中，执行计划是旅行顾问生成的可能路线。在内部，顾问可以将整个路径划分为若干子路由（子计划），并分别计算每个子路由的效率。例如，旅行顾问可以在中等难度的15分钟估计一个子路由，在22分钟时以最小的难度估计另一个子路由，等等。</p>
                        <p>顾问根据用户指定的目标以及有关道路和交通状况的可用统计数据，选择最有效（最低成本）的总体路线。统计越准确，建议越好。例如，如果顾问不经常被告知交通拥堵，道路封闭和恶劣的道路状况，那么推荐的路线可能效率低（成本高）。</p>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="query-optimizer-concepts.html#GUID-5D925135-6CF3-40B8-8AEF-12159055DE1F" title="执行计划描述了SQL语句的推荐执行方法。">执行计划</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div>
            </div><a id="TGSQL203"></a><a id="TGSQL202"></a><div class="props_rev_3"><a id="GUID-12C47112-B713-4658-89C2-DA756E4D29D3" name="GUID-12C47112-B713-4658-89C2-DA756E4D29D3"></a><h3 id="TGSQL-GUID-12C47112-B713-4658-89C2-DA756E4D29D3" class="sect3"><span class="enumeration_section">4.2</span>关于优化器组件</h3>
               <div>
                  <p>优化器包含三个组件：变换器，估计器和计划生成器。</p>
                  <p>下图说明了这些组件。</p>
                  <div class="figure" id="GUID-12C47112-B713-4658-89C2-DA756E4D29D3__BABIECCA">
                     <p class="titleinfigure">图4-2优化器组件</p><img src="img/cncpt287.gif" alt="下面是图4-2的描述" title="下面是图4-2的描述" longdesc="img_text/cncpt287.html"><br><a href="img_text/cncpt287.html">“图4-2优化器组件”的说明</a></div>
                  <!-- class="figure" -->
                  <p>一组查询块表示已解析的查询，该查询是优化程序的输入。下表描述了优化程序操作。</p>
                  <div class="tblformal" id="GUID-12C47112-B713-4658-89C2-DA756E4D29D3__GUID-BADE6536-FE40-46EC-B6C5-628001ABA3E6">
                     <p class="titleintable">表4-1优化器操作</p>
                     <table cellpadding="4" cellspacing="0" class="Formal" title="优化器操作" border="1" summary="This table describes the query transformer, estimator, and plan generator." frame="hsides" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="20%" id="d11530e1297">相</th>
                              <th align="left" valign="bottom" width="20%" id="d11530e1299">手术</th>
                              <th align="left" valign="bottom" width="20%" id="d11530e1301">描述</th>
                              <th align="left" valign="bottom" width="20%" id="d11530e1303">了解更多</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="20%" id="d11530e1307" headers="d11530e1297 ">1</td>
                              <td align="left" valign="top" width="20%" headers="d11530e1307 d11530e1299 ">
                                 <p>查询变换器</p>
                              </td>
                              <td align="left" valign="top" width="20%" headers="d11530e1307 d11530e1301 ">
                                 <p>优化程序确定更改查询形式是否有帮助，以便优化程序可以生成更好的执行计划。</p>
                              </td>
                              <td align="left" valign="top" width="20%" headers="d11530e1307 d11530e1303 "><span class="q">“ <a href="query-optimizer-concepts.html#GUID-25332969-244D-4C30-BEFF-35315C3138F9" title="对于某些语句，查询转换器确定将原始SQL语句重写为具有较低成本的语义等效SQL语句是否有利。">查询变压器</a> ”</span></td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="20%" id="d11530e1323" headers="d11530e1297 ">2</td>
                              <td align="left" valign="top" width="20%" headers="d11530e1323 d11530e1299 ">
                                 <p>估计</p>
                              </td>
                              <td align="left" valign="top" width="20%" headers="d11530e1323 d11530e1301 ">
                                 <p>优化程序根据数据字典中的统计信息估算每个计划的成本。</p>
                              </td>
                              <td align="left" valign="top" width="20%" headers="d11530e1323 d11530e1303 "><span class="q">“ <a href="query-optimizer-concepts.html#GUID-2AB938B9-E1A8-4344-924B-8EFBB6134AFE" title="估计器是优化器的组件，用于确定给定执行计划的总体成本。">Estimator</a> ”</span></td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="20%" id="d11530e1342" headers="d11530e1297 ">3</td>
                              <td align="left" valign="top" width="20%" headers="d11530e1342 d11530e1299 ">
                                 <p>计划生成器</p>
                              </td>
                              <td align="left" valign="top" width="20%" headers="d11530e1342 d11530e1301 ">
                                 <p>优化器比较计划的成本，并选择最低成本计划（称为执行计划）传递给行源生成器。</p>
                              </td>
                              <td align="left" valign="top" width="20%" headers="d11530e1342 d11530e1303 "><span class="q">“ <a href="query-optimizer-concepts.html#GUID-CB5FAF86-7DAF-446B-98A9-CB8DF3B2C68F" title="计划生成器通过尝试不同的访问路径，连接方法和连接顺序来探索查询块的各种计划。">计划生成器</a> ”</span></td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
                  <p>本节包含以下主题：</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="query-optimizer-concepts.html#GUID-25332969-244D-4C30-BEFF-35315C3138F9">查询变换器</a><br>对于某些语句，查询转换器确定将原始SQL语句重写为具有较低成本的语义等效SQL语句是否有利。
                     </li>
                     <li class="ulchildlink"><a href="query-optimizer-concepts.html#GUID-2AB938B9-E1A8-4344-924B-8EFBB6134AFE">估计</a><br><strong class="term">估计器</strong>是优化<strong class="term">器</strong>的组件，用于确定给定执行计划的总体成本。
                     </li>
                     <li class="ulchildlink"><a href="query-optimizer-concepts.html#GUID-CB5FAF86-7DAF-446B-98A9-CB8DF3B2C68F">计划生成器</a><br><strong class="term">计划生成器</strong>通过尝试不同的访问路径，连接方法和连接顺序来探索查询块的各种计划。
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="query-optimizer-concepts.html#GUID-06129ACE-36B2-4534-AE68-EDFCAEBB3B5D" title="本章描述了与查询优化器相关的最重要的概念，包括其主要组件。">查询优化器概念</a></p>
                     </div>
                  </div>
               </div>
               <a id="TGSQL205"></a><a id="TGSQL204"></a><div class="props_rev_3"><a id="GUID-25332969-244D-4C30-BEFF-35315C3138F9" name="GUID-25332969-244D-4C30-BEFF-35315C3138F9"></a><h4 id="TGSQL-GUID-25332969-244D-4C30-BEFF-35315C3138F9" class="sect4"><span class="enumeration_section">4.2.1</span>查询变换器</h4>
                  <div>
                     <p>对于某些语句，查询转换器确定将原始SQL语句重写为具有较低成本的语义等效SQL语句是否有利。</p>
                     <p>当存在可行的替代方案时，数据库将单独计算替代方案的成本，并选择成本最低的替代方案。下图显示了查询转换器将使用<code class="codeph">OR</code>的输入查询重写为使用<code class="codeph">UNION ALL</code>的输出查询。</p>
                     <div class="figure" id="GUID-25332969-244D-4C30-BEFF-35315C3138F9__BABCEIGC">
                        <p class="titleinfigure">图4-3查询变换器</p><img src="img/tgsql_vm_042.png" alt="下面是图4-3的描述" title="下面是图4-3的描述" longdesc="img_text/tgsql_vm_042.html"><br><a href="img_text/tgsql_vm_042.html">“图4-3查询变压器”的说明</a></div>
                     <!-- class="figure" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="query-optimizer-concepts.html#GUID-12C47112-B713-4658-89C2-DA756E4D29D3" title="优化器包含三个组件：变换器，估计器和计划生成器。">关于优化程序组件</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="TGSQL214"></a><a id="TGSQL213"></a><div class="props_rev_3"><a id="GUID-2AB938B9-E1A8-4344-924B-8EFBB6134AFE" name="GUID-2AB938B9-E1A8-4344-924B-8EFBB6134AFE"></a><h4 id="TGSQL-GUID-2AB938B9-E1A8-4344-924B-8EFBB6134AFE" class="sect4"><span class="enumeration_section">4.2.2</span>估算器</h4>
                  <div>
                     <p><strong class="term">估计器</strong>是优化<strong class="term">器</strong>的组件，用于确定给定执行计划的总体成本。
                     </p>
                     <p>估算器使用三种不同的度量来确定成本：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="query-optimizer-concepts.html#GUID-60B12417-9E06-4F3F-B796-DF86549A5B21" title="选择性表示行集中的一小部分行。">选择性</a></p>
                           <p>查询选择的行集中的行百分比， <code class="codeph">0</code>表示没有行， <code class="codeph">1</code>表示所有行。选择性与查询谓词相关联，例如<code class="codeph">WHERE last_name LIKE 'A%'</code>或谓词组合。当值接近<code class="codeph">1</code>谓词变得更具选择性，因为选择性值接近<code class="codeph">0</code>且选择性更低（或更不具有选择性）。
                           </p>
                           <div class="infoboxnote" id="GUID-2AB938B9-E1A8-4344-924B-8EFBB6134AFE__GUID-B816C421-979B-4283-AF77-BA3E0BD7D10A">
                              <p class="notep1">注意：</p>
                              <p>选择性是在执行计划中不可见的内部计算。</p>
                           </div>
                        </li>
                        <li>
                           <p><a href="query-optimizer-concepts.html#GUID-58CF21C3-3233-415C-BBE6-61AAA976EAD7" title="基数是执行计划中每个操作返回的行数。">基数</a></p>
                           <p>基数是执行计划中每个操作返回的行数。此输入对于获得最佳计划至关重要，对所有成本函数都是通用的。估计器可以从<code class="codeph">DBMS_STATS</code>收集的表统计信息中导出基数，或者在考虑谓词（过滤器，连接等）， <code class="codeph">DISTINCT</code>或<code class="codeph">GROUP BY</code>操作等的影响后派生基数。执行计划中的<code class="codeph">Rows</code>列显示估计的基数。
                           </p>
                        </li>
                        <li>
                           <p><a href="query-optimizer-concepts.html#GUID-9D0BF31B-7215-4BD8-B45D-A8BF2B4DB7E5" title="优化程序成本模型考虑了预计使用查询的计算机资源。">成本</a></p>
                           <p>该度量表示使用的工作单元或资源。查询优化器使用磁盘I / O，CPU使用率和内存使用量作为工作单元。</p>
                        </li>
                     </ul>
                     <p>如下图所示，如果统计数据可用，则估算器使用它们来计算度量。统计数据提高了措施的准确程度。</p>
                     <div class="figure" id="GUID-2AB938B9-E1A8-4344-924B-8EFBB6134AFE__BABHBJFA">
                        <p class="titleinfigure">图4-4估算器</p><img src="img/tgsql_vm_043.png" alt="下面是图4-4的描述" title="下面是图4-4的描述" longdesc="img_text/tgsql_vm_043.html"><br><a href="img_text/tgsql_vm_043.html">“图4-4估算器”的描述</a></div>
                     <!-- class="figure" -->
                     <p>对于<a href="query-optimizer-concepts.html#GUID-7A266A25-90F9-443A-83C5-C2BF1DC3F588__BABDBJJJ">示例4-1中</a>显示的查询，估计器使用选择性，估计基数（总返回10行）和成本度量来生成其总成本估计值3：</p><pre class="pre codeblock"><code>-------------------------------------------------- ------------------------------ | ID |操作|名称|行|字节|成本％CPU |时间| -------------------------------------------------- ------------------------------ | 0 |选择声明| | 10 | 250 | <span class="bold">3</span> （0）| 00：00：01 | | 1 | NESTED LOOPS | | | | | | | 2 | NESTED LOOPS | | 10 | 250 | 3（0）| 00：00：01 | | * 3 |表访问完整|部门| 1 | 7 | 2（0）| 00：00：01 | | * 4 | INDEX RANGE SCAN | EMP_DEPARTMENT_IX | 10 | | 0（0）| 00：00：01 | | 5 |按行索引表的访问权限|员工| 10 | 180 | 1（0）| 00：00：01 | -------------------------------------------------- ------------------------------</code></pre><p>本节包含以下主题：</p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="query-optimizer-concepts.html#GUID-60B12417-9E06-4F3F-B796-DF86549A5B21">选择性</a><br><span class="bold">选择性</span>表示行集中的一小部分行。
                        </li>
                        <li class="ulchildlink"><a href="query-optimizer-concepts.html#GUID-58CF21C3-3233-415C-BBE6-61AAA976EAD7">基数</a><br><span class="bold">基数</span>是执行计划中每个操作返回的行数。
                        </li>
                        <li class="ulchildlink"><a href="query-optimizer-concepts.html#GUID-9D0BF31B-7215-4BD8-B45D-A8BF2B4DB7E5">成本</a><br><span class="bold">优化程序成本模型</span>考虑了预计使用查询的计算机资源。
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="query-optimizer-concepts.html#GUID-12C47112-B713-4658-89C2-DA756E4D29D3" title="优化器包含三个组件：变换器，估计器和计划生成器。">关于优化程序组件</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="TGSQL215"></a><div class="props_rev_3"><a id="GUID-60B12417-9E06-4F3F-B796-DF86549A5B21" name="GUID-60B12417-9E06-4F3F-B796-DF86549A5B21"></a><h5 id="TGSQL-GUID-60B12417-9E06-4F3F-B796-DF86549A5B21" class="sect5"><span class="enumeration_section">4.2.2.1</span>选择性</h5>
                     <div>
                        <p><span class="bold">选择性</span>表示行集中的一小部分行。
                        </p>
                        <p>行集可以是基表，视图或连接的结果。选择性与查询谓词相关联，例如<code class="codeph">last_name</code> = <code class="codeph">'Smith'</code> ，或谓词的组合，例如<code class="codeph">last_name = 'Smith' AND job_id = 'SH_CLERK'</code> 。
                        </p>
                        <div class="infoboxnote" id="GUID-60B12417-9E06-4F3F-B796-DF86549A5B21__GUID-21F1013F-E2DE-4485-B441-B416B1403990">
                           <p class="notep1">注意：</p>
                           <p>选择性是在执行计划中不可见的内部计算。</p>
                        </div>
                        <p>谓词过滤行集中的特定行数。因此，谓词的选择性表示通过谓词测试的行数。选择性范围从0.0到1.0。选择性0.0表示没有从行集中选择行，而选择性1.0表示选择所有行。当值接近1.0时，谓词变得更具选择性，而当值接近1.0时，谓词变得更具选择性（或更不具有选择性）。</p>
                        <p>优化程序根据统计信息是否可用来估计选择性：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>统计数据不详</p>
                              <p>根据<code class="codeph">OPTIMIZER_DYNAMIC_SAMPLING</code>初始化参数的值， <code class="codeph">OPTIMIZER_DYNAMIC_SAMPLING</code>程序使用<a href="glossary.html#GUID-453737A7-931A-49D1-AA5C-AFB14D9837FB"><span class="xrefglossterm">动态统计信息</span></a>或内部默认值。数据库使用不同的内部默认值，具体取决于谓词类型。例如，等式谓词（ <code class="codeph">last_name = 'Smith'</code> ）的内部缺省值低于范围谓词（ <code class="codeph">last_name &gt; 'Smith'</code> ），因为等式谓词预计会返回较小的行分数。
                              </p>
                           </li>
                           <li>
                              <p>统计数据</p>
                              <p>当统计数据可用时，估算器使用它们来估计选择性。假设有150个不同的员工姓氏。对于等式谓词<code class="codeph">last_name = 'Smith'</code> ，selective是<code class="codeph">last_name</code>的不同值的数量<span class="italic"><code class="codeph">n</code></span>的倒数，在此示例中为.006，因为查询选择包含150个不同值中的1个的行。
                              </p>
                              <p>如果<code class="codeph">last_name</code>列上存在直方图，则估计器使用直方图而不是不同值的数量。直方图捕获列中不同值的分布，因此可以产生更好的选择性估计值，尤其是对于具有<a href="glossary.html#GUID-D20523EE-FDDA-4C69-95CB-52EFC512616B"><span class="xrefglossterm">数据偏斜的</span></a>列。
                              </p>
                           </li>
                        </ul>
                     </div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-60B12417-9E06-4F3F-B796-DF86549A5B21__GUID-B57621DB-7C01-4836-882A-C1180D1CDCA9">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><span class="q">“ <a href="histograms.html#GUID-BE10EBFC-FEFC-4530-90DF-1443D9AD9B64" title="直方图是一种特殊类型的列统计信息，它提供有关表列中数据分布的更多详细信息。直方图将值排序为" buckets="=" ="">直方图</a> ”</span></p>
                              </li>
                              <li>
                                 <p><a href="../refrn/OPTIMIZER_DYNAMIC_SAMPLING.html#REFRN-GUID-43655FC3-3C32-486B-8B11-8C20C152618D" target="_blank"><span><cite>Oracle数据库参考</cite></span></a>了解有关<code class="codeph">OPTIMIZER_DYNAMIC_SAMPLING</code>更多信息</p>
                              </li>
                           </ul>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="query-optimizer-concepts.html#GUID-2AB938B9-E1A8-4344-924B-8EFBB6134AFE" title="估计器是优化器的组件，用于确定给定执行计划的总体成本。">Estimator</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TGSQL216"></a><div class="props_rev_3"><a id="GUID-58CF21C3-3233-415C-BBE6-61AAA976EAD7" name="GUID-58CF21C3-3233-415C-BBE6-61AAA976EAD7"></a><h5 id="TGSQL-GUID-58CF21C3-3233-415C-BBE6-61AAA976EAD7" class="sect5"><span class="enumeration_section">4.2.2.2</span>基数</h5>
                     <div>
                        <p><span class="bold">基数</span>是执行计划中每个操作返回的行数。
                        </p>
                        <p>例如，如果优化程序对全表扫描返回的行数的估计值为100，则此操作的基数估计值为100。基数估计值显示在执行计划的“ <code class="codeph">Rows</code>列中。
                        </p>
                        <p>优化程序根据一组复杂的公式确定每个操作的基数，这些公式使用表级和列级统计信息或动态统计信息作为输入。当单表等式谓词出现在单表查询中时，优化程序使用最简单的公式之一，没有直方图。在这种情况下，优化程序采用统一分布并通过将表中的总行数除以<code class="codeph">WHERE</code>子句谓词中使用的列中的不同值的数量来计算查询的基数。
                        </p>
                        <p>例如，用户<code class="codeph">hr</code>查询<code class="codeph">employees</code>表，如下所示：</p><pre class="pre codeblock"><code>SELECT first_name，last_name FROM employees WHERE salary ='10200';</code></pre><p><code class="codeph">employees</code>表包含107行。当前数据库统计信息表明<code class="codeph">salary</code>列中的不同值的数量为<code class="codeph">58</code> 。因此，优化器使用公式<code class="codeph">107/58=1.84</code>将结果集的基数估计为<code class="codeph">2</code> 。
                        </p>
                        <p>基数估计必须尽可能准确，因为它们会影响执行计划的所有方面。当优化器确定连接的成本时，基数很重要。例如，在一个嵌套循环加入的<code class="codeph">employees</code>和<code class="codeph">departments</code>表，行的数<code class="codeph">employees</code>决定了数据库必须多久探测<code class="codeph">departments</code>表。基数对于确定各种成本也很重要。
                        </p>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="query-optimizer-concepts.html#GUID-2AB938B9-E1A8-4344-924B-8EFBB6134AFE" title="估计器是优化器的组件，用于确定给定执行计划的总体成本。">Estimator</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TGSQL217"></a><div class="props_rev_3"><a id="GUID-9D0BF31B-7215-4BD8-B45D-A8BF2B4DB7E5" name="GUID-9D0BF31B-7215-4BD8-B45D-A8BF2B4DB7E5"></a><h5 id="TGSQL-GUID-9D0BF31B-7215-4BD8-B45D-A8BF2B4DB7E5" class="sect5"><span class="enumeration_section">4.2.2.3</span>成本</h5>
                     <div>
                        <p><span class="bold">优化程序成本模型</span>考虑了预计使用查询的计算机资源。
                        </p>
                        <p><a href="glossary.html#GUID-7FCF0F80-65B5-4F76-A521-91ABD109DA17"><span class="xrefglossterm">成本</span></a>是一个内部数字度量，表示计划的估计资源使用情况。该开销<span class="italic">特定</span>于优化器环境中的查询。要估算成本，优化程序会考虑以下因素：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>系统资源，包括估计的I / O，CPU和内存</p>
                           </li>
                           <li>
                              <p>估计返回的行数（基数）</p>
                           </li>
                           <li>
                              <p>初始数据集的大小</p>
                           </li>
                           <li>
                              <p>分发数据</p>
                           </li>
                           <li>
                              <p>访问结构</p>
                           </li>
                        </ul>
                        <div class="infoboxnote" id="GUID-9D0BF31B-7215-4BD8-B45D-A8BF2B4DB7E5__GUID-28BE350F-0BAE-4482-BA17-F86879F58046">
                           <p class="notep1">注意：</p>
                           <p>成本是优化程序用于比较同一查询的不同计划的<span class="italic">内部</span>度量。您无法调整或更改费用。
                           </p>
                        </div>
                        <p>执行时间是成本的函数，但成本并不直接等同于时间。例如，如果查询<span class="italic">A</span>的计划成本低于查询<span class="italic">B</span>的计划，则可能会产生以下结果：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><span class="italic">A</span>执行速度比<span class="italic">B</span>快。</p>
                           </li>
                           <li>
                              <p><span class="italic">A</span>执行速度比<span class="italic">B</span>慢。</p>
                           </li>
                           <li>
                              <p><span class="italic">A</span>在与<span class="italic">B</span>相同的时间内执行。</p>
                           </li>
                        </ul>
                        <p>因此，您无法将不同查询的成本相互比较。此外，您无法比较使用不同优化程序模式的语义等效查询的成本。</p>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="query-optimizer-concepts.html#GUID-2AB938B9-E1A8-4344-924B-8EFBB6134AFE" title="估计器是优化器的组件，用于确定给定执行计划的总体成本。">Estimator</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="TGSQL219"></a><a id="TGSQL218"></a><div class="props_rev_3"><a id="GUID-CB5FAF86-7DAF-446B-98A9-CB8DF3B2C68F" name="GUID-CB5FAF86-7DAF-446B-98A9-CB8DF3B2C68F"></a><h4 id="TGSQL-GUID-CB5FAF86-7DAF-446B-98A9-CB8DF3B2C68F" class="sect4"><span class="enumeration_section">4.2.3</span>计划生成器</h4>
                  <div>
                     <p><strong class="term">计划生成器</strong>通过尝试不同的访问路径，连接方法和连接顺序来探索查询块的各种计划。
                     </p>
                     <p>由于数据库可以使用各种组合来产生相同的结果，因此可能有许多计划。优化器以最低的成本选择计划。</p>
                     <p>下图显示了优化程序测试输入查询的不同计划。</p>
                     <div class="figure" id="GUID-CB5FAF86-7DAF-446B-98A9-CB8DF3B2C68F__BABJDBIH">
                        <p class="titleinfigure">图4-5计划生成器</p><img src="img/tgsql_vm_045.png" alt="下面是图4-5的描述" title="下面是图4-5的描述" longdesc="img_text/tgsql_vm_045.html"><br><a href="img_text/tgsql_vm_045.html">“图4-5计划生成器”的说明</a></div>
                     <!-- class="figure" -->
                     <p>优化程序跟踪文件中的以下代码段显示了优化程序执行的一些计算：</p><pre class="pre codeblock"><code>一般计划***************************************考虑基于基数的初始连接顺序。启动表的排列：0 <span class="bold">加入订单[1]：部门[D]＃0员工[E]＃1</span> ***************现在加入：员工[E]＃1 ** ************* NL加入外表：卡：27.00费用：2.01积分：2.01度：1字节：16员工的访问路径分析。 。 。
  <span class="bold">最佳NL成本：13.17</span> 。 。 。SM加入<span class="bold">SM费用：6.08</span> resc：6.08 resc_io：4.00 resc_cpu：2501688 resp：6.08 resp_io：4.00 resp_cpu：2501688。 。 。SM Join（外部索引）Access Path：index（FullScan）。 。 。HA加入<span class="bold">HA费用：4.57</span> resc：4.57 resc_io：4.00 resc_cpu：678154 resp：4.57 resp_io：4.00 resp_cpu：678154 <span class="bold">Best :: JoinMethod：Hash</span> Cost：4.57 Degree：1 Resp：4.57 Card：106.00 Bytes：27。 。 。*********************** <span class="bold">加入订单[2]：员工[E]＃1部门[D]＃0</span> 。 。 。***************现在加入：部门[D]＃0 ***************。 。 。HA加入HA费用：4.58 resc：4.58 resc_io：4.00 resc_cpu：690054 resp：4.58 resp_io：4.00 resp_cpu：690054 <span class="bold">加入订单已中止：费用&gt;最佳计划费用</span> ***************** ******</code></pre><p>跟踪文件显示优化器首先尝试将<code class="codeph">departments</code>表作为连接中的外部表。优化器计算三种不同连接方法的开销：嵌套循环连接（NL），排序合并（SM）和散列连接（HA）。优化器选择散列连接作为最有效的方法：</p><pre class="pre codeblock"><code><span class="bold">Best :: JoinMethod：Hash</span> Cost：4.57 Degree：1 Resp：4.57 Card：106.00 Bytes：27</code></pre><p>然后，优化器使用<code class="codeph">employees</code>作为外部表来尝试不同的连接顺序。此联接订单的成本高于之前的联接订单，因此将被放弃。
                     </p>
                     <p>优化程序使用内部截止值来减少在查找成本最低计划时尝试的计划数量。截止值基于当前最佳计划的成本。如果当前最佳成本很高，那么优化器会探索替代计划以找到更低成本的计划。如果当前最佳成本很小，那么优化器会迅速结束搜索，因为进一步的成本改善并不重要。</p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="query-optimizer-concepts.html#GUID-12C47112-B713-4658-89C2-DA756E4D29D3" title="优化器包含三个组件：变换器，估计器和计划生成器。">关于优化程序组件</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div><a id="TGSQL220"></a><div class="props_rev_3"><a id="GUID-7D015E05-A08D-478B-81AC-AB04ECEED8FA" name="GUID-7D015E05-A08D-478B-81AC-AB04ECEED8FA"></a><h3 id="TGSQL-GUID-7D015E05-A08D-478B-81AC-AB04ECEED8FA" class="sect3"><span class="enumeration_section">4.3</span>关于自动调整优化器</h3>
               <div>
                  <p>优化器根据调用方式执行不同的操作。</p>
                  <p>该数据库提供以下类型的优化：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>正常优化</p>
                        <p>优化器编译SQL并生成执行计划。正常模式为大多数SQL语句生成合理的计划。在正常模式下，优化器以严格的时间约束运行，通常只有几分之一秒，在此期间它必须找到最佳计划。</p>
                     </li>
                     <li>
                        <p>SQL Tuning Advisor优化</p>
                        <p>当SQL Tuning Advisor调用优化程序时，优化程序称为<a href="glossary.html#GUID-6FD1585E-9283-4881-A5BF-86165B4F8C23"><span class="xrefglossterm">自动调整优化程序</span></a> 。在这种情况下，优化程序执行其他分析以进一步改进在正常模式下生成的计划。优化程序输出不是执行计划，而是一系列操作，以及它们的基本原理和产生明显更好的计划的预期收益。
                        </p>
                     </li>
                  </ul>
               </div>
               <div>
                  <div class="infoboxnotealso" id="GUID-7D015E05-A08D-478B-81AC-AB04ECEED8FA__GUID-AFE9B45A-19F2-4AA3-BF39-B6F6B75734B7">
                     <p class="notep1">也可以看看：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><span class="q">“ <a href="sql-tuning-advisor.html#GUID-8E1A39CB-A491-4254-8B31-9B1DF7B52AA1" title="使用SQL Tuning Advisor获取有关提高高负载SQL语句性能的建议，并通过仅执行最佳计划来防止回归。">使用SQL Tuning Advisor分析SQL</a> ”</span></p>
                        </li>
                        <li>
                           <p><a href="../tdppt/tuning-sql-statements.html#TDPPT-GUID-6B386EC1-A58F-4CFC-AEFB-9F787A112396" target="_blank"><span><cite>Oracle Database 2 Day +性能调优指南</cite></span></a> ，了解有关SQL Tuning Advisor的更多信息</p>
                        </li>
                     </ul>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="query-optimizer-concepts.html#GUID-06129ACE-36B2-4534-AE68-EDFCAEBB3B5D" title="本章描述了与查询优化器相关的最重要的概念，包括其主要组件。">查询优化器概念</a></p>
                     </div>
                  </div>
               </div>
               
            </div><a id="TGSQL94982"></a><div class="props_rev_3"><a id="GUID-F368C89A-5CAE-432C-845C-CC38C7F93A03" name="GUID-F368C89A-5CAE-432C-845C-CC38C7F93A03"></a><h3 id="TGSQL-GUID-F368C89A-5CAE-432C-845C-CC38C7F93A03" class="sect3"><span class="enumeration_section">4.4</span>关于自适应查询优化</h3>
               <div>
                  <p>在Oracle数据库中， <strong class="term">自适应查询优化</strong>使优化器能够对执行计划进行运行时调整，并发现可以带来更好统计信息的其他信息。
                  </p>
                  <p>当现有统计数据不足以生成最佳计划时，自适应优化很有用。下图显示了自适应查询优化的功能集。</p>
                  <div class="figure" id="GUID-F368C89A-5CAE-432C-845C-CC38C7F93A03__GUID-D43FBDC9-4348-474B-945E-3FE107468170">
                     <p class="titleinfigure">图4-6自适应查询优化</p><img src="img/tgsql_vm_069.png" alt="下面是图4-6的描述" title="下面是图4-6的描述" longdesc="img_text/tgsql_vm_069.html"><br><a href="img_text/tgsql_vm_069.html">“图4-6自适应查询优化”的说明</a></div>
                  <!-- class="figure" -->
                  <p>本节包含以下主题：</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="query-optimizer-concepts.html#GUID-5A1EB094-1A9E-4B69-9BE5-39BDA2B3253C">自适应查询计划</a><br><strong class="term">自适应查询计划</strong>使优化器能够在执行期间为语句做出计划决策。
                     </li>
                     <li class="ulchildlink"><a href="query-optimizer-concepts.html#GUID-298EDC61-405A-4E25-AEF6-C795E32AAC93">自适应统计</a><br>当查询谓词过于复杂而不能单独依赖基表统计<strong class="term">信息</strong>时，优化程序可以使用<strong class="term">自适应统计</strong>信息。默认情况下，禁用自适应统计信息（ <code class="codeph">OPTIMIZER_ADAPTIVE_STATISTICS</code>为<code class="codeph">false</code> ）。
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="query-optimizer-concepts.html#GUID-06129ACE-36B2-4534-AE68-EDFCAEBB3B5D" title="本章描述了与查询优化器相关的最重要的概念，包括其主要组件。">查询优化器概念</a></p>
                     </div>
                  </div>
               </div>
               <a id="TGSQL221"></a><div class="props_rev_3"><a id="GUID-5A1EB094-1A9E-4B69-9BE5-39BDA2B3253C" name="GUID-5A1EB094-1A9E-4B69-9BE5-39BDA2B3253C"></a><h4 id="TGSQL-GUID-5A1EB094-1A9E-4B69-9BE5-39BDA2B3253C" class="sect4"><span class="enumeration_section">4.4.1</span>自适应查询计划</h4>
                  <div>
                     <p><strong class="term">自适应查询计划</strong>使优化器能够在执行期间为语句做出计划决策。
                     </p>
                     <p>自适应查询计划使优化器能够在运行时修复某些类问题。默认情况下启用自适应计划。</p>
                     <p>本节包含以下主题：</p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="query-optimizer-concepts.html#GUID-6E0BFF94-D8EF-45B0-9667-0DCDE58C64B3">关于自适应查询计划</a><br>自适应查询计划包含多个预定子计划和优化器统计收集器。根据执行期间收集的统计信息，动态计划协调员在运行时选择最佳计划。
                        </li>
                        <li class="ulchildlink"><a href="query-optimizer-concepts.html#GUID-3E7CB836-AEA5-4446-BA80-F322258CFCFA">自适应查询计划的目的</a><br>优化程序根据执行期间获得的统计信息调整计划的能力可以极大地提高查询性能。
                        </li>
                        <li class="ulchildlink"><a href="query-optimizer-concepts.html#GUID-A42B8874-95AF-4D5B-B5D9-F0376F91D15E">自适应查询计划的工作原理</a><br>对于第一次执行语句，优化程序使用默认计划，然后存储自适应计划。除非满足特定条件，否则数据库将使用自适应计划进行后续执行。
                        </li>
                        <li class="ulchildlink"><a href="query-optimizer-concepts.html#GUID-07E98844-1072-454E-AD22-4004EBB91104">启用自适应查询计划时</a><br>默认情况下启用自适应查询计划。
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="query-optimizer-concepts.html#GUID-F368C89A-5CAE-432C-845C-CC38C7F93A03" title="在Oracle数据库中，自适应查询优化使优化器能够对执行计划进行运行时调整，并发现可以带来更好统计信息的其他信息。">关于Adaptive Query Optimization</a></p>
                        </div>
                     </div>
                  </div>
                  
                  <div class="sect4"><a id="GUID-6E0BFF94-D8EF-45B0-9667-0DCDE58C64B3" name="GUID-6E0BFF94-D8EF-45B0-9667-0DCDE58C64B3"></a><h5 id="TGSQL-GUID-6E0BFF94-D8EF-45B0-9667-0DCDE58C64B3" class="sect5"><span class="enumeration_section">4.4.1.1</span>关于自适应查询计划</h5>
                     <div>
                        <p>自适应查询计划包含多个预定子计划和优化器统计收集器。根据执行期间收集的统计信息，动态计划协调员在运行时选择最佳计划。</p>
                        <div class="section">
                           <p class="subhead3" id="GUID-6E0BFF94-D8EF-45B0-9667-0DCDE58C64B3__GUID-84D0F6EF-BF1B-4ADE-81B6-05BD31808170">动态计划</p>
                           <p>要在运行时更改计划，自适应查询计划使用<a href="glossary.html#GUID-4434C6EE-B88D-4728-819A-DB0C6F87224C"><span class="xrefglossterm">动态计划</span></a> ，该<a href="glossary.html#GUID-4434C6EE-B88D-4728-819A-DB0C6F87224C"><span class="xrefglossterm">计划</span></a>表示为一组子计划组。<a href="glossary.html#GUID-45C0E5AC-446D-4C1A-9A8B-788F0A974ACF"><span class="xrefglossterm">子计划组</span></a>是一组子计划。<a href="glossary.html#GUID-430086FC-D715-4EE2-AA30-3643828597FA"><span class="xrefglossterm">子</span></a>计划是优化程序在运行时可以切换到的计划的一部分。例如，嵌套循环连接可以在执行期间切换到散列连接。
                           </p>
                           <p>优化程序决定在运行时使用哪个子程序。当通知与子计划组相关的新统计值时，协调器将其分派给该子组的处理函数。</p>
                           <div class="figure" id="GUID-6E0BFF94-D8EF-45B0-9667-0DCDE58C64B3__GUID-3D74649D-DE9C-4035-A525-13718640E1D1">
                              <p class="titleinfigure">图4-7动态计划协调员</p><img src="img/tgsql_vm_095.png" alt="下面是图4-7的描述" title="下面是图4-7的描述" longdesc="img_text/tgsql_vm_095.html"><br><a href="img_text/tgsql_vm_095.html">“图4-7动态规划协调器”的说明</a></div>
                           <!-- class="figure" -->
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-6E0BFF94-D8EF-45B0-9667-0DCDE58C64B3__GUID-F54676D1-FB5C-4BFF-8B20-C4C6B10BC971">优化器统计收集器</p>
                           <p><a href="glossary.html#GUID-D20217BA-B1E4-49B4-9630-97513DF1BFB2"><span class="xrefglossterm">优化程序统计信息收集器</span></a>是在关键点插入计划的行源，用于收集与基数和直方图相关的运行时统计信息。这些统计信息有助于优化器在多个子计划之间做出最终决策。收集器还支持可选的缓冲，最高可达内部阈值。
                           </p>
                           <p>对于并行缓冲统计信息收集器，每个并行执行服务器收集统计信息，并行查询协调器聚合后再发送给客户端。在此上下文中， <span class="italic">客户端</span>是收集的统计信息的使用者，例如动态计划。每个客户端指定要在每个并行服务器或查询协调器上执行的回调函数。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="query-optimizer-concepts.html#GUID-5A1EB094-1A9E-4B69-9BE5-39BDA2B3253C" title="自适应查询计划使优化器能够在执行期间为语句做出计划决策。">自适应查询计划</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
                  <div class="props_rev_3"><a id="GUID-3E7CB836-AEA5-4446-BA80-F322258CFCFA" name="GUID-3E7CB836-AEA5-4446-BA80-F322258CFCFA"></a><h5 id="TGSQL-GUID-3E7CB836-AEA5-4446-BA80-F322258CFCFA" class="sect5"><span class="enumeration_section">4.4.1.2</span>自适应查询计划的目的</h5>
                     <div>
                        <p>优化程序根据执行期间获得的统计信息调整计划的能力可以极大地提高查询性能。</p>
                        <p>自适应查询计划很有用，因为优化器偶尔会选择一个次优的<a href="glossary.html#GUID-AA88D177-24AC-450D-8C6D-9E4EEE2DEF19"><span class="xrefglossterm">默认计划，</span></a>因为基数是错误的。优化程序根据实际执行统计信息在运行时选择最佳计划的能力可以产生更优化的<a href="glossary.html#GUID-584E030C-0C65-4F35-AD63-C30121C0C9D8"><span class="xrefglossterm">最终计划</span></a> 。选择最终计划后，优化程序将其用于后续执行，从而确保不再使用次优计划。
                        </p>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="query-optimizer-concepts.html#GUID-5A1EB094-1A9E-4B69-9BE5-39BDA2B3253C" title="自适应查询计划使优化器能够在执行期间为语句做出计划决策。">自适应查询计划</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TGSQL224"></a><div class="props_rev_3"><a id="GUID-A42B8874-95AF-4D5B-B5D9-F0376F91D15E" name="GUID-A42B8874-95AF-4D5B-B5D9-F0376F91D15E"></a><h5 id="TGSQL-GUID-A42B8874-95AF-4D5B-B5D9-F0376F91D15E" class="sect5"><span class="enumeration_section">4.4.1.3</span>自适应查询计划的工作原理</h5>
                     <div>
                        <p>对于第一次执行语句，优化程序使用默认计划，然后存储自适应计划。除非满足特定条件，否则数据库将使用自适应计划进行后续执行。</p>
                        <p>在第<span class="italic">一次</span>执行语句期间，数据库执行以下步骤：</p>
                        <ol>
                           <li>
                              <p>数据库使用默认计划开始执行语句。</p>
                           </li>
                           <li>
                              <p>统计信息收集器收集有关正在进行的执行的信息，并缓冲子计划接收的一些行。</p>
                              <p>对于并行缓冲统计信息收集器，每个从属进程都会收集统计信息，查询协调器在发送给客户端之前会聚合这些统计信息。</p>
                           </li>
                           <li>
                              <p>根据收集器收集的统计信息，优化器选择子计划。</p>
                              <p>动态计划协调器决定在运行时为所有此类子计划组使用哪个子计划。当通知与子计划组相关的新统计值时，协调器将其分派给该子组的处理函数。</p>
                           </li>
                           <li>
                              <p>收集器停止收集统计信息和缓冲行，允许行通过。</p>
                           </li>
                           <li>
                              <p>数据库将自适应计划存储在子游标中，以便<span class="italic">下一次</span>执行语句可以使用它。
                              </p>
                           </li>
                        </ol>
                        <p>在<span class="italic">后续</span>执行子游标时，优化器将继续使用相同的自适应计划，除非满足下列条件之一，在这种情况下，它会为当前执行选择一个新计划：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>当前计划从共享池中老化。</p>
                           </li>
                           <li>
                              <p>不同的优化器功能（例如，自适应游标共享或统计反馈）使当前计划无效。</p>
                           </li>
                        </ul>
                        <p>本节包含以下主题：</p>
                     </div>
                     <div>
                        <ul class="ullinks">
                           <li class="ulchildlink"><a href="query-optimizer-concepts.html#GUID-FA5123F0-85A8-47A6-9706-E3FE67B54A50">自适应查询计划：加入方法示例</a><br>此示例显示优化程序如何根据运行时收集的信息选择不同的计划。
                           </li>
                           <li class="ulchildlink"><a href="query-optimizer-concepts.html#GUID-B82D2668-CC83-483B-8DC9-404B9CAAD648">自适应查询计划：并行分布方法</a><br>通常，并行执行需要数据重新分配来执行并行排序，聚合和连接等操作。
                           </li>
                           <li class="ulchildlink"><a href="query-optimizer-concepts.html#GUID-54A0766C-C81C-4633-A63A-F4A948BA0B94">自适应查询计划：位图索引修剪</a><br>自适应计划修剪索引，这些索引不会显着减少匹配行的数量。
                           </li>
                        </ul>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="query-optimizer-concepts.html#GUID-5A1EB094-1A9E-4B69-9BE5-39BDA2B3253C" title="自适应查询计划使优化器能够在执行期间为语句做出计划决策。">自适应查询计划</a></p>
                           </div>
                        </div>
                     </div>
                     <a id="TGSQL225"></a><a id="TGSQL95000"></a><div class="props_rev_3"><a id="GUID-FA5123F0-85A8-47A6-9706-E3FE67B54A50" name="GUID-FA5123F0-85A8-47A6-9706-E3FE67B54A50"></a><h6 id="TGSQL-GUID-FA5123F0-85A8-47A6-9706-E3FE67B54A50" class="sect6"><span class="enumeration_section">4.4.1.3.1</span>自适应查询计划：加入方法示例</h6>
                        <div>
                           <p>此示例显示优化程序如何根据运行时收集的信息选择不同的计划。</p>
                           <p>以下查询显示了<code class="codeph">order_items</code>和<code class="codeph">prod_info</code>表的连接。
                           </p><pre class="pre codeblock"><code>SELECT product_name FROM order_items o，prod_info p WHERE o.unit_price = 15 AND quantity&gt; 1 AND p.product_id = o.product_id</code></pre><p>此语句的自适应查询计划显示两个可能的计划，一个具有嵌套循环连接，另一个具有散列连接：</p><pre class="pre codeblock"><code>SELECT * FROM TABLE（DBMS_XPLAN.display_cursor（FORMAT =&gt;'ADAPTIVE'））; SQL_ID 7hj8dwwy6gm7p，子编号0 ------------------------------------- SELECT product_name FROM order_items o，prod_info p WHERE o.unit_price = 15 AND quantity&gt; 1 AND p.product_id = o.product_id计划哈希值：1553478007 -------------------------- -------------------------------------------------- -  | Id |操作|名称|行|字节|成本（％CPU）|时间| -------------------------------------------------- --------------------------- | 0 |选择声明| | | | 7（100）| | | * 1 | HASH JOIN | | 4 | 128 | 7（0）| 00:00:01 | |  -  2 | NESTED LOOPS | | 4 | 128 | 7（0）| 00:00:01 | |  -  3 | NESTED LOOPS | | 4 | 128 | 7（0）| 00:00:01 | |  -  4 |统计收集者| | | | | | | * 5 |表访问完全| ORDER_ITEMS | 4 | 48 | 3（0）| 00:00:01 | |  -  * 6 | INDEX UNIQUE SCAN | PROD_INFO_PK | 1 | | 0（0）| | |  -  7 |按INDEX ROWID表的访问权限| PROD_INFO | 1 | 20 | 1（0）| 00:00:01 | | 8 |表访问完全| PROD_INFO | 1 | 20 | 1（0）| 00:00:01 | -------------------------------------------------- ---------------------------谓词信息（由操作ID标识）：-------------- ------------------------------------- 1  -  access（“P”。“PRODUCT_ID”=“ O“。”PRODUCT_ID“）5  - 过滤器（（”O“。”UNIT_PRICE“= 15 AND”QUANTITY“&gt; 1））6  - 访问（”P“。”PRODUCT_ID“=”O“。”PRODUCT_ID“）注意-----  - 这是一个自适应计划（标有' - '的行不活动）</code></pre><p>如果数据库可以避免扫描<code class="codeph">prod_info</code>的重要部分，那么嵌套循环连接是首选，因为它的行由连接谓词过滤。但是，如果过滤了少量行，则最好在散列连接中扫描右表。
                           </p>
                           <p>下图显示了自适应过程。对于前面示例中的查询，默认计划的自适应部分包含两个子计划，每个子计划使用不同的连接方法。优化程序自动确定每种连接方法何时最佳，具体取决于连接左侧的基数。</p>
                           <p>统计信息收集器缓冲来自<code class="codeph">order_items</code>表的足够的行，以确定要使用的连接方法。如果行计数低于优化程序确定的阈值，则优化程序选择嵌套循环连接;否则，优化器选择散列连接。在这种情况下，来自<code class="codeph">order_items</code>表的行计数高于阈值，因此优化程序为最终计划选择散列连接，并禁用缓冲。
                           </p>
                           <div class="figure" id="GUID-FA5123F0-85A8-47A6-9706-E3FE67B54A50__GUID-D211C556-0892-48C8-99C7-E93A70CE01D8">
                              <p class="titleinfigure">图4-8自适应连接方法</p><img src="img/tgsql_vm_076.png" alt="下面是图4-8的描述" title="下面是图4-8的描述" longdesc="img_text/tgsql_vm_076.html"><br><a href="img_text/tgsql_vm_076.html">“图4-8自适应连接方法”的说明</a></div>
                           <!-- class="figure" -->
                           <p>执行计划的“ <code class="codeph">Note</code>部分指示计划是否是自适应的，以及计划中的哪些行处于非活动状态。
                           </p>
                        </div>
                        <div>
                           <div class="infoboxnotealso" id="GUID-FA5123F0-85A8-47A6-9706-E3FE67B54A50__GUID-EA8D3843-A0C8-4DB1-94C9-F7F76351492A">
                              <p class="notep1">也可以看看：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p><span class="q">“ <a href="influencing-the-optimizer.html#GUID-DAFB7D07-E8B3-4219-A09D-214BD943AFF9" title="在Oracle数据库中，自适应查询优化是优化程序根据运行时收集的统计信息调整执行计划的过程。">控制自适应优化</a> ”</span></p>
                                 </li>
                                 <li>
                                    <p><span class="q">“ <a href="generating-and-displaying-execution-plans.html#GUID-83F88700-3902-4D19-8182-AF2B92AEA7EB" title="The adaptive optimizer is a feature of the optimizer that enables it to adapt plans based on run-time statistics. All adaptive mechanisms can execute a final plan for a statement that differs from the default plan.">显示自适应查询计划：教程</a> ”，</span>用于<span class="q"><a href="generating-and-displaying-execution-plans.html#GUID-83F88700-3902-4D19-8182-AF2B92AEA7EB" title="自适应优化器是优化器的一项功能，使其能够根据运行时统计信息调整计划。所有自适应机制都可以执行与默认计划不同的语句的最终计划。">显示自适应查询计划</a></span>的扩展示例</p>
                                 </li>
                              </ul>
                           </div>
                           <div class="familylinks">
                              <div class="parentlink">
                                 <p><strong>父主题：</strong> <a href="query-optimizer-concepts.html#GUID-A42B8874-95AF-4D5B-B5D9-F0376F91D15E" title="对于第一次执行语句，优化程序使用默认计划，然后存储自适应计划。除非满足特定条件，否则数据库将使用自适应计划进行后续执行。">自适应查询计划的工作原理</a></p>
                              </div>
                           </div>
                        </div>
                        
                     </div><a id="TGSQL95360"></a><a id="TGSQL95022"></a><div class="props_rev_3"><a id="GUID-B82D2668-CC83-483B-8DC9-404B9CAAD648" name="GUID-B82D2668-CC83-483B-8DC9-404B9CAAD648"></a><h6 id="TGSQL-GUID-B82D2668-CC83-483B-8DC9-404B9CAAD648" class="sect6"><span class="enumeration_section">4.4.1.3.2</span>自适应查询计划：并行分布方法</h6>
                        <div>
                           <p>通常，并行执行需要数据重新分配来执行并行排序，聚合和连接等操作。</p>
                           <p>Oracle数据库可以使用许多不同的数据分发方法。数据库根据要分发的行数和操作中的并行服务器进程数选择方法。</p>
                           <p>例如，考虑以下替代案例：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>许多并行服务器进程分配很少的行。</p>
                                 <p>数据库可以选择广播分发方法。在这种情况下，每个并行服务器进程接收结果集中的每一行。</p>
                              </li>
                              <li>
                                 <p>很少有并行服务器进程分配许多行。</p>
                                 <p>如果在数据重新分发期间遇到数据偏差，则可能会对语句的性能产生负面影响。数据库更可能选择散列分布以确保每个并行服务器进程接收相同数量的行。</p>
                              </li>
                           </ul>
                           <p><a href="glossary.html#GUID-23185865-0232-4D40-8FAC-191B79DAF9FF"><span class="xrefglossterm">混合散列分布技术</span></a>是自适应并行数据分布，其直到执行时才决定最终数据分配方法。优化程序在操作的生产者端的并行服务器进程前插入统计信息收集器。如果行数小于阈值（定义为<a href="glossary.html#GUID-B23E1555-67E3-47DE-99B2-B39608F84DA9"><span class="xrefglossterm">并行度（DOP）的</span></a>两倍<a href="glossary.html#GUID-B23E1555-67E3-47DE-99B2-B39608F84DA9"><span class="xrefglossterm">）</span></a> ，则数据分发方法从散列切换到广播。否则，分发方法是哈希。
                           </p>
                           <div class="section">
                              <p class="subhead3" id="GUID-B82D2668-CC83-483B-8DC9-404B9CAAD648__GUID-6B3FD585-4A0F-4AB3-BF79-48A5D5C14CAD">广播发布</p>
                              <p>下图描绘了<code class="codeph">departments</code>和<code class="codeph">employees</code>表之间的混合散列连接，其中查询协调器指导8个并行服务器进程：P5-P8是生产者，而P1-P4是消费者。每个生产者都有自己的消费者。
                              </p>
                              <div class="figure" id="GUID-B82D2668-CC83-483B-8DC9-404B9CAAD648__BABDJAGI">
                                 <p class="titleinfigure">图4-9 DOP为4的自适应查询</p><img src="img/tgsql_vm_077.png" alt="下面是图4-9的描述" title="下面是图4-9的描述" longdesc="img_text/tgsql_vm_077.html"><br><a href="img_text/tgsql_vm_077.html">“图4-9 DOP为4的自适应查询”的描述</a></div>
                              <!-- class="figure" -->
                              <p>数据库在扫描<code class="codeph">departments</code>表的每个生产者进程前插入统计信息收集器。查询协调器聚合收集的统计信息。分发方法基于运行时统计信息。在<a href="query-optimizer-concepts.html#GUID-B82D2668-CC83-483B-8DC9-404B9CAAD648__BABDJAGI">图4-9中</a> ，行数<span class="italic">低于</span>阈值（8），这是DOP（4）的两倍，因此优化器为<code class="codeph">departments</code>表选择广播技术。
                              </p>
                           </div>
                           <!-- class="section" -->
                           <div class="section">
                              <p class="subhead3" id="GUID-B82D2668-CC83-483B-8DC9-404B9CAAD648__GUID-4052A8D4-7698-4245-A557-7435A72951C9">混合哈希分布</p>
                              <p>考虑一个返回更多行的示例。在以下计划中，阈值为8，或指定DOP为4的两倍。但是，因为统计信息收集器（步骤10）发现行数（27）大于阈值（8），所以优化器选择混合散列分布而不是广播分布。（时间列应显示<code class="codeph">00:00:01</code> ，但显示<code class="codeph">0:01</code>因此计划可以适合页面。）
                              </p><pre class="pre codeblock"><code>一世</code></pre></div>
                           <!-- class="section" -->
                        </div>
                        <div>
                           <div class="infoboxnotealso" id="GUID-B82D2668-CC83-483B-8DC9-404B9CAAD648__GUID-1D83F7AC-67D9-4604-B25F-94F9BE4E8A44">
                              <p class="notep1">也可以看看：</p>
                              <p><a href="../vldbg/parallel-exec-intro.html#VLDBG1382" target="_blank"><span><cite>Oracle数据库VLDB和分区指南，</cite></span></a>以了解有关并行数据重新分发技术的更多信息</p>
                           </div>
                           <div class="familylinks">
                              <div class="parentlink">
                                 <p><strong>父主题：</strong> <a href="query-optimizer-concepts.html#GUID-A42B8874-95AF-4D5B-B5D9-F0376F91D15E" title="对于第一次执行语句，优化程序使用默认计划，然后存储自适应计划。除非满足特定条件，否则数据库将使用自适应计划进行后续执行。">自适应查询计划的工作原理</a></p>
                              </div>
                           </div>
                        </div>
                        
                     </div>
                     <div class="sect5"><a id="GUID-54A0766C-C81C-4633-A63A-F4A948BA0B94" name="GUID-54A0766C-C81C-4633-A63A-F4A948BA0B94"></a><h6 id="TGSQL-GUID-54A0766C-C81C-4633-A63A-F4A948BA0B94" class="sect6"><span class="enumeration_section">4.4.1.3.3</span>自适应查询计划：位图索引修剪</h6>
                        <div>
                           <p>自适应计划修剪索引，这些索引不会显着减少匹配行的数量。</p>
                           <p>当优化器生成星形转换计划时，它必须选择正确的位图索引组合，以尽可能有效地减少相关的rowid集。如果存在许多索引，则某些索引可能不会显着减少rowid集，但是在查询执行期间会引入大量处理成本。自适应计划可以通过不使用降低性能的索引来解决此问题。</p>
                           <div class="example" id="GUID-54A0766C-C81C-4633-A63A-F4A948BA0B94__GUID-FDBF23B9-3197-480A-BEBE-E151F50902C3">
                              <p class="titleinexample">例4-2位图索引修剪</p>
                              <p>在此示例中，您发出以下星型查询，该查询将<code class="codeph">cars</code>事实表与多个维度表连接（包括样本输出）：</p><pre class="pre codeblock"><code>SELECT / * + star_transformation（r）* / l.color_name，k.make_name，h.filter_col，count（*）FROM cars r，colors l，make k，models d，hcc_tab h WHERE r.make_id = k.make_id AND r.color_id = l.color_id AND r.model_id = d.model_id AND r.high_card_col = h.high_card_col AND d.model_name ='RAV4'AND k.make_name ='Toyota'AND l.color_name ='Burgundy'AND h。 filter_col = 100 GROUP BY l.color_name，k.make_name，h.filter_col; COLOR_NA MAKE_N FILTER_COL COUNT（*）-------- ------ ---------- ---------- Burgundy Toyota 100 15000</code></pre><p>以下示例执行计划显示查询在步骤12和步骤17中没有为位图节点生成任何行。自适应优化器确定使用<code class="codeph">CAR_MODEL_IDX</code>和<code class="codeph">CAR_MAKE_IDX</code>索引过滤行是低效的。查询未使用计划中以短划线（ <code class="codeph">-</code> ）开头的步骤。
                              </p><pre class="pre codeblock"><code>-------------------------------------------------- --------- | Id |操作|名称| -------------------------------------------------- --------- | 0 |选择声明| | | 1 | SORT GROUP BY NOSORT | | | 2 | HASH JOIN | | | 3 |查看| VW_ST_5497B905 | | 4 | NESTED LOOPS | | | 5 | BITMAP转换为ROWIDS | | | 6 | BITMAP和| | | 7 | BITMAP MERGE | | | 8 | BITMAP KEY ITERATION | | | 9 |表访问完全|颜色| | 10 | BITMAP INDEX RANGE SCAN | CAR_COLOR_IDX | |  -  11 |统计收集者| | |  -  12 | BITMAP MERGE | | |  -  13 | BITMAP KEY ITERATION | | |  -  14 |表访问完全|型号| |  -  15 | BITMAP INDEX RANGE SCAN | CAR_MODEL_IDX | |  -  16 |统计收集者| | |  -  17 | BITMAP MERGE | | |  -  18 | BITMAP KEY ITERATION | | |  -  19 |表访问完全| MAKES | |  -  20 | BITMAP INDEX RANGE SCAN | CAR_MAKE_IDX | | 21 |通过USER ROWID表的访问权限| CARS | | 22 | MERGE加入笛卡尔| | | 23 | MERGE加入笛卡尔| | | 24 | MERGE加入笛卡尔| | | 25 |表访问完全| MAKES | | 26 | BUFFER SORT | | | 27 |表访问完全|型号| | 28 | BUFFER SORT | | | 29 |表访问完全|颜色| | 30 | BUFFER SORT | | | 31 |表访问完全| HCC_TAB | -------------------------------------------------- ---------注意-----  - 使用的动态统计：动态采样（level = 2） - 用于此语句的星形转换 - 这是一个自适应计划（标记为“ - ”的行不活动）</code></pre></div>
                           <!-- class="example" -->
                        </div>
                        <div>
                           <div class="familylinks">
                              <div class="parentlink">
                                 <p><strong>父主题：</strong> <a href="query-optimizer-concepts.html#GUID-A42B8874-95AF-4D5B-B5D9-F0376F91D15E" title="对于第一次执行语句，优化程序使用默认计划，然后存储自适应计划。除非满足特定条件，否则数据库将使用自适应计划进行后续执行。">自适应查询计划的工作原理</a></p>
                              </div>
                           </div>
                        </div>
                        
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-07E98844-1072-454E-AD22-4004EBB91104" name="GUID-07E98844-1072-454E-AD22-4004EBB91104"></a><h5 id="TGSQL-GUID-07E98844-1072-454E-AD22-4004EBB91104" class="sect5"><span class="enumeration_section">4.4.1.4</span>启用自适应查询计划时</h5>
                     <div>
                        <p>默认情况下启用自适应查询计划。</p>
                        <p>设置以下初始化参数时，将启用自适应计划：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">OPTIMIZER_ADAPTIVE_PLANS</code>为<code class="codeph">TRUE</code> （默认）</p>
                           </li>
                           <li>
                              <p><code class="codeph">OPTIMIZER_FEATURES_ENABLE</code>为<code class="codeph">12.1.0.1</code>或更高版本</p>
                           </li>
                           <li>
                              <p><code class="codeph">OPTIMIZER_ADAPTIVE_REPORTING_ONLY</code>为<code class="codeph">FALSE</code> （默认值）</p>
                           </li>
                        </ul>
                        <p>自适应计划控制以下优化：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>嵌套循环和散列连接选择</p>
                           </li>
                           <li>
                              <p>星变换位图修剪</p>
                           </li>
                           <li>
                              <p>自适应并行分配方法</p>
                           </li>
                        </ul>
                     </div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-07E98844-1072-454E-AD22-4004EBB91104__GUID-C2FF55A8-31AC-4F40-A383-8CEB7BFED9E3">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><span class="q">“ <a href="influencing-the-optimizer.html#GUID-DAFB7D07-E8B3-4219-A09D-214BD943AFF9" title="在Oracle数据库中，自适应查询优化是优化程序根据运行时收集的统计信息调整执行计划的过程。">控制自适应优化</a> ”</span></p>
                              </li>
                              <li>
                                 <p><a href="../refrn/OPTIMIZER_ADAPTIVE_PLANS.html#REFRN-GUID-58C3E867-36BA-449A-B452-4E90FE6DCF05" target="_blank"><span><cite>Oracle Database Reference</cite></span></a>了解有关<code class="codeph">OPTIMIZER_ADAPTIVE_PLANS</code>更多信息</p>
                              </li>
                           </ul>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="query-optimizer-concepts.html#GUID-5A1EB094-1A9E-4B69-9BE5-39BDA2B3253C" title="自适应查询计划使优化器能够在执行期间为语句做出计划决策。">自适应查询计划</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="TGSQL94983"></a><div class="props_rev_3"><a id="GUID-298EDC61-405A-4E25-AEF6-C795E32AAC93" name="GUID-298EDC61-405A-4E25-AEF6-C795E32AAC93"></a><h4 id="TGSQL-GUID-298EDC61-405A-4E25-AEF6-C795E32AAC93" class="sect4"><span class="enumeration_section">4.4.2</span>自适应统计</h4>
                  <div>
                     <p>当查询谓词过于复杂而不能单独依赖基表统计<strong class="term">信息</strong>时，优化程序可以使用<strong class="term">自适应统计</strong>信息。默认情况下，禁用自适应统计信息（ <code class="codeph">OPTIMIZER_ADAPTIVE_STATISTICS</code>为<code class="codeph">false</code> ）。
                     </p>
                     <p>以下主题描述了自适应统计的类型：</p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="query-optimizer-concepts.html#GUID-2D218B35-A443-41CB-855C-CF41ADB802EE">动态统计</a><br><span class="bold">动态统计</span>是一种优化技术，其中数据库执行递归SQL语句以扫描表块的小随机样本以估计谓词基数。
                        </li>
                        <li class="ulchildlink"><a href="query-optimizer-concepts.html#GUID-D23F8328-A4CF-4211-8C9B-79B826F34A32">自动重新优化</a><br>在<strong class="term">自动重新优化中</strong> ，优化程序<span class="italic">在</span>初始执行<span class="italic">后</span>更改后续执行的计划。
                        </li>
                        <li class="ulchildlink"><a href="query-optimizer-concepts.html#GUID-FD0EC783-E77C-4F8C-A26D-C2BFDD0F4CB9">SQL计划指令</a><br><span class="bold">SQL计划指令</span>是优化程序用于生成更优计划的附加信息。
                        </li>
                        <li class="ulchildlink"><a href="query-optimizer-concepts.html#GUID-C1426849-DAB0-4532-BD99-A1145AD9348B">启用自适应统计信息时</a><br>默认情况下禁用自适应统计信息
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="query-optimizer-concepts.html#GUID-F368C89A-5CAE-432C-845C-CC38C7F93A03" title="在Oracle数据库中，自适应查询优化使优化器能够对执行计划进行运行时调整，并发现可以带来更好统计信息的其他信息。">关于Adaptive Query Optimization</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="TGSQL94984"></a><div class="props_rev_3"><a id="GUID-2D218B35-A443-41CB-855C-CF41ADB802EE" name="GUID-2D218B35-A443-41CB-855C-CF41ADB802EE"></a><h5 id="TGSQL-GUID-2D218B35-A443-41CB-855C-CF41ADB802EE" class="sect5"><span class="enumeration_section">4.4.2.1</span>动态统计</h5>
                     <div>
                        <p><span class="bold">动态统计</span>是一种优化技术，其中数据库执行递归SQL语句以扫描表块的小随机样本以估计谓词基数。
                        </p>
                        <p>在SQL编译期间，优化程序通过考虑可用统计信息是否足以生成最佳计划来决定是否使用动态统计信息。如果可用统计信息不足，则优化程序使用动态统计信息来扩充统计信息。为了提高优化器决策的质量，优化器可以使用动态统计信息进行表扫描，索引访问，连接和<code class="codeph">GROUP BY</code>操作。
                        </p>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="query-optimizer-concepts.html#GUID-298EDC61-405A-4E25-AEF6-C795E32AAC93" title="当查询谓词过于复杂而不能单独依赖基表统计信息时，优化程序可以使用自适应统计信息。默认情况下，禁用自适应统计信息（OPTIMIZER_ADAPTIVE_STATISTICS为false）。">自适应统计</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TGSQL226"></a><div class="props_rev_3"><a id="GUID-D23F8328-A4CF-4211-8C9B-79B826F34A32" name="GUID-D23F8328-A4CF-4211-8C9B-79B826F34A32"></a><h5 id="TGSQL-GUID-D23F8328-A4CF-4211-8C9B-79B826F34A32" class="sect5"><span class="enumeration_section">4.4.2.2</span>自动重新优化</h5>
                     <div>
                        <p>在<strong class="term">自动重新优化中</strong> ，优化程序<span class="italic">在</span>初始执行<span class="italic">后</span>更改后续执行的计划。
                        </p>
                        <p>自适应查询计划不适用于所有类型的计划更改。例如，具有低效连接顺序的查询可能执行次优，但自适应查询计划不支持<span class="italic">在</span>执行<span class="italic">期间</span>调整连接顺序。在第一次执行SQL语句结束时，优化程序使用在执行期间收集的信息来确定自动重新优化是否具有成本优势。如果执行信息与优化程序估计值显着不同，则优化程序会在下次执行时查找替换计划。
                        </p>
                        <p>优化程序使用上一次执行期间收集的信息来帮助确定备用计划。优化程序可以多次重新优化查询，每次收集其他数据并进一步改进计划。</p>
                        <p>自动重新优化采用以下形式：</p>
                     </div>
                     <div>
                        <ul class="ullinks">
                           <li class="ulchildlink"><a href="query-optimizer-concepts.html#GUID-739F1F0B-ABE2-44C9-9783-8FA54F4ADB12">重新优化：统计反馈</a><br>称为<span class="bold">统计反馈</span> （以前称为<span class="italic">基数反馈</span> ）的重新优化形式自动改进了具有基数误差的重复查询的计划。
                           </li>
                           <li class="ulchildlink"><a href="query-optimizer-concepts.html#GUID-6D6340AC-3565-471B-B6D7-2402E2C14299">重新优化：绩效反馈</a><br>另一种重新优化形式是绩效反馈。当<code class="codeph">PARALLEL_DEGREE_POLICY</code>设置为<code class="codeph">ADAPTIVE</code>时，此重新优化有助于提高自动为重复SQL语句选择的并行度。</li>
                        </ul>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="query-optimizer-concepts.html#GUID-298EDC61-405A-4E25-AEF6-C795E32AAC93" title="当查询谓词过于复杂而不能单独依赖基表统计信息时，优化程序可以使用自适应统计信息。默认情况下，禁用自适应统计信息（OPTIMIZER_ADAPTIVE_STATISTICS为false）。">自适应统计</a></p>
                           </div>
                        </div>
                     </div>
                     <a id="TGSQL94853"></a><a id="TGSQL94850"></a><div class="props_rev_3"><a id="GUID-739F1F0B-ABE2-44C9-9783-8FA54F4ADB12" name="GUID-739F1F0B-ABE2-44C9-9783-8FA54F4ADB12"></a><h6 id="TGSQL-GUID-739F1F0B-ABE2-44C9-9783-8FA54F4ADB12" class="sect6"><span class="enumeration_section">4.4.2.2.1</span>重新优化：统计反馈</h6>
                        <div>
                           <p>称为<span class="bold">统计反馈</span> （以前称为<span class="italic">基数反馈</span> ）的重新优化形式自动改进了具有基数误差的重复查询的计划。
                           </p>
                           <p>优化程序可能由于多种原因错误地估计基数，例如缺少统计信息，不准确的统计信息或复杂谓词。使用统计反馈重新优化的基本过程如下：</p>
                           <ol>
                              <li>
                                 <p>在第一次执行SQL语句期间，优化程序会生成执行计划。</p>
                                 <p>在以下情况下，优化程序可以启用对共享SQL区域的统计信息反馈的监视：</p>
                                 <ul style="list-style-type:disc">
                                    <li>
                                       <p>表没有统计数据</p>
                                    </li>
                                    <li>
                                       <p>表上有多个连接或析取过滤器谓词</p>
                                    </li>
                                    <li>
                                       <p>包含复杂运算符的谓词，优化程序无法准确计算选择性估计值</p>
                                    </li>
                                 </ul>
                              </li>
                              <li>
                                 <p>在第一次执行结束时，优化程序将其初始基数估计值与执行期间计划中每个操作返回的实际行数进行比较。</p>
                                 <p>如果估计值与实际基数存在显着差异，则优化程序会存储正确的估计值以供后续使用。优化器还会创建SQL计划指令，以便其他SQL语句可以从初始执行期间获取的信息中受益。</p>
                              </li>
                              <li>
                                 <p>如果查询再次执行，则优化程序使用更正的基数估计值而不是通常的估计值。</p>
                              </li>
                           </ol>
                           <p><code class="codeph">OPTIMIZER_ADAPTIVE_STATISTICS</code>初始化参数不控制自动重新优化的所有功能。具体而言，此参数仅在自动重新优化的上下文中控制连接基数的统计信息反馈。例如，将<code class="codeph">OPTIMIZER_ADAPTIVE_STATISTICS</code>设置为<code class="codeph">FALSE</code>会禁用连接基数misestimates的统计信息反馈，但它不会禁用单表基数错误估计的统计信息反馈。
                           </p>
                           <div class="example" id="GUID-739F1F0B-ABE2-44C9-9783-8FA54F4ADB12__GUID-C3AB2DB6-B1B8-4D6A-B06E-C8F1763FD712">
                              <p class="titleinexample">例4-3统计反馈</p>
                              <p>此示例显示数据库如何使用统计信息反馈来调整不正确的估计值</p>
                              <ol>
                                 <li>
                                    <p>用户<code class="codeph">oe</code>运行以下<code class="codeph">orders</code> ， <code class="codeph">order_items</code>和<code class="codeph">product_information</code>表的查询：</p><pre class="pre codeblock"><code>SELECT o.order_id，v.product_name FROM orders o，（SELECT order_id，product_name FROM order_items o，product_information p WHERE p.product_id = o.product_id AND list_price &lt;50 AND min_price &lt;40）v WHERE o.order_id = v.order_id</code></pre></li>
                                 <li>
                                    <p>查询光标中的计划显示估计的行（ <code class="codeph">E-Rows</code> ）远远少于实际行（ <code class="codeph">A-Rows</code> ）。
                                    </p><pre class="pre codeblock"><code>-------------------------------------------------- ------------------------------------------------ | Id |操作|名称|开始| E-Rows | A-Rows | A-Time |缓冲区| OMem | 1Mem | O / 1 / M | -------------------------------------------------- ------------------------------------------------ | 0 |选择声明| | 1 | | 269 | 00：00：00.14 | 1338 | | | | | 1 | NESTED LOOPS | | 1 | 1 | 269 | 00：00：00.14 | 1338 | | | | | 2 | MERGE加入笛卡尔| | 1 | 4 | 9135 | 00：00：00.05 | 33 | | | | | * 3 |表访问完整| PRODUCT_INFORMATION | 1 | 1 | 87 | 00：00：00.01 | 32 | | | | | 4 | BUFFER SORT | | 87 | 105 | 9135 | 00：00：00.02 | 1 | 4096 | 4096 | 1/0/0 | | 5 | INDEX FULL SCAN | ORDER_PK | 1 | 105 | 105 | 00：00：00.01 | 1 | | | | | * 6 | INDEX UNIQUE SCAN | ORDER_ITEMS_UK | 9135 | 1 | 269 | 00：00：00.04 | 1305 | | | | -------------------------------------------------- ------------------------------------------------谓词信息（由操作ID标识）：------------------------------------------- -------- 3  -  filter（（“MIN_PRICE”&lt;40 AND“LIST_PRICE”&lt;50））6  - 访问（“O”。“ORDER_ID”=“ORDER_ID”和“P”。“PRODUCT_ID”= “O”。 “PRODUCT_ID”）</code></pre></li>
                                 <li>
                                    <p>用户<code class="codeph">oe</code>重新运行步骤1中的查询。
                                    </p>
                                 </li>
                                 <li>
                                    <p>查询光标中的计划显示优化程序使用统计信息反馈（如<code class="codeph">Note</code>所示）进行第二次执行，并选择了不同的计划。
                                    </p><pre class="pre codeblock"><code>-------------------------------------------------- ------------------------------------------------ | Id |操作|名称|开始| E-Rows | A-Rows | A-Time |缓冲区|读取| OMem | 1Mem | O / 1 / M | -------------------------------------------------- ------------------------------------------------ | 0 |选择声明| | 1 | | 269 | 00：00：00.05 | 60 | 1 | | | | | 1 | NESTED LOOPS | | 1 | 269 | 269 | 00：00：00.05 | 60 | 1 | | | | | * 2 | HASH JOIN | | 1 | 313 | 269 | 00：00：00.05 | 39 | 1 | 1398K | 1398K | 1/0/0 | | * 3 |表访问完整| PRODUCT_INFORMATION | 1 | 87 | 87 | 00：00：00.01 | 15 | 0 | | | | | 4 | INDEX FAST FULL SCAN | ORDER_ITEMS_UK | 1 | 665 | 665 | 00：00：00.01 | 24 | 1 | | | | | * 5 | INDEX UNIQUE SCAN | ORDER_PK | 269 | 1 | 269 | 00：00：00.01 | 21 | 0 | | | | -------------------------------------------------- ------------------------------------------------谓词信息（由操作ID标识）：------------------------------------------- -------- 2  - 访问（“P”。“PRODUCT_ID”=“O”。“PRODUCT_ID”）3  - 过滤器（（“MIN_PRICE”&lt;40 AND“LIST_PRICE”&lt;50））5  - 访问（ “O”。“ORDER_ID”=“ORDER_ID”）注意-----  - 用于此语句的统计信息反馈</code></pre><p>在前面的输出中，步骤1中的估计行数（ <code class="codeph">269</code> ）与实际行数匹配。
                                    </p>
                                 </li>
                              </ol>
                           </div>
                           <!-- class="example" -->
                        </div>
                        <div>
                           <div class="familylinks">
                              <div class="parentlink">
                                 <p><strong>父主题：</strong> <a href="query-optimizer-concepts.html#GUID-D23F8328-A4CF-4211-8C9B-79B826F34A32" title="在自动重新优化中，优化程序在初始执行后更改后续执行的计划。">自动重新优化</a></p>
                              </div>
                           </div>
                        </div>
                        
                     </div><a id="TGSQL95025"></a><div class="props_rev_3"><a id="GUID-6D6340AC-3565-471B-B6D7-2402E2C14299" name="GUID-6D6340AC-3565-471B-B6D7-2402E2C14299"></a><h6 id="TGSQL-GUID-6D6340AC-3565-471B-B6D7-2402E2C14299" class="sect6"><span class="enumeration_section">4.4.2.2.2</span>重新优化：绩效反馈</h6>
                        <div>
                           <p>另一种重新优化形式是绩效反馈。当<code class="codeph">PARALLEL_DEGREE_POLICY</code>设置为<code class="codeph">ADAPTIVE</code>时，此重新优化有助于提高自动为重复SQL语句选择的并行度。</p>
                           <p>使用绩效反馈重新优化的基本过程如下：</p>
                           <ol>
                              <li>
                                 <p>在第一次执行SQL语句期间，当<code class="codeph">PARALLEL_DEGREE_POLICY</code>设置为<code class="codeph">ADAPTIVE</code> ，优化程序将确定是否并行执行该语句，如果是，则使用哪种并行度。
                                 </p>
                                 <p>优化程序根据语句的估计性能选择并行度。为所有语句启用了附加性能监视。</p>
                              </li>
                              <li>
                                 <p>在初始执行结束时，优化器会比较以下内容：</p>
                                 <ul style="list-style-type:disc">
                                    <li>
                                       <p>优化程序选择的并行度</p>
                                    </li>
                                    <li>
                                       <p>根据在语句的实际执行期间收集的性能统计信息（例如，CPU时间）计算并行度</p>
                                    </li>
                                 </ul>
                                 <p>如果两个值显着不同，则数据库标记用于重新分析的语句，并将初始执行统计信息存储为反馈。此反馈有助于更好地计算后续执行的并行度。</p>
                              </li>
                              <li>
                                 <p>如果再次执行查询，则优化程序将使用在初始执行期间收集的性能统计信息来更好地确定语句的并行度。</p>
                              </li>
                           </ol>
                           <div class="infoboxnote" id="GUID-6D6340AC-3565-471B-B6D7-2402E2C14299__GUID-23B9C039-F6B9-44DB-97E2-458195139C65">
                              <p class="notep1">注意：</p>
                              <p>即使<code class="codeph">PARALLEL_DEGREE_POLICY</code>未设置为<code class="codeph">ADAPTIVE</code> ，统计信息反馈也可能会影响为语句选择的并行度。
                              </p>
                           </div>
                        </div>
                        <div>
                           <div class="familylinks">
                              <div class="parentlink">
                                 <p><strong>父主题：</strong> <a href="query-optimizer-concepts.html#GUID-D23F8328-A4CF-4211-8C9B-79B826F34A32" title="在自动重新优化中，优化程序在初始执行后更改后续执行的计划。">自动重新优化</a></p>
                              </div>
                           </div>
                        </div>
                        
                     </div>
                  </div><a id="TGSQL94985"></a><div class="props_rev_3"><a id="GUID-FD0EC783-E77C-4F8C-A26D-C2BFDD0F4CB9" name="GUID-FD0EC783-E77C-4F8C-A26D-C2BFDD0F4CB9"></a><h5 id="TGSQL-GUID-FD0EC783-E77C-4F8C-A26D-C2BFDD0F4CB9" class="sect5"><span class="enumeration_section">4.4.2.3</span> SQL计划指令</h5>
                     <div>
                        <p><span class="bold">SQL计划指令</span>是优化程序用于生成更优计划的附加信息。
                        </p>
                        <p>该指令是优化器的“自我注释”，它错误地估计某些类型谓词的基数，并提醒<code class="codeph">DBMS_STATS</code>收集纠正未来错误估计所需的统计数据。
                        </p>
                        <p>例如，在查询优化期间，在确定表是否是动态统计信息的候选者时，数据库会在统计信息库中查询表中的指令。如果查询连接两个在其连接列中具有数据倾斜的表，则SQL计划指令可以指示优化程序使用动态统计信息来获得准确的基数估计。</p>
                        <p>优化器在查询表达式而不是语句级别收集SQL计划指令，以便它可以将指令应用于多个SQL语句。优化器不仅会纠正自身，还会记录有关错误的信息，以便即使在查询之后数据库仍可以继续更正其估计值，并且从共享池中刷新任何类似的查询。</p>
                        <p>数据库自动创建指令，并将它们存储在<code class="codeph">SYSAUX</code>表空间中。您可以使用PL / SQL包<code class="codeph">DBMS_SPD</code>更改，保存到磁盘和传输指令。</p>
                     </div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-FD0EC783-E77C-4F8C-A26D-C2BFDD0F4CB9__GUID-71C5539F-9685-4DE4-B3B2-69FA015FC07D">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><span class="q">“ <a href="optimizer-statistics-concepts.html#GUID-F8F25E31-7113-4B91-BD81-BE6082983192" title="SQL计划指令是优化程序可用于生成更优计划的附加信息和指令。">SQL计划指令</a> ”</span></p>
                              </li>
                              <li>
                                 <p><span class="q">“ <a href="options-for-optimizer-statistics-gathering.html#GUID-67E635AA-F168-47D7-9DC9-CE8803464B6E" title="SQL计划指令是优化程序可用于生成更优计划的附加信息和指令。">管理SQL计划指令</a> ”</span></p>
                              </li>
                              <li>
                                 <p><a href="../arpls/DBMS_SPD.html#ARPLS73856" target="_blank"><span><cite>Oracle Database PL / SQL包和类型参考，</cite></span></a>以了解<code class="codeph">DBMS_SPD</code>包</p>
                              </li>
                           </ul>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="query-optimizer-concepts.html#GUID-298EDC61-405A-4E25-AEF6-C795E32AAC93" title="当查询谓词过于复杂而不能单独依赖基表统计信息时，优化程序可以使用自适应统计信息。默认情况下，禁用自适应统计信息（OPTIMIZER_ADAPTIVE_STATISTICS为false）。">自适应统计</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
                  <div class="sect4"><a id="GUID-C1426849-DAB0-4532-BD99-A1145AD9348B" name="GUID-C1426849-DAB0-4532-BD99-A1145AD9348B"></a><h5 id="TGSQL-GUID-C1426849-DAB0-4532-BD99-A1145AD9348B" class="sect5"><span class="enumeration_section">4.4.2.4</span>启用自适应统计时</h5>
                     <div>
                        <p>默认情况下禁用自适应统计信息</p>
                        <p>设置以下初始化参数时，将启用自适应统计信息：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">OPTIMIZER_ADAPTIVE_STATISTICS</code>为<code class="codeph">TRUE</code> （默认值为<code class="codeph">FALSE</code> ）</p>
                           </li>
                           <li>
                              <p><code class="codeph">OPTIMIZER_FEATURES_ENABLE</code>为<code class="codeph">12.1.0.1</code>或更高版本</p>
                           </li>
                        </ul>
                        <p>将<code class="codeph">OPTIMIZER_ADAPTIVE_STATISTICS</code>设置为<code class="codeph">TRUE</code>可启用以下功能：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>SQL计划指令</p>
                           </li>
                           <li>
                              <p>加入基数的统计反馈</p>
                           </li>
                           <li>
                              <p>自适应动态采样</p>
                           </li>
                        </ul>
                        <div class="infoboxnote" id="GUID-C1426849-DAB0-4532-BD99-A1145AD9348B__GUID-536C2D28-F940-4BC7-908C-3BF50EE797DE">
                           <p class="notep1">注意：</p>
                           <p>将<code class="codeph">OPTIMIZER_ADAPTIVE_STATISTICS</code>设置为<code class="codeph">FALSE</code>保留单表基数误差的统计信息反馈。
                           </p>
                        </div>
                     </div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-C1426849-DAB0-4532-BD99-A1145AD9348B__GUID-F61BD3A8-59C4-4E2B-B506-3B683DC936F8">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><span class="q">“ <a href="influencing-the-optimizer.html#GUID-DAFB7D07-E8B3-4219-A09D-214BD943AFF9" title="在Oracle数据库中，自适应查询优化是优化程序根据运行时收集的统计信息调整执行计划的过程。">控制自适应优化</a> ”</span></p>
                              </li>
                              <li>
                                 <p><a href="../refrn/OPTIMIZER_ADAPTIVE_STATISTICS.html#REFRN-GUID-D52B4342-3887-4054-A65C-5AEA83F69E35" target="_blank"><span><cite>Oracle Database Reference</cite></span></a>了解有关<code class="codeph">OPTIMIZER_ADAPTIVE_STATISTICS</code>更多信息</p>
                              </li>
                           </ul>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="query-optimizer-concepts.html#GUID-298EDC61-405A-4E25-AEF6-C795E32AAC93" title="当查询谓词过于复杂而不能单独依赖基表统计信息时，优化程序可以使用自适应统计信息。默认情况下，禁用自适应统计信息（OPTIMIZER_ADAPTIVE_STATISTICS为false）。">自适应统计</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div>
            </div>
            <div class="sect2"><a id="GUID-6273DFAC-7C4D-4540-AE11-B6973F237323" name="GUID-6273DFAC-7C4D-4540-AE11-B6973F237323"></a><h3 id="TGSQL-GUID-6273DFAC-7C4D-4540-AE11-B6973F237323" class="sect3"><span class="enumeration_section">4.5</span>关于近似查询处理</h3>
               <div>
                  <p><strong class="term">近似查询处理</strong>是一组优化技术，通过在可接受的误差范围内计算结果来加速分析查询。
                  </p>
                  <p>商业智能（BI）查询严重依赖于涉及聚合函数的排序，例如<code class="codeph">COUNT DISTINCT</code> ， <code class="codeph">SUM</code> ， <code class="codeph">RANK</code>和<code class="codeph">MEDIAN</code> 。例如，应用程序生成报告，显示有多少不同的客户登录，或上周哪些产品最受欢迎。BI应用程序具有以下要求并不罕见：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>查询必须能够处理比传统数据仓库大几个数量级的数据集。</p>
                        <p>例如，一个受欢迎的网站的每日网络日志量可以达到每天数十或数百TB。</p>
                     </li>
                     <li>
                        <p>查询必须提供接近实时的响应。</p>
                        <p>例如，公司需要快速检测并响应信用卡欺诈。</p>
                     </li>
                     <li>
                        <p>大数据集的探索性查询必须快速。</p>
                        <p>例如，用户可能想要找出销售额大致达到特定阈值的部门列表。用户可以在这些部门上形成目标查询，以查找更详细的信息，例如确切的销售数量，这些部门的位置等。</p>
                     </li>
                  </ul>
                  <p>对于大型数据集，精确的聚合查询会消耗大量内存，通常会溢出到临时空间，并且速度会慢得令人无法接受。应用程序通常对<span class="italic">一般</span>模式比对<span class="italic">确切</span>结果更感兴趣，因此客户愿意牺牲速度的准确性。例如，如果目标是显示描绘最受欢迎产品的条形图，那么产品销售100万单位或.999百万单位在统计上是不显着的。
                  </p>
                  <p>Oracle数据库通过近似查询处理实现其解决方案。通常，近似聚合的准确度超过97％（置信度为95％），但处理时间要快几个数量级。数据库使用较少的CPU，并避免写入临时文件的I / O成本。</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="query-optimizer-concepts.html#GUID-DB2B2D98-B47E-4D44-8F94-E44DCFAEF305">近似查询初始化参数</a><br>您可以使用<code class="codeph">APPROX_FOR_ <span class="codeinlineitalic">*</span></code>初始化参数在不更改现有代码的情况下实现近似查询处理。
                     </li>
                     <li class="ulchildlink"><a href="query-optimizer-concepts.html#GUID-D50CE14A-42A9-4E1D-9362-2B3168023FA3">近似查询SQL函数</a><br>近似查询处理使用SQL函数为可接受近似值的探索性查询提供实时响应。
                     </li>
                  </ul>
                  <div class="infoboxnotealso" id="GUID-6273DFAC-7C4D-4540-AE11-B6973F237323__GUID-FAB08416-F3D5-460E-923B-AC7BA19C7EAC">
                     <p class="notep1">也可以看看：</p>
                     <p><span class="q">“ <a href="gathering-optimizer-statistics.html#GUID-EA02EA33-9E0E-4E32-8C74-5943908D0537" title="从Oracle Database 12c Release 2（12.2）开始，HyperLogLog算法可以提高NDV（不同值的数量）计算性能，还可以减少概要所需的存储空间。">NDV算法：自适应采样和HyperLogLog</a> ”</span></p>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="query-optimizer-concepts.html#GUID-06129ACE-36B2-4534-AE68-EDFCAEBB3B5D" title="本章描述了与查询优化器相关的最重要的概念，包括其主要组件。">查询优化器概念</a></p>
                     </div>
                  </div>
               </div>
               
               <div class="sect3"><a id="GUID-DB2B2D98-B47E-4D44-8F94-E44DCFAEF305" name="GUID-DB2B2D98-B47E-4D44-8F94-E44DCFAEF305"></a><h4 id="TGSQL-GUID-DB2B2D98-B47E-4D44-8F94-E44DCFAEF305" class="sect4"><span class="enumeration_section">4.5.1</span>近似查询初始化参数</h4>
                  <div>
                     <p>您可以使用<code class="codeph">APPROX_FOR_ <span class="codeinlineitalic">*</span></code>初始化参数在不更改现有代码的情况下实现近似查询处理。
                     </p>
                     <div class="section">
                        <p>在数据库或会话级别设置这些参数。下表描述了与近似技术相关的初始化参数和SQL函数。</p>
                        <div class="tblformalwide" id="GUID-DB2B2D98-B47E-4D44-8F94-E44DCFAEF305__GUID-277AC236-6A92-4DC5-913A-CFB2B86A14FB">
                           <p class="titleintable">表4-2近似查询初始化参数</p>
                           <table cellpadding="4" cellspacing="0" class="FormalWide" title="近似查询初始化参数" width="100%" border="1" summary="This table describes initialization parameters that use approximation techniques. Column 1 is the user interface, Column 2 is the default value, Column 3 is the description, and Column 4 has links to more information. " frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="20%" id="d11530e5755">初始化参数</th>
                                    <th align="left" valign="bottom" width="20%" id="d11530e5757">默认</th>
                                    <th align="left" valign="bottom" width="20%" id="d11530e5759">描述</th>
                                    <th align="left" valign="bottom" width="20%" id="d11530e5761">也可以看看</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d11530e5765" headers="d11530e5755 ">
                                       <p><code class="codeph">APPROX_FOR_AGGREGATION</code></p>
                                    </td>
                                    <td align="left" valign="top" width="20%" headers="d11530e5765 d11530e5757 "><code class="codeph">假</code></td>
                                    <td align="left" valign="top" width="20%" headers="d11530e5765 d11530e5759 ">
                                       <p>启用（ <code class="codeph">TRUE</code> ）或禁用（ <code class="codeph">FALSE</code> ）近似查询处理。此参数用作伞形参数，用于启用返回近似结果的函数。
                                       </p>
                                    </td>
                                    <td align="left" valign="top" width="20%" headers="d11530e5765 d11530e5761 ">
                                       <p><a href="../refrn/APPROX_FOR_AGGREGATION.html#GUID-46853DF9-7688-46C7-A5BA-308B9B2DAF67" target="_blank"><span><cite>Oracle数据库参考</cite></span></a></p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d11530e5789" headers="d11530e5755 ">
                                       <p><code class="codeph">APPROX_FOR_COUNT_DISTINCT</code></p>
                                    </td>
                                    <td align="left" valign="top" width="20%" headers="d11530e5789 d11530e5757 "><code class="codeph">假</code></td>
                                    <td align="left" valign="top" width="20%" headers="d11530e5789 d11530e5759 ">
                                       <p>将<code class="codeph">COUNT(DISTINCT)</code>转换为<code class="codeph">APPROX_COUNT_DISTINCT</code> 。</p>
                                    </td>
                                    <td align="left" valign="top" width="20%" headers="d11530e5789 d11530e5761 ">
                                       <p><a href="../refrn/APPROX_FOR_COUNT_DISTINCT.html#GUID-D2A8A53F-113A-4E6F-AC2E-37139460EF8D" target="_blank"><span><cite>Oracle数据库参考</cite></span></a></p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d11530e5813" headers="d11530e5755 ">
                                       <p><code class="codeph">APPROX_FOR_PERCENTILE</code></p>
                                    </td>
                                    <td align="left" valign="top" width="20%" headers="d11530e5813 d11530e5757 "><code class="codeph">没有</code></td>
                                    <td align="left" valign="top" width="20%" headers="d11530e5813 d11530e5759 ">
                                       <p>将符合条件的精确百分位函数转换为其<code class="codeph">APPROX_PERCENTILE_*</code>对应项。
                                       </p>
                                    </td>
                                    <td align="left" valign="top" width="20%" headers="d11530e5813 d11530e5761 ">
                                       <p><a href="../refrn/APPROX_FOR_PERCENTILE.html#GUID-3872A78C-9B3F-457C-AD28-4E86F71AE74D" target="_blank"><span><cite>Oracle数据库参考</cite></span></a></p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-DB2B2D98-B47E-4D44-8F94-E44DCFAEF305__GUID-7C3D929B-5190-428E-B13F-30921E286645">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><span class="q">“ <a href="influencing-the-optimizer.html#GUID-C1C85DEA-3583-40FE-B5BB-6AC8F76FFE34" title="Oracle数据库提供初始化参数以影响优化器行为的各个方面，包括游标共享，自适应优化和优化器模式。">关于优化器初始化参数</a> ”</span></p>
                           </li>
                           <li>
                              <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/tgsql&amp;id=DWHSG-GUID-F7E7DEA6-B225-43E6-97ED-CB3DBE86CD54" target="_blank"><span><cite>Oracle数据库数据仓库指南</cite></span></a> ，了解有关近似查询处理的更多信息</p>
                           </li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="query-optimizer-concepts.html#GUID-6273DFAC-7C4D-4540-AE11-B6973F237323" title="近似查询处理是一组优化技术，通过在可接受的误差范围内计算结果来加速分析查询。">关于近似查询处理</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="sect3"><a id="GUID-D50CE14A-42A9-4E1D-9362-2B3168023FA3" name="GUID-D50CE14A-42A9-4E1D-9362-2B3168023FA3"></a><h4 id="TGSQL-GUID-D50CE14A-42A9-4E1D-9362-2B3168023FA3" class="sect4"><span class="enumeration_section">4.5.2</span>近似查询SQL函数</h4>
                  <div>
                     <p>近似查询处理使用SQL函数为可接受近似值的探索性查询提供实时响应。</p>
                     <div class="section">
                        <p>下表描述了返回近似结果的SQL函数。</p>
                        <div class="tblformalwide" id="GUID-D50CE14A-42A9-4E1D-9362-2B3168023FA3__GUID-2BE09E89-B0B0-4FE0-9AB7-8148C8A2107E">
                           <p class="titleintable">表4-3近似查询用户界面</p>
                           <table cellpadding="4" cellspacing="0" class="FormalWide" title="近似查询用户界面" width="100%" border="1" summary="This table describes SQL functions that use approximation techniques. Column 1 is the function. Column 2 is the description. Column 3 has a link to more information." frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="20%" id="d11530e5999">SQL函数</th>
                                    <th align="left" valign="bottom" width="20%" id="d11530e6001">描述</th>
                                    <th align="left" valign="bottom" width="20%" id="d11530e6003">也可以看看</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d11530e6007" headers="d11530e5999 ">
                                       <p><code class="codeph">APPROX_COUNT</code></p>
                                    </td>
                                    <td align="left" valign="top" width="20%" headers="d11530e6007 d11530e6001 ">
                                       <p>与<code class="codeph">APPROX_RANK</code>函数一起使用时，计算<code class="codeph">APPROX_RANK</code> <span class="italic">n个</span>最常见的值。
                                       </p>
                                       <p>返回表达式的近似计数。如果提供<code class="codeph">MAX_ERROR</code>作为第二个参数，则该函数返回实际和近似计数之间的最大误差。
                                       </p>
                                       <p>必须在<code class="codeph">HAVING</code>子句中将此函数与相应的<code class="codeph">APPROX_RANK</code>函数一起使用。如果查询使用<code class="codeph">APPROX_COUNT</code> ， <code class="codeph">APPROX_SUM</code>或<code class="codeph">APPROX_RANK</code> ，则查询不得使用任何其他非近似聚合函数。
                                       </p>
                                       <p>以下查询返回每个部门中最常见的10个作业：</p><pre class="pre codeblock"><code>SELECT department_id，job_id，APPROX_COUNT（*）FROM employees GROUP BY department_id，job_id HAVING APPROX_RANK（PARTITION BY department_id ORDER BY APPROX_COUNT（*）DESC）&lt;= 10;</code></pre></td>
                                    <td align="left" valign="top" width="20%" headers="d11530e6007 d11530e6003 ">
                                       <p><a href="../sqlrf/APPROX_COUNT_DISTINCT.html#SQLRF56901" target="_blank"><span><cite>Oracle数据库SQL语言参考</cite></span></a></p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d11530e6054" headers="d11530e5999 ">
                                       <p><code class="codeph">APPROX_COUNT_DISTINCT</code></p>
                                    </td>
                                    <td align="left" valign="top" width="20%" headers="d11530e6054 d11530e6001 ">
                                       <p>返回包含表达式的不同值的近似行数。</p>
                                    </td>
                                    <td align="left" valign="top" width="20%" headers="d11530e6054 d11530e6003 ">
                                       <p><a href="../sqlrf/APPROX_COUNT_DISTINCT.html#SQLRF56901" target="_blank"><span><cite>Oracle数据库SQL语言参考</cite></span></a></p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d11530e6069" headers="d11530e5999 ">
                                       <p><code class="codeph">APPROX_COUNT_DISTINCT_AGG</code></p>
                                    </td>
                                    <td align="left" valign="top" width="20%" headers="d11530e6069 d11530e6001 ">
                                       <p>将预先计算的近似计数不同的概要聚合到更高的级别。</p>
                                    </td>
                                    <td align="left" valign="top" width="20%" headers="d11530e6069 d11530e6003 ">
                                       <p><a href="../sqlrf/APPROX_COUNT_DISTINCT_AGG.html#SQLRF-GUID-EEDA9388-A066-422A-B5C0-639A3076A10B" target="_blank"><span><cite>Oracle数据库SQL语言参考</cite></span></a></p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d11530e6084" headers="d11530e5999 ">
                                       <p><code class="codeph">APPROX_COUNT_DISTINCT_DETAIL</code></p>
                                    </td>
                                    <td align="left" valign="top" width="20%" headers="d11530e6084 d11530e6001 ">
                                       <p>将<code class="codeph">APPROX_COUNT_DISTINCT</code>函数的概要作为BLOB返回。</p>
                                       <p>数据库可以将返回的结果持久保存到磁盘以进行进一步聚合。</p>
                                    </td>
                                    <td align="left" valign="top" width="20%" headers="d11530e6084 d11530e6003 ">
                                       <p><a href="../sqlrf/APPROX_COUNT_DISTINCT_DETAIL.html#SQLRF-GUID-8FBD2881-743D-425E-A104-472A720DEF50" target="_blank"><span><cite>Oracle数据库SQL语言参考</cite></span></a></p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d11530e6104" headers="d11530e5999 ">
                                       <p><code class="codeph">APPROX_MEDIAN</code></p>
                                    </td>
                                    <td align="left" valign="top" width="20%" headers="d11530e6104 d11530e6001 ">
                                       <p>接受数字或日期时间值，并返回近似中间或近似插值，当值排序时，该插值将是中间值。</p>
                                       <p>此函数提供<code class="codeph">MEDIAN</code>函数的替代方法。
                                       </p>
                                    </td>
                                    <td align="left" valign="top" width="20%" headers="d11530e6104 d11530e6003 ">
                                       <p><a href="../sqlrf/APPROX_MEDIAN.html#SQLRF-GUID-F6A11DF2-121A-4057-9D0B-BF1A221B5622" target="_blank"><span><cite>Oracle数据库SQL语言参考</cite></span></a></p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d11530e6124" headers="d11530e5999 ">
                                       <p><code class="codeph">APPROX_PERCENTILE</code></p>
                                    </td>
                                    <td align="left" valign="top" width="20%" headers="d11530e6124 d11530e6001 ">
                                       <p>接受百分位值和排序规范，并返回与排序规范相关的百分位值的近似插值。</p>
                                       <p>此函数提供<code class="codeph">PERCENTILE_CONT</code>函数的替代方法。
                                       </p>
                                    </td>
                                    <td align="left" valign="top" width="20%" headers="d11530e6124 d11530e6003 ">
                                       <p><a href="../sqlrf/APPROX_PERCENTILE.html#SQLRF-GUID-70D54091-EE2F-4283-A10B-1AB5A1242FE2" target="_blank"><span><cite>Oracle数据库SQL语言参考</cite></span></a></p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d11530e6144" headers="d11530e5999 ">
                                       <p><code class="codeph">APPROX_RANK</code></p>
                                    </td>
                                    <td align="left" valign="top" width="20%" headers="d11530e6144 d11530e6001 ">
                                       <p>返回一组值中的近似值。</p>
                                       <p>此函数采用可选的<code class="codeph">PARTITION BY</code>子句，后跟强制<code class="codeph">ORDER BY ...DESC</code>条款。<code class="codeph">PARTITION BY</code>键必须是<code class="codeph">GROUP BY</code>键的子集。<code class="codeph">ORDER BY</code>子句必须包含<code class="codeph">APPROX_COUNT</code>或<code class="codeph">APPROX_SUM</code> 。</p>
                                    </td>
                                    <td align="left" valign="top" width="20%" headers="d11530e6144 d11530e6003 ">
                                       <p><a href="../sqlrf/APPROX_COUNT_DISTINCT.html#SQLRF56901" target="_blank"><span><cite>Oracle数据库SQL语言参考</cite></span></a></p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d11530e6183" headers="d11530e5999 ">
                                       <p><code class="codeph">APPROX_SUM</code></p>
                                    </td>
                                    <td align="left" valign="top" width="20%" headers="d11530e6183 d11530e6001 ">
                                       <p>与<code class="codeph">APPROX_RANK</code>函数一起使用时，计算近似的前<span class="italic">n个</span>累计值。
                                       </p>
                                       <p>如果提供<code class="codeph">MAX_ERROR</code>作为第二个参数，则该函数返回实际和近似总和之间的最大误差。
                                       </p>
                                       <p>必须在<code class="codeph">HAVING</code>子句中将此函数与相应的<code class="codeph">APPROX_RANK</code>函数一起使用。如果查询使用<code class="codeph">APPROX_COUNT</code> ， <code class="codeph">APPROX_SUM</code>或<code class="codeph">APPROX_RANK</code> ，则查询不得使用任何其他非近似聚合函数。
                                       </p>
                                       <p>以下查询返回具有最高总薪水的每个部门中的10个作业类型：</p><pre class="pre codeblock"><code>SELECT department_id，job_id，APPROX_SUM（薪水）FROM employees GROUP BY department_id，job_id HAVING APPROX_RANK（PARTITION BY department_id ORDER BY APPROX_SUM（薪水）DESC）&lt;= 10;</code></pre><p>请注意，当输入为负数时， <code class="codeph">APPROX_SUM</code>返回错误。
                                       </p>
                                    </td>
                                    <td align="left" valign="top" width="20%" headers="d11530e6183 d11530e6003 ">
                                       <p><a href="../sqlrf/APPROX_COUNT_DISTINCT.html#SQLRF56901" target="_blank"><span><cite>Oracle数据库SQL语言参考</cite></span></a></p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-D50CE14A-42A9-4E1D-9362-2B3168023FA3__GUID-3B409B37-4C3D-4437-817E-78E5C417834B">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="../dwhsg/data-warehouse-optimizations-techniques.html#DWHSG-GUID-F7E7DEA6-B225-43E6-97ED-CB3DBE86CD54" target="_blank"><span><cite>Oracle数据库数据仓库指南</cite></span></a> ，了解有关近似查询处理的更多信息</p>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="query-optimizer-concepts.html#GUID-6273DFAC-7C4D-4540-AE11-B6973F237323" title="近似查询处理是一组优化技术，通过在可接受的误差范围内计算结果来加速分析查询。">关于近似查询处理</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div><a id="TGSQL227"></a><div class="props_rev_3"><a id="GUID-CC06CD2F-2B18-40CB-B182-FE5AE6A4E21D" name="GUID-CC06CD2F-2B18-40CB-B182-FE5AE6A4E21D"></a><h3 id="TGSQL-GUID-CC06CD2F-2B18-40CB-B182-FE5AE6A4E21D" class="sect3"><span class="enumeration_section">4.6</span>关于SQL计划管理</h3>
               <div>
                  <p><span class="bold">SQL计划管理</span>使优化器能够自动管理执行计划，确保数据库仅使用已知或已验证的计划。
                  </p>
                  <p>SQL计划管理可以构建<a href="glossary.html#GUID-A9B279E2-7088-4029-8C94-4E8DD00B7E21"><span class="xrefglossterm">SQL计划基准</span></a> ，该<a href="glossary.html#GUID-A9B279E2-7088-4029-8C94-4E8DD00B7E21"><span class="xrefglossterm">基准</span></a>包含每个SQL语句的一个或多个接受的计划。优化器可以访问和管理SQL语句的计划历史记录和SQL计划基准。主要目标如下：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>识别可重复的SQL语句</p>
                     </li>
                     <li>
                        <p>维护一组SQL语句的计划历史记录以及可能的SQL计划基准</p>
                     </li>
                     <li>
                        <p>检测不在计划历史记录中的计划</p>
                     </li>
                     <li>
                        <p>检测不在SQL计划基准中的更好的计划</p>
                     </li>
                  </ul>
                  <p>优化程序使用常规的基于成本的搜索方法。</p>
               </div>
               <div>
                  <div class="infoboxnotealso" id="GUID-CC06CD2F-2B18-40CB-B182-FE5AE6A4E21D__GUID-83E4F0ED-CE0F-472A-9CBA-0B1F045E2A59">
                     <p class="notep1">也可以看看：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><span class="q">“ <a href="managing-sql-plan-baselines.html#GUID-7024369A-F98D-48E4-921C-C899485C954F" title="本章介绍使用DBMS_SPM程序包与SQL计划管理相关的概念和任务。">管理SQL计划基准</a> ”</span></p>
                        </li>
                        <li>
                           <p><a href="../arpls/DBMS_SPM.html#ARPLS-GUID-D6EC284C-053D-417D-B887-94422BCB4E3A" target="_blank"><span><cite>Oracle Database PL / SQL包和类型参考，</cite></span></a>以了解<code class="codeph">DBMS_SPM</code>包</p>
                        </li>
                     </ul>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="query-optimizer-concepts.html#GUID-06129ACE-36B2-4534-AE68-EDFCAEBB3B5D" title="本章描述了与查询优化器相关的最重要的概念，包括其主要组件。">查询优化器概念</a></p>
                     </div>
                  </div>
               </div>
               
            </div>
            <div class="sect2"><a id="GUID-E76CD42A-3D1B-4A0A-82F6-5270D3B32E7A" name="GUID-E76CD42A-3D1B-4A0A-82F6-5270D3B32E7A"></a><h3 id="TGSQL-GUID-E76CD42A-3D1B-4A0A-82F6-5270D3B32E7A" class="sect3"><span class="enumeration_section">4.7</span>关于隔离的SQL计划</h3>
               <div>
                  <p>Oracle数据库自动隔离由Oracle数据库资源管理器（资源管理器）终止的SQL语句的计划，以超出资源限制。</p>
                  <p>资源管理器可以为SQL语句设置最大估计执行时间，例如20分钟。如果语句超出此限制，则资源管理器将终止该语句。但是，该声明可能会在终止之前重复运行，每次浪费20分钟的资源。</p>
                  <p>从<span>Oracle Database 19c开始</span> ，如果语句超出指定的资源限制，则资源管理器终止执行并“隔离”计划。隔离计划意味着将其放在数据库不会执行的计划黑名单中。请注意，该计划已被隔离，而不是声明本身。
                  </p>
                  <p>我们示例中的查询仅运行20分钟，然后再次运行 - 除非资源限制增加或计划更改。如果限制增加到25分钟，则资源管理器允许使用隔离计划再次运行该语句。如果语句运行23分钟（低于新阈值），则资源管理器将从隔离区中删除该计划。如果该语句运行26分钟（高于新阈值），则除非限制增加，否则该计划将保持隔离状态。</p>
                  <p><code class="codeph">V$SQL.SQL_QUARANTINE</code>列指示在资源管理器取消执行后是否为计划隔离了计划。<code class="codeph">AVOIDED_EXECUTIONS</code>列指示Oracle数据库阻止语句与隔离计划一起运行的频率。
                  </p>
                  <p><code class="codeph">DBMS_SQLQ</code> PL / SQL程序包具有程序单元，使您可以立即将隔离信息保存到磁盘，为隔离计划设置配置选项（或强制隔离计划），还可以删除配置选项。例如，对于单个SQL语句，您可以指定单个计划或所有计划都被隔离。您可以为隔离计划配置特定阈值，例如，为CPU时间启用10秒的阈值或删除I / O请求的阈值。
                  </p>
               </div>
               <div>
                  <div class="infoboxnotealso" id="GUID-E76CD42A-3D1B-4A0A-82F6-5270D3B32E7A__GUID-A8045E28-19CC-4CC3-ACD3-38CA060135B0">
                     <p class="notep1">也可以看看：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="../admin/managing-resources-with-oracle-database-resource-manager.html#GUID-4206F2EE-E897-4F60-BDE0-3623C1BDBB12" target="_blank"><span><cite>Oracle数据库管理员指南</cite></span></a> ，了解资源管理器如何隔离计划</p>
                        </li>
                        <li>
                           <p><a href="../arpls/DBMS_SQLDIAG.html#GUID-37E72B14-17BB-47E1-9EA4-1EA1DE823867" target="_blank"><span><cite>Oracle Database PL / SQL包和类型参考，</cite></span></a>以了解<code class="codeph">DBMS_SQLQ</code></p>
                        </li>
                        <li>
                           <p><a href="../refrn/V-SQL.html#GUID-2B9340D7-4AA8-4894-94C0-D5990F67BE75" target="_blank"><span><cite>Oracle Database Reference</cite></span></a>了解<code class="codeph">V$SQL</code></p>
                        </li>
                        <li>
                           <p><a href="../dblic/Licensing-Information.html#DBLIC-GUID-0F9EB85D-4610-4EDF-89C2-4916A0E7AC87" target="_blank"><span><cite>“Oracle数据库许可信息用户手册”</cite></span></a> ，了解不同版本和服务支持哪些功能的详细信息</p>
                        </li>
                     </ul>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="query-optimizer-concepts.html#GUID-06129ACE-36B2-4534-AE68-EDFCAEBB3B5D" title="本章描述了与查询优化器相关的最重要的概念，包括其主要组件。">查询优化器概念</a></p>
                     </div>
                  </div>
               </div>
               
            </div>
            <div class="sect2"><a id="GUID-44EB8261-A7B1-4402-94ED-5152EE1C5D08" name="GUID-44EB8261-A7B1-4402-94ED-5152EE1C5D08"></a><h3 id="TGSQL-GUID-44EB8261-A7B1-4402-94ED-5152EE1C5D08" class="sect3"><span class="enumeration_section">4.8</span>关于表达式统计存储（ESS）</h3>
               <div>
                  <p><span class="bold">表达式统计信息存储（ESS）</span>是由优化程序维护的存储库，用于存储有关表达式评估的统计信息。
                  </p>
                  <p>启用IM列存储后，数据库会利用ESS实现其内存中表达式（IM表达式）功能。但是，ESS独立于IM列存储。ESS是数据库的永久组件，无法禁用。</p>
                  <p>数据库使用ESS来确定表达式是否“热”（经常访问），因此是IM表达式的候选者。在查询的硬分析期间，ESS在<code class="codeph">SELECT</code>列表， <code class="codeph">WHERE</code>子句， <code class="codeph">GROUP BY</code>子句等中查找活动表达式。
                  </p>
                  <p>对于每个段，ESS维护表达式统计信息，如下所示：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>执行频率</p>
                     </li>
                     <li>
                        <p>评估成本</p>
                     </li>
                     <li>
                        <p>时间戳评估</p>
                     </li>
                  </ul>
                  <p>优化程序根据成本和评估次数为每个表达式分配加权分数。值是近似值而不是精确值。更活跃的表达有更高的分数。ESS维护最常访问的表达式的内部列表。</p>
                  <p>ESS驻留在SGA中并且还存在于磁盘上。数据库每15分钟将统计信息保存到磁盘，或立即使用<code class="codeph">DBMS_STATS.FLUSH_DATABASE_MONITORING_INFO</code>过程。ESS统计信息在<code class="codeph">DBA_EXPRESSION_STATISTICS</code>视图中可见。
                  </p>
               </div>
               <div>
                  <div class="infoboxnotealso" id="GUID-44EB8261-A7B1-4402-94ED-5152EE1C5D08__GUID-FF58FB33-824E-4859-8D4D-628EE516EFCD">
                     <p class="notep1">也可以看看：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="../inmem/in-memory-column-store-architecture.html#GUID-BF90E4D7-DA7B-4B2B-A0BB-AE88E0C39757" target="_blank"><span><cite>Oracle Database In-Memory指南</cite></span></a>了解有关ESS的更多信息</p>
                        </li>
                        <li>
                           <p><a href="../arpls/DBMS_STATS.html#GUID-CA79C291-B7B4-4B35-8507-454366D83A03" target="_blank"><span><cite>Oracle Database PL / SQL包和类型参考，</cite></span></a>以了解有关<code class="codeph">DBMS_STATS.FLUSH_DATABASE_MONITORING_INFO</code>更多信息</p>
                        </li>
                     </ul>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="query-optimizer-concepts.html#GUID-06129ACE-36B2-4534-AE68-EDFCAEBB3B5D" title="本章描述了与查询优化器相关的最重要的概念，包括其主要组件。">查询优化器概念</a></p>
                     </div>
                  </div>
               </div>
               
            </div>
         </div>
      </article>
   </body>
</html>