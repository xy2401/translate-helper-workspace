<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <title>Java的应用程序连续性</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="JDBC Developer&#39;s Guide"></meta>
      <meta property="og:description" content=""></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="JDBC Developer&#39;s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="jdbc-developers-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-02-13T13:20:37-08:00"></meta>
      <meta name="dcterms.title" content="JDBC Developer&#39;s Guide"></meta>
      <meta name="dcterms.dateCopyrighted" content="1999, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96471-02"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="transaction-guard.html" title="Previous" type="text/html"></link>
      <link rel="next" href="JDBC-support-Oracle-FAN.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.isVersionOf" content="JJDBC"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="transaction-guard.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="JDBC-support-Oracle-FAN.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">JDBC开发人员指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="high-availablility.html" property="item" typeof="WebPage"><span property="name">高可用性</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">Java的应用程序连续性</li>
            </ol>
            <a id="GUID-AAC6F9B7-9B4C-4098-B0D5-312BF9A13928" name="GUID-AAC6F9B7-9B4C-4098-B0D5-312BF9A13928"></a><a id="JJDBC29059"></a>
            
            <h2 id="JJDBC-GUID-AAC6F9B7-9B4C-4098-B0D5-312BF9A13928" class="sect2"><span class="enumeration_chapter">29</span> Java的应用程序连续性</h2>
         </header>
         <div class="ind"><script type="text/javascript">window.name='application-continuity'</script><script type="text/javascript">
    function footdisplay(footnum,footnote) {
    var msg = window.open('about:blank', 'NewWindow' + footnum,
        'directories=no,height=100,location=no,menubar=no,resizable=yes,' +
        'scrollbars=yes,status=no,toolbar=no,width=598');
    msg.document.open('text/html');
    msg.document.write('<!DOCTYPE html ');
    msg.document.write('PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" ');
    msg.document.write('"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">'); 
    msg.document.write('<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us" dir="ltr"><head><title>');
   
    msg.document.write('Footnote&nbsp; ' + footnum);
    msg.document.write('<\/title><meta http-equiv="Content-Type" ');
    msg.document.write('content="text/html; charset=utf-8" />');
    msg.document.write('<meta http-equiv="Content-Script-Type" ');
    msg.document.write('content="text/javascript" />');
    msg.document.write('<style type="text/css"> <![CDATA[ ');
    msg.document.write('h1 {text-align: center; font-size: 14pt;}');
    msg.document.write('fieldset {border: none;}');
    msg.document.write('form {text-align: center;}');
    msg.document.write(' ]]u003e </style>');
    msg.document.write('<\/head><body><div id="footnote"><h1>Footnote&nbsp; ' + footnum + '<\/h1><p>');
    msg.document.write(footnote);
    msg.document.write('<\/p><form action="" method="post"><fieldset>');
    msg.document.write('<input type="button" value="OK" ');
    msg.document.write('onclick="window.close();" />');
    msg.document.write('<\/fieldset><\/form><\/div><\/body><\/html>');
    msg.document.close();
    setTimeout(function() {
        var height = msg.document.getElementById('footnote').offsetHeight;
        msg.resizeTo(598, height + 100);
    }
    , 100);
    msg.focus();
}
            </script><noscript>
               <p>此页面上的脚本内容仅用于导航目的，不会以任何方式更改内容。</p>
            </noscript>
            <div>
               <p>底层软件，硬件，通信和存储层的中断可能导致应用程序执行失败。在最坏的情况下，可能需要重新启动中间层服务器来处理登录风暴<a id="fn_1" name="fn_1" href="#fn_1" ="a="  ="" ="" onclick="footdisplay(1, "><sup>Foot 1</sup></a> 。为了克服这些问题，Oracle Database <span class="italic">12c</span>第1版（12.1）引入了应用程序连续性功能，该功能可以屏蔽应用程序的数据库中断，最终用户不会遇到此类中断。
               </p>
               <div class="infoboxnote" id="GUID-AAC6F9B7-9B4C-4098-B0D5-312BF9A13928__GUID-94C05BEB-C9DE-47CD-8D48-79CA9F23C8B0">
                  <p class="notep1">注意：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>您必须使用Transaction Guard才能使用此功能。</p>
                     </li>
                     <li>
                        <p>Application Continuity是Oracle JDBC Thin驱动程序的一项功能，JDBC OCI驱动程序不支持该功能。</p>
                     </li>
                     <li>
                        <p>应用程序连续性不支持通过<code class="codeph">ALTER SESSION SET CONTAINER</code>语句在应用程序中显式切换容器和服务。
                        </p>
                     </li>
                  </ul>
               </div>
               <p><a id="d75547e44" class="indexterm-anchor"></a><a id="d75547e46" class="indexterm-anchor"></a> Application Continuity提供了一个通用的，独立于应用程序的解决方案，可以在发生计划内或计划外中断后从应用程序角度恢复工作。中断可能与修复，配置更改或修补程序应用程序之后的系统，通信或硬件有关。
               </p>
               <p>本章将在以下部分中讨论Application Continuity的JDBC方面：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="application-continuity.html#GUID-9298BB8C-0E93-44BF-BA26-A615940C0C84">关于为Java的应用程序连续性配置Oracle JDBC</a></p>
                  </li>
                  <li>
                     <p><a href="application-continuity.html#GUID-79858AAD-BDC4-4CFA-91C2-0F515316E069">关于为Java应用程序连续性配置Oracle数据库</a></p>
                  </li>
                  <li>
                     <p><a href="application-continuity.html#GUID-9E97B6A5-B2F6-42A6-B8DD-60208D6D549C">DRCP的应用程序连续性</a></p>
                  </li>
                  <li>
                     <p><a href="application-continuity.html#GUID-49160347-E0C5-4ABA-A871-3870A87700B1">XA数据源的应用程序连续性支持</a></p>
                  </li>
                  <li>
                     <p><a href="application-continuity.html#GUID-4D8A7123-C76E-419D-8AEE-965636B68773">关于在Java应用程序连续性中识别请求边界</a></p>
                  </li>
                  <li>
                     <p><a href="application-continuity.html#GUID-B0FAA17B-9D7A-4795-828C-A95EE521B008">支持透明应用程序连续性</a></p>
                  </li>
                  <li>
                     <p><a href="application-continuity.html#GUID-360EF7D8-1408-4986-8840-3B52FE679EB2">在应用程序连续性重播之前建立初始状态</a></p>
                  </li>
                  <li>
                     <p><a href="application-continuity.html#GUID-C3E438E9-841B-46FA-9BA3-A8B8752CD2A2">关于延迟Java应用程序连续性的重新连接</a></p>
                  </li>
                  <li>
                     <p><a href="application-continuity.html#GUID-E2D03C02-5710-4A1C-8C3A-33BDB38203D5">关于在Java的应用程序连续性中保留可变值</a></p>
                  </li>
                  <li>
                     <p><a href="application-continuity.html#GUID-DB8762A9-A92E-4ED6-A38F-5E614B37A62E">应用程序连续性统计</a></p>
                  </li>
                  <li>
                     <p><a href="application-continuity.html#GUID-81A928A7-3C69-4308-9DD8-D6A6E3A13A3A">关于在Java应用程序连续性中禁用重播</a></p>
                  </li>
               </ul>
            </div>
            <div>
               <div class="relinfo">
                  <p><strong>相关话题</strong></p>
                  <ul>
                     <li><a href="transaction-guard.html#GUID-6F363D40-9EEB-4D34-B085-B5BF4E988D38">Java的Transaction Guard</a></li>
                  </ul>
               </div>
            </div>
            <a id="JJDBC29073"></a><div class="props_rev_3"><a id="GUID-9298BB8C-0E93-44BF-BA26-A615940C0C84" name="GUID-9298BB8C-0E93-44BF-BA26-A615940C0C84"></a><h3 id="JJDBC-GUID-9298BB8C-0E93-44BF-BA26-A615940C0C84" class="sect3"><span class="enumeration_section">29.1</span>关于为Java的应用程序连续性配置Oracle JDBC</h3>
               <div>
                  <div class="section">
                     <p>您必须使用<code class="codeph">oracle.jdbc.replay.OracleDataSourceImpl</code> ， <code class="codeph">oracle.jdbc.replay.OracleConnectionPoolDataSourceImpl</code>或<code class="codeph">oracle.jdbc.replay.driver.OracleXADataSourceImpl</code>数据源，用于获取JDBC连接。您可以同时使用<code class="codeph">oracle.jdbc.replay.OracleDataSourceImpl</code>和<code class="codeph">oracle.jdbc.replay.OracleConnectionPoolDataSourceImpl</code>以独立方式，或将它们配置为连接池的连接工厂，例如通用连接池（UCP）或Oracle WebLogic Server连接池。
                     </p>
                     <p>从Oracle Database 12 <span class="italic">c</span>第2版（12.2.0.1）开始，JDBC重放驱动程序提供了一个新的数据源，即XA重放数据源，它支持重放JDBC操作，并且还可以与UCP数据源和WebLogic Active GridLink单一一起使用。所有Oracle RAC功能的池数据源，包括快速连接故障转移，运行时连接负载平衡以及所有类型的RAC实例关联。要使用此数据源，您的应用程序必须实现<code class="codeph">oracle.jdbc.replay.OracleXADataSource</code>接口。实际的数据源实现类是<code class="codeph">oracle.jdbc.replay.driver.OracleXADataSourceImpl</code> 。您可以将实现类指定为UCP数据源，将Oracle WebLogic Server GridLink数据源指定为连接工厂。JNDI的工厂类是<code class="codeph">oracle.jdbc.replay.OracleXADataSourceFactory</code> 。
                     </p>
                     <div class="infoboxnote" id="GUID-9298BB8C-0E93-44BF-BA26-A615940C0C84__GUID-3D3C518E-5E7C-4501-8732-F762B206719F">
                        <p class="notep1">注意：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>XA重播数据源不提供可配置的重播模式。要启用重播，必须使用重播数据源并在服务器端的数据库服务上将<code class="codeph">FAILOVER_TYPE</code>设置为<code class="codeph">TRANSACTION</code> （如果尚未设置）。
                              </p>
                           </li>
                           <li>
                              <p>从Oracle Database Release 18c开始，您还可以将<code class="codeph">FAILOVER_TYPE</code>设置为<code class="codeph">AUTO</code>以使用透明应用程序连续性。
                              </p>
                              <div class="infoboxnotealso" id="GUID-9298BB8C-0E93-44BF-BA26-A615940C0C84__GUID-B3E6F24D-B022-4CCF-B11F-1D0D4EC88BC7">
                                 <p class="notep1">也可以看看：</p><a href="../racad/ensuring-application-continuity.html#RACAD-GUID-B2895452-68A1-45E5-A9A7-1888B7B10481" target="_blank"><span><cite>“Oracle Real Application Clusters管理和部署指南”</cite></span></a></div>
                           </li>
                           <li>
                              <p>要动态启用和禁用重播，必须使用重播连接代理上可用的单独API。XA重播数据源不提供连接池。任何<code class="codeph">getXAConnection</code>方法调用都会动态生成一个新的JDBC <code class="codeph">XAConnection</code>代理，它将新的JDBC物理连接保存为委托。委托是Oracle JDBC驱动程序对象。
                              </p>
                           </li>
                        </ul>
                     </div>
                     <p>以下代码段说明了<code class="codeph">oracle.jdbc.replay.的用法<code class="codeph">oracle.jdbc.replay.OracleDataSourceImpl</code>和<code class="codeph">oracle.jdbc.replay.独立JDBC应用程序中的OracleConnectionPoolDataSourceImpl</code> ：</p><pre class="oac_no_warn" dir="ltr">import java.sql。连接; import javax.sql。的PooledConnection; import oracle.jdbc。的OracleConnection; import oracle.jdbc.replay。OracleDataSourceFactory; import oracle.jdbc.replay。OracleDataSource; import oracle.jdbc.replay。OracleConnectionPoolDataSource; ...{......OracleDataSource rds = OracleDataSourceFactory.getOracleDataSource（）; rds.setUser（用户）; rds.setPassword（passwd中）; rds.setURL（URL）; ......//其他数据源配置，如回调，超时等。连接conn = rds.getConnection（）; （（OracleConnection）conn）.beginRequest（）; //显式请求开始......//由应用程序连续性（（OracleConnection）conn）.endRequest（）保护的JDBC调用; //显式请求end conn.close（）; OracleConnectionPoolDataSource rcpds = OracleDataSourceFactory.getOracleConnectionPoolDataSource（）; rcpds.setUser（用户）; rcpds.setPassword（passwd中）; rcpds.setURL（URL）; ...... //其他数据源配置，如回调，超时等，PooledConnection pc = rcpds.getPooledConnection（）;连接conn2 = pc.getConnection（）; //隐式请求开始......//受应用程序连续性保护的JDBC调用conn2.close（）; //隐式请求结束......
</pre><p>使用连接URL时，您必须记住以下几点：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>始终在连接URL中使用瘦驱动程序。</p>
                        </li>
                        <li>
                           <p>始终连接到服务。永远不要使用<code class="codeph">instance_name</code>或SID，因为它们不指向已知的良好实例，并且不推荐使用SID。
                           </p>
                        </li>
                        <li>
                           <p>如果客户端<code class="codeph">ADDRESS_LIST</code>中的地址与数据库的<code class="codeph">REMOTE_LISTENER</code>设置不匹配，则表示无法连接， <code class="codeph">services cannot be found</code> 。因此，客户端<code class="codeph">ADDRESS_LIST</code>中的地址<span class="italic">必须</span>与数据库的<code class="codeph">REMOTE_LISTENER</code>设置匹配：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>如果<code class="codeph">REMOTE_LISTENER</code>设置为<code class="codeph">SCAN_VIP</code> ，则<code class="codeph">ADDRESS_LIST</code>使用<code class="codeph">SCAN_VIP</code></p>
                              </li>
                              <li>
                                 <p>如果<code class="codeph">REMOTE_LISTENER</code>设置为主机VIP，则<code class="codeph">ADDRESS_LIST</code>使用相同的主机VIP</p>
                              </li>
                              <li>
                                 <p>如果<code class="codeph">REMOTE_LISTENER</code>设置为<code class="codeph">SCAN_VIP</code>和主机VIP，则<code class="codeph">ADDRESS_LIST</code>使用<code class="codeph">SCAN_VIP</code>和相同的主机VIP</p>
                                 <div class="infoboxnote" id="GUID-9298BB8C-0E93-44BF-BA26-A615940C0C84__GUID-43C2B435-0867-4E38-B683-8E21AC553340">
                                    <p class="notep1">注意：</p>
                                    <p>对于版本11.2之前的Oracle客户端，必须升级<code class="codeph">ADDRESS_LIST</code>以使用SCAN，这意味着将<code class="codeph">ADDRESS_LIST</code>扩展为与三个SCAN IP地址对应的三个<code class="codeph">ADDRESS</code>条目。
                                    </p>
                                    <p>如果此类客户端通过数据库升级助手连接到从早期版本升级的数据库，则必须保留设置为HOST VIP的这些客户端的<code class="codeph">ADDRESS_LIST</code> 。但是，如果<code class="codeph">REMOTE_LISTENER</code>更改为<code class="codeph">ONLY SCAN</code> ，或者客户端被移动到新安装的Oracle Database 12 <span class="italic">c</span> Release 1，其中<code class="codeph">REMOTE_LISTENER</code> <code class="codeph">ONLY SCAN</code> ，则他们无法获得完整的服务映射，并且可能无法始终连接。
                                    </p>
                                 </div>
                              </li>
                           </ul>
                        </li>
                        <li>
                           <p>在连接字符串中设置<code class="codeph">RETRY_COUNT</code> ， <code class="codeph">RETRY_DELAY</code> ， <code class="codeph">CONNECT_TIMEOUT</code>和<code class="codeph">TRANSPORT_CONNECT_TIMEOUT</code>参数。这是从Oracle Database Release 12.1.0.2开始配置JDBC瘦驱动程序连接的一般建议。这些设置可以改善在运行时，重放时以及计划中断的工作流中获取新连接。
                           </p>
                           <p>该<code class="codeph">CONNECT_TIMEOUT</code>参数相当于<code class="codeph">SQLNET.OUTBOUND_CONNECT_TIMEOUT</code>在参数<code class="codeph">sqlnet.ora</code>文件，适用于完整的连接。<code class="codeph">TRANSPORT_CONNECT_TIMEOUT</code>参数根据<code class="codeph">ADDRESS</code>参数应用。如果未注册服务以进行故障转移或重新启动，则在使用SCAN时重试非常重要。例如，要使用指向SCAN地址的远程侦听器，应使用以下设置：</p><pre class="oac_no_warn" dir="ltr">jdbc：oracle：thin：@（DESCRIPTION =（TRANSPORT_CONNECT_TIMEOUT = 3000）（RETRY_COUNT = 20）（RETRY_DELAY = 3）（FAILOVER = ON）（ADDRESS_LIST =（ADDRESS =（PROTOCOL = tcp）（HOST = CLOUD-SCANVIP.example。 com）（PORT = 5221））（CONNECT_DATA =（SERVICE_NAME = orcl）））REMOTE_LISTENERS = CLOUD-SCANVIP.example.com:5221</pre><p>同样，要使用指向数据库中VIP的远程侦听器，您应该使用以下设置：</p><pre class="oac_no_warn" dir="ltr">jdbc：oracle：thin：@（DESCRIPTION =（TRANSPORT_CONNECT_TIMEOUT = 3000）（CONNECT_TIMEOUT = 60）（RETRY_COUNT = 20）（RETRY_DELAY = 3）（FAILOVER = ON）（ADDRESS_LIST =（ADDRESS =（PROTOCOL = tcp）（HOST = CLOUD） -VIP1.example.com）（PORT = 5221））（ADDRESS =（PROTOCOL = tcp）（HOST = CLOUD-VIP2.example.com）（PORT = 5221））（ADDRESS =（PROTOCOL = tcp）（HOST = CLOUD） -VIP3.example.com）（PORT = 5221）））（CONNECT_DATA =（SERVICE_NAME = orcl）））REMOTE_LISTENERS = CLOUD-VIP1.example.com:5221</pre><div class="infoboxnotealso" id="GUID-9298BB8C-0E93-44BF-BA26-A615940C0C84__GUID-D12FBC1E-80C5-490B-B5C7-2626F8FB0503">
                              <p class="notep1">也可以看看：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>有关本地命名参数的详细信息，请<a href="../netrf/index.html" target="_blank"><span class="italic">参见Oracle数据库网络服务参考</span></a></p>
                                 </li>
                                 <li>
                                    <p><a href="../racad/introduction-to-oracle-rac.html#RACAD7273" target="_blank"><span class="italic">“Oracle Real Application Clusters管理和部署指南”</span></a></p>
                                 </li>
                              </ul>
                           </div>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="data-sources-and-URLs.html#GUID-44572C63-10D2-478A-BB2E-ACF6674C59CC">数据源和URL</a></li>
                     </ul>
                  </div>
               </div>
               
               <div class="sect3"><a id="GUID-1A450223-AE20-4F74-8399-3206CF7C4F2C" name="GUID-1A450223-AE20-4F74-8399-3206CF7C4F2C"></a><h4 id="JJDBC-GUID-1A450223-AE20-4F74-8399-3206CF7C4F2C" class="sect4"><span class="enumeration_section">29.1.1</span>支持具有应用连续性的混凝土类</h4>
                  <div>
                     <p></p>
                     <div class="section">
                        <p>从Oracle Database Release 18c开始，JDBC驱动程序支持以下具有应用程序连续性的具体类：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">oracle.sql。CLOB</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">oracle.sql。NCLOB</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">oracle.sql。BLOB</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">oracle.sql。BFILE</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">oracle.sql。STRUCT</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">oracle.sql。REF</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">oracle.sql。ARRAY</code></p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="JJDBC29074"></a><div class="props_rev_3"><a id="GUID-79858AAD-BDC4-4CFA-91C2-0F515316E069" name="GUID-79858AAD-BDC4-4CFA-91C2-0F515316E069"></a><h3 id="JJDBC-GUID-79858AAD-BDC4-4CFA-91C2-0F515316E069" class="sect3"><span class="enumeration_section">29.2</span>关于为Java应用程序连续性配置Oracle数据库</h3>
               <div>
                  <div class="section">
                     <p>您必须具有以下Oracle数据库配置才能使用Application Continuity for Java：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>使用Oracle Database 12 <span class="italic">c</span>第1版（12.1）或更高版本</p>
                        </li>
                        <li>
                           <p>如果您使用的是Oracle Real Application Clusters（Oracle RAC）或Oracle Data Guard，请确保使用Oracle Notification System（ONS）配置FAN以与Oracle WebLogic Server或通用连接池（UCP）进行通信</p>
                        </li>
                        <li>
                           <p>使用应用程序服务进行所有数据库工作。要创建服务，您必须：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>如果您使用的是Oracle RAC，请运行<code class="codeph">SRVCTL</code>命令</p>
                              </li>
                              <li>
                                 <p>如果您不使用Oracle RAC，请使用<code class="codeph">DBMS_SERVICE</code>包</p>
                              </li>
                           </ul>
                        </li>
                        <li>
                           <p>在服务上设置所需的属性以进行重放和负载平衡。例如，设置：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">aq_ha_notifications = TRUE</code>用于启用FAN通知</p>
                              </li>
                              <li>
                                 <p>使用应用程序连续性的<code class="codeph">FAILOVER_TYPE = TRANSACTION</code>或<code class="codeph">FAILOVER_TYPE = AUTO</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">COMMIT_OUTCOME</code> = <code class="codeph">TRUE</code>用于启用Transaction Guard</p>
                              </li>
                              <li>
                                 <p><code class="codeph">REPLAY_INITIATION_TIMEOUT = 900</code>用于设置重播的持续时间（以秒为单位）</p>
                              </li>
                              <li>
                                 <p><code class="codeph">FAILOVER_RETRIES = 30</code>用于指定每次重播的连接重试次数</p>
                              </li>
                              <li>
                                 <p><code class="codeph">FAILOVER_DELAY = 10</code>表示连接重试之间的延迟（以秒为单位）</p>
                              </li>
                              <li>
                                 <p><code class="codeph">GOAL = SERVICE_TIME</code> ，如果您使用的是Oracle RAC，那么这是推荐的设置</p>
                              </li>
                              <li>
                                 <p><code class="codeph">CLB_GOAL = LONG</code> ，通常对已关闭的工作负载有用。如果您使用的是Oracle RAC，则建议使用此设置。对于大多数其他工作负载，建议使用<code class="codeph">SHORT</code>设置。
                                 </p>
                              </li>
                           </ul>
                        </li>
                        <li>
                           <p>请勿使用数据库服务，即与<code class="codeph">DB_NAME</code>或<code class="codeph">DB_UNIQUE_NAME</code>对应的默认服务。此服务保留给Oracle Enterprise Manager和DBA。Oracle不建议使用数据库服务实现高可用性，因为此服务不能：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>启用和禁用</p>
                              </li>
                              <li>
                                 <p>在Oracle RAC上重新定位</p>
                              </li>
                              <li>
                                 <p>切换到Oracle Data Guard</p>
                              </li>
                           </ul>
                        </li>
                     </ul>
                     <div class="infoboxnotealso" id="GUID-79858AAD-BDC4-4CFA-91C2-0F515316E069__GUID-B23A5703-E649-4011-A983-A5C9C1925052">
                        <p class="notep1">也可以看看：</p>
                        <p>有关应用程序连续性的操作和使用的更多信息，请<a href="../racad/ensuring-application-continuity.html#ADFNS314" target="_blank"><span class="italic">参见“Oracle数据库开发指南”</span></a> 。
                        </p>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div>
            </div>
            <div class="sect2"><a id="GUID-9E97B6A5-B2F6-42A6-B8DD-60208D6D549C" name="GUID-9E97B6A5-B2F6-42A6-B8DD-60208D6D549C"></a><h3 id="JJDBC-GUID-9E97B6A5-B2F6-42A6-B8DD-60208D6D549C" class="sect3"><span class="enumeration_section">29.3</span> DRCP的应用连续性</h3>
               <div>
                  <p></p>
                  <p>Oracle Database Release 18c JDBC驱动程序在服务器端启用数据库驻留连接池（DRCP）时支持应用程序连续性。要将应用程序连续性与DRCP一起使用，必须将应用程序服务配置为使用DRCP的服务器。以下代码段显示了如何在DRCP中使用Application Continuity：</p>
                  <div class="example" id="GUID-9E97B6A5-B2F6-42A6-B8DD-60208D6D549C__GUID-AAED1957-D636-41A4-8FB4-C66284FCE0C6">
                     <p class="titleinexample">例29-1在DRCP中使用应用程序连续性</p><pre class="pre codeblock"><code>...String url =“jdbc：oracle：thin：@（DESCRIPTION =（TRANSPORT_CONNECT_TIMEOUT = 3000）（RETRY_COUNT = 20）（RETRY_DELAY = 3）（FAILOVER = ON）（ADDRESS_LIST =（ADDRESS =（PROTOCOL = tcp）（HOST = CLOUD- SCANVIP.example.com）（PORT = 5221））（CONNECT_DATA =（SERVICE_NAME = ac-service）（SERVER = POOLED）））“; PoolDataSource pds = PoolDataSourceFactory.getPoolDataSource（）; pds.setConnectionFactoryClassName（”oracle.jdbc.pool 。OracleDataSource“）; //设置DataSource属性pds.setUser（”HR“）; pds.setPassword（”hr“）; System.out.println（”Connecting to“+ url）; pds.setURL（url）; pds。 setConnectionPoolName（“HR-Pool1”）; pds.setMinPoolSize（2）; pds.setMaxPoolSize（3）; pds.setInitialPoolSize（2）;属性prop = new Properties（）; prop.put（“oracle.jdbc。DRCPConnectionClass“，”HR-Pool1“）; pds.setConnectionProperties（prop）; ...</code></pre></div>
                  <!-- class="example" -->
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="database-resident-connection-pooling.html#GUID-8B2DD8CE-5E6A-4D15-8997-D3261F137D8E">数据库驻留连接池概述</a></li>
                        <li><a href="application-continuity.html#GUID-79858AAD-BDC4-4CFA-91C2-0F515316E069">关于为Java应用程序连续性配置Oracle数据库</a></li>
                     </ul>
                  </div>
               </div>
               
            </div>
            <div class="sect2"><a id="GUID-49160347-E0C5-4ABA-A871-3870A87700B1" name="GUID-49160347-E0C5-4ABA-A871-3870A87700B1"></a><h3 id="JJDBC-GUID-49160347-E0C5-4ABA-A871-3870A87700B1" class="sect3"><span class="enumeration_section">29.4</span> XA数据源的应用程序连续性支持</h3>
               <div>
                  <p></p>
                  <p>Oracle Database 12 <span class="italic">c</span>第2版（12.2.0.1）引入了一项新功能，该功能通过支持Oracle XA数据源（ <code class="codeph">javax.sql. ）来增强应用程序连续性<code class="codeph">javax.sql.XADataSource</code> ），类似于非XA数据源（ <code class="codeph">javax.sql.DataSource</code> ）。JDBC和Java Transaction API（JTA）都允许JDBC连接可互换地参与本地和全局/ XA事务。但是，许多客户应用程序从XA数据源获取连接，但使用这些连接仅执行本地事务。通过新功能，Application Continuity还涵盖了使用支持XA的数据源但具有本地事务的应用程序，包括可促进全局/ XA事务的本地事务。因此，应用程序连续性的好处，例如故障转移和正向恢复，已扩展到这些应用程序。
                  </p>
                  <div class="infoboxnote" id="GUID-49160347-E0C5-4ABA-A871-3870A87700B1__GUID-465B2E45-3D13-42B0-B26C-F0177BBD7C80">
                     <p class="notep1">注意：</p>
                     <p>您必须使用Transaction Guard 12.2才能使用此功能。</p>
                  </div>
                  <p>只要底层物理连接参与全局/ XA事务或参与任何XA操作，就会在该连接上禁用重播。所有其他XA操作正常运行，但应用程序无法获得应用程序连续性保护。</p>
                  <p>由于上述原因，在连接上禁用重播后，它将一直处于禁用状态，直到下一个请求开始。从全局/ XA事务切换到本地事务模式不会自动重新启用连接上的重播。</p>
                  <p>以下代码段说明了从<code class="codeph">OracleXADataSource</code>获取连接时，本地事务如何支持重放，以及XA事务禁用<code class="codeph">OracleXADataSource</code> ：</p><pre class="pre codeblock"><code>import javax.transaction.xa。*; import oracle.jdbc.replay。OracleXADataSource; import oracle.jdbc.replay。OracleXADataSourceFactory; import oracle.jdbc.replay。ReplayableConnection; OracleXADataSource xards = OracleXADataSourceFactory.getOracleXADataSource（）; xards.setURL（connectURL）; xards.setUser（ <span class="italic">&lt;user_name&gt;</span> ）; xards.setPassword（ <span class="italic">&lt;password&gt;</span> ）; XAConnection xaconn = xards.getXAConnection（）; //隐式请求开始Connection conn = xaconn.getConnection（）; / *本地事务案例* / //请求边界检测OFF（（ReplayableConnection）conn）.beginRequest（）; conn.setAutoCommit（假）; PreparedStatement pstmt = conn.prepareStatement（“select cust_first_name，cust_last_name from customers where customer_id = 1”）; ResultSet rs = pstmt.executeQuery（）; //此时发生中断//此时发生重放rs.next（）; rs.close（）; pstmt.close（）;（（ReplayableConnection）conn）.endRequest（）; .../ * Global / XA事务案例* /（（ReplayableConnection）conn）.beginRequest（）; conn.setAutoCommit（假）; XAResource xares = xaconn.getXAResource（）; Xid xid = createXid（）; //这里禁用重放xares.start（xid，XAResource。TMNOFLAGS）; conn.prepareStatement（“INSERT INTO TEST_TAB VALUES（200，'另一个新记录'）”）; //此时发生中断尝试{//此处不重播并抛出异常conn.executeUpdate（）; } // sqlrexc.getNextException（）显示重播失败catch的原因（SQLRecoverableException sqlrexc）{...}</code></pre></div>
            </div><a id="JJDBC29062"></a><div class="props_rev_3"><a id="GUID-4D8A7123-C76E-419D-8AEE-965636B68773" name="GUID-4D8A7123-C76E-419D-8AEE-965636B68773"></a><h3 id="JJDBC-GUID-4D8A7123-C76E-419D-8AEE-965636B68773" class="sect3"><span class="enumeration_section">29.5</span>关于在Java应用程序连续性中识别请求边界</h3>
               <div>
                  <p>请求是与Oracle数据库的物理连接的工作单元，受Application Continuity保护。请求划分因具体的用例场景而异。从通用连接池（UCP）或WebLogic Server连接池借用连接时，请求开始，并在此连接返回到连接池时结束。</p>
                  <p>JDBC驱动程序在<code class="codeph">oracle.jdbc.提供显式请求边界声明API <code class="codeph">beginRequest</code>和<code class="codeph">endRequest</code> <code class="codeph">oracle.jdbc.OracleConnection</code>接口。这些API使应用程序，框架和连接池能够向JDBC重放驱动程序指示有关分界点的位置，可以安全地释放呼叫历史记录，并在先前请求禁用时启用重放。在请求结束时，JDBC重放驱动程序清除连接上记录的历史记录，其中API被调用。这有助于进一步节省长时间使用相同连接而不将其返回池的应用程序的内存消耗。
                  </p>
                  <p>要使连接池正常工作，应用程序必须在需要时获取连接，并在不使用时释放连接。这可以更好地扩展并透明地提供请求边界。除了改善资源消耗，恢复和负载平衡性能之外，API对应用程序没有影响。这些API不涉及通过调用任何JDBC方法，SQL或PL / SQL来更改连接状态。如果在本地事务处于打开状态时尝试开始或结束请求，则会返回错误。</p>
               </div>
            </div>
            <div class="sect2"><a id="GUID-B0FAA17B-9D7A-4795-828C-A95EE521B008" name="GUID-B0FAA17B-9D7A-4795-828C-A95EE521B008"></a><h3 id="JJDBC-GUID-B0FAA17B-9D7A-4795-828C-A95EE521B008" class="sect3"><span class="enumeration_section">29.6</span>支持透明应用程序连续性</h3>
               <div>
                  <p></p>
                  <p>Oracle Database Release 18c引入了透明应用程序连续性功能，该功能是应用程序连续性的功能模式。透明应用程序连续性透明地跟踪和记录会话和事务状态，以便在可恢复的中断后恢复数据库会话。这是安全执行的，无需了解应用程序或应用程序代码更改。透明度是通过使用状态跟踪基础结构来实现的，该基础结构将会话状态使用分类为应用程序发出用户调用。此功能使驱动程序能够检测并注入可能的请求边界，这些边界称为隐式请求边界。对于隐式请求边界：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>没有对象打开</p>
                     </li>
                     <li>
                        <p>游标返回到驱动程序语句缓存</p>
                     </li>
                     <li>
                        <p>没有交易是开放的</p>
                     </li>
                  </ul>
                  <p>已知在这种情况下的会话状态是可恢复的。驱动程序要么关闭当前捕获并启动新事件，要么在发生禁用事件时启用捕获。在下一次调用服务器时，服务器会验证并在适用的情况下创建请求边界，此时之前没有明确的边界。</p>
                  <p>要使用透明应用程序连续性，必须将数据库服务上的服务器端服务属性<code class="codeph">FAILOVER_TYPE</code>设置为<code class="codeph">AUTO</code> 。</p>
                  <p>对隐式请求的支持有助于减少应用程序故障转移恢复时间并优化应用程序连续性。使用透明应用程序连续性，服务器和驱动程序可以跟踪事务和会话状态使用情况。但是，对于在请求期间更改服务器会话状态的应用程序，应谨慎使用此功能。 JDBC Thin驱动程序提供<code class="codeph">oracle.jdbc.enableImplicitRequests</code>属性以在需要时关闭隐式请求。此属性可以在系统级别设置，该级别适用于所有连接，或者应用于特定连接的连接级别。默认情况下，此属性的值为<code class="codeph">true</code> ，这表示启用了对隐式请求的支持。
                  </p>
                  <div class="infoboxnotealso" id="GUID-B0FAA17B-9D7A-4795-828C-A95EE521B008__GUID-5CD0E6D6-F63F-4406-9AD6-BE1A7E649935">
                     <p class="notep1">也可以看看：</p>
                     <p><a href="../racad/ensuring-application-continuity.html#RACAD-GUID-C1EF6BDA-5F90-448F-A1E2-DC15AD5CFE75" target="_blank"><span><cite>“Oracle Real Application Clusters管理和部署指南”</cite></span></a></p>
                  </div>
                  <p>从Oracle Database Release 19c开始，如果将<code class="codeph">FAILOVER_TYPE</code>服务属性的值设置为<code class="codeph">AUTO</code> ，则Oracle JDBC驱动程序会隐式地对通过重放数据源创建的每个新物理连接发起请求。使用此功能，使用第三方连接池的应用程序可以轻松使用透明应用程序连续性（TAC），而无需更改任何代码来注入请求边界。
                  </p>
                  <p>此隐式<code class="codeph">beginRequest</code>仅适用于重放数据源，仅适用于在启用TAC时在运行时创建的物理连接。在重放尝试期间每次重新连接后（即，在重放连接期间未隐式注入<code class="codeph">beginRequest</code> ）或手动应用程序连续性模式（其中<code class="codeph">FAILOVER_TYPE</code>服务属性设置为<code class="codeph">TRANSACTION</code> ），驱动程序不会隐式地开始请求。</p>
                  <p>如果要显式关闭此功能，可以将Java系统属性<code class="codeph">oracle.jdbc.beginRequestAtConnectionCreation</code>的值设置为<code class="codeph">false.</code> 此属性的默认值为<code class="codeph">true</code> 。
                  </p>
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="application-continuity.html#GUID-DCF5E357-C7FB-4F05-86A9-9AC6D5C4E3B7">关于启用FAILOVER_RESTORE</a></li>
                     </ul>
                  </div>
               </div>
               
            </div><a id="JJDBC29063"></a><div class="props_rev_3"><a id="GUID-360EF7D8-1408-4986-8840-3B52FE679EB2" name="GUID-360EF7D8-1408-4986-8840-3B52FE679EB2"></a><h3 id="JJDBC-GUID-360EF7D8-1408-4986-8840-3B52FE679EB2" class="sect3"><span class="enumeration_section">29.7</span>在应用连续性重播之前建立初始状态</h3>
               <div>
                  <p>非事务性会话状态（NTSS）是存在于数据库事务之外且不受恢复保护的数据库会话的状态。对于使用有状态请求的应用程序，非事务状态将重新建立为重建会话。</p>
                  <p>对于仅在请求开始时设置状态的应用程序，或者对于使用具有预设状态的连接获得性能优势的有状态应用程序，将提供以下回调选项之一：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="application-continuity.html#GUID-F8453033-CFE1-47D4-94D2-37D9ED7D47E5">没有回拨</a></p>
                     </li>
                     <li>
                        <p><a href="application-continuity.html#GUID-B2D36006-58CE-4F45-98E1-FCEC0E1BBC01">连接标签</a></p>
                     </li>
                     <li>
                        <p><a href="application-continuity.html#GUID-715A5BE7-93F3-43CE-89E6-EA350AF6363D">连接初始化回调</a></p>
                     </li>
                     <li>
                        <p><a href="application-continuity.html#GUID-DCF5E357-C7FB-4F05-86A9-9AC6D5C4E3B7">关于启用FAILOVER_RESTORE</a></p>
                     </li>
                  </ul>
               </div><a id="JJDBC29064"></a><div class="props_rev_3"><a id="GUID-F8453033-CFE1-47D4-94D2-37D9ED7D47E5" name="GUID-F8453033-CFE1-47D4-94D2-37D9ED7D47E5"></a><h4 id="JJDBC-GUID-F8453033-CFE1-47D4-94D2-37D9ED7D47E5" class="sect4"><span class="enumeration_section">29.7.1</span>无回叫</h4>
                  <div>
                     <p>在这种情况下，应用程序在每个请求期间构建自己的状态。</p>
                  </div>
               </div><a id="JJDBC29065"></a><div class="props_rev_3"><a id="GUID-B2D36006-58CE-4F45-98E1-FCEC0E1BBC01" name="GUID-B2D36006-58CE-4F45-98E1-FCEC0E1BBC01"></a><h4 id="JJDBC-GUID-B2D36006-58CE-4F45-98E1-FCEC0E1BBC01" class="sect4"><span class="enumeration_section">29.7.2</span>连接标签</h4>
                  <div>
                     <p>此方案仅适用于通用连接池（UCP）和Oracle WebLogic服务器。可以修改应用程序以利用连接上的预设状态。连接标签API确定连接的匹配程度，并在借用连接时使用回调填充间隙。</p>
                     <div class="infoboxnotealso" id="GUID-B2D36006-58CE-4F45-98E1-FCEC0E1BBC01__GUID-99338B10-1D80-4BC7-87A1-A031E36201EA">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="../jjucp/application-continuity-using-ucp.html#JJUCP-GUID-83526888-0AA4-4112-B962-4057D64F192B" target="_blank"><span><cite>Oracle通用连接池开发人员指南</cite></span></a></p>
                     </div>
                  </div>
               </div><a id="JJDBC29066"></a><div class="props_rev_3"><a id="GUID-715A5BE7-93F3-43CE-89E6-EA350AF6363D" name="GUID-715A5BE7-93F3-43CE-89E6-EA350AF6363D"></a><h4 id="JJDBC-GUID-715A5BE7-93F3-43CE-89E6-EA350AF6363D" class="sect4"><span class="enumeration_section">29.7.3</span>连接初始化回调</h4>
                  <div>
                     <p>在此方案中，重播驱动程序使用应用程序回调在运行时和重播期间设置会话的初始状态。JDBC重放驱动程序提供可选的连接初始化回调接口以及注册和取消注册此类回调的方法。</p>
                     <p>注册后，在可恢复的错误之后，每次成功重新连接时都会执行初始化回调。应用程序负责确保初始化操作与故障转移之前的原始连接上的初始化操作相同。如果回调调用失败，则在该连接上禁用重播。</p>
                     <p>本节讨论以下部分中的初始化回调：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="application-continuity.html#GUID-1346A77E-5C9D-4E8F-B922-E5BB5A7EF150">创建初始化回调</a></p>
                        </li>
                        <li>
                           <p><a href="application-continuity.html#GUID-080C92FE-E668-4E43-B6DE-89F8A9143CC9">注册初始化回调</a></p>
                        </li>
                        <li>
                           <p><a href="application-continuity.html#GUID-3FA6B622-0581-452E-AB7D-9784B38FA7FE">删除或取消注册初始化回调</a></p>
                        </li>
                     </ul>
                  </div><a id="JJDBC29067"></a><a id="JJDBC29119"></a><div class="props_rev_3"><a id="GUID-1346A77E-5C9D-4E8F-B922-E5BB5A7EF150" name="GUID-1346A77E-5C9D-4E8F-B922-E5BB5A7EF150"></a><h5 id="JJDBC-GUID-1346A77E-5C9D-4E8F-B922-E5BB5A7EF150" class="sect5"><span class="enumeration_section">29.7.3.1</span>创建初始化回调</h5>
                     <div>
                        <div class="section">
                           <p>要创建JDBC连接初始化回调，应用程序将实现<code class="codeph">oracle.jdbc.replay.ConnectionInitializationCallback</code>接口。<code class="codeph">oracle.jdbc.replay.每个实例都允许一个回调<code class="codeph">oracle.jdbc.replay.OracleDataSource</code>接口。
                           </p>
                           <div class="infoboxnote" id="GUID-1346A77E-5C9D-4E8F-B922-E5BB5A7EF150__GUID-77F15FE4-7D58-4BCA-8073-5B96A6977D20">
                              <p class="notep1">注意：</p>
                              <p>只有在重新连接成功后，才会在故障转移期间调用此回调。</p>
                           </div>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-1346A77E-5C9D-4E8F-B922-E5BB5A7EF150__GUID-A08E71DE-467B-4536-B2F5-54C3388C65A3">例</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p>以下代码片段演示了一个简单的初始化回调实现：</p><pre class="oac_no_warn" dir="ltr">import oracle.jdbc.replay。ConnectionInitializationCallback; class MyConnectionInitializationCallback实现ConnectionInitializationCallback {public MyConnectionInitializationCallback（）{...public void initialize（java.sql。连接连接）抛出SQLException {//如有必要，重置连接状态（如ALTER SESSION）...}}</pre><p>对于使用XA数据源的应用程序，连接初始化回调在XA重放数据源上注册。每次发生以下<span class="italic">两种</span>情况时<span class="italic">都会</span>执行回调：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>从连接池借用连接。</p>
                              </li>
                              <li>
                                 <p>重放XA数据源在故障转移时获得新的物理连接。</p>
                              </li>
                           </ul>
                           <div class="infoboxnote" id="GUID-1346A77E-5C9D-4E8F-B922-E5BB5A7EF150__GUID-91BB5B85-633B-4B1C-9597-19F116F57372">
                              <p class="notep1">注意：</p>
                              <p>连接初始化必须是幂等的。如果连接已初始化，则不得重复连接。这使应用程序能够在故障转移之后和重放开始之前重新建立会话初始起始点。回调执行必须保留打开的本地事务，而不提交或回滚。如果违反此规则，则会引发异常。</p>
                           </div>
                           <p>如果回调调用失败，则在该连接上禁用重播。例如，应用程序在此回调中嵌入连接的设置阶段。</p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="JJDBC29068"></a><div class="props_rev_3"><a id="GUID-080C92FE-E668-4E43-B6DE-89F8A9143CC9" name="GUID-080C92FE-E668-4E43-B6DE-89F8A9143CC9"></a><h5 id="JJDBC-GUID-080C92FE-E668-4E43-B6DE-89F8A9143CC9" class="sect5"><span class="enumeration_section">29.7.3.2</span>注册初始化回调</h5>
                     <div>
                        <div class="section">
                           <p>使用JDBC Replay Driver在<code class="codeph">oracle.jdbc.replay.提供的以下方法<code class="codeph">oracle.jdbc.replay.用于注册连接初始化回调的OracleDataSource</code>接口：</p><pre class="oac_no_warn" dir="ltr"><a id="d75547e1079" class="indexterm-anchor"></a> registerConnectionInitializationCallback（ConnectionInitializationCallback cbk）</pre><p><code class="codeph">OracleDataSource</code>接口的每个实例都允许一次回调。
                           </p>
                           <p>要使用XA数据源，请使用<code class="codeph">oracle.jdbc.replay.的<code class="codeph">registerConnectionInitializationCallback(ConnectionInitializationCallback cbk)</code>方法<code class="codeph">oracle.jdbc.replay.OracleXADataSource</code>接口。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="JJDBC29069"></a><div class="props_rev_3"><a id="GUID-3FA6B622-0581-452E-AB7D-9784B38FA7FE" name="GUID-3FA6B622-0581-452E-AB7D-9784B38FA7FE"></a><h5 id="JJDBC-GUID-3FA6B622-0581-452E-AB7D-9784B38FA7FE" class="sect5"><span class="enumeration_section">29.7.3.3</span>删除或取消注册初始化回调</h5>
                     <div>
                        <div class="section">
                           <p>使用JDBC Replay Driver在<code class="codeph">oracle.jdbc.replay.提供的以下方法<code class="codeph">oracle.jdbc.replay.OracleDataSource</code>接口，用于取消注册连接初始化回调：</p><pre class="oac_no_warn" dir="ltr"><a id="d75547e1125" class="indexterm-anchor"></a> unregisterConnectionInitializationCallback（ConnectionInitializationCallback cbk）</pre><p>要使用XA数据源，请使用<code class="codeph">oracle.jdbc.replay.的<code class="codeph">unregisterConnectionInitializationCallback(ConnectionInitializationCallback cbk)</code>方法<code class="codeph">oracle.jdbc.replay.OracleXADataSource</code>接口。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-DCF5E357-C7FB-4F05-86A9-9AC6D5C4E3B7" name="GUID-DCF5E357-C7FB-4F05-86A9-9AC6D5C4E3B7"></a><h4 id="JJDBC-GUID-DCF5E357-C7FB-4F05-86A9-9AC6D5C4E3B7" class="sect4"><span class="enumeration_section">29.7.4</span>关于启用FAILOVER_RESTORE</h4>
                  <div>
                     <p></p>
                     <p><code class="codeph">FAILOVER_RESTORE</code>服务属性是在Oracle Database 12 <span class="italic">c</span>第2版（12.2.0.1）中引入的。将<code class="codeph">FAILOVER_RESTORE</code>设置为<code class="codeph">LEVEL1</code>在重放请求之前自动恢复公共初始状态。默认情况下， <code class="codeph">FAILOVER_RESTORE</code>属性的值设置为<code class="codeph">NONE</code> ，这意味着它已被禁用。
                     </p>
                     <p>从Oracle Database Release 18c开始，您还可以将此属性的值设置为<code class="codeph">AUTO</code> 。此外，如果将<code class="codeph">FAILOVER_TYPE</code>属性的值设置为<code class="codeph">AUTO</code> ，则<code class="codeph">FAILOVER_RESTORE</code>会自动设置为<code class="codeph">AUTO</code> 。只要<code class="codeph">FAILOVER_TYPE</code>设置为<code class="codeph">AUTO</code>就不能将<code class="codeph">FAILOVER_RESTORE</code>的值更改为其他任何值。当<code class="codeph">FAILOVER_RESTORE</code>设置为<code class="codeph">AUTO</code> ，也会设置公共初始状态。就会话状态恢复而言，此设置提供与<code class="codeph">FAILOVER_RESTORE</code>设置为<code class="codeph">LEVEL1</code>相同的功能。
                     </p>
                     <div class="infoboxnotealso" id="GUID-DCF5E357-C7FB-4F05-86A9-9AC6D5C4E3B7__GUID-E2079F8A-5016-42DD-A1A0-4F098C811467">
                        <p class="notep1">也可以看看：</p><a href="../racad/ensuring-application-continuity.html#RACAD-GUID-0BEE4803-7485-437C-BDF7-C6C34F92D9B0" target="_blank"><span class="italic">“Oracle®RealApplication Clusters管理和部署指南”</span></a></div>
                     <div class="infoboxnote" id="GUID-DCF5E357-C7FB-4F05-86A9-9AC6D5C4E3B7__GUID-49275D8F-2F82-4739-A00B-2760EBB793A4">
                        <p class="notep1">注意：</p>
                        <p>对于Oracle Database Release 18c中提供的Java应用程序连续性， <code class="codeph">FAILOVER_RESTORE</code>支持以下初始状态：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">NLS_CALENDAR</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">NLS_CURRENCY</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">NLS_DATE_FORMAT</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">NLS_DATE_LANGUAGE</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">NLS_DUAL_CURRENCY</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">NLS_ISO_CURRENCY</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">NLS_LANGUAGE</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">NLS_LENGTH_SEMANTICS</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">NLS_NCHAR_CONV_EXCP</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">NLS_NUMERIC_CHARACTER</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">NLS_SORT</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">NLS_TERRITORY</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">NLS_TIME_FORMAT</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">NLS_TIME_TZ_FORMAT</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">NLS_TIMESTAMP_FORMAT</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">NLS_TIMESTAMP_TZ_FORMAT</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">TIME_ZONE（OCI，ODP.NET 12201）</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">CURRENT_SCHEMA</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">MODULE</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">行动</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">CLIENT_ID</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">ECONTEXT_ID</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">ECONTEXT_SEQ</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">DB_OP</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">AUTOCOMMIT</code>状态（Java和SQL * Plus）</p>
                           </li>
                           <li>
                              <p>OCI和ODP.NET的<code class="codeph">CONTAINER</code> （PDB）和<code class="codeph">SERVICE</code></p>
                           </li>
                        </ul>
                        <p>在Oracle Database Release 19c中， <code class="codeph">FAILOVER_RESTORE</code>支持以下附加初始状态：</p>
                        <ul id="GUID-DCF5E357-C7FB-4F05-86A9-9AC6D5C4E3B7__UL_NX1_FSN_2GB" style="list-style-type:disc">
                           <li><code class="codeph">ERROR_ON_OVERLAP_TIME</code></li>
                           <li><code class="codeph">版</code></li>
                           <li><code class="codeph">SQL_TRANSLATION_PROFILE</code></li>
                           <li><code class="codeph">行归档可见性</code></li>
                           <li><code class="codeph">角色</code></li>
                           <li><code class="codeph">CLIENT_INFO</code></li>
                        </ul>
                        <div class="p">
                           <div class="infoboxnote" id="GUID-DCF5E357-C7FB-4F05-86A9-9AC6D5C4E3B7__GUID-BF9895E3-274F-429E-924A-507FAF8D5E25">
                              <p class="notep1">注意：</p>对于Oracle Database Release 19c， <code class="codeph">FAILOVER_RESTORE</code>在透明应用程序连续性（TAC）模式下自动启用。
                           </div>以下状态从自动恢复选项中排除，因为Thin驱动程序不支持它们：</div>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">NLS_COMP</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">CALL_COLLECT_TIME</code></p>
                           </li>
                        </ul>
                     </div>
                     <div class="section">
                        <p>对于许多应用程序，启用<code class="codeph">FAILOVER_RESTORE</code>足以自动恢复AC重放所需的初始状态，而无需使用回调。如果您的应用程序需要任何前面列表中未提及的初始状态，或者应用程序更喜欢显式控制设置初始状态，则应用程序必须使用回调，连接标记或初始化回调。配置回调时，它会覆盖<code class="codeph">FAILOVER_RESTORE</code>恢复的初始状态，以防后者同时启用。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="JJDBC29075"></a><div class="props_rev_3"><a id="GUID-C3E438E9-841B-46FA-9BA3-A8B8752CD2A2" name="GUID-C3E438E9-841B-46FA-9BA3-A8B8752CD2A2"></a><h3 id="JJDBC-GUID-C3E438E9-841B-46FA-9BA3-A8B8752CD2A2" class="sect3"><span class="enumeration_section">29.8</span>关于延迟Java应用程序连续性的重新连接</h3>
               <div>
                  <div class="section">
                     <p>默认情况下，当JDBC Replay Driver启动故障转移时，驱动程序会尝试在服务可用的实例上恢复正在进行的工作。为此，驱动程序必须首先重新建立与工作实例的良好连接。如果在重新定位和发布服务之前需要重新启动数据库或实例，则重新连接可能需要一些时间。因此，应该延迟故障转移，直到服务从另一个实例或数据库可用。</p>
                     <p>您必须使用<code class="codeph">FAILOVER_RETRIES</code>和<code class="codeph">FAILOVER_DELAY</code>参数来维持延迟，因为最大延迟计算为<code class="codeph">FAILOVER_RETRIES</code>乘以<code class="codeph">FAILOVER_DELAY</code> 。这些参数可以与计划中断一起很好地工作，例如，可能使服务在几分钟内不可用的中断。设置<code class="codeph">FAILOVER_DELAY</code>和<code class="codeph">FAILOVER_RETRIES</code>参数时，首先检查<code class="codeph">REPLAY_INITIAITION_TIMEOUT</code>参数的值。此参数的默认值为900秒。<code class="codeph">FAILOVER_DELAY</code>参数的高值可能导致重放被取消。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="tblformal" id="GUID-C3E438E9-841B-46FA-9BA3-A8B8752CD2A2__GUID-96EF9097-DA7F-40E2-9775-C8B52CF40F25">
                     <table cellpadding="4" cellspacing="0" class="Formal" title="" width="100%" border="1" summary="Parameters for delaying failover" frame="hsides" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="33%" id="d75547e1457">参数名称</th>
                              <th align="left" valign="bottom" width="33%" id="d75547e1460">可能的价值</th>
                              <th align="left" valign="bottom" width="33%" id="d75547e1463">默认值</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="33%" id="d75547e1468" headers="d75547e1457 ">
                                 <p><code class="codeph">FAILOVER_RETRIES</code></p>
                              </td>
                              <td align="left" valign="top" width="33%" headers="d75547e1468 d75547e1460 ">
                                 <p>正整数为零或以上</p>
                              </td>
                              <td align="left" valign="top" width="33%" headers="d75547e1468 d75547e1463 ">
                                 <p>三十</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="33%" id="d75547e1479" headers="d75547e1457 ">
                                 <p><code class="codeph">FAILOVER_DELAY</code></p>
                              </td>
                              <td align="left" valign="top" width="33%" headers="d75547e1479 d75547e1460 ">
                                 <p>时间以秒为单位</p>
                              </td>
                              <td align="left" valign="top" width="33%" headers="d75547e1479 d75547e1463 ">
                                 <p>10</p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
               </div><a id="JJDBC29076"></a><div class="props_rev_3"><a id="GUID-B9326F73-EE9F-4DA8-8E91-8725E6C52DA4" name="GUID-B9326F73-EE9F-4DA8-8E91-8725E6C52DA4"></a><h4 id="JJDBC-GUID-B9326F73-EE9F-4DA8-8E91-8725E6C52DA4" class="sect4"><span class="enumeration_section">29.8.1</span>与Java应用程序连续性相关的配置示例</h4>
                  <div>
                     <p>本节提供以下小节中的服务创建和修改的配置示例：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="application-continuity.html#GUID-E82C2E85-E0FE-4566-BA90-3928CB8E30A1">在Oracle RAC上创建服务</a></p>
                        </li>
                        <li>
                           <p><a href="application-continuity.html#GUID-9F3DF93D-714E-4468-A30A-C60E72A69D11">修改单实例数据库上的服务</a></p>
                        </li>
                     </ul>
                  </div><a id="JJDBC29078"></a><a id="JJDBC29079"></a><a id="JJDBC29077"></a><div class="props_rev_3"><a id="GUID-E82C2E85-E0FE-4566-BA90-3928CB8E30A1" name="GUID-E82C2E85-E0FE-4566-BA90-3928CB8E30A1"></a><h5 id="JJDBC-GUID-E82C2E85-E0FE-4566-BA90-3928CB8E30A1" class="sect5"><span class="enumeration_section">29.8.1.1</span>在Oracle RAC上创建服务</h5>
                     <div>
                        <p></p>
                        <div class="section">
                           <p>如果您使用的是Oracle RAC或Oracle RAC One，请使用<code class="codeph">SRVCTL</code>命令以下列方式创建和修改服务：</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section" id="GUID-E82C2E85-E0FE-4566-BA90-3928CB8E30A1__CJAHBFAD">
                           <p class="subhead3" id="GUID-E82C2E85-E0FE-4566-BA90-3928CB8E30A1__GUID-26637616-E376-43CB-A0BF-888E4965EC4A">用于透明应用程序连续性</p>
                           <p>您可以创建使用透明应用程序连续性的服务，如下所示：</p>
                           <p><span class="bold">对于策略管理的数据库：</span></p><pre class="pre codeblock"><code>$ srvctl add service -db codedb -service GOLD -serverpool ora。Srvpool -clbgoal SHORT -rlbgoal SERVICE_TIME -failover_restore AUTO -failoverretry 30 -failoverdelay 10 -commit_outcome TRUE -failovertype AUTO -replay_init_time 1800 -retention 86400 -notification TRUE</code></pre><p><span class="bold">对于管理员管理的数据库：</span></p><pre class="pre codeblock"><code>$ srvctl add service -db codedb -service GOLD -preferred serv1 -available serv2 -clbgoal SHORT -rlbgoal SERVICE_TIME -failover_restore AUTO -failoverretry 30 -failoverdelay 10 -commit_outcome TRUE -failovertype AUTO -replay_init_time 1800 -retention 86400 -notification TRUE</code></pre></div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-E82C2E85-E0FE-4566-BA90-3928CB8E30A1__GUID-9DEDBDC3-4CC8-4324-AB3B-E1701335322B">用于手动应用程序连续性</p>
                           <p>您可以创建使用手动应用程序连续性的服务，如下所示：</p>
                           <p><span class="bold">对于策略管理的数据库：</span></p><pre class="pre codeblock"><code>$ srvctl add service -db codedb -service GOLD -serverpool ora。Srvpool -clbgoal SHORT -rlbgoal SERVICE_TIME -failover_restore LEVEL1 -failoverretry 30 -failoverdelay 10 -commit_outcome TRUE -failovertype TRANSACTION -replay_init_time 1800 -retention 86400 -notification TRUE</code></pre><p><span class="bold">对于管理员管理的数据库：</span></p><pre class="pre codeblock"><code>$ srvctl add service -db codedb -service GOLD -preferred serv1 -available serv2 -clbgoal SHORT -rlbgoal SERVICE_TIME -failover_restore LEVEL1 -failoverretry 30 -failoverdelay 10 -commit_outcome TRUE -failovertype TRANSACTION -replay_init_time 1800 -retention 86400 -notification TRUE</code></pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="JJDBC29080"></a><div class="props_rev_3"><a id="GUID-9F3DF93D-714E-4468-A30A-C60E72A69D11" name="GUID-9F3DF93D-714E-4468-A30A-C60E72A69D11"></a><h5 id="JJDBC-GUID-9F3DF93D-714E-4468-A30A-C60E72A69D11" class="sect5"><span class="enumeration_section">29.8.1.2</span>在单实例数据库上修改服务</h5>
                     <div>
                        <div class="section">
                           <p>如果您使用的是单实例数据库，请使用<code class="codeph">DBMS_SERVICE</code>包以下列方式修改服务：</p><pre class="oac_no_warn" dir="ltr">declare params dbms_service.svc_parameter_array;开始参数（'FAILOVER_TYPE'）：='TRANSACTION'; PARAMS（ 'REPLAY_INITIATION_TIMEOUT'）：= 1800; PARAMS（ 'RETENTION_TIMEOUT'）：= 604800; PARAMS（ 'FAILOVER_DELAY'）：= 10; PARAMS（ 'FAILOVER_RETRIES'）：= 30; PARAMS（ 'commit_outcome'）：= '真'; PARAMS（ 'aq_ha_notifications'）：= '真'; dbms_service.modify_service（'[your service]'，params）;结束; /</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div>
            </div><a id="JJDBC29081"></a><div class="props_rev_3"><a id="GUID-E2D03C02-5710-4A1C-8C3A-33BDB38203D5" name="GUID-E2D03C02-5710-4A1C-8C3A-33BDB38203D5"></a><h3 id="JJDBC-GUID-E2D03C02-5710-4A1C-8C3A-33BDB38203D5" class="sect3"><span class="enumeration_section">29.9</span>关于在Java的应用程序连续性中保留可变值</h3>
               <div>
                  <div class="section">
                     <p>可变对象是变量，函数返回值或每次调用时返回不同值的其他结构。例如， <code class="codeph">Sequence.NextVal</code> ， <code class="codeph">SYSDATE</code> ， <code class="codeph">SYSTIMESTAMP</code>和<code class="codeph">SYS_GUID</code> 。要在重放时保留命名函数的函数结果，DBA必须向调用该函数的用户授予<code class="codeph">KEEP</code>特权。强制实施此安全限制是为了确保它对重放有效，以便为不属于该用户的代码保存和恢复功能结果。
                     </p>
                     <div class="infoboxnotealso" id="GUID-E2D03C02-5710-4A1C-8C3A-33BDB38203D5__GUID-AAA6C0D7-7A12-4EAA-89DE-7C3777291853">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="../racad/ensuring-application-continuity.html#ADFNS1203" target="_blank"><span class="italic">Oracle数据库开发指南</span></a></p>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div><a id="JJDBC29082"></a><div class="props_rev_3"><a id="GUID-62FE6103-24FE-4708-8888-1785C47D46D1" name="GUID-62FE6103-24FE-4708-8888-1785C47D46D1"></a><h4 id="JJDBC-GUID-62FE6103-24FE-4708-8888-1785C47D46D1" class="sect4"><span class="enumeration_section">29.9.1</span>授予和撤销接口</h4>
                  <div>
                     <div class="section">
                        <p>您可以通过以下方式使用标准<code class="codeph">GRANT</code>和<code class="codeph">REVOKE</code>接口来处理mutables值：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="application-continuity.html#GUID-024FC906-9130-4CB4-A74F-AA21A6F3265D">日期和SYS_GUID语法</a></p>
                           </li>
                           <li>
                              <p><a href="application-continuity.html#GUID-6BB40865-4ED8-47C8-AFBF-0A5DA0BD5D7A">序列语法</a></p>
                           </li>
                           <li>
                              <p><a href="application-continuity.html#GUID-8323B784-7C06-4D3E-B70F-19F951FF4A7B">GRANT ALL声明</a></p>
                           </li>
                           <li>
                              <p><a href="application-continuity.html#GUID-6CEC1172-1283-4A5F-9A3E-AB25DF804A9D">可变价值赠款规则</a></p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div><a id="JJDBC29083"></a><div class="props_rev_3"><a id="GUID-024FC906-9130-4CB4-A74F-AA21A6F3265D" name="GUID-024FC906-9130-4CB4-A74F-AA21A6F3265D"></a><h5 id="JJDBC-GUID-024FC906-9130-4CB4-A74F-AA21A6F3265D" class="sect5"><span class="enumeration_section">29。9。1。1</span>日期和SYS_GUID语法</h5>
                     <div>
                        <div class="section">
                           <p><code class="codeph">DATE_TIME</code>和<code class="codeph">SYS_GUID</code>语法如下：</p><pre class="oac_no_warn" dir="ltr">GRANT [保持日期时间| SYSGUID] .. [对用户} REVOKE [保持日期时间|保持SYSGUID] ... [来自USER]</pre><p>例如，对于具有原始日期的EBS标准用法</p><pre class="oac_no_warn" dir="ltr">授予保持日期时间，保持SYSGUID为[自定义用户];授予保持日期时间，保持SYSGUID到[apps user];</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="JJDBC29085"></a><a id="JJDBC29086"></a><a id="JJDBC29084"></a><div class="props_rev_3"><a id="GUID-6BB40865-4ED8-47C8-AFBF-0A5DA0BD5D7A" name="GUID-6BB40865-4ED8-47C8-AFBF-0A5DA0BD5D7A"></a><h5 id="JJDBC-GUID-6BB40865-4ED8-47C8-AFBF-0A5DA0BD5D7A" class="sect5"><span class="enumeration_section">29.9.1.2</span>序列语法</h5>
                     <div>
                        <div class="section">
                           <p>Sequence语法可以是以下类型：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><a href="application-continuity.html#GUID-6BB40865-4ED8-47C8-AFBF-0A5DA0BD5D7A__CJAIACDH">拥有的序列语法</a></p>
                              </li>
                              <li>
                                 <p><a href="application-continuity.html#GUID-6BB40865-4ED8-47C8-AFBF-0A5DA0BD5D7A__CJAFAGFC">其他序列语法</a></p>
                              </li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                        <div class="section" id="GUID-6BB40865-4ED8-47C8-AFBF-0A5DA0BD5D7A__CJAIACDH">
                           <p class="subhead3" id="GUID-6BB40865-4ED8-47C8-AFBF-0A5DA0BD5D7A__GUID-90F85C09-221B-417A-A14A-18B04267DBB1">拥有的序列语法</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section"><pre class="oac_no_warn" dir="ltr">ALTER SEQUENCE [序列对象] [KEEP | NOKEEP];</pre><p>此命令保留<code class="codeph">sequence.nextval</code>的原始值以进行重放，以便在重放后密钥匹配。大多数应用程序需要在重放时保留序列值。<code class="codeph">ALTER SYNTAX</code>仅适用于拥有的序列。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section" id="GUID-6BB40865-4ED8-47C8-AFBF-0A5DA0BD5D7A__CJAFAGFC">
                           <p class="subhead3" id="GUID-6BB40865-4ED8-47C8-AFBF-0A5DA0BD5D7A__GUID-D3CFEA49-AA95-46F3-9054-C8958B99DCEF">其他序列语法</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section"><pre class="oac_no_warn" dir="ltr">GRANT KEEP SEQUENCE .. [对象] [序列对象]; REVOKE KEEP SEQUENCE ... [来自USER] [序列对象];</pre><p>例如，对于具有原始序列值的EBS标准用法，请使用以下命令：</p><pre class="oac_no_warn" dir="ltr">在[序列对象]上为[应用程序用户]授予KEEP SEQUENCE;在[序列对象]上为[自定义用户]授予KEEP SEQUENCE;</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="JJDBC29087"></a><div class="props_rev_3"><a id="GUID-8323B784-7C06-4D3E-B70F-19F951FF4A7B" name="GUID-8323B784-7C06-4D3E-B70F-19F951FF4A7B"></a><h5 id="JJDBC-GUID-8323B784-7C06-4D3E-B70F-19F951FF4A7B" class="sect5"><span class="enumeration_section">29.9.1.3授予</span>所有声明</h5>
                     <div>
                        <div class="section">
                           <p><code class="codeph">GRANT ALL</code>语句为用户的所有对象授予<code class="codeph">KEEP</code>特权。但是，它排除了可变值，即可变值需要显式授权。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="JJDBC29088"></a><div class="props_rev_3"><a id="GUID-6CEC1172-1283-4A5F-9A3E-AB25DF804A9D" name="GUID-6CEC1172-1283-4A5F-9A3E-AB25DF804A9D"></a><h5 id="JJDBC-GUID-6CEC1172-1283-4A5F-9A3E-AB25DF804A9D" class="sect5"><span class="enumeration_section">29.9.1.4</span>可变价值补助规则</h5>
                     <div>
                        <div class="section">
                           <p>在为可变对象授予权限时遵循这些规则：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>如果用户对mutables值授予了<code class="codeph">KEEP</code>特权，则在<code class="codeph">SYS_GUID</code> ， <code class="codeph">SYSDATE</code>和<code class="codeph">SYSTIMESTAMP</code>函数时，对象将继承可变访问。
                                 </p>
                              </li>
                              <li>
                                 <p>如果撤消对序列对象上的可变值的<code class="codeph">KEEP</code>特权，则使用该对象的SQL或PL / SQL块将不允许对该序列进行可变的收集或应用。
                                 </p>
                              </li>
                              <li>
                                 <p>如果在运行时和故障转移之间撤消授予的权限，则收集的可变值不会应用于重播。</p>
                              </li>
                              <li>
                                 <p>如果在运行时和故障转移之间授予新权限，则不会收集可变值，并且这些值不会应用于重播。</p>
                              </li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div>
            </div>
            <div class="sect2"><a id="GUID-DB8762A9-A92E-4ED6-A38F-5E614B37A62E" name="GUID-DB8762A9-A92E-4ED6-A38F-5E614B37A62E"></a><h3 id="JJDBC-GUID-DB8762A9-A92E-4ED6-A38F-5E614B37A62E" class="sect3"><span class="enumeration_section">29.10</span>应用连续性统计</h3>
               <div>
                  <p></p>
                  <div class="section">
                     <p>JDBC Replay Driver支持使用Application Continuity的应用程序的以下统计信息：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>请求总数</p>
                        </li>
                        <li>
                           <p>已完成请求的总数</p>
                        </li>
                        <li>
                           <p>通话总数</p>
                        </li>
                        <li>
                           <p>受保护的呼叫总数</p>
                        </li>
                        <li>
                           <p>受中断影响的呼叫总数</p>
                        </li>
                        <li>
                           <p>触发重放的呼叫总数</p>
                        </li>
                        <li>
                           <p>重放期间受中断影响的呼叫总数</p>
                        </li>
                        <li>
                           <p>成功重播的总数</p>
                        </li>
                        <li>
                           <p>重播失败的总数</p>
                        </li>
                        <li>
                           <p>禁用重播的总数</p>
                        </li>
                        <li>
                           <p>重播尝试总次数</p>
                        </li>
                     </ul>
                     <p>所有这些指标均基于每个连接和跨连接提供。您可以使用以下方法获取这些统计信息：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">getReplayStatistics（StatisticsReportType）</code></p>
                           <p>使用<code class="codeph">oracle.jdbc.replay.ReplayableConnection.getReplayStatistics(StatisticsReportType)</code>方法获取快照统计信息。此方法的参数是在同一<code class="codeph">ReplayableConnection</code>接口中定义的枚举类型。要获得跨连接的统计信息，最好在主应用程序逻辑之后调用此方法。应用程序可以使用任何<code class="codeph">oracle.jdbc.replay.仍然打开的ReplayableConnection</code> ，或者打开与同一数据源的新连接。这适用于同时使用UCP和WLS数据源的应用程序，以及直接使用重放数据源的应用程序。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">getReplayStatistics（）</code></p>
                           <p>使用<code class="codeph">oracle.jdbc.replay.OracleDataSource.getReplayStatistics()</code>方法获取跨连接统计信息。这仅适用于直接使用重播数据源的应用程序。
                           </p>
                        </li>
                     </ul>
                     <p>两种方法都返回<code class="codeph">oracle.jdbc.replay.ReplayStatistics</code>对象，您可以从中检索单个重播指标。以下是将ReplayStatistics对象打印为String的示例输出：</p><pre class="pre codeblock"><code>AC统计：=============================================== TotalRequests = 1 TotalCompletedRequests = 1 TotalCalls = 19 TotalProtectedCalls = 19 ====================================== ========= TotalCallsAffectedByOutages = 3 TotalCallsTriggeringReplay = 3 TotalCallsAffectedByOutagesDuringReplay = 0 ================================ =============== SuccessfulReplayCount = 3 FailedReplayCount = 0 ReplayDisablingCount = 0 TotalReplayAttempts = 3 ======================= ========================</code></pre><p>如果要清除每个连接或所有连接的累积重播统计信息，则可以使用以下方法：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">oracle.jdbc.replay。ReplayableConnection.clearReplayStatistics（ReplayableConnection。StatisticsReportType reportType）</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">oracle.jdbc.replay。OracleDataSource.clearReplayStatistics（）</code></p>
                        </li>
                     </ul>
                     <div class="infoboxnote" id="GUID-DB8762A9-A92E-4ED6-A38F-5E614B37A62E__GUID-64F019B2-852D-4958-81E7-686B8089BB5E">
                        <p class="notep1">注意：</p>
                        <p>所有统计信息仅反映自最新清算以来的更新。</p>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div>
            </div><a id="JJDBC29089"></a><div class="props_rev_3"><a id="GUID-81A928A7-3C69-4308-9DD8-D6A6E3A13A3A" name="GUID-81A928A7-3C69-4308-9DD8-D6A6E3A13A3A"></a><h3 id="JJDBC-GUID-81A928A7-3C69-4308-9DD8-D6A6E3A13A3A" class="sect3"><span class="enumeration_section">29.11</span>关于在Java应用程序连续性中禁用重播</h3>
               <div>
                  <div class="section">
                     <p>本节介绍以下概念：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="application-continuity.html#GUID-C4A95E4D-E947-4A37-8AA2-B75EDF28941E">如何禁用重播</a></p>
                        </li>
                        <li>
                           <p><a href="application-continuity.html#GUID-5308BBEA-0923-4FC3-8A3B-8A52344B8858">何时禁用重播</a></p>
                        </li>
                        <li>
                           <p><a href="application-continuity.html#GUID-C1EFA4DD-E22E-4F56-BEC3-3F8C967C0345">诊断和跟踪</a></p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
               </div><a id="JJDBC29090"></a><div class="props_rev_3"><a id="GUID-C4A95E4D-E947-4A37-8AA2-B75EDF28941E" name="GUID-C4A95E4D-E947-4A37-8AA2-B75EDF28941E"></a><h4 id="JJDBC-GUID-C4A95E4D-E947-4A37-8AA2-B75EDF28941E" class="sect4"><span class="enumeration_section">29.11.1</span>如何禁用重播</h4>
                  <div>
                     <div class="section">
                        <p>如果任何应用程序模块使用的设计不适合重放，则禁用重放API会根据每个请求禁用重播。可以使用<code class="codeph">oracle.jdbc.replay.的<code class="codeph">disableReplay</code>方法将禁用重播添加到回调或主代码中<code class="codeph">oracle.jdbc.replay.ReplayableConnection</code>接口。例如：</p><pre class="oac_no_warn" dir="ltr">if（连接instanceof oracle.jdbc.replay。ReplayableConnection）{（（oracle.jdbc.replay。ReplayableConnection）连接）.disableReplay（）; }</pre><p>禁用重播不会通过重新执行任何JDBC方法，SQL或PL / SQL来更改连接状态。使用禁用重播API禁用重播时，将禁用录制和重播，直到该请求结束。没有API可以重新启用重播，因为重播请求中的时间间隔重新建立数据库会话无效。这样可确保<span class="italic">仅</span>在记录了所需呼叫的完整历史记录时<span class="italic">才会</span>运行重播。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JJDBC29091"></a><div class="props_rev_3"><a id="GUID-5308BBEA-0923-4FC3-8A3B-8A52344B8858" name="GUID-5308BBEA-0923-4FC3-8A3B-8A52344B8858"></a><h4 id="JJDBC-GUID-5308BBEA-0923-4FC3-8A3B-8A52344B8858" class="sect4"><span class="enumeration_section">29.11.2</span>何时禁用重播</h4>
                  <div>
                     <div class="section">
                        <p>默认情况下，JDBC重播驱动程序会在发生可恢复的错误后重放。禁用重播API可用于无法丢失数据库会话和恢复的应用程序模块的入口点。例如，如果应用程序使用<code class="codeph">UTL_SMTP</code>包并且不希望重复消息，则<code class="codeph">disableReplay</code> API仅影响需要禁用的请求。所有其他请求继续被重播。
                        </p>
                        <p>以下是配置重播应用程序之前要考虑的方案：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="application-continuity.html#GUID-9742FDBE-614A-4076-B445-4DFAAB84808F">应用程序调用不应重复的外部PL / SQL操作</a></p>
                           </li>
                           <li>
                              <p><a href="application-continuity.html#GUID-500F4904-AE1C-4441-AE7A-1AE223FB4D8E">应用程序同步独立会话</a></p>
                           </li>
                           <li>
                              <p><a href="application-continuity.html#GUID-E24678B6-3512-474C-A73E-20A49B769122">应用程序在执行逻辑中使用中间层的时间</a></p>
                           </li>
                           <li>
                              <p><a href="application-continuity.html#GUID-D0984661-C7B9-491C-A211-C0978B7BDA6B">应用程序假定ROWIds不会更改</a></p>
                           </li>
                           <li>
                              <p><a href="application-continuity.html#GUID-C5E5A8E3-A389-4514-AE62-32DA6A4475A2">应用程序假设副作用执行一次</a></p>
                           </li>
                           <li>
                              <p><a href="application-continuity.html#GUID-7F27816A-DB34-45BD-8153-584DEF17BAEC">应用程序假定位置值不会更改</a></p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div><a id="JJDBC29137"></a><div class="props_rev_3"><a id="GUID-9742FDBE-614A-4076-B445-4DFAAB84808F" name="GUID-9742FDBE-614A-4076-B445-4DFAAB84808F"></a><h5 id="JJDBC-GUID-9742FDBE-614A-4076-B445-4DFAAB84808F" class="sect5"><span class="enumeration_section">29.11.2.1</span>应用程序调用不应重复的外部系统</h5>
                     <div>
                        <div class="section">
                           <p>在重放期间，自治事务和外部系统（如PL / SQL调用或Java调用）可能具有与主事务分离的副作用。除非您另行指定并留下持久性结果，否则将重播这些副作用。这些副作用包括写入外部表，发送电子邮件，从PL / SQL或Java分支会话，传输文件，访问外部URL等。例如，在PL / SQL消息传递的情况下，假设您在没有提交和会话超时的情况下在一些工作之间走开。现在，如果发出<code class="codeph">Ctrl+C</code>命令，则组件的前景会失败。当您重新提交作品时，也可以重复此副作用。
                           </p>
                           <div class="infoboxnotealso" id="GUID-9742FDBE-614A-4076-B445-4DFAAB84808F__GUID-3373F57B-88EF-4D5B-9B71-8FF92382A90C">
                              <p class="notep1">也可以看看：</p>有关应用程序连续性潜在副作用的详细信息，请参阅<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/jjdbc&amp;id=RACAD-GUID-A250F3F8-D681-4F44-8969-7A8434E065DD" target="_blank"><span><cite>“Oracle Real Application Clusters管理和部署指南”</cite></span></a></div>
                           <p>您必须有意识地决定是否为外部操作启用重播。例如，您可以考虑以下情况：此决策很重要：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>使用<code class="codeph">UTL_HTTP</code>包发出SOA调用</p>
                              </li>
                              <li>
                                 <p>使用<code class="codeph">UTL_SMTP</code>包发送消息</p>
                              </li>
                              <li>
                                 <p>使用<code class="codeph">UTL_URL</code>包访问网站</p>
                              </li>
                           </ul>
                           <p>如果您不希望重播此类外部操作，请使用<code class="codeph">disableReplay</code> API。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="JJDBC29092"></a><div class="props_rev_3"><a id="GUID-500F4904-AE1C-4441-AE7A-1AE223FB4D8E" name="GUID-500F4904-AE1C-4441-AE7A-1AE223FB4D8E"></a><h5 id="JJDBC-GUID-500F4904-AE1C-4441-AE7A-1AE223FB4D8E" class="sect5"><span class="enumeration_section">29.11.2.2</span>应用程序同步独立会话</h5>
                     <div>
                        <div class="section">
                           <p>如果应用程序使用在提交，回滚或会话丢失之前保留的易失实体同步独立会话，则可以配置应用程序以进行重播。在这种情况下，应用程序使用诸如数据库锁之类的资源来同步连接到多个数据源的多个会话，否则这些数据源是相互依赖的。如果应用程序仅序列化这些会话并且了解任何会话可能会失败，则此同步可能没问题。但是，如果应用程序假定一个数据源持有的锁或任何其他易失性资源意味着对来自其他连接的相同或单独数据源的数据进行独占访问，则在重放时该假设可能无效。</p>
                           <p>在重放期间，驱动程序不知道会话依赖于持有锁或其他易失性资源的一个会话。您还可以使用管道，缓冲队列，获取资源（例如信号量，设备或套接字）的存储过程来实现由故障丢失的同步。</p>
                           <div class="infoboxnote" id="GUID-500F4904-AE1C-4441-AE7A-1AE223FB4D8E__GUID-146B14D5-299D-4529-B5D2-4D796D57BBE7">
                              <p class="notep1">注意：</p>
                              <p><code class="codeph">DBMS_LOCK</code>不会在受限制的版本中重播。
                              </p>
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="JJDBC29093"></a><div class="props_rev_3"><a id="GUID-E24678B6-3512-474C-A73E-20A49B769122" name="GUID-E24678B6-3512-474C-A73E-20A49B769122"></a><h5 id="JJDBC-GUID-E24678B6-3512-474C-A73E-20A49B769122" class="sect5"><span class="enumeration_section">29.11.2.3</span>应用程序在执行逻辑中的中间层使用时间</h5>
                     <div>
                        <div class="section">
                           <p>在这种情况下，应用程序使用中间层的挂钟作为执行逻辑的一部分。JDBC重放驱动程序不重复中间层时间逻辑，而是使用作为此逻辑的一部分执行的数据库调用。例如，使用中间层时间的应用程序可以假定在时间T1执行的语句不会在时间T2重新执行，除非应用程序明确地这样做。</p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="JJDBC29094"></a><div class="props_rev_3"><a id="GUID-D0984661-C7B9-491C-A211-C0978B7BDA6B" name="GUID-D0984661-C7B9-491C-A211-C0978B7BDA6B"></a><h5 id="JJDBC-GUID-D0984661-C7B9-491C-A211-C0978B7BDA6B" class="sect5"><span class="enumeration_section">29.11.2.4</span>应用程序假定ROWIds不会改变</h5>
                     <div>
                        <div class="section">
                           <p>如果应用程序缓存ROWID，则由于数据库更改，对这些ROWID的访问可能会失效。虽然ROWID唯一标识表中的行，但ROWID可能会在以下情况下更改其值：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>基础表重组</p>
                              </li>
                              <li>
                                 <p>在表上创建索引</p>
                              </li>
                              <li>
                                 <p>基础表是分区的</p>
                              </li>
                              <li>
                                 <p>迁移基础表</p>
                              </li>
                              <li>
                                 <p>使用EXP / IMP / DUL导出和导入基础表</p>
                              </li>
                              <li>
                                 <p>使用Golden Gate或Logical Standby或其他复制技术重建基础表</p>
                              </li>
                              <li>
                                 <p>闪回或恢复基础表的数据库</p>
                              </li>
                           </ul>
                           <p>应用程序存储ROWID供以后使用是不好的做法，因为相应的行可能不存在或包含完全不同的数据。</p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="JJDBC29095"></a><div class="props_rev_3"><a id="GUID-C5E5A8E3-A389-4514-AE62-32DA6A4475A2" name="GUID-C5E5A8E3-A389-4514-AE62-32DA6A4475A2"></a><h5 id="JJDBC-GUID-C5E5A8E3-A389-4514-AE62-32DA6A4475A2" class="sect5"><span class="enumeration_section">29.11.2.5</span>应用程序假定副作用执行一次</h5>
                     <div>
                        <div class="section">
                           <p>在这种情况下，在重播期间重播以下内容：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>自主交易</p>
                              </li>
                              <li>
                                 <p>打开后退通道与主要交易副作用分开</p>
                              </li>
                           </ul>
                           <p>与主事务分离的反向通道示例包括写入外部表，发送电子邮件，从PL / SQL或Java分支会话，写入输出文件，传输文件和编写异常文件。任何这些行为都会在没有重播的情况下产生持续的副作用。反向渠道可以留下持久的结果。例如，如果用户在没有提交的情况下中途离开事务并且会话超时，则用户按下Ctrl + C，前台或任何组件都会失败。如果用户重新提交工作，则可以重复副作用。</p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="JJDBC29120"></a><a id="JJDBC29096"></a><div class="props_rev_3"><a id="GUID-7F27816A-DB34-45BD-8153-584DEF17BAEC" name="GUID-7F27816A-DB34-45BD-8153-584DEF17BAEC"></a><h5 id="JJDBC-GUID-7F27816A-DB34-45BD-8153-584DEF17BAEC" class="sect5"><span class="enumeration_section">29.11.2.6</span>应用程序假定位置值<span class="enumeration_section">不变</span></h5>
                     <div>
                        <div class="section">
                           <p><code class="codeph">SYSCONTEXT</code>选项包括与位置无关的集，例如国家语言支持（NLS）设置， <code class="codeph">ISDBA</code> ， <code class="codeph">CLIENT_IDENTIFIER</code> ， <code class="codeph">MODULE</code>和<code class="codeph">ACTION</code> ，以及使用物理定位器的位置相关集。通常，除测试环境外，应用程序不使用物理标识符。如果在主线代码中使用物理定位器，则重放会找到不匹配并拒绝它。但是，在回调中使用物理定位器是很好的。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-7F27816A-DB34-45BD-8153-584DEF17BAEC__GUID-1DCCB177-D54D-41D0-9639-DA2E99F44A13">例</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section"><pre class="oac_no_warn" dir="ltr">select sys_context（'USERENV'，'DB_NAME'），sys_context（'USERENV'，'HOST'），sys_context（'USERENV'，'INSTANCE'），sys_context（'USERENV'，'IP_ADDRESS'），sys_context（'USERENV'来自双重的'ISDBA'），sys_context（'USERENV'，'SESSIONID'），sys_context（'USERENV'，'TERMINAL'），sys_context（'USERENV'，ID'）</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="JJDBC29098"></a><div class="props_rev_3"><a id="GUID-C1EFA4DD-E22E-4F56-BEC3-3F8C967C0345" name="GUID-C1EFA4DD-E22E-4F56-BEC3-3F8C967C0345"></a><h4 id="JJDBC-GUID-C1EFA4DD-E22E-4F56-BEC3-3F8C967C0345" class="sect4"><span class="enumeration_section">29.11.3</span>诊断和跟踪</h4>
                  <div>
                     <div class="section">
                        <p>JDBC Replay驱动程序支持标准JDK日志记录。使用Java命令行<code class="codeph">-Djava.util.logging.config.file=&lt;file&gt;</code>选项启用日志记录。日志级别由日志配置文件中的<code class="codeph">oracle.jdbc.internal.replay.level</code>属性控制。例如：</p><pre class="oac_no_warn" dir="ltr">oracle.jdbc.internal.replay.level = FINER | FINEST</pre><p>其中， <code class="codeph">FINER</code>生成外部API， <code class="codeph">FINEST</code>生成大量的跟踪。您必须仅在监督下使用<code class="codeph">FINEST</code> 。
                        </p>
                        <p>如果使用<code class="codeph">java.util.logging.XMLFormatter</code>类用于格式化日志记录，然后日志更具可读性但更大。如果在UCP或WebLogic Server上使用FAN启用重播，则还应启用FAN处理日志记录。
                        </p>
                        <div class="infoboxnotealso" id="GUID-C1EFA4DD-E22E-4F56-BEC3-3F8C967C0345__GUID-BB068E6D-9D12-4531-BCDA-2C52BACB6F84">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="../jjucp/logging-in-ucp.html#JJUCP8233" target="_blank"><span class="italic">JDBC开发人员指南的Oracle通用连接池</span></a></p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div><a id="JJDBC29099"></a><div class="props_rev_3"><a id="GUID-58C00F4B-5FA1-4FF8-A710-AA7E01A9ECFC" name="GUID-58C00F4B-5FA1-4FF8-A710-AA7E01A9ECFC"></a><h5 id="JJDBC-GUID-58C00F4B-5FA1-4FF8-A710-AA7E01A9ECFC" class="sect5"><span class="enumeration_section">29.11.3.1</span>将重播跟踪写入控制台</h5>
                     <div>
                        <div class="section">
                           <p>以下是用于记录配置的配置文件的示例。</p><pre class="oac_no_warn" dir="ltr">oracle.jdbc.internal.replay.level = FINER handlers = java.util.logging。ConsoleHandler java.util.logging。ConsoleHandler.level =所有java.util.logging。ConsoleHandler.formatter = java.util.logging。XMLFormatter</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="JJDBC29100"></a><div class="props_rev_3"><a id="GUID-2CD82D18-718A-42F2-B237-97E4965E9707" name="GUID-2CD82D18-718A-42F2-B237-97E4965E9707"></a><h5 id="JJDBC-GUID-2CD82D18-718A-42F2-B237-97E4965E9707" class="sect5"><span class="enumeration_section">29.11.3.2</span>将重播跟踪写入文件</h5>
                     <div>
                        <div class="section">
                           <p>以下是用于记录配置的<code class="codeph">properties</code>文件的示例。
                           </p><pre class="oac_no_warn" dir="ltr">oracle.jdbc.internal.replay.level = FINEST</pre><pre class="oac_no_warn" dir="ltr">＃输出文件格式（大小，数量和样式）#count：循环输出的输出文件数，通过在基本文件名中附加一个整数：#limit：以字节为单位限制输出文件的大小handlers = java.util.logging。FileHandler java.util.logging。FileHandler.pattern = [文件位置] /replay_%U.trc java.util.logging。FileHandler.limit = 500000000 java.util.logging。FileHandler.count = 1000 java.util.logging。FileHandler.formatter = java.util.logging。XMLFormatter</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div>
            </div>
            <hr><br><p style="text-decoration:underline">脚注图例</p>脚注1：<p>“登录风暴是客户端连接请求数量的突然增加。”</p><br></div>
      </article>
   </body>
</html>