<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <title>调整数据库缓冲区高速缓存</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Database Performance Tuning Guide"></meta>
      <meta property="og:description" content=""></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Database Performance Tuning Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="database-performance-tuning-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-03-12T22:26:14-07:00"></meta>
      <meta name="dcterms.title" content="Database Performance Tuning Guide"></meta>
      <meta name="dcterms.dateCopyrighted" content="2007, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96347-03"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="tuning-system-global-area.html" title="Previous" type="text/html"></link>
      <link rel="next" href="tuning-shared-pool-and-large-pool.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.isVersionOf" content="TGDBA"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="tuning-system-global-area.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="tuning-shared-pool-and-large-pool.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">数据库性能调优指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="part-III-tuning-database-memory.html" property="item" typeof="WebPage"><span property="name">调整数据库内存</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">调整数据库缓冲区高速缓存</li>
            </ol>
            <a id="GUID-F2D11BC8-986F-4A8B-A37F-530BE9EB2DA8" name="GUID-F2D11BC8-986F-4A8B-A37F-530BE9EB2DA8"></a><a id="TGDBA294"></a>
            
            <h2 id="TGDBA-GUID-F2D11BC8-986F-4A8B-A37F-530BE9EB2DA8" class="sect2"><span class="enumeration_chapter">13</span>调整数据库缓冲区高速缓存</h2>
         </header>
         <div class="ind">
            <div>
               <p>本章介绍如何调整数据库缓冲区缓存。如果使用自动内存管理来管理系统上的数据库内存，则无需手动调整本章中介绍的内存缓存。</p>
               <p>本章包含以下主题：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="tuning-database-buffer-cache.html#GUID-E5111374-CBFD-481E-B201-A54C1FFC3FC0">关于数据库缓冲区缓存</a></p>
                  </li>
                  <li>
                     <p><a href="tuning-database-buffer-cache.html#GUID-76C5DB98-5140-469E-B23D-777EAA8564C1">配置数据库缓冲区缓存</a></p>
                  </li>
                  <li>
                     <p><a href="tuning-database-buffer-cache.html#GUID-31549A91-EF90-4FD5-AC5E-3F80FD3AE175">配置多个缓冲池</a></p>
                  </li>
                  <li>
                     <p><a href="tuning-database-buffer-cache.html#GUID-1724C3C8-190E-4DBA-90FC-12B1B40158B1">配置重做日志缓冲区</a></p>
                  </li>
                  <li>
                     <p><a href="tuning-database-buffer-cache.html#GUID-37246D78-7499-491B-B891-D625628677E7">配置数据库缓存模式</a></p>
                  </li>
               </ul>
            </div><a id="TGDBA295"></a><div class="props_rev_3"><a id="GUID-E5111374-CBFD-481E-B201-A54C1FFC3FC0" name="GUID-E5111374-CBFD-481E-B201-A54C1FFC3FC0"></a><h3 id="TGDBA-GUID-E5111374-CBFD-481E-B201-A54C1FFC3FC0" class="sect3"><span class="enumeration_section">13.1</span>关于数据库缓冲区高速缓存</h3>
               <div>
                  <p>对于许多类型的操作，Oracle数据库使用缓冲区高速缓存来存储从磁盘读取的数据块。Oracle数据库绕过特定操作的缓冲区高速缓存，例如排序和并行读取。</p>
                  <p>要有效地使用数据库缓冲区缓存，请调整应用程序的SQL语句，以避免不必要的资源消耗。要实现此目标，请验证经常执行的SQL语句和执行许多缓冲区获取的SQL语句是否经过良好调整。</p>
                  <p>使用并行查询时，请考虑将数据库配置为使用数据库缓冲区高速缓存，而不是直接读入程序全局区域（PGA）。当系统具有大量内存时，此配置可能是适当的。</p>
                  <div class="infoboxnotealso" id="GUID-E5111374-CBFD-481E-B201-A54C1FFC3FC0__GUID-02F21174-E00E-4924-9F53-018DB19A6FF7">
                     <p class="notep1">也可以看看：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>有关调优SQL语句的信息，请<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/tgdba&amp;id=TGSQL-GUID-B653E5F3-F078-4BBC-9516-B892960046A2" target="_blank"><span class="italic">参见“Oracle数据库SQL调优指南”</span></a></p>
                        </li>
                        <li>
                           <p>有关并行执行的信息<a href="../vldbg/using-parallel.html#VLDBG010" target="_blank"><span class="italic">，请参见“Oracle数据库VLDB和分区指南”</span></a></p>
                        </li>
                     </ul>
                  </div>
               </div>
            </div><a id="TGDBA310"></a><div class="props_rev_3"><a id="GUID-76C5DB98-5140-469E-B23D-777EAA8564C1" name="GUID-76C5DB98-5140-469E-B23D-777EAA8564C1"></a><h3 id="TGDBA-GUID-76C5DB98-5140-469E-B23D-777EAA8564C1" class="sect3"><span class="enumeration_section">13.2</span>配置数据库缓冲区高速缓存</h3>
               <div>
                  <p>配置新数据库实例时，无法知道缓冲区高速缓存的正确大小。通常，数据库管理员首先估计缓存大小，然后在实例上运行代表性工作负载并检查相关统计信息以查看缓存是否配置不足或配置过多。</p>
                  <p>本节介绍如何配置数据库缓冲区缓存。如果使用自动共享内存管理来配置共享全局区域（SGA），则无需手动调整数据库缓冲区高速缓存，如本节所述。</p>
                  <p>本节包含以下主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="tuning-database-buffer-cache.html#GUID-83733109-5119-4DDB-8A81-5302CE956BE2">使用V $ DB_CACHE_ADVICE视图</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-database-buffer-cache.html#GUID-186EEE2D-11A1-401A-B9B2-E72325F972BC">计算缓冲区高速缓存命中率</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-database-buffer-cache.html#GUID-E4018F9E-5A4B-41D0-8BCA-16191FC783BE">解释缓冲区高速缓存命中率</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-database-buffer-cache.html#GUID-874BE709-8385-43AE-B3AB-BB3F6A0D1971">增加分配给数据库缓冲区高速缓存的内存</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-database-buffer-cache.html#GUID-74EF352E-2C42-4C39-9F82-00BC7DC616AD">减少分配给数据库缓冲区高速缓存的内存</a></p>
                     </li>
                  </ul>
               </div><a id="TGDBA531"></a><a id="TGDBA532"></a><a id="TGDBA530"></a><div class="props_rev_3"><a id="GUID-83733109-5119-4DDB-8A81-5302CE956BE2" name="GUID-83733109-5119-4DDB-8A81-5302CE956BE2"></a><h4 id="TGDBA-GUID-83733109-5119-4DDB-8A81-5302CE956BE2" class="sect4"><span class="enumeration_section">13.2.1</span>使用V $ DB_CACHE_ADVICE视图</h4>
                  <div>
                     <p>该<a id="d39363e282" class="indexterm-anchor"></a> <code class="codeph">V$DB_CACHE_ADVICE</code>视图显示了一系列潜在缓冲区高速缓存大小的模拟未命中率。此视图通过提供预测每个潜在高速缓存大小的物理读取数的信息来协助高速缓存大小调整。数据还包括物理读取因子，如果将缓冲区高速缓存调整为给定值，则估计当前物理读取数量的变化因子。
                     </p>
                     <p>但是，物理读取不一定表示Oracle数据库中的磁盘读取，因为可以通过从文件系统缓存读取来完成物理读取。因此，成功找到高速缓存中的块与高速缓存的大小之间的关系并不总是平滑分布。调整缓冲池大小时，请避免使用对缓存命中率没有贡献（或贡献很小）的其他缓冲区。</p>
                     <p>下图说明了物理I / O比和缓冲区高速缓存大小之间的关系。</p>
                     <div class="figure" id="GUID-83733109-5119-4DDB-8A81-5302CE956BE2__CHDBJBFI">
                        <p class="titleinfigure">图13-1物理I / O比和缓冲区高速缓存大小</p><img src="img/figure_131_physical_io_ratio_and_buffer_cache_size.png" alt="下面是图13-1的描述" title="下面是图13-1的描述" longdesc="img_text/figure_131_physical_io_ratio_and_buffer_cache_size.html"><br><a href="img_text/figure_131_physical_io_ratio_and_buffer_cache_size.html">“图13-1物理I / O比和缓冲区高速缓存大小”的说明</a></div>
                     <!-- class="figure" -->
                     <p>检查上图所示的示例可得出以下结论：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>随着缓冲区数量的增加，物理I / O比率降低。</p>
                        </li>
                        <li>
                           <p>点A和B以及点B和C之间的物理I / O的减小不是平滑的，如图中的虚线所示。</p>
                        </li>
                        <li>
                           <p>从A点到B点增加缓冲区的好处远远高于从B点到C点。</p>
                        </li>
                        <li>
                           <p>增加缓冲区的好处随着缓冲区数量的增加而减少。</p>
                        </li>
                     </ul>
                     <p>使用此顾问视图会产生一些开销。启用该通报后，CPU使用率会略有增加，因为需要额外的簿记。为了减少与簿记相关的CPU和内存开销，Oracle数据库使用抽样来收集缓存顾问统计信息。如果缓冲池中的缓冲区数量很少，则不使用采样。</p>
                     <div class="section">
                        <p class="subhead3" id="GUID-83733109-5119-4DDB-8A81-5302CE956BE2__GUID-AA328675-2F39-4F47-8605-C050C10EA88D">要使用V $ DB_CACHE_ADVICE视图：</p>
                        <ol>
                           <li>
                              <p>将<code class="codeph">DB_CACHE_ADVICE</code>初始化参数的值设置为<code class="codeph">ON</code> 。</p>
                              <p>这样可以启用咨询视图。<code class="codeph">DB_CACHE_ADVICE</code>参数是动态的，因此可以动态启用和禁用通报，以便您可以收集特定工作负载的咨询数据。
                              </p>
                           </li>
                           <li>
                              <p>在数据库实例上运行代表性工作负载。</p>
                              <p>在查询<code class="codeph">V$DB_CACHE_ADVICE</code>视图之前，允许工作负载稳定。
                              </p>
                           </li>
                           <li>
                              <p>查询<code class="codeph">V$DB_CACHE_ADVICE</code>视图。
                              </p>
                           </li>
                        </ol>
                        <p>以下示例显示了此视图的查询，该查询返回各种高速缓存大小的默认缓冲池的预测I / O要求。</p><pre class="oac_no_warn" dir="ltr">COLUMN size_for_estimate格式999,999,999,999标题'缓存大小（MB）'COLUMN buffers_for_estimate格式999,999,999标题'缓冲区'COLUMN estd_physical_read_factor格式999.90标题'Estd Phys |读取因子'COLUMN estd_physical_reads格式999,999,999标题'Estd Phys |读取'SELECT size_for_estimate，buffers_for_estimate，estd_physical_read_factor，estd_physical_reads FROM V $ DB_CACHE_ADVICE WHERE name ='DEFAULT'AND block_size =（SELECT value FROM V $ PARAMETER WHERE name ='db_block_size'）AND advice_status ='ON';</pre><p>此查询的输出可能如下所示：</p><pre class="oac_no_warn" dir="ltr">Estd Phys Estd物理缓存大小（MB）缓冲区读取因子读取---------------- ------------ --------- -  ------------ 30 3,802 18.70 192,317,943 10％当前尺寸60 7,604 12.83 131,949,536 91 11,406 7.38 75,865,861 121 15,208 4.97 51,111,658 152 19,010 3.64 37,460,786 182 22,812 2.50 25,668,196 212 26,614 1.74 17,850,847 243 30,416 1.33 13,720,149 273 34,218 1.13 11,583,180 304 38,020 1.00 10,282,475当前尺寸334 41,822 .93 9,515,878 364 45,624 .87 8,909,026 395 49,426 .83 8,495,039 424 53,228 .79 8,116,496 456 57,030 .76 7,824,764 486 60,832 .74 7,563,180 517 64,634 .71 7,311,729 547 68,436 .69 7,104,280 577 72,238 .67 6,895,122 608 76,040 .66 6,739,731当前尺寸的200％</pre><p>在此示例中，输出显示如果缓存为212 MB而不是当前大小为304 MB，则估计的物理读取次数将增加1.74或74％。因此，不建议将缓存大小减小到212MB。</p>
                        <p>但是，将缓存大小增加到334MB可能会使读取率降低0.93或7％。如果系统上有额外的30MB内存，并且<code class="codeph">SGA_MAX_SIZE</code>参数的值允许增量，则建议将默认缓冲区缓存池大小增加到334MB。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="TGDBA534"></a><a id="TGDBA535"></a><a id="TGDBA533"></a><div class="props_rev_3"><a id="GUID-186EEE2D-11A1-401A-B9B2-E72325F972BC" name="GUID-186EEE2D-11A1-401A-B9B2-E72325F972BC"></a><h4 id="TGDBA-GUID-186EEE2D-11A1-401A-B9B2-E72325F972BC" class="sect4"><span class="enumeration_section">13.2.2</span>计算缓冲区高速缓存命中率</h4>
                  <div>
                     <div class="section">
                        <p>缓冲区高速缓存命中率计算在缓冲区高速缓存中找到请求块的频率，而不需要磁盘访问。使用从<code class="codeph">V$SYSSTAT</code>选择的数据计算该比率<a id="d39363e416" class="indexterm-anchor"></a>绩效观。使用缓冲区高速缓存命中率来验证<code class="codeph">V$DB_CACHE_ADVICE</code>视图预测的物理I / O.
                        </p>
                        <p><a href="tuning-database-buffer-cache.html#GUID-186EEE2D-11A1-401A-B9B2-E72325F972BC__CHDECFBD" title="此表列出了用于计算缓冲区高速缓存命中率的统计信息。">表13-1</a>列出了用于计算缓冲区高速缓存命中率的<code class="codeph">V$SYSSTAT</code>视图的统计<code class="codeph">V$SYSSTAT</code> 。
                        </p>
                        <div class="tblformal" id="GUID-186EEE2D-11A1-401A-B9B2-E72325F972BC__CHDECFBD">
                           <p class="titleintable">表13-1计算缓冲区高速缓存命中率的统计信息</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="计算缓冲区高速缓存命中率的统计信息" width="100%" border="1" summary="This table lists statistics that are used to calculate the buffer cache hit ratio." frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="31%" id="d39363e443">统计</th>
                                    <th align="left" valign="bottom" width="69%" id="d39363e446">描述</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d39363e451" headers="d39363e443 ">
                                       <p><code class="codeph">从缓存中获取一致性</code><a id="d39363e455" class="indexterm-anchor"></a><a id="d39363e457" class="indexterm-anchor"></a></p>
                                    </td>
                                    <td align="left" valign="top" width="69%" headers="d39363e451 d39363e446 ">
                                       <p>从缓冲区高速缓存请求块的一致读取的次数。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d39363e465" headers="d39363e443 ">
                                       <p><code class="codeph">db块从缓存中获取</code><a id="d39363e469" class="indexterm-anchor"></a><a id="d39363e473" class="indexterm-anchor"></a></p>
                                    </td>
                                    <td align="left" valign="top" width="69%" headers="d39363e465 d39363e446 ">
                                       <p>从缓冲区高速缓存请求<code class="codeph">CURRENT</code>块的次数。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d39363e482" headers="d39363e443 ">
                                       <p><code class="codeph">物理读取缓存</code><a id="d39363e486" class="indexterm-anchor"></a><a id="d39363e488" class="indexterm-anchor"></a></p>
                                    </td>
                                    <td align="left" valign="top" width="69%" headers="d39363e482 d39363e446 ">
                                       <p>从磁盘读入缓冲区高速缓存的数据块总数。</p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <p><a href="tuning-database-buffer-cache.html#GUID-186EEE2D-11A1-401A-B9B2-E72325F972BC__CHDJJCIA">例13-1</a>显示了该视图的查询。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-186EEE2D-11A1-401A-B9B2-E72325F972BC__CHDJJCIA">
                        <p class="titleinexample">示例13-1查询V $ SYSSTAT视图</p><pre class="oac_no_warn" dir="ltr">SELECT名称，值FROM V $ SYSSTAT WHERE名称IN（'db block from cache'，'consistent gets from cache'，'physical read cache'）;</pre><p>在此示例中，通过使用直接从<code class="codeph">V$SYSSTAT</code>视图中选择的值而不是间隔来简化查询。建议在应用程序运行时计算一段时间内这些统计信息的增量，然后使用这些增量值来确定缓冲区高速缓存命中率。有关在一定时间间隔内收集统计信息的信息，请参阅<a href="automatic-performance-diagnostics.html#GUID-843A596D-2D8B-422D-9C8D-73C0EF52739D" title="从Oracle Database 12c开始，默认情况下在多租户容器数据库（CDB）的根容器中启用ADDM。从Oracle Database 19c开始，您还可以在可插拔数据库（PDB）中使用ADDM。默认情况下，ADDM在可插拔数据库（PDB）中不起作用，因为默认情况下在PDB中禁用自动AWR快照。要在PDB中使用ADDM，必须通过将AWR_PDB_AUTOFLUSH_ENABLED初始化参数设置为TRUE且AWR快照间隔大于0来在PDB中启用自动AWR快照。">自动性能诊断</a> 。
                        </p>
                        <p>使用此查询输出中的值， <a id="d39363e523" class="indexterm-anchor"></a>使用以下公式计算缓冲区缓存的命中率：</p><pre class="oac_no_warn" dir="ltr">1  - （（'物理读取缓存'）/（'从缓存中获取'一致'+'db块从缓存中获取'））</pre><div class="infoboxnotealso" id="GUID-186EEE2D-11A1-401A-B9B2-E72325F972BC__GUID-E04E7AE6-1E99-4AFB-B0D8-174402ADCE84">
                           <p class="notep1">也可以看看：</p>
                           <p>有关<code class="codeph">V$SYSSTAT</code>视图的信息，请<a href="../refrn/V-SYSSTAT.html#REFRN-GUID-250136E5-E07E-4A78-9F67-28C0D3C6E922" target="_blank"><span class="italic">参见Oracle数据库参考</span></a></p>
                        </div>
                     </div>
                     <!-- class="example" -->
                  </div>
               </div><a id="TGDBA536"></a><div class="props_rev_3"><a id="GUID-E4018F9E-5A4B-41D0-8BCA-16191FC783BE" name="GUID-E4018F9E-5A4B-41D0-8BCA-16191FC783BE"></a><h4 id="TGDBA-GUID-E4018F9E-5A4B-41D0-8BCA-16191FC783BE" class="sect4"><span class="enumeration_section">13.2.3</span>解释缓冲区高速缓存命中率</h4>
                  <div>
                     <p>在决定是否增加或减少缓冲区高速缓存大小之前，应首先检查缓冲区高速缓存命中率。</p>
                     <p>低缓存命中率并不一定意味着增加缓冲区缓存的大小将有利于性能。此外，高缓存命中率可能错误地指示缓冲区缓存的大小适合工作负载。</p>
                     <p>要解释缓冲区缓存命中率，请考虑以下因素：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>通过一次执行处理或优化SQL语句，避免重复扫描频繁访问的数据。</p>
                           <p>重复扫描相同的大型表或索引可以人为地夸大低缓存命中率。检查经常执行的具有大量缓冲区获取的SQL语句，以确保这些SQL语句的执行计划是最佳的。</p>
                        </li>
                        <li>
                           <p>避免通过在客户端程序或中间层缓存频繁访问的数据来重新查询相同的数据。</p>
                        </li>
                        <li>
                           <p>在运行OLTP应用程序的大型数据库中，许多行只能访问一次（或从不）。因此，在使用它之后，没有任何目的将块保持在存储器中。</p>
                        </li>
                        <li>
                           <p>不要不断增加缓冲区缓存大小。</p>
                           <p>如果数据库执行全表扫描或不使用缓冲区高速缓存的操作，则缓冲区高速缓存大小的连续增加不起作用。</p>
                        </li>
                        <li>
                           <p>在发生大型全表扫描时，请考虑较差的命中率。</p>
                           <p>在长全表扫描期间访问的数据库块位于最近最少使用（LRU）列表的尾端，而不是列表的头部。因此，在执行索引查找或小型表扫描时，块会比读取的块更快地老化。</p>
                           <div class="infoboxnote" id="GUID-E4018F9E-5A4B-41D0-8BCA-16191FC783BE__GUID-A77B1D49-1154-4A7E-93C5-0013DA7798A4">
                              <p class="notep1">注意：</p>
                              <p>短表扫描是在特定大小阈值下对表执行的扫描。小表的定义最多为缓冲区高速缓存的2％或20，以较大者为准。</p>
                           </div>
                        </li>
                     </ul>
                  </div>
               </div><a id="TGDBA537"></a><div class="props_rev_3"><a id="GUID-874BE709-8385-43AE-B3AB-BB3F6A0D1971" name="GUID-874BE709-8385-43AE-B3AB-BB3F6A0D1971"></a><h4 id="TGDBA-GUID-874BE709-8385-43AE-B3AB-BB3F6A0D1971" class="sect4"><span class="enumeration_section">13.2.4</span>增加分配给数据库缓冲区高速缓存的内存</h4>
                  <div>
                     <div class="section">
                        <p>如果缓存命中率较低并且调整了应用程序以避免执行全表扫描，请考虑增加缓冲区缓存的大小。如果可能，请动态调整缓冲池的大小，而不是关闭实例以执行此更改。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-874BE709-8385-43AE-B3AB-BB3F6A0D1971__GUID-4DC0436F-66A5-45EC-8DBD-25B4E8ACAC42">要增加数据库缓冲区缓存的大小：</p>
                        <ol>
                           <li>
                              <p>将<code class="codeph">DB_CACHE_ADVICE</code>初始化参数的值设置为<code class="codeph">ON</code> 。</p>
                           </li>
                           <li>
                              <p>允许缓冲区缓存统计信息稳定下来。</p>
                           </li>
                           <li>
                              <p>检查<code class="codeph">V$DB_CACHE_ADVICE</code>视图中的顾问数据，以确定显着减少执行的物理I / O量所需的下一个增量，如<span class="q">“ <a href="tuning-database-buffer-cache.html#GUID-83733109-5119-4DDB-8A81-5302CE956BE2">使用V $ DB_CACHE_ADVICE视图</a> ”中所述</span> 。
                              </p>
                           </li>
                           <li>
                              <p>如果可以在不导致系统分页的情况下分配缓冲区高速缓存所需的额外内存，则分配此内存。</p>
                           </li>
                           <li>
                              <p>要增加分配给缓冲区高速缓存的内存量，请增加<code class="codeph">DB_CACHE_SIZE</code>初始化参数的值。
                              </p>
                              <p><code class="codeph">DB_CACHE_SIZE</code>参数指定数据库标准块大小的默认高速缓存的大小。要创建和使用块大小不是数据库标准块大小的表空间（例如可传输表空间），请为每个使用的块大小配置单独的高速缓存。<code class="codeph"></code>使用<code class="codeph">DB_ <span class="codeinlineitalic">n</span> K_CACHE_SIZE</code>参数配置所需的非标准块大小（其中<span class="italic"><code class="codeph">n</code></span>为<code class="codeph">DB_ <span class="codeinlineitalic">n</span> K_CACHE_SIZE</code>或32而不是标准块大小）。
                              </p>
                           </li>
                        </ol>
                        <div class="infoboxnote" id="GUID-874BE709-8385-43AE-B3AB-BB3F6A0D1971__GUID-66FA0E98-F428-461A-905A-C94C12F1A6E2">
                           <p class="notep1">注意：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>无论缓存是默认标准块大小缓存， <code class="codeph">KEEP</code>还是<code class="codeph">RECYCLE</code>缓存，还是非标准块大小缓存，选择缓存大小的过程都是相同的。
                                 </p>
                              </li>
                              <li>
                                 <p>当缓存显着调整大小（大于20％）时，将丢弃旧缓存顾问值，并将缓存顾问设置为新大小。否则，通过现有值的插值将旧缓存顾问值调整为新大小。</p>
                              </li>
                           </ul>
                        </div>
                        <div class="infoboxnotealso" id="GUID-874BE709-8385-43AE-B3AB-BB3F6A0D1971__GUID-1CD8B261-FA85-4C54-90FE-ED867D02745F">
                           <p class="notep1">也可以看看：</p>
                           <p>有关<code class="codeph">DB_ <span class="codeinlineitalic">n</span> K_CACHE_SIZE</code>参数的详细信息，请参阅：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><a href="../admin/managing-tablespaces.html#ADMIN-GUID-A789CECE-226C-4280-8BC4-39F064036965" target="_blank"><span class="italic">Oracle数据库管理员指南</span></a></p>
                              </li>
                              <li>
                                 <p><a href="../refrn/DB_nK_CACHE_SIZE.html#REFRN-GUID-025ECEB2-E535-49D2-9721-268E3925FE09" target="_blank"><span class="italic">Oracle数据库参考</span></a></p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="TGDBA538"></a><div class="props_rev_3"><a id="GUID-74EF352E-2C42-4C39-9F82-00BC7DC616AD" name="GUID-74EF352E-2C42-4C39-9F82-00BC7DC616AD"></a><h4 id="TGDBA-GUID-74EF352E-2C42-4C39-9F82-00BC7DC616AD" class="sect4"><span class="enumeration_section">13.2.5</span>减少分配给数据库缓冲区高速缓存的内存</h4>
                  <div>
                     <div class="section">
                        <p>如果高速缓存命中率很高，则缓冲区高速缓存可能足够大以存储最频繁访问的数据。如果是这种情况并且另一个内存结构需要内存，请考虑减小缓冲区高速缓存的大小。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-74EF352E-2C42-4C39-9F82-00BC7DC616AD__GUID-D6122DA5-04C7-41ED-89ED-D079F146536D">要减小数据库缓冲区缓存的大小：</p>
                        <ol>
                           <li>
                              <p>检查<code class="codeph">V$DB_CACHE_ADVICE</code>视图中的顾问数据，以确定减小缓冲区高速缓存的大小是否会显着增加物理I / O的数量，如<span class="q">“ <a href="tuning-database-buffer-cache.html#GUID-83733109-5119-4DDB-8A81-5302CE956BE2">使用V $ DB_CACHE_ADVICE视图</a> ”中所述</span> 。
                              </p>
                           </li>
                           <li>
                              <p>要减少分配给缓冲区高速缓存的内存量，请减小<code class="codeph">DB_CACHE_SIZE</code>初始化参数的值。
                              </p>
                           </li>
                        </ol>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="TGDBA315"></a><div class="props_rev_3"><a id="GUID-31549A91-EF90-4FD5-AC5E-3F80FD3AE175" name="GUID-31549A91-EF90-4FD5-AC5E-3F80FD3AE175"></a><h3 id="TGDBA-GUID-31549A91-EF90-4FD5-AC5E-3F80FD3AE175" class="sect3"><span class="enumeration_section">13.3</span>配置多个缓冲池</h3>
               <div>
                  <p>对于大多数系统，单个默认缓冲池通常就足够了。但是，具有应用程序缓冲池详细知识的数据库管理员可以从配置多个缓冲池中受益。</p>
                  <p>对于具有非典型访问模式的段，请考虑将这些段中的块存储在两个单独的缓冲池中： <code class="codeph">KEEP</code>池和<code class="codeph">RECYCLE</code>池。如果段的访问模式经常被访问（有时被称为热门）或不经常访问（例如每天只能由批处理作业访问一次的大段），则该段的访问模式可能是非典型的。
                  </p>
                  <p>运用<a id="d39363e897" class="indexterm-anchor"></a><a id="d39363e899" class="indexterm-anchor"></a>多个缓冲池使您可以解决这些不规则问题。您可以使用<code class="codeph">KEEP</code>池来维护缓冲区缓存中经常访问的段，以及<code class="codeph">RECYCLE</code>池以防止对象占用缓冲区缓存中不必要的空间。当对象与缓冲区高速缓存关联时，该对象的所有块都放在该高速缓存中。Oracle数据库为未分配给特定缓冲池的对象维护<code class="codeph">DEFAULT</code>缓冲池。默认缓冲池大小由<code class="codeph">DB_CACHE_SIZE</code>初始化参数确定。每个缓冲池使用相同的LRU替换策略。例如，如果<code class="codeph">KEEP</code>池的大小不足以存储分配给它的所有段，则最旧的块会从缓存中老化。<a id="d39363e920" class="indexterm-anchor"></a></p>
                  <p>通过将对象分配给适当的缓冲池，您可以：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>减少或消除I / O.</p>
                     </li>
                     <li>
                        <p>将对象隔离或限制为单独的缓存</p>
                     </li>
                  </ul>
                  <p>本节介绍如何配置多个缓冲池，并包含以下主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="tuning-database-buffer-cache.html#GUID-C896955E-01E4-4E93-9198-BA495E3C60E9">使用多个缓冲池的注意事项</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-database-buffer-cache.html#GUID-30C8D6DD-C903-4484-B435-D51DF601D8B1">使用多个缓冲池</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-database-buffer-cache.html#GUID-A77CE146-AA1F-4601-B002-B9261610AAB3">使用单个缓冲池的V $ DB_CACHE_ADVICE视图</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-database-buffer-cache.html#GUID-C66B60D6-A759-47C0-AD53-B55DC3916002">计算单个缓冲池的缓冲池命中率</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-database-buffer-cache.html#GUID-C07C5202-72F2-4A69-AAB6-B58BD3EA05B8">检查缓冲区高速缓存使用模式</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-database-buffer-cache.html#GUID-DE6B6C6E-D947-45FF-B189-F0271B86DB10">配置KEEP池</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-database-buffer-cache.html#GUID-D777DE69-8CCD-49AB-8EC9-F5B7E84690FF">配置RECYCLE池</a></p>
                     </li>
                  </ul>
               </div><a id="TGDBA539"></a><div class="props_rev_3"><a id="GUID-C896955E-01E4-4E93-9198-BA495E3C60E9" name="GUID-C896955E-01E4-4E93-9198-BA495E3C60E9"></a><h4 id="TGDBA-GUID-C896955E-01E4-4E93-9198-BA495E3C60E9" class="sect4"><span class="enumeration_section">13.3.1</span>使用多个缓冲池的注意事项</h4>
                  <div>
                     <p>使用多个缓冲池时，请考虑以下注意事项：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="tuning-database-buffer-cache.html#GUID-6DAE0BC7-CEDF-44AE-A4FB-EDED0B2AA57A">随机访问大段</a></p>
                        </li>
                        <li>
                           <p><a href="tuning-database-buffer-cache.html#GUID-609F72D6-46A1-4570-81F6-D0591548F109">Oracle Real Application Cluster实例</a></p>
                        </li>
                     </ul>
                  </div><a id="TGDBA540"></a><div class="props_rev_3"><a id="GUID-6DAE0BC7-CEDF-44AE-A4FB-EDED0B2AA57A" name="GUID-6DAE0BC7-CEDF-44AE-A4FB-EDED0B2AA57A"></a><h5 id="TGDBA-GUID-6DAE0BC7-CEDF-44AE-A4FB-EDED0B2AA57A" class="sect5"><span class="enumeration_section">13.3.1.1</span>随机访问大段</h5>
                     <div>
                        <p>当使用大型或无限索引范围扫描访问非常大的段（与缓冲区高速缓存的大小相比）时，LRU老化方法可能会出现问题。可以认为占非实质读物的大部分（超过10％）的任何单个片段都非常大。对大段的随机读取可能导致包含其他段的数据的缓冲区从缓存中老化。大段最终消耗了大部分缓冲区缓存，但它不会从缓存中受益。</p>
                        <p>非常频繁访问的段不受大段读取的影响，因为它们的缓冲区经常被加热以使它们不会老化缓冲区高速缓存。但是，该问题会影响温度段，这些段不会频繁访问，无法承受由大段读取引起的缓冲区老化。解决此问题有三种选择：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>如果访问的对象是索引，请确定索引是否是选择性的。如果没有，请调整SQL语句以使用更具选择性的索引。</p>
                           </li>
                           <li>
                              <p>如果调整了SQL语句，请将大段移动到单独的<code class="codeph">RECYCLE</code>缓存中，这样它就不会影响其他段。<code class="codeph">RECYCLE</code>缓存应小于<code class="codeph">DEFAULT</code>缓冲池，并且应该更快地重用缓冲区。
                              </p>
                           </li>
                           <li>
                              <p>或者，考虑将小的热段移动到不用于大段的单独<code class="codeph">KEEP</code>高速缓存中。调整<code class="codeph">KEEP</code>缓存的大小以最大限度地减少缓存中的未命中。通过将查询访问的段存储在<code class="codeph">KEEP</code>缓存中，可以使特定查询的响应时间更加可预测，以确保它们不会老化。
                              </p>
                           </li>
                        </ul>
                     </div>
                  </div><a id="TGDBA541"></a><div class="props_rev_3"><a id="GUID-609F72D6-46A1-4570-81F6-D0591548F109" name="GUID-609F72D6-46A1-4570-81F6-D0591548F109"></a><h5 id="TGDBA-GUID-609F72D6-46A1-4570-81F6-D0591548F109" class="sect5"><span class="enumeration_section">13.3.1.2</span> Oracle Real Application Cluster实例</h5>
                     <div>
                        <p>在Oracle Real Application Cluster（Oracle RAC）环境中，请考虑为每个数据库实例创建多个缓冲池。没有必要为数据库的每个实例定义同一组缓冲池。在实例中，缓冲池可以是不同的大小或未定义的。根据该实例的应用程序要求调整每个实例。</p>
                     </div>
                  </div>
               </div><a id="TGDBA542"></a><div class="props_rev_3"><a id="GUID-30C8D6DD-C903-4484-B435-D51DF601D8B1" name="GUID-30C8D6DD-C903-4484-B435-D51DF601D8B1"></a><h4 id="TGDBA-GUID-30C8D6DD-C903-4484-B435-D51DF601D8B1" class="sect4"><span class="enumeration_section">13.3.2</span>使用多个缓冲池</h4>
                  <div>
                     <p>要为对象定义默认缓冲池，请使用<code class="codeph">STORAGE</code>子句的<code class="codeph">BUFFER_POOL</code>关键字。此子句对以下SQL语句有效：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">创建表</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">创建集群</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">创建指数</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">更改表</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">ALTER CLUSTER</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">改变指数</code></p>
                        </li>
                     </ul>
                     <p>定义缓冲池后，为该对象读取的所有后续块都将放置在该池中。如果为分区表或索引定义了缓冲池，则对象的每个分区都从表或索引定义继承缓冲池，除非它被特定缓冲池覆盖。</p>
                     <p>当使用<code class="codeph">ALTER</code>语句更改对象的缓冲池时，当前包含已更改段的块的所有缓冲区都保留在<code class="codeph">ALTER</code>语句之前的缓冲池中。新加载的块以及任何已老化和重新加载的块都将放入新的缓冲池中。
                     </p>
                     <div class="infoboxnotealso" id="GUID-30C8D6DD-C903-4484-B435-D51DF601D8B1__GUID-83DDC62E-7114-4EB2-AC41-983C32A73A79">
                        <p class="notep1">也可以看看：</p>
                        <p>有关在<code class="codeph">STORAGE</code>子句中指定<code class="codeph">BUFFER_POOL</code>信息，请<a href="../sqlrf/storage_clause.html#SQLRF-GUID-C5A67610-3160-41E9-8D48-03206BD5ED15" target="_blank"><span class="italic">参见“Oracle数据库SQL语言参考</span></a> ”</p>
                     </div>
                  </div>
               </div><a id="TGDBA544"></a><a id="TGDBA543"></a><div class="props_rev_3"><a id="GUID-A77CE146-AA1F-4601-B002-B9261610AAB3" name="GUID-A77CE146-AA1F-4601-B002-B9261610AAB3"></a><h4 id="TGDBA-GUID-A77CE146-AA1F-4601-B002-B9261610AAB3" class="sect4"><span class="enumeration_section">13.3.3</span>对各个缓冲池使用V $ DB_CACHE_ADVICE视图</h4>
                  <div>
                     <div class="section">
                        <p>与默认缓冲池一样，您可以使用<code class="codeph">V$DB_CACHE_ADVICE</code>视图来协助其他池的缓存大小调整。估计初始高速缓存大小并运行代表性工作负载后，查询要使用的池的<code class="codeph">V$DB_CACHE_ADVICE</code>视图。
                        </p>
                        <p>有关使用<code class="codeph">V$DB_CACHE_ADVICE</code>视图的更多信息，请参阅<span class="q">“ <a href="tuning-database-buffer-cache.html#GUID-83733109-5119-4DDB-8A81-5302CE956BE2">使用V $ DB_CACHE_ADVICE视图</a> ”</span> 。
                        </p>
                        <p><a href="tuning-database-buffer-cache.html#GUID-A77CE146-AA1F-4601-B002-B9261610AAB3__CHDCDAAI">例13-2</a>显示了查询来自<code class="codeph">KEEP</code>池的数据的视图的查询：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-A77CE146-AA1F-4601-B002-B9261610AAB3__CHDCDAAI">
                        <p class="titleinexample">例13-2查询KEEP池的V $ DB_CACHE_ADVICE视图</p><pre class="oac_no_warn" dir="ltr">SELECT size_for_estimate，buffers_for_estimate，estd_physical_read_factor，estd_physical_reads FROM V $ DB_CACHE_ADVICE WHERE name ='KEEP'AND block_size =（SELECT value FROM V $ PARAMETER WHERE name ='db_block_size'）AND advice_status ='ON';</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="TGDBA546"></a><a id="TGDBA545"></a><div class="props_rev_3"><a id="GUID-C66B60D6-A759-47C0-AD53-B55DC3916002" name="GUID-C66B60D6-A759-47C0-AD53-B55DC3916002"></a><h4 id="TGDBA-GUID-C66B60D6-A759-47C0-AD53-B55DC3916002" class="sect4"><span class="enumeration_section">13.3.4</span>计算各缓冲池的缓冲池命中率</h4>
                  <div>
                     <div class="section">
                        <p><code class="codeph">V$SYSSTAT</code>视图中的数据反映了一组统计信息中所有缓冲池的逻辑和物理读取。要单独确定缓冲池的命中率，请查询<a id="d39363e1407" class="indexterm-anchor"></a> <code class="codeph">V$BUFFER_POOL_STATISTICS</code>视图。此视图维护有关每个池的逻辑读取和写入次数的统计信息。
                        </p>
                        <div class="infoboxnotealso" id="GUID-C66B60D6-A759-47C0-AD53-B55DC3916002__GUID-F42FE641-27DB-4756-890D-A3A6F87A13F9">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><span class="q">“ <a href="tuning-database-buffer-cache.html#GUID-186EEE2D-11A1-401A-B9B2-E72325F972BC">计算缓冲区高速缓存命中率</a> ”</span>以获取有关计算命中率的更多信息</p>
                              </li>
                              <li>
                                 <p>有关<code class="codeph">V$BUFFER_POOL_STATISTICS</code>视图的更多信息，请<a href="../refrn/V-BUFFER_POOL_STATISTICS.html#REFRN-GUID-1E914318-C648-4A72-9AA9-711F8CAA92FB" target="_blank"><span class="italic">参见Oracle数据库参考</span></a></p>
                              </li>
                           </ul>
                        </div>
                        <p>以下查询使用<code class="codeph">V$BUFFER_POOL_STATISTICS</code>视图计算命中率。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-C66B60D6-A759-47C0-AD53-B55DC3916002__CHDJCBJE">
                        <p class="titleinexample">例13-3查询V $ BUFFER_POOL_STATISTICS视图</p><pre class="oac_no_warn" dir="ltr">SELECT name，physical_reads，db_block_gets，consistent_gets，1  - （physical_reads /（db_block_gets + consistent_gets））“命中率”FROM V $ BUFFER_POOL_STATISTICS;</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="TGDBA547"></a><div class="props_rev_3"><a id="GUID-C07C5202-72F2-4A69-AAB6-B58BD3EA05B8" name="GUID-C07C5202-72F2-4A69-AAB6-B58BD3EA05B8"></a><h4 id="TGDBA-GUID-C07C5202-72F2-4A69-AAB6-B58BD3EA05B8" class="sect4"><span class="enumeration_section">13.3.5</span>检查缓冲区缓存使用模式</h4>
                  <div>
                     <p><code class="codeph">V$BH</code>视图显示当前驻留在SGA中的所有块的数据对象ID。要确定哪些段在池中有许多缓冲区，请使用此视图检查缓冲区高速缓存使用模式。您可以检查所有段或特定段的缓冲区高速缓存使用模式，如以下部分所述：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="tuning-database-buffer-cache.html#GUID-B57D5C88-54F1-4643-B4E8-FA6F166DFC5B">检查所有段的缓冲区高速缓存使用模式</a></p>
                        </li>
                        <li>
                           <p><a href="tuning-database-buffer-cache.html#GUID-DB866D78-6C70-4EEE-A544-C33ED64F2346">检查特定段的缓冲区高速缓存使用模式</a></p>
                        </li>
                     </ul>
                  </div><a id="TGDBA549"></a><a id="TGDBA548"></a><div class="props_rev_3"><a id="GUID-B57D5C88-54F1-4643-B4E8-FA6F166DFC5B" name="GUID-B57D5C88-54F1-4643-B4E8-FA6F166DFC5B"></a><h5 id="TGDBA-GUID-B57D5C88-54F1-4643-B4E8-FA6F166DFC5B" class="sect5"><span class="enumeration_section">13.3.5.1</span>检查所有段的缓冲区高速缓存使用模式</h5>
                     <div>
                        <div class="section">
                           <p>确定池中具有多个缓冲区的一种方法是在给定时间查询驻留在缓冲区高速缓存中的所有段的块数。根据缓冲区高速缓存大小，这可能需要大量的排序空间。</p>
                           <p><a href="tuning-database-buffer-cache.html#GUID-B57D5C88-54F1-4643-B4E8-FA6F166DFC5B__CHDIJAJD">例13-4</a>显示了一个计算所有段的块数的查询。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-B57D5C88-54F1-4643-B4E8-FA6F166DFC5B__CHDIJAJD">
                           <p class="titleinexample">例13-4查询所有段的块数</p><pre class="oac_no_warn" dir="ltr">COLUMN object_name FORMAT A40 COLUMN number_of_blocks FORMAT 999,999,999,999 SELECT o.object_name，COUNT（*）number_of_blocks FROM DBA_OBJECTS o，V $ BH bh WHERE o.data_object_id = bh。OBJD和o.owner！='SYS'GROUP BY o.object_Name ORDER BY COUNT（*）;</pre><p>此查询的输出可能如下所示：</p><pre class="oac_no_warn" dir="ltr">OBJECT_NAME NUMBER_OF_BLOCKS ---------------------------------------- -------- -------- OA_PREF_UNIQ_KEY 1 SYS_C002651 1 ..DS_PERSON 78 OM_EXT_HEADER 701 OM_SHELL 1,765 OM_HEADER 5,826 OM_INSTANCE 12,644</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="TGDBA550"></a><div class="props_rev_3"><a id="GUID-DB866D78-6C70-4EEE-A544-C33ED64F2346" name="GUID-DB866D78-6C70-4EEE-A544-C33ED64F2346"></a><h5 id="TGDBA-GUID-DB866D78-6C70-4EEE-A544-C33ED64F2346" class="sect5"><span class="enumeration_section">13.3.5.2</span>检查特定段的缓冲区高速缓存使用模式</h5>
                     <div>
                        <div class="section">
                           <p>确定池中具有多个缓冲区的另一种方法是计算在给定时间单个对象使用的缓冲区高速缓存的百分比。</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-DB866D78-6C70-4EEE-A544-C33ED64F2346__GUID-EED654CE-ED53-4513-ADB1-C046F0A0B55A">要计算单个对象使用的缓冲区高速缓存的百分比：</p>
                           <ol>
                              <li>
                                 <p>通过查询，找到该段的Oracle数据库内部对象编号<a id="d39363e1630" class="indexterm-anchor"></a> <code class="codeph">DBA_OBJECTS</code>视图：</p><pre class="oac_no_warn" dir="ltr">SELECT data_object_id，object_type FROM DBA_OBJECTS WHERE object_name = UPPER（' <span class="italic">segment_name</span> '）;</pre><p>因为两个对象可以具有相同的名称（如果它们是不同类型的对象），请使用<code class="codeph">OBJECT_TYPE</code>列来标识感兴趣的对象。</p>
                              </li>
                              <li>
                                 <p>在<span class="italic"><code class="codeph">SEGMENT_NAME</code></span>的缓冲区缓存中查找缓冲区数量：</p><pre class="oac_no_warn" dir="ltr">SELECT COUNT（*）缓冲区FROM V $ BH WHERE objd = <span class="italic">data_object_id_value</span> ;</pre><p>对于<span class="italic"><code class="codeph">data_object_id_value</code></span> ，请使用上一步中的<code class="codeph">DATA_OBJECT_ID</code>值。
                                 </p>
                              </li>
                              <li>
                                 <p>查找数据库实例中的缓冲区数量：</p><pre class="oac_no_warn" dir="ltr">SELECT name，block_size，SUM（buffers）FROM V $ BUFFER_POOL GROUP BY name，block_size HAVING SUM（buffers）&gt; 0;</pre></li>
                              <li>
                                 <p>计算缓冲区与总缓冲区的比率，以获取<span class="italic"><code class="codeph">SEGMENT_NAME</code></span>当前使用的缓存百分比：</p><pre class="oac_no_warn" dir="ltr"><span class="italic">segment_name</span> = [buffers（Step2）/ total buffers（Step3）]使用的％缓存</pre></li>
                           </ol>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <div class="infoboxnote" id="GUID-DB866D78-6C70-4EEE-A544-C33ED64F2346__GUID-AF6F1D8F-D322-464B-B890-DBC684FDDCDB">
                              <p class="notep1">注意：</p>
                              <p>此方法仅适用于单个段。对于分区对象，请为每个分区运行查询。</p>
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="TGDBA551"></a><div class="props_rev_3"><a id="GUID-DE6B6C6E-D947-45FF-B189-F0271B86DB10" name="GUID-DE6B6C6E-D947-45FF-B189-F0271B86DB10"></a><h4 id="TGDBA-GUID-DE6B6C6E-D947-45FF-B189-F0271B86DB10" class="sect4"><span class="enumeration_section">13.3.6</span>配置KEEP池</h4>
                  <div>
                     <div class="section">
                        <p><code class="codeph">KEEP</code>缓冲池的目的是将对象保留在内存中，从而避免I / O操作。保留在内存中的每个对象都会导致权衡。将频繁访问的块保留在缓存中更有益。避免在缓存中保留不常使用的块，因为这样可以减少其他更活跃块的空间</p>
                        <p>如果应用程序中存在经常引用的某些段，则考虑将这些段中的块存储在<code class="codeph">KEEP</code>缓冲池中。保留在<code class="codeph">KEEP</code>池中的典型段是经常使用的小型参考表。要确定哪些表是候选表，请通过查询<code class="codeph">V$BH</code>视图来检查候选表中的块数，如<span class="q">“ <a href="tuning-database-buffer-cache.html#GUID-C07C5202-72F2-4A69-AAB6-B58BD3EA05B8">检查缓冲区高速缓存使用模式</a> ”中所述</span> 。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-DE6B6C6E-D947-45FF-B189-F0271B86DB10__GUID-53E46653-BB28-4EDF-BE9A-A3E85F62C2E5">要配置KEEP池：</p>
                        <ol>
                           <li>
                              <p>计算<code class="codeph">KEEP</code>缓冲池的大致大小。
                              </p>
                              <p><code class="codeph">KEEP</code>缓冲池的大小取决于要保留在缓冲区高速缓存中的对象。要估计其大小，请添加分配给此池的所有对象使用的块。
                              </p>
                              <p>如果您收集了有关段的统计信息，请查询<code class="codeph">DBA_TABLES.BLOCKS</code>和<code class="codeph">DBA_TABLES</code> 。 <code class="codeph">EMPTY_BLOCKS</code>确定使用的块数。
                              </p>
                           </li>
                           <li>
                              <p>在不同时间拍摄系统性能的两个快照。</p>
                              <p>使用<code class="codeph">V$DB_CACHE_ADVICE</code>视图从<code class="codeph">KEEP</code>池查询每个快照的数据，如<span class="q">“ <a href="tuning-database-buffer-cache.html#GUID-A77CE146-AA1F-4601-B002-B9261610AAB3">使用各个缓冲池的V $ DB_CACHE_ADVICE视图</a> ”中所述</span> 。
                              </p>
                           </li>
                           <li>
                              <p>从较旧的值中减去<code class="codeph">physical</code> <code class="codeph">reads</code> ， <code class="codeph">block</code> <code class="codeph">gets</code>和<code class="codeph">consistent</code> <code class="codeph">gets</code>的更新值，并使用结果计算命中率。
                              </p>
                              <p>缓冲池命中率为100％可能不是最佳的。通常，您可以减小<code class="codeph">KEEP</code>缓冲池的大小，并仍然保持足够高的命中率。将从<code class="codeph">KEEP</code>缓冲池中删除的块分配给其他缓冲池。
                              </p>
                           </li>
                           <li>
                              <p>通过将<code class="codeph">DB_KEEP_CACHE_SIZE</code>参数的值设置为所需大小，将内存分配给<code class="codeph">KEEP</code>缓冲池。
                              </p>
                              <p><code class="codeph">KEEP</code>池的内存不是默认池的子集。
                              </p>
                           </li>
                        </ol>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <div class="infoboxnote" id="GUID-DE6B6C6E-D947-45FF-B189-F0271B86DB10__GUID-F7C319F4-5A6B-4A5A-BD94-3AF8F2BBB595">
                           <p class="notep1">注意：</p>
                           <p>如果对象的大小增加，则它可能不再适合<code class="codeph">KEEP</code>缓冲池。您将开始从缓存中丢失块。
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="TGDBA552"></a><div class="props_rev_3"><a id="GUID-D777DE69-8CCD-49AB-8EC9-F5B7E84690FF" name="GUID-D777DE69-8CCD-49AB-8EC9-F5B7E84690FF"></a><h4 id="TGDBA-GUID-D777DE69-8CCD-49AB-8EC9-F5B7E84690FF" class="sect4"><span class="enumeration_section">13.3.7</span>配置RECYCLE池</h4>
                  <div>
                     <div class="section">
                        <p>您可以为属于那些您不想保留在内存中的段的块配置<code class="codeph">RECYCLE</code>缓冲池。<code class="codeph">RECYCLE</code>池的目的是保留很少扫描或不经常引用的段。如果应用程序随机访问非常大的对象的块，则存储在缓冲池中的块不可能在其老化之前被重用。无论缓冲池的大小如何（考虑到可用物理内存量的约束），都是如此。因此，不需要缓存对象的块;缓存缓冲区可以分配给其他对象。
                        </p>
                        <p>不要太快丢弃内存中的块。如果缓冲池太小，则在事务或SQL语句完成执行之前，块可能会从缓存中老化。例如，应用程序可能会从表中选择一个值，使用该值处理某些数据，然后更新记录。如果在<code class="codeph">SELECT</code>语句之后从高速缓存中删除该块，则必须再次从磁盘读取该块以执行更新。应在用户事务期间保留该块。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-D777DE69-8CCD-49AB-8EC9-F5B7E84690FF__GUID-BF34F72F-9CDD-46B3-AB6F-C8F6A8F31C80">要配置RECYCLE POOL：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>通过将<code class="codeph">DB_RECYCLE_CACHE_SIZE</code>参数的值设置为所需大小，将内存分配给<code class="codeph">RECYCLE</code>缓冲池。
                              </p>
                              <p><code class="codeph">RECYCLE</code>池的内存不是默认池的子集。
                              </p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="TGDBA554"></a><a id="TGDBA553"></a><div class="props_rev_3"><a id="GUID-1724C3C8-190E-4DBA-90FC-12B1B40158B1" name="GUID-1724C3C8-190E-4DBA-90FC-12B1B40158B1"></a><h3 id="TGDBA-GUID-1724C3C8-190E-4DBA-90FC-12B1B40158B1" class="sect3"><span class="enumeration_section">13.4</span>配置重做日志缓冲区</h3>
               <div>
                  <p>对缓冲区高速缓存中的数据块进行更改的服务器进程会将重做数据生成到日志缓冲区中。如果满足以下任一条件，则日志写入器进程（LGWR）开始写入将条目从重做日志缓冲区复制到联机重做日志：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>重做日志缓冲区至少变为满三分之一</p>
                     </li>
                     <li>
                        <p>LGWR由执行<code class="codeph">COMMIT</code>或<code class="codeph">ROLLBACK</code>的服务器进程发布</p>
                     </li>
                     <li>
                        <p>数据库编写器进程（DBWR）发布LGWR以执行此操作</p>
                     </li>
                  </ul>
                  <p>当LGWR将重做条目从重做日志缓冲区写入重做日志文件或磁盘时，用户进程可以在内存中写入磁盘的条目上复制新条目，如下图所示。</p>
                  <div class="figure" id="GUID-1724C3C8-190E-4DBA-90FC-12B1B40158B1__CACBJEJE">
                     <p class="titleinfigure">图13-2重做日志缓冲区</p><img src="img/figure_132_redo_log_buffer.png" alt="下面是图13-2的描述" title="下面是图13-2的描述" longdesc="img_text/figure_132_redo_log_buffer.html"><br><a href="img_text/figure_132_redo_log_buffer.html">“图13-2重做日志缓冲区”的说明</a></div>
                  <!-- class="figure" -->
                  <p>LGWR尝试快速写入以确保重做日志缓冲区中的空间可用于新条目，即使它经常被访问。拥有更大的重做日志缓冲区使得更有可能存在新条目的空间，并且还使LGWR能够有效地处理重做记录。在具有大量更新的系统上，如果重做日志缓冲区太小，LGWR将不断将重做刷新到磁盘，以使其保持三分之二为空。</p>
                  <p>在具有快速处理器和相对较慢的磁盘的系统上，处理器可能在重做日志写入器将一部分重做日志缓冲区移动到磁盘所花费的时间内填充重做日志缓冲区的其余部分。在这种情况下，较大的重做日志缓冲区可以暂时屏蔽较慢磁盘的影响。或者，考虑改进：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>检查点或存档过程</p>
                     </li>
                     <li>
                        <p>通过将所有在线日志移动到快速原始设备来实现LGWR的性能</p>
                     </li>
                  </ul>
                  <p>要提高重做日志缓冲区的性能，请确保您：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>批处理作业的批处理操作，以便LGWR能够有效地写入重做日志条目</p>
                     </li>
                     <li>
                        <p>在加载大量数据时使用<code class="codeph">NOLOGGING</code>操作</p>
                     </li>
                  </ul>
                  <p>本节介绍如何配置重做日志缓冲区，并包含以下主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="tuning-database-buffer-cache.html#GUID-EA91F2C3-A975-4AD9-B137-0C0C8025E64C">调整重做日志缓冲区的大小</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-database-buffer-cache.html#GUID-772D48A0-FE2B-4A05-8826-3ADA25F4D7C5">使用重做日志缓冲区统计信息</a></p>
                     </li>
                  </ul>
               </div><a id="TGDBA555"></a><div class="props_rev_3"><a id="GUID-EA91F2C3-A975-4AD9-B137-0C0C8025E64C" name="GUID-EA91F2C3-A975-4AD9-B137-0C0C8025E64C"></a><h4 id="TGDBA-GUID-EA91F2C3-A975-4AD9-B137-0C0C8025E64C" class="sect4"><span class="enumeration_section">13.4.1</span>调整重做日志缓冲区的大小</h4>
                  <div>
                     <div class="section">
                        <p>重做日志缓冲区的默认大小计算如下：</p><pre class="oac_no_warn" dir="ltr">MAX（0.5M，（128K * cpus））</pre><p>插入，修改或删除大量数据的应用程序可能需要更改重做日志缓冲区的默认大小。Oracle建议将重做日志缓冲区大小设置为最小8 MB。对于使用闪回功能且具有4GB或更高SGA的数据库，将其设置为最小64 MB。如果您使用具有异步重做传输的Oracle Data Guard并且具有高重做生成速率，则将其设置为最小256 MB。</p>
                        <p>要确定重做日志缓冲区的大小是否太小，请监视重做日志缓冲区统计信息，如<span class="q">“ <a href="tuning-database-buffer-cache.html#GUID-772D48A0-FE2B-4A05-8826-3ADA25F4D7C5">使用重做日志缓冲区统计信息</a> ”中所述</span> 。您还可以检查<code class="codeph">log</code> <code class="codeph">buffer</code> <code class="codeph">space</code>等待事件是否是数据库实例等待时间的重要因素。如果不是，那么日志缓冲区大小很可能是足够大的。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-EA91F2C3-A975-4AD9-B137-0C0C8025E64C__GUID-A0637559-D1DB-43AD-BAD2-136AF52F5207">要调整重做日志缓冲区的大小：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>通过将<code class="codeph">LOG_BUFFER</code>初始化参数的值设置为所需的大小来设置重做日志缓冲区的大小。
                              </p>
                              <p>该参数的值以字节表示。</p>
                              <div class="infoboxnote" id="GUID-EA91F2C3-A975-4AD9-B137-0C0C8025E64C__GUID-8094F4DC-CF3D-4571-B3EC-7FECCD7511AF">
                                 <p class="notep1">注意：</p>
                                 <p>实例启动后无法修改重做日志缓冲区的大小。</p>
                              </div>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="TGDBA557"></a><a id="TGDBA556"></a><div class="props_rev_3"><a id="GUID-772D48A0-FE2B-4A05-8826-3ADA25F4D7C5" name="GUID-772D48A0-FE2B-4A05-8826-3ADA25F4D7C5"></a><h4 id="TGDBA-GUID-772D48A0-FE2B-4A05-8826-3ADA25F4D7C5" class="sect4"><span class="enumeration_section">13.4.2</span>使用重做日志缓冲区统计信息</h4>
                  <div>
                     <div class="section">
                        <p><code class="codeph">REDO</code> <code class="codeph">BUFFER</code> <code class="codeph">ALLOCATION</code> <code class="codeph">RETRIES</code>统计信息反映了用户进程在重做日志缓冲区中等待空间的次数。可以使用<code class="codeph">V$SYSSTAT</code>查询此统计<code class="codeph">V$SYSSTAT</code> <a id="d39363e2197" class="indexterm-anchor"></a>绩效观。
                        </p>
                        <p>您应该在应用程序运行时监视一段时间内的<code class="codeph">redo buffer allocation retries</code>统计信息。在一个间隔内，此统计值应接近零。如果此值持续增加，则表示用户进程必须等待重做日志缓冲区中的空间变为可用。等待可能是由重做日志缓冲区太小或通过检查点引起的。在这种情况下，请考虑以下选项之一：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p>增加重做日志缓冲区的大小，如<span class="q">“ <a href="tuning-database-buffer-cache.html#GUID-EA91F2C3-A975-4AD9-B137-0C0C8025E64C">调整重做日志缓冲区大小</a> ”中所述</span></p>
                           </li>
                           <li>
                              <p>改进检查点或归档过程</p>
                           </li>
                        </ul>
                        <p><a href="tuning-database-buffer-cache.html#GUID-772D48A0-FE2B-4A05-8826-3ADA25F4D7C5__CACHGGFI">例13-5</a>显示了该统计<code class="codeph">V$SYSSTAT</code>的<code class="codeph">V$SYSSTAT</code>视图的查询。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-772D48A0-FE2B-4A05-8826-3ADA25F4D7C5__CACHGGFI">
                        <p class="titleinexample">示例13-5查询V $ SYSSTAT视图</p><pre class="oac_no_warn" dir="ltr">SELECT名称，值FROM V $ SYSSTAT WHERE name ='redo buffer allocation retries';</pre></div>
                     <!-- class="example" -->
                  </div>
               </div>
            </div><a id="TGDBA95384"></a><div class="props_rev_3"><a id="GUID-37246D78-7499-491B-B891-D625628677E7" name="GUID-37246D78-7499-491B-B891-D625628677E7"></a><h3 id="TGDBA-GUID-37246D78-7499-491B-B891-D625628677E7" class="sect3"><span class="enumeration_section">13.5</span>配置数据库缓存模式</h3>
               <div>
                  <p>从Oracle Database 12 <span class="italic">c</span>第1版（12.1.0.2）开始，有两个<a id="d39363e2284" class="indexterm-anchor"></a>数据库缓存模式：以前版本的Oracle数据库中使用的默认数据库缓存模式，以及此版本中新增的强制完全数据库缓存模式。在默认缓存模式下，当用户查询大型表时，Oracle数据库并不总是缓存基础数据。在强制完全数据库缓存模式下，Oracle数据库假定缓冲区缓存足够大，可以缓存整个数据库并尝试缓存查询访问的所有块。
                  </p>
                  <p>本节包含以下主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="tuning-database-buffer-cache.html#GUID-1830CEBC-58F7-4AEC-9D9C-BCDB89D8523F">默认数据库缓存模式</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-database-buffer-cache.html#GUID-0A3960A4-A62C-46C2-A5FE-CD305F0A7DC5">强制完全数据库缓存模式</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-database-buffer-cache.html#GUID-0E5D6B70-245B-4F24-9C7F-E14D98DD312D">确定何时使用强制完全数据库缓存模式</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-database-buffer-cache.html#GUID-4D8C2837-54BC-4D78-AFF6-5445C450A64E">验证数据库缓存模式</a></p>
                     </li>
                  </ul>
                  <div class="infoboxnote" id="GUID-37246D78-7499-491B-B891-D625628677E7__GUID-16ACE00B-6F4E-4CFA-897A-96C3F67A6E60">
                     <p class="notep1">注意：</p>
                     <p>从Oracle Database 12 <span class="italic">c</span>第1版（12.1.0.2）开始，可以使用强制完全数据库缓存模式。
                     </p>
                  </div>
               </div><a id="TGDBA95403"></a><div class="props_rev_3"><a id="GUID-1830CEBC-58F7-4AEC-9D9C-BCDB89D8523F" name="GUID-1830CEBC-58F7-4AEC-9D9C-BCDB89D8523F"></a><h4 id="TGDBA-GUID-1830CEBC-58F7-4AEC-9D9C-BCDB89D8523F" class="sect4"><span class="enumeration_section">13.5.1</span>默认数据库缓存模式</h4>
                  <div>
                     <p>默认情况下，Oracle数据库使用<a id="d39363e2369" class="indexterm-anchor"></a>执行全表扫描时的默认数据库缓存模式。在默认缓存模式下，当用户查询大型表时，Oracle数据库并不总是缓存底层数据，因为这样做可能会从缓冲区缓存中删除更多有用的数据。
                     </p>
                     <p>如果Oracle数据库实例确定有足够的空间来缓存缓冲区高速缓存中的完整数据库，并且这样做是有益的，那么实例会自动将完整数据库缓存在缓冲区高速缓存中。</p>
                     <p>如果Oracle数据库实例确定没有足够的空间来缓存缓冲区缓存中的完整数据库，则：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>只有当表大小小于缓冲区高速缓存大小的2％时，才会将较小的表加载到内存中。</p>
                        </li>
                        <li>
                           <p>对于中型表，Oracle数据库分析最后一次表扫描与缓冲区高速缓存的老化时间戳之间的间隔。如果在上一次表扫描中重用的表的大小大于剩余的缓冲区高速缓存大小，则表将被缓存。</p>
                        </li>
                        <li>
                           <p>除非您为KEEP缓冲池显式声明表，否则通常不会将大表加载到内存中。</p>
                        </li>
                     </ul>
                     <div class="infoboxnote" id="GUID-1830CEBC-58F7-4AEC-9D9C-BCDB89D8523F__GUID-02C5315E-CF1F-495A-B503-D4B49F25B92E">
                        <p class="notep1">注意：</p>
                        <p>在默认缓存模式下，Oracle数据库实例不会在缓冲区缓存中缓存<code class="codeph">NOCACHE</code> LOB。
                        </p>
                     </div>
                     <div class="infoboxnotealso" id="GUID-1830CEBC-58F7-4AEC-9D9C-BCDB89D8523F__GUID-25EBC271-24B2-4E8D-8A03-A4C86018DBDE">
                        <p class="notep1">也可以看看：</p>
                        <p>有关默认数据库缓存模式的信息，请参阅<a href="../cncpt/memory-architecture.html#CNCPT94672" target="_blank"><span class="italic">Oracle数据库概念</span></a></p>
                     </div>
                  </div>
               </div><a id="TGDBA95404"></a><div class="props_rev_3"><a id="GUID-0A3960A4-A62C-46C2-A5FE-CD305F0A7DC5" name="GUID-0A3960A4-A62C-46C2-A5FE-CD305F0A7DC5"></a><h4 id="TGDBA-GUID-0A3960A4-A62C-46C2-A5FE-CD305F0A7DC5" class="sect4"><span class="enumeration_section">13.5.2</span>强制完全数据库缓存模式</h4>
                  <div>
                     <p>随着更多内存添加到数据库，缓冲区缓存大小可能会不断增长。在某些情况下，缓冲区高速缓存的大小可能会变得如此之大，以至于整个数据库都可以放入内存中。在执行全表扫描或访问LOB时，将整个数据库缓存在内存中的能力可以极大地提高数据库性能。</p>
                     <p>在<a id="d39363e2454" class="indexterm-anchor"></a>强制完全数据库缓存模式，当数据库的大小小于数据库缓冲区高速缓存大小时，Oracle数据库将整个数据库缓存在内存中。所有数据文件（包括使用SecureFiles的<code class="codeph">NOCACHE</code> LOB和LOBS）在访问时都会加载到缓冲区缓存中。
                     </p>
                     <div class="infoboxnotealso" id="GUID-0A3960A4-A62C-46C2-A5FE-CD305F0A7DC5__GUID-35080397-4120-4643-8485-B53D6D83F9A7">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="../cncpt/memory-architecture.html#CNCPT94675" target="_blank"><span class="italic">Oracle数据库概念</span></a></p>
                           </li>
                           <li>
                              <p><a href="../admin/managing-memory.html#ADMIN14235" target="_blank"><span class="italic">Oracle数据库管理员指南</span></a></p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="TGDBA95405"></a><div class="props_rev_3"><a id="GUID-0E5D6B70-245B-4F24-9C7F-E14D98DD312D" name="GUID-0E5D6B70-245B-4F24-9C7F-E14D98DD312D"></a><h4 id="TGDBA-GUID-0E5D6B70-245B-4F24-9C7F-E14D98DD312D" class="sect4"><span class="enumeration_section">13.5.3</span>确定何时使用强制完全数据库缓存模式</h4>
                  <div>
                     <p>要提高表扫描和LOB数据访问的数据库性能，尤其是对受I / O吞吐量或响应时间限制的工作负载，请考虑使用force full <a id="d39363e2530" class="indexterm-anchor"></a>数据库缓存模式，只要数据库缓冲区缓存的大小大于数据库的大小。
                     </p>
                     <p>在以下情况下，请考虑使用强制完全数据库缓存模式：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>逻辑数据库大小（或实际使用的空间）小于Oracle RAC环境中每个数据库实例的单个缓冲区高速缓存。这也适用于非Oracle RAC数据库。</p>
                        </li>
                        <li>
                           <p>对于Oracle RAC环境中良好分区的工作负载（通过实例访问），逻辑数据库大小小于所有数据库实例的组合缓冲区高速缓存大小的80％。</p>
                        </li>
                        <li>
                           <p>数据库使用SGA_TARGET或MEMORY_TARGET。</p>
                        </li>
                        <li>
                           <p>需要缓存<code class="codeph">NOCACHE</code> LOB。除非使用强制数据库缓存，否则永远不会缓存<code class="codeph">NOCACHE</code> LOB。
                           </p>
                        </li>
                     </ul>
                     <p>对于前三种情况，您应定期监控系统性能，以验证性能数据是否符合您的预期。</p>
                     <p>当一个Oracle RAC数据库实例使用强制完全数据库缓存模式时，Oracle RAC环境中的所有其他数据库实例也将使用强制完全数据库缓存模式。</p>
                     <p>在多租户环境中，强制完整数据库缓存模式适用于整个容器数据库（CDB），包括其所有可插拔数据库（PDB）。</p>
                  </div>
               </div><a id="TGDBA95406"></a><div class="props_rev_3"><a id="GUID-4D8C2837-54BC-4D78-AFF6-5445C450A64E" name="GUID-4D8C2837-54BC-4D78-AFF6-5445C450A64E"></a><h4 id="TGDBA-GUID-4D8C2837-54BC-4D78-AFF6-5445C450A64E" class="sect4"><span class="enumeration_section">13.5.4</span>验证数据库缓存模式</h4>
                  <div>
                     <div class="section">
                        <p>默认情况下，Oracle数据库以默认方式运行<a id="d39363e2614" class="indexterm-anchor"></a>数据库缓存模式。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-4D8C2837-54BC-4D78-AFF6-5445C450A64E__GUID-7739FC36-BE59-487C-9062-F534679233E4">要验证是否已启用强制完全数据库缓存模式：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>查询<code class="codeph">V$DATABASE</code>视图，如下所示：</p><pre class="pre codeblock"><code>从V $ DATABASE中选择FORCE_FULL_DB_CACHING;</code></pre><p>如果查询返回值<code class="codeph">YES</code> ，则在数据库上启用强制完全数据库缓存模式。如果查询返回值<code class="codeph">NO</code> ，则禁用强制完全数据库缓存模式，并且数据库处于默认数据库缓存模式。
                              </p>
                              <div class="infoboxnote" id="GUID-4D8C2837-54BC-4D78-AFF6-5445C450A64E__GUID-5518BB1A-0959-42D6-8DF1-6947FBC05DCA">
                                 <p class="notep1">注意：</p>
                                 <p>要启用强制完全数据库缓存模式，请使用以下<code class="codeph">ALTER DATABASE</code>命令：</p><pre class="pre codeblock"><code>ALTER DATABASE FORCE FULL DATABASE CACHING;</code></pre></div>
                           </li>
                        </ul>
                        <div class="infoboxnotealso" id="GUID-4D8C2837-54BC-4D78-AFF6-5445C450A64E__GUID-4E60638D-2460-4C89-A20B-FD3402A6BD51">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>有关启用和禁用强制完全数据库缓存模式的详细信息，请参见<a href="../admin/managing-memory.html#ADMIN14235" target="_blank"><span class="italic">“Oracle数据库管理员指南”</span></a></p>
                              </li>
                              <li>
                                 <p>有关<code class="codeph">V$DATABASE</code>视图的更多信息，请<a href="../refrn/V-DATABASE.html#REFRN30047" target="_blank"><span class="italic">参见Oracle数据库参考</span></a></p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>