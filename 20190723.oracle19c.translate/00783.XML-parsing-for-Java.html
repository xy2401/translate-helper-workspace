<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <meta name="abstract" content="Extensible Markup Language (XML) parsing for Java is described."></meta>
      <meta name="description" content="Extensible Markup Language (XML) parsing for Java is described."></meta>
      <title>用于Java的XML解析</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Programmer&#39;s Guide"></meta>
      <meta property="og:description" content="Extensible Markup Language (XML) parsing for Java is described."></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Programmer&#39;s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="xml-developers-kit-programmers-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-11T05:58:48-08:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="2001, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96292-01"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="getting-started-with-XDK-for-Java.html" title="Previous" type="text/html"></link>
      <link rel="next" href="using-binary-XML-with-Java.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="XML Developers Kit Programmers Guide"></meta>
    <meta name="dcterms.isVersionOf" content="ADXDK"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="getting-started-with-XDK-for-Java.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="using-binary-XML-with-Java.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">程序员指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="XDK-for-Java.html" property="item" typeof="WebPage"><span property="name">Oracle XML Developer's Kit for Java</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">用于Java的XML解析</li>
            </ol>
            <a id="GUID-33E0EA2B-A08A-462E-86B4-3F944409663D" name="GUID-33E0EA2B-A08A-462E-86B4-3F944409663D"></a><a id="ADXDK975"></a><a id="ADXDK3000"></a>
            
            <h2 id="ADXDK-GUID-33E0EA2B-A08A-462E-86B4-3F944409663D" class="sect2"><span class="enumeration_chapter">12</span>用于Java的XML解析</h2>
         </header>
         <div class="ind">
            <div>
               <p>描述了针对Java的可扩展标记语言（XML）解析。</p>
            </div><a id="ADXDK976"></a><a id="ADXDK19083"></a><div class="props_rev_4"><a id="GUID-4BC9CC77-9343-421D-A5A0-9F073961DC75" name="GUID-4BC9CC77-9343-421D-A5A0-9F073961DC75"></a><h3 id="ADXDK-GUID-4BC9CC77-9343-421D-A5A0-9F073961DC75" class="sect3">XML解析Java简介</h3>
               <div>
                  <p>描述了Java的XML解析。</p>
               </div><a id="ADXDK19084"></a><div class="props_rev_3"><a id="GUID-362910D4-3A78-4174-AE1E-6099AA852254" name="GUID-362910D4-3A78-4174-AE1E-6099AA852254"></a><h4 id="ADXDK-GUID-362910D4-3A78-4174-AE1E-6099AA852254" class="sect4">使用Java解析的先决条件</h4>
                  <div>
                     <p>Oracle XML解析器读取XML文档，并使用文档对象模型（DOM）应用程序编程接口（API）或Simple API for XML（SAX）来访问其内容和结构。您可以在验证或非验证模式下进行解析。</p>
                     <p>本章假定您熟悉这些技术：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="glossary.html#GUID-0969F796-24C8-4A02-B671-B2EE8BD49F5B"><span class="xrefglossterm">文档对象模型（DOM）</span></a> ：XML文档结构的内存中树表示。
                           </p>
                        </li>
                        <li>
                           <p><a href="glossary.html#GUID-6B57591D-3889-4BCD-8598-58ED2DC9E9EE"><span class="xrefglossterm">简单的XML API（SAX）</span></a> ：基于事件的XML解析的标准。
                           </p>
                        </li>
                        <li>
                           <p><a href="glossary.html#GUID-B2E5C8F8-E243-45AB-B95E-9FCECDE2D247"><span class="xrefglossterm">用于XML处理的Java API（JAXP）</span></a> ：用于使用支持DOM和SAX标准的Java应用程序处理XML的标准接口。
                           </p>
                        </li>
                        <li>
                           <p><a href="glossary.html#GUID-F2AC11F4-F0D2-4EFB-B28B-8114CC0D7C38"><span class="xrefglossterm">文档类型定义（DTD）</span></a> ：一组定义XML文档有效结构的规则。
                           </p>
                        </li>
                        <li>
                           <p><a href="glossary.html#GUID-25F8F1D2-58B2-4A3F-B38C-3C2652C9C19C"><span class="xrefglossterm">XML Schema</span></a> ：万维网联盟（W3C）建议，定义XML文档中数据类型的有效结构。
                           </p>
                        </li>
                        <li>
                           <p><a href="glossary.html#GUID-55AB1901-F16B-4FBD-9C2B-7164C71662B0" title="XML文档中的相关元素名称或属性。命名空间语法和用法由W3C建议定义。例如，元素&lt;xsl：apply-templates /&gt;被标识为XSL名称空间的一部分。命名空间在使用之前在XML文档或DTD中声明，使用以下属性语法：xmlns：xsl =" http:="" /="" /www.w3.org="" /tr="" /wd-xs="." =""><span class="xrefglossterm">XML命名空间</span></a> ：用于区分XML文档中的元素和属性名称的机制。
                           </p>
                        </li>
                        <li>
                           <p><a href="glossary.html#GUID-B612EFFA-1150-448C-B2FC-9DC488F970A4" title="一种可扩展标记语言（XML）表示，它使用紧凑的XML模式识别格式。"><span class="xrefglossterm">二进制XML</span></a> ：一种使用紧凑模式感知格式的XML表示，其中可伸缩和不可扩展的DOM都可以保存XML文档。
                           </p>
                        </li>
                     </ul>
                     <p>有关更多信息，请参阅“ <a href="preface.html#GUID-2CD1F6B6-C8EC-42E3-97F2-589AABF9AFFB" title="列出了与此文档相关的Oracle资源。">相关文档</a> ”中的XML资源列表。
                     </p>
                  </div>
               </div><a id="ADXDK19085"></a><div class="props_rev_3"><a id="GUID-B8341D44-3C69-4FDB-8319-6CC1E167DD4E" name="GUID-B8341D44-3C69-4FDB-8319-6CC1E167DD4E"></a><h4 id="ADXDK-GUID-B8341D44-3C69-4FDB-8319-6CC1E167DD4E" class="sect4">用于Java的XML解析的标准和规范</h4>
                  <div>
                     <p>DOM Level 1，Level 2和Level 3规范是W3C Recommendations。</p>
                     <p>有关W3C DOM规范，请参阅<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/adxdk&amp;id=w3_org_domtr" target="_blank">文档对象模型（DOM）技术报告</a> 。
                     </p>
                     <p>SAX可用于1.0版（已弃用）和2.0版。SAX不是W3C规范。见<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/adxdk&amp;id=sax_project_org" target="_blank">SAX项目</a> 。
                     </p>
                     <p>XML命名空间是W3C推荐标准。请参阅<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/adxdk&amp;id=w3_org_rec_xml_names" target="_blank">XML 1.0（第三版）中的命名空间</a> 。
                     </p>
                     <p>JCR 1.0（也称为JSR 170）为应用程序定义了一个标准Java API，以便与内容存储库进行交互。请参阅<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/adxdk&amp;id=jcp_org_jsr_170" target="_blank">JSR 170：Java技术API的内容存储库</a> 。</p>
                     <div class="infoboxnotealso" id="GUID-B8341D44-3C69-4FDB-8319-6CC1E167DD4E__GUID-0B795078-287A-4F95-AE80-C868431A3116">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="../adxdb/index.html" target="_blank"><span><cite>Oracle XML DB开发人员指南</cite></span></a></p>
                     </div>
                     <p>JAXP是一种标准API，支持使用DOM，SAX，XML Schema和可扩展样式表语言转换（XSLT），与处理器实现无关。</p>
                     <div class="infoboxnotealso" id="GUID-B8341D44-3C69-4FDB-8319-6CC1E167DD4E__GUID-23ABA394-4C19-4FD5-8FB7-E8E322177423">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="XDK-standards.html#GUID-795A483B-12AC-4F6D-A606-6BE9DA963F0F" title="A description is given of the Oracle XML Developer&#39;s Kit (XDK) standards.">Oracle XML Developer's Kit Standards</a> ，有关Oracle XML Developer's Kit（XDK）支持的<a href="XDK-standards.html#GUID-795A483B-12AC-4F6D-A606-6BE9DA963F0F" title="描述了Oracle XML Developer&#39;s Kit（XDK）标准。">标准</a>的信息</p>
                     </div>
                  </div>
               </div><a id="ADXDK19086"></a><div class="props_rev_3"><a id="GUID-695138D4-C21C-4467-98FC-7FE71F56116D" name="GUID-695138D4-C21C-4467-98FC-7FE71F56116D"></a><h4 id="ADXDK-GUID-695138D4-C21C-4467-98FC-7FE71F56116D" class="sect4">大型节点处理</h4>
                  <div>
                     <p>DOM流对XML节点的访问由过程语言/结构化查询语言（PL / SQL）和Java API完成。 XML文档中的节点现在可以远远超过64 KB。因此，可以更容易地存储联合图像专家组（JPEG），Word，PDF，富文本格式（RTF）和HTML文档。</p>
                     <div class="infoboxnotealso" id="GUID-695138D4-C21C-4467-98FC-7FE71F56116D__GUID-2E506D5D-0277-4D88-B2DE-C3559E99A68E">
                        <p class="notep1">也可以看看：</p>
                        <p> <a href="../adxdb/Java-DOM-API-for-XMLType.html#ADXDB1150" target="_blank"><span><cite>Oracle XML DB Developer's Guide</cite></span></a> ，了解Java大型节点功能的完整详细信息</p>
                     </div>
                  </div>
               </div><a id="ADXDK19088"></a><a id="ADXDK19089"></a><a id="ADXDK19087"></a><div class="props_rev_3"><a id="GUID-5779A94D-7350-4678-A27E-49C710465744" name="GUID-5779A94D-7350-4678-A27E-49C710465744"></a><h4 id="ADXDK-GUID-5779A94D-7350-4678-A27E-49C710465744" class="sect4">Java中的XML解析：概述</h4>
                  <div>
                     <p><code class="codeph">XMLParser</code>是Java的XML解析器的抽象基类。实例化的解析器调用<code class="codeph">parse()</code>方法来读取XML文档。<code class="codeph">XMLDOMImplementation</code>工厂方法提供了另一种解析二进制XML以创建可伸缩DOM的方法。</p>
                     <p><a href="XML-parsing-for-Java.html#GUID-5779A94D-7350-4678-A27E-49C710465744__I1041301">图12-1</a>显示了使用<code class="codeph">XMLParser</code>的基本解析过程。该图不适用于<code class="codeph">XMLDOMImplementation()</code> 。
                     </p>
                     <div class="figure" id="GUID-5779A94D-7350-4678-A27E-49C710465744__I1041301">
                        <p class="titleinfigure">图12-1 XML解析器进程</p><img src="img/adxdk040.gif" width="496" alt="下面是图12-1的描述" title="下面是图12-1的描述" longdesc="img_text/adxdk040.html"><br><a href="img_text/adxdk040.html">“图12-1 XML分析器过程”的描述</a></div>
                     <!-- class="figure" -->
                     <p>这些API为Java应用程序提供了对已解析的XML文档的访问：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>DOM API</p>
                           <p>DOM API解析XML文档并在内存中构建文档的树表示。要使用DOM API进行解析，请使用<code class="codeph">DOMParser</code>对象或<code class="codeph">XMLDOMImplementation</code>接口工厂方法来创建可插入的可伸缩DOM（SDOM）。
                           </p>
                        </li>
                        <li>
                           <p>SAX API</p>
                           <p>SAX API将XML文档作为事件流处理，这意味着程序无法访问文档中的随机位置。要使用SAX API进行解析，请使用<code class="codeph">SAXParser</code>对象。
                           </p>
                        </li>
                        <li>
                           <p>JAXP</p>
                           <p>JAXP是一种特定于Java的API，支持DOM，SAX和可扩展样式表语言（XSL）。要使用JAXP进行解析，请使用<code class="codeph">DocumentBuilder</code>或<code class="codeph">SAXParser</code>对象。
                           </p>
                        </li>
                     </ul>
                     <p>后续主题使用<a href="XML-parsing-for-Java.html#GUID-5779A94D-7350-4678-A27E-49C710465744__CCHHDCHF">示例12-1中</a>的示例XML文档来显示DOM，SAX和JAXP之间的差异。</p>
                     <div class="example" id="GUID-5779A94D-7350-4678-A27E-49C710465744__CCHHDCHF">
                        <p class="titleinexample">例12-1示例XML文档</p><pre class="oac_no_warn" dir="ltr">&lt;？xml版本=“1.0”？&gt; &lt;EMPLIST&gt; &lt;EMP&gt; &lt;ENAME&gt; MARY &lt;/ ENAME&gt; &lt;/ EMP&gt; &lt;EMP&gt; &lt;ENAME&gt; SCOTT &lt;/ ENAME&gt; &lt;/ EMP&gt; &lt;/ EMPLIST&gt;</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="ADXDK19090"></a><div class="props_rev_3"><a id="GUID-972BAACB-5EC4-402B-98AA-680E2E783654" name="GUID-972BAACB-5EC4-402B-98AA-680E2E783654"></a><h4 id="ADXDK-GUID-972BAACB-5EC4-402B-98AA-680E2E783654" class="sect4">XML解析中的DOM</h4>
                  <div>
                     <p>DOM API构建XML文档的内存树表示。DOM API提供了导航和处理树的类和方法。</p>
                     <p>例如，给定<a href="XML-parsing-for-Java.html#GUID-5779A94D-7350-4678-A27E-49C710465744__CCHHDCHF">示例12-1中</a>描述的文档，DOM API将创建<a href="XML-parsing-for-Java.html#GUID-31A81B8C-193E-4CD1-B44D-75E425CB9C6A__CCHDFAJF">图12-2</a>中<a href="XML-parsing-for-Java.html#GUID-31A81B8C-193E-4CD1-B44D-75E425CB9C6A__CCHDFAJF">所示</a>的内存树。
                     </p>
                     <p>DOM API的重要方面是：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>DOM API提供了熟悉的对象树结构，使其比SAX API更易于使用。</p>
                        </li>
                        <li>
                           <p>树可以被操纵。例如，可以重新排序和重命名元素，并且可以添加和删除元素和属性。</p>
                        </li>
                        <li>
                           <p>交互式应用程序可以将树存储在内存中，用户可以在其中访问和操作它。</p>
                        </li>
                        <li>
                           <p>XKD包含支持XPath的DOM API扩展。（虽然DOM标准不支持XPath，但大多数XPath实现都使用DOM。）</p>
                        </li>
                        <li>
                           <p>XDK支持SDOM。有关详细信息，请参阅<a href="XML-parsing-for-Java.html#GUID-E2FFE494-A2A8-455E-871E-0E287A956016" title="XDK支持可插拔，可扩展的DOM（SDOM）。这种支持减轻了内存效率低下，可扩展性有限以及缺乏对DOM配置的控制等问题。使用XMLDOMImplementation类主要支持SDOM创建和配置。">SDOM</a> 。</p>
                        </li>
                     </ul>
                  </div><a id="ADXDK19091"></a><div class="props_rev_3"><a id="GUID-DF103B42-D957-4C1E-B433-7C81C0D1EC37" name="GUID-DF103B42-D957-4C1E-B433-7C81C0D1EC37"></a><h5 id="ADXDK-GUID-DF103B42-D957-4C1E-B433-7C81C0D1EC37" class="sect5">DOM创作</h5>
                     <div>
                        <p>在XDK for Java中，有三种方法可以创建DOM：使用<code class="codeph">DOMParser</code>解析文档，使用<code class="codeph">XMLDOMImplementation</code>工厂方法（创建可伸缩的DOM），或使用<code class="codeph">XMLDocument</code>构造函数（不常见）。
                        </p>
                     </div>
                  </div>
               </div><a id="ADXDK3400"></a><div class="props_rev_3"><a id="GUID-E2FFE494-A2A8-455E-871E-0E287A956016" name="GUID-E2FFE494-A2A8-455E-871E-0E287A956016"></a><h4 id="ADXDK-GUID-E2FFE494-A2A8-455E-871E-0E287A956016" class="sect4">SDOM</h4>
                  <div>
                     <p>XDK支持可插拔，可扩展的DOM（SDOM）。这种支持减轻了内存效率低下，可扩展性有限以及缺乏对DOM配置的控制等问题。使用<code class="codeph">XMLDOMImplementation</code>类主要支持SDOM创建和配置。
                     </p>
                     <p>SDOM的重要方面是：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>SDOM可以在其现有形式中使用插件外部XML。</p>
                           <p>插件XML数据可以采用不同的形式 - 二进制XML， <code class="codeph">XMLType</code> ，第三方DOM等。SDOM无需在内部表示中复制外部XML。SDOM是通过<code class="codeph">Reader</code>和<code class="codeph">InfosetWriter</code>抽象接口在插件XML数据之上创建的。
                           </p>
                        </li>
                        <li>
                           <p>SDOM具有瞬态节点。</p>
                           <p>仅在访问节点时才会创建节点，如果未使用节点，则会释放节点。</p>
                        </li>
                        <li>
                           <p>SDOM可以使用二进制XML作为输入和输出。</p>
                           <p>SDOM可以通过两种方式与数据交互：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>通过抽象的<code class="codeph">InfosetReader</code>和<code class="codeph">InfosetWriter</code>接口。
                                 </p>
                                 <p>要读取和写入<code class="codeph">BinXML</code>数据，用户可以使用<code class="codeph">InfosetReader</code>和<code class="codeph">InfosetWriter</code>的<code class="codeph">BinXML</code>实现。要读写其他形式的XML信息集，用户可以使用自己的实现。
                                 </p>
                              </li>
                              <li>
                                 <p>通过为<code class="codeph">BinXMLStream</code>实现<code class="codeph">InfosetReader</code>和<code class="codeph">InfosetWriter</code>适配器。
                                 </p>
                              </li>
                           </ul>
                        </li>
                     </ul>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="using-binary-XML-with-Java.html#GUID-38D2C558-108C-449A-A9CD-BC2DAD163D5C" title="这里的主题解释了如何在Java中使用二进制XML。">在Java中使用二进制XML</a></li>
                        </ul>
                     </div>
                  </div>
                  <a id="ADXDK19092"></a><div class="props_rev_3"><a id="GUID-FDAE7477-75D4-439C-9116-45281C11406A" name="GUID-FDAE7477-75D4-439C-9116-45281C11406A"></a><h5 id="ADXDK-GUID-FDAE7477-75D4-439C-9116-45281C11406A" class="sect5">可插拔DOM支持</h5>
                     <div>
                        <p>可插入DOM允许您从数据层拆分DOM API。通过<code class="codeph">InfosetReader</code>和<code class="codeph">InfosetWriter</code>接口将DOM API与数据分开。使用可插入DOM，您可以轻松地将XML数据从一个处理器移动到另一个处理器。
                        </p>
                        <p>DOM API在数据之上包括统一的标准API，以支持节点访问，导航，更新过程和搜索功能。</p>
                     </div>
                     <div>
                        <div class="relinfo">
                           <p><strong>相关话题</strong></p>
                           <ul>
                              <li><a href="XML-parsing-for-Java.html#GUID-0208270A-89F0-4174-9EB5-3C2960F1E8B3" title="描述了如何使用SDOM。">使用SDOM</a></li>
                           </ul>
                        </div>
                     </div>
                     
                  </div><a id="ADXDK19093"></a><div class="props_rev_3"><a id="GUID-3C68C8C0-D78B-4CBD-AC9D-CCC777CA03CA" name="GUID-3C68C8C0-D78B-4CBD-AC9D-CCC777CA03CA"></a><h5 id="ADXDK-GUID-3C68C8C0-D78B-4CBD-AC9D-CCC777CA03CA" class="sect5">懒惰物化</h5>
                     <div>
                        <p>使用延迟实现，XDK仅创建被访问的节点，并从内存中释放未使用的节点。应用程序可以处理非常大的XML文档，并提高可伸缩性。</p>
                     </div>
                     <div>
                        <div class="relinfo">
                           <p><strong>相关话题</strong></p>
                           <ul>
                              <li><a href="XML-parsing-for-Java.html#GUID-D2C5A5C3-9753-4A27-A8FF-A36541E83C3D" title="使用延迟实现，您可以插入一个空DOM，它可以在需要时提取数据，并在不再需要时释放（取消引用）节点。SDOM支持手动或自动节点解除引用。">使用Lazy Materialization</a></li>
                           </ul>
                        </div>
                     </div>
                     
                  </div><a id="ADXDK19094"></a><div class="props_rev_3"><a id="GUID-7088780C-4754-4732-B097-35CC02906FEC" name="GUID-7088780C-4754-4732-B097-35CC02906FEC"></a><h5 id="ADXDK-GUID-7088780C-4754-4732-B097-35CC02906FEC" class="sect5">可配置的DOM设置</h5>
                     <div>
                        <p>可以制作DOM配置以适应不同的应用。您可以使用不同的访问模式配置DOM，例如只读，流式传输，瞬态更新和卷影复制，从而在应用程序中实现最大的内存使用和性能。</p>
                     </div>
                     <div>
                        <div class="relinfo">
                           <p><strong>相关话题</strong></p>
                           <ul>
                              <li><a href="XML-parsing-for-Java.html#GUID-C5348B7D-15FD-4374-8D61-C913DEBA3EBC" title="使用类XMLDOMImplementation创建DOM时，可以使用方法setAttribute为不同的应用程序配置DOM并实现最高效率。">使用可配置的DOM设置</a></li>
                           </ul>
                        </div>
                     </div>
                     
                  </div><a id="ADXDK173"></a><div class="props_rev_3"><a id="GUID-4A444B50-5AE6-4524-B2A6-89E60630BE0F" name="GUID-4A444B50-5AE6-4524-B2A6-89E60630BE0F"></a><h5 id="ADXDK-GUID-4A444B50-5AE6-4524-B2A6-89E60630BE0F" class="sect5">DOM支持Fast Infoset</h5>
                     <div>
                        <p>由Oracle开发的Fast Infoset是一种紧凑的二进制XML格式，代表XML Infoset。该格式已成为ITU-T SG 17和ISO / IEC JTC1 SC6的国际标准。XML Infoset的Fast Infoset表示在Java XML和Web Service社区中很流行。</p>
                        <p>与其他格式相比，Fast Infoset具有以下优势：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>它比XML文本更紧凑，分析速度更快，序列化更好。</p>
                           </li>
                           <li>
                              <p>它比解析XML文本更快地编码和解码，Fast Infoset文档通常比相应的XML文本小20％到60％。</p>
                           </li>
                           <li>
                              <p>它在性能和压缩比方面领先于其他二进制XML格式，并以更平衡的方式处理小到大的文档。</p>
                           </li>
                        </ul>
                        <p>SDOM是支持可伸缩性的XDK DOM配置。它构建在序列化二进制数据之上，为XPath和XSLT等应用程序提供DOM API。 SDOM有一个开放的插件架构，通过抽象的API InfosetReader读取二进制数据。InfosetReader API允许SDOM解码前进的二进制数据，记住节点的起始位置，并从那里搜索要解码的位置。此支持使SDOM可以释放未使用的节点，并在需要时从二进制数据中重新创建这些节点。当二进制数据存储在外部时，例如存储在文件或BLOB中，SDOM具有高度可扩展性。</p>
                     </div>
                     <div>
                        <div class="relinfo">
                           <p><strong>相关话题</strong></p>
                           <ul>
                              <li><a href="XML-parsing-for-Java.html#GUID-6D67902A-AECA-4DF2-AAA5-C11C1E5E9BD2" title="Fast Infoset到XDK / J模型允许您在使用Java中的XML内容时使用Fast Infoset技术。">使用带有SDOM的快速信息集</a></li>
                           </ul>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="ADXDK19096"></a><a id="ADXDK19095"></a><div class="props_rev_3"><a id="GUID-31A81B8C-193E-4CD1-B44D-75E425CB9C6A" name="GUID-31A81B8C-193E-4CD1-B44D-75E425CB9C6A"></a><h4 id="ADXDK-GUID-31A81B8C-193E-4CD1-B44D-75E425CB9C6A" class="sect4">XML解析器中的SAX</h4>
                  <div>
                     <p>与DOM不同，SAX是基于事件的，因此SAX API不构建输入文档的内存树表示。SAX API逐个元素处理输入文档，并可以将事件和重要数据报告给应用程序中的回调方法。</p>
                     <p>例如，给定<a href="XML-parsing-for-Java.html#GUID-5779A94D-7350-4678-A27E-49C710465744__CCHHDCHF">示例12-1中</a>描述的文档，SAX API将其解析为<a href="XML-parsing-for-Java.html#GUID-31A81B8C-193E-4CD1-B44D-75E425CB9C6A__CCHDFAJF">图12-2中</a>所示的一系列线性事件。
                     </p>
                     <p>SAX API的重要方面是：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>它对于搜索操作和不需要操作XML树的其他程序很有用。</p>
                        </li>
                        <li>
                           <p>它不会占用大量内存资源。</p>
                        </li>
                        <li>
                           <p>从数据库中检索XML文档时，它比DOM快。</p>
                        </li>
                     </ul>
                     <div class="figure" id="GUID-31A81B8C-193E-4CD1-B44D-75E425CB9C6A__CCHDFAJF">
                        <p class="titleinfigure">图12-2比较DOM（基于树）和SAX（基于事件）API</p><img src="img/adxdk041.gif" width="575" alt="下面是图12-2的描述" title="下面是图12-2的描述" longdesc="img_text/adxdk041.html"><br><a href="img_text/adxdk041.html">“图12-2比较DOM（基于树）和SAX（基于事件）API”</a></div>
                     <!-- class="figure" -->
                  </div>
               </div><a id="ADXDK19097"></a><div class="props_rev_3"><a id="GUID-706DD778-4C97-47CC-A7A5-DB9DBFD5C4C8" name="GUID-706DD778-4C97-47CC-A7A5-DB9DBFD5C4C8"></a><h4 id="ADXDK-GUID-706DD778-4C97-47CC-A7A5-DB9DBFD5C4C8" class="sect4">XML解析器中的JAXP</h4>
                  <div>
                     <p>JAXP允许您插入SAX或DOM解析器的实现。XDK提供的SAX和DOM API是JAXP支持的特定于供应商的实现的示例。 JAXP的主要优点是它可以让您编写可互操作的应用程序。</p>
                     <p>使用通过JAXP提供的功能的应用程序可以非常轻松地切换实现。</p>
                     <p>JAXP的主要缺点是它运行速度比特定于供应商的API慢。此外，JAXP缺少Oracle特定API提供的一些功能。通过JAXP扩展机制可以获得某些特定于Oracle的功能，但使用这些扩展的应用程序会失去切换实现的灵活性。</p>
                  </div>
               </div><a id="ADXDK19099"></a><a id="ADXDK19100"></a><a id="ADXDK19098"></a><div class="props_rev_3"><a id="GUID-8FEA89F2-CAA9-407D-8932-ADE6243ED31E" name="GUID-8FEA89F2-CAA9-407D-8932-ADE6243ED31E"></a><h4 id="ADXDK-GUID-8FEA89F2-CAA9-407D-8932-ADE6243ED31E" class="sect4">XML解析器中的命名空间支持</h4>
                  <div>
                     <p>命名空间可以帮助您避免XML文档中的元素或属性之间的名称冲突。</p>
                     <p><a href="XML-parsing-for-Java.html#GUID-8FEA89F2-CAA9-407D-8932-ADE6243ED31E__CCHBFJHA">例12-2</a>是一个XML文档，它使用公司地址和员工地址的<code class="codeph">&lt;address&gt;</code>标记。XML处理器无法区分公司地址和员工地址。
                     </p>
                     <p><a href="XML-parsing-for-Java.html#GUID-8FEA89F2-CAA9-407D-8932-ADE6243ED31E__CCHDECGB">示例12-3</a>是一个XML文档，它使用这些命名空间来区分公司和员工<code class="codeph">&lt;address&gt;</code>标记：</p><pre class="oac_no_warn" dir="ltr">http://www.oracle.com/employee http://www.oracle.com/company</pre><p><a href="XML-parsing-for-Java.html#GUID-8FEA89F2-CAA9-407D-8932-ADE6243ED31E__CCHDECGB">示例12-3</a>将<code class="codeph">com</code>前缀与第一个名称空间相关联，将<code class="codeph">emp</code>前缀与第二个名称空间相关联。
                     </p>
                     <p>解析使用命名空间的文档时，记住这些术语会很有帮助：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><span class="bold">名称空间URI</span>是分配给<code class="codeph">xmlns</code>的URI。在<a href="XML-parsing-for-Java.html#GUID-8FEA89F2-CAA9-407D-8932-ADE6243ED31E__CCHDECGB">例12-3中</a> ， <code class="codeph">http://www.oracle.com/employee</code>和<code class="codeph">http://www.oracle.com/company</code>是名称空间URI。</p>
                        </li>
                        <li>
                           <p><span class="bold">名称空间前缀</span>是使用<code class="codeph">xmlns</code>声明的名称空间标识符。在<a href="XML-parsing-for-Java.html#GUID-8FEA89F2-CAA9-407D-8932-ADE6243ED31E__CCHDECGB">例12-3中</a> ， <code class="codeph">emp</code>和<code class="codeph">com</code>是名称空间前缀。
                           </p>
                        </li>
                        <li>
                           <p><span class="bold">本地名称</span>是没有名称空间前缀的元素或属性的名称。在<a href="XML-parsing-for-Java.html#GUID-8FEA89F2-CAA9-407D-8932-ADE6243ED31E__CCHDECGB">示例12-3中</a> ， <code class="codeph">employee</code>和<code class="codeph">company</code>是本地名称。
                           </p>
                        </li>
                        <li>
                           <p><span class="bold">限定名称</span>是本地名称加前缀。在<a href="XML-parsing-for-Java.html#GUID-8FEA89F2-CAA9-407D-8932-ADE6243ED31E__CCHDECGB">例12-3中</a> ， <code class="codeph">emp:employee</code>和<code class="codeph">com:company</code>是限定名。
                           </p>
                        </li>
                        <li>
                           <p><span class="bold">扩展名称</span>是将名称空间URI替换为名称空间前缀的结果。在<a href="XML-parsing-for-Java.html#GUID-8FEA89F2-CAA9-407D-8932-ADE6243ED31E__CCHDECGB">例12-3中</a> ， <code class="codeph">http://www.oracle.com/employee:employee</code> <code class="codeph">http://www.oracle.com/company:company</code> <a href="XML-parsing-for-Java.html#GUID-8FEA89F2-CAA9-407D-8932-ADE6243ED31E__CCHDECGB">employee</a>和<code class="codeph">http://www.oracle.com/company:company</code>是扩展元素名称。
                           </p>
                        </li>
                     </ul>
                     <div class="example" id="GUID-8FEA89F2-CAA9-407D-8932-ADE6243ED31E__CCHBFJHA">
                        <p class="titleinexample">示例12-2没有命名空间的示例XML文档</p><pre class="oac_no_warn" dir="ltr">&lt;？xml版本='1.0'？&gt; &lt;地址列表&gt; <span class="bold">&lt;公司&gt;</span> <span class="bold">&lt;地址&gt;</span> 500 Oracle Parkway，Redwood Shores，CA 94065 <span class="bold">&lt;/ address&gt;</span> <span class="bold">&lt;/ company&gt;</span> &lt;！ -  ...  - &gt; <span class="bold">&lt;employee&gt;</span> &lt;lastname&gt; King &lt;/ lastname&gt; <span class="bold">&lt;address &gt;</span> 3290 W Big Beaver Troy，MI 48084 <span class="bold">&lt;/ address&gt;</span> <span class="bold">&lt;/ employee&gt;</span> &lt;！ -  ...  - &gt; &lt;/ addresslist&gt;</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-8FEA89F2-CAA9-407D-8932-ADE6243ED31E__CCHDECGB">
                        <p class="titleinexample">示例12-3带有命名空间的示例XML文档</p><pre class="oac_no_warn" dir="ltr">&lt;？xml版本='1.0'？&gt; &lt;addresslist&gt; &lt;！ -  ...  - &gt; &lt;com：company <span class="bold">xmlns：com =“http://www.oracle.com/company”</span> &gt; <span class="bold">&lt;com：address&gt;</span> 500 Oracle Parkway，Redwood Shores，CA 94065 <span class="bold">&lt;/ com：address&gt;</span> &lt;/ com：company&gt; &lt;！ -  ...  - &gt; &lt;emp：employee <span class="bold">xmlns：emp =“http://www.oracle.com/employee”</span> &gt; &lt;emp：lastname&gt; King &lt;/ emp：lastname&gt; <span class="bold">&lt;emp：address&gt;</span> 3290 W Big Beaver Troy，MI 48084 <span class="bold">&lt;/ emp：address&gt;</span> &lt;/ emp：employee&gt;</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="ADXDK19102"></a><a id="ADXDK19101"></a><div class="props_rev_3"><a id="GUID-2DA498AD-B22B-4C66-AE90-5EB37EB105E7" name="GUID-2DA498AD-B22B-4C66-AE90-5EB37EB105E7"></a><h4 id="ADXDK-GUID-2DA498AD-B22B-4C66-AE90-5EB37EB105E7" class="sect4">XML解析器中的验证</h4>
                  <div>
                     <p>要解析XML文档，请调用<code class="codeph">parse()</code>方法。通常，您将调用与<code class="codeph">parse()</code>方法关联的初始化和终止方法。
                     </p>
                     <p>解析器模式可以是验证或非验证。在验证模式下，解析器确定文档是否符合指定的DTD或XML模式。在非验证模式下，解析器仅检查格式良好。要设置解析器模式，请调用<code class="codeph">setValidationMode()</code>定义的<code class="codeph">setValidationMode()</code>方法<code class="codeph">oracle.xml.parser.v2.XMLParser</code> 。
                     </p>
                     <p><a href="XML-parsing-for-Java.html#GUID-2DA498AD-B22B-4C66-AE90-5EB37EB105E7__G1043218" title="此表显示可在XDK解析器中使用的setValidationMode（）标志。模式名称，Java中的模式值和描述是列。">表12-1</a>显示了可以在XDK解析器中使用的<code class="codeph">setValidationMode()</code>标志。
                     </p>
                     <div class="tblformalwide" id="GUID-2DA498AD-B22B-4C66-AE90-5EB37EB105E7__G1043218">
                        <p class="titleintable">表12-1 Java验证模式的XML解析器</p>
                        <table cellpadding="4" cellspacing="0" class="FormalWide" title="用于Java验证模式的XML解析器" width="100%" border="1" summary="This table shows the setValidationMode() flags that you can use in the XDK parser. Name of Mode, Mode Value in Java, and Description are the columns." frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="21%" id="d35651e1958">名称</th>
                                 <th align="left" valign="bottom" width="27%" id="d35651e1961">值</th>
                                 <th align="left" valign="bottom" width="52%" id="d35651e1964">XML解析器。 。 。</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="21%" id="d35651e1969" headers="d35651e1958 ">
                                    <p>非验证模式</p>
                                 </td>
                                 <td align="left" valign="top" width="27%" headers="d35651e1969 d35651e1961 ">
                                    <p><code class="codeph">非验证</code></p>
                                 </td>
                                 <td align="left" valign="top" width="52%" headers="d35651e1969 d35651e1964 ">
                                    <p>验证XML格式正确并解析数据。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="21%" id="d35651e1980" headers="d35651e1958 ">
                                    <p>DTD验证模式</p>
                                 </td>
                                 <td align="left" valign="top" width="27%" headers="d35651e1980 d35651e1961 ">
                                    <p><code class="codeph">DTD_VALIDATION</code></p>
                                 </td>
                                 <td align="left" valign="top" width="52%" headers="d35651e1980 d35651e1964 ">
                                    <p>验证XML格式正确并根据DTD验证XML数据。 DTD中定义的DTD <code class="codeph">&lt;!DOCTYPE&gt;</code>声明必须相对于输入XML文档的位置。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="21%" id="d35651e1994" headers="d35651e1958 ">
                                    <p>架构验证模式</p>
                                 </td>
                                 <td align="left" valign="top" width="27%" headers="d35651e1994 d35651e1961 ">
                                    <p><code class="codeph">SCHEMA_VALIDATION</code></p>
                                 </td>
                                 <td align="left" valign="top" width="52%" headers="d35651e1994 d35651e1964 ">
                                    <p>根据为文档指定的XML模式验证XML文档。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="21%" id="d35651e2005" headers="d35651e1958 ">
                                    <p>LAX验证模式</p>
                                 </td>
                                 <td align="left" valign="top" width="27%" headers="d35651e2005 d35651e1961 ">
                                    <p><code class="codeph">SCHEMA_LAX_VALIDATION</code></p>
                                 </td>
                                 <td align="left" valign="top" width="52%" headers="d35651e2005 d35651e1964 ">
                                    <p>尝试验证部分或全部实例文档是否可以找到模式定义。如果找不到定义，则不会引发错误。请参阅<code class="codeph">schema</code>目录中的示例程序<code class="codeph">XSDLax.java</code> 。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="21%" id="d35651e2022" headers="d35651e1958 ">
                                    <p>严格的验证模式</p>
                                 </td>
                                 <td align="left" valign="top" width="27%" headers="d35651e2022 d35651e1961 ">
                                    <p><code class="codeph">SCHEMA_STRICT_VALIDATION</code></p>
                                 </td>
                                 <td align="left" valign="top" width="52%" headers="d35651e2022 d35651e1964 ">
                                    <p>尝试验证整个实例文档，如果无法找到模式定义或实例不符合定义，则会引发错误。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="21%" id="d35651e2033" headers="d35651e1958 ">
                                    <p>部分验证模式</p>
                                 </td>
                                 <td align="left" valign="top" width="27%" headers="d35651e2033 d35651e1961 ">
                                    <p><code class="codeph">PARTIAL_VALIDATION</code></p>
                                 </td>
                                 <td align="left" valign="top" width="52%" headers="d35651e2033 d35651e1964 ">
                                    <p>根据DTD验证全部或部分输入XML文档（如果存在）。如果DTD不存在，则解析器设置为非验证模式。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="21%" id="d35651e2044" headers="d35651e1958 ">
                                    <p>自动验证模式</p>
                                 </td>
                                 <td align="left" valign="top" width="27%" headers="d35651e2044 d35651e1961 ">
                                    <p><code class="codeph">AUTO_VALIDATION</code></p>
                                 </td>
                                 <td align="left" valign="top" width="52%" headers="d35651e2044 d35651e1964 ">
                                    <p>根据DTD或XML模式（如果存在）验证全部或部分输入XML文档。如果两者都不存在，则解析器设置为非验证模式。</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <p>除了使用<code class="codeph">setValidationMode()</code>设置验证模式之外，还可以使用<code class="codeph">oracle.xml.parser.schema.XSDBuilder</code>类用于构建XML模式，然后通过调用<code class="codeph">XMLParser.setXMLSchema()</code>方法配置解析器以使用它。在这种情况下，XML解析器会自动将验证模式设置为<code class="codeph">SCHEMA_STRICT_VALIDATION</code>并忽略<code class="codeph">schemaLocation</code>和<code class="codeph">noNamespaceSchemaLocation</code>属性。您还可以将验证模式更改为<code class="codeph">SCHEMA_LAX_VALIDATION</code> 。 <code class="codeph">XMLParser.setDoctype()</code>方法是DTD的并行方法，但与<code class="codeph">setXMLSchema()</code>不同，它不会改变验证模式。
                     </p>
                     <div class="infoboxnotealso" id="GUID-2DA498AD-B22B-4C66-AE90-5EB37EB105E7__GUID-EBD33428-9D47-49D4-99C1-4F3FDE7A16A0">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="using-XML-schema-processor-for-Java.html#GUID-F41C7DA2-A3DF-463B-A08C-24E8F0621450" title="这里的主题介绍了如何使用Java的可扩展标记语言（XML）模式处理器。">使用XML Schema Processor for Java</a>来了解验证</p>
                           </li>
                           <li>
                              <p><a href="../jaxml/index.html" target="_blank"><span><cite>Oracle Database XML Java API参考</cite></span></a> ，了解<code class="codeph">XMLParser</code>和<code class="codeph">XSDBuilder</code>类</p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="ADXDK19104"></a><a id="ADXDK19103"></a><div class="props_rev_3"><a id="GUID-644542C5-973E-4CF6-ABCE-85985A34DCAD" name="GUID-644542C5-973E-4CF6-ABCE-85985A34DCAD"></a><h4 id="ADXDK-GUID-644542C5-973E-4CF6-ABCE-85985A34DCAD" class="sect4">XML解析器中的压缩</h4>
                  <div>
                     <p>您可以使用XML解析器中实现的XML压缩器来压缩和解压缩XML文档。压缩算法基于对XML标记进行标记。</p>
                     <p>假设任何XML文档都会重复某些标记，因此对这些标记进行标记会产生相当大的压缩。压缩程度取决于文档类型：标记越大，文本内容越少，压缩越好。</p>
                     <p>Oracle XML解析器从内存中的DOM树或从XML文档生成的SAX事件生成二进制压缩输出。<a href="XML-parsing-for-Java.html#GUID-644542C5-973E-4CF6-ABCE-85985A34DCAD__CCHHGEDF" title="此表描述了使用DOM和SAX API进行压缩之间的差异。">表12-2</a>介绍了两种类型的压缩。
                     </p>
                     <div class="tblformalwide" id="GUID-644542C5-973E-4CF6-ABCE-85985A34DCAD__CCHHGEDF">
                        <p class="titleintable">表12-2使用DOM和SAX的XML压缩</p>
                        <table cellpadding="4" cellspacing="0" class="FormalWide" title="使用DOM和SAX进行XML压缩" width="100%" border="1" summary="This table describes differences between compression with the DOM and SAX APIs." frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="13%" id="d35651e2208">类型</th>
                                 <th align="left" valign="bottom" width="40%" id="d35651e2211">描述</th>
                                 <th align="left" valign="bottom" width="47%" id="d35651e2214">压缩API</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="13%" id="d35651e2219" headers="d35651e2208 ">
                                    <p>基于DOM</p>
                                 </td>
                                 <td align="left" valign="top" width="40%" headers="d35651e2219 d35651e2211 ">
                                    <p>目标是在不丢失DOM树的结构和层次信息的情况下减小XML文档的大小。解析器序列化内存中的DOM树，对应于解析的XML文档，并生成压缩的XML输出流。序列化流在回读时重新生成DOM树。</p>
                                 </td>
                                 <td align="left" valign="top" width="47%" headers="d35651e2219 d35651e2214 ">
                                    <p>使用<code class="codeph">writeExternal()</code>方法生成压缩XML，使用<code class="codeph">readExternal()</code>方法重构它。这些方法位于<code class="codeph">oracle.xml.parser.v2.XMLDocument</code>类。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="13%" id="d35651e2238" headers="d35651e2208 ">
                                    <p>基于SAX</p>
                                 </td>
                                 <td align="left" valign="top" width="40%" headers="d35651e2238 d35651e2211 ">
                                    <p>SAX解析器在分析XML文件时生成压缩流。SAX解析器生成的SAX事件由SAX压缩实用程序处理，该实用程序生成压缩二进制流。当回读二进制流时，生成SAX事件。</p>
                                 </td>
                                 <td align="left" valign="top" width="47%" headers="d35651e2238 d35651e2214 ">
                                    <p>要生成压缩XML，请实例化<code class="codeph">oracle.xml.comp.CXMLHandlerBase</code>通过将输出流传CXMLHandlerBase</code>构造函数。将对象传递给<code class="codeph">SAXParser.setContentHandler()</code> ，然后执行<code class="codeph">parse()</code>方法。使用<code class="codeph">oracle.xml.comp.CXMLParser</code>类解压缩XML。</p>
                                    <p><span class="bold">注意：</span> <code class="codeph">CXMLHandlerBase</code>实现了SAX 1.0和2.0，但由于不推荐使用1.0，Oracle建议您使用2.0 API。</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <p>从DOM和SAX生成的压缩流是兼容的;也就是说，您可以使用从SAX生成的压缩流来生成DOM树，反之亦然。与一般的XML文档一样，您可以将压缩的XML数据输出存储在数据库中作为<code class="codeph">BLOB</code>数据项。
                     </p>
                     <p>当程序解析大型XML文档并在内存中创建DOM树时，它可能会影响性能。您可以通过序列化DOM树将XML文档压缩为二进制流。您可以重新生成DOM树，而无需验证压缩流中的XML数据。您可以将压缩流视为序列化流，但流中的数据比Java默认序列化实现的压缩更受控制和管理。</p>
                     <div class="infoboxnote" id="GUID-644542C5-973E-4CF6-ABCE-85985A34DCAD__GUID-5883F728-AE8F-410F-9ECE-E727B29DBAB1">
                        <p class="notep1">注意：</p>
                        <p>Oracle Text无法搜索压缩的XML文档。减压会降低性能。如果要在客户端和服务器之间传输文件，则可以更轻松地进行超文本传输协议（HTTP）压缩。</p>
                     </div>
                  </div>
               </div>
            </div><a id="ADXDK977"></a><a id="ADXDK19105"></a><div class="props_rev_3"><a id="GUID-800D5A59-4AAC-458D-ACAC-1CF617B88CE2" name="GUID-800D5A59-4AAC-458D-ACAC-1CF617B88CE2"></a><h3 id="ADXDK-GUID-800D5A59-4AAC-458D-ACAC-1CF617B88CE2" class="sect3">使用XML Parsing for Java：概述</h3>
               <div>
                  <p>任何XML开发的基本组件都是XML解析。Java的XML解析是一个独立的XML组件，它解析XML文档（也可能是一个独立的DTD或XML模式），以便您的程序可以处理它。</p>
                  <div class="section">
                     <div class="infoboxnote" id="GUID-800D5A59-4AAC-458D-ACAC-1CF617B88CE2__GUID-07DFBA87-59AA-4B2F-A14D-6933592CE1F2">
                        <p class="notep1">注意：</p>
                        <p>您可以将解析器与任何受支持的Java虚拟机（JVM）一起使用。使用Oracle 9i或更高版本，您可以将解析器加载到数据库中并使用内部Oracle JVM。对于其他数据库版本，请在外部JVM中运行解析器并通过JDBC连接到数据库。</p>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div><a id="ADXDK19107"></a><a id="ADXDK19106"></a><div class="props_rev_3"><a id="GUID-C9FB63BA-709F-49AD-922F-29F9E712974E" name="GUID-C9FB63BA-709F-49AD-922F-29F9E712974E"></a><h4 id="ADXDK-GUID-C9FB63BA-709F-49AD-922F-29F9E712974E" class="sect4">使用XML Parser for Java：基本过程</h4>
                  <div>
                     <p>描述了使用XML Parser for Java的基本过程。</p>
                     <p><a href="XML-parsing-for-Java.html#GUID-C9FB63BA-709F-49AD-922F-29F9E712974E__I1038080">图12-3</a>显示了如何在典型的XML处理应用程序中使用XML解析器。
                     </p>
                     <div class="figure" id="GUID-C9FB63BA-709F-49AD-922F-29F9E712974E__I1038080">
                        <p class="titleinfigure">图12-3 Java的XML解析器</p><img src="img/adxdk002.gif" width="295" alt="下面是图12-3的描述" title="下面是图12-3的描述" longdesc="img_text/adxdk002.html"><br><a href="img_text/adxdk002.html">“图12-3用于Java的XML分析器”的描述</a></div>
                     <!-- class="figure" -->
                     <p><a href="XML-parsing-for-Java.html#GUID-C9FB63BA-709F-49AD-922F-29F9E712974E__I1038080">图12-3中</a>显示的应用程序的基本过程是：</p>
                     <ol>
                        <li>
                           <p>DOM或SAX解析器解析输入XML文档。例如，程序可以解析XML数据文档，DTD，XML模式和XSL样式表。</p>
                        </li>
                        <li>
                           <p>如果实现验证解析器，则处理器会尝试针对任何提供的DTD或XML模式验证XML数据文档。</p>
                        </li>
                     </ol>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="using-XSLT-processor-for-Java.html#GUID-E148A072-BDBE-40A4-A393-F4FC362382F5" title="解释了如何使用Java的可扩展样式表语言转换（XSLT）处理器。">使用XSLT Processor for Java</a></li>
                           <li><a href="using-XML-schema-processor-for-Java.html#GUID-F41C7DA2-A3DF-463B-A08C-24E8F0621450" title="这里的主题介绍了如何使用Java的可扩展标记语言（XML）模式处理器。">使用XML Schema Processor for Java</a></li>
                        </ul>
                     </div>
                     <div class="infoboxnotealso" id="GUID-C9FB63BA-709F-49AD-922F-29F9E712974E__GUID-4F46C7EC-9FF3-41B4-9002-5D4BC20DFA4C">
                        <p class="notep1">也可以看看：</p>
                        <p>适用于XML解析器类和方法的<a href="../jaxml/index.html" target="_blank"><span><cite>Oracle Database XML Java API参考</cite></span></a></p>
                     </div>
                  </div>
                  
               </div><a id="ADXDK19109"></a><a id="ADXDK19108"></a><div class="props_rev_3"><a id="GUID-996EFA8E-2C09-46C4-839B-F607D44B815C" name="GUID-996EFA8E-2C09-46C4-839B-F607D44B815C"></a><h4 id="ADXDK-GUID-996EFA8E-2C09-46C4-839B-F607D44B815C" class="sect4">运行用于Java演示程序的XML Parser</h4>
                  <div>
                     <p>用于Java的XML解析器的演示程序包含在<code class="codeph">$ORACLE_HOME/xdk/demo/java/parser</code> 。
                     </p>
                     <div class="section">
                        <p>演示程序分布在<a href="XML-parsing-for-Java.html#GUID-996EFA8E-2C09-46C4-839B-F607D44B815C__CCHHGCFI" title="描述/ demo / java目录的子目录。">表12-3中</a>描述的子目录中。
                        </p>
                        <div class="tblformalwide" id="GUID-996EFA8E-2C09-46C4-839B-F607D44B815C__CCHHGCFI">
                           <p class="titleintable">表12-3 Java Parser演示</p>
                           <table cellpadding="4" cellspacing="0" class="FormalWide" title="Java Parser演示" width="100%" border="1" summary="Describes the subdirectories of the /demo/java directory." frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="10%" id="d35651e2597">目录</th>
                                    <th align="left" valign="bottom" width="35%" id="d35651e2600">内容</th>
                                    <th align="left" valign="bottom" width="55%" id="d35651e2603">这些节目......</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="10%" id="d35651e2608" headers="d35651e2597 ">
                                       <p><code class="codeph">共同</code></p>
                                    </td>
                                    <td align="left" valign="top" width="35%" headers="d35651e2608 d35651e2600 "><pre class="oac_no_warn" dir="ltr">class.xml DemoUtil.java empl.xml family.dtd family.xml iden.xsl NSExample.xml traversal.xml</pre></td>
                                    <td align="left" valign="top" width="55%" headers="d35651e2608 d35651e2603 ">
                                       <p>提供XML文件和Java程序，以便与XML解析器一起使用。例如，您可以使用XSLT样式表<code class="codeph">iden.xsl</code>来实现XML文件的标识转换。<code class="codeph">DemoUtil.java</code>实现了一个帮助方法，用于从文件名创建URL，并被许多其他演示程序使用。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="10%" id="d35651e2625" headers="d35651e2597 ">
                                       <p><code class="codeph">补偿</code></p>
                                    </td>
                                    <td align="left" valign="top" width="35%" headers="d35651e2625 d35651e2600 "><pre class="oac_no_warn" dir="ltr">DOMCompression.java DOMDeCompression.java SAXCompression.java SAXDeCompression.java SampleSAXHandler.java sample.xml xml.ser</pre></td>
                                    <td align="left" valign="top" width="55%" headers="d35651e2625 d35651e2603 ">
                                       <p>显示DOM和SAX压缩：</p>
                                       <ul style="list-style-type:disc">
                                          <li>
                                             <p><code class="codeph">DOMCompression.java</code>压缩DOM树。
                                             </p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">DOMDeCompression.java</code>从压缩流中读回DOM。
                                             </p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">SAXCompression.java</code>压缩SAX解析器的输出。
                                             </p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">SAXDeCompression.java</code>从压缩流中重新生成SAX事件。
                                             </p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">SampleSAXHandler.java</code>显示使用处理程序来处理SAX <code class="codeph">DeCompressor</code>抛出的事件。
                                             </p>
                                          </li>
                                       </ul>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="10%" id="d35651e2665" headers="d35651e2597 ">
                                       <p><code class="codeph">DOM</code></p>
                                    </td>
                                    <td align="left" valign="top" width="35%" headers="d35651e2665 d35651e2600 "><pre class="oac_no_warn" dir="ltr">AutoDetectEncoding.java DOM2Namespace.java DOMNamespace.java DOMRangeSample.java DOMSample.java EventSample.java I18nSafeXMLFileWritingSample.java NodeIteratorSample.java ParseXMLFromString.java TreeWalkerSample.java</pre></td>
                                    <td align="left" valign="top" width="55%" headers="d35651e2665 d35651e2603 ">
                                       <p>显示DOM API的用法：</p>
                                       <ul style="list-style-type:disc">
                                          <li>
                                             <p><code class="codeph">DOM2Namespace.java</code>显示了如何使用DOM Level 2.0 API。</p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">DOMNamespace.java</code>显示了如何对DOM API使用Namespace扩展。</p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">DOMRangeSample.java</code>显示了如何使用DOM Range API。</p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">DOMSample.java</code>显示了DOM API的基本用法。</p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">EventSample.java</code>显示了如何使用DOM事件API。</p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">NodeIteratorSample.java</code>显示了如何使用DOM Iterator API。</p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">TreeWalkerSample.java</code>显示了如何使用DOM <code class="codeph">TreeWalker</code> API。</p>
                                          </li>
                                       </ul>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="10%" id="d35651e2715" headers="d35651e2597 ">
                                       <p><code class="codeph">JAXP</code></p>
                                    </td>
                                    <td align="left" valign="top" width="35%" headers="d35651e2715 d35651e2600 "><pre class="oac_no_warn" dir="ltr">JAXPExamples.java age.xsl general.xml jaxpone.xml jaxpone.xsl jaxpthree.xsl jaxptwo.xsl oraContentHandler.java</pre></td>
                                    <td align="left" valign="top" width="55%" headers="d35651e2715 d35651e2603 ">
                                       <p>显示JAXP的各种用法：</p>
                                       <ul style="list-style-type:disc">
                                          <li>
                                             <p><code class="codeph">JAXPExamples.java</code>提供了一些如何使用JAXP 1.1 API来运行Oracle引擎的示例。
                                             </p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">oraContentHandler.java</code>实现了一个SAX内容处理程序。程序在识别XML标记时调用<code class="codeph">startDocument()</code> ， <code class="codeph">endDocument()</code> ， <code class="codeph">startElement()</code>和<code class="codeph">endElement()</code> 。
                                             </p>
                                          </li>
                                       </ul>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="10%" id="d35651e2749" headers="d35651e2597 ">
                                       <p><code class="codeph">萨克斯</code></p>
                                    </td>
                                    <td align="left" valign="top" width="35%" headers="d35651e2749 d35651e2600 "><pre class="oac_no_warn" dir="ltr">SAX2Namespace.java SAXNamespace.java SAXSample.java Tokenizer.java</pre></td>
                                    <td align="left" valign="top" width="55%" headers="d35651e2749 d35651e2603 ">
                                       <p>显示SAX API的各种用法：</p>
                                       <ul style="list-style-type:disc">
                                          <li>
                                             <p><code class="codeph">SAX2Namespace.java</code>显示了如何使用SAX 2.0。
                                             </p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">SAXNamespace.java</code>显示了如何对SAX API使用名称空间扩展。</p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">SAXSample.java</code>显示了SAX API的基本用法。</p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">Tokenizer.java</code>显示了如何使用<code class="codeph">XMLToken</code>接口API。该程序实现<code class="codeph">XMLToken</code>接口，该接口必须使用<code class="codeph">setTokenHandler()</code>方法注册。使用<code class="codeph">setToken()</code>方法注册XML令牌请求。在标记化期间，解析器不验证文档，也不包括或读取内部/外部实用程序。
                                             </p>
                                          </li>
                                       </ul>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="10%" id="d35651e2793" headers="d35651e2597 ">
                                       <p><code class="codeph">XSLT</code></p>
                                    </td>
                                    <td align="left" valign="top" width="35%" headers="d35651e2793 d35651e2600 "><pre class="oac_no_warn" dir="ltr">XSLSample.java XSLSample2.java match.xml match.xsl math.xml math.xsl number.xml number.xsl position.xml position.xsl reverse.xml reverse.xsl string.xml string.xsl style.txt variable.xml变量。 XSL</pre></td>
                                    <td align="left" valign="top" width="55%" headers="d35651e2793 d35651e2603 ">
                                       <p>使用XSLT显示文档转换：</p>
                                       <ul style="list-style-type:disc">
                                          <li>
                                             <p><code class="codeph">XSLSample.java</code>显示了如何使用Oracle XML解析器的XSL处理功能。它使用给定的输入样式表转换输入XML文档。此演示将XSL转换的结果构建为<code class="codeph">DocumentFragment</code> ，因此不支持<code class="codeph">xsl:output</code>功能。
                                             </p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">XSLSample2.java</code>使用给定的输入样式表转换输入XML文档。该演示流式传输XSL转换的结果，因此支持<code class="codeph">xsl:output</code>功能。
                                             </p>
                                          </li>
                                       </ul>
                                       <p><span class="bold">另请参阅：</span> <a href="using-XSLT-processor-for-Java.html#GUID-A934BBC3-82AC-4620-A20F-F8AE7E6CA62E" title="用于Java的XSLT处理器的演示程序包含在$ ORACLE_HOME / xdk / demo / java / parser / xslt中。">运行XSLT处理器演示程序</a></p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <p>有关如何编译和运行示例程序的文档位于<code class="codeph">README</code>文件中。基本程序是：</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>转到<code class="codeph">$ORACLE_HOME/xdk/demo/java/parser</code>目录（UNIX）或<code class="codeph">%ORACLE_HOME%\xdk\demo\java\parser</code>目录（Windows）。</span></li>
                        <li class="stepexpand"><span>按照<a href="getting-started-with-XDK-for-Java.html#GUID-EA5DB831-1D91-453A-AF7B-7B55343B1720" title="You can set up the XDK for Java environment using either an environment variable or a command-line option.">设置XDK for Java环境中的</a>描述<a href="getting-started-with-XDK-for-Java.html#GUID-EA5DB831-1D91-453A-AF7B-7B55343B1720" title="您可以使用环境变量或命令行选项设置XDK for Java环境。">设置环境</a> 。</span></li>
                        <li class="stepexpand"><span>转换到每个子目录并在命令行运行<code class="codeph">make</code> （UNIX）或<code class="codeph">Make.bat</code> （Windows）。例如：</span><div><pre class="oac_no_warn" dir="ltr">cd comp; make; cd ..cd jaxp; make; cd ..cd sax; make; cd ..cd dom; make; cd ..cd xslt; make; cd ..
</pre><p>make文件编译每个目录中的源代码，运行程序，并将每个程序的输出写入扩展名为<code class="codeph">*.out</code>的文件。
                              </p>
                           </div>
                        </li>
                        <li class="stepexpand"><span>您可以查看<code class="codeph">*.out</code>文件以查看程序的输出。</span></li>
                     </ol>
                  </div>
               </div><a id="ADXDK19111"></a><a id="ADXDK19110"></a><div class="props_rev_3"><a id="GUID-204C527C-DED2-4FBA-861E-3378370529ED" name="GUID-204C527C-DED2-4FBA-861E-3378370529ED"></a><h4 id="ADXDK-GUID-204C527C-DED2-4FBA-861E-3378370529ED" class="sect4">使用Java XML Parser命令行实用程序（oraxml）</h4>
                  <div>
                     <p><code class="codeph">oraxml</code>实用程序位于<code class="codeph">$ORACLE_HOME/bin</code> （UNIX）或<code class="codeph">%ORACLE_HOME%\bin</code> （Windows）中，是一个解析XML文档的命令行界面。它检查结构良好和有效性。
                     </p>
                     <div class="section">
                        <p>要使用<code class="codeph">oraxml</code> ，请确保：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p>您的<code class="codeph">CLASSPATH</code>的设置如<a href="getting-started-with-XDK-for-Java.html#GUID-EA5DB831-1D91-453A-AF7B-7B55343B1720" title="您可以使用环境变量或命令行选项设置XDK for Java环境。">设置XDK for Java环境中所述</a> ，您的<code class="codeph">CLASSPATH</code>环境变量引用<code class="codeph">xmlparserv2.jar</code>文件。
                              </p>
                           </li>
                           <li>
                              <p>您的<code class="codeph">PATH</code>环境变量可以找到您的Java Development Kit（JDK）版本附带的Java解释器。
                              </p>
                           </li>
                        </ul>
                        <p><a href="XML-parsing-for-Java.html#GUID-204C527C-DED2-4FBA-861E-3378370529ED__BGBCBAIE" title="此表列出了oraxml命令行选项。选项和目的是列。">表12-4</a>列出了<code class="codeph">oraxml</code>命令行选项。
                        </p>
                        <div class="tblformal" id="GUID-204C527C-DED2-4FBA-861E-3378370529ED__BGBCBAIE">
                           <p class="titleintable">表12-4 oraxml命令行选项</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="oraxml命令行选项" width="100%" border="1" summary="This table  lists the oraxml command-line options. Option and Purpose are the columns." frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="30%" id="d35651e3033">选项</th>
                                    <th align="left" valign="bottom" width="70%" id="d35651e3036">目的</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="30%" id="d35651e3041" headers="d35651e3033 ">
                                       <p>- <code class="codeph">help</code></p>
                                    </td>
                                    <td align="left" valign="top" width="70%" headers="d35651e3041 d35651e3036 ">
                                       <p>打印帮助信息</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="30%" id="d35651e3050" headers="d35651e3033 ">
                                       <p>- <code class="codeph">version</code></p>
                                    </td>
                                    <td align="left" valign="top" width="70%" headers="d35651e3050 d35651e3036 ">
                                       <p>打印发行版</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="30%" id="d35651e3059" headers="d35651e3033 ">
                                       <p>- <code class="codeph">novalidate</code> <span class="italic"><code class="codeph">fileName</code></span></p>
                                    </td>
                                    <td align="left" valign="top" width="70%" headers="d35651e3059 d35651e3036 ">
                                       <p>检查输入文件是否格式正确</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="30%" id="d35651e3072" headers="d35651e3033 ">
                                       <p>- <code class="codeph">dtd</code> <span class="italic"><code class="codeph">fileName</code></span></p>
                                    </td>
                                    <td align="left" valign="top" width="70%" headers="d35651e3072 d35651e3036 ">
                                       <p>使用DTD验证验证输入文件</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="30%" id="d35651e3085" headers="d35651e3033 ">
                                       <p>- <code class="codeph">schema</code> <span class="italic"><code class="codeph">fileName</code></span></p>
                                    </td>
                                    <td align="left" valign="top" width="70%" headers="d35651e3085 d35651e3036 ">
                                       <p>使用Schema Validation验证输入文件</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="30%" id="d35651e3098" headers="d35651e3033 ">
                                       <p>- <code class="codeph">log</code> <span class="italic"><code class="codeph">logfile</code></span></p>
                                    </td>
                                    <td align="left" valign="top" width="70%" headers="d35651e3098 d35651e3036 ">
                                       <p>将错误写入输出日志文件</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="30%" id="d35651e3111" headers="d35651e3033 ">
                                       <p>- <code class="codeph">comp</code> <span class="italic"><code class="codeph">fileName</code></span></p>
                                    </td>
                                    <td align="left" valign="top" width="70%" headers="d35651e3111 d35651e3036 ">
                                       <p>压缩输入XML文件</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="30%" id="d35651e3124" headers="d35651e3033 ">
                                       <p>- 解<code class="codeph">decomp</code> <span class="italic"><code class="codeph">fileName</code></span></p>
                                    </td>
                                    <td align="left" valign="top" width="70%" headers="d35651e3124 d35651e3036 ">
                                       <p>解压缩输入的压缩文件</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="30%" id="d35651e3137" headers="d35651e3033 ">
                                       <p>- <code class="codeph">enc</code> <span class="italic"><code class="codeph">fileName</code></span></p>
                                    </td>
                                    <td align="left" valign="top" width="70%" headers="d35651e3137 d35651e3036 ">
                                       <p>打印输入文件的编码</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="30%" id="d35651e3150" headers="d35651e3033 ">
                                       <p>- <code class="codeph">warning</code></p>
                                    </td>
                                    <td align="left" valign="top" width="70%" headers="d35651e3150 d35651e3036 ">
                                       <p>显示警告</p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <p>例如，切换到<code class="codeph">$ORACLE_HOME/xdk/demo/java/parser/common</code>目录。您可以通过在命令行上执行此命令来针对<code class="codeph">family.dtd</code>验证文档<code class="codeph">family.xml</code> ：</p><pre class="oac_no_warn" dir="ltr">oraxml -dtd -enc family.xml</pre><p>输出是：</p><pre class="oac_no_warn" dir="ltr">输入文件的编码：UTF-8使用DTD验证模式解析输入XML文件时没有错误。</pre></div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="ADXDK978"></a><a id="ADXDK19112"></a><div class="props_rev_3"><a id="GUID-B40FF06A-6390-4A8B-A0EB-0F8199977749" name="GUID-B40FF06A-6390-4A8B-A0EB-0F8199977749"></a><h3 id="ADXDK-GUID-B40FF06A-6390-4A8B-A0EB-0F8199977749" class="sect3">使用DOM解析XML</h3>
               <div>
                  <p>W3C标准库<code class="codeph">org.w3c.dom</code>定义了DOM的组件的<code class="codeph">Document</code>类和类。 Oracle XML解析器包含标准DOM API，并符合W3C DOM建议。
                  </p>
                  <div class="section">
                     <p>与<code class="codeph">org.w3c.dom</code> ，Oracle XML解析包括实现DOM API的类，并扩展它们以提供打印文档片段和检索命名空间信息等功能。
                     </p>
                  </div>
                  <!-- class="section" -->
               </div><a id="ADXDK19113"></a><div class="props_rev_3"><a id="GUID-A96D7D89-037D-4107-AAAB-8EAD0FAEBF53" name="GUID-A96D7D89-037D-4107-AAAB-8EAD0FAEBF53"></a><h4 id="ADXDK-GUID-A96D7D89-037D-4107-AAAB-8EAD0FAEBF53" class="sect4">使用DOM API for Java</h4>
                  <div>
                     <p>描述了可用于在XML应用程序中实现基于DOM的组件的Java类。</p>
                     <div class="section">
                        <p>使用这些类：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">oracle.xml.parser.v2。的DOMParser</code></p>
                              <p>此类根据W3C建议实现XML 1.0解析器。由于<code class="codeph">DOMParser</code>扩展<code class="codeph">XMLParser</code> ，所有方法<code class="codeph">XMLParser</code>可供<code class="codeph">DOMParser</code> 。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">oracle.xml.parser.v2。XMLDOMImplementation</code></p>
                              <p>此类包含用于创建SDOM的工厂方法。</p>
                           </li>
                        </ul>
                        <p>您还可以使用<code class="codeph">DOMNamespace</code>和<code class="codeph">DOM2Namespace</code>类，它们是<code class="codeph">$ORACLE_HOME/xdk/demo/java/parser/dom</code>包含的示例程序。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="XML-parsing-for-Java.html#GUID-7F6C9BF4-3E01-4D40-A960-0D469B45C74E" title="描述了DOM解析器的体系结构。">DOM解析器架构</a></li>
                           <li><a href="XML-parsing-for-Java.html#GUID-3F0DFF8C-DB04-4B9A-8C3A-AFD748258A6C" title="解释了如何创建和使用可插入的可伸缩DOM（SDOM）。">创建SDOM</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div><a id="ADXDK19115"></a><a id="ADXDK19114"></a><div class="props_rev_3"><a id="GUID-7F6C9BF4-3E01-4D40-A960-0D469B45C74E" name="GUID-7F6C9BF4-3E01-4D40-A960-0D469B45C74E"></a><h4 id="ADXDK-GUID-7F6C9BF4-3E01-4D40-A960-0D469B45C74E" class="sect4">DOM解析器架构</h4>
                  <div>
                     <p>描述了DOM解析器的体系结构。</p>
                     <div class="figure" id="GUID-7F6C9BF4-3E01-4D40-A960-0D469B45C74E__I1040902">
                        <p class="titleinfigure">图12-4 DOM解析器的基本体系结构</p><img src="img/adxdk055.gif" width="595" alt="下面是图12-4的描述" title="下面是图12-4的描述" longdesc="img_text/adxdk055.html"><br><a href="img_text/adxdk055.html">“图12-4 DOM解析器的基本架构”的描述</a></div>
                     <!-- class="figure" -->
                  </div>
               </div><a id="ADXDK19118"></a><a id="ADXDK19119"></a><a id="ADXDK19120"></a><a id="ADXDK19116"></a><div class="props_rev_3"><a id="GUID-7C91F2D5-350D-4530-8988-295EF0B60D53" name="GUID-7C91F2D5-350D-4530-8988-295EF0B60D53"></a><h4 id="ADXDK-GUID-7C91F2D5-350D-4530-8988-295EF0B60D53" class="sect4">执行基本DOM解析</h4>
                  <div>
                     <p><code class="codeph">DOMSample.java</code>显示了解析输入XML文档并通过DOM访问它的基本步骤。 <code class="codeph">DOMSample.java</code>接收XML文件作为输入，解析它，并在DOM树中打印元素和属性。
                     </p>
                     <div class="section">
                        <p>提供可以使用的可能方法和接口的步骤是：</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>通过调用<code class="codeph">DOMParser()</code>构造函数创建<code class="codeph">DOMParser</code>对象（解析器）。</span><div>
                              <p><code class="codeph">DOMSample.java</code>的代码是：</p><pre class="oac_no_warn" dir="ltr">DOMParser解析器=新的DOMParser（）;</pre></div>
                        </li>
                        <li class="stepexpand"><span>使用<a href="XML-parsing-for-Java.html#GUID-7C91F2D5-350D-4530-8988-295EF0B60D53__CCHHJABF" title="此表描述了可用于设置DOM解析器的各种属性的方法。">表12-5中</a>的方法配置解析器属性。</span><div>
                              <p><code class="codeph">DOMSample.java</code>中的此代码片段指定错误输出流，将验证模式设置为DTD验证，并启用警告消息：</p><pre class="oac_no_warn" dir="ltr">parser.setErrorStream（System.err的）; parser.setValidationMode（的DOMParser。DTD_VALIDATION）; parser.showWarnings（真）;</pre></div>
                        </li>
                        <li class="stepexpand"><span>通过调用<code class="codeph">parse()</code>方法<code class="codeph">parse()</code>输入XML文档，该方法在内存中构建<code class="codeph">Node</code>对象树。</span><div>
                              <p><code class="codeph">DOMSample.java</code>这段代码片段解析了<code class="codeph">java.net.一个实例<code class="codeph">java.net.URL</code>类：</p><pre class="oac_no_warn" dir="ltr">parser.parse（URL）;</pre><p>XML输入可以是文件，字符串缓冲区或URL。如下面的代码片段所示， <code class="codeph">DOMSample.java</code>接受文件名作为参数，并调用<code class="codeph">createURL</code>帮助器方法来构造可以传递给解析器的URL对象：</p><pre class="oac_no_warn" dir="ltr">public class DOMSample {static public void main（String [] argv）{try {if（argv.length！= 1）{//必须传入XML文件的名称。System.err.println（“用法：java DOMSample文件名”）; System.exit（1）; } ...//从文件名生成URL。URL url = DemoUtil.createURL（argv [0]）; ...
</pre></div>
                        </li>
                        <li class="stepexpand"><span>调用<code class="codeph">getDocument()</code>以获取内存中DOM树的根的句柄，该树是<code class="codeph">XMLDocument</code>对象。</span><div>
                              <p>您可以使用此句柄访问已解析的XML文档的每个部分。<code class="codeph">XMLDocument</code>类实现<a href="XML-parsing-for-Java.html#GUID-7C91F2D5-350D-4530-8988-295EF0B60D53__CCHIFIEF" title="列出XMLDocument实现的一些接口。">表12-6中</a>的接口。
                              </p>
                              <p><code class="codeph">DOMSample.java</code>的代码片段是：</p><pre class="oac_no_warn" dir="ltr">XMLDocument doc = parser.getDocument（）;</pre></div>
                        </li>
                        <li class="stepexpand" id="GUID-7C91F2D5-350D-4530-8988-295EF0B60D53__CCHBFACH"><span>通过调用<a href="XML-parsing-for-Java.html#GUID-7C91F2D5-350D-4530-8988-295EF0B60D53__CCHBDBGE" title="此表描述了XMLDocument类的有用方法。">表12-7中的</a> <code class="codeph">XMLDocument</code>方法获取和操作检索到的文档的DOM节点。</span><div>
                              <p><code class="codeph">DOMSample.java</code>这段代码片段使用<code class="codeph">DOMParser.print()</code>方法来打印DOM树的元素和属性：</p><pre class="oac_no_warn" dir="ltr">System.out.print（“元素是：”）; printElements（DOC）; System.out.println（“每个元素的属性是：”）; printElementAttributes（DOC）;</pre><p><code class="codeph">DOMSample.java</code>的以下代码片段实现了<code class="codeph">printElements()</code>方法，该方法调用<code class="codeph">getElementsByTagName()</code>以获取DOM树中所有元素的列表。然后代码循环遍历列表，调用<code class="codeph">getNodeName()</code>来打印每个元素的名称：</p><pre class="oac_no_warn" dir="ltr">static void printElements（Document doc）{NodeList nl = doc.getElementsByTagName（“*”）;节点n; for（int i = 0; i &lt;nl.getLength（）; i ++）{n = nl.item（i）; System.out.print（n.getNodeName（）+“”）; System.out.println（）; }</pre><p><code class="codeph">DOMSample.java</code>的以下代码片段实现了<code class="codeph">printElementAttributes()</code>方法，该方法调用<code class="codeph">Document.getElementsByTagName()</code>以获取DOM树中所有元素的列表。然后代码遍历列表，调用<code class="codeph">Element.getAttributes()</code>来获取元素的属性列表，并调用<code class="codeph">Node.getNodeName()</code>来获取属性名称， <code class="codeph">Node.getNodeValue()</code>来获取属性值：</p><pre class="oac_no_warn" dir="ltr">static void printElementAttributes（Document doc）{NodeList nl = doc.getElementsByTagName（“*”）;元素e;节点n; NamedNodeMap nnm;字符串attrname;字符串attrval; int i，len; len = nl.getLength（）; for（int j = 0; j &lt;len; j ++）{e =（Element）nl.item（j）; System.out.println（e.getTagName（）+“：”）; nnm = e.getAttributes（）;如果（nnm！= null）{for（i = 0; i &lt;nnm.getLength（）; i ++）{n = nnm.item（i）; attrname = n.getNodeName（）; attrval = n.getNodeValue（）; System.out.print（“”+ attrname +“=”+ attrval）; System.out.println（）; }}</pre></div>
                        </li>
                        <li class="stepexpand"><span>通过调用<code class="codeph">reset()</code>方法重置解析器状态。解析器现在可以解析新文档了。</span></li>
                     </ol>
                     <div class="section">
                        <p><a href="XML-parsing-for-Java.html#GUID-7C91F2D5-350D-4530-8988-295EF0B60D53__CCHHJABF" title="此表描述了可用于设置DOM解析器的各种属性的方法。">表12-5</a>总结了<code class="codeph">DOMParser</code>配置方法。
                        </p>
                        <div class="tblformal" id="GUID-7C91F2D5-350D-4530-8988-295EF0B60D53__CCHHJABF">
                           <p class="titleintable">表12-5 DOMParser配置方法</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="DOMParser配置方法" width="100%" border="1" summary="This table describes methods that you can use to set various properties of the DOM parser." frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="33%" id="d35651e3756">方法</th>
                                    <th align="left" valign="bottom" width="67%" id="d35651e3759">目的</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="33%" id="d35651e3764" headers="d35651e3756 ">
                                       <p><code class="codeph">setBaseURL（）</code></p>
                                    </td>
                                    <td align="left" valign="top" width="67%" headers="d35651e3764 d35651e3759 ">
                                       <p>设置加载外部实体和DTD的基本URL。如果XML文档是<code class="codeph">InputStream</code>则调用此方法。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="33%" id="d35651e3775" headers="d35651e3756 ">
                                       <p><code class="codeph">setDoctype（）</code></p>
                                    </td>
                                    <td align="left" valign="top" width="67%" headers="d35651e3775 d35651e3759 ">
                                       <p>指定解析时要使用的DTD。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="33%" id="d35651e3783" headers="d35651e3756 ">
                                       <p><code class="codeph">setErrorStream（）</code></p>
                                    </td>
                                    <td align="left" valign="top" width="67%" headers="d35651e3783 d35651e3759 ">
                                       <p>为错误和警告的输出创建输出流。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="33%" id="d35651e3791" headers="d35651e3756 ">
                                       <p><code class="codeph">setPreserveWhitespace（）</code></p>
                                    </td>
                                    <td align="left" valign="top" width="67%" headers="d35651e3791 d35651e3759 ">
                                       <p>指示解析器保留输入XML文档中的空白区域。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="33%" id="d35651e3799" headers="d35651e3756 ">
                                       <p><code class="codeph">setValidationMode（）</code></p>
                                    </td>
                                    <td align="left" valign="top" width="67%" headers="d35651e3799 d35651e3759 ">
                                       <p>设置解析器的验证模式。<a href="XML-parsing-for-Java.html#GUID-2DA498AD-B22B-4C66-AE90-5EB37EB105E7__G1043218" title="此表显示可在XDK解析器中使用的setValidationMode（）标志。模式名称，Java中的模式值和描述是列。">表12-1</a>介绍了可以与此方法一起使用的标志。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="33%" id="d35651e3812" headers="d35651e3756 ">
                                       <p><code class="codeph">showWarnings（）</code></p>
                                    </td>
                                    <td align="left" valign="top" width="67%" headers="d35651e3812 d35651e3759 ">
                                       <p>指定解析器是否打印警告。</p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <p><a href="XML-parsing-for-Java.html#GUID-7C91F2D5-350D-4530-8988-295EF0B60D53__CCHIFIEF" title="列出XMLDocument实现的一些接口。">表12-6</a>总结了<code class="codeph">XMLDocument</code>类实现的接口。
                        </p>
                        <div class="tblformal" id="GUID-7C91F2D5-350D-4530-8988-295EF0B60D53__CCHIFIEF">
                           <p class="titleintable">表12-6 XMLDocument实现的一些接口</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="一些接口由XMLDocument实现" width="100%" border="1" summary="Lists some of the interfaces implemented by XMLDocument." frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="31%" id="d35651e3838">接口</th>
                                    <th align="left" valign="bottom" width="69%" id="d35651e3841">什么接口定义</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d35651e3846" headers="d35651e3838 ">
                                       <p><code class="codeph">org.w3c.dom中。节点</code></p>
                                    </td>
                                    <td align="left" valign="top" width="69%" headers="d35651e3846 d35651e3841 ">
                                       <p>文档树中的单个节点以及访问和处理节点的方法。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d35651e3854" headers="d35651e3838 ">
                                       <p><code class="codeph">org.w3c.dom中。文献</code></p>
                                    </td>
                                    <td align="left" valign="top" width="69%" headers="d35651e3854 d35651e3841 ">
                                       <p>表示整个XML文档的<code class="codeph">Node</code> 。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d35651e3865" headers="d35651e3838 ">
                                       <p><code class="codeph">org.w3c.dom中。元件</code></p>
                                    </td>
                                    <td align="left" valign="top" width="69%" headers="d35651e3865 d35651e3841 ">
                                       <p>表示XML元素的<code class="codeph">Node</code> 。
                                       </p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <p><a href="XML-parsing-for-Java.html#GUID-7C91F2D5-350D-4530-8988-295EF0B60D53__CCHBDBGE" title="此表描述了XMLDocument类的有用方法。">表12-7</a>总结了获取和操作DOM树节点的方法。
                        </p>
                        <div class="tblformal" id="GUID-7C91F2D5-350D-4530-8988-295EF0B60D53__CCHBDBGE">
                           <p class="titleintable">表12-7获取和操作DOM树节点的方法</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="获取和操作DOM树节点的方法" width="100%" border="1" summary="This table describes useful methods of the XMLDocument class." frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="32%" id="d35651e3891">方法</th>
                                    <th align="left" valign="bottom" width="68%" id="d35651e3894">目的</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="32%" id="d35651e3899" headers="d35651e3891 ">
                                       <p><code class="codeph">的getAttributes（）</code></p>
                                    </td>
                                    <td align="left" valign="top" width="68%" headers="d35651e3899 d35651e3894 ">
                                       <p>生成包含此节点的属性的<code class="codeph">NamedNodeMap</code> （如果它是元素），否则生成<code class="codeph">null</code> 。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="32%" id="d35651e3913" headers="d35651e3891 ">
                                       <p><code class="codeph">的getElementsByTagName（）</code></p>
                                    </td>
                                    <td align="left" valign="top" width="68%" headers="d35651e3913 d35651e3894 ">
                                       <p>以递归方式检索与特定级别下的给定标记名称匹配的所有元素。此方法支持<code class="codeph">*</code>标记，该标记与任何标记匹配。通过文档根目录的句柄调用<code class="codeph">getElementsByTagName("*")</code> ，以生成文档中所有元素的列表。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="32%" id="d35651e3927" headers="d35651e3891 ">
                                       <p><code class="codeph">getExpandedName（）</code></p>
                                    </td>
                                    <td align="left" valign="top" width="68%" headers="d35651e3927 d35651e3894 ">
                                       <p>获取元素的扩展名称。此方法在<code class="codeph">NSName</code>接口中指定。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="32%" id="d35651e3938" headers="d35651e3891 ">
                                       <p><code class="codeph">号·getLocalName（）</code></p>
                                    </td>
                                    <td align="left" valign="top" width="68%" headers="d35651e3938 d35651e3894 ">
                                       <p>获取此元素的本地名称。如果元素名称是<code class="codeph">&lt;E1:locn xmlns:E1="http://www.oracle.com/"/&gt;</code> ，则<code class="codeph">locn</code>是本地名称。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="32%" id="d35651e3952" headers="d35651e3891 ">
                                       <p><code class="codeph">getNamespaceURI（）</code></p>
                                    </td>
                                    <td align="left" valign="top" width="68%" headers="d35651e3952 d35651e3894 ">
                                       <p>获取此节点的名称空间URI，如果未指定，则返回<code class="codeph">null</code> 。如果元素名称是<code class="codeph">&lt;E1:locn xmlns:E1="http://www.oracle.com/"/&gt;</code> ，则<code class="codeph">http://www.oracle.com</code>是名称空间URI。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="32%" id="d35651e3969" headers="d35651e3891 ">
                                       <p><code class="codeph">getNodeName（）</code></p>
                                    </td>
                                    <td align="left" valign="top" width="68%" headers="d35651e3969 d35651e3894 ">
                                       <p>获取DOM树中节点的名称。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="32%" id="d35651e3977" headers="d35651e3891 ">
                                       <p><code class="codeph">getNodeValue（）</code></p>
                                    </td>
                                    <td align="left" valign="top" width="68%" headers="d35651e3977 d35651e3894 ">
                                       <p>获取此节点的值，具体取决于其类型。此节点位于<code class="codeph">Node</code>接口中。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="32%" id="d35651e3988" headers="d35651e3891 ">
                                       <p><code class="codeph">getPrefix（）</code></p>
                                    </td>
                                    <td align="left" valign="top" width="68%" headers="d35651e3988 d35651e3894 ">
                                       <p>获取元素的名称空间前缀。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="32%" id="d35651e3996" headers="d35651e3891 ">
                                       <p><code class="codeph">getQualifiedName（）</code></p>
                                    </td>
                                    <td align="left" valign="top" width="68%" headers="d35651e3996 d35651e3894 ">
                                       <p>获取元素的限定名称。如果元素名称是<code class="codeph">&lt;E1:locn xmlns:E1="http://www.oracle.com/"/&gt;</code> ，则<code class="codeph">E1:locn</code>是限定名称。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="32%" id="d35651e4010" headers="d35651e3891 ">
                                       <p><code class="codeph">getTagName（）</code></p>
                                    </td>
                                    <td align="left" valign="top" width="68%" headers="d35651e4010 d35651e3894 ">
                                       <p>获取DOM树中元素的名称。</p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ADXDK979"></a><a id="ADXDK19121"></a><div class="props_rev_3"><a id="GUID-3F0DFF8C-DB04-4B9A-8C3A-AFD748258A6C" name="GUID-3F0DFF8C-DB04-4B9A-8C3A-AFD748258A6C"></a><h4 id="ADXDK-GUID-3F0DFF8C-DB04-4B9A-8C3A-AFD748258A6C" class="sect4">创建SDOM</h4>
                  <div>
                     <p>解释了如何创建和使用可插入的可伸缩DOM（SDOM）。</p>
                     <div class="section"></div>
                     <!-- class="section" -->
                  </div><a id="ADXDK19122"></a><div class="props_rev_3"><a id="GUID-0208270A-89F0-4174-9EB5-3C2960F1E8B3" name="GUID-0208270A-89F0-4174-9EB5-3C2960F1E8B3"></a><h5 id="ADXDK-GUID-0208270A-89F0-4174-9EB5-3C2960F1E8B3" class="sect5">使用SDOM</h5>
                     <div>
                        <p>描述了如何使用SDOM。</p>
                        <div class="section">
                           <p>SDOM具有从数据中拆分的DOM API。底层数据可以是内部数据或插件数据，也可以是二进制XML。</p>
                           <p><span class="bold">内部数据</span>是尚未解析的XML文本。要插入，内部数据必须保存为二进制XML，然后由<code class="codeph">DOMParser</code>解析。然后可以将解析的二进制XML插入DOM API层的<code class="codeph">InfoSetReader</code> 。<code class="codeph">InfosetReader</code>参数是底层XML数据的接口。
                           </p>
                           <p><span class="bold">插件数据</span>是已解析的XML文本，因此可以从一个处理器传输到另一个处理器。
                           </p>
                           <p>要创建SDOM，可以通过<code class="codeph">XMLDOMImplementation</code>对象上的<code class="codeph">InfosetReader</code> API插入XML数据。例如：</p><pre class="pre codeblock"><code>public Document createDocument（InfosetReader reader）抛出DOMException</code></pre><p><code class="codeph">InfosetReader</code> API在<code class="codeph">BinXMLStream</code>之上实现。还可以支持用于其他形式的XML数据（例如dom4j，JDOM或Java数据库连接（JDBC））的可选适配器。您也可以插入自己的实现。
                           </p>
                           <p><code class="codeph">InfosetReader</code>充当可伸缩DOM API层和底层数据之间的接口。它是一种通用的基于流的pull API，用于访问XML数据。<code class="codeph">InfosetReader</code>从XML流中检索顺序事件，并查询这些事件的状态和数据。以下代码扫描XML数据并检索所有元素的<code class="codeph">QName</code>和属性：</p><pre class="pre codeblock"><code>InfosetReader阅读器; while（reader.hasNext（））{reader.next（）; if（reader.getEventType（）== START_ELEMENT）{QName name = reader.getQName（）; TypedAttributeList attrList = reader.getAttributeList（）; }}</code></pre></div>
                        <!-- class="section" -->
                     </div><a id="ADXDK19123"></a><div class="props_rev_3"><a id="GUID-5DF8A264-91E3-4EA7-B058-BD71381A76AD" name="GUID-5DF8A264-91E3-4EA7-B058-BD71381A76AD"></a><h6 id="ADXDK-GUID-5DF8A264-91E3-4EA7-B058-BD71381A76AD" class="sect6">InfosetReader选项</h6>
                        <div>
                           <p>显示了<code class="codeph">InfosetReader</code> API支持的选项。
                           </p>
                           <p>这些是支持的操作：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>复制（可选，但<code class="codeph">InfosetReader</code>的<code class="codeph">BinXMLStream</code>始终支持它）</p>
                                 <p>要支持跨文档对DOM进行卷影复制，可以使用<code class="codeph">Clone</code>方法创建<code class="codeph">InfosetReader</code>的新副本以确保线程安全。有关更多信息，请参阅<a href="XML-parsing-for-Java.html#GUID-000BEA9C-8AAB-4C04-9BFB-A4BCBC18ACC9" title="卷影副本通过让DOM节点共享其数据来避免数据复制。">使用卷影复制</a> 。
                                 </p>
                              </li>
                              <li>
                                 <p>移动焦点（可选）</p>
                                 <p>为了支持延迟实现， <code class="codeph">InfosetReader</code>可以将焦点移动到<code class="codeph">offset</code>指定的任何位置：</p><pre class="oac_no_warn" dir="ltr">if（reader.hasSeekSupport（）） <span class="bold">reader.seek（offset</span> ）;</pre><p>有关更多信息，请参阅<a href="XML-parsing-for-Java.html#GUID-D2C5A5C3-9753-4A27-A8FF-A36541E83C3D" title="使用延迟实现，您可以插入一个空DOM，它可以在需要时提取数据，并在不再需要时释放（取消引用）节点。SDOM支持手动或自动节点解除引用。">使用惰性实现</a></p>
                              </li>
                           </ul>
                        </div>
                     </div><a id="ADXDK19124"></a><div class="props_rev_3"><a id="GUID-D2842CD2-FA88-4F66-894F-2051675421AD" name="GUID-D2842CD2-FA88-4F66-894F-2051675421AD"></a><h6 id="ADXDK-GUID-D2842CD2-FA88-4F66-894F-2051675421AD" class="sect6">InfosetWriter</h6>
                        <div>
                           <p><code class="codeph">InfosetWriter</code>是支持数据写入的<code class="codeph">InfosetReader</code> API的扩展。XDK在二进制XML之上实现了<code class="codeph">InfosetWriter</code> 。您无法修改此实现。
                           </p>
                        </div>
                     </div><a id="ADXDK19125"></a><div class="props_rev_3"><a id="GUID-DAF4040A-AC94-4D84-895E-2C3EC6642E2F" name="GUID-DAF4040A-AC94-4D84-895E-2C3EC6642E2F"></a><h6 id="ADXDK-GUID-DAF4040A-AC94-4D84-895E-2C3EC6642E2F" class="sect6">将XML文本保存为二进制XML</h6>
                        <div>
                           <p>要从XML文本创建可伸缩DOM，必须先将XML文本另存为二进制XML或对二进制XML的引用，然后才能在其上运行<code class="codeph">DOMParser</code> 。要将XML文本另存为二进制XML，请将<code class="codeph">doc.save</code>参数设置为<code class="codeph">false</code> 。
                           </p>
                           <div class="section"><pre class="pre codeblock"><code>XMLDocument doc; InfosetWriter作家; doc.save（作家， <span class="bold">假</span> ）; writer.close（）;</code></pre><p>如果您知道数据源可用于反序列化，则可以通过将<code class="codeph">doc.save</code>参数设置为<code class="codeph">true</code>来保存二进制XML的节引用而不是实际数据。
                              </p>
                           </div>
                           <!-- class="section" -->
                        </div>
                        <div>
                           <div class="relinfo">
                              <p><strong>相关话题</strong></p>
                              <ul>
                                 <li><a href="using-binary-XML-with-Java.html#GUID-38D2C558-108C-449A-A9CD-BC2DAD163D5C" title="这里的主题解释了如何在Java中使用二进制XML。">在Java中使用二进制XML</a></li>
                              </ul>
                           </div>
                        </div>
                        
                     </div>
                  </div><a id="ADXDK1074"></a><a id="ADXDK19126"></a><div class="props_rev_3"><a id="GUID-D2C5A5C3-9753-4A27-A8FF-A36541E83C3D" name="GUID-D2C5A5C3-9753-4A27-A8FF-A36541E83C3D"></a><h5 id="ADXDK-GUID-D2C5A5C3-9753-4A27-A8FF-A36541E83C3D" class="sect5">使用Lazy Materialization</h5>
                     <div>
                        <p>使用延迟实现，您可以插入一个空DOM，它可以在需要时提取数据，并在不再需要时释放（取消引用）节点。SDOM支持手动或自动节点解除引用。</p>
                     </div><a id="ADXDK19127"></a><div class="props_rev_3"><a id="GUID-F0934CA5-F70E-4A1A-9001-CDCC3565FEC9" name="GUID-F0934CA5-F70E-4A1A-9001-CDCC3565FEC9"></a><h6 id="ADXDK-GUID-F0934CA5-F70E-4A1A-9001-CDCC3565FEC9" class="sect6">按需提取数据</h6>
                        <div>
                           <p>插件DOM体系结构创建一个空DOM，其中包含一个<code class="codeph">Document</code>节点作为树的根。如果访问DOM树的其余部分，则可以稍后进行扩展。
                           </p>
                           <p>节点可以具有未展开的子节点和兄弟节点，但其父节点和祖先节点始终是扩展的。每个节点都维护<code class="codeph">InfoSetReader.下一个节点的Offset</code>属性，以便DOM可以提取其他数据以创建下一个节点。
                           </p>
                           <p>根据访问方法类型，DOM节点可以扩展超过返回的节点集：</p>
                           <div class="tblformal" id="GUID-F0934CA5-F70E-4A1A-9001-CDCC3565FEC9__GUID-9DD24819-2379-4F98-AA7B-51D9355F7FB0">
                              <table cellpadding="4" cellspacing="0" class="Formal" title="" width="100%" border="1" summary="Lists and briefly describes the DOM node access methods." frame="hsides" rules="rows">
                                 <thead>
                                    <tr align="left" valign="top">
                                       <th align="left" valign="bottom" width="29%" id="d35651e4736">访问方法</th>
                                       <th align="left" valign="bottom" width="71%" id="d35651e4739">描述</th>
                                    </tr>
                                 </thead>
                                 <tbody>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="29%" id="d35651e4744" headers="d35651e4736 ">
                                          <p>DOM导航</p>
                                       </td>
                                       <td align="left" valign="top" width="71%" headers="d35651e4744 d35651e4739 ">
                                          <p>允许访问相邻节点，例如第一个孩子，最后一个孩子，父母，前一个兄弟或下一个兄弟。如果需要创建节点，则按文档顺序完成。</p>
                                       </td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="29%" id="d35651e4751" headers="d35651e4736 ">
                                          <p>标识符（ID）索引</p>
                                       </td>
                                       <td align="left" valign="top" width="71%" headers="d35651e4751 d35651e4739 ">
                                          <p>DTD或XML模式可以指定具有类型ID的节点。如果DOM支持ID索引，则可以使用索引直接检索这些节点。在可伸缩DOM中，按索引检索不会导致所有先前节点的扩展，但是它们的祖先节点已实现。</p>
                                       </td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="29%" id="d35651e4758" headers="d35651e4736 ">
                                          <p>XPath表达式</p>
                                       </td>
                                       <td align="left" valign="top" width="71%" headers="d35651e4758 d35651e4739 ">
                                          <p>XPath评估可以导致内存中所有中间节点的实现。例如，后代轴'//'扩展整个子树，尽管某些节点可能在评估后释放。</p>
                                       </td>
                                    </tr>
                                 </tbody>
                              </table>
                           </div>
                           <!-- class="inftblhruleinformal" -->
                        </div>
                     </div><a id="ADXDK1075"></a><div class="props_rev_3"><a id="GUID-58BABDA4-5BAE-4FD6-BE4C-E93F4D6E4294" name="GUID-58BABDA4-5BAE-4FD6-BE4C-E93F4D6E4294"></a><h6 id="ADXDK-GUID-58BABDA4-5BAE-4FD6-BE4C-E93F4D6E4294" class="sect6">使用自动节点解除引用</h6>
                        <div>
                           <p>DOM导航支持需要节点之间的其他链接。在自动解除引用模式下，可以在垃圾回收期间自动解除引用弱链接。要使用自动节点解除引用，请将<code class="codeph">PARTIAL_DOM</code>属性设置为<code class="codeph">Boolean.TRUE</code> 。</p>
                           <div class="section">
                              <p>节点发布取决于链接重要性。无法删除父节点的链接，因为祖先为范围内命名空间提供了上下文，并且很难使用流式API（如<code class="codeph">InfosetReader</code>检索丢弃的父节点。
                              </p>
                              <p>在SDOM树中，父节点和先前兄弟节点的链接很强，并且到子节点和后节点节点的链接很弱。当JVM释放节点时，对它们的引用仍然可用于底层数据，因此可以根据需要重新创建它们。</p>
                           </div>
                           <!-- class="section" -->
                        </div>
                     </div><a id="ADXDK1076"></a><div class="props_rev_3"><a id="GUID-0EE1A341-D1A3-4418-B943-69D68A4A66BE" name="GUID-0EE1A341-D1A3-4418-B943-69D68A4A66BE"></a><h6 id="ADXDK-GUID-0EE1A341-D1A3-4418-B943-69D68A4A66BE" class="sect6">使用手动节点解除引用</h6>
                        <div>
                           <p>描述了手动节点解除引用。</p>
                           <div class="section">
                              <p>在手动解除引用模式下，没有弱引用。应用程序必须显式地取消引用DOM树中的文档片段。如果应用程序以确定的顺序处理数据，那么Oracle建议避免重复释放和重新创建节点的额外开销。</p>
                              <p>要使用手动节点解除引用，请将<code class="codeph">PARTIAL_DOM</code>属性<code class="codeph">PARTIAL_DOM</code>为<code class="codeph">Boolean.FALSE</code>并使用插件XML数据创建SDOM。
                              </p>
                              <p>要从所有其他节点手动取消引用节点，请调用<code class="codeph">freeNode()</code> 。例如：</p><pre class="oac_no_warn" dir="ltr">元素root = doc.getDocumentElement（）; Node item = root.getFirstChild（）;虽然（项目！= null）{processItem（item）;节点tmp = item; item = item.getNextSibling（）; <span class="bold">（（的XMLNode）TMP）.freeNode（）;</span> }</pre><p>取消引用节点不会将其从SDOM树中删除。仍然可以从其父节点，先前节点和后面的兄弟节点访问和重新创建节点。但是，在取消引用节点后，保存节点的变量在访问节点时会引发错误。</p>
                              <div class="infoboxnote" id="GUID-0EE1A341-D1A3-4418-B943-69D68A4A66BE__GUID-111AF5FD-2DD0-4B92-9184-F3715340CF91">
                                 <p class="notep1">注意：</p>
                                 <p><code class="codeph">freeNode</code>调用对不可<code class="codeph">freeNode</code> DOM没有影响。</p>
                              </div>
                           </div>
                           <!-- class="section" -->
                        </div>
                     </div><a id="ADXDK19129"></a><div class="props_rev_3"><a id="GUID-000BEA9C-8AAB-4C04-9BFB-A4BCBC18ACC9" name="GUID-000BEA9C-8AAB-4C04-9BFB-A4BCBC18ACC9"></a><h6 id="ADXDK-GUID-000BEA9C-8AAB-4C04-9BFB-A4BCBC18ACC9" class="sect6">使用卷影复制</h6>
                        <div>
                           <p>卷影副本通过让DOM节点共享其数据来避免数据复制。</p>
                           <p>克隆是XML处理中的常见操作，可以使用SDOM懒散地完成。也就是说， <code class="codeph">copy</code>方法仅创建正在复制的片段的根节点，并且仅在需要时扩展子树。
                           </p>
                           <p>DOM节点本身不共享;他们的基础数据是共享的。DOM规范要求克隆及其原始具有不同的节点标识和不同的父节点。</p>
                        </div>
                     </div><a id="ADXDK19130"></a><div class="props_rev_3"><a id="GUID-EA7D0251-45FE-4E96-91F9-062BCBCDD7D3" name="GUID-EA7D0251-45FE-4E96-91F9-062BCBCDD7D3"></a><h6 id="ADXDK-GUID-EA7D0251-45FE-4E96-91F9-062BCBCDD7D3" class="sect6">合并DOM更新</h6>
                        <div>
                           <p>DOM API支持更新操作，例如添加和删除节点以及设置，删除，更改和插入值。</p>
                           <div class="section">
                              <p>当通过插入XML数据创建DOM时，底层数据被认为是DOM的外部数据。 DOM更新在DOM API中可见，但数据源保持不变。可以使用正常的更新操作，并且不会相互干扰。</p>
                              <p>要使修改后的DOM持久化，必须显式保存DOM。保存将更改与原始数据合并，并将数据序列化为持久存储。如果未明确保存修改后的DOM，则在事务结束时更改将丢失。</p>
                           </div>
                           <!-- class="section" -->
                        </div>
                     </div><a id="ADXDK19131"></a><div class="props_rev_3"><a id="GUID-4F4E67FB-711D-4E16-AB08-FC35BBEECCF1" name="GUID-4F4E67FB-711D-4E16-AB08-FC35BBEECCF1"></a><h6 id="ADXDK-GUID-4F4E67FB-711D-4E16-AB08-FC35BBEECCF1" class="sect6">使用PageManager接口支持内部数据</h6>
                        <div>
                           <p>如何使用<code class="codeph">PageManager</code>接口让SDOM使用后端存储来存储二进制数据。
                           </p>
                           <div class="section">
                              <p>当使用<code class="codeph">DOMParser</code>解析XML文本并将其配置为创建SDOM时，内部数据以二进制XML的形式缓存，而DOM API层构建在内部数据之上。这提供了更高的可伸缩性，因为二进制XML比DOM节点更紧凑。
                              </p>
                              <p>为了获得额外的可扩展性，SDOM可以通过<code class="codeph">PageManager</code>接口将后端存储用于二进制数据。然后，二进制数据可以在不使用时换出内存。
                              </p>
                              <p>此代码显示如何使用<code class="codeph">PageManager</code>接口：</p><pre class="oac_no_warn" dir="ltr">DOMParser解析器=新的DOMParser（）; parser.setAttribute（PARTIAL_DOM，Boolean。真正）; //启用SDOM parser.setAttribute（PAGE_MANAGER，new FilePageManager（“pageFile”））; ...// DOMParser其他配置parser.parse（fileURL）; XMLDocument doc = parser.getDocument（）;</pre><p>如果不使用<code class="codeph">PageManager</code>接口，则解析器将整个文档缓存为二进制XML。</p>
                           </div>
                           <!-- class="section" -->
                        </div>
                     </div>
                  </div><a id="ADXDK19132"></a><div class="props_rev_3"><a id="GUID-C5348B7D-15FD-4374-8D61-C913DEBA3EBC" name="GUID-C5348B7D-15FD-4374-8D61-C913DEBA3EBC"></a><h5 id="ADXDK-GUID-C5348B7D-15FD-4374-8D61-C913DEBA3EBC" class="sect5">使用可配置的DOM设置</h5>
                     <div>
                        <p>使用类<code class="codeph">XMLDOMImplementation</code>创建DOM时，可以使用方法<code class="codeph">setAttribute</code>为不同的应用程序配置DOM并实现最高效率。
                        </p>
                        <div class="section"><pre class="pre codeblock"><code><code class="codeph">public void setAttribute（String name，Object value）抛出IllegalArgumentException</code>
</code></pre><p>对于SDOM，请为<code class="codeph">PARTIAL_DOM</code>和<code class="codeph">ACCESS_MODE</code>属性调用<code class="codeph">setAttribute</code> 。
                           </p>
                           <div class="infoboxnote" id="GUID-C5348B7D-15FD-4374-8D61-C913DEBA3EBC__GUID-091E7B08-8F31-4BF1-BDBF-EE0C8AA81CA5">
                              <p class="notep1">注意：</p>
                              <p>新属性值始终影响下一个DOM，而不是当前DOM。因此，您可以使用<code class="codeph">XMLDOMImplementation</code>实例来创建具有不同配置的DOM。
                              </p>
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div><a id="ADXDK1077"></a><div class="props_rev_3"><a id="GUID-21E3BF40-67ED-4742-A8A7-1C4687E4D187" name="GUID-21E3BF40-67ED-4742-A8A7-1C4687E4D187"></a><h6 id="ADXDK-GUID-21E3BF40-67ED-4742-A8A7-1C4687E4D187" class="sect6">PARTIAL_DOM属性</h6>
                        <div>
                           <p>属性<code class="codeph">PARTIAL_DOM</code>确定创建的DOM是否是部分的，即可伸缩的。当它具有值<code class="codeph">TRUE</code> ，DOM是可伸缩的（即，在需要时释放并重新创建未使用的节点）。如果值为<code class="codeph">FALSE</code> ，则创建的DOM不可伸缩。
                           </p>
                        </div>
                     </div><a id="ADXDK1078"></a><div class="props_rev_3"><a id="GUID-8E768BE9-0EE6-4BF5-8A20-5CAC499B40B0" name="GUID-8E768BE9-0EE6-4BF5-8A20-5CAC499B40B0"></a><h6 id="ADXDK-GUID-8E768BE9-0EE6-4BF5-8A20-5CAC499B40B0" class="sect6">ACCESS_MODE属性</h6>
                        <div>
                           <p>属性<code class="codeph">ACCESS_MODE</code> （适用于SDOM和不可扩展的DOM）控制对创建的DOM的访问。</p>
                           <p><a href="XML-parsing-for-Java.html#GUID-8E768BE9-0EE6-4BF5-8A20-5CAC499B40B0__GUID-6AAC2D0C-C6A3-4D2F-AAEB-F228DF56154A" title="列出ACCESS_MODE属性值从最小到最严格，并解释它们对DOM访问和性能优势的影响。">表12-8</a>中显示了从最小到最严格的属性值。
                           </p>
                           <div class="tblformal" id="GUID-8E768BE9-0EE6-4BF5-8A20-5CAC499B40B0__GUID-6AAC2D0C-C6A3-4D2F-AAEB-F228DF56154A">
                              <p class="titleintable">表12-8 ACCESS_MODE属性值</p>
                              <table cellpadding="4" cellspacing="0" class="Formal" title="ACCESS_MODE属性值" width="100%" border="1" summary="Lists ACCESS_MODE attribute values from least to most restrictive and explains their effect on DOM access and performance advantages." frame="hsides" rules="rows">
                                 <thead>
                                    <tr align="left" valign="top">
                                       <th align="left" valign="bottom" width="19%" id="d35651e5530">值</th>
                                       <th align="left" valign="bottom" width="51%" id="d35651e5533">DOM访问</th>
                                       <th align="left" valign="bottom" width="30%" id="d35651e5536">性能优势</th>
                                    </tr>
                                 </thead>
                                 <tbody>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="19%" id="d35651e5541" headers="d35651e5530 ">
                                          <p><code class="codeph">UPDATEABLE</code></p>
                                       </td>
                                       <td align="left" valign="top" width="51%" headers="d35651e5541 d35651e5533 ">
                                          <p>允许所有更新操作。这是默认值，用于向后兼容XDK DOM实现。</p>
                                       </td>
                                       <td align="left" valign="top" width="30%" headers="d35651e5541 d35651e5536 ">
                                          <p></p>
                                       </td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="19%" id="d35651e5551" headers="d35651e5530 ">
                                          <p><code class="codeph">只读</code></p>
                                       </td>
                                       <td align="left" valign="top" width="51%" headers="d35651e5551 d35651e5533 ">
                                          <p>不允许DOM更新操作。仅当新节点未添加到DOM树时，才允许创建节点（例如，克隆）。</p>
                                       </td>
                                       <td align="left" valign="top" width="30%" headers="d35651e5551 d35651e5536 ">
                                          <p>未创建写缓冲区。</p>
                                       </td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="19%" id="d35651e5562" headers="d35651e5530 ">
                                          <p><code class="codeph">FORWARD_READ</code></p>
                                       </td>
                                       <td align="left" valign="top" width="51%" headers="d35651e5562 d35651e5533 ">
                                          <p>允许前向导航（例如， <code class="codeph">getFirstChild().getNextSibling()</code>和<code class="codeph">getLastChild()</code> ）并允许访问父节点和祖先节点;不允许向后导航（例如， <code class="codeph">getPreviousSibling()</code> ）。
                                          </p>
                                       </td>
                                       <td align="left" valign="top" width="30%" headers="d35651e5562 d35651e5536 ">
                                          <p>不创建以前的兄弟链接。</p>
                                       </td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="19%" id="d35651e5582" headers="d35651e5530 ">
                                          <p><code class="codeph">STREAM_READ</code></p>
                                       </td>
                                       <td align="left" valign="top" width="51%" headers="d35651e5582 d35651e5533 ">
                                          <p>限于文档顺序中的节点流，类似于SAX事件访问。</p>
                                          <p>当前节点是按文档顺序访问的最后一个节点。应用程序可以在变量中保存节点并重新访问它们，但在当前节点（父节点或祖先节点除外）之前使用DOM方法访问任何节点会导致错误。例如：</p>
                                          <ul style="list-style-type:disc">
                                             <li>
                                                <p>这是允许的，尽管父节点在当前节点之前：</p><pre class="oac_no_warn" dir="ltr">Node parent = currentNode.getParentNode（）;</pre></li>
                                             <li>
                                                <p>除非当前节点是父节点的第一个子节点，否则会导致错误：</p><pre class="oac_no_warn" dir="ltr">Node child = parent.getFirstChild（）;</pre></li>
                                             <li>
                                                <p>始终允许访问元素属性：</p><pre class="oac_no_warn" dir="ltr">属性attr = parent.getFirstAttribute（）;</pre></li>
                                          </ul>
                                       </td>
                                       <td align="left" valign="top" width="30%" headers="d35651e5582 d35651e5536 ">
                                          <p>DOM只维护父链接，而不维护节点位置;因此，它不需要重新创建释放的节点。</p>
                                       </td>
                                    </tr>
                                 </tbody>
                              </table>
                           </div>
                           <!-- class="inftblhruleinformal" -->
                        </div>
                     </div>
                  </div><a id="ADXDK174"></a><div class="props_rev_3"><a id="GUID-6D67902A-AECA-4DF2-AAA5-C11C1E5E9BD2" name="GUID-6D67902A-AECA-4DF2-AAA5-C11C1E5E9BD2"></a><h5 id="ADXDK-GUID-6D67902A-AECA-4DF2-AAA5-C11C1E5E9BD2" class="sect5">使用带有SDOM的快速信息集</h5>
                     <div>
                        <p>Fast Infoset到XDK / J模型允许您在使用Java中的XML内容时使用Fast Infoset技术。</p>
                        <div class="section">
                           <div class="infoboxnote" id="GUID-6D67902A-AECA-4DF2-AAA5-C11C1E5E9BD2__GUID-9F2D519C-3294-44E5-AB13-C60B7E0BB823">
                              <p class="notep1">注意：</p>
                              <p>仅将Fast Infoset用于输入。对于输出，请使用CSX或XTI。</p>
                           </div>
                           <p>此示例使用序列化程序将XML数据编码为FastInfoset <code class="codeph">BinaryStream</code> ：</p><pre class="pre codeblock"><code>public com.sun.xml.fastinfoset.sax。SAXDocumentSerializer getSAXDocumentSerializer（）; public com.sun.xml.fastinfoset.stax。StAXDocumentSerializer getStAXDocumentSerializer（）;</code></pre><p>类<code class="codeph">oracle.xml.scalable.BinaryStream</code>是数据管理组件，它提供缓冲区管理和抽象分页I / O视图，以支持对不同类型的数据存储进行解码。
                           </p>
                           <p><code class="codeph">BinaryStream</code>的<code class="codeph">InfosetReader</code>是<code class="codeph">InfosetReader</code>的实现<code class="codeph">oracle.xml.scalable.用于DOM的InfosetReader</code>从二进制读取数据。该实现扩展了基本解码器<code class="codeph">sun.com.xml.fasterinfoset.Decoder</code>并添加对搜索和跳过操作的支持。
                           </p>
                           <p>您可以使用Fast Infoset和Streaming API for XML（StAX）和SAX来创建DOM。要创建SDOM，可以使用前面示例中的例程和本示例中的例程：</p><pre class="pre codeblock"><code>String xmlFile，fiFile; FileInputStream xin = new FileInputStream（new File（xmlFile））; XML_SAX_FI figen = new XML_SAX_FI（）; FileOutputStream outfi = new FileOutputStream（new File（fiFile））; figen.parse（xin，outfi）; outfi.close（）; import oracle.xml.scalable。BinaryStream; BinaryStream stream = BinaryStream.newInstance（SUN_FI）; stream.setFile（new File（fiFile））; InfosetReader reader = stream.getInfosetReader（）; XMLDOMImplementation dimp = new XMLDOMImplementation（）; dimp.setAttribute（为XMLDocument。SCALABLE_DOM，布尔值。真正）; XMLDocument doc =（XMLDocument）dimp.createDocument（reader）;</code></pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="ADXDK19134"></a><div class="props_rev_3"><a id="GUID-1CF9E80D-7493-4574-B2DA-F1928F8AD552" name="GUID-1CF9E80D-7493-4574-B2DA-F1928F8AD552"></a><h5 id="ADXDK-GUID-1CF9E80D-7493-4574-B2DA-F1928F8AD552" class="sect5">SDOM应用程序</h5>
                     <div>
                        <p>提供了创建和使用SDOM的应用程序。</p>
                        <p>此应用程序创建并使用SDOM：</p><pre class="oac_no_warn" dir="ltr">XMLDOMImplementation domimpl = new XMLDOMImplementation（）; domimpl.setAttribute（为XMLDocument。SCALABLE_DOM，布尔值。真正）; domimpl.setAttribute（为XMLDocument。ACCESS_MODE，为XMLDocument。UPDATEABLE）; XMLDocument scalableDoc =（XMLDocument）domimpl.createDocument（reader）;</pre><p>以下应用程序创建并使用基于二进制XML的SDOM，这在<a href="using-binary-XML-with-Java.html#GUID-38D2C558-108C-449A-A9CD-BC2DAD163D5C" title="这里的主题解释了如何在Java中使用二进制XML。">使用带有Java的二进制XML中进行了</a>描述：</p><pre class="oac_no_warn" dir="ltr">BinXMLProcessor proc = BinXMLProcessorFactory.createProcessor（）; BinXMLStream bstr = proc.createBinXMLStream（）; BinXMLEncoder enc = bstr.getEncoder（）; enc.setProperty（BinXMLEncoder。ENC_SCHEMA_AWARE，false）; SAXParser解析器=新的SAXParser（）; parser.setContentHandler（enc.getContentHandler（））; parser.setErrorHandler（enc.getErrorHandler（））; parser.parse（BinXMLUtil.createURL（XMLFILE））; BinXMLDecoder dec = bstr.getDecoder（）; InfosetReader reader = dec.getReader（）; XMLDOMImplementation domimpl = new XMLDOMImplementation（）; domimpl.setAttribute（为XMLDocument。SCALABLE_DOM，布尔值。真正）; XMLDocument currentDoc =（XMLDocument）domimpl.createDocument（reader）;</pre></div>
                  </div><a id="ADXDK181"></a><div class="props_rev_3"><a id="GUID-D44D0697-F1FD-47B3-AE85-E101AA807FD5" name="GUID-D44D0697-F1FD-47B3-AE85-E101AA807FD5"></a><h5 id="ADXDK-GUID-D44D0697-F1FD-47B3-AE85-E101AA807FD5" class="sect5">XDK Java DOM改进</h5>
                     <div>
                        <p>XDK支持DOM Level 3 Core规范，这是W3C的推荐。</p>
                        <div class="infoboxnotealso" id="GUID-D44D0697-F1FD-47B3-AE85-E101AA807FD5__GUID-DAEDC723-554F-4AE0-8655-0B1ACC93C1BC">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/adxdk&amp;id=w3_org_tr_dom_level_3" target="_blank">文档对象模型（DOM）级别3核心规范</a> ，以获取有关DOM级别3的更多信息</p>
                        </div>
                     </div>
                  </div>
               </div><a id="ADXDK19135"></a><div class="props_rev_3"><a id="GUID-C198CA9B-369E-4352-AABC-3BC0A52BA642" name="GUID-C198CA9B-369E-4352-AABC-3BC0A52BA642"></a><h4 id="ADXDK-GUID-C198CA9B-369E-4352-AABC-3BC0A52BA642" class="sect4">使用命名空间执行DOM操作</h4>
                  <div>
                     <p><code class="codeph">DOM2Namespace.java</code>显示了对DOM API的解析器和命名空间扩展的简单使用。程序接收XML文档，对其进行解析，并在文档中打印元素和属性。
                     </p>
                     <div class="section">
                        <p>本节包含<code class="codeph">DOM2Namespace.java</code>程序中的一些代码。有关更多详细信息，请参阅程序本身。
                        </p>
                        <p>从解析器创建到<code class="codeph">getDocument()</code>调用， <a href="XML-parsing-for-Java.html#GUID-7C91F2D5-350D-4530-8988-295EF0B60D53" title="DOMSample.java显示了解析输入XML文档并通过DOM访问它的基本步骤。 DOMSample.java接收XML文件作为输入，解析它，并在DOM树中打印元素和属性。">执行基本DOM解析</a>的前四个步骤对于<code class="codeph">DOM2Namespace.java</code>基本相同。主要区别在于打印DOM树（步骤<a href="XML-parsing-for-Java.html#GUID-7C91F2D5-350D-4530-8988-295EF0B60D53__CCHBFACH">5</a> ）。<code class="codeph">DOM2Namespace.java</code>程序改为：</p><pre class="oac_no_warn" dir="ltr">//打印文档元素printElements（doc）; //打印文档元素属性System.out.println（“每个元素的属性为：”）; printElementAttributes（DOC）;</pre><p>该<code class="codeph">printElements()</code>的实现方法<code class="codeph">DOM2Namespace.java</code>调用<code class="codeph">getElementsByTagName()</code>获取DOM树的所有元素的列表。然后循环遍历列表中的每个项目，并将每个<code class="codeph">Element</code>转换为<code class="codeph">nsElement</code> 。对于每个<code class="codeph">nsElement</code>它调用<code class="codeph">nsElement.getPrefix()</code>来获取名称空间前缀， <code class="codeph">nsElement.getLocalName()</code>来获取本地名称，并使用<code class="codeph">nsElement.getNamespaceURI()</code>来获取名称空间URI：</p><pre class="oac_no_warn" dir="ltr">static void printElements（Document doc）{NodeList nl = doc.getElementsByTagName（“*”）;元素nsElement;字符串前缀; String localName; String nsName; System.out.println（“元素是：”）; for（int i = 0; i &lt;nl.getLength（）; i ++）{nsElement =（Element）nl.item（i）; prefix = nsElement.getPrefix（）; System.out.println（“ELEMENT前缀名称：”+前缀）; localName = nsElement.getLocalName（）; System.out.println（“ELEMENT Local Name：”+ localName）; nsName = nsElement.getNamespaceURI（）; System.out.println（“ELEMENT命名空间：”+ nsName）; System.out.println（）; }</pre><p><code class="codeph">printElementAttributes()</code>方法调用<code class="codeph">Document.getElementsByTagName()</code>以获取DOM树中元素的<code class="codeph">NodeList</code> 。然后循环遍历每个元素并调用<code class="codeph">Element.getAttributes()</code>以获取元素的属性列表作为名为<code class="codeph">NamedNodeMap</code>特殊列表。对于属性列表中的每个项，它调用<code class="codeph">nsAttr.getPrefix()</code>来获取名称空间前缀， <code class="codeph">nsAttr.getLocalName()</code>来获取本地名称，并使用<code class="codeph">nsAttr.getValue()</code>来获取值：</p><pre class="oac_no_warn" dir="ltr">static void printElementAttributes（Document doc）{NodeList nl = doc.getElementsByTagName（“*”）;元素e; Attr nsAttr; String attrpfx;字符串attrname;字符串attrval; NamedNodeMap nnm; int i，len; len = nl.getLength（）; for（int j = 0; j &lt;len; j ++）{e =（Element）nl.item（j）; System.out.println（e.getTagName（）+“：”）; nnm = e.getAttributes（）;如果（nnm！= null）{for（i = 0; i &lt;nnm.getLength（）; i ++）{nsAttr =（Attr）nnm.item（i）; attrpfx = nsAttr.getPrefix（）; attrname = nsAttr.getLocalName（）; attrval = nsAttr.getNodeValue（）; System.out.println（“”+ attrpfx +“：”+ attrname +“=”+ attrval）; System.out.println（）; }}</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ADXDK19136"></a><div class="props_rev_3"><a id="GUID-736B0616-33E7-4DB2-93B8-BA6D7E441DF2" name="GUID-736B0616-33E7-4DB2-93B8-BA6D7E441DF2"></a><h4 id="ADXDK-GUID-736B0616-33E7-4DB2-93B8-BA6D7E441DF2" class="sect4">使用事件执行DOM操作</h4>
                  <div>
                     <p><code class="codeph">EventSample.java</code>显示了如何使用事件侦听器注册事件。例如，将节点添加到指定的DOM元素会触发事件，这会导致侦听器打印有关事件的信息。
                     </p>
                     <div class="section">
                        <p>本节包含<code class="codeph">EventSample.java</code>程序中的一些代码。有关更多详细信息，请参阅程序本身。
                        </p>
                        <p><code class="codeph">EventSample.java</code>程序遵循以下步骤：</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>实例化事件侦听器。</span><div>
                              <p>当已注册的更改触发事件时，事件将传递给处理它的事件侦听器。<code class="codeph">EventSample.java</code>中的此代码片段显示了侦听器的实现：</p><pre class="oac_no_warn" dir="ltr">eventlistener evtlist = new eventlistener（）; ...class eventlistener实现EventListener {public eventlistener（）{} public void handleEvent（Event e）{String s =“Event”+ e.getType（）+“received”+“\ n”; s + =“事件可以取消：”+ e.getCancelable（）+“\ n”; s + =“事件是冒泡事件：”+ e.getBubbles（）+“\ n”; s + =“目标是”+（（节点）（e.getTarget（）））。getNodeName（）+“\ n \ n”;的System.out.println（一个或多个）; }}</pre></div>
                        </li>
                        <li class="stepexpand"><span>实例化一个新的<code class="codeph">XMLDocument</code> ，然后调用<code class="codeph">getImplementation()</code>来检索<code class="codeph">DOMImplementation</code>对象。</span><div>
                              <p>调用<code class="codeph">hasFeature()</code>方法来确定此实现支持哪些功能，因为<code class="codeph">EventSample.java</code>中的此代码片段执行：</p><pre class="oac_no_warn" dir="ltr">XMLDocument doc1 = new XMLDocument（）; DOMImplementation impl = doc1.getImplementation（）; System.out.println（“impl支持事件”+ impl.hasFeature（“Events”，“2.0”））; System.out.println（“impl支持Mutation Events”+ impl.hasFeature（“MutationEvents”，“2.0”））;</pre></div>
                        </li>
                        <li class="stepexpand"><span>向监听器注册所需的事件。<code class="codeph">EventSample.java</code>此代码片段在文档节点上注册了三个事件：</span><div><pre class="oac_no_warn" dir="ltr">doc1.addEventListener（“DOMNodeRemoved”，evtlist，false）; doc1.addEventListener（“DOMNodeInserted”，evtlist，false）; doc1.addEventListener（“DOMCharacterDataModified”，evtlist，false）;</pre><p>从该代码片段<code class="codeph">EventSample.java</code>创建类型的节点<code class="codeph">XMLElement</code>然后注册的节点上三个事件：</p><pre class="oac_no_warn" dir="ltr">XMLElement el =（XMLElement）doc1.createElement（“element”）; ...el.addEventListener（“DOMNodeRemoved”，evtlist，false）; el.addEventListener（“DOMNodeRemovedFromDocument”，evtlist，false）; el.addEventListener（“DOMCharacterDataModified”，evtlist，false）; ...
</pre></div>
                        </li>
                        <li class="stepexpand"><span>执行触发事件的操作，然后将其传递给侦听器进行处理，因为<code class="codeph">EventSample.java</code>中的此代码片段<code class="codeph">EventSample.java</code>操作：</span><div><pre class="oac_no_warn" dir="ltr">att.setNodeValue（ “ABC”）; el.appendChild（EL1）; el.appendChild（文本）; text.setNodeValue（ “XYZ”）; doc1.removeChild（EL）;</pre></div>
                        </li>
                     </ol>
                  </div>
               </div><a id="ADXDK19138"></a><a id="ADXDK19137"></a><div class="props_rev_3"><a id="GUID-0B8B9513-6E00-46BD-BEED-122D2AD0A5C3" name="GUID-0B8B9513-6E00-46BD-BEED-122D2AD0A5C3"></a><h4 id="ADXDK-GUID-0B8B9513-6E00-46BD-BEED-122D2AD0A5C3" class="sect4">使用范围执行DOM操作</h4>
                  <div>
                     <p>根据W3C DOM规范， <span class="bold">范围</span>标识<code class="codeph">Document</code> ， <code class="codeph">DocumentFragment</code>或<code class="codeph">Attr</code>的一系列内容。范围选择对应于范围的开始和结束的一对边界点之间的内容。
                     </p>
                     <div class="section">
                        <p><a href="XML-parsing-for-Java.html#GUID-0B8B9513-6E00-46BD-BEED-122D2AD0A5C3__CCHBADDC" title="此表描述了XMLDocument类中的有用范围方法。">表12-9</a>描述了可通过<code class="codeph">XMLDocument</code>访问的范围方法。
                        </p>
                        <div class="tblformal" id="GUID-0B8B9513-6E00-46BD-BEED-122D2AD0A5C3__CCHBADDC">
                           <p class="titleintable">表12-9范围类方法</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="范围类方法" width="100%" border="1" summary="This table describes useful range methods in the XMLDocument class." frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="30%" id="d35651e6339">方法</th>
                                    <th align="left" valign="bottom" width="70%" id="d35651e6342">描述</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="30%" id="d35651e6347" headers="d35651e6339 ">
                                       <p><code class="codeph">cloneContents（）</code></p>
                                    </td>
                                    <td align="left" valign="top" width="70%" headers="d35651e6347 d35651e6342 ">
                                       <p>复制范围的内容</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="30%" id="d35651e6355" headers="d35651e6339 ">
                                       <p><code class="codeph">deleteContents（）</code></p>
                                    </td>
                                    <td align="left" valign="top" width="70%" headers="d35651e6355 d35651e6342 ">
                                       <p>删除范围的内容</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="30%" id="d35651e6363" headers="d35651e6339 ">
                                       <p><code class="codeph">getCollapsed（）</code></p>
                                    </td>
                                    <td align="left" valign="top" width="70%" headers="d35651e6363 d35651e6342 ">
                                       <p>返回<code class="codeph">TRUE</code>是折叠范围</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="30%" id="d35651e6374" headers="d35651e6339 ">
                                       <p><code class="codeph">getEndContainer（）</code></p>
                                    </td>
                                    <td align="left" valign="top" width="70%" headers="d35651e6374 d35651e6342 ">
                                       <p>获取范围结束的节点</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="30%" id="d35651e6382" headers="d35651e6339 ">
                                       <p><code class="codeph">getStartContainer（）</code></p>
                                    </td>
                                    <td align="left" valign="top" width="70%" headers="d35651e6382 d35651e6342 ">
                                       <p>获取范围开始的节点</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="30%" id="d35651e6390" headers="d35651e6339 ">
                                       <p><code class="codeph">selectNode（）</code></p>
                                    </td>
                                    <td align="left" valign="top" width="70%" headers="d35651e6390 d35651e6342 ">
                                       <p>选择节点及其内容</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="30%" id="d35651e6398" headers="d35651e6339 ">
                                       <p><code class="codeph">selectNodeContents（）</code></p>
                                    </td>
                                    <td align="left" valign="top" width="70%" headers="d35651e6398 d35651e6342 ">
                                       <p>选择节点的内容</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="30%" id="d35651e6406" headers="d35651e6339 ">
                                       <p><code class="codeph">SETEND（）</code></p>
                                    </td>
                                    <td align="left" valign="top" width="70%" headers="d35651e6406 d35651e6342 ">
                                       <p>设置描述范围结束的属性</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="30%" id="d35651e6414" headers="d35651e6339 ">
                                       <p><code class="codeph">setStart（）</code></p>
                                    </td>
                                    <td align="left" valign="top" width="70%" headers="d35651e6414 d35651e6342 ">
                                       <p>设置描述范围起点的属性</p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <p><code class="codeph">DOMRangeSample.java</code>程序显示了一些可以使用范围执行的操作。本节包含<code class="codeph">DOMRangeSample.java</code>程序中的一些代码。有关更多详细信息，请参阅程序本身。
                        </p>
                        <p>从解析器创建到<code class="codeph">getDocument()</code>调用， <a href="XML-parsing-for-Java.html#GUID-7C91F2D5-350D-4530-8988-295EF0B60D53" title="DOMSample.java显示了解析输入XML文档并通过DOM访问它的基本步骤。 DOMSample.java接收XML文件作为输入，解析它，并在DOM树中打印元素和属性。">执行基本DOM解析</a>的前四个步骤对于<code class="codeph">DOMRangeSample.java</code>是相同的。然后， <code class="codeph">DOMRangeSample.java</code>程序遵循以下步骤：</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>在调用<code class="codeph">getDocument()</code>以创建<code class="codeph">XMLDocument</code> ，使用<code class="codeph">createRange()</code>创建一个范围对象并调用<code class="codeph">setStart()</code>和<code class="codeph">setEnd()</code>来设置其边界，因为<code class="codeph">DOMRangeSample.java</code>中的此代码片段执行：</span><div><pre class="oac_no_warn" dir="ltr">XMLDocument doc = parser.getDocument（）; ...范围r =（范围）doc.createRange（）; XMLNode c =（XMLNode）doc.getDocumentElement（）; //设置边界r.setStart（c，0）; r.setEnd（C，1）;</pre></div>
                        </li>
                        <li class="stepexpand"><span>调用<code class="codeph">XMLDocument</code>方法以获取有关范围的信息并操纵其内容。</span><div>
                              <p><code class="codeph">DOMRangeSample.java</code>此代码片段选择并打印当前节点的内容：</p><pre class="oac_no_warn" dir="ltr">r.selectNodeContents（C）;的System.out.println（r.toString（））;</pre><p>此代码片段克隆并打印范围的内容：</p><pre class="oac_no_warn" dir="ltr">XMLDocumentFragment df =（XMLDocumentFragment）r.cloneContents（）; df.print（System.out的）;</pre><p>此代码片段获取并打印该范围的开始和结束容器：</p><pre class="oac_no_warn" dir="ltr">c =（XMLNode）r.getStartContainer（）;的System.out.println（c.getText（））; c =（XMLNode）r.getEndContainer（）;的System.out.println（c.getText（））;</pre></div>
                        </li>
                     </ol>
                  </div>
               </div><a id="ADXDK19140"></a><a id="ADXDK19141"></a><a id="ADXDK19139"></a><div class="props_rev_3"><a id="GUID-7F97E630-D288-4D31-9880-D74B12B63FB0" name="GUID-7F97E630-D288-4D31-9880-D74B12B63FB0"></a><h4 id="ADXDK-GUID-7F97E630-D288-4D31-9880-D74B12B63FB0" class="sect4">使用TreeWalker执行DOM操作</h4>
                  <div>
                     <p>XDK实现<code class="codeph">NodeFilter</code>和<code class="codeph">TreeWalker</code>接口，这些接口由W3C DOM Level 2 Traversal和Range规范定义。
                     </p>
                     <div class="section">
                        <p>节点过滤器是可以过滤掉某些类型的<code class="codeph">Node</code>对象的对象。例如，它可以过滤掉实体引用节点，但接受元素和属性节点。您可以通过实现<code class="codeph">NodeFilter</code>接口然后将<code class="codeph">Node</code>对象传递给<code class="codeph">acceptNode()</code>方法来创建节点过滤器。通常， <code class="codeph">acceptNode()</code>方法实现调用<code class="codeph">getNodeType()</code>来获取节点的类型，并将其与静态变量（如<code class="codeph">ELEMENT_TYPE</code> ， <code class="codeph">ATTRIBUTE_TYPE</code>等）进行比较，然后返回<a href="XML-parsing-for-Java.html#GUID-7F97E630-D288-4D31-9880-D74B12B63FB0__CCHHHHAH" title="此表描述了NodeFilter接口中的有用变量。">表12-10中</a>列出的静态字段之一，基于它发现的东西。
                        </p>
                        <div class="tblformal" id="GUID-7F97E630-D288-4D31-9880-D74B12B63FB0__CCHHHHAH">
                           <p class="titleintable">表12-10 NodeFilter接口中的静态字段</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="NodeFilter接口中的静态字段" width="100%" border="1" summary="This table describes useful variables in the NodeFilter interface." frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="18%" id="d35651e6629">领域</th>
                                    <th align="left" valign="bottom" width="82%" id="d35651e6632">描述</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="18%" id="d35651e6637" headers="d35651e6629 ">
                                       <p><code class="codeph">FILTER_ACCEPT</code></p>
                                    </td>
                                    <td align="left" valign="top" width="82%" headers="d35651e6637 d35651e6632 ">
                                       <p>接受节点。为<code class="codeph">NodeIterator</code>或<code class="codeph">TreeWalker</code>定义的导航方法返回此节点。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="18%" id="d35651e6651" headers="d35651e6629 ">
                                       <p><code class="codeph">FILTER_REJECT</code></p>
                                    </td>
                                    <td align="left" valign="top" width="82%" headers="d35651e6651 d35651e6632 ">
                                       <p>拒绝节点。为<code class="codeph">NodeIterator</code>或<code class="codeph">TreeWalker</code>定义的导航方法不返回此节点。对于<code class="codeph">TreeWalker</code> ，此节点的子节点也被拒绝。<code class="codeph">NodeIterator</code>把<code class="codeph">FILTER_REJECT</code>作为的代名词<code class="codeph">FILTER_SKIP</code> 。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="18%" id="d35651e6678" headers="d35651e6629 ">
                                       <p><code class="codeph">FILTER_SKIP</code></p>
                                    </td>
                                    <td align="left" valign="top" width="82%" headers="d35651e6678 d35651e6632 ">
                                       <p>跳过此单个节点。为<code class="codeph">NodeIterator</code>或<code class="codeph">TreeWalker</code>定义的导航方法不返回此节点。对于<code class="codeph">NodeIterator</code>和<code class="codeph">TreeWalker</code> ，都会考虑此节点的子节点。
                                       </p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <p>您可以使用<code class="codeph">TreeWalker</code>对象来遍历文档树或子树，使用<code class="codeph">whatToShow</code>标志定义的文档视图和<code class="codeph">TreeWalker</code>对象的过滤器。
                        </p>
                        <p>要创建<code class="codeph">TreeWalker</code>对象，请使用<code class="codeph">XMLDocument.createTreeWalker()</code>方法，指定：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p>树或子树的根节点</p>
                           </li>
                           <li>
                              <p>一个标志，用于控制要包含在逻辑视图中的节点类型</p>
                           </li>
                           <li>
                              <p>节点过滤器（可选）</p>
                           </li>
                           <li>
                              <p>一个标志，用于确定是否包含实体引用及其后代</p>
                           </li>
                        </ul>
                        <p><a href="XML-parsing-for-Java.html#GUID-7F97E630-D288-4D31-9880-D74B12B63FB0__CCHGGBGD" title="此表描述了TreeWalker接口中的方法。">表12-11</a>描述了<code class="codeph">org.w3c.dom.traversal.中的方法<code class="codeph">org.w3c.dom.traversal.TreeWalker</code>界面。
                        </p>
                        <div class="tblformal" id="GUID-7F97E630-D288-4D31-9880-D74B12B63FB0__CCHGGBGD">
                           <p class="titleintable">表12-11 TreeWalker接口方法</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="TreeWalker接口方法" width="100%" border="1" summary="This table describes methods in the TreeWalker interface." frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="19%" id="d35651e6749">方法</th>
                                    <th align="left" valign="bottom" width="81%" id="d35651e6752">描述</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="19%" id="d35651e6757" headers="d35651e6749 ">
                                       <p><code class="codeph">第一个孩子（）</code></p>
                                    </td>
                                    <td align="left" valign="top" width="81%" headers="d35651e6757 d35651e6752 ">
                                       <p>将树步行器移动到当前节点的第一个可见子节点并返回新节点。如果当前节点没有可见子节点，则该方法返回<code class="codeph">null</code>并保留当前节点。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="19%" id="d35651e6768" headers="d35651e6749 ">
                                       <p><code class="codeph">getRoot（）</code></p>
                                    </td>
                                    <td align="left" valign="top" width="81%" headers="d35651e6768 d35651e6752 ">
                                       <p>获取树walker的根节点（在创建<code class="codeph">TreeWalker</code>对象时指定）。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="19%" id="d35651e6779" headers="d35651e6749 ">
                                       <p><code class="codeph">最后一个孩子（）</code></p>
                                    </td>
                                    <td align="left" valign="top" width="81%" headers="d35651e6779 d35651e6752 ">
                                       <p>将树步行器移动到当前节点的最后一个可见子节点并返回新节点。如果当前节点没有可见子节点，则该方法返回<code class="codeph">null</code>并保留当前节点。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="19%" id="d35651e6790" headers="d35651e6749 ">
                                       <p><code class="codeph">nextNode（）</code></p>
                                    </td>
                                    <td align="left" valign="top" width="81%" headers="d35651e6790 d35651e6752 ">
                                       <p>将树步行器按文档顺序移动到相对于当前节点的下一个可见节点，并返回新节点。</p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <p><code class="codeph">TreeWalkerSample.java</code>程序显示了可以使用节点过滤器和树步行器执行的一些操作。本节包含<code class="codeph">TreeWalkerSample.java</code>程序中的一些代码。有关更多详细信息，请参阅程序本身。
                        </p>
                        <p>从解析器创建到<code class="codeph">getDocument()</code>调用， <a href="XML-parsing-for-Java.html#GUID-7C91F2D5-350D-4530-8988-295EF0B60D53" title="DOMSample.java显示了解析输入XML文档并通过DOM访问它的基本步骤。 DOMSample.java接收XML文件作为输入，解析它，并在DOM树中打印元素和属性。">执行基本DOM解析</a>的前四个步骤对于<code class="codeph">TreeWalkerSample.java</code>是相同的。<code class="codeph">TreeWalkerSample.java</code>程序遵循以下步骤：</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>创建节点过滤器对象。</span><div>
                              <p>实现<code class="codeph">NodeFilter</code>接口的<code class="codeph">nf</code>类中的<code class="codeph">acceptNode()</code>方法调用<code class="codeph">getNodeType()</code>来获取节点类型，因为<code class="codeph">TreeWalkerSample.java</code>中的代码片段执行：</p><pre class="oac_no_warn" dir="ltr">NodeFilter n2 = new nf（）; ...class nf实现NodeFilter {public short acceptNode（Node node）{short type = node.getNodeType（）; if（（type == Node。ELEMENT_NODE）|| （type == Node。ATTRIBUTE_NODE））返回FILTER_ACCEPT; if（（type == Node。ENTITY_REFERENCE_NODE））返回FILTER_REJECT;返回FILTER_SKIP; }}</pre></div>
                        </li>
                        <li class="stepexpand"><span>调用<code class="codeph">XMLDocument.createTreeWalker()</code>方法以创建树木助手。</span><div>
                              <p><code class="codeph">TreeWalkerSample.java</code>此代码片段使用<code class="codeph">XMLDocument</code>的根节点作为树walker的根节点，并包括树中的所有节点：</p><pre class="oac_no_warn" dir="ltr">XMLDocument doc = parser.getDocument（）; ...TreeWalker tw = doc.createTreeWalker（doc.getDocumentElement（），NodeFilter。SHOW_ALL，N2，真正的）;</pre></div>
                        </li>
                        <li class="stepexpand"><span>得到的根元素<code class="codeph">TreeWalker</code>对象，如从下面的代码段<code class="codeph">TreeWalkerSample.java</code>作用：</span><div><pre class="oac_no_warn" dir="ltr">XMLNode nn =（XMLNode）tw.getRoot（）;</pre></div>
                        </li>
                        <li class="stepexpand"><span>遍历树。</span><div>
                              <p><code class="codeph">TreeWalkerSample.java</code>此代码片段通过调用<code class="codeph">TreeWalker.nextNode()</code>方法按文档顺序<code class="codeph">TreeWalkerSample.java</code>树：</p><pre class="oac_no_warn" dir="ltr">而（nn！= null）{System.out.println（nn.getNodeName（）+“”+ nn.getNodeValue（））; nn =（XMLNode）tw.nextNode（）; }</pre><p><code class="codeph">TreeWalkerSample.java</code>这段代码片段通过调用<code class="codeph">firstChild()</code>方法<code class="codeph">firstChild()</code>树的左深度：</p><pre class="oac_no_warn" dir="ltr">而（nn！= null）{System.out.println（nn.getNodeName（）+“”+ nn.getNodeValue（））; nn =（XMLNode）tw.firstChild（）; }</pre><p>您可以通过调用<code class="codeph">lastChild()</code>方法<code class="codeph">lastChild()</code>树的正确深度。
                              </p>
                           </div>
                        </li>
                     </ol>
                  </div>
               </div>
            </div><a id="ADXDK980"></a><a id="ADXDK19142"></a><div class="props_rev_3"><a id="GUID-2E469495-7D6C-4EB4-9123-6C3C0CDE1218" name="GUID-2E469495-7D6C-4EB4-9123-6C3C0CDE1218"></a><h3 id="ADXDK-GUID-2E469495-7D6C-4EB4-9123-6C3C0CDE1218" class="sect3">使用SAX解析XML</h3>
               <div>
                  <p>简单的XML API（SAX）是基于事件的XML解析的标准接口。</p>
                  <div class="section"></div>
                  <!-- class="section" -->
               </div><a id="ADXDK19144"></a><a id="ADXDK1079"></a><a id="ADXDK19145"></a><a id="ADXDK19146"></a><a id="ADXDK19143"></a><div class="props_rev_3"><a id="GUID-6B2CBBA1-C80B-40E7-A364-6551B98AD9C3" name="GUID-6B2CBBA1-C80B-40E7-A364-6551B98AD9C3"></a><h4 id="ADXDK-GUID-6B2CBBA1-C80B-40E7-A364-6551B98AD9C3" class="sect4">使用SAX API for Java</h4>
                  <div>
                     <p>描述了在1级和2级版本中发布的SAX API的接口和类。</p>
                     <p>这些是接口和类：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>由Oracle XML解析器实现的接口</p>
                        </li>
                        <li>
                           <p>应用程序必须实现的接口（ <a href="XML-parsing-for-Java.html#GUID-6B2CBBA1-C80B-40E7-A364-6551B98AD9C3__CCHIEFJI" title="该表描述了SAX 2.0处理程序接口。">参见表12-12</a> ）</p>
                        </li>
                        <li>
                           <p>标准SAX类</p>
                        </li>
                        <li>
                           <p><code class="codeph">org.xml.sax.helper</code>包中的SAX 2.0帮助程序类（ <a href="XML-parsing-for-Java.html#GUID-6B2CBBA1-C80B-40E7-A364-6551B98AD9C3__BGBBCBED" title="列出左列中的SAX 2.0帮助程序类，并在右列中简要描述它们。">参见表12-13</a> ）</p>
                        </li>
                        <li>
                           <p><code class="codeph">nul</code>包中的演示类</p>
                        </li>
                     </ul>
                     <p><a href="XML-parsing-for-Java.html#GUID-6B2CBBA1-C80B-40E7-A364-6551B98AD9C3__CCHIEFJI" title="该表描述了SAX 2.0处理程序接口。">表12-12</a>列出并描述了应用程序必须实现的SAX 2.0接口。
                     </p>
                     <div class="tblformal" id="GUID-6B2CBBA1-C80B-40E7-A364-6551B98AD9C3__CCHIEFJI">
                        <p class="titleintable">表12-12 SAX 2.0处理程序接口</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="SAX 2.0处理程序接口" width="100%" border="1" summary="This table describes SAX 2.0 handler interfaces." frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="22%" id="d35651e7122">接口</th>
                                 <th align="left" valign="bottom" width="78%" id="d35651e7125">描述</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="22%" id="d35651e7130" headers="d35651e7122 ">
                                    <p><code class="codeph">ContentHandler的</code></p>
                                 </td>
                                 <td align="left" valign="top" width="78%" headers="d35651e7130 d35651e7125 ">
                                    <p>从XML解析器接收通知。实现主要事件处理方法<code class="codeph">startDocument()</code> ， <code class="codeph">endDocument()</code> ， <code class="codeph">startElement()</code>和<code class="codeph">endElement()</code> ，它们在XML解析器标识XML标记时调用。实现方法<code class="codeph">characters()</code>和<code class="codeph">processingInstruction()</code> ，这些方法在XML解析器遇到XML元素或内联处理指令中的文本时调用。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="22%" id="d35651e7157" headers="d35651e7122 ">
                                    <p><code class="codeph">DeclHandler</code></p>
                                 </td>
                                 <td align="left" valign="top" width="78%" headers="d35651e7157 d35651e7125 ">
                                    <p>在XML文档中接收有关DTD声明的通知。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="22%" id="d35651e7165" headers="d35651e7122 ">
                                    <p><code class="codeph">DTDHandler的</code></p>
                                 </td>
                                 <td align="left" valign="top" width="78%" headers="d35651e7165 d35651e7125 ">
                                    <p>处理符号和未解析（二进制）实体。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="22%" id="d35651e7173" headers="d35651e7122 ">
                                    <p><code class="codeph">EntityResolver的</code></p>
                                 </td>
                                 <td align="left" valign="top" width="78%" headers="d35651e7173 d35651e7125 ">
                                    <p>支持文档中URI的重定向。实现方法<code class="codeph">resolveEntity()</code> ，该方法在XML解析器必须标识由URI标识的数据时调用。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="22%" id="d35651e7184" headers="d35651e7122 ">
                                    <p><code class="codeph">的ErrorHandler</code></p>
                                 </td>
                                 <td align="left" valign="top" width="78%" headers="d35651e7184 d35651e7125 ">
                                    <p>处理解析器错误。实现方法<code class="codeph">error()</code> ， <code class="codeph">fatalError()</code>和<code class="codeph">warning()</code> ，程序调用它们以响应各种解析错误。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="22%" id="d35651e7201" headers="d35651e7122 ">
                                    <p><code class="codeph">LexicalHandler</code></p>
                                 </td>
                                 <td align="left" valign="top" width="78%" headers="d35651e7201 d35651e7125 ">
                                    <p>接收有关词汇信息的通知，例如注释和字符数据（CDATA）部分边界。</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <p><a href="XML-parsing-for-Java.html#GUID-6B2CBBA1-C80B-40E7-A364-6551B98AD9C3__BGBBCBED" title="列出左列中的SAX 2.0帮助程序类，并在右列中简要描述它们。">表12-13</a>列出并描述了SAX 2.0帮助程序类。
                     </p>
                     <div class="tblformal" id="GUID-6B2CBBA1-C80B-40E7-A364-6551B98AD9C3__BGBBCBED">
                        <p class="titleintable">表12-13 SAX 2.0帮助程序类</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="SAX 2.0助手类" width="100%" border="1" summary="Lists the SAX 2.0 helper classes in the left column and briefly describes them in the right column." frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="25%" id="d35651e7224">类</th>
                                 <th align="left" valign="bottom" width="75%" id="d35651e7227">描述</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="25%" id="d35651e7232" headers="d35651e7224 ">
                                    <p><code class="codeph">AttributeImpl</code></p>
                                 </td>
                                 <td align="left" valign="top" width="75%" headers="d35651e7232 d35651e7227 ">
                                    <p>制作<code class="codeph">AttributeList</code>的持久副本。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="25%" id="d35651e7243" headers="d35651e7224 ">
                                    <p><code class="codeph">的DefaultHandler</code></p>
                                 </td>
                                 <td align="left" valign="top" width="75%" headers="d35651e7243 d35651e7227 ">
                                    <p>具有<a href="XML-parsing-for-Java.html#GUID-6B2CBBA1-C80B-40E7-A364-6551B98AD9C3__CCHIEFJI" title="该表描述了SAX 2.0处理程序接口。">表12-12中</a>接口的默认实现的基类。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="25%" id="d35651e7256" headers="d35651e7224 ">
                                    <p><code class="codeph">LocatorImpl</code></p>
                                 </td>
                                 <td align="left" valign="top" width="75%" headers="d35651e7256 d35651e7227 ">
                                    <p>在解析中的指定点处创建定位器值的持久快照。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="25%" id="d35651e7264" headers="d35651e7224 ">
                                    <p><code class="codeph">NamespaceSupport</code></p>
                                 </td>
                                 <td align="left" valign="top" width="75%" headers="d35651e7264 d35651e7227 ">
                                    <p>支持XML命名空间。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="25%" id="d35651e7272" headers="d35651e7224 ">
                                    <p><code class="codeph">XMLFilterImpl</code></p>
                                 </td>
                                 <td align="left" valign="top" width="75%" headers="d35651e7272 d35651e7227 ">
                                    <p>修改事件流的应用程序使用的基类。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="25%" id="d35651e7280" headers="d35651e7224 ">
                                    <p><code class="codeph">XMLReaderFactory</code></p>
                                 </td>
                                 <td align="left" valign="top" width="75%" headers="d35651e7280 d35651e7227 ">
                                    <p>支持动态加载SAX解析器。</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <p><a href="XML-parsing-for-Java.html#GUID-6B2CBBA1-C80B-40E7-A364-6551B98AD9C3__I1013043">图12-5</a>显示了如何创建SAX解析器并使用它来解析输入文档。
                     </p>
                     <div class="figure" id="GUID-6B2CBBA1-C80B-40E7-A364-6551B98AD9C3__I1013043">
                        <p class="titleinfigure">图12-5使用SAXParser类</p><img src="img/adxdk052.gif" width="405" alt="下面是图12-5的描述" title="下面是图12-5的描述" longdesc="img_text/adxdk052.html"><br><a href="img_text/adxdk052.html">“图12-5使用SAXParser类”的说明</a></div>
                     <!-- class="figure" -->
                     <p>使用SAX解析输入XML文档的基本步骤是：</p>
                     <ol>
                        <li>
                           <p>创建<code class="codeph">SAXParser</code>对象并配置其属性。
                           </p>
                           <p>例如，设置验证模式。有关配置方法，请<a href="XML-parsing-for-Java.html#GUID-7C91F2D5-350D-4530-8988-295EF0B60D53__CCHHJABF" title="此表描述了可用于设置DOM解析器的各种属性的方法。">参见表12-5</a> 。
                           </p>
                        </li>
                        <li>
                           <p>实例化事件处理程序。</p>
                           <p>您的应用程序必须实现<a href="XML-parsing-for-Java.html#GUID-6B2CBBA1-C80B-40E7-A364-6551B98AD9C3__CCHIEFJI" title="该表描述了SAX 2.0处理程序接口。">表12-12中</a>的处理程序接口。
                           </p>
                        </li>
                        <li>
                           <p>使用XML解析器注册事件处理程序。</p>
                           <p>此步骤使解析器能够在发生给定事件时调用正确的方法。有关注册事件处理程序的<code class="codeph">SAXParser</code>方法的信息，请参阅<a href="XML-parsing-for-Java.html#GUID-6B2CBBA1-C80B-40E7-A364-6551B98AD9C3__CCHEIGGF" title="此表描述了用于注册事件处理程序的SAXParser方法。">表12-14</a> 。
                           </p>
                        </li>
                        <li>
                           <p>使用<code class="codeph">SAXParser.parse()</code>方法解析输入文档。
                           </p>
                           <p>假设所有SAX接口都是同步的：在解析完成之前，解析方法不能返回。在报告下一个事件之前，读者必须等待事件处理程序回调返回。</p>
                           <p>调用<code class="codeph">SAXParser.parse()</code>方法时，程序将调用应用程序中实现的几种回调方法之一。这些方法由事件处理程序中实现的<code class="codeph">ContentHandler</code> ， <code class="codeph">ErrorHandler</code> ， <code class="codeph">DTDHandler</code>和<code class="codeph">EntityResolver</code>接口定义。例如，应用程序可以在遇到start元素时调用<code class="codeph">startElement()</code>方法。
                           </p>
                        </li>
                     </ol>
                     <p><a href="XML-parsing-for-Java.html#GUID-6B2CBBA1-C80B-40E7-A364-6551B98AD9C3__CCHEIGGF" title="此表描述了用于注册事件处理程序的SAXParser方法。">表12-14</a>列出并描述了用于注册事件处理程序的<code class="codeph">SAXParser</code>方法，并说明了何时使用它们。应用程序可以在解析过程中注册新的或不同的处理程序; SAX解析器必须立即开始使用新注册的处理程序。
                     </p>
                     <div class="tblformal" id="GUID-6B2CBBA1-C80B-40E7-A364-6551B98AD9C3__CCHEIGGF">
                        <p class="titleintable">表12-14用于注册事件处理程序的SAXParser方法</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="用于注册事件处理程序的SAXParser方法" width="100%" border="1" summary="This table describes SAXParser methods for registering event handlers." frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="28%" id="d35651e7383">方法</th>
                                 <th align="left" valign="bottom" width="72%" id="d35651e7386">描述</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="28%" id="d35651e7391" headers="d35651e7383 ">
                                    <p><code class="codeph">setContentHandler（）</code></p>
                                 </td>
                                 <td align="left" valign="top" width="72%" headers="d35651e7391 d35651e7386 ">
                                    <p>使用应用程序注册内容事件处理程序。</p>
                                    <p><code class="codeph">org.xml.sax.DefaultHandler</code>类实现<code class="codeph">org.xml.sax.ContentHandler</code>接口。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="28%" id="d35651e7407" headers="d35651e7383 ">
                                    <p><code class="codeph">setDTDHandler（）</code></p>
                                 </td>
                                 <td align="left" valign="top" width="72%" headers="d35651e7407 d35651e7386 ">
                                    <p>使用应用程序注册DTD事件处理程序。</p>
                                    <p>如果应用程序未注册DTD处理程序，则会自动忽略SAX解析器报告的DTD事件。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="28%" id="d35651e7417" headers="d35651e7383 ">
                                    <p><code class="codeph">的setErrorHandler（）</code></p>
                                 </td>
                                 <td align="left" valign="top" width="72%" headers="d35651e7417 d35651e7386 ">
                                    <p>使用应用程序注册错误事件处理程序。</p>
                                    <p>如果应用程序未注册错误处理程序，则会自动忽略SAX解析器报告的所有错误事件;但是，正常处理可能不会继续。Oracle强烈建议所有SAX应用程序实现错误处理程序以避免意外错误。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="28%" id="d35651e7427" headers="d35651e7383 ">
                                    <p><code class="codeph">的setEntityResolver（）</code></p>
                                 </td>
                                 <td align="left" valign="top" width="72%" headers="d35651e7427 d35651e7386 ">
                                    <p>使用应用程序注册实体解析程序。</p>
                                    <p>如果应用程序未注册实体解析程序，则<code class="codeph">XMLReader</code>执行其自己的默认解析。
                                    </p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                  </div>
               </div><a id="ADXDK19147"></a><div class="props_rev_3"><a id="GUID-75C097ED-7247-4C80-9D34-3F1AD9AFBD1E" name="GUID-75C097ED-7247-4C80-9D34-3F1AD9AFBD1E"></a><h4 id="ADXDK-GUID-75C097ED-7247-4C80-9D34-3F1AD9AFBD1E" class="sect4">执行基本SAX分析</h4>
                  <div>
                     <p><code class="codeph">SAXSample.java</code>显示了SAX解析的基本步骤。<code class="codeph">SAXSample</code>类扩展了<code class="codeph">HandlerBase</code> 。程序接收XML文件作为输入，解析它，并打印有关文件内容的信息。
                     </p>
                     <div class="section">
                        <p><code class="codeph">SAXSample.java</code>程序遵循以下步骤（使用程序中的代码片段进行说明）：</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>存储<code class="codeph">Locator</code> ：</span><div><pre class="oac_no_warn" dir="ltr">定位器定位器;</pre><p><code class="codeph">Locator</code>将SAX事件与文档位置相关联。SAX解析器通过将<code class="codeph">Locator</code>实例传递给内容处理程序中的<code class="codeph">setDocumentLocator()</code>方法，为应用程序提供位置信息。应用程序可以使用该对象获取XML源文档中任何其他内容处理程序事件的位置。
                              </p>
                           </div>
                        </li>
                        <li class="stepexpand"><span>实例化一个新的事件处理程序：</span><div><pre class="oac_no_warn" dir="ltr">SAXSample sample = new SAXSample（）;</pre></div>
                        </li>
                        <li class="stepexpand"><span>实例化SAX解析器并对其进行配置：</span><div><pre class="oac_no_warn" dir="ltr">解析器解析器=新的SAXParser（）; （（的SAXParser）分析器）.setValidationMode（SAXParser的。DTD_VALIDATION）;</pre><p>上述代码将模式设置为DTD验证。</p>
                           </div>
                        </li>
                        <li class="stepexpand"><span>使用SAX解析器注册事件处理程序：</span><div><pre class="oac_no_warn" dir="ltr">parser.setDocumentHandler（样品）; parser.setEntityResolver（样品）; parser.setDTDHandler（样品）; parser.setErrorHandler（样品）;</pre><p>您可以使用<code class="codeph">SAXParser</code>类中的注册方法，但必须自己实现事件处理程序接口。
                              </p>
                              <p>以下是<code class="codeph">DocumentHandler</code>接口实现的一部分：</p><pre class="oac_no_warn" dir="ltr">public void setDocumentLocator（Locator locator）{System.out.println（“SetDocumentLocator：”）; this.locator = locator; public void startDocument（）{System.out.println（“StartDocument”）; public void endDocument（）抛出SAXException {System.out.println（“EndDocument”）; public void startElement（String name，AttributeList atts）抛出SAXException {System.out.println（“StartElement：”+ name）; for（int i = 0; i &lt;atts.getLength（）; i ++）{String aname = atts.getName（i）; String type = atts.getType（i）; String value = atts.getValue（i）; System.out.println（“”+ aname +“（”+ type +“）”+“=”+ value）; } ...
</pre><p>以下代码实现了<code class="codeph">EntityResolver</code>接口：</p><pre class="oac_no_warn" dir="ltr">public InputSource resolveEntity（String publicId，String systemId）抛出SAXException {System.out.println（“ResolveEntity：”+ publicId +“”+ systemId）; System.out.println（“Locator：”+ locator.getPublicId（）+“locator.getSystemId（）+”“+ locator.getLineNumber（）+”“+ locator.getColumnNumber（））; return null;}</pre><p>以下代码实现了<code class="codeph">DTDHandler</code>接口：</p><pre class="oac_no_warn" dir="ltr">public void notationDecl（String name，String publicId，String systemId）{System.out.println（“NotationDecl：”+ name +“”+ publicId +“”+ systemId）; public void unparsedEntityDecl（String name，String publicId，String systemId，String notationName）{System.out.println（“UnparsedEntityDecl：”+ name +“”+ publicId +“”+ systemId +“”+ notationName）; }</pre><p>以下代码实现了<code class="codeph">ErrorHandler</code>接口：</p><pre class="oac_no_warn" dir="ltr">public void warning（SAXParseException e）抛出SAXException {System.out.println（“Warning：”+ e.getMessage（））; public void error（SAXParseException e）抛出SAXException {throw new SAXException（e.getMessage（））; public void fatalError（SAXParseException e）抛出SAXException {System.out.println（“致命错误”）;抛出新的SAXException（e.getMessage（））; }</pre></div>
                        </li>
                        <li class="stepexpand"><span>解析输入的XML文档：</span><div><pre class="oac_no_warn" dir="ltr">parser.parse（DemoUtil.createURL（argv的[0]）的toString（））;</pre><p>上述代码将文档转换为URL，然后对其进行解析。</p>
                           </div>
                        </li>
                     </ol>
                  </div>
               </div><a id="ADXDK19148"></a><div class="props_rev_3"><a id="GUID-7E284DE1-049C-43D9-9C15-1B01B2F00123" name="GUID-7E284DE1-049C-43D9-9C15-1B01B2F00123"></a><h4 id="ADXDK-GUID-7E284DE1-049C-43D9-9C15-1B01B2F00123" class="sect4">使用命名空间执行基本SAX分析</h4>
                  <div>
                     <p><code class="codeph">SAX2Namespace.java</code>实现了一个名为<code class="codeph">XMLDefaultHandler</code>的事件处理程序作为<code class="codeph">org.xml.sax.helpers.的子类<code class="codeph">org.xml.sax.helpers.DefaultHandler</code>类。
                     </p>
                     <div class="section">
                        <p>实现<code class="codeph">ContentHandler</code>接口的最简单方法是扩展<code class="codeph">org.xml.sax.helpers.DefaultHandler</code>类。<code class="codeph">DefaultHandler</code>类提供了一些处理事件的默认行为，尽管典型的行为是什么都不做。
                        </p>
                        <p><code class="codeph">SAX2Namespace.java</code>仅覆盖相关事件的方法。具体来说， <code class="codeph">XMLDefaultHandler</code>类只实现两个方法： <code class="codeph">startElement()</code>和<code class="codeph">endElement()</code> 。每当<code class="codeph">SAXParser</code>在XML文档中遇到新元素时，它就会触发<code class="codeph">startElement</code>事件，而<code class="codeph">startElement()</code>方法会打印该元素的命名空间信息。
                        </p>
                        <p><code class="codeph">SAX2Namespace.java</code>示例程序遵循以下步骤（使用程序中的代码片段进行说明）：</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>实例化<code class="codeph">DefaultHandler</code>类型的新事件处理程序：</span><div><pre class="oac_no_warn" dir="ltr">DefaultHandler defHandler = new XMLDefaultHandler（）;</pre></div>
                        </li>
                        <li class="stepexpand"><span>创建SAX解析器并设置其验证模式：</span><div><pre class="oac_no_warn" dir="ltr">解析器解析器=新的SAXParser（）; （（的SAXParser）分析器）.setValidationMode（SAXParser的。DTD_VALIDATION）;</pre><p>上述代码将模式设置为DTD验证。</p>
                           </div>
                        </li>
                        <li class="stepexpand"><span>使用SAX解析器注册事件处理程序：</span><div><pre class="oac_no_warn" dir="ltr">parser.setContentHandler（defHandler）; parser.setEntityResolver（defHandler）; parser.setDTDHandler（defHandler）; parser.setErrorHandler（defHandler）;</pre><p>前面的代码为输入文档，DTD，实体和错误注册处理程序。</p>
                              <p>以下代码显示了<code class="codeph">XMLDefaultHandler</code>实现。<code class="codeph">startElement()</code>和<code class="codeph">endElement()</code>方法为每个元素打印限定名称，本地名称和名称空间URI（有关这些术语的说明，请参阅<a href="XML-parsing-for-Java.html#GUID-7C91F2D5-350D-4530-8988-295EF0B60D53__CCHBDBGE" title="此表描述了XMLDocument类的有用方法。">表12-7</a> ）。
                              </p><pre class="oac_no_warn" dir="ltr">class XMLDefaultHandler extends DefaultHandler {public void XMLDefaultHandler（）{} public void startElement（String uri，String localName，String qName，Attributes atts）throws SAXException {System.out.println（“ELEMENT Qualified Name：”+ qName）; System.out.println（“ELEMENT Local Name：”+ localName）; System.out.println（“ELEMENT命名空间：”+ uri）; for（int i = 0; i &lt;atts.getLength（）; i ++）{qName = atts.getQName（i）; localName = atts.getLocalName（i）; uri = atts.getURI（i）; System.out.println（“ATTRIBUTE Qualified Name：”+ qName）; System.out.println（“ATTRIBUTE Local Name：”+ localName）; System.out.println（“ATTRIBUTE命名空间：”+ uri）; //您可以通过索引或限定名称获取属性的类型和值。String type = atts.getType（qName）; String value = atts.getValue（qName）; System.out.println（“ATTRIBUTE Type：”+ type）; System.out.println（“ATTRIBUTE Value：”+ value）;的System.out.println（）; public void endElement（String uri，String localName，String qName）throws SAXException {System.out.println（“ELEMENT Qualified Name：”+ qName）; System.out.println（“ELEMENT Local Name：”+ localName）; System.out.println（“ELEMENT命名空间：”+ uri）; }}</pre></div>
                        </li>
                        <li class="stepexpand"><span>解析输入的XML文档：</span><div><pre class="oac_no_warn" dir="ltr">parser.parse（DemoUtil.createURL（argv的[0]）的toString（））;</pre><p>上述代码将文档转换为URL，然后对其进行解析。</p>
                           </div>
                        </li>
                     </ol>
                  </div>
               </div><a id="ADXDK19150"></a><a id="ADXDK19149"></a><div class="props_rev_3"><a id="GUID-381D4A51-01E8-4B6F-A581-64D379F3BF9C" name="GUID-381D4A51-01E8-4B6F-A581-64D379F3BF9C"></a><h4 id="ADXDK-GUID-381D4A51-01E8-4B6F-A581-64D379F3BF9C" class="sect4">使用XMLTokenizer执行SAX解析</h4>
                  <div>
                     <p>您可以创建一个简单的SAX解析器作为<code class="codeph">XMLTokenizer</code>类的实例，并使用解析器来标记输入XML。</p>
                     <div class="section">
                        <p><a href="XML-parsing-for-Java.html#GUID-381D4A51-01E8-4B6F-A581-64D379F3BF9C__CCHJDBGJ" title="该表描述了XMLTokenizer方法。">表12-15</a>列出了该类中的有用方法。
                        </p>
                        <div class="tblformal" id="GUID-381D4A51-01E8-4B6F-A581-64D379F3BF9C__CCHJDBGJ">
                           <p class="titleintable">表12-15 XMLTokenizer方法</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="XMLTokenizer方法" width="100%" border="1" summary="This table describes XMLTokenizer methods." frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="25%" id="d35651e7891">方法</th>
                                    <th align="left" valign="bottom" width="75%" id="d35651e7894">描述</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="25%" id="d35651e7899" headers="d35651e7891 ">
                                       <p><code class="codeph">setToken（）</code></p>
                                    </td>
                                    <td align="left" valign="top" width="75%" headers="d35651e7899 d35651e7894 ">
                                       <p>为XML tokenizer注册一个新标记。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="25%" id="d35651e7907" headers="d35651e7891 ">
                                       <p><code class="codeph">setErrorStream（）</code></p>
                                    </td>
                                    <td align="left" valign="top" width="75%" headers="d35651e7907 d35651e7894 ">
                                       <p>注册输出流以查找错误</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="25%" id="d35651e7915" headers="d35651e7891 ">
                                       <p><code class="codeph">记号化（）</code></p>
                                    </td>
                                    <td align="left" valign="top" width="75%" headers="d35651e7915 d35651e7894 ">
                                       <p>标记输入XML</p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <p>具有<code class="codeph">Tokenizer</code>功能的SAX解析器必须实现<code class="codeph">XMLToken</code>接口。<code class="codeph">XMLToken</code>的回调方法是<code class="codeph">token()</code> ，它接收XML标记及其对应的值并执行操作。例如，您可以实现<code class="codeph">token()</code>以便打印令牌名称，后跟令牌的值。
                        </p>
                        <p><code class="codeph">Tokenizer.java</code>示例程序接受XML文档作为输入，对其进行解析，并打印XML标记的列表。该程序实现了一个<code class="codeph">doParse()</code>方法，该方法遵循这些步骤（用程序中的代码片段说明）：</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>从输入XML流创建URL：</span><div><pre class="oac_no_warn" dir="ltr">URL url = DemoUtil.createURL（arg）;</pre></div>
                        </li>
                        <li class="stepexpand"><span>创建<code class="codeph">XMLTokenizer</code>解析器：</span><div><pre class="oac_no_warn" dir="ltr">parser = new XMLTokenizer（（XMLToken）new Tokenizer（））;</pre></div>
                        </li>
                        <li class="stepexpand"><span>注册输出错误流：</span><div><pre class="oac_no_warn" dir="ltr">parser.setErrorStream（System.out）;</pre></div>
                        </li>
                        <li class="stepexpand"><span>使用解析器注册令牌：</span><div><pre class="oac_no_warn" dir="ltr">parser.setToken（STagName，true）; parser.setToken（EmptyElemTag，true）; parser.setToken（STag，true）; parser.setToken（ETag，true）; parser.setToken（ETagName，true）; ...
</pre></div>
                        </li>
                        <li class="stepexpand"><span>对XML文档进行标记：</span><div><pre class="oac_no_warn" dir="ltr">parser.tokenize（url）;</pre><p><code class="codeph">token()</code>回调方法确定遇到特定标记时要采取的操作。以下代码是此方法实现的一部分：</p><pre class="oac_no_warn" dir="ltr">public void token（int token，String value）{switch（token）{case XMLToken。STag：System.out.println（“STag：”+ value）;打破; case XMLToken。ETag：System.out.println（“ETag：”+ value）;打破; case XMLToken。EmptyElemTag：System.out.println（“EmptyElemTag：”+ value）;打破; case XMLToken。AttValue：System.out.println（“AttValue：”+ value）;打破; ...默认值：break; }}</pre></div>
                        </li>
                     </ol>
                  </div>
               </div>
            </div><a id="ADXDK981"></a><a id="ADXDK19151"></a><div class="props_rev_3"><a id="GUID-FD056430-78F8-4507-8D6F-9BFB8D95EA8D" name="GUID-FD056430-78F8-4507-8D6F-9BFB8D95EA8D"></a><h3 id="ADXDK-GUID-FD056430-78F8-4507-8D6F-9BFB8D95EA8D" class="sect3">使用JAXP解析XML</h3>
               <div>
                  <p>JAXP允许您的Java程序使用SAX和DOM解析器以及XSLT处理器。</p>
                  <div class="section"></div>
                  <!-- class="section" -->
               </div><a id="ADXDK19153"></a><a id="ADXDK1080"></a><a id="ADXDK19152"></a><div class="props_rev_3"><a id="GUID-9188A2DD-F117-4D27-8709-3073321C31D8" name="GUID-9188A2DD-F117-4D27-8709-3073321C31D8"></a><h4 id="ADXDK-GUID-9188A2DD-F117-4D27-8709-3073321C31D8" class="sect4">JAXP结构</h4>
                  <div>
                     <p>JAXP由抽象类组成，为解析器可插拔性提供了一个薄层。Oracle基于Sun参考实现实现了JAXP。</p>
                     <p><a href="XML-parsing-for-Java.html#GUID-9188A2DD-F117-4D27-8709-3073321C31D8__CCHDAAFH" title="描述JAXP包。">表12-16</a>列出并描述了包含JAXP的软件包。</p>
                     <div class="tblformal" id="GUID-9188A2DD-F117-4D27-8709-3073321C31D8__CCHDAAFH">
                        <p class="titleintable">表12-16 JAXP包</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="JAXP包" width="100%" border="1" summary="Describes JAXP packages." frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="39%" id="d35651e8169">包</th>
                                 <th align="left" valign="bottom" width="61%" id="d35651e8172">描述</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="39%" id="d35651e8177" headers="d35651e8169 ">
                                    <p><code class="codeph">javax.xml.parsers中</code></p>
                                 </td>
                                 <td align="left" valign="top" width="61%" headers="d35651e8177 d35651e8172 ">
                                    <p>为DOM 2.0和SAX 1.0解析器提供标准API。包含供应商中立的工厂类，包括<code class="codeph">SAXParser</code>和<code class="codeph">DocumentBuilder</code> 。<code class="codeph">DocumentBuilder</code>创建一个符合DOM的<code class="codeph">Document</code>对象。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="39%" id="d35651e8197" headers="d35651e8169 ">
                                    <p><code class="codeph">javax.xml.transform中</code></p>
                                 </td>
                                 <td align="left" valign="top" width="61%" headers="d35651e8197 d35651e8172 ">
                                    <p>定义用于处理XML转换和执行从源到结果的转换的通用API。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="39%" id="d35651e8205" headers="d35651e8169 ">
                                    <p><code class="codeph">javax.xml.transform.dom中</code></p>
                                 </td>
                                 <td align="left" valign="top" width="61%" headers="d35651e8205 d35651e8172 ">
                                    <p>提供特定于DOM的转换API。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="39%" id="d35651e8213" headers="d35651e8169 ">
                                    <p><code class="codeph">javax.xml.transform.sax中</code></p>
                                 </td>
                                 <td align="left" valign="top" width="61%" headers="d35651e8213 d35651e8172 ">
                                    <p>提供特定于SAX2的转换API。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="39%" id="d35651e8221" headers="d35651e8169 ">
                                    <p><code class="codeph">javax.xml.transform.stream</code></p>
                                 </td>
                                 <td align="left" valign="top" width="61%" headers="d35651e8221 d35651e8172 ">
                                    <p>提供特定于流和URI的转换API。</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                  </div>
               </div><a id="ADXDK19155"></a><a id="ADXDK19154"></a><div class="props_rev_3"><a id="GUID-C2FF46DA-F711-4D7E-A96D-637877143375" name="GUID-C2FF46DA-F711-4D7E-A96D-637877143375"></a><h4 id="ADXDK-GUID-C2FF46DA-F711-4D7E-A96D-637877143375" class="sect4">通过JAXP使用SAX API</h4>
                  <div>
                     <p>您可以依赖工厂设计模式来使用JAXP创建新的SAX解析器引擎。</p>
                     <div class="section">
                        <p><a href="XML-parsing-for-Java.html#GUID-C2FF46DA-F711-4D7E-A96D-637877143375__CCHBFEID">图12-6</a>显示了基本过程。
                        </p>
                        <div class="figure" id="GUID-C2FF46DA-F711-4D7E-A96D-637877143375__CCHBFEID">
                           <p class="titleinfigure">图12-6使用JAXP进行SAX分析</p><img src="img/adxdk114.gif" width="370" alt="下面是图12-6的描述" title="下面是图12-6的描述" longdesc="img_text/adxdk114.html"><br><a href="img_text/adxdk114.html">“图12-6 SAX用JAXP解析”的描述</a></div>
                        <!-- class="figure" -->
                        <p>通过JAXP解析SAX的基本步骤是：</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li><span>使用<code class="codeph">SAXParserFactory</code>类创建一个新的SAX解析器工厂。</span></li>
                        <li><span>配置工厂。</span></li>
                        <li><span>从工厂创建一个新的SAX解析器（ <code class="codeph">SAXParser</code> ）对象。</span></li>
                        <li><span>设置SAX解析器的事件处理程序。</span></li>
                        <li><span>解析输入的XML文档。</span></li>
                     </ol>
                  </div>
               </div><a id="ADXDK19157"></a><a id="ADXDK19156"></a><div class="props_rev_3"><a id="GUID-D3EDB994-4754-495B-9D90-EE9CED327A16" name="GUID-D3EDB994-4754-495B-9D90-EE9CED327A16"></a><h4 id="ADXDK-GUID-D3EDB994-4754-495B-9D90-EE9CED327A16" class="sect4">通过JAXP使用DOM API</h4>
                  <div>
                     <p>您可以依赖工厂设计模式来使用JAXP创建新的DOM文档构建器引擎。</p>
                     <div class="section">
                        <p><a href="XML-parsing-for-Java.html#GUID-D3EDB994-4754-495B-9D90-EE9CED327A16__CCHEJCHF">图12-7</a>显示了基本过程。
                        </p>
                        <div class="figure" id="GUID-D3EDB994-4754-495B-9D90-EE9CED327A16__CCHEJCHF">
                           <p class="titleinfigure">图12-7使用JAXP进行DOM解析</p><img src="img/adxdk115.gif" width="408" alt="下面是图12-7的描述" title="下面是图12-7的描述" longdesc="img_text/adxdk115.html"><br><a href="img_text/adxdk115.html">“图12-7使用JAXP解析DOM”的说明</a></div>
                        <!-- class="figure" -->
                        <p>通过JAXP解析DOM的基本步骤是：</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li><span>使用<code class="codeph">DocumentBuilderFactory</code>类创建一个新的DOM解析器工厂。</span></li>
                        <li><span>配置工厂。</span></li>
                        <li><span>从工厂创建一个新的DOM构建器（ <code class="codeph">DocumentBuilder</code> ）对象。</span></li>
                        <li><span>为DOM构建器设置错误处理程序和实体解析程序。</span></li>
                        <li><span>解析输入的XML文档。</span></li>
                     </ol>
                  </div>
               </div><a id="ADXDK19158"></a><div class="props_rev_3"><a id="GUID-5C17A64B-092E-437F-A38A-400E488156FE" name="GUID-5C17A64B-092E-437F-A38A-400E488156FE"></a><h4 id="ADXDK-GUID-5C17A64B-092E-437F-A38A-400E488156FE" class="sect4">通过JAXP转换XML</h4>
                  <div>
                     <p>描述了通过JAXP转换XML的基本步骤。</p>
                     <div class="section">
                        <p>步骤是：</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li><span>使用<code class="codeph">TransformerFactory</code>类创建一个新的变换器工厂。</span></li>
                        <li><span>配置工厂。</span></li>
                        <li><span>从工厂创建一个新的转换器并指定一个XSLT样式表。</span></li>
                        <li><span>配置变压器。</span></li>
                        <li><span>转换文档。</span></li>
                     </ol>
                  </div>
               </div><a id="ADXDK19159"></a><div class="props_rev_3"><a id="GUID-D1B88BA0-9D18-40C7-A704-D53DC41D3BA3" name="GUID-D1B88BA0-9D18-40C7-A704-D53DC41D3BA3"></a><h4 id="ADXDK-GUID-D1B88BA0-9D18-40C7-A704-D53DC41D3BA3" class="sect4">用JAXP解析</h4>
                  <div>
                     <p><code class="codeph">JAXPExamples.java</code>程序显示了使用JAXP解析的基本步骤。</p>
                     <div class="section">
                        <p>该程序实现了这些方法，并使用它们来解析和执行对<code class="codeph">/jaxp</code>目录中XML文件的附加处理：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">基本的（）</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">标识（）</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">的namespaceURI（）</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">templatesHandler（）</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">contentHandler2contentHandler（）</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">contentHandler2DOM（）</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">读者（）</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">xmlFilter（）</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">xmlFilterChain（）</code></p>
                           </li>
                        </ul>
                        <p>该程序为示例XML文件<code class="codeph">jaxpone.xml</code>和<code class="codeph">jaxpone.xsl</code>创建URL，然后按顺序调用前面的方法。该演示的基本设计如下（为了节省空间，只显示了<code class="codeph">basic()</code>方法）：</p><pre class="oac_no_warn" dir="ltr">public class JAXPExamples {public static void main（String argv []）throws TransformerException，TransformerConfigurationException，IOException，SAXException，ParserConfigurationException，FileNotFoundException {try {URL xmlURL = createURL（“jaxpone.xml”）; String xmlID = xmlURL.toString（）; URL xslURL = createURL（“jaxpone.xsl”）; String xslID = xslURL.toString（）; // System.out.println（“--- basic ---”）; basic（xmlID，xslID）;的System.out.println（）; ...} catch（异常错误）{err.printStackTrace（）; // public static void basic（String xmlID，String xslID）throws TransformerException，TransformerConfigurationException {TransformerFactory tfactory = TransformerFactory.newInstance（）; Transformer transformer = tfactory.newTransformer（new StreamSource（xslID））; StreamSource source = new StreamSource（xmlID）; transformer.transform（source，new StreamResult（System.out））; } ...}</pre><p>程序<code class="codeph">JAXPExamples.java</code>中的<code class="codeph">reader()</code>方法显示了一种使用SAX解析XML文档的简单技术，使用这些步骤（用程序中的代码片段说明）：</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>创建一个<code class="codeph">TransformerFactory</code>的新实例并将其<code class="codeph">SAXTransformerFactory</code> <code class="codeph">TransformerFactory</code>为<code class="codeph">SAXTransformerFactory</code> ：</span><div><pre class="oac_no_warn" dir="ltr">TransformerFactory tfactory = TransformerFactory.newInstance（）; SAXTransformerFactory stfactory =（SAXTransformerFactory）tfactory;</pre></div>
                        </li>
                        <li class="stepexpand"><span>通过从样式表创建<code class="codeph">StreamSource</code>对象并将其传递给工厂方法<code class="codeph">newXMLFilter()</code>来创建XML阅读器：</span><div><pre class="oac_no_warn" dir="ltr">URL xslURL = createURL（“jaxpone.xsl”）; String xslID = xslURL.toString（）; ...StreamSource streamSource = new StreamSource（xslID）; XMLReader reader = stfactory.newXMLFilter（streamSource）;</pre><p><code class="codeph">newXMLFilter()</code>返回一个<code class="codeph">XMLFilter</code>对象，该对象使用指定的<code class="codeph">Source</code>作为转换指令。
                              </p>
                           </div>
                        </li>
                        <li class="stepexpand"><span>创建内容处理程序并使用XML阅读器注册它：</span><div><pre class="oac_no_warn" dir="ltr">ContentHandler contentHandler = new oraContentHandler（）; reader.setContentHandler（contentHandler时）;</pre><p>上面的代码通过编译demo目录中的<code class="codeph">oraContentHandler.java</code>程序来创建类<code class="codeph">oraContentHandler</code>的实例。
                              </p>
                              <p>以下代码显示了<code class="codeph">oraContentHandler</code>类的部分实现：</p><pre class="oac_no_warn" dir="ltr">public class oraContentHandler实现ContentHandler {private static final String TRADE_MARK =“Oracle 9i”; public void setDocumentLocator（Locator locator）{System.out.println（TRADE_MARK +“ -  setDocumentLocator”）; public void startDocument（）抛出SAXException {System.out.println（TRADE_MARK +“ -  startDocument”）; public void endDocument（）抛出SAXException {System.out.println（TRADE_MARK +“ -  endDocument”）; } ...
</pre></div>
                        </li>
                        <li class="stepexpand"><span>通过将<code class="codeph">InputSource</code>传递给<code class="codeph">XMLReader.parse()</code>方法来解析输入XML文档：</span><div><pre class="oac_no_warn" dir="ltr">InputSource是= new InputSource（xmlID）; reader.parse（是）;</pre></div>
                        </li>
                     </ol>
                  </div>
               </div><a id="ADXDK19160"></a><div class="props_rev_3"><a id="GUID-CE9DE31B-8870-4944-9491-EB067D5D5F6E" name="GUID-CE9DE31B-8870-4944-9491-EB067D5D5F6E"></a><h4 id="ADXDK-GUID-CE9DE31B-8870-4944-9491-EB067D5D5F6E" class="sect4">使用JAXP执行基本转换</h4>
                  <div>
                     <p>您可以使用JAXP执行基本转换。</p>
                     <div class="section">
                        <p>JAXP可以转换这些类型的输入：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p>XML文档</p>
                           </li>
                           <li>
                              <p>XSL样式表</p>
                           </li>
                           <li>
                              <p>在<code class="codeph">oraContentHandler.java</code>定义的<code class="codeph">ContentHandler</code>类</p>
                           </li>
                        </ul>
                        <p>以下是使用JAXP执行基本转换的一些示例：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>您可以使用<code class="codeph">identity()</code>方法执行转换，其中输出XML文档和输入XML文档是相同的。
                              </p>
                           </li>
                           <li>
                              <p>您可以使用<code class="codeph">xmlFilterChain()</code>方法在链中应用三个样式表。
                              </p>
                           </li>
                           <li>
                              <p>你可以任意变换类接口的<code class="codeph">Source</code>到一个类接口的<code class="codeph">Result</code> （ <code class="codeph">DOMSource</code>到<code class="codeph">DOMResult</code> ， <code class="codeph">StreamSource</code>到<code class="codeph">StreamResult</code> ， <code class="codeph">SAXSource</code>到<code class="codeph">SAXResult</code> ，依此类推）。
                              </p>
                           </li>
                        </ul>
                        <p>程序<code class="codeph">JAXPExamples.java</code>中的<code class="codeph">basic()</code>方法显示了如何使用这些步骤执行基本的XSLT转换（使用程序中的代码片段进行说明）：</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>创建<code class="codeph">TransformerFactory</code>的新实例：</span><div><pre class="oac_no_warn" dir="ltr">TransformerFactory tfactory = TransformerFactory.newInstance（）;</pre></div>
                        </li>
                        <li class="stepexpand"><span>从工厂创建一个新的XSL转换器并指定用于转换的样式表：</span><div><pre class="oac_no_warn" dir="ltr">URL xslURL = createURL（“ <span class="bold">jaxpone.xsl</span> ”）; String xslID = xslURL.toString（）; ...Transformer transformer = tfactory.newTransformer（new StreamSource（xslID））;</pre><p>在上面的代码中，样式表是<code class="codeph">jaxpone.xsl</code> 。
                              </p>
                           </div>
                        </li>
                        <li class="stepexpand"><span>将流源设置为输入XML文档：</span><div><pre class="oac_no_warn" dir="ltr">URL xmlURL = createURL（“ <span class="bold">jaxpone.xml</span> ”）; String xmlID = xmlURL.toString（）; ...StreamSource source = new StreamSource（xmlID）;</pre><p>在前面的代码中，流源是<code class="codeph">jaxpone.xml</code> 。
                              </p>
                           </div>
                        </li>
                        <li class="stepexpand"><span>将文档从<code class="codeph">StreamSource</code>转换为<code class="codeph">StreamResult</code> ：</span><div><pre class="oac_no_warn" dir="ltr">transformer.transform（source，new StreamResult（System.out））;</pre></div>
                        </li>
                     </ol>
                  </div>
               </div>
            </div><a id="ADXDK982"></a><a id="ADXDK19162"></a><div class="props_rev_3"><a id="GUID-7C87A9E2-000B-4A33-8D86-11FDA13E1CCA" name="GUID-7C87A9E2-000B-4A33-8D86-11FDA13E1CCA"></a><h3 id="ADXDK-GUID-7C87A9E2-000B-4A33-8D86-11FDA13E1CCA" class="sect3">压缩和解压缩XML</h3>
               <div>
                  <p>XDK允许您使用SAX或DOM来解析XML，然后将解析的数据写入压缩的二进制流。XDK还允许您反转过程，解压缩二进制流以重建XML数据。</p>
                  <div class="section"></div>
                  <!-- class="section" -->
               </div><a id="ADXDK19164"></a><div class="props_rev_3"><a id="GUID-AF615325-9E89-47D9-85B0-2FC9891CF0DF" name="GUID-AF615325-9E89-47D9-85B0-2FC9891CF0DF"></a><h4 id="ADXDK-GUID-AF615325-9E89-47D9-85B0-2FC9891CF0DF" class="sect4">压缩DOM对象</h4>
                  <div>
                     <p><code class="codeph">DOMCompression.java</code>显示了DOM压缩的基本步骤。最重要的DOM压缩方法是<code class="codeph">XMLDocument.writeExternal()</code> ，它通过创建包含对象信息的二进制压缩流来保存对象的状态。
                     </p>
                     <div class="section">
                        <p><code class="codeph">DOMCompression.java</code>程序使用这些步骤（用程序中的代码片段说明）：</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>创建DOM解析器，解析输入XML文档，并获取DOM表示：</span><div><pre class="oac_no_warn" dir="ltr">public class DOMCompression {static OutputStream out = System.out; public static void main（String [] args）{XMLDocument doc = new XMLDocument（）; DOMParser解析器=新的DOMParser（）;尝试{parser.setValidationMode（XMLParser。SCHEMA_VALIDATION）; parser.setPreserveWhitespace（假）; parser.retainCDATASection（真）; parser.parse（createURL（参数[0]））; doc = parser.getDocument（）; ...
</pre><p>有关此技术的说明，请参阅<a href="XML-parsing-for-Java.html#GUID-7C91F2D5-350D-4530-8988-295EF0B60D53" title="DOMSample.java显示了解析输入XML文档并通过DOM访问它的基本步骤。 DOMSample.java接收XML文件作为输入，解析它，并在DOM树中打印元素和属性。">执行基本DOM分析</a> 。
                              </p>
                           </div>
                        </li>
                        <li class="stepexpand"><span>创建一个<code class="codeph">FileOutputStream</code>并将其包装在<code class="codeph">ObjectOutputStream</code>以进行序列化：</span><div><pre class="oac_no_warn" dir="ltr">OutputStream os = new FileOutputStream（“xml.ser”）; ObjectOutputStream oos = new ObjectOutputStream（os）;</pre></div>
                        </li>
                        <li class="stepexpand"><span>通过调用<code class="codeph">XMLDocument.writeExternal()</code>将对象序列化到该文件：</span><div><pre class="oac_no_warn" dir="ltr">doc.writeExternal（OOS）;</pre><p>此方法通过创建包含有关此对象的信息的二进制压缩流来保存对象的状态。</p>
                           </div>
                        </li>
                     </ol>
                  </div>
               </div><a id="ADXDK19165"></a><div class="props_rev_3"><a id="GUID-71F74D4E-1A6C-4696-AA42-DB3AE952B4A1" name="GUID-71F74D4E-1A6C-4696-AA42-DB3AE952B4A1"></a><h4 id="ADXDK-GUID-71F74D4E-1A6C-4696-AA42-DB3AE952B4A1" class="sect4">解压缩DOM对象</h4>
                  <div>
                     <p><code class="codeph">DOMDeCompression.java</code>显示了DOM解压缩的基本步骤。最重要的DOM解压缩方法是<code class="codeph">XMLDocument.readExternal()</code> ，它读取<code class="codeph">writeExternal()</code>方法写入的信息（压缩流）并恢复对象。
                     </p>
                     <div class="section">
                        <p><code class="codeph">DOMDeCompression.java</code>程序使用这些步骤（用程序中的代码片段说明）：</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>为压缩文件创建文件输入流并将其包装在<code class="codeph">ObjectInputStream</code> ：</span><div><pre class="oac_no_warn" dir="ltr">InputStream是; ObjectInputStream ois; ...is = new FileInputStream（“xml.ser”）; ois = new ObjectInputStream（is）;</pre><p>上面的代码从压缩<a href="XML-parsing-for-Java.html#GUID-AF615325-9E89-47D9-85B0-2FC9891CF0DF" title="DOMCompression.java显示了DOM压缩的基本步骤。最重要的DOM压缩方法是XMLDocument.writeExternal（），它通过创建包含对象信息的二进制压缩流来保存对象的状态。">DOM对象中</a>创建的压缩文件创建<code class="codeph">FileInputStream</code> 。
                              </p>
                           </div>
                        </li>
                        <li class="stepexpand"><span>创建一个新的XML文档对象以包含解压缩的数据：</span><div><pre class="oac_no_warn" dir="ltr">XMLDocument serializedDoc = null; serializedDoc = new XMLDocument（）;</pre></div>
                        </li>
                        <li class="stepexpand"><span>通过调用<code class="codeph">XMLDocument.readExternal()</code>读取压缩文件：</span><div><pre class="oac_no_warn" dir="ltr">serializedDoc.readExternal（OIS）; serializedDoc.print（System.out的）;</pre><p>前面的代码数据并将其打印到<code class="codeph">System.out</code> 。
                              </p>
                           </div>
                        </li>
                     </ol>
                  </div>
               </div><a id="ADXDK19167"></a><div class="props_rev_3"><a id="GUID-7EDACFCC-90A8-4B1D-BC28-106A54A03DF8" name="GUID-7EDACFCC-90A8-4B1D-BC28-106A54A03DF8"></a><h4 id="ADXDK-GUID-7EDACFCC-90A8-4B1D-BC28-106A54A03DF8" class="sect4">压缩SAX对象</h4>
                  <div>
                     <p><code class="codeph">SAXCompression.java</code>显示了使用SAX解析文件并将压缩流写入文件的基本步骤。重要的类是<code class="codeph">CXMLHandlerBase</code> ，它是一个SAX <code class="codeph">Handler</code> <code class="codeph">CXMLHandlerBase</code> ，它根据SAX事件压缩XML数据。
                     </p>
                     <div class="section">
                        <p>要使用SAX压缩，请实现此接口并通过调用<code class="codeph">Parser.setDocumentHandler()</code>将其注册到SAX解析器。
                        </p>
                        <p><code class="codeph">SAXCompression.java</code>程序使用这些步骤（用程序中的代码片段说明）：</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>创建一个<code class="codeph">FileOutputStream</code>并将其包装在<code class="codeph">ObjectOutputStream</code> ：</span><div><pre class="oac_no_warn" dir="ltr">String compFile =“xml.ser”; FileOutputStream outStream = new FileOutputStream（compFile）; ObjectOutputStream out = new ObjectOutputStream（outStream）;</pre></div>
                        </li>
                        <li class="stepexpand"><span>创建SAX事件处理程序：</span><div><pre class="oac_no_warn" dir="ltr">CXMLHandlerBase cxml = new CXMLHandlerBase（out）;</pre><p><code class="codeph">CXMLHandlerBase</code>类实现<code class="codeph">ContentHandler</code> ， <code class="codeph">DTDHandler</code> ， <code class="codeph">EntityResolver</code>和<code class="codeph">ErrorHandler</code>接口。
                              </p>
                           </div>
                        </li>
                        <li class="stepexpand"><span>创建SAX解析器：</span><div><pre class="oac_no_warn" dir="ltr">SAXParser解析器=新的SAXParser（）;</pre></div>
                        </li>
                        <li class="stepexpand"><span>配置SAX解析器：</span><div><pre class="oac_no_warn" dir="ltr">parser.setContentHandler（CXML）; parser.setEntityResolver（CXML）; parser.setValidationMode（XMLConstants。非验证）;</pre><p>上述代码设置内容处理程序，实体解析程序和验证模式。</p>
                              <div class="infoboxnote" id="GUID-7EDACFCC-90A8-4B1D-BC28-106A54A03DF8__GUID-E8C339BD-622D-4958-BF47-B777BE33FE74">
                                 <p class="notep1">注意：</p>
                                 <p>虽然是<code class="codeph">oracle.xml.comp.CXMLHandlerBase</code>实现了<code class="codeph">DocumentHandler</code>和<code class="codeph">ContentHandler</code>接口，Oracle建议使用SAX 2.0 <code class="codeph">ContentHandler</code>接口。
                                 </p>
                              </div>
                           </div>
                        </li>
                        <li class="stepexpand"><span>解析XML：</span><div><pre class="oac_no_warn" dir="ltr">parser.parse（URL）;</pre><p><code class="codeph">SAXCompression.java</code>程序将序列化数据写入<code class="codeph">ObjectOutputStream</code> 。
                              </p>
                           </div>
                        </li>
                     </ol>
                  </div>
               </div><a id="ADXDK19168"></a><div class="props_rev_3"><a id="GUID-AB4A91C9-319C-47AA-B3F3-C963B5BDC0AD" name="GUID-AB4A91C9-319C-47AA-B3F3-C963B5BDC0AD"></a><h4 id="ADXDK-GUID-AB4A91C9-319C-47AA-B3F3-C963B5BDC0AD" class="sect4">解压缩SAX对象</h4>
                  <div>
                     <p><code class="codeph">SAXDeCompression.java</code>显示了从<code class="codeph">SAXCompression.java</code>编写的文件中读取序列化数据的基本步骤。重要的类是<code class="codeph">CXMLParser</code> ，它是一个XML解析器，可以从压缩流中重新生成SAX事件。
                     </p>
                     <div class="section">
                        <p><code class="codeph">SAXDeCompression.java</code>程序遵循以下步骤（使用程序中的代码片段进行说明）：</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>创建一个SAX事件处理程序：</span><div><pre class="oac_no_warn" dir="ltr">SampleSAXHandler xmlHandler = new SampleSAXHandler（）;</pre></div>
                        </li>
                        <li class="stepexpand"><span>通过实例化<code class="codeph">CXMLParser</code>类来创建SAX解析器：</span><div><pre class="oac_no_warn" dir="ltr">CXMLParser解析器= new CXMLParser（）;</pre><p><code class="codeph">CXMLParser</code>类通过从压缩流生成SAX事件来实现XML文档的再生。
                              </p>
                           </div>
                        </li>
                        <li class="stepexpand"><span>设置SAX解析器的事件处理程序：</span><div><pre class="oac_no_warn" dir="ltr">parser.setContentHandler（xmlHandler）;</pre></div>
                        </li>
                        <li class="stepexpand"><span>解析压缩流并生成SAX事件：</span><div><pre class="oac_no_warn" dir="ltr">parser.parse（参数[0]）;</pre><p>上述代码从命令行接收文件名并解析XML。</p>
                           </div>
                        </li>
                     </ol>
                  </div>
               </div>
            </div><a id="ADXDK983"></a><a id="ADXDK19169"></a><div class="props_rev_3"><a id="GUID-BB57C7AC-2962-4617-B26F-FEE6B5114A7A" name="GUID-BB57C7AC-2962-4617-B26F-FEE6B5114A7A"></a><h3 id="ADXDK-GUID-BB57C7AC-2962-4617-B26F-FEE6B5114A7A" class="sect3">解析XML的技巧和技巧</h3>
               <div>
                  <p>列出了一些解析技巧和技巧。</p>
                  <div class="section"></div>
                  <!-- class="section" -->
               </div><a id="ADXDK19171"></a><a id="ADXDK19170"></a><div class="props_rev_3"><a id="GUID-A0AE622C-44E2-4849-9C6D-7338970E026E" name="GUID-A0AE622C-44E2-4849-9C6D-7338970E026E"></a><h4 id="ADXDK-GUID-A0AE622C-44E2-4849-9C6D-7338970E026E" class="sect4">从DOM树中提取节点值</h4>
                  <div>
                     <p>您可以使用<code class="codeph">XMLNode</code>类中的<code class="codeph">selectNodes()</code>方法，根据XSL允许的选择模式从DOM树或子树中提取内容。</p>
                     <div class="section">
                        <p>您可以使用<code class="codeph">selectNodes()</code>的可选第二个参数来解析名称空间前缀;也就是说，在给定前缀时返回扩展名称空间URL。<code class="codeph">XMLElement</code>类实现<code class="codeph">NSResolver</code> ，因此可以<code class="codeph">XMLElement</code>对象的引用作为第二个参数发送。<code class="codeph">XMLElement</code>根据输入文档解析前缀。您可以使用<code class="codeph">NSResolver</code>接口覆盖命名空间定义。
                        </p>
                        <p><a href="XML-parsing-for-Java.html#GUID-A0AE622C-44E2-4849-9C6D-7338970E026E__CCHHEIGA">例12-4</a>中的示例代码显示了如何使用<code class="codeph">selectNodes()</code> 。
                        </p>
                        <p>要测试程序，请使用<a href="XML-parsing-for-Java.html#GUID-A0AE622C-44E2-4849-9C6D-7338970E026E__CCHHEIGA">例12-4中</a>的代码创建一个文件，然后在<code class="codeph">$ORACLE_HOME/xdk/demo/java/parser/</code> <code class="codeph">common</code>目录中编译它。将文件名<code class="codeph">family.xml</code>作为参数<code class="codeph">family.xml</code>给程序以遍历<code class="codeph">&lt;family&gt;</code>树。输出类似于：</p><pre class="oac_no_warn" dir="ltr">％java selectNodesTest family.xml Sarah Bob Joanne Jim</pre><p>现在运行以下代码以确定文档中所有<code class="codeph">&lt;member&gt;</code>元素的<code class="codeph">memberid</code>属性的值：</p><pre class="oac_no_warn" dir="ltr">％java selectNodesTest family.xml // member / @ memberid m1 m2 m3 m4</pre></div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-A0AE622C-44E2-4849-9C6D-7338970E026E__CCHHEIGA">
                        <p class="titleinexample">示例12-4使用selectNodes（）提取DOM树的内容</p><pre class="oac_no_warn" dir="ltr">// // selectNodesTest.java // import java.io.*; import oracle.xml.parser.v2。*; import org.w3c.dom。节点; import org.w3c.dom。元件; import org.w3c.dom。文献; import org.w3c.dom。节点列表; public class selectNodesTest {public static void main（String [] args）throws Exception {//提供xpath表达式String pattern =“/ family / member / text（）”; //在命令行上接受文件名//使用$ ORACLE_HOME / xdk / demo / java / parser / common / family.xml运行程序String file = args [0]; if（args.length == 2）pattern = args [1]; DOMParser dp = new DOMParser（）; dp.parse（DemoUtil.createURL（文件））; //包含来自DemoUtil的createURL XMLDocument xd = dp.getDocument（）; XMLElement element =（XMLElement）xd.getDocumentElement（）; NodeList nl = element.selectNodes（pattern，element）; for（int i = 0; i &lt;nl.getLength（）; i ++）{System.out.println（nl.item（i）.getNodeValue（））; } // end for} // end main} //结束selectNodesTest</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="ADXDK19173"></a><a id="ADXDK19174"></a><a id="ADXDK19172"></a><div class="props_rev_3"><a id="GUID-F27F98D1-262F-49D4-8CDF-FAA1C9804ABD" name="GUID-F27F98D1-262F-49D4-8CDF-FAA1C9804ABD"></a><h4 id="ADXDK-GUID-F27F98D1-262F-49D4-8CDF-FAA1C9804ABD" class="sect4">使用appendChild（）合并文档</h4>
                  <div>
                     <p>描述了如何使用<code class="codeph">XMLElement.appendChild()</code>合并XML文档。
                     </p>
                     <div class="section">
                        <p>要编写允许用户完成客户端Java表单并获取XML文档的程序，Java程序可以包含以下变量：</p><pre class="oac_no_warn" dir="ltr">String firstname =“Gianfranco”; String lastname =“Pietraforte”;</pre><p>要将此信息插入XML文档，您可以使用以下任一技术：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p>在字符串中创建XML文档，然后解析它。例如：</p><pre class="oac_no_warn" dir="ltr">String xml =“&lt;person&gt; &lt;first&gt;”+ firstname +“&lt;/ first&gt;”+“&lt;last&gt;”+ lastname +“&lt;/ last&gt; &lt;/ person&gt;”; DOMParser d = new DOMParser（）; d.parse（new StringReader（xml））;文档xmldoc = d.getDocument（）;</pre></li>
                           <li>
                              <p>使用DOM API构建XML文档，创建元素然后将它们相互附加。例如：</p><pre class="oac_no_warn" dir="ltr">Document xmldoc = new XMLDocument（）;元素e1 = xmldoc.createElement（“person”）; xmldoc.appendChild（E1）;元素e2 = xmldoc.createElement（“firstname”）; e1.appendChild（E2）;文字t = xmldoc.createText（“拉里”）; e2.appendChild（T）;</pre></li>
                        </ul>
                        <p>您只能在<span class="italic">单个</span> DOM树上使用第二种技术。
                        </p>
                        <p><a href="XML-parsing-for-Java.html#GUID-F27F98D1-262F-49D4-8CDF-FAA1C9804ABD__CCHHCEFA">实施例12-5</a>使用两个树木-的所有者文件<code class="codeph">e1</code>是<code class="codeph">xmldoc1</code>和所有者文件<code class="codeph">e2</code>是<code class="codeph">xmldoc2</code> 。<code class="codeph">appendChild()</code>方法仅在单个树中起作用。因此，调用<code class="codeph">XMLElement.appendChild()</code>提出的DOM异常<code class="codeph">WRONG_DOCUMENT_ERR</code> 。</p>
                        <p>要跨不同的XML文档复制和粘贴DOM文档片段或DOM节点，请使用<code class="codeph">XMLDocument.importNode()</code>方法（在DOM 2中引入）和<code class="codeph">XMLDocument.adoptNode()</code>方法（在DOM 3中引入）。<a href="XML-parsing-for-Java.html#GUID-F27F98D1-262F-49D4-8CDF-FAA1C9804ABD__CCHGICFG">例12-6中</a>的注释显示了这种技术。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-F27F98D1-262F-49D4-8CDF-FAA1C9804ABD__CCHHCEFA">
                        <p class="titleinexample">例12-5错误使用appendChild（）</p><pre class="oac_no_warn" dir="ltr">XMLDocument xmldoc1 = new XMLDocument（）; XMLElement e1 = xmldoc1.createElement（“person”）; XMLDocument xmldoc2 = new XMLDocument（）; XMLElement e2 = xmldoc2.createElement（“firstname”）; e1.appendChild（E2）;</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-F27F98D1-262F-49D4-8CDF-FAA1C9804ABD__CCHGICFG">
                        <p class="titleinexample">示例12-6使用appendChild合并文档</p><pre class="oac_no_warn" dir="ltr">XMLDocument doc1 = new XMLDocument（）; XMLElement element1 = doc1.createElement（“person”）; XMLDocument doc2 = new XMLDocument（）; XMLElement element2 = doc2.createElement（“firstname”）; <span class="bold">// element2 = doc1.importNode（element2）;</span> <span class="bold">// element2 = doc1.adoptNode（element2）;</span> element1.appendChild（在element2）;</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="ADXDK1081"></a><a id="ADXDK19175"></a><div class="props_rev_3"><a id="GUID-FC4F9DE4-2636-4069-8732-3F7FE137AF1C" name="GUID-FC4F9DE4-2636-4069-8732-3F7FE137AF1C"></a><h4 id="ADXDK-GUID-FC4F9DE4-2636-4069-8732-3F7FE137AF1C" class="sect4">解析DTD</h4>
                  <div>
                     <p>您可以使用加载并解析DTD。</p>
                     <div class="section"></div>
                     <!-- class="section" -->
                  </div><a id="ADXDK19176"></a><div class="props_rev_3"><a id="GUID-B69C71EF-C5F4-4397-A18B-1666A4064286" name="GUID-B69C71EF-C5F4-4397-A18B-1666A4064286"></a><h5 id="ADXDK-GUID-B69C71EF-C5F4-4397-A18B-1666A4064286" class="sect5">加载外部DTD</h5>
                     <div>
                        <p>提供了加载和解析DTD的过程。</p>
                        <div class="section">
                           <p>如果调用<code class="codeph">DOMParser.parse()</code>方法将XML文档解析为<code class="codeph">InputStream</code> ，则使用<code class="codeph">DOMParser.setBaseURL()</code>方法识别Java程序中的外部DTD。<code class="codeph">DOMParser.setBaseURL()</code>指向DTD公开的位置。
                           </p>
                           <p>加载和解析DTD的过程是：</p>
                        </div>
                        <!-- class="section" -->
                        <ol>
                           <li class="stepexpand"><span>将DTD加载为<code class="codeph">InputStream</code> 。</span><div>
                                 <p>例如，此代码根据<code class="codeph">/mydir/my.dtd</code>外部DTD验证文档：</p><pre class="oac_no_warn" dir="ltr">InputStream = MyClass.class.getResourceAsStream（“/ mydir / my.dtd”）;</pre><p>上面的代码在<code class="codeph">CLASSPATH</code>中可以找到的第一个相对位置打开<code class="codeph">./mydir/my.dtd</code> ，包括JAR文件（如果它在<code class="codeph">CLASSPATH</code> 。</p>
                              </div>
                           </li>
                           <li class="stepexpand"><span>创建DOM解析器并设置验证模式。</span><div>
                                 <p>例如：</p><pre class="oac_no_warn" dir="ltr">DOMParser d = new DOMParser（）; d.setValidationMode（DTD_VALIDATION）;</pre></div>
                           </li>
                           <li class="stepexpand"><span>解析DTD。</span><div>
                                 <p>例如，此代码将<code class="codeph">InputStream</code>对象传递给<code class="codeph">DOMParser.parseDTD()</code>方法：</p><pre class="oac_no_warn" dir="ltr">d.parseDTD（是，“rootelementname”）;</pre></div>
                           </li>
                           <li class="stepexpand"><span>获取文档类型，然后进行设置。</span><div>
                                 <p>例如，在此代码中， <code class="codeph">getDoctype()</code>方法获取DTD对象， <code class="codeph">setDoctype()</code>方法设置用于解析的DTD：</p><pre class="oac_no_warn" dir="ltr">d.setDoctype（d.getDoctype（））;</pre><p>或者，您可以调用<code class="codeph">parseDTD()</code>方法分别解析DTD文件并获取DTD对象：</p><pre class="oac_no_warn" dir="ltr">d.parseDTD（new FileReader（“/ mydir / my.dtd”））; DTD dtd = d.getDoctype（）; parser.setDoctype（DTD）;</pre></div>
                           </li>
                           <li class="stepexpand"><span>解析输入的XML文档：</span><div><pre class="oac_no_warn" dir="ltr">d.parse（ “mydoc.xml”）;</pre></div>
                           </li>
                        </ol>
                     </div>
                  </div><a id="ADXDK19178"></a><a id="ADXDK19177"></a><div class="props_rev_3"><a id="GUID-0B99A25C-9330-4CDD-93AF-96C26667AA39" name="GUID-0B99A25C-9330-4CDD-93AF-96C26667AA39"></a><h5 id="ADXDK-GUID-0B99A25C-9330-4CDD-93AF-96C26667AA39" class="sect5">使用setDoctype缓存DTD</h5>
                     <div>
                        <p>Java的XML解析器通过<code class="codeph">DOMParser.setDoctype()</code>方法在验证和非验证模式中提供DTD缓存。使用此方法设置DTD后，解析器会将其缓存以供进一步解析。
                        </p>
                        <div class="section">
                           <div class="infoboxnote" id="GUID-0B99A25C-9330-4CDD-93AF-96C26667AA39__GUID-6551157D-2FA2-4106-AE11-6A894E626C02">
                              <p class="notep1">注意：</p>
                              <p>DTD缓存是可选的，不会自动启用。</p>
                           </div>
                           <p>假设您的程序必须使用相同的DTD解析多个XML文档。解析第一个XML文档后，可以从解析器获取DTD并进行设置。例如：</p><pre class="oac_no_warn" dir="ltr">DOMParser解析器=新的DOMParser（）; DTD dtd = parser.getDoctype（）; parser.setDoctype（DTD）;</pre><p><a href="XML-parsing-for-Java.html#GUID-0B99A25C-9330-4CDD-93AF-96C26667AA39__CCHDIBGH">例12-7</a>调用<code class="codeph">DOMParser.setDoctype()</code>来缓存DTD。</p>
                           <p>如果缓存的DTD对象仅用于验证，则设置<code class="codeph">DOMParser.USE_DTD_ONLY_FOR_VALIDATION</code>属性：</p><pre class="oac_no_warn" dir="ltr">parser.setAttribute（的DOMParser。USE_DTD_ONLY_FOR_VALIDATION，布尔。真正）;</pre><p>否则，XML解析器会复制DTD对象并将其添加到生成的DOM树中。</p>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-0B99A25C-9330-4CDD-93AF-96C26667AA39__CCHDIBGH">
                           <p class="titleinexample">例12-7 DTDSample.java</p><pre class="oac_no_warn" dir="ltr">/ ** *说明*此程序说明了DTD缓存。* / import java.net。网址; import java.io.*; import org.xml.sax。InputSource的; import oracle.xml.parser.v2。*; public class DTDSample {static public void main（String [] args）{try {if（args.length！= 3）{System.err.println（“用法：java DTDSample dtd rootelement xmldoc”）; System.exit（1）; } //创建DOM解析器DOMParser parser = new DOMParser（）; //配置解析器parser.setErrorStream（System.out）; parser.showWarnings（真）; //为命令// line上指定的DTD文件创建FileReader，并将其包装在InputSource FileReader中r = new FileReader（args [0]）; InputSource inSource = new InputSource（r）; //从命令行参数创建一个URL，并用它来设置//系统标识符inSource.setSystemId（DemoUtil.createURL（args [0]）。toString（））; //从输入源解析外部DTD。第二个参数是//根元素的名称。parser.parseDTD（inSource，args [1]）; DTD dtd = parser.getDoctype（）; //从//命令行中指定的XML文档创建FileReader对象r = new FileReader（args [2]）; //将FileReader包装在InputSource中，//从文件名//创建一个URL，并在Source = new InputSource（r）中设置系统标识符; inSource.setSystemId（DemoUtil.createURL（参数[2]）的toString（））; // ******************** parser.setDoctype（dtd）; // ******************** parser.setValidationMode（DOMParser。DTD_VALIDATION）; // parser.setAttribute //（DOMParser。USE_DTD_ONLY_FOR_VALIDATION，布尔。真正）; parser.parse（Insource公司）; //获取DOM树并打印XMLDocument doc = parser.getDocument（）; doc.print（new PrintWriter（System.out））; } catch（Exception e）{System.out.println（e.toString（））; }}}</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div>
               </div><a id="ADXDK984"></a><a id="ADXDK19179"></a><div class="props_rev_3"><a id="GUID-5F9B55B9-9AA9-4C2C-A59D-A5C97289F641" name="GUID-5F9B55B9-9AA9-4C2C-A59D-A5C97289F641"></a><h4 id="ADXDK-GUID-5F9B55B9-9AA9-4C2C-A59D-A5C97289F641" class="sect4">使用XML解析器处理字符集</h4>
                  <div>
                     <p>介绍了使用解析器处理字符集的主题。</p>
                     <div class="section"></div>
                     <!-- class="section" -->
                  </div><a id="ADXDK19180"></a><div class="props_rev_3"><a id="GUID-A2896B6B-A1EE-4EBA-8CAD-E936ED3D2323" name="GUID-A2896B6B-A1EE-4EBA-8CAD-E936ED3D2323"></a><h5 id="ADXDK-GUID-A2896B6B-A1EE-4EBA-8CAD-E936ED3D2323" class="sect5">检测操作系统上XML文件的编码</h5>
                     <div>
                        <p>使用XML解析器检测存储在文件系统上的XML文件的字符编码。</p>
                        <div class="section">
                           <p>读取存储在操作系统上的XML文件时，请不要使用<code class="codeph">FileReader</code>类。而是使用XML解析器自动检测文档的字符编码。给定没有外部编码信息的二进制<code class="codeph">FileInputStream</code> ，解析器根据XML文档的字节顺序标记和编码声明自动确定字符编码。您可以使用<code class="codeph">AutoDetectEncoding.java</code>演示中的示例代码解析任何支持的编码中的任何格式良好的文档，该演示位于<code class="codeph">$ORACLE_HOME/xdk/demo/java/parser/dom</code> 。
                           </p>
                           <div class="infoboxnote" id="GUID-A2896B6B-A1EE-4EBA-8CAD-E936ED3D2323__GUID-C94CE09B-9D7D-4E28-B8B5-1A6535793F7A">
                              <p class="notep1">注意：</p>
                              <p>根据规范，在文档中包含正确的编码声明。 <code class="codeph">setEncoding()</code>无法设置输入文档的编码。 <code class="codeph">setEncoding()</code>与<code class="codeph">oracle.xml.parser.v2.XMLDocument</code>设置正确的打印编码。
                              </p>
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="ADXDK19181"></a><div class="props_rev_3"><a id="GUID-DB29764D-7BEA-41D6-8B35-76B5C0F65139" name="GUID-DB29764D-7BEA-41D6-8B35-76B5C0F65139"></a><h5 id="ADXDK-GUID-DB29764D-7BEA-41D6-8B35-76B5C0F65139" class="sect5">防止存储在NCLOB列中的XML失真</h5>
                     <div>
                        <p>为了避免存储在<code class="codeph">NCLOB</code>列中的XML数据失真，请使用方法<code class="codeph">getUnicodeStream()</code>和<code class="codeph">getBinaryStream()</code> ，或者打印数据以确保其字符在发送到解析器之前不会失真。
                        </p>
                        <div class="section">
                           <p>假设您使用Unicode（UTF-8）的8位编码将XML加载到数据库的国家字符大对象（ <code class="codeph">NCLOB</code> ）列中，并且XML包含两个UTF-8多字节字符：</p><pre class="oac_no_warn" dir="ltr">G <span class="bold">（0xc2,0x82）</span> otingen，Br <span class="bold">（0xc3,0xbc）</span> ck_W</pre><p>您编写了一个Java存储函数来执行此操作：</p>
                        </div>
                        <!-- class="section" -->
                        <ol>
                           <li class="stepexpand"><span>使用默认连接对象连接到数据库。</span></li>
                           <li class="stepexpand"><span>运行<code class="codeph">SELECT</code>查询。</span></li>
                           <li class="stepexpand"><span>获取<code class="codeph">oracle.jdbc.OracleResultSet</code>对象。</span></li>
                           <li class="stepexpand"><span>调用<code class="codeph">OracleResultSet.getCLOB()</code>方法。</span></li>
                           <li class="stepexpand"><span>在<code class="codeph">CLOB</code>对象上调用<code class="codeph">getAsciiStream()</code>方法。</span></li>
                           <li class="stepexpand"><span>执行此代码以将XML转换为DOM对象：</span><div><pre class="oac_no_warn" dir="ltr">DOMParser解析器=新的DOMParser（）; parser.setPreserveWhitespace（真）; parser.parse（ISTR）; // istr getAsciiStream XMLDocument xmldoc = parser.getDocument（）;</pre></div>
                           </li>
                        </ol>
                        <div class="section">
                           <p>该计划抛出一个异常，说明该XML包含无效的UTF-8编码，即使字符（ <code class="codeph">0xc2</code> ， <code class="codeph">0x82</code> ）是有效的UTF-8。问题是当程序调用<code class="codeph">OracleResultSet.getAsciiStream()</code>方法时，字符可能会失真。要解决此问题，请调用<code class="codeph">getUnicodeStream()</code>和<code class="codeph">getBinaryStream()</code>方法而不是<code class="codeph">getAsciiStream()</code> 。如果此技术不起作用，则尝试打印字符以确保在调用<code class="codeph">DOMParser.parse(istr)</code>时将它们发送到解析器之前不会失真。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="ADXDK19182"></a><div class="props_rev_3"><a id="GUID-00C4A795-47D4-4E77-BA29-915C5DC12E91" name="GUID-00C4A795-47D4-4E77-BA29-915C5DC12E91"></a><h5 id="ADXDK-GUID-00C4A795-47D4-4E77-BA29-915C5DC12E91" class="sect5">在非默认编码中编写XML文件</h5>
                     <div>
                        <p>引入了一种技术来避免在编写包含默认字符编码中不可用的字符的XML文件时可能引入的问题。</p>
                        <div class="section">
                           <p>UTF-8编码在XML文档中很流行，但UTF-8通常不是Java的默认文件编码。在程序中使用假定默认文件编码的Java类可能会导致问题。</p>
                           <p>例如，Java类<code class="codeph">FileWriter</code>依赖于运行时环境的默认字符编码。如果在编写包含默认字符编码中不可用的字符的XML文件时使用<code class="codeph">FileWriter</code>类，则输出文件可能会遇到解析错误或数据丢失。
                           </p>
                           <p>要避免此类问题，请使用<code class="codeph">$ORACLE_HOME/xdk/demo/java/parser/dom</code>中的<code class="codeph">I18nSafeXMLFileWritingSample.java</code>程序中显示的技术。
                           </p>
                           <p>您不能使用<code class="codeph">System.out.println()</code>输出特殊字符。您必须使用可识别编码的二进制输出流，例如<code class="codeph">OutputStreamWriter</code> 。构造一个<code class="codeph">OutputStreamWriter</code>并使用<code class="codeph">write(char[]</code> ， <code class="codeph">int</code> ， <code class="codeph">int)</code>方法进行打印，如下例所示：</p><pre class="oac_no_warn" dir="ltr">/ * ISO8859-1的Java编码字符串* / OutputStreamWriter out = new OutputStreamWriter（System.out，“8859_1”）; OutputStreamWriter.write（...）;</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="ADXDK19184"></a><a id="ADXDK19183"></a><div class="props_rev_3"><a id="GUID-9F9A2E21-D23F-4D27-ABDD-887027A690AA" name="GUID-9F9A2E21-D23F-4D27-ABDD-887027A690AA"></a><h5 id="ADXDK-GUID-9F9A2E21-D23F-4D27-ABDD-887027A690AA" class="sect5">解析存储在字符串中的XML</h5>
                     <div>
                        <p>要解析<code class="codeph">String</code>包含的XML文档，必须先将字符串转换为<code class="codeph">InputStream</code>或<code class="codeph">InputSource</code>对象。
                        </p>
                        <div class="section">
                           <p><a href="XML-parsing-for-Java.html#GUID-9F9A2E21-D23F-4D27-ABDD-887027A690AA__CCHFBJDJ">例12-8</a>将XML字符串（由<code class="codeph">xmlDoc</code>引用）转换为字节数组，将字节数组转换为<code class="codeph">ByteArrwayInputStream</code> ，然后对其进行解析。
                           </p>
                           <p>您可以通过在<code class="codeph">PrintWriter</code>包装<code class="codeph">StringWriter</code>将之前代码中创建的<code class="codeph">XMLDocument</code>对象转换回字符串。此示例显示了此技术：</p>
                           <p>要将<a href="XML-parsing-for-Java.html#GUID-9F9A2E21-D23F-4D27-ABDD-887027A690AA__CCHFBJDJ">示例12-8中</a>创建的<code class="codeph">XMLDocument</code>对象转换回字符串，可以将<code class="codeph">StringWriter</code>包装在<code class="codeph">PrintWriter</code> ：</p><pre class="oac_no_warn" dir="ltr">StringWriter sw = new StringWriter（）; PrintWriter pw = new PrintWriter（sw）; doc.print（PW）; String YourDocInString = sw.toString（）;</pre><p><code class="codeph">ParseXMLFromString.java</code>位于<code class="codeph">$ORACLE_HOME/xdk/demo/java/parser/dom</code> ，是一个完整的程序，它将XML文档创建为字符串并对其进行解析。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-9F9A2E21-D23F-4D27-ABDD-887027A690AA__CCHFBJDJ">
                           <p class="titleinexample">示例12-8在字符串中转换XML</p><pre class="oac_no_warn" dir="ltr">//创建解析器DOMParser parser = new DOMParser（）; //在字符串中创建XML文档String xmlDoc =“&lt;？xml版本='1.0'？&gt;“+”&lt;hello&gt;“+”&lt;world /&gt;“+”&lt;/ hello&gt;“; //将字符串转换为字节为流字节aByteArr [] = xmlDoc.getBytes（）; ByteArrayInputStream bais = new ByteArrayInputStream（aByteArr， 0，aByteArr.length）; //解析并获取DOM树DOMParser.parse（bais）; XMLDocument doc = parser.getDocument（）;</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="ADXDK19186"></a><a id="ADXDK19185"></a><div class="props_rev_3"><a id="GUID-B467ECCA-6AB3-4EB2-89C3-535F3A423265" name="GUID-B467ECCA-6AB3-4EB2-89C3-535F3A423265"></a><h5 id="ADXDK-GUID-B467ECCA-6AB3-4EB2-89C3-535F3A423265" class="sect5">使用重音字符解析XML文档</h5>
                     <div>
                        <p>提供了解析包含重音字符的XML文档的提示。</p>
                        <div class="section">
                           <p><a href="XML-parsing-for-Java.html#GUID-B467ECCA-6AB3-4EB2-89C3-535F3A423265__CCHCBEEG">例12-9</a>显示了使用重音字符（例如<code class="codeph">é</code> ）解析XML文档的一种方法。
                           </p>
                           <p>当您尝试解析XML文件时，解析器可能会抛出“无效的UTF-8编码”异常。编码是用于将Unicode字符编号表示写入磁盘的方案。如果您明确地将编码设置为UTF-8或未指定编码，则解析器会将重音字符（其ASCII值大于127）解释为UTF-8多字节序列的第一个字节。如果后续字节不形成有效的UTF-8序列，则会出现错误。</p>
                           <p>该错误意味着您的XML编辑器未使用UTF-8编码保存文件。编辑器可能已使用ISO-8859-1（西欧ASCII）编码保存文件。将以下元素添加到XML文档的顶部不会导致编辑器使用UTF-8编码将表示文件的字节写入磁盘：</p><pre class="oac_no_warn" dir="ltr">&lt;？xml version =“1.0”encoding =“UTF-8”？&gt;</pre><p>一种解决方案是在XML文档中读取十六进制或十进制格式的重音字符;例如， <code class="codeph">&amp;#xd9;</code> 。如果您不想使用此技术，则可以根据创建XML文件时使用的字符集设置编码（例如，ISO-8859-1）。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-B467ECCA-6AB3-4EB2-89C3-535F3A423265__CCHCBEEG">
                           <p class="titleinexample">示例12-9使用重音字符解析文档</p><pre class="oac_no_warn" dir="ltr">DOMParser解析器=新的DOMParser（）; parser.setPreserveWhitespace（真）; parser.setErrorStream（System.err的）; parser.setValidationMode（假）; parser.showWarnings（真）; parser.parse（new FileInputStream（new File（“file_with_accents.xml”）））;</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="ADXDK19187"></a><div class="props_rev_3"><a id="GUID-3E59A02D-6A61-473E-A1A0-93BC17DACB61" name="GUID-3E59A02D-6A61-473E-A1A0-93BC17DACB61"></a><h5 id="ADXDK-GUID-3E59A02D-6A61-473E-A1A0-93BC17DACB61" class="sect5">处理标记名称中的特殊字符</h5>
                     <div>
                        <p>提供了处理XML元素名称中的特殊字符的提示。</p>
                        <div class="section">
                           <p>如果标记（元素）名称包含特殊字符（ <code class="codeph">&amp;</code> ， <code class="codeph">$</code>和<code class="codeph">#</code>等），则解析器会发出有关无效字符的错误。
                           </p>
                           <p>如果要创建新的XML文档，请选择没有无效<code class="codeph">NameChar</code>字符的标记名称。例如，如果要在公司之后命名标记，并且一个公司的名称为A＆B，则选择<code class="codeph">&lt;A_B&gt;</code> ， <code class="codeph">&lt;AB&gt;</code>或<code class="codeph">&lt;A_AND_B&gt;</code> ，而不是无效标记<code class="codeph">&lt;A&amp;B&gt;</code> <code class="codeph">&lt;A_AND_B&gt;</code> 。
                           </p>
                           <p>如果要从外部数据源（如数据库表）生成XML，则：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>XML 1.0没有解决这个问题。</p>
                              </li>
                              <li>
                                 <p>在XML 1.1中，数据类型<code class="codeph">XMLType</code>通过在<code class="codeph">DBMS_XMLGEN</code>包中提供<code class="codeph">setConvertSpecialChars</code>和<code class="codeph">convert</code>函数来解决此问题。
                                 </p>
                                 <p>您可以使用这些函数来控制结构化查询语言（SQL）名称和XML名称中特殊字符的使用。在SQL到XML名称映射功能逃跑无效的XML <code class="codeph">NameChar</code>中的格式字符<span class="italic"><code class="codeph">_XHHHH_</code></span> ，其中<span class="italic"><code class="codeph">HHHH</code></span>是无效字符的Unicode值。例如，表名<code class="codeph">V$SESSION</code>映射到XML名称<code class="codeph">V_X0024_SESSION</code> 。</p>
                                 <p>转义无效字符提供了一种序列化名称的方法，以便可以在其他位置重新加载它们。</p>
                              </li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>