<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <title>数据库概念</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Programmer&#39;s Guide"></meta>
      <meta property="og:description" content=""></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Programmer&#39;s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="cobol-programmers-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-11T02:40:40-08:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="1996, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96466-01"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="precompiler-concepts.html" title="Previous" type="text/html"></link>
      <link rel="next" href="datatypes-and-host-variables.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Pro*COBOL Programmer&#39;s Guide"></meta>
    <meta name="dcterms.isVersionOf" content="LNPCB"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="precompiler-concepts.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="datatypes-and-host-variables.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">程序员指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="introduction-and-concepts.html" property="item" typeof="WebPage"><span property="name">介绍和概念</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">数据库概念</li>
            </ol>
            <a id="GUID-0F4F51CC-ED32-427A-9631-7BCDDC7D2DB2" name="GUID-0F4F51CC-ED32-427A-9631-7BCDDC7D2DB2"></a><a id="LNPCB003"></a>
            
            <h2 id="LNPCB-GUID-0F4F51CC-ED32-427A-9631-7BCDDC7D2DB2" class="sect2"><span class="enumeration_chapter">3</span>数据库概念</h2>
         </header>
         <div class="ind">
            <div>
               <p>本章介绍CONNECT语句及其选项，Oracle Net Services和相关的网络连接语句。提供了交易处理。您将学习保护数据库一致性的基本技术，包括如何控制对Oracle数据的更改是永久更改还是撤消。</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="database-concepts.html#GUID-5B6A77A1-D7B0-4BC1-B194-E7EB51A54304">连接到Oracle</a></p>
                  </li>
                  <li>
                     <p><a href="database-concepts.html#GUID-E3F2A833-D42D-475F-8DE5-F1EFD91E2A2C">默认数据库和连接</a></p>
                  </li>
                  <li>
                     <p><a href="database-concepts.html#GUID-E1177148-D3CD-4BD8-9410-960476A6617C">关键术语</a></p>
                  </li>
                  <li>
                     <p><a href="database-concepts.html#GUID-6A1C673E-993A-453B-9390-DEF91EEE3D65">事务如何保护数据库</a> 
                     </p>
                  </li>
                  <li>
                     <p><a href="database-concepts.html#GUID-B7317C1E-9549-4ACD-884C-35F3628CA825">开始和结束交易</a></p>
                  </li>
                  <li>
                     <p><a href="database-concepts.html#GUID-F6D78EC6-B50D-45E7-B409-0D3994CF5339">使用COMMIT语句</a></p>
                  </li>
                  <li>
                     <p><a href="database-concepts.html#GUID-C323E4D2-9CEE-46B6-8C08-50B71EA5505D">使用ROLLBACK语句</a></p>
                  </li>
                  <li>
                     <p><a href="database-concepts.html#GUID-59EEDD58-7CD0-4842-9545-6B2C52D6488B">使用SAVEPOINT语句</a></p>
                  </li>
                  <li>
                     <p><a href="database-concepts.html#GUID-4B174FCB-ADD2-46EC-B0D0-6C64BE0DC1D4">使用RELEASE选项</a></p>
                  </li>
                  <li>
                     <p><a href="database-concepts.html#GUID-7CCD2A18-D062-4F41-AABF-D58A763E6627">使用SET TRANSACTION语句</a></p>
                  </li>
                  <li>
                     <p><a href="database-concepts.html#GUID-78E84CE3-AFAA-4279-B3BE-48800AD6ADAC">覆盖默认锁定</a></p>
                  </li>
                  <li>
                     <p><a href="database-concepts.html#GUID-687E5EBE-714C-49B1-928E-4EB8310B85A8">在提交中获取</a></p>
                  </li>
                  <li>
                     <p><a href="database-concepts.html#GUID-123F9392-C594-46DB-A2BB-92A92953C08A">处理分布式事务</a></p>
                  </li>
                  <li>
                     <p><a href="database-concepts.html#GUID-5BE08E32-E12A-48B0-AEBE-DAF750831D12">交易处理指南</a></p>
                  </li>
               </ul>
            </div><a id="LNPCB203"></a><div class="props_rev_3"><a id="GUID-5B6A77A1-D7B0-4BC1-B194-E7EB51A54304" name="GUID-5B6A77A1-D7B0-4BC1-B194-E7EB51A54304"></a><h3 id="LNPCB-GUID-5B6A77A1-D7B0-4BC1-B194-E7EB51A54304" class="sect3"><span class="enumeration_section">3.1</span>连接到Oracle</h3>
               <div>
                  <p>在查询或操作数据之前，您的Pro * COBOL程序必须登录Oracle。要登录，请使用CONNECT语句，如<a id="d10894e119" class="indexterm-anchor"></a><a id="d10894e121" class="indexterm-anchor"></a><a id="d10894e125" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">EXEC SQL CONNECT：USERNAME IDENTIFIED BY：PASSWD END-EXEC。</pre><p>其中USERNAME和PASSWD是PIC X（ <span class="italic">n</span> ）或PIC X（ <span class="italic">n</span> ）VARYING主变量。或者，您可以使用以下语句：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL CONNECT：USR-PWD END-EXEC。</pre><p>其中主机变量USR-PWD包含用斜杠（/）分隔的用户名和密码，后跟可选的tnsnames.ora别名（@TNSALIAS）。</p>
                  <p>CONNECT语句的语法具有可选的ALTER AUTHORIZATION子句。CONNECT的完整语法如下所示：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL CONNECT {：用户IDENTIFIED BY：oldpswd | ：usr_psw} [[AT {dbname | ：host_variable}] USING：connect_string] [{ALTER AUTHORIZATION：newpswd | IN {SYSDBA | SYSOPER} MODE}] END-EXEC。</pre><p>CONNECT语句必须是程序执行的第一个SQL语句。也就是说，其他可执行的SQL语句可以位于CONNECT语句之前，但不能在逻辑上。如果预编译器选项AUTO_CONNECT = YES，则不需要CONNECT语句。）<a id="d10894e149" class="indexterm-anchor"></a><a id="d10894e153" class="indexterm-anchor"></a></p>
                  <p>要单独提供用户名和密码，请将两个主机变量定义为字符串或VARCHAR变量。如果提供包含用户名和密码的用户标识，则只需要一个主变量。<a id="d10894e159" class="indexterm-anchor"></a><a id="d10894e163" class="indexterm-anchor"></a><a id="d10894e167" class="indexterm-anchor"></a></p>
                  <p>确保在执行CONNECT之前设置用户名和密码变量，否则它将失败。您的程序可以提示输入值，也可以对它们进行硬编码，如下所示：<a id="d10894e173" class="indexterm-anchor"></a><a id="d10894e177" class="indexterm-anchor"></a><a id="d10894e181" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">工作储存部分。 ...01 USERNAME PIC X（10）。01 PASSWD PIC X（10）。......程序部门。登录。执行SQL WHENEVER SQLERROR GOTO LOGON-ERROR END-EXEC。将“SCOTT”移至USERNAME。将“TIGER”转移到PASSWD。 EXEC SQL CONNECT：USERNAME IDENTIFIED BY：PASSWD END-EXEC。</pre><p>但是，您不能将用户名和密码硬编码到CONNECT语句中或使用带引号的文字。例如，以下语句<span class="italic">无效</span> ：</p><pre class="oac_no_warn" dir="ltr">由TIGER END-EXEC识别的EXEC SQL CONNECT SCOTT。 EXEC SQL CONNECT“SCOTT”由“TIGER”END-EXEC识别。</pre><div class="infoboxnotealso" id="GUID-5B6A77A1-D7B0-4BC1-B194-E7EB51A54304__GUID-77CFF8AA-BF7B-499F-9777-FA1EA490138B">
                     <p class="notep1">也可以看看：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><span class="q">“</span>有关ALTER AUTHORIZATION子句的更多信息，请参阅<span class="q">” <a href="database-concepts.html#GUID-E37C4FF2-C93D-41E3-A4C0-7B07AA29BEF3">在运行时更改密码</a> “</span> 。
                           </p>
                        </li>
                        <li>
                           <p>有关SYSDBA和SYSOPER的更多信息，请参见<span class="q">“ <a href="database-concepts.html#GUID-C9E12FED-5BDF-4647-A5DE-EDC4D42CEAA1">SYSDBA或SYSOPER权限</a> ”</span> 。</p>
                        </li>
                     </ul>
                  </div>
               </div>
            </div><a id="LNPCB204"></a><div class="props_rev_3"><a id="GUID-E3F2A833-D42D-475F-8DE5-F1EFD91E2A2C" name="GUID-E3F2A833-D42D-475F-8DE5-F1EFD91E2A2C"></a><h3 id="LNPCB-GUID-E3F2A833-D42D-475F-8DE5-F1EFD91E2A2C" class="sect3"><span class="enumeration_section">3.2</span>默认数据库和连接</h3>
               <div>
                  <p>在Pro * COBOL程序中，可以同时维护多个数据库连接。</p>
               </div><a id="LNPCB206"></a><a id="LNPCB205"></a><div class="props_rev_3"><a id="GUID-EE843C17-8881-494C-85CE-8EE4D0833065" name="GUID-EE843C17-8881-494C-85CE-8EE4D0833065"></a><h4 id="LNPCB-GUID-EE843C17-8881-494C-85CE-8EE4D0833065" class="sect4"><span class="enumeration_section">3.2.1</span>并发登录</h4>
                  <div>
                     <p><a id="d10894e259" class="indexterm-anchor"></a> Pro * COBOL通过Oracle Net Services支持分布式处理。您的应用程序可以同时访问本地和远程数据库的任意组合，或者建立到同一数据库的多个连接。在<a href="database-concepts.html#GUID-EE843C17-8881-494C-85CE-8EE4D0833065__BHCBICDF">图3-1中</a> ，应用程序与一个本地和三个远程Oracle数据库进行通信。ORA2，ORA3和ORA4是CONNECT语句中使用的逻辑名称。<a id="d10894e266" class="indexterm-anchor"></a><a id="d10894e270" class="indexterm-anchor"></a><a id="d10894e274" class="indexterm-anchor"></a><a id="d10894e278" class="indexterm-anchor"></a></p>
                     <div class="figure" id="GUID-EE843C17-8881-494C-85CE-8EE4D0833065__BHCBICDF">
                        <p class="titleinfigure">图3-1通过Oracle连接</p><img src="img/pco81045.gif" alt="下面是图3-1的描述" title="下面是图3-1的描述" longdesc="img_text/pco81045.html"><br><a href="img_text/pco81045.html">“图3-1通过Oracle连接”的描述</a></div>
                     <!-- class="figure" -->
                     <p>通过消除不同机器和操作系统之间网络的边界，Oracle Net Services为Oracle工具提供了分布式处理环境。本节介绍Pro * COBOL如何通过Oracle Net Services支持分布式处理。您将了解您的应用程序的用途<a id="d10894e287" class="indexterm-anchor"></a><a id="d10894e291" class="indexterm-anchor"></a></p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>直接或间接访问其他数据库</p>
                        </li>
                        <li>
                           <p>同时访问本地和远程数据库的任意组合</p>
                        </li>
                        <li>
                           <p>建立到同一数据库的多个连接</p>
                        </li>
                     </ul>
                     <p>通常，您只需要一个连接，由<code class="codeph">EXEC SQL CONNECT :USR-PWD END-EXEC</code> 。连接的数据库由USR-PWD包含的内容决定。如果它包含默认数据库的用户名和密码，它将连接到定义为会话默认值的数据库。如果它包含<span class="italic">用户名</span> / <span class="italic">密码</span> @REMDB，它将通过Oracle Net Services连接到Oracle Net Services配置定义的REMDB数据库。（另一种方法是使用USING子句指定Oracle Net Services连接字符串。）这是默认连接。
                     </p>
                     <p>要进一步并发连接到相同或不同的数据库，可以使用AT子句，即<code class="codeph">EXEC SQL AT DB1 CONNECT :USR-PWD END-EXEC</code> 。AT子句后面的名称唯一标识“非默认”连接，并且对该连接执行AT子句后具有相同名称的任何SQL语句。如果在SQL语句中省略了AT子句，则会针对默认连接执行该语句。<a id="d10894e319" class="indexterm-anchor"></a><a id="d10894e321" class="indexterm-anchor"></a></p>
                     <p>所有数据库名称必须唯一，但两个或多个数据库名称可以指定相同的连接。也就是说，您可以与任何节点上的任何数据库建立多个连接。<a id="d10894e327" class="indexterm-anchor"></a></p>
                  </div>
               </div><a id="LNPCB207"></a><div class="props_rev_3"><a id="GUID-1C06C193-EAB3-4859-9A3E-607F27D4117E" name="GUID-1C06C193-EAB3-4859-9A3E-607F27D4117E"></a><h4 id="LNPCB-GUID-1C06C193-EAB3-4859-9A3E-607F27D4117E" class="sect4"><span class="enumeration_section">3.2.2</span>使用用户名/密码</h4>
                  <div>
                     <p>通常，您建立与Oracle的连接，如下所示：<a id="d10894e355" class="indexterm-anchor"></a><a id="d10894e357" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">EXEC SQL CONNECT：USERNAME IDENTIFIED BY：PASSWORD END-EXEC。</pre><p>或者您可以使用：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL CONNECT：USR-PWD END-EXEC。 <span class="bold"> </span>
</pre><p>其中<span class="italic">USR-PWD</span>包含任何有效的Oracle连接字符串。
                     </p>
                     <p>这些是CONNECT语句的简化子集。有关所有详细信息，请阅读本章的下一节<a id="d10894e377" class="indexterm-anchor"></a> 。
                     </p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="database-concepts.html#GUID-056EC81F-F05C-4C33-9393-856EF3FADA89">自动登录</a></li>
                           <li><a href="embedded-SQL-statements-and-precompiler-directives.html#GUID-8E024106-6BB5-434C-99A6-1A55839D8316">CONNECT（可执行的嵌入式SQL扩展）</a></li>
                        </ul>
                     </div>
                  </div><a id="LNPCB208"></a><div class="props_rev_3"><a id="GUID-1B4D63D7-11EB-449A-ADAE-1D76141787E9" name="GUID-1B4D63D7-11EB-449A-ADAE-1D76141787E9"></a><h5 id="LNPCB-GUID-1B4D63D7-11EB-449A-ADAE-1D76141787E9" class="sect5"><span class="enumeration_section">3.2.2.1</span>命名数据库连接</h5>
                     <div>
                        <p>在以下示例中，您将连接到指定的数据库。通常，您仅为多个并发连接使用命名数据库连接。以下示例显示了单个连接的语法：<a id="d10894e415" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">*  - 声明必要的主变量WORKING-STORAGE SECTION。 ...EXEC SQL BEGIN DECLARE SECTION END-EXEC。 01 USERNAME PIC X（10）。01 PASSWORD PIC X（10）。01 DB-STRING PIC X（20）。...EXEC SQL END DECLARE SECTION END-EXEC。 ...程序部门。将“scott”移至USERNAME。移动“老虎”通往PASSSWORD。将“nyremote”移到DB-STRING。 ...*  - 为数据库连接分配唯一的名称。EXEC SQL DECLARE DBNAME DATABASE <span class="bold"> </span> END-EXEC。 *  - 连接到非默认数据库EXEC SQL CONNECT：USERNAME IDENTIFIED BY：PASSWORD at DBNAME使用：DB-STRING END-EXEC。</pre><p>此示例中的标识符用于以下目的：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>主机变量<span class="italic">USERNAME</span>和<span class="italic">PASSWORD</span>标识有效用户。
                              </p>
                           </li>
                           <li>
                              <p>主机变量<span class="italic">DB-STRING</span>包含用于登录远程节点上的非默认数据库的Oracle Net Services语法。
                              </p>
                           </li>
                           <li>
                              <p>未声明的标识符<span class="italic">DBNAME</span>命名非默认连接;它是Oracle使用的标识符， <span class="italic">而不是</span>主机或程序变量。
                              </p>
                           </li>
                        </ul>
                        <p>USING子句指定与<span class="italic">DBNAME</span>关联的网络，计算机和数据库。之后，使用AT子句（带有<span class="italic">DBNAME</span> ）的SQL语句在<span class="italic">DB-STRING</span>指定的数据库中执行。 <a id="d10894e462" class="indexterm-anchor"></a><a id="d10894e466" class="indexterm-anchor"></a><a id="d10894e470" class="indexterm-anchor"></a><a id="d10894e474" class="indexterm-anchor"></a> 
                        </p>
                        <p>或者，您可以在AT子句中使用字符主机变量，如以下示例所示：</p><pre class="oac_no_warn" dir="ltr">*  - 声明必要的主变量WORKING-STORAGE SECTION。 ...EXEC SQL BEGIN DECLARE SECTION END-EXEC。 01 USERNAME PIC X（10）。01 PASSWORD PIC X（10）。01 DB-NAME PIC X（10）。01 DB-STRING PIC X（20）。...EXEC SQL END DECLARE SECTION END-EXEC。 ...程序部门。将“scott”移至USERNAME。移动“老虎”通往PASSSWORD。将“oracle1”移动到DB-NAME。将“nyremote”移到DB-STRING。 ...*  - 连接到非默认数据库EXEC SQL CONNECT：USERNAME IDENTIFIED BY：PASSWORD AT：DB-NAME USING：DB-STRING END-EXEC。</pre><p>如果<span class="italic">DB-NAME</span>是主机变量，则不需要DECLARE DATABASE语句。只有当<span class="italic">DBNAME</span>是未声明的标识符时，才能在执行CONNECT之前执行DECLARE <span class="italic">DBNAME</span> DATABASE语句...AT <span class="italic">DBNAME</span>声明。
                        </p>
                        <p><span class="bold">SQL操作。</span>如果授予该权限，则可以在非默认连接上执行任何SQL数据操作语句。例如，您可以执行以下语句序列：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL AT DBNAME SELECT ...EXEC SQL在DBNAME INSERT ...EXEC SQL在DBNAME UPDATE ...
</pre><p>在下一个示例中， <span class="italic">DB-NAME</span>是主机变量：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL AT：DB-NAME DELETE ...
</pre><p><span class="bold">光标控制。</span>诸如OPEN，FETCH和CLOSE之类的游标控制语句是例外 - 它们从不使用AT子句。如果要将游标与显式标识的数据库关联，请使用DECLARE CURSOR语句中的AT子句，如下所示： <a id="d10894e515" class="indexterm-anchor"></a><a id="d10894e519" class="indexterm-anchor"></a> 
                        </p><pre class="oac_no_warn" dir="ltr">EXEC SQL AT：DB-NAME DECLARE emp_cursor CURSOR FOR ...EXEC SQL OPEN emp_cursor ...EXEC SQL FETCH emp_cursor ...EXEC SQL CLOSE emp_cursor END-EXEC。</pre><p>如果<span class="italic">DB-NAME</span>是主变量，则其声明必须在引用声明游标的所有SQL语句的范围内。例如，如果在一个子程序中打开光标，然后从另一个子程序中取出，则必须全局声明<span class="italic">DB-NAME</span>或将其传递给每个子程序。
                        </p>
                        <p>从光标打开，关闭或提取时，不使用AT子句。如果在游标声明中没有使用AT子句，则SQL语句在DECLARE CURSOR语句的AT子句中指定的数据库中执行，或者在缺省数据库中执行。</p>
                        <p>AT <span class="italic">：host-variable</span>子句使您可以更改与游标关联的连接。但是，您无法在光标打开时更改关联。请考虑以下示例： <a id="d10894e541" class="indexterm-anchor"></a><a id="d10894e545" class="indexterm-anchor"></a> 
                        </p><pre class="oac_no_warn" dir="ltr">EXEC SQL AT：DB-NAME DECLARE emp_cursor CURSOR FOR ...将“oracle1”移动到DB-NAME。 EXEC SQL OPEN emp_cursor END-EXEC。 EXEC SQL FETCH emp_cursor INTO ...将“oracle2”移动到DB-NAME。 *  - 非法，光标仍然打开EXEC SQL OPEN emp_cursor END-EXEC。 EXEC SQL FETCH emp_cursor INTO ...
</pre><p>这是非法的，因为当您尝试执行第二个OPEN语句时， <span class="italic">emp_cursor</span>仍处于打开状态。不为不同的连接维护单独的游标;只有一个<span class="italic">emp_cursor</span> ，必须先关闭才能重新打开另一个连接。要调试最后一个示例，只需在重新打开之前关闭游标，如下所示：</p><pre class="oac_no_warn" dir="ltr">*  - 首先关闭游标EXEC SQL CLOSE emp_cursor END-EXEC。将“oracle2”移动到DB-NAME。 EXEC SQL OPEN EMP-CUROR END-EXEC。 EXEC SQL FETCH emp_cursor INTO ...
</pre><p><span class="bold">动态SQL</span> 。动态SQL语句类似于游标控制语句，因为有些语句从不使用AT子句。对于动态SQL方法1，如果要在非默认连接上执行语句，则必须使用AT子句。一个例子如下： <a id="d10894e566" class="indexterm-anchor"></a><a id="d10894e570" class="indexterm-anchor"></a><a id="d10894e574" class="indexterm-anchor"></a> 
                        </p><pre class="oac_no_warn" dir="ltr">EXEC SQL AT：DB-NAME EXECUTE IMMEDIATE：SQL-STMT END-EXEC。</pre><p>对于方法2,3和4，如果要在非默认连接中执行语句，则仅在DECLARE STATEMENT语句中使用AT子句。所有其他动态SQL语句（如PREPARE，DESCRIBE，OPEN，FETCH和CLOSE）从不使用AT子句。下一个示例显示方法2： <a id="d10894e584" class="indexterm-anchor"></a><a id="d10894e588" class="indexterm-anchor"></a> 
                        </p><pre class="oac_no_warn" dir="ltr">EXEC SQL AT：DB-NAME DECLARE SQL-STMT STATEMENT END-EXEC。 EXEC SQL PREPARE SQL-STMT FROM：SQL-STRING END-EXEC。 EXEC SQL EXECUTE SQL-STMT END-EXEC。</pre><p>以下示例显示方法3：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL AT：DB-NAME DECLARE SQL-STMT STATEMENT END-EXEC。 EXEC SQL PREPARE SQL-STMT FROM：SQL-STRING END-EXEC。 SQL-STMT END-EXEC的EXEC SQL DECLARE emp_cursor CURSOR。 EXEC SQL OPEN emp_cursor ...EXEC SQL FETCH emp_cursor INTO ...EXEC SQL CLOSE emp_cursor END-EXEC。</pre><p>除非同时打开两个或多个连接，否则在连接到远程数据库时不需要使用AT子句（在这种情况下，需要使用AT子句来标识活动连接）。要建立与远程数据库的默认连接，请使用以下语法：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL CONNECT：USERNAME IDENTIFIED BY：PASSWORD USING：DB-STRING END-EXEC。</pre></div>
                  </div>
               </div><a id="LNPCB209"></a><div class="props_rev_3"><a id="GUID-056EC81F-F05C-4C33-9393-856EF3FADA89" name="GUID-056EC81F-F05C-4C33-9393-856EF3FADA89"></a><h4 id="LNPCB-GUID-056EC81F-F05C-4C33-9393-856EF3FADA89" class="sect4"><span class="enumeration_section">3.2.3</span>自动登录</h4>
                  <div>
                     <p>您可以使用userid自动登录Oracle：<a id="d10894e628" class="indexterm-anchor"></a><a id="d10894e632" class="indexterm-anchor"></a><a id="d10894e634" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">&lt;前缀&gt; &lt;用户名&gt;</pre><p>其中<span class="italic">prefix</span>是Oracle初始化参数OS_AUTHENT_PREFIX的值（默认值为OPS $）， <span class="italic">username</span>是您的操作系统用户或任务名称。例如，如果前缀为OPS $，您的用户名为TBARNES，而OPS $ TBARNES是有效的Oracle用户ID，则您以用户OPS $ TBARNES身份登录Oracle。</p>
                     <p>要利用自动登录功能，只需将斜杠（/）字符传递给Pro * COBOL，如下所示：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL BEGIN DECLARE SECTION END-EXEC。 01 ORACLEID PIC X. ...EXEC SQL END DECLARE SECTION END-EXEC。 ...移动'/'到ORACLEID。 EXEC SQL CONNECT：ORACLEID END-EXEC。</pre><p>这会自动将您作为用户OPS $ <span class="italic">用户名连接</span> 。例如，如果您的操作系统用户名是RHILL，并且OPS $ RHILL是有效的Oracle用户名，则使用斜杠（/）连接会自动以Oracle OPS $ RHILL用户身份登录Oracle。</p>
                     <p>您还可以将字符串传递给Pro * COBOL。但是，该字符串不能包含尾随空格。例如，以下CONNECT语句将失败：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL BEGIN DECLARE SECTION END-EXEC。 01 ORACLEID PIC X（5）。...EXEC SQL END DECLARE SECTION END-EXEC。 ...移动'/'到ORACLEID。 EXEC SQL CONNECT：ORACLEID END-EXEC。</pre></div><a id="LNPCB210"></a><div class="props_rev_3"><a id="GUID-CF77C4A1-BF68-40AF-AF53-4AF713B64A7D" name="GUID-CF77C4A1-BF68-40AF-AF53-4AF713B64A7D"></a><h5 id="LNPCB-GUID-CF77C4A1-BF68-40AF-AF53-4AF713B64A7D" class="sect5"><span class="enumeration_section">3.2.3.1</span> AUTO_CONNECT预编译器选项</h5>
                     <div>
                        <p>Pro * COBOL允许您的程序在不使用CONNECT语句的情况下登录到默认数据库。只需在命令行中指定预编译器选项AUTO_CONNECT即可。<a id="d10894e685" class="indexterm-anchor"></a><a id="d10894e689" class="indexterm-anchor"></a><a id="d10894e693" class="indexterm-anchor"></a></p>
                        <p>假设OS_AUTHENT_PREFIX的默认值是OPS $，您的用户名是TBARNES，OPS $ TBARNES是有效的Oracle用户ID。当AUTO_CONNECT = YES时，只要Pro * COBOL遇到可执行的SQL语句，您的程序就会使用用户ID OPS $ TBARNES自动登录到Oracle。</p>
                        <p>当AUTO_CONNECT = NO（缺省值）时，必须使用CONNECT语句登录Oracle。</p>
                     </div>
                  </div>
               </div><a id="LNPCB211"></a><div class="props_rev_3"><a id="GUID-E37C4FF2-C93D-41E3-A4C0-7B07AA29BEF3" name="GUID-E37C4FF2-C93D-41E3-A4C0-7B07AA29BEF3"></a><h4 id="LNPCB-GUID-E37C4FF2-C93D-41E3-A4C0-7B07AA29BEF3" class="sect4"><span class="enumeration_section">3.2.4</span>在运行时更改密码</h4>
                  <div>
                     <p>Pro * COBOL为客户端应用程序提供了一种通过可选的ALTER AUTHORIZATION子句在运行时更改用户密码的便捷方法。</p>
                     <p>ALTER AUTHORIZATION子句的语法如下所示：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL CONNECT ..更改授权： <span class="italic">NEWPSWD</span> END-EXEC。</pre><p>使用此子句表示您要将帐户密码更改为NEWPSWD指示的值。更改后，尝试连接为<code class="codeph">USER</code> / <code class="codeph">NEWPSWD</code> 。这可以得到以下结果：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>该应用程序将连接没有问题。</p>
                        </li>
                        <li>
                           <p>应用程序将无法连接。这可能是由于以下任何一种情况：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>密码验证由于某种原因失败。在这种情况下，密码保持不变。</p>
                              </li>
                              <li>
                                 <p>账号被锁了。不允许更改密码。</p>
                              </li>
                           </ul>
                        </li>
                     </ul>
                  </div>
               </div><a id="LNPCB212"></a><div class="props_rev_3"><a id="GUID-4BE68F3D-D3AF-46F8-BC70-B6541B809A96" name="GUID-4BE68F3D-D3AF-46F8-BC70-B6541B809A96"></a><h4 id="LNPCB-GUID-4BE68F3D-D3AF-46F8-BC70-B6541B809A96" class="sect4"><span class="enumeration_section">3.2.5</span>无需更改授权连接</h4>
                  <div>
                     <p>本节描述CONNECT语句的不同变体的可能结果。</p>
                  </div><a id="LNPCB213"></a><div class="props_rev_3"><a id="GUID-61346520-A069-4C41-8BA2-F3140A2C26AC" name="GUID-61346520-A069-4C41-8BA2-F3140A2C26AC"></a><h5 id="LNPCB-GUID-61346520-A069-4C41-8BA2-F3140A2C26AC" class="sect5"><span class="enumeration_section">3.2.5.1</span>标准CONNECT</h5>
                     <div>
                        <p>如果应用程序发出以下声明：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL CONNECT .../ *没有ALTER AUTHORIZATION子句* /</pre><p>它执行正常的连接尝试。可能的结果包括：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>该应用程序将连接没有问题。</p>
                           </li>
                           <li>
                              <p>应用程序将连接，但会收到密码警告。警告表示密码已过期，但处于允许登录的宽限期内。此时，建议用户在帐户锁定之前更改密码。</p>
                           </li>
                           <li>
                              <p>应用程序将无法连接。可能的原因包括：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>密码不正确。</p>
                                 </li>
                                 <li>
                                    <p>该帐户已过期，可能处于锁定状态。</p>
                                 </li>
                              </ul>
                           </li>
                        </ul>
                     </div>
                  </div><a id="LNPCB214"></a><div class="props_rev_3"><a id="GUID-C9E12FED-5BDF-4647-A5DE-EDC4D42CEAA1" name="GUID-C9E12FED-5BDF-4647-A5DE-EDC4D42CEAA1"></a><h5 id="LNPCB-GUID-C9E12FED-5BDF-4647-A5DE-EDC4D42CEAA1" class="sect5"><span class="enumeration_section">3.2.5.2</span> SYSDBA或SYSOPER权限</h5>
                     <div>
                        <p>在Oracle 8.1版之前，您不必使用此子句来获得SYSOPER或SYSDBA系统特权，但现在必须这样做。</p>
                        <p>如果要使用SYSDBA或SYSOPER系统特权登录，请在所有其他子句后将以下可选字符串附加到CONNECT语句：</p><pre class="oac_no_warn" dir="ltr">IN {SYSDBA | SYSOPER}模式</pre><p>例如：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL CONNECT ...在SYSDBA模式END-EXEC。</pre><p>以下是适用于此选项的限制：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>使用AUTO_CONNECT = YES预编译器选项设置时，不支持此选项。</p>
                           </li>
                           <li>
                              <p>在CONNECT语句中使用ALTER AUTHORIZATION关键字时，不允许使用该选项。</p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="LNPCB215"></a><div class="props_rev_3"><a id="GUID-82015694-70C4-49A9-BEBB-1FC6F64D4C51" name="GUID-82015694-70C4-49A9-BEBB-1FC6F64D4C51"></a><h4 id="LNPCB-GUID-82015694-70C4-49A9-BEBB-1FC6F64D4C51" class="sect4"><span class="enumeration_section">3.2.6</span>使用链接</h4>
                  <div>
                     <p>Oracle分布式数据库选项支持数据库链接。例如，分布式查询允许单个SELECT语句访问一个或多个非默认数据库上的数据。<a id="d10894e907" class="indexterm-anchor"></a><a id="d10894e909" class="indexterm-anchor"></a></p>
                     <p>分布式查询工具依赖于数据库链接，该链接为CONNECT语句而不是连接本身分配名称。在运行时，嵌入式SELECT语句由指定的数据库服务器执行，该服务器隐式连接到非默认数据库以获取所需的数据。</p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="../netag/identifying-and-accessing-database.html#NETAG-GUID-2BDF9E52-4147-4F46-84E2-A5AE1018A373" target="_blank">连接到数据库服务</a></li>
                        </ul>
                     </div>
                  </div>
               </div>
            </div><a id="LNPCB216"></a><div class="props_rev_3"><a id="GUID-E1177148-D3CD-4BD8-9410-960476A6617C" name="GUID-E1177148-D3CD-4BD8-9410-960476A6617C"></a><h3 id="LNPCB-GUID-E1177148-D3CD-4BD8-9410-960476A6617C" class="sect3"><span class="enumeration_section">3.3</span>关键术语</h3>
               <div>
                  <p>在深入研究交易主题之前，您应该了解本节中定义的术语。</p>
                  <p>数据库管理的作业或任务称为<span class="italic"><span class="bold">会话</span></span> 。运行应用程序或Oracle Forms等工具并连接到数据库时，将启动<span class="italic"><span class="bold">用户会话</span></span> 。Oracle使用户会话能够同时工作并共享计算机资源。为此，Oracle必须控制<span class="italic"><span class="bold">并发</span></span> ，许多用户访问相同的数据。如果没有足够的并发控制，可能会丢失<span class="italic"><span class="bold">数据完整性</span></span> 。也就是说，数据或结构的更改可能以错误的顺序进行。<a id="d10894e963" class="indexterm-anchor"></a><a id="d10894e965" class="indexterm-anchor"></a><a id="d10894e968" class="indexterm-anchor"></a><a id="d10894e970" class="indexterm-anchor"></a></p>
                  <p>Oracle使用<span class="italic"><span class="bold">锁</span></span>来控制对数据的并发访问。锁可以为您提供数据库资源的临时所有权，例如表或数据行。因此，在您完成数据之前，其他用户无法更改数据。您永远不需要显式锁定资源，因为默认锁定机制可以保护表数据和结构。但是，您可以在表或行上请求<span class="italic"><span class="bold">数据锁定</span></span> ，以便覆盖默认锁定。您可以选择多种锁定<span class="italic"><span class="bold">模式</span></span> ，例如<span class="italic"><span class="bold">行共享</span></span>和<span class="italic"><span class="bold">独占</span></span> 。<a id="d10894e995" class="indexterm-anchor"></a><a id="d10894e997" class="indexterm-anchor"></a><a id="d10894e999" class="indexterm-anchor"></a></p>
                  <p>当两个或多个用户尝试访问同一数据库对象时，可能会发生<span class="italic"><span class="bold">死锁</span></span> 。例如，如果每个用户尝试更新当前由另一个锁定的行，则更新同一个表的两个用户可能会等待。因为每个用户都在等待另一个用户持有的资源，所以在服务器中断死锁之前都不会继续。服务器向完成最少工作量的参与事务发出错误信号，并且“等待资源时检测到死锁”错误代码返回到SQLCA中的SQLCODE。<a id="d10894e1009" class="indexterm-anchor"></a></p>
                  <p>当一个用户查询表并同时由另一个用户更新时，数据库会为查询生成表的数据的<span class="italic"><span class="bold">读一致</span></span>视图。也就是说，一旦查询开始（并继续），查询读取的数据就不会改变。随着更新活动的继续，数据库会获取表数据的<span class="italic"><span class="bold">快照</span></span>并记录<span class="italic"><span class="bold">回滚段中的</span></span>更改。数据库使用回滚段中的信息来构建读取一致的查询结果，并在必要时撤消更改。<a id="d10894e1025" class="indexterm-anchor"></a><a id="d10894e1027" class="indexterm-anchor"></a><a id="d10894e1029" class="indexterm-anchor"></a></p>
               </div>
            </div><a id="LNPCB217"></a><div class="props_rev_3"><a id="GUID-6A1C673E-993A-453B-9390-DEF91EEE3D65" name="GUID-6A1C673E-993A-453B-9390-DEF91EEE3D65"></a><h3 id="LNPCB-GUID-6A1C673E-993A-453B-9390-DEF91EEE3D65" class="sect3"><span class="enumeration_section">3.4</span>事务如何保护数据库</h3>
               <div>
                  <p>数据库是面向事务的;它使用事务来确保数据完整性。事务是您为完成某项任务而定义的一系列一个或多个逻辑相关的SQL语句。数据库将一系列SQL语句视为一个单元，以便语句带来的所有更改同时<span class="italic">提交</span> （永久）或<span class="italic">回滚</span> （撤消）。如果您的应用程序在事务中间失败，则数据库将自动恢复到其以前的（事务前）状态。 <a id="d10894e1061" class="indexterm-anchor"></a><a id="d10894e1063" class="indexterm-anchor"></a><a id="d10894e1067" class="indexterm-anchor"></a> 
                  </p>
                  <p>接下来的部分将向您展示如何定义和控制事务。具体来说，它显示了如何<a id="d10894e1072" class="indexterm-anchor"></a> ：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>开始和结束交易</p>
                     </li>
                     <li>
                        <p>使用COMMIT语句使事务永久化</p>
                     </li>
                     <li>
                        <p>将SAVEPOINT语句与ROLLBACK TO语句一起使用以撤消部分事务</p>
                     </li>
                     <li>
                        <p>使用ROLLBACK语句撤消整个事务</p>
                     </li>
                     <li>
                        <p>指定RELEASE选项以释放资源并注销数据库</p>
                     </li>
                     <li>
                        <p>使用SET TRANSACTION语句设置只读事务</p>
                     </li>
                     <li>
                        <p>使用FOR UPDATE子句或LOCK TABLE语句覆盖默认锁定</p>
                     </li>
                  </ul>
                  <div class="infoboxnotealso" id="GUID-6A1C673E-993A-453B-9390-DEF91EEE3D65__GUID-0A3729FB-B70B-4196-9660-31542BB8E084">
                     <p class="notep1">也可以看看：</p>有关SQL语句的详细信息，请<a href="../sqlrf/index.html" target="_blank"><span class="italic">参见Oracle数据库SQL语言参考</span></a> 。
                  </div>
               </div>
            </div><a id="LNPCB218"></a><div class="props_rev_3"><a id="GUID-B7317C1E-9549-4ACD-884C-35F3628CA825" name="GUID-B7317C1E-9549-4ACD-884C-35F3628CA825"></a><h3 id="LNPCB-GUID-B7317C1E-9549-4ACD-884C-35F3628CA825" class="sect3"><span class="enumeration_section">3.5</span>开始和结束交易</h3>
               <div>
                  <p>您在程序中使用第一个可执行SQL语句（除CONNECT之外）开始事务。当一个事务结束时，下一个可执行SQL语句会自动开始另一个事务。因此，每个可执行语句都是事务的一部分。因为它们无法回滚且无需提交，所以声明性SQL语句不被视为事务的一部分。 <a id="d10894e1129" class="indexterm-anchor"></a><a id="d10894e1133" class="indexterm-anchor"></a><a id="d10894e1137" class="indexterm-anchor"></a> 
                  </p>
                  <p>您可以通过以下方式之一结束交易：<a id="d10894e1144" class="indexterm-anchor"></a></p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>使用或不使用RELEASE选项对COMMIT或ROLLBACK语句进行编码。这<span class="italic">明确</span>地对数据库进行永久或撤消更改。
                        </p>
                     </li>
                     <li>
                        <p>编写在执行之前<span class="italic">和</span>之后发出自动提交的数据定义语句（例如，ALTER，CREATE或GRANT）。这<span class="italic">隐式</span>地对数据库进行了永久性更改。<a id="d10894e1164" class="indexterm-anchor"></a><a id="d10894e1168" class="indexterm-anchor"></a></p>
                     </li>
                  </ul>
                  <p>当系统出现故障或用户会话因软件问题，硬件问题或强制中断而意外停止时，事务也会结束。<a id="d10894e1174" class="indexterm-anchor"></a></p>
                  <p>如果程序在事务中失败，Oracle会检测到错误并回滚事务。如果操作系统出现故障，Oracle会将数据库还原到以前的（事务前）状态。<a id="d10894e1180" class="indexterm-anchor"></a></p>
               </div>
            </div><a id="LNPCB219"></a><div class="props_rev_3"><a id="GUID-F6D78EC6-B50D-45E7-B409-0D3994CF5339" name="GUID-F6D78EC6-B50D-45E7-B409-0D3994CF5339"></a><h3 id="LNPCB-GUID-F6D78EC6-B50D-45E7-B409-0D3994CF5339" class="sect3"><span class="enumeration_section">3.6</span>使用COMMIT语句</h3>
               <div>
                  <p>COMMIT语句用于永久更改数据库。在提交更改之前，其他用户无法访问更改的数据;他们在交易开始之前就看到了它。COMMIT语句对主机变量的值或程序中的控制流没有影响。具体来说，COMMIT语句：<a id="d10894e1209" class="indexterm-anchor"></a><a id="d10894e1211" class="indexterm-anchor"></a><a id="d10894e1215" class="indexterm-anchor"></a></p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>在当前事务期间对数据库进行永久性所有更改。</p>
                     </li>
                     <li>
                        <p>使这些更改对其他用户可见。</p>
                     </li>
                     <li>
                        <p>删除所有保存点（请参阅下一节）。</p>
                     </li>
                     <li>
                        <p>释放所有行和表锁，但不解析锁。</p>
                     </li>
                     <li>
                        <p>关闭使用FOR UPDATE子句声明的游标，或使用CURRENT OF子句在代码中的其他位置引用的游标。如果MODE = ANSI |使用ANSI14或CLOSE_ON_COMMIT = YES，然后关闭所有显式游标。</p>
                     </li>
                     <li>
                        <p>结束交易。</p>
                     </li>
                  </ul>
                  <p>当MODE = {ANSI13 | ORACLE}，CURRENT OF子句中未引用的显式游标在提交期间保持打开状态。这可以提高性能。有关示例，请参阅<span class="q">“ <a href="database-concepts.html#GUID-687E5EBE-714C-49B1-928E-4EB8310B85A8">提交提交内容</a> ”</span> 。
                  </p>
                  <p>因为它们是正常处理的一部分，COMMIT语句应该通过程序的主路径内联放置。在程序终止之前，它必须显式提交挂起的更改。否则，Oracle会回滚它们。在以下示例中，您提交事务并断开连接：<a id="d10894e1247" class="indexterm-anchor"></a><a id="d10894e1251" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">EXEC SQL COMMIT WORK RELEASE END-EXEC。</pre><p>可选关键字WORK提供ANSI兼容性。RELEASE选项释放程序保存的所有资源（锁和游标）并注销数据库。<a id="d10894e1259" class="indexterm-anchor"></a><a id="d10894e1263" class="indexterm-anchor"></a><a id="d10894e1267" class="indexterm-anchor"></a></p>
                  <p>您不需要使用COMMIT语句跟随数据定义语句，因为数据定义语句在执行之前<span class="italic">和</span>之后发出自动提交。因此，无论它们是成功还是失败，都会提交先前的交易。
                  </p>
               </div><a id="LNPCB220"></a><div class="props_rev_3"><a id="GUID-BD470EC3-4070-4B09-ABD8-6BA096D11D06" name="GUID-BD470EC3-4070-4B09-ABD8-6BA096D11D06"></a><h4 id="LNPCB-GUID-BD470EC3-4070-4B09-ABD8-6BA096D11D06" class="sect4"><span class="enumeration_section">3.6.1</span> DECLARE CURSOR语句中的WITH HOLD子句</h4>
                  <div>
                     <p>在COMMIT之后单词CURSOR之后保持打开的任何已使用WITH HOLD子句声明的游标。以下示例显示如何使用此子句：</p><pre class="oac_no_warn" dir="ltr">执行SQL DECLARE C1游标保持从EMP到7600和7700 END-EXEC之间的EMPNO中选择ENAME。</pre><p>不能为UPDATE声明游标。 DB2中使用WITH HOLD子句来覆盖默认值，即在提交时关闭所有游标。Pro * COBOL提供此子句是为了便于将应用程序从DB2迁移到Oracle。当MODE = ANSI时，Oracle使用DB2默认值，但必须在Declare Section中声明所有主机变量。要避免使用Declare Section，请使用<span class="italic">下面</span>描述的预编译器选项<span class="italic">CLOSE_ON_COMMIT</span> 。
                     </p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="embedded-SQL-statements-and-precompiler-directives.html#GUID-2D17E92E-5215-4BF2-9196-A5B1170C5C81">DECLARE CURSOR（嵌入式SQL指令）</a></li>
                        </ul>
                     </div>
                  </div>
               </div><a id="LNPCB221"></a><div class="props_rev_3"><a id="GUID-C7180D4D-9A0D-4E58-B16D-1E2EC4749A2A" name="GUID-C7180D4D-9A0D-4E58-B16D-1E2EC4749A2A"></a><h4 id="LNPCB-GUID-C7180D4D-9A0D-4E58-B16D-1E2EC4749A2A" class="sect4"><span class="enumeration_section">3.6.2</span> CLOSE_ON_COMMIT预编译器选项</h4>
                  <div>
                     <p>预编译器选项CLOSE_ON_COMMIT <span class="italic"> </span>可用于覆盖MODE = ANSI的默认行为（如果在命令行上指定MODE = ANSI，则在提交时未使用WITH HOLD子句声明的任何游标都将关闭）：</p><pre class="oac_no_warn" dir="ltr">CLOSE_ON_COMMIT = {是|没有}</pre><p>默认值为NO。必须仅在命令行或配置文件中输入此选项。</p>
                     <div class="infoboxnote" id="GUID-C7180D4D-9A0D-4E58-B16D-1E2EC4749A2A__GUID-1FAA8AAC-AF1F-4C59-AC48-6D9B9D759165">
                        <p class="notep1">注意：</p>
                        <p>仔细使用此选项;如果由于需要为每个OPEN语句重新解析而多次打开和关闭游标，则应用程序可能会变慢。请参见<span class="q">“ <a href="precompiler-options.html#GUID-839B1E64-B28C-41BF-9355-783B003C0D81">CLOSE_ON_COMMIT</a> ”</span> 。
                        </p>
                     </div>
                  </div>
               </div>
            </div><a id="LNPCB222"></a><div class="props_rev_3"><a id="GUID-C323E4D2-9CEE-46B6-8C08-50B71EA5505D" name="GUID-C323E4D2-9CEE-46B6-8C08-50B71EA5505D"></a><h3 id="LNPCB-GUID-C323E4D2-9CEE-46B6-8C08-50B71EA5505D" class="sect3"><span class="enumeration_section">3.7</span>使用ROLLBACK语句</h3>
               <div>
                  <p>您可以使用ROLLBACK语句撤消对数据库所做的挂起更改。例如，如果您犯了错误，例如从表中删除了错误的行，则可以使用ROLLBACK来恢复原始数据。ROLLBACK语句对主机变量的值或程序中的控制流没有影响。具体来说，就是ROLLBACK语句<a id="d10894e1379" class="indexterm-anchor"></a><a id="d10894e1381" class="indexterm-anchor"></a><a id="d10894e1385" class="indexterm-anchor"></a><a id="d10894e1387" class="indexterm-anchor"></a><a id="d10894e1391" class="indexterm-anchor"></a></p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>撤消当前事务期间对数据库所做的所有更改</p>
                     </li>
                     <li>
                        <p>删除所有保存点</p>
                     </li>
                     <li>
                        <p>结束交易</p>
                     </li>
                     <li>
                        <p>释放所有行和表锁，但不解析锁</p>
                     </li>
                     <li>
                        <p>关闭使用FOR UPDATE子句声明的游标，或使用CURRENT OF子句在代码中的其他位置引用的游标。如果MODE = {ANSI | ANSI14}，然后关闭<span class="italic">所有</span>显式游标。
                        </p>
                     </li>
                  </ul>
                  <p>当MODE = {ANSI13 | ORACLE}，CURRENT OF子句中未引用的显式游标在回滚期间保持打开状态。</p>
                  <p>因为它们是异常处理的一部分，所以ROLLBACK语句应该放在错误处理例程中，离开程序的主路径。在以下示例中，您回滚事务并断开连接：<a id="d10894e1418" class="indexterm-anchor"></a><a id="d10894e1422" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">EXEC SQL ROLLBACK工作发布END-EXEC。</pre><p>可选关键字WORK提供ANSI兼容性。RELEASE选项释放程序保存的所有资源并注销数据库。<a id="d10894e1430" class="indexterm-anchor"></a><a id="d10894e1434" class="indexterm-anchor"></a></p>
                  <p>如果WHENEVER SQLERROR GOTO语句分支到包含ROLLBACK语句的错误处理例程，则如果回滚失败并且出现错误，则程序可能会进入无限循环。您可以通过在ROLLBACK语句之前编写WHENEVER SQLERROR CONTINUE来避免这种情况。</p>
                  <p>例如，请考虑以下事项：<a id="d10894e1442" class="indexterm-anchor"></a><a id="d10894e1446" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">执行SQL WHENEVER SQLERROR GOTO SQL-ERROR END-EXEC。 ...显示'员工编号？”。接受EMP-NUMBER。显示'员工姓名？”。接受EMP-NAME。 EXEC SQL INSERT INTO EMP（EMPNO，ENAME）值（：EMP-NUMBER，：EMP-NAME）END-EXEC。 ...SQL-ERROR。执行SQL WHENEVER SQLERROR CONTINUE END-EXEC。显示'处理错误'。显示'错误代码：'，SQLCODE。显示'消息：'，SQLERRMC。 EXEC SQL ROLLBACK工作发布END-EXEC。停止运行。</pre><p>如果程序异常终止，Oracle会回滚事务。<a id="d10894e1454" class="indexterm-anchor"></a><a id="d10894e1458" class="indexterm-anchor"></a></p>
               </div><a id="LNPCB223"></a><div class="props_rev_3"><a id="GUID-47069C13-2E08-48D0-A139-939BB719055F" name="GUID-47069C13-2E08-48D0-A139-939BB719055F"></a><h4 id="LNPCB-GUID-47069C13-2E08-48D0-A139-939BB719055F" class="sect4"><span class="enumeration_section">3.7.1</span>语句级回滚</h4>
                  <div>
                     <p>在执行任何SQL语句之前，Oracle会标记一个隐式保存点（不适用于您）。然后，如果语句失败，Oracle会自动回滚它并将适用的错误代码返回到SQLCA中的SQLCODE。例如，如果INSERT语句通过尝试在唯一索引中插入重复值而导致错误，则回滚该语句。<a id="d10894e1486" class="indexterm-anchor"></a><a id="d10894e1488" class="indexterm-anchor"></a></p>
                     <p>只有失败的SQL语句启动的工作才会丢失;保留当前事务中该语句之前完成的工作。因此，如果数据定义语句失败，则不会撤消其前面的自动提交。</p>
                     <div class="infoboxnote" id="GUID-47069C13-2E08-48D0-A139-939BB719055F__GUID-D11340DC-C168-49C3-B1B6-8681D78F0000">
                        <p class="notep1">注意：</p>
                        <p>在执行SQL语句之前，Oracle必须对其进行解析，即检查它以确保它遵循语法规则并引用有效的数据库对象。执行SQL语句时检测到的错误会导致回滚，但在解析语句时检测到的错误则不会。</p>
                     </div>
                     <p>Oracle还可以回滚单个SQL语句以打破死锁。Oracle向其中一个参与事务发出错误信号并回滚该事务中的当前语句。<a id="d10894e1499" class="indexterm-anchor"></a><a id="d10894e1503" class="indexterm-anchor"></a><a id="d10894e1507" class="indexterm-anchor"></a></p>
                  </div>
               </div>
            </div><a id="LNPCB224"></a><div class="props_rev_3"><a id="GUID-59EEDD58-7CD0-4842-9545-6B2C52D6488B" name="GUID-59EEDD58-7CD0-4842-9545-6B2C52D6488B"></a><h3 id="LNPCB-GUID-59EEDD58-7CD0-4842-9545-6B2C52D6488B" class="sect3"><span class="enumeration_section">3.8</span>使用SAVEPOINT语句</h3>
               <div>
                  <p>SAVEPOINT嵌入式SQL语句标记并命名处理事务的当前点。每个标记点称为<span class="italic">保存点</span> 。例如，以下语句标记名为<span class="italic">start_delete</span>的保存点：<a id="d10894e1547" class="indexterm-anchor"></a><a id="d10894e1549" class="indexterm-anchor"></a><a id="d10894e1551" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">EXEC SQL SAVEPOINT start_delete END-EXEC。</pre><p>保存点允许您划分长事务，使您可以更好地控制复杂的过程。例如，如果事务执行多个功能，则可以在每个功能之前标记保存点。然后，如果函数失败，您可以轻松地将数据恢复到以前的状态，恢复，然后重新执行该函数。<a id="d10894e1559" class="indexterm-anchor"></a></p>
                  <p>要撤消部分事务，可以将保存点与ROLLBACK语句及其TO SAVEPOINT子句一起使用。TO SAVEPOINT子句允许您回滚到当前事务中的中间语句。有了它，您不必撤消所有更改。具体来说，ROLLBACK TO SAVEPOINT语句：<a id="d10894e1565" class="indexterm-anchor"></a><a id="d10894e1569" class="indexterm-anchor"></a></p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>取消自指定的保存点被标记以来对数据库所做的更改</p>
                     </li>
                     <li>
                        <p>删除指定保存点后标记的所有保存点</p>
                     </li>
                     <li>
                        <p>释放自标记指定保存点以来获取的所有行和表锁</p>
                     </li>
                  </ul>
                  <p>在以下示例中，您访问表MAIL_LIST以插入新列表，更新旧列表以及删除（一些）非活动列表。删除后，检查SQLCA中的SQLERRD（3）以获取已删除的行数。如果数字意外大，则回滚到保存点<span class="italic">start_delete</span> ，仅撤消删除。<a id="d10894e1586" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">*  - 对于每个新客户DISPLAY'新客户编号？”。接受CUST-NUMBER。如果CUST-NUMBER = 0转到REV-STATUS END-IF。显示'新客户名称？”。接受CUST-NAME。 EXEC SQL INSERT IN MAIL-LIST（CUSTNO，CNAME，STAT）VALUES（：CUST-NUMBER，：CUST-NAME，'ACTIVE'）。END-EXEC。 ...*  - 对于每个修订状态REV-STATUS。显示'修改状态的客户编号？”。接受CUST-NUMBER。如果CUST-NUMBER = 0则转到SAVE-POINT END-IF。显示'新状态？”。接受新状态。 EXEC SQL UPDATE MAIL-LIST SET STAT =：NEW-STATUS CERENO =：CUST-NUMBER END-EXEC。 ...*  - 标记保存点SAVE-POINT。 EXEC SQL SAVEPOINT START-DELETE END-EXEC。来自MAIL-LIST的EXEC SQL DELETE STAT ='INACTIVE'END-EXEC。如果SQLERRD（3）&lt;25 *  - 检查删除的行数DISPLAY'删除的行数是'，SQLERRD（3）ELSE DISPLAY'撤消删除'，SQLERRD（3），'rows'EXEC SQL WHENEVER SQLERROR GOTO SQL -ERROR END-EXEC EXEC SQL ROLLBACK到SAVEPOINT START-DELETE END-EXEC END-IF。执行SQL WHENEVER SQLERROR CONTINUE END-EXEC。 EXEC SQL COMMIT WORK RELEASE END-EXEC。停止运行。 *  - 退出计划。...SQL-ERROR。执行SQL WHENEVER SQLERROR CONTINUE END-EXEC。 EXEC SQL ROLLBACK工作发布END-EXEC。显示'处理错误'。*  - 退出程序并显示错误。停止运行。</pre><p>请注意，您无法在ROLLBACK TO SAVEPOINT语句中指定RELEASE选项。<a id="d10894e1594" class="indexterm-anchor"></a><a id="d10894e1598" class="indexterm-anchor"></a><a id="d10894e1602" class="indexterm-anchor"></a><a id="d10894e1606" class="indexterm-anchor"></a></p>
                  <p>回滚到保存点会删除在该保存点之后标记的所有保存点。但是，您回滚的保存点不会被删除。例如，如果标记五个保存点，则回滚到第三个保存点，仅删除第四个和第五个保存点。COMMIT或ROLLBACK语句将擦除所有保存点。<a id="d10894e1612" class="indexterm-anchor"></a></p>
               </div>
            </div><a id="LNPCB225"></a><div class="props_rev_3"><a id="GUID-4B174FCB-ADD2-46EC-B0D0-6C64BE0DC1D4" name="GUID-4B174FCB-ADD2-46EC-B0D0-6C64BE0DC1D4"></a><h3 id="LNPCB-GUID-4B174FCB-ADD2-46EC-B0D0-6C64BE0DC1D4" class="sect3"><span class="enumeration_section">3.9</span>使用RELEASE选项</h3>
               <div>
                  <p>如果程序异常终止，Oracle会自动回滚更改。当您的程序没有使用RELEASE嵌入式SQL语句显式提交或回滚工作并断开连接时，会发生异常终止。</p>
                  <p>当程序运行其程序，关闭打开的游标，显式提交或回滚工作，断开连接并将控制权返回给用户时，将发生正常终止。如果它执行的最后一个SQL语句是，您的程序将正常退出<a id="d10894e1643" class="indexterm-anchor"></a><a id="d10894e1645" class="indexterm-anchor"></a> 
                  </p><pre class="oac_no_warn" dir="ltr">EXEC SQL COMMIT WORK RELEASE END-EXEC。</pre><p>要么</p><pre class="oac_no_warn" dir="ltr">EXEC SQL ROLLBACK工作发布END-EXEC。</pre><p>令牌WORK是可选的。否则，用户会话获取的锁和游标将在程序终止后保留，直到Oracle识别出用户会话不再处于活动状态。这可能导致多用户环境中的其他用户等待锁定资源所需的时间。 <a id="d10894e1656" class="indexterm-anchor"></a> 
                  </p>
               </div>
            </div><a id="LNPCB226"></a><div class="props_rev_3"><a id="GUID-7CCD2A18-D062-4F41-AABF-D58A763E6627" name="GUID-7CCD2A18-D062-4F41-AABF-D58A763E6627"></a><h3 id="LNPCB-GUID-7CCD2A18-D062-4F41-AABF-D58A763E6627" class="sect3"><span class="enumeration_section">3.10</span>使用SET TRANSACTION语句</h3>
               <div>
                  <p>您可以使用SET TRANSACTION语句开始只读或读/写事务，或将当前事务分配给指定的回滚段。COMMIT，ROLLBACK或数据定义语句结束只读事务。</p>
                  <p>因为它们允许“可重复读取”，所以只读事务对于针对一个或多个表运行多个查询以及其他用户更新相同表时非常有用。在只读事务期间，所有查询都引用数据库的相同快照，从而提供多表，多查询，读取一致的视图。其他用户可以像往常一样继续查询或更新数据。SET TRANSACTION语句的示例如下： <a id="d10894e1687" class="indexterm-anchor"></a><a id="d10894e1691" class="indexterm-anchor"></a><a id="d10894e1695" class="indexterm-anchor"></a><a id="d10894e1697" class="indexterm-anchor"></a>  
                  </p><pre class="oac_no_warn" dir="ltr">EXEC SQL SET TRANSACTION READ ONLY END-EXEC。</pre><p>SET TRANSACTION语句必须是只读事务中的第一个SQL语句，并且只能在事务中出现一次。READ ONLY参数是必需的。它的使用不会影响其他交易。只读事务中只允许SELECT（不带FOR UPDATE），LOCK TABLE，SET ROLE，ALTER SESSION，ALTER SYSTEM，COMMIT和ROLLBACK语句。 <a id="d10894e1706" class="indexterm-anchor"></a><a id="d10894e1710" class="indexterm-anchor"></a><a id="d10894e1714" class="indexterm-anchor"></a><a id="d10894e1718" class="indexterm-anchor"></a><a id="d10894e1722" class="indexterm-anchor"></a> 
                  </p>
                  <p>在以下示例中，商店经理通过使用只读事务生成摘要报告来检查当天，过去一周和过去一个月的销售活动。在事务期间，该报告不受更新数据库的其他用户的影响。 <a id="d10894e1729" class="indexterm-anchor"></a> 
                  </p><pre class="oac_no_warn" dir="ltr">EXEC SQL SET TRANSACTION READ ONLY END-EXEC。 EXEC SQL SELECT SUM（SALEAMT）INTO：SALEDATE = SYSDATE END-EXEC的销售额。 EXEC SQL SELECT SUM（SALEAMT）INTO：每次销售SALEDATE&gt; SYSDATE  -  7 END-EXEC。执行SQL SELECT SUM（SALEAMT）INTO：SALEDATE&gt; SYSDATE  -  30 END-EXEC的销售额。 EXEC SQL COMMIT WORK END-EXEC。 *  - 简单地结束交易，因为没有变化*  - 制作永久*格式和打印报告</pre></div>
            </div><a id="LNPCB227"></a><div class="props_rev_3"><a id="GUID-78E84CE3-AFAA-4279-B3BE-48800AD6ADAC" name="GUID-78E84CE3-AFAA-4279-B3BE-48800AD6ADAC"></a><h3 id="LNPCB-GUID-78E84CE3-AFAA-4279-B3BE-48800AD6ADAC" class="sect3"><span class="enumeration_section">3.11</span>覆盖默认锁定</h3>
               <div>
                  <p>默认情况下，Oracle会隐式（自动）为您锁定许多数据结构。但是，您可以在行或表上请求特定数据锁定，以便覆盖默认锁定。显式锁定允许您在事务期间共享或拒绝对表的访问，或确保多表和多查询读一致性。<a id="d10894e1760" class="indexterm-anchor"></a><a id="d10894e1764" class="indexterm-anchor"></a><a id="d10894e1768" class="indexterm-anchor"></a></p>
                  <p>使用SELECT FOR UPDATE OF语句，您可以显式锁定表的特定行，以确保在执行更新或删除之前它们不会更改。但是，Oracle会在更新或删除时自动获取行级锁。因此，仅当您要在更新或删除<span class="italic">之前</span>锁定行时， <span class="italic">才</span>使用FOR UPDATE OF子句。<a id="d10894e1775" class="indexterm-anchor"></a></p>
                  <p>您可以使用LOCK TABLE语句显式锁定整个表。</p>
               </div><a id="LNPCB228"></a><div class="props_rev_3"><a id="GUID-348B3204-A6B1-4E1B-AB40-C4796F808F21" name="GUID-348B3204-A6B1-4E1B-AB40-C4796F808F21"></a><h4 id="LNPCB-GUID-348B3204-A6B1-4E1B-AB40-C4796F808F21" class="sect4"><span class="enumeration_section">3.11.1</span>使用FOR更新条款</h4>
                  <div>
                     <p>当你DECLARE一个游标时，你可以同时指定FOR UPDATE子句，它具有获取游标定义的所有行的独占锁定的效果。例如，当您希望将更新基于表中的现有行并希望确保它们不会被其他任何人同时更改时，这很有用。</p>
                     <p>请注意，如果您使用CURRENT OF子句引用游标，则预编译器将自动将FOR UPDATE子句添加到游标定义，并且单词OF是可选的。 <a id="d10894e1807" class="indexterm-anchor"></a><a id="d10894e1811" class="indexterm-anchor"></a> 例如，而不是：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL DECLARE emp_cursor CURSOR for SELECT ENAME，JOB，SAL from EMP WHERE DEPTNO = 20 FOR SALDATE SAL END-EXEC。</pre><p>你可以删除该条款的OF部分，只需编写代码：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL DECLARE emp_cursor CURSOR for SELECT ENAME，JOB，SAL from EMP WHERE DEPTNO = 20 FOR UPDATE END-EXEC。</pre><div class="infoboxnotealso" id="GUID-348B3204-A6B1-4E1B-AB40-C4796F808F21__GUID-5DFA3243-112E-4E79-A575-E210BC80640E">
                        <p class="notep1">也可以看看：</p><span class="q">“ <a href="embedded-SQL.html#GUID-E0B72EA2-521D-4604-BD41-0B2B1BC59381">使用CURRENT OF子句</a> ”</span>作为示例。
                     </div>
                  </div><a id="LNPCB229"></a><div class="props_rev_3"><a id="GUID-6F5B308D-5700-4FE5-B7B3-92A7F1EDB1B2" name="GUID-6F5B308D-5700-4FE5-B7B3-92A7F1EDB1B2"></a><h5 id="LNPCB-GUID-6F5B308D-5700-4FE5-B7B3-92A7F1EDB1B2" class="sect5"><span class="enumeration_section">3.11.1.1</span>限制</h5>
                     <div>
                        <p>您不能对多个表使用FOR UPDATE，但必须使用FOR UPDATE OF来标识表中要锁定的列。FOR UPDATE语句获取的行锁由COMMIT清除，这解释了为什么光标关闭。如果在提交后尝试从FOR UPDATE游标获取，Oracle会生成一个Fetch out of Sequence错误。<a id="d10894e1850" class="indexterm-anchor"></a><a id="d10894e1854" class="indexterm-anchor"></a></p>
                     </div>
                  </div>
               </div>
            </div><a id="LNPCB230"></a><div class="props_rev_3"><a id="GUID-687E5EBE-714C-49B1-928E-4EB8310B85A8" name="GUID-687E5EBE-714C-49B1-928E-4EB8310B85A8"></a><h3 id="LNPCB-GUID-687E5EBE-714C-49B1-928E-4EB8310B85A8" class="sect3"><span class="enumeration_section">3.12</span>在提交者中获取</h3>
               <div>
                  <p>如果要混合提交和提取，请不要使用CURRENT OF子句。而是，选择每行的ROWID，然后使用该值在更新或删除期间标识当前行。请考虑以下示例：<a id="d10894e1883" class="indexterm-anchor"></a><a id="d10894e1887" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">EXEC SQL DECLARE emp_cursor CURSOR FOR SELECT ENAME，SAL，ROWID from EMP WHERE JOB ='CLERK'END-EXEC。 ...EXEC SQL OPEN emp_cursor END-EXEC。 EXEC SQL WHENEVER未找到GOTO ......PERFORM EXEC SQL FETCH emp_cursor INTO：EMP_NAME，：SALARY，：ROW-ID END-EXEC ...EXEC SQL UPDATE EMP SET SAL =：NEW-SALARY WHERE ROWID =：ROW-ID END-EXEC EXEC SQL COMMIT END-EXEC END-PERFORM。</pre><p>但请注意，获取的行<span class="italic">未</span>锁定。因此，如果另一个用户在您读取之后但在更新或删除之前修改了行，则可能会收到不一致的结果。
                  </p>
               </div><a id="LNPCB231"></a><div class="props_rev_3"><a id="GUID-D7F99FE8-D739-4E12-B17C-A7A7F21032F0" name="GUID-D7F99FE8-D739-4E12-B17C-A7A7F21032F0"></a><h4 id="LNPCB-GUID-D7F99FE8-D739-4E12-B17C-A7A7F21032F0" class="sect4"><span class="enumeration_section">3.12.1</span>使用LOCK TABLE语句</h4>
                  <div>
                     <p>使用LOCK TABLE语句以指定的锁定模式锁定一个或多个表。例如，以下语句以<span class="italic">行共享</span>模式锁定EMP表。行共享锁允许并发访问表。它们阻止其他用户锁定整个表以供独占使用。<a id="d10894e1925" class="indexterm-anchor"></a><a id="d10894e1929" class="indexterm-anchor"></a><a id="d10894e1933" class="indexterm-anchor"></a><a id="d10894e1935" class="indexterm-anchor"></a><a id="d10894e1939" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">EXEC SQL LOCK表EMP在行分享模式NOWAIT END-EXEC。</pre><p>锁定模式确定可以在表格上放置哪些其他锁定。例如，许多用户可以同时获取表上的行共享锁，但一次只能有一个用户获得<span class="italic">独占</span>锁。当一个用户对表具有独占锁时，其他用户不能插入，更新或删除该表中的行。
                     </p>
                     <p>可选的关键字NOWAIT告诉Oracle如果某个表已被其他用户锁定，则不要等待该表。控制立即返回到您的程序，以便它可以在再次尝试获取锁之前执行其他工作。（您可以在SQLCA中检查SQLCODE以查看表锁是否失败。）如果省略NOWAIT，Oracle会等到表可用为止;等待没有设定限制。<a id="d10894e1952" class="indexterm-anchor"></a><a id="d10894e1956" class="indexterm-anchor"></a><a id="d10894e1960" class="indexterm-anchor"></a></p>
                     <p>表锁永远不会阻止其他用户查询表，并且查询永远不会获取表锁。因此，查询永远不会阻止另一个查询或更新，并且更新永远不会阻止查询。仅当两个不同的事务尝试更新同一行时，一个事务才会等待另一个事务完成。当事务发出COMMIT或ROLLBACK时，将释放表锁。<a id="d10894e1964" class="indexterm-anchor"></a></p>
                     <div class="infoboxnotealso" id="GUID-D7F99FE8-D739-4E12-B17C-A7A7F21032F0__GUID-22418AB6-5109-4545-B365-5EE970E7E725">
                        <p class="notep1">也可以看看：</p>有关锁定模式的更多信息，请<a href="../adfns/sql-processing-for-application-developers.html#ADFNS-GUID-57365E45-5F85-471B-81D9-F52EA16F1E85" target="_blank">使用Oracle Lock Management Services</a> 。
                     </div>
                  </div>
               </div>
            </div><a id="LNPCB232"></a><div class="props_rev_3"><a id="GUID-123F9392-C594-46DB-A2BB-92A92953C08A" name="GUID-123F9392-C594-46DB-A2BB-92A92953C08A"></a><h3 id="LNPCB-GUID-123F9392-C594-46DB-A2BB-92A92953C08A" class="sect3"><span class="enumeration_section">3.13</span>处理分布式事务</h3>
               <div>
                  <p><span class="italic">分布式数据库</span>是包括不同节点处的多个物理数据库的单个逻辑数据库。<span class="italic">分布式语句</span>是使用数据库链接访问远程节点的任何SQL语句。<span class="italic">分布式事务</span>包括至少一个分布式语句，其更新分布式数据库的多个节点处的数据。如果更新仅影响一个节点，则事务是非分布式的。
                  </p>
                  <p>发出提交时，对受分布式事务影响的每个数据库的更改将永久保留。如果您发出回滚，则撤消所有更改。但是，如果网络或计算机在提交或回滚期间出现故障，则分布式事务的状态可能未知或<span class="italic">存在疑问</span> 。在这种情况下，如果您具有FORCE TRANSACTION系统特权，则可以使用FORCE子句在本地数据库中手动提交或回滚事务。必须通过包含事务ID的带引号的文字来标识事务，该事务ID可以在数据字典视图DBA_2PC_PENDING中找到。一些例子如下：<a id="d10894e2011" class="indexterm-anchor"></a><a id="d10894e2013" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">EXEC SQL COMMIT FORCE '22 .31.83'END-EXEC。 ...EXEC SQL ROLLBACK FORCE '25 .33.86'END-EXEC。</pre><p>FORCE仅提交或回滚指定的事务，不会影响您当前的事务。请注意，您无法手动将不确定事务回滚到保存点。</p>
                  <p>COMMIT语句中的COMMENT子句允许您指定要与分布式事务关联的注释。如果事务有疑问，则服务器将COMMENT指定的文本与事务ID一起存储在数据字典视图DBA_2PC_PENDING中。文本必须是长度不超过50个字符的带引号的文字。一个例子如下：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL COMMIT COMMENT'怀疑trans;通知订单输入'END-EXEC。</pre><div class="infoboxnotealso" id="GUID-123F9392-C594-46DB-A2BB-92A92953C08A__GUID-F56F1844-B750-4D2F-9764-82354401F4DA">
                     <p class="notep1">也可以看看：</p><a href="../cncpt/transactions.html#CNCPT1125" target="_blank"><span class="italic">Oracle数据库概念。</span></a>有关分布式事务的更多信息。
                  </div>
               </div>
            </div><a id="LNPCB233"></a><div class="props_rev_3"><a id="GUID-5BE08E32-E12A-48B0-AEBE-DAF750831D12" name="GUID-5BE08E32-E12A-48B0-AEBE-DAF750831D12"></a><h3 id="LNPCB-GUID-5BE08E32-E12A-48B0-AEBE-DAF750831D12" class="sect3"><span class="enumeration_section">3.14</span>交易处理指南</h3>
               <div>
                  <p>以下指南将帮助您避免一些常见问题。</p>
               </div><a id="LNPCB234"></a><div class="props_rev_3"><a id="GUID-10A6DE52-588F-4637-8824-B2D1FF9C13B1" name="GUID-10A6DE52-588F-4637-8824-B2D1FF9C13B1"></a><h4 id="LNPCB-GUID-10A6DE52-588F-4637-8824-B2D1FF9C13B1" class="sect4"><span class="enumeration_section">3.14.1</span>设计应用程序</h4>
                  <div>
                     <p>在设计应用程序时，在一个事务中将逻辑相关的操作组合在一起。精心设计的交易包括完成特定任务所需的所有步骤 - 不多也不少。</p>
                     <p>您引用的表中的数据必须保持一致状态。因此，事务中的SQL语句应以一致的方式更改数据。例如，两个银行账户之间的资金转移应包括一个账户的借方和另一个账户的贷方。两个更新应该成功还是一起失败。不相关的更新（例如新存款到一个帐户）不应包含在交易中。<a id="d10894e2081" class="indexterm-anchor"></a><a id="d10894e2085" class="indexterm-anchor"></a></p>
                  </div>
               </div><a id="LNPCB235"></a><div class="props_rev_3"><a id="GUID-A064F2FA-D4DE-47AD-B309-DA03AD245E1E" name="GUID-A064F2FA-D4DE-47AD-B309-DA03AD245E1E"></a><h4 id="LNPCB-GUID-A064F2FA-D4DE-47AD-B309-DA03AD245E1E" class="sect4"><span class="enumeration_section">3.14.2</span>获取锁</h4>
                  <div>
                     <p>如果您的应用程序包含SQL锁定语句，请确保请求锁定的用户具有获取锁定所需的权限。您的DBA可以锁定任何表。其他用户可以锁定他们拥有的表或他们有权使用的表，例如ALTER，SELECT，INSERT，UPDATE或DELETE。<a id="d10894e2113" class="indexterm-anchor"></a></p>
                  </div>
               </div><a id="LNPCB236"></a><div class="props_rev_3"><a id="GUID-6AAA3E37-EF1C-47CA-872D-752CB8EF371B" name="GUID-6AAA3E37-EF1C-47CA-872D-752CB8EF371B"></a><h4 id="LNPCB-GUID-6AAA3E37-EF1C-47CA-872D-752CB8EF371B" class="sect4"><span class="enumeration_section">3.14.3</span>使用PL / SQL</h4>
                  <div>
                     <p>如果PL / SQL块是事务的一部分，则块内的提交和回滚操作会影响整个事务。在以下示例中，回滚操作将撤消更新<span class="italic">和</span>插入所做的更改：<a id="d10894e2145" class="indexterm-anchor"></a><a id="d10894e2149" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">EXEC SQL INSERT INTO EMP ...EXEC SQL EXECUTE BEGIN UPDATE emp ......DUP_VAL_ON_INDEX然后ROLLBACK的例外情况;结束; END-EXEC。 ...</pre></div>
               </div><a id="LNPCB237"></a><div class="props_rev_3"><a id="GUID-10D56616-11FD-449A-8344-D4B20E8843E4" name="GUID-10D56616-11FD-449A-8344-D4B20E8843E4"></a><h4 id="LNPCB-GUID-10D56616-11FD-449A-8344-D4B20E8843E4" class="sect4"><span class="enumeration_section">3.14.4</span> X / Open应用程序</h4>
                  <div>
                     <p>有关在X / Open应用程序中使用XA接口的说明，请参阅<a href="../adfns/xa.html#ADFNS-GUID-19B8285C-F8CA-4857-89E3-477C6BD1483C" target="_blank">X / Open分布式事务处理（DTP）</a> 。
                     </p><pre class="oac_no_warn" dir="ltr"></pre></div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>