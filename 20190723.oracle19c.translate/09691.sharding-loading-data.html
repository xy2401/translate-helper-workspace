<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <meta name="abstract" content="You can migrate data from a non-sharded database to an Oracle Sharding sharded database using the methods described here."></meta>
      <meta name="description" content="You can migrate data from a non-sharded database to an Oracle Sharding sharded database using the methods described here."></meta>
      <title>将数据迁移到Sharded数据库</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Using Oracle Sharding"></meta>
      <meta property="og:description" content="You can migrate data from a non-sharded database to an Oracle Sharding sharded database using the methods described here."></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Using Oracle Sharding"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="using-oracle-sharding.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-02-14T12:19:13-08:00"></meta>
      <meta name="dcterms.title" content="Using Oracle Sharding"></meta>
      <meta name="dcterms.dateCopyrighted" content="2018, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E87088-04"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="sharding-deployment.html" title="Previous" type="text/html"></link>
      <link rel="next" href="sharding-lifecycle-management.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.isVersionOf" content="SHARD"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="sharding-deployment.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="sharding-lifecycle-management.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">使用Oracle Sharding</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">将数据迁移到Sharded数据库</li>
            </ol>
            <a id="GUID-6140925F-6192-4C6F-9ADC-BC2332ADA3B0" name="GUID-6140925F-6192-4C6F-9ADC-BC2332ADA3B0"></a>
            
            <h2 id="SHARD-GUID-6140925F-6192-4C6F-9ADC-BC2332ADA3B0" class="sect2"><span class="enumeration_chapter">9将</span>数据迁移到分片数据库</h2>
         </header>
         <div class="ind">
            <div>
               <p>您可以使用此处描述的方法将数据从非分片数据库迁移到Oracle Sharding分片数据库。</p>
               <p>这些数据加载方法假定您在要迁移到分片数据库时使用非分片Oracle数据库。提出的这些方法也适用于从其他数据库系统以及第一次数据库用户迁移数据。</p>
            </div>
            <div>
               <ul class="ullinks">
                  <li class="ulchildlink"><a href="sharding-loading-data.html#GUID-041069C8-FA7B-4BA5-BFB8-B5A949DA12A9">关于将数据迁移到分片数据库</a><br>在Oracle Sharding软件安装以及分片数据库配置和创建之后，您可以将数据迁移到分片数据库。
                  </li>
                  <li class="ulchildlink"><a href="sharding-loading-data.html#GUID-6E455646-F4AA-4992-B50B-58A1290355FE">将数据加载到分片数据库的一般准则</a><br>从非分片数据库转换为分片数据库涉及将数据从非分片表移动到分片和重复表。将数据从非分片表移动到重复表不会带来任何复杂性，但是将数据从非分片表移动到分片表需要特别注意。
                  </li>
                  <li class="ulchildlink"><a href="sharding-loading-data.html#GUID-DD36B05A-AC5F-488D-9012-70043ED3E7EE">迁移架构</a><br>在将现有数据库迁移到分片数据库之前，必须确定如何组织分片数据库，包括分片数和复制策略，并且必须确定应用程序中哪些表是分片的，哪些表是重复的表。对于分片表，您必须确定分片方法以及表族中分片表之间的父子关系。
                  </li>
                  <li class="ulchildlink"><a href="sharding-loading-data.html#GUID-18D1592D-3A41-4C81-ABEF-86527A610A3D">准备源数据库</a><br>要使转换为分片数据库模式更顺畅，可以修改源非分片数据库，使其与目标分片数据库中的表定义匹配。
                  </li>
                  <li class="ulchildlink"><a href="sharding-loading-data.html#GUID-59B5EABA-3C10-4329-B662-9E17F2303498">准备目标分片数据库</a><br>在开始将数据迁移到分片数据库之前，必须根据设计创建分片数据库模式。
                  </li>
                  <li class="ulchildlink"><a href="sharding-loading-data.html#GUID-B464BEB3-AEB7-4F6D-8328-C25F69FD223F">迁移您的数据</a><br>使用单个分片或多个分片创建目标分片数据库后，如果已定义分片和重复表，则可以开始将数据迁移到分片数据库中。
                  </li>
                  <li class="ulchildlink"><a href="sharding-loading-data.html#GUID-FD50835F-514F-4E74-95D3-BD0B4A6B0F20">迁移您的应用程序</a><br>分片数据库操作环境使应用程序能够直接访问分片。此功能提供了真正的线性可扩展性，但它的价格很低 - 对应用程序代码稍作改动。
                  </li>
               </ul>
            </div>
            
            <div class="sect2"><a id="GUID-041069C8-FA7B-4BA5-BFB8-B5A949DA12A9" name="GUID-041069C8-FA7B-4BA5-BFB8-B5A949DA12A9"></a><h3 id="SHARD-GUID-041069C8-FA7B-4BA5-BFB8-B5A949DA12A9" class="sect3"><span class="enumeration_section">9.1</span>关于将数据迁移到分片数据库</h3>
               <div>
                  <p>在Oracle Sharding软件安装以及分片数据库配置和创建之后，您可以将数据迁移到分片数据库。</p>
                  <p>以下是迁移到分片数据库环境的高级步骤。</p>
                  <ol>
                     <li>设计并创建分片数据库模式。</li>
                     <li>迁移数据。</li>
                     <li>迁移应用程序。</li>
                  </ol>
               </div>
               <div>
                  <div class="infoboxnotealso" id="GUID-041069C8-FA7B-4BA5-BFB8-B5A949DA12A9__GUID-9D648D57-1DC0-4351-BFAE-DE1153704986">
                     <p class="notep1">也可以看看：</p>
                     <p><a href="sharding-overview.html#GUID-DDF69235-8761-44DA-98AC-3080A239E63E" title="Oracle Sharding适用于适用于分片数据库的OLTP应用程序。">应用程序适用于分片，</a>以熟悉迁移到分片数据库应用程序的约束。
                     </p>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：将</strong> <a href="sharding-loading-data.html#GUID-6140925F-6192-4C6F-9ADC-BC2332ADA3B0" title="您可以使用此处描述的方法将数据从非分片数据库迁移到Oracle Sharding分片数据库。">数据迁移到Sharded数据库</a></p>
                     </div>
                  </div>
               </div>
               
            </div>
            <div class="sect2"><a id="GUID-6E455646-F4AA-4992-B50B-58A1290355FE" name="GUID-6E455646-F4AA-4992-B50B-58A1290355FE"></a><h3 id="SHARD-GUID-6E455646-F4AA-4992-B50B-58A1290355FE" class="sect3"><span class="enumeration_section">9.2</span>将数据加载到分片数据库的一般准则</h3>
               <div>
                  <p>从非分片数据库转换为分片数据库涉及将数据从非分片表移动到分片和重复表。将数据从非分片表移动到重复表不会带来任何复杂性，但是将数据从非分片表移动到分片表需要特别注意。</p>
                  <div class="section">
                     <p class="subhead2" id="GUID-6E455646-F4AA-4992-B50B-58A1290355FE__GUID-4C5D6A0D-884E-4B75-8BC6-DDFBEB05E343">将数据加载到重复的表中</p>
                     <p>可以使用任何现有的数据库工具将数据加载到重复的表中：Data Pump，SQL Loader或纯SQL。必须使用分片目录（协调程序）数据库节点加载数据。换句话说，重复表的全部内容包含在分片目录数据库中。由于复制表的内容使用实例化视图完全复制到数据库分片，因此加载重复的表可能比将相同数据加载到非分片表中所花费的时间更长。</p>
                     <div class="figure" id="GUID-6E455646-F4AA-4992-B50B-58A1290355FE__FIG_JCC_F5G_5GB">
                        <p class="titleinfigure">图9-1加载重复的表</p><br><div class="imageleft"><img class="imageleft" id="GUID-6E455646-F4AA-4992-B50B-58A1290355FE__IMAGE_KCC_F5G_5GB" src="img/load_duplicate_tables.png" alt="下面是图9-1的描述" title="下面是图9-1的描述" longdesc="img_text/load_duplicate_tables.html"><br><a href="img_text/load_duplicate_tables.html">“图9-1加载重复表”的说明</a></div><br></div>
                     <!-- class="figure" -->
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-6E455646-F4AA-4992-B50B-58A1290355FE__GUID-51AE4E26-A9F9-4055-AFD7-EE916519E5B1">将数据加载到分片表中</p>
                     <p>加载分片表时，每个数据库分片都适应整个数据集的不同子集（分片），因此在将每个子集加载到特定分片之前，必须分割（混洗）数据。</p>
                     <div class="figure" id="GUID-6E455646-F4AA-4992-B50B-58A1290355FE__FIG_OD1_CVG_5GB">
                        <p class="titleinfigure">图9-2使用分片目录加载分片表</p><br><div class="imageleft"><img class="imageleft" id="GUID-6E455646-F4AA-4992-B50B-58A1290355FE__IMAGE_PD1_CVG_5GB" src="img/load_sharded_tables_coordinator.png" alt="下面是图9-2的描述" title="下面是图9-2的描述" longdesc="img_text/load_sharded_tables_coordinator.html"><br><a href="img_text/load_sharded_tables_coordinator.html">“图9-2使用碎片目录加载分片表”的说明</a></div><br></div>
                     <!-- class="figure" -->
                     <p>您必须使用Oracle Data Pump实用程序在子集中的数据库分片中加载数据。请考虑以下两个选项：</p>
                     <ul id="GUID-6E455646-F4AA-4992-B50B-58A1290355FE__UL_D45_C42_KGB" style="list-style-type:disc">
                        <li>通过分片协调器（目录）节点加载数据，如上所示。</li>
                        <li>将数据直接加载到数据库分片，如下所示。</li>
                     </ul>
                     <div class="figure" id="GUID-6E455646-F4AA-4992-B50B-58A1290355FE__FIG_GY2_TVG_5GB">
                        <p class="titleinfigure">图9-3直接将Sharded Tables加载到数据库碎片</p><br><div class="imageleft"><img class="imageleft" id="GUID-6E455646-F4AA-4992-B50B-58A1290355FE__IMAGE_HY2_TVG_5GB" src="img/load_sharded_tables_direct.png" alt="下面是图9-3的描述" title="下面是图9-3的描述" longdesc="img_text/load_sharded_tables_direct.html"><br><a href="img_text/load_sharded_tables_direct.html">“图9-3直接将分片表加载到数据库碎片”的说明</a></div><br></div>
                     <!-- class="figure" -->
                     <p>使用分片协调器将数据加载到分片数据库比将整个数据集加载到非分片表中要慢，因为分片逻辑在分片协调器（目录）节点上运行，以及将数据推送到分片的额外开销。</p>
                     <p>将数据直接加载到数据库分片中要快得多，因为每个分片都是单独加载的。也就是说，通过在每个分片上运行Data Pump，您可以在使用整个数据集的最大子集加载分片所需的时间段内完成数据加载操作。平均而言，加载时间可以近似为将整个数据集加载到非分片数据库所需的时间除以分片数据库中的分片数。</p>
                     <p>您可以使用开源分片库拆分库，将分割（混洗）逻辑集成到您的应用程序中，而不是依赖Oracle Data Pump实用程序来拆分不同子集中的加载数据集。分片库源代码以及样本使用可在Oracle Sharding Tools Library中找到， <a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/shard&amp;id=sharding_tools_library" target="_blank">网址</a>为<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/shard&amp;id=sharding_tools_library" target="_blank">https://github.com/oracle/db-sharding/</a> 。基于此分片库，Oracle开发了一个通用流加载库，供Oracle云中使用。此时，流媒体加载库仅在请求时可用。</p>
                  </div>
                  <!-- class="section" -->
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：将</strong> <a href="sharding-loading-data.html#GUID-6140925F-6192-4C6F-9ADC-BC2332ADA3B0" title="您可以使用此处描述的方法将数据从非分片数据库迁移到Oracle Sharding分片数据库。">数据迁移到Sharded数据库</a></p>
                     </div>
                  </div>
               </div>
               
            </div>
            <div class="sect2"><a id="GUID-DD36B05A-AC5F-488D-9012-70043ED3E7EE" name="GUID-DD36B05A-AC5F-488D-9012-70043ED3E7EE"></a><h3 id="SHARD-GUID-DD36B05A-AC5F-488D-9012-70043ED3E7EE" class="sect3"><span class="enumeration_section">9.3</span>迁移模式</h3>
               <div>
                  <p>在将现有数据库迁移到分片数据库之前，必须确定如何组织分片数据库，包括分片数和复制策略，并且必须确定应用程序中哪些表是分片的，哪些表是重复的表。对于分片表，您必须确定分片方法以及表族中分片表之间的父子关系。</p>
                  <p>使用示例应用程序说明了到分片数据库环境的模式迁移，该应用程序是在数据模型和强加约束上定义的。我们分析了如何使用示例程序代码迁移到分片数据库对应用程序的影响。下图显示了示例应用程序数据模型</p>
                  <div class="figure" id="GUID-DD36B05A-AC5F-488D-9012-70043ED3E7EE__GUID-3D6A995B-26D2-4857-9631-8FCFBE978202">
                     <p class="titleinfigure">图9-4</p><img src="img/sample_schema.png" alt="下面是图9-4的描述" title="下面是图9-4的描述" longdesc="img_text/sample_schema.html"><br><a href="img_text/sample_schema.html">“图9-4”的描述</a></div>
                  <!-- class="figure" -->
                  <p>数据模型包括四个表：Customers，Orders，StockItems和LineItems，该模型强制执行以下主键约束。</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>顾客。（CustNo）</p>
                     </li>
                     <li>
                        <p>命令。（PONO）</p>
                     </li>
                     <li>
                        <p>StockItems。（StockNo）</p>
                     </li>
                     <li>
                        <p>了LineItem。（LineNo，PONo）</p>
                     </li>
                  </ul>
                  <p>数据模型定义了以下参照完整性约束。</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>顾客。CustNo  - &gt;订单。CustNo</p>
                     </li>
                     <li>
                        <p>命令。PONo  - &gt; LineItems。PONO</p>
                     </li>
                     <li>
                        <p>StockItems。StockNo  - &gt; LineItems。StockNo</p>
                     </li>
                  </ul>
                  <p>以下DDL语句创建示例应用程序数据库模式定义：</p><pre class="pre codeblock"><code>CREATE TABLE客户（CustNo NUMBER（3）NOT NULL，CusName VARCHAR2（30）NOT NULL，Street VARCHAR2（20）NOT NULL，City VARCHAR2（20）NOT NULL，State CHAR（2）NOT NULL，Zip VARCHAR2（10）NOT NULL，Phone VARCHAR2（12），PRIMARY KEY（CustNo））; CREATE TABLE订单（PoNo NUMBER（5），CustNo NUMBER（3）REFERENCES Customers，OrderDate DATE，ShipDate DATE，ToStreet VARCHAR2（20），ToCity VARCHAR2（20），ToState CHAR（2），ToZip VARCHAR2（10），PRIMARY KEY （PoNo））; CREATE TABLE StockItems（StockNo NUMBER（4）PRIMARY KEY Description VARCHAR2（20），Price NUMBER（6,2））; CREATE TABLE LineItems（LineNo NUMBER（2），PoNo NUMBER（5）REFERENCES Orders，StockNo NUMBER（4）REFERENCES StockItems，Quantity NUMBER（2），Discount NUMBER（4,2），PRIMARY KEY（LineNo，PoNo））;</code></pre><div class="section">
                     <p class="subhead2" id="GUID-DD36B05A-AC5F-488D-9012-70043ED3E7EE__GUID-B5F2DD8A-C80D-4520-9858-C009749FE400">分片密钥</p>
                     <p>Sharding是一种基于跨多个独立Oracle数据库的水平分区的数据库扩展技术。根据分片键列的值将数据库请求路由到适当的分片数据库。分片设计目标是选择一个分片键，最大化单个分片操作，并最小化或消除交叉分片操作。</p>
                     <p>基于样本应用程序数据模型中标识的外键功能依赖性的主键，形成下表族。</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>客户 - 父表</p>
                        </li>
                        <li>
                           <p>订单 - 儿童表</p>
                        </li>
                        <li>
                           <p>Lineitems  - 孙子表</p>
                        </li>
                     </ul>
                     <p>剩下的StockItems表只是一个查找表，将库存项目编号映射到库存项目描述和价格（StockNo  - &gt;（描述，价格））。</p>
                     <p>对于使用引用分区的表系列成员，以及定义StockItems查找表的其他DDL语句，分片数据库定义需要以下表DDL语句：</p><pre class="pre codeblock"><code>CREATE <span class="bold">SHARDED</span> TABLE客户（CustNo NUMBER（3）NOT NULL，CusName VARCHAR2（30）NOT NULL，Street VARCHAR2（20）NOT NULL，City VARCHAR2（20）NOT NULL，State CHAR（2）NOT NULL，Zip VARCHAR2（10） NOT NULL，Phone VARCHAR2（12），CONSTRAINT RootPK PRIMARY KEY（CustNo）） <span class="bold">PARTITION BY CONSISTENT HASH</span> （CustNo）PARTITIONS AUTO TABLESPACE SET ts1;创建<span class="bold">SHARDED</span> TABLE订单（PoNo NUMBER（5）NOT NULL，CustNo NUMBER（3）NOT NULL，OrderDate DATE，ShipDate DATE，ToStreet VARCHAR2（20），ToCity VARCHAR2（20），ToState CHAR（2），ToZip VARCHAR2（10） ，CONSTRAINT OrderPK PRIMARY KEY（CustNo，PoNo）CONSTRAINT CustFK外键（CustNo）REFERENCES Cusomters（CustNo）） <span class="bold">PARTITION BY REFERENCE</span> （CustFK）;创建<span class="bold">重复的</span>表StockItems（StockNo NUMBER（4）PRIMARY KEY描述VARCHAR2（20），价格NUMBER（6,2））; CREATE <span class="bold">SHARDED</span> TABLE LineItems（LineNo NUMBER（2）NOT NULL，PoNo NUMBER（5）NOT NULL，StockNo NUMBER（4）REFERENCES StockItems，Quantity NUMBER（2），Discount NUMBER（4,2），CONSTRAINT LinePK PRIMARY KEY（ <span class="bold">CustNo</span> ， LINENO，PONO）约束LineFK外键<span class="bold">（CustNo，PONO）</span>参考文献订单<span class="bold">（CustNo，PONO））PARTITION BY REFERENCE（LineFK）;</span></code></pre><p>将上面显示的分片数据库DDL与原始（非分片）数据库表进行比较后，您会注意到以下结构表更改（以粗体斜体显示）。</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>表系列中表的<code class="codeph">CREATE TABLE</code>语句包含附加的<code class="codeph">SHARDED</code>关键字。
                           </p>
                        </li>
                        <li>
                           <p>查找表的<code class="codeph">CREATE TABLE</code>语句包含其他关键字<code class="codeph">DUPLICATED</code> 。</p>
                        </li>
                        <li>
                           <p>表系列中的所有表都包含分片键列CustNo作为主键的前导列。这是特定于分片的反规范化，它在表族层次结构的每个级别扩展复合主键，以包括直接父键（也称为级别键）作为主要组件。</p>
                        </li>
                        <li>
                           <p>分片键<code class="codeph">PARTITIONED BY</code>分片键列分割。在这种特殊情况下，系列的根表由<code class="codeph">CONSISTENT HASH</code>划分。这种划分模式传播到较低层级<code class="codeph">BY REFERENCE</code> （参考分区）。<code class="codeph">CONSISTENT HASH</code>的数据分区称为系统管理的分片方法（与用户定义的分片相反）。
                           </p>
                        </li>
                        <li>
                           <p>在系统管理的分片中，为分片表定义了表空间集。第一组表空间用于<code class="codeph">SHARDED</code>表。表空间集在分片数据库中用作一个或多个分片表和索引的逻辑存储单元。表空间集包含分布在分片空间中的分片中的多个表空间。数据库自动在表空间集中创建表空间。表空间的数量是自动确定的，并且等于相应分片空间中的块数。
                           </p>
                           <p><code class="codeph">CREATE TABLESPACE SET tbs1;</code>对于分片表</p>
                           <p>在我们的示例中，Customers，Orders和LineItem放置在表空间集tbs1中。这意味着表系列中三个表的相应分区存储在同一个表空间集tbs1（按引用分区）中。但是，可以为每个表指定单独的表空间集。</p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="sharding-physical-organization.html#GUID-3D0475BE-3F6F-4D2E-8B2E-B1161DBB1A78" title="跨分片的分区分布是通过在驻留在不同分片上的表空间中创建分区来实现的。">分区，表空间和块</a></li>
                     </ul>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：将</strong> <a href="sharding-loading-data.html#GUID-6140925F-6192-4C6F-9ADC-BC2332ADA3B0" title="您可以使用此处描述的方法将数据从非分片数据库迁移到Oracle Sharding分片数据库。">数据迁移到Sharded数据库</a></p>
                     </div>
                  </div>
               </div>
            </div>
            <div class="sect2"><a id="GUID-18D1592D-3A41-4C81-ABEF-86527A610A3D" name="GUID-18D1592D-3A41-4C81-ABEF-86527A610A3D"></a><h3 id="SHARD-GUID-18D1592D-3A41-4C81-ABEF-86527A610A3D" class="sect3"><span class="enumeration_section">9.4</span>准备源数据库</h3>
               <div>
                  <p>要使转换为分片数据库模式更顺畅，可以修改源非分片数据库，使其与目标分片数据库中的表定义匹配。</p>
                  <p>理想情况下，目标分片数据库中的表定义（表名，列名及其数据类型）和源数据库中的表定义将完全相同。但是，作为转换为分片数据库的一部分，您可能需要修改表定义以在分片数据库中使用。如果是这种情况，您可以修改源，非分片数据库，使其与新分片数据库中的表定义匹配。根据更改的程度，这还可能需要更改应用程序代码。通过修改源数据库模式，使其在迁移过程之前与目标分片数据库模式匹配，可以为从原始非分片数据库到新分片数据库的不间断转换提供条件。如果停机时间最短，这些准备工作是最短停机时间的先决条件。此外，如示例应用程序所示，迁移准备是一个无缝且易于反转的过程。您准备源数据库的活动是非常需要的，但不是必需的。如果由于某种原因无法修改源数据库操作环境，则可以跳过此主题。</p>
                  <p>此处显示的步骤遵循上一主题中定义的相同示例模式。</p>
                  <p>要迁移示例数据库，必须使用<code class="codeph">ALTER TABLE</code>将分片键列CustNo添加到源数据库中的LineItems表，如此示例所示。
                  </p><pre class="pre codeblock"><code>ALTER TABLE LineItems ADD（CustNo NUMBER（3））;</code></pre><p>使用此附加列，源表中的行数据布局和目标分片表中的所需布局是相同的。现在，您已准备好使用匹配数据填充此新列。LineItems表中的其他分片键列CustNo中的值必须从以父子关系加入LineItems的Orders派生。</p><pre class="pre codeblock"><code>选择订单。CustNo FROM Orders JOIN LineItems ON Orders。PONo = LineItems。PONO;</code></pre><p>在此示例中，使用<code class="codeph">MERGE</code>语句填充CustNo列。您还可以使用标准SQL来实现相同的目标。在此处显示的示例中， <code class="codeph">MERGE</code>语句如下所示。
                  </p><pre class="pre codeblock"><code>SQL&gt; BEGIN 2 MERGE INTO LineItems l 3使用订单o 4 ON（l。PONo = o。PONo）5匹配时6更新设置l。CustNo = o。CustNo; 7结束; 8 /</code></pre><p>您可能会在此时发现要为CustNo列维护参照完整性。要确保正确填充新列，应在执行<code class="codeph">MERGE</code>语句后添加<code class="codeph">NOT NULL</code>约束，如下所示。
                  </p><pre class="pre codeblock"><code>ALTER TABLE LineItems MODIFY CustNo NOT NULL;</code></pre><p>通过运行上面的<code class="codeph">MERGE</code>语句，可以将LineItems表行布局和行数据置于所需状态。附加的CustNo列使LineItems表的分片方式与表系列（Customers）的根相同。您可以考虑将此更改用作实际迁移之前的最后一个操作之一。否则，您必须在应用程序中维护此新列。因此，还必须为现有数据库中添加的分片键列维护引用完整性。匹配的CustNo列的参照完整性约束在LineItems表中定义，如此处所示。
                  </p><pre class="pre codeblock"><code>ALTER TABLE LineItems ADD CONSTRAINT LineFk FOREIGN KEY（CustNo，PONo）REFERENCES Orders（CustNo，PONo）;</code></pre><p>在更改LineItems表上的参照完整性约束之前，必须删除引用Orders表的现有<code class="codeph">FOREIGN KEY</code>约束。这可以通过在<code class="codeph">ALTER TABLE LineItems READ ONLY;</code>包含<code class="codeph">DROP CONSTRAINT</code>后跟<code class="codeph">ADD CONSTRAINT</code>语句来安全地完成<code class="codeph">ALTER TABLE LineItems READ ONLY;</code>和<code class="codeph">ALTER TABLE LineItems READ WRITE;</code> ，或者只是通过在约束修改期间使用<code class="codeph">LOCK TABLE LineItems IN SHARE MODE</code> 。
                  </p>
                  <p>作为在LineItems表中添加CustNo列作为外键定义的一部分的结果，您必须修改Orders表上的主键。反过来，更改主键需要重建索引，这可能需要一些时间才能完成。只有在计划在迁移到分片数据库之前的一段时间内针对此新架构运行应用程序时，此工作才有意义。</p>
                  <p>以下示例说明了将分片键添加到LineItems表后更改LineItems和Orders架构。在删除LineItems表上的现有外键约束和Orders表上的主键约束之前，必须检索相应的约束名称，如下所示。</p><pre class="pre codeblock"><code>SQL&gt; SELECT a.table_name，a.column_name，a.constraint_name 2 FROM ALL_CONS_COLUMNS A，ALL_CONSTRAINTS C 3 WHERE A.CONSTRAINT_NAME = C.CONSTRAINT_NAME 4 and a.table_name ='LINEITEMS'和C.CONSTRAINT_TYPE ='R'; LINEITEMS PONO SYS_C009087 LINEITEMS STOCKNO SYS_C009088 SQL&gt; SELECT cols.table_name，cols.column_name，cols.constraint_name，cols.position 2 FROM all_constraints cons，all_cons_columns cols 3 WHERE cons.constraint_type ='P'4 AND cons.constraint_name = cols.constraint_name 5 AND cols.table_name ='ORDERS'6 ORDER BY cols.table_name，cols.position; ORDERS ORDER_ID ORDER_PK 1 ORDERS PONO SYS_C009148 1 SQL&gt; ALTER TABLE LineItems READ ONLY;表改变了。SQL&gt; ALTER TABLE命令只读;表改变了。SQL&gt; ALTER TABLE LineItems DROP CONSTRAINT SYS_C009087;表改变了。SQL&gt; ALTER TABLE ORDERS DROP CONSTRAINT SYS_C009148;表改变了。SQL&gt; ALTER TABLE ORDERS ADD CONSTRAINT order_pk PRIMARY KEY（CustNo，PONo）;表改变了。SQL&gt; ALTER TABLE LineItems ADD CONSTRAINT LineFk FOREIGN KEY（CustNo，PONo）REFERENCES Orders（CustNo，PONo）;表改变了。SQL&gt; ALTER TABLE命令READ WRITE;表改变了。SQL&gt; ALTER TABLE LineItems READ WRITE;表改变了。</code></pre><p>同样，您应该通过将CustNo包含为前导列，将LineItems表的<code class="codeph">PRIMARY KEY</code>定义扩展为完整级别键，如此处所示。
                  </p><pre class="pre codeblock"><code>ALTER TABLE LineItems ADD CONSTRAINT LinePK PRIMARY KEY（CustNo，PONo，LineNo）;</code></pre><p>同样，在引入新<code class="codeph">PRIMARY KEY</code>约束之前，必须先删除它。要保持数据完整性，请使用前面建议的两种事务隔离策略之一修改<code class="codeph">PRIMARY KEY</code>和<code class="codeph">FOREIGN KEY</code>约束。在以下示例中，LineItems表在发生约束修改时被锁定。之后， <code class="codeph">COMMIT</code>释放锁。
                  </p><pre class="pre codeblock"><code>SQL&gt; SELECT cols.table_name，cols.column_name，cols.constraint_name，cols.position 2 FROM all_constraints cons，all_cons_columns cols 3 WHERE cons.constraint_type ='P'4 AND cons.constraint_name = cols.constraint_name 5 AND cols.table_name =' LINEITEMS'6 ORDER BY cols.table_name，cols.position; LINEITEMS LINENO SYS_C009086 1 LINEITEMS PONO SYS_C009086 2 SQL&gt; LOCK TABLE LineItems IN SHARE MODE;表（已锁定）。SQL&gt; ALTER TABLE LINEITEMS DROP CONSTRAINT SYS_C009086;表改变了。SQL&gt; ALTER TABLE LineItems ADD CONSTRAINT LinePK PRIMARY KEY（CustNo，PONo，LineNo）;表改变了。SQL&gt; COMMIT;提交完成。</code></pre><p>与参照完整性相关的修改是可选的。提议的修改使源数据库非常接近于类似于分片目标数据库。这进一步促进了过渡过程。</p>
                  <p>在某些情况下，不能强制引用完整性，也不希望创建引用完整性。如果是这种情况，则无法定义引用分区。在这种情况下，您可以使用<code class="codeph">PARENT</code>子句。
                  </p>
                  <p>最后，LineItems表中的其他CustNo列可能会影响现有查询，例如<code class="codeph">SELECT * FROM LineItems</code> 。要避免此问题，您可以将CustNo列修改为不可见，如此处所示。
                  </p><pre class="pre codeblock"><code>SQL&gt; ALTER TABLE LineItems MODIFY CustNo INVISIBLE;</code></pre><p>通过对源数据库表的这些修改，您已为迁移准备了现有的示例数据库。</p>
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：将</strong> <a href="sharding-loading-data.html#GUID-6140925F-6192-4C6F-9ADC-BC2332ADA3B0" title="您可以使用此处描述的方法将数据从非分片数据库迁移到Oracle Sharding分片数据库。">数据迁移到Sharded数据库</a></p>
                     </div>
                  </div>
               </div>
               
            </div>
            <div class="sect2"><a id="GUID-59B5EABA-3C10-4329-B662-9E17F2303498" name="GUID-59B5EABA-3C10-4329-B662-9E17F2303498"></a><h3 id="SHARD-GUID-59B5EABA-3C10-4329-B662-9E17F2303498" class="sect3"><span class="enumeration_section">9.5</span>准备目标分片数据库</h3>
               <div>
                  <p>在开始将数据迁移到分片数据库之前，必须根据设计创建分片数据库模式。</p>
                  <p>从非分片数据库环境到分片数据库环境的数据迁移可以通过两种不同的方式完成：</p>
                  <ul id="GUID-59B5EABA-3C10-4329-B662-9E17F2303498__UL_DHR_4W4_LGB" style="list-style-type:disc">
                     <li><span class="bold">两步法：</span>这是一种更加谨慎，渐进的数据迁移方法。仅使用一个分片创建分片数据库。只要您的分片数据库包含在一个分片中，您的应用程序以及数据库维护过程就可以在不更改应用程序代码和/或可忽略不计的相关修改的情况下使用。换句话说，在迁移到分片环境时，分片数据库的行为与非分片数据库的行为方式相同。然后，一旦修改了应用程序和分片操作过程，就可以继续将数据库扩展到适当数量的分片。
                     </li>
                     <li><span class="bold">单步方法：</span>最初使用适当数量的分片创建分片数据库。在这种情况下，您的应用程序和操作过程应该为迁移时的分片操作做好充分准备。
                     </li>
                  </ul>
                  <p>更谨慎的两步方法可以平滑但更长时间地转换为分片数据库环境。针对单个分片运行应用程序，您可以有时间逐步修改应用程序以进行直接路由。只有在修改现有应用程序以使用分片导向器连接到正确的分片后，才能实例化剩余的分片。</p>
                  <p>该过程的第一步是创建仅包含一个分片的分片数据库。然后，您可以按照以下某个部分中的建议修改现有应用程序。最后一步是将分片数据库向外扩展到所需的分片数。此方法还提供了在向外扩展之前在所有分片上拆分和重新平衡数据块的机会。</p>
                  <p>这种两步迁移方法不仅需要更多时间，而且还需要更多空间。如果将所有数据迁移到单个分片，则可以无限制地将分片表数据直接加载到单个分片。缩小到多个分片后，如果要将分片表直接正确加载到多个数据库分片中，则应严格使用数据泵实用程序。重复的表驻留在目录数据库中，您应始终使用目录数据库加载重复的表。</p>
                  <p>无论您决定使用一步法还是两步法，都必须在将数据加载到分片数据库之前导出数据并创建分片数据库模式。在下面的示例中，假设软件安装已完成，并且您已创建分片数据库环境，至少包括分片目录和分片的一个或多个数据库。您可以创建新的分片目录或使用现有分片目录。为了说明迁移过程，此过程中的示例使用以下数据库实例：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>orignode  - 托管原始非分片数据库实例的站点，SID = orig</p>
                     </li>
                     <li>
                        <p>catnode  - 托管分片目录数据库实例的目录节点，SID = ctlg</p>
                     </li>
                     <li>
                        <p>shrdnodeN  - 托管数据库分片实例的分片节点，SID = shrdN，其中N可以是1,2，依此类推</p>
                     </li>
                     <li>
                        <p>gsmnode  - 托管分片导向器（GSM）实例的目录节点，SID = gsm1</p>
                     </li>
                  </ul>
                  <p>无论您是否已修改源数据库以准备迁移，迁移过程都需要修改DDL定义，包括至少包括<code class="codeph">CREATE SHARDED TABLE</code>和<code class="codeph">CREATE DUPLICATED TABLE</code>语句。要将数据库模式迁移到目标分片数据库，必须从源数据库中提取DDL定义并修改SHARDED和DUPLICATED表元数据。从源数据库中提取DDL语句的便捷方法是创建数据泵提取文件。然后对数据库导出文件使用Data Pump导入实用程序，如下所示。
                  </p><pre class="pre codeblock"><code>impdp uname / pwd @ orignode directory = expdir dumpfile = sample.dmp sqlfile = sample_ddl.sql</code></pre><p>在此示例中， <code class="codeph">impdp</code>命令实际上不执行转储文件内容的导入。而是， <code class="codeph">sqlfile</code>参数触发创建名为sample_ddl.sql的脚本，该脚本包含导出转储文件中的所有DDL。此数据库导出文件的创建如下所示。
                  </p><pre class="pre codeblock"><code>expdp uname / pwd @ orignode full = Y directory = expdir dumpfile = sample.dmp logfile = sample.log</code></pre><p>完整数据库导出文件包含整个数据库内容：数据和元数据。导出整个数据库可能需要很长时间。如果要快速执行此步骤，则只能导出元数据，或仅导出包含您感兴趣的表集的部分，如此示例所示。</p><pre class="pre codeblock"><code>expdp uname / pwd directory = DATA_PUMP_DIR dumpfile = sample_mdt.dmp logfile = sample_mdt.log INCLUDE = TABLE：\“IN \（\'CUSTOMERS \'，\'ORDERS \'，\'STOCKITEMS \'，\'LINEITEMS \'\ ）\“一致= Y内容= METADATA_ONLY</code></pre><p>以这种方式减少导出可以更有效地捕获数据库元数据的一致映像，而无需冗长的数据库数据转储过程。您仍然必须以文本格式获取DDL语句，并根据分片数据库模式设计的要求执行DDL修改。如果您决定导出整个数据库，则可能还会将其用作加载数据的输入。</p>
                  <p>Data Pump提供了一种传输数据的安全方式。数据库管理员必须授权数据库用户访问数据库导出目录，如此处所示。</p><pre class="pre codeblock"><code>创建或替换DIRECTORY expdir AS'/ some / directory'; GRANT READ，WRITE ON DIRECTORY expdir to uname; GRANT EXP_FULL_DATABASE要取消;</code></pre><p>使用完整数据库导出时，数据库管理员必须向用户<code class="codeph">uname</code>授予<code class="codeph">EXP_FULL_DATABASE</code>角色。表级导出不需要其他角色。有关数据泵实用程序的详细信息，请参阅下面参考中的“数据库实用程序”文档。
                  </p>
                  <p>如果修改了源（非分片）数据库以使行布局与目标（分片）数据库匹配，则不需要完整的数据库或表级别导出。可以按原样有效地传输数据，而无需中间转储文件。</p>
                  <p>完成分片数据库模式后，使用数据库管理员凭据对分片目录数据库（ctlg）运行准备好的DDL。必须在启用了<code class="codeph">SHARD DDL</code>设置的会话中执行所有DDL语句，以确保所有DDL语句都从目录数据库（ctlg）传播到分片数据库（shrd1,2，...，N）。
                  </p><pre class="pre codeblock"><code>ALTER SESSTION ENABLE SHARD DDL;</code></pre><p>通过定义分片和重复的表，您的分片数据库已准备好进行数据加载。建议您在加载数据之前使用GDSCTL <code class="codeph">VALIDATE</code>命令验证分片配置。
                  </p><pre class="pre codeblock"><code>gdsctl验证</code></pre><p>成功验证后，分片数据库已准备好进行数据加载。如果发现不一致或错误，则必须使用GDSCTL命令<code class="codeph">SHOW DDL</code>和<code class="codeph">RECOVER</code>更正问题。</p>
                  <p>默认情况下，数据泵导出实用程序文件基于每个表一致。如果希望导出中的所有表与同一时间点保持一致，则必须使用<code class="codeph">FLASHBACK_SCN</code>或<code class="codeph">FLASHBACK_TIME</code>参数。建议使用一致的“截至”时间点数据库导出文件。如果您选择从非分片数据库到分片数据库的不间断迁移（即，如果要在迁移期间提供连续数据库操作），这一点尤为重要。Oracle GoldenGate补充了在连续操作期间使用Data Pump迁移到分片数据库。生成一致数据库快照的导出命令如下所示。
                  </p><pre class="pre codeblock"><code>expdp uname / pwd @ orignode full = Y directory = expdir dumpfile = sample.dmp logfile = sample.log CONSISTENT = Y FLASHBACK_TIME = SYSTIMESTAMP</code></pre><p>一致的快照数据库映像需要额外的<code class="codeph">CONSISTENT</code>或<code class="codeph">FLASHBACK_TIME</code>参数。当您运行该命令时，您会注意到<code class="codeph">CONSISTENT</code>和<code class="codeph">FLASHBACK_TIME</code>这两个参数的含义相同。请注意，时间戳转换为系统更改号（SCN），如此处所示。
                  </p><pre class="pre codeblock"><code>SQL&gt; SELECT TIMESTAMP_TO_SCN（SYSTIMESTAMP）FROM dual; TIMESTAMP_TO_SCN（SYSTIMESTAMP）------------------------------ 1559981</code></pre><p>如果您更喜欢在<code class="codeph">FLASHBACK_TIME</code>使用<code class="codeph">FLASHBACK_SCN</code> ，则可以通过从V $ DATABASE中选择它来获取当前SCN，如下所示。
                  </p><pre class="pre codeblock"><code>SQL&gt; SELECT current_scn FROM v $ database; CURRENT_SCN ----------- 1560005</code></pre><p>或者，您可以如此处所示声明它。</p><pre class="pre codeblock"><code>SQL&gt; SET SERVEROUTPUT ON SQL&gt; DECLARE SCN NUMBER; 2 BEGIN 3 SCN：= DBMS_FLASHBACK.GET_SYSTEM_CHANGE_NUMBER; 4 DBMS_OUTPUT.PUT_LINE（SCN）; 5结束; 6/1560598</code></pre><p>您可能需要请求数据库管理员访问<code class="codeph">DBMS_FLASHBACK</code>授权。</p>
                  <p>您可以使用<code class="codeph">PARALLEL</code>参数使Data Pump更快地运行。此参数应与<code class="codeph">DUMPFILE</code>参数中的％U通配符结合使用，以允许创建多个转储文件，如此示例所示。
                  </p><pre class="pre codeblock"><code>expdp uname / pwd @ orignode full = Y directory = expdir dumpfile = samp_％U.dmp logfile = samp.log CONSISTENT = Y PARALLEL = 3</code></pre><p>上面的命令使用四个并行工作程序，并创建四个后缀为_01，_02，_03的转储文件。导入期间可以使用相同的通配符，以允许您引用多个输入文件。请注意，三个转储文件samp_01.dmp，samp_02.dmp和samp_03.dmp是通过并行导出而不是前一个示例中创建的单个输出文件sample.dmp创建的。此外，并行导出的经过时间小于串行执行所用时间的三分之一，即单个转储文件输出。</p>
                  <div class="section"></div>
                  <!-- class="section" -->
               </div>
               <div>
                  <div class="infoboxnotealso" id="GUID-59B5EABA-3C10-4329-B662-9E17F2303498__GUID-8219201B-DAA6-4512-A101-96D088AF9447">
                     <p class="notep1">也可以看看：</p>
                     <p><a href="sharding-deployment.html#GUID-F99B8742-4089-4E77-87D4-4691EA932207" title="分片数据库部署包括安装所需软件组件，创建目录，角色和分片数据库，配置高可用性复制以及为分片数据库创建架构的先决条件和说明。">Sharded数据库部署</a></p>
                     <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/shard&amp;id=SUTIL-GUID-501A9908-BCC5-434C-8853-9A6096766B5A" target="_blank"><span><cite>Oracle数据库实用程序</cite></span></a></p>
                     <p><a href="../gsmug/gdsctl-reference.html#GSMUG-GUID-E6E76443-AD85-455C-99AA-BF0A7856F880" target="_blank"><span><cite>“Oracle数据库全球数据服务概念和管理指南”</cite></span></a></p>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：将</strong> <a href="sharding-loading-data.html#GUID-6140925F-6192-4C6F-9ADC-BC2332ADA3B0" title="您可以使用此处描述的方法将数据从非分片数据库迁移到Oracle Sharding分片数据库。">数据迁移到Sharded数据库</a></p>
                     </div>
                  </div>
               </div>
               
            </div>
            <div class="sect2"><a id="GUID-B464BEB3-AEB7-4F6D-8328-C25F69FD223F" name="GUID-B464BEB3-AEB7-4F6D-8328-C25F69FD223F"></a><h3 id="SHARD-GUID-B464BEB3-AEB7-4F6D-8328-C25F69FD223F" class="sect3"><span class="enumeration_section">9.6</span>迁移数据</h3>
               <div>
                  <p>使用单个分片或多个分片创建目标分片数据库后，如果已定义分片和重复表，则可以开始将数据迁移到分片数据库中。</p>
                  <p>在开始将数据从源迁移到分片数据库之前，请确保了解以下数据加载注意事项：</p>
                  <ul style="list-style-type:disc">
                     <li>迁移重复表和分片表之间的差异<p>重复的表驻留在分片目录中，它们始终使用任何可用的数据加载实用程序或纯SQL加载到分片目录数据库中。但是，您有两种加载分片表的选项。可以使用分片协调器（目录）加载分片表，也可以使用数据泵实用程序将它们直接加载到分片中。</p>
                     </li>
                     <li>使用协调器迁移分片表或直接加载到分片<p>将分片表直接加载到分片数据库总是更快，因为您可以同时加载多个分片。</p>
                     </li>
                     <li>迁移到多个分片或迁移到单个分片<p>使用单个分片将非分片数据库迁移到分片数据库不需要对应用程序和数据库维护过程进行重大更改。在准备将数据拆分为分片之前，您可以继续保持当前操作的基本不变。但是，将非分片数据库迁移到具有多个分片的分片数据库涉及非平凡的准备过程，对应用程序源代码的修改是最耗时的先决条件。如果您打算使用单个分片迁移到分片数据库，则还必须设置计划以将数据库扩展为多个分片，即稍后在多个分片中分布数据库块。同时，您可以处理使用带有多个分片的分片数据库运行所需的应用程序和其他更改。</p>
                     </li>
                     <li>通过停机或不间断迁移进行迁移<p>仅使用一个分片从非分片数据库到分片数据库的不间断迁移比迁移到具有多个分片的分片数据库更容易，更简单。在数据库运行时，将执行从一个分片到多个分片的后续向外扩展。</p>
                        <p>如果要在一个步骤中从非分片数据库迁移到目标多分片数据库，强烈建议您首先在测试环境中进行尝试，并且只有在确保迁移生产环境后才开始迁移生产环境。测试环境无任何问题地迁移。</p>
                     </li>
                  </ul>
                  <p>无论是否在源数据库中准备目标行数据布局，都有各种方法可供选择以进行有效的数据迁移。选择最适合您条件的方法：可用磁盘空间，远程文件访问，网络吞吐量等。</p>
                  <div class="section">
                     <p class="subhead2" id="GUID-B464BEB3-AEB7-4F6D-8328-C25F69FD223F__GUID-BEDEF66C-FC5D-4902-B4B7-F928F7296716">考虑迁移期间的停机时间</p>
                     <p>如果要消除数据库停机时间，则迁移计划必须包含Oracle GoldenGate。要使目标（分片）数据库与源（非分片）数据库保持同步，必须使用Oracle GoldenGate处理迁移过程中对源数据库所做的更改。</p>
                     <p>除了零停机迁移的好处之外，您还可以选择使用Oracle GoldenGate进行分片数据库的主动 - 主动复制。如果已为分片数据库定义了Oracle GoldenGate主动 - 主动复制，则应将所有数据迁移活动限制为分片目录数据库。</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-B464BEB3-AEB7-4F6D-8328-C25F69FD223F__GUID-66344188-4E93-451A-9E88-9035CCC80C41">使用停机时间将数据迁移到Sharded表</p>
                     <p>如果您不使用Oracle GoldenGate，请采取措施在迁移期间尽可能保持数据库可用;你应该计划停机时间。</p>
                     <p>如果您决定在迁移之前修改源，非分片数据库表，则表模式将与目标分片数据库模式匹配，并且与未执行此预迁移步骤相比，数据迁移过程将更加顺畅。此方法在源数据库中生成相同的行数据布局，并在目标分片数据库中生成相应的布局，因此您可以直接复制数据库内容。</p>
                     <ol id="GUID-B464BEB3-AEB7-4F6D-8328-C25F69FD223F__OL_CBW_TKL_MGB">
                        <li>从数据库表导出数据。<pre class="pre codeblock"><code>expdp uname / pwd @ non_sharded_db directory = file_dir dumpfile = original_tables.dmp logfile = original_table.log INCLUDE = TABLE：\“IN \（\'CUSTOMERS \'，\'ORDERS \'，\'STOCKITEMS \'，\'LINEITEMS \ '\）\“一致= Y内容= DATA_ONLY</code></pre><p>此数据泵导出示例仅限于Oracle Sharding示例应用程序使用的表。由于已在示例中创建了SHARDED和DUPLICATED表，因此只导出表内容（DATA_ONLY）。</p>
                        </li>
                        <li>在开始将数据导入分片数据库之前，使目标数据库节点可以访问导出文件（original_tables.dmp）。
                           <p>您可以将此文件（或并行导出时的多个文件）移动到目标数据库系统，也可以通过网络共享该文件。</p>
                        </li>
                        <li>导出完成后，您可以开始将内容导入分片数据库。
                           <p>必须使用分片目录加载DUPLICATED表（StockItems）。以下是导入命令的示例。</p><pre class="pre codeblock"><code>impdp uname / pwd @ catnode：1521 / ctlg directory = data_pump_dir dumpfile = original_tables.dmp logfile = imp.log tables = <span class="italic">StockItems</span> content = DATA_ONLY</code></pre></li>
                        <li>直接加载分片，或使用分片目录加载它们。
                           <p>加载SHARDED表（Customers，Orders和LineItems）的最佳方法是直接在每个分片（shrd1,2，...，N）上运行数据泵。以下是第一个分片上的import命令的示例。</p><pre class="pre codeblock"><code>impdp uname / pwd @ shrdnode：1521 / shrd1 directory = data_pump_dir dumpfile = original_tables.dmp logfile = imp.log tables = <span class="italic">Customers</span> ， <span class="italic">Orders</span> ， <span class="italic">LineItems</span> content = DATA_ONLY</code></pre><p>或者，您可以在分片目录上运行Data Pump以加载所有表。以下示例显示了import命令。</p><pre class="pre codeblock"><code>impdp uname / pwd @ catnode：1521 / ctlg directory = data_pump_dir dumpfile = original_tables.dmp logfile = imp.log tables = <span class="italic">Customers</span> ， <span class="italic">Orders</span> ， <span class="italic">LineItems，StockItems</span> content = DATA_ONLY</code></pre></li>
                     </ol>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-B464BEB3-AEB7-4F6D-8328-C25F69FD223F__GUID-08E571DD-D3E5-437E-8DB5-1A5F3837B32B">无需停机即可将数据迁移到Sharded表</p>
                     <p>Oracle Sharding提供了Oracle GoldenGate复制与Data Pump导出和导入实用程序之间的紧密集成。如果Oracle GoldenGate当前不存在于源数据库或目标分片数据库中，则在安装之前，应将数据库升级到源数据库和目标数据库上的最新版本的Oracle数据库。升级数据库可提供最大可用功能并简化设置。使用Oracle Database 12c第2版及更高版本，您可以在目标分片数据库上的非分片源和集成副本上使用集成捕获。</p>
                     <p>只要使用数据泵导出和导入来重新创建整个数据库，Oracle GoldenGate就可确保在导出和导入期间和之后迁移数据库。您可以自行决定在迁移过程中Oracle GoldenGate需要复制的内容。建议您不要复制应用程序不需要的数据库更改。</p>
                     <p>为源数据库和目标数据库配置Oracle GoldenGate时，建议您在安排生产迁移之前使用实时数据进行测试。如果克隆源数据库，则可以使用克隆来测试迁移，而不会影响生产环境。</p>
                     <div class="figure" id="GUID-B464BEB3-AEB7-4F6D-8328-C25F69FD223F__FIG_FZ1_HSG_5GB">
                        <p class="titleinfigure">图9-5无停机迁移</p><br><div class="imageleft"><img class="imageleft" id="GUID-B464BEB3-AEB7-4F6D-8328-C25F69FD223F__IMAGE_GZ1_HSG_5GB" src="img/migration_without_downtime.png" alt="下面是图9-5的描述" title="下面是图9-5的描述" longdesc="img_text/migration_without_downtime.html"><br><a href="img_text/migration_without_downtime.html">“图9-5无停机迁移”的说明</a></div><br></div>
                     <!-- class="figure" -->
                     <p>上面说明了使用Data Pump与Oracle GoldenGate结合的迁移过程。大部分数据迁移是使用Data Pump执行的，将数据直接移动到分片目录和分片。数据泵运行期间的数据库更改将收集在Oracle GoldeGate本地跟踪文件中，并移至分片目录数据库。对分片表的更改将从分片目录数据库传播到分片。</p>
                     <p>从Data Pump的角度来看，源数据库（ORIG）使用impdp非分片和impdp分片进程分为分片目录（CTLG）和分片数据库（SHRD1，SHRD2和SHRD3）。impdp非分片进程将重复的表迁移到分片目录数据库。三个impdp分片并行进程将分片表直接迁移到分片SHRD1，SHRD2和SHRD3。</p>
                     <p>从Oracle GoldenGate的角度来看，所有数据库共享从Extract根进程分叉的extract（exsh），pump（pmsh）和replicat（rpsh）进程管道。</p>
                     <p>假设你准备的<code class="codeph">obey</code>对应于上图的文件，用于从源数据库节点（orignode）到碎片目录节点（catnode）的Oracle GoldenGate管线一个GGSCI终端会话看起来像下面的例子。
                     </p><pre class="pre codeblock"><code>查看参数./dirprm/add_exsh_2pumps.oby  - 添加名为exsh的更改数据提取进程组 -  exsh从orig数据库读取DUPLICATED和SHARDED表重做日志添加提取exsh，tranlog，立即开始 - 将跟踪文件关联为输出exsh进程组添加exttrail ./dirdat/et，提取exsh  - 添加SHARDED和DUPLICATE更改数据提取泵进程pmsh  -  pmsh将本地跟踪数据复制到ctlgnode远程跟踪位置add extract pmsh，exttrailsource ./dirdat/et  -  associate远程跟踪pmsh添加rmttrail ./dirdat/et，提取pmsh  - 连接到数据库并添加表级补充日志记录： -  Customers，Orders，LineItems和StockItems表添加trandata uname。客户添加trandata uname。订单添加trandata uname。LineItems添加trandata uname。StockItems</code></pre><p>运行GGSCI <code class="codeph">obey</code>命令为管道，其次是<code class="codeph">info all</code> 。
                     </p><pre class="pre codeblock"><code>服从./dirprm/add_exsh_2pumps.oby信息全部</code></pre><p>您应该看到初始化非分片和分片管道的提取过程，并等待处于停止状态。</p><pre class="pre codeblock"><code>... EXTRACT STOPPED exsh ... EXTRACT STOPPED pmsh ......</code></pre><p>检查分片和目录表的进程组参数<code class="codeph">EXTRACT</code> 。
                     </p><pre class="pre codeblock"><code>查看参数exsh  - 第一行必须提取后跟名称提取exsh  - 登录信息获取元数据userid uname @ orignode，密码pwd  - 导出写入跟踪信息exttrail ./dirdat/exsh  - 检查点时间间隔与源checkpointsecs 1  - 源表table uname。客户表uname。订单表uname。LineItems表uname。StockItems</code></pre><p>查看所有表的泵过程组的参数，pmsh。</p><pre class="pre codeblock"><code>查看parms pmsh  - 第一行必须提取后跟名称extract pmsh  - 无需登录数据库passthru  - 连接到远程主机，写入并与管理器通话rmthost shrdnode，mgrport 7810  - 其中是路径在远程主机rmttrail ./dirdat/rt上 - 检查点时间间隔与目标checkpointsecs 1  - 表table uname。客户表uname。订单表uname。LineItems表uname。StockItems</code></pre><p>在假设Shard目录节点（catnode）上的管理器进程使用端口号7810的情况下创建Oracle GoldenGate Pump进程。这是一个公平的假设，因为分片目录和分片数据库在不同的机器上运行。</p>
                     <p>检查分片目录节点（catnode）上的定义。</p><pre class="pre codeblock"><code>view params mgr PORT 7810  - 源端的PUMP进程用于目标DYNAMICPORTLIST 8000-8010 SYSLOG NONE上的收集器</code></pre><p>在分片目录节点（catnode）上，查看准备好的Replicat进程obey命令文件。</p><pre class="pre codeblock"><code>view params ./dirprm/add_rpsh.oby  - 连接数据库dblogin userid uname @ catnode，密码pwd  - 添加checkpoint表add checkpointtable uname.gg_checkpoint  - 添加replicat进程rpsh，将远程跟踪转换为SQL，不断添加replicat rpsh ，exttrail ./dirdat/rt,checkpointtable uname.gg_checkpoint</code></pre><p>如果修改源数据库以匹配分片行数据布局以准备迁移，则可能引入了不可见列。通过将<code class="codeph">MAPINVISIBLECOLUMNS</code>添加为复制过程参数，可以在复制过程中保留不可见列。
                     </p>
                     <p>在分片目录节点（catnode）上运行obey文件./dirprm/add_rpsh.oby。</p>
                     <p>此时，系统配置为数据迁移，无需停机。大部分负载由Data Pump导出（expdp）和import（impdp）数据库实用程序执行。导出和导入过程中的最终数据库更改由Oracle GoldenGate进程同步。请注意，Oracle GoldenGate Pump流程与任何数据泵流程无关。</p>
                     <p>在开始数据泵导出之前，必须为Oracle GoldenGate复制过程提供每个表的实例化提交序列号（CSN），这些表是数据泵导出的一部分。如前所述，这可以通过运行带有<code class="codeph">FLASBACK_SCN=scn_num</code> <code class="codeph">CONSISTENT=Y</code>和<code class="codeph">FLASBACK_SCN=scn_num</code> expdp来完成。可以使用以下语句获取<code class="codeph">FLASHBACK_SCN</code> 。
                     </p><pre class="pre codeblock"><code>从v $ database中选择current_scn;</code></pre><p>因为expdp是使用<code class="codeph">CONSISTENT=Y</code>运行的，所以所有表图像都显示为“scn_num”，因此复制过程可以从相同的位置启动，在本例中为CSN编号。
                     </p>
                     <p>对于分片目录节点上的replicat，相应的GGSCI命令可能如下所示。</p><pre class="pre codeblock"><code>START REPLICAT rpsh，AFTERCSN scn_num</code></pre><p>更简单的方法是在源节点上使用<code class="codeph">ADD SCHEMATRANDATA</code> GGSCI命令。此命令填充系统表和视图，以便可以在导入时使用实例化CSN。这样，Oracle GoldenGate CSN通过匹配表示数据库的已提交版本的两个戳记，与Data Pump SCN同步。换句话说，自动定义用于导出过程的<code class="codeph">FLASHBACK_SCN</code>和用于复制过程的<code class="codeph">AFTERCSN</code> ，如此处所示。
                     </p><pre class="pre codeblock"><code>ADD SCHEMATRANDATA uname PREPARESCN ALLCOLS</code></pre><p><code class="codeph">ADD SCHEMATRANDATA</code>命令为ORIG数据库的给定“uname”模式中的所有当前和未来表启用模式级补充日志记录，以自动记录Oracle GoldenGate用于行标识的键的超集。<code class="codeph">PREPARESCN</code>参数指示数据泵导出（expdp）自动生成操作， <code class="codeph">SET_INSTANTIATION_CSN</code>在导入（impdp）时为目标处的每个表设置实例化CSN（GGSCI命令， <code class="codeph">SET_INSTANTIATION_CSN</code> ）。<code class="codeph">ALLCOLS</code>参数为给定模式中的所有当前和未来表启用所有受支持的键和非键列的无条件补充日志记录。此选项可以记录计算依赖关系所需的密钥，以及筛选，冲突解决或其他目的所需的列。请务必注意，与分片相关的数据迁移仅限于特定的表集，而其他数据库（增量）更改不会传播到分片目录。
                     </p>
                     <p>应在启动数据泵导出之前停止目标数据库上的复制。始终应该是这种情况，因为目标数据库是从头开始创建的。此处显示了用于停止sahrd目录节点上的replicat进程的GGSCI命令。</p><pre class="pre codeblock"><code>停止REPLICAT rpsh</code></pre><p>此命令将保留下次启动复制过程时的同步状态，并确保Oracle GoldenGate管理器进程不会自动启动复制过程。</p>
                     <p>在启动数据泵导出之前，源数据库上的提取过程应处于活动状态。使用<code class="codeph">INFO EXTRACT</code>或<code class="codeph">STATUS EXTRACT</code>命令检查提取是否已处于活动<code class="codeph">STATUS EXTRACT</code> 。如果尚未启动，则以下命令将启动提取过程。
                     </p><pre class="pre codeblock"><code>开始提取exsh，现在开始</code></pre><p>从现在开始，提取进程将收集对分片过程中涉及的所有表的源数据库的更改，并且您可以安全地启动数据泵导出。</p><pre class="pre codeblock"><code>expdp uname / pwd @ orignode full = Y directory = expdir dumpfile = sample.dmp logfile = sample.log</code></pre><p>最好验证是否自动添加导出实用程序expdp <code class="codeph">FLASHBACK_SCN</code>参数。您应该能够在expdp命令输出中找到消息“FLASHBACK自动启用以保持数据库完整性”。导出完成后，立即继续在目标数据库上导入数据泵，如前面针对分片目录所述。
                     </p><pre class="pre codeblock"><code>impdp uname / pwd @ catnode：1521 / ctlg directory = data_pump_dir dumpfile = sample.dmp logfile = imp.log tables = Customers，Orders，LineItems，StockItems content = DATA_ONLY</code></pre><p>此时，在分片目录节点上启动复制进程是安全的。</p><pre class="pre codeblock"><code>START REPLICAT rpsh</code></pre><p>从此时起，源数据库中的选定表集（Customers，Orders，LineItems和StockItems）将与分片中的Customers，Orders和LineItems表以及分片目录数据库中的StockItems重复表同步。 。在启动复制过程之后，查看复制过程的报告文件是一种很好的做法。在导出过程中验证replicat进程是否知道数据库中存在的SCN或CSN编号，并且它知道现在需要在目标表上应用该SCN之后的任何更改，查找“实例化CSN过滤是在表uname上启用。客户，uname，订单，......“验证。</p>
                  </div>
                  <!-- class="section" -->
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：将</strong> <a href="sharding-loading-data.html#GUID-6140925F-6192-4C6F-9ADC-BC2332ADA3B0" title="您可以使用此处描述的方法将数据从非分片数据库迁移到Oracle Sharding分片数据库。">数据迁移到Sharded数据库</a></p>
                     </div>
                  </div>
               </div>
               
            </div>
            <div class="sect2"><a id="GUID-FD50835F-514F-4E74-95D3-BD0B4A6B0F20" name="GUID-FD50835F-514F-4E74-95D3-BD0B4A6B0F20"></a><h3 id="SHARD-GUID-FD50835F-514F-4E74-95D3-BD0B4A6B0F20" class="sect3"><span class="enumeration_section">9.7</span>迁移您的应用程序</h3>
               <div>
                  <p>分片数据库操作环境使应用程序能够直接访问分片。此功能提供了真正的线性可扩展性，但它的价格很低 - 对应用程序代码稍作改动。</p>
                  <p>以下示例向您展示如何迁移您的应用程序。这些示例是我们迁移数据库模式和数据的示例应用程序的框架。示例应用程序的关键部分包括订单管理和报告功能。包含在Java类POManager中。此类中的第一个静态方法使用addCustomer（）方法在Customers表中引入了一个新行。使用参数列表将列值传递给此函数，如此处所示。</p><pre class="pre codeblock"><code>import java.sql。*; import java.io.*; import oracle.jdbc.driver。*;公共类POManager {public static void addCustomer（int custNo，String custName，String street，String city，String state，String zipCode，String phoneNo）抛出SQLException {String sql =“INSERT INTO Customers VALUES（？，？，？，？， ？，？，？）“; try {Connection conn = DriverManager.getConnection（”jdbc：default：connection：“）; PreparedStatement pstmt = conn.prepareStatement（sql）; pstmt.setInt（1，custNo）; pstmt.setString（2，custName）; pstmt .setString（3，street）; pstmt.setString（4，city）; pstmt.setString（5，state）; pstmt.setString（6，zipCode）; pstmt.setString（7，phoneNo）; pstmt.executeUpdate（）; pstmt.close（）;} catch（SQLException e）{System.err.println（e.getMessage（））;}}</code></pre><p>POManager类中的第二个静态方法addStockItem（）在StockItem表中添加一行。列值作为参数值传递，如以下示例所示。</p><pre class="pre codeblock"><code>public static void addStockItem（int stockNo，String description，float price）抛出SQLException {String sql =“INSERT INTO StockItems VALUES（？，？，？）“; try {Connection conn = DriverManager.getConnection（”jdbc：default：connection：“）; PreparedStatement pstmt = conn.prepareStatement（sql）; pstmt.setInt（1，stockNo）; pstmt.setString（2，description）; pstmt .setFloat（3，price）; pstmt.executeUpdate（）; pstmt.close（）;} catch（SQLException e）{System.err.println（e.getMessage（））;}}</code></pre><p>POManager类中的第三个静态方法enterOrder（）在Orders表中添加一行。列值在参数列表中提供，如此处所示。</p><pre class="pre codeblock"><code>public static void enterOrder（int orderNo，int custNo，String orderDate，String shipDate，String toStreet，String toCity，String toState，String toZipCode）throws SQLException {String sql =“INSERT INTO ORERS VALUES（？，？，？，？，？ ，？，？，？）“; try {Connection conn = DriverManager.getConnection（”jdbc：default：connection：“）; PreparedStatement pstmt = conn.prepareStatement（sql）; pstmt.setInt（1，orderNo）; pstmt.setInt（2，custNo）; pstmt .setString（3，orderDate）; pstmt.setString（4，shipDate）; pstmt.setString（5，toStreet）; pstmt.setString（6，toCity）; pstmt.setString（7，toState）; pstmt.setString（8， toZipCode）; pstmt.executeUpdate（）; pstmt.close（）;} catch（SQLException e）{System.err.println（e.getMessage（））;}}</code></pre><p>POManager类中的下一个静态方法addLineItem（）在LineItems表中添加一行。列值作为参数值传入，如以下示例所示。</p><pre class="pre codeblock"><code>public static void addLineItem（int lineNo，int orderNo，int stockNo，int quantity，float discount）抛出SQLException {String sql =“INSERT INTO LineItems VALUES（？，？，？，？，？）“; try {Connection conn = DriverManager.getConnection（”jdbc：default：connection：“）; PreparedStatement pstmt = conn.prepareStatement（sql）; pstmt.setInt（1，lineNo）; pstmt.setInt（2，orderNo）; pstmt .setInt（3，stockNo）; pstmt.setInt（4，quantity）; pstmt.setFloat（5，discount）; pstmt.executeUpdate（）; pstmt.close（）;} catch（SQLException e）{System.err.println （e.getMessage（））;}}</code></pre><p>POManager类中的下一个静态方法totalOrders（）为Orders表中的每个订单生成总订单值。使用printResult（）方法打印出结果集关系，如下所示。</p><pre class="pre codeblock"><code>public static void totalOrders（）抛出SQLException {String sql =“SELECT O.PONo，ROUND（SUM（S.Price * L.Quantity））AS TOTAL”+“FROM Orders O，LineItems L，StockItems S”+“WHERE O .PONo = L.PONo AND L.StockNo = S.StockNo“+”GROUP by O.PONo“;尝试{Connection conn = DriverManager.getConnection（“jdbc：default：connection：”）; PreparedStatement pstmt = conn.prepareStatement（sql）; ResultSet rset = pstmt.executeQuery（）; printResults（RSET）; rset.close（）; pstmt.close（）; } catch（SQLException e）{System.err.println（e.getMessage（））;}}</code></pre><p>下面显示的辅助方法printResults（）用于打印totalOrders（）方法生成的结果集关系。对结果集关系的引用作为参数传递。</p><pre class="pre codeblock"><code>static void printResults（ResultSet rset）抛出SQLException {String buffer =“”;尝试{ResultSetMetaData meta = rset.getMetaData（）; int cols = meta.getColumnCount（），rows = 0; for（int i = 1; i &lt;= cols; i ++）{int size = meta.getPrecision（i）; String label = meta.getColumnLabel（i）; if（label.length（）&gt; size）size = label.length（）; while（label.length（）&lt;size）label + =“”; buffer = buffer + label +“”; } buffer = buffer +“\ n”; while（rset.next（））{rows ++; for（int i = 1; i &lt;= cols; i ++）{int size = meta.getPrecision（i）; String label = meta.getColumnLabel（i）;字符串值= rset.getString（i）; if（label.length（）&gt; size）size = label.length（）; while（value.length（）&lt;size）value + =“”; buffer = buffer + value +“”; } buffer = buffer +“\ n”; } if（rows == 0）buffer =“找不到数据！\ n“; System.out.println（buffer）;} catch（SQLException e）{System.err.println（e.getMessage（））;}}</code></pre><p>checkStockItem（）静态方法（如下所示）检索指定库存项目的所有订单，客户和行项目详细信息。库存项目作为参数传入。上面详述的辅助方法printResults（）用于打印checkStockItem（）方法生成的结果集关系。</p><pre class="pre codeblock"><code>public static void checkStockItem（int stockNo）抛出SQLException {String sql =“SELECT O.PONo，O.CustNo，L.StockNo，”+“L.LineNo，L.Quantity，L.Discount”+“FROM Orders O，LineItems L“+”在哪里O.PONo = L.PONo和L.StockNo =？“; try {Connection conn = DriverManager.getConnection（”jdbc：default：connection：“）; PreparedStatement pstmt = conn.prepareStatement（sql）; pstmt.setInt（1，stockNo）; ResultSet rset = pstmt.executeQuery（）; printResults （rset）; rset.close（）; pstmt.close（）;} catch（SQLException e）{System.err.println（e.getMessage（））;}}</code></pre><p>changeQuantity（）静态方法更新给定订单和库存项目的行项目数量。特定订单号和库存项目作为输入参数提供，如下所示。</p><pre class="pre codeblock"><code>public static void changeQuantity（int newQty，int orderNo，int stockNo）抛出SQLException {String sql =“UPDATE LineItems SET Quantity =？“+”PONo =？和StockNo =？“; try {Connection conn = DriverManager.getConnection（”jdbc：default：connection：“）; PreparedStatement pstmt = conn.prepareStatement（sql）; pstmt.setInt（1，newQty）; pstmt.setInt（2，orderNo）; pstmt .setInt（3，stockNo）; pstmt.executeUpdate（）; pstmt.close（）;} catch（SQLException e）{System.err.println（e.getMessage（））;}}</code></pre><p>最后一个静态方法deleteOrder（）从Orders表和所有关联的行项中删除指定的顺序。要删除的顺序被指定为输入参数，如以下示例所示。</p><pre class="pre codeblock"><code>public static void deleteOrder（int orderNo）抛出SQLException {String sql =“DELETE FROM LineItems WHERE PONo =？“; try {Connection conn = DriverManager.getConnection（”jdbc：default：connection：“）; PreparedStatement pstmt = conn.prepareStatement（sql）; pstmt.setInt（1，orderNo）; pstmt.executeUpdate（）; sql =”DELETE从订单那里PONO =？“;; pstmt = conn.prepareStatement（sql）; pstmt.setInt（1，orderNo）; pstmt.executeUpdate（）; pstmt.close（）;} catch（SQLException e）{System.err.println（e.getMessage（） ）;}}}</code></pre><p>现在，查看为分片修改的示例应用程序代码。首先要注意的是从OracleShardingKey开始，额外导入与分片相关的Java包。</p><pre class="pre codeblock"><code>import java.sql。*; import java.io.*; import oracle.jdbc.driver。*; // //导入分片和相关包//导入oracle.jdbc。OracleShardingKey; import oracle.jdbc。OracleType; import oracle.jdbc.pool。OracleDataSource; // //示例应用程序：订单管理和报告//为分片修改//公共类POManager {//示例应用程序私有OracleDataSource ods使用的分片数据库的连接工厂; // //使用Sharded数据库连接属性构造POManager类。//连接到分片数据库时使用服务名称，例如：//“jdbc：oracle：thin：@（DESCRIPTION =（ADDRESS =（HOST = myhost）（PORT = 3216）”//“（PROTOCOL = tcp）） （CONNECT_DATA =（SERVICE_NAME = myservice）（REGION = east）））“// public POManager（String yourURL，String yourUser，String yourPwd）抛出SQLException {ods = new OracleDataSource（）; ods.setURL（yourURL）; ods.setUser（yourUser）; ods.setPassword（yourPwd）; } // POManager</code></pre><p>如上所示，POManager类现在包含Connection对象的OracleDataSource工厂。以下两种方法向您展示如何使用连接工厂生成直接和代理路由连接。getCatConn（）方法返回与分片目录的连接。getShardConn（）方法返回与作为参数提供的分片键匹配的分片的连接。</p><pre class="pre codeblock"><code>// //连接到Sharding Catalog数据库。// public static Connection getCatConn（）throws SQLException {Connection catConn = ods.getConnection（）; } // getCatConn // //使用分片键连接到Shard数据库。// public static Connection getShardConn（int custNo）抛出SQLException {OracleShardingKey shardKey = ods.createShardingKeyBuilder（）。subkey（custNo，JDBCType。NUMERIC）.build（）; OracleConnection shardConn = ods.createConnectionBuilder（）。shardingKey（shardingKey）; return shardConn; } // getShardConn</code></pre><p>考虑到所有这些，您将使用getShardConn（）重写分片环境的addCustomer（）方法，如下所示。</p><pre class="pre codeblock"><code>// //连接到Shard数据库以添加客户。// public static void addCustomer（int custNo，String custName，String street，String city，String state，String zipCode，String phoneNo）抛出SQLException {String sql =“INSERT INTO Customers VALUES（？，？，？，？，？， ？，？）“; try {Connection conn = getShardConn（custNo）; PreparedStatement pstmt = conn.prepareStatement（sql）; pstmt.setInt（1，custNo）; pstmt.setString（2，custName）; pstmt.setString（3，street）; pstmt .setString（4，city）; pstmt.setString（5，state）; pstmt.setString（6，zipCode）; pstmt.setString（7，phoneNo）; pstmt.executeUpdate（）; pstmt.close（）;} catch（ SQLException e）{System.err.println（e.getMessage（））;}} // addCustomer</code></pre><p>在addStockItem（）中，使用getCatConn（）连接到分片目录数据库并插入到重复的表StockItems中。</p><pre class="pre codeblock"><code>// //连接到Sharding Catalog以添加库存项目。// public static void addStockItem（int stockNo，String description，float price）抛出SQLException {String sql =“INSERT INTO StockItems VALUES（？，？，？）“; try {Connection conn = getCatConn（）; PreparedStatement pstmt = conn.prepareStatement（sql）; pstmt.setInt（1，stockNo）; pstmt.setString（2，description）; pstmt.setFloat（3，price）; pstmt。 executeUpdate（）; pstmt.close（）;} catch（SQLException e）{System.err.println（e.getMessage（））;}} // addStockItem</code></pre><p>Orders表是Customers表的子表。要插入Orders表，请根据提供的分片键连接到分片数据库，如以下示例所示。</p><pre class="pre codeblock"><code>// //连接到Shard数据库以为客户添加订单。// public static void enterOrder（int orderNo，int custNo，String orderDate，String shipDate，String toStreet，String toCity，String toState，String toZipCode）throws SQLException {String sql =“INSERT INTO ORERS VALUES（？，？，？，？ ，？，？，？，？）“; try {Connection conn = getShardConn（custNo）; PreparedStatement pstmt = conn.prepareStatement（sql）; pstmt.setInt（1，orderNo）; pstmt.setInt（2，custNo）; pstmt.setString（3，orderDate）; pstmt .setString（4，shipDate）; pstmt.setString（5，toStreet）; pstmt.setString（6，toCity）; pstmt.setString（7，toState）; pstmt.setString（8，toZipCode）; pstmt.executeUpdate（）; pstmt.close（）;} catch（SQLException e）{System.err.println（e.getMessage（））;}} // enterOrder</code></pre><p>请注意，对于表族的根，客户和直接子级别Orders，分片kay作为参数提供。对于直接子级以下的级别，您可能没有完整级别的密钥，因此必须从直接父级检索它。在下面的示例中，有一个辅助方法getCustomerFromOrder（），用于根据Order表键值orderNo从Order表中检索分片键custNo。每个子表行都应该有一个父行。这就是为没有父母的孩子或有多个父母的孩子提出完整性违规例外的原因。</p><pre class="pre codeblock"><code>// //确定哪个分片顺序在// static int getCustomerFromOrder（int orderNo）抛出SQLException {String sql =“SELECT O.CustNo FROM Orders O”+“WHERE O.PONo =？“; int custNo; int rsSize = 0;异常异常;尝试{Connection conn = getCatConn（）; PreparedStatement pstmt = conn.prepareStatement（sql）; pstmt.setInt（1，orderNo）; PreparedStatement pstmt = conn.prepareStatement（sql） ; ResultSet rset = pstmt.executeQuery（）; while（rset.next（）&amp;&amp; rsSize &lt;3）{custNo = rs.getInt（“CustNo）; rsSize ++;} rset.close（）; pstmt.close（）;} catch （SQLException e）{System.err.println（e.getMessage（））;} if（rsSize == 0）{throw new SQLIntegrityConstraintViolationException（“No matching parent level key”）; if（rsSize == 2）{throw new SQLIntegrityConstraintViolationException（“多个父级别密钥”）;} return custNo;} // getCustomerFromOrder</code></pre><div class="infoboxnote" id="GUID-FD50835F-514F-4E74-95D3-BD0B4A6B0F20__GUID-E25A47B3-8BD7-429B-8E38-6D8B57CF34F4">
                     <p class="notep1">注意：</p>您的代码不应对分片数据库中的分片数做出任何假设。
                  </div>
                  <p>以下示例显示了原始POManager类中提供的重写的addLineItem（）方法，现在使用getCustomerFromOrder（）辅助方法。对于给定的orderNo，它查询分片目录以查找匹配的custNo值。查询的这一部分使用代理路由传播到所有分片。辅助函数返回单个custNo值。根据此值，使用到该分片的直接路由来插入LineItems表行。</p><pre class="pre codeblock"><code>// //从目录中获取客户（父级），然后插入碎片！// public static void addLineItem（int lineNo，int orderNo，int stockNo，int quantity，float discount）抛出SQLException {String sql =“INSERT INTO LineItems VALUES（？，？，？，？，？，？）“; try {int custNo = getCustomerFromOrder（orderNo）; Connection conn = getShardConn（custNo）; PreparedStatement pstmt = conn.prepareStatement（sql）; pstmt.setInt（1，custNo）; pstmt.setInt（2，lineNo）; pstmt。 setInt（3，orderNo）; pstmt.setInt（4，stockNo）; pstmt.setInt（5，quantity）; pstmt.setFloat（6，discount）; pstmt.executeUpdate（）; pstmt.close（）;} catch（SQLException） e）{System.err.println（e.getMessage（））;}} // addLineItem // //您可以使用整个关键字，直接插入分片。// public static void addLineItemWithinParent（int lineNo，int orderNo，int custNo，int stockNo，int quantity，float discount）抛出SQLException {String sql =“INSERT INTO LineItems VALUES（？，？，？，？，？，？）“; try {Connection conn = getShardConn（custNo）; PreparedStatement pstmt = conn.prepareStatement（sql）; pstmt.setInt（1，custNo）; pstmt.setInt（2，lineNo）; pstmt.setInt（3，orderNo）; pstmt .setInt（4，stockNo）; pstmt.setInt（5，quantity）; pstmt.setFloat（6，discount）; pstmt.executeUpdate（）; pstmt.close（）;} catch（SQLException e）{System.err.println （e.getMessage（））;}} // addLineItemWithinParent</code></pre><div class="infoboxnote" id="GUID-FD50835F-514F-4E74-95D3-BD0B4A6B0F20__GUID-E3F55FFD-25BA-4540-A3DE-00C6EA4C693E">
                     <p class="notep1">注意：</p>大多数情况下，应用程序上下文中将提供完整级别的键上下文。这就是为什么我们引入额外的方法addLineItemWithinParent（），它根据LineItems表复合级别键中的前导列custNo直接连接到分片。这消除了分片目录的往返。避免使用与我们的辅助函数类似的昂贵的分片编程实践：尽可能使用getCustomerFromOrder（）。
                  </div>
                  <p>必须使用分片目录连接执行大多数聚合查询。分片目录数据库使用代理路由来从分片收集部分结果。最终聚合是基于分片产生的部分结果产生的。这就是原始POManager类中引入的totalOrders（）方法被重写以连接到分片目录数据库的原因，如下所示。</p><pre class="pre codeblock"><code>// // xshard聚合连接到分片目录// public static void totalOrders（）throws SQLException {String sql =“SELECT O.PONo，ROUND（SUM（S.Price * L.Quantity））AS TOTAL”+“FROM订单O，LineItems L，StockItems S“+”WHERE O.PONo = L.PONo AND L.StockNo = S.StockNo“+”GROUP by O.PONo“;尝试{Connection conn = getCatConn（）; PreparedStatement pstmt = conn.prepareStatement（sql）; ResultSet rset = pstmt.executeQuery（）; printResults（RSET）; rset.close（）; pstmt.close（）; } catch（SQLException e）{System.err.println（e.getMessage（））;}} // totalOrders</code></pre><p>之前介绍的printResults（）辅助函数不依赖于数据库结构，因此不需要进行任何修改。</p><pre class="pre codeblock"><code>// //辅助函数 - 无需更改// static void printResults（ResultSet rset）抛出SQLException {String buffer =“”;尝试{ResultSetMetaData meta = rset.getMetaData（）; int cols = meta.getColumnCount（），rows = 0; for（int i = 1; i &lt;= cols; i ++）{int size = meta.getPrecision（i）; String label = meta.getColumnLabel（i）; if（label.length（）&gt; size）size = label.length（）; while（label.length（）&lt;size）label + =“”; buffer = buffer + label +“”; } buffer = buffer +“\ n”; while（rset.next（））{rows ++; for（int i = 1; i &lt;= cols; i ++）{int size = meta.getPrecision（i）; String label = meta.getColumnLabel（i）;字符串值= rset.getString（i）; if（label.length（）&gt; size）size = label.length（）; while（value.length（）&lt;size）value + =“”; buffer = buffer + value +“”; } buffer = buffer +“\ n”; } if（rows == 0）buffer =“找不到数据！\ n“; System.out.println（buffer）;} catch（SQLException e）{System.err.println（e.getMessage（））;}} // printResults</code></pre><p>StockItem表键列stockNo中的值可能与所有分片上的Order表行匹配。这就是为什么你必须修改原始POManager类中引入的checkStockItem（）方法来连接到分片目录。分片目录数据库返回由于在每个分片中执行本地连接而返回的所有行的并集。</p><pre class="pre codeblock"><code>// // xshard查询匹配重复表// public static void checkStockItem（int stockNo）抛出SQLException {String sql =“SELECT O.PONo，O.CustNo，L.StockNo，”+“L.LineNo，L.Quantity， L.Discount“+”FROM Orders O，LineItems L“+”WHERE O.PONo = L.PONo AND L.StockNo =？“; try {Connection conn = getCatConn（）; PreparedStatement pstmt = conn.prepareStatement（sql）; pstmt.setInt（1，stockNo）; ResultSet rset = pstmt.executeQuery（）; printResults（rset）; rset.close（）; pstmt.close（）;} catch（SQLException e）{System.err.println（e.getMessage（））;}} // checkStockItem</code></pre><p>原始POManager类中引入的changeQuantity（）方法更新了孙表LineItems。同样，使用getCustomerFromOrder（）辅助方法获取分片键，以便应用程序可以连接到正确的分片以执行更新。与addLineItem（）方法修改类似，您应该期望custNo列值在应用程序上下文中可用。这就是为什么你应该在changeQuantity（）中使用changeQuantifyWithinParent（），保存到分片目录的往返。</p><pre class="pre codeblock"><code>// //从目录中获取客户（父级）然后更新分片！// public static void changeQuantity（int newQty，int orderNo，int stockNo）抛出SQLException {String sql =“UPDATE LineItems SET Quantity =？“+”WHERE CustNo =？和PONo =？和StockNo =？“; try {int custNo = getCustomerFromOrder（orderNo）; Connection conn = getShardConn（custNo）; PreparedStatement pstmt = conn.prepareStatement（sql）; pstmt.setInt（1，newQty）; pstmt.setInt（2，custNo）; pstmt。 setInt（3，orderNo）; pstmt.setInt（4，stockNo）; pstmt.executeUpdate（）; pstmt.close（）;} catch（SQLException e）{System.err.println（e.getMessage（））;}} // changeQuantity // //您可以使用完整级别的密钥，直接更新分片。// public static void changeQuantityWithinParent（int newQty，int custNo，int orderNo，int stockNo）抛出SQLException {String sql =“UPDATE LineItems SET Quantity =？“+”WHERE CustNo =？和PONo =？和StockNo =？“; try {Connection conn = getShardConn（custNo）; PreparedStatement pstmt = conn.prepareStatement（sql）; pstmt.setInt（1，newQty）; pstmt.setInt（2，custNo）; pstmt.setInt（3，orderNo）; pstmt .setInt（4，stockNo）; pstmt.executeUpdate（）; pstmt.close（）;} catch（SQLException e）{System.err.println（e.getMessage（））;}} // changeQuantityWithinParent</code></pre><p>对最后一个方法deleteOrder（）的修改遵循应用于addLineItem（）和changeQuantity（）的相同指导原则。在从LineItems表中删除行之前，应用程序应首先在分片目录中查找与请求的顺序对应的custNo分片键值。获得分片键后，连接到分片并执行删除。同样，使用deleteOrderWithinParent（）方法，期望在应用程序上下文中提供分片键值。</p><pre class="pre codeblock"><code>// //首先从目录中获取客户（父级），在分片中删除！// public static void deleteOrder（int orderNo）throws SQLException {String sql =“DELETE FROM LineItems WHERE CustNo =？和PONo =？“; try {int custNo = getCustomerFromOrder（orderNo）; Connection conn = getShardConn（custNo）; PreparedStatement pstmt = conn.prepareStatement（sql）; pstmt.setInt（1，orderNo）; pstmt.executeUpdate（）; sql =”DELETE FROM订单在哪里PONo =？“;; pstmt = conn.prepareStatement（sql）; pstmt.setInt（1，custNo）; pstmt.setInt（2，orderNo）; pstmt.executeUpdate（）; pstmt.close（）;} catch（SQLException e）{System。 err.println（e.getMessage（））;}} // deleteOrder // //你已经得到了整个级别的密钥，直接在shard中删除// public static void deleteOrderWithinParent（int custNo，int orderNo）throws SQLException {String sql =“DELETE FROM LineItems WHERE CustNo =？和PONo =？“; try {Connection conn = getShardConn（custNo）; PreparedStatement pstmt = conn.prepareStatement（sql）; pstmt.setInt（1，orderNo）; pstmt.executeUpdate（）; sql =”DELETE FROM Orders WHERE PONo =？“;; pstmt = conn.prepareStatement（sql）; pstmt.setInt（1，custNo）; pstmt.setInt（2，orderNo）; pstmt.executeUpdate（）; pstmt.close（）;} catch（SQLException e）{System。 err.println（e.getMessage（））;}} // deleteOrderWithinParent} // POManager</code></pre></div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：将</strong> <a href="sharding-loading-data.html#GUID-6140925F-6192-4C6F-9ADC-BC2332ADA3B0" title="您可以使用此处描述的方法将数据从非分片数据库迁移到Oracle Sharding分片数据库。">数据迁移到Sharded数据库</a></p>
                     </div>
                  </div>
               </div>
               
            </div>
         </div>
      </article>
   </body>
</html>