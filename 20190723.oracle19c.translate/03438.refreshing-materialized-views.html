<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <title>刷新物化视图</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Data Warehousing Guide"></meta>
      <meta property="og:description" content=""></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Data Warehousing Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="database-data-warehousing-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-09T00:20:13-08:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="2001, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96243-01"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="advanced-materialized-views.html" title="Previous" type="text/html"></link>
      <link rel="next" href="synchronous-refresh.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Database Data Warehousing Guide"></meta>
    <meta name="dcterms.isVersionOf" content="DWHSG"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="advanced-materialized-views.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="synchronous-refresh.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">数据仓库指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="part-optimizing-dw.html" property="item" typeof="WebPage"><span property="name">优化数据仓库</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">刷新物化视图</li>
            </ol>
            <a id="GUID-64068234-BDB0-4C12-AE70-75571046A586" name="GUID-64068234-BDB0-4C12-AE70-75571046A586"></a>
            
            <h2 id="DWHSG-GUID-64068234-BDB0-4C12-AE70-75571046A586" class="sect2"><span class="enumeration_chapter">7</span>刷新物化视图</h2>
         </header>
         <div class="ind">
            <div>
               <p>本章讨论如何刷新实例化视图，这是在数据仓库环境中处理实例化视图时保持良好性能和一致数据的关键要素。</p>
               <p>本章包括以下部分：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="refreshing-materialized-views.html#GUID-E519B53C-ACD3-4253-811B-FBAB07AB8213" title="每次在任何物化视图的基表上执行DML操作时，都会自动刷新使用ON STATEMENT刷新模式的物化视图。Oracle数据库对使用近似查询定义的物化视图执行快速刷新。在使用DBMS_REDEFINITION包在线重新定义表时，可以执行依赖于正在重新定义的表的快速可刷新实体化视图的增量刷新。">关于刷新物化视图</a></p>
                  </li>
                  <li>
                     <p><a href="refreshing-materialized-views.html#GUID-E4E896C7-8173-4A36-A43F-188158981EB7">刷新物化视图的提示</a></p>
                  </li>
                  <li>
                     <p><a href="refreshing-materialized-views.html#GUID-7EA0FBD1-DCBD-4EBD-A131-59EE6ACC97B6">使用具有分区表的物化视图</a></p>
                  </li>
                  <li>
                     <p><a href="refreshing-materialized-views.html#GUID-4679957A-71E5-439E-BD8B-A0331F0631F2">使用分区来改进数据仓库刷新</a></p>
                  </li>
                  <li>
                     <p><a href="refreshing-materialized-views.html#GUID-2F0765F5-DDDA-4667-9629-6834A805CB13">在刷新期间优化DML操作</a></p>
                  </li>
               </ul>
            </div><a id="DWHSG03003"></a><div class="props_rev_3"><a id="GUID-E519B53C-ACD3-4253-811B-FBAB07AB8213" name="GUID-E519B53C-ACD3-4253-811B-FBAB07AB8213"></a><h3 id="DWHSG-GUID-E519B53C-ACD3-4253-811B-FBAB07AB8213" class="sect3"><span class="enumeration_section">7.1</span>关于刷新物化视图</h3>
               <div>
                  <p><a id="d29043e76" class="indexterm-anchor"></a><a id="d29043e80" class="indexterm-anchor"></a>数据库通过在更改基表后刷新数据来维护物化视图中的数据。
                  </p>
                  <p>执行刷新操作需要临时空间来重建索引，并且可能需要额外的空间来执行刷新操作本身。某些站点可能不希望同时刷新所有物化视图：只要更新了一些基础详细数据，使用此数据的所有物化视图都将变为陈旧。因此，如果您推迟刷新实体化视图，则可以依赖于所选的重写完整性级别来确定是否可以使用陈旧的实例化视图进行查询重写，或者可以使用<code class="codeph">ALTER</code> <code class="codeph">SYSTEM</code> <code class="codeph">SET</code>临时禁用查询重写<code class="codeph">QUERY_REWRITE_ENABLED = FALSE</code>声明。刷新实例化视图后，通过将<code class="codeph">ALTER</code> <code class="codeph">SYSTEM</code> <code class="codeph">SET</code> <code class="codeph">QUERY_REWRITE_ENABLED</code>指定为<code class="codeph">TRUE</code> ，可以重新启用查询重写作为当前数据库实例中所有会话的缺省值。刷新实例化视图会自动更新其所有索引。在完全刷新的情况下，这需要临时排序空间以在刷新期间重建所有索引。这是因为完全刷新会在插入新的完整数据卷之前截断或删除表。如果可用的临时空间不足以重建索引，则必须在执行刷新操作之前显式删除每个索引或将其标记为<code class="codeph">UNUSABLE</code> 。
                  </p>
                  <div class="section">
                     <p class="subhead2" id="GUID-E519B53C-ACD3-4253-811B-FBAB07AB8213__GUID-479E688B-D61B-45E8-B040-5D1B6B7F26C0">关于物化视图的刷新类型</p>
                     <p>刷新方法可以是增量或完全刷新。有两种增量刷新方法，称为基于日志的刷新和分区更改跟踪（PCT）刷新。增量刷新通常称为<code class="codeph">FAST</code>刷新，因为它通常比完全刷新执行得更快。
                     </p>
                     <p>当物化视图定义为<code class="codeph">BUILD</code> <code class="codeph">IMMEDIATE</code> ，最初创建完全刷新，除非物化视图引用预构建表或定义为<code class="codeph">BUILD</code> <code class="codeph">DEFERRED</code> 。用户可以在创建实例化视图后随时执行完整刷新。完整刷新涉及执行定义物化视图的查询。此过程可能很慢，尤其是在数据库必须读取和处理大量数据的情况下。
                     </p>
                     <p>增量刷新消除了从头开始重建物化视图的需要。因此，仅处理改变可以导致非常快的刷新时间。物化视图可以按需或定期刷新。或者，只要事务将其更改提交到基表，就可以刷新与其基表相同的数据库中的实例化视图。</p>
                     <p>对于使用基于日志的快速刷新方法的物化视图，物化视图日志和/或直接加载器日志会记录对基表的更改。物化视图日志是一种模式对象，它记录对基表的更改，以便可以递增地刷新在基表上定义的物化视图。每个物化视图日志都与单个基表相关联。物化视图日志与其基表位于相同的数据库和模式中。</p>
                     <p>如果修改的基表被分区并且修改的基表分区可用于识别物化视图中受影响的分区或数据部分，则可以使用PCT刷新方法。当基表上有一些分区维护操作时，这是唯一可以使用的增量刷新方法。PCT刷新会删除受影响的物化视图分区或受影响的数据部分中的所有数据，并从头开始重新计算它们。</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-E519B53C-ACD3-4253-811B-FBAB07AB8213__GUID-44977D69-68BF-46A4-A2FE-28EC3B573FF2"><span class="bold">关于物化视图的刷新模式</span></p>
                     <p>什么时候<a id="d29043e152" class="indexterm-anchor"></a>创建物化视图，您可以选择指定刷新是<code class="codeph">ON</code> <code class="codeph">DEMAND</code>还是“ <code class="codeph">ON</code> <code class="codeph">COMMIT</code> 。</p>
                     <p>如果您预期对物化视图引用的表执行插入，更新或删除操作，同时刷新该物化视图，并且该物化视图包括连接和聚合，Oracle建议您使用<code class="codeph">ON</code> <code class="codeph">COMMIT</code>快速刷新而不是<code class="codeph">ON</code> <code class="codeph">DEMAND</code>快速刷新。
                     </p>
                     <p>在<code class="codeph">ON</code> <code class="codeph">COMMIT</code>的情况下，每次事务提交时都会更改实例化视图，从而确保实体化视图始终包含最新数据。或者，您可以通过指定<code class="codeph">ON</code> <code class="codeph">DEMAND</code>来控制物化视图刷新的时间。对于<code class="codeph">ON</code> <code class="codeph">DEMAND</code>物化视图，可以使用<code class="codeph">DBMS_SYNC_REFRESH</code>或<code class="codeph">DBMS_MVIEW</code>包中提供的刷新方法执行刷新：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">DBMS_SYNC_REFRESH</code>程序包包含用于同步刷新的API，这是Oracle Database 12 <span class="italic">c</span> （第1版）中引入的新刷新方法。有关详细信息，请参阅<a href="synchronous-refresh.html#GUID-14730F6C-D96D-4AA3-A91E-9FBF456EC889">同步刷新</a> 。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">DBMS_MVIEW</code>包中包含其用法在本章中描述的API。刷新操作有三种基本类型：完全刷新，快速刷新和分区更改跟踪（PCT）刷新。Oracle Database <span class="italic">12c</span> ，Release 1中增强了这些基本类型，并增加了一个名为out-of-place refresh的新刷新选项。
                           </p>
                        </li>
                     </ul>
                     <p><code class="codeph">DBMS_MVIEW</code>包中包含三个用于执行刷新操作的API：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">DBMS_MVIEW.REFRESH</code> 
                           </p>
                           <p>刷新一个或多个物化视图。</p>
                        </li>
                        <li>
                           <p><code class="codeph">DBMS_MVIEW.REFRESH_ALL_MVIEWS</code></p>
                           <p>刷新所有物化视图。</p>
                        </li>
                        <li>
                           <p><code class="codeph">DBMS_MVIEW.REFRESH_DEPENDENT</code></p>
                           <p>刷新依赖于指定主表或物化视图或主表或物化视图列表的所有物化视图。</p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-E519B53C-ACD3-4253-811B-FBAB07AB8213__GUID-1EDAE461-5656-4797-98A6-B32B1594691C"><span class="bold">如何刷新物化视图？</span></p>
                     <p>对于每个刷新选项，您有两种技术可以执行刷新，即就地刷新和不适当刷新。就地刷新直接在物化视图上执行刷新语句。异地刷新创建一个或多个外部表，并在外部表上执行刷新语句，然后使用外部表切换物化视图或受影响的物化视图分区。就地刷新和不适当刷新在某些刷新场景中都可以获得良好的性能。但是，异地刷新可在刷新期间实现高物化视图可用性，尤其是在刷新语句需要很长时间才能完成时。</p>
                     <p>同样采用不合适的机制，在Oracle Database <span class="italic">12c</span> ，Release 1中引入了一种称为同步刷新的新刷新方法。它针对数据仓库中的常见使用场景，其中事实表及其物化视图以相同方式分区，或者它们的分区通过功能依赖关联。
                     </p>
                     <p>刷新方法使您可以保持一组表，并在它们上定义的物化视图始终保持同步。在此刷新方法中，用户不直接修改基表的内容，但必须使用同步刷新包提供的API，这些API将同时将这些更改应用于基表和物化视图，以确保它们的一致性。同步刷新方法非常适用于数据仓库，其中增量数据的加载受到严格控制并且定期发生。</p>
                     <div class="infoboxnotealso" id="GUID-E519B53C-ACD3-4253-811B-FBAB07AB8213__GUID-E94EF20D-ADDB-4A2E-93A0-324C4BFDF413">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="refreshing-materialized-views.html#GUID-51191C38-D52F-4A4D-B6FF-E631965AD69A">关于不合适的刷新选项</a></p>
                           </li>
                           <li>
                              <p>有关刷新多维数据集组织的物化视图的信息，请参阅<a href="../olaug/administering-oracle-olap.html#OLAUG700" target="_blank"><span><cite>“Oracle OLAP用户指南”</cite></span></a></p>
                           </li>
                        </ul>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div><a id="DWHSG8360"></a><div class="props_rev_3"><a id="GUID-A32EE00B-B369-44C3-AB5D-07403C0A44CD" name="GUID-A32EE00B-B369-44C3-AB5D-07403C0A44CD"></a><h4 id="DWHSG-GUID-A32EE00B-B369-44C3-AB5D-07403C0A44CD" class="sect4"><span class="enumeration_section">7.1.1</span>关于物化视图的完全刷新</h4>
                  <div>
                     <p><a id="d29043e307" class="indexterm-anchor"></a>除非物化视图引用预构建的表，否则在物化视图最初定义为<code class="codeph">BUILD</code> <code class="codeph">IMMEDIATE</code>时会发生完全刷新。对于使用<code class="codeph">BUILD</code> <code class="codeph">DEFERRED</code>物化视图，必须先请求完整刷新才能首次使用。在任何物化视图的生命周期内，可以随时请求完整刷新。刷新涉及读取详细信息表以计算实例化视图的结果。这可能是一个非常耗时的过程，尤其是在需要读取和处理大量数据的情况下。因此，您应该始终考虑在请求之前处理完整刷新所需的时间。
                     </p>
                     <p>但是，有一种情况是，对于已构建的物化视图可用的唯一刷新方法是完全刷新，因为物化视图不满足以下部分中指定的快速刷新条件。</p>
                  </div>
               </div><a id="DWHSG8361"></a><div class="props_rev_3"><a id="GUID-4FD1E4C6-B82F-4B13-880C-80187FA22AAF" name="GUID-4FD1E4C6-B82F-4B13-880C-80187FA22AAF"></a><h4 id="DWHSG-GUID-4FD1E4C6-B82F-4B13-880C-80187FA22AAF" class="sect4"><span class="enumeration_section">7.1.2</span>关于物化视图的快速刷新</h4>
                  <div>
                     <p><a id="d29043e345" class="indexterm-anchor"></a>大多数数据仓库都会定期对其详细数据进行增量更新。如<span class="q">“ <a href="basic-materialized-views.html#GUID-8FA00C38-B792-4B44-BDDF-1D80B2451F27">关于物化视图架构设计</a> ”中所述</span> ，您可以使用SQL * Loader或任何批量装入实用程序来执行增量加载的详细数据。快速刷新物化视图通常很有效，因为不必重新计算整个物化视图，而是将更改应用于现有数据。因此，仅处理改变可以导致非常快的刷新时间。
                     </p>
                  </div>
               </div><a id="DWHSG8362"></a><div class="props_rev_3"><a id="GUID-FE65EDEB-56AF-43CB-A7C2-06E74553E0CD" name="GUID-FE65EDEB-56AF-43CB-A7C2-06E74553E0CD"></a><h4 id="DWHSG-GUID-FE65EDEB-56AF-43CB-A7C2-06E74553E0CD" class="sect4"><span class="enumeration_section">7.1.3</span>关于物化视图的分区更改跟踪（PCT）刷新</h4>
                  <div>
                     <p>在详细信息表上进行了一些分区维护操作，这是可以使用的唯一快速刷新方法。仅当满足<span class="q">“ <a href="advanced-materialized-views.html#GUID-CE717BD7-15B7-4C8B-A172-6C50F5A802E1">关于分区更改跟踪</a> ”</span>中描述的所有条件时，才会启用基于PCT的物化视图刷新。
                     </p>
                     <p>如果没有对详细信息表进行分区维护操作，当您通过<code class="codeph">DBMS_MVIEW</code>程序包中的过程<code class="codeph">DBMS_MVIEW</code>刷新的<code class="codeph">FAST</code>方法（ <code class="codeph">method =&gt; 'F'</code> ）时，Oracle会在选择PCT刷新之前使用启发式规则尝试基于日志的规则快速刷新。同样，当您请求<code class="codeph">FORCE</code>方法时（ <code class="codeph">method =&gt; '?'</code> ），Oracle根据以下尝试顺序选择刷新方法：基于日志的快速刷新，PCT刷新和完全刷新。或者，您可以请求PCT方法（ <code class="codeph">method =&gt; 'P'</code> ），如果满足所有PCT要求，Oracle将使用PCT方法。
                     </p>
                     <p>如果Oracle满足<span class="q">“ <a href="advanced-materialized-views.html#GUID-1D0C81F8-6F6D-4E41-BEBC-A0F6B205A3AA">分割物化视图的优点</a> ”中</span>的条件，则可以在物化视图上使用<code class="codeph">TRUNCATE</code> <code class="codeph">PARTITION</code> ，从而使PCT刷新过程更有效。
                     </p>
                     <div class="infoboxnotealso" id="GUID-FE65EDEB-56AF-43CB-A7C2-06E74553E0CD__GUID-44E9C54C-91AF-45C6-9BEB-C337016E382C">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>有关分区更改跟踪的详细信息，请参阅<span class="q">“ <a href="advanced-materialized-views.html#GUID-CE717BD7-15B7-4C8B-A172-6C50F5A802E1">关于分区更改跟踪</a> ”</span></p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div>
               <div class="props_rev_3"><a id="GUID-51191C38-D52F-4A4D-B6FF-E631965AD69A" name="GUID-51191C38-D52F-4A4D-B6FF-E631965AD69A"></a><h4 id="DWHSG-GUID-51191C38-D52F-4A4D-B6FF-E631965AD69A" class="sect4"><span class="enumeration_section">7.1.4</span>关于<span class="enumeration_section">不合适</span>的刷新选项</h4>
                  <div>
                     <p>从Oracle Datab ase 12 <span class="italic">c</span> Release 1开始，可以使用新的刷新选项来提高物化视图刷新性能和可用性。此刷新选项称为异地刷新，因为它在刷新期间使用外部表，而不是直接将更改直接应用于实例化视图容器表的现有“就地”刷新。不合适的刷新选项适用于所有现有的刷新方法，例如<code class="codeph">FAST</code> （ <code class="codeph">'F'</code> ）， <code class="codeph">COMPLETE</code> （' <code class="codeph">C'</code> ）， <code class="codeph">PCT</code> （ <code class="codeph">'P'</code> ）和<code class="codeph">FORCE</code> （ <code class="codeph">'?'</code> ）。在处理具有大量数据更改的情况时，就地刷新尤其有效，其中传统的DML语句不能很好地扩展。它还使您能够实现非常高的可用性，因为正在刷新的物化视图可以在执行刷新语句期间用于直接访问和查询重写。此外，它有助于避免潜在的问题，例如物化视图容器表随着时间的推移变得碎片化或者看到中间刷新结果。
                     </p>
                     <p>在异地刷新中，物化视图的整个或受影响部分被计算到一个或多个外部表中。对于分区的物化视图，如果可以进行分区级别更改跟踪，并且在物化视图上定义了本地索引，则外部方法也会在外部表上构建相同的本地索引。通过在物化视图和外部表之间切换或在受影响的分区与外部表之间进行分区交换来完成此刷新过程。请注意，在切换或分区交换操作期间不支持查询重写。在刷新期间，外部表由直接加载填充，这是有效的。</p>
                     <p>本节包含以下主题：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="refreshing-materialized-views.html#GUID-0A1E1DC3-0881-4DF9-A388-5FF7A553D540">不合适刷新的类型</a></p>
                        </li>
                        <li>
                           <p><a href="refreshing-materialized-views.html#GUID-9B26B82B-AAA4-4270-9966-86B75CDE31F6">使用不合适刷新的限制和注意事项</a></p>
                        </li>
                     </ul>
                  </div><a id="DWHSG9416"></a><div class="props_rev_3"><a id="GUID-0A1E1DC3-0881-4DF9-A388-5FF7A553D540" name="GUID-0A1E1DC3-0881-4DF9-A388-5FF7A553D540"></a><h5 id="DWHSG-GUID-0A1E1DC3-0881-4DF9-A388-5FF7A553D540" class="sect5"><span class="enumeration_section">7.1.4.1不合适</span>刷新的类型</h5>
                     <div>
                        <p>有三种类型的异地刷新：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>不合时宜的快速刷新</p>
                              <p>这提供了比就地快速刷新更好的可用性。当更改影响物化视图的大部分时，它还提供更好的性能。</p>
                           </li>
                           <li>
                              <p>不合时宜的PCT更新</p>
                              <p>这提供了比就地PCT刷新更好的可用性。分区和非分区的物化视图有两种不同的方法。如果截断和直接加载不可行，则在更改相对较大时应使用不合适的刷新。如果截断和直接加载是可行的，就性能而言，就地刷新是优选的。在可用性方面，外部刷新总是更可取的。</p>
                           </li>
                           <li>
                              <p>不完整的刷新</p>
                              <p>这提供了比就地完全刷新更好的可用性。</p>
                           </li>
                        </ul>
                        <p>使用<code class="codeph">DBMS_MVIEW</code>包中的刷新接口， <code class="codeph">method</code> <code class="codeph">=</code> <code class="codeph">?</code> 并且<code class="codeph">out_of_place</code> <code class="codeph">=</code> <code class="codeph">true</code> ，首先尝试<code class="codeph">out_of_place</code>快速刷新，然后尝试<code class="codeph">out_of_place</code> PCT刷新，最后完成不完整的刷新。一个例子如下：</p><pre class="oac_no_warn" dir="ltr">DBMS_MVIEW.REFRESH（'CAL_MONTH_SALES_MV'，method =&gt;'？'，atomic_refresh =&gt; FALSE，out_of_place =&gt; TRUE）;</pre></div>
                  </div><a id="DWHSG9082"></a><div class="props_rev_3"><a id="GUID-9B26B82B-AAA4-4270-9966-86B75CDE31F6" name="GUID-9B26B82B-AAA4-4270-9966-86B75CDE31F6"></a><h5 id="DWHSG-GUID-9B26B82B-AAA4-4270-9966-86B75CDE31F6" class="sect5"><span class="enumeration_section">7.1.4.2使用不合适</span>刷新的限制和注意事项</h5>
                     <div>
                        <div class="section">
                           <p>使用相应的就地刷新时，就地刷新具有所有限制。此外，它还有以下限制：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>仅允许物化连接视图和物化聚合视图</p>
                              </li>
                              <li>
                                 <p>不允许<code class="codeph">ON</code> <code class="codeph">COMMIT</code>刷新</p>
                              </li>
                              <li>
                                 <p>不允许使用远程物化视图，立方体物化视图，对象物化视图</p>
                              </li>
                              <li>
                                 <p>不允许<code class="codeph">LOB</code>列</p>
                              </li>
                              <li>
                                 <p>如果在物化视图上定义了物化视图日志，触发器或约束（ <code class="codeph">NOT</code> <code class="codeph">NULL</code>除外），则不允许</p>
                              </li>
                              <li>
                                 <p>如果物化视图包含<code class="codeph">CLUSTERING</code>子句，则不允许</p>
                              </li>
                              <li>
                                 <p>不适用于在<code class="codeph">CREATE</code>或<code class="codeph">ALTER</code> <code class="codeph">MATERIALIZED</code> <code class="codeph">VIEW</code>会话或<code class="codeph">ALTER</code> <code class="codeph">TABLE</code>会话中完成刷新</p>
                              </li>
                              <li>
                                 <p>不允许使用原子模式。如果指定<code class="codeph">atomic_refresh</code>为<code class="codeph">TRUE</code>和<code class="codeph">out_of_place</code>为<code class="codeph">TRUE</code> ，则显示错误</p>
                              </li>
                           </ul>
                           <p>对于不合适的PCT刷新，有以下限制：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>不允许<code class="codeph">UNION</code> <code class="codeph">ALL</code>或分组集</p>
                              </li>
                           </ul>
                           <p>对于不合适的快速刷新，有以下限制：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>不允许<code class="codeph">UNION</code> <code class="codeph">ALL</code> ，分组集或外部联接</p>
                              </li>
                              <li>
                                 <p>当使用混合DML语句修改多个基表时，不允许物化连接视图</p>
                              </li>
                           </ul>
                           <p>异地刷新需要额外存储外部表和索引以进行刷新。因此，您必须有足够的可用表空间或自动扩展打开。</p>
                           <p>异地PCT刷新中的分区交换会影响物化视图上的全局索引。因此，如果在物化视图容器表中定义了全局索引，Oracle会在执行分区交换之前禁用全局索引，并在分区交换后重建全局索引。这种重建是额外的开销。</p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="DWHSG8363"></a><div class="props_rev_3"><a id="GUID-587D67C7-CD96-44CA-8B3B-597C39247F31" name="GUID-587D67C7-CD96-44CA-8B3B-597C39247F31"></a><h4 id="DWHSG-GUID-587D67C7-CD96-44CA-8B3B-597C39247F31" class="sect4"><span class="enumeration_section">7.1.5</span>关于物化视图的ON COMMIT刷新</h4>
                  <div>
                     <p>可以使用<code class="codeph">ON</code> <code class="codeph">COMMIT</code>方法自动刷新实例化视图。因此，每当事务提交更新了定义了物化视图的表时，这些更改将自动反映在物化视图中。使用此方法的优点是您永远不必记住刷新物化视图。唯一的缺点是，由于涉及额外的处理，完成提交所需的时间会稍长。但是，在数据仓库中，这应该不是问题，因为尝试更新同一个表的并发进程不太可能。
                     </p>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-C40C225A-8328-44D5-AE90-9078C2C773EA" name="GUID-C40C225A-8328-44D5-AE90-9078C2C773EA"></a><h4 id="DWHSG-GUID-C40C225A-8328-44D5-AE90-9078C2C773EA" class="sect4"><span class="enumeration_section">7.1.6</span>关于物化视图的ON STATEMENT刷新</h4>
                  <div>
                     <p>每次在任何物化视图的基表上执行DML操作时，都会自动刷新使用<code class="codeph">ON STATEMENT</code>刷新模式的物化视图。
                     </p>
                     <p></p>
                     <p>使用<code class="codeph">ON STATEMENT</code>刷新模式，对基表的任何更改都会立即反映在物化视图中。无需在基表上提交事务或维护物化视图日志。如果随后回滚DML语句，则还会回滚对实例化视图所做的相应更改。
                     </p>
                     <p>要使用<code class="codeph">ON STATEMENT</code>刷新模式，必须可以快速刷新实例化视图。在事实表的<code class="codeph">ROWID</code>列上自动创建索引，以提高快速刷新性能。
                     </p>
                     <p><code class="codeph">ON STATEMENT</code>刷新模式的优点是物化视图始终与基表中的数据同步，而不会产生维护物化视图日志的开销。但是，此模式可能会增加执行DML操作所需的时间，因为实体化视图正在作为DML操作的一部分进行刷新。
                     </p>
                     <div class="infoboxnotealso" id="GUID-C40C225A-8328-44D5-AE90-9078C2C773EA__GUID-6356C591-60A0-40BF-978A-5D2D5B8CE2CF">
                        <p class="notep1">也可以看看：</p>
                        <p>用于<code class="codeph">ON STATEMENT</code>子句限制的<a href="../sqlrf/CREATE-MATERIALIZED-VIEW.html#SQLRF-GUID-EE262CA4-01E5-4618-B659-6165D993CA1B" target="_blank"><span><cite>Oracle数据库SQL语言参考</cite></span></a></p>
                     </div>
                     <div class="example" id="GUID-C40C225A-8328-44D5-AE90-9078C2C773EA__GUID-BB529D99-C057-4E97-8615-9B56A4B973DC">
                        <p class="titleinexample">示例7-1使用ON STATEMENT刷新创建物化视图</p>
                        <p>此示例创建一个物化视图<code class="codeph">sales_mv_onstat</code> ，该视图使用<code class="codeph">ON STATEMENT</code>刷新模式，并基于<code class="codeph">sh.sales</code> ， <code class="codeph">sh.customers</code>和<code class="codeph">sh.products</code>表。在任何基表上执行DML操作时，将自动刷新实例化视图。在DML操作之后，不需要提交来刷新实例化视图。
                        </p><pre class="pre codeblock"><code>创建物化视图sales_mv_onstat使用TRUSTED CONSTRAINT作为SELECT快速刷新语句s.rowid sales_rid，c.cust_first_name first_name，c.cust_last_name last_name，p.prod_name prod_name，s.quantity_sold quantity_sold，s.amount_sold amount_sold FROM sh.sales s，sh。客户c，sh.products p WHERE s.cust_id = c.cust_id和s.prod_id = p.prod_id;</code></pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="DWHSG8365"></a><a id="DWHSG8364"></a><div class="props_rev_3"><a id="GUID-6EEA28AC-503B-4526-AD56-85378B547971" name="GUID-6EEA28AC-503B-4526-AD56-85378B547971"></a><h4 id="DWHSG-GUID-6EEA28AC-503B-4526-AD56-85378B547971" class="sect4"><span class="enumeration_section">7.1.7</span>关于使用DBMS_MVIEW包进行手动刷新</h4>
                  <div>
                     <p>当物化视图是REF reshed <code class="codeph">ON</code> <code class="codeph">DEMAND</code> ，如图所示，下表中的4种刷新方法之一可以被指定。您可以在创建物化视图期间定义默认选项。<a href="refreshing-materialized-views.html#GUID-6EEA28AC-503B-4526-AD56-85378B547971__I1008349" title="此表描述了物化视图的各种ON DEMAND刷新方法。">表7-1</a>详细介绍了刷新选项。
                     </p>
                     <div class="tblformal" id="GUID-6EEA28AC-503B-4526-AD56-85378B547971__I1008349">
                        <p class="titleintable">表7-1 ON DEMAND刷新方法</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="ON DEMAND刷新方法" width="100%" border="1" summary="This table describes the various ON DEMAND refresh methods for materialized view." frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="17%" id="d29043e859">刷新选项</th>
                                 <th align="left" valign="bottom" width="17%" id="d29043e862">参数</th>
                                 <th align="left" valign="bottom" width="67%" id="d29043e865">描述</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="17%" id="d29043e870" headers="d29043e859 ">
                                    <p><code class="codeph">完成</code></p>
                                 </td>
                                 <td align="left" valign="top" width="17%" headers="d29043e870 d29043e862 ">
                                    <p><code class="codeph">C</code></p>
                                 </td>
                                 <td align="left" valign="top" width="67%" headers="d29043e870 d29043e865 ">
                                    <p>通过重新计算实例化视图的定义查询来刷新。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="17%" id="d29043e882" headers="d29043e859 ">
                                    <p><code class="codeph">快速</code></p>
                                 </td>
                                 <td align="left" valign="top" width="17%" headers="d29043e882 d29043e862 ">
                                    <p><code class="codeph">F</code></p>
                                 </td>
                                 <td align="left" valign="top" width="67%" headers="d29043e882 d29043e865 ">
                                    <p>通过逐步将更改应用于实例化视图来刷新。</p>
                                    <p>对于本地物化视图，它选择优化器估计的最有效的刷新方法。考虑的刷新方法是基于日志的<code class="codeph">FAST</code>和<code class="codeph">FAST_PCT</code> 。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="17%" id="d29043e902" headers="d29043e859 ">
                                    <p><code class="codeph">FAST_PCT</code></p>
                                 </td>
                                 <td align="left" valign="top" width="17%" headers="d29043e902 d29043e862 ">
                                    <p><code class="codeph">P</code></p>
                                 </td>
                                 <td align="left" valign="top" width="67%" headers="d29043e902 d29043e865 ">
                                    <p>通过重新计算详细信息表中受更改的分区影响的实例化视图中的行来刷新。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="17%" id="d29043e914" headers="d29043e859 ">
                                    <p><code class="codeph">力</code></p>
                                 </td>
                                 <td align="left" valign="top" width="17%" headers="d29043e914 d29043e862 ">
                                    <p><code class="codeph">？</code></p>
                                 </td>
                                 <td align="left" valign="top" width="67%" headers="d29043e914 d29043e865 ">
                                    <p>尝试快速刷新。如果那是不可能的，它会完全刷新。</p>
                                    <p>对于本地物化视图，它选择优化器估计的最有效的刷新方法。考虑的刷新方法是基于日志的<code class="codeph">FAST</code> ， <code class="codeph">FAST_PCT</code>和<code class="codeph">COMPLETE</code> 。</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <p><a id="d29043e937" class="indexterm-anchor"></a> <code class="codeph">DBMS_MVIEW</code>包中提供了三个刷新过程，用于执行<code class="codeph">ON</code> <code class="codeph">DEMAND</code>刷新。每个都有自己独特的参数集。
                     </p>
                     <div class="infoboxnotealso" id="GUID-6EEA28AC-503B-4526-AD56-85378B547971__GUID-842C6F74-F828-411A-B860-F7E617DB5663">
                        <p class="notep1">也可以看看：</p>
                        <p>有关<code class="codeph">DBMS_MVIEW</code>包的详细信息，请<code class="codeph">DBMS_MVIEW</code> <a href="../arpls/DBMS_MVIEW.html#ARPLS027" target="_blank"><span><cite>Oracle Database PL / SQL包和类型参考</cite></span></a></p>
                     </div>
                  </div>
               </div><a id="DWHSG8366"></a><div class="props_rev_3"><a id="GUID-EB813C4E-FEE4-4E4C-AAB8-9A34F8EB8D3C" name="GUID-EB813C4E-FEE4-4E4C-AAB8-9A34F8EB8D3C"></a><h4 id="DWHSG-GUID-EB813C4E-FEE4-4E4C-AAB8-9A34F8EB8D3C" class="sect4"><span class="enumeration_section">7.1.8</span>使用REFRESH刷新特定的物化视图</h4>
                  <div>
                     <div class="section">
                        <p>使用<code class="codeph">DBMS_MVIEW.REFRESH</code>过程刷新一个或多个物化视图。某些参数仅用于复制，因此这里不再提及。使用此过程所需的参数是：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p>要刷新的以逗号分隔的物化视图列表</p>
                           </li>
                           <li>
                              <p>刷新方法： <code class="codeph">F</code> <code class="codeph">P</code> Fast， <code class="codeph">P</code> -Fast_PCT , <code class="codeph">?</code> - 强制， <code class="codeph">C</code> - 完成</p>
                           </li>
                           <li>
                              <p>要使用的回滚段</p>
                           </li>
                           <li>
                              <p>错误后刷新（ <code class="codeph">TRUE</code>或<code class="codeph">FALSE</code> ）</p>
                              <p>布尔参数。如果设置为<code class="codeph">TRUE</code> ，则<code class="codeph">number_of_failures</code>输出参数设置为失败的刷新次数，并且一般错误消息指示发生了故障。实例的警报日志提供了刷新错误的详细信息。如果设置为<code class="codeph">FALSE</code> （默认值），则刷新在遇到第一个错误后停止，并且列表中任何剩余的物化视图都不会刷新。
                              </p>
                           </li>
                           <li>
                              <p>复制过程使用以下四个参数。对于仓库刷新，将它们设置为<code class="codeph">FALSE, 0,0,0</code> 。
                              </p>
                           </li>
                           <li>
                              <p>原子刷新（ <code class="codeph">TRUE</code>或<code class="codeph">FALSE</code> ）</p>
                              <p>如果设置为<code class="codeph">TRUE</code> ，则所有刷新都在一个事务中完成。如果设置为<code class="codeph">FALSE</code> ，则每个物化视图在单独的事务中以非原子方式刷新。如果设置为<code class="codeph">FALSE</code> ，Oracle可以通过使用并行DML优化刷新并在物化视图上截断DDL。在原子模式下刷新<code class="codeph">stale_tolerated</code>化视图时，如果重写完整性模式设置为<code class="codeph">stale_tolerated</code> ，则符合查询重写的<code class="codeph">stale_tolerated</code> 。在嵌套视图上执行刷新时，无法保证原子刷新。
                              </p>
                           </li>
                           <li>
                              <p>是否使用不合适的刷新</p>
                              <p>此参数适用于所有现有刷新方法（ <code class="codeph">F</code> ， <code class="codeph">P</code> ， <code class="codeph">C</code> <code class="codeph">?</code> ）。因此，例如，如果指定<code class="codeph">F</code>并且<code class="codeph">out_of_place</code> <code class="codeph">=</code> <code class="codeph">true</code> ，则尝试进行<code class="codeph">out_of_place</code>快速刷新。同样，如果指定<code class="codeph">P</code>并且<code class="codeph">out_of_place</code> <code class="codeph">=</code> <code class="codeph">true</code> ，则尝试进行异地PCT刷新。
                              </p>
                           </li>
                        </ul>
                        <p>例如，要在物化视图<code class="codeph">cal_month_sales_mv</code>上执行快速刷新， <code class="codeph">DBMS_MVIEW</code>如下方式调用<code class="codeph">DBMS_MVIEW</code>包：</p><pre class="oac_no_warn" dir="ltr">DBMS_MVIEW.REFRESH（'CAL_MONTH_SALES_MV'，'F'，''，TRUE，FALSE，0,0,0，FALSE，FALSE）;</pre><p>可以同时刷新多个物化视图，并且它们不必都使用相同的刷新方法。要为它们提供不同的刷新方法，请按照与物化视图列表相同的顺序指定多个方法代码（不带逗号）。例如，下面指定该<code class="codeph">cal_month_sales_mv</code>完全刷新， <code class="codeph">fweek_pscat_sales_mv</code>收到一个快速刷新：</p><pre class="oac_no_warn" dir="ltr">DBMS_MVIEW.REFRESH（'CAL_MONTH_SALES_MV，FWEEK_PSCAT_SALES_MV'，'CF'，''，TRUE，FALSE，0,0,0，FALSE，FALSE）;</pre><p>如果未指定refresh方法，则使用在实例化视图定义中指定的默认刷新方法。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="DWHSG8367"></a><div class="props_rev_3"><a id="GUID-A927CEA3-D02D-4871-955D-86E965BC03C4" name="GUID-A927CEA3-D02D-4871-955D-86E965BC03C4"></a><h4 id="DWHSG-GUID-A927CEA3-D02D-4871-955D-86E965BC03C4" class="sect4"><span class="enumeration_section">7.1.9</span>使用REFRESH_ALL_MVIEWS刷新所有物化视图</h4>
                  <div>
                     <div class="section">
                        <p><a id="d29043e1148" class="indexterm-anchor"></a>指定要刷新的<code class="codeph">DBMS_MVIEW.REFRESH_ALL_MVIEWS</code>化视图的替代方法是使用过程<code class="codeph">DBMS_MVIEW.REFRESH_ALL_MVIEWS</code> 。此过程刷新所有物化视图。如果任何物化视图无法刷新，则报告故障数。
                        </p>
                        <p>此过程的参数是：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p>失败次数（这是一个<code class="codeph">OUT</code>变量）</p>
                           </li>
                           <li>
                              <p>刷新方法： <code class="codeph">F</code> <code class="codeph">P</code> Fast， <code class="codeph">P</code> -Fast_PCT , <code class="codeph">?</code> - 强制， <code class="codeph">C</code> - 完成</p>
                           </li>
                           <li>
                              <p>错误后刷新（ <code class="codeph">TRUE</code>或<code class="codeph">FALSE</code> ）</p>
                              <p>布尔参数。如果设置为<code class="codeph">TRUE</code> ，则<code class="codeph">number_of_failures</code>输出参数设置为失败的刷新次数，并且一般错误消息指示发生了故障。实例的警报日志提供了刷新错误的详细信息。如果设置为<code class="codeph">FALSE</code> ，则默认设置，然后刷新在遇到第一个错误后停止，并且列表中任何剩余的实体化视图不会刷新。
                              </p>
                           </li>
                           <li>
                              <p>原子刷新（ <code class="codeph">TRUE</code>或<code class="codeph">FALSE</code> ）</p>
                              <p>如果设置为<code class="codeph">TRUE</code> ，则所有刷新都在一个事务中完成。如果设置为<code class="codeph">FALSE</code> ，则每个物化视图在单独的事务中以非原子方式刷新。如果设置为<code class="codeph">FALSE</code> ，Oracle可以通过使用并行DML优化刷新并在物化视图上截断DDL。在原子模式下刷新<code class="codeph">stale_tolerated</code>化视图时，如果重写完整性模式设置为<code class="codeph">stale_tolerated</code> ，则符合查询重写的<code class="codeph">stale_tolerated</code> 。在嵌套视图上执行刷新时，无法保证原子刷新。
                              </p>
                           </li>
                           <li>
                              <p>是否使用不合适的刷新</p>
                              <p>此参数适用于所有现有刷新方法（ <code class="codeph">F</code> ， <code class="codeph">P</code> ， <code class="codeph">C</code> <code class="codeph">?</code> ）。因此，例如，如果指定<code class="codeph">F</code>并且<code class="codeph">out_of_place</code> <code class="codeph">=</code> <code class="codeph">true</code> ，则尝试进行<code class="codeph">out_of_place</code>快速刷新。同样，如果指定<code class="codeph">P</code>并且<code class="codeph">out_of_place</code> <code class="codeph">=</code> <code class="codeph">true</code> ，则尝试进行异地PCT刷新。
                              </p>
                           </li>
                        </ul>
                        <p>刷新所有物化视图的示例如下：</p><pre class="oac_no_warn" dir="ltr">DBMS_MVIEW.REFRESH_ALL_MVIEWS（失败，'C'，''，TRUE，FALSE，FALSE）;</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="DWHSG8368"></a><div class="props_rev_3"><a id="GUID-2A3AE420-9B99-4F52-A1E3-8F56B7563B2B" name="GUID-2A3AE420-9B99-4F52-A1E3-8F56B7563B2B"></a><h4 id="DWHSG-GUID-2A3AE420-9B99-4F52-A1E3-8F56B7563B2B" class="sect4"><span class="enumeration_section">7.1.10</span>使用REFRESH_DEPENDENT刷新相关的物化视图</h4>
                  <div>
                     <div class="section">
                        <p><a id="d29043e1293" class="indexterm-anchor"></a>第三个过程<code class="codeph">DBMS_MVIEW.REFRESH_DEPENDENT</code>仅刷新依赖于特定表或表列表的物化视图。例如，假设已收到<code class="codeph">orders</code>表的更改，但未收到<code class="codeph">customer</code>付款的更改。可以调用与刷新相关的过程以仅刷新引用<code class="codeph">orders</code>表的那些物化视图。
                        </p>
                        <p>此过程的参数是：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p>失败次数（这是一个<code class="codeph">OUT</code>变量）</p>
                           </li>
                           <li>
                              <p>从属表</p>
                           </li>
                           <li>
                              <p>刷新方法： <code class="codeph">F</code> <code class="codeph">P</code> Fast， <code class="codeph">P</code> -Fast_PCT , <code class="codeph">?</code> - 强制， <code class="codeph">C</code> - 完成</p>
                           </li>
                           <li>
                              <p>要使用的回滚段</p>
                           </li>
                           <li>
                              <p>错误后刷新（ <code class="codeph">TRUE</code>或<code class="codeph">FALSE</code> ）</p>
                              <p>布尔参数。如果设置为<code class="codeph">TRUE</code> ，则<code class="codeph">number_of_failures</code>输出参数设置为失败的刷新次数，并且一般错误消息指示发生了故障。实例的警报日志提供了刷新错误的详细信息。如果设置为<code class="codeph">FALSE</code> ，则默认设置，然后刷新在遇到第一个错误后停止，并且列表中任何剩余的实体化视图都不会刷新。
                              </p>
                           </li>
                           <li>
                              <p>原子刷新（ <code class="codeph">TRUE</code>或<code class="codeph">FALSE</code> ）</p>
                              <p>如果设置为<code class="codeph">TRUE</code> ，则所有刷新都在一个事务中完成。如果设置为<code class="codeph">FALSE</code> ，则每个物化视图在单独的事务中以非原子方式刷新。如果设置为<code class="codeph">FALSE</code> ，Oracle可以通过使用并行DML优化刷新并在物化视图上截断DDL。在原子模式下刷新<code class="codeph">stale_tolerated</code>化视图时，如果重写完整性模式设置为<code class="codeph">stale_tolerated</code> ，则符合查询重写的<code class="codeph">stale_tolerated</code> 。在嵌套视图上执行刷新时，无法保证原子刷新。
                              </p>
                           </li>
                           <li>
                              <p>是否嵌套</p>
                              <p>如果设置为<code class="codeph">TRUE</code> ，则根据依赖关系顺序刷新指定表集的所有从属物化视图，以确保物化视图相对于基础基表真正新鲜。
                              </p>
                           </li>
                           <li>
                              <p>是否使用不合适的刷新</p>
                              <p>此参数适用于所有现有刷新方法（ <code class="codeph">F</code> ， <code class="codeph">P</code> ， <code class="codeph">C</code> <code class="codeph">?</code> ）。因此，例如，如果指定<code class="codeph">F</code>并且<code class="codeph">out_of_place</code> <code class="codeph">=</code> <code class="codeph">true</code> ，则尝试进行<code class="codeph">out_of_place</code>快速刷新。同样，如果指定<code class="codeph">P</code>并且<code class="codeph">out_of_place</code> <code class="codeph">=</code> <code class="codeph">true</code> ，则尝试进行异地PCT刷新。
                              </p>
                           </li>
                        </ul>
                        <p>要在引用<code class="codeph">customers</code>表的所有物化视图上执行完全刷新，请指定：</p><pre class="oac_no_warn" dir="ltr">DBMS_MVIEW.REFRESH_DEPENDENT（失败，'CUSTOMERS'，'C'，''，FALSE，FALSE，FALSE）;</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="DWHSG8369"></a><div class="props_rev_3"><a id="GUID-EEB31BA4-AD51-4A90-8FB0-2238F5A41817" name="GUID-EEB31BA4-AD51-4A90-8FB0-2238F5A41817"></a><h4 id="DWHSG-GUID-EEB31BA4-AD51-4A90-8FB0-2238F5A41817" class="sect4"><span class="enumeration_section">7.1.11</span>关于使用作业队列进行刷新</h4>
                  <div>
                     <p>作业队列可用于并行刷新多个物化视图。如果队列不可用，则快速刷新会依次刷新前台进程中的每个视图。要使队列可用，必须设置<code class="codeph">JOB_QUEUE_PROCESSES</code>参数。此参数定义后台作业队列进程的数量，并确定可以同时刷新多少物化视图。Oracle尝试平衡并发刷新的数量与每次刷新的并行度。刷新实例化视图的顺序取决于嵌套<span class="q"><a href="refreshing-materialized-views.html#GUID-18BA80A4-C156-4884-96C0-6ECEC4BB6B8A">实体化视图</a></span>强加的依赖关系，以及通过对其他<span class="q"><a href="refreshing-materialized-views.html#GUID-18BA80A4-C156-4884-96C0-6ECEC4BB6B8A">实体化视图</a></span>使用查询重写来实现高效刷新的可能性（有关详细信息，请参阅<span class="q">“ <a href="refreshing-materialized-views.html#GUID-18BA80A4-C156-4884-96C0-6ECEC4BB6B8A">调度物化视图的刷新</a> ”</span> ）。此参数仅在<code class="codeph">atomic_refresh</code>设置为<code class="codeph">FALSE</code>时有效。</p>
                     <p><a id="d29043e1479" class="indexterm-anchor"></a>如果正在执行<code class="codeph">DBMS_MVIEW.REFRESH</code>的进程中断或实例已关闭，则在作业队列进程中执行的所有刷新作业都将重新排队并继续运行。要删除这些作业，请使用<code class="codeph">DBMS_JOB.REMOVE</code>过程。
                     </p>
                     <div class="infoboxnotealso" id="GUID-EEB31BA4-AD51-4A90-8FB0-2238F5A41817__GUID-1AA9BC52-C060-47B9-B209-0937DC57042A">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>有关<code class="codeph">DBMS_JOB</code>包的详细信息，请<a href="../arpls/DBMS_JOB.html#ARPLS019" target="_blank"><span><cite>参见Oracle Database PL / SQL包和类型参考</cite></span></a></p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="DWHSG8370"></a><div class="props_rev_3"><a id="GUID-E7F71AF0-8AF4-4DA5-B08A-A1F6733213DD" name="GUID-E7F71AF0-8AF4-4DA5-B08A-A1F6733213DD"></a><h4 id="DWHSG-GUID-E7F71AF0-8AF4-4DA5-B08A-A1F6733213DD" class="sect4"><span class="enumeration_section">7.1.12</span>何时可以快速刷新</h4>
                  <div>
                     <p>并非所有物化视图都可以快速刷新。因此，使用包<code class="codeph">DBMS_MVIEW.EXPLAIN_MVIEW</code>确定可用于实例化视图的刷新方法。
                     </p>
                     <p>如果您不确定如何使物化视图快速刷新，则可以使用<code class="codeph">DBMS_ADVISOR.TUNE_MVIEW</code>过程，该过程提供包含创建快速可刷新物化视图所需语句的脚本。
                     </p>
                     <div class="infoboxnotealso" id="GUID-E7F71AF0-8AF4-4DA5-B08A-A1F6733213DD__GUID-F772E6CB-AF35-44B0-A649-977DE149F2E8">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="../tgsql/introduction-to-sql-tuning.html#TGSQL591" target="_blank"><span><cite>Oracle数据库SQL调优指南</cite></span></a></p>
                           </li>
                           <li>
                              <p><a href="basic-materialized-views.html#GUID-A7AE8E5D-68A5-4519-81EB-252EAAF0ADFF" title="如果物化视图仅包含连接，则每个表的ROWID列（以及在FROM列表中多次出现的表的每个实例）必须存在于实例化视图的SELECT列表中。可以使用CREATE MATERIALIZED VIEW语句或使用Enterprise Manager创建实例化视图。使用CREATE MATERIALIZED VIEW语句创建基于混合分区表的物化视图。基于近似查询的物化视图使用SQL函数，该函数在其定义查询中返回近似函数。基于COUNT（DISTINCT）函数的物化视图可以通过对整数列使用基于位图的操作来提供增强的性能。">基本物化视图，</a>以获取有关<code class="codeph">DBMS_MVIEW</code>包的更多信息</p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-675D03FA-F6E3-4DBD-90E2-1290B20E4689" name="GUID-675D03FA-F6E3-4DBD-90E2-1290B20E4689"></a><h4 id="DWHSG-GUID-675D03FA-F6E3-4DBD-90E2-1290B20E4689" class="sect4"><span class="enumeration_section">7.1.13</span>基于近似查询刷新物化视图</h4>
                  <div>
                     <p>Oracle数据库对使用近似查询定义的物化视图执行快速刷新。</p>
                     <div class="section">
                        <p></p>
                        <p>近似查询包含返回近似结果的SQL函数。刷新包含近似查询的物化视图取决于在实例化视图的基表上执行的DML操作。</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>对于插入操作，快速刷新用于包含详细百分位数的物化视图。</p>
                           </li>
                           <li>
                              <p>对于删除操作或导致删除的任何DML操作（例如<code class="codeph">UPDATE</code>或<code class="codeph">MERGE</code> ），仅当物化视图不包含<code class="codeph">WHERE</code>子句时，才会对包含近似聚合的物化视图使用快速刷新。
                              </p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="p">物化视图日志必须存在于需要快速刷新的物化视图的所有基表上。</div>
                     <!-- class="section" -->
                     <ul>
                        <li class="stepexpand"><span>要刷新基于近似查询的实例化视图：</span><div>
                              <p>运行<code class="codeph">DBMS_REFRESH.REFRESH</code>过程以执行物化视图的快速刷新</p>
                           </div>
                        </li>
                     </ul>
                     <div class="example" id="GUID-675D03FA-F6E3-4DBD-90E2-1290B20E4689__GUID-AF00B477-25CF-4C7A-9F0E-341F676B8C1C">
                        <p class="titleinexample">示例7-2 <span class="bold">基于近似查询刷新实体化视图</span></p>
                        <p>以下示例执行基于近似查询的物化视图<code class="codeph">percentile_per_pdt</code>的快速刷新。
                        </p><pre class="pre codeblock"><code>exec DBMS_MVIEW.REFRESH（'percentile_per_pdt'，method =&gt;'F'）;</code></pre><div class="infoboxnotealso" id="GUID-675D03FA-F6E3-4DBD-90E2-1290B20E4689__GUID-B2FFF9AF-D4D9-42E2-AB84-67C3525580F4">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><a href="data-warehouse-optimizations-techniques.html#GUID-F7E7DEA6-B225-43E6-97ED-CB3DBE86CD54" title="近似查询处理使用SQL函数为可接受近似值的探索性查询提供实时响应。包含返回近似结果的SQL函数的查询称为近似查询。">关于近似查询处理</a></p>
                              </li>
                              <li>
                                 <p><a href="basic-materialized-views.html#GUID-42B64F99-7391-48B8-B37D-1B486DC29645" title="基于近似查询的物化视图使用SQL函数，该函数在其定义查询中返回近似函数。">基于近似查询创建物化视图</a></p>
                              </li>
                              <li>
                                 <p><a href="advanced-query-rewrite-materialized-views.html#GUID-41A13A98-E51A-435A-973E-05CC083F2CFC" title="如果可以使用物化视图回答这些查询，则会自动重写包含返回近似结果的SQL函数的查询以使用匹配的物化视图。">基于近似查询的查询重写和物化视图</a></p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="example" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-1B4FCFD7-C08E-42BC-BFB6-68D053B8E0D5" name="GUID-1B4FCFD7-C08E-42BC-BFB6-68D053B8E0D5"></a><h4 id="DWHSG-GUID-1B4FCFD7-C08E-42BC-BFB6-68D053B8E0D5" class="sect4"><span class="enumeration_section">7.1.14</span>关于在线表重新定义期间刷新从属物化视图</h4>
                  <div>
                     <p>在使用<code class="codeph">DBMS_REDEFINITION</code>包在线重新定义表时，可以执行依赖于正在重新定义的表的快速可刷新实体化视图的增量刷新。
                     </p>
                     <p>在Oracle Database <span class="italic">12c</span>第2版（12.2）之前，要刷新正在进行重定义的表的相关物化视图，必须在重新定义过程完成后手动执行完全刷新。
                     </p>
                     <p></p>
                     <p>要在联机表重新定义期间逐步刷新相关的<code class="codeph">refresh_dep_mviews</code>化视图，请将<code class="codeph">DBMS_REDEFINITON.REDEF_TABLE</code>过程中的<code class="codeph">refresh_dep_mviews</code>参数设置为Y.仅当物化视图可快速刷新且不是基于<code class="codeph">ROWID</code>的物化视图或物化连接视图时，才能在在线表重新定义期间刷新从属物化视图。不遵循这些限制的物化视图不会刷新。
                     </p>
                     <div class="example" id="GUID-1B4FCFD7-C08E-42BC-BFB6-68D053B8E0D5__GUID-1D0EB66C-153A-4CBE-8A71-8A0256D6D139">
                        <p>考虑具有以下依赖的物化视图的表<code class="codeph">my_sales</code> ：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">my_sales_pk_mv</code> ：快速刷新的基于主键的物化视图</p>
                           </li>
                           <li>
                              <p><code class="codeph">my_sales_rid_mv</code> ：基于<code class="codeph">ROWID</code>的快速可刷新物化视图</p>
                           </li>
                           <li>
                              <p><code class="codeph">my_sales_mjv</code> ：快速刷新的物化连接视图</p>
                           </li>
                           <li>
                              <p><code class="codeph">my_sales_mav</code> ：快速刷新的物化聚合视图</p>
                           </li>
                           <li>
                              <p><code class="codeph">my_sales_rmv</code> ：只有完全可刷新的物化视图</p>
                           </li>
                        </ul>
                        <p>运行以下命令时，仅对<code class="codeph">my_sales_pk_mv</code>和<code class="codeph">my_sales_mav</code>化视图执行快速刷新：</p><pre class="pre codeblock"><code>DBMS_REDEFINITION.REDEF_TABLE（uname =&gt;'SH'，tname =&gt;'MY_SALES'，table_compression_type =&gt;'ROW STORE COMPRESS ADVANCED'，refresh_dep_mviews =&gt;'Y'）;</code></pre><div class="infoboxnotealso" id="GUID-1B4FCFD7-C08E-42BC-BFB6-68D053B8E0D5__GUID-827F56DC-6AAE-45F1-A20B-B51E868CC281">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="../admin/managing-tables.html#ADMIN-GUID-D902E9EE-9EA2-434B-934E-43A549D64CEB" target="_blank"><span><cite>Oracle数据库管理员指南</cite></span></a></p>
                        </div>
                     </div>
                     <!-- class="example" -->
                  </div>
               </div><a id="DWHSG8371"></a><div class="props_rev_3"><a id="GUID-D13F84CB-04D1-490F-80FB-AC0E95E0DB60" name="GUID-D13F84CB-04D1-490F-80FB-AC0E95E0DB60"></a><h4 id="DWHSG-GUID-D13F84CB-04D1-490F-80FB-AC0E95E0DB60" class="sect4"><span class="enumeration_section">7.1.15</span>并行性的推荐初始化参数</h4>
                  <div>
                     <p>需要正确设置以下初始化参数才能使并行有效：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>应将<code class="codeph">PARALLEL_MAX_SERVERS</code>设置得足够高以处理并行性。您必须考虑刷新语句所需的从站数。例如，如果并行度为8，则需要16个从属进程。
                           </p>
                        </li>
                        <li>
                           <p>应为实例设置<code class="codeph">PGA_AGGREGATE_TARGET</code>以自动管理排序和连接的内存使用情况。如果手动设置了内存参数，则<code class="codeph">SORT_AREA_SIZE</code>应小于<code class="codeph">HASH_AREA_SIZE</code> 。</p>
                        </li>
                        <li>
                           <p><code class="codeph">OPTIMIZER_MODE</code>应该等于<code class="codeph">all_rows</code> 。
                           </p>
                        </li>
                     </ul>
                     <p>请记住分析所有表和索引以获得更好的优化。</p>
                     <div class="infoboxnotealso" id="GUID-D13F84CB-04D1-490F-80FB-AC0E95E0DB60__GUID-4C72F524-0B9F-44EA-87AA-49BE57CCCD40">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="../vldbg/using-parallel.html#VLDBG010" target="_blank"><span><cite>Oracle数据库VLDB和分区指南</cite></span></a></p>
                     </div>
                  </div>
               </div><a id="DWHSG8372"></a><div class="props_rev_3"><a id="GUID-85E2F8EC-2497-42F4-AB84-E3A99FD22EE2" name="GUID-85E2F8EC-2497-42F4-AB84-E3A99FD22EE2"></a><h4 id="DWHSG-GUID-85E2F8EC-2497-42F4-AB84-E3A99FD22EE2" class="sect4"><span class="enumeration_section">7.1.16</span>监控刷新</h4>
                  <div>
                     <div class="section">
                        <p><a id="d29043e1855" class="indexterm-anchor"></a><a id="d29043e1859" class="indexterm-anchor"></a>作业正在运行时，您可以查询<code class="codeph">V$SESSION_LONGOPS</code>视图，以告诉您正在刷新的每个物化视图的进度。
                        </p><pre class="oac_no_warn" dir="ltr">SELECT * FROM V $ SESSION_LONGOPS;</pre><p>要查看哪个作业在哪个队列上的进度，请使用：</p><pre class="oac_no_warn" dir="ltr">SELECT * FROM DBA_JOBS_RUNNING;</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="DWHSG8373"></a><div class="props_rev_3"><a id="GUID-A5F676C6-68D5-4E85-B0CC-DE0DAFE2BD4B" name="GUID-A5F676C6-68D5-4E85-B0CC-DE0DAFE2BD4B"></a><h4 id="DWHSG-GUID-A5F676C6-68D5-4E85-B0CC-DE0DAFE2BD4B" class="sect4"><span class="enumeration_section">7.1.17</span>检查物化视图的状态</h4>
                  <div>
                     <div class="section">
                        <p>三<a id="d29043e1896" class="indexterm-anchor"></a>提供了用于检查<code class="codeph">DBA_MVIEWS</code>化视图状态的视图： <code class="codeph">DBA_MVIEWS</code> ， <code class="codeph">ALL_MVIEWS</code>和<code class="codeph">USER_MVIEWS</code> 。要检查实例化视图是新鲜还是陈旧，请发出以下语句：</p><pre class="oac_no_warn" dir="ltr">选择MVIEW_NAME，STALENESS，LAST_REFRESH_TYPE，COMPILE_STATE来自USER_MVIEWS订购MVIEW_NAME; MVIEW_NAME STALENESS LAST_REF COMPILE_STATE ---------- --------- -------- ------------- CUST_MTH_SALES_MV NEEDS_COMPILE FAST NEEDS_COMPILE PROD_YR_SALES_MV FRESH快速有效</pre><p>如果<code class="codeph">compile_state</code>列显示<code class="codeph">NEEDS</code> <code class="codeph">COMPILE</code> ，则其他显示的列值不能被信任为反映真实状态。要重新验证实例化视图，请发出以下语句：</p><pre class="oac_no_warn" dir="ltr">ALTER MATERIALIZED VIEW [materialized_view_name] COMPILE;</pre><p>然后重新发出<code class="codeph">SELECT</code>语句。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div><a id="DWHSG8375"></a><a id="DWHSG8374"></a><div class="props_rev_3"><a id="GUID-5B145F5C-C368-450D-8768-22D138A2ED39" name="GUID-5B145F5C-C368-450D-8768-22D138A2ED39"></a><h5 id="DWHSG-GUID-5B145F5C-C368-450D-8768-22D138A2ED39" class="sect5"><span class="enumeration_section">7.1.17.1</span>查看分区新鲜度</h5>
                     <div>
                        <div class="section">
                           <p>有几种视图可用于验证基表分区的状态，并确定哪些物化视图数据是新鲜的，哪些是陈旧的。意见如下：</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">* _USER_MVIEWS</code></p>
                                 <p>确定物化视图的分区更改跟踪（PCT）信息。</p>
                              </li>
                              <li>
                                 <p><code class="codeph">* _USER_MVIEW_DETAIL_RELATIONS</code></p>
                                 <p>要显示详细信息表的分区信息，物化视图基于。</p>
                              </li>
                              <li>
                                 <p><code class="codeph">* _USER_MVIEW_DETAIL_PARTITION</code></p>
                                 <p>确定哪些分区是新鲜的。</p>
                              </li>
                              <li>
                                 <p><code class="codeph">* _USER_MVIEW_DETAIL_SUBPARTITION</code></p>
                                 <p>确定哪些子分区是新鲜的。</p>
                              </li>
                           </ul>
                           <p>以下示例说明了这些视图的使用。<a href="refreshing-materialized-views.html#GUID-5B145F5C-C368-450D-8768-22D138A2ED39__CACFEBFE">图7-1</a>说明了范围列表分区表和基于它的物化视图。分区是P1，P2，P3和P4，而子分区是SP1，SP2和SP3。
                           </p>
                           <div class="figure" id="GUID-5B145F5C-C368-450D-8768-22D138A2ED39__CACFEBFE">
                              <p class="titleinfigure">图7-1确定PCT新鲜度</p><img src="img/dwhsg130.gif" alt="下面是图7-1的描述" title="下面是图7-1的描述" longdesc="img_text/dwhsg130.html"><br><a href="img_text/dwhsg130.html">“图7-1确定PCT新鲜度”的描述</a></div>
                           <!-- class="figure" -->
                           <div class="infoboxnotealso" id="GUID-5B145F5C-C368-450D-8768-22D138A2ED39__GUID-7845953F-8BD8-4514-B8EF-7BCE4456DDBF">
                              <p class="notep1">也可以看看：</p>
                              <p><a href="refreshing-materialized-views.html#GUID-96A66E25-4845-45EB-AD82-940E7E693BF5">使用视图确定新鲜度的示例</a></p>
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div><a id="DWHSG8377"></a><a id="DWHSG8378"></a><a id="DWHSG8379"></a><a id="DWHSG8380"></a><a id="DWHSG8376"></a><div class="props_rev_3"><a id="GUID-96A66E25-4845-45EB-AD82-940E7E693BF5" name="GUID-96A66E25-4845-45EB-AD82-940E7E693BF5"></a><h6 id="DWHSG-GUID-96A66E25-4845-45EB-AD82-940E7E693BF5" class="sect6"><span class="enumeration_section">7.1.17.1.1</span>使用视图确定新鲜<span class="enumeration_section">度的</span>示例</h6>
                        <div>
                           <div class="section">
                              <p>本节说明了确定实体化视图及其详细信息表的PCT和新鲜度信息的示例。</p>
                           </div>
                           <!-- class="section" -->
                           <div class="example" id="GUID-96A66E25-4845-45EB-AD82-940E7E693BF5__GUID-520866E2-8E42-4E08-BFC9-DD2EC6B46DC1">
                              <p class="titleinexample">示例7-3验证物化视图的PCT状态</p>
                              <p>查询<code class="codeph">USER_MVIEWS</code>以访问有关物化视图的PCT信息，如下所示：</p><pre class="oac_no_warn" dir="ltr">SELECT MVIEW_NAME，NUM_PCT_TABLES，NUM_FRESH_PCT_REGIONS，NUM_STALE_PCT_REGIONS FROM USER_MVIEWS WHERE MVIEW_NAME = MV1; MVIEW_NAME NUM_PCT_TABLES NUM_FRESH_PCT_REGIONS NUM_STALE_PCT_REGIONS ---------- -------------- ---------------------  - -------------------- MV1 1 9 3</pre></div>
                           <!-- class="example" -->
                           <div class="example" id="GUID-96A66E25-4845-45EB-AD82-940E7E693BF5__GUID-3D7406D5-B321-42A2-96B5-005D9A53E404">
                              <p class="titleinexample">示例7-4验证物化视图详细信息表中的PCT状态</p>
                              <p>查询<code class="codeph">USER_MVIEW_DETAIL_RELATIONS</code>以访问PCT详细信息表信息，如下所示：</p><pre class="oac_no_warn" dir="ltr">选择MVIEW_NAME，DETAILOBJ_NAME，DETAILOBJ_PCT，NUM_FRESH_PCT_PARTITIONS，NUM_STALE_PCT_PARTITIONS来自USER_MVIEW_DETAIL_RELATIONS，其中MVIEW_NAME = MV1;</pre><pre class="oac_no_warn" dir="ltr">MVIEW_NAME DETAILOBJ_NAME DETAIL_OBJ_PCT NUM_FRESH_PCT_PARTITIONS NUM_STALE_PCT_PARTITIONS ---------- -------------- -------------- ------- ----------------- ------------------------ MV1 T1 Y 3 1</pre></div>
                           <!-- class="example" -->
                           <div class="example" id="GUID-96A66E25-4845-45EB-AD82-940E7E693BF5__GUID-8DFF7D1A-3990-48A3-B24A-F28140C8D32A">
                              <p class="titleinexample">示例7-5验证哪些分区是新鲜的</p>
                              <p>查询<code class="codeph">USER_MVIEW_DETAIL_PARTITION</code>以访问分区的PCT新鲜度信息，如下所示：</p><pre class="oac_no_warn" dir="ltr">SELECT MVIEW_NAME，DETAILOBJ_NAME，DETAIL_PARTITION_NAME，DETAIL_PARTITION_POSITION，来自USER_MVIEW_DETAIL_PARTITION的FRESHNESS，其中MVIEW_NAME = MV1;</pre><pre class="oac_no_warn" dir="ltr">MVIEW_NAME DETAILOBJ_NAME DETAIL_PARTITION_NAME DETAIL_PARTITION_POSITION FRESHNESS ---------- -------------- --------------------- ------------------------- --------- MV1 T1 P1 1 FRESH MV1 T1 P2 2 FRESH MV1 T1 P3 3 STALE MV1 T1 P4 4新鲜</pre></div>
                           <!-- class="example" -->
                           <div class="example" id="GUID-96A66E25-4845-45EB-AD82-940E7E693BF5__GUID-BCE1BEED-5962-4500-A038-2F46B83CA31D">
                              <p class="titleinexample">例7-6验证哪些子分区是新鲜的</p>
                              <p>查询<code class="codeph">USER_MVIEW_DETAIL_SUBPARTITION</code>以访问子分区的PCT新鲜度信息，如下所示：</p><pre class="oac_no_warn" dir="ltr">SELECT MVIEW_NAME，DETAILOBJ_NAME，DETAIL_PARTITION_NAME，DETAIL_SUBPARTITION_NAME，DETAIL_SUBPARTITION_POSITION，来自USER_MVIEW_DETAIL_SUBPARTITION的FRESHNESS，其中MVIEW_NAME = MV1;</pre><pre class="oac_no_warn" dir="ltr">MVIEW_NAME DETAILOBJ DETAIL_PARTITION DETAIL_SUBPARTITION_NAME DETAIL_SUBPARTITION_POS FRESHNESS ---------- --------- ---------------- --------- --------------- ----------------------- --------- MV1 T1 P1 SP1 1新鲜MV1 T1 P1 SP2 1新鲜MV1 T1 P1 SP3 1新鲜MV1 T1 P2 SP1 1新鲜MV1 T1 P2 SP2 1新鲜MV1 T1 P2 SP3 1新鲜MV1 T1 P3 SP1 1 STALE MV1 T1 P3 SP2 1 STALE MV1 T1 P3 SP3 1 STALE MV1 T1 P4 SP1 1 FRESH MV1 T1 P4 SP2 1 FRESH MV1 T1 P4 SP3 1 FRESH</pre></div>
                           <!-- class="example" -->
                        </div>
                     </div>
                  </div>
               </div><a id="DWHSG8381"></a><div class="props_rev_3"><a id="GUID-18BA80A4-C156-4884-96C0-6ECEC4BB6B8A" name="GUID-18BA80A4-C156-4884-96C0-6ECEC4BB6B8A"></a><h4 id="DWHSG-GUID-18BA80A4-C156-4884-96C0-6ECEC4BB6B8A" class="sect4"><span class="enumeration_section">7.1.18</span>调度物化视图的刷新</h4>
                  <div>
                     <div class="section">
                        <p>非常<a id="d29043e2091" class="indexterm-anchor"></a>通常，您在数据库中有多个物化视图。其中一些可以通过重写其他人来计算。这在数据仓库环境中非常常见，您可以在某些层次结构的不同级别嵌套实体化视图或物化视图。
                        </p>
                        <p>在这种情况下，您应该将<code class="codeph">DBMS_MVIEW</code>化视图创建为<code class="codeph">BUILD DEFERRED</code> ，然后在<code class="codeph">DBMS_MVIEW</code>包中发出一个刷新过程以刷新所有<code class="codeph">DBMS_MVIEW</code>化视图。Oracle数据库计算依赖项并以正确的顺序刷新实例化视图。考虑“分层多维数据集<span class="q"><a href="sql-aggregation-data-warehouses.html#GUID-7E6BC903-3368-41F3-A427-C38B42D3A5C0">物化视图的示例</a> ”中</span>描述的完整分层多维数据集的<span class="q"><a href="sql-aggregation-data-warehouses.html#GUID-7E6BC903-3368-41F3-A427-C38B42D3A5C0">示例</a></span> 。假设所有物化视图都已创建为<code class="codeph">BUILD DEFERRED</code> 。以<code class="codeph">BUILD DEFERRED</code>创建物化视图仅为所有物化视图创建元数据。然后，您可以调用<code class="codeph">DBMS_MVIEW</code>包中的一个刷新过程，以正确的顺序刷新所有物化视图：</p><pre class="oac_no_warn" dir="ltr">DECLARE numerrs PLS_INTEGER; BEGIN DBMS_MVIEW.REFRESH_DEPENDENT（number_of_failures =&gt; numerrs，list =&gt;'SALES'，method =&gt;'C'）; DBMS_OUTPUT.PUT_LINE（'刷新期间有'|| numerrs ||'错误'）;结束; /</pre><p>该过程按其依赖项的顺序刷新<code class="codeph">sales_hierarchical_mon_cube_mv</code>化视图（首先是<code class="codeph">sales_hierarchical_mon_cube_mv</code> ，然后是<code class="codeph">sales_hierarchical_qtr_cube_mv</code> ，然后是<code class="codeph">sales_hierarchical_yr_cube_mv</code> ，最后是<code class="codeph">sales_hierarchical_all_cube_mv</code> ）。这些物化视图中的每一个都被重写为列表中的前一个视图。
                        </p>
                        <p>在进行PCT刷新时也可以使用相同类型的重写。PCT刷新重新计算物化视图中与详细信息表中已更改行对应的行。并且，如果在刷新时有其他新的物化视图可用，它可以直接针对它们而不是违反细节表。</p>
                        <p>因此，将物化视图列表传递给<code class="codeph">DBMS_MVIEW</code>包中的任何刷新过程（无论指定的方法如何）总是有益的，并让程序确定在物化视图上执行刷新的顺序。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="DWHSG9417"></a><div class="props_rev_3"><a id="GUID-E4E896C7-8173-4A36-A43F-188158981EB7" name="GUID-E4E896C7-8173-4A36-A43F-188158981EB7"></a><h3 id="DWHSG-GUID-E4E896C7-8173-4A36-A43F-188158981EB7" class="sect3"><span class="enumeration_section">7.2</span>刷新物化视图的提示</h3>
               <div>
                  <p>本节包含以下主题以及有关刷新实例化视图的提示：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="refreshing-materialized-views.html#GUID-BB945209-8D69-4FC7-844E-35C9ED7C8A80">使用聚合刷新实体化视图的提示</a></p>
                     </li>
                     <li>
                        <p><a href="refreshing-materialized-views.html#GUID-8ACD48DC-9F21-4B30-9A07-7A81B8515199">刷新没有聚合的物化视图的提示</a></p>
                     </li>
                     <li>
                        <p><a href="refreshing-materialized-views.html#GUID-3EA0A375-94F7-44D5-B0F6-6D2E20923A64">刷新嵌套物化视图的提示</a></p>
                     </li>
                     <li>
                        <p><a href="refreshing-materialized-views.html#GUID-848922D5-4C3A-4297-A9D2-30BCD92D9046">使用UNION ALL快速刷新的提示</a></p>
                     </li>
                     <li>
                        <p><a href="refreshing-materialized-views.html#GUID-5CBF17CF-0253-4A7B-826C-95A9CF2B659E">使用提交基于SCN的物化视图日志快速刷新的提示</a></p>
                     </li>
                     <li>
                        <p><a href="refreshing-materialized-views.html#GUID-E7F088E2-B9ED-482B-919B-D4AF315F2761">刷新物化视图后的提示</a></p>
                     </li>
                  </ul>
               </div><a id="DWHSG8382"></a><div class="props_rev_3"><a id="GUID-BB945209-8D69-4FC7-844E-35C9ED7C8A80" name="GUID-BB945209-8D69-4FC7-844E-35C9ED7C8A80"></a><h4 id="DWHSG-GUID-BB945209-8D69-4FC7-844E-35C9ED7C8A80" class="sect4"><span class="enumeration_section">7.2.1</span>使用聚合刷新实体化视图的提示</h4>
                  <div>
                     <p>以下是使用聚合的物化视图的刷新机制的一些准则。</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>要进行快速刷新，请使用<code class="codeph">ROWID</code> ， <code class="codeph">SEQUENCE</code>和<code class="codeph">INCLUDING</code> <code class="codeph">NEW</code> <code class="codeph">VALUES</code>子句在物化视图中涉及的所有详细信息表上创建物化视图日志。
                           </p>
                           <p>包括可能在物化视图日志中的物化视图中使用的表中的所有列。</p>
                           <p>即使物化视图日志中省略了<code class="codeph">SEQUENCE</code>选项，也可以快速刷新。如果可以确定仅在所有详细信息表上发生插入或删除，则物化视图日志不需要<code class="codeph">SEQUENCE</code>子句。但是，如果可能或需要更新多个表，或者特定更新方案未知，请确保包含<code class="codeph">SEQUENCE</code>子句。
                           </p>
                        </li>
                        <li>
                           <p></p>
                           <p>使用Oracle的批量加载器实用程序或直接路径<code class="codeph">INSERT</code> （带有<code class="codeph">APPEND</code>提示的<code class="codeph">INSERT</code>用于加载）。Oracle数据库<span class="italic">12c</span>中开始，数据库自动收集的统计信息表作为批量负荷运转（CTAS和IAS）类似于如何创建索引时收集统计的一部分。通过在数据加载期间收集统计信息，您可以避免其他扫描操作，并在数据可供用户使用后立即提供必要的统计信息。
                           </p>
                           <p>这比传统插件更有效。在加载期间，禁用所有约束并在完成加载时重新启用。请注意，无论您使用直接加载还是传统DML，都需要物化视图日志。</p>
                           <p>尝试优化传统混合DML操作的顺序，直接路径<code class="codeph">INSERT</code>和物化视图的快速刷新。您可以使用传统DML和直接负载的混合快速刷新。如果快速刷新发现仅发生了直接加载，则可以执行重要的优化，如下所示：</p>
                           <ol>
                              <li>
                                 <p>直接路径<code class="codeph">INSERT</code> （SQL * Loader或<code class="codeph">INSERT /*+ APPEND */</code> ）进入详细信息表</p>
                              </li>
                              <li>
                                 <p>刷新物化视图</p>
                              </li>
                              <li>
                                 <p>常规混合DML</p>
                              </li>
                              <li>
                                 <p>刷新物化视图</p>
                              </li>
                           </ol>
                           <p>您可以使用常规混合DML（ <code class="codeph">INSERT</code> ， <code class="codeph">UPDATE</code>和<code class="codeph">DELETE</code> ）快速刷新到详细信息表。但是，如果快速刷新检测到只对表执行了插入或删除操作，则可以在其处理中执行重要的优化，例如：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>DML <code class="codeph">INSERT</code>或<code class="codeph">DELETE</code>到详细信息表</p>
                              </li>
                              <li>
                                 <p>刷新物化视图</p>
                              </li>
                              <li>
                                 <p>DML更新到详细信息表</p>
                              </li>
                              <li>
                                 <p>刷新物化视图</p>
                              </li>
                           </ul>
                           <p>更优化的是<code class="codeph">INSERT</code>和<code class="codeph">DELETE</code>的分离。</p>
                           <p>如果可能，应在每种类型的数据更改后执行刷新（如前所示），而不是在结尾处仅发出一次刷新。如果无法做到这一点，请将常规DML限制为仅插入表，以获得更好的刷新性能。避免混合删除和直接负载。</p>
                           <p>此外，为了刷新<code class="codeph">ON</code> <code class="codeph">COMMIT</code> ，Oracle会跟踪已提交事务中完成的DML类型。因此，不要对同一事务中的其他表执行直接路径<code class="codeph">INSERT</code>和DML，因为Oracle可能无法优化刷新阶段。
                           </p>
                           <p>对于<code class="codeph">ON</code> <code class="codeph">COMMIT</code>物化视图，在每个事务结束时自动进行刷新，可能无法隔离DML语句，在这种情况下保持事务简短将有所帮助。但是，如果您计划对详细信息表进行大量修改，则最好在一个事务中执行它们，以便在提交时执行一次物化视图的刷新，而不是在每次更新后执行。
                           </p>
                        </li>
                        <li>
                           <p>Oracle建议对表进行分区，因为它允许您使用：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>并行DML</p>
                                 <p>对于大负载或刷新，启用并行DML有助于缩短操作的时间长度。</p>
                              </li>
                              <li>
                                 <p>分区更改跟踪（PCT）快速刷新</p>
                                 <p>您可以在详细信息表上执行分区维护操作后快速刷新物化视图。 <span class="q">“ <a href="advanced-materialized-views.html#GUID-CE717BD7-15B7-4C8B-A172-6C50F5A802E1">关于分区更改跟踪</a> ”</span> ，了解为物化视图启用PCT的详细信息。
                                 </p>
                              </li>
                           </ul>
                        </li>
                        <li>
                           <p>对物化视图进行分区还有助于刷新性能，因为刷新可以使用并行DML更新实例化视图。例如，假设详细信息表和物化视图已分区并具有并行子句。以下序列将使Oracle能够并行化物化视图的刷新。</p>
                           <ol>
                              <li>
                                 <p>批量加载到详细信息表中。</p>
                              </li>
                              <li>
                                 <p>使用<code class="codeph">ALTER</code> <code class="codeph">SESSION</code> <code class="codeph">ENABLE</code> <code class="codeph">PARALLEL</code> <code class="codeph">DML</code>语句<code class="codeph">ENABLE</code> <code class="codeph">PARALLEL</code> <code class="codeph">DML</code> 。
                                 </p>
                              </li>
                              <li>
                                 <p>刷新物化视图。</p>
                              </li>
                           </ol>
                        </li>
                        <li>
                           <p>要使用<code class="codeph">DBMS_MVIEW.REFRESH</code>进行刷新，请将参数<code class="codeph">atomic_refresh</code>设置为<code class="codeph">FALSE</code> 。</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>对于<code class="codeph">COMPLETE</code>刷新，这会导致<code class="codeph">TRUNCATE</code>删除<code class="codeph">TRUNCATE</code>化视图中的现有行，这比删除更快。
                                 </p>
                              </li>
                              <li>
                                 <p>对于<code class="codeph">PCT</code>刷新，如果物化视图已正确分区，则使用<code class="codeph">TRUNCATE</code> <code class="codeph">PARTITION</code>删除物化视图的受影响分区中的行，这比删除更快。
                                 </p>
                              </li>
                              <li>
                                 <p>对于<code class="codeph">FAST</code>或<code class="codeph">FORCE</code>刷新，如果选择了<code class="codeph">COMPLETE</code>或PCT刷新，则可以使用前面描述的<code class="codeph">TRUNCATE</code>优化。
                                 </p>
                              </li>
                           </ul>
                        </li>
                        <li>
                           <p>将<code class="codeph">DBMS_MVIEW.REFRESH</code>与<code class="codeph">DBMS_MVIEW.REFRESH</code>一起<code class="codeph">JOB_QUEUES</code> ，请记住将<code class="codeph">atomic</code>设置为<code class="codeph">FALSE</code> 。否则，不使用<code class="codeph">JOB_QUEUES</code> 。将作业队列进程数设置为大于处理器数。
                           </p>
                           <p>如果启用了作业队列并且有许多物化视图要刷新，则在单个命令中刷新所有这些视图比单独调用它们更快。</p>
                        </li>
                        <li>
                           <p>使用<code class="codeph">REFRESH</code> <code class="codeph">FORCE</code>确保刷新<code class="codeph">REFRESH</code>化视图，以便它绝对可以用于查询重写。选择最佳刷新方法。如果无法快速刷新，则执行完全刷新。
                           </p>
                        </li>
                        <li>
                           <p>在单个过程调用中刷新所有实例化视图。这使Oracle有机会按照正确的顺序安排所有物化视图的刷新，同时考虑嵌套物化视图强加的依赖性，并通过对其他物化视图使用查询重写来实现高效刷新。</p>
                        </li>
                     </ul>
                  </div>
               </div><a id="DWHSG8383"></a><div class="props_rev_3"><a id="GUID-8ACD48DC-9F21-4B30-9A07-7A81B8515199" name="GUID-8ACD48DC-9F21-4B30-9A07-7A81B8515199"></a><h4 id="DWHSG-GUID-8ACD48DC-9F21-4B30-9A07-7A81B8515199" class="sect4"><span class="enumeration_section">7.2.2</span>刷新没有聚合的物化视图的提示</h4>
                  <div>
                     <p>如果物化视图包含连接但不包含聚合，则在详细信息表中的每个连接列rowid上都有一个索引可以极大地提高刷新性能，因为这种物化视图往往比包含聚合的物化视图大得多。例如，请考虑以下物化视图：</p><pre class="oac_no_warn" dir="ltr">CREATE MATERIALIZED VIEW detail_fact_mv建立立即作为选择s.rowid“sales_rid”，t.rowid“times_rid”，c.rowid“cust_rid”，c.cust_state_province，t.week_ending_day，s.amount_sold FROM sales s，times t，customers c WHERE s.time_id = t.time_id AND s.cust_id = c.cust_id;</pre><p>应在列<code class="codeph">sales_rid</code> ， <code class="codeph">times_rid</code>和<code class="codeph">cust_rid</code>上创建索引。强烈建议进行分区，在调用刷新之前在会话中启用并行DML，因为它极大地提高了刷新性能。
                     </p>
                     <p>如果在详细信息表上执行DML，也可以快速刷新此类物化视图。建议对此类物化视图应用与单个表聚合相同的过程。也就是说，执行一种类型的更改（直接路径<code class="codeph">INSERT</code>或DML），然后刷新物化视图。这是因为如果Oracle数据库检测到只进行了一种类型的更改，则可以执行重要的优化。
                     </p>
                     <p>此外，Oracle建议在加载每个表后调用刷新，而不是加载所有表，然后执行刷新。</p>
                     <p>对于刷新<code class="codeph">ON</code> <code class="codeph">COMMIT</code> ，Oracle会跟踪已提交事务中完成的DML类型。因此，Oracle建议您不要对同一事务中的其他表执行直接路径和常规DML，因为Oracle可能无法优化刷新阶段。例如，不建议以下内容：</p>
                     <ol>
                        <li>
                           <p>将新数据直接加载到事实表中</p>
                        </li>
                        <li>
                           <p>DML进入商店表</p>
                        </li>
                        <li>
                           <p>承诺</p>
                        </li>
                     </ol>
                     <p>另外，尽可能不要混合使用不同类型的传统DML语句。这将再次阻止在快速刷新期间使用各种优化。例如，尽量避免以下情况：</p>
                     <ol>
                        <li>
                           <p>插入事实表</p>
                        </li>
                        <li>
                           <p>从事实表中删除</p>
                        </li>
                        <li>
                           <p>承诺</p>
                        </li>
                     </ol>
                     <p>如果需要进行许多更新，请尝试将它们全部分组到一个事务中，因为刷新仅在提交时执行一次，而不是在每次更新后执行。</p>
                     <p>在数据仓库环境中，假设物化视图具有并行子句，建议执行以下步骤：</p>
                     <ol>
                        <li>
                           <p>批量加载到事实表中</p>
                        </li>
                        <li>
                           <p>启用并行DML</p>
                        </li>
                        <li>
                           <p><code class="codeph">ALTER</code> <code class="codeph">SESSION</code> <code class="codeph">ENABLE</code> <code class="codeph">PARALLEL</code> <code class="codeph">DML</code>语句</p>
                        </li>
                        <li>
                           <p>刷新物化视图</p>
                        </li>
                     </ol>
                  </div>
               </div><a id="DWHSG8384"></a><div class="props_rev_3"><a id="GUID-3EA0A375-94F7-44D5-B0F6-6D2E20923A64" name="GUID-3EA0A375-94F7-44D5-B0F6-6D2E20923A64"></a><h4 id="DWHSG-GUID-3EA0A375-94F7-44D5-B0F6-6D2E20923A64" class="sect4"><span class="enumeration_section">7.2.3</span>刷新嵌套物化视图的提示</h4>
                  <div>
                     <p><a id="d29043e2605" class="indexterm-anchor"></a><a id="d29043e2609" class="indexterm-anchor"></a>刷新实体化视图时，所有基础对象都被视为普通表。如果指定了<code class="codeph">ON</code> <code class="codeph">COMMIT</code>刷新选项，则在提交时以适当的顺序刷新所有实例化视图。换句话说，Oracle构建了一组部分有序的物化视图并刷新它们，以便在成功完成刷新后，所有物化视图都是新鲜的。可以通过查询相应的<code class="codeph">USER_</code> ， <code class="codeph">DBA_</code>或<code class="codeph">ALL_MVIEWS</code>视图来检查<code class="codeph">ALL_MVIEWS</code>视图的状态。
                     </p>
                     <p>如果任何物化视图定义为<code class="codeph">ON</code> <code class="codeph">DEMAND</code>刷新（无论刷新方法是<code class="codeph">FAST</code> ， <code class="codeph">FORCE</code>还是<code class="codeph">COMPLETE</code> ），您必须以正确的顺序刷新它们（考虑物化视图之间的依赖关系），因为嵌套物化视图会根据其他物化视图的当前内容（无论是否新鲜）进行刷新。这可以通过针对嵌套层次结构顶部的实例化视图调用刷新过程并将<code class="codeph">nested</code>参数指定为<code class="codeph">TRUE</code> 。</p>
                     <p>如果在提交期间刷新失败，则尚未刷新的实例化视图列表将写入警报日志，您必须手动刷新它们及其所有相关的物化视图。</p>
                     <p>在常规物化视图上使用的嵌套物化视图上使用相同的<code class="codeph">DBMS_MVIEW</code>过程。
                     </p>
                     <p>与嵌套的物化视图一起使用时，这些过程具有以下行为：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>如果<code class="codeph">REFRESH</code>应用于物化视图<code class="codeph">my_mv</code>是建立在其他物化视图，然后<code class="codeph">my_mv</code>刷新相对于其他的当前内容的物化视图（即，其他物化视图不是用新鲜的第一），除非你指定<code class="codeph">nested =&gt; TRUE</code> 。</p>
                        </li>
                        <li>
                           <p>如果将<code class="codeph">REFRESH_DEPENDENT</code>应用于物化视图<code class="codeph">my_mv</code> ，则只刷新直接依赖于<code class="codeph">my_mv</code>的物化视图（即，依赖于依赖于<code class="codeph">my_mv</code>的物化视图的物化视图将不会刷新），除非您指定<code class="codeph">nested =&gt; TRUE</code> 。</p>
                        </li>
                        <li>
                           <p>如果使用<code class="codeph">REFRESH_ALL_MVIEWS</code> ，则保证刷新实例化视图的顺序遵守嵌套的实例化视图之间的依赖关系。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">GET_MV_DEPENDENCIES</code>提供了对象的直接（或直接）物化视图依赖关系的列表。
                           </p>
                        </li>
                     </ul>
                  </div>
               </div><a id="DWHSG8385"></a><div class="props_rev_3"><a id="GUID-848922D5-4C3A-4297-A9D2-30BCD92D9046" name="GUID-848922D5-4C3A-4297-A9D2-30BCD92D9046"></a><h4 id="DWHSG-GUID-848922D5-4C3A-4297-A9D2-30BCD92D9046" class="sect4"><span class="enumeration_section">7.2.4</span>使用UNION ALL快速刷新的提示</h4>
                  <div>
                     <p>你可以快速使用<a id="d29043e2730" class="indexterm-anchor"></a><a id="d29043e2734" class="indexterm-anchor"></a>通过在物化视图的定义中提供维护列来刷新使用<code class="codeph">UNION</code> <code class="codeph">ALL</code>运算符的物化视图。例如，具有<code class="codeph">UNION</code> <code class="codeph">ALL</code>运算符的物化视图可以快速刷新，如下所示：</p><pre class="oac_no_warn" dir="ltr">CREATE MATERIALIZED VIEW fast_rf_union_all_mv AS SELECT x.rowid AS r1，y.rowid AS r2，a，b，c，1 AS标记FROM x，y WHERE xa = yb UNION ALL SELECT p.rowid，r.rowid，a，c， d，2 AS标记FROM p，r WHERE pa = ry;</pre><p>维护标记列的形式（示例中的列<code class="codeph">MARKER</code>必须是<code class="codeph">numeric_or_string_literal</code> <code class="codeph">AS</code> <code class="codeph">column_alias</code> ，其中每个<code class="codeph">UNION</code> <code class="codeph">ALL</code>成员都具有<code class="codeph">numeric_or_string_literal</code>的不同值。
                     </p>
                  </div>
               </div><a id="DWHSG0319"></a><div class="props_rev_3"><a id="GUID-5CBF17CF-0253-4A7B-826C-95A9CF2B659E" name="GUID-5CBF17CF-0253-4A7B-826C-95A9CF2B659E"></a><h4 id="DWHSG-GUID-5CBF17CF-0253-4A7B-826C-95A9CF2B659E" class="sect4"><span class="enumeration_section">7.2.5</span>使用提交基于SCN的物化视图日志快速刷新的提示</h4>
                  <div>
                     <p>通常，通常可以确保基表上的物化视图日志包含<code class="codeph">WITH</code> <code class="codeph">COMMIT</code> <code class="codeph">SCN</code>子句，从而提高快速刷新性能。通过<code class="codeph">WITH</code> <code class="codeph">COMMIT</code> <code class="codeph">SCN</code>优化物化视图日志处理，快速刷新过程可以节省时间。以下示例说明了如何使用此子句：</p><pre class="oac_no_warn" dir="ltr">使用ROWID（prod_id，cust_id，time_id，channel_id，promo_id，quantity_sold，amount_sold）创建物料化视图登录销售，包括新值的COMMIT SCN;</pre><p>物化视图刷新自动使用基于提交SCN的物化视图日志来节省刷新时间。</p>
                     <p>请注意，只有新的物化视图日志才能利用<code class="codeph">COMMIT</code> <code class="codeph">SCN</code> 。除非删除并重新创建<code class="codeph">COMMIT</code> <code class="codeph">SCN</code>否则不能更改现有的物化视图日志。
                     </p>
                     <p>在具有基于时间戳的物化视图日志的基表和基于提交SCN的物化视图日志的基表上创建物化视图时，会引发错误（ORA-32414），表明物化视图日志彼此不兼容快速刷新。</p>
                  </div>
               </div><a id="DWHSG8386"></a><div class="props_rev_3"><a id="GUID-E7F088E2-B9ED-482B-919B-D4AF315F2761" name="GUID-E7F088E2-B9ED-482B-919B-D4AF315F2761"></a><h4 id="DWHSG-GUID-E7F088E2-B9ED-482B-919B-D4AF315F2761" class="sect4"><span class="enumeration_section">7.2.6</span>刷新物化视图后的提示</h4>
                  <div>
                     <p>执行加载或增量加载并重建详细信息表索引后，必须重新启用完整性约束（如果有）并刷新从该详细信息数据派生的实例化视图和物化视图索引。在数据仓库环境中，通常使用<code class="codeph">NOVALIDATE</code>或<code class="codeph">RELY</code>选项启用参照完整性约束。在执行刷新操作之前做出的重要决定是刷新是否需要可恢复。由于物化视图数据是冗余的并且始终可以从详细信息表中重建，因此最好禁用物化视图上的日志记录。要禁用日志记录并以不可恢复的方式运行增量刷新，请使用<code class="codeph">ALTER</code> <code class="codeph">MATERIALIZED</code> <code class="codeph">VIEW</code> ...刷新之前的<code class="codeph">NOLOGGING</code>语句。
                     </p>
                     <p>如果使用<code class="codeph">ON</code> <code class="codeph">COMMIT</code>方法刷新<code class="codeph">ora_</code>化视图，则在刷新操作之后，请查阅警报日志<code class="codeph">alert_</code> <span class="italic">SID</span> <code class="codeph">.log</code>和跟踪文件<code class="codeph">ora_</code> <span class="italic">SID</span> <code class="codeph">_number.trc</code>以检查是否未发生错误。
                     </p>
                  </div>
               </div>
            </div><a id="DWHSG03009"></a><div class="props_rev_3"><a id="GUID-7EA0FBD1-DCBD-4EBD-A131-59EE6ACC97B6" name="GUID-7EA0FBD1-DCBD-4EBD-A131-59EE6ACC97B6"></a><h3 id="DWHSG-GUID-7EA0FBD1-DCBD-4EBD-A131-59EE6ACC97B6" class="sect3"><span class="enumeration_section">7.3</span>使用具有分区表的物化视图</h3>
               <div>
                  <div class="section">
                     <p>主要维护<a id="d29043e2927" class="indexterm-anchor"></a><a id="d29043e2931" class="indexterm-anchor"></a>当详细数据更改时，数据仓库的组件正在同步（刷新）实例化视图。对基础详细信息表进行分区可以减少执行刷新任务所需的时间。这是可能的，因为分区使刷新能够使用并行DML来更新实体化视图。此外，它还支持使用分区更改跟踪。
                     </p>
                     <p><span class="q">“ <a href="refreshing-materialized-views.html#GUID-26E584E9-86BB-4752-9202-5D58D31172A9">具有分区更改跟踪的物化视图快速刷新</a> ”</span>提供了有关PCT刷新的其他信息。
                     </p>
                  </div>
                  <!-- class="section" -->
               </div><a id="DWHSG8387"></a><div class="props_rev_3"><a id="GUID-26E584E9-86BB-4752-9202-5D58D31172A9" name="GUID-26E584E9-86BB-4752-9202-5D58D31172A9"></a><h4 id="DWHSG-GUID-26E584E9-86BB-4752-9202-5D58D31172A9" class="sect4"><span class="enumeration_section">7.3.1</span>具有分区更改跟踪的物化视图快速刷新</h4>
                  <div>
                     <p>在数据仓库中，对详细信息表的更改通常需要进行分区维护操作，例如<code class="codeph">DROP</code> ， <code class="codeph">EXCHANGE</code> ， <code class="codeph">MERGE</code>和<code class="codeph">ADD</code> <code class="codeph">PARTITION</code> 。在此类操作过去需要手动维护（另请参见<code class="codeph">CONSIDER</code> <code class="codeph">FRESH</code> ）或完全刷新之后，要保持物化视图。您现在可以选择使用称为分区更改跟踪（PCT）刷新的快速刷新添加。
                     </p>
                     <p>要使PCT可用，必须对详细信息表进行分区。物化视图本身的分区与此功能无关。如果可以进行PCT刷新，则会自动进行，并且不需要用户干预就可以进行PCT刷新。有关PCT要求，请参阅<span class="q">“ <a href="advanced-materialized-views.html#GUID-CE717BD7-15B7-4C8B-A172-6C50F5A802E1">关于分区更改跟踪</a> ”</span> 。
                     </p>
                     <p>以下示例说明了此功能的用法：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="refreshing-materialized-views.html#GUID-A56F85C1-DA13-4EF9-AE02-5D559880B976">物化视图的PCT快速刷新：场景1</a></p>
                        </li>
                        <li>
                           <p><a href="refreshing-materialized-views.html#GUID-01EB5EF7-B938-4A81-9F17-BB1AE3D91950">物化视图的PCT快速刷新：场景2</a></p>
                        </li>
                        <li>
                           <p><a href="refreshing-materialized-views.html#GUID-B4682FA1-52C4-4847-9843-8CA3D6AD258D">物化视图的PCT快速刷新：场景3</a></p>
                        </li>
                     </ul>
                  </div><a id="DWHSG8388"></a><div class="props_rev_3"><a id="GUID-A56F85C1-DA13-4EF9-AE02-5D559880B976" name="GUID-A56F85C1-DA13-4EF9-AE02-5D559880B976"></a><h5 id="DWHSG-GUID-A56F85C1-DA13-4EF9-AE02-5D559880B976" class="sect5"><span class="enumeration_section">7.3.1.1</span>物化视图的PCT快速刷新：场景1</h5>
                     <div>
                        <div class="section">
                           <p>在此方案中，假设<code class="codeph">sales</code>是使用<code class="codeph">time_id</code>列的分区表，并且<code class="codeph">products</code>由<code class="codeph">prod_category</code>列分区。表<code class="codeph">times</code>不是分区表。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <ol>
                           <li class="stepexpand"><span>创建物化视图。以下物化视图满足PCT的要求。</span><div><pre class="oac_no_warn" dir="ltr">CREATE MATERIALIZED VIEW cust_mth_sales_mv建立立即刷新请求快速启动QUERY REWRITE作为SELECT s.time_id，s.prod_id，SUM（s.quantity_sold），SUM（s.amount_sold），p.prod_name，t.calendar_month_name，COUNT（*）， COUNT（s.quantity_sold），COUNT（s.amount_sold）FROM sales s，products p，times t WHERE s.time_id = t.time_id AND s.prod_id = p.prod_id GROUP BY t.calendar_month_name，s.prod_id，p。 prod_name，s.time_id;</pre></div>
                           </li>
                           <li class="stepexpand"><span>运行<code class="codeph">DBMS_MVIEW.EXPLAIN_MVIEW</code>过程以确定哪些表允许PCT刷新。</span><div><pre class="oac_no_warn" dir="ltr">MVNAME CAPABILITY_NAME可能RELATED_TEXT MSGTXT ----------------- --------------- -------- ----- ------- ---------------- CUST_MTH_SALES_MV PCT Y SALES CUST_MTH_SALES_MV PCT_TABLE Y SALES CUST_MTH_SALES_MV PCT_TABLE N产品SELECT列表中没有分区键或PMARKER CUST_MTH_SALES_MV PCT_TABLE N TIMES关系不是partitionedtable</pre><p>从<code class="codeph">EXPLAIN_MVIEW</code>的部分样本输出可以看出，在<code class="codeph">sales</code>表上执行的任何分区维护操作都允许PCT快速刷新。但是，在分区维护操作或对<code class="codeph">products</code>表的更新之后，PCT是不可能的，因为<code class="codeph">cust_mth_sales_mv</code>包含的信息<code class="codeph">cust_mth_sales_mv</code>进行PCT刷新。请注意， <code class="codeph">times</code>未分区，因此永远不允许PCT刷新。如果Oracle数据库可以确定实例化视图具有足以支持所有更新表的PCT的信息，则应用PCT数据库。您可以使用<code class="codeph">DBA_MVIEWS</code>和<code class="codeph">DBA_MVIEW_DETAIL_PARTITION</code>等视图验证哪些分区是新鲜的和陈旧的。</p>
                                 <p>有关如何使用此过程的信息以及有关PCT相关视图的一些详细信息，请参阅<span class="q">“ <a href="basic-materialized-views.html#GUID-651B08EB-4D32-4A93-A260-A965C40AE136">分析物化视图功能</a> ”</span> 。
                                 </p>
                              </div>
                           </li>
                           <li class="stepexpand"><span>假设稍后，销售表中的一个分区的<code class="codeph">SPLIT</code>操作变得必要。</span><div><pre class="oac_no_warn" dir="ltr">ALTER TABLE SALES SPLIT PARTITION month3 AT（TO_DATE（'05 -02-1998'，'DD-MM-YYYY'）INTO（PARTITION month3_1 TABLESPACE summ，PARTITION month3 TABLESPACE summ）;</pre></div>
                           </li>
                           <li class="stepexpand"><span>将一些数据插入<code class="codeph">sales</code>表。</span></li>
                           <li class="stepexpand"><span>使用<code class="codeph">DBMS_MVIEW.REFRESH</code>过程快速刷新<code class="codeph">cust_mth_sales_mv</code> 。</span><div><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_MVIEW.REFRESH（'CUST_MTH_SALES_MV'，'F'，''，TRUE，FALSE，0,0,0，FALSE）;</pre></div>
                           </li>
                        </ol>
                        <div class="section">
                           <p>快速刷新会自动执行PCT刷新，因为它是此方案中唯一可能的快速刷新。但是，如果在未启用PCT的表上进行任何更新时发生分区维护操作，则不会发生快速刷新。这在<span class="q">“ <a href="refreshing-materialized-views.html#GUID-01EB5EF7-B938-4A81-9F17-BB1AE3D91950">物化视图的PCT快速刷新：场景2</a> ”中显示</span> 。
                           </p>
                           <p>如果物化视图是使用<code class="codeph">PMARKER</code>子句创建的，则“物化视图的<span class="q"><a href="refreshing-materialized-views.html#GUID-A56F85C1-DA13-4EF9-AE02-5D559880B976">PCT快速刷新：场景1</a> ”</span>也是合适的，如下所示：</p><pre class="oac_no_warn" dir="ltr">CREATE MATERIALIZED VIEW cust_sales_marker_mv建立立即刷新需求快速启动QUERY REWRITE作为选择DBMS_MVIEW.PMARKER（s.rowid）s_marker，SUM（s.quantity_sold），SUM（s.amount_sold），p.prod_name，t.calendar_month_name，COUNT（* ），COUNT（s.quantity_sold），COUNT（s.amount_sold）FROM sales s，products p，times t WHERE s.time_id = t.time_id AND s.prod_id = p.prod_id GROUP BY DBMS_MVIEW.PMARKER（s.rowid） ，p.prod_name，t.calendar_month_name;</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="DWHSG8389"></a><div class="props_rev_3"><a id="GUID-01EB5EF7-B938-4A81-9F17-BB1AE3D91950" name="GUID-01EB5EF7-B938-4A81-9F17-BB1AE3D91950"></a><h5 id="DWHSG-GUID-01EB5EF7-B938-4A81-9F17-BB1AE3D91950" class="sect5"><span class="enumeration_section">7.3.1.2</span>物化视图的PCT快速刷新：场景2</h5>
                     <div>
                        <div class="section">
                           <p>在此方案中，前三个步骤与<span class="q">“ <a href="refreshing-materialized-views.html#GUID-A56F85C1-DA13-4EF9-AE02-5D559880B976">物化视图的PCT快速刷新：场景1</a> ”中的相同</span> 。然后，执行对<code class="codeph">sales</code>表的<code class="codeph">SPLIT</code>分区操作，但在物化视图刷新发生之前，将记录插入到<code class="codeph">times</code>中。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <ol>
                           <li class="stepexpand"><span>与<span class="q">“ <a href="refreshing-materialized-views.html#GUID-A56F85C1-DA13-4EF9-AE02-5D559880B976">物化视图的PCT快速刷新：场景1</a> ”中的相同</span> 。</span></li>
                           <li class="stepexpand"><span>与<span class="q">“ <a href="refreshing-materialized-views.html#GUID-A56F85C1-DA13-4EF9-AE02-5D559880B976">物化视图的PCT快速刷新：场景1</a> ”中的相同</span> 。</span></li>
                           <li class="stepexpand"><span>与<span class="q">“ <a href="refreshing-materialized-views.html#GUID-A56F85C1-DA13-4EF9-AE02-5D559880B976">物化视图的PCT快速刷新：场景1</a> ”中的相同</span> 。</span></li>
                           <li class="stepexpand"><span>发出相同的<code class="codeph">SPLIT</code>操作后，如<span class="q">“ <a href="refreshing-materialized-views.html#GUID-A56F85C1-DA13-4EF9-AE02-5D559880B976">物化视图的PCT快速刷新：场景1</a> ”中所示</span> ，将一些数据插入到<code class="codeph">times</code>中。</span><div><pre class="oac_no_warn" dir="ltr">ALTER TABLE SALES SPLIT PARTITION month3 AT（TO_DATE（'05 -02-1998'，'DD-MM-YYYY'）INTO（PARTIITION month3_1 TABLESPACE summ，PARTITION month3 TABLESPACE summ）;</pre></div>
                           </li>
                           <li class="stepexpand"><span>刷新<code class="codeph">cust_mth_sales_mv</code> 。</span><div><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_MVIEW.REFRESH（'CUST_MTH_SALES_MV'，'F'，''，TRUE，FALSE，0,0,0，FALSE，FALSE）; ORA-12052：无法快速刷新物化视图SH.CUST_MTH_SALES_MV</pre></div>
                           </li>
                        </ol>
                        <div class="section">
                           <p>物化视图不能快速刷新，因为DML已经发生在无法进行PCT快速刷新的表中。为避免发生这种情况，Oracle建议在对可供分区跟踪快速刷新的详细信息表执行任何分区维护操作后立即执行快速刷新。</p>
                           <p>如果出现<span class="q">“ <a href="refreshing-materialized-views.html#GUID-01EB5EF7-B938-4A81-9F17-BB1AE3D91950">物化视图的PCT快速刷新：场景2</a> ”中的</span>情况，则有两种可能性：如果合适，执行完整刷新或切换到下面概述的<code class="codeph">CONSIDER</code> <code class="codeph">FRESH</code>选项。但是，应该注意的是， <code class="codeph">CONSIDER</code> <code class="codeph">FRESH</code>和分区更改跟踪快速刷新不兼容。一旦发出<code class="codeph">ALTER</code> <code class="codeph">MATERIALIZED</code> <code class="codeph">VIEW</code> <code class="codeph">cust_mth_sales_mv</code> <code class="codeph">CONSIDER</code> <code class="codeph">FRESH</code>语句，PCT刷新就不再应用于此物化视图，直到完成完全刷新。此外，除非您采取手动操作以确保物化视图确实是新鲜的，否则不应使用<code class="codeph">CONSIDER</code> <code class="codeph">FRESH</code> 。
                           </p>
                           <p>数据仓库中的常见情况是使用滚动数据窗口。在这种情况下，详细信息表和物化视图可能包含最近12个月的数据。每个月，表中都会添加一个月的新数据，并删除最早的月份（或者可能已归档）。在这种情况下，PCT刷新提供了一种非常有效的机制来维护物化视图。</p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="DWHSG8390"></a><div class="props_rev_3"><a id="GUID-B4682FA1-52C4-4847-9843-8CA3D6AD258D" name="GUID-B4682FA1-52C4-4847-9843-8CA3D6AD258D"></a><h5 id="DWHSG-GUID-B4682FA1-52C4-4847-9843-8CA3D6AD258D" class="sect5"><span class="enumeration_section">7.3.1.3</span>物化视图的PCT快速刷新：场景3</h5>
                     <div>
                        <ol>
                           <li class="stepexpand"><span>通常通过添加新分区并将其与包含新数据的表进行交换，将新数据添加到详细信息表中。</span><div><pre class="oac_no_warn" dir="ltr">ALTER TABLE sales ADD PARTITION month_new ...ALTER TABLE sales EXCHANGE PARTITION month_new month_new_table</pre></div>
                           </li>
                           <li class="stepexpand"><span>接下来，删除或截断最旧的分区。</span><div><pre class="oac_no_warn" dir="ltr">ALTER TABLE sales DROP PARTITION month_oldest;</pre></div>
                           </li>
                           <li class="stepexpand"><span>现在，如果物化视图满足PCT刷新的所有条件。</span><div><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_MVIEW.REFRESH（'CUST_MTH_SALES_MV'，'F'，''，TRUE，FALSE，0,0,0，FALSE，FALSE）;</pre></div>
                           </li>
                        </ol>
                        <div class="section">
                           <p>快速刷新将自动检测PCT是否可用并执行PCT刷新。</p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div>
            </div>
            <div class="sect2"><a id="GUID-8481EFCA-C0B6-461B-8311-D793566A5973" name="GUID-8481EFCA-C0B6-461B-8311-D793566A5973"></a><h3 id="DWHSG-GUID-8481EFCA-C0B6-461B-8311-D793566A5973" class="sect3"><span class="enumeration_section">7.4</span>基于混合分区表的刷新物化视图</h3>
               <div>
                  <p>您可以使用完整，快速或PCT刷新方法刷新基于混合分区表的实例化视图。</p>
                  <div class="section">
                     <p></p>
                     <p>由于Oracle数据库无法控制外部源中数据的维护方式，因此外部分区中的数据不保证是新鲜的，其新鲜度标记为UNKNOWN。来自外部分区的数据只能在受信任的完整性模式或过期容忍模式下使用。</p>
                     <p>来自外部分区的刷新数据可能很昂贵，并且通常不需要（当源数据不变时）操作。您可以使用<code class="codeph">DBMS_MVIEW.REFRESH</code>过程中的<code class="codeph">skip_ext_data</code>属性跳过刷新与外部分区对应的物化视图数据。将此属性设置为TRUE时，不会重新计算与外部分区对应的实体化视图数据，并保持状态为UNKNOWN的受信任模式。默认情况下， <code class="codeph">skip_ext_data</code>为FALSE。</p>
                     <div class="infoboxnote" id="GUID-8481EFCA-C0B6-461B-8311-D793566A5973__GUID-3F536239-693D-461C-881D-4BE132BA7243">
                        <p class="notep1">注意：</p>
                        <p>如果物化视图所基于的混合分区表未启用PCT，则<code class="codeph">COMPLETE</code>和<code class="codeph">FORCE</code>是唯一支持的刷新方法。不支持<code class="codeph">FAST</code>刷新。
                        </p>
                     </div>
                  </div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-8481EFCA-C0B6-461B-8311-D793566A5973__GUID-EB7ED3F2-7423-4669-9122-38B0FC649B1B">
                     <p class="titleinexample">示例7-7 <span class="bold">刷新基于混合分区表的物化视图</span></p>
                     <p>假设内部分区， <code class="codeph">year_2000</code> ，在物化视图中命名<code class="codeph">hypt_mv</code>是陈旧的。此物化视图基于混合分区表。查询目录视图<code class="codeph">USER_MVIEW_DETAIL_PARTITION</code>显示以下内容：</p><pre class="pre codeblock"><code>从USER_MVIEW_DETAIL_PARTITION中选择mview_name，detail_partition_name，fresh，last_refresh_time; MVIEW_NAME DETAIL_PARTITION_NAME FRESHNESS LAST_REFRESH_TIME ---------- --------------------- --------- ------ ----------- HyPT_MV century_19 UNKNOWN 2016-10-31 20：48：00.20 HyPT_MV century_20 UNKNOWN 2016-10-31 20：48：00.20 HyPT_MV year_2000 STALE 2016-10-31 20：48：00.20 HyPT_MV year_2001 FRESH 2016-10-31 20：48：00.20</code></pre><p>使用以下命令执行物化视图的快速刷新：</p><pre class="pre codeblock"><code>DBMS_MVIEW.REFERSH（'HyPT_MV'，'F'， <span class="bold">skip_ext_data =&gt; false</span> ）;</code></pre><p>刷新后查询目录视图<code class="codeph">USER_MVIEW_DETAIL_PARTITION</code> ，显示以下内容：</p><pre class="pre codeblock"><code>从USER_MVIEW_DETAIL_PARTITION中选择mview_name，detail_partition_name，fresh，last_refresh_time; MVIEW_NAME DETAIL_PARTITION_NAME FRESHNESS LAST_REFRESH_TIME ---------- --------------------- --------- ------ ----------- HyPT_MV century_19 UNKNOWN 2016-10-31 21：32：17.00 HyPT_MV century_20 UNKNOWN 2016-10-31 21：32：17.00 HyPT_MV year_2000 FRESH 2016-10-31 21：32：17.00 HyPT_MV year_2001 FRESH 2016-10-31 20：48：00.20</code></pre><p>请注意，仅刷新了内部分区<code class="codeph">year_2000</code> 。分区<code class="codeph">year_2001</code>没有刷新，因为它已经很新鲜了。当<code class="codeph">skip_ext_data</code>设置为FALSE时，将执行外部分区的完全刷新和内部分区的快速刷新。
                     </p>
                  </div>
                  <!-- class="example" -->
               </div>
            </div><a id="DWHSG03001"></a><div class="props_rev_3"><a id="GUID-4679957A-71E5-439E-BD8B-A0331F0631F2" name="GUID-4679957A-71E5-439E-BD8B-A0331F0631F2"></a><h3 id="DWHSG-GUID-4679957A-71E5-439E-BD8B-A0331F0631F2" class="sect3"><span class="enumeration_section">7.5</span>使用分区来改进数据仓库刷新</h3>
               <div>
                  <div class="section">
                     <p><a href="glossary.html#GUID-A85C01AD-53F8-409B-A648-60DC2E8CE0ED"><span class="xrefglossterm">ETL</span></a> （提取，转换和加载）按计划完成，以反映对原始源系统所做的更改。在此步骤中，您将新的，干净的数据物理插入到生产数据仓库模式中，并采取所有必要的其他步骤（例如构建索引，验证约束，进行备份）以使最新用户可以使用此新数据。将所有这些数据加载到数据仓库后，必须更新实体化视图以反映最新数据。
                     </p>
                     <p><a id="d29043e3445" class="indexterm-anchor"></a>数据仓库的分区方案通常对于确定数据仓库加载过程中的刷新操作的效率至关重要。事实上，加载过程通常是选择数据仓库表和索引的分区方案的首要考虑因素。
                     </p>
                     <p>最大数据仓库表的分区方案（例如，星型模式中的事实表）应基于数据仓库的加载范例。</p>
                     <p>大多数数据仓库定期加载新数据。例如，每隔一晚，每周或每月，新数据都会被带入数据仓库。在周或月结束时加载的数据通常对应于周或月的交易。在这种非常常见的情况下，数据仓库正在按时加载。这表明数据仓库表应该在日期列上进行分区。在我们的数据仓库示例中，假设每月将新数据加载到<code class="codeph">sales</code>表中。此外， <code class="codeph">sales</code>表已按月分区。这些步骤显示了加载过程如何将新月（2001年1月）的数据添加到表<code class="codeph">sales</code> 。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <ol>
                     <li class="stepexpand"><span>将新数据放入单独的表<code class="codeph">sales_01_2001</code> 。此数据可以从数据仓库外部直接加载到<code class="codeph">sales_01_2001</code> ，或者此数据可以是数据仓库中已经发生的先前数据转换操作的结果。 <code class="codeph">sales_01_2001</code>具有与<code class="codeph">sales</code>表完全相同的列，数据类型等。收集<code class="codeph">sales_01_2001</code>表的统计信息。</span></li>
                     <li class="stepexpand"><span>在<code class="codeph">sales_01_2001</code>上创建索引并添加约束。同样， <code class="codeph">sales_01_2001</code>上的索引和约束应该与<code class="codeph">sales</code>的索引和约束相同。索引可以并行构建，并应使用<code class="codeph">NOLOGGING</code>和<code class="codeph">COMPUTE</code> <code class="codeph">STATISTICS</code>选项。例如：</span><div><pre class="oac_no_warn" dir="ltr">CREATE BITMAP INDEX sales_01_2001_customer_id_bix ON sales_01_2001（customer_id）TABLESPACE sales_idx NOLOGGING PARALLEL 8 COMPUTE STATISTICS;</pre><p>将所有约束应用于<code class="codeph">sales_01_2001</code>表，该表存在于<code class="codeph">sales</code>表中。这包括参照完整性约束。典型的约束是：</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE sales_01_2001 ADD CONSTRAINT sales_customer_id REFERENCES customer（customer_id）ENABLE NOVALIDATE;</pre><p>如果分区表<code class="codeph">sales</code>具有使用全局索引结构强制执行的主键或唯一键，请确保在不创建索引结构的情况下验证<code class="codeph">sales_pk_jan01</code>上的约束，如下所示：</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE sales_01_2001 ADD CONSTRAINT sales_pk_jan01 PRIMARY KEY（sales_transaction_id）DISABLE VALIDATE;</pre><p>使用<code class="codeph">ENABLE</code>子句创建约束将导致创建唯一索引，该索引与分区表的本地索引结构不匹配。您不能在非分区表上构建任何索引结构来交换分区表的现有全局索引。exchange命令会失败。
                           </p>
                        </div>
                     </li>
                     <li class="stepexpand"><span>将<code class="codeph">sales_01_2001</code>表添加到<code class="codeph">sales</code>表。</span><div>
                           <p>要将此新数据添加到<code class="codeph">sales</code>表，您必须执行两项操作。首先，您必须将新分区添加到<code class="codeph">sales</code>表。你使用<code class="codeph">ALTER</code> <code class="codeph">TABLE</code> ...<code class="codeph">ADD</code> <code class="codeph">PARTITION</code>语句。这会在<code class="codeph">sales</code>表中添加一个空分区：</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE sales ADD PARTITION sales_01_2001 VALUES少于（TO_DATE（'01-FEB-2001'，'DD-MON-YYYY'））;</pre><p>然后，您可以使用<code class="codeph">EXCHANGE</code> <code class="codeph">PARTITION</code>操作将新创建的表添加到此分区。这将使用新加载的表交换新的空分区。
                           </p><pre class="oac_no_warn" dir="ltr">ALTER TABLE sales EXCHANGE PARTITION sales_01_2001 WITH TABLE sales_01_2001包括没有确认更新全局指数的指数;</pre><p><code class="codeph">EXCHANGE</code>操作保留<code class="codeph">sales_01_2001</code>表中已存在的索引和约束。对于唯一约束（例如<code class="codeph">sales_transaction_id</code>上的唯一约束），可以使用<code class="codeph">UPDATE</code> <code class="codeph">GLOBAL</code> <code class="codeph">INDEXES</code>子句，如前所示。这会自动维护您的全局索引结构，作为分区维护操作的一部分，并在整个过程中使它们可访问。如果只有外键约束，那么交换操作将是即时的。
                           </p>
                           <p>请注意，如果使用同步刷新而不是执行步骤3，则必须使用<code class="codeph">DBMS_SYNC_REFRESH.REGISTER_PARTITION_OPERATION</code>包注册<code class="codeph">sales_01_2001</code>表。有关更多信息，请参阅<a href="synchronous-refresh.html#GUID-14730F6C-D96D-4AA3-A91E-9FBF456EC889">同步刷新</a> 。
                           </p>
                        </div>
                     </li>
                  </ol>
                  <div class="section">
                     <p>这种分区技术的好处是显着的。首先，以最小的资源利用率加载新数据。新数据被加载到一个完全独立的表中，索引处理和约束处理仅应用于新分区。如果<code class="codeph">sales</code>表是50 GB并且有12个分区，则新月份的数据大约包含4 GB。只有新月的数据必须编入索引。其余46 GB数据上的所有索引都不得修改。此分区方案还确保负载处理时间与正在加载的新数据量成正比，而不是与<code class="codeph">sales</code>表的总大小成正比。
                     </p>
                     <p>其次，加载新数据对并发查询的影响最小。与数据加载相关的所有操作都在单独的<code class="codeph">sales_01_2001</code>表上进行。因此，在此数据刷新过程中， <code class="codeph">sales</code>表的任何现有数据或索引都不会受到影响。在整个刷新过程中， <code class="codeph">sales</code>表及其索引完全不受影响。
                     </p>
                     <p>第三，在存在任何全局索引的情况下，这些索引将作为交换命令的一部分逐步维护。此维护不会影响现有全局索引结构的可用性。</p>
                     <p>交换操作可以被视为发布机制。在数据仓库管理员将<code class="codeph">sales_01_2001</code>表交换到<code class="codeph">sales</code>表之前，最终用户无法看到新数据。交换发生后，访问<code class="codeph">sales</code>表的任何最终用户查询都可以立即看到<code class="codeph">sales_01_2001</code>数据。
                     </p>
                     <p>分区不仅可用于添加新数据，还可用于删除和存档数据。许多数据仓库都维护着一个滚动的数据窗口。例如，数据仓库存储最近36个月的<code class="codeph">sales</code>数据。正如可以将新分区添加到<code class="codeph">sales</code>表（如前所述），可以从<code class="codeph">sales</code>表中快速（并独立）删除旧分区。这两个好处（减少资源利用率和最小的最终用户影响）与删除分区和添加分区一样重要。
                     </p>
                     <p>从分区表中删除数据并不一定意味着从数据库中物理删除旧数据。从分区表中删除旧数据有两种方法。首先，您可以通过删除包含旧数据的分区来物理删除数据库中的所有数据，从而释放分配的空间：</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE sales DROP PARTITION sales_01_1998;</pre><p>此外，您可以使用相同结构的空表交换旧分区;创建此空表相当于加载过程中描述的步骤1和2。假设新的空表存根名为<code class="codeph">sales_archive_01_1998</code> ，则以下SQL语句清空分区<code class="codeph">sales_01_1998</code> ：</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE sales EXCHANGE PARTITION sales_01_1998 WITH TABLE sales_archive_01_1998包括没有确认更新全局指数的指数;</pre><p>请注意，旧数据仍然作为已交换的非分区表<code class="codeph">sales_archive_01_1998</code> 。
                     </p>
                     <p>如果分区表的设置方式是每个分区都存储在单独的表空间中，则可以在删除实际数据（表空间）之前使用Oracle数据库的可传输表空间框架归档（或传输）此表。</p>
                     <p>在某些情况下，您可能不希望立即删除旧数据，而是将其保留为分区表的一部分;虽然数据不再是主要关注点，但仍有可能查询访问这些旧的只读数据。您可以使用Oracle的数据压缩来最小化旧数据的空间使用。您还假设至少有一个压缩分区已经是分区表的一部分。</p>
                     <div class="infoboxnotealso" id="GUID-4679957A-71E5-439E-BD8B-A0331F0631F2__GUID-EDDEEB4D-EFEE-4ED0-B5AD-F93F48D94293">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><span class="q">“ <a href="transportation-data-warehouses.html#GUID-B3C1F5D9-21CD-41DB-BEC9-986016E6A5AA">使用可传输表空间的传输</a> ”</span>有关可传输表空间的更多详细信息</p>
                           </li>
                           <li>
                              <p>有关表压缩的详细信息，请参见<a href="../admin/managing-tables.html#ADMIN13948" target="_blank"><span><cite>“Oracle数据库管理员指南”</cite></span></a></p>
                           </li>
                           <li>
                              <p>有关分区和表压缩的详细信息，请<a href="../vldbg/partition-availability.html#VLDBG004" target="_blank"><span><cite>参见“Oracle数据库VLDB和分区指南”</cite></span></a></p>
                           </li>
                        </ul>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div><a id="DWHSG8344"></a><div class="props_rev_3"><a id="GUID-19F3E938-9783-419F-8B70-DABEC4B40FAF" name="GUID-19F3E938-9783-419F-8B70-DABEC4B40FAF"></a><h4 id="DWHSG-GUID-19F3E938-9783-419F-8B70-DABEC4B40FAF" class="sect4"><span class="enumeration_section">7.5.1</span>数据仓库刷新方案</h4>
                  <div>
                     <div class="section">
                        <p>典型情况可能不仅需要压缩旧数据，还需要合并多个旧分区以反映多个合并分区的后续备份的粒度。让我们假设备份（分区）粒度在每季度基于季度基数，其中最早的月份比最近一个月落后36个月。在这种情况下，您将<code class="codeph">sales_01_1998</code> ， <code class="codeph">sales_02_1998</code>和<code class="codeph">sales_03_1998</code>压缩并合并到新的压缩分区<code class="codeph">sales_q1_1998</code> 。
                        </p>
                        <ol>
                           <li>
                              <p>在另一个表空间中并行创建新的合并分区。该分区作为<code class="codeph">MERGE</code>操作的一部分进行压缩：</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE sales MERGE PARTITIONS sales_01_1998，sales_02_1998，sales_03_1998 INTO PARTITION sales_q1_1998 TABLESPACE archive_q1_1998 COMPRESS UPDATE GLOBAL INDEXES PARALLEL 4;</pre></li>
                           <li>
                              <p>分区<code class="codeph">MERGE</code>操作使新合并分区的本地索引无效。因此，您必须重建它们：</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE销售修改分区sales_q1_1998 REBUILD不可用的本地索引;</pre></li>
                        </ol>
                        <p>或者，您可以选择在分区表外部创建新的压缩表并将其交换回来。两种方法的性能和临时空间消耗相同：</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>创建一个中间表以保存新的合并信息。以下语句默认继承原始表中的所有<code class="codeph">NOT</code> <code class="codeph">NULL</code>约束：</span><div><pre class="oac_no_warn" dir="ltr">CREATE TABLE sales_q1_1998_out TABLESPACE archive_q1_1998 NOLOGGING COMPRESS PARALLEL 4 AS SELECT * FROM sales WHERE time_id&gt; = TO_DATE（'01 -JAN-1998'，'dd-mon-yyyy'）AND time_id &lt;TO_DATE（'01 -APR-1998'，' DD-MON-YYYY'）;</pre></div>
                        </li>
                        <li class="stepexpand"><span>为<code class="codeph">sales_q1_1998_out</code>表创建与现有表<code class="codeph">sales</code>相等的索引结构。</span></li>
                        <li class="stepexpand"><span>使用新的压缩表<code class="codeph">sales_q1_1998_out</code>为交换准备现有的表销售。因为要交换的表包含实际覆盖在三个分区中的数据，所以必须创建一个匹配的分区，具有您要查找的范围边界。您只需删除两个现有分区。请注意，您必须删除较低的两个分区<code class="codeph">sales_01_1998</code>和<code class="codeph">sales_02_1998</code> ;范围分区的下边界始终由前一个分区的上（独占）边界定义：</span><div><pre class="oac_no_warn" dir="ltr">ALTER TABLE sales DROP PARTITION sales_01_1998; ALTER TABLE销售DROP PARTITION sales_02_1998;</pre></div>
                        </li>
                        <li class="stepexpand"><span>现在，您可以交换表<code class="codeph">sales_q1_1998_out</code>与分区<code class="codeph">sales_03_1998</code> 。与分区名称所暗示的不同，其边界涵盖Q1-1998。</span><div><pre class="oac_no_warn" dir="ltr">ALTER TABLE sales EXCHANGE PARTITION sales_03_1998 WITH TABLE sales_q1_1998_out包括没有验证更新全局指数的指数;</pre></div>
                        </li>
                     </ol>
                     <div class="section">
                        <p>这两种方法都适用于略有不同的业务场景：使用<code class="codeph">MERGE</code> <code class="codeph">PARTITION</code>方法使受影响分区的本地索引结构无效，但它始终可以访问所有数据。任何通过其中一个不可用的索引结构访问受影响的分区的尝试都会引发错误。有限的可用时间大约是重新创建本地位图索引结构的时间。在大多数情况下，这可以忽略不计，因为不应经常访问分区表的这一部分。
                        </p>
                        <p>但是，CTAS方法最小化了接近零的任何索引结构的不可用性，但是存在特定的时间窗口，其中分区表没有所有数据，因为您丢弃了两个分区。有限的可用时间大约是交换表的时间。根据全局索引的存在和数量，此时间窗口会有所不同。没有任何现有的全局索引，这个时间窗口只需几分钟到几秒钟。</p>
                        <p>这些示例是数据仓库滚动窗口加载方案的简化。实际数据仓库刷新特性总是更复杂。但是，在更复杂的情况下，这种滚动窗口方法的优点并没有减少。</p>
                        <p>请注意，在首次将单个或多个压缩分区添加到分区表之前，必须删除所有本地位图索引或将其标记为不可用。添加第一个压缩分区后，对于涉及压缩分区的所有后续操作，不需要执行其他操作。压缩分区如何添加到分区表无关紧要。</p>
                        <div class="infoboxnotealso" id="GUID-19F3E938-9783-419F-8B70-DABEC4B40FAF__GUID-67814316-CFFC-431B-82C7-B21AA7E11768">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>有关分区和表压缩的详细信息，请<a href="../vldbg/partition-availability.html#VLDBG004" target="_blank"><span class="italic">参见“Oracle数据库VLDB和分区指南”</span></a></p>
                              </li>
                              <li>
                                 <p>有关分区和表压缩的更多详细信息，请参见<a href="../admin/managing-tables.html#ADMIN13948" target="_blank"><span class="italic">“Oracle数据库管理员指南”</span></a> 。
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="DWHSG8345"></a><div class="props_rev_3"><a id="GUID-3D827265-D3BD-4BE4-BD5B-A2943AB5C0C7" name="GUID-3D827265-D3BD-4BE4-BD5B-A2943AB5C0C7"></a><h4 id="DWHSG-GUID-3D827265-D3BD-4BE4-BD5B-A2943AB5C0C7" class="sect4"><span class="enumeration_section">7.5.2</span>使用分区刷新数据仓库的方案</h4>
                  <div>
                     <p>本节介绍以下两种典型方案，其中分区与刷新一起使用：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="refreshing-materialized-views.html#GUID-5B57F621-2E5B-4B32-9B04-77FEAAB4F9BB">刷新数据仓库的分区：场景1</a></p>
                        </li>
                        <li>
                           <p><a href="refreshing-materialized-views.html#GUID-16210EF4-406E-4DC9-BC97-60D02F5BD5F4">刷新数据仓库的分区：场景2</a></p>
                        </li>
                     </ul>
                  </div><a id="DWHSG8346"></a><div class="props_rev_3"><a id="GUID-5B57F621-2E5B-4B32-9B04-77FEAAB4F9BB" name="GUID-5B57F621-2E5B-4B32-9B04-77FEAAB4F9BB"></a><h5 id="DWHSG-GUID-5B57F621-2E5B-4B32-9B04-77FEAAB4F9BB" class="sect5"><span class="enumeration_section">7.5.2.1</span>刷新数据仓库的分区：场景1</h5>
                     <div>
                        <div class="section">
                           <p>数据每天加载。但是，数据仓库包含两年的数据，因此可能不希望按日分区。</p>
                           <p>解决方案是按周或月（视情况而定）进行分区。使用<code class="codeph">INSERT</code>将新数据添加到现有分区。<code class="codeph">INSERT</code>操作仅影响单个分区，因此前面描述的优点保持不变。当分区仍然是表的一部分时，可能会发生<code class="codeph">INSERT</code>操作。插入单个分区可以并行化：</p><pre class="oac_no_warn" dir="ltr">INSERT / * + APPEND * / INTO sales PARTITION（sales_01_2001）SELECT * FROM new_sales;</pre><p>此<code class="codeph">sales</code>分区的索引也是并行维护的。另一种方法是使用<code class="codeph">EXCHANGE</code>操作。您可以通过交换<code class="codeph">sales</code>表的<code class="codeph">sales_01_2001</code>分区然后使用<code class="codeph">INSERT</code>操作来完成此操作。在删除和重建索引比维护索引更有效时，您可能更喜欢这种技术。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="DWHSG8347"></a><div class="props_rev_3"><a id="GUID-16210EF4-406E-4DC9-BC97-60D02F5BD5F4" name="GUID-16210EF4-406E-4DC9-BC97-60D02F5BD5F4"></a><h5 id="DWHSG-GUID-16210EF4-406E-4DC9-BC97-60D02F5BD5F4" class="sect5"><span class="enumeration_section">7.5.2.2</span>刷新数据仓库的分区：场景2</h5>
                     <div>
                        <div class="section">
                           <p>新数据源虽然主要包含最近一天，一周和一个月的数据，但也包含以前时间段的一些数据。</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-16210EF4-406E-4DC9-BC97-60D02F5BD5F4__GUID-B721299A-E260-4C9D-9256-6E91703E8456">解决方案1</p>
                           <p>使用并行SQL操作（例如<code class="codeph">CREATE</code> <code class="codeph">TABLE</code> ...<code class="codeph">AS</code> <code class="codeph">SELECT</code> ）将新数据与先前时间段内的数据分开。使用其他技术分别处理旧数据。
                           </p>
                           <p>新数据源不仅仅是基于时间的。您还可以根据业务需求，使用来自多个操作系统的数据将新数据提供到数据仓库中。例如，来自直接渠道的销售数据可能与来自间接渠道的数据分开进入数据仓库。出于商业原因，将直接和间接数据保存在单独的分区中可能更有意义。</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-16210EF4-406E-4DC9-BC97-60D02F5BD5F4__GUID-212BD8A4-C900-4850-AE24-4C9CF4667FAF">解决方案2</p>
                           <p>Oracle支持复合范围列表分区。sales表的主分区策略可以是基于<code class="codeph">time_id</code>范围分区，如示例所示。但是，子分区是基于channel属性的列表。现在，每个子分区可以彼此独立地加载（对于每个不同的通道），并且如前所述在滚动窗口操作中添加。分区策略以最佳方式满足业务需求。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div>
            </div><a id="DWHSG03002"></a><div class="props_rev_3"><a id="GUID-2F0765F5-DDDA-4667-9629-6834A805CB13" name="GUID-2F0765F5-DDDA-4667-9629-6834A805CB13"></a><h3 id="DWHSG-GUID-2F0765F5-DDDA-4667-9629-6834A805CB13" class="sect3"><span class="enumeration_section">7.6</span>在刷新期间优化DML操作</h3>
               <div>
                  <p>您可以通过以下技术优化DML性能：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="refreshing-materialized-views.html#GUID-BAD960EE-66F2-43C2-9705-248B8D721B4E">实施高效的MERGE操作</a></p>
                     </li>
                     <li>
                        <p><a href="refreshing-materialized-views.html#GUID-2ABAAD60-8354-4302-9D7E-CB802001105E">维护数据仓库中的参照完整性</a></p>
                     </li>
                     <li>
                        <p><a href="refreshing-materialized-views.html#GUID-599B0FB2-2053-43BF-9887-CA0A96F2FBF9">清除数据仓库中的数据</a></p>
                     </li>
                  </ul>
               </div><a id="DWHSG8351"></a><a id="DWHSG8352"></a><a id="DWHSG8353"></a><a id="DWHSG8354"></a><a id="DWHSG8355"></a><a id="DWHSG8356"></a><a id="DWHSG8357"></a><a id="DWHSG8350"></a><div class="props_rev_3"><a id="GUID-BAD960EE-66F2-43C2-9705-248B8D721B4E" name="GUID-BAD960EE-66F2-43C2-9705-248B8D721B4E"></a><h4 id="DWHSG-GUID-BAD960EE-66F2-43C2-9705-248B8D721B4E" class="sect4"><span class="enumeration_section">7.6.1</span>实现高效的MERGE操作</h4>
                  <div>
                     <div class="section">
                        <p><a id="d29043e4045" class="indexterm-anchor"></a>通常，从源系统提取的数据不仅仅是需要插入数据仓库的新记录列表。相反，这个新数据集是新记录和修改记录的组合。例如，假设从OLTP系统提取的大多数数据都是新的销售交易。这些记录被插入到仓库的<code class="codeph">sales</code>表中，但是一些记录可能反映了先前交易的修改，例如退回的商品或最初加载到数据仓库时不完整或不正确的交易。这些记录需要更新<code class="codeph">sales</code>表。
                        </p>
                        <p>作为典型场景，假设有一个名为<code class="codeph">new_sales</code>的表，其中包含应用于<code class="codeph">sales</code>表的插入和更新。在设计整个数据仓库加载过程时，确定<code class="codeph">new_sales</code>表将包含具有以下语义的记录：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p>如果给定<code class="codeph">sales_transaction_id</code>在创纪录的<code class="codeph">new_sales</code>在已经存在<code class="codeph">sales</code> ，然后更新<code class="codeph">sales</code>通过添加表<code class="codeph">sales_dollar_amount</code>和<code class="codeph">sales_quantity_sold</code>从值<code class="codeph">new_sales</code>表中现有行<code class="codeph">sales</code>表。
                              </p>
                           </li>
                           <li>
                              <p>否则，将<code class="codeph">new_sales</code>表中的整个新记录插入<code class="codeph">sales</code>表。
                              </p>
                           </li>
                        </ul>
                        <p>此<code class="codeph">UPDATE-ELSE-INSERT</code>操作通常称为合并。可以使用一个SQL语句执行合并。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-BAD960EE-66F2-43C2-9705-248B8D721B4E__GUID-877052F7-6E9A-4884-8180-B57CA21B40BA">
                        <p class="titleinexample">例7-8 MERGE操作</p><pre class="oac_no_warn" dir="ltr">MERGE INTO sales s USING new_sales n ON（s.sales_transaction_id = n.sales_transaction_id）匹配时更新设置s.sales_quantity_sold = s.sales_quantity_sold + n.sales_quantity_sold，s.sales_dollar_amount = s.sales_dollar_amount + n.sales_dollar_amount什么时候不匹配然后插入（sales_transaction_id，sales_quantity_sold，sales_dollar_amount）VALUES（n.sales_transcation_id，n.sales_quantity_sold，n.sales_dollar_amount）;</pre><p>除了将<code class="codeph">MERGE</code>语句用于无条件<code class="codeph">UPDATE</code> <code class="codeph">ELSE</code> <code class="codeph">INSERT</code>功能到目标表之外，您还可以使用它来：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>仅执行<code class="codeph">UPDATE</code>或仅执行<code class="codeph">INSERT</code>语句。
                              </p>
                           </li>
                           <li>
                              <p>为<code class="codeph">MERGE</code>语句的<code class="codeph">UPDATE</code>或<code class="codeph">INSERT</code>部分应用其他<code class="codeph">WHERE</code>条件。
                              </p>
                           </li>
                           <li>
                              <p>如果特定条件产生true，则<code class="codeph">UPDATE</code>操作甚至可以删除行。
                              </p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-BAD960EE-66F2-43C2-9705-248B8D721B4E__GUID-48F4E58F-DE47-4522-A994-6E9F5E8C33A0">
                        <p class="titleinexample">例7-9省略INSERT子句</p>
                        <p>在某些数据仓库应用程序中，不允许向历史信息添加新行，而只是更新它们。您可能还希望更新但只插入新信息。以下示例演示了<code class="codeph">INSERT</code> -only和<code class="codeph">UPDATE</code> -only功能：</p><pre class="oac_no_warn" dir="ltr">合并使用Product_Changes S  - 源/ Delta表INTO产品D1  - 目标表1 ON（D1。PROD_ID = S.PROD_ID） - 匹配然后更新的搜索/加入条件 - 如果加入SET D1则更新。PROD_STATUS = S.PROD_NEW_STATUS</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-BAD960EE-66F2-43C2-9705-248B8D721B4E__GUID-EF74A6A4-74DB-4337-B784-E84B3797DE4B">
                        <p class="titleinexample">例7-10省略UPDATE子句</p>
                        <p>以下语句说明了省略<code class="codeph">UPDATE</code>的示例：</p><pre class="oac_no_warn" dir="ltr">合并使用New_Product S  - 源/ Delta表INTO产品D2  - 目标表2 ON（D2。PROD_ID = S.PROD_ID） - 搜索/加入条件当没有匹配时 - 如果没有加入则插入INSERT（PROD_ID，PROD_STATUS）值（S.PROD_ID，S.PROD_NEW_STATUS）</pre><p>省略<code class="codeph">INSERT</code>子句时，Oracle数据库会执行源表和目标表的常规连接。省略<code class="codeph">UPDATE</code>子句时，Oracle数据库会执行源表和目标表的反连接。这使得源表和目标表之间的连接更有效。
                        </p>
                     </div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-BAD960EE-66F2-43C2-9705-248B8D721B4E__GUID-AD1164D9-1C1B-4714-9140-F00656530AEF">
                        <p class="titleinexample">例7-11跳过UPDATE子句</p>
                        <p>在某些情况下，您可能希望在将给定行合并到表中时跳过<code class="codeph">UPDATE</code>操作。在这种情况下，您可以在<code class="codeph">MERGE</code>的<code class="codeph">UPDATE</code>子句中使用可选的<code class="codeph">WHERE</code>子句。因此， <code class="codeph">UPDATE</code>操作仅在给定条件为真时执行。以下语句说明了跳过<code class="codeph">UPDATE</code>操作的示例：</p><pre class="oac_no_warn" dir="ltr">合并使用Product_Changes S  - 源/ Delta表INTO产品P  - 目标表1 ON（P.PROD_ID = S.PROD_ID） - 搜索/加入条件匹配然后更新 - 如果加入SET P.PROD_LIST_PRICE = S则更新PROD_NEW_PRICE WHERE P.PROD_STATUS &lt;&gt;“OBSOLETE” - 条件更新</pre><p>这显示了如果条件<code class="codeph">P.PROD_STATUS &lt;&gt; "OBSOLETE"</code>不为真，将如何跳过<code class="codeph">UPDATE</code>操作。条件谓词可以指向目标表和源表。
                        </p>
                     </div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-BAD960EE-66F2-43C2-9705-248B8D721B4E__GUID-5D5F8EC6-E080-41AB-BD5A-F22FCFDFCA80">
                        <p class="titleinexample">示例7-12带有MERGE语句的条件插入</p>
                        <p>将给定行合并到表中时，可能需要跳过<code class="codeph">INSERT</code>操作。因此，可选的<code class="codeph">WHERE</code>子句被添加到<code class="codeph">MERGE</code>的<code class="codeph">INSERT</code>子句中。因此， <code class="codeph">INSERT</code>操作仅在给定条件为真时执行。以下语句提供了一个示例：</p><pre class="oac_no_warn" dir="ltr">合并使用Product_Changes S  - 源/ Delta表INTO产品P  - 目标表1 ON（P.PROD_ID = S.PROD_ID） - 搜索/加入条件匹配然后更新 - 如果加入SET P.PROD_LIST_PRICE = S则更新PROD_NEW_PRICE WHERE P.PROD_STATUS &lt;&gt;“OBSOLETE” - 条件何时不匹配，然后插入（PROD_ID，PROD_STATUS，PROD_LIST_PRICE） - 如果不加入VALUES则插入（S.PROD_ID，S.PROD_NEW_STATUS，S.PROD_NEW_PRICE）WHERE S.PROD_STATUS &lt; &gt;“OBSOLETE”; - 条件INSERT</pre><p>此示例显示如果条件<code class="codeph">S.PROD_STATUS &lt;&gt; "OBSOLETE"</code>不为真，则将跳过<code class="codeph">INSERT</code>操作，并且仅在条件为真时才会发生<code class="codeph">INSERT</code> 。条件谓词只能引用源表。条件谓词只能引用源表。
                        </p>
                     </div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-BAD960EE-66F2-43C2-9705-248B8D721B4E__GUID-E1672702-D63D-4C6F-93BE-BD73C531371D">
                        <p class="titleinexample">示例7-13将DELETE子句与MERGE语句一起使用</p>
                        <p>您可能希望在填充或更新表时清理表。为此，您可能需要考虑在<code class="codeph">MERGE</code>语句中使用<code class="codeph">DELETE</code>子句，如下例所示：</p><pre class="oac_no_warn" dir="ltr">合并使用Product_Changes S INTO产品D ON（D.PROD_ID = S.PROD_ID）匹配时更新设置D.PROD_LIST_PRICE = S.PROD_NEW_PRICE，D.PROD_STATUS = S.PROD_NEWSTATUS DELETE WHERE（D.PROD_STATUS =“OBSOLETE”）然后匹配INSERT（PROD_ID，PROD_LIST_PRICE，PROD_STATUS）值（S.PROD_ID，S.PROD_NEW_PRICE，S.PROD_NEW_STATUS）;</pre><p>因此，当在<code class="codeph">products</code>更新行时，Oracle会检查删除条件<code class="codeph">D.PROD_STATUS = "OBSOLETE"</code> ，如果条件为true，则删除该行。
                        </p>
                        <p><code class="codeph">DELETE</code>操作与完整<code class="codeph">DELETE</code>语句的操作不同。只能删除<code class="codeph">MERGE</code>目标中的行。受<code class="codeph">DELETE</code>影响的唯一行是由此<code class="codeph">MERGE</code>语句更新的行。因此，尽管目标表的给定行满足删除条件，但如果它不在<code class="codeph">ON</code>子句条件下连接，则不会删除它。
                        </p>
                     </div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-BAD960EE-66F2-43C2-9705-248B8D721B4E__GUID-22086C31-067A-4352-B21B-B28B55F628CC">
                        <p class="titleinexample">示例7-14带有MERGE语句的无条件插入</p>
                        <p>您可能希望将所有源行插入表中。在这种情况下，可以避免源表和目标表之间的连接。通过识别始终导致<code class="codeph">FALSE</code>特殊常量连接条件（例如，1 = 0），优化此类<code class="codeph">MERGE</code>语句并抑制连接条件。
                        </p><pre class="oac_no_warn" dir="ltr">合并使用New_Product S  - 源/ Delta表INTO产品P  - 目标表1 ON（1 = 0） - 搜索/加入条件当不匹配时 - 如果没有加入则插入INSERT（PROD_ID，PROD_STATUS）VALUES（S PROD_ID，S.PROD_NEW_STATUS）</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="DWHSG8358"></a><div class="props_rev_3"><a id="GUID-2ABAAD60-8354-4302-9D7E-CB802001105E" name="GUID-2ABAAD60-8354-4302-9D7E-CB802001105E"></a><h4 id="DWHSG-GUID-2ABAAD60-8354-4302-9D7E-CB802001105E" class="sect4"><span class="enumeration_section">7.6.2</span>维护数据仓库中的参照完整性</h4>
                  <div>
                     <div class="section">
                        <p>在某些数据仓库环境中，您可能希望将新数据插入表中以保证参照完整性。例如，数据仓库可以从直接从收银机检索数据的操作系统获得<code class="codeph">sales</code> 。 <code class="codeph">sales</code>每晚都在刷新。但是， <code class="codeph">product</code>维度表的数据可以从单独的操作系统导出。<code class="codeph">product</code>维度表每周只能刷新一次，因为<code class="codeph">product</code>表的变化相对较慢。如果星期一引入了新产品，那么在将<code class="codeph">product_id</code>插入数据仓库<code class="codeph">product</code>表之前，该产品的<code class="codeph">product_id</code>可能会出现在数据仓库的<code class="codeph">sales</code>数据中。
                        </p>
                        <p>虽然新产品的销售交易可能有效，但此销售数据不满足<code class="codeph">product</code>维度表和<code class="codeph">sales</code>事实表之间的参照完整性约束。您可以选择将销售交易插入到<code class="codeph">sales</code>表中，而不是禁止新的销售交易。但是，您可能还希望维护<code class="codeph">sales</code>表和<code class="codeph">product</code>表之间的参照完整性关系。这可以通过在<code class="codeph">product</code>表中插入新行作为未知产品的占位符来实现。
                        </p>
                        <p>与前面的示例一样，假设<code class="codeph">sales</code>表的新数据在单独的表<code class="codeph">new_sales</code> 。使用单个<code class="codeph">INSERT</code>语句（可以并行化），可以更改<code class="codeph">product</code>表以反映新产品：</p><pre class="oac_no_warn" dir="ltr">INSERT INTO产品（SELECT sales_product_id，'Unknown Product Name'，NULL，NULL ...FROM new_sales WHERE sales_product_id NOT IN（SELECT product_id FROM product））;</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="DWHSG8359"></a><div class="props_rev_3"><a id="GUID-599B0FB2-2053-43BF-9887-CA0A96F2FBF9" name="GUID-599B0FB2-2053-43BF-9887-CA0A96F2FBF9"></a><h4 id="DWHSG-GUID-599B0FB2-2053-43BF-9887-CA0A96F2FBF9" class="sect4"><span class="enumeration_section">7.6.3</span>从数据仓库中清除数据</h4>
                  <div>
                     <div class="section">
                        <p><a id="d29043e4423" class="indexterm-anchor"></a><a id="d29043e4425" class="indexterm-anchor"></a>偶尔，这是必要的<a id="d29043e4430" class="indexterm-anchor"></a>从数据仓库中删除大量数据。一个非常常见的情况是前面讨论过的滚动窗口，其中旧数据从数据仓库中推出，以便为新数据腾出空间。
                        </p>
                        <p>但是，有时可能需要从数据仓库中删除其他数据。假设零售公司之前已经销售过<code class="codeph">XYZ</code> <code class="codeph">Software</code>产品，并且<code class="codeph">XYZ</code> <code class="codeph">Software</code>随后停业。仓库的业务用户可能会决定他们不再有兴趣查看与<code class="codeph">XYZ</code> <code class="codeph">Software</code>相关的任何数据，因此应删除此数据。
                        </p>
                        <p>删除大量数据的一种方法是使用并行删除，如以下语句所示：</p><pre class="oac_no_warn" dir="ltr">DELETE FROM sales WHERE sales_product_id IN（SELECT product_id FROM product WHERE product_category ='XYZ Software'）;</pre><p>此SQL语句为每个分区生成一个并行进程。这种方法比一系列<code class="codeph">DELETE</code>语句更有效，并且不需要移动<code class="codeph">sales</code>表中的任何数据。但是，这种方法也有一些缺点。删除大部分行时， <code class="codeph">DELETE</code>语句会在现有分区中留下许多空行槽。如果使用滚动窗口技术加载新数据（或使用直接路径<code class="codeph">INSERT</code>或加载加载），则不回收此存储空间。而且，即使<code class="codeph">DELETE</code>语句是并行化的，也可能有更有效的方法。另一种方法是重新创建整个<code class="codeph">sales</code>表，保留除<code class="codeph">XYZ</code> <code class="codeph">Software</code>之外的所有产品类别的数据。
                        </p><pre class="oac_no_warn" dir="ltr">CREATE TABLE sales2 AS SELECT * FROM sales，product WHERE sales.sales_product_id = product.product_id AND product_category &lt;&gt;'XYZ Software'NOLOGGING PARALLEL（DEGREE 8）#PARTITION ...; #create索引，约束等DROP TABLE SALES;重新销售SALES2销售;</pre><p>这种方法可能比并行删除更有效。但是，就磁盘空间量而言，它也是昂贵的，因为<code class="codeph">sales</code>表必须有效地实例化两次。
                        </p>
                        <p>使用更少空间的另一种方法是一次重新创建一个分区的<code class="codeph">sales</code>表：</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE sales_temp AS SELECT * FROM sales WHERE 1 = 0; INSERT INTO sales_temp SELECT * FROM sales PARTITION（sales_99jan），product WHERE sales.sales_product_id = product.product_id AND product_category &lt;&gt;'XYZ Software'; &lt;在sales_temp上创建适当的索引和约束&gt; ALTER TABLE sales EXCHANGE PARTITION sales_99jan WITH TABLE sales_temp;</pre><p>对<code class="codeph">sales</code>表中的每个分区继续此过程。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>